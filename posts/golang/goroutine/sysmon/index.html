<!DOCTYPE html>
<html lang="zh" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>sysmon 监控线程 | Helium</title>
<meta name="keywords" content="golang, Golang">
<meta name="description" content="💥本文章所有相关go代码参考自go 1.18&#43;版本">
<meta name="author" content="helium">
<link rel="canonical" href="https://heliu.site/posts/golang/goroutine/sysmon/">
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<meta name="referrer" content="no-referrer-when-downgrade">
<link crossorigin="anonymous" href="/assets/css/stylesheet.css" rel="preload stylesheet" as="style">
<link rel="icon" href="https://heliu.site/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://heliu.site/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://heliu.site/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://heliu.site/apple-touch-icon.png">
<link rel="mask-icon" href="https://heliu.site/apple-touch-icon.png">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="zh" href="https://heliu.site/posts/golang/goroutine/sysmon/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
<html>
<head>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/jetbrains-mono@1.0.6/css/jetbrains-mono-nl.min.css" />
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lxgw-wenkai-lite-webfont@1.1.0/style.css" />
    <link rel="stylesheet" href="https://cdn.staticfile.org/lxgw-wenkai-screen-webfont/1.6.0/style.css" />
    <style>
        body {
            font-family: "LXGW WenKai Lite", sans-serif;
            font-family: "LXGW WenKai Screen", sans-serif;
        }
    </style>
</head>
</html>

  

<meta property="og:title" content="sysmon 监控线程" />
<meta property="og:description" content="💥本文章所有相关go代码参考自go 1.18&#43;版本" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://heliu.site/posts/golang/goroutine/sysmon/" />
<meta property="og:image" content="https://heliu.site/favicon-32x32.png" />
<meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-07-30T00:00:00+00:00" />
<meta property="article:modified_time" content="2024-07-30T00:00:00+00:00" /><meta property="og:site_name" content="Helium" />

<meta name="twitter:card" content="summary_large_image" />
<meta name="twitter:image" content="https://heliu.site/favicon-32x32.png" />
<meta name="twitter:title" content="sysmon 监控线程"/>
<meta name="twitter:description" content="💥本文章所有相关go代码参考自go 1.18&#43;版本"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Article",
      "item": "https://heliu.site/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Golang",
      "item": "https://heliu.site/posts/golang/"
    }, 
    {
      "@type": "ListItem",
      "position":  3 ,
      "name": "第12章 Goroutine",
      "item": "https://heliu.site/posts/golang/goroutine/"
    }, 
    {
      "@type": "ListItem",
      "position":  4 ,
      "name": "sysmon 监控线程",
      "item": "https://heliu.site/posts/golang/goroutine/sysmon/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "sysmon 监控线程",
  "name": "sysmon 监控线程",
  "description": "💥本文章所有相关go代码参考自go 1.18+版本",
  "keywords": [
    "golang", "Golang"
  ],
  "articleBody": "runtime.main 监控线程在runtime.main中被创建。 func main() { // ... if GOARCH != \"wasm\" { // no threads on wasm yet, so no sysmon // systemstack()函数切换到g0栈去运行闭包函数 systemstack(func() { // newm新创建一个线程，从sysmon入口函数开始执行 newm(sysmon, nil, -1) // 监控线程sysmon不需要P就能运行 }) } // ... } variables // forcegcperiod is the maximum time in nanoseconds between garbage // collections. If we go this long without a garbage collection, one // is forced to run. // // This is a variable for testing purposes. It normally doesn't change. // // forceegcperiod是两次垃圾回收之间的最大时间，单位为纳秒。 // 如果这么长时间都没有垃圾收集，那么垃圾收集将被迫运行。 // 这是一个用于测试的变量。它通常不会改变。 var forcegcperiod int64 = 2 * 60 * 1e9 // 2min sysmon() 前面创建监控线程可以看出，监控线程是没有绑定P的。 这个监控线程是一个独立的线程，无需P即可运行，sysmon每20us ~ 10ms运行一次。 timer在每次调度器调度和窃取其他g的时候触发，这种具有一定的随机性和不确定性，系统监控线程触发依然是一个兜底保障。 监控线程主要职责： 最长10ms间隔执行一次网络轮询（保证I/O轮询）。因为netpoll是随机的，不是定时间段的。 抢占超过时间片的G。 超过预定时间，发起一轮GC。 总是在没有P的情况下运行，因此不允许写屏障。 文件位置：go1.19.3/src/runtime/proc.go。 5131 5132 5133 5134 5135 5136 5137 5138 5139 5140 5141 5142 5143 5144 5145 5146 5147 5148 5149 5150 5151 5152 5153 5154 5155 5156 5157 5158 5159 5160 5161 5162 5163 5164 5165 5166 5167 5168 5169 5170 5171 5172 5173 5174 5175 5176 5177 5178 5179 5180 5181 5182 5183 5184 5185 5186 5187 5188 5189 5190 5191 5192 5193 5194 5195 5196 5197 5198 5199 5200 5201 5202 5203 5204 5205 5206 5207 5208 5209 5210 5211 5212 5213 5214 5215 5216 5217 5218 5219 5220 5221 5222 5223 5224 5225 5226 5227 5228 5229 5230 5231 5232 5233 5234 5235 5236 5237 5238 5239 5240 5241 5242 5243 5244 5245 5246 5247 5248 5249 5250 5251 5252 5253 5254 5255 5256 5257 5258 5259 5260 5261 5262 5263 5264 5265 5266 5267 5268 5269 5270 5271 5272 5273 5274 5275 5276 5277 5278 5279 5280 5281 5282 5283 5284 5285 5286 5287 5288 5289 5290 5291 5292 5293 5294 5295 5296 5297 5298 5299 5300 5301 5302 5303 5304 5305 5306 5307 5308 5309 5310 5311 5312 5313 5314 5315 5316 5317 5318 5319 5320 5321 5322 5323 5324 5325 5326 5327 5328 5329 5330 5331 5332 5333 5334 5335 5336 5337 5338 5339 5340 5341 5342 5343 5344 5345 5346 5347 5348 5349 5350 5351 5352 5353 5354 5355 5356 5357 5358 5359 5360 5361 5362 5363 5364 5365 5366 5367 5368 5369 5370 5371 5372 5373 5374 5375 5376 5377 5378 5379 // Always runs without a P, so write barriers are not allowed. // //go:nowritebarrierrec func sysmon() { lock(\u0026sched.lock) sched.nmsys++ // 系统M数量 checkdead() // 检查死锁 unlock(\u0026sched.lock) lasttrace := int64(0) // 最后跟踪时间 // idle：在以下两种情况下才会重置为0 // 1. 有陷入系统调度的P需要被抢占时。 // 2. sysmon从深度睡眠中醒来时。 // 进入深度睡眠在这两种条件下： // 1. STW期间，sysmon可以进入深度睡眠。 // 2. 在所有P都空闲时(可能都陷入系统调用)。 // 其他情况idle会累加，因此sysmon的调度间隔会趋向于10ms。这一个goroutine运行的时间片时间值。 idle := 0 // how many cycles in succession we had not wokeup somebody // 下次sysmon运行的时间间隔，微秒。根据idle计算而来。 delay := uint32(0) for { // 1) 计算下次运行时间间隔 // 1. 默认20us。(20微秒)。 // 2. 连续50个周期无事可做则翻倍时间，后面依次翻倍。 // 3. 最高10ms。(10毫秒)。 if idle == 0 { // start with 20us sleep... delay = 20 } else if idle \u003e 50 { // start doubling the sleep after 1ms... delay *= 2\t} if delay \u003e 10*1000 { // up to 10ms delay = 10 * 1000\t} // 系统调用sleep delay微秒 usleep(delay) // sysmon should not enter deep sleep if schedtrace is enabled so that // it can print that information at the right time. // // It should also not enter deep sleep if there are any active P's so // that it can retake P's from syscalls, preempt long running G's, and // poll the network if all P's are busy for long stretches. // // It should wakeup from deep sleep if any P's become active either due // to exiting a syscall or waking up due to a timer expiring so that it // can resume performing those duties. If it wakes from a syscall it // resets idle and delay as a bet that since it had retaken a P from a // syscall before, it may need to do it again shortly after the // application starts work again. It does not reset idle when waking // from a timer to avoid adding system load to applications that spend // most of their time sleeping. // // 如果启用了 schedtrace，sysmon 不应进入深度睡眠，以便它可以在正确的时间打印该信息 // 如果有任何活动的P，它也不应该进入深度睡眠，以便它可以从系统调用中重新获取P， // 抢占长时间运行的G，并在所有P长时间忙碌时轮询网络 // 如果任何 P 由于退出系统调用或由于计时器到期而唤醒， // 它应该从深度睡眠中唤醒，以便它可以恢复执行这些职责 // 果它从系统调用中唤醒，它会重置空闲和延迟作为赌注，因为它之前已经从系统调用中重新获得了P， // 它可能需要在应用程序再次开始工作后不久再次这样做 // 它不会在从计时器唤醒时重置空闲，以避免将系统负载添加到大部分时间都在休眠的应用程序 now := nanotime() // 当前时间 // 2) 满足以下条件工作线程会进入深度睡眠： // 1. STW正在等待其他P停下来，这段时间sysmon线程可以深度睡眠，在start the world时会唤醒sysmon。 // 2. 全部P都处于空闲，这段时间sysmon线程可以深度睡眠，这可能是处于系统调用中时，系统调用返回时会唤醒sysmon。 if debug.schedtrace \u003c= 0 \u0026\u0026 (sched.gcwaiting != 0 || atomic.Load(\u0026sched.npidle) == uint32(gomaxprocs)) { lock(\u0026sched.lock) // mutex lock // 加锁后，再次判断一次原因是获取锁这段时间可能条件不成立了。 if atomic.Load(\u0026sched.gcwaiting) != 0 || atomic.Load(\u0026sched.npidle) == uint32(gomaxprocs) { syscallWake := false // 系统调用唤醒? // 2.1) 最近一次timer的触发时间点或没有timer时都应该sleep。 // timeSleepUntil函数只会在sysmon和checkdead函数中被调用： // 1. next表示最先触发timer的时间点，timeSleepUntil函数会遍历所有的P取选择最小的timer触发时间点。 // 2. 返回 maxWhen = 1\u003c\u003c63 - 1，表示没有定时器。 next, _ := timeSleepUntil() // 2.2) 还未到触发timer的时间点时或没有timer，这段时间可以sleep。 if next \u003e now {\tatomic.Store(\u0026sched.sysmonwait, 1) // sched.sysmonwait = 1 unlock(\u0026sched.lock)\t// Make wake-up period small enough // for the sampling to be correct. // // 使唤醒周期足够小，以保证取样正确。 // 2.3) 计算睡眠时间间隔最大值1分钟。 sleep := forcegcperiod / 2 // 1min if next-now \u003c sleep { sleep = next - now } // osRelaxMinNS 表示如果下一个计时器从现在开始少于 60 毫秒，则 sysmon 不应该 osRelax // 由于 osRelaxing 可能会将计时器分辨率降低到 15.6 毫秒，这将计时器错误保持在大约 4 分之一以下 // const osRelaxMinNS = 0 shouldRelax := sleep \u003e= osRelaxMinNS if shouldRelax { // osRelax 在与所有空闲的 P 之间转换时由调度程序调用 // 在 linux amd64 下该函数为空 osRelax(true)\t} // 2.4) 在sched.sysmonnote上睡眠sleep纳秒。 // 睡眠 sleep ns 时间，睡眠在 sched.sysmonnote 上。 // 最长情况会睡眠1min，也就是全部P都无事可做时。 // sleep时间后，也就是最新的timer需要触发的时间点，唤醒监控线程。 // 当 STW 正在进行时，这里会把监控线程sleep 1min，在start the world时会唤醒 // 在sched.sysmonnote上的监控线程。 // 当系统调用返回，在runtime_exitsyscall()函数中会响应的唤醒 // 在sched.sysmonnote上的监控线程。 // syscallWake = true。 syscallWake = notetsleep(\u0026sched.sysmonnote, sleep) if shouldRelax { osRelax(false) } lock(\u0026sched.lock) // sched.sysmonwait = 0;sched.sysmonnote.key = 0; atomic.Store(\u0026sched.sysmonwait, 0) noteclear(\u0026sched.sysmonnote) } // 由系统调用醒来或触发timer时间点已经过了，重置计时。 if syscallWake { idle = 0 delay = 20 } } unlock(\u0026sched.lock) } lock(\u0026sched.sysmonlock) // Update now in case we blocked on sysmonnote or spent a long time // blocked on schedlock or sysmonlock above. // // 如果我们在sysmonnote上被阻塞，或者在上面的schedlock或sysmonlock上花了很长时间阻塞，现在更新。 now = nanotime() // trigger libc interceptors if needed if *cgo_yield != nil { asmcgocall(*cgo_yield, nil) } // 3) network poll; 网络轮询。 // 网络轮询的时间间隔设置为10ms。 // poll network if not polled for more than 10ms // // 超过10ms没有进行网络轮询，则进行网络轮询。 // sched.lastpoll：记录的是上次执行netpoll的时间。 // 1. 如果等于0，则表示某个线程正在阻塞式地执行netpoll。 // 2. 大于0，则是上次执行时间点。 lastpoll := int64(atomic.Load64(\u0026sched.lastpoll)) // 以下三种情况不会轮询网络： // 1. 没有初始化 netpoll 时。 // 2. 其他线程阻塞式访问 netpoll 时。 // 3. 上次轮询时间还没到 10ms 时。 // 需要查看network：已初始化 \u0026\u0026 没有其他线程在阻塞调用epoll \u0026\u0026 上次epoll已超过10ms了 if netpollinited() \u0026\u0026 lastpoll != 0 \u0026\u0026 lastpoll+10*1000*1000 \u003c now { // CAS更新 sched.lastpoll 时间。 atomic.Cas64(\u0026sched.lastpoll, uint64(lastpoll), uint64(now)) // 3.1) 轮询 poll。参数0立即返回。 // network poll是否有就绪的事件。 // 传递参数0表示epoll轮询wait等待函数立即返回。 // 非阻塞式轮询，返回就绪的goroutine列表。 list := netpoll(0) // non-blocking - returns list of goroutines // 存在就绪的 goroutine。 if !list.empty() { // Need to decrement number of idle locked M's // (pretending that one more is running) before injectglist. // Otherwise it can lead to the following situation: // injectglist grabs all P's but before it starts M's to run the P's, // another M returns from syscall, finishes running its G, // observes that there is no work to do and no other running M's // and reports deadlock. // // 设置 sched.nmidlelocked += -1 incidlelocked(-1) // 处理准备好的goroutine // 该函数在调度循环函数中有详细注解。 injectglist(\u0026list) incidlelocked(1) } } // 在 linux amd64 下不会触发。 if GOOS == \"netbsd\" \u0026\u0026 needSysmonWorkaround { // netpoll is responsible for waiting for timer // expiration, so we typically don't have to worry // about starting an M to service timers. (Note that // sleep for timeSleepUntil above simply ensures sysmon // starts running again when that timer expiration may // cause Go code to run again). // // However, netbsd has a kernel bug that sometimes // misses netpollBreak wake-ups, which can lead to // unbounded delays servicing timers. If we detect this // overrun, then startm to get something to handle the // timer. // // See issue 42515 and // https://gnats.netbsd.org/cgi-bin/query-pr-single.pl?number=50094. if next, _ := timeSleepUntil(); next \u003c now { startm(nil, false) } } if atomic.Load(\u0026scavenge.sysmonWake) != 0 { // Kick the scavenger awake if someone requested it. wakeScavenger() } // 4) 检查所有的P查看是否存在运行时间太长的G需要设置抢占请求。 // 1. goroutine运行时间超过10ms时需要抢占。 // 2. goroutine陷入系统调用，运行时间超过10ms或在第二轮来是sysmon系统调用还没返回时。 // 陷入系统调用而抢占P的情况： // 1. 运行时间超过10ms，可能一开始就陷入系统调用，或中途陷入系统调用。不论那种情况都应该抢占。 // 2. 运行时间没到10ms，但是两轮sysmon了还是在系统调用中，需要抢占P。这时候时间间隔在(0, 20ms)这个范围。 // retake P's blocked in syscalls // and preempt long running G's // // 重新获取在系统调用中阻塞的 P 并抢占长时间运行的 G // retake函数返回值，陷入系统调用的需要抢占的P的数量。 if retake(now) != 0 { // 为什么陷入系统调度的P需要重置监控频率？ // 原因是陷入系统调度的P，把时间调回20us，下轮监控线程来时判断是否还在系统调用中。 idle = 0 } else { idle++ } // 5) GC相关，定时检查GC是否该触发了 // check if we need to force a GC // t.test()：判断是否满足定时GC间隔2分钟的条件 // forcegc.idle.Load()：当前定时GC是空闲的 if t := (gcTrigger{kind: gcTriggerTime, now: now}); t.test() \u0026\u0026 atomic.Load(\u0026forcegc.idle) != 0 { lock(\u0026forcegc.lock) // 获取互斥锁 forcegc.idle = 0 // 标记本轮定时GC开始了 var list gList // goroutine的列表，最后会把里面的goroutine放入P的本地队列 list.push(forcegc.g)// forcegchelper goroutine 加入本地队列，去触发goroutine injectglist(\u0026list) // list 加入P的本地队列等待M调用，等待forcegchelper()函数继续运行吧 unlock(\u0026forcegc.lock)// 解锁 } if debug.schedtrace \u003e 0 \u0026\u0026 lasttrace+int64(debug.schedtrace)*1000000 \u003c= now { lasttrace = now schedtrace(debug.scheddetail \u003e 0) } unlock(\u0026sched.sysmonlock) } } ",
  "wordCount" : "1397",
  "inLanguage": "zh",
  "image": "https://heliu.site/favicon-32x32.png","datePublished": "2024-07-30T00:00:00Z",
  "dateModified": "2024-07-30T00:00:00Z",
  "author":[{
    "@type": "Person",
    "name": "helium"
  }],
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://heliu.site/posts/golang/goroutine/sysmon/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Helium",
    "logo": {
      "@type": "ImageObject",
      "url": "https://heliu.site/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://heliu.site/" accesskey="h" title="Blog (Alt + H)">
                <img src="https://heliu.site/helium.png" alt="" aria-label="logo"
                    height="35">Blog</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://heliu.site/" title="主页">
                    <span>Home</span>
                </a>
            </li>
            <li>
                <a href="https://heliu.site/posts" title="文章">
                    <span>Article</span>
                </a>
            </li>
            <li>
                <a href="https://heliu.site/archives" title="时间轴">
                    <span>Archive</span>
                </a>
            </li>
            <li>
                <a href="https://heliu.site/tags/" title="标签">
                    <span>Tag</span>
                </a>
            </li>
            <li>
                <a href="https://heliu.site/search/" title="搜索 (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
            <li>
                <a href="https://heliu.site/support" title="打赏">
                    <span>🫶Help</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">


<article class="post" autonumbering>
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://heliu.site/">主页</a>&nbsp;»&nbsp;<a href="https://heliu.site/posts/">Article</a>&nbsp;»&nbsp;<a href="https://heliu.site/posts/golang/">Golang</a>&nbsp;»&nbsp;<a href="https://heliu.site/posts/golang/goroutine/">第12章 Goroutine</a></div>
    <h1 class="post-title entry-hint-parent">
      sysmon 监控线程
    </h1>
    <div class="post-description">
      💥本文章所有相关go代码参考自go 1.18&#43;版本
    </div>
    <div class="post-meta">










<span class="x-post-meta-item"><svg t="1720837714681" class="icon" viewBox="0 0 1084 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="7520" width="200" height="200"><path d="M123.47509 1023.984942a123.565437 123.565437 0 0 1-123.505206-123.32451V243.863302A123.565437 123.565437 0 0 1 123.47509 120.568908h171.630374V26.06529a26.050232 26.050232 0 0 1 52.070349 0v94.503618h377.592848V26.06529a26.050232 26.050232 0 0 1 52.100464 0v94.503618h183.797189A123.565437 123.565437 0 0 1 1084.171519 243.863302v656.79713A123.565437 123.565437 0 0 1 960.666314 1023.984942H123.47509z m-71.404741-123.32451A71.434857 71.434857 0 0 0 123.47509 971.974825h837.191224a71.434857 71.434857 0 0 0 71.404741-71.314393V442.326922l-946.361273-3.824716a25.598494 25.598494 0 0 1-5.84248-0.692665l-27.796953-6.444798v469.295689zM123.47509 172.579025a71.434857 71.434857 0 0 0-71.404741 71.284277v149.736133l27.796953-6.444797a26.080348 26.080348 0 0 1 5.902712-0.662549l946.301041 3.824716V243.863302a71.404741 71.404741 0 0 0-71.404741-71.284277h-180.183284l-6.173754 12.859479a26.200812 26.200812 0 0 1-23.490383 14.786895 26.261043 26.261043 0 0 1-23.520499-14.786895l-6.173754-12.859479H350.819834l-6.173754 12.859479a26.200812 26.200812 0 0 1-23.490383 14.786895 26.230928 26.230928 0 0 1-23.520499-14.786895l-6.173755-12.859479H123.47509z m156.150814 578.827128a26.050232 26.050232 0 0 1-26.050232-25.990001c0-14.335157 11.68496-26.020116 26.050232-26.020116h521.697312c14.365273 0 26.050232 11.68496 26.050233 26.020116a26.050232 26.050232 0 0 1-26.050233 25.990001H279.625904z" fill="#3D3F42" p-id="7521"></path></svg><span>2024-07-30</span></span>&nbsp;<span class="x-post-meta-item"><svg t="1720839329181" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="14106" width="200" height="200"><path d="M699.270662 190.485379c-0.411369 0-0.821715 0.011256-1.227967 0.032746H507.034407a23.041786 23.041786 0 0 0-1.221828-0.031723c-12.779048 0-23.140023 10.359952-23.140023 23.139 0 12.781094 10.360975 23.141046 23.140023 23.141046v0.032746h193.458083v-0.032746c12.780071 0 23.141046-10.359952 23.141047-23.141046 0-12.780071-10.360975-23.140023-23.141047-23.140023zM979.215516 724.005508c0-142.090159-115.186416-257.277598-257.277598-257.277598-72.245418 0-137.532353 29.777187-184.262654 77.725223l45.868677 31.474852c36.227086-33.873482 84.882226-54.617945 138.393977-54.617945 111.945605 0 202.696492 90.750887 202.696492 202.695468h-43.01263l70.331835 104.289228 70.331835-104.289228H979.215516z" fill="" p-id="14107"></path><path d="M748.885664 588.843132c0-14.881942-12.06785-26.945699-26.947746-26.945698-14.883989 0-26.947745 12.063757-26.947745 26.945698v135.164423c0 14.879895 12.063757 26.945699 26.947745 26.945699h107.786889c14.881942 0 26.945699-12.063757 26.945698-26.945699s-12.063757-26.945699-26.945698-26.945699h-80.839143V588.843132zM721.937918 926.702c-111.947651 0-202.696492-90.74884-202.696492-202.696492 0-0.144286 0.004093-0.285502 0.004094-0.429788h43.004443l-70.330812-104.289228-70.331835 104.289228h43.075051c0 0.144286-0.00307 0.285502-0.00307 0.429788 0 142.091182 115.187439 257.279644 257.278621 257.279645 72.241324 0 137.530306-29.77821 184.260607-77.727269l-45.86663-31.474852c-36.227086 33.873482-84.884272 54.618968-138.393977 54.618968zM694.633039 423.38066c-1.354857-11.487635-11.120268-20.400632-22.972201-20.400632H206.362486c-12.780071 0-23.140023 10.359952-23.140023 23.138999 0 12.781094 10.359952 23.141046 23.140023 23.141047H596.949252c30.209022-13.81668 63.104223-22.76754 97.683787-25.879414zM438.548616 623.143333H206.362486c-12.780071 0-23.140023 10.358929-23.140023 23.140023 0 12.780071 10.359952 23.140023 23.140023 23.140023h219.956598a298.463626 298.463626 0 0 1 12.229532-46.280046zM506.934123 513.062192H206.362486c-12.780071 0-23.140023 10.359952-23.140023 23.139 0 12.781094 10.359952 23.140023 23.140023 23.140023H469.936487a302.241672 302.241672 0 0 1 36.997636-46.279023z" fill="" p-id="14108"></path><path d="M442.765661 835.277778a298.531164 298.531164 0 0 1-14.365173-46.150087H146.542052v-0.065491c-33.036417 0-59.81941-26.78197-59.81941-59.819411V329.36031h704.907545v100.905154a298.561863 298.561863 0 0 1 46.150086 14.996552V194.619536h-0.162706c0-53.422723-43.307342-96.728018-96.730065-96.728018h-68.89409V84.418668c0-33.037441-26.782993-59.81941-59.81941-59.81941v-0.361227h-18.87079v0.032745c-33.038464 0-59.820434 26.78197-59.820433 59.819411 0 0.109494 0.008186 0.218988 0.008186 0.328481h-0.339738v13.47285H345.203648V84.418668c0-33.037441-26.782993-59.81941-59.819411-59.81941v-0.361227h-18.872836v0.032745c-33.036417 0-59.81941 26.78197-59.81941 59.819411 0 0.109494 0.007163 0.218988 0.008186 0.328481h-0.339737v13.47285h-69.189826c-53.4217 0-96.729042 43.306318-96.729041 96.728018 0 1.701758 0.045025 3.39226 0.132006 5.071505v533.785166a98.051153 98.051153 0 0 0-0.132006 5.071506c0 53.4217 43.307342 96.728018 96.729041 96.728018v0.001023h305.595047zM86.723665 204.056466c0-33.037441 26.782993-59.81941 59.819411-59.819411 0.044002 0 0.086981 0.00307 0.130983 0.00307v-0.068561h105.968473V94.874811h0.032746a22.807449 22.807449 0 0 1-0.032746-1.215688c0-12.779048 10.360975-23.140023 23.140023-23.140023s23.140023 10.360975 23.140023 23.140023c0 0.408299-0.010233 0.812505-0.031722 1.215688h0.031722v49.297776h280.508696V94.874811h0.032745a22.807449 22.807449 0 0 1-0.032745-1.215688c0-12.779048 10.361999-23.140023 23.140023-23.140023 12.780071 0 23.141046 10.360975 23.141046 23.140023 0 0.408299-0.011256 0.812505-0.032746 1.215688h0.032746v49.297776h106.10048v0.065492c33.035394 0 59.818387 26.780947 59.818387 59.81941h0.130983V283.080264H86.723665v-79.023798z" fill="" p-id="14109"></path></svg><span>2024-07-30</span></span>&nbsp;<span class="x-post-meta-item"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2" fill="none"
     stroke-linecap="round" stroke-linejoin="round" class="feather feather-file-text" style="user-select: text;">
    <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z" style="user-select: text;"></path>
    <polyline points="14 2 14 8 20 8" style="user-select: text;"></polyline>
    <line x1="16" y1="13" x2="8" y2="13" style="user-select: text;"></line>
    <line x1="16" y1="17" x2="8" y2="17" style="user-select: text;"></line>
    <polyline points="10 9 9 9 8 9" style="user-select: text;"></polyline>
</svg><span>1397字</span></span>&nbsp;<span class="x-post-meta-item"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2" fill="none"
     stroke-linecap="round" stroke-linejoin="round">
    <path stroke="none" d="M0 0h24v24H0z" fill="none"></path>
    <circle cx="12" cy="12" r="9"></circle>
    <polyline points="12 7 12 12 15 15"></polyline>
</svg><span>7分钟</span></span>&nbsp;<span class="x-post-meta-item"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2" fill="none"
     stroke-linecap="round" stroke-linejoin="round">
    <path stroke="none" d="M0 0h24v24H0z" fill="none"></path>
    <circle cx="12" cy="7" r="4"></circle>
    <path d="M6 21v-2a4 4 0 0 1 4 -4h4a4 4 0 0 1 4 4v2"></path>
</svg><span>helium</span></span>
      <span class="x-post-meta-item">
        &nbsp;<svg t="1720840393161" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="18680" width="200" height="200"><path d="M995.125144 559.61812l-415.998603-415.998602A52.986489 52.986489 0 0 0 541.413335 127.99957H338.847348c-3.166656-26.559911-9.286635-51.046495-17.999939-71.333094C299.734146 7.333309 271.154242 0 256.00096 0c-13.939953 0-40.439864 6.339979-61.259794 48.806503-10.473298 21.366595-17.946606 48.966502-21.573261 79.193067H53.334974a53.393154 53.393154 0 0 0-53.333154 53.333154v360.078791a52.986489 52.986489 0 0 0 15.619948 37.713206l415.998602 415.998603a53.333154 53.333154 0 0 0 75.426413 0l26.286579-26.293245 26.286578 26.293245a53.426487 53.426487 0 0 0 16.719944 11.333295 21.333262 21.333262 0 0 0 36.079879 11.293295l382.705381-382.705381a53.399821 53.399821 0 0 0 0-75.426413z m-762.070774-491.998347C241.494342 50.373164 250.667645 42.666523 256.00096 42.666523c5.99998 0 16.573278 9.639968 25.646581 30.806564 6.493312 15.159949 11.333295 33.999886 14.146619 54.526483H216.16776c3.206656-23.419921 9.013303-44.359851 16.88661-60.41313z m243.819181 897.330319a10.666631 10.666631 0 0 1-15.079949 0l-415.998603-415.998603A10.573298 10.573298 0 0 1 42.668343 541.411515V181.332724a10.666631 10.666631 0 0 1 10.666631-10.666631h245.332509c0 47.853173-10.373298 92.15969-27.066575 115.632945-5.926647 8.326639-16.566611 14.186619-22.306592 16.113279C204.041135 314.752276 170.667913 356.218803 170.667913 405.331972c0 58.813136 47.853173 106.666308 106.666309 106.666308s106.666308-47.853173 106.666308-106.666308c0-47.086508-30.666564-87.139707-73.079754-101.246327C330.060711 272.705751 341.334007 223.692582 341.334007 170.666093h72.079758a10.573298 10.573298 0 0 1 7.539974 3.126656l415.998603 415.998603a10.666631 10.666631 0 0 1 0 15.079949zM341.334007 405.331972a63.999785 63.999785 0 1 1-63.999785-63.999785 64.073118 64.073118 0 0 1 63.999785 63.999785z m263.539114 559.61812a10.666631 10.666631 0 0 1-15.079949 0L563.499927 938.663513l303.625647-303.61898a53.399821 53.399821 0 0 0 0-75.426413L478.16688 170.666093h63.246455a10.573298 10.573298 0 0 1 7.539974 3.126656l415.998603 415.998603c0.239999 0.239999 0.466665 0.486665 0.666664 0.746664l0.086667 0.106666a10.666631 10.666631 0 0 1 0 13.373289l-0.086667 0.106666c-0.213333 0.259999-0.439999 0.506665-0.666664 0.746664z" fill="#5C5C66" p-id="18681"></path></svg>
        <ul class="post-tags-meta" style="display: inline-block;font-size: 14px;">
            <a href="https://heliu.site/tags/golang/" target="_blank" rel="noopener">Golang</a>
        </ul>
      </span>
      
      <span id="busuanzi_container_page_pv" class="x-post-meta-item">
        &nbsp;<svg t="1720844685710" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="27237" width="200" height="200"><path d="M739.754667 574.08c-121.386667 45.610667-208.469333 169.813333-208.64 316.16 0 33.408 4.693333 65.493333 13.141333 95.914667H94.122667c-26.453333-43.52-41.685333-91.946667-41.685334-143.189334 0-185.173333 192.896-335.104 430.805334-335.104 96.256 0 184.832 24.746667 256.512 66.218667z m-280.490667-114.986667a214.869333 214.869333 0 0 1-214.869333-215.04A215.04 215.04 0 0 1 459.264 28.842667a215.04 215.04 0 0 1 215.04 215.210666 215.04 215.04 0 0 1-215.04 215.04zM974.506667 641.28c9.856 0 17.834667 7.466667 17.834666 16.64v59.989333c-0.341333 8.789333-7.850667 15.786667-17.28 16.085334-9.856 0.341333-18.176-6.826667-18.517333-16.085334v-20.053333l-99.114667 91.093333-0.256 0.256a18.474667 18.474667 0 0 1-14.848 4.352h-0.768a18.176 18.176 0 0 1-9.344-4.608l-0.938666-0.981333-85.930667-80.042667-123.562667 115.072a18.773333 18.773333 0 0 1-25.216 0 15.786667 15.786667 0 0 1 0-23.466666l136.149334-126.848 0.725333-0.597334a18.645333 18.645333 0 0 1 24.362667 0.512l87.253333 81.237334 86.058667-79.232h-21.248c-9.386667-0.298667-16.938667-7.338667-17.28-16.085334-0.341333-9.173333 7.381333-16.896 17.28-17.237333h64.64z m-367.146667 240h48.128c8.874667 0 16.042667 7.168 16.042667 16.042667v72.192a16.042667 16.042667 0 0 1-16.042667 16.042666h-48.128a16.042667 16.042667 0 0 1-16.042667-16.042666v-72.192c0-8.874667 7.210667-16.042667 16.042667-16.042667z m110.805333-106.666667h48.128c8.874667 0 16.042667 7.168 16.042667 16.042667v178.858667a16.042667 16.042667 0 0 1-16.042667 16.042666h-48.128a16.042667 16.042667 0 0 1-16.042666-16.042666v-178.858667c0-8.874667 7.168-16.042667 16.042666-16.042667z m106.538667 80h48.128c8.874667 0 16.042667 7.168 16.042667 16.042667v99.413333a16.042667 16.042667 0 0 1-16.042667 16.042667H824.746667a16.042667 16.042667 0 0 1-16.042667-16.042667v-99.413333c0-8.874667 7.168-16.042667 16.042667-16.042667z m110.165333-80h48.128c8.874667 0 16.042667 7.168 16.042667 16.042667v179.413333a16.042667 16.042667 0 0 1-16.042667 16.042667h-48.128a16.042667 16.042667 0 0 1-16.042666-16.042667v-179.413333c0-8.874667 7.210667-16.042667 16.042666-16.042667z" fill="#999999" p-id="27238"></path></svg>
        <span id="busuanzi_value_page_pv"></span>
      </span>

</div>
  </header> <aside id="toc-container" class="toc-container wide">
    <div class="toc">
        <details  open>
            <summary accesskey="c" title="(Alt + C)">
                <span class="details">目录</span>
            </summary>

            <div class="inner"><ul>
                    <li>
                        <a href="#runtimemain" aria-label="runtime.main">runtime.main</a></li>
                    <li>
                        <a href="#variables" aria-label="variables">variables</a></li>
                    <li>
                        <a href="#sysmon" aria-label="sysmon()">sysmon()</a>
                    </li>
                </ul>
            </div>
        </details>
    </div>
</aside>
<script>
    let activeElement;
    let elements;
    window.addEventListener('DOMContentLoaded', function (event) {
        checkTocPosition();

        elements = document.querySelectorAll('h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]');
         
         activeElement = elements[0];
         const id = encodeURI(activeElement.getAttribute('id')).toLowerCase();
         document.querySelector(`.inner ul li a[href="#${id}"]`).classList.add('active');
     }, false);

    window.addEventListener('resize', function(event) {
        checkTocPosition();
    }, false);

    window.addEventListener('scroll', () => {
        
        activeElement = Array.from(elements).find((element) => {
            if ((getOffsetTop(element) - window.pageYOffset) > 0 && 
                (getOffsetTop(element) - window.pageYOffset) < window.innerHeight/2) {
                return element;
            }
        }) || activeElement

        elements.forEach(element => {
             const id = encodeURI(element.getAttribute('id')).toLowerCase();
             if (element === activeElement){
                 document.querySelector(`.inner ul li a[href="#${id}"]`).classList.add('active');
             } else {
                 document.querySelector(`.inner ul li a[href="#${id}"]`).classList.remove('active');
             }
         })
     }, false);

    const main = parseInt(getComputedStyle(document.body).getPropertyValue('--article-width'), 10);
    const toc = parseInt(getComputedStyle(document.body).getPropertyValue('--toc-width'), 10);
    const gap = parseInt(getComputedStyle(document.body).getPropertyValue('--gap'), 10);

    function checkTocPosition() {
        const width = document.body.scrollWidth;

        if (width - main - (toc * 2) - (gap * 4) > 0) {
            document.getElementById("toc-container").classList.add("wide");
        } else {
            document.getElementById("toc-container").classList.remove("wide");
        }
    }

    function getOffsetTop(element) {
        if (!element.getClientRects().length) {
            return 0;
        }
        let rect = element.getBoundingClientRect();
        let win = element.ownerDocument.defaultView;
        return rect.top + win.pageYOffset;   
    }
</script>
  <div class="post-content"><h2 id="runtimemain">runtime.main<a hidden class="anchor" aria-hidden="true" href="#runtimemain">#</a></h2>
<ol>
<li>监控线程在<code>runtime.main</code>中被创建。</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">GOARCH</span> <span class="o">!=</span> <span class="s">&#34;wasm&#34;</span> <span class="p">{</span> <span class="c1">// no threads on wasm yet, so no sysmon
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// systemstack()函数切换到g0栈去运行闭包函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nf">systemstack</span><span class="p">(</span><span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// newm新创建一个线程，从sysmon入口函数开始执行
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="nf">newm</span><span class="p">(</span><span class="nx">sysmon</span><span class="p">,</span> <span class="kc">nil</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="c1">// 监控线程sysmon不需要P就能运行
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="p">})</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></div><h2 id="variables">variables<a hidden class="anchor" aria-hidden="true" href="#variables">#</a></h2>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// forcegcperiod is the maximum time in nanoseconds between garbage
</span></span></span><span class="line"><span class="cl"><span class="c1">// collections. If we go this long without a garbage collection, one
</span></span></span><span class="line"><span class="cl"><span class="c1">// is forced to run.
</span></span></span><span class="line"><span class="cl"><span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1">// This is a variable for testing purposes. It normally doesn&#39;t change.
</span></span></span><span class="line"><span class="cl"><span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1">// forceegcperiod是两次垃圾回收之间的最大时间，单位为纳秒。
</span></span></span><span class="line"><span class="cl"><span class="c1">// 如果这么长时间都没有垃圾收集，那么垃圾收集将被迫运行。
</span></span></span><span class="line"><span class="cl"><span class="c1">// 这是一个用于测试的变量。它通常不会改变。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">var</span> <span class="nx">forcegcperiod</span> <span class="kt">int64</span> <span class="p">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="mi">60</span> <span class="o">*</span> <span class="mf">1e9</span> <span class="c1">// 2min
</span></span></span></code></pre></div><h2 id="sysmon">sysmon()<a hidden class="anchor" aria-hidden="true" href="#sysmon">#</a></h2>
<ol>
<li>前面创建监控线程可以看出，监控线程是没有绑定<code>P</code>的。</li>
<li>这个监控线程是一个独立的线程，无需<code>P</code>即可运行，<code>sysmon</code>每<code>20us ~ 10ms</code>运行一次。</li>
<li><code>timer</code>在每次调度器调度和窃取其他<code>g</code>的时候触发，这种具有一定的随机性和不确定性，系统监控线程触发依然是一个兜底保障。</li>
<li>监控线程主要职责：
<ol>
<li>最长<code>10ms</code>间隔执行一次网络轮询（保证<code>I/O</code>轮询）。因为<code>netpoll</code>是随机的，不是定时间段的。</li>
<li>抢占超过时间片的<code>G</code>。</li>
<li>超过预定时间，发起一轮<code>GC</code>。</li>
</ol>
</li>
<li>总是在没有<code>P</code>的情况下运行，因此不允许写屏障。</li>
<li>文件位置：<code>go1.19.3/src/runtime/proc.go</code>。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">5131
</span><span class="lnt">5132
</span><span class="lnt">5133
</span><span class="lnt">5134
</span><span class="lnt">5135
</span><span class="lnt">5136
</span><span class="lnt">5137
</span><span class="lnt">5138
</span><span class="lnt">5139
</span><span class="lnt">5140
</span><span class="lnt">5141
</span><span class="lnt">5142
</span><span class="lnt">5143
</span><span class="lnt">5144
</span><span class="lnt">5145
</span><span class="lnt">5146
</span><span class="lnt">5147
</span><span class="lnt">5148
</span><span class="lnt">5149
</span><span class="lnt">5150
</span><span class="lnt">5151
</span><span class="lnt">5152
</span><span class="lnt">5153
</span><span class="lnt">5154
</span><span class="lnt">5155
</span><span class="lnt">5156
</span><span class="lnt">5157
</span><span class="lnt">5158
</span><span class="lnt">5159
</span><span class="lnt">5160
</span><span class="lnt">5161
</span><span class="lnt">5162
</span><span class="lnt">5163
</span><span class="lnt">5164
</span><span class="lnt">5165
</span><span class="lnt">5166
</span><span class="lnt">5167
</span><span class="lnt">5168
</span><span class="lnt">5169
</span><span class="lnt">5170
</span><span class="lnt">5171
</span><span class="lnt">5172
</span><span class="lnt">5173
</span><span class="lnt">5174
</span><span class="lnt">5175
</span><span class="lnt">5176
</span><span class="lnt">5177
</span><span class="lnt">5178
</span><span class="lnt">5179
</span><span class="lnt">5180
</span><span class="lnt">5181
</span><span class="lnt">5182
</span><span class="lnt">5183
</span><span class="lnt">5184
</span><span class="lnt">5185
</span><span class="lnt">5186
</span><span class="lnt">5187
</span><span class="lnt">5188
</span><span class="lnt">5189
</span><span class="lnt">5190
</span><span class="lnt">5191
</span><span class="lnt">5192
</span><span class="lnt">5193
</span><span class="lnt">5194
</span><span class="lnt">5195
</span><span class="lnt">5196
</span><span class="lnt">5197
</span><span class="lnt">5198
</span><span class="lnt">5199
</span><span class="lnt">5200
</span><span class="lnt">5201
</span><span class="lnt">5202
</span><span class="lnt">5203
</span><span class="lnt">5204
</span><span class="lnt">5205
</span><span class="lnt">5206
</span><span class="lnt">5207
</span><span class="lnt">5208
</span><span class="lnt">5209
</span><span class="lnt">5210
</span><span class="lnt">5211
</span><span class="lnt">5212
</span><span class="lnt">5213
</span><span class="lnt">5214
</span><span class="lnt">5215
</span><span class="lnt">5216
</span><span class="lnt">5217
</span><span class="lnt">5218
</span><span class="lnt">5219
</span><span class="lnt">5220
</span><span class="lnt">5221
</span><span class="lnt">5222
</span><span class="lnt">5223
</span><span class="lnt">5224
</span><span class="lnt">5225
</span><span class="lnt">5226
</span><span class="lnt">5227
</span><span class="lnt">5228
</span><span class="lnt">5229
</span><span class="lnt">5230
</span><span class="lnt">5231
</span><span class="lnt">5232
</span><span class="lnt">5233
</span><span class="lnt">5234
</span><span class="lnt">5235
</span><span class="lnt">5236
</span><span class="lnt">5237
</span><span class="lnt">5238
</span><span class="lnt">5239
</span><span class="lnt">5240
</span><span class="lnt">5241
</span><span class="lnt">5242
</span><span class="lnt">5243
</span><span class="lnt">5244
</span><span class="lnt">5245
</span><span class="lnt">5246
</span><span class="lnt">5247
</span><span class="lnt">5248
</span><span class="lnt">5249
</span><span class="lnt">5250
</span><span class="lnt">5251
</span><span class="lnt">5252
</span><span class="lnt">5253
</span><span class="lnt">5254
</span><span class="lnt">5255
</span><span class="lnt">5256
</span><span class="lnt">5257
</span><span class="lnt">5258
</span><span class="lnt">5259
</span><span class="lnt">5260
</span><span class="lnt">5261
</span><span class="lnt">5262
</span><span class="lnt">5263
</span><span class="lnt">5264
</span><span class="lnt">5265
</span><span class="lnt">5266
</span><span class="lnt">5267
</span><span class="lnt">5268
</span><span class="lnt">5269
</span><span class="lnt">5270
</span><span class="lnt">5271
</span><span class="lnt">5272
</span><span class="lnt">5273
</span><span class="lnt">5274
</span><span class="lnt">5275
</span><span class="lnt">5276
</span><span class="lnt">5277
</span><span class="lnt">5278
</span><span class="lnt">5279
</span><span class="lnt">5280
</span><span class="lnt">5281
</span><span class="lnt">5282
</span><span class="lnt">5283
</span><span class="lnt">5284
</span><span class="lnt">5285
</span><span class="lnt">5286
</span><span class="lnt">5287
</span><span class="lnt">5288
</span><span class="lnt">5289
</span><span class="lnt">5290
</span><span class="lnt">5291
</span><span class="lnt">5292
</span><span class="lnt">5293
</span><span class="lnt">5294
</span><span class="lnt">5295
</span><span class="lnt">5296
</span><span class="lnt">5297
</span><span class="lnt">5298
</span><span class="lnt">5299
</span><span class="lnt">5300
</span><span class="lnt">5301
</span><span class="lnt">5302
</span><span class="lnt">5303
</span><span class="lnt">5304
</span><span class="lnt">5305
</span><span class="lnt">5306
</span><span class="lnt">5307
</span><span class="lnt">5308
</span><span class="lnt">5309
</span><span class="lnt">5310
</span><span class="lnt">5311
</span><span class="lnt">5312
</span><span class="lnt">5313
</span><span class="lnt">5314
</span><span class="lnt">5315
</span><span class="lnt">5316
</span><span class="lnt">5317
</span><span class="lnt">5318
</span><span class="lnt">5319
</span><span class="lnt">5320
</span><span class="lnt">5321
</span><span class="lnt">5322
</span><span class="lnt">5323
</span><span class="lnt">5324
</span><span class="lnt">5325
</span><span class="lnt">5326
</span><span class="lnt">5327
</span><span class="lnt">5328
</span><span class="lnt">5329
</span><span class="lnt">5330
</span><span class="lnt">5331
</span><span class="lnt">5332
</span><span class="lnt">5333
</span><span class="lnt">5334
</span><span class="lnt">5335
</span><span class="lnt">5336
</span><span class="lnt">5337
</span><span class="lnt">5338
</span><span class="lnt">5339
</span><span class="lnt">5340
</span><span class="lnt">5341
</span><span class="lnt">5342
</span><span class="lnt">5343
</span><span class="lnt">5344
</span><span class="lnt">5345
</span><span class="lnt">5346
</span><span class="lnt">5347
</span><span class="lnt">5348
</span><span class="lnt">5349
</span><span class="lnt">5350
</span><span class="lnt">5351
</span><span class="lnt">5352
</span><span class="lnt">5353
</span><span class="lnt">5354
</span><span class="lnt">5355
</span><span class="lnt">5356
</span><span class="lnt">5357
</span><span class="lnt">5358
</span><span class="lnt">5359
</span><span class="lnt">5360
</span><span class="lnt">5361
</span><span class="lnt">5362
</span><span class="lnt">5363
</span><span class="lnt">5364
</span><span class="lnt">5365
</span><span class="lnt">5366
</span><span class="lnt">5367
</span><span class="lnt">5368
</span><span class="lnt">5369
</span><span class="lnt">5370
</span><span class="lnt">5371
</span><span class="lnt">5372
</span><span class="lnt">5373
</span><span class="lnt">5374
</span><span class="lnt">5375
</span><span class="lnt">5376
</span><span class="lnt">5377
</span><span class="lnt">5378
</span><span class="lnt">5379
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// Always runs without a P, so write barriers are not allowed.
</span></span></span><span class="line"><span class="cl"><span class="c1">// 
</span></span></span><span class="line"><span class="cl"><span class="c1">//go:nowritebarrierrec
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">sysmon</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nx">sched</span><span class="p">.</span><span class="nx">nmsys</span><span class="o">++</span>   <span class="c1">// 系统M数量
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">checkdead</span><span class="p">()</span>     <span class="c1">// 检查死锁
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nx">lasttrace</span> <span class="o">:=</span> <span class="nb">int64</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>   <span class="c1">// 最后跟踪时间
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    
</span></span><span class="line"><span class="cl">    <span class="c1">// idle：在以下两种情况下才会重置为0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//  1. 有陷入系统调度的P需要被抢占时。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//  2. sysmon从深度睡眠中醒来时。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 进入深度睡眠在这两种条件下：
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//  1. STW期间，sysmon可以进入深度睡眠。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//  2. 在所有P都空闲时(可能都陷入系统调用)。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 其他情况idle会累加，因此sysmon的调度间隔会趋向于10ms。这一个goroutine运行的时间片时间值。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">idle</span> <span class="o">:=</span> <span class="mi">0</span> <span class="c1">// how many cycles in succession we had not wokeup somebody
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 下次sysmon运行的时间间隔，微秒。根据idle计算而来。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">delay</span> <span class="o">:=</span> <span class="nb">uint32</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 1) 计算下次运行时间间隔
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">//  1. 默认20us。(20微秒)。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">//  2. 连续50个周期无事可做则翻倍时间，后面依次翻倍。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">//  3. 最高10ms。(10毫秒)。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="nx">idle</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span> <span class="c1">// start with 20us sleep...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="nx">delay</span> <span class="p">=</span> <span class="mi">20</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nx">idle</span> <span class="p">&gt;</span> <span class="mi">50</span> <span class="p">{</span> <span class="c1">// start doubling the sleep after 1ms...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="nx">delay</span> <span class="o">*=</span> <span class="mi">2</span>	
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="nx">delay</span> <span class="p">&gt;</span> <span class="mi">10</span><span class="o">*</span><span class="mi">1000</span> <span class="p">{</span> <span class="c1">// up to 10ms
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="nx">delay</span> <span class="p">=</span> <span class="mi">10</span> <span class="o">*</span> <span class="mi">1000</span>	
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 系统调用sleep delay微秒
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nf">usleep</span><span class="p">(</span><span class="nx">delay</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// sysmon should not enter deep sleep if schedtrace is enabled so that
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// it can print that information at the right time.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// It should also not enter deep sleep if there are any active P&#39;s so
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// that it can retake P&#39;s from syscalls, preempt long running G&#39;s, and
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// poll the network if all P&#39;s are busy for long stretches.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// It should wakeup from deep sleep if any P&#39;s become active either due
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// to exiting a syscall or waking up due to a timer expiring so that it
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// can resume performing those duties. If it wakes from a syscall it
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// resets idle and delay as a bet that since it had retaken a P from a
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// syscall before, it may need to do it again shortly after the
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// application starts work again. It does not reset idle when waking
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// from a timer to avoid adding system load to applications that spend
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// most of their time sleeping.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 如果启用了 schedtrace，sysmon 不应进入深度睡眠，以便它可以在正确的时间打印该信息
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 如果有任何活动的P，它也不应该进入深度睡眠，以便它可以从系统调用中重新获取P，
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 抢占长时间运行的G，并在所有P长时间忙碌时轮询网络
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 如果任何 P 由于退出系统调用或由于计时器到期而唤醒，
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 它应该从深度睡眠中唤醒，以便它可以恢复执行这些职责
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 果它从系统调用中唤醒，它会重置空闲和延迟作为赌注，因为它之前已经从系统调用中重新获得了P，
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 它可能需要在应用程序再次开始工作后不久再次这样做
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 它不会在从计时器唤醒时重置空闲，以避免将系统负载添加到大部分时间都在休眠的应用程序
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">now</span> <span class="o">:=</span> <span class="nf">nanotime</span><span class="p">()</span>   <span class="c1">// 当前时间
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        
</span></span><span class="line"><span class="cl">        <span class="c1">// 2) 满足以下条件工作线程会进入深度睡眠：
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">//  1. STW正在等待其他P停下来，这段时间sysmon线程可以深度睡眠，在start the world时会唤醒sysmon。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">//  2. 全部P都处于空闲，这段时间sysmon线程可以深度睡眠，这可能是处于系统调用中时，系统调用返回时会唤醒sysmon。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="nx">debug</span><span class="p">.</span><span class="nx">schedtrace</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="nx">sched</span><span class="p">.</span><span class="nx">gcwaiting</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">||</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Load</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">npidle</span><span class="p">)</span> <span class="o">==</span> <span class="nb">uint32</span><span class="p">(</span><span class="nx">gomaxprocs</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span> <span class="c1">// mutex lock
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// 加锁后，再次判断一次原因是获取锁这段时间可能条件不成立了。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="k">if</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Load</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">gcwaiting</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">||</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Load</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">npidle</span><span class="p">)</span> <span class="o">==</span> <span class="nb">uint32</span><span class="p">(</span><span class="nx">gomaxprocs</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="nx">syscallWake</span> <span class="o">:=</span> <span class="kc">false</span> <span class="c1">// 系统调用唤醒?
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                
</span></span><span class="line"><span class="cl">                <span class="c1">// 2.1) 最近一次timer的触发时间点或没有timer时都应该sleep。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="c1">// timeSleepUntil函数只会在sysmon和checkdead函数中被调用：
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="c1">//  1. next表示最先触发timer的时间点，timeSleepUntil函数会遍历所有的P取选择最小的timer触发时间点。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="c1">//  2. 返回 maxWhen = 1&lt;&lt;63 - 1，表示没有定时器。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="nx">next</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nf">timeSleepUntil</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">                <span class="c1">// 2.2) 还未到触发timer的时间点时或没有timer，这段时间可以sleep。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="k">if</span> <span class="nx">next</span> <span class="p">&gt;</span> <span class="nx">now</span> <span class="p">{</span>	
</span></span><span class="line"><span class="cl">                    <span class="nx">atomic</span><span class="p">.</span><span class="nf">Store</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">sysmonwait</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="c1">// sched.sysmonwait = 1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                    <span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>	
</span></span><span class="line"><span class="cl">                    <span class="c1">// Make wake-up period small enough
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                    <span class="c1">// for the sampling to be correct.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                    <span class="c1">// 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                    <span class="c1">// 使唤醒周期足够小，以保证取样正确。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                    <span class="c1">// 2.3) 计算睡眠时间间隔最大值1分钟。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                    <span class="nx">sleep</span> <span class="o">:=</span> <span class="nx">forcegcperiod</span> <span class="o">/</span> <span class="mi">2</span> <span class="c1">// 1min
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                    <span class="k">if</span> <span class="nx">next</span><span class="o">-</span><span class="nx">now</span> <span class="p">&lt;</span> <span class="nx">sleep</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                        <span class="nx">sleep</span> <span class="p">=</span> <span class="nx">next</span> <span class="o">-</span> <span class="nx">now</span>
</span></span><span class="line"><span class="cl">                    <span class="p">}</span>
</span></span><span class="line"><span class="cl">                    <span class="c1">// osRelaxMinNS 表示如果下一个计时器从现在开始少于 60 毫秒，则 sysmon 不应该 osRelax
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                    <span class="c1">// 由于 osRelaxing 可能会将计时器分辨率降低到 15.6 毫秒，这将计时器错误保持在大约 4 分之一以下
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                    <span class="c1">// const osRelaxMinNS = 0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                    <span class="nx">shouldRelax</span> <span class="o">:=</span> <span class="nx">sleep</span> <span class="o">&gt;=</span> <span class="nx">osRelaxMinNS</span>
</span></span><span class="line"><span class="cl">                    <span class="k">if</span> <span class="nx">shouldRelax</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                        <span class="c1">// osRelax 在与所有空闲的 P 之间转换时由调度程序调用
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                        <span class="c1">// 在 linux amd64 下该函数为空
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                        <span class="nf">osRelax</span><span class="p">(</span><span class="kc">true</span><span class="p">)</span>	
</span></span><span class="line"><span class="cl">                    <span class="p">}</span>
</span></span><span class="line"><span class="cl">                      
</span></span><span class="line"><span class="cl">                    <span class="c1">// 2.4) 在sched.sysmonnote上睡眠sleep纳秒。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                    <span class="c1">// 睡眠 sleep ns 时间，睡眠在 sched.sysmonnote 上。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                    <span class="c1">// 最长情况会睡眠1min，也就是全部P都无事可做时。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                    <span class="c1">// sleep时间后，也就是最新的timer需要触发的时间点，唤醒监控线程。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                    <span class="c1">// 当 STW 正在进行时，这里会把监控线程sleep 1min，在start the world时会唤醒
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                    <span class="c1">// 在sched.sysmonnote上的监控线程。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                    <span class="c1">// 当系统调用返回，在runtime_exitsyscall()函数中会响应的唤醒
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                    <span class="c1">// 在sched.sysmonnote上的监控线程。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                    <span class="c1">// syscallWake = true。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                    <span class="nx">syscallWake</span> <span class="p">=</span> <span class="nf">notetsleep</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">sysmonnote</span><span class="p">,</span> <span class="nx">sleep</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                    <span class="k">if</span> <span class="nx">shouldRelax</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                        <span class="nf">osRelax</span><span class="p">(</span><span class="kc">false</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                    <span class="p">}</span>
</span></span><span class="line"><span class="cl">                    <span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                    <span class="c1">// sched.sysmonwait = 0;sched.sysmonnote.key = 0;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                    <span class="nx">atomic</span><span class="p">.</span><span class="nf">Store</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">sysmonwait</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                    <span class="nf">noteclear</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">sysmonnote</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                <span class="p">}</span>
</span></span><span class="line"><span class="cl">                <span class="c1">// 由系统调用醒来或触发timer时间点已经过了，重置计时。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="k">if</span> <span class="nx">syscallWake</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                    <span class="nx">idle</span> <span class="p">=</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">                    <span class="nx">delay</span> <span class="p">=</span> <span class="mi">20</span>
</span></span><span class="line"><span class="cl">                <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">sysmonlock</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// Update now in case we blocked on sysmonnote or spent a long time
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// blocked on schedlock or sysmonlock above.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 如果我们在sysmonnote上被阻塞，或者在上面的schedlock或sysmonlock上花了很长时间阻塞，现在更新。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">now</span> <span class="p">=</span> <span class="nf">nanotime</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// trigger libc interceptors if needed
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="o">*</span><span class="nx">cgo_yield</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nf">asmcgocall</span><span class="p">(</span><span class="o">*</span><span class="nx">cgo_yield</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">        <span class="c1">// 3) network poll; 网络轮询。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 网络轮询的时间间隔设置为10ms。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        
</span></span><span class="line"><span class="cl">        <span class="c1">// poll network if not polled for more than 10ms
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 超过10ms没有进行网络轮询，则进行网络轮询。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// sched.lastpoll：记录的是上次执行netpoll的时间。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">//  1. 如果等于0，则表示某个线程正在阻塞式地执行netpoll。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">//  2. 大于0，则是上次执行时间点。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">lastpoll</span> <span class="o">:=</span> <span class="nb">int64</span><span class="p">(</span><span class="nx">atomic</span><span class="p">.</span><span class="nf">Load64</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lastpoll</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 以下三种情况不会轮询网络：
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">//  1. 没有初始化 netpoll 时。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">//  2. 其他线程阻塞式访问 netpoll 时。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">//  3. 上次轮询时间还没到 10ms 时。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 需要查看network：已初始化 &amp;&amp; 没有其他线程在阻塞调用epoll &amp;&amp; 上次epoll已超过10ms了
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="nf">netpollinited</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="nx">lastpoll</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">lastpoll</span><span class="o">+</span><span class="mi">10</span><span class="o">*</span><span class="mi">1000</span><span class="o">*</span><span class="mi">1000</span> <span class="p">&lt;</span> <span class="nx">now</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// CAS更新 sched.lastpoll 时间。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="nx">atomic</span><span class="p">.</span><span class="nf">Cas64</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lastpoll</span><span class="p">,</span> <span class="nb">uint64</span><span class="p">(</span><span class="nx">lastpoll</span><span class="p">),</span> <span class="nb">uint64</span><span class="p">(</span><span class="nx">now</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 3.1) 轮询 poll。参数0立即返回。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// network poll是否有就绪的事件。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// 传递参数0表示epoll轮询wait等待函数立即返回。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// 非阻塞式轮询，返回就绪的goroutine列表。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="nx">list</span> <span class="o">:=</span> <span class="nf">netpoll</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="c1">// non-blocking - returns list of goroutines
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// 存在就绪的 goroutine。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="k">if</span> <span class="p">!</span><span class="nx">list</span><span class="p">.</span><span class="nf">empty</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="c1">// Need to decrement number of idle locked M&#39;s
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="c1">// (pretending that one more is running) before injectglist.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="c1">// Otherwise it can lead to the following situation:
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="c1">// injectglist grabs all P&#39;s but before it starts M&#39;s to run the P&#39;s,
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="c1">// another M returns from syscall, finishes running its G,
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="c1">// observes that there is no work to do and no other running M&#39;s
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="c1">// and reports deadlock.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="c1">// 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="c1">// 设置 sched.nmidlelocked += -1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="nf">incidlelocked</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                <span class="c1">// 处理准备好的goroutine
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="c1">// 该函数在调度循环函数中有详细注解。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="nf">injectglist</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">list</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                <span class="nf">incidlelocked</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">        <span class="c1">// 在 linux amd64 下不会触发。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="nx">GOOS</span> <span class="o">==</span> <span class="s">&#34;netbsd&#34;</span> <span class="o">&amp;&amp;</span> <span class="nx">needSysmonWorkaround</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// netpoll is responsible for waiting for timer
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// expiration, so we typically don&#39;t have to worry
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// about starting an M to service timers. (Note that
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// sleep for timeSleepUntil above simply ensures sysmon
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// starts running again when that timer expiration may
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// cause Go code to run again).
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// However, netbsd has a kernel bug that sometimes
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// misses netpollBreak wake-ups, which can lead to
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// unbounded delays servicing timers. If we detect this
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// overrun, then startm to get something to handle the
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// timer.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// See issue 42515 and
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// https://gnats.netbsd.org/cgi-bin/query-pr-single.pl?number=50094.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="k">if</span> <span class="nx">next</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nf">timeSleepUntil</span><span class="p">();</span> <span class="nx">next</span> <span class="p">&lt;</span> <span class="nx">now</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="nf">startm</span><span class="p">(</span><span class="kc">nil</span><span class="p">,</span> <span class="kc">false</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Load</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">scavenge</span><span class="p">.</span><span class="nx">sysmonWake</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// Kick the scavenger awake if someone requested it.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="nf">wakeScavenger</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">        <span class="c1">// 4) 检查所有的P查看是否存在运行时间太长的G需要设置抢占请求。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">//  1. goroutine运行时间超过10ms时需要抢占。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">//  2. goroutine陷入系统调用，运行时间超过10ms或在第二轮来是sysmon系统调用还没返回时。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 陷入系统调用而抢占P的情况：
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">//  1. 运行时间超过10ms，可能一开始就陷入系统调用，或中途陷入系统调用。不论那种情况都应该抢占。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">//  2. 运行时间没到10ms，但是两轮sysmon了还是在系统调用中，需要抢占P。这时候时间间隔在(0, 20ms)这个范围。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        
</span></span><span class="line"><span class="cl">        <span class="c1">// retake P&#39;s blocked in syscalls
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// and preempt long running G&#39;s
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 重新获取在系统调用中阻塞的 P 并抢占长时间运行的 G
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// retake函数返回值，陷入系统调用的需要抢占的P的数量。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="nf">retake</span><span class="p">(</span><span class="nx">now</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 为什么陷入系统调度的P需要重置监控频率？
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// 原因是陷入系统调度的P，把时间调回20us，下轮监控线程来时判断是否还在系统调用中。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="nx">idle</span> <span class="p">=</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nx">idle</span><span class="o">++</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">        <span class="c1">// 5) GC相关，定时检查GC是否该触发了
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        
</span></span><span class="line"><span class="cl">        <span class="c1">// check if we need to force a GC
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// t.test()：判断是否满足定时GC间隔2分钟的条件
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// forcegc.idle.Load()：当前定时GC是空闲的
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="nx">t</span> <span class="o">:=</span> <span class="p">(</span><span class="nx">gcTrigger</span><span class="p">{</span><span class="nx">kind</span><span class="p">:</span> <span class="nx">gcTriggerTime</span><span class="p">,</span> <span class="nx">now</span><span class="p">:</span> <span class="nx">now</span><span class="p">});</span> <span class="nx">t</span><span class="p">.</span><span class="nf">test</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Load</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">forcegc</span><span class="p">.</span><span class="nx">idle</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">forcegc</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span> <span class="c1">// 获取互斥锁
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="nx">forcegc</span><span class="p">.</span><span class="nx">idle</span> <span class="p">=</span> <span class="mi">0</span>    <span class="c1">// 标记本轮定时GC开始了
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="kd">var</span> <span class="nx">list</span> <span class="nx">gList</span>      <span class="c1">// goroutine的列表，最后会把里面的goroutine放入P的本地队列
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="nx">list</span><span class="p">.</span><span class="nf">push</span><span class="p">(</span><span class="nx">forcegc</span><span class="p">.</span><span class="nx">g</span><span class="p">)</span><span class="c1">// forcegchelper goroutine 加入本地队列，去触发goroutine
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="nf">injectglist</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">list</span><span class="p">)</span>  <span class="c1">// list 加入P的本地队列等待M调用，等待forcegchelper()函数继续运行吧
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">forcegc</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span><span class="c1">// 解锁
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="nx">debug</span><span class="p">.</span><span class="nx">schedtrace</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">lasttrace</span><span class="o">+</span><span class="nb">int64</span><span class="p">(</span><span class="nx">debug</span><span class="p">.</span><span class="nx">schedtrace</span><span class="p">)</span><span class="o">*</span><span class="mi">1000000</span> <span class="o">&lt;=</span> <span class="nx">now</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nx">lasttrace</span> <span class="p">=</span> <span class="nx">now</span>
</span></span><span class="line"><span class="cl">            <span class="nf">schedtrace</span><span class="p">(</span><span class="nx">debug</span><span class="p">.</span><span class="nx">scheddetail</span> <span class="p">&gt;</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">sysmonlock</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div>

  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://heliu.site/tags/golang/">Golang</a></li>
    </ul>
<nav class="paginav">
  <a class="prev" href="https://heliu.site/posts/golang/goroutine/mstart/">
    <span class="title">« 上一页</span>
    <br>
    <span>GMP 调度模型</span>
  </a>
  <a class="next" href="https://heliu.site/posts/golang/goroutine/newm/">
    <span class="title">下一页 »</span>
    <br>
    <span>工作线程的唤醒和创建</span>
  </a>
</nav>

  </footer>
</article>
    </main>
    
<footer class="footer">
    
    <div class="busuanzi-footer">
    <span id="busuanzi_container_site_pv">
        本站总访问量<span id="busuanzi_value_site_pv"></span>次
    </span>
    <span id="busuanzi_container_site_uv">
        本站访客数<span id="busuanzi_value_site_uv"></span>人次
    </span>
    </div>
        <span>Copyright © 2024 蜀ICP备2024091074号 <a href="#">heliu's blog</a>. All rights reserved</span>  
    
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'Copy';

        function copyingDone() {
            copybutton.innerHTML = 'Done';
            setTimeout(() => {
                copybutton.innerHTML = 'Copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
