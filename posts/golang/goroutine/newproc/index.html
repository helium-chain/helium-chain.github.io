<!DOCTYPE html>
<html lang="zh" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>go 关键字 | Helium</title>
<meta name="keywords" content="golang, Goroutine">
<meta name="description" content="💥本文章所有相关go代码参考自go 1.18&#43;版本">
<meta name="author" content="helium">
<link rel="canonical" href="https://helium.github.io/posts/golang/goroutine/newproc/">
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<meta name="referrer" content="no-referrer-when-downgrade">
<link crossorigin="anonymous" href="/assets/css/stylesheet.css" rel="preload stylesheet" as="style">
<link rel="icon" href="https://helium.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://helium.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://helium.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://helium.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://helium.github.io/apple-touch-icon.png">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="zh" href="https://helium.github.io/posts/golang/goroutine/newproc/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
<html>
<head>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/jetbrains-mono@1.0.6/css/jetbrains-mono-nl.min.css" />
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lxgw-wenkai-lite-webfont@1.1.0/style.css" />
    <link rel="stylesheet" href="https://cdn.staticfile.org/lxgw-wenkai-screen-webfont/1.6.0/style.css" />
    <style>
        body {
            font-family: "LXGW WenKai Lite", sans-serif;
            font-family: "LXGW WenKai Screen", sans-serif;
        }
    </style>
</head>
</html>

  

<meta property="og:title" content="go 关键字" />
<meta property="og:description" content="💥本文章所有相关go代码参考自go 1.18&#43;版本" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://helium.github.io/posts/golang/goroutine/newproc/" />
<meta property="og:image" content="https://helium.github.io/favicon-32x32.png" />
<meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-07-29T00:00:00+00:00" />
<meta property="article:modified_time" content="2024-07-29T00:00:00+00:00" /><meta property="og:site_name" content="Helium" />

<meta name="twitter:card" content="summary_large_image" />
<meta name="twitter:image" content="https://helium.github.io/favicon-32x32.png" />
<meta name="twitter:title" content="go 关键字"/>
<meta name="twitter:description" content="💥本文章所有相关go代码参考自go 1.18&#43;版本"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Article",
      "item": "https://helium.github.io/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Golang",
      "item": "https://helium.github.io/posts/golang/"
    }, 
    {
      "@type": "ListItem",
      "position":  3 ,
      "name": "第12章 Goroutine",
      "item": "https://helium.github.io/posts/golang/goroutine/"
    }, 
    {
      "@type": "ListItem",
      "position":  4 ,
      "name": "go 关键字",
      "item": "https://helium.github.io/posts/golang/goroutine/newproc/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "go 关键字",
  "name": "go 关键字",
  "description": "💥本文章所有相关go代码参考自go 1.18+版本",
  "keywords": [
    "golang", "Goroutine"
  ],
  "articleBody": " go关键字流程： newproc()函数是go关键字创建goroutine的初始化函数。 也是创建第一个goroutine(runtime.main)的函数。 newproc() 该函数是整个go关键字的执行流程代码，其中包括newg的创建，newg放入P中，唤醒其他P起来工作等。 创建一个新的goroutine运行fn。把它放到等待运行的g队列中。编译器将go语句转换为对this的调用。 关于参数的说明： fn *funcval：fn是一个闭包变量。看过之前版本的该函数就会发现go A(1,2)这种形式的参数怎么处理的？ 在之前版本中该函数的形式如这func newproc(siz int32, fn *funcval)，多了一个siz参数表示参数共占多少字节。 在之前的版本中Go的传参是入栈形式的，在1.18中已经改成了寄存器传参形式。 在1.18中在A函数的外层在封装了一层闭包所以少传一个参数，go A(1,2) -\u003e go func() {A(1,2)}作为参数传入newproc函数。 fn *funcval：这里的函数原型是 func()，没有参数和返回值。 文件位置：go1.19.3/src/runtime/proc.go。 4091 4092 4093 4094 4095 4096 4097 4098 4099 4100 4101 4102 4103 4104 4105 4106 4107 4108 4109 4110 4111 4112 4113 4114 4115 4116 4117 4118 4119 4120 4121 4122 4123 4124 4125 4126 4127 4128 // Create a new g running fn. // Put it on the queue of g's waiting to run. // The compiler turns a go statement into a call to this. func newproc(fn *funcval) { // getg函数在源代码中没有对应的定义，由编译器插入类似下面两行代码 // get_tls(CX); # 获取fs寄存器地址，放入寄存器CX中，fs地址被设置成\u0026m.tls[1]处地址 // MOVQ g(CX), BX; # BX存器里面现在放的是当前g的地址，g(CX)获取fs-8位置存储数据,也就是当前执行的g，也就是m.tls[0]地址 gp := getg() // 获取当前运行的g，m.tls[0]存储的就是当前工作线程M绑定的g，也就是当前正在运行的g // getcallerpc()返回一个地址，也就是调用newproc时由call指令压栈的函数返回地址 // 对于我们现在这个场景来说，pc就是CALL runtime·newproc(SB)指令后面的POPQ AX这条指令的地址 // 主要用于新创建的 goroutine 记录自己是在哪里被创建的。 pc := getcallerpc() // systemstack的作用是切换到g0栈执行作为参数的函数 // 我们这个场景现在本身就在g0栈，因此什么也不做，直接调用作为参数的函数 systemstack(func() { // 创建一个新的goroutine并初始化，设置好栈大小执行地址和执行完返回地址 // 该闭包函数捕获fn、gp、pc三个变量 // 由于fn和gp都是指针，捕获值即可，而pc是uintptr类型，也是捕获的值 newg := newproc1(fn, gp, pc) // 由于当前在g0栈上，因此getg()获取的是g0 // getg().m 获取的是当前的工作线程M // 获取当前m绑定的P _p_ := getg().m.p.ptr() // 把newg放入_p_的运行队列，初始化的时候一定是p的本地运行队列 // 其它goroutine的时候可能因为本地队列满了而放入全局队列 runqput(_p_, newg, true) // true.放入P的第一位，false.放入P的最后一位 // mainStarted全局变量标记主线程runtime.main是否已经启动 // 即主goroutine已经开始执行，此后才会通过wakeup()函数启动新的工作线程， // 以保证main()函数总会被主线程调度执行。 if mainStarted { wakep()\t// 唤醒P } }) } systemstack() systemstack在系统栈上运行fn。 如果从per-OS-thread (g0)栈调用systemstack，或者从信号处理(gsignal)栈调用systemstack，则systemstack直接调用fn并且返回。 否则，systemstack将从普通goroutine的有限栈中调用。在这种情况下，systemstack切换到per-OS-thread栈，调用fn然后切换回来。 通常使用 fn 字面量作为参数，以便于系统栈调用周围的代码贡献输入和输出： // ... set up y ... systemstack(func() { x = bigcall(y) }) // ... use x ... go:noescape：指示编译器在编译代码时不对函数进行逃逸分析。 告诉编译器该函数不会将其参数的地址泄露到函数外部，因此可以避免逃逸分析和堆分配，从而提高代码的性能。 这个指令通常在一些需要高性能的函数中使用，如一些常用的内置函数或一些特定的库函数。 文件位置：go1.19.3/src/runtime/stubs.go。 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 // systemstack runs fn on a system stack. // If systemstack is called from the per-OS-thread (g0) stack, or // if systemstack is called from the signal handling (gsignal) stack, // systemstack calls fn directly and returns. // Otherwise, systemstack is being called from the limited stack // of an ordinary goroutine. In this case, systemstack switches // to the per-OS-thread stack, calls fn, and switches back. // It is common to use a func literal as the argument, in order // to share inputs and outputs with the code around the call // to system stack: // // ... set up y ... // systemstack(func() { // x = bigcall(y) // }) // ... use x ... // //go:noescape func systemstack(fn func()) runtime·systemstack() systemstack函数被设计用来临时性的切换至当前M的g0栈，完成某些操作后再切换回原来goroutine的栈。 该函数主要用于执行runtime中一些会触发栈增长的函数，因为goroutine的栈是被runtime管理的，所以runtime中这些逻辑就不能在普通的gorooutine上执行，以免陷入递归。 g0的栈是由操作系统分配的，可以认为空间足够大，被runtime用来执行自身逻辑非常安全。 文件位置：go1.19.3/src/runtime/asm_amd64.s。 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 # func systemstack(fn func()) TEXT runtime·systemstack(SB), NOSPLIT, $0-8 # 闭包参数 fn func()，把fn存入DI寄存器 MOVQ fn+0(FP), DI # DI = fn get_tls(CX) # CX = \u0026m.tls[1]; TLS # 这里获取的g是当前正在运行的g，可能是g0也可能不是 # 从TLS获取当前g，存入AX寄存器 MOVQ g(CX), AX # AX = g # 当前正在运行的工作线程m，将g.m存入BX寄存器中 MOVQ g_m(AX), BX # BX = m # 1) 验证数据 # 如果当前 g 是 m.gsignal # 跳转 noswitch 没有什么可做直接调用 fn 即可 # 可知m.gsignal的栈是g0栈 CMPQ AX, m_gsignal(BX) JEQ noswitch # gsignal 也是系统栈，不用切换 # 将m.g0存入DX寄存器 MOVQ m_g0(BX), DX # DX = g0 # 比较 g 和 g0，是否是一个，如果是直接跳转 noswitch # 比较当前g是不是g0 CMPQ AX, DX JEQ\tnoswitch # 已经在g0上，不需要切换 # 比较当前g是否和m.curg不一致 # 比较 g 和 m.curg，如果不相等跳转 bad # 程序刚启动初始化时m.curg为nil，会在前面的g0判断处直接跳转了，不会走到这里 # 为什么要比较crug是否是当前g?是因为从g0切换回当前g需要m.curg这个参数。 # 这种情况在普通 goroutine 切换 g0 栈时用到 CMPQ AX, m_curg(BX) JNE\tbad # 2) 存储g信息 # switch stacks # save our state in g-\u003esched. Pretend to # be systemstack_switch if the G stack is scanned. # # 将当前g的信息保存到 g-\u003esched 中。如果G栈已被扫描，则假装是 systemstack_switch 调用的。 # 保存 goroutine 的调度信息。 CALL gosave_systemstack_switch\u003c\u003e(SB) # 3) 切换到g0栈 # g0写入TLS、g0写入R14寄存器中、g0的栈顶值写入SP寄存器中 # switch to g0 MOVQ DX, g(CX) # g0写入TLS中 # R14 = g0 MOVQ DX, R14 # set the g register # BX = g0.sched.gobuf.sp MOVQ (g_sched+gobuf_sp)(DX), BX # SP = g0.sched.gobuf.sp MOVQ BX, SP # 恢复g0的SP # 4) 调用 fn 函数，此时已经切换到g0栈 # 上下文信息在DX寄存器中，包含闭包捕获的变量列表 # call target function MOVQ DI, DX # DX = fn = \u0026funcval MOVQ 0(DI), DI # DI = funcval.fn CALL DI # fn() # 5) 切换回g栈 # 注意：当从g0切换回g的时候，并没有将g0的状态保存到g0.sched中 # 也就是说每次从g0切换至其他的goroutine后，g0栈上的内容就被抛弃了 # 下次切换至g0还是从头开始。 # 从m.curg中取出g，然后写入TLS中，恢复SP寄存器的值 # 这里没有恢复PC寄存器和BP寄存器的值，因为PC寄存器的值这里不需要恢复顺序执行代码即可， # BP寄存器的值在调用systemstack()函数的整个过程中都没有修改，因此也不需要恢复。 # switch back to g get_tls(CX) # CX = \u0026m.tls[1] MOVQ g(CX), AX # AX = g0 MOVQ g_m(AX), BX # BX = m MOVQ m_curg(BX), AX # AX = m.curg; 当前g MOVQ AX, g(CX) # g存入TLS # 调用 systemstack 函数前的 SP; # R14寄存器在这个函数中没有被设置回来，应该是编译器负责设置回来吧。 MOVQ (g_sched+gobuf_sp)(AX), SP # 恢复SP; SP = g.sched.gobuf.sp MOVQ $0, (g_sched+gobuf_sp)(AX) # 清除 g.sched.gobuf.sp = 0 RET noswitch: # already on m stack; tail call the function # Using a tail call here cleans up tracebacks since we won't stop # at an intermediate systemstack. # # 已经在m栈上；由于我们不会在中间系统栈上停止，因此在这里直接调用fn MOVQ DI, DX # DX = \u0026funcval MOVQ 0(DI), DI # DI = funcval.fn JMP\tDI # 调用fn函数 bad: # Bad: g is not gsignal, not g0, not curg. What is it? # Bad：g 不是 gsignal，也不是 g0，不是 curg。它是什么？ MOVQ $runtime·badsystemstack(SB), AX CALL AX INT\t$3 # 调试错误 gosave_systemstack_switch() 保存调用者状态到g-\u003esched，但是伪装PC值从systemstack_switch函数调用的。 该函数只能从没有局部变量的（$0）的函数调用，否则systemstack_switch是不正确的。 R9寄存器的值被覆盖。 文件位置：go1.19.3/src/runtime/asm_amd64.s。 766 767 768 769 770 771 772 773 774 775 776 777 778 779 780 781 782 783 784 785 786 787 788 789 790 791 792 793 794 795 # Save state of caller into g-\u003esched, # but using fake PC from systemstack_switch. # Must only be called from functions with no locals ($0) # or else unwinding from systemstack_switch is incorrect. # Smashes R9. TEXT gosave_systemstack_switch\u003c\u003e(SB),NOSPLIT,$0 MOVQ $runtime·systemstack_switch(SB), R9 # g.sched.gobuf.pc = $runtime·systemstack_switch # 伪装当前调用是从 runtime·systemstack_switch 函数开始的。 # 从systemstack()后面的代码看出，这里的PC值没有被使用，原因是PC不需要还原设置。 # 因为systemstack()函数是闭包调用fn()函数，因此执行完后还在调用者的代码中。 MOVQ R9, (g_sched+gobuf_pc)(R14) # g.sched.gobuf.pc = runtime·systemstack_switch # 因为调用gosave_systemstack_switch()函数使用了CALL指令，所以会把返回地址压入栈中 # 因此 8(SP)的位置正好是调用者函数的栈，也就是systemstack()函数的栈 # 从systemstack()函数的函数原型可知，该函数没有分配栈大小为0，因此也是调用systemstack()函数的SP值 # 这里是newproc()函数的的栈顶的值 LEAQ 8(SP), R9 # 8(SP) 是调用者前的SP指向的值 MOVQ R9, (g_sched+gobuf_sp)(R14) # g.sched.gobuf.sp 指向调用者SP MOVQ $0, (g_sched+gobuf_ret)(R14) # g.sched.gobuf.ret = 0 # BP寄存器与SP一样，这里也是newproc()函数的栈底的值 MOVQ BP, (g_sched+gobuf_bp)(R14) # g.sched.gobuf.bp = BP; 调用者BP # Assert ctxt is zero. See func save. # # 断言 ctxt 是0。参看 func save。 # g.sched.gobuf.ctxt 存储的是闭包的上下文，也就是DX寄存器的值是函数的\u0026funcval MOVQ (g_sched+gobuf_ctxt)(R14), R9 # R9 = g.sched.gobuf.ctxt TESTQ R9, R9 JZ\t2(PC) # 判断结果为0则跳过abort()函数 CALL runtime·abort(SB) RET systemstack_switch() 文件位置：：go1.19.3/src/runtime/asm_amd64.s。 453 454 455 456 457 458 459 # systemstack_switch is a dummy routine that systemstack leaves at the bottom # of the G stack. We need to distinguish the routine that # lives at the bottom of the G stack from the one that lives # at the top of the system stack because the one at the top of # the system stack terminates the stack walk (see topofstack()). TEXT runtime·systemstack_switch(SB), NOSPLIT, $0-0 RET newproc1() 该函数主要是创建new goroutine，并设置new goroutine该从哪里进入哪里退出。 从fn开始，创建一个状态为_Grunnable的新g。 callerpc 是创建这个go语句的地址（也就是go关键字代码的下一条指针）。 调用者负责将新的g添加到调度器。 参数： fn *funcval：要执行函数的闭包。也就是go关键字后面的函数闭包，不过函数闭包原型是func()。 callergp *g：当前正在运行的goroutine。也就是调用go关键字的goroutine。 callerpc uintptr：go关键字的下一行指令地址。也就是调用go关键字后的下一条指令。 返回值：*g：新创建的goroutine。 文件位置：go1.19.3/src/runtime/proc.go。 4109 4110 4111 4112 4113 4114 4115 4116 4117 4118 4119 4120 4121 4122 4123 4124 4125 4126 4127 4128 4129 4130 4131 4132 4133 4134 4135 4136 4137 4138 4139 4140 4141 4142 4143 4144 4145 4146 4147 4148 4149 4150 4151 4152 4153 4154 4155 4156 4157 4158 4159 4160 4161 4162 4163 4164 4165 4166 4167 4168 4169 4170 4171 4172 4173 4174 4175 4176 4177 4178 4179 4180 4181 4182 4183 4184 4185 4186 4187 4188 4189 4190 4191 4192 4193 4194 4195 4196 4197 4198 4199 4200 4201 4202 4203 4204 4205 4206 4207 4208 4209 4210 4211 4212 4213 4214 4215 4216 4217 4218 4219 4220 4221 4222 4223 4224 4225 4226 4227 4228 4229 4230 4231 // Create a new g in state _Grunnable, starting at fn. callerpc is the // address of the go statement that created this. The caller is responsible // for adding the new g to the scheduler. func newproc1(fn *funcval, callergp *g, callerpc uintptr) *g { // 获取当前工作线程正在运行的g，该g是g0， // 因为newproc1()函数只会在g0栈中被调用。 _g_ := getg() // g0 // \"go nil\" 这种形式是不会允许的。 // var fn func() // nil // go fn() if fn == nil { _g_.m.throwing = -1 // do not dump full stacks throw(\"go of nil func value\") } // 禁用抢占，因为它可以在本地变量中持有p // 将当前g.m.locks++，当前g是g0。 acquirem() // disable preemption because it can be holding p in a local var // 获取当前工作线程M绑定的P _p_ := _g_.m.p.ptr() // 初始化时_p_ = g0.m.p，从前面的分析可以知道其实就是allp[0] newg := gfget(_p_) // 从P的本地缓冲里获取一个没有使用的g，初始化时没有，返回nil // 如果从当前P的空闲g链表中没有获取到g，则创建一个 if newg == nil { // new一个g结构体对象，然后从堆上为其分配栈，并设置g的stack成员和两个stackgard成员 newg = malg(_StackMin) // _StackMin = 2048 // _Gidle = 0：该状态是G刚刚被分配还没初始化时 // _Gdead = 6：该状态表示当前没有被用到，它可能刚刚完成初始化或刚刚退出运行，在一个空闲链表中。 // 注意这里是CAS操作 casgstatus(newg, _Gidle, _Gdead) // 初始化g的状态为_Gdead // 放入全局变量【allgs切片】中，新增的g全部都会加入这里，并且不会移除，这也确保GC不会去释放它们 allgadd(newg) // publishes with a g-\u003estatus of Gdead so GC scanner doesn't look at uninitialized stack. } // newg 缺少栈 if newg.stack.hi == 0 { throw(\"newproc1: newg missing stack\") } // newg 的状态应该是 _Gdead：goroutine当前没有被用到 if readgstatus(newg) != _Gdead { throw(\"newproc1: new g is not Gdead\") } // 调整goroutine的栈hi，用于 usesLR 为true时 // sys.MinFrameSize = 0; goarch.PtrSize = 8; totalSize = 32; // extra space in case of reads slightly beyond frame totalSize := uintptr(4*goarch.PtrSize + sys.MinFrameSize) // sys.StackAlign = 8; totalSize = 32; totalSize = alignUp(totalSize, sys.StackAlign) // 注意预留这32字节是从栈高地址开始的 sp := newg.stack.hi - totalSize // 预留32字节，主要用于下面usesLR spArg := sp if usesLR { // caller's LR *(*uintptr)(unsafe.Pointer(sp)) = 0 prepGoExitFrame(sp) spArg += sys.MinFrameSize } // 把newg.sched结构体成员的所有成员设置为0 // newg.sched是一个gobuf结构体，保存的CPU主要的几个寄存器的值 memclrNoHeapPointers(unsafe.Pointer(\u0026newg.sched), unsafe.Sizeof(newg.sched)) newg.sched.sp = sp // newg.sched.sp寄存器rsp得值，也就是newg的栈顶，注意这里其实指向的是rbp存储的值 newg.stktopsp = sp // 栈顶位置，该值用于回溯 // newg.sched.pc 保存的是rip寄存器的值，newg.sched.pc 表示当newg被调度起来运行时从这个地址开始执行指令 // 把pc设置成了goexit这个函数偏移1（sys.PCQuantum等于1）的位置， // 这里设置goroutine的执行地址为goexit函数的第二条指令的代码地址而不是fn.fn // 至于为什么要这么做需要等到分析完gostartcallfn函数才知道 // +PCQuantum so that previous instruction is in same function newg.sched.pc = abi.FuncPCABI0(goexit) + sys.PCQuantum newg.sched.g = guintptr(unsafe.Pointer(newg)) // 记录当前的gobuf是来自newg这个goroutine gostartcallfn(\u0026newg.sched, fn) // 该函数处理newg从哪里进入从哪里退出 newg.gopc = callerpc // 保存go关键字后的下一条代码地址，主要用于traceback newg.ancestors = saveAncestors(callergp) // 保存当前创建go关键的的goroutine // 设置newg的startpc为fn.fn，该成员主要用于函数调用栈的traceback和栈收缩 // newg真正从哪里开始执行并不依赖于这个成员，而是sched.pc newg.startpc = fn.fn // 在isSystemGoroutine中被用到 // 判断当前goroutine是否是系统goroutine // runtime.main被认为不是系统goroutine。 if isSystemGoroutine(newg, false) { // sched.ngsys：记录的是系统goroutine的数量，会被原子性的更新。 atomic.Xadd(\u0026sched.ngsys, +1) } else { // Only user goroutines inherit pprof labels. // user goroutine 继承 labels if _g_.m.curg != nil { newg.labels = _g_.m.curg.labels } } // Track initial transition? // 用于确实是否跟踪这个G newg.trackingSeq = uint8(fastrand()) // gTrackingPeriod = 8 if newg.trackingSeq%gTrackingPeriod == 0 { newg.tracking = true } // 设置g的状态为_Grunnable，表示这个g代表的goroutine可以运行了 // _Gdead = 6：该状态表示当前没有被用到，它可能刚刚完成初始化或刚刚退出运行，在一个空闲链表中。 // _Grunnable = 1：goroutine应该在某个runq中，当前并没有在运行用户代码，它的栈不归自己所有。 casgstatus(newg, _Gdead, _Grunnable) gcController.addScannableStack(_p_, int64(newg.stack.hi-newg.stack.lo)) if _p_.goidcache == _p_.goidcacheend { // Sched.goidgen is the last allocated id, // this batch must be [sched.goidgen+1, sched.goidgen+GoidCacheBatch]. // At startup sched.goidgen=0, so main goroutine receives goid=1. _p_.goidcache = atomic.Xadd64(\u0026sched.goidgen, _GoidCacheBatch) _p_.goidcache -= _GoidCacheBatch - 1 _p_.goidcacheend = _p_.goidcache + _GoidCacheBatch } // goid 表示G的唯一ID newg.goid = int64(_p_.goidcache) // 设置当前go在P中的位置 _p_.goidcache++ if raceenabled { newg.racectx = racegostart(callerpc) } if trace.enabled { traceGoCreate(newg, newg.startpc) } releasem(_g_.m) // 允许当前M被抢占 return newg } gfget() 该函数主要是从当前P空闲的G链表中获取G，或者从全局的P链表中获取G，如果本地P中没有空闲的G则从全局的P中迁移部分G放入本地非P中。 从gfree列表获取。如果局部列表为空，则从全局列表中获取一部分到本地。 参看下面\"空闲的g链表\"中的gfget函数注释，有些变化。 文件位置：go1.19.3/src/runtime/proc.go。 4282 4283 4284 4285 4286 4287 4288 4289 4290 4291 4292 4293 4294 4295 4296 4297 4298 4299 4300 4301 4302 4303 4304 4305 4306 4307 4308 4309 4310 4311 4312 4313 4314 4315 4316 4317 4318 4319 4320 4321 4322 4323 4324 4325 4326 4327 4328 4329 4330 4331 4332 // Get from gfree list. // If local list is empty, grab a batch from global list. func gfget(_p_ *p) *g { retry: // 如果当前P的gFree为空 并且 全局的gFree.stack或gFree.noStack不为空 // sched.gFree.stack 表示这里的goroutine带有栈大小的默认是2KB // sched.gFree.noStack 表示这里的goroutine没有分配栈大小，默认是0KB if _p_.gFree.empty() \u0026\u0026 (!sched.gFree.stack.empty() || !sched.gFree.noStack.empty()) { lock(\u0026sched.gFree.lock) // Move a batch of free Gs to the P. for _p_.gFree.n \u003c 32 { // 当前P的gFree的数量小于32，从sched.gFree中移动一部分到P的gFree中 // Prefer Gs with stacks. gp := sched.gFree.stack.pop() // 从ched.gFree.stack取一个G if gp == nil { // 取不到，则从sched.gFree.noStack取一个G gp = sched.gFree.noStack.pop() if gp == nil { break } } sched.gFree.n-- // 记录当前sched.gFree减一 _p_.gFree.push(gp) // 把当前取到的G加入P的gFree中 _p_.gFree.n++ // 把P的gFree的数量加一 } unlock(\u0026sched.gFree.lock) goto retry } gp := _p_.gFree.pop() // 从P中取出一个G if gp == nil { return nil } _p_.gFree.n-- // 标记当前P的gFree减一 if gp.stack.lo == 0 { // 如果当前G的栈顶为0，说明栈被释放了 // Stack was deallocated in gfput. Allocate a new one. // 堆栈在gfput()函数中被释放 分配一个新的 systemstack(func() { gp.stack = stackalloc(_FixedStack) // 重新分配栈信息 }) gp.stackguard0 = gp.stack.lo + _StackGuard // 把gp.stackguard0也执行该位置 } else { if raceenabled { racemalloc(unsafe.Pointer(gp.stack.lo), gp.stack.hi-gp.stack.lo) } if msanenabled { msanmalloc(unsafe.Pointer(gp.stack.lo), gp.stack.hi-gp.stack.lo) } if asanenabled { asanunpoison(unsafe.Pointer(gp.stack.lo), gp.stack.hi-gp.stack.lo) } } return gp } malg() 该函数主要是如果从gfget()函数中获取不到空闲的g，那么就自己分配一个，并设置栈空间 分配一个新的g，它的堆栈足够大，可以容纳stacksize字节。 文件位置：go1.19.3/src/runtime/proc.go。 4074 4075 4076 4077 4078 4079 4080 4081 4082 4083 4084 4085 4086 4087 4088 4089 4090 4091 4092 4093 4094 4095 4096 4097 // Allocate a new g, with a stack big enough for stacksize bytes. func malg(stacksize int32) *g { newg := new(g) // 创建一个G，这里是堆分配的 // 需要分配栈大小 if stacksize \u003e= 0 { // _StackSystem = 0，round2函数向上取成2的幂次方，stacksize是2KB stacksize = round2(_StackSystem + stacksize) // 计算大小2的幂次方 // 切换到g0栈，去分配栈 systemstack(func() {\t// 分配栈，goroutine在linux上默认是2KB大小 newg.stack = stackalloc(uint32(stacksize)) }) // 注意：stackguard0 = newg.stack.lo + _StackGuard 溢出警戒线 newg.stackguard0 = newg.stack.lo + _StackGuard // 设置newg.stackguard0 newg.stackguard1 = ^uintptr(0) // Clear the bottom word of the stack. We record g // there on gsignal stack during VDSO on ARM and ARM64. // // 清除堆栈的底部单词。在ARM和ARM64上进行VDSO时，我们在gsignal堆栈上记录g。 // 这里修改的是 newg.stack.lo 地址指向的值为0，不是 newg.stack.lo = 0。 *(*uintptr)(unsafe.Pointer(newg.stack.lo)) = 0 } return newg } gostartcallfn() 该函数主要作用是处理go关键注册的闭包，以及newg从哪里进入从哪里退出等。 调整gobuf，让它像执行了对fn的调用一样，然后在fn中的第一个指令之前停止。 参数： gobuf *gobuf：goroutine的调度信息。 fv *funcval：goroutine要执行的闭包。 文件位置：go1.19.3/src/runtime/stack.go。 1125 1126 1127 1128 1129 1130 1131 1132 1133 1134 1135 1136 1137 1138 1139 1140 1141 1142 1143 1144 // adjust Gobuf as if it executed a call to fn // and then stopped before the first instruction in fn. func gostartcallfn(gobuf *gobuf, fv *funcval) { var fn unsafe.Pointer\tif fv != nil { // 知道闭包的结构，知道fv.fn为注册函数的地址 // fn: gorotine的入口地址，初始化时对应的是runtime.main fn = unsafe.Pointer(fv.fn)\t} else { // //go:nosplit // func nilfunc() { // *(*uint8)(nil) = 0 // } // 如果传入【nil】的函数闭包，则封装nilfunc函数，运行起来该函数会报错。 fn = unsafe.Pointer(abi.FuncPCABIInternal(nilfunc)) } // unsafe.Pointer(fv) 作为fn的上下文环境传入 // unsafe.Pointer(fv) 会传入DX寄存器，DX寄存器用于闭包调用隐藏传值 gostartcall(gobuf, fn, unsafe.Pointer(fv))\t} gostartcall() 该函数主要数处理newg从哪里进入从哪里退出。 伪装newg注册的函数是从goexit+1代码处调用fn函数，该newg执行完后会接到执行goexit+1后面代码。 该函数是设置goroutine从哪里进入从哪里出去的关键。 参数： buf *gobuf：goroutine的调度信息。 fn unsafe.Pointer：闭包函数funcval.fn的值。 ctxt unsafe.Pointer：闭包函数funcval的地址。 文件位置：go1.19.3/src/runtime/sys_x86.go。 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 // adjust Gobuf as if it executed a call to fn with context ctxt // and then stopped before the first instruction in fn. func gostartcall(buf *gobuf, fn, ctxt unsafe.Pointer) { sp := buf.sp // buf.sp 栈开始的位置 sp -= goarch.PtrSize // 为返回地址预留8B空间 // 这里在伪装fn是被goexit()函数调用的，使得fn执行完后返回到goexit继续执行，从而完成清理工作 *(*uintptr)(unsafe.Pointer(sp)) = buf.pc // 把goexit+1代码地址放入该处，模拟是被goexit函数调用的 buf.sp = sp // 重新设置newg的栈顶寄存器 // 这里才真正让newg的ip寄存器指向fn函数，注意，这里只是在设置newg的一些信息，newg还未执行， // 等到newg被调度起来运行时，调度器会把buf.pc放入cpu的IP寄存器， // 从而使newg得以在cpu上真正的运行起来 buf.pc = uintptr(fn) // 该值用在闭包的调用 DX 寄存器需要的上下文，该值是调度起fn函数的关键 buf.ctxt = ctxt // 保存当前goroutine上下环境信息 } runtime.gpexit() 当goroutine运行完时会返回到该函数处继续运行后续收尾工作。 部分人可能担心goexit()函数加一会造成指令错乱，实际不会有问题，因为goexit()函数的代码已经考虑到这一层了。 首位各有一条NOP指令占位，所以入口地址加一后不会影响，正好对其到了接下来的CALL指令。 pc的值之所以需要是goexit()函数的地址加一，是因为这样才像是goexit()函数调用了fn()函数， 如果指向goexit()函数的起始地址就不合适了，那样goexit()函数看起来还没有执行。 文件位置：go1.19.3/src/runtime/asm_amd64.s。 1591 1592 1593 1594 1595 1596 1597 // The top-most function running on a goroutine // returns to goexit+PCQuantum. TEXT runtime·goexit(SB),NOSPLIT|TOPFRAME,$0-0 BYTE $0x90 // NOP CALL runtime·goexit1(SB) // does not return // traceback from goexit1 must hit code range of goexit BYTE $0x90 // NOP runqput() 该函数主要是把设置好的newg放入M关联的P的首位置或全局P中等待被调度器调度起来执行。 该函数也是调度循环中从全局运行g链表中取出g放入本地P调用的函数。 参数： _p_ *p：当前工作线程m绑定的P。 gp *g：新创建的goroutine。 next bool：true.表示追加到P的首位置 false.表示追加到P的末尾位置。 文件位置：go1.19.3/src/runtime/proc.go。 5780 5781 5782 5783 5784 5785 5786 5787 5788 5789 5790 5791 5792 5793 5794 5795 5796 5797 5798 5799 5800 5801 5802 5803 5804 5805 5806 5807 5808 5809 5810 5811 5812 5813 5814 5815 5816 5817 5818 5819 5820 5821 5822 5823 5824 5825 5826 5827 5828 5829 5830 5831 5832 5833 5834 5835 5836 5837 // runqput tries to put g on the local runnable queue. // If next is false, runqput adds g to the tail of the runnable queue. // If next is true, runqput puts g in the _p_.runnext slot. // If the run queue is full, runnext puts g on the global queue. // Executed only by the owner P. func runqput(_p_ *p, gp *g, next bool) { // 这里是为了曾加随机性，newg不是总存入指定位置,fastrandn(2) 取随机数对2求余 if randomizeScheduler \u0026\u0026 next \u0026\u0026 fastrandn(2) == 0 { next = false } // 如果是追加到P的首位置处 if next { retryNext: // 把gp放在_p_.runnext成员里，runnext成员中的goroutine会被优先调度起来运行 oldnext := _p_.runnext // 处理旧的将要被执行的goroutine // 使用锁的形式替换_p_.runnext的值为gp新值，如果存在其他goroutine在操作runnext成员则需要重试 if !_p_.runnext.cas(oldnext, guintptr(unsafe.Pointer(gp))) { goto retryNext } // 如果之前需要处理的goroutine为空则返回即可 if oldnext == 0 { return } // Kick the old runnext out to the regular run queue. gp = oldnext.ptr() // 获取旧的goroutine地址 } retry: // P.runqhead uint32 记录着当前goroutine队列的队列头位置 一直往上加，到最大值变为0 // P.runqtail uint32 记录着当前goroutine队列的队列尾位置 一直往上加，到最大值变为0 // P.runq [256]guintptr 使用数组实现的循环队列 // 可能有其他线程正在并发取runqhead成员，所以需要跟其它线程同步 // 这里为什么只判断_p_.runqhead那是因为所以入数据的都是从首取走的 h := atomic.LoadAcq(\u0026_p_.runqhead) // load-acquire, synchronize with consumers t := _p_.runqtail // 如果t-h \u003c 256则是没有存满，可以接到存储g if t-h \u003c uint32(len(_p_.runq)) { // 判断队列是否满了 // 队列还没存满可以放入本地P的队列中，这里放入的是t的位置处 _p_.runq[t%uint32(len(_p_.runq))].set(gp) // 虽然没有其他线程并发修改这个runqtail，但其他线程会并发读取该值以及p的runq成员 // 这里使用StoreRel是为了： // 1. 原子写入runqtail // 2. 防止编译器和CPU乱序，保证上一行代码对runq的修改发生在修改runqtail之前 // 3. 可见行屏障，保证当前线程对运行队列的修改对其他线程立马可见 atomic.StoreRel(\u0026_p_.runqtail, t+1) // store-release, makes the item available for consumption return } // P的本地运行队列已满，需要放入全局运行队列 // 如果这里返回false，则说明P的本地运行队列G中部分G被其他M偷走了，继续执行goto retry if runqputslow(_p_, gp, h, t) { return } // the queue is not full, now the put above must succeed // 队列未满，现在上面的 put 必须成功 goto retry } runqputslow() 将P得本地队列的g迁移部分到全局队列中。 文件位置：go1.19.3/src/runtime/proc.go。 5818 5819 5820 5821 5822 5823 5824 5825 5826 5827 5828 5829 5830 5831 5832 5833 5834 5835 5836 5837 5838 5839 5840 5841 5842 5843 5844 5845 5846 5847 5848 5849 5850 5851 5852 5853 5854 5855 5856 5857 5858 5859 5860 5861 5862 5863 5864 5865 5866 5867 5868 5869 5870 // Put g and a batch of work from local runnable queue on global queue. // Executed only by the owner P. func runqputslow(_p_ *p, gp *g, h, t uint32) bool { var batch [len(_p_.runq)/2 + 1]*g // gp加上_p_本地队列的一半 // First, grab a batch from local queue. n := t - h // 计算当前P中存储的数量n n = n / 2 // 取一半 if n != uint32(len(_p_.runq)/2) { // 判断P是否已满 throw(\"runqputslow: queue is not full\") } // 复制P本地队列G的一半，放入batch中 for i := uint32(0); i \u003c n; i++ { // 从P的本地队列head开头开始复制一半存入batch中 batch[i] = _p_.runq[(h+i)%uint32(len(_p_.runq))].ptr() } // 这里把_p_.runqhead值设置成h+n，并判断旧值h是否发生变化，如果发生变化则说明其他goroutine正在偷取g if !atomic.CasRel(\u0026_p_.runqhead, h, h+n) { // cas-release, commits consume // 如果cas操作失败，说明已经有其他工作线程从_p_的本地运行队列偷走一些goroutine，所以直接返回 return false } batch[n] = gp // 最后一个位置处追加gp // 增加随机性 打乱batch if randomizeScheduler { for i := uint32(1); i \u003c= n; i++ { j := fastrandn(i + 1)\t// fastrand()%n batch[i], batch[j] = batch[j], batch[i] } } // Link the goroutines. // 全局运行队列是一个链表，这里首先把所有需要放入全局运行队列的g链接起来 // 减少后面对迁居链表的锁住时间，从而降低锁冲突 // 前一个和后一个链接起来 for i := uint32(0); i \u003c n; i++ { batch[i].schedlink.set(batch[i+1]) } // type gQueue struct { // head guintptr // tail guintptr // } var q gQueue q.head.set(batch[0]) // 设置开头 q.tail.set(batch[n]) // 设置结尾 // Now put the batch on global queue. lock(\u0026sched.lock) // 锁住当前sched globrunqputbatch(\u0026q, int32(n+1)) // 拼接到全局sched.runq上去 unlock(\u0026sched.lock) // 解锁当前sched return true } globrunqputbatch() 文件位置：go1.19.3/src/runtime/proc.go。 5587 5588 5589 5590 5591 5592 5593 5594 5595 5596 5597 5598 // Put a batch of runnable goroutines on the global runnable queue. // This clears *batch. // sched.lock must be held. // May run during STW, so write barriers are not allowed. //go:nowritebarrierrec func globrunqputbatch(batch *gQueue, n int32) { assertLockHeld(\u0026sched.lock) sched.runq.pushBackAll(*batch) // 把当前batch链接到全局sched.runq上去 sched.runqsize += n // 累加当前sched.runqsize数量 *batch = gQueue{} // 清空 } acquirem() 文件位置：go1.19.3/src/runtime/runtime1.go。 473 474 475 476 477 478 //go:nosplit func acquirem() *m { _g_ := getg() _g_.m.locks++ return _g_.m } ",
  "wordCount" : "2970",
  "inLanguage": "zh",
  "image": "https://helium.github.io/favicon-32x32.png","datePublished": "2024-07-29T00:00:00Z",
  "dateModified": "2024-07-29T00:00:00Z",
  "author":[{
    "@type": "Person",
    "name": "helium"
  }],
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://helium.github.io/posts/golang/goroutine/newproc/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Helium",
    "logo": {
      "@type": "ImageObject",
      "url": "https://helium.github.io/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://helium.github.io/" accesskey="h" title="Blog (Alt + H)">
                <img src="https://helium.github.io/helium.png" alt="" aria-label="logo"
                    height="35">Blog</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://helium.github.io/" title="主页">
                    <span>Home</span>
                </a>
            </li>
            <li>
                <a href="https://helium.github.io/posts" title="文章">
                    <span>Article</span>
                </a>
            </li>
            <li>
                <a href="https://helium.github.io/archives" title="时间轴">
                    <span>Archive</span>
                </a>
            </li>
            <li>
                <a href="https://helium.github.io/tags/" title="标签">
                    <span>Tag</span>
                </a>
            </li>
            <li>
                <a href="https://helium.github.io/search/" title="搜索 (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
            <li>
                <a href="https://helium.github.io/support" title="打赏">
                    <span>🫶Help</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">


<article class="post" autonumbering>
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://helium.github.io/">主页</a>&nbsp;»&nbsp;<a href="https://helium.github.io/posts/">Article</a>&nbsp;»&nbsp;<a href="https://helium.github.io/posts/golang/">Golang</a>&nbsp;»&nbsp;<a href="https://helium.github.io/posts/golang/goroutine/">第12章 Goroutine</a></div>
    <h1 class="post-title entry-hint-parent">
      go 关键字
    </h1>
    <div class="post-description">
      💥本文章所有相关go代码参考自go 1.18&#43;版本
    </div>
    <div class="post-meta">










<span class="x-post-meta-item"><svg t="1720837714681" class="icon" viewBox="0 0 1084 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="7520" width="200" height="200"><path d="M123.47509 1023.984942a123.565437 123.565437 0 0 1-123.505206-123.32451V243.863302A123.565437 123.565437 0 0 1 123.47509 120.568908h171.630374V26.06529a26.050232 26.050232 0 0 1 52.070349 0v94.503618h377.592848V26.06529a26.050232 26.050232 0 0 1 52.100464 0v94.503618h183.797189A123.565437 123.565437 0 0 1 1084.171519 243.863302v656.79713A123.565437 123.565437 0 0 1 960.666314 1023.984942H123.47509z m-71.404741-123.32451A71.434857 71.434857 0 0 0 123.47509 971.974825h837.191224a71.434857 71.434857 0 0 0 71.404741-71.314393V442.326922l-946.361273-3.824716a25.598494 25.598494 0 0 1-5.84248-0.692665l-27.796953-6.444798v469.295689zM123.47509 172.579025a71.434857 71.434857 0 0 0-71.404741 71.284277v149.736133l27.796953-6.444797a26.080348 26.080348 0 0 1 5.902712-0.662549l946.301041 3.824716V243.863302a71.404741 71.404741 0 0 0-71.404741-71.284277h-180.183284l-6.173754 12.859479a26.200812 26.200812 0 0 1-23.490383 14.786895 26.261043 26.261043 0 0 1-23.520499-14.786895l-6.173754-12.859479H350.819834l-6.173754 12.859479a26.200812 26.200812 0 0 1-23.490383 14.786895 26.230928 26.230928 0 0 1-23.520499-14.786895l-6.173755-12.859479H123.47509z m156.150814 578.827128a26.050232 26.050232 0 0 1-26.050232-25.990001c0-14.335157 11.68496-26.020116 26.050232-26.020116h521.697312c14.365273 0 26.050232 11.68496 26.050233 26.020116a26.050232 26.050232 0 0 1-26.050233 25.990001H279.625904z" fill="#3D3F42" p-id="7521"></path></svg><span>2024-07-29</span></span>&nbsp;<span class="x-post-meta-item"><svg t="1720839329181" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="14106" width="200" height="200"><path d="M699.270662 190.485379c-0.411369 0-0.821715 0.011256-1.227967 0.032746H507.034407a23.041786 23.041786 0 0 0-1.221828-0.031723c-12.779048 0-23.140023 10.359952-23.140023 23.139 0 12.781094 10.360975 23.141046 23.140023 23.141046v0.032746h193.458083v-0.032746c12.780071 0 23.141046-10.359952 23.141047-23.141046 0-12.780071-10.360975-23.140023-23.141047-23.140023zM979.215516 724.005508c0-142.090159-115.186416-257.277598-257.277598-257.277598-72.245418 0-137.532353 29.777187-184.262654 77.725223l45.868677 31.474852c36.227086-33.873482 84.882226-54.617945 138.393977-54.617945 111.945605 0 202.696492 90.750887 202.696492 202.695468h-43.01263l70.331835 104.289228 70.331835-104.289228H979.215516z" fill="" p-id="14107"></path><path d="M748.885664 588.843132c0-14.881942-12.06785-26.945699-26.947746-26.945698-14.883989 0-26.947745 12.063757-26.947745 26.945698v135.164423c0 14.879895 12.063757 26.945699 26.947745 26.945699h107.786889c14.881942 0 26.945699-12.063757 26.945698-26.945699s-12.063757-26.945699-26.945698-26.945699h-80.839143V588.843132zM721.937918 926.702c-111.947651 0-202.696492-90.74884-202.696492-202.696492 0-0.144286 0.004093-0.285502 0.004094-0.429788h43.004443l-70.330812-104.289228-70.331835 104.289228h43.075051c0 0.144286-0.00307 0.285502-0.00307 0.429788 0 142.091182 115.187439 257.279644 257.278621 257.279645 72.241324 0 137.530306-29.77821 184.260607-77.727269l-45.86663-31.474852c-36.227086 33.873482-84.884272 54.618968-138.393977 54.618968zM694.633039 423.38066c-1.354857-11.487635-11.120268-20.400632-22.972201-20.400632H206.362486c-12.780071 0-23.140023 10.359952-23.140023 23.138999 0 12.781094 10.359952 23.141046 23.140023 23.141047H596.949252c30.209022-13.81668 63.104223-22.76754 97.683787-25.879414zM438.548616 623.143333H206.362486c-12.780071 0-23.140023 10.358929-23.140023 23.140023 0 12.780071 10.359952 23.140023 23.140023 23.140023h219.956598a298.463626 298.463626 0 0 1 12.229532-46.280046zM506.934123 513.062192H206.362486c-12.780071 0-23.140023 10.359952-23.140023 23.139 0 12.781094 10.359952 23.140023 23.140023 23.140023H469.936487a302.241672 302.241672 0 0 1 36.997636-46.279023z" fill="" p-id="14108"></path><path d="M442.765661 835.277778a298.531164 298.531164 0 0 1-14.365173-46.150087H146.542052v-0.065491c-33.036417 0-59.81941-26.78197-59.81941-59.819411V329.36031h704.907545v100.905154a298.561863 298.561863 0 0 1 46.150086 14.996552V194.619536h-0.162706c0-53.422723-43.307342-96.728018-96.730065-96.728018h-68.89409V84.418668c0-33.037441-26.782993-59.81941-59.81941-59.81941v-0.361227h-18.87079v0.032745c-33.038464 0-59.820434 26.78197-59.820433 59.819411 0 0.109494 0.008186 0.218988 0.008186 0.328481h-0.339738v13.47285H345.203648V84.418668c0-33.037441-26.782993-59.81941-59.819411-59.81941v-0.361227h-18.872836v0.032745c-33.036417 0-59.81941 26.78197-59.81941 59.819411 0 0.109494 0.007163 0.218988 0.008186 0.328481h-0.339737v13.47285h-69.189826c-53.4217 0-96.729042 43.306318-96.729041 96.728018 0 1.701758 0.045025 3.39226 0.132006 5.071505v533.785166a98.051153 98.051153 0 0 0-0.132006 5.071506c0 53.4217 43.307342 96.728018 96.729041 96.728018v0.001023h305.595047zM86.723665 204.056466c0-33.037441 26.782993-59.81941 59.819411-59.819411 0.044002 0 0.086981 0.00307 0.130983 0.00307v-0.068561h105.968473V94.874811h0.032746a22.807449 22.807449 0 0 1-0.032746-1.215688c0-12.779048 10.360975-23.140023 23.140023-23.140023s23.140023 10.360975 23.140023 23.140023c0 0.408299-0.010233 0.812505-0.031722 1.215688h0.031722v49.297776h280.508696V94.874811h0.032745a22.807449 22.807449 0 0 1-0.032745-1.215688c0-12.779048 10.361999-23.140023 23.140023-23.140023 12.780071 0 23.141046 10.360975 23.141046 23.140023 0 0.408299-0.011256 0.812505-0.032746 1.215688h0.032746v49.297776h106.10048v0.065492c33.035394 0 59.818387 26.780947 59.818387 59.81941h0.130983V283.080264H86.723665v-79.023798z" fill="" p-id="14109"></path></svg><span>2024-07-29</span></span>&nbsp;<span class="x-post-meta-item"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2" fill="none"
     stroke-linecap="round" stroke-linejoin="round" class="feather feather-file-text" style="user-select: text;">
    <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z" style="user-select: text;"></path>
    <polyline points="14 2 14 8 20 8" style="user-select: text;"></polyline>
    <line x1="16" y1="13" x2="8" y2="13" style="user-select: text;"></line>
    <line x1="16" y1="17" x2="8" y2="17" style="user-select: text;"></line>
    <polyline points="10 9 9 9 8 9" style="user-select: text;"></polyline>
</svg><span>2970字</span></span>&nbsp;<span class="x-post-meta-item"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2" fill="none"
     stroke-linecap="round" stroke-linejoin="round">
    <path stroke="none" d="M0 0h24v24H0z" fill="none"></path>
    <circle cx="12" cy="12" r="9"></circle>
    <polyline points="12 7 12 12 15 15"></polyline>
</svg><span>14分钟</span></span>&nbsp;<span class="x-post-meta-item"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2" fill="none"
     stroke-linecap="round" stroke-linejoin="round">
    <path stroke="none" d="M0 0h24v24H0z" fill="none"></path>
    <circle cx="12" cy="7" r="4"></circle>
    <path d="M6 21v-2a4 4 0 0 1 4 -4h4a4 4 0 0 1 4 4v2"></path>
</svg><span>helium</span></span>
      <span class="x-post-meta-item">
        &nbsp;<svg t="1720840393161" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="18680" width="200" height="200"><path d="M995.125144 559.61812l-415.998603-415.998602A52.986489 52.986489 0 0 0 541.413335 127.99957H338.847348c-3.166656-26.559911-9.286635-51.046495-17.999939-71.333094C299.734146 7.333309 271.154242 0 256.00096 0c-13.939953 0-40.439864 6.339979-61.259794 48.806503-10.473298 21.366595-17.946606 48.966502-21.573261 79.193067H53.334974a53.393154 53.393154 0 0 0-53.333154 53.333154v360.078791a52.986489 52.986489 0 0 0 15.619948 37.713206l415.998602 415.998603a53.333154 53.333154 0 0 0 75.426413 0l26.286579-26.293245 26.286578 26.293245a53.426487 53.426487 0 0 0 16.719944 11.333295 21.333262 21.333262 0 0 0 36.079879 11.293295l382.705381-382.705381a53.399821 53.399821 0 0 0 0-75.426413z m-762.070774-491.998347C241.494342 50.373164 250.667645 42.666523 256.00096 42.666523c5.99998 0 16.573278 9.639968 25.646581 30.806564 6.493312 15.159949 11.333295 33.999886 14.146619 54.526483H216.16776c3.206656-23.419921 9.013303-44.359851 16.88661-60.41313z m243.819181 897.330319a10.666631 10.666631 0 0 1-15.079949 0l-415.998603-415.998603A10.573298 10.573298 0 0 1 42.668343 541.411515V181.332724a10.666631 10.666631 0 0 1 10.666631-10.666631h245.332509c0 47.853173-10.373298 92.15969-27.066575 115.632945-5.926647 8.326639-16.566611 14.186619-22.306592 16.113279C204.041135 314.752276 170.667913 356.218803 170.667913 405.331972c0 58.813136 47.853173 106.666308 106.666309 106.666308s106.666308-47.853173 106.666308-106.666308c0-47.086508-30.666564-87.139707-73.079754-101.246327C330.060711 272.705751 341.334007 223.692582 341.334007 170.666093h72.079758a10.573298 10.573298 0 0 1 7.539974 3.126656l415.998603 415.998603a10.666631 10.666631 0 0 1 0 15.079949zM341.334007 405.331972a63.999785 63.999785 0 1 1-63.999785-63.999785 64.073118 64.073118 0 0 1 63.999785 63.999785z m263.539114 559.61812a10.666631 10.666631 0 0 1-15.079949 0L563.499927 938.663513l303.625647-303.61898a53.399821 53.399821 0 0 0 0-75.426413L478.16688 170.666093h63.246455a10.573298 10.573298 0 0 1 7.539974 3.126656l415.998603 415.998603c0.239999 0.239999 0.466665 0.486665 0.666664 0.746664l0.086667 0.106666a10.666631 10.666631 0 0 1 0 13.373289l-0.086667 0.106666c-0.213333 0.259999-0.439999 0.506665-0.666664 0.746664z" fill="#5C5C66" p-id="18681"></path></svg>
        <ul class="post-tags-meta" style="display: inline-block;font-size: 14px;">
            <a href="https://helium.github.io/tags/golang/" target="_blank" rel="noopener">Golang</a>
            <a href="https://helium.github.io/tags/goroutine/" target="_blank" rel="noopener">Goroutine</a>
        </ul>
      </span>
      
      <span id="busuanzi_container_page_pv" class="x-post-meta-item">
        &nbsp;<svg t="1720844685710" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="27237" width="200" height="200"><path d="M739.754667 574.08c-121.386667 45.610667-208.469333 169.813333-208.64 316.16 0 33.408 4.693333 65.493333 13.141333 95.914667H94.122667c-26.453333-43.52-41.685333-91.946667-41.685334-143.189334 0-185.173333 192.896-335.104 430.805334-335.104 96.256 0 184.832 24.746667 256.512 66.218667z m-280.490667-114.986667a214.869333 214.869333 0 0 1-214.869333-215.04A215.04 215.04 0 0 1 459.264 28.842667a215.04 215.04 0 0 1 215.04 215.210666 215.04 215.04 0 0 1-215.04 215.04zM974.506667 641.28c9.856 0 17.834667 7.466667 17.834666 16.64v59.989333c-0.341333 8.789333-7.850667 15.786667-17.28 16.085334-9.856 0.341333-18.176-6.826667-18.517333-16.085334v-20.053333l-99.114667 91.093333-0.256 0.256a18.474667 18.474667 0 0 1-14.848 4.352h-0.768a18.176 18.176 0 0 1-9.344-4.608l-0.938666-0.981333-85.930667-80.042667-123.562667 115.072a18.773333 18.773333 0 0 1-25.216 0 15.786667 15.786667 0 0 1 0-23.466666l136.149334-126.848 0.725333-0.597334a18.645333 18.645333 0 0 1 24.362667 0.512l87.253333 81.237334 86.058667-79.232h-21.248c-9.386667-0.298667-16.938667-7.338667-17.28-16.085334-0.341333-9.173333 7.381333-16.896 17.28-17.237333h64.64z m-367.146667 240h48.128c8.874667 0 16.042667 7.168 16.042667 16.042667v72.192a16.042667 16.042667 0 0 1-16.042667 16.042666h-48.128a16.042667 16.042667 0 0 1-16.042667-16.042666v-72.192c0-8.874667 7.210667-16.042667 16.042667-16.042667z m110.805333-106.666667h48.128c8.874667 0 16.042667 7.168 16.042667 16.042667v178.858667a16.042667 16.042667 0 0 1-16.042667 16.042666h-48.128a16.042667 16.042667 0 0 1-16.042666-16.042666v-178.858667c0-8.874667 7.168-16.042667 16.042666-16.042667z m106.538667 80h48.128c8.874667 0 16.042667 7.168 16.042667 16.042667v99.413333a16.042667 16.042667 0 0 1-16.042667 16.042667H824.746667a16.042667 16.042667 0 0 1-16.042667-16.042667v-99.413333c0-8.874667 7.168-16.042667 16.042667-16.042667z m110.165333-80h48.128c8.874667 0 16.042667 7.168 16.042667 16.042667v179.413333a16.042667 16.042667 0 0 1-16.042667 16.042667h-48.128a16.042667 16.042667 0 0 1-16.042666-16.042667v-179.413333c0-8.874667 7.210667-16.042667 16.042666-16.042667z" fill="#999999" p-id="27238"></path></svg>
        <span id="busuanzi_value_page_pv"></span>
      </span>

</div>
  </header> <aside id="toc-container" class="toc-container wide">
    <div class="toc">
        <details  open>
            <summary accesskey="c" title="(Alt + C)">
                <span class="details">目录</span>
            </summary>

            <div class="inner"><ul>
                    <li>
                        <a href="#newproc" aria-label="newproc()">newproc()</a><ul>
                            
                    <li>
                        <a href="#systemstack" aria-label="systemstack()">systemstack()</a></li>
                    <li>
                        <a href="#runtimesystemstack" aria-label="runtime·systemstack()">runtime·systemstack()</a></li>
                    <li>
                        <a href="#gosave_systemstack_switch" aria-label="gosave_systemstack_switch()">gosave_systemstack_switch()</a></li>
                    <li>
                        <a href="#systemstack_switch" aria-label="systemstack_switch()">systemstack_switch()</a></li></ul>
                    </li>
                    <li>
                        <a href="#newproc1" aria-label="newproc1()">newproc1()</a><ul>
                            
                    <li>
                        <a href="#gfget" aria-label="gfget()">gfget()</a></li>
                    <li>
                        <a href="#malg" aria-label="malg()">malg()</a></li>
                    <li>
                        <a href="#gostartcallfn" aria-label="gostartcallfn()">gostartcallfn()</a></li>
                    <li>
                        <a href="#runtimegpexit" aria-label="runtime.gpexit()">runtime.gpexit()</a></li></ul>
                    </li>
                    <li>
                        <a href="#runqput" aria-label="runqput()">runqput()</a><ul>
                            
                    <li>
                        <a href="#runqputslow" aria-label="runqputslow()">runqputslow()</a></li>
                    <li>
                        <a href="#globrunqputbatch" aria-label="globrunqputbatch()">globrunqputbatch()</a></li>
                    <li>
                        <a href="#acquirem" aria-label="acquirem()">acquirem()</a>
                    </li>
                </ul>
                </li>
                </ul>
            </div>
        </details>
    </div>
</aside>
<script>
    let activeElement;
    let elements;
    window.addEventListener('DOMContentLoaded', function (event) {
        checkTocPosition();

        elements = document.querySelectorAll('h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]');
         
         activeElement = elements[0];
         const id = encodeURI(activeElement.getAttribute('id')).toLowerCase();
         document.querySelector(`.inner ul li a[href="#${id}"]`).classList.add('active');
     }, false);

    window.addEventListener('resize', function(event) {
        checkTocPosition();
    }, false);

    window.addEventListener('scroll', () => {
        
        activeElement = Array.from(elements).find((element) => {
            if ((getOffsetTop(element) - window.pageYOffset) > 0 && 
                (getOffsetTop(element) - window.pageYOffset) < window.innerHeight/2) {
                return element;
            }
        }) || activeElement

        elements.forEach(element => {
             const id = encodeURI(element.getAttribute('id')).toLowerCase();
             if (element === activeElement){
                 document.querySelector(`.inner ul li a[href="#${id}"]`).classList.add('active');
             } else {
                 document.querySelector(`.inner ul li a[href="#${id}"]`).classList.remove('active');
             }
         })
     }, false);

    const main = parseInt(getComputedStyle(document.body).getPropertyValue('--article-width'), 10);
    const toc = parseInt(getComputedStyle(document.body).getPropertyValue('--toc-width'), 10);
    const gap = parseInt(getComputedStyle(document.body).getPropertyValue('--gap'), 10);

    function checkTocPosition() {
        const width = document.body.scrollWidth;

        if (width - main - (toc * 2) - (gap * 4) > 0) {
            document.getElementById("toc-container").classList.add("wide");
        } else {
            document.getElementById("toc-container").classList.remove("wide");
        }
    }

    function getOffsetTop(element) {
        if (!element.getClientRects().length) {
            return 0;
        }
        let rect = element.getBoundingClientRect();
        let win = element.ownerDocument.defaultView;
        return rect.top + win.pageYOffset;   
    }
</script>
  <div class="post-content"><ul>
<li><code>go</code>关键字流程：
<ul>
<li><code>newproc()</code>函数是<code>go</code>关键字创建<code>goroutine</code>的初始化函数。</li>
<li>也是创建第一个<code>goroutine(runtime.main)</code>的函数。</li>
</ul>
</li>
</ul>
<h2 id="newproc">newproc()<a hidden class="anchor" aria-hidden="true" href="#newproc">#</a></h2>
<ol>
<li>该函数是整个<code>go</code>关键字的执行流程代码，其中包括<code>newg</code>的创建，<code>newg</code>放入<code>P</code>中，唤醒其他<code>P</code>起来工作等。</li>
<li>创建一个新的<code>goroutine</code>运行<code>fn</code>。把它放到等待运行的<code>g</code>队列中。编译器将<code>go</code>语句转换为对<code>this</code>的调用。</li>
<li>关于参数的说明：
<ol>
<li><strong><code>fn *funcval</code></strong>：<code>fn</code>是一个闭包变量。看过之前版本的该函数就会发现<code>go A(1,2)</code>这种形式的参数怎么处理的？</li>
<li>在之前版本中该函数的形式如这<code>func newproc(siz int32, fn *funcval)</code>，多了一个<code>siz</code>参数表示参数共占多少字节。</li>
<li>在之前的版本中<code>Go</code>的传参是入栈形式的，在1.18中已经改成了寄存器传参形式。</li>
<li>在1.18中在<code>A</code>函数的外层在封装了一层闭包所以少传一个参数，<code>go A(1,2) -&gt; go func() {A(1,2)}</code>作为参数传入<code>newproc</code>函数。</li>
</ol>
</li>
<li><code>fn *funcval</code>：这里的函数原型是 <strong><code>func()</code></strong>，没有参数和返回值。</li>
<li>文件位置：<code>go1.19.3/src/runtime/proc.go</code>。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">4091
</span><span class="lnt">4092
</span><span class="lnt">4093
</span><span class="lnt">4094
</span><span class="lnt">4095
</span><span class="lnt">4096
</span><span class="lnt">4097
</span><span class="lnt">4098
</span><span class="lnt">4099
</span><span class="lnt">4100
</span><span class="lnt">4101
</span><span class="lnt">4102
</span><span class="lnt">4103
</span><span class="lnt">4104
</span><span class="lnt">4105
</span><span class="lnt">4106
</span><span class="lnt">4107
</span><span class="lnt">4108
</span><span class="lnt">4109
</span><span class="lnt">4110
</span><span class="lnt">4111
</span><span class="lnt">4112
</span><span class="lnt">4113
</span><span class="lnt">4114
</span><span class="lnt">4115
</span><span class="lnt">4116
</span><span class="lnt">4117
</span><span class="lnt">4118
</span><span class="lnt">4119
</span><span class="lnt">4120
</span><span class="lnt">4121
</span><span class="lnt">4122
</span><span class="lnt">4123
</span><span class="lnt">4124
</span><span class="lnt">4125
</span><span class="lnt">4126
</span><span class="lnt">4127
</span><span class="lnt">4128
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// Create a new g running fn.
</span></span></span><span class="line"><span class="cl"><span class="c1">// Put it on the queue of g&#39;s waiting to run.
</span></span></span><span class="line"><span class="cl"><span class="c1">// The compiler turns a go statement into a call to this.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">newproc</span><span class="p">(</span><span class="nx">fn</span> <span class="o">*</span><span class="nx">funcval</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// getg函数在源代码中没有对应的定义，由编译器插入类似下面两行代码
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// get_tls(CX);    # 获取fs寄存器地址，放入寄存器CX中，fs地址被设置成&amp;m.tls[1]处地址
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// MOVQ g(CX), BX; # BX存器里面现在放的是当前g的地址，g(CX)获取fs-8位置存储数据,也就是当前执行的g，也就是m.tls[0]地址
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">gp</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">()</span> <span class="c1">// 获取当前运行的g，m.tls[0]存储的就是当前工作线程M绑定的g，也就是当前正在运行的g
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    
</span></span><span class="line"><span class="cl">    <span class="c1">// getcallerpc()返回一个地址，也就是调用newproc时由call指令压栈的函数返回地址
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 对于我们现在这个场景来说，pc就是CALL runtime·newproc(SB)指令后面的POPQ AX这条指令的地址
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 主要用于新创建的 goroutine 记录自己是在哪里被创建的。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">pc</span> <span class="o">:=</span> <span class="nf">getcallerpc</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c1">// systemstack的作用是切换到g0栈执行作为参数的函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 我们这个场景现在本身就在g0栈，因此什么也不做，直接调用作为参数的函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">systemstack</span><span class="p">(</span><span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 创建一个新的goroutine并初始化，设置好栈大小执行地址和执行完返回地址
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 该闭包函数捕获fn、gp、pc三个变量
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 由于fn和gp都是指针，捕获值即可，而pc是uintptr类型，也是捕获的值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">newg</span> <span class="o">:=</span> <span class="nf">newproc1</span><span class="p">(</span><span class="nx">fn</span><span class="p">,</span> <span class="nx">gp</span><span class="p">,</span> <span class="nx">pc</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">        <span class="c1">// 由于当前在g0栈上，因此getg()获取的是g0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// getg().m 获取的是当前的工作线程M
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 获取当前m绑定的P
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">_p_</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">().</span><span class="nx">m</span><span class="p">.</span><span class="nx">p</span><span class="p">.</span><span class="nf">ptr</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 把newg放入_p_的运行队列，初始化的时候一定是p的本地运行队列
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 其它goroutine的时候可能因为本地队列满了而放入全局队列
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nf">runqput</span><span class="p">(</span><span class="nx">_p_</span><span class="p">,</span> <span class="nx">newg</span><span class="p">,</span> <span class="kc">true</span><span class="p">)</span> <span class="c1">// true.放入P的第一位，false.放入P的最后一位
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">        <span class="c1">// mainStarted全局变量标记主线程runtime.main是否已经启动
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 即主goroutine已经开始执行，此后才会通过wakeup()函数启动新的工作线程，
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 以保证main()函数总会被主线程调度执行。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="nx">mainStarted</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nf">wakep</span><span class="p">()</span>	<span class="c1">// 唤醒P
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">})</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="systemstack">systemstack()<a hidden class="anchor" aria-hidden="true" href="#systemstack">#</a></h3>
<ol>
<li><code>systemstack</code>在系统栈上运行<code>fn</code>。</li>
<li>如果从<code>per-OS-thread (g0)</code>栈调用<code>systemstack</code>，或者从信号处理(<code>gsignal</code>)栈调用<code>systemstack</code>，则<code>systemstack</code>直接调用<code>fn</code>并且返回。</li>
<li>否则，<code>systemstack</code>将从普通<code>goroutine</code>的有限栈中调用。在这种情况下，<code>systemstack</code>切换到<code>per-OS-thread</code>栈，调用<code>fn</code>然后切换回来。</li>
<li>通常使用 <code>fn</code> 字面量作为参数，以便于系统栈调用周围的代码贡献输入和输出：</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">//  ... set up y ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nf">systemstack</span><span class="p">(</span><span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">x</span> <span class="p">=</span> <span class="nf">bigcall</span><span class="p">(</span><span class="nx">y</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">})</span>
</span></span><span class="line"><span class="cl"><span class="c1">//  ... use x ...
</span></span></span></code></pre></div><ol start="5">
<li><code>go:noescape</code>：指示编译器在编译代码时不对函数进行逃逸分析。</li>
<li>告诉编译器该函数不会将其参数的地址泄露到函数外部，因此可以避免逃逸分析和堆分配，从而提高代码的性能。</li>
<li>这个指令通常在一些需要高性能的函数中使用，如一些常用的内置函数或一些特定的库函数。</li>
<li>文件位置：<code>go1.19.3/src/runtime/stubs.go</code>。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// systemstack runs fn on a system stack.
</span></span></span><span class="line"><span class="cl"><span class="c1">// If systemstack is called from the per-OS-thread (g0) stack, or
</span></span></span><span class="line"><span class="cl"><span class="c1">// if systemstack is called from the signal handling (gsignal) stack,
</span></span></span><span class="line"><span class="cl"><span class="c1">// systemstack calls fn directly and returns.
</span></span></span><span class="line"><span class="cl"><span class="c1">// Otherwise, systemstack is being called from the limited stack
</span></span></span><span class="line"><span class="cl"><span class="c1">// of an ordinary goroutine. In this case, systemstack switches
</span></span></span><span class="line"><span class="cl"><span class="c1">// to the per-OS-thread stack, calls fn, and switches back.
</span></span></span><span class="line"><span class="cl"><span class="c1">// It is common to use a func literal as the argument, in order
</span></span></span><span class="line"><span class="cl"><span class="c1">// to share inputs and outputs with the code around the call
</span></span></span><span class="line"><span class="cl"><span class="c1">// to system stack:
</span></span></span><span class="line"><span class="cl"><span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1">//  ... set up y ...
</span></span></span><span class="line"><span class="cl"><span class="c1">//  systemstack(func() {
</span></span></span><span class="line"><span class="cl"><span class="c1">//      x = bigcall(y)
</span></span></span><span class="line"><span class="cl"><span class="c1">//  })
</span></span></span><span class="line"><span class="cl"><span class="c1">//  ... use x ...
</span></span></span><span class="line"><span class="cl"><span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1">//go:noescape
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">systemstack</span><span class="p">(</span><span class="nx">fn</span> <span class="kd">func</span><span class="p">())</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="runtimesystemstack">runtime·systemstack()<a hidden class="anchor" aria-hidden="true" href="#runtimesystemstack">#</a></h3>
<ol>
<li><code>systemstack</code>函数被设计用来临时性的切换至当前<code>M</code>的<code>g0</code>栈，完成某些操作后再切换回原来<code>goroutine</code>的栈。</li>
<li>该函数主要用于执行<code>runtime</code>中一些会触发<strong>栈增长</strong>的函数，因为<code>goroutine</code>的栈是被<code>runtime</code>管理的，所以<code>runtime</code>中这些逻辑就不能在普通的<code>gorooutine</code>上执行，以免陷入递归。</li>
<li><code>g0</code>的栈是由操作系统分配的，可以认为空间足够大，被<code>runtime</code>用来执行自身逻辑非常安全。</li>
<li>文件位置：<code>go1.19.3/src/runtime/asm_amd64.s</code>。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">461
</span><span class="lnt">462
</span><span class="lnt">463
</span><span class="lnt">464
</span><span class="lnt">465
</span><span class="lnt">466
</span><span class="lnt">467
</span><span class="lnt">468
</span><span class="lnt">469
</span><span class="lnt">470
</span><span class="lnt">471
</span><span class="lnt">472
</span><span class="lnt">473
</span><span class="lnt">474
</span><span class="lnt">475
</span><span class="lnt">476
</span><span class="lnt">477
</span><span class="lnt">478
</span><span class="lnt">479
</span><span class="lnt">480
</span><span class="lnt">481
</span><span class="lnt">482
</span><span class="lnt">483
</span><span class="lnt">484
</span><span class="lnt">485
</span><span class="lnt">486
</span><span class="lnt">487
</span><span class="lnt">488
</span><span class="lnt">489
</span><span class="lnt">490
</span><span class="lnt">491
</span><span class="lnt">492
</span><span class="lnt">493
</span><span class="lnt">494
</span><span class="lnt">495
</span><span class="lnt">496
</span><span class="lnt">497
</span><span class="lnt">498
</span><span class="lnt">499
</span><span class="lnt">500
</span><span class="lnt">501
</span><span class="lnt">502
</span><span class="lnt">503
</span><span class="lnt">504
</span><span class="lnt">505
</span><span class="lnt">506
</span><span class="lnt">507
</span><span class="lnt">508
</span><span class="lnt">509
</span><span class="lnt">510
</span><span class="lnt">511
</span><span class="lnt">512
</span><span class="lnt">513
</span><span class="lnt">514
</span><span class="lnt">515
</span><span class="lnt">516
</span><span class="lnt">517
</span><span class="lnt">518
</span><span class="lnt">519
</span><span class="lnt">520
</span><span class="lnt">521
</span><span class="lnt">522
</span><span class="lnt">523
</span><span class="lnt">524
</span><span class="lnt">525
</span><span class="lnt">526
</span><span class="lnt">527
</span><span class="lnt">528
</span><span class="lnt">529
</span><span class="lnt">530
</span><span class="lnt">531
</span><span class="lnt">532
</span><span class="lnt">533
</span><span class="lnt">534
</span><span class="lnt">535
</span><span class="lnt">536
</span><span class="lnt">537
</span><span class="lnt">538
</span><span class="lnt">539
</span><span class="lnt">540
</span><span class="lnt">541
</span><span class="lnt">542
</span><span class="lnt">543
</span><span class="lnt">544
</span><span class="lnt">545
</span><span class="lnt">546
</span><span class="lnt">547
</span><span class="lnt">548
</span><span class="lnt">549
</span><span class="lnt">550
</span><span class="lnt">551
</span><span class="lnt">552
</span><span class="lnt">553
</span><span class="lnt">554
</span><span class="lnt">555
</span><span class="lnt">556
</span><span class="lnt">557
</span><span class="lnt">558
</span><span class="lnt">559
</span><span class="lnt">560
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-asm" data-lang="asm"><span class="line"><span class="cl"><span class="c1"># func systemstack(fn func())
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nf">TEXT</span> <span class="no">runtime</span><span class="err">·</span><span class="no">systemstack</span><span class="p">(</span><span class="no">SB</span><span class="p">),</span> <span class="no">NOSPLIT</span><span class="p">,</span> <span class="no">$0-8</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># 闭包参数 fn func()，把fn存入DI寄存器
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">MOVQ</span>    <span class="no">fn</span><span class="err">+</span><span class="mi">0</span><span class="p">(</span><span class="no">FP</span><span class="p">),</span> <span class="no">DI</span>    <span class="c1"># DI = fn
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">get_tls</span><span class="p">(</span><span class="no">CX</span><span class="p">)</span>             <span class="c1"># CX = &amp;m.tls[1]; TLS
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1"># 这里获取的g是当前正在运行的g，可能是g0也可能不是
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1"># 从TLS获取当前g，存入AX寄存器
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">MOVQ</span>    <span class="no">g</span><span class="p">(</span><span class="no">CX</span><span class="p">),</span> <span class="no">AX</span>       <span class="c1"># AX = g
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1"># 当前正在运行的工作线程m，将g.m存入BX寄存器中
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">MOVQ</span>    <span class="no">g_m</span><span class="p">(</span><span class="no">AX</span><span class="p">),</span> <span class="no">BX</span>     <span class="c1"># BX = m
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    
</span></span><span class="line"><span class="cl">    <span class="c1"># 1) 验证数据
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    
</span></span><span class="line"><span class="cl">    <span class="c1"># 如果当前 g 是 m.gsignal
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1"># 跳转 noswitch 没有什么可做直接调用 fn 即可
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1"># 可知m.gsignal的栈是g0栈
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">CMPQ</span>    <span class="no">AX</span><span class="p">,</span> <span class="no">m_gsignal</span><span class="p">(</span><span class="no">BX</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nf">JEQ</span> <span class="no">noswitch</span> <span class="c1"># gsignal 也是系统栈，不用切换
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="c1"># 将m.g0存入DX寄存器
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">MOVQ</span>    <span class="no">m_g0</span><span class="p">(</span><span class="no">BX</span><span class="p">),</span> <span class="no">DX</span>    <span class="c1"># DX = g0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1"># 比较 g 和 g0，是否是一个，如果是直接跳转 noswitch
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1"># 比较当前g是不是g0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">CMPQ</span>    <span class="no">AX</span><span class="p">,</span> <span class="no">DX</span>
</span></span><span class="line"><span class="cl">    <span class="nf">JEQ</span>	<span class="no">noswitch</span> <span class="c1"># 已经在g0上，不需要切换
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    
</span></span><span class="line"><span class="cl">    <span class="c1"># 比较当前g是否和m.curg不一致
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1"># 比较 g 和 m.curg，如果不相等跳转 bad
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1"># 程序刚启动初始化时m.curg为nil，会在前面的g0判断处直接跳转了，不会走到这里
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1"># 为什么要比较crug是否是当前g?是因为从g0切换回当前g需要m.curg这个参数。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1"># 这种情况在普通 goroutine 切换 g0 栈时用到
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">CMPQ</span>    <span class="no">AX</span><span class="p">,</span> <span class="no">m_curg</span><span class="p">(</span><span class="no">BX</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nf">JNE</span>	<span class="no">bad</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1"># 2) 存储g信息
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="c1"># switch stacks
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1"># save our state in g-&gt;sched. Pretend to
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1"># be systemstack_switch if the G stack is scanned.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1"># 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1"># 将当前g的信息保存到 g-&gt;sched 中。如果G栈已被扫描，则假装是 systemstack_switch 调用的。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1"># 保存 goroutine 的调度信息。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">CALL</span>    <span class="no">gosave_systemstack_switch</span><span class="err">&lt;&gt;</span><span class="p">(</span><span class="no">SB</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1"># 3) 切换到g0栈
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1"># g0写入TLS、g0写入R14寄存器中、g0的栈顶值写入SP寄存器中
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="c1"># switch to g0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">MOVQ</span>    <span class="no">DX</span><span class="p">,</span> <span class="no">g</span><span class="p">(</span><span class="no">CX</span><span class="p">)</span>  <span class="c1"># g0写入TLS中
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1"># R14 = g0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">MOVQ</span>    <span class="no">DX</span><span class="p">,</span> <span class="no">R14</span> <span class="c1"># set the g register
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1"># BX = g0.sched.gobuf.sp
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">MOVQ</span>    <span class="p">(</span><span class="no">g_sched</span><span class="err">+</span><span class="no">gobuf_sp</span><span class="p">)(</span><span class="no">DX</span><span class="p">),</span> <span class="no">BX</span> 
</span></span><span class="line"><span class="cl">    <span class="c1"># SP = g0.sched.gobuf.sp
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">MOVQ</span>    <span class="no">BX</span><span class="p">,</span> <span class="no">SP</span> <span class="c1"># 恢复g0的SP
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="c1"># 4) 调用 fn 函数，此时已经切换到g0栈
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1"># 上下文信息在DX寄存器中，包含闭包捕获的变量列表
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="c1"># call target function
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">MOVQ</span>    <span class="no">DI</span><span class="p">,</span> <span class="no">DX</span>      <span class="c1"># DX = fn = &amp;funcval
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">MOVQ</span>    <span class="mi">0</span><span class="p">(</span><span class="no">DI</span><span class="p">),</span> <span class="no">DI</span>   <span class="c1"># DI = funcval.fn
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">CALL</span>    <span class="no">DI</span>          <span class="c1"># fn()
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="c1"># 5) 切换回g栈
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1"># 注意：当从g0切换回g的时候，并没有将g0的状态保存到g0.sched中
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1"># 也就是说每次从g0切换至其他的goroutine后，g0栈上的内容就被抛弃了
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1"># 下次切换至g0还是从头开始。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1"># 从m.curg中取出g，然后写入TLS中，恢复SP寄存器的值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1"># 这里没有恢复PC寄存器和BP寄存器的值，因为PC寄存器的值这里不需要恢复顺序执行代码即可，
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1"># BP寄存器的值在调用systemstack()函数的整个过程中都没有修改，因此也不需要恢复。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="c1"># switch back to g
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">get_tls</span><span class="p">(</span><span class="no">CX</span><span class="p">)</span>             <span class="c1"># CX = &amp;m.tls[1]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">MOVQ</span>    <span class="no">g</span><span class="p">(</span><span class="no">CX</span><span class="p">),</span> <span class="no">AX</span>       <span class="c1"># AX = g0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">MOVQ</span>    <span class="no">g_m</span><span class="p">(</span><span class="no">AX</span><span class="p">),</span> <span class="no">BX</span>     <span class="c1"># BX = m
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">MOVQ</span>    <span class="no">m_curg</span><span class="p">(</span><span class="no">BX</span><span class="p">),</span> <span class="no">AX</span>  <span class="c1"># AX = m.curg; 当前g
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">MOVQ</span>    <span class="no">AX</span><span class="p">,</span> <span class="no">g</span><span class="p">(</span><span class="no">CX</span><span class="p">)</span>       <span class="c1"># g存入TLS
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1"># 调用 systemstack 函数前的 SP;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1"># R14寄存器在这个函数中没有被设置回来，应该是编译器负责设置回来吧。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">MOVQ</span>    <span class="p">(</span><span class="no">g_sched</span><span class="err">+</span><span class="no">gobuf_sp</span><span class="p">)(</span><span class="no">AX</span><span class="p">),</span> <span class="no">SP</span> <span class="c1"># 恢复SP; SP = g.sched.gobuf.sp
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">MOVQ</span>    <span class="no">$0</span><span class="p">,</span> <span class="p">(</span><span class="no">g_sched</span><span class="err">+</span><span class="no">gobuf_sp</span><span class="p">)(</span><span class="no">AX</span><span class="p">)</span> <span class="c1"># 清除 g.sched.gobuf.sp = 0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">RET</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nl">noswitch:</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># already on m stack; tail call the function
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1"># Using a tail call here cleans up tracebacks since we won&#39;t stop
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1"># at an intermediate systemstack.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1"># 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1"># 已经在m栈上；由于我们不会在中间系统栈上停止，因此在这里直接调用fn
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">MOVQ</span>    <span class="no">DI</span><span class="p">,</span> <span class="no">DX</span>      <span class="c1"># DX = &amp;funcval
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">MOVQ</span>    <span class="mi">0</span><span class="p">(</span><span class="no">DI</span><span class="p">),</span> <span class="no">DI</span>   <span class="c1"># DI = funcval.fn
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">JMP</span>	<span class="no">DI</span> <span class="c1"># 调用fn函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="nl">bad:</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># Bad: g is not gsignal, not g0, not curg. What is it?
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1"># Bad：g 不是 gsignal，也不是 g0，不是 curg。它是什么？
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">MOVQ</span>    <span class="no">$runtime</span><span class="err">·</span><span class="no">badsystemstack</span><span class="p">(</span><span class="no">SB</span><span class="p">),</span> <span class="no">AX</span>
</span></span><span class="line"><span class="cl">    <span class="nf">CALL</span>    <span class="no">AX</span>
</span></span><span class="line"><span class="cl">    <span class="nf">INT</span>	<span class="no">$3</span>  <span class="c1"># 调试错误
</span></span></span></code></pre></td></tr></table>
</div>
</div><p><img loading="lazy" src="../images/goroutine-011.png" alt=""  />
</p>
<h3 id="gosave_systemstack_switch">gosave_systemstack_switch()<a hidden class="anchor" aria-hidden="true" href="#gosave_systemstack_switch">#</a></h3>
<ol>
<li>保存调用者状态到<code>g-&gt;sched</code>，但是伪装<code>PC</code>值从<code>systemstack_switch</code>函数调用的。</li>
<li>该函数只能从没有局部变量的（<code>$0</code>）的函数调用，否则<code>systemstack_switch</code>是不正确的。</li>
<li><code>R9</code>寄存器的值被覆盖。</li>
<li>文件位置：<code>go1.19.3/src/runtime/asm_amd64.s</code>。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">766
</span><span class="lnt">767
</span><span class="lnt">768
</span><span class="lnt">769
</span><span class="lnt">770
</span><span class="lnt">771
</span><span class="lnt">772
</span><span class="lnt">773
</span><span class="lnt">774
</span><span class="lnt">775
</span><span class="lnt">776
</span><span class="lnt">777
</span><span class="lnt">778
</span><span class="lnt">779
</span><span class="lnt">780
</span><span class="lnt">781
</span><span class="lnt">782
</span><span class="lnt">783
</span><span class="lnt">784
</span><span class="lnt">785
</span><span class="lnt">786
</span><span class="lnt">787
</span><span class="lnt">788
</span><span class="lnt">789
</span><span class="lnt">790
</span><span class="lnt">791
</span><span class="lnt">792
</span><span class="lnt">793
</span><span class="lnt">794
</span><span class="lnt">795
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-asm" data-lang="asm"><span class="line"><span class="cl"><span class="c1"># Save state of caller into g-&gt;sched,
</span></span></span><span class="line"><span class="cl"><span class="c1"># but using fake PC from systemstack_switch.
</span></span></span><span class="line"><span class="cl"><span class="c1"># Must only be called from functions with no locals ($0)
</span></span></span><span class="line"><span class="cl"><span class="c1"># or else unwinding from systemstack_switch is incorrect.
</span></span></span><span class="line"><span class="cl"><span class="c1"># Smashes R9.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nf">TEXT</span> <span class="no">gosave_systemstack_switch</span><span class="err">&lt;&gt;</span><span class="p">(</span><span class="no">SB</span><span class="p">),</span><span class="no">NOSPLIT</span><span class="p">,</span><span class="no">$0</span>
</span></span><span class="line"><span class="cl">    <span class="nf">MOVQ</span>    <span class="no">$runtime</span><span class="err">·</span><span class="no">systemstack_switch</span><span class="p">(</span><span class="no">SB</span><span class="p">),</span> <span class="no">R9</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># g.sched.gobuf.pc = $runtime·systemstack_switch
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1"># 伪装当前调用是从 runtime·systemstack_switch 函数开始的。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1"># 从systemstack()后面的代码看出，这里的PC值没有被使用，原因是PC不需要还原设置。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1"># 因为systemstack()函数是闭包调用fn()函数，因此执行完后还在调用者的代码中。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">MOVQ</span>    <span class="no">R9</span><span class="p">,</span> <span class="p">(</span><span class="no">g_sched</span><span class="err">+</span><span class="no">gobuf_pc</span><span class="p">)(</span><span class="no">R14</span><span class="p">)</span> <span class="c1"># g.sched.gobuf.pc = runtime·systemstack_switch
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1"># 因为调用gosave_systemstack_switch()函数使用了CALL指令，所以会把返回地址压入栈中
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1"># 因此 8(SP)的位置正好是调用者函数的栈，也就是systemstack()函数的栈
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1"># 从systemstack()函数的函数原型可知，该函数没有分配栈大小为0，因此也是调用systemstack()函数的SP值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1"># 这里是newproc()函数的的栈顶的值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">LEAQ</span>    <span class="mi">8</span><span class="p">(</span><span class="no">SP</span><span class="p">),</span> <span class="no">R9</span> <span class="c1"># 8(SP) 是调用者前的SP指向的值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">MOVQ</span>    <span class="no">R9</span><span class="p">,</span> <span class="p">(</span><span class="no">g_sched</span><span class="err">+</span><span class="no">gobuf_sp</span><span class="p">)(</span><span class="no">R14</span><span class="p">)</span>     <span class="c1"># g.sched.gobuf.sp 指向调用者SP
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">MOVQ</span>    <span class="no">$0</span><span class="p">,</span> <span class="p">(</span><span class="no">g_sched</span><span class="err">+</span><span class="no">gobuf_ret</span><span class="p">)(</span><span class="no">R14</span><span class="p">)</span>    <span class="c1"># g.sched.gobuf.ret = 0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1"># BP寄存器与SP一样，这里也是newproc()函数的栈底的值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">MOVQ</span>    <span class="no">BP</span><span class="p">,</span> <span class="p">(</span><span class="no">g_sched</span><span class="err">+</span><span class="no">gobuf_bp</span><span class="p">)(</span><span class="no">R14</span><span class="p">)</span>     <span class="c1"># g.sched.gobuf.bp = BP; 调用者BP
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1"># Assert ctxt is zero. See func save.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">#
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1"># 断言 ctxt 是0。参看 func save。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1"># g.sched.gobuf.ctxt 存储的是闭包的上下文，也就是DX寄存器的值是函数的&amp;funcval
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">MOVQ</span>    <span class="p">(</span><span class="no">g_sched</span><span class="err">+</span><span class="no">gobuf_ctxt</span><span class="p">)(</span><span class="no">R14</span><span class="p">),</span> <span class="no">R9</span>   <span class="c1"># R9 = g.sched.gobuf.ctxt
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">TESTQ</span>   <span class="no">R9</span><span class="p">,</span> <span class="no">R9</span>
</span></span><span class="line"><span class="cl">    <span class="nf">JZ</span>	<span class="mi">2</span><span class="p">(</span><span class="no">PC</span><span class="p">)</span>   <span class="c1"># 判断结果为0则跳过abort()函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">CALL</span>    <span class="no">runtime</span><span class="err">·</span><span class="no">abort</span><span class="p">(</span><span class="no">SB</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nf">RET</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="systemstack_switch">systemstack_switch()<a hidden class="anchor" aria-hidden="true" href="#systemstack_switch">#</a></h3>
<ol>
<li>文件位置：：<code>go1.19.3/src/runtime/asm_amd64.s</code>。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">453
</span><span class="lnt">454
</span><span class="lnt">455
</span><span class="lnt">456
</span><span class="lnt">457
</span><span class="lnt">458
</span><span class="lnt">459
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-asm" data-lang="asm"><span class="line"><span class="cl"><span class="c1"># systemstack_switch is a dummy routine that systemstack leaves at the bottom
</span></span></span><span class="line"><span class="cl"><span class="c1"># of the G stack. We need to distinguish the routine that
</span></span></span><span class="line"><span class="cl"><span class="c1"># lives at the bottom of the G stack from the one that lives
</span></span></span><span class="line"><span class="cl"><span class="c1"># at the top of the system stack because the one at the top of
</span></span></span><span class="line"><span class="cl"><span class="c1"># the system stack terminates the stack walk (see topofstack()).
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nf">TEXT</span> <span class="no">runtime</span><span class="err">·</span><span class="no">systemstack_switch</span><span class="p">(</span><span class="no">SB</span><span class="p">),</span> <span class="no">NOSPLIT</span><span class="p">,</span> <span class="no">$0-0</span>
</span></span><span class="line"><span class="cl">    <span class="nf">RET</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="newproc1">newproc1()<a hidden class="anchor" aria-hidden="true" href="#newproc1">#</a></h2>
<ol>
<li>该函数主要是创建<code>new goroutine</code>，并设置<code>new goroutine</code>该从哪里进入哪里退出。</li>
<li>从<code>fn</code>开始，创建一个状态为<code>_Grunnable</code>的新<code>g</code>。</li>
<li><code>callerpc</code> 是创建这个<code>go</code>语句的地址（也就是<code>go</code>关键字代码的下一条指针）。</li>
<li>调用者负责将新的<code>g</code>添加到调度器。</li>
<li>参数：
<ol>
<li><strong><code>fn *funcval</code></strong>：要执行函数的闭包。也就是<code>go</code>关键字后面的函数闭包，不过函数闭包原型是<code>func()</code>。</li>
<li><strong><code>callergp *g</code></strong>：当前正在运行的<code>goroutine</code>。也就是调用<code>go</code>关键字的<code>goroutine</code>。</li>
<li><strong><code>callerpc uintptr</code></strong>：<code>go</code>关键字的下一行指令地址。也就是调用<code>go</code>关键字后的下一条指令。</li>
</ol>
</li>
<li>返回值：<strong><code>*g</code></strong>：新创建的<code>goroutine</code>。</li>
<li>文件位置：<code>go1.19.3/src/runtime/proc.go</code>。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">4109
</span><span class="lnt">4110
</span><span class="lnt">4111
</span><span class="lnt">4112
</span><span class="lnt">4113
</span><span class="lnt">4114
</span><span class="lnt">4115
</span><span class="lnt">4116
</span><span class="lnt">4117
</span><span class="lnt">4118
</span><span class="lnt">4119
</span><span class="lnt">4120
</span><span class="lnt">4121
</span><span class="lnt">4122
</span><span class="lnt">4123
</span><span class="lnt">4124
</span><span class="lnt">4125
</span><span class="lnt">4126
</span><span class="lnt">4127
</span><span class="lnt">4128
</span><span class="lnt">4129
</span><span class="lnt">4130
</span><span class="lnt">4131
</span><span class="lnt">4132
</span><span class="lnt">4133
</span><span class="lnt">4134
</span><span class="lnt">4135
</span><span class="lnt">4136
</span><span class="lnt">4137
</span><span class="lnt">4138
</span><span class="lnt">4139
</span><span class="lnt">4140
</span><span class="lnt">4141
</span><span class="lnt">4142
</span><span class="lnt">4143
</span><span class="lnt">4144
</span><span class="lnt">4145
</span><span class="lnt">4146
</span><span class="lnt">4147
</span><span class="lnt">4148
</span><span class="lnt">4149
</span><span class="lnt">4150
</span><span class="lnt">4151
</span><span class="lnt">4152
</span><span class="lnt">4153
</span><span class="lnt">4154
</span><span class="lnt">4155
</span><span class="lnt">4156
</span><span class="lnt">4157
</span><span class="lnt">4158
</span><span class="lnt">4159
</span><span class="lnt">4160
</span><span class="lnt">4161
</span><span class="lnt">4162
</span><span class="lnt">4163
</span><span class="lnt">4164
</span><span class="lnt">4165
</span><span class="lnt">4166
</span><span class="lnt">4167
</span><span class="lnt">4168
</span><span class="lnt">4169
</span><span class="lnt">4170
</span><span class="lnt">4171
</span><span class="lnt">4172
</span><span class="lnt">4173
</span><span class="lnt">4174
</span><span class="lnt">4175
</span><span class="lnt">4176
</span><span class="lnt">4177
</span><span class="lnt">4178
</span><span class="lnt">4179
</span><span class="lnt">4180
</span><span class="lnt">4181
</span><span class="lnt">4182
</span><span class="lnt">4183
</span><span class="lnt">4184
</span><span class="lnt">4185
</span><span class="lnt">4186
</span><span class="lnt">4187
</span><span class="lnt">4188
</span><span class="lnt">4189
</span><span class="lnt">4190
</span><span class="lnt">4191
</span><span class="lnt">4192
</span><span class="lnt">4193
</span><span class="lnt">4194
</span><span class="lnt">4195
</span><span class="lnt">4196
</span><span class="lnt">4197
</span><span class="lnt">4198
</span><span class="lnt">4199
</span><span class="lnt">4200
</span><span class="lnt">4201
</span><span class="lnt">4202
</span><span class="lnt">4203
</span><span class="lnt">4204
</span><span class="lnt">4205
</span><span class="lnt">4206
</span><span class="lnt">4207
</span><span class="lnt">4208
</span><span class="lnt">4209
</span><span class="lnt">4210
</span><span class="lnt">4211
</span><span class="lnt">4212
</span><span class="lnt">4213
</span><span class="lnt">4214
</span><span class="lnt">4215
</span><span class="lnt">4216
</span><span class="lnt">4217
</span><span class="lnt">4218
</span><span class="lnt">4219
</span><span class="lnt">4220
</span><span class="lnt">4221
</span><span class="lnt">4222
</span><span class="lnt">4223
</span><span class="lnt">4224
</span><span class="lnt">4225
</span><span class="lnt">4226
</span><span class="lnt">4227
</span><span class="lnt">4228
</span><span class="lnt">4229
</span><span class="lnt">4230
</span><span class="lnt">4231
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// Create a new g in state _Grunnable, starting at fn. callerpc is the
</span></span></span><span class="line"><span class="cl"><span class="c1">// address of the go statement that created this. The caller is responsible
</span></span></span><span class="line"><span class="cl"><span class="c1">// for adding the new g to the scheduler.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">newproc1</span><span class="p">(</span><span class="nx">fn</span> <span class="o">*</span><span class="nx">funcval</span><span class="p">,</span> <span class="nx">callergp</span> <span class="o">*</span><span class="nx">g</span><span class="p">,</span> <span class="nx">callerpc</span> <span class="kt">uintptr</span><span class="p">)</span> <span class="o">*</span><span class="nx">g</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 获取当前工作线程正在运行的g，该g是g0，
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 因为newproc1()函数只会在g0栈中被调用。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">_g_</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">()</span>   <span class="c1">// g0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="c1">// &#34;go nil&#34; 这种形式是不会允许的。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// var fn func() // nil
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// go fn()
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nx">fn</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">throwing</span> <span class="p">=</span> <span class="o">-</span><span class="mi">1</span> <span class="c1">// do not dump full stacks
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nf">throw</span><span class="p">(</span><span class="s">&#34;go of nil func value&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c1">// 禁用抢占，因为它可以在本地变量中持有p
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 将当前g.m.locks++，当前g是g0。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">acquirem</span><span class="p">()</span> <span class="c1">// disable preemption because it can be holding p in a local var
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 获取当前工作线程M绑定的P
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">_p_</span> <span class="o">:=</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">p</span><span class="p">.</span><span class="nf">ptr</span><span class="p">()</span> <span class="c1">// 初始化时_p_ = g0.m.p，从前面的分析可以知道其实就是allp[0]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">newg</span> <span class="o">:=</span> <span class="nf">gfget</span><span class="p">(</span><span class="nx">_p_</span><span class="p">)</span>   <span class="c1">// 从P的本地缓冲里获取一个没有使用的g，初始化时没有，返回nil
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 如果从当前P的空闲g链表中没有获取到g，则创建一个
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nx">newg</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// new一个g结构体对象，然后从堆上为其分配栈，并设置g的stack成员和两个stackgard成员
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">newg</span> <span class="p">=</span> <span class="nf">malg</span><span class="p">(</span><span class="nx">_StackMin</span><span class="p">)</span>  <span class="c1">// _StackMin = 2048
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// _Gidle = 0：该状态是G刚刚被分配还没初始化时
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// _Gdead = 6：该状态表示当前没有被用到，它可能刚刚完成初始化或刚刚退出运行，在一个空闲链表中。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 注意这里是CAS操作
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nf">casgstatus</span><span class="p">(</span><span class="nx">newg</span><span class="p">,</span> <span class="nx">_Gidle</span><span class="p">,</span> <span class="nx">_Gdead</span><span class="p">)</span> <span class="c1">// 初始化g的状态为_Gdead
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 放入全局变量【allgs切片】中，新增的g全部都会加入这里，并且不会移除，这也确保GC不会去释放它们
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nf">allgadd</span><span class="p">(</span><span class="nx">newg</span><span class="p">)</span> <span class="c1">// publishes with a g-&gt;status of Gdead so GC scanner doesn&#39;t look at uninitialized stack.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// newg 缺少栈
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nx">newg</span><span class="p">.</span><span class="nx">stack</span><span class="p">.</span><span class="nx">hi</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">throw</span><span class="p">(</span><span class="s">&#34;newproc1: newg missing stack&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// newg 的状态应该是 _Gdead：goroutine当前没有被用到
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nf">readgstatus</span><span class="p">(</span><span class="nx">newg</span><span class="p">)</span> <span class="o">!=</span> <span class="nx">_Gdead</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">throw</span><span class="p">(</span><span class="s">&#34;newproc1: new g is not Gdead&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 调整goroutine的栈hi，用于 usesLR 为true时
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// sys.MinFrameSize = 0; goarch.PtrSize = 8; totalSize = 32;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// extra space in case of reads slightly beyond frame
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">totalSize</span> <span class="o">:=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="mi">4</span><span class="o">*</span><span class="nx">goarch</span><span class="p">.</span><span class="nx">PtrSize</span> <span class="o">+</span> <span class="nx">sys</span><span class="p">.</span><span class="nx">MinFrameSize</span><span class="p">)</span> 
</span></span><span class="line"><span class="cl">    <span class="c1">// sys.StackAlign = 8; totalSize = 32;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">totalSize</span> <span class="p">=</span> <span class="nf">alignUp</span><span class="p">(</span><span class="nx">totalSize</span><span class="p">,</span> <span class="nx">sys</span><span class="p">.</span><span class="nx">StackAlign</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 注意预留这32字节是从栈高地址开始的
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">sp</span> <span class="o">:=</span> <span class="nx">newg</span><span class="p">.</span><span class="nx">stack</span><span class="p">.</span><span class="nx">hi</span> <span class="o">-</span> <span class="nx">totalSize</span> <span class="c1">// 预留32字节，主要用于下面usesLR
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">spArg</span> <span class="o">:=</span> <span class="nx">sp</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">usesLR</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// caller&#39;s LR
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="kt">uintptr</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">sp</span><span class="p">))</span> <span class="p">=</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">        <span class="nf">prepGoExitFrame</span><span class="p">(</span><span class="nx">sp</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="nx">spArg</span> <span class="o">+=</span> <span class="nx">sys</span><span class="p">.</span><span class="nx">MinFrameSize</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 把newg.sched结构体成员的所有成员设置为0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// newg.sched是一个gobuf结构体，保存的CPU主要的几个寄存器的值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">memclrNoHeapPointers</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">newg</span><span class="p">.</span><span class="nx">sched</span><span class="p">),</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Sizeof</span><span class="p">(</span><span class="nx">newg</span><span class="p">.</span><span class="nx">sched</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">    <span class="nx">newg</span><span class="p">.</span><span class="nx">sched</span><span class="p">.</span><span class="nx">sp</span> <span class="p">=</span> <span class="nx">sp</span>  <span class="c1">// newg.sched.sp寄存器rsp得值，也就是newg的栈顶，注意这里其实指向的是rbp存储的值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">newg</span><span class="p">.</span><span class="nx">stktopsp</span> <span class="p">=</span> <span class="nx">sp</span>  <span class="c1">// 栈顶位置，该值用于回溯
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// newg.sched.pc 保存的是rip寄存器的值，newg.sched.pc 表示当newg被调度起来运行时从这个地址开始执行指令
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 把pc设置成了goexit这个函数偏移1（sys.PCQuantum等于1）的位置，
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 这里设置goroutine的执行地址为goexit函数的第二条指令的代码地址而不是fn.fn
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 至于为什么要这么做需要等到分析完gostartcallfn函数才知道
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// +PCQuantum so that previous instruction is in same function
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">newg</span><span class="p">.</span><span class="nx">sched</span><span class="p">.</span><span class="nx">pc</span> <span class="p">=</span> <span class="nx">abi</span><span class="p">.</span><span class="nf">FuncPCABI0</span><span class="p">(</span><span class="nx">goexit</span><span class="p">)</span> <span class="o">+</span> <span class="nx">sys</span><span class="p">.</span><span class="nx">PCQuantum</span> 
</span></span><span class="line"><span class="cl">    <span class="nx">newg</span><span class="p">.</span><span class="nx">sched</span><span class="p">.</span><span class="nx">g</span> <span class="p">=</span> <span class="nf">guintptr</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">newg</span><span class="p">))</span>   <span class="c1">// 记录当前的gobuf是来自newg这个goroutine
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">gostartcallfn</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">newg</span><span class="p">.</span><span class="nx">sched</span><span class="p">,</span> <span class="nx">fn</span><span class="p">)</span>  <span class="c1">// 该函数处理newg从哪里进入从哪里退出
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">newg</span><span class="p">.</span><span class="nx">gopc</span> <span class="p">=</span> <span class="nx">callerpc</span>            <span class="c1">// 保存go关键字后的下一条代码地址，主要用于traceback
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">newg</span><span class="p">.</span><span class="nx">ancestors</span> <span class="p">=</span> <span class="nf">saveAncestors</span><span class="p">(</span><span class="nx">callergp</span><span class="p">)</span>    <span class="c1">// 保存当前创建go关键的的goroutine
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 设置newg的startpc为fn.fn，该成员主要用于函数调用栈的traceback和栈收缩
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// newg真正从哪里开始执行并不依赖于这个成员，而是sched.pc
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">newg</span><span class="p">.</span><span class="nx">startpc</span> <span class="p">=</span> <span class="nx">fn</span><span class="p">.</span><span class="nx">fn</span> <span class="c1">// 在isSystemGoroutine中被用到
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 判断当前goroutine是否是系统goroutine
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// runtime.main被认为不是系统goroutine。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nf">isSystemGoroutine</span><span class="p">(</span><span class="nx">newg</span><span class="p">,</span> <span class="kc">false</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// sched.ngsys：记录的是系统goroutine的数量，会被原子性的更新。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">atomic</span><span class="p">.</span><span class="nf">Xadd</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">ngsys</span><span class="p">,</span> <span class="o">+</span><span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// Only user goroutines inherit pprof labels.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// user goroutine 继承 labels
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">curg</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nx">newg</span><span class="p">.</span><span class="nx">labels</span> <span class="p">=</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">curg</span><span class="p">.</span><span class="nx">labels</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Track initial transition?
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 用于确实是否跟踪这个G
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">newg</span><span class="p">.</span><span class="nx">trackingSeq</span> <span class="p">=</span> <span class="nb">uint8</span><span class="p">(</span><span class="nf">fastrand</span><span class="p">())</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// gTrackingPeriod = 8
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nx">newg</span><span class="p">.</span><span class="nx">trackingSeq</span><span class="o">%</span><span class="nx">gTrackingPeriod</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">newg</span><span class="p">.</span><span class="nx">tracking</span> <span class="p">=</span> <span class="kc">true</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 设置g的状态为_Grunnable，表示这个g代表的goroutine可以运行了
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// _Gdead = 6：该状态表示当前没有被用到，它可能刚刚完成初始化或刚刚退出运行，在一个空闲链表中。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// _Grunnable = 1：goroutine应该在某个runq中，当前并没有在运行用户代码，它的栈不归自己所有。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">casgstatus</span><span class="p">(</span><span class="nx">newg</span><span class="p">,</span> <span class="nx">_Gdead</span><span class="p">,</span> <span class="nx">_Grunnable</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nx">gcController</span><span class="p">.</span><span class="nf">addScannableStack</span><span class="p">(</span><span class="nx">_p_</span><span class="p">,</span> <span class="nb">int64</span><span class="p">(</span><span class="nx">newg</span><span class="p">.</span><span class="nx">stack</span><span class="p">.</span><span class="nx">hi</span><span class="o">-</span><span class="nx">newg</span><span class="p">.</span><span class="nx">stack</span><span class="p">.</span><span class="nx">lo</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">_p_</span><span class="p">.</span><span class="nx">goidcache</span> <span class="o">==</span> <span class="nx">_p_</span><span class="p">.</span><span class="nx">goidcacheend</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// Sched.goidgen is the last allocated id,
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// this batch must be [sched.goidgen+1, sched.goidgen+GoidCacheBatch].
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// At startup sched.goidgen=0, so main goroutine receives goid=1.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">_p_</span><span class="p">.</span><span class="nx">goidcache</span> <span class="p">=</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Xadd64</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">goidgen</span><span class="p">,</span> <span class="nx">_GoidCacheBatch</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="nx">_p_</span><span class="p">.</span><span class="nx">goidcache</span> <span class="o">-=</span> <span class="nx">_GoidCacheBatch</span> <span class="o">-</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">        <span class="nx">_p_</span><span class="p">.</span><span class="nx">goidcacheend</span> <span class="p">=</span> <span class="nx">_p_</span><span class="p">.</span><span class="nx">goidcache</span> <span class="o">+</span> <span class="nx">_GoidCacheBatch</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// goid 表示G的唯一ID
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">newg</span><span class="p">.</span><span class="nx">goid</span> <span class="p">=</span> <span class="nb">int64</span><span class="p">(</span><span class="nx">_p_</span><span class="p">.</span><span class="nx">goidcache</span><span class="p">)</span>    <span class="c1">// 设置当前go在P中的位置
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">_p_</span><span class="p">.</span><span class="nx">goidcache</span><span class="o">++</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">raceenabled</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">newg</span><span class="p">.</span><span class="nx">racectx</span> <span class="p">=</span> <span class="nf">racegostart</span><span class="p">(</span><span class="nx">callerpc</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">trace</span><span class="p">.</span><span class="nx">enabled</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">traceGoCreate</span><span class="p">(</span><span class="nx">newg</span><span class="p">,</span> <span class="nx">newg</span><span class="p">.</span><span class="nx">startpc</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nf">releasem</span><span class="p">(</span><span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">)</span> <span class="c1">// 允许当前M被抢占
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nx">newg</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="gfget">gfget()<a hidden class="anchor" aria-hidden="true" href="#gfget">#</a></h3>
<ol>
<li>该函数主要是从当前<code>P</code>空闲的<code>G</code>链表中获取<code>G</code>，或者从全局的<code>P</code>链表中获取<code>G</code>，如果本地<code>P</code>中没有空闲的<code>G</code>则从全局的<code>P</code>中迁移部分<code>G</code>放入本地非<code>P</code>中。</li>
<li>从<code>gfree</code>列表获取。如果局部列表为空，则从全局列表中获取一部分到本地。</li>
<li>参看下面&quot;空闲的g链表&quot;中的<code>gfget</code>函数注释，有些变化。</li>
<li>文件位置：<code>go1.19.3/src/runtime/proc.go</code>。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">4282
</span><span class="lnt">4283
</span><span class="lnt">4284
</span><span class="lnt">4285
</span><span class="lnt">4286
</span><span class="lnt">4287
</span><span class="lnt">4288
</span><span class="lnt">4289
</span><span class="lnt">4290
</span><span class="lnt">4291
</span><span class="lnt">4292
</span><span class="lnt">4293
</span><span class="lnt">4294
</span><span class="lnt">4295
</span><span class="lnt">4296
</span><span class="lnt">4297
</span><span class="lnt">4298
</span><span class="lnt">4299
</span><span class="lnt">4300
</span><span class="lnt">4301
</span><span class="lnt">4302
</span><span class="lnt">4303
</span><span class="lnt">4304
</span><span class="lnt">4305
</span><span class="lnt">4306
</span><span class="lnt">4307
</span><span class="lnt">4308
</span><span class="lnt">4309
</span><span class="lnt">4310
</span><span class="lnt">4311
</span><span class="lnt">4312
</span><span class="lnt">4313
</span><span class="lnt">4314
</span><span class="lnt">4315
</span><span class="lnt">4316
</span><span class="lnt">4317
</span><span class="lnt">4318
</span><span class="lnt">4319
</span><span class="lnt">4320
</span><span class="lnt">4321
</span><span class="lnt">4322
</span><span class="lnt">4323
</span><span class="lnt">4324
</span><span class="lnt">4325
</span><span class="lnt">4326
</span><span class="lnt">4327
</span><span class="lnt">4328
</span><span class="lnt">4329
</span><span class="lnt">4330
</span><span class="lnt">4331
</span><span class="lnt">4332
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// Get from gfree list.
</span></span></span><span class="line"><span class="cl"><span class="c1">// If local list is empty, grab a batch from global list.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">gfget</span><span class="p">(</span><span class="nx">_p_</span> <span class="o">*</span><span class="nx">p</span><span class="p">)</span> <span class="o">*</span><span class="nx">g</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="nx">retry</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 如果当前P的gFree为空 并且 全局的gFree.stack或gFree.noStack不为空
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// sched.gFree.stack 表示这里的goroutine带有栈大小的默认是2KB
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// sched.gFree.noStack 表示这里的goroutine没有分配栈大小，默认是0KB
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nx">_p_</span><span class="p">.</span><span class="nx">gFree</span><span class="p">.</span><span class="nf">empty</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="p">(!</span><span class="nx">sched</span><span class="p">.</span><span class="nx">gFree</span><span class="p">.</span><span class="nx">stack</span><span class="p">.</span><span class="nf">empty</span><span class="p">()</span> <span class="o">||</span> <span class="p">!</span><span class="nx">sched</span><span class="p">.</span><span class="nx">gFree</span><span class="p">.</span><span class="nx">noStack</span><span class="p">.</span><span class="nf">empty</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">gFree</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// Move a batch of free Gs to the P.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">for</span> <span class="nx">_p_</span><span class="p">.</span><span class="nx">gFree</span><span class="p">.</span><span class="nx">n</span> <span class="p">&lt;</span> <span class="mi">32</span> <span class="p">{</span>  <span class="c1">// 当前P的gFree的数量小于32，从sched.gFree中移动一部分到P的gFree中
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// Prefer Gs with stacks.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="nx">gp</span> <span class="o">:=</span> <span class="nx">sched</span><span class="p">.</span><span class="nx">gFree</span><span class="p">.</span><span class="nx">stack</span><span class="p">.</span><span class="nf">pop</span><span class="p">()</span>   <span class="c1">// 从ched.gFree.stack取一个G
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="k">if</span> <span class="nx">gp</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>  <span class="c1">// 取不到，则从sched.gFree.noStack取一个G
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="nx">gp</span> <span class="p">=</span> <span class="nx">sched</span><span class="p">.</span><span class="nx">gFree</span><span class="p">.</span><span class="nx">noStack</span><span class="p">.</span><span class="nf">pop</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">                <span class="k">if</span> <span class="nx">gp</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                    <span class="k">break</span>
</span></span><span class="line"><span class="cl">                <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="nx">sched</span><span class="p">.</span><span class="nx">gFree</span><span class="p">.</span><span class="nx">n</span><span class="o">--</span>     <span class="c1">// 记录当前sched.gFree减一
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="nx">_p_</span><span class="p">.</span><span class="nx">gFree</span><span class="p">.</span><span class="nf">push</span><span class="p">(</span><span class="nx">gp</span><span class="p">)</span>  <span class="c1">// 把当前取到的G加入P的gFree中
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="nx">_p_</span><span class="p">.</span><span class="nx">gFree</span><span class="p">.</span><span class="nx">n</span><span class="o">++</span>       <span class="c1">// 把P的gFree的数量加一
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">gFree</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">goto</span> <span class="nx">retry</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nx">gp</span> <span class="o">:=</span> <span class="nx">_p_</span><span class="p">.</span><span class="nx">gFree</span><span class="p">.</span><span class="nf">pop</span><span class="p">()</span>       <span class="c1">// 从P中取出一个G
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nx">gp</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nx">_p_</span><span class="p">.</span><span class="nx">gFree</span><span class="p">.</span><span class="nx">n</span><span class="o">--</span>           <span class="c1">// 标记当前P的gFree减一
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">stack</span><span class="p">.</span><span class="nx">lo</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>   <span class="c1">// 如果当前G的栈顶为0，说明栈被释放了
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// Stack was deallocated in gfput. Allocate a new one.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 堆栈在gfput()函数中被释放 分配一个新的
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nf">systemstack</span><span class="p">(</span><span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nx">gp</span><span class="p">.</span><span class="nx">stack</span> <span class="p">=</span> <span class="nf">stackalloc</span><span class="p">(</span><span class="nx">_FixedStack</span><span class="p">)</span>  <span class="c1">// 重新分配栈信息
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="p">})</span>
</span></span><span class="line"><span class="cl">        <span class="nx">gp</span><span class="p">.</span><span class="nx">stackguard0</span> <span class="p">=</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">stack</span><span class="p">.</span><span class="nx">lo</span> <span class="o">+</span> <span class="nx">_StackGuard</span>  <span class="c1">// 把gp.stackguard0也执行该位置
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="nx">raceenabled</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nf">racemalloc</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">gp</span><span class="p">.</span><span class="nx">stack</span><span class="p">.</span><span class="nx">lo</span><span class="p">),</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">stack</span><span class="p">.</span><span class="nx">hi</span><span class="o">-</span><span class="nx">gp</span><span class="p">.</span><span class="nx">stack</span><span class="p">.</span><span class="nx">lo</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="nx">msanenabled</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nf">msanmalloc</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">gp</span><span class="p">.</span><span class="nx">stack</span><span class="p">.</span><span class="nx">lo</span><span class="p">),</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">stack</span><span class="p">.</span><span class="nx">hi</span><span class="o">-</span><span class="nx">gp</span><span class="p">.</span><span class="nx">stack</span><span class="p">.</span><span class="nx">lo</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="nx">asanenabled</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nf">asanunpoison</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">gp</span><span class="p">.</span><span class="nx">stack</span><span class="p">.</span><span class="nx">lo</span><span class="p">),</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">stack</span><span class="p">.</span><span class="nx">hi</span><span class="o">-</span><span class="nx">gp</span><span class="p">.</span><span class="nx">stack</span><span class="p">.</span><span class="nx">lo</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nx">gp</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="malg">malg()<a hidden class="anchor" aria-hidden="true" href="#malg">#</a></h3>
<ol>
<li>该函数主要是如果从<code>gfget()</code>函数中获取不到空闲的<code>g</code>，那么就自己分配一个，并设置栈空间</li>
<li>分配一个新的<code>g</code>，它的堆栈足够大，可以容纳<code>stacksize</code>字节。</li>
<li>文件位置：<code>go1.19.3/src/runtime/proc.go</code>。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">4074
</span><span class="lnt">4075
</span><span class="lnt">4076
</span><span class="lnt">4077
</span><span class="lnt">4078
</span><span class="lnt">4079
</span><span class="lnt">4080
</span><span class="lnt">4081
</span><span class="lnt">4082
</span><span class="lnt">4083
</span><span class="lnt">4084
</span><span class="lnt">4085
</span><span class="lnt">4086
</span><span class="lnt">4087
</span><span class="lnt">4088
</span><span class="lnt">4089
</span><span class="lnt">4090
</span><span class="lnt">4091
</span><span class="lnt">4092
</span><span class="lnt">4093
</span><span class="lnt">4094
</span><span class="lnt">4095
</span><span class="lnt">4096
</span><span class="lnt">4097
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// Allocate a new g, with a stack big enough for stacksize bytes.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">malg</span><span class="p">(</span><span class="nx">stacksize</span> <span class="kt">int32</span><span class="p">)</span> <span class="o">*</span><span class="nx">g</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">newg</span> <span class="o">:=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">g</span><span class="p">)</span>  <span class="c1">// 创建一个G，这里是堆分配的
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 需要分配栈大小
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nx">stacksize</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// _StackSystem = 0，round2函数向上取成2的幂次方，stacksize是2KB
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">stacksize</span> <span class="p">=</span> <span class="nf">round2</span><span class="p">(</span><span class="nx">_StackSystem</span> <span class="o">+</span> <span class="nx">stacksize</span><span class="p">)</span>    <span class="c1">// 计算大小2的幂次方
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 切换到g0栈，去分配栈
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nf">systemstack</span><span class="p">(</span><span class="kd">func</span><span class="p">()</span> <span class="p">{</span>	
</span></span><span class="line"><span class="cl">            <span class="c1">// 分配栈，goroutine在linux上默认是2KB大小
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="nx">newg</span><span class="p">.</span><span class="nx">stack</span> <span class="p">=</span> <span class="nf">stackalloc</span><span class="p">(</span><span class="nb">uint32</span><span class="p">(</span><span class="nx">stacksize</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">        <span class="p">})</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 注意：stackguard0 = newg.stack.lo + _StackGuard 溢出警戒线
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">newg</span><span class="p">.</span><span class="nx">stackguard0</span> <span class="p">=</span> <span class="nx">newg</span><span class="p">.</span><span class="nx">stack</span><span class="p">.</span><span class="nx">lo</span> <span class="o">+</span> <span class="nx">_StackGuard</span>  <span class="c1">// 设置newg.stackguard0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">newg</span><span class="p">.</span><span class="nx">stackguard1</span> <span class="p">=</span> <span class="p">^</span><span class="nb">uintptr</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// Clear the bottom word of the stack. We record g
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// there on gsignal stack during VDSO on ARM and ARM64.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 清除堆栈的底部单词。在ARM和ARM64上进行VDSO时，我们在gsignal堆栈上记录g。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 这里修改的是 newg.stack.lo 地址指向的值为0，不是 newg.stack.lo = 0。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="kt">uintptr</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">newg</span><span class="p">.</span><span class="nx">stack</span><span class="p">.</span><span class="nx">lo</span><span class="p">))</span> <span class="p">=</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nx">newg</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="gostartcallfn">gostartcallfn()<a hidden class="anchor" aria-hidden="true" href="#gostartcallfn">#</a></h3>
<ol>
<li>该函数主要作用是处理<code>go</code>关键注册的闭包，以及<code>newg</code>从哪里进入从哪里退出等。</li>
<li>调整<code>gobuf</code>，让它像执行了对<code>fn</code>的调用一样，然后在<code>fn</code>中的第一个指令之前停止。</li>
<li>参数：
<ul>
<li><code>gobuf *gobuf</code>：<code>goroutine</code>的调度信息。</li>
<li><code>fv *funcval</code>：<code>goroutine</code>要执行的闭包。</li>
</ul>
</li>
<li>文件位置：<code>go1.19.3/src/runtime/stack.go</code>。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1125
</span><span class="lnt">1126
</span><span class="lnt">1127
</span><span class="lnt">1128
</span><span class="lnt">1129
</span><span class="lnt">1130
</span><span class="lnt">1131
</span><span class="lnt">1132
</span><span class="lnt">1133
</span><span class="lnt">1134
</span><span class="lnt">1135
</span><span class="lnt">1136
</span><span class="lnt">1137
</span><span class="lnt">1138
</span><span class="lnt">1139
</span><span class="lnt">1140
</span><span class="lnt">1141
</span><span class="lnt">1142
</span><span class="lnt">1143
</span><span class="lnt">1144
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// adjust Gobuf as if it executed a call to fn
</span></span></span><span class="line"><span class="cl"><span class="c1">// and then stopped before the first instruction in fn.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">gostartcallfn</span><span class="p">(</span><span class="nx">gobuf</span> <span class="o">*</span><span class="nx">gobuf</span><span class="p">,</span> <span class="nx">fv</span> <span class="o">*</span><span class="nx">funcval</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">var</span> <span class="nx">fn</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span>	
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">fv</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 知道闭包的结构，知道fv.fn为注册函数的地址
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// fn: gorotine的入口地址，初始化时对应的是runtime.main
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">fn</span> <span class="p">=</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">fv</span><span class="p">.</span><span class="nx">fn</span><span class="p">)</span>	
</span></span><span class="line"><span class="cl">    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// //go:nosplit
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// func nilfunc() {
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">//  *(*uint8)(nil) = 0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// }
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 如果传入【nil】的函数闭包，则封装nilfunc函数，运行起来该函数会报错。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">fn</span> <span class="p">=</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">abi</span><span class="p">.</span><span class="nf">FuncPCABIInternal</span><span class="p">(</span><span class="nx">nilfunc</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// unsafe.Pointer(fv) 作为fn的上下文环境传入
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// unsafe.Pointer(fv) 会传入DX寄存器，DX寄存器用于闭包调用隐藏传值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">gostartcall</span><span class="p">(</span><span class="nx">gobuf</span><span class="p">,</span> <span class="nx">fn</span><span class="p">,</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">fv</span><span class="p">))</span>	
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div>

<p><details >
  <summary markdown="span">gostartcall()</summary>
  <blockquote>
<ol>
<li>该函数主要数处理<code>newg</code>从哪里进入从哪里退出。</li>
<li>伪装<code>newg</code>注册的函数是从<code>goexit+1</code>代码处调用<code>fn</code>函数，该<code>newg</code>执行完后会接到执行<code>goexit+1</code>后面代码。</li>
<li>该函数是设置<code>goroutine</code>从哪里进入从哪里出去的关键。</li>
<li>参数：
<ul>
<li><code>buf *gobuf</code>：<code>goroutine</code>的调度信息。</li>
<li><code>fn unsafe.Pointer</code>：闭包函数<code>funcval.fn</code>的值。</li>
<li><code>ctxt unsafe.Pointer</code>：闭包函数<code>funcval</code>的地址。</li>
</ul>
</li>
<li>文件位置：<code>go1.19.3/src/runtime/sys_x86.go</code>。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// adjust Gobuf as if it executed a call to fn with context ctxt
</span></span></span><span class="line"><span class="cl"><span class="c1">// and then stopped before the first instruction in fn.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">gostartcall</span><span class="p">(</span><span class="nx">buf</span> <span class="o">*</span><span class="nx">gobuf</span><span class="p">,</span> <span class="nx">fn</span><span class="p">,</span> <span class="nx">ctxt</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">sp</span> <span class="o">:=</span> <span class="nx">buf</span><span class="p">.</span><span class="nx">sp</span>              <span class="c1">// buf.sp 栈开始的位置
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">sp</span> <span class="o">-=</span> <span class="nx">goarch</span><span class="p">.</span><span class="nx">PtrSize</span>      <span class="c1">// 为返回地址预留8B空间
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 这里在伪装fn是被goexit()函数调用的，使得fn执行完后返回到goexit继续执行，从而完成清理工作
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="kt">uintptr</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">sp</span><span class="p">))</span> <span class="p">=</span> <span class="nx">buf</span><span class="p">.</span><span class="nx">pc</span>  <span class="c1">// 把goexit+1代码地址放入该处，模拟是被goexit函数调用的
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">buf</span><span class="p">.</span><span class="nx">sp</span> <span class="p">=</span> <span class="nx">sp</span>               <span class="c1">// 重新设置newg的栈顶寄存器
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 这里才真正让newg的ip寄存器指向fn函数，注意，这里只是在设置newg的一些信息，newg还未执行，
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 等到newg被调度起来运行时，调度器会把buf.pc放入cpu的IP寄存器，
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 从而使newg得以在cpu上真正的运行起来
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">buf</span><span class="p">.</span><span class="nx">pc</span> <span class="p">=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">fn</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 该值用在闭包的调用 DX 寄存器需要的上下文，该值是调度起fn函数的关键
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">buf</span><span class="p">.</span><span class="nx">ctxt</span> <span class="p">=</span> <span class="nx">ctxt</span>           <span class="c1">// 保存当前goroutine上下环境信息
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div></blockquote>

</details></p>

<h3 id="runtimegpexit">runtime.gpexit()<a hidden class="anchor" aria-hidden="true" href="#runtimegpexit">#</a></h3>
<ol>
<li>当<code>goroutine</code>运行完时会返回到该函数处继续运行后续收尾工作。</li>
<li>部分人可能担心<code>goexit()</code>函数加一会造成指令错乱，实际不会有问题，因为<code>goexit()</code>函数的代码已经考虑到这一层了。</li>
<li>首位各有一条<code>NOP</code>指令占位，所以入口地址加一后不会影响，正好对其到了接下来的<code>CALL</code>指令。</li>
<li><code>pc</code>的值之所以需要是<code>goexit()</code>函数的地址加一，是因为这样才像是<code>goexit()</code>函数调用了<code>fn()</code>函数，</li>
<li>如果指向<code>goexit()</code>函数的起始地址就不合适了，那样<code>goexit()</code>函数看起来还没有执行。</li>
<li>文件位置：<code>go1.19.3/src/runtime/asm_amd64.s</code>。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1591
</span><span class="lnt">1592
</span><span class="lnt">1593
</span><span class="lnt">1594
</span><span class="lnt">1595
</span><span class="lnt">1596
</span><span class="lnt">1597
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-asm" data-lang="asm"><span class="line"><span class="cl"><span class="c1">// The top-most function running on a goroutine
</span></span></span><span class="line"><span class="cl"><span class="c1">// returns to goexit+PCQuantum.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nf">TEXT</span> <span class="no">runtime</span><span class="err">·</span><span class="no">goexit</span><span class="p">(</span><span class="no">SB</span><span class="p">),</span><span class="no">NOSPLIT</span><span class="err">|</span><span class="no">TOPFRAME</span><span class="p">,</span><span class="no">$0-0</span>
</span></span><span class="line"><span class="cl">    <span class="nf">BYTE</span>    <span class="no">$0x90</span>   <span class="c1">// NOP
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">CALL</span>    <span class="no">runtime</span><span class="err">·</span><span class="no">goexit1</span><span class="p">(</span><span class="no">SB</span><span class="p">)</span> <span class="c1">// does not return
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// traceback from goexit1 must hit code range of goexit
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">BYTE</span>    <span class="no">$0x90</span>   <span class="c1">// NOP
</span></span></span></code></pre></td></tr></table>
</div>
</div><p><img loading="lazy" src="../images/goroutine-012.png" alt=""  />
</p>
<h2 id="runqput">runqput()<a hidden class="anchor" aria-hidden="true" href="#runqput">#</a></h2>
<ol>
<li>该函数主要是把设置好的<code>newg</code>放入<code>M</code>关联的<code>P</code>的首位置或全局<code>P</code>中等待被调度器调度起来执行。</li>
<li>该函数也是调度循环中从全局运行<code>g</code>链表中取出<code>g</code>放入本地<code>P</code>调用的函数。</li>
<li>参数：
<ul>
<li><code>_p_ *p</code>：当前工作线程<code>m</code>绑定的<code>P</code>。</li>
<li><code>gp *g</code>：新创建的<code>goroutine</code>。</li>
<li><code>next bool</code>：<code>true</code>.表示追加到<code>P</code>的首位置 <code>false</code>.表示追加到<code>P</code>的末尾位置。</li>
</ul>
</li>
<li>文件位置：<code>go1.19.3/src/runtime/proc.go</code>。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">5780
</span><span class="lnt">5781
</span><span class="lnt">5782
</span><span class="lnt">5783
</span><span class="lnt">5784
</span><span class="lnt">5785
</span><span class="lnt">5786
</span><span class="lnt">5787
</span><span class="lnt">5788
</span><span class="lnt">5789
</span><span class="lnt">5790
</span><span class="lnt">5791
</span><span class="lnt">5792
</span><span class="lnt">5793
</span><span class="lnt">5794
</span><span class="lnt">5795
</span><span class="lnt">5796
</span><span class="lnt">5797
</span><span class="lnt">5798
</span><span class="lnt">5799
</span><span class="lnt">5800
</span><span class="lnt">5801
</span><span class="lnt">5802
</span><span class="lnt">5803
</span><span class="lnt">5804
</span><span class="lnt">5805
</span><span class="lnt">5806
</span><span class="lnt">5807
</span><span class="lnt">5808
</span><span class="lnt">5809
</span><span class="lnt">5810
</span><span class="lnt">5811
</span><span class="lnt">5812
</span><span class="lnt">5813
</span><span class="lnt">5814
</span><span class="lnt">5815
</span><span class="lnt">5816
</span><span class="lnt">5817
</span><span class="lnt">5818
</span><span class="lnt">5819
</span><span class="lnt">5820
</span><span class="lnt">5821
</span><span class="lnt">5822
</span><span class="lnt">5823
</span><span class="lnt">5824
</span><span class="lnt">5825
</span><span class="lnt">5826
</span><span class="lnt">5827
</span><span class="lnt">5828
</span><span class="lnt">5829
</span><span class="lnt">5830
</span><span class="lnt">5831
</span><span class="lnt">5832
</span><span class="lnt">5833
</span><span class="lnt">5834
</span><span class="lnt">5835
</span><span class="lnt">5836
</span><span class="lnt">5837
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// runqput tries to put g on the local runnable queue.
</span></span></span><span class="line"><span class="cl"><span class="c1">// If next is false, runqput adds g to the tail of the runnable queue.
</span></span></span><span class="line"><span class="cl"><span class="c1">// If next is true, runqput puts g in the _p_.runnext slot.
</span></span></span><span class="line"><span class="cl"><span class="c1">// If the run queue is full, runnext puts g on the global queue.
</span></span></span><span class="line"><span class="cl"><span class="c1">// Executed only by the owner P.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">runqput</span><span class="p">(</span><span class="nx">_p_</span> <span class="o">*</span><span class="nx">p</span><span class="p">,</span> <span class="nx">gp</span> <span class="o">*</span><span class="nx">g</span><span class="p">,</span> <span class="nx">next</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 这里是为了曾加随机性，newg不是总存入指定位置,fastrandn(2) 取随机数对2求余
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nx">randomizeScheduler</span> <span class="o">&amp;&amp;</span> <span class="nx">next</span> <span class="o">&amp;&amp;</span> <span class="nf">fastrandn</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">next</span> <span class="p">=</span> <span class="kc">false</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c1">// 如果是追加到P的首位置处
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nx">next</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">retryNext</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 把gp放在_p_.runnext成员里，runnext成员中的goroutine会被优先调度起来运行
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">oldnext</span> <span class="o">:=</span> <span class="nx">_p_</span><span class="p">.</span><span class="nx">runnext</span>  <span class="c1">// 处理旧的将要被执行的goroutine
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 使用锁的形式替换_p_.runnext的值为gp新值，如果存在其他goroutine在操作runnext成员则需要重试
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="p">!</span><span class="nx">_p_</span><span class="p">.</span><span class="nx">runnext</span><span class="p">.</span><span class="nf">cas</span><span class="p">(</span><span class="nx">oldnext</span><span class="p">,</span> <span class="nf">guintptr</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">gp</span><span class="p">)))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">goto</span> <span class="nx">retryNext</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 如果之前需要处理的goroutine为空则返回即可
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="nx">oldnext</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// Kick the old runnext out to the regular run queue.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">gp</span> <span class="p">=</span> <span class="nx">oldnext</span><span class="p">.</span><span class="nf">ptr</span><span class="p">()</span>  <span class="c1">// 获取旧的goroutine地址
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">retry</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// P.runqhead uint32 记录着当前goroutine队列的队列头位置 一直往上加，到最大值变为0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// P.runqtail uint32 记录着当前goroutine队列的队列尾位置 一直往上加，到最大值变为0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// P.runq [256]guintptr 使用数组实现的循环队列
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 可能有其他线程正在并发取runqhead成员，所以需要跟其它线程同步
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 这里为什么只判断_p_.runqhead那是因为所以入数据的都是从首取走的
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">h</span> <span class="o">:=</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">LoadAcq</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">_p_</span><span class="p">.</span><span class="nx">runqhead</span><span class="p">)</span> <span class="c1">// load-acquire, synchronize with consumers
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">t</span> <span class="o">:=</span> <span class="nx">_p_</span><span class="p">.</span><span class="nx">runqtail</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 如果t-h &lt; 256则是没有存满，可以接到存储g
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nx">t</span><span class="o">-</span><span class="nx">h</span> <span class="p">&lt;</span> <span class="nb">uint32</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">_p_</span><span class="p">.</span><span class="nx">runq</span><span class="p">))</span> <span class="p">{</span>    <span class="c1">// 判断队列是否满了
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 队列还没存满可以放入本地P的队列中，这里放入的是t的位置处
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">_p_</span><span class="p">.</span><span class="nx">runq</span><span class="p">[</span><span class="nx">t</span><span class="o">%</span><span class="nb">uint32</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">_p_</span><span class="p">.</span><span class="nx">runq</span><span class="p">))].</span><span class="nf">set</span><span class="p">(</span><span class="nx">gp</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">        <span class="c1">// 虽然没有其他线程并发修改这个runqtail，但其他线程会并发读取该值以及p的runq成员
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 这里使用StoreRel是为了：
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 1. 原子写入runqtail
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 2. 防止编译器和CPU乱序，保证上一行代码对runq的修改发生在修改runqtail之前
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 3. 可见行屏障，保证当前线程对运行队列的修改对其他线程立马可见
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">atomic</span><span class="p">.</span><span class="nf">StoreRel</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">_p_</span><span class="p">.</span><span class="nx">runqtail</span><span class="p">,</span> <span class="nx">t</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="c1">// store-release, makes the item available for consumption
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">return</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// P的本地运行队列已满，需要放入全局运行队列
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 如果这里返回false，则说明P的本地运行队列G中部分G被其他M偷走了，继续执行goto retry
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nf">runqputslow</span><span class="p">(</span><span class="nx">_p_</span><span class="p">,</span> <span class="nx">gp</span><span class="p">,</span> <span class="nx">h</span><span class="p">,</span> <span class="nx">t</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// the queue is not full, now the put above must succeed
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 队列未满，现在上面的 put 必须成功
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">goto</span> <span class="nx">retry</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="runqputslow">runqputslow()<a hidden class="anchor" aria-hidden="true" href="#runqputslow">#</a></h3>
<ol>
<li>将<code>P</code>得本地队列的<code>g</code>迁移部分到全局队列中。</li>
<li>文件位置：<code>go1.19.3/src/runtime/proc.go</code>。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">5818
</span><span class="lnt">5819
</span><span class="lnt">5820
</span><span class="lnt">5821
</span><span class="lnt">5822
</span><span class="lnt">5823
</span><span class="lnt">5824
</span><span class="lnt">5825
</span><span class="lnt">5826
</span><span class="lnt">5827
</span><span class="lnt">5828
</span><span class="lnt">5829
</span><span class="lnt">5830
</span><span class="lnt">5831
</span><span class="lnt">5832
</span><span class="lnt">5833
</span><span class="lnt">5834
</span><span class="lnt">5835
</span><span class="lnt">5836
</span><span class="lnt">5837
</span><span class="lnt">5838
</span><span class="lnt">5839
</span><span class="lnt">5840
</span><span class="lnt">5841
</span><span class="lnt">5842
</span><span class="lnt">5843
</span><span class="lnt">5844
</span><span class="lnt">5845
</span><span class="lnt">5846
</span><span class="lnt">5847
</span><span class="lnt">5848
</span><span class="lnt">5849
</span><span class="lnt">5850
</span><span class="lnt">5851
</span><span class="lnt">5852
</span><span class="lnt">5853
</span><span class="lnt">5854
</span><span class="lnt">5855
</span><span class="lnt">5856
</span><span class="lnt">5857
</span><span class="lnt">5858
</span><span class="lnt">5859
</span><span class="lnt">5860
</span><span class="lnt">5861
</span><span class="lnt">5862
</span><span class="lnt">5863
</span><span class="lnt">5864
</span><span class="lnt">5865
</span><span class="lnt">5866
</span><span class="lnt">5867
</span><span class="lnt">5868
</span><span class="lnt">5869
</span><span class="lnt">5870
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// Put g and a batch of work from local runnable queue on global queue.
</span></span></span><span class="line"><span class="cl"><span class="c1">// Executed only by the owner P.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">runqputslow</span><span class="p">(</span><span class="nx">_p_</span> <span class="o">*</span><span class="nx">p</span><span class="p">,</span> <span class="nx">gp</span> <span class="o">*</span><span class="nx">g</span><span class="p">,</span> <span class="nx">h</span><span class="p">,</span> <span class="nx">t</span> <span class="kt">uint32</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">var</span> <span class="nx">batch</span> <span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="nx">_p_</span><span class="p">.</span><span class="nx">runq</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="nx">g</span>   <span class="c1">// gp加上_p_本地队列的一半
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="c1">// First, grab a batch from local queue.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">n</span> <span class="o">:=</span> <span class="nx">t</span> <span class="o">-</span> <span class="nx">h</span>      <span class="c1">// 计算当前P中存储的数量n
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">n</span> <span class="p">=</span> <span class="nx">n</span> <span class="o">/</span> <span class="mi">2</span>       <span class="c1">// 取一半
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nx">n</span> <span class="o">!=</span> <span class="nb">uint32</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">_p_</span><span class="p">.</span><span class="nx">runq</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span> <span class="p">{</span>   <span class="c1">// 判断P是否已满
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nf">throw</span><span class="p">(</span><span class="s">&#34;runqputslow: queue is not full&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 复制P本地队列G的一半，放入batch中
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="nb">uint32</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">n</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 从P的本地队列head开头开始复制一半存入batch中
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">batch</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nx">_p_</span><span class="p">.</span><span class="nx">runq</span><span class="p">[(</span><span class="nx">h</span><span class="o">+</span><span class="nx">i</span><span class="p">)</span><span class="o">%</span><span class="nb">uint32</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">_p_</span><span class="p">.</span><span class="nx">runq</span><span class="p">))].</span><span class="nf">ptr</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 这里把_p_.runqhead值设置成h+n，并判断旧值h是否发生变化，如果发生变化则说明其他goroutine正在偷取g
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">!</span><span class="nx">atomic</span><span class="p">.</span><span class="nf">CasRel</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">_p_</span><span class="p">.</span><span class="nx">runqhead</span><span class="p">,</span> <span class="nx">h</span><span class="p">,</span> <span class="nx">h</span><span class="o">+</span><span class="nx">n</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// cas-release, commits consume
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 如果cas操作失败，说明已经有其他工作线程从_p_的本地运行队列偷走一些goroutine，所以直接返回
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">return</span> <span class="kc">false</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nx">batch</span><span class="p">[</span><span class="nx">n</span><span class="p">]</span> <span class="p">=</span> <span class="nx">gp</span>   <span class="c1">// 最后一个位置处追加gp
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 增加随机性 打乱batch
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nx">randomizeScheduler</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="nb">uint32</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span> <span class="nx">i</span> <span class="o">&lt;=</span> <span class="nx">n</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nx">j</span> <span class="o">:=</span> <span class="nf">fastrandn</span><span class="p">(</span><span class="nx">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>	<span class="c1">// fastrand()%n
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="nx">batch</span><span class="p">[</span><span class="nx">i</span><span class="p">],</span> <span class="nx">batch</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span> <span class="p">=</span> <span class="nx">batch</span><span class="p">[</span><span class="nx">j</span><span class="p">],</span> <span class="nx">batch</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// Link the goroutines.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 全局运行队列是一个链表，这里首先把所有需要放入全局运行队列的g链接起来
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 减少后面对迁居链表的锁住时间，从而降低锁冲突
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 前一个和后一个链接起来
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="nb">uint32</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">n</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">batch</span><span class="p">[</span><span class="nx">i</span><span class="p">].</span><span class="nx">schedlink</span><span class="p">.</span><span class="nf">set</span><span class="p">(</span><span class="nx">batch</span><span class="p">[</span><span class="nx">i</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c1">// type gQueue struct {
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//     head guintptr
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//     tail guintptr
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// }
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kd">var</span> <span class="nx">q</span> <span class="nx">gQueue</span>
</span></span><span class="line"><span class="cl">    <span class="nx">q</span><span class="p">.</span><span class="nx">head</span><span class="p">.</span><span class="nf">set</span><span class="p">(</span><span class="nx">batch</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>    <span class="c1">// 设置开头
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">q</span><span class="p">.</span><span class="nx">tail</span><span class="p">.</span><span class="nf">set</span><span class="p">(</span><span class="nx">batch</span><span class="p">[</span><span class="nx">n</span><span class="p">])</span>    <span class="c1">// 设置结尾
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Now put the batch on global queue.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>                   <span class="c1">// 锁住当前sched
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">globrunqputbatch</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">q</span><span class="p">,</span> <span class="nb">int32</span><span class="p">(</span><span class="nx">n</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>    <span class="c1">// 拼接到全局sched.runq上去
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>                 <span class="c1">// 解锁当前sched
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">return</span> <span class="kc">true</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="globrunqputbatch">globrunqputbatch()<a hidden class="anchor" aria-hidden="true" href="#globrunqputbatch">#</a></h3>
<ol>
<li>文件位置：<code>go1.19.3/src/runtime/proc.go</code>。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">5587
</span><span class="lnt">5588
</span><span class="lnt">5589
</span><span class="lnt">5590
</span><span class="lnt">5591
</span><span class="lnt">5592
</span><span class="lnt">5593
</span><span class="lnt">5594
</span><span class="lnt">5595
</span><span class="lnt">5596
</span><span class="lnt">5597
</span><span class="lnt">5598
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// Put a batch of runnable goroutines on the global runnable queue.
</span></span></span><span class="line"><span class="cl"><span class="c1">// This clears *batch.
</span></span></span><span class="line"><span class="cl"><span class="c1">// sched.lock must be held.
</span></span></span><span class="line"><span class="cl"><span class="c1">// May run during STW, so write barriers are not allowed.
</span></span></span><span class="line"><span class="cl"><span class="c1">//go:nowritebarrierrec
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">globrunqputbatch</span><span class="p">(</span><span class="nx">batch</span> <span class="o">*</span><span class="nx">gQueue</span><span class="p">,</span> <span class="nx">n</span> <span class="kt">int32</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nf">assertLockHeld</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nx">sched</span><span class="p">.</span><span class="nx">runq</span><span class="p">.</span><span class="nf">pushBackAll</span><span class="p">(</span><span class="o">*</span><span class="nx">batch</span><span class="p">)</span>  <span class="c1">// 把当前batch链接到全局sched.runq上去
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">sched</span><span class="p">.</span><span class="nx">runqsize</span> <span class="o">+=</span> <span class="nx">n</span>             <span class="c1">// 累加当前sched.runqsize数量
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="o">*</span><span class="nx">batch</span> <span class="p">=</span> <span class="nx">gQueue</span><span class="p">{}</span>               <span class="c1">// 清空
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="acquirem">acquirem()<a hidden class="anchor" aria-hidden="true" href="#acquirem">#</a></h3>
<ol>
<li>文件位置：<code>go1.19.3/src/runtime/runtime1.go</code>。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">473
</span><span class="lnt">474
</span><span class="lnt">475
</span><span class="lnt">476
</span><span class="lnt">477
</span><span class="lnt">478
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">//go:nosplit
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">acquirem</span><span class="p">()</span> <span class="o">*</span><span class="nx">m</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">_g_</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">locks</span><span class="o">++</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><img loading="lazy" src="../images/goroutine-013.png" alt=""  />
</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://helium.github.io/tags/golang/">Golang</a></li>
      <li><a href="https://helium.github.io/tags/goroutine/">Goroutine</a></li>
    </ul>
<nav class="paginav">
  <a class="prev" href="https://helium.github.io/posts/golang/goroutine/flow/">
    <span class="title">« 上一页</span>
    <br>
    <span>Go 执行流程</span>
  </a>
  <a class="next" href="https://helium.github.io/posts/golang/goroutine/user/">
    <span class="title">下一页 »</span>
    <br>
    <span>user goroutine</span>
  </a>
</nav>

  </footer>
</article>
    </main>
    
<footer class="footer">
    
    <div class="busuanzi-footer">
    <span id="busuanzi_container_site_pv">
        本站总访问量<span id="busuanzi_value_site_pv"></span>次
    </span>
    <span id="busuanzi_container_site_uv">
        本站访客数<span id="busuanzi_value_site_uv"></span>人次
    </span>
    </div>
        <span>Copyright © 2024 蜀ICP备2024091074号 <a href="#">heliu's blog</a>. All rights reserved</span>  
    
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'Copy';

        function copyingDone() {
            copybutton.innerHTML = 'Done';
            setTimeout(() => {
                copybutton.innerHTML = 'Copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
