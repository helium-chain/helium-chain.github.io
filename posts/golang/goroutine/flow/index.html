<!DOCTYPE html>
<html lang="zh" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Go 执行流程 | Helium</title>
<meta name="keywords" content="golang, Goroutine">
<meta name="description" content="💥本文章所有相关go代码参考自go 1.18&#43;版本">
<meta name="author" content="helium">
<link rel="canonical" href="https://heliu.site/posts/golang/goroutine/flow/">
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<meta name="referrer" content="no-referrer-when-downgrade">
<link crossorigin="anonymous" href="/assets/css/stylesheet.css" rel="preload stylesheet" as="style">
<link rel="icon" href="https://heliu.site/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://heliu.site/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://heliu.site/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://heliu.site/apple-touch-icon.png">
<link rel="mask-icon" href="https://heliu.site/apple-touch-icon.png">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="zh" href="https://heliu.site/posts/golang/goroutine/flow/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
<html>
<head>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/jetbrains-mono@1.0.6/css/jetbrains-mono-nl.min.css" />
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lxgw-wenkai-lite-webfont@1.1.0/style.css" />
    <link rel="stylesheet" href="https://cdn.staticfile.org/lxgw-wenkai-screen-webfont/1.6.0/style.css" />
    <style>
        body {
            font-family: "LXGW WenKai Lite", sans-serif;
            font-family: "LXGW WenKai Screen", sans-serif;
        }
    </style>
</head>
</html>

  

<meta property="og:title" content="Go 执行流程" />
<meta property="og:description" content="💥本文章所有相关go代码参考自go 1.18&#43;版本" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://heliu.site/posts/golang/goroutine/flow/" />
<meta property="og:image" content="https://heliu.site/favicon-32x32.png" />
<meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-07-27T00:00:00+00:00" />
<meta property="article:modified_time" content="2024-07-27T00:00:00+00:00" /><meta property="og:site_name" content="Helium" />

<meta name="twitter:card" content="summary_large_image" />
<meta name="twitter:image" content="https://heliu.site/favicon-32x32.png" />
<meta name="twitter:title" content="Go 执行流程"/>
<meta name="twitter:description" content="💥本文章所有相关go代码参考自go 1.18&#43;版本"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Article",
      "item": "https://heliu.site/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Golang 合集",
      "item": "https://heliu.site/posts/golang/"
    }, 
    {
      "@type": "ListItem",
      "position":  3 ,
      "name": "第12章 Goroutine",
      "item": "https://heliu.site/posts/golang/goroutine/"
    }, 
    {
      "@type": "ListItem",
      "position":  4 ,
      "name": "Go 执行流程",
      "item": "https://heliu.site/posts/golang/goroutine/flow/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Go 执行流程",
  "name": "Go 执行流程",
  "description": "💥本文章所有相关go代码参考自go 1.18+版本",
  "keywords": [
    "golang", "Goroutine"
  ],
  "articleBody": " 示例代码。 1 2 3 4 5 6 7 package main import \"fmt\" func main() { fmt.Println(\"Hello World!\") } 程序加载阶段 程序在被操作系统加载起来运行时都会依次经过如下阶段： 从磁盘上把可执行程序读入内存。 创建进程和主线程。 为主线程分配栈空间。 把由用户在命令行输入的参数拷贝到主线程的栈。 把主线程放入操作系统的运行队列等待被调度执行起来运行。 在主线程第一次被调度起来执行第一条指令之前，主线程的函数栈如下图所示：sp指向栈顶。 相关概念： rsp：指向当前栈的栈顶，表示当前栈已经用到什么位置。 rbp：指向当前栈的栈底，表示当前栈的起点位置。 rip：CPU即将执行的下一条指令在内存中的地址，控制着程序的流程。 SB：GO汇编相关的虚拟寄存器，保存程序地址空间的起始地址。 SB寄存器保存的是当前函数在代码区的起始位置。 出现在GO汇编的函数定义、函数调用、全局变量定义以及对其引用会用到这个SB虚拟寄存器。 FP：GO汇编相关的虚拟寄存器，主要用来引用函数参数。 Go语言规定函数调用时参数都必须放在栈上，比如被调用函数使用first_arg+0(FP)来引用调用者传递进来的第一个参数。 用second_arg+8(FP)来引用第二个参数等。这里的first_arg和second_arg仅仅是一个帮助我们阅读源代码的符号。 对编译器来说无实际意义，+0和+8表示相对于FP寄存器的偏移量。 $16-8：数字16说明此函数的栈帧大小为16字节，8说明此函数的参数和返回值一共需要占用8字节内存。 程序入口 第一行代码：定义了_rt0_amd64_linux这个符号，并不是真正的CPU指令。 NOSPLIT告诉编译器不要在这个函数中插入检查栈是否溢出的代码。 第二行的JMP指令：才是主线程的第一条指令。 这条指令简单的跳转到（相当于go语言或c中的goto关键字）_rt0_amd64 这个符号处继续执行。 文件位置：go1.19.3/src/runtime/rt0_linux_amd64.s。 7 8 TEXT _rt0_amd64_linux(SB),NOSPLIT,$-8 JMP _rt0_amd64(SB) 前两行指令：把操作系统内核传递过来的参数argc和argv数组的地址分别放在DI和SI寄存器中。 需要注意的是：【MOVQ 0(SP), DI】拷贝的是argc的值是个8字节的存储的是参数的个数，是个数字。 【LEAQ 8(SP), SI】则是取的argv的地址，是个指针*argv，也是8字节。 第三行指令：跳转到 rt0_go 去执行。 文件位置：go1.19.3/src/runtime/asm_amd64.s。 11 12 13 14 15 16 17 18 19 # _rt0_amd64 is common startup code for most amd64 systems when using # internal linking. This is the entry point for the program from the # kernel for an ordinary -buildmode=exe program. The stack holds the # number of arguments and the C-style argv. TEXT _rt0_amd64(SB),NOSPLIT,$-8 MOVQ 0(SP), DI # DI = argc # 假设SP存储值为0x00ff00，则SI=0x00ff08，指向的是 *argv LEAQ 8(SP), SI # SI = 8(SP); *argv JMP\truntime·rt0_go(SB) rt0_go函数完成了go程序启动时的所有初始化工作。 第4条指令（ANDQ $~15, SP）： 用于调整栈顶寄存器的值使其按16字节对齐，也就是让栈顶寄存器SP指向的内存的地址为16的倍数。 之所以要按16字节对齐，是因为CPU有一组SSE指令，这些指令中出现的内存地址必须是16的倍数。 最后两条指令：把argc和argv搬到新的位置。 文件位置：go1.19.3/src/runtime/asm_amd64.s。 159 160 161 162 163 164 165 166 167 168 169 170 171 172 TEXT runtime·rt0_go(SB),NOSPLIT|TOPFRAME,$0 # copy arguments forward on an even stack # # 在偶数栈上向前复制参数 # argc是个8字节的数值，因此AX存储的是拷贝的值 # argv根据前面可知，这里BX存储的是argv的地址，因此原数据还在8(SP)的位置 MOVQ DI, AX # AX=argc MOVQ SI, BX # BX=*argv SUBQ $(5*8), SP # 3args 2auto # $~15：0000_1111 -\u003e 1111_0000 # 经过 ANDQ 调整后，一定是大于等于40byte ANDQ $~15, SP # 调整栈顶寄存器使其按16字节对齐 MOVQ AX, 24(SP) # argc放在SP+24字节处 MOVQ BX, 32(SP) # argv放在SP+32字节处，此时是argv的地址，*argv 总结：这部分代码完成了argc和argv的拷贝（argv是拷贝了地址，argv则是拷贝了副本值），栈按照16字节对齐了。 初始化g0 g0的主要作用是提供一个栈供runtime代码执行，因此这里主要对g0的几个与栈有关的成员进行了初始化。 从这里可以看出g0的栈大约有64KB，地址范围为SP - 64*1024 + 104 ～ SP。 注意：虽然这里给g0指定了大概64KB大小的栈空间大小，但是SP寄存器的值却没有减去64KB大小。 文件位置：go1.19.3/src/runtime/asm_amd64.s。 168 169 170 171 172 173 174 175 176 177 178 179 180 181 # create istack out of the given (operating system) stack. # _cgo_init may update stackguard. # 从给定的操作系统栈中创建 istack (自己的栈)。_cgo_init 可能会更新 stackguard。 # 下面这段代码从系统线程的栈空分出一部分当做g0的栈，然后初始化g0的栈信息和stackgard MOVQ $runtime·g0(SB), DI # DI = \u0026g0 LEAQ (-64*1024+104)(SP), BX # BX = SP - 64*1024 + 104 # g0.stackguard0和g0.stackguard1用于栈溢出检查，实现栈的自动伸缩，抢占调度也会用到stackguard0 MOVQ BX, g_stackguard0(DI) # g0.stackguard0 = SP - 64*1024 + 104 MOVQ BX, g_stackguard1(DI) # g0.stackguard1 = SP - 64*1024 + 104 # g0.stack 主要用来记录goroutine所使用的栈，[lo, hi) # g0.stack.lo 栈顶，指向内存低地址 # g0.stack.hi 栈底，指向内存高地址 MOVQ BX, (g_stack+stack_lo)(DI) # g0.stack.lo = SP - 64*1024 + 104 lo MOVQ SP, (g_stack+stack_hi)(DI) # g0.stack.hi = SP hi 运行完上面这几行指令后g0与栈之间的关系如下图所示： 总结：这部分代码给g0预留了大约64KB的小的栈空间（注意这里的SP寄存器值并没有被修改），设置了stack、stackguard0、stackguard1字段，这些字段都是与g0栈相关的。 CPU 相关 调用CPU相关指令，尝试获取CPU相关信息，比如CPU的厂商、处理器型号等，如果获取成功则记录在全局变量中。 判断是否需要调用初始化CGO相关函数（程序中有相关C代码则会调用，没有则不会调用）。 文件位置：go1.19.3/src/runtime/asm_amd64.s。 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 # find out information about the processor we're on # # 找出我们正在使用的处理器信息 # EAX寄存器设置为编号0，因为CPUID指令会使用到该寄存器。 MOVL $0, AX # EAX = 0 # CPUID 是一种用于查询处理器信息的指令，它可以返回处理器支持的功能列表和特性信息。 # CPUID 指令需要将查询信息的编号存储在 EAX 寄存器中，然后执行 CPUID 指令。 # 处理器将返回结果存储在 EAX、EBX、ECX 和 EDX 四个寄存器中，具体的返回值格式和含义取决于查询信息的编号。 # EAX 是 0 时：返回最大支持的功能编号（包括该编号）和厂商 ID（12 个字符）。 # 1. EAX：返回最大支持的功能编号 # 2. EBX：如果是 Inter 返回 \"Genu\"。如果是 AMD 返回 \"Auth\" 。 # 3. ECX：如果是 Inter 返回 \"ntel\"。如果是 AMD 返回 \"enti\" 。 # 4. EDX：如果是 Inter 返回 \"ntel\"。如果是 AMD 返回 \"cAMD\" 。 # Genuntelntel是英特厂商名称。AuthenticAMD表示是AMD厂商名称。 # EAX 是 1 时：返回处理器的基本信息，包括处理器型号、系列、扩展型号、扩展系列等。 # 1. EAX 的位0-3将包含处理器类型编码，位4-7将包含处理器家族编码，位8-11将包含处理器型号编码， # 位12-13将包含处理器扩展型号编码，位14-15将包含处理器扩展家族编码。 # 2. EBX、ECX、EDX 三个寄存器将包含其他处理器特性的信息。此处我们不关心这些数据。 # 查询 CPU 支持的功能列表（编号 0）：0、1、2、4、0x80000000、0x80000001 # 1. EAX 的值为 0x0：返回最大支持的功能编号（包括该编号）和厂商 ID（12 个字符）。 # 2. EAX 的值为 0x1：返回处理器的基本信息，包括处理器型号、系列、扩展型号、扩展系列等。 # 3. EAX 的值为 0x80000000h：返回最大支持的扩展功能编号和厂商 ID（12 个字符）。 # 4. EAX 的值为 0x80000001h：返回处理器的扩展信息，包括扩展特性、虚拟化支持等。 CPUID CMPL AX, $0 JE nocpuinfo # AX == 0，没有CPU信息 # 以下判断当前处理器是否是 GenuineIntel # BX != \"Genu\"; JNE 就会跳转 CMPL BX, $0x756E6547 # \"Genu\" JNE\tnotintel # 不是英特处理器时 # BX != \"ineI\"; JNE 就会跳转 CMPL DX, $0x49656E69 # \"ineI\" JNE\tnotintel # 不是英特处理器时 # BX != \"ntel\"; JNE 就会跳转 CMPL CX, $0x6C65746E # \"ntel\" JNE\tnotintel # 不是英特处理器时 # 将runtime的全局变量 isIntel 设置为 1 # 该变量在 runtime/runtime2.go 全局变量中 # 表示当前处理器是 GenuineIntel MOVB $1, runtime·isIntel(SB) notintel: # 不是intel # Load EAX=1 cpuid flags MOVL $1, AX CPUID # 将runtime的全局变量 processorVersionInfo 设置为 AX # AX寄存器存储的是处理器的标识，可以识别特定的处理器。 # 由于判断CPU是否支持相关的指令集，比如AVX指令集。 MOVL AX, runtime·processorVersionInfo(SB) nocpuinfo: # 没有cpu信息 # if there is an _cgo_init, call it. # # 如果存在_cgo_init，则调用它。代码中存在调用C相关函数时这里AX会有值并判断成功 # cgo_init函数是一个内部函数，用于初始化C语言代码和Go代码之间的接口。 # cgo_init函数是Go运行时系统的一部分，它在程序启动时被自动调用。 # 它会初始化cgo相关的全局变量，设置cgo的信号处理器，并将C语言代码中的函数指针转换为Go语言中的函数类型， # 以便能够在Go语言中调用它们。 # 使用 CGO 的情况下： # 1. Go会创建一个C语言的线程，并使用线程本地存储（Thread-Local Storage，TLS）来存储C语言函数所需要的数据。 # 2. 当使用cgo调用C语言函数时，cgo会自动初始化这个线程的TLS。这个初始化是在_cgo_init函数中完成的， # 这个函数是由Go编译器自动生成的。 MOVQ _cgo_init(SB), AX # 将寄存器 AX 中的值与自己进行按位逻辑与运算，并更新标志寄存器的值。 # 如果全部为 1，那么结果就是非零值，否则就是零。 # 这条指令的作用就是判断 AX 的值是否为零。 TESTQ AX, AX # 这条指令是一个条件跳转指令，它会根据上一条指令更新的标志寄存器的值来判断是否跳转到目标标签 needtls。 # JZ 是“Jump if Zero”的缩写，意思是如果上一条指令的【结果为零】，则跳转到目标标签。 # 跳转这里表示修改去 TLS 设置 JZ\tneedtls # 没有 _cgo_init 函数时跳转到 needtls # arg 1: g0, already in DI # 参数1：g0, 已经在 DI 中，前面初始化g0时放入DI中的 # 参数2：setg_gcc 放入 SI MOVQ $setg_gcc\u003c\u003e(SB), SI # arg 2: setg_gcc #ifdef GOOS_android\tMOVQ $runtime·tls_g(SB), DX # arg 3: \u0026tls_g # arg 4: TLS base, stored in slot 0 (Android's TLS_SLOT_SELF). # Compensate for tls_g (+16). MOVQ -16(TLS), CX #else # 参数3,4：都为0，使用平台的TLS时不使用 MOVQ $0, DX\t# arg 3, 4: not used when using platform's TLS MOVQ $0, CX #endif #ifdef GOOS_windows # Adjust for the Win64 calling convention. MOVQ CX, R9 # arg 4 MOVQ DX, R8 # arg 3 MOVQ SI, DX # arg 2 MOVQ DI, CX # arg 1 #endif # DI、SI、DX、CX参数已准备好 # DI = \u0026g0 # SI = setg_gcc # DX = 0 # CX = 0 # AX=_cgo_init; 调用 _cgo_init 函数 CALL AX # update stackguard after _cgo_init # 在 _cgo_init 后更新 stackguard，因为更新了stack.lo的值了。 MOVQ $runtime·g0(SB), CX # CX = \u0026g0 MOVQ (g_stack+stack_lo)(CX), AX # AX = g0.stack.lo; lo = SP + 8MB - 4KB # _StackGuard 是 928byte ADDQ $const__StackGuard, AX # AX = AX + _StackGuard # g0.stackguard0 = g0.stack.lo + _StackGuard # g0.stack.lo = SP + 8MB - 4KB # stackguard0 用于 runtime 栈溢出判断。 MOVQ AX, g_stackguard0(CX) # g0.stackguard1 = g0.stack.lo + _StackGuard # stackguard1 被 g0 和 gsignal 中的C代码使用。用于栈溢出判断 MOVQ AX, g_stackguard1(CX) ## 这里是 ifndef，不是windows则JMP ok不需要去TLS ## 这种情况发生在 _cgo_init 函数被调用时候 # #ifndef GOOS_windows JMP ok #endif needtls: ## 需要TLS的情况判断 #ifdef GOOS_plan9 # skip TLS setup on Plan 9 JMP ok ## 跳过TLS设置，不要手动设置 #endif #ifdef GOOS_solaris # skip TLS setup on Solaris JMP ok ## 跳过TLS设置，不要手动设置 #endif #ifdef GOOS_illumos # skip TLS setup on illumos JMP ok ## 跳过TLS设置，不要手动设置 #endif #ifdef GOOS_darwin # skip TLS setup on Darwin JMP ok ## 跳过TLS设置，不要手动设置 #endif #ifdef GOOS_openbsd # skip TLS setup on OpenBSD JMP ok ## 跳过TLS设置，不要手动设置 #endif cgo初始化 初始化 C 语言代码和 Go 代码之间的接口。 参数： G *g：\u0026runtime.g0。 void (*setg)(void*)：setg_gcc函数。 void **tlsg：NULL。 void **tlsbase：NULL。 文件位置：go1.19.3/src/runtime/cgo/gcc_linux_amd64.c。 该函数只是设置了g0栈的stack.lo = SP - 8MB + 4KB，并没有创建新的线程。 这段代码执行了以下重要任务： 线程栈的初始化和设置： Go运行时使用goroutines来并发执行代码，每个goroutine有自己的栈。 当使用cgo时，Go运行时需要与C代码的线程栈进行交互。 这段代码确保了C线程的栈与Go运行时的栈设置是一致的。 栈边界设置： 设置stacklo字段是为了确定goroutine栈的底部位置。 在Go中，每个goroutine的栈都有一个底部和顶部，stacklo和stackhi分别代表栈的底部和顶部地址。 以下是为什么要这样设置的原因： 安全边界：通过将stacklo设置为距离栈顶8MB减去4KB的位置，代码为栈溢出检测留出了空间。如果goroutine的栈增长超过了这个设置的范围，那么它将触发栈溢出错误，而不是覆盖其他内存，这有助于防止内存损坏。 栈空间预留：在C和Go代码之间进行切换时，可能需要额外的栈空间来处理函数调用、参数传递等。预留空间可以确保在这些操作中有足够的空间，避免栈溢出。 与Go运行时栈管理兼容：Go运行时负责管理goroutines的栈，包括栈的增长和收缩。这段代码确保了C线程的栈与Go运行时的栈管理策略兼容。 初始化setg_gcc：setg_gcc是一个全局变量，用于在C代码中设置当前的goroutine。在C代码中调用Go函数时，需要正确设置当前的goroutine，这样Go运行时才能正确管理goroutine的状态。 总的来说，这段代码是cgo初始化的一部分，目的是为了确保C线程的栈与Go运行时的goroutine栈能够正确地协同工作，同时保持栈的安全性和性能。 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 static void (*setg_gcc)(void*); // This will be set in gcc_android.c for android-specific customization. void (*x_cgo_inittls)(void **tlsg, void **tlsbase) __attribute__((common)); void x_cgo_init(G *g, void (*setg)(void*), void **tlsg, void **tlsbase) { // 申明一个 pthread_attr_t 类型变量 *attr，指针类型. // pthread_attr_t 是线程的属性结构 pthread_attr_t *attr; // 申明一个 size_t 类型变量 size。 size_t size; // 用于保存新创建的这个线程的栈大小 /* The memory sanitizer distributed with versions of clang before 3.8 has a bug: if you call mmap before malloc, mmap may return an address that is later overwritten by the msan library. Avoid this problem by forcing a call to malloc here, before we ever call malloc. This is only required for the memory sanitizer, so it's unfortunate that we always run it. It should be possible to remove this when we no longer care about versions of clang before 3.8. The test for this is misc/cgo/testsanitizers. GCC works hard to eliminate a seemingly unnecessary call to malloc, so we actually use the memory we allocate. */ setg_gcc = setg; // 向setg_gcc全局静态变量赋值setg_gcc()函数的地址 // 向操作系统申请 *attr 类型需要的内存，其实就是一个指针大小。 attr = (pthread_attr_t*)malloc(sizeof *attr); if (attr == NULL) { // 申请失败 fatalf(\"malloc failed: %s\", strerror(errno)); } // 初始化线程属性对象；创建的默认栈大小为8M pthread_attr_init(attr); // pthread_attr_getstacksize 获取线程的栈大小 pthread_attr_getstacksize(attr, \u0026size); // __builtin_frame_address(0) 查看当前函数的栈帧地址，因此和SP寄存器值相差不大 // 注意这里修改的是 stack.lo = SP - 8MB + 4KB，加上4KB是为了判断当前分配的栈是否超过4KB // 因为g参数传递的是指针，这里直接修改了g0的stack.lo字段的值，这里相当于扩大了g0栈大小。 g-\u003estacklo = (uintptr)__builtin_frame_address(0) - size + 4096; // lo \u003e= hi，错误的栈边界。hi-\u003elo（高-\u003e低），判断是否溢出 if (g-\u003estacklo \u003e= g-\u003estackhi) fatalf(\"bad stack bounds: lo=%p hi=%p\\n\", g-\u003estacklo, g-\u003estackhi); // 销毁 attr 这个线程属性对象 pthread_attr_destroy(attr); free(attr); // 释放 attr 占用的内存 if (x_cgo_inittls) { x_cgo_inittls(tlsg, tlsbase); } } 根据汇编代码可知，setg_gcc()函数应该是把g放入TLS和R14寄存器中。 文件位置：go1.19.3/src/runtime/asm_amd64.s。 1049 1050 1051 1052 1053 1054 # void setg_gcc(G*); set g called from gcc. TEXT setg_gcc\u003c\u003e(SB),NOSPLIT,$0 get_tls(AX) MOVQ DI, g(AX) MOVQ DI, R14 # set the g register RET 传入给x_cgo_init的G *g参数其实是g0，而g0结构体第一个字段就是stack，包含stacklo和stackhi，因此能直接转换。 文件位置：go1.19.3/src/runtime/cgo/libcgo.h。 17 18 19 20 21 22 23 24 25 26 27 /* * The beginning of the per-goroutine structure, * as defined in ../pkg/runtime/runtime.h. * Just enough to edit these two fields. */ typedef struct G G; struct G { uintptr stacklo; uintptr stackhi; }; 总结：这部分代码，尝试获取CPU相关信息并保存在全局变量中。判断是否存在CGO相关初始化，如果需要则从新设置g0的栈大小。 运行完上面这cgo初始化与栈之间的关系如下图所示： 主线程与m0绑定 设置tls 设置好g0栈之后，获取到CPU型号以及cgo初始化后，设置工作线程TLS。 调用settls函数初始化主线程的线程本地存储(TLS)，目的是把m0与主线程关联在一起。 设置了线程本地存储之后接下来的几条指令在于验证TLS功能是否正常，如果不正常则直接abort退出程序。 文件位置：go1.19.3/src/runtime/asm_amd64.s。 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 # 1) 设置 TLS # 下面开始初始化tls（thread local storage，线程本地存储） # LEA将内存地址赋值给DI，取m0的tls成员的地址到DI寄存器 LEAQ runtime·m0+m_tls(SB), DI # DI=\u0026m0.tls # 调用settls设置线程本地存储，settls函数的参数在DI寄存器中 CALL runtime·settls(SB) # 2) 验证 TLS 是否可用 # store through it, to make sure it works # # 通过它进行存储，以确保它有效 # 验证settls是否可以正常工作，如果有问题则abort退出程序 get_tls(BX)\t# 获取fs段基地址并放入BX寄存器，其实就是m0.tls[1]的地址，get_tls的代码由编译器生成 # 通过 FS 寄存器存储的值进行设置 MOVQ $0x123, g(BX) # 把整型常量0x123拷贝到fs段基地址偏移-8的内存位置，也就是m0.tls[0]=0x123 # 通过 runtime.mtls[0] 进行取值 MOVQ runtime·m0+m_tls(SB), AX # AX=m0.tls[0]，MOV将值赋值给AX # 比较 AX 与 $0x123 是否相等 CMPQ AX, $0x123 # 检查m0.tls[0]的值是否通过线程本地存储存入的0x123来验证tls功能是否正常 # 如果前面的比较结果是相等，跳转到当前指令地址加2个字节的位置（即下一条指令） # 如果比较结果不是相等，则继续执行下一条指令。 JEQ 2(PC) # 跳过下面这一条指令 CALL runtime·abort(SB) # 如果线程本地存储不能正常工作，退出程序 runtime·settls(SB) 将tls-base设置为DI寄存器的值，DI寄存器存储的是m0.tls的地址。 通过arch_prctl系统调用把m0.tls[1]的地址设置成了fs段的段基址。 CPU中有个叫fs的段寄存器与之对应： 而每个线程都有自己的一组CPU寄存器值，操作系统在把线程调离CPU运行时会帮我们把所有寄存器中的值保存在内存中。 调度线程起来运行时又会从内存中把这些寄存器的值恢复到CPU。在此之后工作线程代码就可以通过fs寄存器来找到m.tls。 文件位置：go1.19.3/src/runtime/sys_linux_amd64.s。 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 # set tls base to DI TEXT runtime·settls(SB),NOSPLIT,$32 #ifdef GOOS_android # Android stores the TLS offset in runtime·tls_g. SUBQ runtime·tls_g(SB), DI #else # DI寄存器中存放的是m.tls[0]的地址，m的tls成员是一个数组 # 下面这一句代码把DI寄存器中的地址加8，为什么要+8呢，主要跟ELF可执行文件格式中的TLS实现的机制有关 # 执行下面这句指令之后DI寄存器中存放的就是m.tls[1]的地址了 ADDQ $8, DI # ELF wants to use -8(FS) #endif # AMD64 Linux平台约定在进行系统调用时使用： # 1. rax寄存器存放系统调用编号 # 2. 同时约定使用rdi, rsi, rdx, r10, r8和r9来传递前6个系统调用参数 # 下面通过arch_prctl系统调用设置FS段基地址 # arch_prctl系统调用的第二个参数，设置该值为FS段基地址 MOVQ DI, SI # SI = DI # arch_prctl的第一个参数：ARCH_SET_FS 参数值表示设置线程的TLS地址的。 # 在 x86 架构中，FS 寄存器用于存储 TLS （Thread Local Storage）的地址 MOVQ $0x1002, DI\t# ARCH_SET_FS # AX 系统调用编号 MOVQ $SYS_arch_prctl, AX # AX = $SYS_arch_prctl # DI = ARCH_SET_FS # SI = \u0026m.tls[1] SYSCALL # 系统调用，进入内核 # 判断系统调用是否成功 # 将 AX 寄存器中的值与 0xfffffffffffff001 进行比较 # 如果 AX 中的值小于等于 0xfffffffffffff001，则跳转到当前指令地址加上2的地址（即跳转到下一条指令的下一条指令）。 CMPQ AX, $0xfffffffffffff001 JLS\t2(PC) # 跳过以下两条指令 MOVL $0xf1, 0xf1 # crash 系统调用失败直接crash，失败原因是把$0xf1放入不存在地址里面 RET # 直接返回 相关宏定义。 文件位置：go1.19.3/src/runtime/go_tls.h。 9 10 11 12 #ifdef GOARCH_amd64 #define get_tls(r) MOVQ TLS, r // get_tls函数定义，TLS其实就是FS寄存器的值 #define g(r) 0(r)(TLS*1) // (r + TLS*1 + 0) #endif m0绑定 首先把g0的地址放入主线程的线程本地存储（TLS）中，然后通过【m0.g0=\u0026g0】【g0.m=\u0026m0】把m0和g0绑定在一起。 之后在主线程中通过get_tls可以获取到g0，通过g0的m成员又可以找到m0。 保存在主线程本地存储中的值是g0的地址，也就是说工作线程的私有全局变量其实是一个指向g的指针而不是指向m的指针。 目前这个指针指向g0，表示代码正运行在g0栈。 文件位置：go1.19.3/src/runtime/asm_amd64.s。 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 ok: # 1) g0 与 TLS 绑定 # set the per-goroutine and per-mach \"registers\" get_tls(BX)\t# 获取fs段基地址到BX寄存器 LEAQ runtime·g0(SB), CX # CX = \u0026g0; var g0 g; # 把g0的地址保存在线程本地存储里面 MOVQ CX, g(BX) # m0.tls[0]=\u0026g0 LEAQ runtime·m0(SB), AX # AX = \u0026m0; var m0 m; # 2) m0 和 g0 相互绑定 # m0.g0 = \u0026g0 # g0.m = \u0026m0 # save m-\u003eg0 = g0 MOVQ CX, m_g0(AX) # m0.g0=g0 # save m0 to g0-\u003em # m的第一个字段就是m0.g0所以这里AX代表的就是m0.g0的地址处 MOVQ AX, g_m(CX) # g0.m=m0\t# CLD 指令是 Clear Direction Flag 的缩写。用于将方向标志位 DF（Direction Flag）清零。 # 在x86架构的计算机中，方向标志位DF是一个标志寄存器中的一位，用于指示字符串操作指令（如 MOVSB、LODSB、STOSB 等） # 在执行时是按照递增方向还是递减方向进行操作。 # 当 DF 为 0 时，字符串指针将按照递增方向移动；当 DF 为 1 时，字符串指针将按照递减方向移动。 # CLD 指令将方向标志位 DF 清零，表示字符串操作指令将按照递增方向进行操作。 # 如果我们使用MOVSB指令将一个长度为10字节的字符串从存储器中复制到寄存器中，它会按照递增方向从存储器中的第一个字节开始读取数据， # 并将它们复制到寄存器中。然后，它会递增存储器地址和寄存器地址，以便读取和复制下一个字节，直到整个字符串被复制到寄存器中为止。 # 意思是，在使用字符串操作指令时，这些指令会按照递增方向操作，即按照存储器地址递增的顺序复制数据。 CLD # convention is D is always left cleared 此时，主线程，m0，g0以及g0的栈之间的关系如下图所示： 总结：这段函数通过runtime·settls()函数把当前工作线程的FS寄存器地址设置为\u0026m0.tls[1]地址的值，然后再验证是否设置成功。然后把g0地址放入FS段寄存器中，也就是\u0026m0.tls[0]处，表示当前工作线程正在执行g0。接着设置m0.g0=g0和g0.m=m0，把g0和m0相关联起。 检查 编译器会在很多函数需要前封装一层把g写入R14寄存器中。这里编译器会把g0写入R14寄存其中。 主要是runtime·check()函数，检查内置类型的相关。 文件位置：go1.19.3/src/runtime/asm_amd64.s。 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 # Check GOAMD64 reqirements # We need to do this after setting up TLS, so that # we can report an error if there is a failure. See issue 49586. # # 检查GOAMD64要求我们需要在设置TLS后执行此操作，以便在出现失败时报告错误。 #ifdef NEED_FEATURES_CX\tMOVL $0, AX CPUID CMPL AX, $0 JE\tbad_cpu MOVL $1, AX CPUID ANDL $NEED_FEATURES_CX, CX CMPL CX, $NEED_FEATURES_CX JNE\tbad_cpu #endif #ifdef NEED_MAX_CPUID MOVL $0x80000000, AX CPUID CMPL AX, $NEED_MAX_CPUID JL bad_cpu #endif #ifdef NEED_EXT_FEATURES_BX MOVL $7, AX MOVL $0, CX CPUID ANDL $NEED_EXT_FEATURES_BX, BX CMPL BX, $NEED_EXT_FEATURES_BX JNE bad_cpu #endif #ifdef NEED_EXT_FEATURES_CX MOVL $0x80000001, AX CPUID ANDL $NEED_EXT_FEATURES_CX, CX CMPL CX, $NEED_EXT_FEATURES_CX JNE bad_cpu #endif #ifdef NEED_OS_SUPPORT_AX XORL CX, CX XGETBV ANDL $NEED_OS_SUPPORT_AX, AX CMPL AX, $NEED_OS_SUPPORT_AX JNE bad_cpu #endif #ifdef NEED_DARWIN_SUPPORT MOVQ $commpage64_version, BX CMPW (BX), $13 # cpu_capabilities64 undefined in versions \u003c 13 JL bad_cpu MOVQ $commpage64_cpu_capabilities64, BX MOVQ (BX), BX MOVQ $NEED_DARWIN_SUPPORT, CX ANDQ CX, BX CMPQ BX, CX JNE bad_cpu #endif # \"TEXT runtime.check(SB)\" 是由编译器实现，因为以下check方法由runtime的Go实现需要获取g。 # 编译器实现 \"TEXT runtime.check(SB)\" 是需要把g0写入R14中，然后JMP跳转到check # 该函数在 go1.19.3/src/runtime/runtime1.go:check() # 主要是检查go支持的变量内存情况，原子CAS函数等 CALL runtime·check(SB) runtime·check(SB) 汇编开头几行。 TEXT runtime.check(SB) \u003cautogenerated\u003e xorps xmm15, xmm15\t# 清除xmm15寄存器，可能后面函数需要使用 mov r14, qword ptr fs:[0xfffffff8] # R14 = g0 jmp $runtime.check # 跳转 check() 函数 runtime.check()的源码定义在/src/runtime/runtime1.go文件中。 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 func check() { var ( a int8 b uint8 c int16 d uint16 e int32 f uint32 g int64 h uint64 i, i1 float32 j, j1 float64 k unsafe.Pointer l *uint16 m [4]byte ) type x1t struct { x uint8 } type y1t struct { x1 x1t y uint8 } var x1 x1t var y1 y1t // 检查 int8 类型占用字节长度 if unsafe.Sizeof(a) != 1 { throw(\"bad a\") } // 检查 uint8 类型占用字节长度 if unsafe.Sizeof(b) != 1 { throw(\"bad b\") } if unsafe.Sizeof(c) != 2 { throw(\"bad c\") } if unsafe.Sizeof(d) != 2 { throw(\"bad d\") } if unsafe.Sizeof(e) != 4 { throw(\"bad e\") } if unsafe.Sizeof(f) != 4 { throw(\"bad f\") } if unsafe.Sizeof(g) != 8 { throw(\"bad g\") } if unsafe.Sizeof(h) != 8 { throw(\"bad h\") } if unsafe.Sizeof(i) != 4 { throw(\"bad i\") } if unsafe.Sizeof(j) != 8 { throw(\"bad j\") } if unsafe.Sizeof(k) != goarch.PtrSize { throw(\"bad k\") } if unsafe.Sizeof(l) != goarch.PtrSize { throw(\"bad l\") } if unsafe.Sizeof(x1) != 1 { throw(\"bad unsafe.Sizeof x1\") } if unsafe.Offsetof(y1.y) != 1 { throw(\"bad offsetof y1.y\") } if unsafe.Sizeof(y1) != 2 { throw(\"bad unsafe.Sizeof y1\") } if timediv(12345*1000000000+54321, 1000000000, \u0026e) != 12345 || e != 54321 { throw(\"bad timediv\") } var z uint32 z = 1 // 检查原子操作相关 if !atomic.Cas(\u0026z, 1, 2) { throw(\"cas1\") } if z != 2 { throw(\"cas2\") } z = 4 if atomic.Cas(\u0026z, 5, 6) { throw(\"cas3\") } if z != 4 { throw(\"cas4\") } z = 0xffffffff if !atomic.Cas(\u0026z, 0xffffffff, 0xfffffffe) { throw(\"cas5\") } if z != 0xfffffffe { throw(\"cas6\") } m = [4]byte{1, 1, 1, 1} atomic.Or8(\u0026m[1], 0xf0) if m[0] != 1 || m[1] != 0xf1 || m[2] != 1 || m[3] != 1 { throw(\"atomicor8\") } m = [4]byte{0xff, 0xff, 0xff, 0xff} atomic.And8(\u0026m[1], 0x1) if m[0] != 0xff || m[1] != 0x1 || m[2] != 0xff || m[3] != 0xff { throw(\"atomicand8\") } *(*uint64)(unsafe.Pointer(\u0026j)) = ^uint64(0) if j == j { throw(\"float64nan\") } if !(j != j) { throw(\"float64nan1\") } *(*uint64)(unsafe.Pointer(\u0026j1)) = ^uint64(1) if j == j1 { throw(\"float64nan2\") } if !(j != j1) { throw(\"float64nan3\") } *(*uint32)(unsafe.Pointer(\u0026i)) = ^uint32(0) if i == i { throw(\"float32nan\") } if i == i { throw(\"float32nan1\") } *(*uint32)(unsafe.Pointer(\u0026i1)) = ^uint32(1) if i == i1 { throw(\"float32nan2\") } if i == i1 { throw(\"float32nan3\") } testAtomic64() if _FixedStack != round2(_FixedStack) { throw(\"FixedStack is not power-of-2\") } if !checkASM() { throw(\"assembly checks failed\") } } 总结：这段代码主要是调用了runtime·check()函数，该函数主要是检查编译器是否按照预期，检查了相关内存占用值和原子操作等。 初始化m0 处理命令行参数，调用osinit函数获取CPU核的数量并保存在全局变量ncpu之中， 调度器初始化时需要知道当前系统有多少个CPU核。 调用runtime.args()函数来暂存命令行参数以待后续解析。部分系统会在这里获取与硬件相关的一些参数，例如物理页面大小。 文件位置：go1.19.3/src/runtime/asm_amd64.s。 338 339 340 341 342 343 344 345 346 347 348 349 350 # 1) 准备调用args函数，前面四条指令把参数放在栈上 MOVL\t24(SP), AX\t# copy argc AX=argc MOVL\tAX, 0(SP)\t# argc放在栈顶，为调用runtime·args的第一个参数，var argc int32 MOVQ\t32(SP), AX\t# copy argv AX=*argv MOVQ\tAX, 8(SP)\t# argv放在SP+8的位置，为调用runtime·args的第二个参数，var argv **byte # 保存 argc和argv 遍历 auxv 设置 physPageSize 和 startupRandomData 以及处理 VDSO # 处理操作系统传递过来的参数和env，复制全局变量argc和argv值，并处理系统参数赋值给cpu相关 CALL\truntime·args(SB) # 获取CPU核数保存在ncpu中，获取physHugePageSize参数。 # physHugePageSize 是分配大页面时候被用到。 CALL\truntime·osinit(SB)\t# 执行的结果是全局变量ncpu = CPU核数 CALL\truntime·schedinit(SB)\t# 调度系统初始化 args(SB) 关于 argv 的分布图。 argv：是一个指向字符指针的指针数组，其中每个字符指针指向一个以 null 结尾的字符串，这些字符串代表了程序启动时在命令行上输入的参数。数组的第一个元素 argv[0] 通常包含了程序的名称或路径，而随后的元素 argv[1] 到 argv[argc-1] 包含了程序的实际参数。 envp：是一个指向环境变量的指针数组，这些环境变量在程序启动时由操作系统传递给程序。每个数组元素都是一个以 null 结尾的字符串，表示一个键值对，其中键和值之间通过等号(=)连接。环境变量是操作系统用来存储有关当前会话或执行环境的信息的一种方式。它们通常用于配置程序的行为，提供路径信息，或者存储用户特定的设置。 以下是一些常见的环境变量及其用途： HOME：用户的主目录路径。 PATH：执行命令时要搜索的目录列表。 PWD：当前工作目录的路径。 USER：当前登录的用户名。 SHELL：用户登录的 shell 的路径。 LANG：系统语言和地区设置。 DISPLAY：X Window System 的显示变量，用于图形界面程序。 EDITOR：用户的首选文本编辑器。 TERM：终端类型。 auxv：为程序提供了关于其执行环境的额外信息。 以下是一些常见的 auxv 条目类型及其含义： AT_NULL：标志着 auxv 数组的结束。 AT_EXECFD：执行文件的文件描述符。 AT_PHDR：程序头表的地址。 AT_PHENT：程序头表中每个条目的大小。 AT_PHNUM：程序头表中的条目数量。 AT_PAGESZ：系统的页面大小。 AT_BASE：动态链接器的基地址。 AT_ENTRY：程序的入口点地址。 AT_UID：执行程序的用户的真实用户 ID。 AT_EUID：执行程序的有效用户 ID。 AT_GID：执行程序的组 ID。 AT_EGID：执行程序的有效组 ID。 AT_SECURE：指示程序是否在 “secure mode” 下执行。 AT_RANDOM：提供随机值的指针，用于安全目的。 文件位置：go1.19.3/src/runtime/runtime1.go。 66 67 68 69 70 71 72 73 74 75 76 77 func args(c int32, v **byte) { // 保存 argc 和 argv argc = c // runtime的全局变量中 argv = v // runtime的全局变量中 // 加载 auxv sysargs(c, v) } var ( argc int32 argv **byte ) sysargs() 文件位置：go1.19.3/src/runtime/os_linux.go。 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 func sysargs(argc int32, argv **byte) { // 跳过 argv + NULL n := argc + 1 // skip over argv, envp to get to auxv // 跳过 argv 和 envp 直接到 auxv for argv_index(argv, n) != nil { n++ } // skip NULL separator n++ // 跳过 NULL // now argv+n is auxv // argv+n 后现在是 auxv。 auxv := (*[1 \u003c\u003c 28]uintptr)(add(unsafe.Pointer(argv), uintptr(n)*goarch.PtrSize)) if sysauxv(auxv[:]) != 0 { return } // In some situations we don't get a loader-provided // auxv, such as when loaded as a library on Android. // Fall back to /proc/self/auxv. // // 在某些情况下，我们不会得到加载器提供的auxv，比如在Android上作为库加载时。 // 回到 /proc/self/auxv，去加载信息。 // var procAuxv []byte = []byte(\"/proc/self/auxv\\x00\") fd := open(\u0026procAuxv[0], 0 /* O_RDONLY */, 0) // 打开指定文件句柄 if fd \u003c 0 { // On Android, /proc/self/auxv might be unreadable (issue 9229), so we fallback to // try using mincore to detect the physical page size. // mincore should return EINVAL when address is not a multiple of system page size. const size = 256 \u003c\u003c 10 // size of memory region to allocate p, err := mmap(nil, size, _PROT_READ|_PROT_WRITE, _MAP_ANON|_MAP_PRIVATE, -1, 0) if err != 0 { return } var n uintptr for n = 4 \u003c\u003c 10; n \u003c size; n \u003c\u003c= 1 { err := mincore(unsafe.Pointer(uintptr(p)+n), 1, \u0026addrspace_vec[0]) if err == 0 { physPageSize = n break } } if physPageSize == 0 { physPageSize = size } munmap(p, size) return } var buf [128]uintptr // 从当前文件中读取信息 n = read(fd, noescape(unsafe.Pointer(\u0026buf[0])), int32(unsafe.Sizeof(buf))) closefd(fd) // 关闭文件句柄 if n \u003c 0 { return } // Make sure buf is terminated, even if we didn't read // the whole file. // 确保buf被终止，即使我们没有读取整个文件。 buf[len(buf)-2] = _AT_NULL sysauxv(buf[:]) } argv_index() 文件位置：go1.19.3/src/runtime/runtime1.go。 59 60 61 62 63 64 // nosplit for use in linux startup sysargs // //go:nosplit func argv_index(argv **byte, i int32) *byte { return *(**byte)(add(unsafe.Pointer(argv), uintptr(i)*goarch.PtrSize)) } sysauxv() 设置 startupRandomData 用于Hash，physPageSize 物理内存页大小，如果这些存在的情况下。 设置全局变量物理页面大小等。 文件位置：go1.19.3/src/runtime/os_linux.go。 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 func sysauxv(auxv []uintptr) int { var i int // 遍历auxv直到结束 _AT_NULL，一次性取两个分别是 tag 和 val for ; auxv[i] != _AT_NULL; i += 2 { tag, val := auxv[i], auxv[i+1] switch tag { case _AT_RANDOM: // The kernel provides a pointer to 16-bytes // worth of random data. // // 内核提供了一个指向16字节随机数据的指针。 // startupRandomData保存在启动时初始化的随机字节。这些来自ELF AT_RANDOM辅助向量。 startupRandomData = (*[16]byte)(unsafe.Pointer(val))[:] case _AT_PAGESZ: physPageSize = val // 如果是物理页大小设置该值 } archauxv(tag, val) // 该函数在linux下是空 vdsoauxv(tag, val) // 处理 vdso } return i / 2 } osinit(SB) runtime.osinit()函数中，所有的系统都会在这里获取CPU核心数，如果上一步runtime.args()没有成功获取物理页面大小，则部分系统会再次获取。Linux系统会在这里获取Huge物理页面的大小。 文件位置：go1.19.3/src/runtime/os_linux.go。 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 func osinit() { // 获取 CPU 核数 ncpu = getproccount() // 获取Linux中物理内存大页面大小。 // 大页面是指比普通页面（通常为 4KB）更大的页面大小，通常为 2MB 或 1GB。 // 使用大页面可以提高内存访问效率和系统性能，因为在使用大页面时，内核需要管理更少的页表和 TLB 条目。 // 该方法通过open去\"/sys/kernel/mm/transparent_hugepage/hpage_pmd_size\"路径读取的 physHugePageSize = getHugePageSize() if iscgo { // #42494 glibc and musl reserve some signals for // internal use and require they not be blocked by // the rest of a normal C runtime. When the go runtime // blocks...unblocks signals, temporarily, the blocked // interval of time is generally very short. As such, // these expectations of *libc code are mostly met by // the combined go+cgo system of threads. However, // when go causes a thread to exit, via a return from // mstart(), the combined runtime can deadlock if // these signals are blocked. Thus, don't block these // signals when exiting threads. // - glibc: SIGCANCEL (32), SIGSETXID (33) // - musl: SIGTIMER (32), SIGCANCEL (33), SIGSYNCCALL (34) sigdelset(\u0026sigsetAllExiting, 32) sigdelset(\u0026sigsetAllExiting, 33) sigdelset(\u0026sigsetAllExiting, 34) } osArchInit() // linux上该函数为空 } 获取cpu核数 这段代码通过调用操作系统的sched_getaffinity系统调用来获取当前进程的CPU亲和力掩码，这个掩码是一个位图，其中每个比特位对应一个CPU核心。如果某个比特位为1，则表示对应的CPU核心是可用的。代码通过遍历这个位图并计算为1的比特位的数量来得到可用的CPU核心数。这是一个高效的方式来获取系统资源信息，特别是在需要根据核心数来调整程序并行度的场景中。 文件位置：go1.19.3/src/runtime/os_linux.go。 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 func getproccount() int32 { // This buffer is huge (8 kB) but we are on the system stack // and there should be plenty of space (64 kB). // Also this is a leaf, so we're not holding up the memory for long. // See golang.org/issue/11823. // The suggested behavior here is to keep trying with ever-larger // buffers, but we don't have a dynamic memory allocator at the // moment, so that's a bit tricky and seems like overkill. // // 这个缓冲区很大(8 kB)，但我们在系统堆栈上，应该有足够的空间(64 kB)。 // 而且这是一个叶子，所以我们不会占用内存很长时间。 // 这里建议的行为是继续尝试使用更大的缓冲区，但我们目前没有动态内存分配器，所以这有点棘手，似乎有点过度。 // 定义了一个常量maxCPUs，值为65536。 // 这个值并不是真正的CPU核心数，而是一个预定义的最大值，用于确定缓冲区大小。 const maxCPUs = 64 * 1024 // 65536 // 定义了一个字节切片buf，大小为8192字节（即8KB）。 // 这是因为每个CPU核心可以用一个比特位表示，所以8192字节可以表示65536个比特位，对应maxCPUs个CPU核心 var buf [maxCPUs / 8]byte // 8KB // 这行代码是核心，它调用了操作系统提供的sched_getaffinity系统调用。 // 这个系统调用用于获取给定进程ID（这里是0，表示当前进程）的CPU亲和力掩码。 // 1. 第一个参数0表示当前进程的进程ID。 // 2. 第二个参数是缓冲区buf的大小。 // 3. 第三个参数是缓冲区的指针。 // r是系统调用的返回值，它表示实际写入缓冲区的字节数。 r := sched_getaffinity(0, unsafe.Sizeof(buf), \u0026buf[0]) // int32 // 如果系统调用返回负值，表示发生了错误。 // 在这种情况下，函数返回1，这可能意味着至少有一个CPU核心是可用的。 if r \u003c 0 { return 1 } n := int32(0) // 遍历缓冲区直到实际写入的字节数。 // 这段代码实际上是在计算缓冲区中设置为1的比特位的数量，每个为1的比特位代表一个可用的CPU核心。 for _, v := range buf[:r] { // 对于缓冲区的每个字节，如果它不为0，则进行处理。 for v != 0 { // 通过检查每个比特位是否为1来计算核心数。 // 这里使用了位运算\u0026来检查最低位是否为1，如果是，则增加核心数。 n += int32(v \u0026 1) // 将字节右移一位，继续检查下一个比特位。 v \u003e\u003e= 1 } // n = 4 } // 如果计算得出的核心数为0（这可能是一个错误的情况），则默认设置为1。 if n == 0 { n = 1 } // 函数返回计算出的CPU核心数。 return n } sched_getaffinity 函数原型。 文件位置：go1.19.3/src/runtime/os_linux.go。 448 449 //go:noescape func sched_getaffinity(pid, len uintptr, buf *byte) int32 汇编文件地址：go1.19.3/src/runtime/sys_linux_amd64.s。 660 661 662 663 664 665 666 667 668 669 670 TEXT runtime·sched_getaffinity(SB),NOSPLIT,$0 # 第一个参数 pid 为 0 MOVQ pid+0(FP), DI\t# 第二个参数 len 占用内存大小字节 MOVQ len+8(FP), SI # 第三个参数 buf *byte 指针 MOVQ buf+16(FP), DX MOVL $SYS_sched_getaffinity, AX # $SYS_sched_getaffinity = 204 SYSCALL MOVL AX, ret+24(FP) # 保存返回值 RET 获取物理内存页大小 这段代码通过读取操作系统文件/sys/kernel/mm/transparent_hugepage/hpage_pmd_size来获取透明大页的大小。 这个文件通常包含一个整数，表示透明大页的大小（通常是2的幂）。代码通过标准的文件打开、读取和关闭操作来获取这个值，并进行了一些基本的错误处理和验证，以确保返回的是一个合理的页大小。如果文件不存在、无法读取或内容不符合预期，函数将返回0。返回值uintptr是一个无符号整数类型，足以存储内存页大小。 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 // 定义了一个字节切片sysTHPSizePath，其中包含了透明大页大小的配置文件路径。 // 末尾的\\x00是空字符，用于字符串的终止。 var sysTHPSizePath = []byte(\"/sys/kernel/mm/transparent_hugepage/hpage_pmd_size\\x00\") func getHugePageSize() uintptr { var numbuf [20]byte // 调用open函数以只读模式打开上述路径指定的文件。 // 0作为第二个参数表示只读模式（O_RDONLY），第三个参数是模式，这里传0表示不需要特殊的文件权限。 fd := open(\u0026sysTHPSizePath[0], 0 /* O_RDONLY */, 0) // 如果open函数返回的文件描述符小于0，表示打开文件失败，函数返回0。 if fd \u003c 0 { return 0 } // 使用noescape函数来防止ptr逃逸到堆上，unsafe.Pointer将numbuf数组的地址转换为指针。 ptr := noescape(unsafe.Pointer(\u0026numbuf[0])) // 调用read函数从文件描述符fd读取内容到numbuf数组中，最多读取numbuf的长度个字节。 n := read(fd, ptr, int32(len(numbuf))) // 读取完成后关闭文件描述符。 closefd(fd) // 如果读取的字节数小于或等于0，表示读取失败或文件为空，函数返回0。 if n \u003c= 0 { return 0 } // 减去1，以移除读取到的字符串末尾的换行符。 n-- // remove trailing newline // 将读取到的字节转换为字符串，然后使用atoi函数将字符串转换为整数。ok表示转换是否成功。 v, ok := atoi(slicebytetostringtmp((*byte)(ptr), int(n))) // 如果转换失败或得到的值小于0，则将v设置为0。 if !ok || v \u003c 0 { v = 0 } // 检查v是否为2的幂。 // 一个数是2的幂当且仅当它与其自身减1的位与结果为0。如果不是2的幂，则返回0。 if v\u0026(v-1) != 0 { // v is not a power of 2 return 0 } // 如果一切正常，将读取到的值转换为uintptr类型并返回。 return uintptr(v) } schedinit(SB) 初始化调度系统，加载过程： call osinit：调用osinit()函数，设置runtime.ncpu和runtime.physHugePageSize参数的值。 call schedinit：调用schedinit()函数，初始化调度器。 make \u0026 queue new G：创建第一个main goroutine，并加入队列。 call runtime·mstart：调用runtime·mstart()函数开启调度循环。 这个新的goroutine运行runtime.main()函数。 文件位置：go1.19.3/src/runtime/proc.go。 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 756 757 758 759 760 761 762 763 764 765 766 767 768 769 770 771 772 773 774 775 776 777 778 779 780 781 782 783 784 785 786 787 788 789 790 791 792 793 794 795 796 797 // The bootstrap sequence is: // //\tcall osinit //\tcall schedinit //\tmake \u0026 queue new G //\tcall runtime·mstart // // The new G calls runtime·main. func schedinit() { // 初始化锁，如果有锁排名情况下 lockInit(\u0026sched.lock, lockRankSched) lockInit(\u0026sched.sysmonlock, lockRankSysmon) lockInit(\u0026sched.deferlock, lockRankDefer) lockInit(\u0026sched.sudoglock, lockRankSudog) lockInit(\u0026deadlock, lockRankDeadlock) lockInit(\u0026paniclk, lockRankPanic) lockInit(\u0026allglock, lockRankAllg) lockInit(\u0026allpLock, lockRankAllp) lockInit(\u0026reflectOffs.lock, lockRankReflectOffs) lockInit(\u0026finlock, lockRankFin) lockInit(\u0026trace.bufLock, lockRankTraceBuf) lockInit(\u0026trace.stringsLock, lockRankTraceStrings) lockInit(\u0026trace.lock, lockRankTrace) lockInit(\u0026cpuprof.lock, lockRankCpuprof) lockInit(\u0026trace.stackTab.lock, lockRankTraceStackTab) // Enforce that this lock is always a leaf lock. // All of this lock's critical sections should be // extremely short. // 强制这个锁始终是一个叶锁。所有锁的关键部分都应该非常短。 lockInit(\u0026memstats.heapStats.noPLock, lockRankLeafRank) // raceinit must be the first call to race detector. // In particular, it must be done before mallocinit below calls racemapshadow. // // getg()函数在源代码中没有对应的定义，由编译器插入类似下面两行代码 // 1. get_tls(CX) =\u003e MOVQ TLS, CX // 2. MOVQ g(CX), BX; // 起始就是从TLS中取出goroutine，此时应该是*g0。也就是\u0026m0.tls[0]里面存储的值*g0。 // 前面代码可知，g0的地址被放入了TLS中，因此这里从TLS获取g0的地址 _g_ := getg() // _g_ = \u0026g0 if raceenabled { _g_.racectx, raceprocctx0 = raceinit() } // 设置最多启动10000个操作系统线程，也就是最多10000个M sched.maxmcount = 10000 // The world starts stopped. // // 在没有锁排名下，该函数为空。因为此时就只有m0一个线程。 // 在有锁排名下，该函数把worldIsStopped全局变量设置为1，就返回了。 worldStopped() // STW // 校验程序的各个模块，因为golang支持shared、plugin等build模式，可能会有很多个二进制模块 // 这里会校验各个模块的符号、ABI等，确保模块间一致。 moduledataverify() // 栈内存初始化，stackpool 和 stackLarge 初始化 // goroutine的栈是动态分配、动态增长的，这一步会初始化用于栈分配的全局缓存池，以及相关的锁。 stackinit() // 栈内存初始化 // 堆内存初始化，包括初始化mheap、mcache0以及设置堆的arenaHint mallocinit()\t// 进行与CPU相关的初始化工作，检测CPU是否支持某些指令集，以及根据GODEBUG环境变量来启用或禁用某些硬件特性 cpuinit() // must run before alginit // 根据CPU对AES相关指令的支持情况，选择不同得Hash算法，所以必须在 cpuinit() 后面调用 // map、hash必须在 alginit() 函数调用后才可以使用 alginit() // maps, hash, fastrand must not be used before this call // 初始化 fastrandseed，在接下来的mcommoninit()函数中被用到 fastrandinit() // must run before mcommoninit // 初始化m0，因为从前的代码我们知道 g0-\u003em=\u0026m0 // 为当前工作线程M分配ID、初始化gsignal，并把M添加到allm全局链表中 // 该函数在新创建工作线程时也会调用。 mcommoninit(_g_.m, -1) // m0 // 基于所有的已加载模块，构造一个活跃模块切片 modulesSlice，并初始化GC需要的Mask数据 modulesinit() // provides activeModules // Typelinksinit扫描来自额外模块的类型，并构建moduledata类型映射，用于消除重复类型指针。 // 基于活跃模块列表构建模块级的typemap，实现全局范围内对类型元数据去重。 typelinksinit() // uses maps, activeModules // 遍历活跃模块列表，将编译器阶段生成的所有itab添加到itabTable中 // 该函数会调用itabAdd()函数，接口的时候知道该函数会生成*itab itabsinit() // uses activeModules stkobjinit() // must run before GC starts sigsave(\u0026_g_.m.sigmask) initSigmask = _g_.m.sigmask // 解析命令行参数，程序中通过os.Args得到的参数是在这里初始化的（Windows除外） // 存入 argslice []string 变量中 goargs() // 解析环境变量，程序中通过os.Getenv获取的环境变量是在这里初始化的（Windows除外） // 存入 envs []string 变量中 goenvs() // 解析环境变量GODEBUG，为runtime各个调试参数赋值 parsedebugvars() // 初始化与GC相关的参数，根据环境变量GOGC设置gcpercent gcinit() lock(\u0026sched.lock) // 获取 mutex 解锁 // 上次网络轮询的时间点，设置为当前时间点 sched.lastpoll = uint64(nanotime()) // 系统中有多少核，就创建和初始化多少个P结构体对象 procs := ncpu\t// ncpu该值在runtime.osinit函数中被设置 // 如果环境变量指定了GOMAXPROCS，则创建指定数量的p if n, ok := atoi32(gogetenv(\"GOMAXPROCS\")); ok \u0026\u0026 n \u003e 0 { procs = n\t} // procresize 创建和初始化全局变量allp // 根据 CPU 的核数或环境变量GOMAXPROC确定P的数量，调用procresize进行调整 // procresize 返回nil表示所有的P中本地队列都没有可运行的goroutine。 if procresize(procs) != nil { throw(\"unknown runnable goroutine during bootstrap\") } unlock(\u0026sched.lock) // mutex 解锁 // World is effectively started now, as P's can run. worldStarted() // Start World // For cgocheck \u003e 1, we turn on the write barrier at all times // and check all pointer writes. We can't do this until after // procresize because the write barrier needs a P. // // 对于cgocheck \u003e 1，我们在任何时候都打开写屏障并检查所有的指针写。 // 我们不能这样做，直到procresize之后，因为写屏障需要一个P。 if debug.cgocheck \u003e 1 { // debug.cgocheck在parsedebugvars()函数中被设置为1 // 开启写屏障 writeBarrier.cgo = true writeBarrier.enabled = true // 初始化所有P上的写屏障缓存区 for _, p := range allp { p.wbBuf.reset() } } // 未知编译版本时 if buildVersion == \"\" { // Condition should never trigger. This code just serves // to ensure runtime·buildVersion is kept in the resulting binary. // // 条件应该永远不会触发。这段代码只是用于确保runtime·buildVersion保存在结果二进制文件中。 buildVersion = \"unknown\" } if len(modinfo) == 1 { // Condition should never trigger. This code just serves // to ensure runtime·modinfo is kept in the resulting binary. // // 条件应该永远不会触发。这段代码只是用于确保runtime·modinfo保存在结果二进制文件中。 modinfo = \"\" } } mcommoninit() getg()获取出来的是g0，然后调用mcommoninit函数对m0(g0.m)进行必要的初始化。 预分配的ID可以作为'id'传递，也可以通过传递 -1 来省略，系统默认分配。 该函数在新创建工作线程时也会被调用，因此可能会出现竞争。 总结：该方法主要为工作线程分配（指定一个唯一id），并初始化m的相关参数，把m加入到全局allm中。 文件位置：go1.19.3/src/runtime/proc.go。 785 786 787 788 789 790 791 792 793 794 795 796 797 798 799 800 801 802 803 804 805 806 807 808 809 810 811 812 813 814 815 816 817 818 819 820 821 822 823 824 825 826 827 828 829 830 831 832 833 834 835 836 837 838 839 840 841 842 843 844 845 846 847 848 849 // Pre-allocated ID may be passed as 'id', or omitted by passing -1. func mcommoninit(mp *m, id int64) { _g_ := getg() // \u0026g0 // g0 stack won't make sense for user (and is not necessary unwindable). // // g0堆栈对用户来说没有意义(并且不一定是可撤销的)。 if _g_ != _g_.m.g0 { callers(1, mp.createstack[:]) } // 获取 mutex 锁 lock(\u0026sched.lock) if id \u003e= 0 { mp.id = id // 使用传递来的id } else { mp.id = mReserveID() // 系统分配 } // 根据mp.id和fastrandseed生成随机hash lo := uint32(int64Hash(uint64(mp.id), fastrandseed)) // 根据cputicks()和^fastrandseed生成随机hash。cputicks()是当前CPU时间 hi := uint32(int64Hash(uint64(cputicks()), ^fastrandseed)) // 如果 lo 和 hi 刚好互补时 if lo|hi == 0 { hi = 1 } // Same behavior as for 1.17. // TODO: Simplify ths. // // 下面通过 uint32 的 lo 和 hi 组成一个(hi\u003c\u003c32 + lo)的uint64随机值 // 因为内存存储的原因所以有以下判断，以及数据的操作不一样 if goarch.BigEndian { // 数据存储是大端存储时 mp.fastrand = uint64(lo)\u003c\u003c32 | uint64(hi) } else { // 数据存储是小端存储时 // linux x86走这里。fastrand表示M的随机值。 mp.fastrand = uint64(hi)\u003c\u003c32 | uint64(lo) } // 创建信号处理的gsignal。 // 分配一个32KB大小的栈，然后 mp.gsignal.m = mp mpreinit(mp) if mp.gsignal != nil { // 设置 mp.gsignal.stackguard1 = 0 + _StackGuard mp.gsignal.stackguard1 = mp.gsignal.stack.lo + _StackGuard } // Add to allm so garbage collector doesn't free g-\u003em // when it is just in a register or thread-local storage. mp.alllink = allm // mp.alllink 与 allm 绑定 // NumCgoCall() iterates over allm w/o schedlock, // so we need to publish it safely. atomicstorep(unsafe.Pointer(\u0026allm), unsafe.Pointer(mp)) // atomically allm = mp unlock(\u0026sched.lock) // mutex 解锁 // Allocate memory to hold a cgo traceback if the cgo call crashes. // 如果cgo调用崩溃，分配内存保存cgo回溯。 if iscgo || GOOS == \"solaris\" || GOOS == \"illumos\" || GOOS == \"windows\" { mp.cgoCallers = new(cgoCallers) } } mReserveID() 向系统申请ID。就是递增的值。 文件位置：go1.19.3/src/runtime/proc.go。 769 770 771 772 773 774 775 776 777 778 779 780 781 782 783 784 785 786 // mReserveID returns the next ID to use for a new m. This new m is immediately // considered 'running' by checkdead. // // sched.lock must be held. func mReserveID() int64 { // 调用该方法时 sched.lock 锁必须已被持有 assertLockHeld(\u0026sched.lock) // mnext 值已经溢出 if sched.mnext+1 \u003c sched.mnext { throw(\"runtime: thread ID overflow\") } id := sched.mnext // 分配该值 sched.mnext++ // 检查是否超出设置的最大值 checkmcount() return id } 759 760 761 762 763 764 765 766 767 768 // sched.lock must be held. func checkmcount() { assertLockHeld(\u0026sched.lock) // sched.maxmcount 最大值默认被设置为 10000 if mcount() \u003e sched.maxmcount { print(\"runtime: program exceeds \", sched.maxmcount, \"-thread limit\\n\") throw(\"thread exhaustion\") } } 4490 4491 4492 4493 func mcount() int32 { // sched.nmfreed 已释放的工作线程数量 return int32(sched.mnext - sched.nmfreed) } mpreinit() mpreinit 为gsignal分配32KB栈，并绑定当前M。 文件位置：go1.19.3/src/runtime/os_linux.go。 381 382 383 384 385 386 // Called to initialize a new m (including the bootstrap m). // Called on the parent thread (main thread in case of bootstrap), can allocate memory. func mpreinit(mp *m) { mp.gsignal = malg(32 * 1024) // Linux wants \u003e= 2K mp.gsignal.m = mp } atomicstorep() atomicstorep 原子地执行 *ptr = new，并调用一个写屏障。 文件位置：go1.19.3/src/runtime/atomic_pointer.go。 28 29 30 31 32 33 34 35 36 37 // atomicstorep performs *ptr = new atomically and invokes a write barrier. // //go:nosplit func atomicstorep(ptr unsafe.Pointer, new unsafe.Pointer) { // 如果开启了写屏障 if writeBarrier.enabled { atomicwb((*unsafe.Pointer)(ptr), new) } atomic.StorepNoWB(noescape(ptr), new) // *ptr = new } 此时，主线程，m0，g0以及g0的栈之间的关系如下图所示： goargs() 保存argv参数到argslice中。 文件位置：go1.19.3/src/runtime/runtime1.go。 72 73 74 75 76 77 78 79 80 81 82 83 84 85 func goargs() { if GOOS == \"windows\" { return } // 申请参数需要的内存大小 argslice = make([]string, argc) for i := int32(0); i \u003c argc; i++ { // argv_index 在7.1.2中列出，就是偏移i个字节 argslice[i] = gostringnocopy(argv_index(argv, i)) } } var envs []string var argslice []string gostringnocopy组装成一个字符串。 文件位置：go1.19.3/src/runtime/string.go。 564 565 566 567 568 569 570 //go:nosplit func gostringnocopy(str *byte) string { // findnull寻找到null结束识别字符串长度 ss := stringStruct{str: unsafe.Pointer(str), len: findnull(str)} s := *(*string)(unsafe.Pointer(\u0026ss)) return s } goenvs() 解析环境变量。 文件位置：go1.19.3/src/runtime/os_linux.go。 367 368 369 func goenvs() { goenvs_unix() } 文件位置：go1.19.3/src/runtime/runtime1.go。 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 func goenvs_unix() { // TODO(austin): ppc64 in dynamic linking mode doesn't // guarantee env[] will immediately follow argv. Might cause // problems. n := int32(0) // 跳过argv + NULL，到envp，计算envp的长度。 // argv_index 参考7.1.2 for argv_index(argv, argc+1+n) != nil { n++ } envs = make([]string, n) // 申请n长度的内存 for i := int32(0); i \u003c n; i++ { envs[i] = gostring(argv_index(argv, argc+1+i)) } } 文件位置：go1.19.3/src/runtime/string.go。 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 // This is exported via linkname to assembly in syscall (for Plan9). // //go:linkname gostring func gostring(p *byte) string { l := findnull(p) // 找出字符串长度 if l == 0 { return \"\" } // rawstring 函数在字符串包中已经介绍过 // 分会的s和b分别共用一个底层，这样操作b切片s也会跟着改变 s, b := rawstring(l) // s string, b []byte // 拷贝数据到b中从p拷贝长度l字节。 memmove(unsafe.Pointer(\u0026b[0]), unsafe.Pointer(p), uintptr(l)) return s } 初始化allp 下面分析procresize()函数。 考虑到初始化完成之后用户代码还可以通过GOMAXPROCS()函数调用它重新创建和初始化p结构体对象。 而在运行过程中再动态的调整p牵涉到的问题比较多，所以这个函数的处理比较复杂。 procresize() 更改处理器数量。sched.lock必须被持有并且必须是在STW期间。 gcworkbufs不能被GC或写屏障代码修改，因此如果P数实际发生变化，GC必须不运行。 返回具有本地工作的p列表，它们需要由调用者调度。 该函数会在【程序初始化】或【startTheWorldWithSema】函数中被调用。 函数流程： 使用make([]*p, nprocs)初始化全局变量allp，即allp = make([]*p, nprocs)。 循环创建并初始化nprocs个p结构体对象并依次保存在allp切片之中。 把m0和allp[0]绑定在一起，即【m0.p = allp[0], allp[0].m = m0】。 把除了allp[0]之外的所有p放入到全局变量sched的pidle空闲队列之中。 文件位置：go1.19.3/src/runtime/proc.go。 4793 4794 4795 4796 4797 4798 4799 4800 4801 4802 4803 4804 4805 4806 4807 4808 4809 4810 4811 4812 4813 4814 4815 4816 4817 4818 4819 4820 4821 4822 4823 4824 4825 4826 4827 4828 4829 4830 4831 4832 4833 4834 4835 4836 4837 4838 4839 4840 4841 4842 4843 4844 4845 4846 4847 4848 4849 4850 4851 4852 4853 4854 4855 4856 4857 4858 4859 4860 4861 4862 4863 4864 4865 4866 4867 4868 4869 4870 4871 4872 4873 4874 4875 4876 4877 4878 4879 4880 4881 4882 4883 4884 4885 4886 4887 4888 4889 4890 4891 4892 4893 4894 4895 4896 4897 4898 4899 4900 4901 4902 4903 4904 4905 4906 4907 4908 4909 4910 4911 4912 4913 4914 4915 4916 4917 4918 4919 4920 4921 4922 4923 4924 4925 4926 4927 4928 4929 4930 4931 4932 4933 4934 4935 4936 4937 4938 4939 4940 4941 4942 4943 4944 4945 4946 4947 4948 4949 4950 4951 4952 4953 4954 4955 4956 4957 4958 4959 4960 4961 4962 4963 4964 4965 4966 4967 4968 4969 4970 4971 4972 4973 4974 4975 4976 4977 4978 4979 4980 4981 4982 4983 4984 // Change number of processors. // // sched.lock must be held, and the world must be stopped. // // gcworkbufs must not be being modified by either the GC or the write barrier // code, so the GC must not be running if the number of Ps actually changes. // // Returns list of Ps with local work, they need to be scheduled by the caller. func procresize(nprocs int32) *p { // sched.lock 锁已经被持有 assertLockHeld(\u0026sched.lock) // 必须是 STW 期间 assertWorldStopped() // 系统初始化时，gomaxprocs = 0 old := gomaxprocs // 旧的数量，也就是上次的数量 // nprocs 服务器cpu核数，或用户通过GOMAXPROCS环境变量指定的数量 if old \u003c 0 || nprocs \u003c= 0 { throw(\"procresize: invalid arg\") } if trace.enabled { traceGomaxprocs(nprocs) } // update statistics now := nanotime() // 当前时间 // sched.procresizetime 最后一次改变gomaxprocs的时间 if sched.procresizetime != 0 { // 从备注中看出该值是procresizetime变化的积分，因该用于统计相关 // ∫gomaxprocs dt up to procresizetime sched.totaltime += int64(old) * (now - sched.procresizetime) } sched.procresizetime = now // 以32为一组，分别处理P的标志位 // idlepMask：表示在_Pidle列表中的位掩码，每一个P表示一位，记录那些P处理_Pidle（空闲）状态 // timerpMask：表示P在timer上的位掩码，每一个P表示一位，记录P与timer相关（1表示有timer，0表示没有timer） // idlepMask和timerpMask用于快速判断P的状态和P上是否有timer。 maskWords := (nprocs + 31) / 32 // int32 // Grow allp if necessary. // // 如果有必要扩展allp。 if nprocs \u003e int32(len(allp)) { // 初始化时 或 P的数量扩大时 // Synchronize with retake, which could be running // concurrently since it doesn't run on a P. lock(\u0026allpLock)\t// 获取 mutex 锁 // 当前 allp 的容量足够本次扩展。处理P if nprocs \u003c= int32(cap(allp)) { allp = allp[:nprocs] } else { // 从新申请内存并拷贝 nallp := make([]*p, nprocs) // Copy everything up to allp's cap so we // never lose old allocated Ps. copy(nallp, allp[:cap(allp)]) allp = nallp } // idlepMask和timerpMask处理，容量够，直接使用 if maskWords \u003c= int32(cap(idlepMask)) { idlepMask = idlepMask[:maskWords] timerpMask = timerpMask[:maskWords] } else { // 容量不够，申请内存并搬迁 // 创建一个 []uint32，每一位分别代表一个P nidlepMask := make([]uint32, maskWords) // No need to copy beyond len, old Ps are irrelevant. copy(nidlepMask, idlepMask) idlepMask = nidlepMask ntimerpMask := make([]uint32, maskWords) copy(ntimerpMask, timerpMask) timerpMask = ntimerpMask } unlock(\u0026allpLock) // mutex 解锁 } // initialize new P's // // 初始化所有新创建的P，从old处开始因此之前的已经初始化了 for i := old; i \u003c nprocs; i++ { pp := allp[i] if pp == nil { // 可见P是堆分配的 pp = new(p) } pp.init(i) // 初始化当前P // 原子设置 【allp[i] = pp】 atomicstorep(unsafe.Pointer(\u0026allp[i]), unsafe.Pointer(pp)) // 保存allp中去 } _g_ := getg() // g0 // 当前m绑定了P时，初始化时m并没有绑定P，_g_.m.p == 0。 // _g_.m.p != 0 \u0026\u0026 _g_.m.p.ptr().id \u003c nprocs 这种情况成立发生在： // 发生扩容 或 发生缩容(当前P并不在裁剪之外) if _g_.m.p != 0 \u0026\u0026 _g_.m.p.ptr().id \u003c nprocs { // continue to use the current P // // 继续使用当前P，_Prunning 运行中状态 _g_.m.p.ptr().status = _Prunning _g_.m.p.ptr().mcache.prepareForSweep() // 清理 } else { // release the current P and acquire allp[0]. // // We must do this before destroying our current P // because p.destroy itself has write barriers, so we // need to do that from a valid P. if _g_.m.p != 0 { // 这种情况发生在P在缩容(当前P并不在裁剪之外) if trace.enabled { // Pretend that we were descheduled // and then scheduled again to keep // the trace sane. traceGoSched() traceProcStop(_g_.m.p.ptr()) } // 当前M绑定的p与当前M解绑 // 因为 M 与 P 相互绑定的，这里要解绑 _g_.m.p.ptr().m = 0 // p.m = 0 } // 初始化时，会走这里 // 解绑M与P关系 _g_.m.p = 0 // m.p = 0 // 选取allp[0]绑定当前工作线程 p := allp[0] p.m = 0 // _Pidle 空闲状态 p.status = _Pidle // 标记当前P为空闲状态 // 该方法要求P和M都是没有绑定的，并且P一定是_Pidle状态。 // p.m = m; m.p = p; acquirep(p) // m与p相互绑定，并修改p的状态为运行中。 if trace.enabled { traceGoStart() } } // g.m.p is now set, so we no longer need mcache0 for bootstrapping. // // g.m.p 现在已经设置，因此我们不再需要 mcache0 来进行引导。 // mcache0 在 p.init() 函数中被使用 mcache0 = nil // 该值在前面schedinit()函数中，栈相关初始化时被设置 // release resources from unused P's // // 从未使用的 P 释放资源，这种情况发生在缩容P时 for i := nprocs; i \u003c old; i++ { p := allp[i] p.destroy() // 回收P // can't free P itself because it can be referenced by an M in syscall // // 不能释放P本身，因为它可以被系统调用中的M引用 } // Trim allp. // 裁剪 allp。 if int32(len(allp)) != nprocs { lock(\u0026allpLock) allp = allp[:nprocs] idlepMask = idlepMask[:maskWords] timerpMask = timerpMask[:maskWords] unlock(\u0026allpLock) } var runnablePs *p // 遍历所有P，处理P的本地队列中有goroutine的需要绑定M运行这些goroutine。 for i := nprocs - 1; i \u003e= 0; i-- { p := allp[i] // 跳过当前P，当前工作线程绑定的P正在执行这里的代码需要跳过 if _g_.m.p.ptr() == p { continue } p.status = _Pidle // 状态修改为 _Pidle 空闲 if runqempty(p) { // P的runq是空的时 pidleput(p, now) // 把当前P挂在全局sched空闲链表中 } else { p.m.set(mget()) // p绑定m p.link.set(runnablePs) runnablePs = p } } // 重置 stealOrder，该值用于随机从allp中偷取goroutine初始条件 stealOrder.reset(uint32(nprocs)) // 初始化P后面要用到偷取的数据 // 原子绑定 gomaxprocs = nprocs var int32p *int32 = \u0026gomaxprocs // make compiler check that gomaxprocs is an int32 atomic.Store((*uint32)(unsafe.Pointer(int32p)), uint32(nprocs)) // gomaxprocs = nprocs if old != nprocs { // Notify the limiter that the amount of procs has changed. gcCPULimiter.resetCapacity(now, nprocs) } // runnablePs != nil 说明除了当前P外的其他P中存在goroutine return runnablePs } p.init() 初始化P。 文件位置：go1.19.3/src/runtime/proc.go。 4669 4670 4671 4672 4673 4674 4675 4676 4677 4678 4679 4680 4681 4682 4683 4684 4685 4686 4687 4688 4689 4690 4691 4692 4693 4694 4695 4696 4697 4698 4699 4700 4701 4702 4703 4704 4705 4706 4707 4708 4709 4710 4711 4712 // init initializes pp, which may be a freshly allocated p or a // previously destroyed p, and transitions it to status _Pgcstop. func (pp *p) init(id int32) { pp.id = id\t// 分配P的id，该id是唯一的 pp.status = _Pgcstop // 设置P状态 _Pgcstop GC停止状态 pp.sudogcache = pp.sudogbuf[:0] // P上sudog缓存 pp.deferpool = pp.deferpoolbuf[:0] // P上defer池 pp.wbBuf.reset() // P的wbBuf重置，该字段与写屏障相关 // pp.mcache 没有初始化 if pp.mcache == nil { if id == 0 { // 程序刚初始化时，mcache0在schedinit()中的mallocinit()函数中被创建 if mcache0 == nil { throw(\"missing mcache?\") } // Use the bootstrap mcache0. Only one P will get // mcache0: the one with ID 0. pp.mcache = mcache0 } else { // 使用 allocmcache() 分配缓存 pp.mcache = allocmcache() } } if raceenabled \u0026\u0026 pp.raceprocctx == 0 { if id == 0 { pp.raceprocctx = raceprocctx0 raceprocctx0 = 0 // bootstrap } else { pp.raceprocctx = raceproccreate() } } lockInit(\u0026pp.timersLock, lockRankTimers) // 初始化 P.timersLock 锁 // This P may get timers when it starts running. Set the mask here // since the P may not go through pidleget (notably P 0 on startup). // // 这个P开始运行时可能会有times。在这里设置可能不会经过pidleget(特别是在启动时P 0)。 timerpMask.set(id) // Similarly, we may not go through pidleget before this P starts // running if it is P 0 on startup. // // 类似的，如果这个P是在启动的是P 0，我们可能不会在这个P开始运行之前经历pidleget。 idlepMask.clear(id) } acquirep() M和P相互绑定。m.p = p、p.m = m。 文件位置：go1.19.3/src/runtime/proc.go。 4938 4939 4940 4941 4942 4943 4944 4945 4946 4947 4948 4949 4950 4951 4952 4953 4954 4955 4956 4957 4958 4959 4960 4961 // Associate p and the current m. // // This function is allowed to have write barriers even if the caller // isn't because it immediately acquires _p_. // //go:yeswritebarrierrec func acquirep(_p_ *p) { // Do the part that isn't allowed to have write barriers. // // 不允许有写入障碍的部分。 wirep(_p_) // m与p相互绑定，并修改p的状态为运行中。 // Have p; write barriers now allowed. // Perform deferred mcache flush before this P can allocate // from a potentially stale mcache. // // 在这个P可以从可能过期的mcache进行分配之前执行延迟的mcache刷写。 _p_.mcache.prepareForSweep() // GC相关 if trace.enabled { traceProcStart() } } wirep() wirep是acquirep 的第一步，它实际上将当前M关联到 _p_。 这里不允许栈检查，以及写屏障相关代码，因为M还没有绑定P。 m与p相互绑定，并修改p的状态为运行中。 文件位置：go1.19.3/src/runtime/proc.go。 4959 4960 4961 4962 4963 4964 4965 4966 4967 4968 4969 4970 4971 4972 4973 4974 4975 4976 4977 4978 4979 4980 4981 4982 4983 4984 4985 4986 4987 // wirep is the first step of acquirep, which actually associates the // current M to _p_. This is broken out so we can disallow write // barriers for this part, since we don't yet have a P. // //go:nowritebarrierrec //go:nosplit func wirep(_p_ *p) { // 在当前这里只能是g0，但是其他地方可能是g _g_ := getg() // g0 // 此时M一定是没有绑定P的。 if _g_.m.p != 0 { throw(\"wirep: already in go\") } // 此时p一定没有绑定M，并且P一定是_Pidle状态（空闲） if _p_.m != 0 || _p_.status != _Pidle { id := int64(0) if _p_.m != 0 { id = _p_.m.ptr().id } print(\"wirep: p-\u003em=\", _p_.m, \"(\", id, \") p-\u003estatus=\", _p_.status, \"\\n\") throw(\"wirep: invalid p state\") } // M与P相互绑定，并设置P的状态为运行中 _g_.m.p.set(_p_) // m.p = _p_ _p_.m.set(_g_.m) // _p_.m = m // _Prunning 运行中状态 _p_.status = _Prunning // 修改当前P为运行状态 } p.destroy() destroy释放与pp相关的所有资源，并将其转换为状态_Pdead。 sched.lock必须被持有并且STW。 该函数处理P中的goroutine，以及迁移pp上所有的timer，以及写屏障相关内存释放等。 文件位置：go1.19.3/src/runtime/proc.go。 4707 4708 4709 4710 4711 4712 4713 4714 4715 4716 4717 4718 4719 4720 4721 4722 4723 4724 4725 4726 4727 4728 4729 4730 4731 4732 4733 4734 4735 4736 4737 4738 4739 4740 4741 4742 4743 4744 4745 4746 4747 4748 4749 4750 4751 4752 4753 4754 4755 4756 4757 4758 4759 4760 4761 4762 4763 4764 4765 4766 4767 4768 4769 4770 4771 4772 4773 4774 4775 4776 4777 4778 4779 4780 4781 4782 4783 4784 4785 4786 4787 4788 4789 4790 4791 4792 4793 4794 4795 4796 4797 4798 4799 4800 4801 4802 4803 4804 4805 4806 4807 4808 // destroy releases all of the resources associated with pp and // transitions it to status _Pdead. // // sched.lock must be held and the world must be stopped. func (pp *p) destroy() { assertLockHeld(\u0026sched.lock) assertWorldStopped() // Move all runnable goroutines to the global queue // // 将当前P的所有可运行的goroutines移动到全局队列 for pp.runqhead != pp.runqtail { // Pop from tail of local queue pp.runqtail-- gp := pp.runq[pp.runqtail%uint32(len(pp.runq))].ptr() // Push onto head of global queue globrunqputhead(gp) // 加入到全局队列池中 } // pp.runnext 上存在 goroutine，加入到全局池 if pp.runnext != 0 { globrunqputhead(pp.runnext.ptr()) pp.runnext = 0 } // P 中还有timer。 if len(pp.timers) \u003e 0 { // 当前工作线程绑定的P plocal := getg().m.p.ptr() // The world is stopped, but we acquire timersLock to // protect against sysmon calling timeSleepUntil. // This is the only case where we hold the timersLock of // more than one P, so there are no deadlock concerns. // // STW了，但是我们获得了timersLock来防止sysmon调用timeSleepUntil // 这是我们持有不止一个P的定时器锁的唯一情况，因此不存在死锁问题。 lock(\u0026plocal.timersLock) // plocal lock(\u0026pp.timersLock) // pp // 把pp.timers中所有有效的timer重新添加到plocal.timers中 // 这里把需要删除的pp上的所有timer转移到当前工作线程绑定的P上面 moveTimers(plocal, pp.timers) pp.timers = nil // 情况 pp.timers，因为timers已经迁移到了当前工作线程的P了。 // numTimers：记录的是堆中 timer 的总数，应该与 timers 切片的长度一致。 pp.numTimers = 0 // deletedTimers：记录的是堆中已删除但还未被移除的 timer 的总数。 pp.deletedTimers = 0 // timer0When：表示位于最小堆堆顶的 timer 的触发时间，也就是赋值其 when 字段。 atomic.Store64(\u0026pp.timer0When, 0) // pp.timer0When = 0 unlock(\u0026pp.timersLock) unlock(\u0026plocal.timersLock) } // Flush p's write barrier buffer. // // 刷新p的写屏障缓冲区。写屏障相关 if gcphase != _GCoff { wbBufFlush1(pp) pp.gcw.dispose() } for i := range pp.sudogbuf { pp.sudogbuf[i] = nil } pp.sudogcache = pp.sudogbuf[:0] for j := range pp.deferpoolbuf { pp.deferpoolbuf[j] = nil } pp.deferpool = pp.deferpoolbuf[:0] // 切换到g0栈处理mspancache systemstack(func() { // 相关内存释放 for i := 0; i \u003c pp.mspancache.len; i++ { // Safe to call since the world is stopped. mheap_.spanalloc.free(unsafe.Pointer(pp.mspancache.buf[i])) } pp.mspancache.len = 0 lock(\u0026mheap_.lock) pp.pcache.flush(\u0026mheap_.pages) unlock(\u0026mheap_.lock) }) freemcache(pp.mcache) // 释放内存 pp.mcache = nil gfpurge(pp) // 回收P traceProcFree(pp) if raceenabled { if pp.timerRaceCtx != 0 { // The race detector code uses a callback to fetch // the proc context, so arrange for that callback // to see the right thing. // This hack only works because we are the only // thread running. mp := getg().m phold := mp.p.ptr() mp.p.set(pp) racectxend(pp.timerRaceCtx) pp.timerRaceCtx = 0 mp.p.set(phold) } raceprocdestroy(pp.raceprocctx) pp.raceprocctx = 0 } pp.gcAssistTime = 0 pp.status = _Pdead // 修改P状态为空闲 } pidleput() 参数： _p_ *p：当前操作的p，该p的本地队列应该是空的。 now int64：当前时间。 把当_p_挂在全局sched空闲链表中。 文件位置：go1.19.3/src/runtime/proc.go。 5696 5697 5698 5699 5700 5701 5702 5703 5704 5705 5706 5707 5708 5709 5710 5711 5712 5713 5714 5715 5716 5717 5718 5719 5720 5721 5722 5723 5724 5725 5726 5727 5728 5729 5730 // pidleput puts p on the _Pidle list. now must be a relatively recent call // to nanotime or zero. Returns now or the current time if now was zero. // // This releases ownership of p. Once sched.lock is released it is no longer // safe to use p. // // sched.lock must be held. // // May run during STW, so write barriers are not allowed. // //go:nowritebarrierrec func pidleput(_p_ *p, now int64) int64 { // 调用该函数时 sched.lock 必须被持有 assertLockHeld(\u0026sched.lock) // 当前P准备放入空闲链表，因此runq中不能有goroutine if !runqempty(_p_) { throw(\"pidleput: P has non-empty run queue\") } if now == 0 { now = nanotime() } // 更新TimerPMask updateTimerPMask(_p_) // clear if there are no timers. idlepMask.set(_p_.id) // 标记_p_是空闲的 // 放入全局链表中 _p_.link = sched.pidle sched.pidle.set(_p_) // sched.pidle = _p_ // 空闲P数量加一 atomic.Xadd(\u0026sched.npidle, 1) // sched.npidle if !_p_.limiterEvent.start(limiterEventIdle, now) { throw(\"must be able to track idle limiter event\") } return now } 创建main goroutine schedinit完成调度系统初始化后。 返回到rt0_go函数中开始调用newproc()创建一个新的goroutine用于执行mainPC所对应的runtime·main函数。 文件位置：go1.19.3/src/runtime/asm_amd64.s。 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 # create a new goroutine to start program # # 创建一个新的goroutine来启动程序。 # AX = runtime·main # runtime·main 是一个闭包，\u0026funcval{fn:runtime.main} MOVQ $runtime·mainPC(SB), AX # entry # 将AX的值压入栈中 PUSHQ AX # AX的值作为runtime·newproc()函数的参数 CALL runtime·newproc(SB) # 创建main goroutine POPQ AX # start this M CALL runtime·mstart(SB) # 主线程进入循环调度，运行刚刚创建的goroutine # 上面的mstart永远不应该返回的，如果返回了，一定是代码逻辑有问题，直接abort CALL runtime·abort(SB)\t# mstart should never return RET # 前面没有获取到CPU相关信息时会走这里的异常 bad_cpu: # show that the program requires a certain microarchitecture level. MOVQ $2, 0(SP) MOVQ $bad_cpu_msg\u003c\u003e(SB), AX MOVQ AX, 8(SP) MOVQ $84, 16(SP) CALL runtime·write(SB) MOVQ $1, 0(SP) CALL runtime·exit(SB) CALL runtime·abort(SB) RET # Prevent dead-code elimination of debugCallV2, which is # intended to be called by debuggers. MOVQ $runtime·debugCallV2\u003cABIInternal\u003e(SB), AX RET argc和argv 在计算机编程中，通常使用命令行参数来向程序传递额外的信息。 C语言中的main函数接受两个参数，分别是argc和argv。 其中argc表示命令行参数的数量，而argv是一个指向参数字符串数组的指针，其中每个元素都包含一个命令行参数。 如果你在命令行中执行以下命令：$ my_program arg1 arg2 arg3 则argc的值将是4，其中包括程序名my_program和3个参数arg1、arg2和arg3。而argv指向一个字符串数组，其内容如下： argv[0] = \"my_program\" argv[1] = \"arg1\" argv[2] = \"arg2\" argv[3] = \"arg3\" 比如在Go语言中，argc和argv使用： 1 2 3 4 5 6 7 8 9 10 11 12 13 package main import ( \"fmt\" \"os\" ) func main() { args := os.Args // []string fmt.Printf(\"Path：%s\\n\", args[0]) fmt.Printf(\"Args：%#v\\n\", args[1:]) } 当我们执行go run命令运行上面的程序并传递一些参数时，将会得到类似以下的输出： [root@localhost hello1]# go run tt12.go foo bar baz js Path：/tmp/go-build1239766326/b001/exe/tt12 Args：[]string{\"foo\", \"bar\", \"baz\", \"js\"} ",
  "wordCount" : "7928",
  "inLanguage": "zh",
  "image": "https://heliu.site/favicon-32x32.png","datePublished": "2024-07-27T00:00:00Z",
  "dateModified": "2024-07-27T00:00:00Z",
  "author":[{
    "@type": "Person",
    "name": "helium"
  }],
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://heliu.site/posts/golang/goroutine/flow/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Helium",
    "logo": {
      "@type": "ImageObject",
      "url": "https://heliu.site/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://heliu.site/" accesskey="h" title="Blog (Alt + H)">
                <img src="https://heliu.site/helium.png" alt="" aria-label="logo"
                    height="35">Blog</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://heliu.site/" title="主页">
                    <span>Home</span>
                </a>
            </li>
            <li>
                <a href="https://heliu.site/posts" title="文章">
                    <span>Article</span>
                </a>
            </li>
            <li>
                <a href="https://heliu.site/archives" title="时间轴">
                    <span>Archive</span>
                </a>
            </li>
            <li>
                <a href="https://heliu.site/tags/" title="标签">
                    <span>Tag</span>
                </a>
            </li>
            <li>
                <a href="https://heliu.site/search/" title="搜索 (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
            <li>
                <a href="https://heliu.site/support" title="打赏">
                    <span>🫶Help</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">


<article class="post" autonumbering>
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://heliu.site/">主页</a>&nbsp;»&nbsp;<a href="https://heliu.site/posts/">Article</a>&nbsp;»&nbsp;<a href="https://heliu.site/posts/golang/">Golang 合集</a>&nbsp;»&nbsp;<a href="https://heliu.site/posts/golang/goroutine/">第12章 Goroutine</a></div>
    <h1 class="post-title entry-hint-parent">
      Go 执行流程
    </h1>
    <div class="post-description">
      💥本文章所有相关go代码参考自go 1.18&#43;版本
    </div>
    <div class="post-meta">










<span class="x-post-meta-item"><svg t="1720837714681" class="icon" viewBox="0 0 1084 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="7520" width="200" height="200"><path d="M123.47509 1023.984942a123.565437 123.565437 0 0 1-123.505206-123.32451V243.863302A123.565437 123.565437 0 0 1 123.47509 120.568908h171.630374V26.06529a26.050232 26.050232 0 0 1 52.070349 0v94.503618h377.592848V26.06529a26.050232 26.050232 0 0 1 52.100464 0v94.503618h183.797189A123.565437 123.565437 0 0 1 1084.171519 243.863302v656.79713A123.565437 123.565437 0 0 1 960.666314 1023.984942H123.47509z m-71.404741-123.32451A71.434857 71.434857 0 0 0 123.47509 971.974825h837.191224a71.434857 71.434857 0 0 0 71.404741-71.314393V442.326922l-946.361273-3.824716a25.598494 25.598494 0 0 1-5.84248-0.692665l-27.796953-6.444798v469.295689zM123.47509 172.579025a71.434857 71.434857 0 0 0-71.404741 71.284277v149.736133l27.796953-6.444797a26.080348 26.080348 0 0 1 5.902712-0.662549l946.301041 3.824716V243.863302a71.404741 71.404741 0 0 0-71.404741-71.284277h-180.183284l-6.173754 12.859479a26.200812 26.200812 0 0 1-23.490383 14.786895 26.261043 26.261043 0 0 1-23.520499-14.786895l-6.173754-12.859479H350.819834l-6.173754 12.859479a26.200812 26.200812 0 0 1-23.490383 14.786895 26.230928 26.230928 0 0 1-23.520499-14.786895l-6.173755-12.859479H123.47509z m156.150814 578.827128a26.050232 26.050232 0 0 1-26.050232-25.990001c0-14.335157 11.68496-26.020116 26.050232-26.020116h521.697312c14.365273 0 26.050232 11.68496 26.050233 26.020116a26.050232 26.050232 0 0 1-26.050233 25.990001H279.625904z" fill="#3D3F42" p-id="7521"></path></svg><span>2024-07-27</span></span>&nbsp;<span class="x-post-meta-item"><svg t="1720839329181" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="14106" width="200" height="200"><path d="M699.270662 190.485379c-0.411369 0-0.821715 0.011256-1.227967 0.032746H507.034407a23.041786 23.041786 0 0 0-1.221828-0.031723c-12.779048 0-23.140023 10.359952-23.140023 23.139 0 12.781094 10.360975 23.141046 23.140023 23.141046v0.032746h193.458083v-0.032746c12.780071 0 23.141046-10.359952 23.141047-23.141046 0-12.780071-10.360975-23.140023-23.141047-23.140023zM979.215516 724.005508c0-142.090159-115.186416-257.277598-257.277598-257.277598-72.245418 0-137.532353 29.777187-184.262654 77.725223l45.868677 31.474852c36.227086-33.873482 84.882226-54.617945 138.393977-54.617945 111.945605 0 202.696492 90.750887 202.696492 202.695468h-43.01263l70.331835 104.289228 70.331835-104.289228H979.215516z" fill="" p-id="14107"></path><path d="M748.885664 588.843132c0-14.881942-12.06785-26.945699-26.947746-26.945698-14.883989 0-26.947745 12.063757-26.947745 26.945698v135.164423c0 14.879895 12.063757 26.945699 26.947745 26.945699h107.786889c14.881942 0 26.945699-12.063757 26.945698-26.945699s-12.063757-26.945699-26.945698-26.945699h-80.839143V588.843132zM721.937918 926.702c-111.947651 0-202.696492-90.74884-202.696492-202.696492 0-0.144286 0.004093-0.285502 0.004094-0.429788h43.004443l-70.330812-104.289228-70.331835 104.289228h43.075051c0 0.144286-0.00307 0.285502-0.00307 0.429788 0 142.091182 115.187439 257.279644 257.278621 257.279645 72.241324 0 137.530306-29.77821 184.260607-77.727269l-45.86663-31.474852c-36.227086 33.873482-84.884272 54.618968-138.393977 54.618968zM694.633039 423.38066c-1.354857-11.487635-11.120268-20.400632-22.972201-20.400632H206.362486c-12.780071 0-23.140023 10.359952-23.140023 23.138999 0 12.781094 10.359952 23.141046 23.140023 23.141047H596.949252c30.209022-13.81668 63.104223-22.76754 97.683787-25.879414zM438.548616 623.143333H206.362486c-12.780071 0-23.140023 10.358929-23.140023 23.140023 0 12.780071 10.359952 23.140023 23.140023 23.140023h219.956598a298.463626 298.463626 0 0 1 12.229532-46.280046zM506.934123 513.062192H206.362486c-12.780071 0-23.140023 10.359952-23.140023 23.139 0 12.781094 10.359952 23.140023 23.140023 23.140023H469.936487a302.241672 302.241672 0 0 1 36.997636-46.279023z" fill="" p-id="14108"></path><path d="M442.765661 835.277778a298.531164 298.531164 0 0 1-14.365173-46.150087H146.542052v-0.065491c-33.036417 0-59.81941-26.78197-59.81941-59.819411V329.36031h704.907545v100.905154a298.561863 298.561863 0 0 1 46.150086 14.996552V194.619536h-0.162706c0-53.422723-43.307342-96.728018-96.730065-96.728018h-68.89409V84.418668c0-33.037441-26.782993-59.81941-59.81941-59.81941v-0.361227h-18.87079v0.032745c-33.038464 0-59.820434 26.78197-59.820433 59.819411 0 0.109494 0.008186 0.218988 0.008186 0.328481h-0.339738v13.47285H345.203648V84.418668c0-33.037441-26.782993-59.81941-59.819411-59.81941v-0.361227h-18.872836v0.032745c-33.036417 0-59.81941 26.78197-59.81941 59.819411 0 0.109494 0.007163 0.218988 0.008186 0.328481h-0.339737v13.47285h-69.189826c-53.4217 0-96.729042 43.306318-96.729041 96.728018 0 1.701758 0.045025 3.39226 0.132006 5.071505v533.785166a98.051153 98.051153 0 0 0-0.132006 5.071506c0 53.4217 43.307342 96.728018 96.729041 96.728018v0.001023h305.595047zM86.723665 204.056466c0-33.037441 26.782993-59.81941 59.819411-59.819411 0.044002 0 0.086981 0.00307 0.130983 0.00307v-0.068561h105.968473V94.874811h0.032746a22.807449 22.807449 0 0 1-0.032746-1.215688c0-12.779048 10.360975-23.140023 23.140023-23.140023s23.140023 10.360975 23.140023 23.140023c0 0.408299-0.010233 0.812505-0.031722 1.215688h0.031722v49.297776h280.508696V94.874811h0.032745a22.807449 22.807449 0 0 1-0.032745-1.215688c0-12.779048 10.361999-23.140023 23.140023-23.140023 12.780071 0 23.141046 10.360975 23.141046 23.140023 0 0.408299-0.011256 0.812505-0.032746 1.215688h0.032746v49.297776h106.10048v0.065492c33.035394 0 59.818387 26.780947 59.818387 59.81941h0.130983V283.080264H86.723665v-79.023798z" fill="" p-id="14109"></path></svg><span>2024-07-27</span></span>&nbsp;<span class="x-post-meta-item"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2" fill="none"
     stroke-linecap="round" stroke-linejoin="round" class="feather feather-file-text" style="user-select: text;">
    <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z" style="user-select: text;"></path>
    <polyline points="14 2 14 8 20 8" style="user-select: text;"></polyline>
    <line x1="16" y1="13" x2="8" y2="13" style="user-select: text;"></line>
    <line x1="16" y1="17" x2="8" y2="17" style="user-select: text;"></line>
    <polyline points="10 9 9 9 8 9" style="user-select: text;"></polyline>
</svg><span>7928字</span></span>&nbsp;<span class="x-post-meta-item"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2" fill="none"
     stroke-linecap="round" stroke-linejoin="round">
    <path stroke="none" d="M0 0h24v24H0z" fill="none"></path>
    <circle cx="12" cy="12" r="9"></circle>
    <polyline points="12 7 12 12 15 15"></polyline>
</svg><span>38分钟</span></span>&nbsp;<span class="x-post-meta-item"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2" fill="none"
     stroke-linecap="round" stroke-linejoin="round">
    <path stroke="none" d="M0 0h24v24H0z" fill="none"></path>
    <circle cx="12" cy="7" r="4"></circle>
    <path d="M6 21v-2a4 4 0 0 1 4 -4h4a4 4 0 0 1 4 4v2"></path>
</svg><span>helium</span></span>
      <span class="x-post-meta-item">
        &nbsp;<svg t="1720840393161" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="18680" width="200" height="200"><path d="M995.125144 559.61812l-415.998603-415.998602A52.986489 52.986489 0 0 0 541.413335 127.99957H338.847348c-3.166656-26.559911-9.286635-51.046495-17.999939-71.333094C299.734146 7.333309 271.154242 0 256.00096 0c-13.939953 0-40.439864 6.339979-61.259794 48.806503-10.473298 21.366595-17.946606 48.966502-21.573261 79.193067H53.334974a53.393154 53.393154 0 0 0-53.333154 53.333154v360.078791a52.986489 52.986489 0 0 0 15.619948 37.713206l415.998602 415.998603a53.333154 53.333154 0 0 0 75.426413 0l26.286579-26.293245 26.286578 26.293245a53.426487 53.426487 0 0 0 16.719944 11.333295 21.333262 21.333262 0 0 0 36.079879 11.293295l382.705381-382.705381a53.399821 53.399821 0 0 0 0-75.426413z m-762.070774-491.998347C241.494342 50.373164 250.667645 42.666523 256.00096 42.666523c5.99998 0 16.573278 9.639968 25.646581 30.806564 6.493312 15.159949 11.333295 33.999886 14.146619 54.526483H216.16776c3.206656-23.419921 9.013303-44.359851 16.88661-60.41313z m243.819181 897.330319a10.666631 10.666631 0 0 1-15.079949 0l-415.998603-415.998603A10.573298 10.573298 0 0 1 42.668343 541.411515V181.332724a10.666631 10.666631 0 0 1 10.666631-10.666631h245.332509c0 47.853173-10.373298 92.15969-27.066575 115.632945-5.926647 8.326639-16.566611 14.186619-22.306592 16.113279C204.041135 314.752276 170.667913 356.218803 170.667913 405.331972c0 58.813136 47.853173 106.666308 106.666309 106.666308s106.666308-47.853173 106.666308-106.666308c0-47.086508-30.666564-87.139707-73.079754-101.246327C330.060711 272.705751 341.334007 223.692582 341.334007 170.666093h72.079758a10.573298 10.573298 0 0 1 7.539974 3.126656l415.998603 415.998603a10.666631 10.666631 0 0 1 0 15.079949zM341.334007 405.331972a63.999785 63.999785 0 1 1-63.999785-63.999785 64.073118 64.073118 0 0 1 63.999785 63.999785z m263.539114 559.61812a10.666631 10.666631 0 0 1-15.079949 0L563.499927 938.663513l303.625647-303.61898a53.399821 53.399821 0 0 0 0-75.426413L478.16688 170.666093h63.246455a10.573298 10.573298 0 0 1 7.539974 3.126656l415.998603 415.998603c0.239999 0.239999 0.466665 0.486665 0.666664 0.746664l0.086667 0.106666a10.666631 10.666631 0 0 1 0 13.373289l-0.086667 0.106666c-0.213333 0.259999-0.439999 0.506665-0.666664 0.746664z" fill="#5C5C66" p-id="18681"></path></svg>
        <ul class="post-tags-meta" style="display: inline-block;font-size: 14px;">
            <a href="https://heliu.site/tags/golang/" target="_blank" rel="noopener">Golang</a>
            <a href="https://heliu.site/tags/goroutine/" target="_blank" rel="noopener">Goroutine</a>
        </ul>
      </span>
      
      <span id="busuanzi_container_page_pv" class="x-post-meta-item">
        &nbsp;<svg t="1720844685710" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="27237" width="200" height="200"><path d="M739.754667 574.08c-121.386667 45.610667-208.469333 169.813333-208.64 316.16 0 33.408 4.693333 65.493333 13.141333 95.914667H94.122667c-26.453333-43.52-41.685333-91.946667-41.685334-143.189334 0-185.173333 192.896-335.104 430.805334-335.104 96.256 0 184.832 24.746667 256.512 66.218667z m-280.490667-114.986667a214.869333 214.869333 0 0 1-214.869333-215.04A215.04 215.04 0 0 1 459.264 28.842667a215.04 215.04 0 0 1 215.04 215.210666 215.04 215.04 0 0 1-215.04 215.04zM974.506667 641.28c9.856 0 17.834667 7.466667 17.834666 16.64v59.989333c-0.341333 8.789333-7.850667 15.786667-17.28 16.085334-9.856 0.341333-18.176-6.826667-18.517333-16.085334v-20.053333l-99.114667 91.093333-0.256 0.256a18.474667 18.474667 0 0 1-14.848 4.352h-0.768a18.176 18.176 0 0 1-9.344-4.608l-0.938666-0.981333-85.930667-80.042667-123.562667 115.072a18.773333 18.773333 0 0 1-25.216 0 15.786667 15.786667 0 0 1 0-23.466666l136.149334-126.848 0.725333-0.597334a18.645333 18.645333 0 0 1 24.362667 0.512l87.253333 81.237334 86.058667-79.232h-21.248c-9.386667-0.298667-16.938667-7.338667-17.28-16.085334-0.341333-9.173333 7.381333-16.896 17.28-17.237333h64.64z m-367.146667 240h48.128c8.874667 0 16.042667 7.168 16.042667 16.042667v72.192a16.042667 16.042667 0 0 1-16.042667 16.042666h-48.128a16.042667 16.042667 0 0 1-16.042667-16.042666v-72.192c0-8.874667 7.210667-16.042667 16.042667-16.042667z m110.805333-106.666667h48.128c8.874667 0 16.042667 7.168 16.042667 16.042667v178.858667a16.042667 16.042667 0 0 1-16.042667 16.042666h-48.128a16.042667 16.042667 0 0 1-16.042666-16.042666v-178.858667c0-8.874667 7.168-16.042667 16.042666-16.042667z m106.538667 80h48.128c8.874667 0 16.042667 7.168 16.042667 16.042667v99.413333a16.042667 16.042667 0 0 1-16.042667 16.042667H824.746667a16.042667 16.042667 0 0 1-16.042667-16.042667v-99.413333c0-8.874667 7.168-16.042667 16.042667-16.042667z m110.165333-80h48.128c8.874667 0 16.042667 7.168 16.042667 16.042667v179.413333a16.042667 16.042667 0 0 1-16.042667 16.042667h-48.128a16.042667 16.042667 0 0 1-16.042666-16.042667v-179.413333c0-8.874667 7.210667-16.042667 16.042666-16.042667z" fill="#999999" p-id="27238"></path></svg>
        <span id="busuanzi_value_page_pv"></span>
      </span>

</div>
  </header> <aside id="toc-container" class="toc-container wide">
    <div class="toc">
        <details  open>
            <summary accesskey="c" title="(Alt + C)">
                <span class="details">目录</span>
            </summary>

            <div class="inner"><ul>
                    <li>
                        <a href="#%e7%a8%8b%e5%ba%8f%e5%8a%a0%e8%bd%bd%e9%98%b6%e6%ae%b5" aria-label="程序加载阶段">程序加载阶段</a></li>
                    <li>
                        <a href="#%e7%a8%8b%e5%ba%8f%e5%85%a5%e5%8f%a3" aria-label="程序入口">程序入口</a></li>
                    <li>
                        <a href="#%e5%88%9d%e5%a7%8b%e5%8c%96g0" aria-label="初始化g0">初始化<code>g0</code></a></li>
                    <li>
                        <a href="#cpu-%e7%9b%b8%e5%85%b3" aria-label="CPU 相关">CPU 相关</a></li>
                    <li>
                        <a href="#%e4%b8%bb%e7%ba%bf%e7%a8%8b%e4%b8%8em0%e7%bb%91%e5%ae%9a" aria-label="主线程与m0绑定">主线程与<code>m0</code>绑定</a><ul>
                            
                    <li>
                        <a href="#%e8%ae%be%e7%bd%aetls" aria-label="设置tls">设置tls</a></li>
                    <li>
                        <a href="#m0%e7%bb%91%e5%ae%9a" aria-label="m0绑定"><code>m0</code>绑定</a></li></ul>
                    </li>
                    <li>
                        <a href="#%e6%a3%80%e6%9f%a5" aria-label="检查">检查</a></li>
                    <li>
                        <a href="#%e5%88%9d%e5%a7%8b%e5%8c%96m0" aria-label="初始化m0">初始化<code>m0</code></a><ul>
                            
                    <li>
                        <a href="#argssb-" aria-label="args(SB) "><code>args(SB) </code></a><ul>
                            
                    <li>
                        <a href="#sysargs" aria-label="sysargs()">sysargs()</a></li>
                    <li>
                        <a href="#argv_index" aria-label="argv_index()">argv_index()</a></li>
                    <li>
                        <a href="#sysauxv" aria-label="sysauxv()">sysauxv()</a></li></ul>
                    </li>
                    <li>
                        <a href="#osinitsb" aria-label="osinit(SB)">osinit(SB)</a><ul>
                            
                    <li>
                        <a href="#%e8%8e%b7%e5%8f%96cpu%e6%a0%b8%e6%95%b0" aria-label="获取cpu核数">获取cpu核数</a></li>
                    <li>
                        <a href="#%e8%8e%b7%e5%8f%96%e7%89%a9%e7%90%86%e5%86%85%e5%ad%98%e9%a1%b5%e5%a4%a7%e5%b0%8f" aria-label="获取物理内存页大小">获取物理内存页大小</a></li></ul>
                    </li>
                    <li>
                        <a href="#schedinitsb" aria-label="schedinit(SB)">schedinit(SB)</a><ul>
                            
                    <li>
                        <a href="#mcommoninit" aria-label="mcommoninit()">mcommoninit()</a></li>
                    <li>
                        <a href="#goargs" aria-label="goargs()">goargs()</a></li>
                    <li>
                        <a href="#goenvs" aria-label="goenvs()">goenvs()</a></li></ul>
                    </li>
                    <li>
                        <a href="#%e5%88%9d%e5%a7%8b%e5%8c%96allp" aria-label="初始化allp">初始化allp</a><ul>
                            
                    <li>
                        <a href="#procresize" aria-label="procresize()">procresize()</a></li>
                    <li>
                        <a href="#pinit" aria-label="p.init()">p.init()</a></li>
                    <li>
                        <a href="#acquirep" aria-label="acquirep()">acquirep()</a></li>
                    <li>
                        <a href="#wirep" aria-label="wirep()">wirep()</a></li>
                    <li>
                        <a href="#pdestroy" aria-label="p.destroy()">p.destroy()</a></li>
                    <li>
                        <a href="#pidleput" aria-label="pidleput()">pidleput()</a></li></ul>
                    </li></ul>
                    </li>
                    <li>
                        <a href="#%e5%88%9b%e5%bb%bamain-goroutine" aria-label="创建main goroutine">创建<code>main goroutine</code></a></li>
                    <li>
                        <a href="#argc%e5%92%8cargv" aria-label="argc和argv">argc和argv</a>
                    </li>
                </ul>
            </div>
        </details>
    </div>
</aside>
<script>
    let activeElement;
    let elements;
    window.addEventListener('DOMContentLoaded', function (event) {
        checkTocPosition();

        elements = document.querySelectorAll('h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]');
         
         activeElement = elements[0];
         const id = encodeURI(activeElement.getAttribute('id')).toLowerCase();
         document.querySelector(`.inner ul li a[href="#${id}"]`).classList.add('active');
     }, false);

    window.addEventListener('resize', function(event) {
        checkTocPosition();
    }, false);

    window.addEventListener('scroll', () => {
        
        activeElement = Array.from(elements).find((element) => {
            if ((getOffsetTop(element) - window.pageYOffset) > 0 && 
                (getOffsetTop(element) - window.pageYOffset) < window.innerHeight/2) {
                return element;
            }
        }) || activeElement

        elements.forEach(element => {
             const id = encodeURI(element.getAttribute('id')).toLowerCase();
             if (element === activeElement){
                 document.querySelector(`.inner ul li a[href="#${id}"]`).classList.add('active');
             } else {
                 document.querySelector(`.inner ul li a[href="#${id}"]`).classList.remove('active');
             }
         })
     }, false);

    const main = parseInt(getComputedStyle(document.body).getPropertyValue('--article-width'), 10);
    const toc = parseInt(getComputedStyle(document.body).getPropertyValue('--toc-width'), 10);
    const gap = parseInt(getComputedStyle(document.body).getPropertyValue('--gap'), 10);

    function checkTocPosition() {
        const width = document.body.scrollWidth;

        if (width - main - (toc * 2) - (gap * 4) > 0) {
            document.getElementById("toc-container").classList.add("wide");
        } else {
            document.getElementById("toc-container").classList.remove("wide");
        }
    }

    function getOffsetTop(element) {
        if (!element.getClientRects().length) {
            return 0;
        }
        let rect = element.getBoundingClientRect();
        let win = element.ownerDocument.defaultView;
        return rect.top + win.pageYOffset;   
    }
</script>
  <div class="post-content"><ol>
<li>示例代码。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kn">package</span> <span class="nx">main</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="s">&#34;fmt&#34;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;Hello World!&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="程序加载阶段">程序加载阶段<a hidden class="anchor" aria-hidden="true" href="#程序加载阶段">#</a></h2>
<ol>
<li>程序在被操作系统加载起来运行时都会依次经过如下阶段：
<ol>
<li>从磁盘上把可执行程序读入内存。</li>
<li>创建进程和主线程。</li>
<li>为主线程分配栈空间。</li>
<li>把由用户在命令行输入的参数拷贝到主线程的栈。</li>
<li>把主线程放入操作系统的运行队列等待被调度执行起来运行。</li>
</ol>
</li>
<li>在主线程第一次被调度起来执行第一条指令之前，主线程的函数栈如下图所示：<code>sp</code>指向栈顶。</li>
</ol>
<p><img loading="lazy" src="../images/goroutine-001.png" alt=""  />
</p>
<ol start="3">
<li>相关概念：
<ol>
<li><strong><code>rsp</code></strong>：指向当前栈的栈顶，表示当前栈已经用到什么位置。</li>
<li><strong><code>rbp</code></strong>：指向当前栈的栈底，表示当前栈的起点位置。</li>
<li><strong><code>rip</code></strong>：<code>CPU</code>即将执行的下一条指令在内存中的地址，控制着程序的流程。</li>
<li><strong><code>SB</code></strong>：<code>GO</code>汇编相关的虚拟寄存器，保存程序地址空间的起始地址。
<ul>
<li><code>SB</code>寄存器保存的是当前函数在代码区的起始位置。</li>
<li>出现在<code>GO</code>汇编的函数定义、函数调用、全局变量定义以及对其引用会用到这个<code>SB</code>虚拟寄存器。</li>
</ul>
</li>
<li><strong><code>FP</code></strong>：<code>GO</code>汇编相关的虚拟寄存器，主要用来引用函数参数。
<ul>
<li><code>Go</code>语言规定函数调用时参数都必须放在栈上，比如被调用函数使用<code>first_arg+0(FP)</code>来引用调用者传递进来的第一个参数。</li>
<li>用<code>second_arg+8(FP)</code>来引用第二个参数等。这里的<code>first_arg</code>和<code>second_arg</code>仅仅是一个帮助我们阅读源代码的符号。</li>
<li>对编译器来说无实际意义，+0和+8表示相对于<code>FP</code>寄存器的偏移量。</li>
</ul>
</li>
<li><strong><code>$16-8</code></strong>：数字16说明此函数的栈帧大小为16字节，8说明此函数的参数和返回值一共需要占用8字节内存。</li>
</ol>
</li>
</ol>
<h2 id="程序入口">程序入口<a hidden class="anchor" aria-hidden="true" href="#程序入口">#</a></h2>
<ol>
<li>第一行代码：定义了<code>_rt0_amd64_linux</code>这个符号，并不是真正的<code>CPU</code>指令。
<ul>
<li><code>NOSPLIT</code>告诉编译器不要在这个函数中插入检查栈是否溢出的代码。</li>
</ul>
</li>
<li>第二行的<code>JMP</code>指令：才是主线程的第一条指令。
<ul>
<li>这条指令简单的跳转到（相当于<code>go</code>语言或<code>c</code>中的<code>goto</code>关键字）<code>_rt0_amd64</code> 这个符号处继续执行。</li>
</ul>
</li>
<li>文件位置：<code>go1.19.3/src/runtime/rt0_linux_amd64.s</code>。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-asm" data-lang="asm"><span class="line"><span class="cl"><span class="nf">TEXT</span> <span class="no">_rt0_amd64_linux</span><span class="p">(</span><span class="no">SB</span><span class="p">),</span><span class="no">NOSPLIT</span><span class="p">,</span><span class="no">$-8</span>
</span></span><span class="line"><span class="cl">    <span class="nf">JMP</span> <span class="no">_rt0_amd64</span><span class="p">(</span><span class="no">SB</span><span class="p">)</span>
</span></span></code></pre></td></tr></table>
</div>
</div><hr>
<ol>
<li>前两行指令：把操作系统内核传递过来的参数<code>argc</code>和<code>argv</code>数组的地址分别放在<code>DI</code>和<code>SI</code>寄存器中。
<ul>
<li>需要注意的是：【<code>MOVQ 0(SP), DI</code>】拷贝的是<code>argc</code>的值是个8字节的存储的是参数的个数，是个数字。</li>
<li>【<code>LEAQ 8(SP), SI</code>】则是取的<code>argv</code>的地址，是个指针<code>*argv</code>，也是8字节。</li>
</ul>
</li>
<li>第三行指令：跳转到 <code>rt0_go</code> 去执行。</li>
<li>文件位置：<code>go1.19.3/src/runtime/asm_amd64.s</code>。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-asm" data-lang="asm"><span class="line"><span class="cl"><span class="c1"># _rt0_amd64 is common startup code for most amd64 systems when using
</span></span></span><span class="line"><span class="cl"><span class="c1"># internal linking. This is the entry point for the program from the
</span></span></span><span class="line"><span class="cl"><span class="c1"># kernel for an ordinary -buildmode=exe program. The stack holds the
</span></span></span><span class="line"><span class="cl"><span class="c1"># number of arguments and the C-style argv.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nf">TEXT</span> <span class="no">_rt0_amd64</span><span class="p">(</span><span class="no">SB</span><span class="p">),</span><span class="no">NOSPLIT</span><span class="p">,</span><span class="no">$-8</span>
</span></span><span class="line"><span class="cl">    <span class="nf">MOVQ</span>    <span class="mi">0</span><span class="p">(</span><span class="no">SP</span><span class="p">),</span> <span class="no">DI</span>   <span class="c1"># DI = argc
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1"># 假设SP存储值为0x00ff00，则SI=0x00ff08，指向的是 *argv
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">LEAQ</span>    <span class="mi">8</span><span class="p">(</span><span class="no">SP</span><span class="p">),</span> <span class="no">SI</span>   <span class="c1"># SI = 8(SP); *argv
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">JMP</span>	<span class="no">runtime</span><span class="err">·</span><span class="no">rt0_go</span><span class="p">(</span><span class="no">SB</span><span class="p">)</span>
</span></span></code></pre></td></tr></table>
</div>
</div><hr>
<ol>
<li><code>rt0_go</code>函数完成了<code>go</code>程序启动时的所有初始化工作。</li>
<li>第<code>4</code>条指令（<code>ANDQ $~15, SP</code>）：
<ul>
<li>用于调整栈顶寄存器的值使其按16字节对齐，也就是让栈顶寄存器<code>SP</code>指向的内存的地址为16的倍数。</li>
<li><strong>之所以要按16字节对齐，是因为CPU有一组SSE指令，这些指令中出现的内存地址必须是16的倍数</strong>。</li>
</ul>
</li>
<li>最后两条指令：把<code>argc</code>和<code>argv</code>搬到新的位置。</li>
<li>文件位置：<code>go1.19.3/src/runtime/asm_amd64.s</code>。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">159
</span><span class="lnt">160
</span><span class="lnt">161
</span><span class="lnt">162
</span><span class="lnt">163
</span><span class="lnt">164
</span><span class="lnt">165
</span><span class="lnt">166
</span><span class="lnt">167
</span><span class="lnt">168
</span><span class="lnt">169
</span><span class="lnt">170
</span><span class="lnt">171
</span><span class="lnt">172
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-asm" data-lang="asm"><span class="line"><span class="cl"><span class="nf">TEXT</span> <span class="no">runtime</span><span class="err">·</span><span class="no">rt0_go</span><span class="p">(</span><span class="no">SB</span><span class="p">),</span><span class="no">NOSPLIT</span><span class="err">|</span><span class="no">TOPFRAME</span><span class="p">,</span><span class="no">$0</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># copy arguments forward on an even stack
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1"># 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1"># 在偶数栈上向前复制参数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1"># argc是个8字节的数值，因此AX存储的是拷贝的值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1"># argv根据前面可知，这里BX存储的是argv的地址，因此原数据还在8(SP)的位置
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">MOVQ</span>    <span class="no">DI</span><span class="p">,</span> <span class="no">AX</span>      <span class="c1"># AX=argc
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">MOVQ</span>    <span class="no">SI</span><span class="p">,</span> <span class="no">BX</span>      <span class="c1"># BX=*argv
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">SUBQ</span>    <span class="no">$</span><span class="p">(</span><span class="mi">5</span><span class="p">*</span><span class="mi">8</span><span class="p">),</span> <span class="no">SP</span>  <span class="c1"># 3args 2auto
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1"># $~15：0000_1111 -&gt; 1111_0000
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1"># 经过 ANDQ 调整后，一定是大于等于40byte
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">ANDQ</span>    <span class="no">$</span><span class="err">~</span><span class="mi">15</span><span class="p">,</span> <span class="no">SP</span>    <span class="c1"># 调整栈顶寄存器使其按16字节对齐
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">MOVQ</span>    <span class="no">AX</span><span class="p">,</span> <span class="mi">24</span><span class="p">(</span><span class="no">SP</span><span class="p">)</span>  <span class="c1"># argc放在SP+24字节处
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">MOVQ</span>    <span class="no">BX</span><span class="p">,</span> <span class="mi">32</span><span class="p">(</span><span class="no">SP</span><span class="p">)</span>  <span class="c1"># argv放在SP+32字节处，此时是argv的地址，*argv
</span></span></span></code></pre></td></tr></table>
</div>
</div><p><img loading="lazy" src="../images/goroutine-002.png" alt=""  />
</p>
<ol start="5">
<li>总结：这部分代码完成了<code>argc</code>和<code>argv</code>的拷贝（<code>argv</code>是拷贝了地址，<code>argv</code>则是拷贝了副本值），栈按照16字节对齐了。</li>
</ol>
<h2 id="初始化g0">初始化<code>g0</code><a hidden class="anchor" aria-hidden="true" href="#初始化g0">#</a></h2>
<ol>
<li><code>g0</code>的主要作用是提供一个栈供<code>runtime</code>代码执行，因此这里主要对<code>g0</code>的几个与栈有关的成员进行了初始化。</li>
<li>从这里可以看出<code>g0</code>的栈大约有<code>64KB</code>，地址范围为<code>SP - 64*1024 + 104 ～ SP</code>。</li>
<li>注意：虽然这里给<code>g0</code>指定了大概<code>64KB</code>大小的栈空间大小，但是<code>SP</code>寄存器的值却没有减去<code>64KB</code>大小。</li>
<li>文件位置：<code>go1.19.3/src/runtime/asm_amd64.s</code>。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">168
</span><span class="lnt">169
</span><span class="lnt">170
</span><span class="lnt">171
</span><span class="lnt">172
</span><span class="lnt">173
</span><span class="lnt">174
</span><span class="lnt">175
</span><span class="lnt">176
</span><span class="lnt">177
</span><span class="lnt">178
</span><span class="lnt">179
</span><span class="lnt">180
</span><span class="lnt">181
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-asm" data-lang="asm"><span class="line"><span class="cl">    <span class="c1"># create istack out of the given (operating system) stack.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1"># _cgo_init may update stackguard.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1"># 从给定的操作系统栈中创建 istack (自己的栈)。_cgo_init 可能会更新 stackguard。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1"># 下面这段代码从系统线程的栈空分出一部分当做g0的栈，然后初始化g0的栈信息和stackgard
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">MOVQ</span>    <span class="no">$runtime</span><span class="err">·</span><span class="no">g0</span><span class="p">(</span><span class="no">SB</span><span class="p">),</span> <span class="no">DI</span>         <span class="c1"># DI = &amp;g0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">LEAQ</span>    <span class="p">(-</span><span class="mi">64</span><span class="p">*</span><span class="mi">1024</span><span class="err">+</span><span class="mi">104</span><span class="p">)(</span><span class="no">SP</span><span class="p">),</span> <span class="no">BX</span>      <span class="c1"># BX = SP - 64*1024 + 104
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1"># g0.stackguard0和g0.stackguard1用于栈溢出检查，实现栈的自动伸缩，抢占调度也会用到stackguard0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">MOVQ</span>    <span class="no">BX</span><span class="p">,</span> <span class="no">g_stackguard0</span><span class="p">(</span><span class="no">DI</span><span class="p">)</span>       <span class="c1"># g0.stackguard0 = SP - 64*1024 + 104
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">MOVQ</span>    <span class="no">BX</span><span class="p">,</span> <span class="no">g_stackguard1</span><span class="p">(</span><span class="no">DI</span><span class="p">)</span>       <span class="c1"># g0.stackguard1 = SP - 64*1024 + 104
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1"># g0.stack 主要用来记录goroutine所使用的栈，[lo, hi)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1"># g0.stack.lo 栈顶，指向内存低地址
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1"># g0.stack.hi 栈底，指向内存高地址
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">MOVQ</span>    <span class="no">BX</span><span class="p">,</span> <span class="p">(</span><span class="no">g_stack</span><span class="err">+</span><span class="no">stack_lo</span><span class="p">)(</span><span class="no">DI</span><span class="p">)</span>  <span class="c1"># g0.stack.lo = SP - 64*1024 + 104  lo
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">MOVQ</span>    <span class="no">SP</span><span class="p">,</span> <span class="p">(</span><span class="no">g_stack</span><span class="err">+</span><span class="no">stack_hi</span><span class="p">)(</span><span class="no">DI</span><span class="p">)</span>  <span class="c1"># g0.stack.hi = SP                  hi
</span></span></span></code></pre></td></tr></table>
</div>
</div><ol start="5">
<li>运行完上面这几行指令后<code>g0</code>与栈之间的关系如下图所示：</li>
</ol>
<p><img loading="lazy" src="../images/goroutine-003.png" alt=""  />
</p>
<ol start="6">
<li>总结：这部分代码给<code>g0</code>预留了大约<code>64KB</code>的小的栈空间（注意这里的<code>SP</code>寄存器值并没有被修改），设置了<code>stack</code>、<code>stackguard0</code>、<code>stackguard1</code>字段，这些字段都是与<code>g0</code>栈相关的。</li>
</ol>
<h2 id="cpu-相关">CPU 相关<a hidden class="anchor" aria-hidden="true" href="#cpu-相关">#</a></h2>
<ol>
<li>调用<code>CPU</code>相关指令，尝试获取<code>CPU</code>相关信息，比如<code>CPU</code>的厂商、处理器型号等，如果获取成功则记录在全局变量中。</li>
<li>判断是否需要调用初始化<code>CGO</code>相关函数（程序中有相关<code>C</code>代码则会调用，没有则不会调用）。</li>
<li>文件位置：<code>go1.19.3/src/runtime/asm_amd64.s</code>。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">177
</span><span class="lnt">178
</span><span class="lnt">179
</span><span class="lnt">180
</span><span class="lnt">181
</span><span class="lnt">182
</span><span class="lnt">183
</span><span class="lnt">184
</span><span class="lnt">185
</span><span class="lnt">186
</span><span class="lnt">187
</span><span class="lnt">188
</span><span class="lnt">189
</span><span class="lnt">190
</span><span class="lnt">191
</span><span class="lnt">192
</span><span class="lnt">193
</span><span class="lnt">194
</span><span class="lnt">195
</span><span class="lnt">196
</span><span class="lnt">197
</span><span class="lnt">198
</span><span class="lnt">199
</span><span class="lnt">200
</span><span class="lnt">201
</span><span class="lnt">202
</span><span class="lnt">203
</span><span class="lnt">204
</span><span class="lnt">205
</span><span class="lnt">206
</span><span class="lnt">207
</span><span class="lnt">208
</span><span class="lnt">209
</span><span class="lnt">210
</span><span class="lnt">211
</span><span class="lnt">212
</span><span class="lnt">213
</span><span class="lnt">214
</span><span class="lnt">215
</span><span class="lnt">216
</span><span class="lnt">217
</span><span class="lnt">218
</span><span class="lnt">219
</span><span class="lnt">220
</span><span class="lnt">221
</span><span class="lnt">222
</span><span class="lnt">223
</span><span class="lnt">224
</span><span class="lnt">225
</span><span class="lnt">226
</span><span class="lnt">227
</span><span class="lnt">228
</span><span class="lnt">229
</span><span class="lnt">230
</span><span class="lnt">231
</span><span class="lnt">232
</span><span class="lnt">233
</span><span class="lnt">234
</span><span class="lnt">235
</span><span class="lnt">236
</span><span class="lnt">237
</span><span class="lnt">238
</span><span class="lnt">239
</span><span class="lnt">240
</span><span class="lnt">241
</span><span class="lnt">242
</span><span class="lnt">243
</span><span class="lnt">244
</span><span class="lnt">245
</span><span class="lnt">246
</span><span class="lnt">247
</span><span class="lnt">248
</span><span class="lnt">249
</span><span class="lnt">250
</span><span class="lnt">251
</span><span class="lnt">252
</span><span class="lnt">253
</span><span class="lnt">254
</span><span class="lnt">255
</span><span class="lnt">256
</span><span class="lnt">257
</span><span class="lnt">258
</span><span class="lnt">259
</span><span class="lnt">260
</span><span class="lnt">261
</span><span class="lnt">262
</span><span class="lnt">263
</span><span class="lnt">264
</span><span class="lnt">265
</span><span class="lnt">266
</span><span class="lnt">267
</span><span class="lnt">268
</span><span class="lnt">269
</span><span class="lnt">270
</span><span class="lnt">271
</span><span class="lnt">272
</span><span class="lnt">273
</span><span class="lnt">274
</span><span class="lnt">275
</span><span class="lnt">276
</span><span class="lnt">277
</span><span class="lnt">278
</span><span class="lnt">279
</span><span class="lnt">280
</span><span class="lnt">281
</span><span class="lnt">282
</span><span class="lnt">283
</span><span class="lnt">284
</span><span class="lnt">285
</span><span class="lnt">286
</span><span class="lnt">287
</span><span class="lnt">288
</span><span class="lnt">289
</span><span class="lnt">290
</span><span class="lnt">291
</span><span class="lnt">292
</span><span class="lnt">293
</span><span class="lnt">294
</span><span class="lnt">295
</span><span class="lnt">296
</span><span class="lnt">297
</span><span class="lnt">298
</span><span class="lnt">299
</span><span class="lnt">300
</span><span class="lnt">301
</span><span class="lnt">302
</span><span class="lnt">303
</span><span class="lnt">304
</span><span class="lnt">305
</span><span class="lnt">306
</span><span class="lnt">307
</span><span class="lnt">308
</span><span class="lnt">309
</span><span class="lnt">310
</span><span class="lnt">311
</span><span class="lnt">312
</span><span class="lnt">313
</span><span class="lnt">314
</span><span class="lnt">315
</span><span class="lnt">316
</span><span class="lnt">317
</span><span class="lnt">318
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-asm" data-lang="asm"><span class="line"><span class="cl">    <span class="c1"># find out information about the processor we&#39;re on
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">#
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1"># 找出我们正在使用的处理器信息
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1"># EAX寄存器设置为编号0，因为CPUID指令会使用到该寄存器。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">MOVL</span>    <span class="no">$0</span><span class="p">,</span> <span class="no">AX</span>  <span class="c1"># EAX = 0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1"># CPUID 是一种用于查询处理器信息的指令，它可以返回处理器支持的功能列表和特性信息。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1"># CPUID 指令需要将查询信息的编号存储在 EAX 寄存器中，然后执行 CPUID 指令。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1"># 处理器将返回结果存储在 EAX、EBX、ECX 和 EDX 四个寄存器中，具体的返回值格式和含义取决于查询信息的编号。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1"># EAX 是 0 时：返回最大支持的功能编号（包括该编号）和厂商 ID（12 个字符）。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">#   1. EAX：返回最大支持的功能编号
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">#   2. EBX：如果是 Inter 返回 &#34;Genu&#34;。如果是 AMD 返回 &#34;Auth&#34; 。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">#   3. ECX：如果是 Inter 返回 &#34;ntel&#34;。如果是 AMD 返回 &#34;enti&#34; 。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">#   4. EDX：如果是 Inter 返回 &#34;ntel&#34;。如果是 AMD 返回 &#34;cAMD&#34; 。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">#   Genuntelntel是英特厂商名称。AuthenticAMD表示是AMD厂商名称。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">#  EAX 是 1 时：返回处理器的基本信息，包括处理器型号、系列、扩展型号、扩展系列等。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">#   1. EAX 的位0-3将包含处理器类型编码，位4-7将包含处理器家族编码，位8-11将包含处理器型号编码，
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">#      位12-13将包含处理器扩展型号编码，位14-15将包含处理器扩展家族编码。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">#   2. EBX、ECX、EDX 三个寄存器将包含其他处理器特性的信息。此处我们不关心这些数据。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1"># 查询 CPU 支持的功能列表（编号 0）：0、1、2、4、0x80000000、0x80000001
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">#  1. EAX 的值为 0x0：返回最大支持的功能编号（包括该编号）和厂商 ID（12 个字符）。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">#  2. EAX 的值为 0x1：返回处理器的基本信息，包括处理器型号、系列、扩展型号、扩展系列等。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">#  3. EAX 的值为 0x80000000h：返回最大支持的扩展功能编号和厂商 ID（12 个字符）。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">#  4. EAX 的值为 0x80000001h：返回处理器的扩展信息，包括扩展特性、虚拟化支持等。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">CPUID</span>
</span></span><span class="line"><span class="cl">    <span class="nf">CMPL</span>    <span class="no">AX</span><span class="p">,</span> <span class="no">$0</span>
</span></span><span class="line"><span class="cl">    <span class="nf">JE</span>  <span class="no">nocpuinfo</span> <span class="c1"># AX == 0，没有CPU信息
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="c1"># 以下判断当前处理器是否是 GenuineIntel
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1"># BX != &#34;Genu&#34;; JNE 就会跳转
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">CMPL</span>    <span class="no">BX</span><span class="p">,</span> <span class="no">$0x756E6547</span>  <span class="c1"># &#34;Genu&#34;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">JNE</span>	<span class="no">notintel</span> <span class="c1"># 不是英特处理器时
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1"># BX != &#34;ineI&#34;; JNE 就会跳转
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">CMPL</span>    <span class="no">DX</span><span class="p">,</span> <span class="no">$0x49656E69</span>  <span class="c1"># &#34;ineI&#34;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">JNE</span>	<span class="no">notintel</span> <span class="c1"># 不是英特处理器时
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1"># BX != &#34;ntel&#34;; JNE 就会跳转
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">CMPL</span>    <span class="no">CX</span><span class="p">,</span> <span class="no">$0x6C65746E</span>  <span class="c1"># &#34;ntel&#34;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">JNE</span>	<span class="no">notintel</span> <span class="c1"># 不是英特处理器时 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1"># 将runtime的全局变量 isIntel 设置为 1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1"># 该变量在 runtime/runtime2.go 全局变量中
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1"># 表示当前处理器是 GenuineIntel
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">MOVB</span>    <span class="no">$1</span><span class="p">,</span> <span class="no">runtime</span><span class="err">·</span><span class="no">isIntel</span><span class="p">(</span><span class="no">SB</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nl">notintel:</span> <span class="c1"># 不是intel
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1"># Load EAX=1 cpuid flags
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">MOVL</span>    <span class="no">$1</span><span class="p">,</span> <span class="no">AX</span>
</span></span><span class="line"><span class="cl">    <span class="nf">CPUID</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># 将runtime的全局变量 processorVersionInfo 设置为 AX
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1"># AX寄存器存储的是处理器的标识，可以识别特定的处理器。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1"># 由于判断CPU是否支持相关的指令集，比如AVX指令集。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">MOVL</span>    <span class="no">AX</span><span class="p">,</span> <span class="no">runtime</span><span class="err">·</span><span class="no">processorVersionInfo</span><span class="p">(</span><span class="no">SB</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nl">nocpuinfo:</span> <span class="c1"># 没有cpu信息
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1"># if there is an _cgo_init, call it.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">#
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1"># 如果存在_cgo_init，则调用它。代码中存在调用C相关函数时这里AX会有值并判断成功
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1"># cgo_init函数是一个内部函数，用于初始化C语言代码和Go代码之间的接口。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1"># cgo_init函数是Go运行时系统的一部分，它在程序启动时被自动调用。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1"># 它会初始化cgo相关的全局变量，设置cgo的信号处理器，并将C语言代码中的函数指针转换为Go语言中的函数类型，
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1"># 以便能够在Go语言中调用它们。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1"># 使用 CGO 的情况下：
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">#   1. Go会创建一个C语言的线程，并使用线程本地存储（Thread-Local Storage，TLS）来存储C语言函数所需要的数据。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">#   2. 当使用cgo调用C语言函数时，cgo会自动初始化这个线程的TLS。这个初始化是在_cgo_init函数中完成的，
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">#   这个函数是由Go编译器自动生成的。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">MOVQ</span>    <span class="no">_cgo_init</span><span class="p">(</span><span class="no">SB</span><span class="p">),</span> <span class="no">AX</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># 将寄存器 AX 中的值与自己进行按位逻辑与运算，并更新标志寄存器的值。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1"># 如果全部为 1，那么结果就是非零值，否则就是零。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1"># 这条指令的作用就是判断 AX 的值是否为零。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">TESTQ</span>   <span class="no">AX</span><span class="p">,</span> <span class="no">AX</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># 这条指令是一个条件跳转指令，它会根据上一条指令更新的标志寄存器的值来判断是否跳转到目标标签 needtls。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1"># JZ 是“Jump if Zero”的缩写，意思是如果上一条指令的【结果为零】，则跳转到目标标签。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1"># 跳转这里表示修改去 TLS 设置
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">JZ</span>	<span class="no">needtls</span> <span class="c1"># 没有 _cgo_init 函数时跳转到 needtls
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1"># arg 1: g0, already in DI
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1"># 参数1：g0, 已经在 DI 中，前面初始化g0时放入DI中的
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1"># 参数2：setg_gcc 放入 SI
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">MOVQ</span>    <span class="no">$setg_gcc</span><span class="err">&lt;&gt;</span><span class="p">(</span><span class="no">SB</span><span class="p">),</span> <span class="no">SI</span> <span class="c1"># arg 2: setg_gcc
</span></span></span><span class="line"><span class="cl"><span class="c1">#ifdef GOOS_android	
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">MOVQ</span>    <span class="no">$runtime</span><span class="err">·</span><span class="no">tls_g</span><span class="p">(</span><span class="no">SB</span><span class="p">),</span> <span class="no">DX</span>  <span class="c1"># arg 3: &amp;tls_g
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1"># arg 4: TLS base, stored in slot 0 (Android&#39;s TLS_SLOT_SELF).
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1"># Compensate for tls_g (+16).
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">MOVQ</span>    <span class="p">-</span><span class="mi">16</span><span class="p">(</span><span class="no">TLS</span><span class="p">),</span> <span class="no">CX</span>
</span></span><span class="line"><span class="cl"><span class="c1">#else
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1"># 参数3,4：都为0，使用平台的TLS时不使用
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">MOVQ</span>    <span class="no">$0</span><span class="p">,</span> <span class="no">DX</span>	<span class="c1"># arg 3, 4: not used when using platform&#39;s TLS
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">MOVQ</span>    <span class="no">$0</span><span class="p">,</span> <span class="no">CX</span>
</span></span><span class="line"><span class="cl"><span class="c1">#endif
</span></span></span><span class="line"><span class="cl"><span class="c1">#ifdef GOOS_windows 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1"># Adjust for the Win64 calling convention.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">MOVQ</span>    <span class="no">CX</span><span class="p">,</span> <span class="no">R9</span> <span class="c1"># arg 4
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">MOVQ</span>    <span class="no">DX</span><span class="p">,</span> <span class="no">R8</span> <span class="c1"># arg 3
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">MOVQ</span>    <span class="no">SI</span><span class="p">,</span> <span class="no">DX</span> <span class="c1"># arg 2
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">MOVQ</span>    <span class="no">DI</span><span class="p">,</span> <span class="no">CX</span> <span class="c1"># arg 1
</span></span></span><span class="line"><span class="cl"><span class="c1">#endif
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1"># DI、SI、DX、CX参数已准备好
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1"># DI = &amp;g0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1"># SI = setg_gcc
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1"># DX = 0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1"># CX = 0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1"># AX=_cgo_init; 调用 _cgo_init 函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">CALL</span>    <span class="no">AX</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1"># update stackguard after _cgo_init
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1"># 在 _cgo_init 后更新 stackguard，因为更新了stack.lo的值了。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">MOVQ</span>    <span class="no">$runtime</span><span class="err">·</span><span class="no">g0</span><span class="p">(</span><span class="no">SB</span><span class="p">),</span> <span class="no">CX</span>     <span class="c1"># CX = &amp;g0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">MOVQ</span>    <span class="p">(</span><span class="no">g_stack</span><span class="err">+</span><span class="no">stack_lo</span><span class="p">)(</span><span class="no">CX</span><span class="p">),</span> <span class="no">AX</span> <span class="c1"># AX = g0.stack.lo; lo = SP + 8MB - 4KB
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1"># _StackGuard 是 928byte
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">ADDQ</span>    <span class="no">$const__StackGuard</span><span class="p">,</span> <span class="no">AX</span> <span class="c1"># AX = AX + _StackGuard
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1"># g0.stackguard0 = g0.stack.lo + _StackGuard
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1"># g0.stack.lo = SP + 8MB - 4KB
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1"># stackguard0 用于 runtime 栈溢出判断。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">MOVQ</span>    <span class="no">AX</span><span class="p">,</span> <span class="no">g_stackguard0</span><span class="p">(</span><span class="no">CX</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># g0.stackguard1 = g0.stack.lo + _StackGuard
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1"># stackguard1 被 g0 和 gsignal 中的C代码使用。用于栈溢出判断
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">MOVQ</span>    <span class="no">AX</span><span class="p">,</span> <span class="no">g_stackguard1</span><span class="p">(</span><span class="no">CX</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">## 这里是 ifndef，不是windows则JMP ok不需要去TLS
</span></span></span><span class="line"><span class="cl"><span class="c1">## 这种情况发生在 _cgo_init 函数被调用时候
</span></span></span><span class="line"><span class="cl"><span class="c1">#
</span></span></span><span class="line"><span class="cl"><span class="c1">#ifndef GOOS_windows
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">JMP</span> <span class="no">ok</span>
</span></span><span class="line"><span class="cl"><span class="c1">#endif
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nl">needtls:</span> <span class="c1">## 需要TLS的情况判断
</span></span></span><span class="line"><span class="cl"><span class="c1">#ifdef GOOS_plan9
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1"># skip TLS setup on Plan 9
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">JMP</span> <span class="no">ok</span> <span class="c1">## 跳过TLS设置，不要手动设置
</span></span></span><span class="line"><span class="cl"><span class="c1">#endif
</span></span></span><span class="line"><span class="cl"><span class="c1">#ifdef GOOS_solaris 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1"># skip TLS setup on Solaris
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">JMP</span> <span class="no">ok</span> <span class="c1">## 跳过TLS设置，不要手动设置
</span></span></span><span class="line"><span class="cl"><span class="c1">#endif
</span></span></span><span class="line"><span class="cl"><span class="c1">#ifdef GOOS_illumos 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1"># skip TLS setup on illumos
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">JMP</span> <span class="no">ok</span> <span class="c1">## 跳过TLS设置，不要手动设置
</span></span></span><span class="line"><span class="cl"><span class="c1">#endif
</span></span></span><span class="line"><span class="cl"><span class="c1">#ifdef GOOS_darwin
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1"># skip TLS setup on Darwin
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">JMP</span> <span class="no">ok</span> <span class="c1">## 跳过TLS设置，不要手动设置
</span></span></span><span class="line"><span class="cl"><span class="c1">#endif
</span></span></span><span class="line"><span class="cl"><span class="c1">#ifdef GOOS_openbsd
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1"># skip TLS setup on OpenBSD
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">JMP</span> <span class="no">ok</span> <span class="c1">## 跳过TLS设置，不要手动设置
</span></span></span><span class="line"><span class="cl"><span class="c1">#endif
</span></span></span></code></pre></td></tr></table>
</div>
</div>

<p><details >
  <summary markdown="span">cgo初始化</summary>
  <blockquote>
<ol>
<li>初始化 <code>C</code> 语言代码和 <code>Go</code> 代码之间的接口。</li>
<li>参数：
<ul>
<li><code>G *g</code>：&amp;runtime.g0。</li>
<li><code>void (*setg)(void*)</code>：setg_gcc函数。</li>
<li><code>void **tlsg</code>：NULL。</li>
<li><code>void **tlsbase</code>：NULL。</li>
</ul>
</li>
<li>文件位置：<code>go1.19.3/src/runtime/cgo/gcc_linux_amd64.c</code>。</li>
<li>该函数只是设置了g0栈的<code>stack.lo = SP - 8MB + 4KB</code>，并没有创建新的线程。</li>
<li>这段代码执行了以下重要任务：
<ol>
<li>线程栈的初始化和设置：
<ul>
<li>Go运行时使用goroutines来并发执行代码，每个goroutine有自己的栈。</li>
<li>当使用cgo时，Go运行时需要与C代码的线程栈进行交互。</li>
<li>这段代码确保了C线程的栈与Go运行时的栈设置是一致的。</li>
</ul>
</li>
<li>栈边界设置：
<ul>
<li>设置stacklo字段是为了确定goroutine栈的底部位置。</li>
<li>在Go中，每个goroutine的栈都有一个底部和顶部，stacklo和stackhi分别代表栈的底部和顶部地址。</li>
</ul>
</li>
</ol>
</li>
<li>以下是为什么要这样设置的原因：
<ol>
<li>安全边界：通过将stacklo设置为距离栈顶8MB减去4KB的位置，代码为栈溢出检测留出了空间。如果goroutine的栈增长超过了这个设置的范围，那么它将触发栈溢出错误，而不是覆盖其他内存，这有助于防止内存损坏。</li>
<li>栈空间预留：在C和Go代码之间进行切换时，可能需要额外的栈空间来处理函数调用、参数传递等。预留空间可以确保在这些操作中有足够的空间，避免栈溢出。</li>
<li>与Go运行时栈管理兼容：Go运行时负责管理goroutines的栈，包括栈的增长和收缩。这段代码确保了C线程的栈与Go运行时的栈管理策略兼容。</li>
<li>初始化setg_gcc：setg_gcc是一个全局变量，用于在C代码中设置当前的goroutine。在C代码中调用Go函数时，需要正确设置当前的goroutine，这样Go运行时才能正确管理goroutine的状态。</li>
</ol>
</li>
<li>总的来说，这段代码是cgo初始化的一部分，目的是为了确保C线程的栈与Go运行时的goroutine栈能够正确地协同工作，同时保持栈的安全性和性能。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">static</span> <span class="nf">void</span> <span class="p">(</span><span class="o">*</span><span class="n">setg_gcc</span><span class="p">)(</span><span class="kt">void</span><span class="o">*</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// This will be set in gcc_android.c for android-specific customization.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">x_cgo_inittls</span><span class="p">)(</span><span class="kt">void</span> <span class="o">**</span><span class="n">tlsg</span><span class="p">,</span> <span class="kt">void</span> <span class="o">**</span><span class="n">tlsbase</span><span class="p">)</span> <span class="nf">__attribute__</span><span class="p">((</span><span class="n">common</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span>
</span></span><span class="line"><span class="cl"><span class="nf">x_cgo_init</span><span class="p">(</span><span class="n">G</span> <span class="o">*</span><span class="n">g</span><span class="p">,</span> <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">setg</span><span class="p">)(</span><span class="kt">void</span><span class="o">*</span><span class="p">),</span> <span class="kt">void</span> <span class="o">**</span><span class="n">tlsg</span><span class="p">,</span> <span class="kt">void</span> <span class="o">**</span><span class="n">tlsbase</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 申明一个 pthread_attr_t 类型变量 *attr，指针类型.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// pthread_attr_t 是线程的属性结构
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">pthread_attr_t</span> <span class="o">*</span><span class="n">attr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 申明一个 size_t 类型变量 size。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">size_t</span> <span class="n">size</span><span class="p">;</span> <span class="c1">// 用于保存新创建的这个线程的栈大小
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="cm">/* The memory sanitizer distributed with versions of clang
</span></span></span><span class="line"><span class="cl"><span class="cm">       before 3.8 has a bug: if you call mmap before malloc, mmap
</span></span></span><span class="line"><span class="cl"><span class="cm">       may return an address that is later overwritten by the msan
</span></span></span><span class="line"><span class="cl"><span class="cm">       library.  Avoid this problem by forcing a call to malloc
</span></span></span><span class="line"><span class="cl"><span class="cm">       here, before we ever call malloc.
</span></span></span><span class="line"><span class="cl"><span class="cm">
</span></span></span><span class="line"><span class="cl"><span class="cm">       This is only required for the memory sanitizer, so it&#39;s
</span></span></span><span class="line"><span class="cl"><span class="cm">       unfortunate that we always run it.  It should be possible
</span></span></span><span class="line"><span class="cl"><span class="cm">       to remove this when we no longer care about versions of
</span></span></span><span class="line"><span class="cl"><span class="cm">       clang before 3.8.  The test for this is
</span></span></span><span class="line"><span class="cl"><span class="cm">       misc/cgo/testsanitizers.
</span></span></span><span class="line"><span class="cl"><span class="cm">
</span></span></span><span class="line"><span class="cl"><span class="cm">       GCC works hard to eliminate a seemingly unnecessary call to
</span></span></span><span class="line"><span class="cl"><span class="cm">       malloc, so we actually use the memory we allocate.  */</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">setg_gcc</span> <span class="o">=</span> <span class="n">setg</span><span class="p">;</span> <span class="c1">// 向setg_gcc全局静态变量赋值setg_gcc()函数的地址
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 向操作系统申请 *attr 类型需要的内存，其实就是一个指针大小。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">attr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">pthread_attr_t</span><span class="o">*</span><span class="p">)</span><span class="nf">malloc</span><span class="p">(</span><span class="k">sizeof</span> <span class="o">*</span><span class="n">attr</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">attr</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 申请失败
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nf">fatalf</span><span class="p">(</span><span class="s">&#34;malloc failed: %s&#34;</span><span class="p">,</span> <span class="nf">strerror</span><span class="p">(</span><span class="n">errno</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 初始化线程属性对象；创建的默认栈大小为8M
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">pthread_attr_init</span><span class="p">(</span><span class="n">attr</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// pthread_attr_getstacksize 获取线程的栈大小
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">pthread_attr_getstacksize</span><span class="p">(</span><span class="n">attr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">size</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// __builtin_frame_address(0) 查看当前函数的栈帧地址，因此和SP寄存器值相差不大
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 注意这里修改的是 stack.lo = SP - 8MB + 4KB，加上4KB是为了判断当前分配的栈是否超过4KB
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 因为g参数传递的是指针，这里直接修改了g0的stack.lo字段的值，这里相当于扩大了g0栈大小。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">g</span><span class="o">-&gt;</span><span class="n">stacklo</span> <span class="o">=</span> <span class="p">(</span><span class="n">uintptr</span><span class="p">)</span><span class="nf">__builtin_frame_address</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">-</span> <span class="n">size</span> <span class="o">+</span> <span class="mi">4096</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// lo &gt;= hi，错误的栈边界。hi-&gt;lo（高-&gt;低），判断是否溢出
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">g</span><span class="o">-&gt;</span><span class="n">stacklo</span> <span class="o">&gt;=</span> <span class="n">g</span><span class="o">-&gt;</span><span class="n">stackhi</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="nf">fatalf</span><span class="p">(</span><span class="s">&#34;bad stack bounds: lo=%p hi=%p</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">g</span><span class="o">-&gt;</span><span class="n">stacklo</span><span class="p">,</span> <span class="n">g</span><span class="o">-&gt;</span><span class="n">stackhi</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 销毁 attr 这个线程属性对象
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">pthread_attr_destroy</span><span class="p">(</span><span class="n">attr</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">free</span><span class="p">(</span><span class="n">attr</span><span class="p">);</span>   <span class="c1">// 释放 attr 占用的内存
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">x_cgo_inittls</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">x_cgo_inittls</span><span class="p">(</span><span class="n">tlsg</span><span class="p">,</span> <span class="n">tlsbase</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ol start="8">
<li>根据汇编代码可知，<code>setg_gcc()</code>函数应该是把<code>g</code>放入<code>TLS</code>和<code>R14</code>寄存器中。</li>
<li>文件位置：<code>go1.19.3/src/runtime/asm_amd64.s</code>。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1049
</span><span class="lnt">1050
</span><span class="lnt">1051
</span><span class="lnt">1052
</span><span class="lnt">1053
</span><span class="lnt">1054
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-asm" data-lang="asm"><span class="line"><span class="cl"><span class="c1"># void setg_gcc(G*); set g called from gcc.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nf">TEXT</span> <span class="no">setg_gcc</span><span class="err">&lt;&gt;</span><span class="p">(</span><span class="no">SB</span><span class="p">),</span><span class="no">NOSPLIT</span><span class="p">,</span><span class="no">$0</span>
</span></span><span class="line"><span class="cl">    <span class="nf">get_tls</span><span class="p">(</span><span class="no">AX</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nf">MOVQ</span>    <span class="no">DI</span><span class="p">,</span> <span class="no">g</span><span class="p">(</span><span class="no">AX</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nf">MOVQ</span>    <span class="no">DI</span><span class="p">,</span> <span class="no">R14</span> <span class="c1"># set the g register
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">RET</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ol start="10">
<li>传入给<code>x_cgo_init</code>的<code>G *g</code>参数其实是<code>g0</code>，而<code>g0</code>结构体第一个字段就是<code>stack</code>，包含<code>stacklo</code>和<code>stackhi</code>，因此能直接转换。</li>
<li>文件位置：<code>go1.19.3/src/runtime/cgo/libcgo.h</code>。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cm">/*
</span></span></span><span class="line"><span class="cl"><span class="cm">* The beginning of the per-goroutine structure,
</span></span></span><span class="line"><span class="cl"><span class="cm">* as defined in ../pkg/runtime/runtime.h.
</span></span></span><span class="line"><span class="cl"><span class="cm">* Just enough to edit these two fields.
</span></span></span><span class="line"><span class="cl"><span class="cm">*/</span>
</span></span><span class="line"><span class="cl"><span class="k">typedef</span> <span class="k">struct</span> <span class="n">G</span> <span class="n">G</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="n">G</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">uintptr</span> <span class="n">stacklo</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">uintptr</span> <span class="n">stackhi</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ol start="12">
<li>总结：这部分代码，尝试获取<code>CPU</code>相关信息并保存在全局变量中。判断是否存在<code>CGO</code>相关初始化，如果需要则从新设置<code>g0</code>的栈大小。</li>
<li>运行完上面这cgo初始化与栈之间的关系如下图所示：</li>
</ol>
<p><img loading="lazy" src="../images/goroutine-004.png" alt=""  />
</p>
</blockquote>
</details></p>

<h2 id="主线程与m0绑定">主线程与<code>m0</code>绑定<a hidden class="anchor" aria-hidden="true" href="#主线程与m0绑定">#</a></h2>
<h3 id="设置tls">设置tls<a hidden class="anchor" aria-hidden="true" href="#设置tls">#</a></h3>
<ol>
<li>设置好<code>g0</code>栈之后，获取到<code>CPU</code>型号以及<code>cgo</code>初始化后，设置工作线程<code>TLS</code>。</li>
<li>调用<code>settls</code>函数初始化主线程的线程本地存储(<code>TLS</code>)，目的是把<code>m0</code>与主线程关联在一起。</li>
<li>设置了线程本地存储之后接下来的几条指令在于验证<code>TLS</code>功能是否正常，如果不正常则直接<code>abort</code>退出程序。</li>
<li>文件位置：<code>go1.19.3/src/runtime/asm_amd64.s</code>。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">250
</span><span class="lnt">251
</span><span class="lnt">252
</span><span class="lnt">253
</span><span class="lnt">254
</span><span class="lnt">255
</span><span class="lnt">256
</span><span class="lnt">257
</span><span class="lnt">258
</span><span class="lnt">259
</span><span class="lnt">260
</span><span class="lnt">261
</span><span class="lnt">262
</span><span class="lnt">263
</span><span class="lnt">264
</span><span class="lnt">265
</span><span class="lnt">266
</span><span class="lnt">267
</span><span class="lnt">268
</span><span class="lnt">269
</span><span class="lnt">270
</span><span class="lnt">271
</span><span class="lnt">272
</span><span class="lnt">273
</span><span class="lnt">274
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-asm" data-lang="asm"><span class="line"><span class="cl">    <span class="c1"># 1) 设置 TLS
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="c1"># 下面开始初始化tls（thread local storage，线程本地存储）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1"># LEA将内存地址赋值给DI，取m0的tls成员的地址到DI寄存器
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">LEAQ</span>    <span class="no">runtime</span><span class="err">·</span><span class="no">m0</span><span class="err">+</span><span class="no">m_tls</span><span class="p">(</span><span class="no">SB</span><span class="p">),</span> <span class="no">DI</span>  <span class="c1"># DI=&amp;m0.tls
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1"># 调用settls设置线程本地存储，settls函数的参数在DI寄存器中
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">CALL</span>    <span class="no">runtime</span><span class="err">·</span><span class="no">settls</span><span class="p">(</span><span class="no">SB</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1"># 2) 验证 TLS 是否可用
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="c1"># store through it, to make sure it works
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">#
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1"># 通过它进行存储，以确保它有效
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1"># 验证settls是否可以正常工作，如果有问题则abort退出程序
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">get_tls</span><span class="p">(</span><span class="no">BX</span><span class="p">)</span>	<span class="c1"># 获取fs段基地址并放入BX寄存器，其实就是m0.tls[1]的地址，get_tls的代码由编译器生成
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1"># 通过 FS 寄存器存储的值进行设置
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">MOVQ</span>    <span class="no">$0x123</span><span class="p">,</span> <span class="no">g</span><span class="p">(</span><span class="no">BX</span><span class="p">)</span> <span class="c1"># 把整型常量0x123拷贝到fs段基地址偏移-8的内存位置，也就是m0.tls[0]=0x123
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1"># 通过 runtime.mtls[0] 进行取值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">MOVQ</span>    <span class="no">runtime</span><span class="err">·</span><span class="no">m0</span><span class="err">+</span><span class="no">m_tls</span><span class="p">(</span><span class="no">SB</span><span class="p">),</span> <span class="no">AX</span> <span class="c1"># AX=m0.tls[0]，MOV将值赋值给AX
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1"># 比较 AX 与 $0x123 是否相等
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">CMPQ</span>    <span class="no">AX</span><span class="p">,</span> <span class="no">$0x123</span>  <span class="c1"># 检查m0.tls[0]的值是否通过线程本地存储存入的0x123来验证tls功能是否正常
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1"># 如果前面的比较结果是相等，跳转到当前指令地址加2个字节的位置（即下一条指令）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1"># 如果比较结果不是相等，则继续执行下一条指令。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">JEQ</span> <span class="mi">2</span><span class="p">(</span><span class="no">PC</span><span class="p">)</span>   <span class="c1"># 跳过下面这一条指令
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">CALL</span>    <span class="no">runtime</span><span class="err">·</span><span class="no">abort</span><span class="p">(</span><span class="no">SB</span><span class="p">)</span> <span class="c1"># 如果线程本地存储不能正常工作，退出程序
</span></span></span></code></pre></td></tr></table>
</div>
</div>

<p><details >
  <summary markdown="span">runtime·settls(SB)</summary>
  <blockquote>
<ol>
<li>将<code>tls-base</code>设置为<code>DI</code>寄存器的值，<code>DI</code>寄存器存储的是<code>m0.tls</code>的地址。</li>
<li>通过<code>arch_prctl</code>系统调用把<code>m0.tls[1]</code>的地址设置成了<code>fs</code>段的段基址。</li>
<li><code>CPU</code>中有个叫<code>fs</code>的段寄存器与之对应：
<ul>
<li>而每个线程都有自己的一组<code>CPU</code>寄存器值，操作系统在把线程调离<code>CPU</code>运行时会帮我们把所有寄存器中的值保存在内存中。</li>
<li>调度线程起来运行时又会从内存中把这些寄存器的值恢复到<code>CPU</code>。在此之后工作线程代码就可以通过<code>fs</code>寄存器来找到<code>m.tls</code>。</li>
</ul>
</li>
<li>文件位置：<code>go1.19.3/src/runtime/sys_linux_amd64.s</code>。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">638
</span><span class="lnt">639
</span><span class="lnt">640
</span><span class="lnt">641
</span><span class="lnt">642
</span><span class="lnt">643
</span><span class="lnt">644
</span><span class="lnt">645
</span><span class="lnt">646
</span><span class="lnt">647
</span><span class="lnt">648
</span><span class="lnt">649
</span><span class="lnt">650
</span><span class="lnt">651
</span><span class="lnt">652
</span><span class="lnt">653
</span><span class="lnt">654
</span><span class="lnt">655
</span><span class="lnt">656
</span><span class="lnt">657
</span><span class="lnt">658
</span><span class="lnt">659
</span><span class="lnt">660
</span><span class="lnt">661
</span><span class="lnt">662
</span><span class="lnt">663
</span><span class="lnt">664
</span><span class="lnt">665
</span><span class="lnt">666
</span><span class="lnt">667
</span><span class="lnt">668
</span><span class="lnt">669
</span><span class="lnt">670
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-asm" data-lang="asm"><span class="line"><span class="cl"><span class="c1"># set tls base to DI
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nf">TEXT</span> <span class="no">runtime</span><span class="err">·</span><span class="no">settls</span><span class="p">(</span><span class="no">SB</span><span class="p">),</span><span class="no">NOSPLIT</span><span class="p">,</span><span class="no">$32</span>
</span></span><span class="line"><span class="cl"><span class="c1">#ifdef GOOS_android
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1"># Android stores the TLS offset in runtime·tls_g.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">SUBQ</span>    <span class="no">runtime</span><span class="err">·</span><span class="no">tls_g</span><span class="p">(</span><span class="no">SB</span><span class="p">),</span> <span class="no">DI</span>
</span></span><span class="line"><span class="cl"><span class="c1">#else
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1"># DI寄存器中存放的是m.tls[0]的地址，m的tls成员是一个数组
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1"># 下面这一句代码把DI寄存器中的地址加8，为什么要+8呢，主要跟ELF可执行文件格式中的TLS实现的机制有关
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1"># 执行下面这句指令之后DI寄存器中存放的就是m.tls[1]的地址了
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">ADDQ</span>    <span class="no">$8</span><span class="p">,</span> <span class="no">DI</span>  <span class="c1"># ELF wants to use -8(FS)
</span></span></span><span class="line"><span class="cl"><span class="c1">#endif
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1"># AMD64 Linux平台约定在进行系统调用时使用：
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">#   1. rax寄存器存放系统调用编号
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">#   2. 同时约定使用rdi, rsi, rdx, r10, r8和r9来传递前6个系统调用参数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1"># 下面通过arch_prctl系统调用设置FS段基地址
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1"># arch_prctl系统调用的第二个参数，设置该值为FS段基地址
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">MOVQ</span>    <span class="no">DI</span><span class="p">,</span> <span class="no">SI</span>  <span class="c1"># SI = DI
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1"># arch_prctl的第一个参数：ARCH_SET_FS 参数值表示设置线程的TLS地址的。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1"># 在 x86 架构中，FS 寄存器用于存储 TLS （Thread Local Storage）的地址
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">MOVQ</span>    <span class="no">$0x1002</span><span class="p">,</span> <span class="no">DI</span>	<span class="c1"># ARCH_SET_FS
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1"># AX 系统调用编号
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">MOVQ</span>    <span class="no">$SYS_arch_prctl</span><span class="p">,</span> <span class="no">AX</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># AX = $SYS_arch_prctl
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1"># DI = ARCH_SET_FS
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1"># SI = &amp;m.tls[1]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">SYSCALL</span>   <span class="c1"># 系统调用，进入内核
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1"># 判断系统调用是否成功
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1"># 将 AX 寄存器中的值与 0xfffffffffffff001 进行比较
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1"># 如果 AX 中的值小于等于 0xfffffffffffff001，则跳转到当前指令地址加上2的地址（即跳转到下一条指令的下一条指令）。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">CMPQ</span>    <span class="no">AX</span><span class="p">,</span> <span class="no">$0xfffffffffffff001</span>
</span></span><span class="line"><span class="cl">    <span class="nf">JLS</span>	<span class="mi">2</span><span class="p">(</span><span class="no">PC</span><span class="p">)</span>   <span class="c1"># 跳过以下两条指令
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">MOVL</span>    <span class="no">$0xf1</span><span class="p">,</span> <span class="mi">0xf1</span> <span class="c1"># crash 系统调用失败直接crash，失败原因是把$0xf1放入不存在地址里面
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">RET</span> <span class="c1"># 直接返回
</span></span></span></code></pre></td></tr></table>
</div>
</div><ol start="5">
<li>相关宏定义。</li>
<li>文件位置：<code>go1.19.3/src/runtime/go_tls.h</code>。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#ifdef GOARCH_amd64
</span></span></span><span class="line"><span class="cl"><span class="cp">#define   get_tls(r)  MOVQ TLS, r </span><span class="c1">// get_tls函数定义，TLS其实就是FS寄存器的值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#define   g(r)    0(r)(TLS*1)     </span><span class="c1">// (r + TLS*1 + 0)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#endif
</span></span></span></code></pre></td></tr></table>
</div>
</div></blockquote>

</details></p>

<h3 id="m0绑定"><code>m0</code>绑定<a hidden class="anchor" aria-hidden="true" href="#m0绑定">#</a></h3>
<ol>
<li>首先把<code>g0</code>的地址放入主线程的线程本地存储（<code>TLS</code>）中，然后通过【<code>m0.g0=&amp;g0</code>】【<code>g0.m=&amp;m0</code>】把<code>m0</code>和<code>g0</code>绑定在一起。</li>
<li>之后在主线程中通过<code>get_tls</code>可以获取到<code>g0</code>，通过<code>g0</code>的<code>m</code>成员又可以找到<code>m0</code>。</li>
<li>保存在主线程本地存储中的值是<code>g0</code>的地址，也就是说工作线程的私有全局变量其实是一个指向<code>g</code>的指针而不是指向<code>m</code>的指针。</li>
<li>目前这个指针指向<code>g0</code>，表示代码正运行在<code>g0</code>栈。</li>
<li>文件位置：<code>go1.19.3/src/runtime/asm_amd64.s</code>。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">264
</span><span class="lnt">265
</span><span class="lnt">266
</span><span class="lnt">267
</span><span class="lnt">268
</span><span class="lnt">269
</span><span class="lnt">270
</span><span class="lnt">271
</span><span class="lnt">272
</span><span class="lnt">273
</span><span class="lnt">274
</span><span class="lnt">275
</span><span class="lnt">276
</span><span class="lnt">277
</span><span class="lnt">278
</span><span class="lnt">279
</span><span class="lnt">280
</span><span class="lnt">281
</span><span class="lnt">282
</span><span class="lnt">283
</span><span class="lnt">284
</span><span class="lnt">285
</span><span class="lnt">286
</span><span class="lnt">287
</span><span class="lnt">288
</span><span class="lnt">289
</span><span class="lnt">290
</span><span class="lnt">291
</span><span class="lnt">292
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-asm" data-lang="asm"><span class="line"><span class="cl">    <span class="nl">ok:</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># 1) g0 与 TLS 绑定
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="c1"># set the per-goroutine and per-mach &#34;registers&#34;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">get_tls</span><span class="p">(</span><span class="no">BX</span><span class="p">)</span>	<span class="c1"># 获取fs段基地址到BX寄存器
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">LEAQ</span>    <span class="no">runtime</span><span class="err">·</span><span class="no">g0</span><span class="p">(</span><span class="no">SB</span><span class="p">),</span> <span class="no">CX</span> <span class="c1"># CX = &amp;g0; var g0 g;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1"># 把g0的地址保存在线程本地存储里面
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">MOVQ</span>    <span class="no">CX</span><span class="p">,</span> <span class="no">g</span><span class="p">(</span><span class="no">BX</span><span class="p">)</span>           <span class="c1"># m0.tls[0]=&amp;g0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">LEAQ</span>    <span class="no">runtime</span><span class="err">·</span><span class="no">m0</span><span class="p">(</span><span class="no">SB</span><span class="p">),</span> <span class="no">AX</span>  <span class="c1"># AX = &amp;m0; var m0 m;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="c1"># 2) m0 和 g0 相互绑定 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">#   m0.g0 = &amp;g0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">#   g0.m = &amp;m0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="c1"># save m-&gt;g0 = g0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">MOVQ</span>    <span class="no">CX</span><span class="p">,</span> <span class="no">m_g0</span><span class="p">(</span><span class="no">AX</span><span class="p">)</span>    <span class="c1"># m0.g0=g0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1"># save m0 to g0-&gt;m
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1"># m的第一个字段就是m0.g0所以这里AX代表的就是m0.g0的地址处
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">MOVQ</span>    <span class="no">AX</span><span class="p">,</span> <span class="no">g_m</span><span class="p">(</span><span class="no">CX</span><span class="p">)</span> <span class="c1"># g0.m=m0	
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="c1"># CLD 指令是 Clear Direction Flag 的缩写。用于将方向标志位 DF（Direction Flag）清零。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1"># 在x86架构的计算机中，方向标志位DF是一个标志寄存器中的一位，用于指示字符串操作指令（如 MOVSB、LODSB、STOSB 等）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1"># 在执行时是按照递增方向还是递减方向进行操作。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1"># 当 DF 为 0 时，字符串指针将按照递增方向移动；当 DF 为 1 时，字符串指针将按照递减方向移动。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1"># CLD 指令将方向标志位 DF 清零，表示字符串操作指令将按照递增方向进行操作。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1"># 如果我们使用MOVSB指令将一个长度为10字节的字符串从存储器中复制到寄存器中，它会按照递增方向从存储器中的第一个字节开始读取数据，
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1"># 并将它们复制到寄存器中。然后，它会递增存储器地址和寄存器地址，以便读取和复制下一个字节，直到整个字符串被复制到寄存器中为止。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1"># 意思是，在使用字符串操作指令时，这些指令会按照递增方向操作，即按照存储器地址递增的顺序复制数据。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">CLD</span>     <span class="c1"># convention is D is always left cleared
</span></span></span></code></pre></td></tr></table>
</div>
</div><ol start="6">
<li>此时，主线程，<code>m0</code>，<code>g0</code>以及<code>g0</code>的栈之间的关系如下图所示：</li>
</ol>
<p><img loading="lazy" src="../images/goroutine-005.png" alt=""  />
</p>
<ol start="7">
<li>总结：这段函数通过<code>runtime·settls()</code>函数把当前工作线程的<code>FS</code>寄存器地址设置为<code>&amp;m0.tls[1]</code>地址的值，然后再验证是否设置成功。然后把<code>g0</code>地址放入<code>FS</code>段寄存器中，也就是<code>&amp;m0.tls[0]</code>处，表示当前工作线程正在执行<code>g0</code>。接着设置<code>m0.g0=g0</code>和<code>g0.m=m0</code>，把<code>g0</code>和<code>m0</code>相关联起。</li>
</ol>
<h2 id="检查">检查<a hidden class="anchor" aria-hidden="true" href="#检查">#</a></h2>
<ol>
<li>编译器会在很多函数需要前封装一层把<code>g</code>写入<code>R14</code>寄存器中。这里编译器会把<code>g0</code>写入<code>R14</code>寄存其中。</li>
<li>主要是<code>runtime·check()</code>函数，检查内置类型的相关。</li>
<li>文件位置：<code>go1.19.3/src/runtime/asm_amd64.s</code>。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">278
</span><span class="lnt">279
</span><span class="lnt">280
</span><span class="lnt">281
</span><span class="lnt">282
</span><span class="lnt">283
</span><span class="lnt">284
</span><span class="lnt">285
</span><span class="lnt">286
</span><span class="lnt">287
</span><span class="lnt">288
</span><span class="lnt">289
</span><span class="lnt">290
</span><span class="lnt">291
</span><span class="lnt">292
</span><span class="lnt">293
</span><span class="lnt">294
</span><span class="lnt">295
</span><span class="lnt">296
</span><span class="lnt">297
</span><span class="lnt">298
</span><span class="lnt">299
</span><span class="lnt">300
</span><span class="lnt">301
</span><span class="lnt">302
</span><span class="lnt">303
</span><span class="lnt">304
</span><span class="lnt">305
</span><span class="lnt">306
</span><span class="lnt">307
</span><span class="lnt">308
</span><span class="lnt">309
</span><span class="lnt">310
</span><span class="lnt">311
</span><span class="lnt">312
</span><span class="lnt">313
</span><span class="lnt">314
</span><span class="lnt">315
</span><span class="lnt">316
</span><span class="lnt">317
</span><span class="lnt">318
</span><span class="lnt">319
</span><span class="lnt">320
</span><span class="lnt">321
</span><span class="lnt">322
</span><span class="lnt">323
</span><span class="lnt">324
</span><span class="lnt">325
</span><span class="lnt">326
</span><span class="lnt">327
</span><span class="lnt">328
</span><span class="lnt">329
</span><span class="lnt">330
</span><span class="lnt">331
</span><span class="lnt">332
</span><span class="lnt">333
</span><span class="lnt">334
</span><span class="lnt">335
</span><span class="lnt">336
</span><span class="lnt">337
</span><span class="lnt">338
</span><span class="lnt">339
</span><span class="lnt">340
</span><span class="lnt">341
</span><span class="lnt">342
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-asm" data-lang="asm"><span class="line"><span class="cl">    <span class="c1"># Check GOAMD64 reqirements
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1"># We need to do this after setting up TLS, so that
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1"># we can report an error if there is a failure. See issue 49586.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">#
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1"># 检查GOAMD64要求我们需要在设置TLS后执行此操作，以便在出现失败时报告错误。
</span></span></span><span class="line"><span class="cl"><span class="c1">#ifdef NEED_FEATURES_CX	
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">MOVL</span>    <span class="no">$0</span><span class="p">,</span> <span class="no">AX</span>
</span></span><span class="line"><span class="cl">    <span class="nf">CPUID</span>
</span></span><span class="line"><span class="cl">    <span class="nf">CMPL</span>    <span class="no">AX</span><span class="p">,</span> <span class="no">$0</span>
</span></span><span class="line"><span class="cl">    <span class="nf">JE</span>	<span class="no">bad_cpu</span>
</span></span><span class="line"><span class="cl">    <span class="nf">MOVL</span>    <span class="no">$1</span><span class="p">,</span> <span class="no">AX</span>
</span></span><span class="line"><span class="cl">    <span class="nf">CPUID</span>
</span></span><span class="line"><span class="cl">    <span class="nf">ANDL</span>    <span class="no">$NEED_FEATURES_CX</span><span class="p">,</span> <span class="no">CX</span>
</span></span><span class="line"><span class="cl">    <span class="nf">CMPL</span>    <span class="no">CX</span><span class="p">,</span> <span class="no">$NEED_FEATURES_CX</span>
</span></span><span class="line"><span class="cl">    <span class="nf">JNE</span>	<span class="no">bad_cpu</span>
</span></span><span class="line"><span class="cl"><span class="c1">#endif
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">#ifdef NEED_MAX_CPUID
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">MOVL</span>    <span class="no">$0x80000000</span><span class="p">,</span> <span class="no">AX</span>
</span></span><span class="line"><span class="cl">    <span class="nf">CPUID</span>
</span></span><span class="line"><span class="cl">    <span class="nf">CMPL</span>    <span class="no">AX</span><span class="p">,</span> <span class="no">$NEED_MAX_CPUID</span>
</span></span><span class="line"><span class="cl">    <span class="nf">JL</span>  <span class="no">bad_cpu</span>
</span></span><span class="line"><span class="cl"><span class="c1">#endif
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">#ifdef NEED_EXT_FEATURES_BX
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">MOVL</span>    <span class="no">$7</span><span class="p">,</span> <span class="no">AX</span>
</span></span><span class="line"><span class="cl">    <span class="nf">MOVL</span>    <span class="no">$0</span><span class="p">,</span> <span class="no">CX</span>
</span></span><span class="line"><span class="cl">    <span class="nf">CPUID</span>
</span></span><span class="line"><span class="cl">    <span class="nf">ANDL</span>    <span class="no">$NEED_EXT_FEATURES_BX</span><span class="p">,</span> <span class="no">BX</span>
</span></span><span class="line"><span class="cl">    <span class="nf">CMPL</span>    <span class="no">BX</span><span class="p">,</span> <span class="no">$NEED_EXT_FEATURES_BX</span>
</span></span><span class="line"><span class="cl">    <span class="nf">JNE</span> <span class="no">bad_cpu</span>
</span></span><span class="line"><span class="cl"><span class="c1">#endif
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">#ifdef NEED_EXT_FEATURES_CX
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">MOVL</span>    <span class="no">$0x80000001</span><span class="p">,</span> <span class="no">AX</span>
</span></span><span class="line"><span class="cl">    <span class="nf">CPUID</span>
</span></span><span class="line"><span class="cl">    <span class="nf">ANDL</span>    <span class="no">$NEED_EXT_FEATURES_CX</span><span class="p">,</span> <span class="no">CX</span>
</span></span><span class="line"><span class="cl">    <span class="nf">CMPL</span>    <span class="no">CX</span><span class="p">,</span> <span class="no">$NEED_EXT_FEATURES_CX</span>
</span></span><span class="line"><span class="cl">    <span class="nf">JNE</span> <span class="no">bad_cpu</span>
</span></span><span class="line"><span class="cl"><span class="c1">#endif
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">#ifdef NEED_OS_SUPPORT_AX
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">XORL</span>    <span class="no">CX</span><span class="p">,</span> <span class="no">CX</span>
</span></span><span class="line"><span class="cl">    <span class="nf">XGETBV</span>
</span></span><span class="line"><span class="cl">    <span class="nf">ANDL</span>    <span class="no">$NEED_OS_SUPPORT_AX</span><span class="p">,</span> <span class="no">AX</span>
</span></span><span class="line"><span class="cl">    <span class="nf">CMPL</span>    <span class="no">AX</span><span class="p">,</span> <span class="no">$NEED_OS_SUPPORT_AX</span>
</span></span><span class="line"><span class="cl">    <span class="nf">JNE</span> <span class="no">bad_cpu</span>
</span></span><span class="line"><span class="cl"><span class="c1">#endif
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">#ifdef NEED_DARWIN_SUPPORT
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">MOVQ</span>    <span class="no">$commpage64_version</span><span class="p">,</span> <span class="no">BX</span>
</span></span><span class="line"><span class="cl">    <span class="nf">CMPW</span>    <span class="p">(</span><span class="no">BX</span><span class="p">),</span> <span class="no">$13</span>  <span class="c1"># cpu_capabilities64 undefined in versions &lt; 13
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">JL</span>  <span class="no">bad_cpu</span>
</span></span><span class="line"><span class="cl">    <span class="nf">MOVQ</span>    <span class="no">$commpage64_cpu_capabilities64</span><span class="p">,</span> <span class="no">BX</span>
</span></span><span class="line"><span class="cl">    <span class="nf">MOVQ</span>    <span class="p">(</span><span class="no">BX</span><span class="p">),</span> <span class="no">BX</span>
</span></span><span class="line"><span class="cl">    <span class="nf">MOVQ</span>    <span class="no">$NEED_DARWIN_SUPPORT</span><span class="p">,</span> <span class="no">CX</span>
</span></span><span class="line"><span class="cl">    <span class="nf">ANDQ</span>    <span class="no">CX</span><span class="p">,</span> <span class="no">BX</span>
</span></span><span class="line"><span class="cl">    <span class="nf">CMPQ</span>    <span class="no">BX</span><span class="p">,</span> <span class="no">CX</span>
</span></span><span class="line"><span class="cl">    <span class="nf">JNE</span> <span class="no">bad_cpu</span>
</span></span><span class="line"><span class="cl"><span class="c1">#endif
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1"># &#34;TEXT runtime.check(SB)&#34; 是由编译器实现，因为以下check方法由runtime的Go实现需要获取g。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1"># 编译器实现 &#34;TEXT runtime.check(SB)&#34; 是需要把g0写入R14中，然后JMP跳转到check
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1"># 该函数在 go1.19.3/src/runtime/runtime1.go:check() 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1"># 主要是检查go支持的变量内存情况，原子CAS函数等
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">CALL</span>    <span class="no">runtime</span><span class="err">·</span><span class="no">check</span><span class="p">(</span><span class="no">SB</span><span class="p">)</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ol start="4">
<li><code>runtime·check(SB)</code> 汇编开头几行。</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-asm" data-lang="asm"><span class="line"><span class="cl"><span class="nf">TEXT</span> <span class="no">runtime.check</span><span class="p">(</span><span class="no">SB</span><span class="p">)</span> <span class="err">&lt;</span><span class="no">autogenerated</span><span class="err">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="nf">xorps</span> <span class="no">xmm15</span><span class="p">,</span> <span class="no">xmm15</span>	<span class="c1"># 清除xmm15寄存器，可能后面函数需要使用
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nf">mov</span> <span class="no">r14</span><span class="p">,</span> <span class="no">qword</span> <span class="no">ptr</span> <span class="no">fs</span><span class="p">:[</span><span class="mi">0xfffffff8</span><span class="p">]</span> <span class="c1"># R14 = g0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nf">jmp</span> <span class="no">$runtime.check</span> <span class="c1"># 跳转 check() 函数
</span></span></span></code></pre></div><ol start="5">
<li><code>runtime.check()</code>的源码定义在<code>/src/runtime/runtime1.go</code>文件中。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">142
</span><span class="lnt">143
</span><span class="lnt">144
</span><span class="lnt">145
</span><span class="lnt">146
</span><span class="lnt">147
</span><span class="lnt">148
</span><span class="lnt">149
</span><span class="lnt">150
</span><span class="lnt">151
</span><span class="lnt">152
</span><span class="lnt">153
</span><span class="lnt">154
</span><span class="lnt">155
</span><span class="lnt">156
</span><span class="lnt">157
</span><span class="lnt">158
</span><span class="lnt">159
</span><span class="lnt">160
</span><span class="lnt">161
</span><span class="lnt">162
</span><span class="lnt">163
</span><span class="lnt">164
</span><span class="lnt">165
</span><span class="lnt">166
</span><span class="lnt">167
</span><span class="lnt">168
</span><span class="lnt">169
</span><span class="lnt">170
</span><span class="lnt">171
</span><span class="lnt">172
</span><span class="lnt">173
</span><span class="lnt">174
</span><span class="lnt">175
</span><span class="lnt">176
</span><span class="lnt">177
</span><span class="lnt">178
</span><span class="lnt">179
</span><span class="lnt">180
</span><span class="lnt">181
</span><span class="lnt">182
</span><span class="lnt">183
</span><span class="lnt">184
</span><span class="lnt">185
</span><span class="lnt">186
</span><span class="lnt">187
</span><span class="lnt">188
</span><span class="lnt">189
</span><span class="lnt">190
</span><span class="lnt">191
</span><span class="lnt">192
</span><span class="lnt">193
</span><span class="lnt">194
</span><span class="lnt">195
</span><span class="lnt">196
</span><span class="lnt">197
</span><span class="lnt">198
</span><span class="lnt">199
</span><span class="lnt">200
</span><span class="lnt">201
</span><span class="lnt">202
</span><span class="lnt">203
</span><span class="lnt">204
</span><span class="lnt">205
</span><span class="lnt">206
</span><span class="lnt">207
</span><span class="lnt">208
</span><span class="lnt">209
</span><span class="lnt">210
</span><span class="lnt">211
</span><span class="lnt">212
</span><span class="lnt">213
</span><span class="lnt">214
</span><span class="lnt">215
</span><span class="lnt">216
</span><span class="lnt">217
</span><span class="lnt">218
</span><span class="lnt">219
</span><span class="lnt">220
</span><span class="lnt">221
</span><span class="lnt">222
</span><span class="lnt">223
</span><span class="lnt">224
</span><span class="lnt">225
</span><span class="lnt">226
</span><span class="lnt">227
</span><span class="lnt">228
</span><span class="lnt">229
</span><span class="lnt">230
</span><span class="lnt">231
</span><span class="lnt">232
</span><span class="lnt">233
</span><span class="lnt">234
</span><span class="lnt">235
</span><span class="lnt">236
</span><span class="lnt">237
</span><span class="lnt">238
</span><span class="lnt">239
</span><span class="lnt">240
</span><span class="lnt">241
</span><span class="lnt">242
</span><span class="lnt">243
</span><span class="lnt">244
</span><span class="lnt">245
</span><span class="lnt">246
</span><span class="lnt">247
</span><span class="lnt">248
</span><span class="lnt">249
</span><span class="lnt">250
</span><span class="lnt">251
</span><span class="lnt">252
</span><span class="lnt">253
</span><span class="lnt">254
</span><span class="lnt">255
</span><span class="lnt">256
</span><span class="lnt">257
</span><span class="lnt">258
</span><span class="lnt">259
</span><span class="lnt">260
</span><span class="lnt">261
</span><span class="lnt">262
</span><span class="lnt">263
</span><span class="lnt">264
</span><span class="lnt">265
</span><span class="lnt">266
</span><span class="lnt">267
</span><span class="lnt">268
</span><span class="lnt">269
</span><span class="lnt">270
</span><span class="lnt">271
</span><span class="lnt">272
</span><span class="lnt">273
</span><span class="lnt">274
</span><span class="lnt">275
</span><span class="lnt">276
</span><span class="lnt">277
</span><span class="lnt">278
</span><span class="lnt">279
</span><span class="lnt">280
</span><span class="lnt">281
</span><span class="lnt">282
</span><span class="lnt">283
</span><span class="lnt">284
</span><span class="lnt">285
</span><span class="lnt">286
</span><span class="lnt">287
</span><span class="lnt">288
</span><span class="lnt">289
</span><span class="lnt">290
</span><span class="lnt">291
</span><span class="lnt">292
</span><span class="lnt">293
</span><span class="lnt">294
</span><span class="lnt">295
</span><span class="lnt">296
</span><span class="lnt">297
</span><span class="lnt">298
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">check</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">var</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">        <span class="nx">a</span>     <span class="kt">int8</span>
</span></span><span class="line"><span class="cl">        <span class="nx">b</span>     <span class="kt">uint8</span>
</span></span><span class="line"><span class="cl">        <span class="nx">c</span>     <span class="kt">int16</span>
</span></span><span class="line"><span class="cl">        <span class="nx">d</span>     <span class="kt">uint16</span>
</span></span><span class="line"><span class="cl">        <span class="nx">e</span>     <span class="kt">int32</span>
</span></span><span class="line"><span class="cl">        <span class="nx">f</span>     <span class="kt">uint32</span>
</span></span><span class="line"><span class="cl">        <span class="nx">g</span>     <span class="kt">int64</span>
</span></span><span class="line"><span class="cl">        <span class="nx">h</span>     <span class="kt">uint64</span>
</span></span><span class="line"><span class="cl">        <span class="nx">i</span><span class="p">,</span> <span class="nx">i1</span> <span class="kt">float32</span>
</span></span><span class="line"><span class="cl">        <span class="nx">j</span><span class="p">,</span> <span class="nx">j1</span> <span class="kt">float64</span>
</span></span><span class="line"><span class="cl">        <span class="nx">k</span>     <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span>
</span></span><span class="line"><span class="cl">        <span class="nx">l</span>     <span class="o">*</span><span class="kt">uint16</span>
</span></span><span class="line"><span class="cl">        <span class="nx">m</span>     <span class="p">[</span><span class="mi">4</span><span class="p">]</span><span class="kt">byte</span>
</span></span><span class="line"><span class="cl">    <span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="kd">type</span> <span class="nx">x1t</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">x</span> <span class="kt">uint8</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="kd">type</span> <span class="nx">y1t</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">x1</span> <span class="nx">x1t</span>
</span></span><span class="line"><span class="cl">        <span class="nx">y</span>  <span class="kt">uint8</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="kd">var</span> <span class="nx">x1</span> <span class="nx">x1t</span>
</span></span><span class="line"><span class="cl">    <span class="kd">var</span> <span class="nx">y1</span> <span class="nx">y1t</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 检查 int8 类型占用字节长度
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Sizeof</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">throw</span><span class="p">(</span><span class="s">&#34;bad a&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 检查 uint8 类型占用字节长度
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Sizeof</span><span class="p">(</span><span class="nx">b</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">throw</span><span class="p">(</span><span class="s">&#34;bad b&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Sizeof</span><span class="p">(</span><span class="nx">c</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">throw</span><span class="p">(</span><span class="s">&#34;bad c&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Sizeof</span><span class="p">(</span><span class="nx">d</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">throw</span><span class="p">(</span><span class="s">&#34;bad d&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Sizeof</span><span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">4</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">throw</span><span class="p">(</span><span class="s">&#34;bad e&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Sizeof</span><span class="p">(</span><span class="nx">f</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">4</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">throw</span><span class="p">(</span><span class="s">&#34;bad f&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Sizeof</span><span class="p">(</span><span class="nx">g</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">8</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">throw</span><span class="p">(</span><span class="s">&#34;bad g&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Sizeof</span><span class="p">(</span><span class="nx">h</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">8</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">throw</span><span class="p">(</span><span class="s">&#34;bad h&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Sizeof</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">4</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">throw</span><span class="p">(</span><span class="s">&#34;bad i&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Sizeof</span><span class="p">(</span><span class="nx">j</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">8</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">throw</span><span class="p">(</span><span class="s">&#34;bad j&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Sizeof</span><span class="p">(</span><span class="nx">k</span><span class="p">)</span> <span class="o">!=</span> <span class="nx">goarch</span><span class="p">.</span><span class="nx">PtrSize</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">throw</span><span class="p">(</span><span class="s">&#34;bad k&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Sizeof</span><span class="p">(</span><span class="nx">l</span><span class="p">)</span> <span class="o">!=</span> <span class="nx">goarch</span><span class="p">.</span><span class="nx">PtrSize</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">throw</span><span class="p">(</span><span class="s">&#34;bad l&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Sizeof</span><span class="p">(</span><span class="nx">x1</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">throw</span><span class="p">(</span><span class="s">&#34;bad unsafe.Sizeof x1&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Offsetof</span><span class="p">(</span><span class="nx">y1</span><span class="p">.</span><span class="nx">y</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">throw</span><span class="p">(</span><span class="s">&#34;bad offsetof y1.y&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Sizeof</span><span class="p">(</span><span class="nx">y1</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">throw</span><span class="p">(</span><span class="s">&#34;bad unsafe.Sizeof y1&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nf">timediv</span><span class="p">(</span><span class="mi">12345</span><span class="o">*</span><span class="mi">1000000000</span><span class="o">+</span><span class="mi">54321</span><span class="p">,</span> <span class="mi">1000000000</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">e</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">12345</span> <span class="o">||</span> <span class="nx">e</span> <span class="o">!=</span> <span class="mi">54321</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">throw</span><span class="p">(</span><span class="s">&#34;bad timediv&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">var</span> <span class="nx">z</span> <span class="kt">uint32</span>
</span></span><span class="line"><span class="cl">    <span class="nx">z</span> <span class="p">=</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 检查原子操作相关
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">!</span><span class="nx">atomic</span><span class="p">.</span><span class="nf">Cas</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">z</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">throw</span><span class="p">(</span><span class="s">&#34;cas1&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">z</span> <span class="o">!=</span> <span class="mi">2</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">throw</span><span class="p">(</span><span class="s">&#34;cas2&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nx">z</span> <span class="p">=</span> <span class="mi">4</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Cas</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">z</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">throw</span><span class="p">(</span><span class="s">&#34;cas3&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">z</span> <span class="o">!=</span> <span class="mi">4</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">throw</span><span class="p">(</span><span class="s">&#34;cas4&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nx">z</span> <span class="p">=</span> <span class="mh">0xffffffff</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">!</span><span class="nx">atomic</span><span class="p">.</span><span class="nf">Cas</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">z</span><span class="p">,</span> <span class="mh">0xffffffff</span><span class="p">,</span> <span class="mh">0xfffffffe</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">throw</span><span class="p">(</span><span class="s">&#34;cas5&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">z</span> <span class="o">!=</span> <span class="mh">0xfffffffe</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">throw</span><span class="p">(</span><span class="s">&#34;cas6&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nx">m</span> <span class="p">=</span> <span class="p">[</span><span class="mi">4</span><span class="p">]</span><span class="kt">byte</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nx">atomic</span><span class="p">.</span><span class="nf">Or8</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">m</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mh">0xf0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">m</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">1</span> <span class="o">||</span> <span class="nx">m</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="mh">0xf1</span> <span class="o">||</span> <span class="nx">m</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">1</span> <span class="o">||</span> <span class="nx">m</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">1</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">throw</span><span class="p">(</span><span class="s">&#34;atomicor8&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nx">m</span> <span class="p">=</span> <span class="p">[</span><span class="mi">4</span><span class="p">]</span><span class="kt">byte</span><span class="p">{</span><span class="mh">0xff</span><span class="p">,</span> <span class="mh">0xff</span><span class="p">,</span> <span class="mh">0xff</span><span class="p">,</span> <span class="mh">0xff</span><span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nx">atomic</span><span class="p">.</span><span class="nf">And8</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">m</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mh">0x1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">m</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="mh">0xff</span> <span class="o">||</span> <span class="nx">m</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="mh">0x1</span> <span class="o">||</span> <span class="nx">m</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">!=</span> <span class="mh">0xff</span> <span class="o">||</span> <span class="nx">m</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">!=</span> <span class="mh">0xff</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">throw</span><span class="p">(</span><span class="s">&#34;atomicand8&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="kt">uint64</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">j</span><span class="p">))</span> <span class="p">=</span> <span class="p">^</span><span class="nb">uint64</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">j</span> <span class="o">==</span> <span class="nx">j</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">throw</span><span class="p">(</span><span class="s">&#34;float64nan&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">!(</span><span class="nx">j</span> <span class="o">!=</span> <span class="nx">j</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">throw</span><span class="p">(</span><span class="s">&#34;float64nan1&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="kt">uint64</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">j1</span><span class="p">))</span> <span class="p">=</span> <span class="p">^</span><span class="nb">uint64</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">j</span> <span class="o">==</span> <span class="nx">j1</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">throw</span><span class="p">(</span><span class="s">&#34;float64nan2&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">!(</span><span class="nx">j</span> <span class="o">!=</span> <span class="nx">j1</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">throw</span><span class="p">(</span><span class="s">&#34;float64nan3&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="kt">uint32</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">i</span><span class="p">))</span> <span class="p">=</span> <span class="p">^</span><span class="nb">uint32</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">i</span> <span class="o">==</span> <span class="nx">i</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">throw</span><span class="p">(</span><span class="s">&#34;float32nan&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">i</span> <span class="o">==</span> <span class="nx">i</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">throw</span><span class="p">(</span><span class="s">&#34;float32nan1&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="kt">uint32</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">i1</span><span class="p">))</span> <span class="p">=</span> <span class="p">^</span><span class="nb">uint32</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">i</span> <span class="o">==</span> <span class="nx">i1</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">throw</span><span class="p">(</span><span class="s">&#34;float32nan2&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">i</span> <span class="o">==</span> <span class="nx">i1</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">throw</span><span class="p">(</span><span class="s">&#34;float32nan3&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nf">testAtomic64</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">_FixedStack</span> <span class="o">!=</span> <span class="nf">round2</span><span class="p">(</span><span class="nx">_FixedStack</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">throw</span><span class="p">(</span><span class="s">&#34;FixedStack is not power-of-2&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">!</span><span class="nf">checkASM</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">throw</span><span class="p">(</span><span class="s">&#34;assembly checks failed&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ol start="6">
<li>总结：这段代码主要是调用了<code>runtime·check()</code>函数，该函数主要是检查编译器是否按照预期，检查了相关内存占用值和原子操作等。</li>
</ol>
<h2 id="初始化m0">初始化<code>m0</code><a hidden class="anchor" aria-hidden="true" href="#初始化m0">#</a></h2>
<ol>
<li>处理命令行参数，调用<code>osinit</code>函数获取<code>CPU</code>核的数量并保存在全局变量<code>ncpu</code>之中，</li>
<li>调度器初始化时需要知道当前系统有多少个<code>CPU</code>核。</li>
<li>调用<code>runtime.args()</code>函数来暂存命令行参数以待后续解析。部分系统会在这里获取与硬件相关的一些参数，例如物理页面大小。</li>
<li>文件位置：<code>go1.19.3/src/runtime/asm_amd64.s</code>。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">338
</span><span class="lnt">339
</span><span class="lnt">340
</span><span class="lnt">341
</span><span class="lnt">342
</span><span class="lnt">343
</span><span class="lnt">344
</span><span class="lnt">345
</span><span class="lnt">346
</span><span class="lnt">347
</span><span class="lnt">348
</span><span class="lnt">349
</span><span class="lnt">350
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-asm" data-lang="asm"><span class="line"><span class="cl">    <span class="c1"># 1) 准备调用args函数，前面四条指令把参数放在栈上
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">MOVL</span>	<span class="mi">24</span><span class="p">(</span><span class="no">SP</span><span class="p">),</span> <span class="no">AX</span>		<span class="c1"># copy argc   AX=argc
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">MOVL</span>	<span class="no">AX</span><span class="p">,</span> <span class="mi">0</span><span class="p">(</span><span class="no">SP</span><span class="p">)</span>		<span class="c1"># argc放在栈顶，为调用runtime·args的第一个参数，var argc int32
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">MOVQ</span>	<span class="mi">32</span><span class="p">(</span><span class="no">SP</span><span class="p">),</span> <span class="no">AX</span>		<span class="c1"># copy argv   AX=*argv
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">MOVQ</span>	<span class="no">AX</span><span class="p">,</span> <span class="mi">8</span><span class="p">(</span><span class="no">SP</span><span class="p">)</span>		<span class="c1"># argv放在SP+8的位置，为调用runtime·args的第二个参数，var argv **byte
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1"># 保存 argc和argv 遍历 auxv 设置 physPageSize 和 startupRandomData 以及处理 VDSO
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1"># 处理操作系统传递过来的参数和env，复制全局变量argc和argv值，并处理系统参数赋值给cpu相关
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">CALL</span>	<span class="no">runtime</span><span class="err">·</span><span class="no">args</span><span class="p">(</span><span class="no">SB</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1"># 获取CPU核数保存在ncpu中，获取physHugePageSize参数。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1"># physHugePageSize 是分配大页面时候被用到。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">CALL</span>	<span class="no">runtime</span><span class="err">·</span><span class="no">osinit</span><span class="p">(</span><span class="no">SB</span><span class="p">)</span>		<span class="c1"># 执行的结果是全局变量ncpu = CPU核数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">CALL</span>	<span class="no">runtime</span><span class="err">·</span><span class="no">schedinit</span><span class="p">(</span><span class="no">SB</span><span class="p">)</span>	<span class="c1"># 调度系统初始化
</span></span></span></code></pre></td></tr></table>
</div>
</div><h3 id="argssb-"><code>args(SB) </code><a hidden class="anchor" aria-hidden="true" href="#argssb-">#</a></h3>
<ol>
<li>关于 argv 的分布图。
<ul>
<li><code>argv</code>：是一个指向字符指针的指针数组，其中每个字符指针指向一个以 null 结尾的字符串，这些字符串代表了程序启动时在命令行上输入的参数。数组的第一个元素 argv[0] 通常包含了程序的名称或路径，而随后的元素 argv[1] 到 argv[argc-1] 包含了程序的实际参数。</li>
<li><code>envp</code>：是一个指向环境变量的指针数组，这些环境变量在程序启动时由操作系统传递给程序。每个数组元素都是一个以 null 结尾的字符串，表示一个键值对，其中键和值之间通过等号(=)连接。环境变量是操作系统用来存储有关当前会话或执行环境的信息的一种方式。它们通常用于配置程序的行为，提供路径信息，或者存储用户特定的设置。
<ul>
<li>以下是一些常见的环境变量及其用途：
<ul>
<li>HOME：用户的主目录路径。</li>
<li>PATH：执行命令时要搜索的目录列表。</li>
<li>PWD：当前工作目录的路径。</li>
<li>USER：当前登录的用户名。</li>
<li>SHELL：用户登录的 shell 的路径。</li>
<li>LANG：系统语言和地区设置。</li>
<li>DISPLAY：X Window System 的显示变量，用于图形界面程序。</li>
<li>EDITOR：用户的首选文本编辑器。</li>
<li>TERM：终端类型。</li>
</ul>
</li>
</ul>
</li>
<li><code>auxv</code>：为程序提供了关于其执行环境的额外信息。
<ul>
<li>以下是一些常见的 auxv 条目类型及其含义：
<ul>
<li>AT_NULL：标志着 auxv 数组的结束。</li>
<li>AT_EXECFD：执行文件的文件描述符。</li>
<li>AT_PHDR：程序头表的地址。</li>
<li>AT_PHENT：程序头表中每个条目的大小。</li>
<li>AT_PHNUM：程序头表中的条目数量。</li>
<li>AT_PAGESZ：系统的页面大小。</li>
<li>AT_BASE：动态链接器的基地址。</li>
<li>AT_ENTRY：程序的入口点地址。</li>
<li>AT_UID：执行程序的用户的真实用户 ID。</li>
<li>AT_EUID：执行程序的有效用户 ID。</li>
<li>AT_GID：执行程序的组 ID。</li>
<li>AT_EGID：执行程序的有效组 ID。</li>
<li>AT_SECURE：指示程序是否在 “secure mode” 下执行。</li>
<li>AT_RANDOM：提供随机值的指针，用于安全目的。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<p><img loading="lazy" src="../images/goroutine-006.png" alt=""  />
</p>
<ol>
<li>文件位置：<code>go1.19.3/src/runtime/runtime1.go</code>。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span><span class="lnt">77
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">args</span><span class="p">(</span><span class="nx">c</span> <span class="kt">int32</span><span class="p">,</span> <span class="nx">v</span> <span class="o">**</span><span class="kt">byte</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 保存 argc 和 argv
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">argc</span> <span class="p">=</span> <span class="nx">c</span> <span class="c1">// runtime的全局变量中
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">argv</span> <span class="p">=</span> <span class="nx">v</span> <span class="c1">// runtime的全局变量中
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 加载 auxv
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">sysargs</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">v</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">var</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="nx">argc</span> <span class="kt">int32</span>
</span></span><span class="line"><span class="cl">    <span class="nx">argv</span> <span class="o">**</span><span class="kt">byte</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="sysargs">sysargs()<a hidden class="anchor" aria-hidden="true" href="#sysargs">#</a></h4>
<ol>
<li>文件位置：<code>go1.19.3/src/runtime/os_linux.go</code>。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">224
</span><span class="lnt">225
</span><span class="lnt">226
</span><span class="lnt">227
</span><span class="lnt">228
</span><span class="lnt">229
</span><span class="lnt">230
</span><span class="lnt">231
</span><span class="lnt">232
</span><span class="lnt">233
</span><span class="lnt">234
</span><span class="lnt">235
</span><span class="lnt">236
</span><span class="lnt">237
</span><span class="lnt">238
</span><span class="lnt">239
</span><span class="lnt">240
</span><span class="lnt">241
</span><span class="lnt">242
</span><span class="lnt">243
</span><span class="lnt">244
</span><span class="lnt">245
</span><span class="lnt">246
</span><span class="lnt">247
</span><span class="lnt">248
</span><span class="lnt">249
</span><span class="lnt">250
</span><span class="lnt">251
</span><span class="lnt">252
</span><span class="lnt">253
</span><span class="lnt">254
</span><span class="lnt">255
</span><span class="lnt">256
</span><span class="lnt">257
</span><span class="lnt">258
</span><span class="lnt">259
</span><span class="lnt">260
</span><span class="lnt">261
</span><span class="lnt">262
</span><span class="lnt">263
</span><span class="lnt">264
</span><span class="lnt">265
</span><span class="lnt">266
</span><span class="lnt">267
</span><span class="lnt">268
</span><span class="lnt">269
</span><span class="lnt">270
</span><span class="lnt">271
</span><span class="lnt">272
</span><span class="lnt">273
</span><span class="lnt">274
</span><span class="lnt">275
</span><span class="lnt">276
</span><span class="lnt">277
</span><span class="lnt">278
</span><span class="lnt">279
</span><span class="lnt">280
</span><span class="lnt">281
</span><span class="lnt">282
</span><span class="lnt">283
</span><span class="lnt">284
</span><span class="lnt">285
</span><span class="lnt">286
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">sysargs</span><span class="p">(</span><span class="nx">argc</span> <span class="kt">int32</span><span class="p">,</span> <span class="nx">argv</span> <span class="o">**</span><span class="kt">byte</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 跳过 argv + NULL
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">n</span> <span class="o">:=</span> <span class="nx">argc</span> <span class="o">+</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// skip over argv, envp to get to auxv
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 跳过 argv 和 envp 直接到 auxv
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">for</span> <span class="nf">argv_index</span><span class="p">(</span><span class="nx">argv</span><span class="p">,</span> <span class="nx">n</span><span class="p">)</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">n</span><span class="o">++</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// skip NULL separator
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">n</span><span class="o">++</span> <span class="c1">// 跳过 NULL
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="c1">// now argv+n is auxv
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// argv+n 后现在是 auxv。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">auxv</span> <span class="o">:=</span> <span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">28</span><span class="p">]</span><span class="kt">uintptr</span><span class="p">)(</span><span class="nf">add</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">argv</span><span class="p">),</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">n</span><span class="p">)</span><span class="o">*</span><span class="nx">goarch</span><span class="p">.</span><span class="nx">PtrSize</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nf">sysauxv</span><span class="p">(</span><span class="nx">auxv</span><span class="p">[:])</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// In some situations we don&#39;t get a loader-provided
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// auxv, such as when loaded as a library on Android.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// Fall back to /proc/self/auxv.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 在某些情况下，我们不会得到加载器提供的auxv，比如在Android上作为库加载时。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 回到 /proc/self/auxv，去加载信息。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// var procAuxv []byte = []byte(&#34;/proc/self/auxv\x00&#34;)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">fd</span> <span class="o">:=</span> <span class="nf">open</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">procAuxv</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">0</span> <span class="cm">/* O_RDONLY */</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="c1">// 打开指定文件句柄
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nx">fd</span> <span class="p">&lt;</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// On Android, /proc/self/auxv might be unreadable (issue 9229), so we fallback to
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// try using mincore to detect the physical page size.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// mincore should return EINVAL when address is not a multiple of system page size.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="kd">const</span> <span class="nx">size</span> <span class="p">=</span> <span class="mi">256</span> <span class="o">&lt;&lt;</span> <span class="mi">10</span> <span class="c1">// size of memory region to allocate
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">p</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nf">mmap</span><span class="p">(</span><span class="kc">nil</span><span class="p">,</span> <span class="nx">size</span><span class="p">,</span> <span class="nx">_PROT_READ</span><span class="p">|</span><span class="nx">_PROT_WRITE</span><span class="p">,</span> <span class="nx">_MAP_ANON</span><span class="p">|</span><span class="nx">_MAP_PRIVATE</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="kd">var</span> <span class="nx">n</span> <span class="kt">uintptr</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="nx">n</span> <span class="p">=</span> <span class="mi">4</span> <span class="o">&lt;&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="nx">n</span> <span class="p">&lt;</span> <span class="nx">size</span><span class="p">;</span> <span class="nx">n</span> <span class="o">&lt;&lt;=</span> <span class="mi">1</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nx">err</span> <span class="o">:=</span> <span class="nf">mincore</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">p</span><span class="p">)</span><span class="o">+</span><span class="nx">n</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">addrspace_vec</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="nx">err</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="nx">physPageSize</span> <span class="p">=</span> <span class="nx">n</span>
</span></span><span class="line"><span class="cl">                <span class="k">break</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="nx">physPageSize</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nx">physPageSize</span> <span class="p">=</span> <span class="nx">size</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="nf">munmap</span><span class="p">(</span><span class="nx">p</span><span class="p">,</span> <span class="nx">size</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="kd">var</span> <span class="nx">buf</span> <span class="p">[</span><span class="mi">128</span><span class="p">]</span><span class="kt">uintptr</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 从当前文件中读取信息
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">n</span> <span class="p">=</span> <span class="nf">read</span><span class="p">(</span><span class="nx">fd</span><span class="p">,</span> <span class="nf">noescape</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">buf</span><span class="p">[</span><span class="mi">0</span><span class="p">])),</span> <span class="nb">int32</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Sizeof</span><span class="p">(</span><span class="nx">buf</span><span class="p">)))</span>
</span></span><span class="line"><span class="cl">    <span class="nf">closefd</span><span class="p">(</span><span class="nx">fd</span><span class="p">)</span> <span class="c1">// 关闭文件句柄
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nx">n</span> <span class="p">&lt;</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Make sure buf is terminated, even if we didn&#39;t read
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// the whole file.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 确保buf被终止，即使我们没有读取整个文件。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">buf</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="nx">buf</span><span class="p">)</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="p">=</span> <span class="nx">_AT_NULL</span>
</span></span><span class="line"><span class="cl">    <span class="nf">sysauxv</span><span class="p">(</span><span class="nx">buf</span><span class="p">[:])</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="argv_index">argv_index()<a hidden class="anchor" aria-hidden="true" href="#argv_index">#</a></h4>
<ol>
<li>文件位置：<code>go1.19.3/src/runtime/runtime1.go</code>。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// nosplit for use in linux startup sysargs
</span></span></span><span class="line"><span class="cl"><span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1">//go:nosplit
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">argv_index</span><span class="p">(</span><span class="nx">argv</span> <span class="o">**</span><span class="kt">byte</span><span class="p">,</span> <span class="nx">i</span> <span class="kt">int32</span><span class="p">)</span> <span class="o">*</span><span class="kt">byte</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="o">*</span><span class="p">(</span><span class="o">**</span><span class="kt">byte</span><span class="p">)(</span><span class="nf">add</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">argv</span><span class="p">),</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span><span class="o">*</span><span class="nx">goarch</span><span class="p">.</span><span class="nx">PtrSize</span><span class="p">))</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="sysauxv">sysauxv()<a hidden class="anchor" aria-hidden="true" href="#sysauxv">#</a></h4>
<ol>
<li>设置 <code>startupRandomData</code> 用于<code>Hash</code>，<code>physPageSize</code> 物理内存页大小，如果这些存在的情况下。</li>
<li>设置全局变量物理页面大小等。</li>
<li>文件位置：<code>go1.19.3/src/runtime/os_linux.go</code>。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">283
</span><span class="lnt">284
</span><span class="lnt">285
</span><span class="lnt">286
</span><span class="lnt">287
</span><span class="lnt">288
</span><span class="lnt">289
</span><span class="lnt">290
</span><span class="lnt">291
</span><span class="lnt">292
</span><span class="lnt">293
</span><span class="lnt">294
</span><span class="lnt">295
</span><span class="lnt">296
</span><span class="lnt">297
</span><span class="lnt">298
</span><span class="lnt">299
</span><span class="lnt">300
</span><span class="lnt">301
</span><span class="lnt">302
</span><span class="lnt">303
</span><span class="lnt">304
</span><span class="lnt">305
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">sysauxv</span><span class="p">(</span><span class="nx">auxv</span> <span class="p">[]</span><span class="kt">uintptr</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">var</span> <span class="nx">i</span> <span class="kt">int</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 遍历auxv直到结束 _AT_NULL，一次性取两个分别是 tag 和 val
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">for</span> <span class="p">;</span> <span class="nx">auxv</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">!=</span> <span class="nx">_AT_NULL</span><span class="p">;</span> <span class="nx">i</span> <span class="o">+=</span> <span class="mi">2</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">tag</span><span class="p">,</span> <span class="nx">val</span> <span class="o">:=</span> <span class="nx">auxv</span><span class="p">[</span><span class="nx">i</span><span class="p">],</span> <span class="nx">auxv</span><span class="p">[</span><span class="nx">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">        <span class="k">switch</span> <span class="nx">tag</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">case</span> <span class="nx">_AT_RANDOM</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// The kernel provides a pointer to 16-bytes
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// worth of random data.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// 内核提供了一个指向16字节随机数据的指针。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// startupRandomData保存在启动时初始化的随机字节。这些来自ELF AT_RANDOM辅助向量。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="nx">startupRandomData</span> <span class="p">=</span> <span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="mi">16</span><span class="p">]</span><span class="kt">byte</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">val</span><span class="p">))[:]</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="k">case</span> <span class="nx">_AT_PAGESZ</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">            <span class="nx">physPageSize</span> <span class="p">=</span> <span class="nx">val</span> <span class="c1">// 如果是物理页大小设置该值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="nf">archauxv</span><span class="p">(</span><span class="nx">tag</span><span class="p">,</span> <span class="nx">val</span><span class="p">)</span> <span class="c1">// 该函数在linux下是空
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nf">vdsoauxv</span><span class="p">(</span><span class="nx">tag</span><span class="p">,</span> <span class="nx">val</span><span class="p">)</span> <span class="c1">// 处理 vdso
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nx">i</span> <span class="o">/</span> <span class="mi">2</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="osinitsb">osinit(SB)<a hidden class="anchor" aria-hidden="true" href="#osinitsb">#</a></h3>
<ol>
<li><code>runtime.osinit()</code>函数中，所有的系统都会在这里获取<code>CPU</code>核心数，如果上一步<code>runtime.args()</code>没有成功获取物理页面大小，则部分系统会再次获取。<code>Linux</code>系统会在这里获取<code>Huge</code>物理页面的大小。</li>
<li>文件位置：<code>go1.19.3/src/runtime/os_linux.go</code>。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">329
</span><span class="lnt">330
</span><span class="lnt">331
</span><span class="lnt">332
</span><span class="lnt">333
</span><span class="lnt">334
</span><span class="lnt">335
</span><span class="lnt">336
</span><span class="lnt">337
</span><span class="lnt">338
</span><span class="lnt">339
</span><span class="lnt">340
</span><span class="lnt">341
</span><span class="lnt">342
</span><span class="lnt">343
</span><span class="lnt">344
</span><span class="lnt">345
</span><span class="lnt">346
</span><span class="lnt">347
</span><span class="lnt">348
</span><span class="lnt">349
</span><span class="lnt">350
</span><span class="lnt">351
</span><span class="lnt">352
</span><span class="lnt">353
</span><span class="lnt">354
</span><span class="lnt">355
</span><span class="lnt">356
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">osinit</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 获取 CPU 核数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">ncpu</span> <span class="p">=</span> <span class="nf">getproccount</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 获取Linux中物理内存大页面大小。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 大页面是指比普通页面（通常为 4KB）更大的页面大小，通常为 2MB 或 1GB。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 使用大页面可以提高内存访问效率和系统性能，因为在使用大页面时，内核需要管理更少的页表和 TLB 条目。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 该方法通过open去&#34;/sys/kernel/mm/transparent_hugepage/hpage_pmd_size&#34;路径读取的
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">physHugePageSize</span> <span class="p">=</span> <span class="nf">getHugePageSize</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">iscgo</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// #42494 glibc and musl reserve some signals for
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// internal use and require they not be blocked by
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// the rest of a normal C runtime. When the go runtime
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// blocks...unblocks signals, temporarily, the blocked
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// interval of time is generally very short. As such,
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// these expectations of *libc code are mostly met by
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// the combined go+cgo system of threads. However,
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// when go causes a thread to exit, via a return from
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// mstart(), the combined runtime can deadlock if
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// these signals are blocked. Thus, don&#39;t block these
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// signals when exiting threads.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// - glibc: SIGCANCEL (32), SIGSETXID (33)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// - musl: SIGTIMER (32), SIGCANCEL (33), SIGSYNCCALL (34)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nf">sigdelset</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sigsetAllExiting</span><span class="p">,</span> <span class="mi">32</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="nf">sigdelset</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sigsetAllExiting</span><span class="p">,</span> <span class="mi">33</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="nf">sigdelset</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sigsetAllExiting</span><span class="p">,</span> <span class="mi">34</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nf">osArchInit</span><span class="p">()</span> <span class="c1">// linux上该函数为空
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="获取cpu核数">获取cpu核数<a hidden class="anchor" aria-hidden="true" href="#获取cpu核数">#</a></h4>
<ol>
<li>这段代码通过调用操作系统的sched_getaffinity系统调用来获取当前进程的CPU亲和力掩码，这个掩码是一个位图，其中每个比特位对应一个CPU核心。如果某个比特位为1，则表示对应的CPU核心是可用的。代码通过遍历这个位图并计算为1的比特位的数量来得到可用的CPU核心数。这是一个高效的方式来获取系统资源信息，特别是在需要根据核心数来调整程序并行度的场景中。</li>
<li>文件位置：<code>go1.19.3/src/runtime/os_linux.go</code>。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span><span class="lnt">113
</span><span class="lnt">114
</span><span class="lnt">115
</span><span class="lnt">116
</span><span class="lnt">117
</span><span class="lnt">118
</span><span class="lnt">119
</span><span class="lnt">120
</span><span class="lnt">121
</span><span class="lnt">122
</span><span class="lnt">123
</span><span class="lnt">124
</span><span class="lnt">125
</span><span class="lnt">126
</span><span class="lnt">127
</span><span class="lnt">128
</span><span class="lnt">129
</span><span class="lnt">130
</span><span class="lnt">131
</span><span class="lnt">132
</span><span class="lnt">133
</span><span class="lnt">134
</span><span class="lnt">135
</span><span class="lnt">136
</span><span class="lnt">137
</span><span class="lnt">138
</span><span class="lnt">139
</span><span class="lnt">140
</span><span class="lnt">141
</span><span class="lnt">142
</span><span class="lnt">143
</span><span class="lnt">144
</span><span class="lnt">145
</span><span class="lnt">146
</span><span class="lnt">147
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">getproccount</span><span class="p">()</span> <span class="kt">int32</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// This buffer is huge (8 kB) but we are on the system stack
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// and there should be plenty of space (64 kB).
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// Also this is a leaf, so we&#39;re not holding up the memory for long.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// See golang.org/issue/11823.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// The suggested behavior here is to keep trying with ever-larger
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// buffers, but we don&#39;t have a dynamic memory allocator at the
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// moment, so that&#39;s a bit tricky and seems like overkill.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 这个缓冲区很大(8 kB)，但我们在系统堆栈上，应该有足够的空间(64 kB)。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 而且这是一个叶子，所以我们不会占用内存很长时间。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 这里建议的行为是继续尝试使用更大的缓冲区，但我们目前没有动态内存分配器，所以这有点棘手，似乎有点过度。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 定义了一个常量maxCPUs，值为65536。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 这个值并不是真正的CPU核心数，而是一个预定义的最大值，用于确定缓冲区大小。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kd">const</span> <span class="nx">maxCPUs</span> <span class="p">=</span> <span class="mi">64</span> <span class="o">*</span> <span class="mi">1024</span> <span class="c1">// 65536
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 定义了一个字节切片buf，大小为8192字节（即8KB）。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 这是因为每个CPU核心可以用一个比特位表示，所以8192字节可以表示65536个比特位，对应maxCPUs个CPU核心
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kd">var</span> <span class="nx">buf</span> <span class="p">[</span><span class="nx">maxCPUs</span> <span class="o">/</span> <span class="mi">8</span><span class="p">]</span><span class="kt">byte</span> <span class="c1">// 8KB
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 这行代码是核心，它调用了操作系统提供的sched_getaffinity系统调用。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 这个系统调用用于获取给定进程ID（这里是0，表示当前进程）的CPU亲和力掩码。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//  1. 第一个参数0表示当前进程的进程ID。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//  2. 第二个参数是缓冲区buf的大小。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//  3. 第三个参数是缓冲区的指针。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// r是系统调用的返回值，它表示实际写入缓冲区的字节数。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">r</span> <span class="o">:=</span> <span class="nf">sched_getaffinity</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Sizeof</span><span class="p">(</span><span class="nx">buf</span><span class="p">),</span> <span class="o">&amp;</span><span class="nx">buf</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="c1">// int32
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 如果系统调用返回负值，表示发生了错误。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 在这种情况下，函数返回1，这可能意味着至少有一个CPU核心是可用的。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nx">r</span> <span class="p">&lt;</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nx">n</span> <span class="o">:=</span> <span class="nb">int32</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 遍历缓冲区直到实际写入的字节数。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 这段代码实际上是在计算缓冲区中设置为1的比特位的数量，每个为1的比特位代表一个可用的CPU核心。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">buf</span><span class="p">[:</span><span class="nx">r</span><span class="p">]</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 对于缓冲区的每个字节，如果它不为0，则进行处理。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">for</span> <span class="nx">v</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 通过检查每个比特位是否为1来计算核心数。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// 这里使用了位运算&amp;来检查最低位是否为1，如果是，则增加核心数。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="nx">n</span> <span class="o">+=</span> <span class="nb">int32</span><span class="p">(</span><span class="nx">v</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 将字节右移一位，继续检查下一个比特位。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="nx">v</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// n = 4
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 如果计算得出的核心数为0（这可能是一个错误的情况），则默认设置为1。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nx">n</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">n</span> <span class="p">=</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 函数返回计算出的CPU核心数。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">return</span> <span class="nx">n</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ol start="3">
<li>sched_getaffinity 函数原型。</li>
<li>文件位置：<code>go1.19.3/src/runtime/os_linux.go</code>。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">448
</span><span class="lnt">449
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">//go:noescape
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">sched_getaffinity</span><span class="p">(</span><span class="nx">pid</span><span class="p">,</span> <span class="nx">len</span> <span class="kt">uintptr</span><span class="p">,</span> <span class="nx">buf</span> <span class="o">*</span><span class="kt">byte</span><span class="p">)</span> <span class="kt">int32</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ol start="5">
<li>汇编文件地址：<code>go1.19.3/src/runtime/sys_linux_amd64.s</code>。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">660
</span><span class="lnt">661
</span><span class="lnt">662
</span><span class="lnt">663
</span><span class="lnt">664
</span><span class="lnt">665
</span><span class="lnt">666
</span><span class="lnt">667
</span><span class="lnt">668
</span><span class="lnt">669
</span><span class="lnt">670
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-asm" data-lang="asm"><span class="line"><span class="cl"><span class="nf">TEXT</span> <span class="no">runtime</span><span class="err">·</span><span class="no">sched_getaffinity</span><span class="p">(</span><span class="no">SB</span><span class="p">),</span><span class="no">NOSPLIT</span><span class="p">,</span><span class="no">$0</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># 第一个参数 pid 为 0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">MOVQ</span>    <span class="no">pid</span><span class="err">+</span><span class="mi">0</span><span class="p">(</span><span class="no">FP</span><span class="p">),</span> <span class="no">DI</span>	
</span></span><span class="line"><span class="cl">    <span class="c1"># 第二个参数 len 占用内存大小字节
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">MOVQ</span>    <span class="no">len</span><span class="err">+</span><span class="mi">8</span><span class="p">(</span><span class="no">FP</span><span class="p">),</span> <span class="no">SI</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># 第三个参数 buf *byte 指针
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">MOVQ</span>    <span class="no">buf</span><span class="err">+</span><span class="mi">16</span><span class="p">(</span><span class="no">FP</span><span class="p">),</span> <span class="no">DX</span>
</span></span><span class="line"><span class="cl">    <span class="nf">MOVL</span>    <span class="no">$SYS_sched_getaffinity</span><span class="p">,</span> <span class="no">AX</span> <span class="c1"># $SYS_sched_getaffinity = 204
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">SYSCALL</span>
</span></span><span class="line"><span class="cl">    <span class="nf">MOVL</span>    <span class="no">AX</span><span class="p">,</span> <span class="no">ret</span><span class="err">+</span><span class="mi">24</span><span class="p">(</span><span class="no">FP</span><span class="p">)</span> <span class="c1"># 保存返回值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">RET</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="获取物理内存页大小">获取物理内存页大小<a hidden class="anchor" aria-hidden="true" href="#获取物理内存页大小">#</a></h4>
<ol>
<li>这段代码通过读取操作系统文件/sys/kernel/mm/transparent_hugepage/hpage_pmd_size来获取透明大页的大小。</li>
<li>这个文件通常包含一个整数，表示透明大页的大小（通常是2的幂）。代码通过标准的文件打开、读取和关闭操作来获取这个值，并进行了一些基本的错误处理和验证，以确保返回的是一个合理的页大小。如果文件不存在、无法读取或内容不符合预期，函数将返回0。返回值uintptr是一个无符号整数类型，足以存储内存页大小。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">301
</span><span class="lnt">302
</span><span class="lnt">303
</span><span class="lnt">304
</span><span class="lnt">305
</span><span class="lnt">306
</span><span class="lnt">307
</span><span class="lnt">308
</span><span class="lnt">309
</span><span class="lnt">310
</span><span class="lnt">311
</span><span class="lnt">312
</span><span class="lnt">313
</span><span class="lnt">314
</span><span class="lnt">315
</span><span class="lnt">316
</span><span class="lnt">317
</span><span class="lnt">318
</span><span class="lnt">319
</span><span class="lnt">320
</span><span class="lnt">321
</span><span class="lnt">322
</span><span class="lnt">323
</span><span class="lnt">324
</span><span class="lnt">325
</span><span class="lnt">326
</span><span class="lnt">327
</span><span class="lnt">328
</span><span class="lnt">329
</span><span class="lnt">330
</span><span class="lnt">331
</span><span class="lnt">332
</span><span class="lnt">333
</span><span class="lnt">334
</span><span class="lnt">335
</span><span class="lnt">336
</span><span class="lnt">337
</span><span class="lnt">338
</span><span class="lnt">339
</span><span class="lnt">340
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// 定义了一个字节切片sysTHPSizePath，其中包含了透明大页大小的配置文件路径。
</span></span></span><span class="line"><span class="cl"><span class="c1">// 末尾的\x00是空字符，用于字符串的终止。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">var</span> <span class="nx">sysTHPSizePath</span> <span class="p">=</span> <span class="p">[]</span><span class="nb">byte</span><span class="p">(</span><span class="s">&#34;/sys/kernel/mm/transparent_hugepage/hpage_pmd_size\x00&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">getHugePageSize</span><span class="p">()</span> <span class="kt">uintptr</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">var</span> <span class="nx">numbuf</span> <span class="p">[</span><span class="mi">20</span><span class="p">]</span><span class="kt">byte</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 调用open函数以只读模式打开上述路径指定的文件。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 0作为第二个参数表示只读模式（O_RDONLY），第三个参数是模式，这里传0表示不需要特殊的文件权限。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">fd</span> <span class="o">:=</span> <span class="nf">open</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sysTHPSizePath</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">0</span> <span class="cm">/* O_RDONLY */</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 如果open函数返回的文件描述符小于0，表示打开文件失败，函数返回0。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nx">fd</span> <span class="p">&lt;</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 使用noescape函数来防止ptr逃逸到堆上，unsafe.Pointer将numbuf数组的地址转换为指针。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">ptr</span> <span class="o">:=</span> <span class="nf">noescape</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">numbuf</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 调用read函数从文件描述符fd读取内容到numbuf数组中，最多读取numbuf的长度个字节。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">n</span> <span class="o">:=</span> <span class="nf">read</span><span class="p">(</span><span class="nx">fd</span><span class="p">,</span> <span class="nx">ptr</span><span class="p">,</span> <span class="nb">int32</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">numbuf</span><span class="p">)))</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 读取完成后关闭文件描述符。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">closefd</span><span class="p">(</span><span class="nx">fd</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 如果读取的字节数小于或等于0，表示读取失败或文件为空，函数返回0。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nx">n</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 减去1，以移除读取到的字符串末尾的换行符。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">n</span><span class="o">--</span> <span class="c1">// remove trailing newline
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 将读取到的字节转换为字符串，然后使用atoi函数将字符串转换为整数。ok表示转换是否成功。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">v</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nf">atoi</span><span class="p">(</span><span class="nf">slicebytetostringtmp</span><span class="p">((</span><span class="o">*</span><span class="kt">byte</span><span class="p">)(</span><span class="nx">ptr</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="nx">n</span><span class="p">)))</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 如果转换失败或得到的值小于0，则将v设置为0。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">!</span><span class="nx">ok</span> <span class="o">||</span> <span class="nx">v</span> <span class="p">&lt;</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">v</span> <span class="p">=</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 检查v是否为2的幂。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 一个数是2的幂当且仅当它与其自身减1的位与结果为0。如果不是2的幂，则返回0。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nx">v</span><span class="o">&amp;</span><span class="p">(</span><span class="nx">v</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// v is not a power of 2
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">return</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 如果一切正常，将读取到的值转换为uintptr类型并返回。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">return</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">v</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="schedinitsb">schedinit(SB)<a hidden class="anchor" aria-hidden="true" href="#schedinitsb">#</a></h3>
<ol>
<li>初始化调度系统，加载过程：
<ol>
<li><strong><code>call osinit</code></strong>：调用<code>osinit()</code>函数，设置<code>runtime.ncpu</code>和<code>runtime.physHugePageSize</code>参数的值。</li>
<li><strong><code>call schedinit</code></strong>：调用<code>schedinit()</code>函数，初始化调度器。</li>
<li><strong><code>make &amp; queue new G</code></strong>：创建第一个<code>main goroutine</code>，并加入队列。</li>
<li><strong><code>call runtime·mstart</code></strong>：调用<code>runtime·mstart()</code>函数开启调度循环。</li>
</ol>
</li>
<li>这个新的<code>goroutine</code>运行<code>runtime.main()</code>函数。</li>
<li>文件位置：<code>go1.19.3/src/runtime/proc.go</code>。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">650
</span><span class="lnt">651
</span><span class="lnt">652
</span><span class="lnt">653
</span><span class="lnt">654
</span><span class="lnt">655
</span><span class="lnt">656
</span><span class="lnt">657
</span><span class="lnt">658
</span><span class="lnt">659
</span><span class="lnt">660
</span><span class="lnt">661
</span><span class="lnt">662
</span><span class="lnt">663
</span><span class="lnt">664
</span><span class="lnt">665
</span><span class="lnt">666
</span><span class="lnt">667
</span><span class="lnt">668
</span><span class="lnt">669
</span><span class="lnt">670
</span><span class="lnt">671
</span><span class="lnt">672
</span><span class="lnt">673
</span><span class="lnt">674
</span><span class="lnt">675
</span><span class="lnt">676
</span><span class="lnt">677
</span><span class="lnt">678
</span><span class="lnt">679
</span><span class="lnt">680
</span><span class="lnt">681
</span><span class="lnt">682
</span><span class="lnt">683
</span><span class="lnt">684
</span><span class="lnt">685
</span><span class="lnt">686
</span><span class="lnt">687
</span><span class="lnt">688
</span><span class="lnt">689
</span><span class="lnt">690
</span><span class="lnt">691
</span><span class="lnt">692
</span><span class="lnt">693
</span><span class="lnt">694
</span><span class="lnt">695
</span><span class="lnt">696
</span><span class="lnt">697
</span><span class="lnt">698
</span><span class="lnt">699
</span><span class="lnt">700
</span><span class="lnt">701
</span><span class="lnt">702
</span><span class="lnt">703
</span><span class="lnt">704
</span><span class="lnt">705
</span><span class="lnt">706
</span><span class="lnt">707
</span><span class="lnt">708
</span><span class="lnt">709
</span><span class="lnt">710
</span><span class="lnt">711
</span><span class="lnt">712
</span><span class="lnt">713
</span><span class="lnt">714
</span><span class="lnt">715
</span><span class="lnt">716
</span><span class="lnt">717
</span><span class="lnt">718
</span><span class="lnt">719
</span><span class="lnt">720
</span><span class="lnt">721
</span><span class="lnt">722
</span><span class="lnt">723
</span><span class="lnt">724
</span><span class="lnt">725
</span><span class="lnt">726
</span><span class="lnt">727
</span><span class="lnt">728
</span><span class="lnt">729
</span><span class="lnt">730
</span><span class="lnt">731
</span><span class="lnt">732
</span><span class="lnt">733
</span><span class="lnt">734
</span><span class="lnt">735
</span><span class="lnt">736
</span><span class="lnt">737
</span><span class="lnt">738
</span><span class="lnt">739
</span><span class="lnt">740
</span><span class="lnt">741
</span><span class="lnt">742
</span><span class="lnt">743
</span><span class="lnt">744
</span><span class="lnt">745
</span><span class="lnt">746
</span><span class="lnt">747
</span><span class="lnt">748
</span><span class="lnt">749
</span><span class="lnt">750
</span><span class="lnt">751
</span><span class="lnt">752
</span><span class="lnt">753
</span><span class="lnt">754
</span><span class="lnt">755
</span><span class="lnt">756
</span><span class="lnt">757
</span><span class="lnt">758
</span><span class="lnt">759
</span><span class="lnt">760
</span><span class="lnt">761
</span><span class="lnt">762
</span><span class="lnt">763
</span><span class="lnt">764
</span><span class="lnt">765
</span><span class="lnt">766
</span><span class="lnt">767
</span><span class="lnt">768
</span><span class="lnt">769
</span><span class="lnt">770
</span><span class="lnt">771
</span><span class="lnt">772
</span><span class="lnt">773
</span><span class="lnt">774
</span><span class="lnt">775
</span><span class="lnt">776
</span><span class="lnt">777
</span><span class="lnt">778
</span><span class="lnt">779
</span><span class="lnt">780
</span><span class="lnt">781
</span><span class="lnt">782
</span><span class="lnt">783
</span><span class="lnt">784
</span><span class="lnt">785
</span><span class="lnt">786
</span><span class="lnt">787
</span><span class="lnt">788
</span><span class="lnt">789
</span><span class="lnt">790
</span><span class="lnt">791
</span><span class="lnt">792
</span><span class="lnt">793
</span><span class="lnt">794
</span><span class="lnt">795
</span><span class="lnt">796
</span><span class="lnt">797
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// The bootstrap sequence is:
</span></span></span><span class="line"><span class="cl"><span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1">//	call osinit
</span></span></span><span class="line"><span class="cl"><span class="c1">//	call schedinit
</span></span></span><span class="line"><span class="cl"><span class="c1">//	make &amp; queue new G
</span></span></span><span class="line"><span class="cl"><span class="c1">//	call runtime·mstart
</span></span></span><span class="line"><span class="cl"><span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1">// The new G calls runtime·main.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">schedinit</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 初始化锁，如果有锁排名情况下
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">lockInit</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">,</span> <span class="nx">lockRankSched</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nf">lockInit</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">sysmonlock</span><span class="p">,</span> <span class="nx">lockRankSysmon</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nf">lockInit</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">deferlock</span><span class="p">,</span> <span class="nx">lockRankDefer</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nf">lockInit</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">sudoglock</span><span class="p">,</span> <span class="nx">lockRankSudog</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nf">lockInit</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">deadlock</span><span class="p">,</span> <span class="nx">lockRankDeadlock</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nf">lockInit</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">paniclk</span><span class="p">,</span> <span class="nx">lockRankPanic</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nf">lockInit</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">allglock</span><span class="p">,</span> <span class="nx">lockRankAllg</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nf">lockInit</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">allpLock</span><span class="p">,</span> <span class="nx">lockRankAllp</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nf">lockInit</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">reflectOffs</span><span class="p">.</span><span class="nx">lock</span><span class="p">,</span> <span class="nx">lockRankReflectOffs</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nf">lockInit</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">finlock</span><span class="p">,</span> <span class="nx">lockRankFin</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nf">lockInit</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">trace</span><span class="p">.</span><span class="nx">bufLock</span><span class="p">,</span> <span class="nx">lockRankTraceBuf</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nf">lockInit</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">trace</span><span class="p">.</span><span class="nx">stringsLock</span><span class="p">,</span> <span class="nx">lockRankTraceStrings</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nf">lockInit</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">trace</span><span class="p">.</span><span class="nx">lock</span><span class="p">,</span> <span class="nx">lockRankTrace</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nf">lockInit</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">cpuprof</span><span class="p">.</span><span class="nx">lock</span><span class="p">,</span> <span class="nx">lockRankCpuprof</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nf">lockInit</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">trace</span><span class="p">.</span><span class="nx">stackTab</span><span class="p">.</span><span class="nx">lock</span><span class="p">,</span> <span class="nx">lockRankTraceStackTab</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Enforce that this lock is always a leaf lock.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// All of this lock&#39;s critical sections should be
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// extremely short.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 强制这个锁始终是一个叶锁。所有锁的关键部分都应该非常短。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">lockInit</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">memstats</span><span class="p">.</span><span class="nx">heapStats</span><span class="p">.</span><span class="nx">noPLock</span><span class="p">,</span> <span class="nx">lockRankLeafRank</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// raceinit must be the first call to race detector.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// In particular, it must be done before mallocinit below calls racemapshadow.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// getg()函数在源代码中没有对应的定义，由编译器插入类似下面两行代码
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//  1. get_tls(CX) =&gt; MOVQ TLS, CX
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//  2. MOVQ g(CX), BX;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 起始就是从TLS中取出goroutine，此时应该是*g0。也就是&amp;m0.tls[0]里面存储的值*g0。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 前面代码可知，g0的地址被放入了TLS中，因此这里从TLS获取g0的地址
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">_g_</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">()</span>   <span class="c1">// _g_ = &amp;g0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nx">raceenabled</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">_g_</span><span class="p">.</span><span class="nx">racectx</span><span class="p">,</span> <span class="nx">raceprocctx0</span> <span class="p">=</span> <span class="nf">raceinit</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 设置最多启动10000个操作系统线程，也就是最多10000个M
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">sched</span><span class="p">.</span><span class="nx">maxmcount</span> <span class="p">=</span> <span class="mi">10000</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// The world starts stopped.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 在没有锁排名下，该函数为空。因为此时就只有m0一个线程。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 在有锁排名下，该函数把worldIsStopped全局变量设置为1，就返回了。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">worldStopped</span><span class="p">()</span>  <span class="c1">// STW
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 校验程序的各个模块，因为golang支持shared、plugin等build模式，可能会有很多个二进制模块
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 这里会校验各个模块的符号、ABI等，确保模块间一致。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">moduledataverify</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 栈内存初始化，stackpool 和 stackLarge 初始化
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// goroutine的栈是动态分配、动态增长的，这一步会初始化用于栈分配的全局缓存池，以及相关的锁。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">stackinit</span><span class="p">()</span> <span class="c1">// 栈内存初始化
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 堆内存初始化，包括初始化mheap、mcache0以及设置堆的arenaHint
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">mallocinit</span><span class="p">()</span>	
</span></span><span class="line"><span class="cl">    <span class="c1">// 进行与CPU相关的初始化工作，检测CPU是否支持某些指令集，以及根据GODEBUG环境变量来启用或禁用某些硬件特性
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">cpuinit</span><span class="p">()</span>   <span class="c1">// must run before alginit
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 根据CPU对AES相关指令的支持情况，选择不同得Hash算法，所以必须在 cpuinit() 后面调用
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// map、hash必须在 alginit() 函数调用后才可以使用
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">alginit</span><span class="p">()</span>   <span class="c1">// maps, hash, fastrand must not be used before this call
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 初始化 fastrandseed，在接下来的mcommoninit()函数中被用到
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">fastrandinit</span><span class="p">()</span> <span class="c1">// must run before mcommoninit
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 初始化m0，因为从前的代码我们知道 g0-&gt;m=&amp;m0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 为当前工作线程M分配ID、初始化gsignal，并把M添加到allm全局链表中
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 该函数在新创建工作线程时也会调用。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">mcommoninit</span><span class="p">(</span><span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="c1">// m0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 基于所有的已加载模块，构造一个活跃模块切片 modulesSlice，并初始化GC需要的Mask数据
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">modulesinit</span><span class="p">()</span>   <span class="c1">// provides activeModules
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// Typelinksinit扫描来自额外模块的类型，并构建moduledata类型映射，用于消除重复类型指针。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 基于活跃模块列表构建模块级的typemap，实现全局范围内对类型元数据去重。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">typelinksinit</span><span class="p">()</span> <span class="c1">// uses maps, activeModules
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 遍历活跃模块列表，将编译器阶段生成的所有itab添加到itabTable中
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 该函数会调用itabAdd()函数，接口的时候知道该函数会生成*itab
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">itabsinit</span><span class="p">()</span>     <span class="c1">// uses activeModules
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">stkobjinit</span><span class="p">()</span>    <span class="c1">// must run before GC starts
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="nf">sigsave</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">sigmask</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nx">initSigmask</span> <span class="p">=</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">sigmask</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 解析命令行参数，程序中通过os.Args得到的参数是在这里初始化的（Windows除外）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 存入 argslice []string 变量中
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">goargs</span><span class="p">()</span> 
</span></span><span class="line"><span class="cl">    <span class="c1">// 解析环境变量，程序中通过os.Getenv获取的环境变量是在这里初始化的（Windows除外）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 存入 envs []string 变量中
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">goenvs</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 解析环境变量GODEBUG，为runtime各个调试参数赋值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">parsedebugvars</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 初始化与GC相关的参数，根据环境变量GOGC设置gcpercent
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">gcinit</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span> <span class="c1">// 获取 mutex 解锁
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 上次网络轮询的时间点，设置为当前时间点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">sched</span><span class="p">.</span><span class="nx">lastpoll</span> <span class="p">=</span> <span class="nb">uint64</span><span class="p">(</span><span class="nf">nanotime</span><span class="p">())</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 系统中有多少核，就创建和初始化多少个P结构体对象
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">procs</span> <span class="o">:=</span> <span class="nx">ncpu</span>	<span class="c1">// ncpu该值在runtime.osinit函数中被设置
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 如果环境变量指定了GOMAXPROCS，则创建指定数量的p
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nx">n</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nf">atoi32</span><span class="p">(</span><span class="nf">gogetenv</span><span class="p">(</span><span class="s">&#34;GOMAXPROCS&#34;</span><span class="p">));</span> <span class="nx">ok</span> <span class="o">&amp;&amp;</span> <span class="nx">n</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">procs</span> <span class="p">=</span> <span class="nx">n</span>	
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// procresize 创建和初始化全局变量allp
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 根据 CPU 的核数或环境变量GOMAXPROC确定P的数量，调用procresize进行调整
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// procresize 返回nil表示所有的P中本地队列都没有可运行的goroutine。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nf">procresize</span><span class="p">(</span><span class="nx">procs</span><span class="p">)</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">throw</span><span class="p">(</span><span class="s">&#34;unknown runnable goroutine during bootstrap&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span> <span class="c1">// mutex 解锁
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="c1">// World is effectively started now, as P&#39;s can run.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">worldStarted</span><span class="p">()</span> <span class="c1">// Start World
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="c1">// For cgocheck &gt; 1, we turn on the write barrier at all times
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// and check all pointer writes. We can&#39;t do this until after
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// procresize because the write barrier needs a P.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 对于cgocheck &gt; 1，我们在任何时候都打开写屏障并检查所有的指针写。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 我们不能这样做，直到procresize之后，因为写屏障需要一个P。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nx">debug</span><span class="p">.</span><span class="nx">cgocheck</span> <span class="p">&gt;</span> <span class="mi">1</span> <span class="p">{</span> <span class="c1">// debug.cgocheck在parsedebugvars()函数中被设置为1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 开启写屏障
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">writeBarrier</span><span class="p">.</span><span class="nx">cgo</span> <span class="p">=</span> <span class="kc">true</span>
</span></span><span class="line"><span class="cl">        <span class="nx">writeBarrier</span><span class="p">.</span><span class="nx">enabled</span> <span class="p">=</span> <span class="kc">true</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 初始化所有P上的写屏障缓存区
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">p</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">allp</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nx">p</span><span class="p">.</span><span class="nx">wbBuf</span><span class="p">.</span><span class="nf">reset</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 未知编译版本时
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nx">buildVersion</span> <span class="o">==</span> <span class="s">&#34;&#34;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// Condition should never trigger. This code just serves
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// to ensure runtime·buildVersion is kept in the resulting binary.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 条件应该永远不会触发。这段代码只是用于确保runtime·buildVersion保存在结果二进制文件中。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">buildVersion</span> <span class="p">=</span> <span class="s">&#34;unknown&#34;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">modinfo</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// Condition should never trigger. This code just serves
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// to ensure runtime·modinfo is kept in the resulting binary.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 条件应该永远不会触发。这段代码只是用于确保runtime·modinfo保存在结果二进制文件中。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">modinfo</span> <span class="p">=</span> <span class="s">&#34;&#34;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="mcommoninit">mcommoninit()<a hidden class="anchor" aria-hidden="true" href="#mcommoninit">#</a></h4>
<ol>
<li><code>getg()</code>获取出来的是<code>g0</code>，然后调用<code>mcommoninit</code>函数对<code>m0(g0.m)</code>进行必要的初始化。</li>
<li>预分配的<code>ID</code>可以作为<code>'id'</code>传递，也可以通过传递 -1 来省略，系统默认分配。</li>
<li>该函数在<strong>新创建工作线程</strong>时也会被调用，因此可能会出现竞争。</li>
<li>总结：该方法主要为工作线程分配（指定一个唯一<code>id</code>），并初始化<code>m</code>的相关参数，把<code>m</code>加入到全局<code>allm</code>中。</li>
<li>文件位置：<code>go1.19.3/src/runtime/proc.go</code>。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">785
</span><span class="lnt">786
</span><span class="lnt">787
</span><span class="lnt">788
</span><span class="lnt">789
</span><span class="lnt">790
</span><span class="lnt">791
</span><span class="lnt">792
</span><span class="lnt">793
</span><span class="lnt">794
</span><span class="lnt">795
</span><span class="lnt">796
</span><span class="lnt">797
</span><span class="lnt">798
</span><span class="lnt">799
</span><span class="lnt">800
</span><span class="lnt">801
</span><span class="lnt">802
</span><span class="lnt">803
</span><span class="lnt">804
</span><span class="lnt">805
</span><span class="lnt">806
</span><span class="lnt">807
</span><span class="lnt">808
</span><span class="lnt">809
</span><span class="lnt">810
</span><span class="lnt">811
</span><span class="lnt">812
</span><span class="lnt">813
</span><span class="lnt">814
</span><span class="lnt">815
</span><span class="lnt">816
</span><span class="lnt">817
</span><span class="lnt">818
</span><span class="lnt">819
</span><span class="lnt">820
</span><span class="lnt">821
</span><span class="lnt">822
</span><span class="lnt">823
</span><span class="lnt">824
</span><span class="lnt">825
</span><span class="lnt">826
</span><span class="lnt">827
</span><span class="lnt">828
</span><span class="lnt">829
</span><span class="lnt">830
</span><span class="lnt">831
</span><span class="lnt">832
</span><span class="lnt">833
</span><span class="lnt">834
</span><span class="lnt">835
</span><span class="lnt">836
</span><span class="lnt">837
</span><span class="lnt">838
</span><span class="lnt">839
</span><span class="lnt">840
</span><span class="lnt">841
</span><span class="lnt">842
</span><span class="lnt">843
</span><span class="lnt">844
</span><span class="lnt">845
</span><span class="lnt">846
</span><span class="lnt">847
</span><span class="lnt">848
</span><span class="lnt">849
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// Pre-allocated ID may be passed as &#39;id&#39;, or omitted by passing -1.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">mcommoninit</span><span class="p">(</span><span class="nx">mp</span> <span class="o">*</span><span class="nx">m</span><span class="p">,</span> <span class="nx">id</span> <span class="kt">int64</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">_g_</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">()</span> <span class="c1">// &amp;g0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="c1">// g0 stack won&#39;t make sense for user (and is not necessary unwindable).
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// g0堆栈对用户来说没有意义(并且不一定是可撤销的)。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nx">_g_</span> <span class="o">!=</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">g0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">callers</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nx">mp</span><span class="p">.</span><span class="nx">createstack</span><span class="p">[:])</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 获取 mutex 锁
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">id</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">mp</span><span class="p">.</span><span class="nx">id</span> <span class="p">=</span> <span class="nx">id</span> <span class="c1">// 使用传递来的id
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">mp</span><span class="p">.</span><span class="nx">id</span> <span class="p">=</span> <span class="nf">mReserveID</span><span class="p">()</span> <span class="c1">// 系统分配
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 根据mp.id和fastrandseed生成随机hash
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">lo</span> <span class="o">:=</span> <span class="nb">uint32</span><span class="p">(</span><span class="nf">int64Hash</span><span class="p">(</span><span class="nb">uint64</span><span class="p">(</span><span class="nx">mp</span><span class="p">.</span><span class="nx">id</span><span class="p">),</span> <span class="nx">fastrandseed</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 根据cputicks()和^fastrandseed生成随机hash。cputicks()是当前CPU时间
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">hi</span> <span class="o">:=</span> <span class="nb">uint32</span><span class="p">(</span><span class="nf">int64Hash</span><span class="p">(</span><span class="nb">uint64</span><span class="p">(</span><span class="nf">cputicks</span><span class="p">()),</span> <span class="p">^</span><span class="nx">fastrandseed</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 如果 lo 和 hi 刚好互补时
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nx">lo</span><span class="p">|</span><span class="nx">hi</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">hi</span> <span class="p">=</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Same behavior as for 1.17.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// TODO: Simplify ths.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 下面通过 uint32 的 lo 和 hi 组成一个(hi&lt;&lt;32 + lo)的uint64随机值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 因为内存存储的原因所以有以下判断，以及数据的操作不一样
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nx">goarch</span><span class="p">.</span><span class="nx">BigEndian</span> <span class="p">{</span> 
</span></span><span class="line"><span class="cl">        <span class="c1">// 数据存储是大端存储时
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">mp</span><span class="p">.</span><span class="nx">fastrand</span> <span class="p">=</span> <span class="nb">uint64</span><span class="p">(</span><span class="nx">lo</span><span class="p">)</span><span class="o">&lt;&lt;</span><span class="mi">32</span> <span class="p">|</span> <span class="nb">uint64</span><span class="p">(</span><span class="nx">hi</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 数据存储是小端存储时
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// linux x86走这里。fastrand表示M的随机值。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">mp</span><span class="p">.</span><span class="nx">fastrand</span> <span class="p">=</span> <span class="nb">uint64</span><span class="p">(</span><span class="nx">hi</span><span class="p">)</span><span class="o">&lt;&lt;</span><span class="mi">32</span> <span class="p">|</span> <span class="nb">uint64</span><span class="p">(</span><span class="nx">lo</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 创建信号处理的gsignal。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 分配一个32KB大小的栈，然后 mp.gsignal.m = mp
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">mpreinit</span><span class="p">(</span><span class="nx">mp</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">mp</span><span class="p">.</span><span class="nx">gsignal</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 设置 mp.gsignal.stackguard1 = 0 + _StackGuard
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">mp</span><span class="p">.</span><span class="nx">gsignal</span><span class="p">.</span><span class="nx">stackguard1</span> <span class="p">=</span> <span class="nx">mp</span><span class="p">.</span><span class="nx">gsignal</span><span class="p">.</span><span class="nx">stack</span><span class="p">.</span><span class="nx">lo</span> <span class="o">+</span> <span class="nx">_StackGuard</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// Add to allm so garbage collector doesn&#39;t free g-&gt;m
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// when it is just in a register or thread-local storage.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">mp</span><span class="p">.</span><span class="nx">alllink</span> <span class="p">=</span> <span class="nx">allm</span> <span class="c1">// mp.alllink 与 allm 绑定
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="c1">// NumCgoCall() iterates over allm w/o schedlock,
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// so we need to publish it safely.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">atomicstorep</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">allm</span><span class="p">),</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">mp</span><span class="p">))</span> <span class="c1">// atomically allm = mp
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span> <span class="c1">// mutex 解锁
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Allocate memory to hold a cgo traceback if the cgo call crashes.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 如果cgo调用崩溃，分配内存保存cgo回溯。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nx">iscgo</span> <span class="o">||</span> <span class="nx">GOOS</span> <span class="o">==</span> <span class="s">&#34;solaris&#34;</span> <span class="o">||</span> <span class="nx">GOOS</span> <span class="o">==</span> <span class="s">&#34;illumos&#34;</span> <span class="o">||</span> <span class="nx">GOOS</span> <span class="o">==</span> <span class="s">&#34;windows&#34;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">mp</span><span class="p">.</span><span class="nx">cgoCallers</span> <span class="p">=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">cgoCallers</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div>

<p><details >
  <summary markdown="span">mReserveID()</summary>
  <blockquote>
<ol>
<li>向系统申请<code>ID</code>。就是递增的值。</li>
<li>文件位置：<code>go1.19.3/src/runtime/proc.go</code>。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">769
</span><span class="lnt">770
</span><span class="lnt">771
</span><span class="lnt">772
</span><span class="lnt">773
</span><span class="lnt">774
</span><span class="lnt">775
</span><span class="lnt">776
</span><span class="lnt">777
</span><span class="lnt">778
</span><span class="lnt">779
</span><span class="lnt">780
</span><span class="lnt">781
</span><span class="lnt">782
</span><span class="lnt">783
</span><span class="lnt">784
</span><span class="lnt">785
</span><span class="lnt">786
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// mReserveID returns the next ID to use for a new m. This new m is immediately
</span></span></span><span class="line"><span class="cl"><span class="c1">// considered &#39;running&#39; by checkdead.
</span></span></span><span class="line"><span class="cl"><span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1">// sched.lock must be held.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">mReserveID</span><span class="p">()</span> <span class="kt">int64</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 调用该方法时 sched.lock 锁必须已被持有
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">assertLockHeld</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// mnext 值已经溢出
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nx">sched</span><span class="p">.</span><span class="nx">mnext</span><span class="o">+</span><span class="mi">1</span> <span class="p">&lt;</span> <span class="nx">sched</span><span class="p">.</span><span class="nx">mnext</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">throw</span><span class="p">(</span><span class="s">&#34;runtime: thread ID overflow&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nx">id</span> <span class="o">:=</span> <span class="nx">sched</span><span class="p">.</span><span class="nx">mnext</span> <span class="c1">// 分配该值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">sched</span><span class="p">.</span><span class="nx">mnext</span><span class="o">++</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 检查是否超出设置的最大值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">checkmcount</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nx">id</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">759
</span><span class="lnt">760
</span><span class="lnt">761
</span><span class="lnt">762
</span><span class="lnt">763
</span><span class="lnt">764
</span><span class="lnt">765
</span><span class="lnt">766
</span><span class="lnt">767
</span><span class="lnt">768
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// sched.lock must be held.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">checkmcount</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nf">assertLockHeld</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// sched.maxmcount 最大值默认被设置为 10000
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nf">mcount</span><span class="p">()</span> <span class="p">&gt;</span> <span class="nx">sched</span><span class="p">.</span><span class="nx">maxmcount</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nb">print</span><span class="p">(</span><span class="s">&#34;runtime: program exceeds &#34;</span><span class="p">,</span> <span class="nx">sched</span><span class="p">.</span><span class="nx">maxmcount</span><span class="p">,</span> <span class="s">&#34;-thread limit\n&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="nf">throw</span><span class="p">(</span><span class="s">&#34;thread exhaustion&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">4490
</span><span class="lnt">4491
</span><span class="lnt">4492
</span><span class="lnt">4493
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">mcount</span><span class="p">()</span> <span class="kt">int32</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// sched.nmfreed 已释放的工作线程数量
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">return</span> <span class="nb">int32</span><span class="p">(</span><span class="nx">sched</span><span class="p">.</span><span class="nx">mnext</span> <span class="o">-</span> <span class="nx">sched</span><span class="p">.</span><span class="nx">nmfreed</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div></blockquote>

</details></p>



<p><details >
  <summary markdown="span">mpreinit()</summary>
  <blockquote>
<ol>
<li>mpreinit 为gsignal分配32KB栈，并绑定当前M。</li>
<li>文件位置：<code>go1.19.3/src/runtime/os_linux.go</code>。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">381
</span><span class="lnt">382
</span><span class="lnt">383
</span><span class="lnt">384
</span><span class="lnt">385
</span><span class="lnt">386
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// Called to initialize a new m (including the bootstrap m).
</span></span></span><span class="line"><span class="cl"><span class="c1">// Called on the parent thread (main thread in case of bootstrap), can allocate memory.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">mpreinit</span><span class="p">(</span><span class="nx">mp</span> <span class="o">*</span><span class="nx">m</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">mp</span><span class="p">.</span><span class="nx">gsignal</span> <span class="p">=</span> <span class="nf">malg</span><span class="p">(</span><span class="mi">32</span> <span class="o">*</span> <span class="mi">1024</span><span class="p">)</span> <span class="c1">// Linux wants &gt;= 2K
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">mp</span><span class="p">.</span><span class="nx">gsignal</span><span class="p">.</span><span class="nx">m</span> <span class="p">=</span> <span class="nx">mp</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div></blockquote>

</details></p>



<p><details >
  <summary markdown="span">atomicstorep()</summary>
  <blockquote>
<ol>
<li>atomicstorep 原子地执行 <code>*ptr = new</code>，并调用一个写屏障。</li>
<li>文件位置：<code>go1.19.3/src/runtime/atomic_pointer.go</code>。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// atomicstorep performs *ptr = new atomically and invokes a write barrier.
</span></span></span><span class="line"><span class="cl"><span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1">//go:nosplit
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">atomicstorep</span><span class="p">(</span><span class="nx">ptr</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">,</span> <span class="nx">new</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 如果开启了写屏障
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nx">writeBarrier</span><span class="p">.</span><span class="nx">enabled</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">atomicwb</span><span class="p">((</span><span class="o">*</span><span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">)(</span><span class="nx">ptr</span><span class="p">),</span> <span class="nx">new</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nx">atomic</span><span class="p">.</span><span class="nf">StorepNoWB</span><span class="p">(</span><span class="nf">noescape</span><span class="p">(</span><span class="nx">ptr</span><span class="p">),</span> <span class="nx">new</span><span class="p">)</span> <span class="c1">// *ptr = new
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div></blockquote>

</details></p>

<ol start="6">
<li>此时，主线程，m0，g0以及g0的栈之间的关系如下图所示：</li>
</ol>
<p><img loading="lazy" src="../images/goroutine-007.png" alt=""  />
</p>
<h4 id="goargs">goargs()<a hidden class="anchor" aria-hidden="true" href="#goargs">#</a></h4>
<ol>
<li>保存<code>argv</code>参数到<code>argslice</code>中。</li>
<li>文件位置：<code>go1.19.3/src/runtime/runtime1.go</code>。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span><span class="lnt">77
</span><span class="lnt">78
</span><span class="lnt">79
</span><span class="lnt">80
</span><span class="lnt">81
</span><span class="lnt">82
</span><span class="lnt">83
</span><span class="lnt">84
</span><span class="lnt">85
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">goargs</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">GOOS</span> <span class="o">==</span> <span class="s">&#34;windows&#34;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 申请参数需要的内存大小
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">argslice</span> <span class="p">=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">string</span><span class="p">,</span> <span class="nx">argc</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="nb">int32</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">argc</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// argv_index 在7.1.2中列出，就是偏移i个字节
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">argslice</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nf">gostringnocopy</span><span class="p">(</span><span class="nf">argv_index</span><span class="p">(</span><span class="nx">argv</span><span class="p">,</span> <span class="nx">i</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">envs</span> <span class="p">[]</span><span class="kt">string</span>
</span></span><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">argslice</span> <span class="p">[]</span><span class="kt">string</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ol start="3">
<li><code>gostringnocopy</code>组装成一个字符串。</li>
<li>文件位置：<code>go1.19.3/src/runtime/string.go</code>。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">564
</span><span class="lnt">565
</span><span class="lnt">566
</span><span class="lnt">567
</span><span class="lnt">568
</span><span class="lnt">569
</span><span class="lnt">570
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">//go:nosplit
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">gostringnocopy</span><span class="p">(</span><span class="nx">str</span> <span class="o">*</span><span class="kt">byte</span><span class="p">)</span> <span class="kt">string</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// findnull寻找到null结束识别字符串长度
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">ss</span> <span class="o">:=</span> <span class="nx">stringStruct</span><span class="p">{</span><span class="nx">str</span><span class="p">:</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">str</span><span class="p">),</span> <span class="nx">len</span><span class="p">:</span> <span class="nf">findnull</span><span class="p">(</span><span class="nx">str</span><span class="p">)}</span>
</span></span><span class="line"><span class="cl">    <span class="nx">s</span> <span class="o">:=</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="kt">string</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">ss</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nx">s</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="goenvs">goenvs()<a hidden class="anchor" aria-hidden="true" href="#goenvs">#</a></h4>
<ol>
<li>解析环境变量。</li>
<li>文件位置：<code>go1.19.3/src/runtime/os_linux.go</code>。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">367
</span><span class="lnt">368
</span><span class="lnt">369
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">goenvs</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nf">goenvs_unix</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ol start="3">
<li>文件位置：<code>go1.19.3/src/runtime/runtime1.go</code>。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">367
</span><span class="lnt">368
</span><span class="lnt">369
</span><span class="lnt">370
</span><span class="lnt">371
</span><span class="lnt">372
</span><span class="lnt">373
</span><span class="lnt">374
</span><span class="lnt">375
</span><span class="lnt">376
</span><span class="lnt">377
</span><span class="lnt">378
</span><span class="lnt">379
</span><span class="lnt">380
</span><span class="lnt">381
</span><span class="lnt">382
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">goenvs_unix</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// TODO(austin): ppc64 in dynamic linking mode doesn&#39;t
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// guarantee env[] will immediately follow argv. Might cause
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// problems.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">n</span> <span class="o">:=</span> <span class="nb">int32</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 跳过argv + NULL，到envp，计算envp的长度。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// argv_index 参考7.1.2
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">for</span> <span class="nf">argv_index</span><span class="p">(</span><span class="nx">argv</span><span class="p">,</span> <span class="nx">argc</span><span class="o">+</span><span class="mi">1</span><span class="o">+</span><span class="nx">n</span><span class="p">)</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">n</span><span class="o">++</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nx">envs</span> <span class="p">=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">string</span><span class="p">,</span> <span class="nx">n</span><span class="p">)</span> <span class="c1">// 申请n长度的内存
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="nb">int32</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">n</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">envs</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nf">gostring</span><span class="p">(</span><span class="nf">argv_index</span><span class="p">(</span><span class="nx">argv</span><span class="p">,</span> <span class="nx">argc</span><span class="o">+</span><span class="mi">1</span><span class="o">+</span><span class="nx">i</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ol start="4">
<li>文件位置：<code>go1.19.3/src/runtime/string.go</code>。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">327
</span><span class="lnt">328
</span><span class="lnt">329
</span><span class="lnt">330
</span><span class="lnt">331
</span><span class="lnt">332
</span><span class="lnt">333
</span><span class="lnt">334
</span><span class="lnt">335
</span><span class="lnt">336
</span><span class="lnt">337
</span><span class="lnt">338
</span><span class="lnt">339
</span><span class="lnt">340
</span><span class="lnt">341
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// This is exported via linkname to assembly in syscall (for Plan9).
</span></span></span><span class="line"><span class="cl"><span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1">//go:linkname gostring
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">gostring</span><span class="p">(</span><span class="nx">p</span> <span class="o">*</span><span class="kt">byte</span><span class="p">)</span> <span class="kt">string</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">l</span> <span class="o">:=</span> <span class="nf">findnull</span><span class="p">(</span><span class="nx">p</span><span class="p">)</span> <span class="c1">// 找出字符串长度
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nx">l</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="s">&#34;&#34;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// rawstring 函数在字符串包中已经介绍过
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 分会的s和b分别共用一个底层，这样操作b切片s也会跟着改变
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">s</span><span class="p">,</span> <span class="nx">b</span> <span class="o">:=</span> <span class="nf">rawstring</span><span class="p">(</span><span class="nx">l</span><span class="p">)</span> <span class="c1">// s string, b []byte
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 拷贝数据到b中从p拷贝长度l字节。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">memmove</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">b</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">p</span><span class="p">),</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">l</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nx">s</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="初始化allp">初始化allp<a hidden class="anchor" aria-hidden="true" href="#初始化allp">#</a></h3>
<ol>
<li>下面分析<code>procresize()</code>函数。
<ul>
<li>考虑到初始化完成之后用户代码还可以通过<code>GOMAXPROCS()</code>函数调用它重新创建和初始化<code>p</code>结构体对象。</li>
<li>而在运行过程中再动态的调整p牵涉到的问题比较多，所以这个函数的处理比较复杂。</li>
</ul>
</li>
</ol>
<h4 id="procresize">procresize()<a hidden class="anchor" aria-hidden="true" href="#procresize">#</a></h4>
<ol>
<li>更改处理器数量。<code>sched.lock</code>必须被持有并且必须是在<code>STW</code>期间。</li>
<li><code>gcworkbufs</code>不能被<code>GC</code>或写屏障代码修改，因此如果<code>P</code>数实际发生变化，<code>GC</code>必须不运行。</li>
<li>返回具有本地工作的<code>p</code>列表，它们需要由调用者调度。</li>
<li>该函数会在【程序初始化】或【<code>startTheWorldWithSema</code>】函数中被调用。</li>
<li>函数流程：
<ol>
<li>使用<code>make([]*p, nprocs)</code>初始化全局变量<code>allp</code>，即<code>allp = make([]*p, nprocs)</code>。</li>
<li>循环创建并初始化<code>nprocs</code>个<code>p</code>结构体对象并依次保存在<code>allp</code>切片之中。</li>
<li>把<code>m0</code>和<code>allp[0]</code>绑定在一起，即【<code>m0.p = allp[0]</code>, <code>allp[0].m = m0</code>】。</li>
<li>把除了<code>allp[0]</code>之外的所有<code>p</code>放入到全局变量<code>sched</code>的<code>pidle</code>空闲队列之中。</li>
</ol>
</li>
<li>文件位置：<code>go1.19.3/src/runtime/proc.go</code>。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">4793
</span><span class="lnt">4794
</span><span class="lnt">4795
</span><span class="lnt">4796
</span><span class="lnt">4797
</span><span class="lnt">4798
</span><span class="lnt">4799
</span><span class="lnt">4800
</span><span class="lnt">4801
</span><span class="lnt">4802
</span><span class="lnt">4803
</span><span class="lnt">4804
</span><span class="lnt">4805
</span><span class="lnt">4806
</span><span class="lnt">4807
</span><span class="lnt">4808
</span><span class="lnt">4809
</span><span class="lnt">4810
</span><span class="lnt">4811
</span><span class="lnt">4812
</span><span class="lnt">4813
</span><span class="lnt">4814
</span><span class="lnt">4815
</span><span class="lnt">4816
</span><span class="lnt">4817
</span><span class="lnt">4818
</span><span class="lnt">4819
</span><span class="lnt">4820
</span><span class="lnt">4821
</span><span class="lnt">4822
</span><span class="lnt">4823
</span><span class="lnt">4824
</span><span class="lnt">4825
</span><span class="lnt">4826
</span><span class="lnt">4827
</span><span class="lnt">4828
</span><span class="lnt">4829
</span><span class="lnt">4830
</span><span class="lnt">4831
</span><span class="lnt">4832
</span><span class="lnt">4833
</span><span class="lnt">4834
</span><span class="lnt">4835
</span><span class="lnt">4836
</span><span class="lnt">4837
</span><span class="lnt">4838
</span><span class="lnt">4839
</span><span class="lnt">4840
</span><span class="lnt">4841
</span><span class="lnt">4842
</span><span class="lnt">4843
</span><span class="lnt">4844
</span><span class="lnt">4845
</span><span class="lnt">4846
</span><span class="lnt">4847
</span><span class="lnt">4848
</span><span class="lnt">4849
</span><span class="lnt">4850
</span><span class="lnt">4851
</span><span class="lnt">4852
</span><span class="lnt">4853
</span><span class="lnt">4854
</span><span class="lnt">4855
</span><span class="lnt">4856
</span><span class="lnt">4857
</span><span class="lnt">4858
</span><span class="lnt">4859
</span><span class="lnt">4860
</span><span class="lnt">4861
</span><span class="lnt">4862
</span><span class="lnt">4863
</span><span class="lnt">4864
</span><span class="lnt">4865
</span><span class="lnt">4866
</span><span class="lnt">4867
</span><span class="lnt">4868
</span><span class="lnt">4869
</span><span class="lnt">4870
</span><span class="lnt">4871
</span><span class="lnt">4872
</span><span class="lnt">4873
</span><span class="lnt">4874
</span><span class="lnt">4875
</span><span class="lnt">4876
</span><span class="lnt">4877
</span><span class="lnt">4878
</span><span class="lnt">4879
</span><span class="lnt">4880
</span><span class="lnt">4881
</span><span class="lnt">4882
</span><span class="lnt">4883
</span><span class="lnt">4884
</span><span class="lnt">4885
</span><span class="lnt">4886
</span><span class="lnt">4887
</span><span class="lnt">4888
</span><span class="lnt">4889
</span><span class="lnt">4890
</span><span class="lnt">4891
</span><span class="lnt">4892
</span><span class="lnt">4893
</span><span class="lnt">4894
</span><span class="lnt">4895
</span><span class="lnt">4896
</span><span class="lnt">4897
</span><span class="lnt">4898
</span><span class="lnt">4899
</span><span class="lnt">4900
</span><span class="lnt">4901
</span><span class="lnt">4902
</span><span class="lnt">4903
</span><span class="lnt">4904
</span><span class="lnt">4905
</span><span class="lnt">4906
</span><span class="lnt">4907
</span><span class="lnt">4908
</span><span class="lnt">4909
</span><span class="lnt">4910
</span><span class="lnt">4911
</span><span class="lnt">4912
</span><span class="lnt">4913
</span><span class="lnt">4914
</span><span class="lnt">4915
</span><span class="lnt">4916
</span><span class="lnt">4917
</span><span class="lnt">4918
</span><span class="lnt">4919
</span><span class="lnt">4920
</span><span class="lnt">4921
</span><span class="lnt">4922
</span><span class="lnt">4923
</span><span class="lnt">4924
</span><span class="lnt">4925
</span><span class="lnt">4926
</span><span class="lnt">4927
</span><span class="lnt">4928
</span><span class="lnt">4929
</span><span class="lnt">4930
</span><span class="lnt">4931
</span><span class="lnt">4932
</span><span class="lnt">4933
</span><span class="lnt">4934
</span><span class="lnt">4935
</span><span class="lnt">4936
</span><span class="lnt">4937
</span><span class="lnt">4938
</span><span class="lnt">4939
</span><span class="lnt">4940
</span><span class="lnt">4941
</span><span class="lnt">4942
</span><span class="lnt">4943
</span><span class="lnt">4944
</span><span class="lnt">4945
</span><span class="lnt">4946
</span><span class="lnt">4947
</span><span class="lnt">4948
</span><span class="lnt">4949
</span><span class="lnt">4950
</span><span class="lnt">4951
</span><span class="lnt">4952
</span><span class="lnt">4953
</span><span class="lnt">4954
</span><span class="lnt">4955
</span><span class="lnt">4956
</span><span class="lnt">4957
</span><span class="lnt">4958
</span><span class="lnt">4959
</span><span class="lnt">4960
</span><span class="lnt">4961
</span><span class="lnt">4962
</span><span class="lnt">4963
</span><span class="lnt">4964
</span><span class="lnt">4965
</span><span class="lnt">4966
</span><span class="lnt">4967
</span><span class="lnt">4968
</span><span class="lnt">4969
</span><span class="lnt">4970
</span><span class="lnt">4971
</span><span class="lnt">4972
</span><span class="lnt">4973
</span><span class="lnt">4974
</span><span class="lnt">4975
</span><span class="lnt">4976
</span><span class="lnt">4977
</span><span class="lnt">4978
</span><span class="lnt">4979
</span><span class="lnt">4980
</span><span class="lnt">4981
</span><span class="lnt">4982
</span><span class="lnt">4983
</span><span class="lnt">4984
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// Change number of processors.
</span></span></span><span class="line"><span class="cl"><span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1">// sched.lock must be held, and the world must be stopped.
</span></span></span><span class="line"><span class="cl"><span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1">// gcworkbufs must not be being modified by either the GC or the write barrier
</span></span></span><span class="line"><span class="cl"><span class="c1">// code, so the GC must not be running if the number of Ps actually changes.
</span></span></span><span class="line"><span class="cl"><span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1">// Returns list of Ps with local work, they need to be scheduled by the caller.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">procresize</span><span class="p">(</span><span class="nx">nprocs</span> <span class="kt">int32</span><span class="p">)</span> <span class="o">*</span><span class="nx">p</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// sched.lock 锁已经被持有
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">assertLockHeld</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 必须是 STW 期间
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">assertWorldStopped</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 系统初始化时，gomaxprocs = 0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">old</span> <span class="o">:=</span> <span class="nx">gomaxprocs</span> <span class="c1">// 旧的数量，也就是上次的数量
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// nprocs 服务器cpu核数，或用户通过GOMAXPROCS环境变量指定的数量
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nx">old</span> <span class="p">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="nx">nprocs</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">throw</span><span class="p">(</span><span class="s">&#34;procresize: invalid arg&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">trace</span><span class="p">.</span><span class="nx">enabled</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">traceGomaxprocs</span><span class="p">(</span><span class="nx">nprocs</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// update statistics
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">now</span> <span class="o">:=</span> <span class="nf">nanotime</span><span class="p">()</span> <span class="c1">// 当前时间
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// sched.procresizetime 最后一次改变gomaxprocs的时间
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nx">sched</span><span class="p">.</span><span class="nx">procresizetime</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 从备注中看出该值是procresizetime变化的积分，因该用于统计相关
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// ∫gomaxprocs dt up to procresizetime
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">sched</span><span class="p">.</span><span class="nx">totaltime</span> <span class="o">+=</span> <span class="nb">int64</span><span class="p">(</span><span class="nx">old</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="nx">now</span> <span class="o">-</span> <span class="nx">sched</span><span class="p">.</span><span class="nx">procresizetime</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nx">sched</span><span class="p">.</span><span class="nx">procresizetime</span> <span class="p">=</span> <span class="nx">now</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 以32为一组，分别处理P的标志位
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// idlepMask：表示在_Pidle列表中的位掩码，每一个P表示一位，记录那些P处理_Pidle（空闲）状态
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// timerpMask：表示P在timer上的位掩码，每一个P表示一位，记录P与timer相关（1表示有timer，0表示没有timer）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// idlepMask和timerpMask用于快速判断P的状态和P上是否有timer。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">maskWords</span> <span class="o">:=</span> <span class="p">(</span><span class="nx">nprocs</span> <span class="o">+</span> <span class="mi">31</span><span class="p">)</span> <span class="o">/</span> <span class="mi">32</span> <span class="c1">// int32
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Grow allp if necessary.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 如果有必要扩展allp。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nx">nprocs</span> <span class="p">&gt;</span> <span class="nb">int32</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">allp</span><span class="p">))</span> <span class="p">{</span> <span class="c1">// 初始化时 或 P的数量扩大时
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// Synchronize with retake, which could be running
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// concurrently since it doesn&#39;t run on a P.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">allpLock</span><span class="p">)</span>	<span class="c1">// 获取 mutex 锁
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 当前 allp 的容量足够本次扩展。处理P
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="nx">nprocs</span> <span class="o">&lt;=</span> <span class="nb">int32</span><span class="p">(</span><span class="nb">cap</span><span class="p">(</span><span class="nx">allp</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nx">allp</span> <span class="p">=</span> <span class="nx">allp</span><span class="p">[:</span><span class="nx">nprocs</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 从新申请内存并拷贝
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="nx">nallp</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="o">*</span><span class="nx">p</span><span class="p">,</span> <span class="nx">nprocs</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// Copy everything up to allp&#39;s cap so we
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// never lose old allocated Ps.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="nb">copy</span><span class="p">(</span><span class="nx">nallp</span><span class="p">,</span> <span class="nx">allp</span><span class="p">[:</span><span class="nb">cap</span><span class="p">(</span><span class="nx">allp</span><span class="p">)])</span>
</span></span><span class="line"><span class="cl">            <span class="nx">allp</span> <span class="p">=</span> <span class="nx">nallp</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// idlepMask和timerpMask处理，容量够，直接使用
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="nx">maskWords</span> <span class="o">&lt;=</span> <span class="nb">int32</span><span class="p">(</span><span class="nb">cap</span><span class="p">(</span><span class="nx">idlepMask</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nx">idlepMask</span> <span class="p">=</span> <span class="nx">idlepMask</span><span class="p">[:</span><span class="nx">maskWords</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">            <span class="nx">timerpMask</span> <span class="p">=</span> <span class="nx">timerpMask</span><span class="p">[:</span><span class="nx">maskWords</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span> <span class="c1">// 容量不够，申请内存并搬迁
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// 创建一个 []uint32，每一位分别代表一个P
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="nx">nidlepMask</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">uint32</span><span class="p">,</span> <span class="nx">maskWords</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// No need to copy beyond len, old Ps are irrelevant.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="nb">copy</span><span class="p">(</span><span class="nx">nidlepMask</span><span class="p">,</span> <span class="nx">idlepMask</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="nx">idlepMask</span> <span class="p">=</span> <span class="nx">nidlepMask</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            <span class="nx">ntimerpMask</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">uint32</span><span class="p">,</span> <span class="nx">maskWords</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="nb">copy</span><span class="p">(</span><span class="nx">ntimerpMask</span><span class="p">,</span> <span class="nx">timerpMask</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="nx">timerpMask</span> <span class="p">=</span> <span class="nx">ntimerpMask</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">allpLock</span><span class="p">)</span> <span class="c1">// mutex 解锁
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// initialize new P&#39;s
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 初始化所有新创建的P，从old处开始因此之前的已经初始化了
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="nx">old</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">nprocs</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">pp</span> <span class="o">:=</span> <span class="nx">allp</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="nx">pp</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 可见P是堆分配的
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="nx">pp</span> <span class="p">=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">p</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="nx">pp</span><span class="p">.</span><span class="nf">init</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span> <span class="c1">// 初始化当前P
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 原子设置 【allp[i] = pp】
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nf">atomicstorep</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">allp</span><span class="p">[</span><span class="nx">i</span><span class="p">]),</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">pp</span><span class="p">))</span> <span class="c1">// 保存allp中去
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nx">_g_</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">()</span> <span class="c1">// g0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 当前m绑定了P时，初始化时m并没有绑定P，_g_.m.p == 0。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// _g_.m.p != 0 &amp;&amp; _g_.m.p.ptr().id &lt; nprocs 这种情况成立发生在：
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 发生扩容 或 发生缩容(当前P并不在裁剪之外)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">p</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">p</span><span class="p">.</span><span class="nf">ptr</span><span class="p">().</span><span class="nx">id</span> <span class="p">&lt;</span> <span class="nx">nprocs</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// continue to use the current P
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 继续使用当前P，_Prunning 运行中状态
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">p</span><span class="p">.</span><span class="nf">ptr</span><span class="p">().</span><span class="nx">status</span> <span class="p">=</span> <span class="nx">_Prunning</span>
</span></span><span class="line"><span class="cl">        <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">p</span><span class="p">.</span><span class="nf">ptr</span><span class="p">().</span><span class="nx">mcache</span><span class="p">.</span><span class="nf">prepareForSweep</span><span class="p">()</span> <span class="c1">// 清理
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// release the current P and acquire allp[0].
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// We must do this before destroying our current P
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// because p.destroy itself has write barriers, so we
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// need to do that from a valid P.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">p</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span> <span class="c1">// 这种情况发生在P在缩容(当前P并不在裁剪之外)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="k">if</span> <span class="nx">trace</span><span class="p">.</span><span class="nx">enabled</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="c1">// Pretend that we were descheduled
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="c1">// and then scheduled again to keep
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="c1">// the trace sane.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="nf">traceGoSched</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">                <span class="nf">traceProcStop</span><span class="p">(</span><span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">p</span><span class="p">.</span><span class="nf">ptr</span><span class="p">())</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 当前M绑定的p与当前M解绑
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// 因为 M 与 P 相互绑定的，这里要解绑
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">p</span><span class="p">.</span><span class="nf">ptr</span><span class="p">().</span><span class="nx">m</span> <span class="p">=</span> <span class="mi">0</span> <span class="c1">// p.m = 0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 初始化时，会走这里
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 解绑M与P关系
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">p</span> <span class="p">=</span> <span class="mi">0</span> <span class="c1">// m.p = 0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 选取allp[0]绑定当前工作线程
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">p</span> <span class="o">:=</span> <span class="nx">allp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> 
</span></span><span class="line"><span class="cl">        <span class="nx">p</span><span class="p">.</span><span class="nx">m</span> <span class="p">=</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// _Pidle 空闲状态
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">p</span><span class="p">.</span><span class="nx">status</span> <span class="p">=</span> <span class="nx">_Pidle</span> <span class="c1">// 标记当前P为空闲状态
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 该方法要求P和M都是没有绑定的，并且P一定是_Pidle状态。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// p.m = m; m.p = p;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nf">acquirep</span><span class="p">(</span><span class="nx">p</span><span class="p">)</span> <span class="c1">// m与p相互绑定，并修改p的状态为运行中。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="nx">trace</span><span class="p">.</span><span class="nx">enabled</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nf">traceGoStart</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// g.m.p is now set, so we no longer need mcache0 for bootstrapping.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// g.m.p 现在已经设置，因此我们不再需要 mcache0 来进行引导。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// mcache0 在 p.init() 函数中被使用
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">mcache0</span> <span class="p">=</span> <span class="kc">nil</span> <span class="c1">// 该值在前面schedinit()函数中，栈相关初始化时被设置
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="c1">// release resources from unused P&#39;s
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 从未使用的 P 释放资源，这种情况发生在缩容P时
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="nx">nprocs</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">old</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">p</span> <span class="o">:=</span> <span class="nx">allp</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">        <span class="nx">p</span><span class="p">.</span><span class="nf">destroy</span><span class="p">()</span> <span class="c1">// 回收P
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// can&#39;t free P itself because it can be referenced by an M in syscall
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 不能释放P本身，因为它可以被系统调用中的M引用
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// Trim allp.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 裁剪 allp。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nb">int32</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">allp</span><span class="p">))</span> <span class="o">!=</span> <span class="nx">nprocs</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">allpLock</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="nx">allp</span> <span class="p">=</span> <span class="nx">allp</span><span class="p">[:</span><span class="nx">nprocs</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">        <span class="nx">idlepMask</span> <span class="p">=</span> <span class="nx">idlepMask</span><span class="p">[:</span><span class="nx">maskWords</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">        <span class="nx">timerpMask</span> <span class="p">=</span> <span class="nx">timerpMask</span><span class="p">[:</span><span class="nx">maskWords</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">        <span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">allpLock</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">var</span> <span class="nx">runnablePs</span> <span class="o">*</span><span class="nx">p</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 遍历所有P，处理P的本地队列中有goroutine的需要绑定M运行这些goroutine。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="nx">nprocs</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span><span class="o">--</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">p</span> <span class="o">:=</span> <span class="nx">allp</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 跳过当前P，当前工作线程绑定的P正在执行这里的代码需要跳过
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">p</span><span class="p">.</span><span class="nf">ptr</span><span class="p">()</span> <span class="o">==</span> <span class="nx">p</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">continue</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="nx">p</span><span class="p">.</span><span class="nx">status</span> <span class="p">=</span> <span class="nx">_Pidle</span> <span class="c1">// 状态修改为 _Pidle 空闲
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="nf">runqempty</span><span class="p">(</span><span class="nx">p</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// P的runq是空的时
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="nf">pidleput</span><span class="p">(</span><span class="nx">p</span><span class="p">,</span> <span class="nx">now</span><span class="p">)</span> <span class="c1">// 把当前P挂在全局sched空闲链表中
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span> 
</span></span><span class="line"><span class="cl">            <span class="nx">p</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nf">set</span><span class="p">(</span><span class="nf">mget</span><span class="p">())</span> <span class="c1">// p绑定m
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="nx">p</span><span class="p">.</span><span class="nx">link</span><span class="p">.</span><span class="nf">set</span><span class="p">(</span><span class="nx">runnablePs</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="nx">runnablePs</span> <span class="p">=</span> <span class="nx">p</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c1">// 重置 stealOrder，该值用于随机从allp中偷取goroutine初始条件
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">stealOrder</span><span class="p">.</span><span class="nf">reset</span><span class="p">(</span><span class="nb">uint32</span><span class="p">(</span><span class="nx">nprocs</span><span class="p">))</span> <span class="c1">// 初始化P后面要用到偷取的数据
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 原子绑定 gomaxprocs = nprocs
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kd">var</span> <span class="nx">int32p</span> <span class="o">*</span><span class="kt">int32</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">gomaxprocs</span> <span class="c1">// make compiler check that gomaxprocs is an int32
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">atomic</span><span class="p">.</span><span class="nf">Store</span><span class="p">((</span><span class="o">*</span><span class="kt">uint32</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">int32p</span><span class="p">)),</span> <span class="nb">uint32</span><span class="p">(</span><span class="nx">nprocs</span><span class="p">))</span> <span class="c1">// gomaxprocs = nprocs
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nx">old</span> <span class="o">!=</span> <span class="nx">nprocs</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// Notify the limiter that the amount of procs has changed.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">gcCPULimiter</span><span class="p">.</span><span class="nf">resetCapacity</span><span class="p">(</span><span class="nx">now</span><span class="p">,</span> <span class="nx">nprocs</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// runnablePs != nil 说明除了当前P外的其他P中存在goroutine
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">return</span> <span class="nx">runnablePs</span> 
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><img loading="lazy" src="../images/goroutine-008.png" alt=""  />
</p>
<h4 id="pinit">p.init()<a hidden class="anchor" aria-hidden="true" href="#pinit">#</a></h4>
<ol>
<li>初始化P。</li>
<li>文件位置：<code>go1.19.3/src/runtime/proc.go</code>。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">4669
</span><span class="lnt">4670
</span><span class="lnt">4671
</span><span class="lnt">4672
</span><span class="lnt">4673
</span><span class="lnt">4674
</span><span class="lnt">4675
</span><span class="lnt">4676
</span><span class="lnt">4677
</span><span class="lnt">4678
</span><span class="lnt">4679
</span><span class="lnt">4680
</span><span class="lnt">4681
</span><span class="lnt">4682
</span><span class="lnt">4683
</span><span class="lnt">4684
</span><span class="lnt">4685
</span><span class="lnt">4686
</span><span class="lnt">4687
</span><span class="lnt">4688
</span><span class="lnt">4689
</span><span class="lnt">4690
</span><span class="lnt">4691
</span><span class="lnt">4692
</span><span class="lnt">4693
</span><span class="lnt">4694
</span><span class="lnt">4695
</span><span class="lnt">4696
</span><span class="lnt">4697
</span><span class="lnt">4698
</span><span class="lnt">4699
</span><span class="lnt">4700
</span><span class="lnt">4701
</span><span class="lnt">4702
</span><span class="lnt">4703
</span><span class="lnt">4704
</span><span class="lnt">4705
</span><span class="lnt">4706
</span><span class="lnt">4707
</span><span class="lnt">4708
</span><span class="lnt">4709
</span><span class="lnt">4710
</span><span class="lnt">4711
</span><span class="lnt">4712
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// init initializes pp, which may be a freshly allocated p or a
</span></span></span><span class="line"><span class="cl"><span class="c1">// previously destroyed p, and transitions it to status _Pgcstop.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">pp</span> <span class="o">*</span><span class="nx">p</span><span class="p">)</span> <span class="nf">init</span><span class="p">(</span><span class="nx">id</span> <span class="kt">int32</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">pp</span><span class="p">.</span><span class="nx">id</span> <span class="p">=</span> <span class="nx">id</span>	<span class="c1">// 分配P的id，该id是唯一的
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">pp</span><span class="p">.</span><span class="nx">status</span> <span class="p">=</span> <span class="nx">_Pgcstop</span> <span class="c1">// 设置P状态 _Pgcstop GC停止状态
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">pp</span><span class="p">.</span><span class="nx">sudogcache</span> <span class="p">=</span> <span class="nx">pp</span><span class="p">.</span><span class="nx">sudogbuf</span><span class="p">[:</span><span class="mi">0</span><span class="p">]</span> <span class="c1">// P上sudog缓存
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">pp</span><span class="p">.</span><span class="nx">deferpool</span> <span class="p">=</span> <span class="nx">pp</span><span class="p">.</span><span class="nx">deferpoolbuf</span><span class="p">[:</span><span class="mi">0</span><span class="p">]</span> <span class="c1">// P上defer池 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">pp</span><span class="p">.</span><span class="nx">wbBuf</span><span class="p">.</span><span class="nf">reset</span><span class="p">()</span> <span class="c1">// P的wbBuf重置，该字段与写屏障相关
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// pp.mcache 没有初始化
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nx">pp</span><span class="p">.</span><span class="nx">mcache</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="nx">id</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span> 
</span></span><span class="line"><span class="cl">            <span class="c1">// 程序刚初始化时，mcache0在schedinit()中的mallocinit()函数中被创建
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="k">if</span> <span class="nx">mcache0</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="nf">throw</span><span class="p">(</span><span class="s">&#34;missing mcache?&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// Use the bootstrap mcache0. Only one P will get
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// mcache0: the one with ID 0.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="nx">pp</span><span class="p">.</span><span class="nx">mcache</span> <span class="p">=</span> <span class="nx">mcache0</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 使用 allocmcache() 分配缓存
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="nx">pp</span><span class="p">.</span><span class="nx">mcache</span> <span class="p">=</span> <span class="nf">allocmcache</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">raceenabled</span> <span class="o">&amp;&amp;</span> <span class="nx">pp</span><span class="p">.</span><span class="nx">raceprocctx</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="nx">id</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nx">pp</span><span class="p">.</span><span class="nx">raceprocctx</span> <span class="p">=</span> <span class="nx">raceprocctx0</span>
</span></span><span class="line"><span class="cl">            <span class="nx">raceprocctx0</span> <span class="p">=</span> <span class="mi">0</span> <span class="c1">// bootstrap
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nx">pp</span><span class="p">.</span><span class="nx">raceprocctx</span> <span class="p">=</span> <span class="nf">raceproccreate</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nf">lockInit</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">pp</span><span class="p">.</span><span class="nx">timersLock</span><span class="p">,</span> <span class="nx">lockRankTimers</span><span class="p">)</span> <span class="c1">// 初始化 P.timersLock 锁
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="c1">// This P may get timers when it starts running. Set the mask here
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// since the P may not go through pidleget (notably P 0 on startup).
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 这个P开始运行时可能会有times。在这里设置可能不会经过pidleget(特别是在启动时P 0)。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">timerpMask</span><span class="p">.</span><span class="nf">set</span><span class="p">(</span><span class="nx">id</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Similarly, we may not go through pidleget before this P starts
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// running if it is P 0 on startup.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 类似的，如果这个P是在启动的是P 0，我们可能不会在这个P开始运行之前经历pidleget。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">idlepMask</span><span class="p">.</span><span class="nb">clear</span><span class="p">(</span><span class="nx">id</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="acquirep">acquirep()<a hidden class="anchor" aria-hidden="true" href="#acquirep">#</a></h4>
<ol>
<li><code>M</code>和<code>P</code>相互绑定。<code>m.p = p</code>、<code>p.m = m</code>。</li>
<li>文件位置：<code>go1.19.3/src/runtime/proc.go</code>。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">4938
</span><span class="lnt">4939
</span><span class="lnt">4940
</span><span class="lnt">4941
</span><span class="lnt">4942
</span><span class="lnt">4943
</span><span class="lnt">4944
</span><span class="lnt">4945
</span><span class="lnt">4946
</span><span class="lnt">4947
</span><span class="lnt">4948
</span><span class="lnt">4949
</span><span class="lnt">4950
</span><span class="lnt">4951
</span><span class="lnt">4952
</span><span class="lnt">4953
</span><span class="lnt">4954
</span><span class="lnt">4955
</span><span class="lnt">4956
</span><span class="lnt">4957
</span><span class="lnt">4958
</span><span class="lnt">4959
</span><span class="lnt">4960
</span><span class="lnt">4961
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// Associate p and the current m.
</span></span></span><span class="line"><span class="cl"><span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1">// This function is allowed to have write barriers even if the caller
</span></span></span><span class="line"><span class="cl"><span class="c1">// isn&#39;t because it immediately acquires _p_.
</span></span></span><span class="line"><span class="cl"><span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1">//go:yeswritebarrierrec
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">acquirep</span><span class="p">(</span><span class="nx">_p_</span> <span class="o">*</span><span class="nx">p</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Do the part that isn&#39;t allowed to have write barriers.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 不允许有写入障碍的部分。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">wirep</span><span class="p">(</span><span class="nx">_p_</span><span class="p">)</span> <span class="c1">// m与p相互绑定，并修改p的状态为运行中。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Have p; write barriers now allowed.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Perform deferred mcache flush before this P can allocate
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// from a potentially stale mcache.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 在这个P可以从可能过期的mcache进行分配之前执行延迟的mcache刷写。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">_p_</span><span class="p">.</span><span class="nx">mcache</span><span class="p">.</span><span class="nf">prepareForSweep</span><span class="p">()</span> <span class="c1">// GC相关
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">trace</span><span class="p">.</span><span class="nx">enabled</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">traceProcStart</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="wirep">wirep()<a hidden class="anchor" aria-hidden="true" href="#wirep">#</a></h4>
<ol>
<li><code>wirep</code>是<code>acquirep</code> 的第一步，它实际上将当前<code>M</code>关联到 <code>_p_</code>。</li>
<li>这里不允许栈检查，以及写屏障相关代码，因为<code>M</code>还没有绑定<code>P</code>。</li>
<li><code>m</code>与<code>p</code>相互绑定，并修改<code>p</code>的状态为运行中。</li>
<li>文件位置：<code>go1.19.3/src/runtime/proc.go</code>。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">4959
</span><span class="lnt">4960
</span><span class="lnt">4961
</span><span class="lnt">4962
</span><span class="lnt">4963
</span><span class="lnt">4964
</span><span class="lnt">4965
</span><span class="lnt">4966
</span><span class="lnt">4967
</span><span class="lnt">4968
</span><span class="lnt">4969
</span><span class="lnt">4970
</span><span class="lnt">4971
</span><span class="lnt">4972
</span><span class="lnt">4973
</span><span class="lnt">4974
</span><span class="lnt">4975
</span><span class="lnt">4976
</span><span class="lnt">4977
</span><span class="lnt">4978
</span><span class="lnt">4979
</span><span class="lnt">4980
</span><span class="lnt">4981
</span><span class="lnt">4982
</span><span class="lnt">4983
</span><span class="lnt">4984
</span><span class="lnt">4985
</span><span class="lnt">4986
</span><span class="lnt">4987
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// wirep is the first step of acquirep, which actually associates the
</span></span></span><span class="line"><span class="cl"><span class="c1">// current M to _p_. This is broken out so we can disallow write
</span></span></span><span class="line"><span class="cl"><span class="c1">// barriers for this part, since we don&#39;t yet have a P.
</span></span></span><span class="line"><span class="cl"><span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1">//go:nowritebarrierrec
</span></span></span><span class="line"><span class="cl"><span class="c1">//go:nosplit
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">wirep</span><span class="p">(</span><span class="nx">_p_</span> <span class="o">*</span><span class="nx">p</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 在当前这里只能是g0，但是其他地方可能是g
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">_g_</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">()</span> <span class="c1">// g0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 此时M一定是没有绑定P的。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">p</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">throw</span><span class="p">(</span><span class="s">&#34;wirep: already in go&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 此时p一定没有绑定M，并且P一定是_Pidle状态（空闲）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nx">_p_</span><span class="p">.</span><span class="nx">m</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">||</span> <span class="nx">_p_</span><span class="p">.</span><span class="nx">status</span> <span class="o">!=</span> <span class="nx">_Pidle</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">id</span> <span class="o">:=</span> <span class="nb">int64</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="nx">_p_</span><span class="p">.</span><span class="nx">m</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nx">id</span> <span class="p">=</span> <span class="nx">_p_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nf">ptr</span><span class="p">().</span><span class="nx">id</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="nb">print</span><span class="p">(</span><span class="s">&#34;wirep: p-&gt;m=&#34;</span><span class="p">,</span> <span class="nx">_p_</span><span class="p">.</span><span class="nx">m</span><span class="p">,</span> <span class="s">&#34;(&#34;</span><span class="p">,</span> <span class="nx">id</span><span class="p">,</span> <span class="s">&#34;) p-&gt;status=&#34;</span><span class="p">,</span> <span class="nx">_p_</span><span class="p">.</span><span class="nx">status</span><span class="p">,</span> <span class="s">&#34;\n&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="nf">throw</span><span class="p">(</span><span class="s">&#34;wirep: invalid p state&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// M与P相互绑定，并设置P的状态为运行中
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">p</span><span class="p">.</span><span class="nf">set</span><span class="p">(</span><span class="nx">_p_</span><span class="p">)</span> <span class="c1">// m.p = _p_
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">_p_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nf">set</span><span class="p">(</span><span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">)</span> <span class="c1">// _p_.m = m
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// _Prunning 运行中状态
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">_p_</span><span class="p">.</span><span class="nx">status</span> <span class="p">=</span> <span class="nx">_Prunning</span> <span class="c1">// 修改当前P为运行状态
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><img loading="lazy" src="../images/goroutine-009.png" alt=""  />
</p>
<h4 id="pdestroy">p.destroy()<a hidden class="anchor" aria-hidden="true" href="#pdestroy">#</a></h4>
<ol>
<li><code>destroy</code>释放与<code>pp</code>相关的所有资源，并将其转换为状态<code>_Pdead</code>。</li>
<li><code>sched.lock</code>必须被持有并且<code>STW</code>。</li>
<li>该函数处理<code>P</code>中的<code>goroutine</code>，以及迁移<code>pp</code>上所有的<code>timer</code>，以及写屏障相关内存释放等。</li>
<li>文件位置：<code>go1.19.3/src/runtime/proc.go</code>。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">4707
</span><span class="lnt">4708
</span><span class="lnt">4709
</span><span class="lnt">4710
</span><span class="lnt">4711
</span><span class="lnt">4712
</span><span class="lnt">4713
</span><span class="lnt">4714
</span><span class="lnt">4715
</span><span class="lnt">4716
</span><span class="lnt">4717
</span><span class="lnt">4718
</span><span class="lnt">4719
</span><span class="lnt">4720
</span><span class="lnt">4721
</span><span class="lnt">4722
</span><span class="lnt">4723
</span><span class="lnt">4724
</span><span class="lnt">4725
</span><span class="lnt">4726
</span><span class="lnt">4727
</span><span class="lnt">4728
</span><span class="lnt">4729
</span><span class="lnt">4730
</span><span class="lnt">4731
</span><span class="lnt">4732
</span><span class="lnt">4733
</span><span class="lnt">4734
</span><span class="lnt">4735
</span><span class="lnt">4736
</span><span class="lnt">4737
</span><span class="lnt">4738
</span><span class="lnt">4739
</span><span class="lnt">4740
</span><span class="lnt">4741
</span><span class="lnt">4742
</span><span class="lnt">4743
</span><span class="lnt">4744
</span><span class="lnt">4745
</span><span class="lnt">4746
</span><span class="lnt">4747
</span><span class="lnt">4748
</span><span class="lnt">4749
</span><span class="lnt">4750
</span><span class="lnt">4751
</span><span class="lnt">4752
</span><span class="lnt">4753
</span><span class="lnt">4754
</span><span class="lnt">4755
</span><span class="lnt">4756
</span><span class="lnt">4757
</span><span class="lnt">4758
</span><span class="lnt">4759
</span><span class="lnt">4760
</span><span class="lnt">4761
</span><span class="lnt">4762
</span><span class="lnt">4763
</span><span class="lnt">4764
</span><span class="lnt">4765
</span><span class="lnt">4766
</span><span class="lnt">4767
</span><span class="lnt">4768
</span><span class="lnt">4769
</span><span class="lnt">4770
</span><span class="lnt">4771
</span><span class="lnt">4772
</span><span class="lnt">4773
</span><span class="lnt">4774
</span><span class="lnt">4775
</span><span class="lnt">4776
</span><span class="lnt">4777
</span><span class="lnt">4778
</span><span class="lnt">4779
</span><span class="lnt">4780
</span><span class="lnt">4781
</span><span class="lnt">4782
</span><span class="lnt">4783
</span><span class="lnt">4784
</span><span class="lnt">4785
</span><span class="lnt">4786
</span><span class="lnt">4787
</span><span class="lnt">4788
</span><span class="lnt">4789
</span><span class="lnt">4790
</span><span class="lnt">4791
</span><span class="lnt">4792
</span><span class="lnt">4793
</span><span class="lnt">4794
</span><span class="lnt">4795
</span><span class="lnt">4796
</span><span class="lnt">4797
</span><span class="lnt">4798
</span><span class="lnt">4799
</span><span class="lnt">4800
</span><span class="lnt">4801
</span><span class="lnt">4802
</span><span class="lnt">4803
</span><span class="lnt">4804
</span><span class="lnt">4805
</span><span class="lnt">4806
</span><span class="lnt">4807
</span><span class="lnt">4808
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// destroy releases all of the resources associated with pp and
</span></span></span><span class="line"><span class="cl"><span class="c1">// transitions it to status _Pdead.
</span></span></span><span class="line"><span class="cl"><span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1">// sched.lock must be held and the world must be stopped.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">pp</span> <span class="o">*</span><span class="nx">p</span><span class="p">)</span> <span class="nf">destroy</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nf">assertLockHeld</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nf">assertWorldStopped</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// Move all runnable goroutines to the global queue
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>     <span class="c1">// 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 将当前P的所有可运行的goroutines移动到全局队列
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">for</span> <span class="nx">pp</span><span class="p">.</span><span class="nx">runqhead</span> <span class="o">!=</span> <span class="nx">pp</span><span class="p">.</span><span class="nx">runqtail</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// Pop from tail of local queue
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">pp</span><span class="p">.</span><span class="nx">runqtail</span><span class="o">--</span>
</span></span><span class="line"><span class="cl">        <span class="nx">gp</span> <span class="o">:=</span> <span class="nx">pp</span><span class="p">.</span><span class="nx">runq</span><span class="p">[</span><span class="nx">pp</span><span class="p">.</span><span class="nx">runqtail</span><span class="o">%</span><span class="nb">uint32</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">pp</span><span class="p">.</span><span class="nx">runq</span><span class="p">))].</span><span class="nf">ptr</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// Push onto head of global queue
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nf">globrunqputhead</span><span class="p">(</span><span class="nx">gp</span><span class="p">)</span> <span class="c1">// 加入到全局队列池中
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// pp.runnext 上存在 goroutine，加入到全局池
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nx">pp</span><span class="p">.</span><span class="nx">runnext</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">globrunqputhead</span><span class="p">(</span><span class="nx">pp</span><span class="p">.</span><span class="nx">runnext</span><span class="p">.</span><span class="nf">ptr</span><span class="p">())</span>
</span></span><span class="line"><span class="cl">        <span class="nx">pp</span><span class="p">.</span><span class="nx">runnext</span> <span class="p">=</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// P 中还有timer。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">pp</span><span class="p">.</span><span class="nx">timers</span><span class="p">)</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 当前工作线程绑定的P
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">plocal</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">().</span><span class="nx">m</span><span class="p">.</span><span class="nx">p</span><span class="p">.</span><span class="nf">ptr</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// The world is stopped, but we acquire timersLock to
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// protect against sysmon calling timeSleepUntil.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// This is the only case where we hold the timersLock of
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// more than one P, so there are no deadlock concerns.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// STW了，但是我们获得了timersLock来防止sysmon调用timeSleepUntil
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 这是我们持有不止一个P的定时器锁的唯一情况，因此不存在死锁问题。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">plocal</span><span class="p">.</span><span class="nx">timersLock</span><span class="p">)</span> <span class="c1">// plocal
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">pp</span><span class="p">.</span><span class="nx">timersLock</span><span class="p">)</span> <span class="c1">// pp
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 把pp.timers中所有有效的timer重新添加到plocal.timers中
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 这里把需要删除的pp上的所有timer转移到当前工作线程绑定的P上面
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nf">moveTimers</span><span class="p">(</span><span class="nx">plocal</span><span class="p">,</span> <span class="nx">pp</span><span class="p">.</span><span class="nx">timers</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="nx">pp</span><span class="p">.</span><span class="nx">timers</span> <span class="p">=</span> <span class="kc">nil</span> <span class="c1">// 情况 pp.timers，因为timers已经迁移到了当前工作线程的P了。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// numTimers：记录的是堆中 timer 的总数，应该与 timers 切片的长度一致。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">pp</span><span class="p">.</span><span class="nx">numTimers</span> <span class="p">=</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// deletedTimers：记录的是堆中已删除但还未被移除的 timer 的总数。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">pp</span><span class="p">.</span><span class="nx">deletedTimers</span> <span class="p">=</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// timer0When：表示位于最小堆堆顶的 timer 的触发时间，也就是赋值其 when 字段。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">atomic</span><span class="p">.</span><span class="nf">Store64</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">pp</span><span class="p">.</span><span class="nx">timer0When</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="c1">// pp.timer0When = 0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">pp</span><span class="p">.</span><span class="nx">timersLock</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">plocal</span><span class="p">.</span><span class="nx">timersLock</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Flush p&#39;s write barrier buffer.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 刷新p的写屏障缓冲区。写屏障相关
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nx">gcphase</span> <span class="o">!=</span> <span class="nx">_GCoff</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">wbBufFlush1</span><span class="p">(</span><span class="nx">pp</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="nx">pp</span><span class="p">.</span><span class="nx">gcw</span><span class="p">.</span><span class="nf">dispose</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">pp</span><span class="p">.</span><span class="nx">sudogbuf</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">pp</span><span class="p">.</span><span class="nx">sudogbuf</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nx">pp</span><span class="p">.</span><span class="nx">sudogcache</span> <span class="p">=</span> <span class="nx">pp</span><span class="p">.</span><span class="nx">sudogbuf</span><span class="p">[:</span><span class="mi">0</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="nx">j</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">pp</span><span class="p">.</span><span class="nx">deferpoolbuf</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">pp</span><span class="p">.</span><span class="nx">deferpoolbuf</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span> <span class="p">=</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nx">pp</span><span class="p">.</span><span class="nx">deferpool</span> <span class="p">=</span> <span class="nx">pp</span><span class="p">.</span><span class="nx">deferpoolbuf</span><span class="p">[:</span><span class="mi">0</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 切换到g0栈处理mspancache
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">systemstack</span><span class="p">(</span><span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 相关内存释放
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">pp</span><span class="p">.</span><span class="nx">mspancache</span><span class="p">.</span><span class="nx">len</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// Safe to call since the world is stopped.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="nx">mheap_</span><span class="p">.</span><span class="nx">spanalloc</span><span class="p">.</span><span class="nf">free</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">pp</span><span class="p">.</span><span class="nx">mspancache</span><span class="p">.</span><span class="nx">buf</span><span class="p">[</span><span class="nx">i</span><span class="p">]))</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="nx">pp</span><span class="p">.</span><span class="nx">mspancache</span><span class="p">.</span><span class="nx">len</span> <span class="p">=</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">        <span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">mheap_</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="nx">pp</span><span class="p">.</span><span class="nx">pcache</span><span class="p">.</span><span class="nf">flush</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">mheap_</span><span class="p">.</span><span class="nx">pages</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">mheap_</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">})</span>
</span></span><span class="line"><span class="cl">    <span class="nf">freemcache</span><span class="p">(</span><span class="nx">pp</span><span class="p">.</span><span class="nx">mcache</span><span class="p">)</span> <span class="c1">// 释放内存
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">pp</span><span class="p">.</span><span class="nx">mcache</span> <span class="p">=</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl">    <span class="nf">gfpurge</span><span class="p">(</span><span class="nx">pp</span><span class="p">)</span> <span class="c1">// 回收P
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">traceProcFree</span><span class="p">(</span><span class="nx">pp</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">raceenabled</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="nx">pp</span><span class="p">.</span><span class="nx">timerRaceCtx</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// The race detector code uses a callback to fetch
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// the proc context, so arrange for that callback
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// to see the right thing.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// This hack only works because we are the only
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// thread running.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="nx">mp</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">().</span><span class="nx">m</span>
</span></span><span class="line"><span class="cl">            <span class="nx">phold</span> <span class="o">:=</span> <span class="nx">mp</span><span class="p">.</span><span class="nx">p</span><span class="p">.</span><span class="nf">ptr</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">            <span class="nx">mp</span><span class="p">.</span><span class="nx">p</span><span class="p">.</span><span class="nf">set</span><span class="p">(</span><span class="nx">pp</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            <span class="nf">racectxend</span><span class="p">(</span><span class="nx">pp</span><span class="p">.</span><span class="nx">timerRaceCtx</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="nx">pp</span><span class="p">.</span><span class="nx">timerRaceCtx</span> <span class="p">=</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            <span class="nx">mp</span><span class="p">.</span><span class="nx">p</span><span class="p">.</span><span class="nf">set</span><span class="p">(</span><span class="nx">phold</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="nf">raceprocdestroy</span><span class="p">(</span><span class="nx">pp</span><span class="p">.</span><span class="nx">raceprocctx</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="nx">pp</span><span class="p">.</span><span class="nx">raceprocctx</span> <span class="p">=</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nx">pp</span><span class="p">.</span><span class="nx">gcAssistTime</span> <span class="p">=</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">    <span class="nx">pp</span><span class="p">.</span><span class="nx">status</span> <span class="p">=</span> <span class="nx">_Pdead</span> <span class="c1">// 修改P状态为空闲
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="pidleput">pidleput()<a hidden class="anchor" aria-hidden="true" href="#pidleput">#</a></h4>
<ol>
<li>参数：
<ul>
<li><code>_p_ *p</code>：当前操作的<code>p</code>，该<code>p</code>的本地队列应该是空的。</li>
<li><code>now int64</code>：当前时间。</li>
</ul>
</li>
<li>把当<code>_p_</code>挂在全局<code>sched</code>空闲链表中。</li>
<li>文件位置：<code>go1.19.3/src/runtime/proc.go</code>。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">5696
</span><span class="lnt">5697
</span><span class="lnt">5698
</span><span class="lnt">5699
</span><span class="lnt">5700
</span><span class="lnt">5701
</span><span class="lnt">5702
</span><span class="lnt">5703
</span><span class="lnt">5704
</span><span class="lnt">5705
</span><span class="lnt">5706
</span><span class="lnt">5707
</span><span class="lnt">5708
</span><span class="lnt">5709
</span><span class="lnt">5710
</span><span class="lnt">5711
</span><span class="lnt">5712
</span><span class="lnt">5713
</span><span class="lnt">5714
</span><span class="lnt">5715
</span><span class="lnt">5716
</span><span class="lnt">5717
</span><span class="lnt">5718
</span><span class="lnt">5719
</span><span class="lnt">5720
</span><span class="lnt">5721
</span><span class="lnt">5722
</span><span class="lnt">5723
</span><span class="lnt">5724
</span><span class="lnt">5725
</span><span class="lnt">5726
</span><span class="lnt">5727
</span><span class="lnt">5728
</span><span class="lnt">5729
</span><span class="lnt">5730
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// pidleput puts p on the _Pidle list. now must be a relatively recent call
</span></span></span><span class="line"><span class="cl"><span class="c1">// to nanotime or zero. Returns now or the current time if now was zero.
</span></span></span><span class="line"><span class="cl"><span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1">// This releases ownership of p. Once sched.lock is released it is no longer
</span></span></span><span class="line"><span class="cl"><span class="c1">// safe to use p.
</span></span></span><span class="line"><span class="cl"><span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1">// sched.lock must be held.
</span></span></span><span class="line"><span class="cl"><span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1">// May run during STW, so write barriers are not allowed.
</span></span></span><span class="line"><span class="cl"><span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1">//go:nowritebarrierrec
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">pidleput</span><span class="p">(</span><span class="nx">_p_</span> <span class="o">*</span><span class="nx">p</span><span class="p">,</span> <span class="nx">now</span> <span class="kt">int64</span><span class="p">)</span> <span class="kt">int64</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 调用该函数时 sched.lock 必须被持有
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">assertLockHeld</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 当前P准备放入空闲链表，因此runq中不能有goroutine
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">!</span><span class="nf">runqempty</span><span class="p">(</span><span class="nx">_p_</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">throw</span><span class="p">(</span><span class="s">&#34;pidleput: P has non-empty run queue&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">now</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">now</span> <span class="p">=</span> <span class="nf">nanotime</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 更新TimerPMask
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">updateTimerPMask</span><span class="p">(</span><span class="nx">_p_</span><span class="p">)</span> <span class="c1">// clear if there are no timers.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">idlepMask</span><span class="p">.</span><span class="nf">set</span><span class="p">(</span><span class="nx">_p_</span><span class="p">.</span><span class="nx">id</span><span class="p">)</span> <span class="c1">// 标记_p_是空闲的
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 放入全局链表中
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">_p_</span><span class="p">.</span><span class="nx">link</span> <span class="p">=</span> <span class="nx">sched</span><span class="p">.</span><span class="nx">pidle</span>
</span></span><span class="line"><span class="cl">    <span class="nx">sched</span><span class="p">.</span><span class="nx">pidle</span><span class="p">.</span><span class="nf">set</span><span class="p">(</span><span class="nx">_p_</span><span class="p">)</span> <span class="c1">// sched.pidle = _p_
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 空闲P数量加一
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">atomic</span><span class="p">.</span><span class="nf">Xadd</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">npidle</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="c1">// sched.npidle
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">!</span><span class="nx">_p_</span><span class="p">.</span><span class="nx">limiterEvent</span><span class="p">.</span><span class="nf">start</span><span class="p">(</span><span class="nx">limiterEventIdle</span><span class="p">,</span> <span class="nx">now</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">throw</span><span class="p">(</span><span class="s">&#34;must be able to track idle limiter event&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nx">now</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="创建main-goroutine">创建<code>main goroutine</code><a hidden class="anchor" aria-hidden="true" href="#创建main-goroutine">#</a></h2>
<ol>
<li><code>schedinit</code>完成调度系统初始化后。</li>
<li>返回到<code>rt0_go</code>函数中开始调用<code>newproc()</code>创建一个新的<code>goroutine</code>用于执行<code>mainPC</code>所对应的<code>runtime·main</code>函数。</li>
<li>文件位置：<code>go1.19.3/src/runtime/asm_amd64.s</code>。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">347
</span><span class="lnt">348
</span><span class="lnt">349
</span><span class="lnt">350
</span><span class="lnt">351
</span><span class="lnt">352
</span><span class="lnt">353
</span><span class="lnt">354
</span><span class="lnt">355
</span><span class="lnt">356
</span><span class="lnt">357
</span><span class="lnt">358
</span><span class="lnt">359
</span><span class="lnt">360
</span><span class="lnt">361
</span><span class="lnt">362
</span><span class="lnt">363
</span><span class="lnt">364
</span><span class="lnt">365
</span><span class="lnt">366
</span><span class="lnt">367
</span><span class="lnt">368
</span><span class="lnt">369
</span><span class="lnt">370
</span><span class="lnt">371
</span><span class="lnt">372
</span><span class="lnt">373
</span><span class="lnt">374
</span><span class="lnt">375
</span><span class="lnt">376
</span><span class="lnt">377
</span><span class="lnt">378
</span><span class="lnt">379
</span><span class="lnt">380
</span><span class="lnt">381
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-asm" data-lang="asm"><span class="line"><span class="cl">    <span class="c1"># create a new goroutine to start program
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1"># 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1"># 创建一个新的goroutine来启动程序。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1"># AX = runtime·main 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1"># runtime·main 是一个闭包，&amp;funcval{fn:runtime.main}
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">MOVQ</span>    <span class="no">$runtime</span><span class="err">·</span><span class="no">mainPC</span><span class="p">(</span><span class="no">SB</span><span class="p">),</span> <span class="no">AX</span> <span class="c1"># entry
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1"># 将AX的值压入栈中
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">PUSHQ</span>   <span class="no">AX</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># AX的值作为runtime·newproc()函数的参数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">CALL</span>    <span class="no">runtime</span><span class="err">·</span><span class="no">newproc</span><span class="p">(</span><span class="no">SB</span><span class="p">)</span> <span class="c1"># 创建main goroutine
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">POPQ</span>    <span class="no">AX</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1"># start this M
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">CALL</span>    <span class="no">runtime</span><span class="err">·</span><span class="no">mstart</span><span class="p">(</span><span class="no">SB</span><span class="p">)</span> <span class="c1"># 主线程进入循环调度，运行刚刚创建的goroutine
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="c1"># 上面的mstart永远不应该返回的，如果返回了，一定是代码逻辑有问题，直接abort
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">CALL</span>    <span class="no">runtime</span><span class="err">·</span><span class="no">abort</span><span class="p">(</span><span class="no">SB</span><span class="p">)</span>	<span class="c1"># mstart should never return
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">RET</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 前面没有获取到CPU相关信息时会走这里的异常
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nl">bad_cpu:</span> <span class="c1"># show that the program requires a certain microarchitecture level.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">MOVQ</span>    <span class="no">$2</span><span class="p">,</span> <span class="mi">0</span><span class="p">(</span><span class="no">SP</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nf">MOVQ</span>    <span class="no">$bad_cpu_msg</span><span class="err">&lt;&gt;</span><span class="p">(</span><span class="no">SB</span><span class="p">),</span> <span class="no">AX</span>
</span></span><span class="line"><span class="cl">    <span class="nf">MOVQ</span>    <span class="no">AX</span><span class="p">,</span> <span class="mi">8</span><span class="p">(</span><span class="no">SP</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nf">MOVQ</span>    <span class="no">$84</span><span class="p">,</span> <span class="mi">16</span><span class="p">(</span><span class="no">SP</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nf">CALL</span>    <span class="no">runtime</span><span class="err">·</span><span class="no">write</span><span class="p">(</span><span class="no">SB</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nf">MOVQ</span>    <span class="no">$1</span><span class="p">,</span> <span class="mi">0</span><span class="p">(</span><span class="no">SP</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nf">CALL</span>    <span class="no">runtime</span><span class="err">·</span><span class="no">exit</span><span class="p">(</span><span class="no">SB</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nf">CALL</span>    <span class="no">runtime</span><span class="err">·</span><span class="no">abort</span><span class="p">(</span><span class="no">SB</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nf">RET</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1"># Prevent dead-code elimination of debugCallV2, which is
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1"># intended to be called by debuggers.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">MOVQ</span>    <span class="no">$runtime</span><span class="err">·</span><span class="no">debugCallV2</span><span class="err">&lt;</span><span class="no">ABIInternal</span><span class="err">&gt;</span><span class="p">(</span><span class="no">SB</span><span class="p">),</span> <span class="no">AX</span>
</span></span><span class="line"><span class="cl">    <span class="nf">RET</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="argc和argv">argc和argv<a hidden class="anchor" aria-hidden="true" href="#argc和argv">#</a></h2>
<ol>
<li>在计算机编程中，通常使用命令行参数来向程序传递额外的信息。</li>
<li><code>C</code>语言中的<code>main</code>函数接受两个参数，分别是<code>argc</code>和<code>argv</code>。</li>
<li>其中<code>argc</code>表示命令行参数的数量，而<code>argv</code>是一个指向参数字符串数组的指针，其中每个元素都包含一个命令行参数。</li>
<li>如果你在命令行中执行以下命令：<code>$ my_program arg1 arg2 arg3</code></li>
<li>则<code>argc</code>的值将是4，其中包括程序名<code>my_program</code>和3个参数<code>arg1</code>、<code>arg2</code>和<code>arg3</code>。而<code>argv</code>指向一个字符串数组，其内容如下：</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="n">argv</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#34;my_program&#34;</span>
</span></span><span class="line"><span class="cl"><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#34;arg1&#34;</span>
</span></span><span class="line"><span class="cl"><span class="n">argv</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#34;arg2&#34;</span>
</span></span><span class="line"><span class="cl"><span class="n">argv</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#34;arg3&#34;</span>
</span></span></code></pre></div><ol start="6">
<li>比如在<code>Go</code>语言中，<code>argc</code>和<code>argv</code>使用：</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kn">package</span> <span class="nx">main</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="s">&#34;fmt&#34;</span>
</span></span><span class="line"><span class="cl">    <span class="s">&#34;os&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">args</span> <span class="o">:=</span> <span class="nx">os</span><span class="p">.</span><span class="nx">Args</span> <span class="c1">// []string
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;Path：%s\n&#34;</span><span class="p">,</span> <span class="nx">args</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
</span></span><span class="line"><span class="cl">    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;Args：%#v\n&#34;</span><span class="p">,</span> <span class="nx">args</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ol start="7">
<li>当我们执行<code>go run</code>命令运行上面的程序并传递一些参数时，将会得到类似以下的输出：</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl"><span class="o">[</span>root@localhost hello1<span class="o">]</span><span class="c1"># go run tt12.go foo bar baz js</span>
</span></span><span class="line"><span class="cl">Path：/tmp/go-build1239766326/b001/exe/tt12
</span></span><span class="line"><span class="cl">Args：<span class="o">[]</span>string<span class="o">{</span><span class="s2">&#34;foo&#34;</span>, <span class="s2">&#34;bar&#34;</span>, <span class="s2">&#34;baz&#34;</span>, <span class="s2">&#34;js&#34;</span><span class="o">}</span>
</span></span></code></pre></div>

  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://heliu.site/tags/golang/">Golang</a></li>
      <li><a href="https://heliu.site/tags/goroutine/">Goroutine</a></li>
    </ul>
<nav class="paginav">
  <a class="prev" href="https://heliu.site/posts/golang/func/use/">
    <span class="title">« 上一页</span>
    <br>
    <span>函数使用</span>
  </a>
  <a class="next" href="https://heliu.site/posts/golang/netpoll/linux/">
    <span class="title">下一页 »</span>
    <br>
    <span>Linux epoll</span>
  </a>
</nav>

  </footer>
</article>
    </main>
    
<footer class="footer">
    
    <div class="busuanzi-footer">
    <span id="busuanzi_container_site_pv">
        本站总访问量<span id="busuanzi_value_site_pv"></span>次
    </span>
    <span id="busuanzi_container_site_uv">
        本站访客数<span id="busuanzi_value_site_uv"></span>人次
    </span>
    </div>
        <span>Copyright © 2020-2024 <a href="#">heliu's blog</a>. All rights reserved</span>  
    
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'Copy';

        function copyingDone() {
            copybutton.innerHTML = 'Done';
            setTimeout(() => {
                copybutton.innerHTML = 'Copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
