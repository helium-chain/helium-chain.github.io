<!DOCTYPE html>
<html lang="zh" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>runtime中重要的结构体 | Helium</title>
<meta name="keywords" content="golang, Goroutine">
<meta name="description" content="💥本文章所有相关go代码参考自go 1.18&#43;版本">
<meta name="author" content="helium">
<link rel="canonical" href="https://heliu.site/posts/golang/goroutine/struct/">
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<meta name="referrer" content="no-referrer-when-downgrade">
<link crossorigin="anonymous" href="/assets/css/stylesheet.css" rel="preload stylesheet" as="style">
<link rel="icon" href="https://heliu.site/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://heliu.site/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://heliu.site/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://heliu.site/apple-touch-icon.png">
<link rel="mask-icon" href="https://heliu.site/apple-touch-icon.png">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="zh" href="https://heliu.site/posts/golang/goroutine/struct/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
<html>
<head>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/jetbrains-mono@1.0.6/css/jetbrains-mono-nl.min.css" />
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lxgw-wenkai-lite-webfont@1.1.0/style.css" />
    <link rel="stylesheet" href="https://cdn.staticfile.org/lxgw-wenkai-screen-webfont/1.6.0/style.css" />
    <style>
        body {
            font-family: "LXGW WenKai Lite", sans-serif;
            font-family: "LXGW WenKai Screen", sans-serif;
        }
    </style>
</head>
</html>

  

<meta property="og:title" content="runtime中重要的结构体" />
<meta property="og:description" content="💥本文章所有相关go代码参考自go 1.18&#43;版本" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://heliu.site/posts/golang/goroutine/struct/" />
<meta property="og:image" content="https://heliu.site/favicon-32x32.png" />
<meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-08-01T00:00:00+00:00" />
<meta property="article:modified_time" content="2024-08-01T00:00:00+00:00" /><meta property="og:site_name" content="Helium" />

<meta name="twitter:card" content="summary_large_image" />
<meta name="twitter:image" content="https://heliu.site/favicon-32x32.png" />
<meta name="twitter:title" content="runtime中重要的结构体"/>
<meta name="twitter:description" content="💥本文章所有相关go代码参考自go 1.18&#43;版本"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Article",
      "item": "https://heliu.site/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Golang 合集",
      "item": "https://heliu.site/posts/golang/"
    }, 
    {
      "@type": "ListItem",
      "position":  3 ,
      "name": "第12章 Goroutine",
      "item": "https://heliu.site/posts/golang/goroutine/"
    }, 
    {
      "@type": "ListItem",
      "position":  4 ,
      "name": "runtime中重要的结构体",
      "item": "https://heliu.site/posts/golang/goroutine/struct/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "runtime中重要的结构体",
  "name": "runtime中重要的结构体",
  "description": "💥本文章所有相关go代码参考自go 1.18+版本",
  "keywords": [
    "golang", "Goroutine"
  ],
  "articleBody": "type g struct 每一个实例对象代表一个goroutine。 该结构体保存CPU寄存器的值以及goroutine的所有信息，包括栈，gobuf结构体和其它的一些状态信息。 调度器代码可以通过g对象来对goroutine进行调度： 当goroutine被调离CPU时，调度器代码负责把CPU寄存器的值保存在g对象的成员变量之中。 当goroutine被调度起来运行时，调度器代码又负责把g对象的成员变量所保存的寄存器的值恢复到CPU的寄存器。 type g struct { // Stack parameters. // stack describes the actual stack memory: [stack.lo, stack.hi). // stackguard0 is the stack pointer compared in the Go stack growth prologue. // It is stack.lo+StackGuard normally, but can be StackPreempt to trigger a preemption. // stackguard1 is the stack pointer compared in the C stack growth prologue. // It is stack.lo+StackGuard on g0 and gsignal stacks. // It is ~0 on other goroutine stacks, to trigger a call to morestackc (and crash). // // goroutine栈以及栈扩容相关信息 // 记录该goroutine使用的栈信息，[lo,hi) stack stack // offset known to runtime/cgo // 被正常的goroutine使用，编译器安插在函数头部的栈增长代码，用它来和SP比较，按需进行栈增长。 // 它的值一般是 stcak.lo + StackGuard，也可能被设置成 StackPreempt，以触发一次抢占。 // const _StackGuard = 928; linux amd64 // const stackPreempt = 0xfffffade; ((1\u003c\u003c64) - 1) \u0026 -1314 stackguard0 uintptr // offset known to liblink // 原理和 stackguard0 差不多，只不过是被 g0 和 gsignal 中的C代码使用。 stackguard1 uintptr // offset known to liblink // _panic 和 _defer 在defer和panic中被使用 // panic链表，记录当前goroutine触发的panic链表 _panic *_panic // innermost panic - offset known to liblink // defer链表，记录整个调用链函数中注册的defer函数链表 _defer *_defer // innermost defer // 关联到正在执行当前G的工作线程M，也就是 type m struct 结构体指针 m *m // current m; offset known to arm liblink // 保存调度信息，主要是几个寄存器的值，g被调离前CPU以及寄存器信息保存在这里，恢复后从这里保存的信息开始 // 被调度器，用来保存 goroutine 的执行上下文。 sched gobuf // 档期前goroutine被调度或者被保存是CPU相关信息存储在这里 // 系统调用进入调用前，保存SP寄存器和IP寄存器的值 syscallsp uintptr// if status==Gsyscall, syscallsp = sched.sp to use during gc syscallpc uintptr// if status==Gsyscall, syscallpc = sched.pc to use during gc // 应为堆栈顶部的sp，用于回溯 stktopsp uintptr// expected sp at top of stack, to check in traceback // param is a generic pointer parameter field used to pass // values in particular contexts where other storage for the // parameter would be difficult to find. It is currently used // in three ways: // 1. When a channel operation wakes up a blocked goroutine, it sets param to // point to the sudog of the completed blocking operation. // 2. By gcAssistAlloc1 to signal back to its caller that the goroutine completed // the GC cycle. It is unsafe to do so in any other way, because the goroutine's // stack may have moved in the meantime. // 3. By debugCallWrap to pass parameters to a new goroutine because allocating a // closure in the runtime is forbidden. // // param是一个通用的指针参数字段，用于在很难找到参数的其他存储的特定上下文中传递值。它目前有三种使用方式： // 1.当通道操作唤醒被阻塞的goroutine时，它将param设置为指向已完成阻塞操作的sudog。 // 2.通过gcAssistAlloc1向其调用方发出信号，表明goroutine完成了GC循环。 // 以任何其他方式这样做都是不安全的，因为goroutine的堆栈可能在此期间发生了移动。 // 3.通过debugCallWrap将参数传递给新的goroutine，因为禁止在运行时分配闭包。 param unsafe.Pointer // passed parameter on wakeup // 用来表示当前G的状态。 atomicstatus uint32 // 记录当前G的状态 stackLock uint32 // sigprof/scang lock; TODO: fold in to atomicstatus // 当前 goroutine 的全局唯一 ID。 goid int64 // schedlink字段指向全局运行队列中的下一个g // 所有位于全局运行队列中的g形成一个链表 // 被调度器用于实现内部链表、队列，对应的 guintptr 类型从逻辑上将等于 *g， // 而底层类型却是个 uintptr，这样是为了避免写屏障。 schedlink guintptr waitsince int64 // g被阻塞的大约时间 waitreason waitReason // if status==Gwaiting // 抢占调度标志，如果需要抢占调度，设置preempt为true // 抢占信号，重复 stackguard0 = stackpreempt // 为true时，调度器会在合适的时机触发一次抢占 preempt bool // preemption signal, duplicates stackguard0 = stackpreempt preemptStop bool // transition to _Gpreempted on preemption; otherwise, just deschedule preemptShrink bool // shrink stack at synchronous safe point\t在同步安全点收缩堆栈 // asyncSafePoint is set if g is stopped at an asynchronous // safe point. This means there are frames on the stack // without precise pointer information. asyncSafePoint bool paniconfault bool // panic (instead of crash) on unexpected fault address gcscandone bool // g has scanned stack; protected by _Gscan bit in status // 不能扩展栈，该值在系统调用前被设置为true，在系统调用返回是设置为false。 throwsplit bool // must not split stack // activeStackChans indicates that there are unlocked channels // pointing into this goroutine's stack. If true, stack // copying needs to acquire channel locks to protect these // areas of the stack. // activeStackChans 表示有未锁定的通道指向这个 goroutines 堆栈 // 如果为true，堆栈复制需要获取通道锁来保护堆栈的这些区域 activeStackChans bool // parkingOnChan indicates that the goroutine is about to // park on a chansend or chanrecv. Used to signal an unsafe point // for stack shrinking. It's a boolean value, but is updated atomically. parkingOnChan uint8\t// 赋值1，表示当前goroutine正在chan上 raceignore int8 // ignore race detection events sysblocktraced bool // StartTrace has emitted EvGoInSyscall about this goroutine tracking bool // whether we're tracking this G for sched latency statistics trackingSeq uint8// used to decide whether to track this G runnableStamp int64// timestamp of when the G last became runnable, only used when tracking runnableTime int64// the amount of time spent runnable, cleared when running, only used when tracking sysexitticks int64// cputicks when syscall has returned (for tracing) traceseq uint64// trace event sequencer tracelastp puintptr// last P emitted an event for this goroutine // 关联到与当前G绑定的M，可以参考下 LockOSThread。 lockedm muintptr sig uint32 writebuf []byte // sigcode0 和 sigcode1 用于临时传参记录 sigcode0 uintptr\t// 记录当前需要跳转的SP地址，比如panic中即将跳转goexit sigcode1 uintptr\t// 记录当前需要跳转的PC地址，比如panic中即将跳转goexit sigpc uintptr // 在创建goroutine时候被保存 gopc uintptr // pc of go statement that created this goroutine // 创建此goroutine的祖先信息goroutine（仅在debug.traceback祖先时使用），在创建goroutin时候被保存 ancestors *[]ancestorInfo // ancestor information goroutine(s) that created this goroutine (only used if debug.tracebackancestors) // goroutine函数的pc。在创建goroutin时候被保存 startpc uintptr // pc of goroutine function racectx uintptr // 标记当前goroutine 0表示主goroutine // 记录让当前goroutine等待的sudog，sudog是chan的等待队列，等待被读，c\u003c-1操作引起当前，该参数在当前goroutine被恢复时判断使用 // Sudog结构这个g正在等待(有一个有效的elem指针);按锁定顺序。 // 主要用于实现 channel 中的等待队列。 waiting *sudog // sudog structures this g is waiting on (that have a valid elem ptr); in lock order cgoCtxt []uintptr// cgo traceback context labels unsafe.Pointer // profiler labels // 缓存 timer 由于 time.Sleep。 timer *timer // cached timer for time.Sleep // selectDone uint32 // are we participating in a select and did someone win the race? // Per-G GC state // gcAssistBytes is this G's GC assist credit in terms of // bytes allocated. If this is positive, then the G has credit // to allocate gcAssistBytes bytes without assisting. If this // is negative, then the G must correct this by performing // scan work. We track this in bytes to make it fast to update // and check for debt in the malloc hot path. The assist ratio // determines how this corresponds to scan work debt. gcAssistBytes int64 // GC信用值 } type stack struct Stack描述了Go的执行栈。栈的边界正好是[lo, hi)，两边都没有隐式的数据结构。 注意栈是向下生长的。 // Stack describes a Go execution stack. // The bounds of the stack are exactly [lo, hi), // with no implicit data structures on either side. type stack struct { lo uintptr // 栈顶，指向内存【低地址】 hi uintptr // 栈底，指向内存【高地址】 } type gobuf struct 保存goroutine的调度信息，应用场景在这goroutine被选中调度起来去执行，或当前goroutine被抢占需要保存CPU信息然后下次接到从此处执行。 用来存储goroutine执行上下文的sched字段需要格外注意，它与goroutine协程切换的底层实现相关。 type gobuf struct { // sp字段存储的是栈指针，rsp寄存器的值 sp uintptr // 保存CPU的SP寄存器的值，存储的是被抢占或调度时CPU信息 // pc字段存储的是指令指针，rip寄存器的值 pc uintptr // 保存CPU的IP寄存器的值 // g字段用来反向关联到对应的G。 g guintptr // 记录当前这个gobuf对象属于那个goroutine // ctxt字段指向闭包对象，也就是说用go关键字创建协程的时候传递的是一个闭包 // 这里会存储闭包对象的地址。rdx寄存器的值 ctxt unsafe.Pointer // 上下文信息 // 保存系统调用的返回值，因为从系统调用返回之后如果p被其他工作线程抢占 // 则这个goroutine会被放入全局运行队列被其他工作线程调度，其他线程需要知道系统调用的返回值 // ret字段用来存储返回值，实际上是利用AX寄存器实现类似C函数的返回值，目前只发现panic-recover机制用到了该字段。 ret sys.Uintreg // lr字段在arm等架构上用来存储返地址，x86没有用到该字段。 lr uintptr // bp字段用来存储栈帧基地址。rbp寄存器的值 bp uintptr // 对于支持帧指针的架构 } G Status // defined constants const ( // goroutine 开始创建的状态，此时尚未初始化完成； _Gidle = iota // 0 // goroutine 在待执行队列中，等待被执行； _Grunnable // 1 // goroutine 正在执行，同一时刻一个P中只有一个g处于此状态； _Grunning // 2 // goroutine 正在执行系统调用； _Gsyscall // 3 // goroutine 处于挂起状态，需要等待被唤醒。gc、channel 或者锁操作时经常会进入这种状态； _Gwaiting // 4 // _Gmoribund_unused is currently unused, but hardcoded in gdb // scripts. _Gmoribund_unused // 5 // goroutine 刚初始化完成或者已经被销毁，会处于此状态； _Gdead // 6 // _Genqueue_unused is currently unused. _Genqueue_unused // 7 // goroutine 正在栈扩容流程中； _Gcopystack // 8 // goroutine 被抢占后的状态 _Gpreempted // 9 // _Gscan与前面的一些状态组合。 // 除了_Gscanrunning外，其他的组合状态都表示GC正在扫描goroutine的栈，goroutine没有在执行用户代码， // 栈的所有权归设置了_Gscan标志位的goroutine所有。 _Gscan = 0x1000 _Gscanrunnable = _Gscan + _Grunnable // 0x1001 // _Gscanrunning在GC通知G扫描栈的时候，它被用来短暂的阻止状态变换，其他方面和_Grunning一样。 // 栈扫描完成后，goroutine将会切换回原来的状态，移除_Gscan标志位。 _Gscanrunning = _Gscan + _Grunning // 0x1002 _Gscansyscall = _Gscan + _Gsyscall // 0x1003 _Gscanwaiting = _Gscan + _Gwaiting // 0x1004 _Gscanpreempted = _Gscan + _Gpreempted // 0x1009 ) type m struct m结构体用来代表工作线程，它保存了m自身使用的栈信息。 当前正在运行的goroutine以及与m绑定的p等信息。 每个工作线程都有唯一的一个m结构体的实例对象与之对应，m结构体对象除了记录着工作线程的诸如栈的起止位置、当前正在执行的goroutine以及是否空闲等等状态信息之外，还通过指针维持着与p结构体的实例对象之间的绑定关系。 于是，通过m既可以找到与之对应的工作线程正在运行的goroutine，又可以找到工作线程的局部运行队列等资源。 只要每个工作线程拥有了各自私有的m结构体全局变量，我们就能在不同的工作线程中使用相同的全局变量名来访问不同的m结构体对象。 type m struct { // 并不是一个真正的goroutine，它的栈是由操作系统分配的， // 初始大小比普通goroutine的栈要大，被用作调度器执行的栈。 // 程序刚初始化启动时第一个g0栈大概有64KB大小，后面的工作线程的g0栈有8KB大小 g0 *g // goroutine with scheduling stack // 记录被调用者信息，在抢占调度中被设置 morebuf gobuf // gobuf arg to morestack divmod uint32 // div/mod denominator for arm - known to liblink // Fields not known to debuggers. // 线程ID，该值在`go1.19.3/src/runtime/os_linux.go:minit`被调用，该方法在mstart函数线程刚启动时初始化。 // 该值默认是一个自增的ID procid uint64 // for debuggers, but offset not hard-coded // 本质上是用来处理信号的栈，因为一些UNIX系统支持为信号处理器配置独立的栈。 gsignal *g // signal-handling g goSigStack gsignalStack // Go-allocated signal handling stack sigmask sigset // storage for saved signal mask // 通过TLS实现m结构体对象与工作线程之前的绑定 // 线程本地存储，存储内容只对当前线程可见。线程本地存储的时m.tls的地址，m.tls[0]存储的是当前运行的g， // 因此线程可以通过g找到当前的m、p、g0等信息。 tls [6]uintptr // thread-local storage (for x86 extern register) mstartfn func() // 工作线程启动后需要执行的函数 // 指向工作线程正在运行的goroutine的g结构体对象，该参数的作用是在切换到g0栈后清除之前的g， // 记录在这里指向的是M当前正在执行的G。 curg *g // current running goroutine caughtsig guintptr // goroutine running during fatal signal // 记录与当前工作线程绑定的p结构体对象 // GMP中的P，即关联到当前M上的处理器。 p puintptr // attached p for executing go code (nil if not executing go code) // 用来将P传递给M，调度器一般是在M阻塞时为m.nextp赋值，等到M开始运行后会尝试从nextp处获取P进行关联。 nextp puintptr // 用来暂存执行系统调用之前关联的P。 oldp puintptr // the p that was attached before executing a syscall // M的唯一id。 id int64 // 当前线程的ID，根据schedt.mnext记录的工作线程个数而设置的 // mallocing = 1，当前goroutine正在分配内存 mallocing int32 throwing int32 // 不为空时表示要关闭对curg的抢占，字符串内容给出了相关的原因。 // 用于控制当前 goroutine 是否可被抢占。 //\t1. 当一个 goroutine 执行一些关键操作时（如获取锁、执行系统调用等），它可能需要暂时关闭抢占，以避免在关键操作期间被抢占导致死锁或竞争条件的发生。 // 2. 程序员可以通过使用 runtime.LockOSThread() 函数来将当前 goroutine 绑定到一个 OS 线程上，从而避免抢占的发生。 // 3. 如果在执行关键操作时需要暂时关闭抢占，可以使用 runtime.LockOSThread() 函数将当前 goroutine 绑定到一个 OS 线程上，并在操作完成后调用 runtime.UnlockOSThread() 函数将其解绑。 preemptoff string // if != \"\", keep curg running on this m // 记录当前M持有锁的数量，不为0时能够阻止抢占发生。 // 用来记录当前 goroutine 持有的互斥锁数量的 // 1. 当 goroutine 持有一个互斥锁时，它不能被抢占，因为如果被抢占了，其他 goroutine 就无法获取该锁。 // 2. 为了避免这种情况的发生，Go 语言的调度器会在检查是否应该抢占当前 goroutine 之前，先检查它是否持有互斥锁。 // 3. 如果当前 goroutine 持有互斥锁，则调度器会暂时将其标记为不可抢占状态，直到该 goroutine 释放锁为止。 // 4. 因此，m.locks 字段是用来辅助调度器实现这一机制的。 // 5. 当一个 goroutine 获取一个互斥锁时，m.locks 字段会被更新，标记该 goroutine 持有相应的互斥锁。 // 6. 当 goroutine 释放锁时，m.locks 字段也会被更新，清除相应的标记。 // 7. 调度器在决定是否应该抢占一个 goroutine 时，会检查该 goroutine 是否持有互斥锁，以此来避免因抢占导致的锁竞争和死锁问题。 locks int32\t// 尝试获取锁的次数，在lock中加一，在unlock减一 dying int32 profilehz int32 // spining状态：表示当前工作线程正在试图从其他工作线程的本地运行队列偷取goroutine // 表示当前M正处于自旋状态。 spinning bool // m is out of work and is actively looking for work\tblocked bool // m is blocked on a note m在note上被屏蔽，表示当前M正在休眠中 newSigstack bool // minit on C thread called sigaltstack printlock int8 incgo bool // m is executing a cgo call freeWait atomic.Uint32 // Whether it is safe to free g0 and delete m (one of freeMRef, freeMStack, freeMWait) // fastrand 用于在一些随机值的使用需要 fastrand uint64 needextram bool traceback uint8 ncgocall uint64 // number of cgo calls in total ncgo int32 // number of cgo calls currently in progress cgoCallersUse uint32 // if non-zero, cgoCallers in use temporarily cgoCallers *cgoCallers // cgo traceback if crashing in cgo call doesPark bool // non-P running threads: sysmon and newmHandoff never use .park // 没有goroutine需要运行时，工作线程睡眠在这个park成员上 // 其他线程通过这个park唤醒该工作线程 // 用来支持M的sleep和wakeup，可以很方便地实现每个M单独sleep和wakeup。 park note // 记录所有工作线程的一个链表 // 把所有的M连起来，构成allm链表。 alllink *m // on allm // 被调度器用于实现链表，如空闲M链表。 schedlink muintptr // 关联到与当前M绑定的G，可参考LockOSThread。 lockedg guintptr createstack [32]uintptr // stack that created this thread. lockedExt uint32 // tracking for external LockOSThread lockedInt uint32 // tracking for internal lockOSThread nextwaitm muintptr // next m waiting for lock waitunlockf func(*g, unsafe.Pointer) bool waitlock unsafe.Pointer waittraceev byte waittraceskip int startingtrace bool syscalltick uint32 // 用来把已经退出运行的M连起来，构成sched.freem链表，方便下次分配时复用。 freelink *m // on sched.freem // mFixup is used to synchronize OS related m state (credentials etc) // use mutex to access. mFixup struct { lock mutex fn func(bool) bool } // these are here because they are too large to be on the stack // of low-level NOSPLIT functions. libcall libcall libcallpc uintptr // for cpu profiler libcallsp uintptr libcallg guintptr syscall libcall // stores syscall parameters on windows vdsoSP uintptr // SP for traceback while in VDSO call (0 if not in call) vdsoPC uintptr // PC for traceback while in VDSO call // preemptGen counts the number of completed preemption // signals. This is used to detect when a preemption is // requested, but fails. Accessed atomically. preemptGen uint32 // Whether this is a pending preemption signal on this M. // Accessed atomically. // // 这个M上是否有一个待处理的抢占信号。原子操作。 // 该参数在 preemptM 函数中从0设置为1。 signalPending uint32 dlogPerM mOS // Up to 10 locks held by this m, maintained by the lock ranking code. locksHeldLen int locksHeld [10]heldLockInfo } type p struct p结构体用于保存工作线程执行go代码时所必需的资源。 比如goroutine的运行队列，内存分配用到的缓存，局部goroutien运行队列等等。 type p struct { // P的位移ID，等于当前P在allp数组中的下标。 id int32 // 当前P所处状态，也就是当前P上的g的状态 status uint32 // one of pidle/prunning/... // link是一个没有写屏障的指针，被调度器用来构造链表 link puintptr // 在每次调度器调用时递增，记录当前P的调度次数 // 记录调度发生的次数，实际上在每发生一次goroutine切换且不继承时间片的情况下，该字段会加一。 schedtick uint32 // incremented on every scheduler call // 在每次系统调用时递增，记录当前P的系统调用次数 // 发生每一次系统调用就会加一。 syscalltick uint32 // incremented on every system call // sysmon观察到的最后一个时钟信号 // 该值被用于sysmon线程记录被监控p的系统调用时间和运行时间，注意这里是与sysmon相关的 // type sysmontick struct { //\tschedtick uint32 //\tschedwhen int64 //\tsyscalltick uint32 //\tsyscallwhen int64 // } // 被监控线程用来存储上一次检查时的调度器时钟滴答，用于实现时间片算法。 sysmontick sysmontick // last tick observed by sysmon // 本质上是个指针，反向关联到当前P绑定的M。 m muintptr // back-link to associated m (nil if idle) mcache *mcache\t// p的内存模块管理 pcache pageCache raceprocctx uintptr // 用于缓存*_defer接口，避免频繁堆分配 deferpool []*_defer // pool of available defer structs of different sizes (see panic.go) // 根据源码中 pp.deferpool = pp.deferpoolbuf[:0] 可知，deferpoolbuf只是作为deferpool的内存地址在使用 deferpoolbuf [32]*_defer // Cache of goroutine ids, amortizes accesses to runtime·sched.goidgen. // 用来从全局sched,goidgen处生气goid分配区间，批量申请以减少全局范围的锁竞争用。 goidcache uint64 goidcacheend uint64 // Queue of runnable goroutines. Accessed without lock. // 本地goroutine运行队列 // 当前P的就绪队列，用一个数组和一头一尾两个下标实现了一个环型队列。 runqhead uint32\t// 队列头 runqtail uint32\t// 队列尾 runq [256]guintptr // 使用数组实现的循环队列 // runnext, if non-nil, is a runnable G that was ready'd by // the current G and should be run next instead of what's in // runq if there's time remaining in the running G's time // slice. It will inherit the time left in the current time // slice. If a set of goroutines is locked in a // communicate-and-wait pattern, this schedules that set as a // unit and eliminates the (potentially large) scheduling // latency that otherwise arises from adding the ready'd // goroutines to the end of the run queue. // // 如果不为nil，则指向一个被当前G准备好(就绪)的G，接下来将会继承当前G的时间片开始运行。 // 该字段存在的意义在于，假如有一组goroutine中有生产者和消费者，它们在一个channel上频繁的等待、唤醒， // 那么调度器会把它们作为一个单元来调度。每次使用runnext比添加到本地runq尾部能大幅减少延迟。 runnext guintptr\t// 记录着下一个将要执行的goroutine // Available G's (status == Gdead) // 记录着所有状态为Gdead的空闲的goroutine链表 // go关键字配的时候优先从这里获取，goroutine执行完时保存在这里 // 用来缓存已经退出运行的G，方便再次分配时进行复用。 gFree struct { gList\t// type gList struct {head guintptr}\tguintptr是uintputr的自定义类型 n int32\t// 记录着当前空闲的g的数量 } sudogcache []*sudog sudogbuf [128]*sudog // Cache of mspan objects from the heap. mspancache struct { // We need an explicit length here because this field is used // in allocation codepaths where write barriers are not allowed, // and eliminating the write barrier/keeping it eliminated from // slice updates is tricky, moreso than just managing the length // ourselves. len int buf [128]*mspan } tracebuf traceBufPtr // traceSweep indicates the sweep events should be traced. // This is used to defer the sweep start event until a span // has actually been swept. traceSweep bool // traceSwept and traceReclaimed track the number of bytes // swept and reclaimed by sweeping in the current sweep loop. traceSwept, traceReclaimed uintptr palloc persistentAlloc // per-P to avoid mutex // 用于下面字段对齐 _ uint32 // Alignment for atomic fields below // 以下timer0When和timerModifiedEarliest字段维护这这个P的执行时间，也是用于抢断判断依据 // The when field of the first entry on the timer heap. // This is updated using atomic functions. // This is 0 if the timer heap is empty. // timer 堆上第一个条目的 when 字段。 // 这是使用原子函数更新的 // 如果 timer 堆为空，则为 0 timer0When uint64\t// 堆顶元素什么时候执行 // The earliest known nextwhen field of a timer with // timerModifiedEarlier status. Because the timer may have been // modified again, there need not be any timer with this value. // This is updated using atomic functions. // This is 0 if the value is unknown. // 具有 timerModifiedEarlier 状态的定时器的最早已知 nextwhen 字段。 // 因为定时器可能已经被再次修改，所以不需要任何具有该值的timer // 这是使用原子函数更新的 // 如果没有 timerModifiedEarlier 计时器，则为 0 timerModifiedEarliest uint64\t// 如果有timer修改为更早执行时间了，将执行时间更新到当更早时间 // Per-P GC state gcAssistTime int64 // Nanoseconds in assistAlloc gcFractionalMarkTime int64 // Nanoseconds in fractional mark worker (atomic) // gcMarkWorkerMode is the mode for the next mark worker to run in. // That is, this is used to communicate with the worker goroutine // selected for immediate execution by // gcController.findRunnableGCWorker. When scheduling other goroutines, // this field must be set to gcMarkWorkerNotWorker. gcMarkWorkerMode gcMarkWorkerMode // gcMarkWorkerStartTime is the nanotime() at which the most recent // mark worker started. gcMarkWorkerStartTime int64 // gcw is this P's GC work buffer cache. The work buffer is // filled by write barriers, drained by mutator assists, and // disposed on certain GC state transitions. gcw gcWork // wbBuf is this P's GC write barrier buffer. // // TODO: Consider caching this in the running G. wbBuf wbBuf runSafePointFn uint32 // if 1, run sched.safePointFn at next safe point // statsSeq is a counter indicating whether this P is currently // writing any stats. Its value is even when not, odd when it is. statsSeq uint32 // Lock for timers. We normally access the timers while running // on this P, but the scheduler can also do it from a different P. // 锁定timers。我们通常在此P上运行时访问timers，但调度程序也可以从不同的P上执行此操作 timersLock mutex\t// 操作timer的互斥锁 // Actions to take at some time. This is used to implement the // standard library's time package. // Must hold timersLock to access. // 必须持有 timersLock 才能访问 // 当前关于P的timer，可能出现当前P中很多goroutine被挂在不同的timer上 timers []*timer\t// 该P上的所有timer，必须加锁去操作这个字段，因为不同的P操作这个字段会有竞争 // Number of timers in P's heap. // Modified using atomic instructions. // P 堆中的timers数量，使用原子指令修改 numTimers uint32\t// P堆上所有的timer数量 // Number of timerModifiedEarlier timers on P's heap. // This should only be modified while holding timersLock, // or while the timer status is in a transient state // such as timerModifying. // P 的堆上 timerModifiedEarlier 计时器的数量 // 这只应在持有 timersLock 时修改，或者当定时器状态处于诸如 timerModifying 之类的瞬态状态时进行修改 adjustTimers uint32 // Number of timerDeleted timers in P's heap. // Modified using atomic instructions. // P 的堆中 timerDeleted timers的数量 // 使用原子指令修改 deletedTimers uint32\t// 被标记为删除的timer，要么是我们调用stop，要么是timer自己触发后过期导致的删除 // Race context used while executing timer functions. timerRaceCtx uintptr // preempt is set to indicate that this P should be enter the // scheduler ASAP (regardless of what G is running on it). // preempt 设置为指示该 P 应尽快进入调度程序（无论 G 在其上运行什么） // 在GO1.14版本被引入，以支持新的异步抢占机制。 preempt bool pad cpu.CacheLinePad } P Status const ( // P status // _Pidle means a P is not being used to run user code or the // scheduler. Typically, it's on the idle P list and available // to the scheduler, but it may just be transitioning between // other states. // // The P is owned by the idle list or by whatever is // transitioning its state. Its run queue is empty. // // 空闲状态。此时的P没有被用来执行用户代码或调度器代码，通常位于空闲链表中，能够被调度器获取， // 它的状态可能正在由空闲转变成其他状态。P的所有权归空闲链表或某个正在改变它状态的线程所有，本地runq为空。 _Pidle = iota // 空闲状态 // _Prunning means a P is owned by an M and is being used to // run user code or the scheduler. Only the M that owns this P // is allowed to change the P's status from _Prunning. The M // may transition the P to _Pidle (if it has no more work to // do), _Psyscall (when entering a syscall), or _Pgcstop (to // halt for the GC). The M may also hand ownership of the P // off directly to another M (e.g., to schedule a locked G). // // 运行中状态。当前P正被某个M持有，并且用于执行用户代码或调度器代码。 // 只有持有P所有权的M，才被允许将P的状态从_Prunning转变为其他状态。 // 在任务都执行完以后，M会把P设置为_Pidle状态。在进入系统调用时，M会把P设置为_Psyscall状态。 // 挂起以执行GC时，会设置为_Pgcstop状态。某些情况下，M还可能会直接把P的所有权交给另一个M。 _Prunning // 运行中状态 // _Psyscall means a P is not running user code. It has // affinity to an M in a syscall but is not owned by it and // may be stolen by another M. This is similar to _Pidle but // uses lightweight transitions and maintains M affinity. // // Leaving _Psyscall must be done with a CAS, either to steal // or retake the P. Note that there's an ABA hazard: even if // an M successfully CASes its original P back to _Prunning // after a syscall, it must understand the P may have been // used by another M in the interim. // // 系统调用状态。此时的P没有执行用户代码，它和一个处于syscall中的M间存在弱关联关系，可能会被另外一个M窃取走。 _Psyscall // 系统调用中状态 // _Pgcstop means a P is halted for STW and owned by the M // that stopped the world. The M that stopped the world // continues to use its P, even in _Pgcstop. Transitioning // from _Prunning to _Pgcstop causes an M to release its P and // park. // // The P retains its run queue and startTheWorld will restart // the scheduler on Ps with non-empty run queues. // // GC停止状态。P被STW挂起以执行GC，所有权归执行STW的M所有，执行STW的M会继续使用处于_Pgcstop状态的P。 // 当P的状态从_Prunning转变成_Pgcstop时，会造成关联的M释放P的所有权，然后进入阻塞状态。 // P会保留它的本地runq，然后Start The World会从新启动这些本地runq不为空的P。 _Pgcstop // GC停止状态 // _Pdead means a P is no longer used (GOMAXPROCS shrank). We // reuse Ps if GOMAXPROCS increases. A dead P is mostly // stripped of its resources, though a few things remain // (e.g., trace buffers). // // 停用状态。因为GOMAXPROCS收缩，会造成多余的P被停用，当GOMAXPROCS再次增大时还会被复用。 // 一个停用的P，大部分资源被剥夺，只有很少量保留。 _Pdead // 停用状态 ) type schedt struct schedt结构体用来保存调度器的状态信息和(可运行或空闲的)goroutine的容器以及保存goroutine的运行队列 每个Go程序中只有一个调度器，多以每个Go程序中schedt结构体只有一个实例对象，该实例对象在源代码中被定义成了一个共享的全局变量 这样每个工作线程都可以访问它以及它所拥有的goroutine运行队列，我们称这个运行队列为全局goroutine运行队列 全局运行队列是每个工作线程都可以读写的，因此访问它需要加锁，然而在一个繁忙的系统中，加锁会导致严重的性能问题 于是又为每个工作线程引入一个私有的局部goroutine运行队列，工作线程优先使用自己的局部运行队列，只有必要时才会去访问全局运行队列 这大大减少了锁冲突，提高了工作线程的并发性 在Go调度器源代码中，局部运行队列被包含在p结构体的实例对象之中，每一个运行着go代码的工作线程都会与一个p结构体的实例对象关联在一起 type schedt struct { // accessed atomically. keep at top to ensure alignment on 32-bit systems. // 用作全局的goid分配器，以保证goid的唯一性。 // P中的goidcache就是从这里批量分配获取goid的。 goidgen uint64 // 以下两个字段可以在IO轮询时判断是否有需要的timer已到时间需要去执行 // 上次网络轮询的时间点，如果当前轮询，则为 0 // 记录的是上次执行netpoll的时间，如果等于0，则表示某个线程正在阻塞式地执行netpoll。 lastpoll uint64 // time of last network poll, 0 if currently polling // 下次timer应该被唤醒时间点，来自timer四叉数中的时间 // 表示阻塞式地netpoll将在何时被唤醒。GO1.14版本重构了Timer，引入了该字段，唤醒netpoller以处理Timer。 pollUntil uint64 // time to which current poll is sleeping // 全局范围的调度器锁，访问sched中的很多字段需要提前获得该锁。 lock mutex // When increasing nmidle, nmidlelocked, nmsys, or nmfreed, be // sure to call checkdead(). // 有空闲的工作线程M组成的链表 // 空闲M链表的链表头，nmidle记录的是空闲M的数量，即链表的长度。 midle muintptr // idle m's waiting for work // 空闲的工作线程数量 nmidle int32 // number of idle m's waiting for work // 统计的是与G绑定(LockOSThread)且处于空闲状态的M，绑定的G没有在运行，相应的M不能用来运行其他G，只能挂起，以便进入空闲状态。 nmidlelocked int32 // number of locked m's waiting for work // 下一个工作线程M的ID值 // 记录了共创建了多少个M，同时也被用作下一个M的ID。 mnext int64 // number of m's that have been created and next M ID // 最多只能创建maxmcount个工作线程M，初始化时该值为10000，schedinit()中被设置。 // 限制了最多允许的M的个数，除去那些已经释放的。 maxmcount int32 // maximum number of m's allowed (or die) // 统计的是系统M的个数。比如监控线程sysmon启动时会 nmsys++。 nmsys int32 // number of system m's not counted for deadlock // 统计的是累计已经释放了所少M。 nmfreed int64 // cumulative number of freed m's // 记录的是系统goroutine的数量，会被原子性的更新。 ngsys uint32 // 系统 goroutine 的数量； 原子更新 // 由空闲的p结构体对象组成的链表 // 空闲P链表的表头，npidle记录了空闲P的个数，也就是链表的长度。 pidle puintptr // idle p's // 空闲的p结构体对象的数量 npidle uint32 // 正在自旋的M的数量 // 记录的是处于自旋状态的M的数量。 nmspinning uint32 // See \"Worker thread parking/unparking\" comment in proc.go. // Global runnable queue. // goroutine全局运行队列，全局的就绪队列。 runq gQueue // 记录的是全局就绪队列的长度。也就是全局队列goroutine的个数。 runqsize int32 // disable controls selective disabling of the scheduler. // // Use schedEnableUser to control this. // // disable is protected by sched.lock. // // 用来禁止调度用户goroutine，其中的user变量被置为true后，调度器将不在调度执行用户goroutine， // 系统goroutine不受影响。期间就绪的用户gouroutine会被临时存储放到disable.runnable队列中，变量n记录了队列长度。 // GC期间。 disable struct { // user disables scheduling of user goroutines. user bool runnable gQueue // pending runnable Gs n int32 // length of runnable } // Global cache of dead G's. // gFree是所有已退出的goroutine对应的g结构体对象组成的链表 // 用于缓存g结构体对象，避免每次创建gouroutine时都重新分配内存 // 用来存储已经退出运行的G，lock是本结构单独的锁，避免争用sched.lock。stack和noStack这两个列表分别用来存储有栈的G，因为在 // G结束运行被回收的时候，如果栈大小超过了标准大小，就会被释放，所以有一部分G是没有栈的。变量n是两个列表之和，也就是总缓存了多少个G。 gFree struct { lock mutex stack gList // Gs with stacks noStack gList // Gs without stacks n int32 } // Central cache of sudog structs. // 构成了 sudog 结构的中央缓存，供各个P存储。 sudoglock mutex sudogcache *sudog // Central pool of available defer structs of different sizes. // 构成了 _defer 结构的中央缓存。 deferlock mutex deferpool [5]*_defer // freem is the list of m's waiting to be freed when their // m.exited is set. Linked through m.freelink. // freem 是设置 m.exited 时等待释放的 m 的列表。 通过 m.freelink 链接。 // 一组已经结束运行的M构成的链表头，通过m.freem链接到下一个项，链表中的内容在分配新的M时会被复用。 freem *m // 表示GC正在等待运行，和stopwait、stopnote一同被用于实现STW。 // stopwait记录了STW需要停止的P的数量，发起STW的线程会先把GOMAXPROCS赋值给stopwait，也就是需要停止所有的P。 // 再把gcwaiting置为1，然后再stopnote上睡眠等待被唤醒。其他正在运行的M检测到gcwaiting后会释放关联P的所有权，并把P的状态 // 置为_Pgcstop，再把stopwait的值减1，然后M把自己挂起。M在自我挂起之前如果检测到stopwait==0，也就是所有P都已经停止了， // 就会通过stopnote唤醒发起STW的线程。 gcwaiting uint32 // gc is waiting to run; GC是否正在处于等待 stopwait int32 stopnote note // sysmonwait的值为0或1，表示sysmon线程是否sleep。 // 1. 0时，sysmon没有sleep。 // 2. 1时，sysmon在sysmonnote上sleep。 // 当STW时sysmon可能会挂在sysmonnote上，在STW退出时会唤醒sysmon。 // 当所有P都空闲(可能是陷入系统调用中)，sysmon可能会挂在 sysmonwait uint32 sysmonnote note // While true, sysmon not ready for mFixup calls. // Accessed atomically. // 表示主线程已经创建了监控线程sysmon，但是后者尚未开始运行，某些操作需要等到sysmon启动之后才能进行。 sysmonStarting uint32 // safepointFn should be called on each P at the next GC // safepoint if p.runSafePointFn is set. // 如果设置了 p.runSafePointFn，则应该在下一个 GC 安全点对每个 P 调用 safepointFn // 是一个Function Value.safePointWait 和 Value.safePointNote的左右类似stopwait和stopnone，被runtime.forEachP用来确保每个P都在 // 下一个GC安全点执行了 safePointFn。 safePointFn func(*p) safePointWait int32 safePointNote note // 用来设置性能分析的采样频率。 profilehz int32 // cpu profiling rate // 最后一次改变gomaxprocs的时间，参看procresize()函数 // 统计了改变GOMAXPROCS所花费的时间。 procresizetime int64 // nanotime() of last change to gomaxprocs totaltime int64 // ∫gomaxprocs dt up to procresizetime // sysmonlock protects sysmon's actions on the runtime. // // Acquire and hold this mutex to block sysmon from interacting // with the rest of the runtime. // 监控线程sysmon访问runtime数据时会加上的锁，其他线程可以通过它和监控线程进行同步。 sysmonlock mutex } 重要的全局变量 var ( allgs []*g\t// 保存所有的g allm *m // 所有的m构成的一个链表，包括下面的m0 allp []*p // 保存所有的p，len(allp) == gomaxprocs ncpu int32 // 系统中cpu核的数量，程序启动时由runtime代码初始化 gomaxprocs int32 // p的最大值，默认等于ncpu，但可以通过GOMAXPROCS修改 sched schedt // 调度器结构体对象，记录了调度器的工作状态 m0 m // 代表进程的主线程 g0 g // m0的g0，也是m0.g0 = \u0026g0 // Information about what cpu features are available. // Packages outside the runtime should not use these // as they are not an external api. // Set on startup in asm_{386,amd64}.s processorVersionInfo uint32 // CPU厂商信息，能根据该标识找到对应厂商 isIntel bool // true.当前处理器信息是英特，false.不是英特处理器 ) ",
  "wordCount" : "3734",
  "inLanguage": "zh",
  "image": "https://heliu.site/favicon-32x32.png","datePublished": "2024-08-01T00:00:00Z",
  "dateModified": "2024-08-01T00:00:00Z",
  "author":[{
    "@type": "Person",
    "name": "helium"
  }],
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://heliu.site/posts/golang/goroutine/struct/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Helium",
    "logo": {
      "@type": "ImageObject",
      "url": "https://heliu.site/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://heliu.site/" accesskey="h" title="Blog (Alt + H)">
                <img src="https://heliu.site/helium.png" alt="" aria-label="logo"
                    height="35">Blog</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://heliu.site/" title="主页">
                    <span>Home</span>
                </a>
            </li>
            <li>
                <a href="https://heliu.site/posts" title="文章">
                    <span>Article</span>
                </a>
            </li>
            <li>
                <a href="https://heliu.site/archives" title="时间轴">
                    <span>Archive</span>
                </a>
            </li>
            <li>
                <a href="https://heliu.site/tags/" title="标签">
                    <span>Tag</span>
                </a>
            </li>
            <li>
                <a href="https://heliu.site/search/" title="搜索 (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
            <li>
                <a href="https://heliu.site/support" title="打赏">
                    <span>🫶Help</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">


<article class="post" autonumbering>
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://heliu.site/">主页</a>&nbsp;»&nbsp;<a href="https://heliu.site/posts/">Article</a>&nbsp;»&nbsp;<a href="https://heliu.site/posts/golang/">Golang 合集</a>&nbsp;»&nbsp;<a href="https://heliu.site/posts/golang/goroutine/">第12章 Goroutine</a></div>
    <h1 class="post-title entry-hint-parent">
      runtime中重要的结构体
    </h1>
    <div class="post-description">
      💥本文章所有相关go代码参考自go 1.18&#43;版本
    </div>
    <div class="post-meta">










<span class="x-post-meta-item"><svg t="1720837714681" class="icon" viewBox="0 0 1084 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="7520" width="200" height="200"><path d="M123.47509 1023.984942a123.565437 123.565437 0 0 1-123.505206-123.32451V243.863302A123.565437 123.565437 0 0 1 123.47509 120.568908h171.630374V26.06529a26.050232 26.050232 0 0 1 52.070349 0v94.503618h377.592848V26.06529a26.050232 26.050232 0 0 1 52.100464 0v94.503618h183.797189A123.565437 123.565437 0 0 1 1084.171519 243.863302v656.79713A123.565437 123.565437 0 0 1 960.666314 1023.984942H123.47509z m-71.404741-123.32451A71.434857 71.434857 0 0 0 123.47509 971.974825h837.191224a71.434857 71.434857 0 0 0 71.404741-71.314393V442.326922l-946.361273-3.824716a25.598494 25.598494 0 0 1-5.84248-0.692665l-27.796953-6.444798v469.295689zM123.47509 172.579025a71.434857 71.434857 0 0 0-71.404741 71.284277v149.736133l27.796953-6.444797a26.080348 26.080348 0 0 1 5.902712-0.662549l946.301041 3.824716V243.863302a71.404741 71.404741 0 0 0-71.404741-71.284277h-180.183284l-6.173754 12.859479a26.200812 26.200812 0 0 1-23.490383 14.786895 26.261043 26.261043 0 0 1-23.520499-14.786895l-6.173754-12.859479H350.819834l-6.173754 12.859479a26.200812 26.200812 0 0 1-23.490383 14.786895 26.230928 26.230928 0 0 1-23.520499-14.786895l-6.173755-12.859479H123.47509z m156.150814 578.827128a26.050232 26.050232 0 0 1-26.050232-25.990001c0-14.335157 11.68496-26.020116 26.050232-26.020116h521.697312c14.365273 0 26.050232 11.68496 26.050233 26.020116a26.050232 26.050232 0 0 1-26.050233 25.990001H279.625904z" fill="#3D3F42" p-id="7521"></path></svg><span>2024-08-01</span></span>&nbsp;<span class="x-post-meta-item"><svg t="1720839329181" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="14106" width="200" height="200"><path d="M699.270662 190.485379c-0.411369 0-0.821715 0.011256-1.227967 0.032746H507.034407a23.041786 23.041786 0 0 0-1.221828-0.031723c-12.779048 0-23.140023 10.359952-23.140023 23.139 0 12.781094 10.360975 23.141046 23.140023 23.141046v0.032746h193.458083v-0.032746c12.780071 0 23.141046-10.359952 23.141047-23.141046 0-12.780071-10.360975-23.140023-23.141047-23.140023zM979.215516 724.005508c0-142.090159-115.186416-257.277598-257.277598-257.277598-72.245418 0-137.532353 29.777187-184.262654 77.725223l45.868677 31.474852c36.227086-33.873482 84.882226-54.617945 138.393977-54.617945 111.945605 0 202.696492 90.750887 202.696492 202.695468h-43.01263l70.331835 104.289228 70.331835-104.289228H979.215516z" fill="" p-id="14107"></path><path d="M748.885664 588.843132c0-14.881942-12.06785-26.945699-26.947746-26.945698-14.883989 0-26.947745 12.063757-26.947745 26.945698v135.164423c0 14.879895 12.063757 26.945699 26.947745 26.945699h107.786889c14.881942 0 26.945699-12.063757 26.945698-26.945699s-12.063757-26.945699-26.945698-26.945699h-80.839143V588.843132zM721.937918 926.702c-111.947651 0-202.696492-90.74884-202.696492-202.696492 0-0.144286 0.004093-0.285502 0.004094-0.429788h43.004443l-70.330812-104.289228-70.331835 104.289228h43.075051c0 0.144286-0.00307 0.285502-0.00307 0.429788 0 142.091182 115.187439 257.279644 257.278621 257.279645 72.241324 0 137.530306-29.77821 184.260607-77.727269l-45.86663-31.474852c-36.227086 33.873482-84.884272 54.618968-138.393977 54.618968zM694.633039 423.38066c-1.354857-11.487635-11.120268-20.400632-22.972201-20.400632H206.362486c-12.780071 0-23.140023 10.359952-23.140023 23.138999 0 12.781094 10.359952 23.141046 23.140023 23.141047H596.949252c30.209022-13.81668 63.104223-22.76754 97.683787-25.879414zM438.548616 623.143333H206.362486c-12.780071 0-23.140023 10.358929-23.140023 23.140023 0 12.780071 10.359952 23.140023 23.140023 23.140023h219.956598a298.463626 298.463626 0 0 1 12.229532-46.280046zM506.934123 513.062192H206.362486c-12.780071 0-23.140023 10.359952-23.140023 23.139 0 12.781094 10.359952 23.140023 23.140023 23.140023H469.936487a302.241672 302.241672 0 0 1 36.997636-46.279023z" fill="" p-id="14108"></path><path d="M442.765661 835.277778a298.531164 298.531164 0 0 1-14.365173-46.150087H146.542052v-0.065491c-33.036417 0-59.81941-26.78197-59.81941-59.819411V329.36031h704.907545v100.905154a298.561863 298.561863 0 0 1 46.150086 14.996552V194.619536h-0.162706c0-53.422723-43.307342-96.728018-96.730065-96.728018h-68.89409V84.418668c0-33.037441-26.782993-59.81941-59.81941-59.81941v-0.361227h-18.87079v0.032745c-33.038464 0-59.820434 26.78197-59.820433 59.819411 0 0.109494 0.008186 0.218988 0.008186 0.328481h-0.339738v13.47285H345.203648V84.418668c0-33.037441-26.782993-59.81941-59.819411-59.81941v-0.361227h-18.872836v0.032745c-33.036417 0-59.81941 26.78197-59.81941 59.819411 0 0.109494 0.007163 0.218988 0.008186 0.328481h-0.339737v13.47285h-69.189826c-53.4217 0-96.729042 43.306318-96.729041 96.728018 0 1.701758 0.045025 3.39226 0.132006 5.071505v533.785166a98.051153 98.051153 0 0 0-0.132006 5.071506c0 53.4217 43.307342 96.728018 96.729041 96.728018v0.001023h305.595047zM86.723665 204.056466c0-33.037441 26.782993-59.81941 59.819411-59.819411 0.044002 0 0.086981 0.00307 0.130983 0.00307v-0.068561h105.968473V94.874811h0.032746a22.807449 22.807449 0 0 1-0.032746-1.215688c0-12.779048 10.360975-23.140023 23.140023-23.140023s23.140023 10.360975 23.140023 23.140023c0 0.408299-0.010233 0.812505-0.031722 1.215688h0.031722v49.297776h280.508696V94.874811h0.032745a22.807449 22.807449 0 0 1-0.032745-1.215688c0-12.779048 10.361999-23.140023 23.140023-23.140023 12.780071 0 23.141046 10.360975 23.141046 23.140023 0 0.408299-0.011256 0.812505-0.032746 1.215688h0.032746v49.297776h106.10048v0.065492c33.035394 0 59.818387 26.780947 59.818387 59.81941h0.130983V283.080264H86.723665v-79.023798z" fill="" p-id="14109"></path></svg><span>2024-08-01</span></span>&nbsp;<span class="x-post-meta-item"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2" fill="none"
     stroke-linecap="round" stroke-linejoin="round" class="feather feather-file-text" style="user-select: text;">
    <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z" style="user-select: text;"></path>
    <polyline points="14 2 14 8 20 8" style="user-select: text;"></polyline>
    <line x1="16" y1="13" x2="8" y2="13" style="user-select: text;"></line>
    <line x1="16" y1="17" x2="8" y2="17" style="user-select: text;"></line>
    <polyline points="10 9 9 9 8 9" style="user-select: text;"></polyline>
</svg><span>3734字</span></span>&nbsp;<span class="x-post-meta-item"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2" fill="none"
     stroke-linecap="round" stroke-linejoin="round">
    <path stroke="none" d="M0 0h24v24H0z" fill="none"></path>
    <circle cx="12" cy="12" r="9"></circle>
    <polyline points="12 7 12 12 15 15"></polyline>
</svg><span>18分钟</span></span>&nbsp;<span class="x-post-meta-item"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2" fill="none"
     stroke-linecap="round" stroke-linejoin="round">
    <path stroke="none" d="M0 0h24v24H0z" fill="none"></path>
    <circle cx="12" cy="7" r="4"></circle>
    <path d="M6 21v-2a4 4 0 0 1 4 -4h4a4 4 0 0 1 4 4v2"></path>
</svg><span>helium</span></span>
      <span class="x-post-meta-item">
        &nbsp;<svg t="1720840393161" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="18680" width="200" height="200"><path d="M995.125144 559.61812l-415.998603-415.998602A52.986489 52.986489 0 0 0 541.413335 127.99957H338.847348c-3.166656-26.559911-9.286635-51.046495-17.999939-71.333094C299.734146 7.333309 271.154242 0 256.00096 0c-13.939953 0-40.439864 6.339979-61.259794 48.806503-10.473298 21.366595-17.946606 48.966502-21.573261 79.193067H53.334974a53.393154 53.393154 0 0 0-53.333154 53.333154v360.078791a52.986489 52.986489 0 0 0 15.619948 37.713206l415.998602 415.998603a53.333154 53.333154 0 0 0 75.426413 0l26.286579-26.293245 26.286578 26.293245a53.426487 53.426487 0 0 0 16.719944 11.333295 21.333262 21.333262 0 0 0 36.079879 11.293295l382.705381-382.705381a53.399821 53.399821 0 0 0 0-75.426413z m-762.070774-491.998347C241.494342 50.373164 250.667645 42.666523 256.00096 42.666523c5.99998 0 16.573278 9.639968 25.646581 30.806564 6.493312 15.159949 11.333295 33.999886 14.146619 54.526483H216.16776c3.206656-23.419921 9.013303-44.359851 16.88661-60.41313z m243.819181 897.330319a10.666631 10.666631 0 0 1-15.079949 0l-415.998603-415.998603A10.573298 10.573298 0 0 1 42.668343 541.411515V181.332724a10.666631 10.666631 0 0 1 10.666631-10.666631h245.332509c0 47.853173-10.373298 92.15969-27.066575 115.632945-5.926647 8.326639-16.566611 14.186619-22.306592 16.113279C204.041135 314.752276 170.667913 356.218803 170.667913 405.331972c0 58.813136 47.853173 106.666308 106.666309 106.666308s106.666308-47.853173 106.666308-106.666308c0-47.086508-30.666564-87.139707-73.079754-101.246327C330.060711 272.705751 341.334007 223.692582 341.334007 170.666093h72.079758a10.573298 10.573298 0 0 1 7.539974 3.126656l415.998603 415.998603a10.666631 10.666631 0 0 1 0 15.079949zM341.334007 405.331972a63.999785 63.999785 0 1 1-63.999785-63.999785 64.073118 64.073118 0 0 1 63.999785 63.999785z m263.539114 559.61812a10.666631 10.666631 0 0 1-15.079949 0L563.499927 938.663513l303.625647-303.61898a53.399821 53.399821 0 0 0 0-75.426413L478.16688 170.666093h63.246455a10.573298 10.573298 0 0 1 7.539974 3.126656l415.998603 415.998603c0.239999 0.239999 0.466665 0.486665 0.666664 0.746664l0.086667 0.106666a10.666631 10.666631 0 0 1 0 13.373289l-0.086667 0.106666c-0.213333 0.259999-0.439999 0.506665-0.666664 0.746664z" fill="#5C5C66" p-id="18681"></path></svg>
        <ul class="post-tags-meta" style="display: inline-block;font-size: 14px;">
            <a href="https://heliu.site/tags/golang/" target="_blank" rel="noopener">Golang</a>
            <a href="https://heliu.site/tags/goroutine/" target="_blank" rel="noopener">Goroutine</a>
        </ul>
      </span>
      
      <span id="busuanzi_container_page_pv" class="x-post-meta-item">
        &nbsp;<svg t="1720844685710" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="27237" width="200" height="200"><path d="M739.754667 574.08c-121.386667 45.610667-208.469333 169.813333-208.64 316.16 0 33.408 4.693333 65.493333 13.141333 95.914667H94.122667c-26.453333-43.52-41.685333-91.946667-41.685334-143.189334 0-185.173333 192.896-335.104 430.805334-335.104 96.256 0 184.832 24.746667 256.512 66.218667z m-280.490667-114.986667a214.869333 214.869333 0 0 1-214.869333-215.04A215.04 215.04 0 0 1 459.264 28.842667a215.04 215.04 0 0 1 215.04 215.210666 215.04 215.04 0 0 1-215.04 215.04zM974.506667 641.28c9.856 0 17.834667 7.466667 17.834666 16.64v59.989333c-0.341333 8.789333-7.850667 15.786667-17.28 16.085334-9.856 0.341333-18.176-6.826667-18.517333-16.085334v-20.053333l-99.114667 91.093333-0.256 0.256a18.474667 18.474667 0 0 1-14.848 4.352h-0.768a18.176 18.176 0 0 1-9.344-4.608l-0.938666-0.981333-85.930667-80.042667-123.562667 115.072a18.773333 18.773333 0 0 1-25.216 0 15.786667 15.786667 0 0 1 0-23.466666l136.149334-126.848 0.725333-0.597334a18.645333 18.645333 0 0 1 24.362667 0.512l87.253333 81.237334 86.058667-79.232h-21.248c-9.386667-0.298667-16.938667-7.338667-17.28-16.085334-0.341333-9.173333 7.381333-16.896 17.28-17.237333h64.64z m-367.146667 240h48.128c8.874667 0 16.042667 7.168 16.042667 16.042667v72.192a16.042667 16.042667 0 0 1-16.042667 16.042666h-48.128a16.042667 16.042667 0 0 1-16.042667-16.042666v-72.192c0-8.874667 7.210667-16.042667 16.042667-16.042667z m110.805333-106.666667h48.128c8.874667 0 16.042667 7.168 16.042667 16.042667v178.858667a16.042667 16.042667 0 0 1-16.042667 16.042666h-48.128a16.042667 16.042667 0 0 1-16.042666-16.042666v-178.858667c0-8.874667 7.168-16.042667 16.042666-16.042667z m106.538667 80h48.128c8.874667 0 16.042667 7.168 16.042667 16.042667v99.413333a16.042667 16.042667 0 0 1-16.042667 16.042667H824.746667a16.042667 16.042667 0 0 1-16.042667-16.042667v-99.413333c0-8.874667 7.168-16.042667 16.042667-16.042667z m110.165333-80h48.128c8.874667 0 16.042667 7.168 16.042667 16.042667v179.413333a16.042667 16.042667 0 0 1-16.042667 16.042667h-48.128a16.042667 16.042667 0 0 1-16.042666-16.042667v-179.413333c0-8.874667 7.210667-16.042667 16.042666-16.042667z" fill="#999999" p-id="27238"></path></svg>
        <span id="busuanzi_value_page_pv"></span>
      </span>

</div>
  </header> <aside id="toc-container" class="toc-container wide">
    <div class="toc">
        <details  open>
            <summary accesskey="c" title="(Alt + C)">
                <span class="details">目录</span>
            </summary>

            <div class="inner"><ul>
                    <li>
                        <a href="#type-g-struct" aria-label="type g struct">type g struct</a><ul>
                            
                    <li>
                        <a href="#type-stack-struct" aria-label="type stack struct">type stack struct</a></li>
                    <li>
                        <a href="#type-gobuf-struct" aria-label="type gobuf struct">type gobuf struct</a></li>
                    <li>
                        <a href="#g-status" aria-label="G Status">G Status</a></li></ul>
                    </li>
                    <li>
                        <a href="#type-m-struct" aria-label="type m struct">type m struct</a></li>
                    <li>
                        <a href="#type-p-struct" aria-label="type p struct">type p struct</a><ul>
                            
                    <li>
                        <a href="#p-status" aria-label="P Status">P Status</a></li></ul>
                    </li>
                    <li>
                        <a href="#type-schedt-struct" aria-label="type schedt struct">type schedt struct</a></li>
                    <li>
                        <a href="#%e9%87%8d%e8%a6%81%e7%9a%84%e5%85%a8%e5%b1%80%e5%8f%98%e9%87%8f" aria-label="重要的全局变量">重要的全局变量</a>
                    </li>
                </ul>
            </div>
        </details>
    </div>
</aside>
<script>
    let activeElement;
    let elements;
    window.addEventListener('DOMContentLoaded', function (event) {
        checkTocPosition();

        elements = document.querySelectorAll('h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]');
         
         activeElement = elements[0];
         const id = encodeURI(activeElement.getAttribute('id')).toLowerCase();
         document.querySelector(`.inner ul li a[href="#${id}"]`).classList.add('active');
     }, false);

    window.addEventListener('resize', function(event) {
        checkTocPosition();
    }, false);

    window.addEventListener('scroll', () => {
        
        activeElement = Array.from(elements).find((element) => {
            if ((getOffsetTop(element) - window.pageYOffset) > 0 && 
                (getOffsetTop(element) - window.pageYOffset) < window.innerHeight/2) {
                return element;
            }
        }) || activeElement

        elements.forEach(element => {
             const id = encodeURI(element.getAttribute('id')).toLowerCase();
             if (element === activeElement){
                 document.querySelector(`.inner ul li a[href="#${id}"]`).classList.add('active');
             } else {
                 document.querySelector(`.inner ul li a[href="#${id}"]`).classList.remove('active');
             }
         })
     }, false);

    const main = parseInt(getComputedStyle(document.body).getPropertyValue('--article-width'), 10);
    const toc = parseInt(getComputedStyle(document.body).getPropertyValue('--toc-width'), 10);
    const gap = parseInt(getComputedStyle(document.body).getPropertyValue('--gap'), 10);

    function checkTocPosition() {
        const width = document.body.scrollWidth;

        if (width - main - (toc * 2) - (gap * 4) > 0) {
            document.getElementById("toc-container").classList.add("wide");
        } else {
            document.getElementById("toc-container").classList.remove("wide");
        }
    }

    function getOffsetTop(element) {
        if (!element.getClientRects().length) {
            return 0;
        }
        let rect = element.getBoundingClientRect();
        let win = element.ownerDocument.defaultView;
        return rect.top + win.pageYOffset;   
    }
</script>
  <div class="post-content"><h2 id="type-g-struct">type g struct<a hidden class="anchor" aria-hidden="true" href="#type-g-struct">#</a></h2>
<ol>
<li>每一个实例对象代表一个<code>goroutine</code>。</li>
<li>该结构体保存<code>CPU</code>寄存器的值以及<code>goroutine</code>的所有信息，包括栈，<code>gobuf</code>结构体和其它的一些状态信息。</li>
<li>调度器代码可以通过<code>g</code>对象来对<code>goroutine</code>进行调度：
<ol>
<li>当<code>goroutine</code>被调离<code>CPU</code>时，调度器代码负责把<code>CPU</code>寄存器的值保存在<code>g</code>对象的成员变量之中。</li>
<li>当<code>goroutine</code>被调度起来运行时，调度器代码又负责把<code>g</code>对象的成员变量所保存的寄存器的值恢复到<code>CPU</code>的寄存器。</li>
</ol>
</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">g</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Stack parameters.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// stack describes the actual stack memory: [stack.lo, stack.hi).
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// stackguard0 is the stack pointer compared in the Go stack growth prologue.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// It is stack.lo+StackGuard normally, but can be StackPreempt to trigger a preemption.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// stackguard1 is the stack pointer compared in the C stack growth prologue.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// It is stack.lo+StackGuard on g0 and gsignal stacks.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// It is ~0 on other goroutine stacks, to trigger a call to morestackc (and crash).
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// goroutine栈以及栈扩容相关信息
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 记录该goroutine使用的栈信息，[lo,hi)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">stack</span>       <span class="nx">stack</span>   <span class="c1">// offset known to runtime/cgo
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 被正常的goroutine使用，编译器安插在函数头部的栈增长代码，用它来和SP比较，按需进行栈增长。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 它的值一般是 stcak.lo + StackGuard，也可能被设置成 StackPreempt，以触发一次抢占。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// const _StackGuard = 928; linux amd64
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// const stackPreempt = 0xfffffade; ((1&lt;&lt;64) - 1) &amp; -1314
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">stackguard0</span> <span class="kt">uintptr</span> <span class="c1">// offset known to liblink
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 原理和 stackguard0 差不多，只不过是被 g0 和 gsignal 中的C代码使用。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">stackguard1</span> <span class="kt">uintptr</span> <span class="c1">// offset known to liblink
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="c1">// _panic 和 _defer 在defer和panic中被使用
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// panic链表，记录当前goroutine触发的panic链表
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">_panic</span>       <span class="o">*</span><span class="nx">_panic</span> <span class="c1">// innermost panic - offset known to liblink
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// defer链表，记录整个调用链函数中注册的defer函数链表
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">_defer</span>       <span class="o">*</span><span class="nx">_defer</span> <span class="c1">// innermost defer
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    
</span></span><span class="line"><span class="cl">    <span class="c1">// 关联到正在执行当前G的工作线程M，也就是 type m struct 结构体指针
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">m</span>            <span class="o">*</span><span class="nx">m</span>     <span class="c1">// current m; offset known to arm liblink
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 保存调度信息，主要是几个寄存器的值，g被调离前CPU以及寄存器信息保存在这里，恢复后从这里保存的信息开始
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 被调度器，用来保存 goroutine 的执行上下文。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">sched</span>        <span class="nx">gobuf</span>  <span class="c1">// 档期前goroutine被调度或者被保存是CPU相关信息存储在这里
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 系统调用进入调用前，保存SP寄存器和IP寄存器的值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">syscallsp</span>    <span class="kt">uintptr</span><span class="c1">// if status==Gsyscall, syscallsp = sched.sp to use during gc
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">syscallpc</span>    <span class="kt">uintptr</span><span class="c1">// if status==Gsyscall, syscallpc = sched.pc to use during gc
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 应为堆栈顶部的sp，用于回溯
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">stktopsp</span>     <span class="kt">uintptr</span><span class="c1">// expected sp at top of stack, to check in traceback
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// param is a generic pointer parameter field used to pass
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// values in particular contexts where other storage for the
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// parameter would be difficult to find. It is currently used
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// in three ways:
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 1. When a channel operation wakes up a blocked goroutine, it sets param to
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//    point to the sudog of the completed blocking operation.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 2. By gcAssistAlloc1 to signal back to its caller that the goroutine completed
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//    the GC cycle. It is unsafe to do so in any other way, because the goroutine&#39;s
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//    stack may have moved in the meantime.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 3. By debugCallWrap to pass parameters to a new goroutine because allocating a
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//    closure in the runtime is forbidden.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// param是一个通用的指针参数字段，用于在很难找到参数的其他存储的特定上下文中传递值。它目前有三种使用方式：
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//  1.当通道操作唤醒被阻塞的goroutine时，它将param设置为指向已完成阻塞操作的sudog。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//  2.通过gcAssistAlloc1向其调用方发出信号，表明goroutine完成了GC循环。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//    以任何其他方式这样做都是不安全的，因为goroutine的堆栈可能在此期间发生了移动。 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//  3.通过debugCallWrap将参数传递给新的goroutine，因为禁止在运行时分配闭包。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">param</span>        <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span> <span class="c1">// passed parameter on wakeup
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 用来表示当前G的状态。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">atomicstatus</span> <span class="kt">uint32</span> <span class="c1">// 记录当前G的状态
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">stackLock</span>    <span class="kt">uint32</span> <span class="c1">// sigprof/scang lock; TODO: fold in to atomicstatus
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 当前 goroutine 的全局唯一 ID。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">goid</span>         <span class="kt">int64</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// schedlink字段指向全局运行队列中的下一个g
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 所有位于全局运行队列中的g形成一个链表
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 被调度器用于实现内部链表、队列，对应的 guintptr 类型从逻辑上将等于 *g，
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 而底层类型却是个 uintptr，这样是为了避免写屏障。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">schedlink</span>    <span class="nx">guintptr</span>
</span></span><span class="line"><span class="cl">    <span class="nx">waitsince</span>    <span class="kt">int64</span>      <span class="c1">// g被阻塞的大约时间
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">waitreason</span>   <span class="nx">waitReason</span> <span class="c1">// if status==Gwaiting
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 抢占调度标志，如果需要抢占调度，设置preempt为true
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 抢占信号，重复 stackguard0 = stackpreempt
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 为true时，调度器会在合适的时机触发一次抢占
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">preempt</span>       <span class="kt">bool</span> <span class="c1">// preemption signal, duplicates stackguard0 = stackpreempt
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    
</span></span><span class="line"><span class="cl">    <span class="nx">preemptStop</span>   <span class="kt">bool</span> <span class="c1">// transition to _Gpreempted on preemption; otherwise, just deschedule
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">preemptShrink</span> <span class="kt">bool</span> <span class="c1">// shrink stack at synchronous safe point	在同步安全点收缩堆栈
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="c1">// asyncSafePoint is set if g is stopped at an asynchronous
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// safe point. This means there are frames on the stack
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// without precise pointer information.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">asyncSafePoint</span> <span class="kt">bool</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nx">paniconfault</span> <span class="kt">bool</span> <span class="c1">// panic (instead of crash) on unexpected fault address
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">gcscandone</span>   <span class="kt">bool</span> <span class="c1">// g has scanned stack; protected by _Gscan bit in status
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 不能扩展栈，该值在系统调用前被设置为true，在系统调用返回是设置为false。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">throwsplit</span>   <span class="kt">bool</span> <span class="c1">// must not split stack
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// activeStackChans indicates that there are unlocked channels
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// pointing into this goroutine&#39;s stack. If true, stack
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// copying needs to acquire channel locks to protect these
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// areas of the stack.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// activeStackChans 表示有未锁定的通道指向这个 goroutines 堆栈
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 如果为true，堆栈复制需要获取通道锁来保护堆栈的这些区域
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">activeStackChans</span> <span class="kt">bool</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// parkingOnChan indicates that the goroutine is about to
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// park on a chansend or chanrecv. Used to signal an unsafe point
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// for stack shrinking. It&#39;s a boolean value, but is updated atomically.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">parkingOnChan</span> <span class="kt">uint8</span>	<span class="c1">// 赋值1，表示当前goroutine正在chan上
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="nx">raceignore</span>     <span class="kt">int8</span> <span class="c1">// ignore race detection events
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">sysblocktraced</span> <span class="kt">bool</span> <span class="c1">// StartTrace has emitted EvGoInSyscall about this goroutine
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">tracking</span>       <span class="kt">bool</span> <span class="c1">// whether we&#39;re tracking this G for sched latency statistics
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">trackingSeq</span>    <span class="kt">uint8</span><span class="c1">// used to decide whether to track this G
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">runnableStamp</span>  <span class="kt">int64</span><span class="c1">// timestamp of when the G last became runnable, only used when tracking
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">runnableTime</span>   <span class="kt">int64</span><span class="c1">// the amount of time spent runnable, cleared when running, only used when tracking
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">sysexitticks</span>   <span class="kt">int64</span><span class="c1">// cputicks when syscall has returned (for tracing)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">traceseq</span>       <span class="kt">uint64</span><span class="c1">// trace event sequencer
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">tracelastp</span>     <span class="nx">puintptr</span><span class="c1">// last P emitted an event for this goroutine
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 关联到与当前G绑定的M，可以参考下 LockOSThread。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">lockedm</span>        <span class="nx">muintptr</span>
</span></span><span class="line"><span class="cl">    <span class="nx">sig</span>            <span class="kt">uint32</span>
</span></span><span class="line"><span class="cl">    <span class="nx">writebuf</span>       <span class="p">[]</span><span class="kt">byte</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// sigcode0 和 sigcode1 用于临时传参记录
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">sigcode0</span>       <span class="kt">uintptr</span>	<span class="c1">// 记录当前需要跳转的SP地址，比如panic中即将跳转goexit
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">sigcode1</span>       <span class="kt">uintptr</span>	<span class="c1">// 记录当前需要跳转的PC地址，比如panic中即将跳转goexit
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">sigpc</span>          <span class="kt">uintptr</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 在创建goroutine时候被保存
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">gopc</span>           <span class="kt">uintptr</span>  <span class="c1">// pc of go statement that created this goroutine
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 创建此goroutine的祖先信息goroutine（仅在debug.traceback祖先时使用），在创建goroutin时候被保存
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">ancestors</span>      <span class="o">*</span><span class="p">[]</span><span class="nx">ancestorInfo</span> <span class="c1">// ancestor information goroutine(s) that created this goroutine (only used if debug.tracebackancestors)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// goroutine函数的pc。在创建goroutin时候被保存
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">startpc</span>        <span class="kt">uintptr</span>  <span class="c1">// pc of goroutine function
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">racectx</span>        <span class="kt">uintptr</span>  <span class="c1">// 标记当前goroutine 0表示主goroutine
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 记录让当前goroutine等待的sudog，sudog是chan的等待队列，等待被读，c&lt;-1操作引起当前，该参数在当前goroutine被恢复时判断使用
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// Sudog结构这个g正在等待(有一个有效的elem指针);按锁定顺序。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 主要用于实现 channel 中的等待队列。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">waiting</span>        <span class="o">*</span><span class="nx">sudog</span>   <span class="c1">// sudog structures this g is waiting on (that have a valid elem ptr); in lock order
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">cgoCtxt</span>        <span class="p">[]</span><span class="kt">uintptr</span><span class="c1">// cgo traceback context
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">labels</span>         <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span> <span class="c1">// profiler labels
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 缓存 timer 由于 time.Sleep。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">timer</span>          <span class="o">*</span><span class="nx">timer</span> <span class="c1">// cached timer for time.Sleep
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">selectDone</span>     <span class="kt">uint32</span> <span class="c1">// are we participating in a select and did someone win the race?
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Per-G GC state
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="c1">// gcAssistBytes is this G&#39;s GC assist credit in terms of
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// bytes allocated. If this is positive, then the G has credit
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// to allocate gcAssistBytes bytes without assisting. If this
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// is negative, then the G must correct this by performing
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// scan work. We track this in bytes to make it fast to update
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// and check for debt in the malloc hot path. The assist ratio
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// determines how this corresponds to scan work debt.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">gcAssistBytes</span> <span class="kt">int64</span> <span class="c1">// GC信用值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></div><h3 id="type-stack-struct">type stack struct<a hidden class="anchor" aria-hidden="true" href="#type-stack-struct">#</a></h3>
<ol>
<li><code>Stack</code>描述了<code>Go</code>的执行栈。栈的边界正好是<code>[lo, hi)</code>，两边都没有隐式的数据结构。</li>
<li>注意栈是向下生长的。</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// Stack describes a Go execution stack.
</span></span></span><span class="line"><span class="cl"><span class="c1">// The bounds of the stack are exactly [lo, hi),
</span></span></span><span class="line"><span class="cl"><span class="c1">// with no implicit data structures on either side.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">type</span> <span class="nx">stack</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">lo</span> <span class="kt">uintptr</span> <span class="c1">// 栈顶，指向内存【低地址】
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">hi</span> <span class="kt">uintptr</span> <span class="c1">// 栈底，指向内存【高地址】
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></div><p><img loading="lazy" src="../images/goroutine-016.png" alt=""  />
</p>
<h3 id="type-gobuf-struct">type gobuf struct<a hidden class="anchor" aria-hidden="true" href="#type-gobuf-struct">#</a></h3>
<ol>
<li>保存<code>goroutine</code>的调度信息，应用场景在这<code>goroutine</code>被选中调度起来去执行，或当前<code>goroutine</code>被抢占需要保存<code>CPU</code>信息然后下次接到从此处执行。</li>
<li>用来存储<code>goroutine</code>执行上下文的<code>sched</code>字段需要格外注意，它与<code>goroutine</code>协程切换的底层实现相关。</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">gobuf</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// sp字段存储的是栈指针，rsp寄存器的值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">sp</span>   <span class="kt">uintptr</span>    <span class="c1">// 保存CPU的SP寄存器的值，存储的是被抢占或调度时CPU信息
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// pc字段存储的是指令指针，rip寄存器的值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">pc</span>   <span class="kt">uintptr</span>    <span class="c1">// 保存CPU的IP寄存器的值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// g字段用来反向关联到对应的G。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">g</span>    <span class="nx">guintptr</span>   <span class="c1">// 记录当前这个gobuf对象属于那个goroutine
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// ctxt字段指向闭包对象，也就是说用go关键字创建协程的时候传递的是一个闭包
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 这里会存储闭包对象的地址。rdx寄存器的值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">ctxt</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span> <span class="c1">// 上下文信息
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    
</span></span><span class="line"><span class="cl">    <span class="c1">// 保存系统调用的返回值，因为从系统调用返回之后如果p被其他工作线程抢占
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 则这个goroutine会被放入全局运行队列被其他工作线程调度，其他线程需要知道系统调用的返回值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// ret字段用来存储返回值，实际上是利用AX寄存器实现类似C函数的返回值，目前只发现panic-recover机制用到了该字段。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">ret</span>  <span class="nx">sys</span><span class="p">.</span><span class="nx">Uintreg</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// lr字段在arm等架构上用来存储返地址，x86没有用到该字段。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">lr</span>   <span class="kt">uintptr</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c1">// bp字段用来存储栈帧基地址。rbp寄存器的值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">bp</span>   <span class="kt">uintptr</span> <span class="c1">// 对于支持帧指针的架构
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></div><h3 id="g-status">G Status<a hidden class="anchor" aria-hidden="true" href="#g-status">#</a></h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// defined constants
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">const</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// goroutine 开始创建的状态，此时尚未初始化完成；
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">_Gidle</span> <span class="p">=</span> <span class="kc">iota</span> <span class="c1">// 0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// goroutine 在待执行队列中，等待被执行；
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">_Grunnable</span>    <span class="c1">// 1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// goroutine 正在执行，同一时刻一个P中只有一个g处于此状态；
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">_Grunning</span>     <span class="c1">// 2
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// goroutine 正在执行系统调用；
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">_Gsyscall</span>     <span class="c1">// 3
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// goroutine 处于挂起状态，需要等待被唤醒。gc、channel 或者锁操作时经常会进入这种状态；
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">_Gwaiting</span>     <span class="c1">// 4
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// _Gmoribund_unused is currently unused, but hardcoded in gdb
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// scripts.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">_Gmoribund_unused</span> <span class="c1">// 5
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// goroutine 刚初始化完成或者已经被销毁，会处于此状态；
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">_Gdead</span>        <span class="c1">// 6
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// _Genqueue_unused is currently unused.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">_Genqueue_unused</span> <span class="c1">// 7
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// goroutine 正在栈扩容流程中；
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">_Gcopystack</span>   <span class="c1">// 8
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// goroutine 被抢占后的状态
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">_Gpreempted</span>   <span class="c1">// 9
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="c1">// _Gscan与前面的一些状态组合。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 除了_Gscanrunning外，其他的组合状态都表示GC正在扫描goroutine的栈，goroutine没有在执行用户代码，
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 栈的所有权归设置了_Gscan标志位的goroutine所有。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">_Gscan</span>          <span class="p">=</span> <span class="mh">0x1000</span>
</span></span><span class="line"><span class="cl">    <span class="nx">_Gscanrunnable</span>  <span class="p">=</span> <span class="nx">_Gscan</span> <span class="o">+</span> <span class="nx">_Grunnable</span>  <span class="c1">// 0x1001
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// _Gscanrunning在GC通知G扫描栈的时候，它被用来短暂的阻止状态变换，其他方面和_Grunning一样。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 栈扫描完成后，goroutine将会切换回原来的状态，移除_Gscan标志位。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">_Gscanrunning</span>   <span class="p">=</span> <span class="nx">_Gscan</span> <span class="o">+</span> <span class="nx">_Grunning</span>   <span class="c1">// 0x1002
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">_Gscansyscall</span>   <span class="p">=</span> <span class="nx">_Gscan</span> <span class="o">+</span> <span class="nx">_Gsyscall</span>   <span class="c1">// 0x1003
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">_Gscanwaiting</span>   <span class="p">=</span> <span class="nx">_Gscan</span> <span class="o">+</span> <span class="nx">_Gwaiting</span>   <span class="c1">// 0x1004
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">_Gscanpreempted</span> <span class="p">=</span> <span class="nx">_Gscan</span> <span class="o">+</span> <span class="nx">_Gpreempted</span> <span class="c1">// 0x1009
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">)</span>
</span></span></code></pre></div><p><img loading="lazy" src="../images/goroutine-017.png" alt=""  />
</p>
<h2 id="type-m-struct">type m struct<a hidden class="anchor" aria-hidden="true" href="#type-m-struct">#</a></h2>
<ol>
<li><code>m</code>结构体用来代表工作线程，它保存了<code>m</code>自身使用的栈信息。</li>
<li>当前正在运行的<code>goroutine</code>以及与<code>m</code>绑定的<code>p</code>等信息。</li>
<li>每个工作线程都有唯一的一个m结构体的实例对象与之对应，m结构体对象除了记录着工作线程的诸如栈的起止位置、当前正在执行的goroutine以及是否空闲等等状态信息之外，还通过指针维持着与p结构体的实例对象之间的绑定关系。</li>
<li>于是，通过m既可以找到与之对应的工作线程正在运行的goroutine，又可以找到工作线程的局部运行队列等资源。</li>
<li>只要每个工作线程拥有了各自私有的m结构体全局变量，我们就能在不同的工作线程中使用相同的全局变量名来访问不同的m结构体对象。</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">m</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 并不是一个真正的goroutine，它的栈是由操作系统分配的，
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 初始大小比普通goroutine的栈要大，被用作调度器执行的栈。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 程序刚初始化启动时第一个g0栈大概有64KB大小，后面的工作线程的g0栈有8KB大小
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">g0</span>      <span class="o">*</span><span class="nx">g</span>     <span class="c1">// goroutine with scheduling stack
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 记录被调用者信息，在抢占调度中被设置
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">morebuf</span> <span class="nx">gobuf</span>  <span class="c1">// gobuf arg to morestack 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">divmod</span>  <span class="kt">uint32</span> <span class="c1">// div/mod denominator for arm - known to liblink
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Fields not known to debuggers.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 线程ID，该值在`go1.19.3/src/runtime/os_linux.go:minit`被调用，该方法在mstart函数线程刚启动时初始化。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 该值默认是一个自增的ID
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">procid</span>        <span class="kt">uint64</span>       <span class="c1">// for debuggers, but offset not hard-coded
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 本质上是用来处理信号的栈，因为一些UNIX系统支持为信号处理器配置独立的栈。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">gsignal</span>       <span class="o">*</span><span class="nx">g</span>           <span class="c1">// signal-handling g
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">goSigStack</span>    <span class="nx">gsignalStack</span> <span class="c1">// Go-allocated signal handling stack
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">sigmask</span>       <span class="nx">sigset</span>       <span class="c1">// storage for saved signal mask
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 通过TLS实现m结构体对象与工作线程之前的绑定
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 线程本地存储，存储内容只对当前线程可见。线程本地存储的时m.tls的地址，m.tls[0]存储的是当前运行的g，
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 因此线程可以通过g找到当前的m、p、g0等信息。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">tls</span>           <span class="p">[</span><span class="mi">6</span><span class="p">]</span><span class="kt">uintptr</span>   <span class="c1">// thread-local storage (for x86 extern register)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">mstartfn</span>      <span class="kd">func</span><span class="p">()</span> <span class="c1">// 工作线程启动后需要执行的函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 指向工作线程正在运行的goroutine的g结构体对象，该参数的作用是在切换到g0栈后清除之前的g，
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 记录在这里指向的是M当前正在执行的G。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">curg</span>          <span class="o">*</span><span class="nx">g</span>       <span class="c1">// current running goroutine 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">caughtsig</span>     <span class="nx">guintptr</span> <span class="c1">// goroutine running during fatal signal
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 记录与当前工作线程绑定的p结构体对象
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// GMP中的P，即关联到当前M上的处理器。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">p</span>             <span class="nx">puintptr</span> <span class="c1">// attached p for executing go code (nil if not executing go code)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 用来将P传递给M，调度器一般是在M阻塞时为m.nextp赋值，等到M开始运行后会尝试从nextp处获取P进行关联。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">nextp</span>         <span class="nx">puintptr</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 用来暂存执行系统调用之前关联的P。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">oldp</span>          <span class="nx">puintptr</span> <span class="c1">// the p that was attached before executing a syscall
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// M的唯一id。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">id</span>            <span class="kt">int64</span>    <span class="c1">// 当前线程的ID，根据schedt.mnext记录的工作线程个数而设置的
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// mallocing = 1，当前goroutine正在分配内存
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">mallocing</span>     <span class="kt">int32</span>
</span></span><span class="line"><span class="cl">    <span class="nx">throwing</span>      <span class="kt">int32</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 不为空时表示要关闭对curg的抢占，字符串内容给出了相关的原因。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 用于控制当前 goroutine 是否可被抢占。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//	1. 当一个 goroutine 执行一些关键操作时（如获取锁、执行系统调用等），它可能需要暂时关闭抢占，以避免在关键操作期间被抢占导致死锁或竞争条件的发生。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//  2. 程序员可以通过使用 runtime.LockOSThread() 函数来将当前 goroutine 绑定到一个 OS 线程上，从而避免抢占的发生。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//  3. 如果在执行关键操作时需要暂时关闭抢占，可以使用 runtime.LockOSThread() 函数将当前 goroutine 绑定到一个 OS 线程上，并在操作完成后调用 runtime.UnlockOSThread() 函数将其解绑。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">preemptoff</span>    <span class="kt">string</span> <span class="c1">// if != &#34;&#34;, keep curg running on this m
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 记录当前M持有锁的数量，不为0时能够阻止抢占发生。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 用来记录当前 goroutine 持有的互斥锁数量的
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//  1. 当 goroutine 持有一个互斥锁时，它不能被抢占，因为如果被抢占了，其他 goroutine 就无法获取该锁。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//  2. 为了避免这种情况的发生，Go 语言的调度器会在检查是否应该抢占当前 goroutine 之前，先检查它是否持有互斥锁。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//  3. 如果当前 goroutine 持有互斥锁，则调度器会暂时将其标记为不可抢占状态，直到该 goroutine 释放锁为止。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//  4. 因此，m.locks 字段是用来辅助调度器实现这一机制的。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//  5. 当一个 goroutine 获取一个互斥锁时，m.locks 字段会被更新，标记该 goroutine 持有相应的互斥锁。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//  6. 当 goroutine 释放锁时，m.locks 字段也会被更新，清除相应的标记。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//  7. 调度器在决定是否应该抢占一个 goroutine 时，会检查该 goroutine 是否持有互斥锁，以此来避免因抢占导致的锁竞争和死锁问题。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">locks</span>         <span class="kt">int32</span>	 <span class="c1">// 尝试获取锁的次数，在lock中加一，在unlock减一
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">dying</span>         <span class="kt">int32</span>
</span></span><span class="line"><span class="cl">    <span class="nx">profilehz</span>     <span class="kt">int32</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// spining状态：表示当前工作线程正在试图从其他工作线程的本地运行队列偷取goroutine
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 表示当前M正处于自旋状态。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">spinning</span>      <span class="kt">bool</span> <span class="c1">// m is out of work and is actively looking for work	
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">blocked</span>       <span class="kt">bool</span> <span class="c1">// m is blocked on a note 	m在note上被屏蔽，表示当前M正在休眠中
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">newSigstack</span>   <span class="kt">bool</span> <span class="c1">// minit on C thread called sigaltstack
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">printlock</span>     <span class="kt">int8</span>
</span></span><span class="line"><span class="cl">    <span class="nx">incgo</span>         <span class="kt">bool</span>   <span class="c1">// m is executing a cgo call
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">freeWait</span>      <span class="nx">atomic</span><span class="p">.</span><span class="nx">Uint32</span> <span class="c1">// Whether it is safe to free g0 and delete m (one of freeMRef, freeMStack, freeMWait)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// fastrand 用于在一些随机值的使用需要
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">fastrand</span>      <span class="kt">uint64</span> 
</span></span><span class="line"><span class="cl">    <span class="nx">needextram</span>    <span class="kt">bool</span>
</span></span><span class="line"><span class="cl">    <span class="nx">traceback</span>     <span class="kt">uint8</span>
</span></span><span class="line"><span class="cl">    <span class="nx">ncgocall</span>      <span class="kt">uint64</span>      <span class="c1">// number of cgo calls in total
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">ncgo</span>          <span class="kt">int32</span>       <span class="c1">// number of cgo calls currently in progress
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">cgoCallersUse</span> <span class="kt">uint32</span>      <span class="c1">// if non-zero, cgoCallers in use temporarily
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">cgoCallers</span>    <span class="o">*</span><span class="nx">cgoCallers</span> <span class="c1">// cgo traceback if crashing in cgo call
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">doesPark</span>      <span class="kt">bool</span>        <span class="c1">// non-P running threads: sysmon and newmHandoff never use .park
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 没有goroutine需要运行时，工作线程睡眠在这个park成员上
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 其他线程通过这个park唤醒该工作线程
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 用来支持M的sleep和wakeup，可以很方便地实现每个M单独sleep和wakeup。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">park</span>          <span class="nx">note</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 记录所有工作线程的一个链表
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 把所有的M连起来，构成allm链表。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">alllink</span>       <span class="o">*</span><span class="nx">m</span> <span class="c1">// on allm
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 被调度器用于实现链表，如空闲M链表。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">schedlink</span>     <span class="nx">muintptr</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 关联到与当前M绑定的G，可参考LockOSThread。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">lockedg</span>       <span class="nx">guintptr</span>
</span></span><span class="line"><span class="cl">    <span class="nx">createstack</span>   <span class="p">[</span><span class="mi">32</span><span class="p">]</span><span class="kt">uintptr</span> <span class="c1">// stack that created this thread.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">lockedExt</span>     <span class="kt">uint32</span>      <span class="c1">// tracking for external LockOSThread
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">lockedInt</span>     <span class="kt">uint32</span>      <span class="c1">// tracking for internal lockOSThread
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">nextwaitm</span>     <span class="nx">muintptr</span>    <span class="c1">// next m waiting for lock
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">waitunlockf</span>   <span class="kd">func</span><span class="p">(</span><span class="o">*</span><span class="nx">g</span><span class="p">,</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">)</span> <span class="kt">bool</span>
</span></span><span class="line"><span class="cl">    <span class="nx">waitlock</span>      <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span>
</span></span><span class="line"><span class="cl">    <span class="nx">waittraceev</span>   <span class="kt">byte</span>
</span></span><span class="line"><span class="cl">    <span class="nx">waittraceskip</span> <span class="kt">int</span>
</span></span><span class="line"><span class="cl">    <span class="nx">startingtrace</span> <span class="kt">bool</span>
</span></span><span class="line"><span class="cl">    <span class="nx">syscalltick</span>   <span class="kt">uint32</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 用来把已经退出运行的M连起来，构成sched.freem链表，方便下次分配时复用。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">freelink</span>      <span class="o">*</span><span class="nx">m</span> <span class="c1">// on sched.freem
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="c1">// mFixup is used to synchronize OS related m state (credentials etc)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// use mutex to access.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">mFixup</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">lock</span> <span class="nx">mutex</span>
</span></span><span class="line"><span class="cl">        <span class="nx">fn</span>   <span class="kd">func</span><span class="p">(</span><span class="kt">bool</span><span class="p">)</span> <span class="kt">bool</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// these are here because they are too large to be on the stack
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// of low-level NOSPLIT functions.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">libcall</span>   <span class="nx">libcall</span>
</span></span><span class="line"><span class="cl">    <span class="nx">libcallpc</span> <span class="kt">uintptr</span> <span class="c1">// for cpu profiler
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">libcallsp</span> <span class="kt">uintptr</span>
</span></span><span class="line"><span class="cl">    <span class="nx">libcallg</span>  <span class="nx">guintptr</span>
</span></span><span class="line"><span class="cl">    <span class="nx">syscall</span>   <span class="nx">libcall</span> <span class="c1">// stores syscall parameters on windows
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="nx">vdsoSP</span> <span class="kt">uintptr</span> <span class="c1">// SP for traceback while in VDSO call (0 if not in call)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">vdsoPC</span> <span class="kt">uintptr</span> <span class="c1">// PC for traceback while in VDSO call
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="c1">// preemptGen counts the number of completed preemption
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// signals. This is used to detect when a preemption is
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// requested, but fails. Accessed atomically.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">preemptGen</span> <span class="kt">uint32</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// Whether this is a pending preemption signal on this M.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// Accessed atomically.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 这个M上是否有一个待处理的抢占信号。原子操作。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 该参数在 preemptM 函数中从0设置为1。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">signalPending</span> <span class="kt">uint32</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nx">dlogPerM</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nx">mOS</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// Up to 10 locks held by this m, maintained by the lock ranking code.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">locksHeldLen</span> <span class="kt">int</span>
</span></span><span class="line"><span class="cl">    <span class="nx">locksHeld</span>    <span class="p">[</span><span class="mi">10</span><span class="p">]</span><span class="nx">heldLockInfo</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h2 id="type-p-struct">type p struct<a hidden class="anchor" aria-hidden="true" href="#type-p-struct">#</a></h2>
<ol>
<li><code>p</code>结构体用于保存工作线程执行<code>go</code>代码时所必需的资源。</li>
<li>比如<code>goroutine</code>的运行队列，内存分配用到的缓存，局部goroutien运行队列等等。</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">p</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// P的位移ID，等于当前P在allp数组中的下标。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">id</span>          <span class="kt">int32</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 当前P所处状态，也就是当前P上的g的状态
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">status</span>      <span class="kt">uint32</span> <span class="c1">// one of pidle/prunning/...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// link是一个没有写屏障的指针，被调度器用来构造链表
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">link</span>        <span class="nx">puintptr</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 在每次调度器调用时递增，记录当前P的调度次数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 记录调度发生的次数，实际上在每发生一次goroutine切换且不继承时间片的情况下，该字段会加一。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">schedtick</span>   <span class="kt">uint32</span>     <span class="c1">// incremented on every scheduler call
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 在每次系统调用时递增，记录当前P的系统调用次数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 发生每一次系统调用就会加一。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">syscalltick</span> <span class="kt">uint32</span>     <span class="c1">// incremented on every system call
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// sysmon观察到的最后一个时钟信号
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 该值被用于sysmon线程记录被监控p的系统调用时间和运行时间，注意这里是与sysmon相关的
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 	type sysmontick struct {
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//		schedtick   uint32
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//		schedwhen   int64
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//		syscalltick uint32
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//		syscallwhen int64
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 	}
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 被监控线程用来存储上一次检查时的调度器时钟滴答，用于实现时间片算法。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">sysmontick</span>  <span class="nx">sysmontick</span> <span class="c1">// last tick observed by sysmon
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 本质上是个指针，反向关联到当前P绑定的M。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">m</span>           <span class="nx">muintptr</span>   <span class="c1">// back-link to associated m (nil if idle)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">mcache</span>      <span class="o">*</span><span class="nx">mcache</span>		<span class="c1">// p的内存模块管理
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">pcache</span>      <span class="nx">pageCache</span>
</span></span><span class="line"><span class="cl">    <span class="nx">raceprocctx</span> <span class="kt">uintptr</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 用于缓存*_defer接口，避免频繁堆分配
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">deferpool</span>    <span class="p">[]</span><span class="o">*</span><span class="nx">_defer</span> <span class="c1">// pool of available defer structs of different sizes (see panic.go)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 根据源码中 pp.deferpool = pp.deferpoolbuf[:0] 可知，deferpoolbuf只是作为deferpool的内存地址在使用
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">deferpoolbuf</span> <span class="p">[</span><span class="mi">32</span><span class="p">]</span><span class="o">*</span><span class="nx">_defer</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// Cache of goroutine ids, amortizes accesses to runtime·sched.goidgen.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 用来从全局sched,goidgen处生气goid分配区间，批量申请以减少全局范围的锁竞争用。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">goidcache</span>    <span class="kt">uint64</span>
</span></span><span class="line"><span class="cl">    <span class="nx">goidcacheend</span> <span class="kt">uint64</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// Queue of runnable goroutines. Accessed without lock.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 本地goroutine运行队列
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 当前P的就绪队列，用一个数组和一头一尾两个下标实现了一个环型队列。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">runqhead</span> <span class="kt">uint32</span>		<span class="c1">// 队列头
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">runqtail</span> <span class="kt">uint32</span>		<span class="c1">// 队列尾
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">runq</span>     <span class="p">[</span><span class="mi">256</span><span class="p">]</span><span class="nx">guintptr</span> <span class="c1">// 使用数组实现的循环队列
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// runnext, if non-nil, is a runnable G that was ready&#39;d by
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// the current G and should be run next instead of what&#39;s in
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// runq if there&#39;s time remaining in the running G&#39;s time
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// slice. It will inherit the time left in the current time
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// slice. If a set of goroutines is locked in a
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// communicate-and-wait pattern, this schedules that set as a
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// unit and eliminates the (potentially large) scheduling
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// latency that otherwise arises from adding the ready&#39;d
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// goroutines to the end of the run queue.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 如果不为nil，则指向一个被当前G准备好(就绪)的G，接下来将会继承当前G的时间片开始运行。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 该字段存在的意义在于，假如有一组goroutine中有生产者和消费者，它们在一个channel上频繁的等待、唤醒，
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 那么调度器会把它们作为一个单元来调度。每次使用runnext比添加到本地runq尾部能大幅减少延迟。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">runnext</span> <span class="nx">guintptr</span>	<span class="c1">// 记录着下一个将要执行的goroutine
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Available G&#39;s (status == Gdead)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 记录着所有状态为Gdead的空闲的goroutine链表
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// go关键字配的时候优先从这里获取，goroutine执行完时保存在这里
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 用来缓存已经退出运行的G，方便再次分配时进行复用。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">gFree</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">gList</span>	<span class="c1">// type gList struct {head guintptr}	guintptr是uintputr的自定义类型
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">n</span> <span class="kt">int32</span>	<span class="c1">// 记录着当前空闲的g的数量
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nx">sudogcache</span> <span class="p">[]</span><span class="o">*</span><span class="nx">sudog</span>
</span></span><span class="line"><span class="cl">    <span class="nx">sudogbuf</span>   <span class="p">[</span><span class="mi">128</span><span class="p">]</span><span class="o">*</span><span class="nx">sudog</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// Cache of mspan objects from the heap.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">mspancache</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// We need an explicit length here because this field is used
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// in allocation codepaths where write barriers are not allowed,
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// and eliminating the write barrier/keeping it eliminated from
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// slice updates is tricky, moreso than just managing the length
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// ourselves.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">len</span> <span class="kt">int</span>
</span></span><span class="line"><span class="cl">        <span class="nx">buf</span> <span class="p">[</span><span class="mi">128</span><span class="p">]</span><span class="o">*</span><span class="nx">mspan</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nx">tracebuf</span> <span class="nx">traceBufPtr</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// traceSweep indicates the sweep events should be traced.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// This is used to defer the sweep start event until a span
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// has actually been swept.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">traceSweep</span> <span class="kt">bool</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// traceSwept and traceReclaimed track the number of bytes
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// swept and reclaimed by sweeping in the current sweep loop.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">traceSwept</span><span class="p">,</span> <span class="nx">traceReclaimed</span> <span class="kt">uintptr</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nx">palloc</span> <span class="nx">persistentAlloc</span> <span class="c1">// per-P to avoid mutex
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 用于下面字段对齐
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">_</span> <span class="kt">uint32</span> <span class="c1">// Alignment for atomic fields below
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 以下timer0When和timerModifiedEarliest字段维护这这个P的执行时间，也是用于抢断判断依据
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// The when field of the first entry on the timer heap.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// This is updated using atomic functions.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// This is 0 if the timer heap is empty.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// timer 堆上第一个条目的 when 字段。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 这是使用原子函数更新的
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 如果 timer 堆为空，则为 0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">timer0When</span> <span class="kt">uint64</span>	<span class="c1">// 堆顶元素什么时候执行
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="c1">// The earliest known nextwhen field of a timer with
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// timerModifiedEarlier status. Because the timer may have been
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// modified again, there need not be any timer with this value.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// This is updated using atomic functions.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// This is 0 if the value is unknown.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 具有 timerModifiedEarlier 状态的定时器的最早已知 nextwhen 字段。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 因为定时器可能已经被再次修改，所以不需要任何具有该值的timer
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 这是使用原子函数更新的
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 如果没有 timerModifiedEarlier 计时器，则为 0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">timerModifiedEarliest</span> <span class="kt">uint64</span>	<span class="c1">// 如果有timer修改为更早执行时间了，将执行时间更新到当更早时间
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Per-P GC state
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">gcAssistTime</span>         <span class="kt">int64</span> <span class="c1">// Nanoseconds in assistAlloc
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">gcFractionalMarkTime</span> <span class="kt">int64</span> <span class="c1">// Nanoseconds in fractional mark worker (atomic)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="c1">// gcMarkWorkerMode is the mode for the next mark worker to run in.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// That is, this is used to communicate with the worker goroutine
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// selected for immediate execution by
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// gcController.findRunnableGCWorker. When scheduling other goroutines,
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// this field must be set to gcMarkWorkerNotWorker.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">gcMarkWorkerMode</span> <span class="nx">gcMarkWorkerMode</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// gcMarkWorkerStartTime is the nanotime() at which the most recent
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// mark worker started.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">gcMarkWorkerStartTime</span> <span class="kt">int64</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// gcw is this P&#39;s GC work buffer cache. The work buffer is
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// filled by write barriers, drained by mutator assists, and
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// disposed on certain GC state transitions.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">gcw</span> <span class="nx">gcWork</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// wbBuf is this P&#39;s GC write barrier buffer.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// TODO: Consider caching this in the running G.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">wbBuf</span> <span class="nx">wbBuf</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nx">runSafePointFn</span> <span class="kt">uint32</span> <span class="c1">// if 1, run sched.safePointFn at next safe point
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="c1">// statsSeq is a counter indicating whether this P is currently
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// writing any stats. Its value is even when not, odd when it is.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">statsSeq</span> <span class="kt">uint32</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// Lock for timers. We normally access the timers while running
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// on this P, but the scheduler can also do it from a different P.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 锁定timers。我们通常在此P上运行时访问timers，但调度程序也可以从不同的P上执行此操作
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">timersLock</span> <span class="nx">mutex</span>	<span class="c1">// 操作timer的互斥锁
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Actions to take at some time. This is used to implement the
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// standard library&#39;s time package.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// Must hold timersLock to access.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 必须持有 timersLock 才能访问
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 当前关于P的timer，可能出现当前P中很多goroutine被挂在不同的timer上
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">timers</span> <span class="p">[]</span><span class="o">*</span><span class="nx">timer</span>	<span class="c1">// 该P上的所有timer，必须加锁去操作这个字段，因为不同的P操作这个字段会有竞争
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Number of timers in P&#39;s heap.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// Modified using atomic instructions.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// P 堆中的timers数量，使用原子指令修改
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">numTimers</span> <span class="kt">uint32</span>	<span class="c1">// P堆上所有的timer数量
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Number of timerModifiedEarlier timers on P&#39;s heap.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// This should only be modified while holding timersLock,
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// or while the timer status is in a transient state
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// such as timerModifying.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// P 的堆上 timerModifiedEarlier 计时器的数量
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 这只应在持有 timersLock 时修改，或者当定时器状态处于诸如 timerModifying 之类的瞬态状态时进行修改
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">adjustTimers</span> <span class="kt">uint32</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// Number of timerDeleted timers in P&#39;s heap.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// Modified using atomic instructions.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// P 的堆中 timerDeleted timers的数量
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 使用原子指令修改
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">deletedTimers</span> <span class="kt">uint32</span>	<span class="c1">// 被标记为删除的timer，要么是我们调用stop，要么是timer自己触发后过期导致的删除
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Race context used while executing timer functions.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">timerRaceCtx</span> <span class="kt">uintptr</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// preempt is set to indicate that this P should be enter the
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// scheduler ASAP (regardless of what G is running on it).
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// preempt 设置为指示该 P 应尽快进入调度程序（无论 G 在其上运行什么）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 在GO1.14版本被引入，以支持新的异步抢占机制。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">preempt</span> <span class="kt">bool</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nx">pad</span> <span class="nx">cpu</span><span class="p">.</span><span class="nx">CacheLinePad</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h3 id="p-status">P Status<a hidden class="anchor" aria-hidden="true" href="#p-status">#</a></h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">const</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// P status
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="c1">// _Pidle means a P is not being used to run user code or the
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// scheduler. Typically, it&#39;s on the idle P list and available
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// to the scheduler, but it may just be transitioning between
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// other states.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// The P is owned by the idle list or by whatever is
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// transitioning its state. Its run queue is empty.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 空闲状态。此时的P没有被用来执行用户代码或调度器代码，通常位于空闲链表中，能够被调度器获取，
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 它的状态可能正在由空闲转变成其他状态。P的所有权归空闲链表或某个正在改变它状态的线程所有，本地runq为空。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">_Pidle</span> <span class="p">=</span> <span class="kc">iota</span> <span class="c1">// 空闲状态
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="c1">// _Prunning means a P is owned by an M and is being used to
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// run user code or the scheduler. Only the M that owns this P
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// is allowed to change the P&#39;s status from _Prunning. The M
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// may transition the P to _Pidle (if it has no more work to
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// do), _Psyscall (when entering a syscall), or _Pgcstop (to
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// halt for the GC). The M may also hand ownership of the P
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// off directly to another M (e.g., to schedule a locked G).
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 运行中状态。当前P正被某个M持有，并且用于执行用户代码或调度器代码。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 只有持有P所有权的M，才被允许将P的状态从_Prunning转变为其他状态。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 在任务都执行完以后，M会把P设置为_Pidle状态。在进入系统调用时，M会把P设置为_Psyscall状态。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 挂起以执行GC时，会设置为_Pgcstop状态。某些情况下，M还可能会直接把P的所有权交给另一个M。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">_Prunning</span> <span class="c1">// 运行中状态
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="c1">// _Psyscall means a P is not running user code. It has
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// affinity to an M in a syscall but is not owned by it and
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// may be stolen by another M. This is similar to _Pidle but
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// uses lightweight transitions and maintains M affinity.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// Leaving _Psyscall must be done with a CAS, either to steal
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// or retake the P. Note that there&#39;s an ABA hazard: even if
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// an M successfully CASes its original P back to _Prunning
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// after a syscall, it must understand the P may have been
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// used by another M in the interim.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 系统调用状态。此时的P没有执行用户代码，它和一个处于syscall中的M间存在弱关联关系，可能会被另外一个M窃取走。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">_Psyscall</span> <span class="c1">// 系统调用中状态
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="c1">// _Pgcstop means a P is halted for STW and owned by the M
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// that stopped the world. The M that stopped the world
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// continues to use its P, even in _Pgcstop. Transitioning
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// from _Prunning to _Pgcstop causes an M to release its P and
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// park.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// The P retains its run queue and startTheWorld will restart
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// the scheduler on Ps with non-empty run queues.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// GC停止状态。P被STW挂起以执行GC，所有权归执行STW的M所有，执行STW的M会继续使用处于_Pgcstop状态的P。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 当P的状态从_Prunning转变成_Pgcstop时，会造成关联的M释放P的所有权，然后进入阻塞状态。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// P会保留它的本地runq，然后Start The World会从新启动这些本地runq不为空的P。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">_Pgcstop</span> <span class="c1">// GC停止状态
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="c1">// _Pdead means a P is no longer used (GOMAXPROCS shrank). We
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// reuse Ps if GOMAXPROCS increases. A dead P is mostly
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// stripped of its resources, though a few things remain
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// (e.g., trace buffers).
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 停用状态。因为GOMAXPROCS收缩，会造成多余的P被停用，当GOMAXPROCS再次增大时还会被复用。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 一个停用的P，大部分资源被剥夺，只有很少量保留。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">_Pdead</span> <span class="c1">// 停用状态
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">)</span>
</span></span></code></pre></div><h2 id="type-schedt-struct">type schedt struct<a hidden class="anchor" aria-hidden="true" href="#type-schedt-struct">#</a></h2>
<ol>
<li><code>schedt</code>结构体用来保存调度器的状态信息和(可运行或空闲的)<code>goroutine</code>的容器以及保存<code>goroutine</code>的运行队列</li>
<li>每个Go程序中只有一个调度器，多以每个Go程序中schedt结构体只有一个实例对象，该实例对象在源代码中被定义成了一个共享的全局变量</li>
<li>这样每个工作线程都可以访问它以及它所拥有的goroutine运行队列，我们称这个运行队列为<strong>全局goroutine运行队列</strong></li>
</ol>
<ul>
<li>全局运行队列是每个工作线程都可以读写的，因此访问它需要加锁，然而在一个繁忙的系统中，加锁会导致严重的性能问题</li>
<li>于是又为每个工作线程引入一个私有的<strong>局部goroutine运行队列</strong>，工作线程优先使用自己的局部运行队列，只有必要时才会去访问全局运行队列</li>
<li>这大大减少了锁冲突，提高了工作线程的并发性</li>
</ul>
<ol start="4">
<li>在Go调度器源代码中，局部运行队列被包含在<strong>p结构体</strong>的实例对象之中，每一个运行着go代码的工作线程都会与一个p结构体的实例对象关联在一起</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">schedt</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// accessed atomically. keep at top to ensure alignment on 32-bit systems.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 用作全局的goid分配器，以保证goid的唯一性。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// P中的goidcache就是从这里批量分配获取goid的。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">goidgen</span>   <span class="kt">uint64</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 以下两个字段可以在IO轮询时判断是否有需要的timer已到时间需要去执行
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 上次网络轮询的时间点，如果当前轮询，则为 0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 记录的是上次执行netpoll的时间，如果等于0，则表示某个线程正在阻塞式地执行netpoll。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">lastpoll</span>  <span class="kt">uint64</span> <span class="c1">// time of last network poll, 0 if currently polling
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 下次timer应该被唤醒时间点，来自timer四叉数中的时间
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 表示阻塞式地netpoll将在何时被唤醒。GO1.14版本重构了Timer，引入了该字段，唤醒netpoller以处理Timer。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">pollUntil</span> <span class="kt">uint64</span> <span class="c1">// time to which current poll is sleeping
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 全局范围的调度器锁，访问sched中的很多字段需要提前获得该锁。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">lock</span> <span class="nx">mutex</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// When increasing nmidle, nmidlelocked, nmsys, or nmfreed, be
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// sure to call checkdead().
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 有空闲的工作线程M组成的链表
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 空闲M链表的链表头，nmidle记录的是空闲M的数量，即链表的长度。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">midle</span>        <span class="nx">muintptr</span> <span class="c1">// idle m&#39;s waiting for work
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 空闲的工作线程数量
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">nmidle</span>       <span class="kt">int32</span>    <span class="c1">// number of idle m&#39;s waiting for work
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 统计的是与G绑定(LockOSThread)且处于空闲状态的M，绑定的G没有在运行，相应的M不能用来运行其他G，只能挂起，以便进入空闲状态。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">nmidlelocked</span> <span class="kt">int32</span>    <span class="c1">// number of locked m&#39;s waiting for work
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 下一个工作线程M的ID值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 记录了共创建了多少个M，同时也被用作下一个M的ID。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">mnext</span>        <span class="kt">int64</span>    <span class="c1">// number of m&#39;s that have been created and next M ID
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 最多只能创建maxmcount个工作线程M，初始化时该值为10000，schedinit()中被设置。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 限制了最多允许的M的个数，除去那些已经释放的。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">maxmcount</span>    <span class="kt">int32</span>    <span class="c1">// maximum number of m&#39;s allowed (or die)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 统计的是系统M的个数。比如监控线程sysmon启动时会 nmsys++。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">nmsys</span>        <span class="kt">int32</span>    <span class="c1">// number of system m&#39;s not counted for deadlock
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 统计的是累计已经释放了所少M。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">nmfreed</span>      <span class="kt">int64</span>    <span class="c1">// cumulative number of freed m&#39;s
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 记录的是系统goroutine的数量，会被原子性的更新。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">ngsys</span> <span class="kt">uint32</span> <span class="c1">// 系统 goroutine 的数量； 原子更新
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 由空闲的p结构体对象组成的链表
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 空闲P链表的表头，npidle记录了空闲P的个数，也就是链表的长度。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">pidle</span>      <span class="nx">puintptr</span> <span class="c1">// idle p&#39;s
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 空闲的p结构体对象的数量
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">npidle</span>     <span class="kt">uint32</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 正在自旋的M的数量
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 记录的是处于自旋状态的M的数量。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">nmspinning</span> <span class="kt">uint32</span> <span class="c1">// See &#34;Worker thread parking/unparking&#34; comment in proc.go.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Global runnable queue.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// goroutine全局运行队列，全局的就绪队列。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">runq</span>     <span class="nx">gQueue</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 记录的是全局就绪队列的长度。也就是全局队列goroutine的个数。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">runqsize</span> <span class="kt">int32</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// disable controls selective disabling of the scheduler.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// Use schedEnableUser to control this.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// disable is protected by sched.lock.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 用来禁止调度用户goroutine，其中的user变量被置为true后，调度器将不在调度执行用户goroutine，
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 系统goroutine不受影响。期间就绪的用户gouroutine会被临时存储放到disable.runnable队列中，变量n记录了队列长度。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// GC期间。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">disable</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// user disables scheduling of user goroutines.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">user</span>     <span class="kt">bool</span>
</span></span><span class="line"><span class="cl">        <span class="nx">runnable</span> <span class="nx">gQueue</span> <span class="c1">// pending runnable Gs
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">n</span>        <span class="kt">int32</span>  <span class="c1">// length of runnable
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// Global cache of dead G&#39;s.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// gFree是所有已退出的goroutine对应的g结构体对象组成的链表
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 用于缓存g结构体对象，避免每次创建gouroutine时都重新分配内存
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 用来存储已经退出运行的G，lock是本结构单独的锁，避免争用sched.lock。stack和noStack这两个列表分别用来存储有栈的G，因为在
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// G结束运行被回收的时候，如果栈大小超过了标准大小，就会被释放，所以有一部分G是没有栈的。变量n是两个列表之和，也就是总缓存了多少个G。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">gFree</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">lock</span>    <span class="nx">mutex</span>
</span></span><span class="line"><span class="cl">        <span class="nx">stack</span>   <span class="nx">gList</span> <span class="c1">// Gs with stacks
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">noStack</span> <span class="nx">gList</span> <span class="c1">// Gs without stacks
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">n</span>       <span class="kt">int32</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// Central cache of sudog structs.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 构成了 sudog 结构的中央缓存，供各个P存储。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">sudoglock</span>  <span class="nx">mutex</span>
</span></span><span class="line"><span class="cl">    <span class="nx">sudogcache</span> <span class="o">*</span><span class="nx">sudog</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// Central pool of available defer structs of different sizes.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 构成了 _defer 结构的中央缓存。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">deferlock</span> <span class="nx">mutex</span>
</span></span><span class="line"><span class="cl">    <span class="nx">deferpool</span> <span class="p">[</span><span class="mi">5</span><span class="p">]</span><span class="o">*</span><span class="nx">_defer</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// freem is the list of m&#39;s waiting to be freed when their
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// m.exited is set. Linked through m.freelink.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// freem 是设置 m.exited 时等待释放的 m 的列表。 通过 m.freelink 链接。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 一组已经结束运行的M构成的链表头，通过m.freem链接到下一个项，链表中的内容在分配新的M时会被复用。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">freem</span> <span class="o">*</span><span class="nx">m</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 表示GC正在等待运行，和stopwait、stopnote一同被用于实现STW。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// stopwait记录了STW需要停止的P的数量，发起STW的线程会先把GOMAXPROCS赋值给stopwait，也就是需要停止所有的P。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 再把gcwaiting置为1，然后再stopnote上睡眠等待被唤醒。其他正在运行的M检测到gcwaiting后会释放关联P的所有权，并把P的状态
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 置为_Pgcstop，再把stopwait的值减1，然后M把自己挂起。M在自我挂起之前如果检测到stopwait==0，也就是所有P都已经停止了，
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 就会通过stopnote唤醒发起STW的线程。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">gcwaiting</span>  <span class="kt">uint32</span> <span class="c1">// gc is waiting to run; GC是否正在处于等待
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">stopwait</span>   <span class="kt">int32</span>
</span></span><span class="line"><span class="cl">    <span class="nx">stopnote</span>   <span class="nx">note</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c1">// sysmonwait的值为0或1，表示sysmon线程是否sleep。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//  1. 0时，sysmon没有sleep。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//  2. 1时，sysmon在sysmonnote上sleep。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 当STW时sysmon可能会挂在sysmonnote上，在STW退出时会唤醒sysmon。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 当所有P都空闲(可能是陷入系统调用中)，sysmon可能会挂在
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">sysmonwait</span> <span class="kt">uint32</span>
</span></span><span class="line"><span class="cl">    <span class="nx">sysmonnote</span> <span class="nx">note</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// While true, sysmon not ready for mFixup calls.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// Accessed atomically.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 表示主线程已经创建了监控线程sysmon，但是后者尚未开始运行，某些操作需要等到sysmon启动之后才能进行。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">sysmonStarting</span> <span class="kt">uint32</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// safepointFn should be called on each P at the next GC
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// safepoint if p.runSafePointFn is set.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 如果设置了 p.runSafePointFn，则应该在下一个 GC 安全点对每个 P 调用 safepointFn
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 是一个Function Value.safePointWait 和 Value.safePointNote的左右类似stopwait和stopnone，被runtime.forEachP用来确保每个P都在
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 下一个GC安全点执行了 safePointFn。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">safePointFn</span>   <span class="kd">func</span><span class="p">(</span><span class="o">*</span><span class="nx">p</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nx">safePointWait</span> <span class="kt">int32</span>
</span></span><span class="line"><span class="cl">    <span class="nx">safePointNote</span> <span class="nx">note</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 用来设置性能分析的采样频率。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">profilehz</span> <span class="kt">int32</span> <span class="c1">// cpu profiling rate
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 最后一次改变gomaxprocs的时间，参看procresize()函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 统计了改变GOMAXPROCS所花费的时间。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">procresizetime</span> <span class="kt">int64</span> <span class="c1">// nanotime() of last change to gomaxprocs
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">totaltime</span>      <span class="kt">int64</span> <span class="c1">// ∫gomaxprocs dt up to procresizetime
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="c1">// sysmonlock protects sysmon&#39;s actions on the runtime.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// Acquire and hold this mutex to block sysmon from interacting
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// with the rest of the runtime.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 监控线程sysmon访问runtime数据时会加上的锁，其他线程可以通过它和监控线程进行同步。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">sysmonlock</span> <span class="nx">mutex</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h2 id="重要的全局变量">重要的全局变量<a hidden class="anchor" aria-hidden="true" href="#重要的全局变量">#</a></h2>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">var</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="nx">allgs</span> <span class="p">[]</span><span class="o">*</span><span class="nx">g</span>	<span class="c1">// 保存所有的g
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">allm</span>  <span class="o">*</span><span class="nx">m</span>    <span class="c1">// 所有的m构成的一个链表，包括下面的m0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">allp</span>  <span class="p">[]</span><span class="o">*</span><span class="nx">p</span>  <span class="c1">// 保存所有的p，len(allp) == gomaxprocs
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="nx">ncpu</span>  <span class="kt">int32</span> <span class="c1">// 系统中cpu核的数量，程序启动时由runtime代码初始化
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">gomaxprocs</span> <span class="kt">int32</span> <span class="c1">// p的最大值，默认等于ncpu，但可以通过GOMAXPROCS修改
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="nx">sched</span> <span class="nx">schedt</span> <span class="c1">// 调度器结构体对象，记录了调度器的工作状态
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="nx">m0</span>   <span class="nx">m</span>      <span class="c1">// 代表进程的主线程
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">g0</span>   <span class="nx">g</span>      <span class="c1">// m0的g0，也是m0.g0 = &amp;g0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Information about what cpu features are available.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// Packages outside the runtime should not use these
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// as they are not an external api.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// Set on startup in asm_{386,amd64}.s
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">processorVersionInfo</span> <span class="kt">uint32</span> <span class="c1">// CPU厂商信息，能根据该标识找到对应厂商
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">isIntel</span> <span class="kt">bool</span> <span class="c1">// true.当前处理器信息是英特，false.不是英特处理器
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">)</span>
</span></span></code></pre></div>

  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://heliu.site/tags/golang/">Golang</a></li>
      <li><a href="https://heliu.site/tags/goroutine/">Goroutine</a></li>
    </ul>
<nav class="paginav">
  <a class="prev" href="https://heliu.site/posts/golang/goroutine/retake/">
    <span class="title">« 上一页</span>
    <br>
    <span>被动让出调度</span>
  </a>
  <a class="next" href="https://heliu.site/posts/golang/channel/use/">
    <span class="title">下一页 »</span>
    <br>
    <span>Channel(使用)</span>
  </a>
</nav>

  </footer>
</article>
    </main>
    
<footer class="footer">
    
    <div class="busuanzi-footer">
    <span id="busuanzi_container_site_pv">
        本站总访问量<span id="busuanzi_value_site_pv"></span>次
    </span>
    <span id="busuanzi_container_site_uv">
        本站访客数<span id="busuanzi_value_site_uv"></span>人次
    </span>
    </div>
        <span>Copyright © 2024 蜀ICP备2024091074号 <a href="#">heliu's blog</a>. All rights reserved</span>  
    
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'Copy';

        function copyingDone() {
            copybutton.innerHTML = 'Done';
            setTimeout(() => {
                copybutton.innerHTML = 'Copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
