<!DOCTYPE html>
<html lang="zh" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>user goroutine | Helium</title>
<meta name="keywords" content="golang, Goroutine">
<meta name="description" content="💥本文章所有相关go代码参考自go 1.18&#43;版本">
<meta name="author" content="helium">
<link rel="canonical" href="https://helium-chain.github.io/posts/golang/goroutine/user/">
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<meta name="referrer" content="no-referrer-when-downgrade">
<link crossorigin="anonymous" href="/assets/css/stylesheet.css" rel="preload stylesheet" as="style">
<link rel="icon" href="https://helium-chain.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://helium-chain.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://helium-chain.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://helium-chain.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://helium-chain.github.io/apple-touch-icon.png">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="zh" href="https://helium-chain.github.io/posts/golang/goroutine/user/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
<html>
<head>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/jetbrains-mono@1.0.6/css/jetbrains-mono-nl.min.css" />
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lxgw-wenkai-lite-webfont@1.1.0/style.css" />
    <link rel="stylesheet" href="https://cdn.staticfile.org/lxgw-wenkai-screen-webfont/1.6.0/style.css" />
    <style>
        body {
            font-family: "LXGW WenKai Lite", sans-serif;
            font-family: "LXGW WenKai Screen", sans-serif;
        }
    </style>
</head>
</html>

  

<meta property="og:title" content="user goroutine" />
<meta property="og:description" content="💥本文章所有相关go代码参考自go 1.18&#43;版本" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://helium-chain.github.io/posts/golang/goroutine/user/" />
<meta property="og:image" content="https://helium-chain.github.io/favicon-32x32.png" />
<meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-07-29T00:00:00+00:00" />
<meta property="article:modified_time" content="2024-07-29T00:00:00+00:00" /><meta property="og:site_name" content="Helium" />

<meta name="twitter:card" content="summary_large_image" />
<meta name="twitter:image" content="https://helium-chain.github.io/favicon-32x32.png" />
<meta name="twitter:title" content="user goroutine"/>
<meta name="twitter:description" content="💥本文章所有相关go代码参考自go 1.18&#43;版本"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Article",
      "item": "https://helium-chain.github.io/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Golang",
      "item": "https://helium-chain.github.io/posts/golang/"
    }, 
    {
      "@type": "ListItem",
      "position":  3 ,
      "name": "第12章 Goroutine",
      "item": "https://helium-chain.github.io/posts/golang/goroutine/"
    }, 
    {
      "@type": "ListItem",
      "position":  4 ,
      "name": "user goroutine",
      "item": "https://helium-chain.github.io/posts/golang/goroutine/user/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "user goroutine",
  "name": "user goroutine",
  "description": "💥本文章所有相关go代码参考自go 1.18+版本",
  "keywords": [
    "golang", "Goroutine"
  ],
  "articleBody": " 本篇是接着上一篇《go关键字》的后续，goroutine运行完后的回收阶段。 goexit() goroutine运行结束后返回到goexit+PCQuantum处。const PCQuantum = 1。 也就是接着执行CALL runtime·goexit1(SB)这条指令。 文件位置：go1.19.3/src/runtime/asm_amd64.s。 1591 1592 1593 1594 1595 1596 1597 1598 // The top-most function running on a goroutine // returns to goexit+PCQuantum. TEXT runtime·goexit(SB),NOSPLIT|TOPFRAME,$0-0 BYTE $0x90 // NOP 从下一条指令开始执行 CALL runtime·goexit1(SB) // 这条指令调用函数将永不返回 // traceback from goexit1 must hit code range of goexit // 从goexit1回溯必须达到goexit的代码范围 BYTE $0x90 // NOP goexit1() goexit1()函数通过调用mcall从当前运行的g2 goroutine切换到g0，然后在g0栈上调用和执行goexit0()这个函数。 文件位置：go1.19.3/src/runtime/proc.go。 3468 3469 3470 3471 3472 3473 3474 3475 3476 3477 3478 3479 3480 3481 3482 3483 // Finishes execution of the current goroutine. func goexit1() { if raceenabled { //与竞态检查有关，不关注 racegoend() } if trace.enabled { //与backtrace有关，不关注 traceGoEnd() } // 注意，mcall函数的参数是一个函数goexit0 // Function Value 结构 // type funcval struct { // fn uintptr // // 闭包捕获的参数在这 // } mcall(goexit0) } mcall() 函数原型：func mcall(fn func(*g))。 runtime.mcall()函数和systemstack()函数很像，也是切换到系统栈去执行某个Function Value。 但是也有些不同，mcall()函数不能在g0栈上调用，而且也不会再切换回来。 切换到m.g0栈，调用fn(g)。 Fn必须永不返回。它应该调用gogo(\u0026g-\u003esched)来保持g的运行。这里的g应该是g0。 从当前运行的g切换到g0，这一步包括保存当前g的调度信息，把g0设置到tls中，修改CPU的rsp寄存器使其指向g0的栈。 以当前运行的g为参数调用fn函数(此处为goexit0)。 mcall函数不能在g0栈上调用，而且也不会再切换回来。 文件位置：go1.19.3/src/runtime/asm_amd64.s。 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 # func mcall(fn func(*g)) # Switch to m-\u003eg0's stack, call fn(g). # Fn must never return. It should gogo(\u0026g-\u003esched) # to keep running g. TEXT runtime·mcall\u003cABIInternal\u003e(SB), NOSPLIT, $0-8 # 1) 从AX中获取参数，注意这里还是再普通goroutine中不是g0 # 在go1.17后版本中采用寄存器传参，因此AX作为第一个参数存储的是macll的参数 # 传参顺序 AX、BX、CX、DI、SI、R8、R9、R10、R11 MOVQ AX, DX # DX = \u0026funcval; \u0026funcval -\u003e goexit0 # 2) 保存状态到 g-\u003esched。这里的g是当前正在运行的goroutine。 # save state in g-\u003esched # 以下保存当前状态到g-\u003esched中，在go 1.17版本后R14寄存器存储的是当前工作线程运行的goroutine # 0(SP)：存储的是goexit1函数调用mall函数的下一条指令地址。也就是goexit1()函数的返回地址 MOVQ 0(SP), BX # caller's PC\tmcall返回地址放入BX # g.sched.pc = BX MOVQ BX, (g_sched+gobuf_pc)(R14) # g.sched.pc = BX，保存g的rip # fn+0(FP)表当前参数所在栈位置，也就是goexit1函数的SP位置处。因为参数在调用者栈上。 LEAQ fn+0(FP), BX # caller's SP MOVQ BX, (g_sched+gobuf_sp)(R14) # g.sched.sp = BX，保存g的rsp # g.sched.bp = BP MOVQ BP, (g_sched+gobuf_bp)(R14) # g.sched.bp = BP，保存g的rbp # 3) 切换到 m-\u003eg0 及其堆栈，调用fn函数。 # switch to m-\u003eg0 \u0026 its stack, call fn # # BX = m MOVQ g_m(R14), BX # BX = g.m，拿到当前工作线程M # SI = g0 MOVQ m_g0(BX), SI # SI = g.m.g0，那当当前工作线程M的g0栈 # 此刻，SI = g0， R14 = g，所以这里在判断g是否是g0，如果g == g0则一定是哪里代码写错了 CMPQ SI, R14 # if g == m-\u003eg0 call badmcall JNE goodm # SI和R14不相等则跳转 JMP runtime·badmcall(SB) goodm: # 正常流程跳转到这里 # AX = g MOVQ R14, AX # AX (and arg 0) = g，AX = g2，当前g不是g0，AX也是goexit0函数需要的参数 # R14 = g0 MOVQ SI, R14 # g = g.m.g0，R14 = g0，设置当前正在运行的是g0 # CX = \u0026m.tls[1] get_tls(CX) # Set G in TLS # TLS = g0 MOVQ R14, g(CX) # sp = g0.sched.sp MOVQ (g_sched+gobuf_sp)(R14), SP # AX = g 入栈，此时已经在g0的栈上了 # AX存储的时普通的goroutine，这里入栈也是goexit0()函数的参数 PUSHQ AX # open up space for fn's arg spill slot # R12 = funcval.fn; DX = \u0026funcval MOVQ 0(DX), R12 # fn的第一个成员是goexit0函数代码地址处，R12 = fn.fn # 调用goexit0()函数，参数再AX寄存器中，上下文在DX寄存器中。 CALL R12 # 调用 goexit0(g)，这里【永不会返回】 POPQ AX JMP\truntime·badmcall2(SB) RET goexit0() 在g0上继续执行goexit0()。参数：gp *g，当前运行完的普通的goroutine。 从g2栈切换到g0栈之后，下面开始在g0栈执行goexit0()函数，该函数完成最后的清理工作： 把g的状态从_Grunning变更为_Gdead。 然后把g的一些字段清空成零值。 调用dropg函数解除g和m之间的关系，其实就是设置 g-\u003em = nil,m-\u003ecurrg = nil。 把g放入p的freeg队列缓存起来供下次创建g时快速获取而不用从内存分配。freeg就是g的一个对象池。 调用schedule()函数再次进行调度。 文件位置：go1.19.3/src/runtime/runtime/proc.go。 3479 3480 3481 3482 3483 3484 3485 3486 3487 3488 3489 3490 3491 3492 3493 3494 3495 3496 3497 3498 3499 3500 3501 3502 3503 3504 3505 3506 3507 3508 3509 3510 3511 3512 3513 3514 3515 3516 3517 3518 3519 3520 3521 3522 3523 3524 3525 3526 3527 3528 3529 3530 3531 3532 3533 3534 3535 3536 3537 3538 3539 3540 3541 3542 3543 3544 3545 3546 3547 3548 3549 3550 3551 3552 3553 3554 3555 3556 3557 3558 3559 3560 3561 3562 3563 3564 3565 // goexit continuation on g0. func goexit0(gp *g) { _g_ := getg() // _g_ = g0 _p_ := _g_.m.p.ptr() // _p_ = g0.m.p // _Grunning：2 表示这个 goroutine 可以执行用户代码。 堆栈由这个 goroutine 拥有。 // 它不在运行队列中。它被分配了一个 M 和一个 P（g.m 和 g.m.p 是有效的） // _Gdead：6 表示这个 goroutine 当前未被使用，它可能刚刚退出，在空闲列表中，或者刚刚被初始化 casgstatus(gp, _Grunning, _Gdead) // g马上退出，所以设置其状态为_Gdead gcController.addScannableStack(_p_, -int64(gp.stack.hi-gp.stack.lo)) // 已分配栈总量 // sSystemGoroutine 报告在堆栈转储和死锁检测器中是否必须省略 goroutine g // 这是在 runtime.* 入口点启动的任何 goroutine，除了 runtime.main、runtime.handleAsyncEvent // （仅限 wasm）和有时 runtime.runfinq // 如果 fixed 为真，任何可以在用户和系统之间变化的 goroutine（即终结器 goroutine）都被认为是用户 goroutine if isSystemGoroutine(gp, false) { atomic.Xadd(\u0026sched.ngsys, -1) // sched.ngsys 记录系统goroutine的数量 } // 清空g保存的一些信息 gp.m = nil // lockedm 关联到与当前G绑定的M，可以参考下 LockOSThread。 locked := gp.lockedm != 0 gp.lockedm = 0 _g_.m.lockedg = 0 gp.preemptStop = false gp.paniconfault = false gp._defer = nil // should be true already but just in case. gp._panic = nil // non-nil for Goexit during panic. points at stack-allocated data. gp.writebuf = nil gp.waitreason = 0 gp.param = nil gp.labels = nil gp.timer = nil // gcBlackenEnabled：表示辅助助手和后台标记线程允许将对象置为黑色; // gcAssistBytes：表示当前goroutine还有信用值。（GC相关） if gcBlackenEnabled != 0 \u0026\u0026 gp.gcAssistBytes \u003e 0 { // Flush assist credit to the global pool. This gives // better information to pacing if the application is // rapidly creating an exiting goroutines. assistWorkPerByte := gcController.assistWorkPerByte.Load() scanCredit := int64(assistWorkPerByte * float64(gp.gcAssistBytes)) atomic.Xaddint64(\u0026gcController.bgScanCredit, scanCredit) gp.gcAssistBytes = 0 } // g2-\u003em = nil, m-\u003ecurrg = nil 解绑g和m之关系 // m-\u003ecurrg记录着前一个g信息 // func dropg() { // _g_ := getg() // _g_ = g0 // setMNoWB(\u0026_g_.m.curg.m, nil) // g2-\u003em = nil // setGNoWB(\u0026_g_.m.curg, nil) // m-\u003ecurrg = nil // } // // func setMNoWB(mp **m, new *m) { // (*muintptr)(unsafe.Pointer(mp)).set(new) // } dropg() // 解绑gp的m和当前m.currg值 if GOARCH == \"wasm\" { // no threads yet on wasm gfput(_p_, gp) schedule() // never returns } // lockedInt 内部lockOSThread的跟踪 if _g_.m.lockedInt != 0 { print(\"invalid m-\u003elockedInt = \", _g_.m.lockedInt, \"\\n\") throw(\"internal lockOSThread error\") } // go keyword 文档关于 gfput 和 gfget 函数注解。 gfput(_p_, gp) // g2放入p的freeg队列，方便下次重用，免得再去申请内存，提高效率 if locked { // The goroutine may have locked this thread because // it put it in an unusual kernel state. Kill it // rather than returning it to the thread pool. // Return to mstart, which will release the P and exit // the thread. if GOOS != \"plan9\" { // See golang.org/issue/22227. gogo(\u0026_g_.m.g0.sched) } else { // Clear lockedExt on plan9 since we may end up re-using // this thread. _g_.m.lockedExt = 0 } } schedule() // 下面再次调用schedule } ",
  "wordCount" : "943",
  "inLanguage": "zh",
  "image": "https://helium-chain.github.io/favicon-32x32.png","datePublished": "2024-07-29T00:00:00Z",
  "dateModified": "2024-07-29T00:00:00Z",
  "author":[{
    "@type": "Person",
    "name": "helium"
  }],
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://helium-chain.github.io/posts/golang/goroutine/user/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Helium",
    "logo": {
      "@type": "ImageObject",
      "url": "https://helium-chain.github.io/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://helium-chain.github.io/" accesskey="h" title="Blog (Alt + H)">
                <img src="https://helium-chain.github.io/helium.png" alt="" aria-label="logo"
                    height="35">Blog</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://helium-chain.github.io/" title="主页">
                    <span>Home</span>
                </a>
            </li>
            <li>
                <a href="https://helium-chain.github.io/posts" title="文章">
                    <span>Article</span>
                </a>
            </li>
            <li>
                <a href="https://helium-chain.github.io/archives" title="时间轴">
                    <span>Archive</span>
                </a>
            </li>
            <li>
                <a href="https://helium-chain.github.io/tags/" title="标签">
                    <span>Tag</span>
                </a>
            </li>
            <li>
                <a href="https://helium-chain.github.io/search/" title="搜索 (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
            <li>
                <a href="https://helium-chain.github.io/support" title="打赏">
                    <span>🫶Help</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">


<article class="post" autonumbering>
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://helium-chain.github.io/">主页</a>&nbsp;»&nbsp;<a href="https://helium-chain.github.io/posts/">Article</a>&nbsp;»&nbsp;<a href="https://helium-chain.github.io/posts/golang/">Golang</a>&nbsp;»&nbsp;<a href="https://helium-chain.github.io/posts/golang/goroutine/">第12章 Goroutine</a></div>
    <h1 class="post-title entry-hint-parent">
      user goroutine
    </h1>
    <div class="post-description">
      💥本文章所有相关go代码参考自go 1.18&#43;版本
    </div>
    <div class="post-meta">










<span class="x-post-meta-item"><svg t="1720837714681" class="icon" viewBox="0 0 1084 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="7520" width="200" height="200"><path d="M123.47509 1023.984942a123.565437 123.565437 0 0 1-123.505206-123.32451V243.863302A123.565437 123.565437 0 0 1 123.47509 120.568908h171.630374V26.06529a26.050232 26.050232 0 0 1 52.070349 0v94.503618h377.592848V26.06529a26.050232 26.050232 0 0 1 52.100464 0v94.503618h183.797189A123.565437 123.565437 0 0 1 1084.171519 243.863302v656.79713A123.565437 123.565437 0 0 1 960.666314 1023.984942H123.47509z m-71.404741-123.32451A71.434857 71.434857 0 0 0 123.47509 971.974825h837.191224a71.434857 71.434857 0 0 0 71.404741-71.314393V442.326922l-946.361273-3.824716a25.598494 25.598494 0 0 1-5.84248-0.692665l-27.796953-6.444798v469.295689zM123.47509 172.579025a71.434857 71.434857 0 0 0-71.404741 71.284277v149.736133l27.796953-6.444797a26.080348 26.080348 0 0 1 5.902712-0.662549l946.301041 3.824716V243.863302a71.404741 71.404741 0 0 0-71.404741-71.284277h-180.183284l-6.173754 12.859479a26.200812 26.200812 0 0 1-23.490383 14.786895 26.261043 26.261043 0 0 1-23.520499-14.786895l-6.173754-12.859479H350.819834l-6.173754 12.859479a26.200812 26.200812 0 0 1-23.490383 14.786895 26.230928 26.230928 0 0 1-23.520499-14.786895l-6.173755-12.859479H123.47509z m156.150814 578.827128a26.050232 26.050232 0 0 1-26.050232-25.990001c0-14.335157 11.68496-26.020116 26.050232-26.020116h521.697312c14.365273 0 26.050232 11.68496 26.050233 26.020116a26.050232 26.050232 0 0 1-26.050233 25.990001H279.625904z" fill="#3D3F42" p-id="7521"></path></svg><span>2024-07-29</span></span>&nbsp;<span class="x-post-meta-item"><svg t="1720839329181" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="14106" width="200" height="200"><path d="M699.270662 190.485379c-0.411369 0-0.821715 0.011256-1.227967 0.032746H507.034407a23.041786 23.041786 0 0 0-1.221828-0.031723c-12.779048 0-23.140023 10.359952-23.140023 23.139 0 12.781094 10.360975 23.141046 23.140023 23.141046v0.032746h193.458083v-0.032746c12.780071 0 23.141046-10.359952 23.141047-23.141046 0-12.780071-10.360975-23.140023-23.141047-23.140023zM979.215516 724.005508c0-142.090159-115.186416-257.277598-257.277598-257.277598-72.245418 0-137.532353 29.777187-184.262654 77.725223l45.868677 31.474852c36.227086-33.873482 84.882226-54.617945 138.393977-54.617945 111.945605 0 202.696492 90.750887 202.696492 202.695468h-43.01263l70.331835 104.289228 70.331835-104.289228H979.215516z" fill="" p-id="14107"></path><path d="M748.885664 588.843132c0-14.881942-12.06785-26.945699-26.947746-26.945698-14.883989 0-26.947745 12.063757-26.947745 26.945698v135.164423c0 14.879895 12.063757 26.945699 26.947745 26.945699h107.786889c14.881942 0 26.945699-12.063757 26.945698-26.945699s-12.063757-26.945699-26.945698-26.945699h-80.839143V588.843132zM721.937918 926.702c-111.947651 0-202.696492-90.74884-202.696492-202.696492 0-0.144286 0.004093-0.285502 0.004094-0.429788h43.004443l-70.330812-104.289228-70.331835 104.289228h43.075051c0 0.144286-0.00307 0.285502-0.00307 0.429788 0 142.091182 115.187439 257.279644 257.278621 257.279645 72.241324 0 137.530306-29.77821 184.260607-77.727269l-45.86663-31.474852c-36.227086 33.873482-84.884272 54.618968-138.393977 54.618968zM694.633039 423.38066c-1.354857-11.487635-11.120268-20.400632-22.972201-20.400632H206.362486c-12.780071 0-23.140023 10.359952-23.140023 23.138999 0 12.781094 10.359952 23.141046 23.140023 23.141047H596.949252c30.209022-13.81668 63.104223-22.76754 97.683787-25.879414zM438.548616 623.143333H206.362486c-12.780071 0-23.140023 10.358929-23.140023 23.140023 0 12.780071 10.359952 23.140023 23.140023 23.140023h219.956598a298.463626 298.463626 0 0 1 12.229532-46.280046zM506.934123 513.062192H206.362486c-12.780071 0-23.140023 10.359952-23.140023 23.139 0 12.781094 10.359952 23.140023 23.140023 23.140023H469.936487a302.241672 302.241672 0 0 1 36.997636-46.279023z" fill="" p-id="14108"></path><path d="M442.765661 835.277778a298.531164 298.531164 0 0 1-14.365173-46.150087H146.542052v-0.065491c-33.036417 0-59.81941-26.78197-59.81941-59.819411V329.36031h704.907545v100.905154a298.561863 298.561863 0 0 1 46.150086 14.996552V194.619536h-0.162706c0-53.422723-43.307342-96.728018-96.730065-96.728018h-68.89409V84.418668c0-33.037441-26.782993-59.81941-59.81941-59.81941v-0.361227h-18.87079v0.032745c-33.038464 0-59.820434 26.78197-59.820433 59.819411 0 0.109494 0.008186 0.218988 0.008186 0.328481h-0.339738v13.47285H345.203648V84.418668c0-33.037441-26.782993-59.81941-59.819411-59.81941v-0.361227h-18.872836v0.032745c-33.036417 0-59.81941 26.78197-59.81941 59.819411 0 0.109494 0.007163 0.218988 0.008186 0.328481h-0.339737v13.47285h-69.189826c-53.4217 0-96.729042 43.306318-96.729041 96.728018 0 1.701758 0.045025 3.39226 0.132006 5.071505v533.785166a98.051153 98.051153 0 0 0-0.132006 5.071506c0 53.4217 43.307342 96.728018 96.729041 96.728018v0.001023h305.595047zM86.723665 204.056466c0-33.037441 26.782993-59.81941 59.819411-59.819411 0.044002 0 0.086981 0.00307 0.130983 0.00307v-0.068561h105.968473V94.874811h0.032746a22.807449 22.807449 0 0 1-0.032746-1.215688c0-12.779048 10.360975-23.140023 23.140023-23.140023s23.140023 10.360975 23.140023 23.140023c0 0.408299-0.010233 0.812505-0.031722 1.215688h0.031722v49.297776h280.508696V94.874811h0.032745a22.807449 22.807449 0 0 1-0.032745-1.215688c0-12.779048 10.361999-23.140023 23.140023-23.140023 12.780071 0 23.141046 10.360975 23.141046 23.140023 0 0.408299-0.011256 0.812505-0.032746 1.215688h0.032746v49.297776h106.10048v0.065492c33.035394 0 59.818387 26.780947 59.818387 59.81941h0.130983V283.080264H86.723665v-79.023798z" fill="" p-id="14109"></path></svg><span>2024-07-29</span></span>&nbsp;<span class="x-post-meta-item"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2" fill="none"
     stroke-linecap="round" stroke-linejoin="round" class="feather feather-file-text" style="user-select: text;">
    <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z" style="user-select: text;"></path>
    <polyline points="14 2 14 8 20 8" style="user-select: text;"></polyline>
    <line x1="16" y1="13" x2="8" y2="13" style="user-select: text;"></line>
    <line x1="16" y1="17" x2="8" y2="17" style="user-select: text;"></line>
    <polyline points="10 9 9 9 8 9" style="user-select: text;"></polyline>
</svg><span>943字</span></span>&nbsp;<span class="x-post-meta-item"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2" fill="none"
     stroke-linecap="round" stroke-linejoin="round">
    <path stroke="none" d="M0 0h24v24H0z" fill="none"></path>
    <circle cx="12" cy="12" r="9"></circle>
    <polyline points="12 7 12 12 15 15"></polyline>
</svg><span>5分钟</span></span>&nbsp;<span class="x-post-meta-item"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2" fill="none"
     stroke-linecap="round" stroke-linejoin="round">
    <path stroke="none" d="M0 0h24v24H0z" fill="none"></path>
    <circle cx="12" cy="7" r="4"></circle>
    <path d="M6 21v-2a4 4 0 0 1 4 -4h4a4 4 0 0 1 4 4v2"></path>
</svg><span>helium</span></span>
      <span class="x-post-meta-item">
        &nbsp;<svg t="1720840393161" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="18680" width="200" height="200"><path d="M995.125144 559.61812l-415.998603-415.998602A52.986489 52.986489 0 0 0 541.413335 127.99957H338.847348c-3.166656-26.559911-9.286635-51.046495-17.999939-71.333094C299.734146 7.333309 271.154242 0 256.00096 0c-13.939953 0-40.439864 6.339979-61.259794 48.806503-10.473298 21.366595-17.946606 48.966502-21.573261 79.193067H53.334974a53.393154 53.393154 0 0 0-53.333154 53.333154v360.078791a52.986489 52.986489 0 0 0 15.619948 37.713206l415.998602 415.998603a53.333154 53.333154 0 0 0 75.426413 0l26.286579-26.293245 26.286578 26.293245a53.426487 53.426487 0 0 0 16.719944 11.333295 21.333262 21.333262 0 0 0 36.079879 11.293295l382.705381-382.705381a53.399821 53.399821 0 0 0 0-75.426413z m-762.070774-491.998347C241.494342 50.373164 250.667645 42.666523 256.00096 42.666523c5.99998 0 16.573278 9.639968 25.646581 30.806564 6.493312 15.159949 11.333295 33.999886 14.146619 54.526483H216.16776c3.206656-23.419921 9.013303-44.359851 16.88661-60.41313z m243.819181 897.330319a10.666631 10.666631 0 0 1-15.079949 0l-415.998603-415.998603A10.573298 10.573298 0 0 1 42.668343 541.411515V181.332724a10.666631 10.666631 0 0 1 10.666631-10.666631h245.332509c0 47.853173-10.373298 92.15969-27.066575 115.632945-5.926647 8.326639-16.566611 14.186619-22.306592 16.113279C204.041135 314.752276 170.667913 356.218803 170.667913 405.331972c0 58.813136 47.853173 106.666308 106.666309 106.666308s106.666308-47.853173 106.666308-106.666308c0-47.086508-30.666564-87.139707-73.079754-101.246327C330.060711 272.705751 341.334007 223.692582 341.334007 170.666093h72.079758a10.573298 10.573298 0 0 1 7.539974 3.126656l415.998603 415.998603a10.666631 10.666631 0 0 1 0 15.079949zM341.334007 405.331972a63.999785 63.999785 0 1 1-63.999785-63.999785 64.073118 64.073118 0 0 1 63.999785 63.999785z m263.539114 559.61812a10.666631 10.666631 0 0 1-15.079949 0L563.499927 938.663513l303.625647-303.61898a53.399821 53.399821 0 0 0 0-75.426413L478.16688 170.666093h63.246455a10.573298 10.573298 0 0 1 7.539974 3.126656l415.998603 415.998603c0.239999 0.239999 0.466665 0.486665 0.666664 0.746664l0.086667 0.106666a10.666631 10.666631 0 0 1 0 13.373289l-0.086667 0.106666c-0.213333 0.259999-0.439999 0.506665-0.666664 0.746664z" fill="#5C5C66" p-id="18681"></path></svg>
        <ul class="post-tags-meta" style="display: inline-block;font-size: 14px;">
            <a href="https://helium-chain.github.io/tags/golang/" target="_blank" rel="noopener">Golang</a>
            <a href="https://helium-chain.github.io/tags/goroutine/" target="_blank" rel="noopener">Goroutine</a>
        </ul>
      </span>
      
      <span id="busuanzi_container_page_pv" class="x-post-meta-item">
        &nbsp;<svg t="1720844685710" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="27237" width="200" height="200"><path d="M739.754667 574.08c-121.386667 45.610667-208.469333 169.813333-208.64 316.16 0 33.408 4.693333 65.493333 13.141333 95.914667H94.122667c-26.453333-43.52-41.685333-91.946667-41.685334-143.189334 0-185.173333 192.896-335.104 430.805334-335.104 96.256 0 184.832 24.746667 256.512 66.218667z m-280.490667-114.986667a214.869333 214.869333 0 0 1-214.869333-215.04A215.04 215.04 0 0 1 459.264 28.842667a215.04 215.04 0 0 1 215.04 215.210666 215.04 215.04 0 0 1-215.04 215.04zM974.506667 641.28c9.856 0 17.834667 7.466667 17.834666 16.64v59.989333c-0.341333 8.789333-7.850667 15.786667-17.28 16.085334-9.856 0.341333-18.176-6.826667-18.517333-16.085334v-20.053333l-99.114667 91.093333-0.256 0.256a18.474667 18.474667 0 0 1-14.848 4.352h-0.768a18.176 18.176 0 0 1-9.344-4.608l-0.938666-0.981333-85.930667-80.042667-123.562667 115.072a18.773333 18.773333 0 0 1-25.216 0 15.786667 15.786667 0 0 1 0-23.466666l136.149334-126.848 0.725333-0.597334a18.645333 18.645333 0 0 1 24.362667 0.512l87.253333 81.237334 86.058667-79.232h-21.248c-9.386667-0.298667-16.938667-7.338667-17.28-16.085334-0.341333-9.173333 7.381333-16.896 17.28-17.237333h64.64z m-367.146667 240h48.128c8.874667 0 16.042667 7.168 16.042667 16.042667v72.192a16.042667 16.042667 0 0 1-16.042667 16.042666h-48.128a16.042667 16.042667 0 0 1-16.042667-16.042666v-72.192c0-8.874667 7.210667-16.042667 16.042667-16.042667z m110.805333-106.666667h48.128c8.874667 0 16.042667 7.168 16.042667 16.042667v178.858667a16.042667 16.042667 0 0 1-16.042667 16.042666h-48.128a16.042667 16.042667 0 0 1-16.042666-16.042666v-178.858667c0-8.874667 7.168-16.042667 16.042666-16.042667z m106.538667 80h48.128c8.874667 0 16.042667 7.168 16.042667 16.042667v99.413333a16.042667 16.042667 0 0 1-16.042667 16.042667H824.746667a16.042667 16.042667 0 0 1-16.042667-16.042667v-99.413333c0-8.874667 7.168-16.042667 16.042667-16.042667z m110.165333-80h48.128c8.874667 0 16.042667 7.168 16.042667 16.042667v179.413333a16.042667 16.042667 0 0 1-16.042667 16.042667h-48.128a16.042667 16.042667 0 0 1-16.042666-16.042667v-179.413333c0-8.874667 7.210667-16.042667 16.042666-16.042667z" fill="#999999" p-id="27238"></path></svg>
        <span id="busuanzi_value_page_pv"></span>
      </span>

</div>
  </header> <aside id="toc-container" class="toc-container wide">
    <div class="toc">
        <details  open>
            <summary accesskey="c" title="(Alt + C)">
                <span class="details">目录</span>
            </summary>

            <div class="inner"><ul>
                    <li>
                        <a href="#goexit" aria-label="goexit()">goexit()</a></li>
                    <li>
                        <a href="#goexit1" aria-label="goexit1()">goexit1()</a></li>
                    <li>
                        <a href="#mcall" aria-label="mcall()">mcall()</a></li>
                    <li>
                        <a href="#goexit0" aria-label="goexit0()">goexit0()</a>
                    </li>
                </ul>
            </div>
        </details>
    </div>
</aside>
<script>
    let activeElement;
    let elements;
    window.addEventListener('DOMContentLoaded', function (event) {
        checkTocPosition();

        elements = document.querySelectorAll('h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]');
         
         activeElement = elements[0];
         const id = encodeURI(activeElement.getAttribute('id')).toLowerCase();
         document.querySelector(`.inner ul li a[href="#${id}"]`).classList.add('active');
     }, false);

    window.addEventListener('resize', function(event) {
        checkTocPosition();
    }, false);

    window.addEventListener('scroll', () => {
        
        activeElement = Array.from(elements).find((element) => {
            if ((getOffsetTop(element) - window.pageYOffset) > 0 && 
                (getOffsetTop(element) - window.pageYOffset) < window.innerHeight/2) {
                return element;
            }
        }) || activeElement

        elements.forEach(element => {
             const id = encodeURI(element.getAttribute('id')).toLowerCase();
             if (element === activeElement){
                 document.querySelector(`.inner ul li a[href="#${id}"]`).classList.add('active');
             } else {
                 document.querySelector(`.inner ul li a[href="#${id}"]`).classList.remove('active');
             }
         })
     }, false);

    const main = parseInt(getComputedStyle(document.body).getPropertyValue('--article-width'), 10);
    const toc = parseInt(getComputedStyle(document.body).getPropertyValue('--toc-width'), 10);
    const gap = parseInt(getComputedStyle(document.body).getPropertyValue('--gap'), 10);

    function checkTocPosition() {
        const width = document.body.scrollWidth;

        if (width - main - (toc * 2) - (gap * 4) > 0) {
            document.getElementById("toc-container").classList.add("wide");
        } else {
            document.getElementById("toc-container").classList.remove("wide");
        }
    }

    function getOffsetTop(element) {
        if (!element.getClientRects().length) {
            return 0;
        }
        let rect = element.getBoundingClientRect();
        let win = element.ownerDocument.defaultView;
        return rect.top + win.pageYOffset;   
    }
</script>
  <div class="post-content"><ul>
<li>本篇是接着上一篇《go关键字》的后续，goroutine运行完后的回收阶段。</li>
</ul>
<h2 id="goexit">goexit()<a hidden class="anchor" aria-hidden="true" href="#goexit">#</a></h2>
<ol>
<li><code>goroutine</code>运行结束后返回到<code>goexit+PCQuantum</code>处。<code>const PCQuantum = 1</code>。</li>
<li>也就是接着执行<code>CALL runtime·goexit1(SB)</code>这条指令。</li>
<li>文件位置：<code>go1.19.3/src/runtime/asm_amd64.s</code>。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1591
</span><span class="lnt">1592
</span><span class="lnt">1593
</span><span class="lnt">1594
</span><span class="lnt">1595
</span><span class="lnt">1596
</span><span class="lnt">1597
</span><span class="lnt">1598
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-asm" data-lang="asm"><span class="line"><span class="cl"><span class="c1">// The top-most function running on a goroutine
</span></span></span><span class="line"><span class="cl"><span class="c1">// returns to goexit+PCQuantum.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nf">TEXT</span> <span class="no">runtime</span><span class="err">·</span><span class="no">goexit</span><span class="p">(</span><span class="no">SB</span><span class="p">),</span><span class="no">NOSPLIT</span><span class="err">|</span><span class="no">TOPFRAME</span><span class="p">,</span><span class="no">$0-0</span>
</span></span><span class="line"><span class="cl">    <span class="nf">BYTE</span>    <span class="no">$0x90</span>               <span class="c1">// NOP 从下一条指令开始执行
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">CALL</span>    <span class="no">runtime</span><span class="err">·</span><span class="no">goexit1</span><span class="p">(</span><span class="no">SB</span><span class="p">)</span> <span class="c1">// 这条指令调用函数将永不返回
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// traceback from goexit1 must hit code range of goexit
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 从goexit1回溯必须达到goexit的代码范围
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">BYTE</span>    <span class="no">$0x90</span>               <span class="c1">// NOP
</span></span></span></code></pre></td></tr></table>
</div>
</div><h2 id="goexit1">goexit1()<a hidden class="anchor" aria-hidden="true" href="#goexit1">#</a></h2>
<ol>
<li><code>goexit1()</code>函数通过调用<code>mcall</code>从当前运行的<code>g2 goroutine</code>切换到<code>g0</code>，然后在<code>g0</code>栈上调用和执行<code>goexit0()</code>这个函数。</li>
<li>文件位置：<code>go1.19.3/src/runtime/proc.go</code>。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">3468
</span><span class="lnt">3469
</span><span class="lnt">3470
</span><span class="lnt">3471
</span><span class="lnt">3472
</span><span class="lnt">3473
</span><span class="lnt">3474
</span><span class="lnt">3475
</span><span class="lnt">3476
</span><span class="lnt">3477
</span><span class="lnt">3478
</span><span class="lnt">3479
</span><span class="lnt">3480
</span><span class="lnt">3481
</span><span class="lnt">3482
</span><span class="lnt">3483
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// Finishes execution of the current goroutine.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">goexit1</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">raceenabled</span> <span class="p">{</span>    <span class="c1">//与竞态检查有关，不关注
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nf">racegoend</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">trace</span><span class="p">.</span><span class="nx">enabled</span> <span class="p">{</span>  <span class="c1">//与backtrace有关，不关注
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nf">traceGoEnd</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 注意，mcall函数的参数是一个函数goexit0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// Function Value 结构 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// type funcval struct {
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//      fn uintptr
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//      // 闭包捕获的参数在这
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// }
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">mcall</span><span class="p">(</span><span class="nx">goexit0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="mcall">mcall()<a hidden class="anchor" aria-hidden="true" href="#mcall">#</a></h2>
<ol>
<li>函数原型：<strong><code>func mcall(fn func(*g))</code></strong>。</li>
<li><code>runtime.mcall()</code>函数和<code>systemstack()</code>函数很像，也是切换到系统栈去执行某个<code>Function Value</code>。</li>
<li>但是也有些不同，<code>mcall()</code>函数不能在<code>g0</code>栈上调用，而且也不会再切换回来。</li>
<li>切换到<code>m.g0</code>栈，调用<code>fn(g)</code>。</li>
<li><code>Fn</code>必须永不返回。它应该调用<code>gogo(&amp;g-&gt;sched)</code>来保持<code>g</code>的运行。这里的<code>g</code>应该是<code>g0</code>。</li>
<li>从当前运行的<code>g</code>切换到<code>g0</code>，这一步包括保存当前<code>g</code>的调度信息，把<code>g0</code>设置到<code>tls</code>中，修改<code>CPU</code>的<code>rsp</code>寄存器使其指向<code>g0</code>的栈。</li>
<li>以当前运行的<code>g</code>为参数调用<code>fn</code>函数(此处为<code>goexit0</code>)。</li>
<li><code>mcall</code>函数不能在<code>g0</code>栈上调用，而且也不会再切换回来。</li>
<li>文件位置：<code>go1.19.3/src/runtime/asm_amd64.s</code>。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">420
</span><span class="lnt">421
</span><span class="lnt">422
</span><span class="lnt">423
</span><span class="lnt">424
</span><span class="lnt">425
</span><span class="lnt">426
</span><span class="lnt">427
</span><span class="lnt">428
</span><span class="lnt">429
</span><span class="lnt">430
</span><span class="lnt">431
</span><span class="lnt">432
</span><span class="lnt">433
</span><span class="lnt">434
</span><span class="lnt">435
</span><span class="lnt">436
</span><span class="lnt">437
</span><span class="lnt">438
</span><span class="lnt">439
</span><span class="lnt">440
</span><span class="lnt">441
</span><span class="lnt">442
</span><span class="lnt">443
</span><span class="lnt">444
</span><span class="lnt">445
</span><span class="lnt">446
</span><span class="lnt">447
</span><span class="lnt">448
</span><span class="lnt">449
</span><span class="lnt">450
</span><span class="lnt">451
</span><span class="lnt">452
</span><span class="lnt">453
</span><span class="lnt">454
</span><span class="lnt">455
</span><span class="lnt">456
</span><span class="lnt">457
</span><span class="lnt">458
</span><span class="lnt">459
</span><span class="lnt">460
</span><span class="lnt">461
</span><span class="lnt">462
</span><span class="lnt">463
</span><span class="lnt">464
</span><span class="lnt">465
</span><span class="lnt">466
</span><span class="lnt">467
</span><span class="lnt">468
</span><span class="lnt">469
</span><span class="lnt">470
</span><span class="lnt">471
</span><span class="lnt">472
</span><span class="lnt">473
</span><span class="lnt">474
</span><span class="lnt">475
</span><span class="lnt">476
</span><span class="lnt">477
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-asm" data-lang="asm"><span class="line"><span class="cl"><span class="c1"># func mcall(fn func(*g))
</span></span></span><span class="line"><span class="cl"><span class="c1"># Switch to m-&gt;g0&#39;s stack, call fn(g).
</span></span></span><span class="line"><span class="cl"><span class="c1"># Fn must never return. It should gogo(&amp;g-&gt;sched)
</span></span></span><span class="line"><span class="cl"><span class="c1"># to keep running g.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nf">TEXT</span> <span class="no">runtime</span><span class="err">·</span><span class="no">mcall</span><span class="err">&lt;</span><span class="no">ABIInternal</span><span class="err">&gt;</span><span class="p">(</span><span class="no">SB</span><span class="p">),</span> <span class="no">NOSPLIT</span><span class="p">,</span> <span class="no">$0-8</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># 1) 从AX中获取参数，注意这里还是再普通goroutine中不是g0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    
</span></span><span class="line"><span class="cl">    <span class="c1"># 在go1.17后版本中采用寄存器传参，因此AX作为第一个参数存储的是macll的参数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1"># 传参顺序 AX、BX、CX、DI、SI、R8、R9、R10、R11
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">MOVQ</span>    <span class="no">AX</span><span class="p">,</span> <span class="no">DX</span>  <span class="c1"># DX = &amp;funcval; &amp;funcval -&gt; goexit0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="c1"># 2) 保存状态到 g-&gt;sched。这里的g是当前正在运行的goroutine。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="c1"># save state in g-&gt;sched
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1"># 以下保存当前状态到g-&gt;sched中，在go 1.17版本后R14寄存器存储的是当前工作线程运行的goroutine
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1"># 0(SP)：存储的是goexit1函数调用mall函数的下一条指令地址。也就是goexit1()函数的返回地址
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">MOVQ</span>    <span class="mi">0</span><span class="p">(</span><span class="no">SP</span><span class="p">),</span> <span class="no">BX</span>                   <span class="c1"># caller&#39;s PC	mcall返回地址放入BX
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1"># g.sched.pc = BX
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">MOVQ</span>    <span class="no">BX</span><span class="p">,</span> <span class="p">(</span><span class="no">g_sched</span><span class="err">+</span><span class="no">gobuf_pc</span><span class="p">)(</span><span class="no">R14</span><span class="p">)</span> <span class="c1"># g.sched.pc = BX，保存g的rip
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1"># fn+0(FP)表当前参数所在栈位置，也就是goexit1函数的SP位置处。因为参数在调用者栈上。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">LEAQ</span>    <span class="no">fn</span><span class="err">+</span><span class="mi">0</span><span class="p">(</span><span class="no">FP</span><span class="p">),</span> <span class="no">BX</span>                <span class="c1"># caller&#39;s SP
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">MOVQ</span>    <span class="no">BX</span><span class="p">,</span> <span class="p">(</span><span class="no">g_sched</span><span class="err">+</span><span class="no">gobuf_sp</span><span class="p">)(</span><span class="no">R14</span><span class="p">)</span> <span class="c1"># g.sched.sp = BX，保存g的rsp
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1"># g.sched.bp = BP
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">MOVQ</span>    <span class="no">BP</span><span class="p">,</span> <span class="p">(</span><span class="no">g_sched</span><span class="err">+</span><span class="no">gobuf_bp</span><span class="p">)(</span><span class="no">R14</span><span class="p">)</span> <span class="c1"># g.sched.bp = BP，保存g的rbp
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="c1"># 3) 切换到 m-&gt;g0 及其堆栈，调用fn函数。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="c1"># switch to m-&gt;g0 &amp; its stack, call fn
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1"># 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1"># BX = m
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">MOVQ</span>    <span class="no">g_m</span><span class="p">(</span><span class="no">R14</span><span class="p">),</span> <span class="no">BX</span>    <span class="c1"># BX = g.m，拿到当前工作线程M
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1"># SI = g0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">MOVQ</span>    <span class="no">m_g0</span><span class="p">(</span><span class="no">BX</span><span class="p">),</span> <span class="no">SI</span>    <span class="c1"># SI = g.m.g0，那当当前工作线程M的g0栈
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1"># 此刻，SI = g0， R14 = g，所以这里在判断g是否是g0，如果g == g0则一定是哪里代码写错了
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">CMPQ</span>    <span class="no">SI</span><span class="p">,</span> <span class="no">R14</span>         <span class="c1"># if g == m-&gt;g0 call badmcall
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">JNE</span> <span class="no">goodm</span> <span class="c1"># SI和R14不相等则跳转
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">JMP</span> <span class="no">runtime</span><span class="err">·</span><span class="no">badmcall</span><span class="p">(</span><span class="no">SB</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nl">goodm:</span>  <span class="c1"># 正常流程跳转到这里
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1"># AX = g
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">MOVQ</span>    <span class="no">R14</span><span class="p">,</span> <span class="no">AX</span>     <span class="c1"># AX (and arg 0) = g，AX = g2，当前g不是g0，AX也是goexit0函数需要的参数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1"># R14 = g0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">MOVQ</span>    <span class="no">SI</span><span class="p">,</span> <span class="no">R14</span>     <span class="c1"># g = g.m.g0，R14 = g0，设置当前正在运行的是g0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1"># CX = &amp;m.tls[1]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">get_tls</span><span class="p">(</span><span class="no">CX</span><span class="p">)</span>         <span class="c1"># Set G in TLS
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1"># TLS = g0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">MOVQ</span>    <span class="no">R14</span><span class="p">,</span> <span class="no">g</span><span class="p">(</span><span class="no">CX</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># sp = g0.sched.sp
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">MOVQ</span>    <span class="p">(</span><span class="no">g_sched</span><span class="err">+</span><span class="no">gobuf_sp</span><span class="p">)(</span><span class="no">R14</span><span class="p">),</span> <span class="no">SP</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># AX = g 入栈，此时已经在g0的栈上了
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1"># AX存储的时普通的goroutine，这里入栈也是goexit0()函数的参数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">PUSHQ</span>   <span class="no">AX</span>          <span class="c1"># open up space for fn&#39;s arg spill slot
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1"># R12 = funcval.fn; DX = &amp;funcval
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">MOVQ</span>    <span class="mi">0</span><span class="p">(</span><span class="no">DX</span><span class="p">),</span> <span class="no">R12</span>  <span class="c1"># fn的第一个成员是goexit0函数代码地址处，R12 = fn.fn
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1"># 调用goexit0()函数，参数再AX寄存器中，上下文在DX寄存器中。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">CALL</span>    <span class="no">R12</span>         <span class="c1"># 调用 goexit0(g)，这里【永不会返回】
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">POPQ</span>    <span class="no">AX</span>
</span></span><span class="line"><span class="cl">    <span class="nf">JMP</span>	<span class="no">runtime</span><span class="err">·</span><span class="no">badmcall2</span><span class="p">(</span><span class="no">SB</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nf">RET</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="goexit0">goexit0()<a hidden class="anchor" aria-hidden="true" href="#goexit0">#</a></h2>
<ol>
<li>在<code>g0</code>上继续执行<code>goexit0()</code>。参数：<code>gp *g</code>，当前运行完的普通的<code>goroutine</code>。</li>
<li>从<code>g2</code>栈切换到<code>g0</code>栈之后，下面开始在<code>g0</code>栈执行<code>goexit0()</code>函数，该函数完成最后的清理工作：
<ol>
<li>把<code>g</code>的状态从<code>_Grunning</code>变更为<code>_Gdead</code>。</li>
<li>然后把<code>g</code>的一些字段清空成零值。</li>
<li>调用<code>dropg</code>函数解除<code>g</code>和<code>m</code>之间的关系，其实就是设置 <strong><code>g-&gt;m = nil</code></strong>,<strong><code>m-&gt;currg = nil</code></strong>。</li>
<li>把<code>g</code>放入<code>p</code>的<code>freeg</code>队列缓存起来供下次创建<code>g</code>时快速获取而不用从内存分配。<code>freeg</code>就是<code>g</code>的一个对象池。</li>
<li>调用<code>schedule()</code>函数再次进行调度。</li>
</ol>
</li>
<li>文件位置：<code>go1.19.3/src/runtime/runtime/proc.go</code>。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">3479
</span><span class="lnt">3480
</span><span class="lnt">3481
</span><span class="lnt">3482
</span><span class="lnt">3483
</span><span class="lnt">3484
</span><span class="lnt">3485
</span><span class="lnt">3486
</span><span class="lnt">3487
</span><span class="lnt">3488
</span><span class="lnt">3489
</span><span class="lnt">3490
</span><span class="lnt">3491
</span><span class="lnt">3492
</span><span class="lnt">3493
</span><span class="lnt">3494
</span><span class="lnt">3495
</span><span class="lnt">3496
</span><span class="lnt">3497
</span><span class="lnt">3498
</span><span class="lnt">3499
</span><span class="lnt">3500
</span><span class="lnt">3501
</span><span class="lnt">3502
</span><span class="lnt">3503
</span><span class="lnt">3504
</span><span class="lnt">3505
</span><span class="lnt">3506
</span><span class="lnt">3507
</span><span class="lnt">3508
</span><span class="lnt">3509
</span><span class="lnt">3510
</span><span class="lnt">3511
</span><span class="lnt">3512
</span><span class="lnt">3513
</span><span class="lnt">3514
</span><span class="lnt">3515
</span><span class="lnt">3516
</span><span class="lnt">3517
</span><span class="lnt">3518
</span><span class="lnt">3519
</span><span class="lnt">3520
</span><span class="lnt">3521
</span><span class="lnt">3522
</span><span class="lnt">3523
</span><span class="lnt">3524
</span><span class="lnt">3525
</span><span class="lnt">3526
</span><span class="lnt">3527
</span><span class="lnt">3528
</span><span class="lnt">3529
</span><span class="lnt">3530
</span><span class="lnt">3531
</span><span class="lnt">3532
</span><span class="lnt">3533
</span><span class="lnt">3534
</span><span class="lnt">3535
</span><span class="lnt">3536
</span><span class="lnt">3537
</span><span class="lnt">3538
</span><span class="lnt">3539
</span><span class="lnt">3540
</span><span class="lnt">3541
</span><span class="lnt">3542
</span><span class="lnt">3543
</span><span class="lnt">3544
</span><span class="lnt">3545
</span><span class="lnt">3546
</span><span class="lnt">3547
</span><span class="lnt">3548
</span><span class="lnt">3549
</span><span class="lnt">3550
</span><span class="lnt">3551
</span><span class="lnt">3552
</span><span class="lnt">3553
</span><span class="lnt">3554
</span><span class="lnt">3555
</span><span class="lnt">3556
</span><span class="lnt">3557
</span><span class="lnt">3558
</span><span class="lnt">3559
</span><span class="lnt">3560
</span><span class="lnt">3561
</span><span class="lnt">3562
</span><span class="lnt">3563
</span><span class="lnt">3564
</span><span class="lnt">3565
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// goexit continuation on g0.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">goexit0</span><span class="p">(</span><span class="nx">gp</span> <span class="o">*</span><span class="nx">g</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">_g_</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">()</span>           <span class="c1">// _g_ = g0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">_p_</span> <span class="o">:=</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">p</span><span class="p">.</span><span class="nf">ptr</span><span class="p">()</span>    <span class="c1">// _p_ = g0.m.p
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    
</span></span><span class="line"><span class="cl">    <span class="c1">// _Grunning：2 表示这个 goroutine 可以执行用户代码。 堆栈由这个 goroutine 拥有。 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 它不在运行队列中。它被分配了一个 M 和一个 P（g.m 和 g.m.p 是有效的）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// _Gdead：6 表示这个 goroutine 当前未被使用，它可能刚刚退出，在空闲列表中，或者刚刚被初始化
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">casgstatus</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="nx">_Grunning</span><span class="p">,</span> <span class="nx">_Gdead</span><span class="p">)</span> <span class="c1">// g马上退出，所以设置其状态为_Gdead
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">gcController</span><span class="p">.</span><span class="nf">addScannableStack</span><span class="p">(</span><span class="nx">_p_</span><span class="p">,</span> <span class="o">-</span><span class="nb">int64</span><span class="p">(</span><span class="nx">gp</span><span class="p">.</span><span class="nx">stack</span><span class="p">.</span><span class="nx">hi</span><span class="o">-</span><span class="nx">gp</span><span class="p">.</span><span class="nx">stack</span><span class="p">.</span><span class="nx">lo</span><span class="p">))</span> <span class="c1">// 已分配栈总量
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// sSystemGoroutine 报告在堆栈转储和死锁检测器中是否必须省略 goroutine g
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 这是在 runtime.* 入口点启动的任何 goroutine，除了 runtime.main、runtime.handleAsyncEvent
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// （仅限 wasm）和有时 runtime.runfinq
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 如果 fixed 为真，任何可以在用户和系统之间变化的 goroutine（即终结器 goroutine）都被认为是用户 goroutine
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nf">isSystemGoroutine</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="kc">false</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">atomic</span><span class="p">.</span><span class="nf">Xadd</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">ngsys</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>   <span class="c1">// sched.ngsys 记录系统goroutine的数量
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c1">// 清空g保存的一些信息
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">gp</span><span class="p">.</span><span class="nx">m</span> <span class="p">=</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// lockedm 关联到与当前G绑定的M，可以参考下 LockOSThread。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">locked</span> <span class="o">:=</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">lockedm</span> <span class="o">!=</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">    <span class="nx">gp</span><span class="p">.</span><span class="nx">lockedm</span> <span class="p">=</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">    <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">lockedg</span> <span class="p">=</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">    <span class="nx">gp</span><span class="p">.</span><span class="nx">preemptStop</span> <span class="p">=</span> <span class="kc">false</span>
</span></span><span class="line"><span class="cl">    <span class="nx">gp</span><span class="p">.</span><span class="nx">paniconfault</span> <span class="p">=</span> <span class="kc">false</span>
</span></span><span class="line"><span class="cl">    <span class="nx">gp</span><span class="p">.</span><span class="nx">_defer</span> <span class="p">=</span> <span class="kc">nil</span> <span class="c1">// should be true already but just in case.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">gp</span><span class="p">.</span><span class="nx">_panic</span> <span class="p">=</span> <span class="kc">nil</span> <span class="c1">// non-nil for Goexit during panic. points at stack-allocated data.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">gp</span><span class="p">.</span><span class="nx">writebuf</span> <span class="p">=</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl">    <span class="nx">gp</span><span class="p">.</span><span class="nx">waitreason</span> <span class="p">=</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">    <span class="nx">gp</span><span class="p">.</span><span class="nx">param</span> <span class="p">=</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl">    <span class="nx">gp</span><span class="p">.</span><span class="nx">labels</span> <span class="p">=</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl">    <span class="nx">gp</span><span class="p">.</span><span class="nx">timer</span> <span class="p">=</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// gcBlackenEnabled：表示辅助助手和后台标记线程允许将对象置为黑色;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// gcAssistBytes：表示当前goroutine还有信用值。（GC相关）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nx">gcBlackenEnabled</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">gcAssistBytes</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// Flush assist credit to the global pool. This gives
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// better information to pacing if the application is
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// rapidly creating an exiting goroutines.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">assistWorkPerByte</span> <span class="o">:=</span> <span class="nx">gcController</span><span class="p">.</span><span class="nx">assistWorkPerByte</span><span class="p">.</span><span class="nf">Load</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">        <span class="nx">scanCredit</span> <span class="o">:=</span> <span class="nb">int64</span><span class="p">(</span><span class="nx">assistWorkPerByte</span> <span class="o">*</span> <span class="nb">float64</span><span class="p">(</span><span class="nx">gp</span><span class="p">.</span><span class="nx">gcAssistBytes</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">        <span class="nx">atomic</span><span class="p">.</span><span class="nf">Xaddint64</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">gcController</span><span class="p">.</span><span class="nx">bgScanCredit</span><span class="p">,</span> <span class="nx">scanCredit</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="nx">gp</span><span class="p">.</span><span class="nx">gcAssistBytes</span> <span class="p">=</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// g2-&gt;m = nil, m-&gt;currg = nil 解绑g和m之关系
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// m-&gt;currg记录着前一个g信息
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// func dropg() {
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//      _g_ := getg()                   // _g_ = g0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//      setMNoWB(&amp;_g_.m.curg.m, nil)    // g2-&gt;m = nil
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//      setGNoWB(&amp;_g_.m.curg, nil)      // m-&gt;currg = nil
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// }
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// func setMNoWB(mp **m, new *m) {
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//      (*muintptr)(unsafe.Pointer(mp)).set(new)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// }
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">dropg</span><span class="p">()</span> <span class="c1">// 解绑gp的m和当前m.currg值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">GOARCH</span> <span class="o">==</span> <span class="s">&#34;wasm&#34;</span> <span class="p">{</span> <span class="c1">// no threads yet on wasm
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nf">gfput</span><span class="p">(</span><span class="nx">_p_</span><span class="p">,</span> <span class="nx">gp</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="nf">schedule</span><span class="p">()</span> <span class="c1">// never returns
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// lockedInt 内部lockOSThread的跟踪
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">lockedInt</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nb">print</span><span class="p">(</span><span class="s">&#34;invalid m-&gt;lockedInt = &#34;</span><span class="p">,</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">lockedInt</span><span class="p">,</span> <span class="s">&#34;\n&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="nf">throw</span><span class="p">(</span><span class="s">&#34;internal lockOSThread error&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// go keyword 文档关于 gfput 和 gfget 函数注解。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">gfput</span><span class="p">(</span><span class="nx">_p_</span><span class="p">,</span> <span class="nx">gp</span><span class="p">)</span>  <span class="c1">// g2放入p的freeg队列，方便下次重用，免得再去申请内存，提高效率
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nx">locked</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// The goroutine may have locked this thread because
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// it put it in an unusual kernel state. Kill it
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// rather than returning it to the thread pool.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">        <span class="c1">// Return to mstart, which will release the P and exit
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// the thread.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="nx">GOOS</span> <span class="o">!=</span> <span class="s">&#34;plan9&#34;</span> <span class="p">{</span> <span class="c1">// See golang.org/issue/22227.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="nf">gogo</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">g0</span><span class="p">.</span><span class="nx">sched</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// Clear lockedExt on plan9 since we may end up re-using
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// this thread.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">lockedExt</span> <span class="p">=</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nf">schedule</span><span class="p">()</span>  <span class="c1">// 下面再次调用schedule
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div>

  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://helium-chain.github.io/tags/golang/">Golang</a></li>
      <li><a href="https://helium-chain.github.io/tags/goroutine/">Goroutine</a></li>
    </ul>
<nav class="paginav">
  <a class="prev" href="https://helium-chain.github.io/posts/golang/goroutine/newproc/">
    <span class="title">« 上一页</span>
    <br>
    <span>go 关键字</span>
  </a>
  <a class="next" href="https://helium-chain.github.io/posts/golang/goroutine/main/">
    <span class="title">下一页 »</span>
    <br>
    <span>main goroutine</span>
  </a>
</nav>

  </footer>
</article>
    </main>
    
<footer class="footer">
    
    <div class="busuanzi-footer">
    <span id="busuanzi_container_site_pv">
        本站总访问量<span id="busuanzi_value_site_pv"></span>次
    </span>
    <span id="busuanzi_container_site_uv">
        本站访客数<span id="busuanzi_value_site_uv"></span>人次
    </span>
    </div>
        <span>Copyright © 2024 蜀ICP备2024091074号 <a href="#">heliu's blog</a>. All rights reserved</span>  
    
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'Copy';

        function copyingDone() {
            copybutton.innerHTML = 'Done';
            setTimeout(() => {
                copybutton.innerHTML = 'Copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
