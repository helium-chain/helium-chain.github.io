<!DOCTYPE html>
<html lang="zh" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>被动让出调度 | Helium</title>
<meta name="keywords" content="golang, Goroutine">
<meta name="description" content="💥本文章所有相关go代码参考自go 1.18&#43;版本">
<meta name="author" content="helium">
<link rel="canonical" href="https://helium.github.io/posts/golang/goroutine/retake/">
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<meta name="referrer" content="no-referrer-when-downgrade">
<link crossorigin="anonymous" href="/assets/css/stylesheet.css" rel="preload stylesheet" as="style">
<link rel="icon" href="https://helium.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://helium.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://helium.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://helium.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://helium.github.io/apple-touch-icon.png">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="zh" href="https://helium.github.io/posts/golang/goroutine/retake/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
<html>
<head>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/jetbrains-mono@1.0.6/css/jetbrains-mono-nl.min.css" />
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lxgw-wenkai-lite-webfont@1.1.0/style.css" />
    <link rel="stylesheet" href="https://cdn.staticfile.org/lxgw-wenkai-screen-webfont/1.6.0/style.css" />
    <style>
        body {
            font-family: "LXGW WenKai Lite", sans-serif;
            font-family: "LXGW WenKai Screen", sans-serif;
        }
    </style>
</head>
</html>

  

<meta property="og:title" content="被动让出调度" />
<meta property="og:description" content="💥本文章所有相关go代码参考自go 1.18&#43;版本" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://helium.github.io/posts/golang/goroutine/retake/" />
<meta property="og:image" content="https://helium.github.io/favicon-32x32.png" />
<meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-07-31T00:00:00+00:00" />
<meta property="article:modified_time" content="2024-07-31T00:00:00+00:00" /><meta property="og:site_name" content="Helium" />

<meta name="twitter:card" content="summary_large_image" />
<meta name="twitter:image" content="https://helium.github.io/favicon-32x32.png" />
<meta name="twitter:title" content="被动让出调度"/>
<meta name="twitter:description" content="💥本文章所有相关go代码参考自go 1.18&#43;版本"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Article",
      "item": "https://helium.github.io/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Golang",
      "item": "https://helium.github.io/posts/golang/"
    }, 
    {
      "@type": "ListItem",
      "position":  3 ,
      "name": "第12章 Goroutine",
      "item": "https://helium.github.io/posts/golang/goroutine/"
    }, 
    {
      "@type": "ListItem",
      "position":  4 ,
      "name": "被动让出调度",
      "item": "https://helium.github.io/posts/golang/goroutine/retake/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "被动让出调度",
  "name": "被动让出调度",
  "description": "💥本文章所有相关go代码参考自go 1.18+版本",
  "keywords": [
    "golang", "Goroutine"
  ],
  "articleBody": " 抢占调度（goroutine因运行时间过长）。 抢占调度：因goroutine运行时间过长而发生的。 goroutine因读写channel等阻塞而导致的被动调度，以及通过调用Gosched()函数发起的主动调度。 抢占标识 retake() _Prunning，表示对应的goroutine正在运行，如果其运行时间超过了10毫秒则对需要抢占。 _Psyscall，表示对应的goroutine正在内核执行系统调用，此时需要根据多个条件来判断是否需要抢占。 该函数只在sysmon监控线程中被调用。 参数now int64：当前时间。 返回值uint32：处于系统调用中需要抢占P的数量。 文件位置：go1.19.3/src/runtime/proc.go。 // forcePreemptNS is the time slice given to a G before it is // preempted. // // forcePreemptNS 是在G被抢占之前给它的时间片。 const forcePreemptNS = 10 * 1000 * 1000 // 10ms 5285 5286 5287 5288 5289 5290 5291 5292 5293 5294 5295 5296 5297 5298 5299 5300 5301 5302 5303 5304 5305 5306 5307 5308 5309 5310 5311 5312 5313 5314 5315 5316 5317 5318 5319 5320 5321 5322 5323 5324 5325 5326 5327 5328 5329 5330 5331 5332 5333 5334 5335 5336 5337 5338 5339 5340 5341 5342 5343 5344 5345 5346 5347 5348 5349 5350 5351 5352 5353 5354 5355 5356 5357 5358 5359 5360 5361 5362 5363 5364 5365 5366 5367 5368 5369 5370 5371 5372 5373 5374 5375 5376 5377 5378 5379 5380 5381 5382 5383 5384 5385 5386 5387 5388 5389 5390 5391 5392 5393 5394 5395 5396 5397 5398 5399 5400 5401 5402 5403 5404 5405 5406 5407 5408 5409 5410 5411 5412 5413 5414 5415 5416 5417 5418 5419 5420 5421 5422 5423 5424 5425 5426 5427 5428 5429 5430 5431 5432 5433 5434 5435 5436 5437 5438 5439 5440 5441 5442 5443 5444 5445 // 检查所有的P查看是否存在运行时间太长的G需要设置抢占请求。 // 1. goroutine运行时间超过10ms时需要抢占。 // 2. goroutine陷入系统调用，运行时间超过10ms或在第二轮来是sysmon系统调用还没返回时。 // 陷入系统调用而抢占P的情况： // 1. 运行时间超过10ms，可能一开始就陷入系统调用，或中途陷入系统调用。不论那种情况都应该抢占。 // 2. 运行时间没到10ms，但是两轮sysmon了还是在系统调用中，需要抢占P。 func retake(now int64) uint32 { n := 0 // 1) 锁住 allp，现在需要遍历所有的P查看是否存在运行时间过长而需要抢占的G。 // Prevent allp slice changes. This lock will be completely // uncontended unless we're already stopping the world. // // 防止 allp 切片更改。 除非我们已经STW，否则这把锁将是完全无人争夺的 lock(\u0026allpLock) // allp加锁 // 2) 遍历所有的P，根据运行时间是否设置抢占标志。 // We can't use a range loop over allp because we may // temporarily drop the allpLock. Hence, we need to re-fetch // allp each time around the loop. // // 我们不能使用range来遍历allp，因为我们可能会暂时放弃allpLock锁（会暂时解锁）。 // 因此，我们需要在每次循环中重新获取allp。 // range会拷贝，因此增长或缩小了allp不会实时变化。 for i := 0; i \u003c len(allp); i++ { // 遍历所有的P _p_ := allp[i] // 2.1) 未初始化的P跳过。可能正在增长P。 if _p_ == nil { // This can happen if procresize has grown // allp but not yet created new Ps. // // 如果procresize已经增长了所有p，但还没有创建新的p，则可能发生这种情况。 continue } // 2.2) 判断是否运行时间过长 // _p_.sysmontick用于sysmon线程记录被监控p的系统调用时间和运行时间 // type sysmontick struct { // schedtick uint32 // 调度器调度次数 // schedwhen int64 // 上次调度时间 // // syscalltick uint32 // 系统调用次数 // syscallwhen int64 // 上次调度时间 // } pd := \u0026_p_.sysmontick // 与sysmon线程相关 // _Prunning：对应的goroutine正在运行 // _Psyscall：对应的goroutine正在内核执行系统调用 s := _p_.status // P当前所处状态 _Prunning，_Psyscall // 标记当前P是否已设置抢占请求 // false.未设置 true.已设置 sysretake := false // 2.3) 先判断 schedtick 和 schedwhen 时间是否运行时间过长。 // G的运行时间是包括系统调用的时间的。 if s == _Prunning || s == _Psyscall { // Preempt G if it's running for too long.\t// // 如果G运行太久，就抢占它。 // _p_.schedtick调度次数，该值是在P上的，记录当前的调度次数。 // 注意区别sysmontick上的schedtick t := int64(_p_.schedtick) // _p_.schedtick：每发生一次调度，调度器++该值 // pd.schedtick == t说明(pd.schedwhen～now)这段时间未发生过调度（这种情况也就是我们要处理的抢占情况）， // 所以这段时间是同一个goroutine一直在运行，下面检查一直运行是否超过了10毫秒，否则则是发生过调度 if int64(pd.schedtick) != t { // 如果不相等说明是一次新的调度 // 监控线程监控到一次新的调度，所以重置跟sysmon相关的schedtick和schedwhen变量 // 2.4) 检测到下次调度，更新调度时间 pd.schedtick = uint32(t) pd.schedwhen = now } else if pd.schedwhen+forcePreemptNS \u003c= now { // 2.4) 本次调度已超过 10ms，设置抢占标识。 // 从某goroutine第一次被sysmon线程监控到正在运行一直运行到现在超过了10毫秒 // 抢占用户代码的goroutine时是需要判断是否能抢占的条件的。 preemptone(_p_) // 设置抢占请求，非系统调用时在这里后就结束了。 // In case of syscall, preemptone() doesn't // work, because there is no M wired to P. // // 在系统调用的情况下，preemptone()不起作用，因为M没有连接到P。此时已经陷入到系统调度中，不会响应请求。 sysretake = true // 已标记了抢占 } // 2.4) 本地调度运行时间还未到10ms。 } // 2.5) P处于系统调用之中时。 if s == _Psyscall { // Retake P from syscall if it's there for more than 1 sysmon tick (at least 20us). // // 如果P存在超过1个sysmon tick(至少20us)，则从sycall中重新取P。 // _p_.syscalltick用于记录系统调用的次数，主要由工作线程在完成系统调用之后++ t := int64(_p_.syscalltick)\t// sysretake = false：前面没有设置抢占标志。 // 1. 本轮调度G还没到达10ms。 // 2. 新的一轮调度，已经重置了。 // int64(pd.syscalltick) != t：新的一轮系统调度了。 if !sysretake \u0026\u0026 int64(pd.syscalltick) != t { pd.syscalltick = uint32(t) // update syscalltick pd.syscallwhen = now // update syscallwhen continue } // 2.6) sysretake == true || (sysretake == false \u0026\u0026 int64(pd.syscalltick) == t) // 1. sysretake == true：前面已经设置了抢占请求，G运行时间超过了10ms，现在处于系统调用中。 // 2. (sysretake == false \u0026\u0026 int64(pd.syscalltick) == t)： // goroutine没有超过10ms，但是监控先到第二轮了，现在处于系统调用中。 // 因此这种情况取决于监控线程的调度时间间隔。 // On the one hand we don't want to retake Ps if there is no other work to do, // but on the other hand we want to retake them eventually // because they can prevent the sysmon thread from deep sleep. // // 一方面我们不想在没有其他工作的情况下重新获取 Ps， // 另一方面我们希望最终重新获取它们，因为它们可以防止 sysmon 线程深度睡眠。 // 只要满足下面三个条件中的任意一个，则抢占该p，否则不抢占 // 1. p的运行队列里面有等待运行的goroutine。（有需要运行的goroutine，需要抢占P） // 2. 没有无所事事的p，也就是没有自旋的P或空闲的P。（系统很忙，需要抢占P） // 3. 从上一次监控线程观察到p对应的m处于系统调用之中到现在已经超过10了毫秒。（系统调用时间太长，需要抢占P） if runqempty(_p_) \u0026\u0026 atomic.Load(\u0026sched.nmspinning)+atomic.Load(\u0026sched.npidle) \u003e 0 \u0026\u0026 pd.syscallwhen+10*1000*1000 \u003e now { // 不需要抢占：_p_本地队列为空 \u0026\u0026 存在自旋或空闲的P（系统不忙） \u0026\u0026 系统调用时间还没有超过了10ms continue } // Drop allpLock so we can take sched.lock. // // 这里是前面不能有for range的原因，解锁这段时间可能allp会发生变化。 unlock(\u0026allpLock) // 解锁 allpLock // Need to decrement number of idle locked M's // (pretending that one more is running) before the CAS. // Otherwise the M from which we retake can exit the syscall, // increment nmidle and report deadlock. // // 需要在CAS之前减少空闲锁定M的数量(假装还有一个正在运行)。 // 否则，我们重新获取的M可以退出系统调用，增加nmid并报告死锁。 incidlelocked(-1) // sched.nmidlelocked += -1 // 这里使用Cas修改P的使用权，原因是此时此刻正好存在系统调用返回了，也正在获取P的使用权 // 如果使用权获取成功则调用handoffp()寻找新的工作线程来接管这个p // _Pidle：空闲状态。此时的P没有被用来执行用户代码或调度器代码，通常位于空闲链表中，能够被调度器获取， // 它的状态可能正在由空闲转变成其他状态。P的所有权归空闲链表或某个正在改变它状态的线程所有，本地runq为空。 if atomic.Cas(\u0026_p_.status, s, _Pidle) { if trace.enabled { traceGoSysBlock(_p_) traceProcStop(_p_) } n++ _p_.syscalltick++ // 系统调度次数加一 // 尝试寻找一个新的m出来接管P // 抢占陷入系统调用的P时，没有多余的条件 handoffp(_p_)\t} incidlelocked(1) lock(\u0026allpLock) } } unlock(\u0026allpLock) return uint32(n) } incidlelocked() 文件位置：go1.19.3/src/runtime/proc.go。 5505 5506 5507 5508 5509 5510 5511 5512 5513 5514 func incidlelocked(v int32) { lock(\u0026sched.lock) // nmidlelocked 锁定等待工作的M的数量 // 只会在该函数中加减，在checkdead()函数中判断 sched.nmidlelocked += v if v \u003e 0 { checkdead() } unlock(\u0026sched.lock) } preemptone() sysmon线程如果监控到某个goroutine连续运行超过了10毫秒，则会调用preemptone()函数向该goroutine发出抢占请求。 告诉在处理器P上运行的goroutine停止。 这个函数只是尽了最大努力。它可能会错误地没有通知goroutine。也可能会通知错误的goroutine。 即使它通知了正确的goroutine，如果goroutine同时执行newstack，它可能会忽略请求。 不需要锁。如果发出抢占请求，则返回true。 实际的抢占将在未来的某个时间点发生，并且将由gp-\u003estatus不再是Grunning表示。设置抢占请求。 该函数会在retake()函数中调用，GC期间调用。 可以看出，preemptone函数只是简单的设置了被抢占goroutine对应的g结构体中的 preempt成员为true和stackguard0成员为stackPreempt（stackPreempt是一个常量0xfffffffffffffade，是非常大的一个数）就返回了，并未真正强制被抢占的goroutine暂停下来。 既然设置了一些抢占标志，那么就一定需要对这些标志进行处理，下面我们就来分析被抢占的goroutine如何处理这些标志去响应监控线程提出的抢占请求。 文件位置：go1.19.3/src/runtime/proc.go。 5378 5379 5380 5381 5382 5383 5384 5385 5386 5387 5388 5389 5390 5391 5392 5393 5394 5395 5396 5397 5398 5399 5400 5401 5402 5403 5404 5405 5406 5407 5408 5409 5410 5411 5412 5413 5414 5415 5416 5417 5418 5419 5420 5421 5422 5423 5424 5425 5426 5427 5428 5429 5430 5431 5432 5433 5434 5435 // Tell the goroutine running on processor P to stop. // This function is purely best-effort. It can incorrectly fail to inform the // goroutine. It can inform the wrong goroutine. Even if it informs the // correct goroutine, that goroutine might ignore the request if it is // simultaneously executing newstack. // No lock needs to be held. // Returns true if preemption request was issued. // The actual preemption will happen at some point in the future // and will be indicated by the gp-\u003estatus no longer being // Grunning func preemptone(_p_ *p) bool { // 1) 抢占P的关联的m mp := _p_.m.ptr() // mp := m // 2) 抢占的P没有绑定M，或抢占的P的M与当前运行G的M一致【不设置抢占标志】 // 1. mp == nil：可能来自sysmon抢占空闲的P的时候，这时候P是没有绑定M的。 // 2. mp == getg().m：抢占的是自己，很大可能这种情况来自GC在等待其他P停下来的时候。 if mp == nil || mp == getg().m { return false } // 3) 抢占的工作线程刚好处理完goroutine，或抢占的工作线程正在g0中【不设置抢占标志】 gp := mp.curg // mp工作线程上正在运行的goroutine // 1. gp == nil：当前工作线程正在执行的goroutine刚好运行完被调离M时。 // 2. gp == mp.g0：当前正在g0上，可能在执行调度代码。 if gp == nil || gp == mp.g0 { return false } gp.preempt = true // 标记正在运行的P的g设置抢占标志 // Every call in a goroutine checks for stack overflow by // comparing the current stack pointer to gp-\u003estackguard0. // Setting gp-\u003estackguard0 to StackPreempt folds // preemption into the normal stack overflow check. // // goroutine中的每个调用都通过将当前堆栈指针与gp-\u003estackguard0进行比较来检查堆栈溢出。 // 设置gp-\u003estackguard0为StackPreempt将抢占转换为正常的栈溢出检查。 // stackPreempt是一个常量0xfffffffffffffade，是非常大的一个数。 gp.stackguard0 = stackPreempt // 设置stackguard0使被抢占的goroutine去处理抢占请求 // Request an async preemption of this P. // // 请求这个P的异步抢占。这种情况是对于没有调用任何函数的goroutine，没有抢占机会的情况下。 // 1. preemptMSupported：其中的 preemptMSupported 是个常量，因为受硬件特性的限制， // 在某些平台上是无法支持这种抢占的。 // 2. debug.asyncpreemptoff：则是让用户可以通过 GODEBUG 环境变量来禁用异步抢占， // 默认情况下是被启用的。 if preemptMSupported \u0026\u0026 debug.asyncpreemptoff == 0 { // 在P的数据结构中也新增了一个preempt字段，这里会把它设置为true。 _p_.preempt = true // 实际上抢占操作是由 preemptM 函数完成的。 preemptM(mp)\t// 该函数发起异步抢占给MP发送抢占信号 } return true } handoffp() 从系统调用中关闭P或锁定M。总是在没有P的情况下运行，因此不允许有写屏障。 handoffp()函数主要任务是通过各种条件判断是否需要启动工作线程来接管_p_，如果不需要则把_p_放入P的全局空闲队列。 _p_的本地运行队列或全局运行队列里面有待运行的goroutine。 需要帮助gc完成标记工作。 系统比较忙，所有其它_p_都在运行goroutine，需要帮忙。 所有其它P都已经处于空闲状态，如果需要监控网络连接读写事件，则需要启动新的m来poll网络连接。 文件位置：go1.19.3/src/runtime/proc.go。 2350 2351 2352 2353 2354 2355 2356 2357 2358 2359 2360 2361 2362 2363 2364 2365 2366 2367 2368 2369 2370 2371 2372 2373 2374 2375 2376 2377 2378 2379 2380 2381 2382 2383 2384 2385 2386 2387 2388 2389 2390 2391 2392 2393 2394 2395 2396 2397 2398 2399 2400 2401 2402 2403 2404 2405 2406 2407 2408 2409 2410 2411 2412 2413 2414 2415 2416 2417 2418 2419 2420 2421 2422 2423 2424 2425 2426 2427 2428 2429 2430 2431 2432 2433 2434 2435 2436 2437 2438 2439 // Hands off P from syscall or locked M. // Always runs without a P, so write barriers are not allowed. // //go:nowritebarrierrec func handoffp(_p_ *p) { // handoffp must start an M in any situation where // findrunnable would return a G to run on _p_. // // 在findrunnable返回G并在_p_上运行的任何情况下，handffp必须开始一个M。 // if it has local work, start it straight away // // 如果它有本地工作，需要启动m来接管 if !runqempty(_p_) || sched.runqsize != 0 { startm(_p_, false) // 创建M来接管P return } // if there's trace work to do, start it straight away if (trace.enabled || trace.shutdown) \u0026\u0026 traceReaderAvailable() { startm(_p_, false) return } // if it has GC work, start it straight away // // GC正在工作，也需要启动m来接管 if gcBlackenEnabled != 0 \u0026\u0026 gcMarkWorkAvailable(_p_) { startm(_p_, false) return } // no local work, check that there are no spinning/idle M's, // otherwise our help is not required // // 没有本地工作，检查是否有 spinning/idle 的M，否则不需要我们的帮助。 // 1. atomic.Load(\u0026sched.nmspinning)+atomic.Load(\u0026sched.npidle) == 0：没有自旋的M和空闲的P时。 // 2. atomic.Cas(\u0026sched.nmspinning, 0, 1)：sched.nmspinning = 1。 if atomic.Load(\u0026sched.nmspinning)+atomic.Load(\u0026sched.npidle) == 0 \u0026\u0026 atomic.Cas(\u0026sched.nmspinning, 0, 1) { // TODO: fast atomic startm(_p_, true) // 这时候启动的M绑定P可以起去其他P中偷取任务，如果存在空闲的P则表示其他P不忙 return } lock(\u0026sched.lock) // GC正在STW等待时。 if sched.gcwaiting != 0 { _p_.status = _Pgcstop // 修改状态为GC而停下 sched.stopwait-- // 因为GC而停下来 // 当前STW要求的P全部停下来时，就可以唤醒等待在sched.stopnote上的发起STW的线程了。 if sched.stopwait == 0 { notewakeup(\u0026sched.stopnote) } unlock(\u0026sched.lock) return } if _p_.runSafePointFn != 0 \u0026\u0026 atomic.Cas(\u0026_p_.runSafePointFn, 1, 0) { sched.safePointFn(_p_) sched.safePointWait-- if sched.safePointWait == 0 { notewakeup(\u0026sched.safePointNote) } } // 全局队列池有G需要处理时。 if sched.runqsize != 0 { unlock(\u0026sched.lock) startm(_p_, false) return } // If this is the last running P and nobody is polling network, // need to wakeup another M to poll network. // // 如果这是最后一个运行的P并且没有其他线程在阻塞式等待netpoll，需要唤醒一个M来处理netpoll。 // 1. sched.npidle == uint32(gomaxprocs-1)：当前是最后一个空闲P // 2. atomic.Load64(\u0026sched.lastpoll) != 0：没有其他线程在阻塞式访问netpoll。 if sched.npidle == uint32(gomaxprocs-1) \u0026\u0026 atomic.Load64(\u0026sched.lastpoll) != 0 { unlock(\u0026sched.lock) startm(_p_, false) return } // The scheduler lock cannot be held when calling wakeNetPoller below // because wakeNetPoller may call wakep which may call startm. // // 当调用wakeNetPoller时，调度器锁不能保持，因为wakeNetPoller可能会调用wakeep，而后者可能会调用startm。 when := nobarrierWakeTime(_p_) // 最新timer触发时间点 pidleput(_p_, 0) //无事可做，把p放入全局空闲队列 unlock(\u0026sched.lock) if when != 0 { wakeNetPoller(when) } // 走到这里不会抢占P } 响应抢占请求 抢占的相关函数调用链morestack_noctxt()-\u003emorestack()-\u003enewstack()。 从源代码中morestack()函数的注释可以知道，该函数会被编译器自动插入到函数 序言(prologue) 中。 morestack_noctxt() 文件位置：go1.19.3/src/runtime/asm_amd64.s。 574 575 576 577 # morestack but not preserving ctxt. TEXT runtime·morestack_noctxt(SB),NOSPLIT,$0 MOVL $0, DX # DX = 0，DX寄存器被用作函数调用的隐藏传值 JMP\truntime·morestack(SB) # 注意这里使用的是JMP不是CALL因此不是函数调用 我们假设是在main.main函数序言中调用了morestack_noctxt()函数，则函数的栈帧结构如下： // +10 | // ---------------------------- runtime.main SP // +08 | runtime.main callback // ---------------------------- main.main SP // +00 | main.main callback // ---------------------------- morestack_noctxt SP // // runtime·morestack(SB)是通过JMP调用的，所以没有重新分配栈帧 morestack() 当需要更多栈时，在函数prolog期间调用。 回溯例程将g0上的morestack视为栈的顶部(例如，morestack调用newstack调用调度器调用newm调用gc)， 因此我们必须记录参数大小。为此，它没有参数。 文件位置：go1.19.3/src/runtime/asm_amd64.s。 该函数，保护调用者信息，切换到g0栈调用runtime·newstack方法。 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 # Called during function prolog when more stack is needed. # # The traceback routines see morestack on a g0 as being # the top of a stack (for example, morestack calling newstack # calling the scheduler calling newm calling gc), so we must # record an argument size. For that purpose, it has no arguments. TEXT runtime·morestack(SB),NOSPLIT,$0-0 # Cannot grow scheduler stack (m-\u003eg0). get_tls(CX) # CX = \u0026m.tls[1] MOVQ g(CX), BX # BX = m.tls[0] = g MOVQ g_m(BX), BX # BX = g.m MOVQ m_g0(BX), SI # SI = m.g0 CMPQ g(CX), SI # 比较当前g是否是g0 JNE\t3(PC) # 判断不为零时则跳转 # runtime·badmorestackg0 错误信息 \"morestack()函数在g0栈上被调用\" CALL runtime·badmorestackg0(SB) # int 3 进入中断指令，这是一个调试指令 CALL runtime·abort(SB) # Cannot grow signal stack (m-\u003egsignal). MOVQ m_gsignal(BX), SI # SI = m.gsignal CMPQ g(CX), SI JNE\t3(PC) # 判断不为零时则跳转 # runtime·badmorestackgsignal 错误信息 \"morestack()函数在gsignal上被调用\" CALL runtime·badmorestackgsignal(SB) CALL runtime·abort(SB) # Called from f. # Set m-\u003emorebuf to f's caller. # # 从f调用。设置m-\u003emorebuf为f的调用者。 # NOP SP 指令意义： # 1. NOP SP指令不做任何操作。具体来说，它会将堆栈指针(SP)向后移动0个字节，这实际上是没有任何效果的。 # 2. 在 Go 的汇编语言中，有时需要使用 \"NOP SP\" 这条指令来进行指令对齐，但这也可能会导致 vet 工具产生误报，因为它会认为这会导致堆栈偏移量的改变。 # \"# tell vet SP changed - stop checking offsets\" 这行注释的意义： # 1. 为了避免这种情况，程序员可以添加这个注释来告诉vet工具，实际上没有对堆栈偏移量进行任何更改，因此vet工具可以停止检查堆栈偏移量。 # 2. 这句话的意思是，程序员在添加NOP SP指令时遇到了vet工具的误报问题，为了解决这个问题，他们添加了这个注释，告诉vet工具不需要继续检查堆栈偏移量。 # 指令对齐：是指将指令地址对齐到一定的边界上，使得指令的执行效率更高。 # 1. 在计算机系统中，CPU 通常需要从内存中读取指令并执行它们，这是一个非常耗时的过程。 # 2. 为了提高执行效率，CPU 需要在访问内存时保持一定的对齐方式，以便更快地读取指令并进行处理。 # 3. 在指令对齐中，指令地址通常被要求对齐到一个特定的边界，通常是2的幂次方，如2、4、8等。 # 4. 这意味着指令地址的低位必须是0，这使得 CPU 可以更快地读取指令并进行处理，从而提高程序的执行效率。 # 5. 在编写汇编语言程序时，程序员通常需要手动对指令进行对齐。这可以通过添加一些无操作指令，如NOP指令，来实现。 # 6. 这些指令不会对程序的执行产生任何影响，只是用来填充指令流中的空隙，以确保指令地址对齐。 # 7. 这些操作可以帮助 CPU 更快地读取指令并提高程序的执行效率。 NOP\tSP\t# tell vet SP changed - stop checking offsets # 以下代码保存调用者信息，比如在main.main的序言中调了morestack_noctxt()-\u003emorestack()函数，需要保存的是main.main的信息 # 8(SP)：main函数在调用morestack_noctxt之前的rsp寄存器 # 通过上面函数栈帧的分配 8(SP) 是runtime.main函数的返回地址，注意这里是保存在m上的，m-\u003emorebuf # 保存到m-\u003emorebuf用于提供给接下来的newstack()函数使用 MOVQ 8(SP), AX\t# f's caller's PC; MOVQ AX, (m_morebuf+gobuf_pc)(BX) # m.morebuf.gobuf.pc=AX # 16(SP)：调用者函数的SP，也就是runtime.main的SP寄存器地址，注意这里是 LEAQ 指令 LEAQ 16(SP), AX\t# f's caller's SP # AX = 16(SP); 该值是runtime.main函数的rsp寄存器存储的地址 MOVQ AX, (m_morebuf+gobuf_sp)(BX) # m.morebuf.gobuf.sp=AX get_tls(CX) # CX = \u0026m.tls[1] MOVQ g(CX), SI # SI = m.tls[0] = g; 这里是g，不是g0 MOVQ SI, (m_morebuf+gobuf_g)(BX) # m.morebuf.gobuf.g = g # 到这里我们已经在m-\u003emorebuf保存好了调用者runtime.main的rip、rsp、g相关信息 # Set g-\u003esched to context in f. # # 将 g-\u003esched 设置为f的上下文，这才是需要恢复的现场数据 # SP栈顶寄存器现在指向的是morestack_noctxt函数的返回地址，注意下面都是保存在g上的，g-\u003esched不是g0上 # 0(SP)：通过上面函数栈帧的分配 0(SP) 是main.main函数的返回地址，也就是rip中的值就是main.main的下条代码地址 MOVQ 0(SP), AX # f's PC # g.sched.gobuf.pc = AX MOVQ AX, (g_sched+gobuf_pc)(SI) # 执行完morestack_noctxt函数之后应该返回去继续执行指令的地址 AX # 8(SP)：调用者函数的SP，也就是main.main的SP寄存器地址，这个地址是没有压入rip指令数据前的地址，注意这里是 LEAQ 指令 LEAQ 8(SP), AX # f's SP; MOVQ AX, (g_sched+gobuf_sp)(SI) # g.sched.gobuf.sp = AX # 由于BP寄存器的值一致没有变，所以这里BP寄存器还是指向main.main的栈底 MOVQ BP, (g_sched+gobuf_bp)(SI) # g.sched.gobuf.bp = BP # DX寄存器被设置为了0，在runtime·morestack_noctxt()函数中 MOVQ DX, (g_sched+gobuf_ctxt)(SI)# g.sched.gobuf.ctxt = DX; # 到这里当前g-\u003esched已保存好了恢复到main.main的现场，包括rip、rsp、rbp、rdx # Call newstack on m-\u003eg0's stack. # 切换到g0栈，并设置tls的g为g0 MOVQ m_g0(BX), BX # BX = g0 # 设置TLS中的g为g0 MOVQ BX, g(CX) # m.tls[0] = g0 # 把g0栈的栈顶寄存器的值恢复到CPU的寄存器，达到切换栈的目的，下面这一条指令执行之前， # CPU还是使用的调用此函数的g的栈，执行之后CPU就开始使用g0的栈了 MOVQ (g_sched+gobuf_sp)(BX), SP # rsp = g0.sched.gobuf.sp CALL runtime·newstack(SB) # 调用 newstack() 函数 CALL runtime·abort(SB) # crash if newstack returns RET 汇编语言\"int 3\"是一个中断指令，它向操作系统发出一个调试信号，要求在程序的当前位置停止执行并进入调试器。 通常，调试器会在此处暂停程序的执行，并允许程序员检查程序状态、变量值和程序流程等信息，以帮助他们调试程序。 TEXT runtime·abort(SB),NOSPLIT,$0-0 INT\t$3 loop: JMP\tloop newstack() 该函数主要有两个职责：一个是【扩栈】，另一个是响应sysmon提出的【抢占请求】。 newstack()函数首先检查g.stackguard0是否被设置为stackPreempt，如果是则表示sysmon已经发现我们运行得太久了并对我们发起了抢占请求。 当需要更多堆栈时从runtime·morestack调用。分配更大的堆栈并重新定位到新堆栈。对于固定的平摊代价，堆栈增长是乘法的。 g-\u003eatomicstatus将在进入时进行Grunning或Gscanrunning。调度程序试图停止这个g，然后它将设置preemptStop。 这必须是nowritebarrierrec，因为它可以作为堆栈增长的一部分从其他nowritebarrierrec函数调用，但编译器不会检查这一点。 go:nowritebarrierrec：编译器不插入写屏障相关代码，包括当前函数以及调用的任何函数中。 文件位置：go1.19.3/src/runtime/stack.go。 950 951 952 953 954 955 956 957 958 959 960 961 962 963 964 965 966 967 968 969 970 971 972 973 974 975 976 977 978 979 980 981 982 983 984 985 986 987 988 989 990 991 992 993 994 995 996 997 998 999 1000 1001 1002 1003 1004 1005 1006 1007 1008 1009 1010 1011 1012 1013 1014 1015 1016 1017 1018 1019 1020 1021 1022 1023 1024 1025 1026 1027 1028 1029 1030 1031 1032 1033 1034 1035 1036 1037 1038 1039 1040 1041 1042 1043 1044 1045 1046 1047 1048 1049 1050 1051 1052 1053 1054 1055 1056 1057 1058 1059 1060 1061 1062 1063 1064 1065 1066 1067 1068 1069 1070 1071 1072 1073 1074 1075 1076 1077 1078 1079 1080 1081 1082 1083 1084 1085 1086 1087 1088 1089 1090 1091 1092 1093 1094 1095 1096 1097 1098 1099 1100 1101 1102 1103 1104 1105 1106 1107 1108 1109 1110 1111 1112 1113 1114 1115 1116 1117 1118 1119 1120 1121 1122 1123 1124 1125 1126 1127 1128 1129 1130 1131 1132 1133 1134 1135 1136 1137 1138 1139 1140 1141 1142 // Called from runtime·morestack when more stack is needed. // Allocate larger stack and relocate to new stack. // Stack growth is multiplicative, for constant amortized cost. // // g-\u003eatomicstatus will be Grunning or Gscanrunning upon entry. // If the scheduler is trying to stop this g, then it will set preemptStop. // // This must be nowritebarrierrec because it can be called as part of // stack growth from other nowritebarrierrec functions, but the // compiler doesn't check this. // //go:nowritebarrierrec func newstack() { thisg := getg() // thisg = g0; 根据morestack()函数的相关代码 // TODO: double check all gp. shouldn't be getg(). // // 根据morestack()函数的相关代码，这里thisg.m.morebuf.g.ptr()是g不是g0 if thisg.m.morebuf.g.ptr().stackguard0 == stackFork { throw(\"stack growth after fork\") } // m-\u003ecurg 是当前m上正在运行的g if thisg.m.morebuf.g.ptr() != thisg.m.curg { print(\"runtime: newstack called from g=\", hex(thisg.m.morebuf.g), \"\\n\"+\"\\tm=\", thisg.m, \" m-\u003ecurg=\", thisg.m.curg, \" m-\u003eg0=\", thisg.m.g0, \" m-\u003egsignal=\", thisg.m.gsignal, \"\\n\") morebuf := thisg.m.morebuf traceback(morebuf.pc, morebuf.sp, morebuf.lr, morebuf.g.ptr()) throw(\"runtime: wrong goroutine in newstack\") } gp := thisg.m.curg // gp 在这里例子是runtime.main的goroutine // g.throwsplit 在系统调用前会被设置为true或其他地方。因此g出现在这里不合适。 if thisg.m.curg.throwsplit { // Update syscallsp, syscallpc in case traceback uses them. morebuf := thisg.m.morebuf gp.syscallsp = morebuf.sp gp.syscallpc = morebuf.pc pcname, pcoff := \"(unknown)\", uintptr(0) f := findfunc(gp.sched.pc) if f.valid() { pcname = funcname(f) pcoff = gp.sched.pc - f.entry() } print(\"runtime: newstack at \", pcname, \"+\", hex(pcoff), \" sp=\", hex(gp.sched.sp), \" stack=[\", hex(gp.stack.lo), \", \", hex(gp.stack.hi), \"]\\n\", \"\\tmorebuf={pc:\", hex(morebuf.pc), \" sp:\", hex(morebuf.sp), \" lr:\", hex(morebuf.lr), \"}\\n\", \"\\tsched={pc:\", hex(gp.sched.pc), \" sp:\", hex(gp.sched.sp), \" lr:\", hex(gp.sched.lr), \" ctxt:\", gp.sched.ctxt, \"}\\n\") thisg.m.traceback = 2 // Include runtime frames traceback(morebuf.pc, morebuf.sp, morebuf.lr, gp) throw(\"runtime: stack split at bad time\") } // m.morebuf 在上面的morestack函数中被设置为调用函数的相关信息。 morebuf := thisg.m.morebuf thisg.m.morebuf.pc = 0 thisg.m.morebuf.lr = 0 thisg.m.morebuf.sp = 0 thisg.m.morebuf.g = 0 // NOTE: stackguard0 may change underfoot, if another thread // is about to try to preempt gp. Read it just once and use that same // value now and below. // // 注意：如果另一个线程即将尝试抢占gp，stackguard0可能会在脚下发生变化。 // 只需阅读一次并在现在和下面使用相同的值 stackguard0 := atomic.Loaduintptr(\u0026gp.stackguard0) // 获取gp.stackguard0 // Be conservative about where we preempt. // We are interested in preempting user Go code, not runtime code. // If we're holding locks, mallocing, or preemption is disabled, don't // preempt. // This check is very early in newstack so that even the status change // from Grunning to Gwaiting and back doesn't happen in this case. // That status change by itself can be viewed as a small preemption, // because the GC might change Gwaiting to Gscanwaiting, and then // this goroutine has to wait for the GC to finish before continuing. // If the GC is in some way dependent on this goroutine (for example, // it needs a lock held by the goroutine), that small preemption turns // into a real deadlock. preempt := stackguard0 == stackPreempt // 判断当前是否真需要被抢占 if preempt { // canPreemptM -\u003e mp.locks == 0 \u0026\u0026 mp.mallocing == 0 \u0026\u0026 mp.preemptoff == \"\" \u0026\u0026 mp.p.ptr().status == _Prunning if !canPreemptM(thisg.m) { // canPreemptM(thisg.m); true.可以抢占; false.不允许抢占 // 以下是【不允许】抢占时，再次恢复gp。 // Let the goroutine keep running for now. // gp-\u003epreempt is set, so it will be preempted next time. // // 现在让goroutine继续运行。gp-\u003epreempt已设置，因此下次将被抢占。 // (gp-\u003epreempt在前面已被设置为true) // 还原stackguard0为正常值，表示我们已经处理过抢占请求了 gp.stackguard0 = gp.stack.lo + _StackGuard // 恢复gp，这里永远不会返回 gogo(\u0026gp.sched) // never return } } if gp.stack.lo == 0 { throw(\"missing stack in newstack\") } sp := gp.sched.sp if goarch.ArchFamily == goarch.AMD64 || goarch.ArchFamily == goarch.I386 || goarch.ArchFamily == goarch.WASM { // The call to morestack cost a word. sp -= goarch.PtrSize } if stackDebug \u003e= 1 || sp \u003c gp.stack.lo { print(\"runtime: newstack sp=\", hex(sp), \" stack=[\", hex(gp.stack.lo), \", \", hex(gp.stack.hi), \"]\\n\", \"\\tmorebuf={pc:\", hex(morebuf.pc), \" sp:\", hex(morebuf.sp), \" lr:\", hex(morebuf.lr), \"}\\n\", \"\\tsched={pc:\", hex(gp.sched.pc), \" sp:\", hex(gp.sched.sp), \" lr:\", hex(gp.sched.lr), \" ctxt:\", gp.sched.ctxt, \"}\\n\") } if sp \u003c gp.stack.lo { print(\"runtime: gp=\", gp, \", goid=\", gp.goid, \", gp-\u003estatus=\", hex(readgstatus(gp)), \"\\n \") print(\"runtime: split stack overflow: \", hex(sp), \" \u003c \", hex(gp.stack.lo), \"\\n\") throw(\"runtime: split stack overflow\") } // 判断抢占，发起抢占 if preempt { if gp == thisg.m.g0 { throw(\"runtime: preempt g0\") } if thisg.m.p == 0 \u0026\u0026 thisg.m.locks == 0 { throw(\"runtime: g is running but p is not\") } if gp.preemptShrink { // We're at a synchronous safe point now, so // do the pending stack shrink. gp.preemptShrink = false shrinkstack(gp) } // 停止抢占，开启下一次调度循环,makeroot期间改值会被设置为true。 if gp.preemptStop {\tpreemptPark(gp) // never returns } // Act like goroutine called runtime.Gosched. // // 像调用 runtime.Gosched 的 goroutine 一样 // 调用gopreempt_m把gp切换出去，抢占这个goroutine成功了 gopreempt_m(gp) // never return } // 下面代码是扩大栈相关代码 // Allocate a bigger segment and move the stack. oldsize := gp.stack.hi - gp.stack.lo newsize := oldsize * 2 // 扩大为原来的2倍 // Make sure we grow at least as much as needed to fit the new frame. // (This is just an optimization - the caller of morestack will // recheck the bounds on return.) if f := findfunc(gp.sched.pc); f.valid() { max := uintptr(funcMaxSPDelta(f)) needed := max + _StackGuard used := gp.stack.hi - gp.sched.sp for newsize-used \u003c needed { newsize *= 2 } } if stackguard0 == stackForceMove { // Forced stack movement used for debugging. // Don't double the stack (or we may quickly run out // if this is done repeatedly). newsize = oldsize } if newsize \u003e maxstacksize || newsize \u003e maxstackceiling { if maxstacksize \u003c maxstackceiling { print(\"runtime: goroutine stack exceeds \", maxstacksize, \"-byte limit\\n\") } else { print(\"runtime: goroutine stack exceeds \", maxstackceiling, \"-byte limit\\n\") } print(\"runtime: sp=\", hex(sp), \" stack=[\", hex(gp.stack.lo), \", \", hex(gp.stack.hi), \"]\\n\") throw(\"stack overflow\") } // The goroutine must be executing in order to call newstack, // so it must be Grunning (or Gscanrunning). casgstatus(gp, _Grunning, _Gcopystack) // The concurrent GC will not scan the stack while we are doing the copy since // the gp is in a Gcopystack status. copystack(gp, newsize) if stackDebug \u003e= 1 { print(\"stack grow done\\n\") } casgstatus(gp, _Gcopystack, _Grunning) gogo(\u0026gp.sched) // 再次恢复这个goroutine } canPreemptM canPreemptM报告mp是否处于可以安全抢占的状态。 它是nosplit因为它有nosplit的调用者。 go:nosplit：告诉编译器不要在当前函数中插入任何栈扩展代码，这样可以确保当前函数不会导致栈的大小发生变化。 在Go语言中，每个goroutine都有一个固定的栈大小，当栈的大小不足以容纳当前函数的执行时，就会发生栈溢出错误。 因此，使用\"go:nosplit\"指令可以确保函数的执行不会导致栈的大小发生变化，从而避免栈溢出错误的发生。这个指令通常用于一些关键性的函数中，比如垃圾回收器和调度器等。 需要注意的是，使用\"go:nosplit\"指令可能会影响程序的性能。因为不再插入栈扩展代码，这意味着在执行函数时，栈的大小不会动态调整。因此，程序员需要在使用\"go:nosplit\"指令时仔细考虑性能和栈溢出错误之间的权衡。 文件位置：go1.19.3/src/runtime/preempt.go。 282 283 284 285 286 287 288 289 290 291 292 293 294 295 // canPreemptM reports whether mp is in a state that is safe to preempt. // // It is nosplit because it has nosplit callers. // //go:nosplit func canPreemptM(mp *m) bool { // 能否抢占条件：true.能抢占，false.不能抢占。 // 1. mp.locks == 0：表示当前goroutine持有的互斥锁数量，没到0时，不应该被抢占。 // 2. mp.mallocing == 0：当前goroutine正在分配内存，不应该被抢占。 // 3. mp.preemptoff：如果该值被设置为非空字符串，则表示当前goroutine不应该被抢占。 // 4. mp.p.ptr().status == _Prunning：当前P正在运行中。 // 满足以上条件则能抢占g。该函数也会在信号抢占函数isAsyncPreempt()函数中调用，用于判断是否允许抢占 return mp.locks == 0 \u0026\u0026 mp.mallocing == 0 \u0026\u0026 mp.preemptoff == \"\" \u0026\u0026 mp.p.ptr().status == _Prunning } gopreempt_m 抢占调度，后逻辑和runtime.Gosched一样。 文件位置：go1.19.3/src/runtime/proc.go。 3402 3403 3404 3405 3406 3407 func gopreempt_m(gp *g) { if trace.enabled { traceGoPreempt() } goschedImpl(gp) } 系统调用前后 handoffp()，对正在进行系统调用的goroutine的抢占实质上是剥夺与其对应的工作线程所绑定的p。 虽然说处于系统调用之中的工作线程并不需要p，但一旦从操作系统内核返回到用户空间之后就必须绑定一个p才能运行go代码。 系统调用 Syscall6() 系统调用时最终会调用该汇编函数。 文件位置：go1.19.3/src/syscall/asm_unix_amd64.s。 函数原型：func Syscall6(num, a1, a2, a3, a4, a5, a6 uintptr) (r1, r2, errno uintptr)。 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 TEXT ·Syscall6(SB),NOSPLIT,$0-80 # 调用 runtime.entersyscall 函数，保存现场解除绑定关系 CALL runtime·entersyscall\u003cABIInternal\u003e(SB) # 系统调用参数，按照linux系统约定寄存器并调用SYSCALL执行进入内核。 # 系统调用编号放入AX。 MOVQ trap+0(FP), AX # syscall entry MOVQ a1+8(FP), DI MOVQ a2+16(FP), SI MOVQ a3+24(FP), DX MOVQ a4+32(FP), R10 MOVQ a5+40(FP), R8 MOVQ a6+48(FP), R9 SYSCALL # 进入内核 # 从内核返回，判断标识是否跳转 JCC\tok6 MOVQ $-1, r1+56(FP) # r1 MOVQ $0, r2+64(FP) # r2 MOVQ AX, err+72(FP) # errno CALL runtime·exitsyscall\u003cABIInternal\u003e(SB) RET ok6: # 系统调用返回的值保存栈 MOVQ AX, r1+56(FP) # r1 MOVQ DX, r2+64(FP) # r2 MOVQ $0, err+72(FP) # errno CALL runtime·exitsyscall\u003cABIInternal\u003e(SB) RET 系统调用前 entersyscall() go系统调用库和普通cgo调用使用的标准系统调用项。 这是通过syscall包和x/sys中的链接名导出到程序集的。 文件位置：go1.19.3/src/runtime/proc.go。 3672 3673 3674 3675 3676 3677 3678 3679 3680 3681 3682 // Standard syscall entry used by the go syscall library and normal cgo calls. // // This is exported via linkname to assembly in the syscall package and x/sys. // //go:nosplit //go:linkname entersyscall func entersyscall() { // getcallerpc()：调用者当前PC值。 // getcallersp()：调用者当前SP值。 reentersyscall(getcallerpc(), getcallersp()) } reentersyscall() 文件位置：go1.19.3/src/runtime/proc.go。 3575 3576 3577 3578 3579 3580 3581 3582 3583 3584 3585 3586 3587 3588 3589 3590 3591 3592 3593 3594 3595 3596 3597 3598 3599 3600 3601 3602 3603 3604 3605 3606 3607 3608 3609 3610 3611 3612 3613 3614 3615 3616 3617 3618 3619 3620 3621 3622 3623 3624 3625 3626 3627 3628 3629 3630 3631 3632 3633 3634 3635 3636 3637 3638 3639 3640 3641 3642 3643 3644 3645 3646 3647 3648 3649 3650 3651 3652 3653 3654 3655 3656 3657 3658 3659 3660 3661 3662 3663 3664 3665 3666 3667 3668 3669 3670 3671 3672 3673 3674 3675 3676 3677 3678 3679 3680 3681 3682 3683 3684 3685 3686 3687 3688 // The goroutine g is about to enter a system call. // Record that it's not using the cpu anymore. // This is called only from the go syscall library and cgocall, // not from the low-level system calls used by the runtime. // // Entersyscall cannot split the stack: the save must // make g-\u003esched refer to the caller's stack segment, because // entersyscall is going to return immediately after. // // Nothing entersyscall calls can split the stack either. // We cannot safely move the stack during an active call to syscall, // because we do not know which of the uintptr arguments are // really pointers (back into the stack). // In practice, this means that we make the fast path run through // entersyscall doing no-split things, and the slow path has to use systemstack // to run bigger things on the system stack. // // reentersyscall is the entry point used by cgo callbacks, where explicitly // saved SP and PC are restored. This is needed when exitsyscall will be called // from a function further up in the call stack than the parent, as g-\u003esyscallsp // must always point to a valid stack frame. entersyscall below is the normal // entry point for syscalls, which obtains the SP and PC from the caller. // // Syscall tracing: // At the start of a syscall we emit traceGoSysCall to capture the stack trace. // If the syscall does not block, that is it, we do not emit any other events. // If the syscall blocks (that is, P is retaken), retaker emits traceGoSysBlock; // when syscall returns we emit traceGoSysExit and when the goroutine starts running // (potentially instantly, if exitsyscallfast returns true) we emit traceGoStart. // To ensure that traceGoSysExit is emitted strictly after traceGoSysBlock, // we remember current value of syscalltick in m (_g_.m.syscalltick = _g_.m.p.ptr().syscalltick), // whoever emits traceGoSysBlock increments p.syscalltick afterwards; // and we wait for the increment before emitting traceGoSysExit. // Note that the increment is done even if tracing is not enabled, // because tracing can be enabled in the middle of syscall. We don't want the wait to hang. // //go:nosplit func reentersyscall(pc, sp uintptr) { // user goroutine _g_ := getg() // 执行系统调用的goroutine // Disable preemption because during this function g is in Gsyscall status, // but can have inconsistent g-\u003esched, do not let GC observe it. // // 禁用抢占，因为在这个功能期间g处于Gsyscall状态，但可能有不一致的g-\u003esched，不要让GC观察它。 _g_.m.locks++ // Entersyscall must not call any function that might split/grow the stack. // (See details in comment above.) // Catch calls that might, by replacing the stack guard with something that // will trip any stack check and leaving a flag to tell newstack to die. _g_.stackguard0 = stackPreempt // 设置抢占，在调用返回时会修改回来 // 不能扩展栈，在调用返回时会修改回来 _g_.throwsplit = true // Leave SP around for GC and traceback. save(pc, sp) // 保存g的现场信息，rsp，rbp，rip等 _g_.syscallsp = sp _g_.syscallpc = pc // 监控线程依赖_Gsyscall状态实施系统调用时的抢占 casgstatus(_g_, _Grunning, _Gsyscall) // 切换g状态为系统调用中 // SP是否在goroutine的栈范围内 if _g_.syscallsp \u003c _g_.stack.lo || _g_.stack.hi \u003c _g_.syscallsp { systemstack(func() { print(\"entersyscall inconsistent \", hex(_g_.syscallsp), \" [\", hex(_g_.stack.lo), \",\", hex(_g_.stack.hi), \"]\\n\") throw(\"entersyscall\") }) } if trace.enabled { systemstack(traceGoSysCall) // systemstack itself clobbers g.sched.{pc,sp} and we might // need them later when the G is genuinely blocked in a // syscall save(pc, sp) } // sysmon 监控线程正挂起在 sched.sysmonwait if atomic.Load(\u0026sched.sysmonwait) != 0 { // 切换到g0栈调用 entersyscall_sysmon 函数 // entersyscall_sysmon 函数唤醒 sysmon 监控线程 systemstack(entersyscall_sysmon) save(pc, sp) } if _g_.m.p.ptr().runSafePointFn != 0 { // runSafePointFn may stack split if run on this stack systemstack(runSafePointFn) save(pc, sp) } // 把P的调用次数拷贝给M _g_.m.syscalltick = _g_.m.p.ptr().syscalltick _g_.sysblocktraced = true // M和P相互解除关联，并把P暂存与m.oldp中， // 等待系统调用完后使用 // 解除p.m关联的m pp := _g_.m.p.ptr() // pp = p pp.m = 0 // m.oldp = pp _g_.m.oldp.set(pp) // 解除 m.p 的关系 p _g_.m.p = 0 atomic.Store(\u0026pp.status, _Psyscall) // pp.status = _Psyscall // STW正在等待时 if sched.gcwaiting != 0 { // 切换到g0栈调用entersyscall_gcwait函数 // entersyscall_gcwait函数，将P状态设置为 _Pgcstop，如果STW已完成则唤醒在sched.stopnote上等待的STW发起的线程。 systemstack(entersyscall_gcwait) save(pc, sp) } _g_.m.locks-- } save() 保存goroutine现场。 文件位置：go1.19.3/src/runtime/proc.go。 3543 3544 3545 3546 3547 3548 3549 3550 3551 3552 3553 3554 3555 3556 3557 3558 3559 3560 3561 3562 3563 3564 3565 3566 3567 3568 3569 3570 3571 3572 3573 // save updates getg().sched to refer to pc and sp so that a following // gogo will restore pc and sp. // // save must not have write barriers because invoking a write barrier // can clobber getg().sched. // //go:nosplit //go:nowritebarrierrec func save(pc, sp uintptr) { gp := getg() if gp == gp.m.g0 || gp == gp.m.gsignal { // m.g0.sched is special and must describe the context // for exiting the thread. mstart1 writes to it directly. // m.gsignal.sched should not be used at all. // This check makes sure save calls do not accidentally // run in contexts where they'd write to system g's. throw(\"save on system g not allowed\") } gp.sched.pc = pc gp.sched.sp = sp gp.sched.lr = 0 gp.sched.ret = 0 // We need to ensure ctxt is zero, but can't have a write // barrier here. However, it should always already be zero. // Assert that. if gp.sched.ctxt != nil { badctxt() } } 系统调用后 exitsyscall() 这个goroutine g退出系统调用。安排它再次在cpu上运行。 这仅从go系统调用库中调用，而不是从运行时使用的低级系统调用中调用。 写屏障是不被允许的，因为我们的P可能被偷了。 文件位置：go1.19.3/src/runtime/proc.go。 3761 3762 3763 3764 3765 3766 3767 3768 3769 3770 3771 3772 3773 3774 3775 3776 3777 3778 3779 3780 3781 3782 3783 3784 3785 3786 3787 3788 3789 3790 3791 3792 3793 3794 3795 3796 3797 3798 3799 3800 3801 3802 3803 3804 3805 3806 3807 3808 3809 3810 3811 3812 3813 3814 3815 3816 3817 3818 3819 3820 3821 3822 3823 3824 3825 3826 3827 3828 3829 3830 3831 3832 3833 3834 3835 3836 3837 3838 3839 3840 3841 3842 3843 3844 3845 3846 3847 3848 3849 3850 3851 3852 3853 3854 3855 3856 3857 3858 3859 3860 3861 3862 3863 3864 3865 3866 // The goroutine g exited its system call. // Arrange for it to run on a cpu again. // This is called only from the go syscall library, not // from the low-level system calls used by the runtime. // // Write barriers are not allowed because our P may have been stolen. // // This is exported via linkname to assembly in the syscall package. // //go:nosplit //go:nowritebarrierrec //go:linkname exitsyscall func exitsyscall() { // user goroutine _g_ := getg() // goroutine g _g_.m.locks++ // see comment in entersyscall if getcallersp() \u003e _g_.syscallsp { throw(\"exitsyscall: syscall frame is no longer valid\") } // g.waitsince，g被阻塞的大约时间 _g_.waitsince = 0 // 进入系统调用之前所绑定的p oldp := _g_.m.oldp.ptr() _g_.m.oldp = 0 // exitsyscallfast 尝试绑定P，成功返回true，失败返回false。 if exitsyscallfast(oldp) { // When exitsyscallfast returns success, we have a P so can now use // write barriers if goroutineProfile.active { // Make sure that gp has had its stack written out to the goroutine // profile, exactly as it was when the goroutine profiler first // stopped the world. systemstack(func() { tryRecordGoroutineProfileWB(_g_) }) } if trace.enabled { if oldp != _g_.m.p.ptr() || _g_.m.syscalltick != _g_.m.p.ptr().syscalltick { systemstack(traceGoStart) } } // There's a cpu for us, so we can run. _g_.m.p.ptr().syscalltick++ // We need to cas the status and scan before resuming... casgstatus(_g_, _Gsyscall, _Grunning) // Garbage collector isn't running (since we are), // so okay to clear syscallsp. _g_.syscallsp = 0 _g_.m.locks-- if _g_.preempt { // restore the preemption request in case we've cleared it in newstack // 恢复抢占请求，以防我们在newstack中清除了它 _g_.stackguard0 = stackPreempt } else { // otherwise restore the real _StackGuard, we've spoiled it in entersyscall/entersyscallblock // 否则恢复真正的_StackGuard，我们已经在entersyscall/entersyscallblock中破坏了它 _g_.stackguard0 = _g_.stack.lo + _StackGuard } _g_.throwsplit = false // sched.disable.user == true，用户goroutine被禁止运行 // schedEnabled判断g是否是系统goroutine if sched.disable.user \u0026\u0026 !schedEnabled(_g_) { // Scheduling of this goroutine is disabled. Gosched() // 让出CPU，当前goroutine。 } return } // M绑定P没有成功时。 _g_.sysexitticks = 0 if trace.enabled { // Wait till traceGoSysBlock event is emitted. // This ensures consistency of the trace (the goroutine is started after it is blocked). for oldp != nil \u0026\u0026 oldp.syscalltick == _g_.m.syscalltick { osyield() } // We can't trace syscall exit right now because we don't have a P. // Tracing code can invoke write barriers that cannot run without a P. // So instead we remember the syscall exit time and emit the event // in execute when we have a P. _g_.sysexitticks = cputicks() } _g_.m.locks-- // Call the scheduler. // // 没有绑定到p，调用mcall切换到g0栈执行exitsyscall0函数 mcall(exitsyscall0) // mcall函数会保存现场，切换g0调用exitsyscall0函数 // Scheduler returned, so we're allowed to run now. // Delete the syscallsp information that we left for // the garbage collector during the system call. // Must wait until now because until gosched returns // we don't know for sure that the garbage collector // is not running. _g_.syscallsp = 0 _g_.m.p.ptr().syscalltick++ _g_.throwsplit = false } exitsyscallfast() 尝试绑定一个空闲的P。true.绑定成功，false.绑定失败。 文件位置：go1.19.3/src/runtime/proc.go。 3856 3857 3858 3859 3860 3861 3862 3863 3864 3865 3866 3867 3868 3869 3870 3871 3872 3873 3874 3875 3876 3877 3878 3879 3880 3881 3882 3883 3884 3885 3886 3887 3888 3889 3890 3891 3892 3893 3894 3895 3896 3897 3898 3899 3900 3901 3902 3903 3904 //go:nosplit func exitsyscallfast(oldp *p) bool { _g_ := getg() // g // Freezetheworld sets stopwait but does not retake P's. // // Freezetheworld 设置停止等待，但不重新获取P。 // const freezeStopWait int = 0x7fffffff if sched.stopwait == freezeStopWait { return false } // Try to re-acquire the last P. // // 试着重新获取last P。 if oldp != nil \u0026\u0026 oldp.status == _Psyscall \u0026\u0026 atomic.Cas(\u0026oldp.status, _Psyscall, _Pidle) { // There's a cpu for us, so we can run. // 我们有cpu，所以我们可以运行。 wirep(oldp) // 绑定P exitsyscallfast_reacquired() // 处理P的syscalltick字段 return true } // Try to get any other idle P. // // 尝试获取一个空闲的P。 if sched.pidle != 0 { var ok bool // 切换到g0栈 systemstack(func() { // 从全局队列中寻找空闲的p，需要加锁，比较慢 ok = exitsyscallfast_pidle() // 搬到成功返回true，绑定失败返回false。 if ok \u0026\u0026 trace.enabled { if oldp != nil { // Wait till traceGoSysBlock event is emitted. // This ensures consistency of the trace (the goroutine is started after it is blocked). for oldp.syscalltick == _g_.m.syscalltick { osyield() } } traceGoSysExit(0) } }) if ok { return true } } return false } exitsyscallfast_pidle() 文件位置：go1.19.3/src/runtime/proc.go。 3913 3914 3915 3916 3917 3918 3919 3920 3921 3922 3923 3924 3925 3926 3927 func exitsyscallfast_pidle() bool { lock(\u0026sched.lock) _p_, _ := pidleget(0) // 处理sysmon，因为在陷入到系统调用是sysmon可能自己把自己挂起，所以需要恢复 if _p_ != nil \u0026\u0026 atomic.Load(\u0026sched.sysmonwait) != 0 { atomic.Store(\u0026sched.sysmonwait, 0) notewakeup(\u0026sched.sysmonnote) } unlock(\u0026sched.lock) if _p_ != nil { acquirep(_p_) // 绑定P如果有的话 return true } return false } exitsyscall0() exitsyscall在g0上的慢路径。获取P失败将gp放入可运行队列中。 通过mcall()调用，gp是从这个M调用g。 文件位置：go1.19.3/src/runtime/proc.go。 3934 3935 3936 3937 3938 3939 3940 3941 3942 3943 3944 3945 3946 3947 3948 3949 3950 3951 3952 3953 3954 3955 3956 3957 3958 3959 3960 3961 3962 3963 3964 3965 3966 3967 3968 3969 3970 3971 3972 3973 3974 3975 3976 3977 3978 3979 3980 3981 3982 3983 3984 3985 3986 3987 // exitsyscall slow path on g0. // Failed to acquire P, enqueue gp as runnable. // // Called via mcall, so gp is the calling g from this M. // //go:nowritebarrierrec func exitsyscall0(gp *g) { // 修改gp状态为_Grunnable casgstatus(gp, _Gsyscall, _Grunnable) dropg() // 解除g关联关系 lock(\u0026sched.lock) var _p_ *p // 判断gp是否是系统goroutine，如果是的话再次尝试获取P。 if schedEnabled(gp) { _p_, _ = pidleget(0) } var locked bool if _p_ == nil { globrunqput(gp) // gp加入全局可运行队列 // Below, we stoplockedm if gp is locked. globrunqput releases // ownership of gp, so we must check if gp is locked prior to // committing the release by unlocking sched.lock, otherwise we // could race with another M transitioning gp from unlocked to // locked. // // 下面，如果gp被锁定，我们将停止阻塞。 // globrunqput释放了gp的所有权，所以我们必须在释放之前通过解锁sched.lock检查gp是否被锁定，否则我们可以与另一个M转换gp从解锁到锁定。 locked = gp.lockedm != 0 } else if atomic.Load(\u0026sched.sysmonwait) != 0 { // 尝试唤醒sysmon，如果有 atomic.Store(\u0026sched.sysmonwait, 0) notewakeup(\u0026sched.sysmonnote) } unlock(\u0026sched.lock) if _p_ != nil { acquirep(_p_) // 绑定P // gp 被调度起来运行 execute(gp, false) // Never returns. } if locked { // Wait until another thread schedules gp and so m again. // // N.B. lockedm must be this M, as this g was running on this M // before entersyscall. // // 等待另一个线程调度gp，然后再调度m。 // 注意，lockedm一定是这个M，因为这个g在entersyscall之前是在这个M上运行的。 stoplockedm() execute(gp, false) // Never returns. } stopm() // 当前工作线程被挂起，等待被唤醒获取P然后运行起来 // 调度循环开始 schedule() // Never returns. } 信号形式发送抢占 preemptM() preemptM向mp发送抢占请求。该请求可以异步处理，并且可以与对M的其他请求合并。 当接收到请求时，如果正在运行的G或P被标记为抢占，并且goroutine处于异步安全点，则它将抢占 goroutine。 它总是在处理抢占请求后自动递增mp.preemptGen。 通过runtime.signalM()函数向执行M发送sigPreempt信号。 至于signalM()函数，就是调用操作系统的信号相关系统调用，将指定信号发送给目标线程。 至此，异步抢占逻辑的主要工作就算完成了前一半。 preemptM这个函数会调用signalM将在初始化的安装的_SIGURG信号发送到指定的M上。 使用 preemptM 发送抢占信号的地方主要有下面几个： Go 后台监控 runtime.sysmon 检测超时发送抢占信号； Go GC 栈扫描发送抢占信号； Go GC STW 的时候调用 preemptall 抢占所有 P，让其暂停； 文件位置：go1.19.3/src/runtime/signal_unix.go。 参数mp *m：被抢占的P关联的M。 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 // preemptM sends a preemption request to mp. This request may be // handled asynchronously and may be coalesced with other requests to // the M. When the request is received, if the running G or P are // marked for preemption and the goroutine is at an asynchronous // safe-point, it will preempt the goroutine. It always atomically // increments mp.preemptGen after handling a preemption request. func preemptM(mp *m) { // On Darwin, don't try to preempt threads during exec. // Issue #41702. if GOOS == \"darwin\" || GOOS == \"ios\" { execLock.rlock() } // mp.signalPending: 这个M上是否有一个待处理的抢占信号。原子操作。 if atomic.Cas(\u0026mp.signalPending, 0, 1) { if GOOS == \"darwin\" || GOOS == \"ios\" { atomic.Xadd(\u0026pendingPreemptSignals, 1) } // If multiple threads are preempting the same M, it may send many // signals to the same M such that it hardly make progress, causing // live-lock problem. Apparently this could happen on darwin. See // issue #37741. // Only send a signal if there isn't already one pending. // // 如果多个线程抢占同一个M，它可能会向同一个M发送许多信号， // 使其几乎无法取得进展，从而导致实时锁定问题。 // 显然这可能发生在darwin身上。只有在还没有挂起的情况下才发送信号。 // const sigPreempt int = _SIGURG // const _SIGURG = 0x17 signalM(mp, sigPreempt) } if GOOS == \"darwin\" || GOOS == \"ios\" { execLock.runlock() } } signalM() signalM向mp发送信号。 文件位置：go1.19.3/src/runtime/os_linux.go。 551 552 553 554 555 556 557 558 559 560 561 562 // signalM sends a signal to mp. func signalM(mp *m, sig int) { // 将信号sig发送到线程组tgid中具有线程ID tid的线程。 // int tgkill(int tgid, int tid, int sig); // 1. tgid：为线程组中主线程的线程ID，或者称为进程号。 // 其实它能起到保护的作用，防止向错误的线程发送信号。 // 比如向线程ID为1234的线程发送信号时，很可能线程1234早就退出了， // 而线程ID 1234恰好被内核分配给了另一个不相干的进程。 // 2. tid：线程ID。 // 3. sig：信号值。sigPreempt = _SIGURG = 0x17。 tgkill(getpid(), int(mp.procid), sig) } tgkill() 系统调用 tgkill() 函数向进程内的线程发送信号。 文件位置：go1.19.3/src/runtime/sys_linux_amd64.s。 176 177 178 179 180 181 182 TEXT ·tgkill(SB),NOSPLIT,$0 MOVQ tgid+0(FP), DI MOVQ tid+8(FP), SI MOVQ sig+16(FP), DX MOVL $SYS_tgkill, AX SYSCALL # 进入系统调用 RET 全局信号处理注册 mstart1() 主线程启动运行到mstart()-\u003emstart0()-\u003emstart1()函数内时。 文件位置：go1.19.3/src/runtime/proc.go。 1394 1395 1396 1397 1398 1399 1400 1401 1402 1403 1404 1405 1406 1407 1408 1409 1410 1411 1412 // The go:noinline is to guarantee the getcallerpc/getcallersp below are safe, // so that we can set up g0.sched to return to the call of mstart1 above. // //go:noinline func mstart1() { // ... asminit() minit() // Install signal handlers; after minit so that minit can // prepare the thread to be able to handle the signals. // // 安装信号处理程序;在minit之后，以便minit可以准备线程，以便能够处理信号。 if gp.m == \u0026m0 { mstartm0() } // ... } mstartm0() initsig(false)则是注册信号处理相关。 文件位置：go1.19.3/src/runtime/proc.go。 1435 1436 1437 1438 1439 1440 1441 1442 1443 1444 1445 1446 1447 1448 1449 1450 // mstartm0 implements part of mstart1 that only runs on the m0. // // Write barriers are allowed here because we know the GC can't be // running yet, so they'll be no-ops. // //go:yeswritebarrierrec func mstartm0() { // Create an extra M for callbacks on threads not created by Go. // An extra M is also needed on Windows for callbacks created by // syscall.NewCallback. See issue #6751 for details. if (iscgo || GOOS == \"windows\") \u0026\u0026 !cgoHasExtraM { cgoHasExtraM = true newextram() } initsig(false) } initsig() 信号注册。 文件位置：go1.19.3/src/runtime/signal_unix.go。 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 // Initialize signals. // Called by libpreinit so runtime may not be initialized. // //go:nosplit //go:nowritebarrierrec func initsig(preinit bool) { if !preinit { // It's now OK for signal handlers to run. // // 现在可以运行信号处理程序了。 signalsOK = true } // For c-archive/c-shared this is called by libpreinit with // preinit == true. if (isarchive || islibrary) \u0026\u0026 !preinit { return } // 遍历信号数组 // const _NSIG int = 65; for i := uint32(0); i \u003c _NSIG; i++ { // sigtable 全局变量存储的是所有信号及描述 t := \u0026sigtable[i] // const _SigDefault int = 16; // 如果信号没有被显式请求，就不要监视它 // 略过信号，SIGKILL、SIGSTOP、SIGTSTP、SIGCONT、SIGTTIN、SIGTTOU if t.flags == 0 || t.flags\u0026_SigDefault != 0 { continue } // We don't need to use atomic operations here because // there shouldn't be any other goroutines running yet. fwdSig[i] = getsig(i) if !sigInstallGoHandler(i) { // Even if we are not installing a signal handler, // set SA_ONSTACK if necessary. if fwdSig[i] != _SIG_DFL \u0026\u0026 fwdSig[i] != _SIG_IGN { setsigstack(i) } else if fwdSig[i] == _SIG_IGN { sigInitIgnored(i) } continue } handlingSig[i] = 1 setsig(i, abi.FuncPCABIInternal(sighandler)) } } setsig() 这里需要注意的是，当 fn 等于 sighandler 的时候，调用的函数会被替换成 sigtramp。 sigaction 函数在 Linux 下会调用系统调用函数 sys_signal 以及 sys_rt_sigaction 实现安装信号。 文件位置：go1.19.3/src/runtime/os_linux.go。 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 //go:nosplit //go:nowritebarrierrec func setsig(i uint32, fn uintptr) { var sa sigactiont sa.sa_flags = _SA_SIGINFO | _SA_ONSTACK | _SA_RESTORER | _SA_RESTART sigfillset(\u0026sa.sa_mask) // Although Linux manpage says \"sa_restorer element is obsolete and // should not be used\". x86_64 kernel requires it. Only use it on // x86. if GOARCH == \"386\" || GOARCH == \"amd64\" { sa.sa_restorer = abi.FuncPCABI0(sigreturn) } if fn == abi.FuncPCABIInternal(sighandler) { // abi.FuncPCABIInternal(sighandler) matches the callers in signal_unix.go if iscgo { fn = abi.FuncPCABI0(cgoSigtramp) } else { // 替换为调用 sigtramp fn = abi.FuncPCABI0(sigtramp) } } sa.sa_handler = fn sigaction(i, \u0026sa, nil) } 信号形式响应抢占 sigtramp() 函数原型：func sigtramp()。 sigtramp()实际上是真正的信号处理函数，进程从内核态收到信号回到用户态调用的处理函数就是它。 注释中表明这个函数以C语言的调用惯例被调用，Go在这里通过PUSH_REGS_HOST_TO_ABI0保存go自己调用惯例用的寄存器后， 转换成自己的调用规范，等函数调用完毕之后，再通过POP_REGS_HOST_TO_ABI0恢复这些寄存器的值。 调度路径sigtramp()-\u003esigtrampgo()-\u003esighandler()-\u003edoSigPreempt()。 这里会被调用说明信号已经发送响应了，runtime·sigtramp会进行信号的处理。 runtime·sigtramp会继续调用runtime·sigtrampgo。 文件位置：go1.19.3/src/runtime/sys_linux_amd64.s。 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 # Called using C ABI. TEXT runtime·sigtramp(SB),NOSPLIT|TOPFRAME,$0 # Transition from C ABI to Go ABI. PUSH_REGS_HOST_TO_ABI0() # Set up ABIInternal environment: g in R14, cleared X15. get_tls(R12) # TLS MOVQ g(R12), R14 # R14 = g PXOR X15, X15 # Reserve space for spill slots. NOP SP # disable vet stack checking ADJSP $24 # Call into the Go signal handler # # 内核修改用户态寄存器时设置的 rdi、rsi、rdx # 三个寄存器的值就是内核模仿调用sigtramp时传入的参数 MOVQ DI, AX\t# sig MOVQ SI, BX\t# info MOVQ DX, CX\t# ctx CALL ·sigtrampgo\u003cABIInternal\u003e(SB) ADJSP $-24 POP_REGS_HOST_TO_ABI0() RET sigtrampgo() 文件位置：go1.19.3/src/runtime/signal_unix.go。 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 // sigtrampgo is called from the signal handler function, sigtramp, // written in assembly code. // This is called by the signal handler, and the world may be stopped. // // It must be nosplit because getg() is still the G that was running // (if any) when the signal was delivered, but it's (usually) called // on the gsignal stack. Until this switches the G to gsignal, the // stack bounds check won't work. // //go:nosplit //go:nowritebarrierrec func sigtrampgo(sig uint32, info *siginfo, ctx unsafe.Pointer) { if sigfwdgo(sig, info, ctx) { return } c := \u0026sigctxt{info, ctx} gp := sigFetchG(c) // g setg(gp) if gp == nil { if sig == _SIGPROF { // Some platforms (Linux) have per-thread timers, which we use in // combination with the process-wide timer. Avoid double-counting. if validSIGPROF(nil, c) { sigprofNonGoPC(c.sigpc()) } return } if sig == sigPreempt \u0026\u0026 preemptMSupported \u0026\u0026 debug.asyncpreemptoff == 0 { // This is probably a signal from preemptM sent // while executing Go code but received while // executing non-Go code. // We got past sigfwdgo, so we know that there is // no non-Go signal handler for sigPreempt. // The default behavior for sigPreempt is to ignore // the signal, so badsignal will be a no-op anyway. if GOOS == \"darwin\" || GOOS == \"ios\" { pendingPreemptSignals.Add(-1) } return } c.fixsigcode(sig) badsignal(uintptr(sig), c) return } setg(gp.m.gsignal) // If some non-Go code called sigaltstack, adjust. var gsignalStack gsignalStack setStack := adjustSignalStack(sig, gp.m, \u0026gsignalStack) if setStack { gp.m.gsignal.stktopsp = getcallersp() } if gp.stackguard0 == stackFork { signalDuringFork(sig) } c.fixsigcode(sig) sighandler(sig, info, ctx, gp) setg(gp) if setStack { restoreGsignalStack(\u0026gsignalStack) } } sighander() 响应抢占。调度路径sigtramp()-\u003esigtrampgo()-\u003esighandler()-\u003edoSigPreempt()。 文件位置：go1.19.3/src/runtime/signal_unix.go。 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 // sighandler is invoked when a signal occurs. The global g will be // set to a gsignal goroutine and we will be running on the alternate // signal stack. The parameter g will be the value of the global g // when the signal occurred. The sig, info, and ctxt parameters are // from the system signal handler: they are the parameters passed when // the SA is passed to the sigaction system call. // // The garbage collector may have stopped the world, so write barriers // are not allowed. // //go:nowritebarrierrec func sighandler(sig uint32, info *siginfo, ctxt unsafe.Pointer, gp *g) { // ... ... // sig == sigPreempt：抢占信号 // debug.asyncpreemptoff == 0：没有禁止抢占 // delayedSignal：延迟信号? if sig == sigPreempt \u0026\u0026 debug.asyncpreemptoff == 0 \u0026\u0026 !delayedSignal { // Might be a preemption signal. // 可能是一个抢占信号。 doSigPreempt(gp, c) // Even if this was definitely a preemption signal, it // may have been coalesced with another signal, so we // still let it through to the application. // 即使这确实是一个抢占信号，它可能已经与另一个信号合并，所以我们仍然让它通过应用程序。 } // ... ... } doSigPreempt() doSigPreempt处理gp上的抢占信号。 调用到doSigPreempt时，会将ctx这个参数传入，其中包含了进程用户态硬件上下文 ctxt的类型为*sigctxt，指向的是用户态堆栈中存放内核态堆栈内容的地址。 然后信号处理程序通过isAsyncSafePoint来判断抢占位置是否安全，并返回安全的抢占地址。 如果确认抢占没有问题，接着会调用pushCall方法来修改ctxt中的用户态硬件上下文， 用于稍后再一次从内核态返回用户态时模拟出一个用户态程序调用asyncPreempt的假象。 文件位置：go1.19.3/src/runtime/signal_unix.go。 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 // doSigPreempt handles a preemption signal on gp. func doSigPreempt(gp *g, ctxt *sigctxt) { // Check if this G wants to be preempted and is safe to // preempt. // 检查这个G是否希望被抢占，并且抢占是安全的。 // 通过 wantAsyncPreempt 函数确认runtime确实想要对指定的G实施异步抢占 if wantAsyncPreempt(gp) { // 通过isAsyncSafePoint函数确认G当前执行上下文是能够安全地进行异步抢占的。 if ok, newpc := isAsyncSafePoint(gp, ctxt.sigpc(), ctxt.sigsp(), ctxt.siglr()); ok { // Adjust the PC and inject a call to asyncPreempt. // 以上两个函数都确认无误后，才通过pushCall向G的执行上下文中注入一个函数调用， // 要调用的目标函数是 runtime.asyncPreempt 函数。这是一个汇编函数，它会先把各个寄存器的值保存在栈上， // 也就是将现场保存在栈上，然后调用 runtime.asyncPreempt2函数。 ctxt.pushCall(abi.FuncPCABI0(asyncPreempt), newpc) // 就是向当前运行的goroutine注册加入asyncPreempt函数 } } // Acknowledge the preemption. atomic.Xadd(\u0026gp.m.preemptGen, 1) atomic.Store(\u0026gp.m.signalPending, 0) if GOOS == \"darwin\" || GOOS == \"ios\" { atomic.Xadd(\u0026pendingPreemptSignals, -1) } } wantAsyncPreempt() wantAsyncPreempt返回异步抢占是否为gp排队。 文件位置：go1.19.3/src/runtime/preempt.go。 340 341 342 343 344 345 346 347 348 349 350 // wantAsyncPreempt returns whether an asynchronous preemption is // queued for gp. func wantAsyncPreempt(gp *g) bool { // Check both the G and the P. // 同时检查G和P的preempt字段，并且G当前需要处于_Grunning状态。 // 在每轮调度循环中，P和G的preempt字段都会被置为false，所以这个检测能够避免刚刚切换至一个新的G后马上又被抢占。 // gp.preempt || gp.m.p != 0 \u0026\u0026 gp.m.p.ptr().preempt：判断G或P的preempt抢占标识位。 // readgstatus(gp)\u0026^_Gscan == _Grunning：当前G正在运行状态。 // 确认是否设置了抢占标志 return (gp.preempt || gp.m.p != 0 \u0026\u0026 gp.m.p.ptr().preempt) \u0026\u0026 readgstatus(gp)\u0026^_Gscan == _Grunning } isAsyncSafePoint() 它从以下几个方面来保证在当前位置进行异步抢占是安全的。 可以挂起G并安全的扫描它的栈和寄存器，没有潜在的隐藏指针，而且当前并没有打断一个写屏障。 G还有足够的栈空间来注入一个对asyncPreempt()函数的调用。 可以安全地和 runtime 进行交互，例如未持有 runtime 相关的锁，因此在尝试获得锁时不会造成死锁。 isAsyncSafePoint报告指令PC上的gp是否是异步安全点。这表明： 暂停gp并保守地扫描它的堆栈和寄存器是安全的。它没有潜在的隐藏指针值，也不像写屏障那样位于原子序列的中间。 gp有足够的堆栈空间注入asyncPreempt调用。 通常情况下，与运行时交互是安全的，即使我们在信号处理程序中就停在这里。例如，没有持有运行时锁，因此获取运行时锁不会自死锁。 在某些情况下，PC是安全的异步抢占，但它也需要调整恢复PC。新的PC在第二个结果中返回。 文件位置：go1.19.3/src/runtime/preempt.go。 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 // isAsyncSafePoint reports whether gp at instruction PC is an // asynchronous safe point. This indicates that: // // 1. It's safe to suspend gp and conservatively scan its stack and // registers. There are no potentially hidden pointer values and it's // not in the middle of an atomic sequence like a write barrier. // // 2. gp has enough stack space to inject the asyncPreempt call. // // 3. It's generally safe to interact with the runtime, even if we're // in a signal handler stopped here. For example, there are no runtime // locks held, so acquiring a runtime lock won't self-deadlock. // // In some cases the PC is safe for asynchronous preemption but it // also needs to adjust the resumption PC. The new PC is returned in // the second result. func isAsyncSafePoint(gp *g, pc, sp, lr uintptr) (bool, uintptr) { mp := gp.m // Only user Gs can have safe-points. We check this first // because it's extremely common that we'll catch mp in the // scheduler processing this G preemption. // // 只有用户Gs可以有安全点。我们首先检查这个，因为在处理G抢占的调度器中捕获mp是非常常见的。 if mp.curg != gp { return false, 0 } // Check M state. // 检查M状态。 // canPreemptM(mp) -\u003e mp.locks == 0 \u0026\u0026 mp.mallocing == 0 \u0026\u0026 mp.preemptoff == \"\" \u0026\u0026 mp.p.ptr().status == _Prunning if mp.p == 0 || !canPreemptM(mp) { return false, 0 } // Check stack space. // 检查栈空间。 // asyncPreemptStack是注入一个asyncPreempt调用所需的栈空间的字节。 if sp \u003c gp.stack.lo || sp-gp.stack.lo \u003c asyncPreemptStack { return false, 0 } // Check if PC is an unsafe-point. // 检查PC是否为不安全点。 f := findfunc(pc) if !f.valid() { // Not Go code. return false, 0 } if (GOARCH == \"mips\" || GOARCH == \"mipsle\" || GOARCH == \"mips64\" || GOARCH == \"mips64le\") \u0026\u0026 lr == pc+8 \u0026\u0026 funcspdelta(f, pc, nil) == 0 { // We probably stopped at a half-executed CALL instruction, // where the LR is updated but the PC has not. If we preempt // here we'll see a seemingly self-recursive call, which is in // fact not. // This is normally ok, as we use the return address saved on // stack for unwinding, not the LR value. But if this is a // call to morestack, we haven't created the frame, and we'll // use the LR for unwinding, which will be bad. return false, 0 } up, startpc := pcdatavalue2(f, _PCDATA_UnsafePoint, pc) if up == _PCDATA_UnsafePointUnsafe { // Unsafe-point marked by compiler. This includes // atomic sequences (e.g., write barrier) and nosplit // functions (except at calls). return false, 0 } if fd := funcdata(f, _FUNCDATA_LocalsPointerMaps); fd == nil || f.flag\u0026funcFlag_ASM != 0 { // This is assembly code. Don't assume it's well-formed. // TODO: Empirically we still need the fd == nil check. Why? // // TODO: Are there cases that are safe but don't have a // locals pointer map, like empty frame functions? // It might be possible to preempt any assembly functions // except the ones that have funcFlag_SPWRITE set in f.flag. return false, 0 } name := funcname(f) if inldata := funcdata(f, _FUNCDATA_InlTree); inldata != nil { inltree := (*[1 \u003c\u003c 20]inlinedCall)(inldata) ix := pcdatavalue(f, _PCDATA_InlTreeIndex, pc, nil) if ix \u003e= 0 { name = funcnameFromNameoff(f, inltree[ix].func_) } } if hasPrefix(name, \"runtime.\") || hasPrefix(name, \"runtime/internal/\") || hasPrefix(name, \"reflect.\") { // For now we never async preempt the runtime or // anything closely tied to the runtime. Known issues // include: various points in the scheduler (\"don't // preempt between here and here\"), much of the defer // implementation (untyped info on stack), bulk write // barriers (write barrier check), // reflect.{makeFuncStub,methodValueCall}. // // TODO(austin): We should improve this, or opt things // in incrementally. return false, 0 } switch up { case _PCDATA_Restart1, _PCDATA_Restart2: // Restartable instruction sequence. Back off PC to // the start PC. if startpc == 0 || startpc \u003e pc || pc-startpc \u003e 20 { throw(\"bad restart PC\") } return true, startpc case _PCDATA_RestartAtEntry: // Restart from the function entry at resumption. return true, f.entry() } return true, pc } pushCall() pushCall干了两件事： 修改程序计数器的指向为asyncPreempt函数的地址。 修改栈顶指针，将当前 goroutine 的原本中断地址放入堆栈。 文件位置：go1.19.3/src/runtime/signal_amd64.go。 先把SP向下移动一个指针大小的位置，把PC的值存入栈上SP指向的位置，然后将PC的值更新为targetPC。 这样就模拟了一条CALL指令的效果，栈上存入的PC的旧值就相当于返回地址。 此时整个执行上下文的状态就像是goroutine在被信号打断的位置额外执行了一条CALL targetPC指令。 由于执行流程刚刚跳转到targetPC地址处，所以还没来得及执行目标地址处的指令。 当sighandler()函数处理完信号并返回后，被打断的goroutine得以继续执行，会立即调用被注入的asyncPreempt()函数。经过一连串的函数调用，最终执行到schedule()函数。 参数： targetPC uintptr：asyncPreempt 函数的执行入口地址。 resumePC uintptr：其实就是发生中断前当前goroutine的下一指令地址，也就是PC的值。 80 81 82 83 84 85 86 87 88 89 func (c *sigctxt) pushCall(targetPC, resumePC uintptr) { // Make it look like we called target at resumePC. // 让它看起来像我们在resumePC上调用了target。 sp := uintptr(c.rsp()) // 当前goroutine的SP sp -= goarch.PtrSize *(*uintptr)(unsafe.Pointer(sp)) = resumePC // 设置当前中断保存的上下文信息，因为中断结束后从这里恢复。 c.set_rsp(uint64(sp)) // 修改中断保存的上下文SP c.set_rip(uint64(targetPC)) // 修改中断保存的上下文PC } asyncPreempt() 中断信号函数处理完后，goroutine得到运行，继续从嵌入的本函数开始执行。 文件位置：go1.19.3/src/runtime/preempt_amd64.s。 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 TEXT ·asyncPreempt(SB),NOSPLIT|NOFRAME,$0-0 PUSHQ BP # BP入栈 MOVQ SP, BP # BP = SP # Save flags before clobbering them PUSHFQ # obj doesn't understand ADD/SUB on SP, but does understand ADJSP ADJSP $368 # But vet doesn't know ADJSP, so suppress vet stack checking NOP SP MOVQ AX, 0(SP) MOVQ CX, 8(SP) MOVQ DX, 16(SP) MOVQ BX, 24(SP) MOVQ SI, 32(SP) MOVQ DI, 40(SP) MOVQ R8, 48(SP) MOVQ R9, 56(SP) MOVQ R10, 64(SP) MOVQ R11, 72(SP) MOVQ R12, 80(SP) MOVQ R13, 88(SP) MOVQ R14, 96(SP) MOVQ R15, 104(SP) #ifdef GOOS_darwin CMPB internal∕cpu·X86+const_offsetX86HasAVX(SB), $0 JE 2(PC) VZEROUPPER #endif MOVUPS X0, 112(SP) MOVUPS X1, 128(SP) MOVUPS X2, 144(SP) MOVUPS X3, 160(SP) MOVUPS X4, 176(SP) MOVUPS X5, 192(SP) MOVUPS X6, 208(SP) MOVUPS X7, 224(SP) MOVUPS X8, 240(SP) MOVUPS X9, 256(SP) MOVUPS X10, 272(SP) MOVUPS X11, 288(SP) MOVUPS X12, 304(SP) MOVUPS X13, 320(SP) MOVUPS X14, 336(SP) MOVUPS X15, 352(SP) CALL ·asyncPreempt2(SB) # 调用asyncPreempt2 # 下次goroutine再度被运行起来时，从这里恢复。 MOVUPS 352(SP), X15 MOVUPS 336(SP), X14 MOVUPS 320(SP), X13 MOVUPS 304(SP), X12 MOVUPS 288(SP), X11 MOVUPS 272(SP), X10 MOVUPS 256(SP), X9 MOVUPS 240(SP), X8 MOVUPS 224(SP), X7 MOVUPS 208(SP), X6 MOVUPS 192(SP), X5 MOVUPS 176(SP), X4 MOVUPS 160(SP), X3 MOVUPS 144(SP), X2 MOVUPS 128(SP), X1 MOVUPS 112(SP), X0 MOVQ 104(SP), R15 MOVQ 96(SP), R14 MOVQ 88(SP), R13 MOVQ 80(SP), R12 MOVQ 72(SP), R11 MOVQ 64(SP), R10 MOVQ 56(SP), R9 MOVQ 48(SP), R8 MOVQ 40(SP), DI MOVQ 32(SP), SI MOVQ 24(SP), BX MOVQ 16(SP), DX MOVQ 8(SP), CX MOVQ 0(SP), AX ADJSP $-368 POPFQ POPQ BP RET # 返回继续去执行原来的goroutine代码 asyncPreempt2() 文件位置：go1.19.3/src/runtime/preempt.go。 301 302 303 304 305 306 307 308 309 310 311 312 313 314 //go:nosplit func asyncPreempt2() { gp := getg() gp.asyncSafePoint = true // preemptStop 主要在GC标记期间被用来挂起运行中的 goroutine if gp.preemptStop { // preemptPark会把当前g切换至_Gpreempted状态，然后调用schedule函数 mcall(preemptPark) } else { // 通过preemptone函数发起的异步抢占会调用gopreempt_m函数，它最终也会调用schedule函数 mcall(gopreempt_m) } gp.asyncSafePoint = false } gopreempt_m() 文件位置：go1.19.3/src/runtime/proc.go。 3402 3403 3404 3405 3406 3407 func gopreempt_m(gp *g) { if trace.enabled { traceGoPreempt() } goschedImpl(gp) } goschedImpl() G加入全局队列，解除G与M的关系，再次发起调度循环。 文件位置：go1.19.3/src/runtime/proc.go。 3366 3367 3368 3369 3370 3371 3372 3373 3374 3375 3376 3377 3378 3379 3380 func goschedImpl(gp *g) { status := readgstatus(gp) // 获取G状态 if status\u0026^_Gscan != _Grunning { dumpgstatus(gp) throw(\"bad g status\") } // 修改G状态 _Grunnable casgstatus(gp, _Grunning, _Grunnable) dropg() // 解除绑定关系 lock(\u0026sched.lock) globrunqput(gp) // 加入全局链表 unlock(\u0026sched.lock) schedule() // 调度循环 } ",
  "wordCount" : "8774",
  "inLanguage": "zh",
  "image": "https://helium.github.io/favicon-32x32.png","datePublished": "2024-07-31T00:00:00Z",
  "dateModified": "2024-07-31T00:00:00Z",
  "author":[{
    "@type": "Person",
    "name": "helium"
  }],
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://helium.github.io/posts/golang/goroutine/retake/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Helium",
    "logo": {
      "@type": "ImageObject",
      "url": "https://helium.github.io/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://helium.github.io/" accesskey="h" title="Blog (Alt + H)">
                <img src="https://helium.github.io/helium.png" alt="" aria-label="logo"
                    height="35">Blog</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://helium.github.io/" title="主页">
                    <span>Home</span>
                </a>
            </li>
            <li>
                <a href="https://helium.github.io/posts" title="文章">
                    <span>Article</span>
                </a>
            </li>
            <li>
                <a href="https://helium.github.io/archives" title="时间轴">
                    <span>Archive</span>
                </a>
            </li>
            <li>
                <a href="https://helium.github.io/tags/" title="标签">
                    <span>Tag</span>
                </a>
            </li>
            <li>
                <a href="https://helium.github.io/search/" title="搜索 (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
            <li>
                <a href="https://helium.github.io/support" title="打赏">
                    <span>🫶Help</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">


<article class="post" autonumbering>
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://helium.github.io/">主页</a>&nbsp;»&nbsp;<a href="https://helium.github.io/posts/">Article</a>&nbsp;»&nbsp;<a href="https://helium.github.io/posts/golang/">Golang</a>&nbsp;»&nbsp;<a href="https://helium.github.io/posts/golang/goroutine/">第12章 Goroutine</a></div>
    <h1 class="post-title entry-hint-parent">
      被动让出调度
    </h1>
    <div class="post-description">
      💥本文章所有相关go代码参考自go 1.18&#43;版本
    </div>
    <div class="post-meta">










<span class="x-post-meta-item"><svg t="1720837714681" class="icon" viewBox="0 0 1084 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="7520" width="200" height="200"><path d="M123.47509 1023.984942a123.565437 123.565437 0 0 1-123.505206-123.32451V243.863302A123.565437 123.565437 0 0 1 123.47509 120.568908h171.630374V26.06529a26.050232 26.050232 0 0 1 52.070349 0v94.503618h377.592848V26.06529a26.050232 26.050232 0 0 1 52.100464 0v94.503618h183.797189A123.565437 123.565437 0 0 1 1084.171519 243.863302v656.79713A123.565437 123.565437 0 0 1 960.666314 1023.984942H123.47509z m-71.404741-123.32451A71.434857 71.434857 0 0 0 123.47509 971.974825h837.191224a71.434857 71.434857 0 0 0 71.404741-71.314393V442.326922l-946.361273-3.824716a25.598494 25.598494 0 0 1-5.84248-0.692665l-27.796953-6.444798v469.295689zM123.47509 172.579025a71.434857 71.434857 0 0 0-71.404741 71.284277v149.736133l27.796953-6.444797a26.080348 26.080348 0 0 1 5.902712-0.662549l946.301041 3.824716V243.863302a71.404741 71.404741 0 0 0-71.404741-71.284277h-180.183284l-6.173754 12.859479a26.200812 26.200812 0 0 1-23.490383 14.786895 26.261043 26.261043 0 0 1-23.520499-14.786895l-6.173754-12.859479H350.819834l-6.173754 12.859479a26.200812 26.200812 0 0 1-23.490383 14.786895 26.230928 26.230928 0 0 1-23.520499-14.786895l-6.173755-12.859479H123.47509z m156.150814 578.827128a26.050232 26.050232 0 0 1-26.050232-25.990001c0-14.335157 11.68496-26.020116 26.050232-26.020116h521.697312c14.365273 0 26.050232 11.68496 26.050233 26.020116a26.050232 26.050232 0 0 1-26.050233 25.990001H279.625904z" fill="#3D3F42" p-id="7521"></path></svg><span>2024-07-31</span></span>&nbsp;<span class="x-post-meta-item"><svg t="1720839329181" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="14106" width="200" height="200"><path d="M699.270662 190.485379c-0.411369 0-0.821715 0.011256-1.227967 0.032746H507.034407a23.041786 23.041786 0 0 0-1.221828-0.031723c-12.779048 0-23.140023 10.359952-23.140023 23.139 0 12.781094 10.360975 23.141046 23.140023 23.141046v0.032746h193.458083v-0.032746c12.780071 0 23.141046-10.359952 23.141047-23.141046 0-12.780071-10.360975-23.140023-23.141047-23.140023zM979.215516 724.005508c0-142.090159-115.186416-257.277598-257.277598-257.277598-72.245418 0-137.532353 29.777187-184.262654 77.725223l45.868677 31.474852c36.227086-33.873482 84.882226-54.617945 138.393977-54.617945 111.945605 0 202.696492 90.750887 202.696492 202.695468h-43.01263l70.331835 104.289228 70.331835-104.289228H979.215516z" fill="" p-id="14107"></path><path d="M748.885664 588.843132c0-14.881942-12.06785-26.945699-26.947746-26.945698-14.883989 0-26.947745 12.063757-26.947745 26.945698v135.164423c0 14.879895 12.063757 26.945699 26.947745 26.945699h107.786889c14.881942 0 26.945699-12.063757 26.945698-26.945699s-12.063757-26.945699-26.945698-26.945699h-80.839143V588.843132zM721.937918 926.702c-111.947651 0-202.696492-90.74884-202.696492-202.696492 0-0.144286 0.004093-0.285502 0.004094-0.429788h43.004443l-70.330812-104.289228-70.331835 104.289228h43.075051c0 0.144286-0.00307 0.285502-0.00307 0.429788 0 142.091182 115.187439 257.279644 257.278621 257.279645 72.241324 0 137.530306-29.77821 184.260607-77.727269l-45.86663-31.474852c-36.227086 33.873482-84.884272 54.618968-138.393977 54.618968zM694.633039 423.38066c-1.354857-11.487635-11.120268-20.400632-22.972201-20.400632H206.362486c-12.780071 0-23.140023 10.359952-23.140023 23.138999 0 12.781094 10.359952 23.141046 23.140023 23.141047H596.949252c30.209022-13.81668 63.104223-22.76754 97.683787-25.879414zM438.548616 623.143333H206.362486c-12.780071 0-23.140023 10.358929-23.140023 23.140023 0 12.780071 10.359952 23.140023 23.140023 23.140023h219.956598a298.463626 298.463626 0 0 1 12.229532-46.280046zM506.934123 513.062192H206.362486c-12.780071 0-23.140023 10.359952-23.140023 23.139 0 12.781094 10.359952 23.140023 23.140023 23.140023H469.936487a302.241672 302.241672 0 0 1 36.997636-46.279023z" fill="" p-id="14108"></path><path d="M442.765661 835.277778a298.531164 298.531164 0 0 1-14.365173-46.150087H146.542052v-0.065491c-33.036417 0-59.81941-26.78197-59.81941-59.819411V329.36031h704.907545v100.905154a298.561863 298.561863 0 0 1 46.150086 14.996552V194.619536h-0.162706c0-53.422723-43.307342-96.728018-96.730065-96.728018h-68.89409V84.418668c0-33.037441-26.782993-59.81941-59.81941-59.81941v-0.361227h-18.87079v0.032745c-33.038464 0-59.820434 26.78197-59.820433 59.819411 0 0.109494 0.008186 0.218988 0.008186 0.328481h-0.339738v13.47285H345.203648V84.418668c0-33.037441-26.782993-59.81941-59.819411-59.81941v-0.361227h-18.872836v0.032745c-33.036417 0-59.81941 26.78197-59.81941 59.819411 0 0.109494 0.007163 0.218988 0.008186 0.328481h-0.339737v13.47285h-69.189826c-53.4217 0-96.729042 43.306318-96.729041 96.728018 0 1.701758 0.045025 3.39226 0.132006 5.071505v533.785166a98.051153 98.051153 0 0 0-0.132006 5.071506c0 53.4217 43.307342 96.728018 96.729041 96.728018v0.001023h305.595047zM86.723665 204.056466c0-33.037441 26.782993-59.81941 59.819411-59.819411 0.044002 0 0.086981 0.00307 0.130983 0.00307v-0.068561h105.968473V94.874811h0.032746a22.807449 22.807449 0 0 1-0.032746-1.215688c0-12.779048 10.360975-23.140023 23.140023-23.140023s23.140023 10.360975 23.140023 23.140023c0 0.408299-0.010233 0.812505-0.031722 1.215688h0.031722v49.297776h280.508696V94.874811h0.032745a22.807449 22.807449 0 0 1-0.032745-1.215688c0-12.779048 10.361999-23.140023 23.140023-23.140023 12.780071 0 23.141046 10.360975 23.141046 23.140023 0 0.408299-0.011256 0.812505-0.032746 1.215688h0.032746v49.297776h106.10048v0.065492c33.035394 0 59.818387 26.780947 59.818387 59.81941h0.130983V283.080264H86.723665v-79.023798z" fill="" p-id="14109"></path></svg><span>2024-07-31</span></span>&nbsp;<span class="x-post-meta-item"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2" fill="none"
     stroke-linecap="round" stroke-linejoin="round" class="feather feather-file-text" style="user-select: text;">
    <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z" style="user-select: text;"></path>
    <polyline points="14 2 14 8 20 8" style="user-select: text;"></polyline>
    <line x1="16" y1="13" x2="8" y2="13" style="user-select: text;"></line>
    <line x1="16" y1="17" x2="8" y2="17" style="user-select: text;"></line>
    <polyline points="10 9 9 9 8 9" style="user-select: text;"></polyline>
</svg><span>8774字</span></span>&nbsp;<span class="x-post-meta-item"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2" fill="none"
     stroke-linecap="round" stroke-linejoin="round">
    <path stroke="none" d="M0 0h24v24H0z" fill="none"></path>
    <circle cx="12" cy="12" r="9"></circle>
    <polyline points="12 7 12 12 15 15"></polyline>
</svg><span>42分钟</span></span>&nbsp;<span class="x-post-meta-item"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2" fill="none"
     stroke-linecap="round" stroke-linejoin="round">
    <path stroke="none" d="M0 0h24v24H0z" fill="none"></path>
    <circle cx="12" cy="7" r="4"></circle>
    <path d="M6 21v-2a4 4 0 0 1 4 -4h4a4 4 0 0 1 4 4v2"></path>
</svg><span>helium</span></span>
      <span class="x-post-meta-item">
        &nbsp;<svg t="1720840393161" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="18680" width="200" height="200"><path d="M995.125144 559.61812l-415.998603-415.998602A52.986489 52.986489 0 0 0 541.413335 127.99957H338.847348c-3.166656-26.559911-9.286635-51.046495-17.999939-71.333094C299.734146 7.333309 271.154242 0 256.00096 0c-13.939953 0-40.439864 6.339979-61.259794 48.806503-10.473298 21.366595-17.946606 48.966502-21.573261 79.193067H53.334974a53.393154 53.393154 0 0 0-53.333154 53.333154v360.078791a52.986489 52.986489 0 0 0 15.619948 37.713206l415.998602 415.998603a53.333154 53.333154 0 0 0 75.426413 0l26.286579-26.293245 26.286578 26.293245a53.426487 53.426487 0 0 0 16.719944 11.333295 21.333262 21.333262 0 0 0 36.079879 11.293295l382.705381-382.705381a53.399821 53.399821 0 0 0 0-75.426413z m-762.070774-491.998347C241.494342 50.373164 250.667645 42.666523 256.00096 42.666523c5.99998 0 16.573278 9.639968 25.646581 30.806564 6.493312 15.159949 11.333295 33.999886 14.146619 54.526483H216.16776c3.206656-23.419921 9.013303-44.359851 16.88661-60.41313z m243.819181 897.330319a10.666631 10.666631 0 0 1-15.079949 0l-415.998603-415.998603A10.573298 10.573298 0 0 1 42.668343 541.411515V181.332724a10.666631 10.666631 0 0 1 10.666631-10.666631h245.332509c0 47.853173-10.373298 92.15969-27.066575 115.632945-5.926647 8.326639-16.566611 14.186619-22.306592 16.113279C204.041135 314.752276 170.667913 356.218803 170.667913 405.331972c0 58.813136 47.853173 106.666308 106.666309 106.666308s106.666308-47.853173 106.666308-106.666308c0-47.086508-30.666564-87.139707-73.079754-101.246327C330.060711 272.705751 341.334007 223.692582 341.334007 170.666093h72.079758a10.573298 10.573298 0 0 1 7.539974 3.126656l415.998603 415.998603a10.666631 10.666631 0 0 1 0 15.079949zM341.334007 405.331972a63.999785 63.999785 0 1 1-63.999785-63.999785 64.073118 64.073118 0 0 1 63.999785 63.999785z m263.539114 559.61812a10.666631 10.666631 0 0 1-15.079949 0L563.499927 938.663513l303.625647-303.61898a53.399821 53.399821 0 0 0 0-75.426413L478.16688 170.666093h63.246455a10.573298 10.573298 0 0 1 7.539974 3.126656l415.998603 415.998603c0.239999 0.239999 0.466665 0.486665 0.666664 0.746664l0.086667 0.106666a10.666631 10.666631 0 0 1 0 13.373289l-0.086667 0.106666c-0.213333 0.259999-0.439999 0.506665-0.666664 0.746664z" fill="#5C5C66" p-id="18681"></path></svg>
        <ul class="post-tags-meta" style="display: inline-block;font-size: 14px;">
            <a href="https://helium.github.io/tags/golang/" target="_blank" rel="noopener">Golang</a>
            <a href="https://helium.github.io/tags/goroutine/" target="_blank" rel="noopener">Goroutine</a>
        </ul>
      </span>
      
      <span id="busuanzi_container_page_pv" class="x-post-meta-item">
        &nbsp;<svg t="1720844685710" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="27237" width="200" height="200"><path d="M739.754667 574.08c-121.386667 45.610667-208.469333 169.813333-208.64 316.16 0 33.408 4.693333 65.493333 13.141333 95.914667H94.122667c-26.453333-43.52-41.685333-91.946667-41.685334-143.189334 0-185.173333 192.896-335.104 430.805334-335.104 96.256 0 184.832 24.746667 256.512 66.218667z m-280.490667-114.986667a214.869333 214.869333 0 0 1-214.869333-215.04A215.04 215.04 0 0 1 459.264 28.842667a215.04 215.04 0 0 1 215.04 215.210666 215.04 215.04 0 0 1-215.04 215.04zM974.506667 641.28c9.856 0 17.834667 7.466667 17.834666 16.64v59.989333c-0.341333 8.789333-7.850667 15.786667-17.28 16.085334-9.856 0.341333-18.176-6.826667-18.517333-16.085334v-20.053333l-99.114667 91.093333-0.256 0.256a18.474667 18.474667 0 0 1-14.848 4.352h-0.768a18.176 18.176 0 0 1-9.344-4.608l-0.938666-0.981333-85.930667-80.042667-123.562667 115.072a18.773333 18.773333 0 0 1-25.216 0 15.786667 15.786667 0 0 1 0-23.466666l136.149334-126.848 0.725333-0.597334a18.645333 18.645333 0 0 1 24.362667 0.512l87.253333 81.237334 86.058667-79.232h-21.248c-9.386667-0.298667-16.938667-7.338667-17.28-16.085334-0.341333-9.173333 7.381333-16.896 17.28-17.237333h64.64z m-367.146667 240h48.128c8.874667 0 16.042667 7.168 16.042667 16.042667v72.192a16.042667 16.042667 0 0 1-16.042667 16.042666h-48.128a16.042667 16.042667 0 0 1-16.042667-16.042666v-72.192c0-8.874667 7.210667-16.042667 16.042667-16.042667z m110.805333-106.666667h48.128c8.874667 0 16.042667 7.168 16.042667 16.042667v178.858667a16.042667 16.042667 0 0 1-16.042667 16.042666h-48.128a16.042667 16.042667 0 0 1-16.042666-16.042666v-178.858667c0-8.874667 7.168-16.042667 16.042666-16.042667z m106.538667 80h48.128c8.874667 0 16.042667 7.168 16.042667 16.042667v99.413333a16.042667 16.042667 0 0 1-16.042667 16.042667H824.746667a16.042667 16.042667 0 0 1-16.042667-16.042667v-99.413333c0-8.874667 7.168-16.042667 16.042667-16.042667z m110.165333-80h48.128c8.874667 0 16.042667 7.168 16.042667 16.042667v179.413333a16.042667 16.042667 0 0 1-16.042667 16.042667h-48.128a16.042667 16.042667 0 0 1-16.042666-16.042667v-179.413333c0-8.874667 7.210667-16.042667 16.042666-16.042667z" fill="#999999" p-id="27238"></path></svg>
        <span id="busuanzi_value_page_pv"></span>
      </span>

</div>
  </header> <aside id="toc-container" class="toc-container wide">
    <div class="toc">
        <details  open>
            <summary accesskey="c" title="(Alt + C)">
                <span class="details">目录</span>
            </summary>

            <div class="inner"><ul>
                    <li>
                        <a href="#%e6%8a%a2%e5%8d%a0%e6%a0%87%e8%af%86" aria-label="抢占标识">抢占标识</a><ul>
                            
                    <li>
                        <a href="#retake" aria-label="retake()">retake()</a><ul>
                            
                    <li>
                        <a href="#incidlelocked" aria-label="incidlelocked()">incidlelocked()</a></li></ul>
                    </li>
                    <li>
                        <a href="#preemptone" aria-label="preemptone()">preemptone()</a></li>
                    <li>
                        <a href="#handoffp" aria-label="handoffp()">handoffp()</a></li></ul>
                    </li>
                    <li>
                        <a href="#%e5%93%8d%e5%ba%94%e6%8a%a2%e5%8d%a0%e8%af%b7%e6%b1%82" aria-label="响应抢占请求">响应抢占请求</a><ul>
                            
                    <li>
                        <a href="#morestack_noctxt" aria-label="morestack_noctxt()">morestack_noctxt()</a></li>
                    <li>
                        <a href="#morestack" aria-label="morestack()">morestack()</a></li>
                    <li>
                        <a href="#newstack" aria-label="newstack()">newstack()</a><ul>
                            
                    <li>
                        <a href="#canpreemptm" aria-label="canPreemptM">canPreemptM</a></li>
                    <li>
                        <a href="#gopreempt_m" aria-label="gopreempt_m">gopreempt_m</a></li></ul>
                    </li></ul>
                    </li>
                    <li>
                        <a href="#%e7%b3%bb%e7%bb%9f%e8%b0%83%e7%94%a8%e5%89%8d%e5%90%8e" aria-label="系统调用前后">系统调用前后</a><ul>
                            
                    <li>
                        <a href="#%e7%b3%bb%e7%bb%9f%e8%b0%83%e7%94%a8" aria-label="系统调用">系统调用</a><ul>
                            
                    <li>
                        <a href="#syscall6" aria-label="Syscall6()">Syscall6()</a></li></ul>
                    </li>
                    <li>
                        <a href="#%e7%b3%bb%e7%bb%9f%e8%b0%83%e7%94%a8%e5%89%8d" aria-label="系统调用前">系统调用前</a><ul>
                            
                    <li>
                        <a href="#entersyscall" aria-label="entersyscall()">entersyscall()</a></li>
                    <li>
                        <a href="#reentersyscall" aria-label="reentersyscall()">reentersyscall()</a></li>
                    <li>
                        <a href="#save" aria-label="save()">save()</a></li></ul>
                    </li>
                    <li>
                        <a href="#%e7%b3%bb%e7%bb%9f%e8%b0%83%e7%94%a8%e5%90%8e" aria-label="系统调用后">系统调用后</a><ul>
                            
                    <li>
                        <a href="#exitsyscall" aria-label="exitsyscall()">exitsyscall()</a></li>
                    <li>
                        <a href="#exitsyscallfast" aria-label="exitsyscallfast()">exitsyscallfast()</a></li>
                    <li>
                        <a href="#exitsyscallfast_pidle" aria-label="exitsyscallfast_pidle()">exitsyscallfast_pidle()</a></li>
                    <li>
                        <a href="#exitsyscall0" aria-label="exitsyscall0()">exitsyscall0()</a></li></ul>
                    </li></ul>
                    </li>
                    <li>
                        <a href="#%e4%bf%a1%e5%8f%b7%e5%bd%a2%e5%bc%8f%e5%8f%91%e9%80%81%e6%8a%a2%e5%8d%a0" aria-label="信号形式发送抢占">信号形式发送抢占</a><ul>
                            
                    <li>
                        <a href="#preemptm" aria-label="preemptM()">preemptM()</a></li>
                    <li>
                        <a href="#signalm" aria-label="signalM()">signalM()</a></li>
                    <li>
                        <a href="#tgkill" aria-label="tgkill()">tgkill()</a></li></ul>
                    </li>
                    <li>
                        <a href="#%e5%85%a8%e5%b1%80%e4%bf%a1%e5%8f%b7%e5%a4%84%e7%90%86%e6%b3%a8%e5%86%8c" aria-label="全局信号处理注册">全局信号处理注册</a><ul>
                            
                    <li>
                        <a href="#mstart1" aria-label="mstart1()">mstart1()</a></li>
                    <li>
                        <a href="#mstartm0" aria-label="mstartm0()">mstartm0()</a></li>
                    <li>
                        <a href="#initsig" aria-label="initsig()">initsig()</a></li>
                    <li>
                        <a href="#setsig" aria-label="setsig()">setsig()</a></li></ul>
                    </li>
                    <li>
                        <a href="#%e4%bf%a1%e5%8f%b7%e5%bd%a2%e5%bc%8f%e5%93%8d%e5%ba%94%e6%8a%a2%e5%8d%a0" aria-label="信号形式响应抢占">信号形式响应抢占</a><ul>
                            
                    <li>
                        <a href="#sigtramp" aria-label="sigtramp()">sigtramp()</a></li>
                    <li>
                        <a href="#sigtrampgo" aria-label="sigtrampgo()">sigtrampgo()</a></li>
                    <li>
                        <a href="#sighander" aria-label="sighander()">sighander()</a></li>
                    <li>
                        <a href="#dosigpreempt" aria-label="doSigPreempt()">doSigPreempt()</a></li>
                    <li>
                        <a href="#wantasyncpreempt" aria-label="wantAsyncPreempt()">wantAsyncPreempt()</a></li>
                    <li>
                        <a href="#isasyncsafepoint" aria-label="isAsyncSafePoint()">isAsyncSafePoint()</a></li>
                    <li>
                        <a href="#pushcall" aria-label="pushCall()">pushCall()</a></li>
                    <li>
                        <a href="#asyncpreempt" aria-label="asyncPreempt()">asyncPreempt()</a></li>
                    <li>
                        <a href="#asyncpreempt2" aria-label="asyncPreempt2()">asyncPreempt2()</a></li>
                    <li>
                        <a href="#gopreempt_m-1" aria-label="gopreempt_m()">gopreempt_m()</a></li>
                    <li>
                        <a href="#goschedimpl" aria-label="goschedImpl()">goschedImpl()</a>
                    </li>
                </ul>
                </li>
                </ul>
            </div>
        </details>
    </div>
</aside>
<script>
    let activeElement;
    let elements;
    window.addEventListener('DOMContentLoaded', function (event) {
        checkTocPosition();

        elements = document.querySelectorAll('h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]');
         
         activeElement = elements[0];
         const id = encodeURI(activeElement.getAttribute('id')).toLowerCase();
         document.querySelector(`.inner ul li a[href="#${id}"]`).classList.add('active');
     }, false);

    window.addEventListener('resize', function(event) {
        checkTocPosition();
    }, false);

    window.addEventListener('scroll', () => {
        
        activeElement = Array.from(elements).find((element) => {
            if ((getOffsetTop(element) - window.pageYOffset) > 0 && 
                (getOffsetTop(element) - window.pageYOffset) < window.innerHeight/2) {
                return element;
            }
        }) || activeElement

        elements.forEach(element => {
             const id = encodeURI(element.getAttribute('id')).toLowerCase();
             if (element === activeElement){
                 document.querySelector(`.inner ul li a[href="#${id}"]`).classList.add('active');
             } else {
                 document.querySelector(`.inner ul li a[href="#${id}"]`).classList.remove('active');
             }
         })
     }, false);

    const main = parseInt(getComputedStyle(document.body).getPropertyValue('--article-width'), 10);
    const toc = parseInt(getComputedStyle(document.body).getPropertyValue('--toc-width'), 10);
    const gap = parseInt(getComputedStyle(document.body).getPropertyValue('--gap'), 10);

    function checkTocPosition() {
        const width = document.body.scrollWidth;

        if (width - main - (toc * 2) - (gap * 4) > 0) {
            document.getElementById("toc-container").classList.add("wide");
        } else {
            document.getElementById("toc-container").classList.remove("wide");
        }
    }

    function getOffsetTop(element) {
        if (!element.getClientRects().length) {
            return 0;
        }
        let rect = element.getBoundingClientRect();
        let win = element.ownerDocument.defaultView;
        return rect.top + win.pageYOffset;   
    }
</script>
  <div class="post-content"><ol>
<li>抢占调度（goroutine因运行时间过长）。
<ul>
<li><strong>抢占调度</strong>：因<code>goroutine</code>运行时间过长而发生的。</li>
<li><code>goroutine</code>因读写<code>channel</code>等阻塞而导致的<strong>被动调度</strong>，以及通过调用<code>Gosched()</code>函数发起的<strong>主动调度</strong>。</li>
</ul>
</li>
</ol>
<h2 id="抢占标识">抢占标识<a hidden class="anchor" aria-hidden="true" href="#抢占标识">#</a></h2>
<h3 id="retake">retake()<a hidden class="anchor" aria-hidden="true" href="#retake">#</a></h3>
<ol>
<li><strong>_Prunning</strong>，表示对应的<code>goroutine</code>正在运行，如果其运行时间超过了10毫秒则对需要抢占。</li>
<li><strong>_Psyscall</strong>，表示对应的<code>goroutine</code>正在内核执行系统调用，此时需要根据多个条件来判断是否需要抢占。</li>
<li>该函数<strong>只在</strong><code>sysmon</code>监控线程中被调用。</li>
<li>参数<code>now int64</code>：当前时间。</li>
<li>返回值<code>uint32</code>：处于系统调用中需要抢占<code>P</code>的数量。</li>
<li>文件位置：go1.19.3/src/runtime/proc.go。</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// forcePreemptNS is the time slice given to a G before it is
</span></span></span><span class="line"><span class="cl"><span class="c1">// preempted.
</span></span></span><span class="line"><span class="cl"><span class="c1">// 
</span></span></span><span class="line"><span class="cl"><span class="c1">// forcePreemptNS 是在G被抢占之前给它的时间片。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">const</span> <span class="nx">forcePreemptNS</span> <span class="p">=</span> <span class="mi">10</span> <span class="o">*</span> <span class="mi">1000</span> <span class="o">*</span> <span class="mi">1000</span> <span class="c1">// 10ms
</span></span></span></code></pre></div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">5285
</span><span class="lnt">5286
</span><span class="lnt">5287
</span><span class="lnt">5288
</span><span class="lnt">5289
</span><span class="lnt">5290
</span><span class="lnt">5291
</span><span class="lnt">5292
</span><span class="lnt">5293
</span><span class="lnt">5294
</span><span class="lnt">5295
</span><span class="lnt">5296
</span><span class="lnt">5297
</span><span class="lnt">5298
</span><span class="lnt">5299
</span><span class="lnt">5300
</span><span class="lnt">5301
</span><span class="lnt">5302
</span><span class="lnt">5303
</span><span class="lnt">5304
</span><span class="lnt">5305
</span><span class="lnt">5306
</span><span class="lnt">5307
</span><span class="lnt">5308
</span><span class="lnt">5309
</span><span class="lnt">5310
</span><span class="lnt">5311
</span><span class="lnt">5312
</span><span class="lnt">5313
</span><span class="lnt">5314
</span><span class="lnt">5315
</span><span class="lnt">5316
</span><span class="lnt">5317
</span><span class="lnt">5318
</span><span class="lnt">5319
</span><span class="lnt">5320
</span><span class="lnt">5321
</span><span class="lnt">5322
</span><span class="lnt">5323
</span><span class="lnt">5324
</span><span class="lnt">5325
</span><span class="lnt">5326
</span><span class="lnt">5327
</span><span class="lnt">5328
</span><span class="lnt">5329
</span><span class="lnt">5330
</span><span class="lnt">5331
</span><span class="lnt">5332
</span><span class="lnt">5333
</span><span class="lnt">5334
</span><span class="lnt">5335
</span><span class="lnt">5336
</span><span class="lnt">5337
</span><span class="lnt">5338
</span><span class="lnt">5339
</span><span class="lnt">5340
</span><span class="lnt">5341
</span><span class="lnt">5342
</span><span class="lnt">5343
</span><span class="lnt">5344
</span><span class="lnt">5345
</span><span class="lnt">5346
</span><span class="lnt">5347
</span><span class="lnt">5348
</span><span class="lnt">5349
</span><span class="lnt">5350
</span><span class="lnt">5351
</span><span class="lnt">5352
</span><span class="lnt">5353
</span><span class="lnt">5354
</span><span class="lnt">5355
</span><span class="lnt">5356
</span><span class="lnt">5357
</span><span class="lnt">5358
</span><span class="lnt">5359
</span><span class="lnt">5360
</span><span class="lnt">5361
</span><span class="lnt">5362
</span><span class="lnt">5363
</span><span class="lnt">5364
</span><span class="lnt">5365
</span><span class="lnt">5366
</span><span class="lnt">5367
</span><span class="lnt">5368
</span><span class="lnt">5369
</span><span class="lnt">5370
</span><span class="lnt">5371
</span><span class="lnt">5372
</span><span class="lnt">5373
</span><span class="lnt">5374
</span><span class="lnt">5375
</span><span class="lnt">5376
</span><span class="lnt">5377
</span><span class="lnt">5378
</span><span class="lnt">5379
</span><span class="lnt">5380
</span><span class="lnt">5381
</span><span class="lnt">5382
</span><span class="lnt">5383
</span><span class="lnt">5384
</span><span class="lnt">5385
</span><span class="lnt">5386
</span><span class="lnt">5387
</span><span class="lnt">5388
</span><span class="lnt">5389
</span><span class="lnt">5390
</span><span class="lnt">5391
</span><span class="lnt">5392
</span><span class="lnt">5393
</span><span class="lnt">5394
</span><span class="lnt">5395
</span><span class="lnt">5396
</span><span class="lnt">5397
</span><span class="lnt">5398
</span><span class="lnt">5399
</span><span class="lnt">5400
</span><span class="lnt">5401
</span><span class="lnt">5402
</span><span class="lnt">5403
</span><span class="lnt">5404
</span><span class="lnt">5405
</span><span class="lnt">5406
</span><span class="lnt">5407
</span><span class="lnt">5408
</span><span class="lnt">5409
</span><span class="lnt">5410
</span><span class="lnt">5411
</span><span class="lnt">5412
</span><span class="lnt">5413
</span><span class="lnt">5414
</span><span class="lnt">5415
</span><span class="lnt">5416
</span><span class="lnt">5417
</span><span class="lnt">5418
</span><span class="lnt">5419
</span><span class="lnt">5420
</span><span class="lnt">5421
</span><span class="lnt">5422
</span><span class="lnt">5423
</span><span class="lnt">5424
</span><span class="lnt">5425
</span><span class="lnt">5426
</span><span class="lnt">5427
</span><span class="lnt">5428
</span><span class="lnt">5429
</span><span class="lnt">5430
</span><span class="lnt">5431
</span><span class="lnt">5432
</span><span class="lnt">5433
</span><span class="lnt">5434
</span><span class="lnt">5435
</span><span class="lnt">5436
</span><span class="lnt">5437
</span><span class="lnt">5438
</span><span class="lnt">5439
</span><span class="lnt">5440
</span><span class="lnt">5441
</span><span class="lnt">5442
</span><span class="lnt">5443
</span><span class="lnt">5444
</span><span class="lnt">5445
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// 检查所有的P查看是否存在运行时间太长的G需要设置抢占请求。
</span></span></span><span class="line"><span class="cl"><span class="c1">//  1. goroutine运行时间超过10ms时需要抢占。
</span></span></span><span class="line"><span class="cl"><span class="c1">//  2. goroutine陷入系统调用，运行时间超过10ms或在第二轮来是sysmon系统调用还没返回时。
</span></span></span><span class="line"><span class="cl"><span class="c1">// 陷入系统调用而抢占P的情况：
</span></span></span><span class="line"><span class="cl"><span class="c1">//  1. 运行时间超过10ms，可能一开始就陷入系统调用，或中途陷入系统调用。不论那种情况都应该抢占。
</span></span></span><span class="line"><span class="cl"><span class="c1">//  2. 运行时间没到10ms，但是两轮sysmon了还是在系统调用中，需要抢占P。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">retake</span><span class="p">(</span><span class="nx">now</span> <span class="kt">int64</span><span class="p">)</span> <span class="kt">uint32</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">n</span> <span class="o">:=</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c1">// 1) 锁住 allp，现在需要遍历所有的P查看是否存在运行时间过长而需要抢占的G。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    
</span></span><span class="line"><span class="cl">    <span class="c1">// Prevent allp slice changes. This lock will be completely
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// uncontended unless we&#39;re already stopping the world.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 防止 allp 切片更改。 除非我们已经STW，否则这把锁将是完全无人争夺的
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">allpLock</span><span class="p">)</span> <span class="c1">// allp加锁
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    
</span></span><span class="line"><span class="cl">    <span class="c1">// 2) 遍历所有的P，根据运行时间是否设置抢占标志。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    
</span></span><span class="line"><span class="cl">    <span class="c1">// We can&#39;t use a range loop over allp because we may
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// temporarily drop the allpLock. Hence, we need to re-fetch
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// allp each time around the loop.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 我们不能使用range来遍历allp，因为我们可能会暂时放弃allpLock锁（会暂时解锁）。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 因此，我们需要在每次循环中重新获取allp。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// range会拷贝，因此增长或缩小了allp不会实时变化。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">allp</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span> <span class="c1">// 遍历所有的P
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">_p_</span> <span class="o">:=</span> <span class="nx">allp</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 2.1) 未初始化的P跳过。可能正在增长P。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="nx">_p_</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// This can happen if procresize has grown
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// allp but not yet created new Ps.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// 如果procresize已经增长了所有p，但还没有创建新的p，则可能发生这种情况。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="k">continue</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">        <span class="c1">// 2.2) 判断是否运行时间过长
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// _p_.sysmontick用于sysmon线程记录被监控p的系统调用时间和运行时间
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">//  type sysmontick struct {
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">//      schedtick   uint32      // 调度器调度次数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">//      schedwhen   int64       // 上次调度时间
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">//      syscalltick uint32      // 系统调用次数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">//      syscallwhen int64       // 上次调度时间
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">//  }
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">pd</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">_p_</span><span class="p">.</span><span class="nx">sysmontick</span>           <span class="c1">// 与sysmon线程相关
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        
</span></span><span class="line"><span class="cl">        <span class="c1">// _Prunning：对应的goroutine正在运行
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// _Psyscall：对应的goroutine正在内核执行系统调用
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">s</span> <span class="o">:=</span> <span class="nx">_p_</span><span class="p">.</span><span class="nx">status</span> <span class="c1">// P当前所处状态 _Prunning，_Psyscall
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        
</span></span><span class="line"><span class="cl">        <span class="c1">// 标记当前P是否已设置抢占请求
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// false.未设置 true.已设置
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">sysretake</span> <span class="o">:=</span> <span class="kc">false</span> 
</span></span><span class="line"><span class="cl">        <span class="c1">// 2.3) 先判断 schedtick 和 schedwhen 时间是否运行时间过长。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// G的运行时间是包括系统调用的时间的。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="nx">s</span> <span class="o">==</span> <span class="nx">_Prunning</span> <span class="o">||</span> <span class="nx">s</span> <span class="o">==</span> <span class="nx">_Psyscall</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// Preempt G if it&#39;s running for too long.	
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// 如果G运行太久，就抢占它。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            
</span></span><span class="line"><span class="cl">            <span class="c1">// _p_.schedtick调度次数，该值是在P上的，记录当前的调度次数。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// 注意区别sysmontick上的schedtick
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="nx">t</span> <span class="o">:=</span> <span class="nb">int64</span><span class="p">(</span><span class="nx">_p_</span><span class="p">.</span><span class="nx">schedtick</span><span class="p">)</span> <span class="c1">// _p_.schedtick：每发生一次调度，调度器++该值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            
</span></span><span class="line"><span class="cl">            <span class="c1">// pd.schedtick == t说明(pd.schedwhen～now)这段时间未发生过调度（这种情况也就是我们要处理的抢占情况），
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// 所以这段时间是同一个goroutine一直在运行，下面检查一直运行是否超过了10毫秒，否则则是发生过调度
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="k">if</span> <span class="nb">int64</span><span class="p">(</span><span class="nx">pd</span><span class="p">.</span><span class="nx">schedtick</span><span class="p">)</span> <span class="o">!=</span> <span class="nx">t</span> <span class="p">{</span> <span class="c1">// 如果不相等说明是一次新的调度
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="c1">// 监控线程监控到一次新的调度，所以重置跟sysmon相关的schedtick和schedwhen变量
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="c1">// 2.4) 检测到下次调度，更新调度时间
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="nx">pd</span><span class="p">.</span><span class="nx">schedtick</span> <span class="p">=</span> <span class="nb">uint32</span><span class="p">(</span><span class="nx">t</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                <span class="nx">pd</span><span class="p">.</span><span class="nx">schedwhen</span> <span class="p">=</span> <span class="nx">now</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nx">pd</span><span class="p">.</span><span class="nx">schedwhen</span><span class="o">+</span><span class="nx">forcePreemptNS</span> <span class="o">&lt;=</span> <span class="nx">now</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="c1">// 2.4) 本次调度已超过 10ms，设置抢占标识。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="c1">// 从某goroutine第一次被sysmon线程监控到正在运行一直运行到现在超过了10毫秒
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="c1">// 抢占用户代码的goroutine时是需要判断是否能抢占的条件的。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="nf">preemptone</span><span class="p">(</span><span class="nx">_p_</span><span class="p">)</span> <span class="c1">// 设置抢占请求，非系统调用时在这里后就结束了。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                
</span></span><span class="line"><span class="cl">                <span class="c1">// In case of syscall, preemptone() doesn&#39;t
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="c1">// work, because there is no M wired to P.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="c1">// 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="c1">// 在系统调用的情况下，preemptone()不起作用，因为M没有连接到P。此时已经陷入到系统调度中，不会响应请求。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="nx">sysretake</span> <span class="p">=</span> <span class="kc">true</span> <span class="c1">// 已标记了抢占
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 2.4) 本地调度运行时间还未到10ms。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">        <span class="c1">// 2.5) P处于系统调用之中时。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="nx">s</span> <span class="o">==</span> <span class="nx">_Psyscall</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// Retake P from syscall if it&#39;s there for more than 1 sysmon tick (at least 20us).
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// 如果P存在超过1个sysmon tick(至少20us)，则从sycall中重新取P。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// _p_.syscalltick用于记录系统调用的次数，主要由工作线程在完成系统调用之后++
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="nx">t</span> <span class="o">:=</span> <span class="nb">int64</span><span class="p">(</span><span class="nx">_p_</span><span class="p">.</span><span class="nx">syscalltick</span><span class="p">)</span>	
</span></span><span class="line"><span class="cl">            <span class="c1">// sysretake = false：前面没有设置抢占标志。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">//  1. 本轮调度G还没到达10ms。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">//  2. 新的一轮调度，已经重置了。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// int64(pd.syscalltick) != t：新的一轮系统调度了。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="k">if</span> <span class="p">!</span><span class="nx">sysretake</span> <span class="o">&amp;&amp;</span> <span class="nb">int64</span><span class="p">(</span><span class="nx">pd</span><span class="p">.</span><span class="nx">syscalltick</span><span class="p">)</span> <span class="o">!=</span> <span class="nx">t</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="nx">pd</span><span class="p">.</span><span class="nx">syscalltick</span> <span class="p">=</span> <span class="nb">uint32</span><span class="p">(</span><span class="nx">t</span><span class="p">)</span> <span class="c1">// update syscalltick
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="nx">pd</span><span class="p">.</span><span class="nx">syscallwhen</span> <span class="p">=</span> <span class="nx">now</span> <span class="c1">// update syscallwhen
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="k">continue</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">            
</span></span><span class="line"><span class="cl">            <span class="c1">// 2.6) sysretake == true || (sysretake == false &amp;&amp; int64(pd.syscalltick) == t)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">//  1. sysretake == true：前面已经设置了抢占请求，G运行时间超过了10ms，现在处于系统调用中。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">//  2. (sysretake == false &amp;&amp; int64(pd.syscalltick) == t)：
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">//      goroutine没有超过10ms，但是监控先到第二轮了，现在处于系统调用中。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">//      因此这种情况取决于监控线程的调度时间间隔。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            
</span></span><span class="line"><span class="cl">            <span class="c1">// On the one hand we don&#39;t want to retake Ps if there is no other work to do,
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// but on the other hand we want to retake them eventually
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// because they can prevent the sysmon thread from deep sleep.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// 一方面我们不想在没有其他工作的情况下重新获取 Ps，
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// 另一方面我们希望最终重新获取它们，因为它们可以防止 sysmon 线程深度睡眠。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// 只要满足下面三个条件中的任意一个，则抢占该p，否则不抢占
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">//  1. p的运行队列里面有等待运行的goroutine。（有需要运行的goroutine，需要抢占P）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">//  2. 没有无所事事的p，也就是没有自旋的P或空闲的P。（系统很忙，需要抢占P）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">//  3. 从上一次监控线程观察到p对应的m处于系统调用之中到现在已经超过10了毫秒。（系统调用时间太长，需要抢占P）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="k">if</span> <span class="nf">runqempty</span><span class="p">(</span><span class="nx">_p_</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Load</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">nmspinning</span><span class="p">)</span><span class="o">+</span><span class="nx">atomic</span><span class="p">.</span><span class="nf">Load</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">npidle</span><span class="p">)</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">pd</span><span class="p">.</span><span class="nx">syscallwhen</span><span class="o">+</span><span class="mi">10</span><span class="o">*</span><span class="mi">1000</span><span class="o">*</span><span class="mi">1000</span> <span class="p">&gt;</span> <span class="nx">now</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                  <span class="c1">// 不需要抢占：_p_本地队列为空 &amp;&amp; 存在自旋或空闲的P（系统不忙） &amp;&amp; 系统调用时间还没有超过了10ms
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                  <span class="k">continue</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">            
</span></span><span class="line"><span class="cl">            <span class="c1">// Drop allpLock so we can take sched.lock.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// 这里是前面不能有for range的原因，解锁这段时间可能allp会发生变化。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">allpLock</span><span class="p">)</span>   <span class="c1">// 解锁 allpLock
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            
</span></span><span class="line"><span class="cl">            <span class="c1">// Need to decrement number of idle locked M&#39;s
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// (pretending that one more is running) before the CAS.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// Otherwise the M from which we retake can exit the syscall,
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// increment nmidle and report deadlock.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// 需要在CAS之前减少空闲锁定M的数量(假装还有一个正在运行)。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// 否则，我们重新获取的M可以退出系统调用，增加nmid并报告死锁。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="nf">incidlelocked</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>   <span class="c1">// sched.nmidlelocked += -1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// 这里使用Cas修改P的使用权，原因是此时此刻正好存在系统调用返回了，也正在获取P的使用权
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// 如果使用权获取成功则调用handoffp()寻找新的工作线程来接管这个p
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// _Pidle：空闲状态。此时的P没有被用来执行用户代码或调度器代码，通常位于空闲链表中，能够被调度器获取，
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// 它的状态可能正在由空闲转变成其他状态。P的所有权归空闲链表或某个正在改变它状态的线程所有，本地runq为空。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="k">if</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Cas</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">_p_</span><span class="p">.</span><span class="nx">status</span><span class="p">,</span> <span class="nx">s</span><span class="p">,</span> <span class="nx">_Pidle</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="k">if</span> <span class="nx">trace</span><span class="p">.</span><span class="nx">enabled</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                    <span class="nf">traceGoSysBlock</span><span class="p">(</span><span class="nx">_p_</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                    <span class="nf">traceProcStop</span><span class="p">(</span><span class="nx">_p_</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                <span class="p">}</span>
</span></span><span class="line"><span class="cl">                <span class="nx">n</span><span class="o">++</span>
</span></span><span class="line"><span class="cl">                <span class="nx">_p_</span><span class="p">.</span><span class="nx">syscalltick</span><span class="o">++</span> <span class="c1">// 系统调度次数加一
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="c1">// 尝试寻找一个新的m出来接管P
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="c1">// 抢占陷入系统调用的P时，没有多余的条件
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="nf">handoffp</span><span class="p">(</span><span class="nx">_p_</span><span class="p">)</span>	
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="nf">incidlelocked</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">allpLock</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">allpLock</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nb">uint32</span><span class="p">(</span><span class="nx">n</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="incidlelocked">incidlelocked()<a hidden class="anchor" aria-hidden="true" href="#incidlelocked">#</a></h4>
<ol>
<li>文件位置：go1.19.3/src/runtime/proc.go。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">5505
</span><span class="lnt">5506
</span><span class="lnt">5507
</span><span class="lnt">5508
</span><span class="lnt">5509
</span><span class="lnt">5510
</span><span class="lnt">5511
</span><span class="lnt">5512
</span><span class="lnt">5513
</span><span class="lnt">5514
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">incidlelocked</span><span class="p">(</span><span class="nx">v</span> <span class="kt">int32</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// nmidlelocked 锁定等待工作的M的数量
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 只会在该函数中加减，在checkdead()函数中判断
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">sched</span><span class="p">.</span><span class="nx">nmidlelocked</span> <span class="o">+=</span> <span class="nx">v</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">v</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">checkdead</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="preemptone">preemptone()<a hidden class="anchor" aria-hidden="true" href="#preemptone">#</a></h3>
<ol>
<li><code>sysmon</code>线程如果监控到某个<code>goroutine</code>连续运行超过了10毫秒，则会调用<code>preemptone()</code>函数向该<code>goroutine</code>发出抢占请求。</li>
<li>告诉在处理器<code>P</code>上运行的<code>goroutine</code>停止。</li>
<li>这个函数只是尽了最大努力。它可能会错误地没有通知<code>goroutine</code>。也可能会通知错误的<code>goroutine</code>。</li>
<li>即使它通知了正确的<code>goroutine</code>，如果<code>goroutine</code>同时执行<code>newstack</code>，它可能会忽略请求。</li>
<li>不需要锁。如果发出抢占请求，则返回true。</li>
<li>实际的抢占将在未来的某个时间点发生，并且将由<code>gp-&gt;status</code>不再是<code>Grunning</code>表示。设置抢占请求。</li>
<li>该函数会在<code>retake()</code>函数中调用，<code>GC</code>期间调用。</li>
<li>可以看出，<code>preemptone</code>函数只是简单的设置了被抢占<code>goroutine</code>对应的<code>g</code>结构体中的 <strong>preempt</strong>成员为<code>true</code>和<strong>stackguard0</strong>成员为<code>stackPreempt</code>（<code>stackPreempt</code>是一个常量<code>0xfffffffffffffade</code>，是非常大的一个数）就返回了，并未真正强制被抢占的<code>goroutine</code>暂停下来。</li>
<li>既然设置了一些抢占标志，那么就一定需要对这些标志进行处理，下面我们就来分析被抢占的<code>goroutine</code>如何处理这些标志去响应监控线程提出的抢占请求。</li>
<li>文件位置：go1.19.3/src/runtime/proc.go。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">5378
</span><span class="lnt">5379
</span><span class="lnt">5380
</span><span class="lnt">5381
</span><span class="lnt">5382
</span><span class="lnt">5383
</span><span class="lnt">5384
</span><span class="lnt">5385
</span><span class="lnt">5386
</span><span class="lnt">5387
</span><span class="lnt">5388
</span><span class="lnt">5389
</span><span class="lnt">5390
</span><span class="lnt">5391
</span><span class="lnt">5392
</span><span class="lnt">5393
</span><span class="lnt">5394
</span><span class="lnt">5395
</span><span class="lnt">5396
</span><span class="lnt">5397
</span><span class="lnt">5398
</span><span class="lnt">5399
</span><span class="lnt">5400
</span><span class="lnt">5401
</span><span class="lnt">5402
</span><span class="lnt">5403
</span><span class="lnt">5404
</span><span class="lnt">5405
</span><span class="lnt">5406
</span><span class="lnt">5407
</span><span class="lnt">5408
</span><span class="lnt">5409
</span><span class="lnt">5410
</span><span class="lnt">5411
</span><span class="lnt">5412
</span><span class="lnt">5413
</span><span class="lnt">5414
</span><span class="lnt">5415
</span><span class="lnt">5416
</span><span class="lnt">5417
</span><span class="lnt">5418
</span><span class="lnt">5419
</span><span class="lnt">5420
</span><span class="lnt">5421
</span><span class="lnt">5422
</span><span class="lnt">5423
</span><span class="lnt">5424
</span><span class="lnt">5425
</span><span class="lnt">5426
</span><span class="lnt">5427
</span><span class="lnt">5428
</span><span class="lnt">5429
</span><span class="lnt">5430
</span><span class="lnt">5431
</span><span class="lnt">5432
</span><span class="lnt">5433
</span><span class="lnt">5434
</span><span class="lnt">5435
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// Tell the goroutine running on processor P to stop.
</span></span></span><span class="line"><span class="cl"><span class="c1">// This function is purely best-effort. It can incorrectly fail to inform the
</span></span></span><span class="line"><span class="cl"><span class="c1">// goroutine. It can inform the wrong goroutine. Even if it informs the
</span></span></span><span class="line"><span class="cl"><span class="c1">// correct goroutine, that goroutine might ignore the request if it is
</span></span></span><span class="line"><span class="cl"><span class="c1">// simultaneously executing newstack.
</span></span></span><span class="line"><span class="cl"><span class="c1">// No lock needs to be held.
</span></span></span><span class="line"><span class="cl"><span class="c1">// Returns true if preemption request was issued.
</span></span></span><span class="line"><span class="cl"><span class="c1">// The actual preemption will happen at some point in the future
</span></span></span><span class="line"><span class="cl"><span class="c1">// and will be indicated by the gp-&gt;status no longer being
</span></span></span><span class="line"><span class="cl"><span class="c1">// Grunning
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">preemptone</span><span class="p">(</span><span class="nx">_p_</span> <span class="o">*</span><span class="nx">p</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 1) 抢占P的关联的m
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">mp</span> <span class="o">:=</span> <span class="nx">_p_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nf">ptr</span><span class="p">()</span>   <span class="c1">// mp := m
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    
</span></span><span class="line"><span class="cl">    <span class="c1">// 2) 抢占的P没有绑定M，或抢占的P的M与当前运行G的M一致【不设置抢占标志】
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//  1. mp == nil：可能来自sysmon抢占空闲的P的时候，这时候P是没有绑定M的。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//  2. mp == getg().m：抢占的是自己，很大可能这种情况来自GC在等待其他P停下来的时候。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nx">mp</span> <span class="o">==</span> <span class="kc">nil</span> <span class="o">||</span> <span class="nx">mp</span> <span class="o">==</span> <span class="nf">getg</span><span class="p">().</span><span class="nx">m</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="kc">false</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c1">// 3) 抢占的工作线程刚好处理完goroutine，或抢占的工作线程正在g0中【不设置抢占标志】
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">gp</span> <span class="o">:=</span> <span class="nx">mp</span><span class="p">.</span><span class="nx">curg</span>   <span class="c1">// mp工作线程上正在运行的goroutine
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 1. gp == nil：当前工作线程正在执行的goroutine刚好运行完被调离M时。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 2. gp == mp.g0：当前正在g0上，可能在执行调度代码。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nx">gp</span> <span class="o">==</span> <span class="kc">nil</span> <span class="o">||</span> <span class="nx">gp</span> <span class="o">==</span> <span class="nx">mp</span><span class="p">.</span><span class="nx">g0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="kc">false</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nx">gp</span><span class="p">.</span><span class="nx">preempt</span> <span class="p">=</span> <span class="kc">true</span> <span class="c1">// 标记正在运行的P的g设置抢占标志
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Every call in a goroutine checks for stack overflow by
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// comparing the current stack pointer to gp-&gt;stackguard0.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// Setting gp-&gt;stackguard0 to StackPreempt folds
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// preemption into the normal stack overflow check.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// goroutine中的每个调用都通过将当前堆栈指针与gp-&gt;stackguard0进行比较来检查堆栈溢出。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 设置gp-&gt;stackguard0为StackPreempt将抢占转换为正常的栈溢出检查。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// stackPreempt是一个常量0xfffffffffffffade，是非常大的一个数。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">gp</span><span class="p">.</span><span class="nx">stackguard0</span> <span class="p">=</span> <span class="nx">stackPreempt</span> <span class="c1">// 设置stackguard0使被抢占的goroutine去处理抢占请求
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Request an async preemption of this P.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 请求这个P的异步抢占。这种情况是对于没有调用任何函数的goroutine，没有抢占机会的情况下。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//  1. preemptMSupported：其中的 preemptMSupported 是个常量，因为受硬件特性的限制，
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//     在某些平台上是无法支持这种抢占的。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//  2. debug.asyncpreemptoff：则是让用户可以通过 GODEBUG 环境变量来禁用异步抢占，
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//     默认情况下是被启用的。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nx">preemptMSupported</span> <span class="o">&amp;&amp;</span> <span class="nx">debug</span><span class="p">.</span><span class="nx">asyncpreemptoff</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 在P的数据结构中也新增了一个preempt字段，这里会把它设置为true。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">_p_</span><span class="p">.</span><span class="nx">preempt</span> <span class="p">=</span> <span class="kc">true</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 实际上抢占操作是由 preemptM 函数完成的。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nf">preemptM</span><span class="p">(</span><span class="nx">mp</span><span class="p">)</span>	<span class="c1">// 该函数发起异步抢占给MP发送抢占信号
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="kc">true</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="handoffp">handoffp()<a hidden class="anchor" aria-hidden="true" href="#handoffp">#</a></h3>
<ol>
<li>从系统调用中关闭<code>P</code>或锁定<code>M</code>。总是在没有<code>P</code>的情况下运行，因此不允许有写屏障。</li>
<li><code>handoffp()</code>函数主要任务是通过各种条件判断是否需要启动工作线程来接管<code>_p_</code>，如果不需要则把<code>_p_</code>放入<code>P</code>的全局空闲队列。
<ol>
<li><code>_p_</code>的本地运行队列或全局运行队列里面有待运行的<code>goroutine</code>。</li>
<li>需要帮助<code>gc</code>完成标记工作。</li>
<li>系统比较忙，所有其它<code>_p_</code>都在运行<code>goroutine</code>，需要帮忙。</li>
<li>所有其它<code>P</code>都已经处于空闲状态，如果需要监控网络连接读写事件，则需要启动新的<code>m</code>来<code>poll</code>网络连接。</li>
</ol>
</li>
<li>文件位置：go1.19.3/src/runtime/proc.go。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">2350
</span><span class="lnt">2351
</span><span class="lnt">2352
</span><span class="lnt">2353
</span><span class="lnt">2354
</span><span class="lnt">2355
</span><span class="lnt">2356
</span><span class="lnt">2357
</span><span class="lnt">2358
</span><span class="lnt">2359
</span><span class="lnt">2360
</span><span class="lnt">2361
</span><span class="lnt">2362
</span><span class="lnt">2363
</span><span class="lnt">2364
</span><span class="lnt">2365
</span><span class="lnt">2366
</span><span class="lnt">2367
</span><span class="lnt">2368
</span><span class="lnt">2369
</span><span class="lnt">2370
</span><span class="lnt">2371
</span><span class="lnt">2372
</span><span class="lnt">2373
</span><span class="lnt">2374
</span><span class="lnt">2375
</span><span class="lnt">2376
</span><span class="lnt">2377
</span><span class="lnt">2378
</span><span class="lnt">2379
</span><span class="lnt">2380
</span><span class="lnt">2381
</span><span class="lnt">2382
</span><span class="lnt">2383
</span><span class="lnt">2384
</span><span class="lnt">2385
</span><span class="lnt">2386
</span><span class="lnt">2387
</span><span class="lnt">2388
</span><span class="lnt">2389
</span><span class="lnt">2390
</span><span class="lnt">2391
</span><span class="lnt">2392
</span><span class="lnt">2393
</span><span class="lnt">2394
</span><span class="lnt">2395
</span><span class="lnt">2396
</span><span class="lnt">2397
</span><span class="lnt">2398
</span><span class="lnt">2399
</span><span class="lnt">2400
</span><span class="lnt">2401
</span><span class="lnt">2402
</span><span class="lnt">2403
</span><span class="lnt">2404
</span><span class="lnt">2405
</span><span class="lnt">2406
</span><span class="lnt">2407
</span><span class="lnt">2408
</span><span class="lnt">2409
</span><span class="lnt">2410
</span><span class="lnt">2411
</span><span class="lnt">2412
</span><span class="lnt">2413
</span><span class="lnt">2414
</span><span class="lnt">2415
</span><span class="lnt">2416
</span><span class="lnt">2417
</span><span class="lnt">2418
</span><span class="lnt">2419
</span><span class="lnt">2420
</span><span class="lnt">2421
</span><span class="lnt">2422
</span><span class="lnt">2423
</span><span class="lnt">2424
</span><span class="lnt">2425
</span><span class="lnt">2426
</span><span class="lnt">2427
</span><span class="lnt">2428
</span><span class="lnt">2429
</span><span class="lnt">2430
</span><span class="lnt">2431
</span><span class="lnt">2432
</span><span class="lnt">2433
</span><span class="lnt">2434
</span><span class="lnt">2435
</span><span class="lnt">2436
</span><span class="lnt">2437
</span><span class="lnt">2438
</span><span class="lnt">2439
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// Hands off P from syscall or locked M.
</span></span></span><span class="line"><span class="cl"><span class="c1">// Always runs without a P, so write barriers are not allowed.
</span></span></span><span class="line"><span class="cl"><span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1">//go:nowritebarrierrec
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">handoffp</span><span class="p">(</span><span class="nx">_p_</span> <span class="o">*</span><span class="nx">p</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// handoffp must start an M in any situation where
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// findrunnable would return a G to run on _p_.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 在findrunnable返回G并在_p_上运行的任何情况下，handffp必须开始一个M。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="c1">// if it has local work, start it straight away
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 如果它有本地工作，需要启动m来接管
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">!</span><span class="nf">runqempty</span><span class="p">(</span><span class="nx">_p_</span><span class="p">)</span> <span class="o">||</span> <span class="nx">sched</span><span class="p">.</span><span class="nx">runqsize</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">startm</span><span class="p">(</span><span class="nx">_p_</span><span class="p">,</span> <span class="kc">false</span><span class="p">)</span> <span class="c1">// 创建M来接管P
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">return</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// if there&#39;s trace work to do, start it straight away
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="nx">trace</span><span class="p">.</span><span class="nx">enabled</span> <span class="o">||</span> <span class="nx">trace</span><span class="p">.</span><span class="nx">shutdown</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="nf">traceReaderAvailable</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">startm</span><span class="p">(</span><span class="nx">_p_</span><span class="p">,</span> <span class="kc">false</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// if it has GC work, start it straight away
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// GC正在工作，也需要启动m来接管
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nx">gcBlackenEnabled</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nf">gcMarkWorkAvailable</span><span class="p">(</span><span class="nx">_p_</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">startm</span><span class="p">(</span><span class="nx">_p_</span><span class="p">,</span> <span class="kc">false</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// no local work, check that there are no spinning/idle M&#39;s,
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// otherwise our help is not required
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 没有本地工作，检查是否有 spinning/idle 的M，否则不需要我们的帮助。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//  1. atomic.Load(&amp;sched.nmspinning)+atomic.Load(&amp;sched.npidle) == 0：没有自旋的M和空闲的P时。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//  2. atomic.Cas(&amp;sched.nmspinning, 0, 1)：sched.nmspinning = 1。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Load</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">nmspinning</span><span class="p">)</span><span class="o">+</span><span class="nx">atomic</span><span class="p">.</span><span class="nf">Load</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">npidle</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Cas</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">nmspinning</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// TODO: fast atomic
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nf">startm</span><span class="p">(</span><span class="nx">_p_</span><span class="p">,</span> <span class="kc">true</span><span class="p">)</span> <span class="c1">// 这时候启动的M绑定P可以起去其他P中偷取任务，如果存在空闲的P则表示其他P不忙
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">return</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// GC正在STW等待时。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nx">sched</span><span class="p">.</span><span class="nx">gcwaiting</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">_p_</span><span class="p">.</span><span class="nx">status</span> <span class="p">=</span> <span class="nx">_Pgcstop</span> <span class="c1">// 修改状态为GC而停下
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">sched</span><span class="p">.</span><span class="nx">stopwait</span><span class="o">--</span>      <span class="c1">// 因为GC而停下来
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 当前STW要求的P全部停下来时，就可以唤醒等待在sched.stopnote上的发起STW的线程了。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="nx">sched</span><span class="p">.</span><span class="nx">stopwait</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nf">notewakeup</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">stopnote</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">_p_</span><span class="p">.</span><span class="nx">runSafePointFn</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Cas</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">_p_</span><span class="p">.</span><span class="nx">runSafePointFn</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">sched</span><span class="p">.</span><span class="nf">safePointFn</span><span class="p">(</span><span class="nx">_p_</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="nx">sched</span><span class="p">.</span><span class="nx">safePointWait</span><span class="o">--</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="nx">sched</span><span class="p">.</span><span class="nx">safePointWait</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nf">notewakeup</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">safePointNote</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 全局队列池有G需要处理时。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nx">sched</span><span class="p">.</span><span class="nx">runqsize</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="nf">startm</span><span class="p">(</span><span class="nx">_p_</span><span class="p">,</span> <span class="kc">false</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// If this is the last running P and nobody is polling network,
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// need to wakeup another M to poll network.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 如果这是最后一个运行的P并且没有其他线程在阻塞式等待netpoll，需要唤醒一个M来处理netpoll。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//  1. sched.npidle == uint32(gomaxprocs-1)：当前是最后一个空闲P
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//  2. atomic.Load64(&amp;sched.lastpoll) != 0：没有其他线程在阻塞式访问netpoll。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nx">sched</span><span class="p">.</span><span class="nx">npidle</span> <span class="o">==</span> <span class="nb">uint32</span><span class="p">(</span><span class="nx">gomaxprocs</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Load64</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lastpoll</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="nf">startm</span><span class="p">(</span><span class="nx">_p_</span><span class="p">,</span> <span class="kc">false</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// The scheduler lock cannot be held when calling wakeNetPoller below
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// because wakeNetPoller may call wakep which may call startm.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 当调用wakeNetPoller时，调度器锁不能保持，因为wakeNetPoller可能会调用wakeep，而后者可能会调用startm。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">when</span> <span class="o">:=</span> <span class="nf">nobarrierWakeTime</span><span class="p">(</span><span class="nx">_p_</span><span class="p">)</span> <span class="c1">// 最新timer触发时间点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">pidleput</span><span class="p">(</span><span class="nx">_p_</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="c1">//无事可做，把p放入全局空闲队列
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">when</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">wakeNetPoller</span><span class="p">(</span><span class="nx">when</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c1">// 走到这里不会抢占P
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="响应抢占请求">响应抢占请求<a hidden class="anchor" aria-hidden="true" href="#响应抢占请求">#</a></h2>
<ol>
<li>抢占的相关函数调用链<code>morestack_noctxt()</code>-&gt;<code>morestack()</code>-&gt;<code>newstack()</code>。</li>
<li>从源代码中<code>morestack()</code>函数的注释可以知道，该函数会被编译器自动插入到函数 <strong>序言(prologue)</strong> 中。</li>
</ol>
<h3 id="morestack_noctxt">morestack_noctxt()<a hidden class="anchor" aria-hidden="true" href="#morestack_noctxt">#</a></h3>
<ol>
<li>文件位置：go1.19.3/src/runtime/asm_amd64.s。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">574
</span><span class="lnt">575
</span><span class="lnt">576
</span><span class="lnt">577
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-asm" data-lang="asm"><span class="line"><span class="cl"><span class="c1"># morestack but not preserving ctxt.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nf">TEXT</span> <span class="no">runtime</span><span class="err">·</span><span class="no">morestack_noctxt</span><span class="p">(</span><span class="no">SB</span><span class="p">),</span><span class="no">NOSPLIT</span><span class="p">,</span><span class="no">$0</span>
</span></span><span class="line"><span class="cl">    <span class="nf">MOVL</span>    <span class="no">$0</span><span class="p">,</span> <span class="no">DX</span>              <span class="c1"># DX = 0，DX寄存器被用作函数调用的隐藏传值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">JMP</span>	<span class="no">runtime</span><span class="err">·</span><span class="no">morestack</span><span class="p">(</span><span class="no">SB</span><span class="p">)</span>   <span class="c1"># 注意这里使用的是JMP不是CALL因此不是函数调用
</span></span></span></code></pre></td></tr></table>
</div>
</div><ol start="2">
<li>我们假设是在<code>main.main</code>函数序言中调用了<code>morestack_noctxt()</code>函数，则函数的栈帧结构如下：</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-txt" data-lang="txt"><span class="line"><span class="cl">//  +10 | 
</span></span><span class="line"><span class="cl">//      ----------------------------    runtime.main SP
</span></span><span class="line"><span class="cl">//  +08 | runtime.main callback
</span></span><span class="line"><span class="cl">//      ----------------------------    main.main SP
</span></span><span class="line"><span class="cl">//  +00 | main.main callback
</span></span><span class="line"><span class="cl">//      ----------------------------    morestack_noctxt SP
</span></span><span class="line"><span class="cl">//
</span></span><span class="line"><span class="cl">//      runtime·morestack(SB)是通过JMP调用的，所以没有重新分配栈帧
</span></span></code></pre></div><h3 id="morestack">morestack()<a hidden class="anchor" aria-hidden="true" href="#morestack">#</a></h3>
<ol>
<li>当需要更多栈时，在函数<code>prolog</code>期间调用。</li>
<li>回溯例程将<code>g0</code>上的<code>morestack</code>视为栈的顶部(例如，<code>morestack</code>调用<code>newstack</code>调用调度器调用<code>newm</code>调用<code>gc</code>)，</li>
<li>因此我们必须记录参数大小。为此，它没有参数。</li>
<li>文件位置：go1.19.3/src/runtime/asm_amd64.s。</li>
<li>该函数，保护调用者信息，切换到g0栈调用runtime·newstack方法。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">269
</span><span class="lnt">270
</span><span class="lnt">271
</span><span class="lnt">272
</span><span class="lnt">273
</span><span class="lnt">274
</span><span class="lnt">275
</span><span class="lnt">276
</span><span class="lnt">277
</span><span class="lnt">278
</span><span class="lnt">279
</span><span class="lnt">280
</span><span class="lnt">281
</span><span class="lnt">282
</span><span class="lnt">283
</span><span class="lnt">284
</span><span class="lnt">285
</span><span class="lnt">286
</span><span class="lnt">287
</span><span class="lnt">288
</span><span class="lnt">289
</span><span class="lnt">290
</span><span class="lnt">291
</span><span class="lnt">292
</span><span class="lnt">293
</span><span class="lnt">294
</span><span class="lnt">295
</span><span class="lnt">296
</span><span class="lnt">297
</span><span class="lnt">298
</span><span class="lnt">299
</span><span class="lnt">300
</span><span class="lnt">301
</span><span class="lnt">302
</span><span class="lnt">303
</span><span class="lnt">304
</span><span class="lnt">305
</span><span class="lnt">306
</span><span class="lnt">307
</span><span class="lnt">308
</span><span class="lnt">309
</span><span class="lnt">310
</span><span class="lnt">311
</span><span class="lnt">312
</span><span class="lnt">313
</span><span class="lnt">314
</span><span class="lnt">315
</span><span class="lnt">316
</span><span class="lnt">317
</span><span class="lnt">318
</span><span class="lnt">319
</span><span class="lnt">320
</span><span class="lnt">321
</span><span class="lnt">322
</span><span class="lnt">323
</span><span class="lnt">324
</span><span class="lnt">325
</span><span class="lnt">326
</span><span class="lnt">327
</span><span class="lnt">328
</span><span class="lnt">329
</span><span class="lnt">330
</span><span class="lnt">331
</span><span class="lnt">332
</span><span class="lnt">333
</span><span class="lnt">334
</span><span class="lnt">335
</span><span class="lnt">336
</span><span class="lnt">337
</span><span class="lnt">338
</span><span class="lnt">339
</span><span class="lnt">340
</span><span class="lnt">341
</span><span class="lnt">342
</span><span class="lnt">343
</span><span class="lnt">344
</span><span class="lnt">345
</span><span class="lnt">346
</span><span class="lnt">347
</span><span class="lnt">348
</span><span class="lnt">349
</span><span class="lnt">350
</span><span class="lnt">351
</span><span class="lnt">352
</span><span class="lnt">353
</span><span class="lnt">354
</span><span class="lnt">355
</span><span class="lnt">356
</span><span class="lnt">357
</span><span class="lnt">358
</span><span class="lnt">359
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-asm" data-lang="asm"><span class="line"><span class="cl"><span class="c1"># Called during function prolog when more stack is needed.
</span></span></span><span class="line"><span class="cl"><span class="c1">#
</span></span></span><span class="line"><span class="cl"><span class="c1"># The traceback routines see morestack on a g0 as being
</span></span></span><span class="line"><span class="cl"><span class="c1"># the top of a stack (for example, morestack calling newstack
</span></span></span><span class="line"><span class="cl"><span class="c1"># calling the scheduler calling newm calling gc), so we must
</span></span></span><span class="line"><span class="cl"><span class="c1"># record an argument size. For that purpose, it has no arguments.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nf">TEXT</span> <span class="no">runtime</span><span class="err">·</span><span class="no">morestack</span><span class="p">(</span><span class="no">SB</span><span class="p">),</span><span class="no">NOSPLIT</span><span class="p">,</span><span class="no">$0-0</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># Cannot grow scheduler stack (m-&gt;g0).
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">get_tls</span><span class="p">(</span><span class="no">CX</span><span class="p">)</span>             <span class="c1"># CX = &amp;m.tls[1]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">MOVQ</span>    <span class="no">g</span><span class="p">(</span><span class="no">CX</span><span class="p">),</span> <span class="no">BX</span>       <span class="c1"># BX = m.tls[0] = g
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">MOVQ</span>    <span class="no">g_m</span><span class="p">(</span><span class="no">BX</span><span class="p">),</span> <span class="no">BX</span>     <span class="c1"># BX = g.m
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">MOVQ</span>    <span class="no">m_g0</span><span class="p">(</span><span class="no">BX</span><span class="p">),</span> <span class="no">SI</span>    <span class="c1"># SI = m.g0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">CMPQ</span>    <span class="no">g</span><span class="p">(</span><span class="no">CX</span><span class="p">),</span> <span class="no">SI</span>       <span class="c1"># 比较当前g是否是g0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">JNE</span>	<span class="mi">3</span><span class="p">(</span><span class="no">PC</span><span class="p">)</span> <span class="c1"># 判断不为零时则跳转
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1"># runtime·badmorestackg0 错误信息 &#34;morestack()函数在g0栈上被调用&#34;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">CALL</span>    <span class="no">runtime</span><span class="err">·</span><span class="no">badmorestackg0</span><span class="p">(</span><span class="no">SB</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># int 3 进入中断指令，这是一个调试指令
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">CALL</span>    <span class="no">runtime</span><span class="err">·</span><span class="no">abort</span><span class="p">(</span><span class="no">SB</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1"># Cannot grow signal stack (m-&gt;gsignal).
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">MOVQ</span>    <span class="no">m_gsignal</span><span class="p">(</span><span class="no">BX</span><span class="p">),</span> <span class="no">SI</span>   <span class="c1"># SI = m.gsignal
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">CMPQ</span>    <span class="no">g</span><span class="p">(</span><span class="no">CX</span><span class="p">),</span> <span class="no">SI</span>
</span></span><span class="line"><span class="cl">    <span class="nf">JNE</span>	<span class="mi">3</span><span class="p">(</span><span class="no">PC</span><span class="p">)</span> <span class="c1"># 判断不为零时则跳转
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1"># runtime·badmorestackgsignal 错误信息 &#34;morestack()函数在gsignal上被调用&#34;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">CALL</span>    <span class="no">runtime</span><span class="err">·</span><span class="no">badmorestackgsignal</span><span class="p">(</span><span class="no">SB</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nf">CALL</span>    <span class="no">runtime</span><span class="err">·</span><span class="no">abort</span><span class="p">(</span><span class="no">SB</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1"># Called from f.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1"># Set m-&gt;morebuf to f&#39;s caller.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1"># 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1"># 从f调用。设置m-&gt;morebuf为f的调用者。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1"># NOP SP 指令意义：
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">#   1. NOP SP指令不做任何操作。具体来说，它会将堆栈指针(SP)向后移动0个字节，这实际上是没有任何效果的。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">#   2. 在 Go 的汇编语言中，有时需要使用 &#34;NOP SP&#34; 这条指令来进行指令对齐，但这也可能会导致 vet 工具产生误报，因为它会认为这会导致堆栈偏移量的改变。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1"># &#34;# tell vet SP changed - stop checking offsets&#34; 这行注释的意义：
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">#   1. 为了避免这种情况，程序员可以添加这个注释来告诉vet工具，实际上没有对堆栈偏移量进行任何更改，因此vet工具可以停止检查堆栈偏移量。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">#   2. 这句话的意思是，程序员在添加NOP SP指令时遇到了vet工具的误报问题，为了解决这个问题，他们添加了这个注释，告诉vet工具不需要继续检查堆栈偏移量。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1"># 指令对齐：是指将指令地址对齐到一定的边界上，使得指令的执行效率更高。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">#   1. 在计算机系统中，CPU 通常需要从内存中读取指令并执行它们，这是一个非常耗时的过程。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">#   2. 为了提高执行效率，CPU 需要在访问内存时保持一定的对齐方式，以便更快地读取指令并进行处理。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">#   3. 在指令对齐中，指令地址通常被要求对齐到一个特定的边界，通常是2的幂次方，如2、4、8等。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">#   4. 这意味着指令地址的低位必须是0，这使得 CPU 可以更快地读取指令并进行处理，从而提高程序的执行效率。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">#   5. 在编写汇编语言程序时，程序员通常需要手动对指令进行对齐。这可以通过添加一些无操作指令，如NOP指令，来实现。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">#   6. 这些指令不会对程序的执行产生任何影响，只是用来填充指令流中的空隙，以确保指令地址对齐。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">#   7. 这些操作可以帮助 CPU 更快地读取指令并提高程序的执行效率。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">NOP</span>	<span class="no">SP</span>	<span class="c1"># tell vet SP changed - stop checking offsets
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    
</span></span><span class="line"><span class="cl">    <span class="c1"># 以下代码保存调用者信息，比如在main.main的序言中调了morestack_noctxt()-&gt;morestack()函数，需要保存的是main.main的信息
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    
</span></span><span class="line"><span class="cl">    <span class="c1"># 8(SP)：main函数在调用morestack_noctxt之前的rsp寄存器
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1"># 通过上面函数栈帧的分配 8(SP) 是runtime.main函数的返回地址，注意这里是保存在m上的，m-&gt;morebuf
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1"># 保存到m-&gt;morebuf用于提供给接下来的newstack()函数使用
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">MOVQ</span>    <span class="mi">8</span><span class="p">(</span><span class="no">SP</span><span class="p">),</span> <span class="no">AX</span>	<span class="c1"># f&#39;s caller&#39;s PC; 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">MOVQ</span>    <span class="no">AX</span><span class="p">,</span> <span class="p">(</span><span class="no">m_morebuf</span><span class="err">+</span><span class="no">gobuf_pc</span><span class="p">)(</span><span class="no">BX</span><span class="p">)</span>    <span class="c1"># m.morebuf.gobuf.pc=AX
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1"># 16(SP)：调用者函数的SP，也就是runtime.main的SP寄存器地址，注意这里是 LEAQ 指令
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">LEAQ</span>    <span class="mi">16</span><span class="p">(</span><span class="no">SP</span><span class="p">),</span> <span class="no">AX</span>	<span class="c1"># f&#39;s caller&#39;s SP   # AX = 16(SP); 该值是runtime.main函数的rsp寄存器存储的地址
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">MOVQ</span>    <span class="no">AX</span><span class="p">,</span> <span class="p">(</span><span class="no">m_morebuf</span><span class="err">+</span><span class="no">gobuf_sp</span><span class="p">)(</span><span class="no">BX</span><span class="p">)</span>    <span class="c1"># m.morebuf.gobuf.sp=AX
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">get_tls</span><span class="p">(</span><span class="no">CX</span><span class="p">)</span>         <span class="c1"># CX = &amp;m.tls[1]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">MOVQ</span>    <span class="no">g</span><span class="p">(</span><span class="no">CX</span><span class="p">),</span> <span class="no">SI</span>   <span class="c1"># SI = m.tls[0] = g;    这里是g，不是g0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">MOVQ</span>    <span class="no">SI</span><span class="p">,</span> <span class="p">(</span><span class="no">m_morebuf</span><span class="err">+</span><span class="no">gobuf_g</span><span class="p">)(</span><span class="no">BX</span><span class="p">)</span> <span class="c1"># m.morebuf.gobuf.g = g
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1"># 到这里我们已经在m-&gt;morebuf保存好了调用者runtime.main的rip、rsp、g相关信息
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="c1"># Set g-&gt;sched to context in f.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1"># 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1"># 将 g-&gt;sched 设置为f的上下文，这才是需要恢复的现场数据
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    
</span></span><span class="line"><span class="cl">    <span class="c1"># SP栈顶寄存器现在指向的是morestack_noctxt函数的返回地址，注意下面都是保存在g上的，g-&gt;sched不是g0上
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1"># 0(SP)：通过上面函数栈帧的分配 0(SP) 是main.main函数的返回地址，也就是rip中的值就是main.main的下条代码地址
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">MOVQ</span>    <span class="mi">0</span><span class="p">(</span><span class="no">SP</span><span class="p">),</span> <span class="no">AX</span>   <span class="c1"># f&#39;s PC
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1"># g.sched.gobuf.pc = AX
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">MOVQ</span>    <span class="no">AX</span><span class="p">,</span> <span class="p">(</span><span class="no">g_sched</span><span class="err">+</span><span class="no">gobuf_pc</span><span class="p">)(</span><span class="no">SI</span><span class="p">)</span>  <span class="c1"># 执行完morestack_noctxt函数之后应该返回去继续执行指令的地址 AX
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1"># 8(SP)：调用者函数的SP，也就是main.main的SP寄存器地址，这个地址是没有压入rip指令数据前的地址，注意这里是 LEAQ 指令
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">LEAQ</span>    <span class="mi">8</span><span class="p">(</span><span class="no">SP</span><span class="p">),</span> <span class="no">AX</span>                   <span class="c1"># f&#39;s SP;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">MOVQ</span>    <span class="no">AX</span><span class="p">,</span> <span class="p">(</span><span class="no">g_sched</span><span class="err">+</span><span class="no">gobuf_sp</span><span class="p">)(</span><span class="no">SI</span><span class="p">)</span>  <span class="c1"># g.sched.gobuf.sp = AX
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1"># 由于BP寄存器的值一致没有变，所以这里BP寄存器还是指向main.main的栈底
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">MOVQ</span>    <span class="no">BP</span><span class="p">,</span> <span class="p">(</span><span class="no">g_sched</span><span class="err">+</span><span class="no">gobuf_bp</span><span class="p">)(</span><span class="no">SI</span><span class="p">)</span>  <span class="c1"># g.sched.gobuf.bp = BP
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1"># DX寄存器被设置为了0，在runtime·morestack_noctxt()函数中
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">MOVQ</span>    <span class="no">DX</span><span class="p">,</span> <span class="p">(</span><span class="no">g_sched</span><span class="err">+</span><span class="no">gobuf_ctxt</span><span class="p">)(</span><span class="no">SI</span><span class="p">)</span><span class="c1"># g.sched.gobuf.ctxt = DX;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1"># 到这里当前g-&gt;sched已保存好了恢复到main.main的现场，包括rip、rsp、rbp、rdx
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="c1"># Call newstack on m-&gt;g0&#39;s stack.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1"># 切换到g0栈，并设置tls的g为g0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">MOVQ</span>    <span class="no">m_g0</span><span class="p">(</span><span class="no">BX</span><span class="p">),</span> <span class="no">BX</span>                <span class="c1"># BX = g0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1"># 设置TLS中的g为g0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">MOVQ</span>    <span class="no">BX</span><span class="p">,</span> <span class="no">g</span><span class="p">(</span><span class="no">CX</span><span class="p">)</span>                   <span class="c1"># m.tls[0] = g0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1"># 把g0栈的栈顶寄存器的值恢复到CPU的寄存器，达到切换栈的目的，下面这一条指令执行之前，
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1"># CPU还是使用的调用此函数的g的栈，执行之后CPU就开始使用g0的栈了
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">MOVQ</span>    <span class="p">(</span><span class="no">g_sched</span><span class="err">+</span><span class="no">gobuf_sp</span><span class="p">)(</span><span class="no">BX</span><span class="p">),</span> <span class="no">SP</span>  <span class="c1"># rsp = g0.sched.gobuf.sp
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">CALL</span>    <span class="no">runtime</span><span class="err">·</span><span class="no">newstack</span><span class="p">(</span><span class="no">SB</span><span class="p">)</span>        <span class="c1"># 调用 newstack() 函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">CALL</span>    <span class="no">runtime</span><span class="err">·</span><span class="no">abort</span><span class="p">(</span><span class="no">SB</span><span class="p">)</span>           <span class="c1"># crash if newstack returns
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">RET</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ol start="6">
<li>汇编语言<code>&quot;int 3&quot;</code>是一个中断指令，它向操作系统发出一个调试信号，要求在程序的当前位置停止执行并进入调试器。</li>
<li>通常，调试器会在此处暂停程序的执行，并允许程序员检查程序状态、变量值和程序流程等信息，以帮助他们调试程序。</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-asm" data-lang="asm"><span class="line"><span class="cl"><span class="nf">TEXT</span> <span class="no">runtime</span><span class="err">·</span><span class="no">abort</span><span class="p">(</span><span class="no">SB</span><span class="p">),</span><span class="no">NOSPLIT</span><span class="p">,</span><span class="no">$0-0</span>
</span></span><span class="line"><span class="cl">    <span class="nf">INT</span>	<span class="no">$3</span>
</span></span><span class="line"><span class="cl"><span class="nl">loop:</span>
</span></span><span class="line"><span class="cl">    <span class="nf">JMP</span>	<span class="no">loop</span>
</span></span></code></pre></div><h3 id="newstack">newstack()<a hidden class="anchor" aria-hidden="true" href="#newstack">#</a></h3>
<ol>
<li>该函数主要有两个职责：一个是【扩栈】，另一个是响应sysmon提出的【抢占请求】。</li>
<li><code>newstack()</code>函数首先检查<code>g.stackguard0</code>是否被设置为<code>stackPreempt</code>，如果是则表示<code>sysmon</code>已经发现我们运行得太久了并对我们发起了抢占请求。</li>
<li>当需要更多堆栈时从<code>runtime·morestack</code>调用。分配更大的堆栈并重新定位到新堆栈。对于固定的平摊代价，堆栈增长是乘法的。</li>
<li><code>g-&gt;atomicstatus</code>将在进入时进行<code>Grunning</code>或<code>Gscanrunning</code>。调度程序试图停止这个<code>g</code>，然后它将设置<code>preemptStop</code>。</li>
<li>这必须是<code>nowritebarrierrec</code>，因为它可以作为堆栈增长的一部分从其他<code>nowritebarrierrec</code>函数调用，但编译器不会检查这一点。</li>
<li><strong>go:nowritebarrierrec</strong>：编译器不插入写屏障相关代码，包括当前函数以及调用的任何函数中。</li>
<li>文件位置：go1.19.3/src/runtime/stack.go。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 950
</span><span class="lnt"> 951
</span><span class="lnt"> 952
</span><span class="lnt"> 953
</span><span class="lnt"> 954
</span><span class="lnt"> 955
</span><span class="lnt"> 956
</span><span class="lnt"> 957
</span><span class="lnt"> 958
</span><span class="lnt"> 959
</span><span class="lnt"> 960
</span><span class="lnt"> 961
</span><span class="lnt"> 962
</span><span class="lnt"> 963
</span><span class="lnt"> 964
</span><span class="lnt"> 965
</span><span class="lnt"> 966
</span><span class="lnt"> 967
</span><span class="lnt"> 968
</span><span class="lnt"> 969
</span><span class="lnt"> 970
</span><span class="lnt"> 971
</span><span class="lnt"> 972
</span><span class="lnt"> 973
</span><span class="lnt"> 974
</span><span class="lnt"> 975
</span><span class="lnt"> 976
</span><span class="lnt"> 977
</span><span class="lnt"> 978
</span><span class="lnt"> 979
</span><span class="lnt"> 980
</span><span class="lnt"> 981
</span><span class="lnt"> 982
</span><span class="lnt"> 983
</span><span class="lnt"> 984
</span><span class="lnt"> 985
</span><span class="lnt"> 986
</span><span class="lnt"> 987
</span><span class="lnt"> 988
</span><span class="lnt"> 989
</span><span class="lnt"> 990
</span><span class="lnt"> 991
</span><span class="lnt"> 992
</span><span class="lnt"> 993
</span><span class="lnt"> 994
</span><span class="lnt"> 995
</span><span class="lnt"> 996
</span><span class="lnt"> 997
</span><span class="lnt"> 998
</span><span class="lnt"> 999
</span><span class="lnt">1000
</span><span class="lnt">1001
</span><span class="lnt">1002
</span><span class="lnt">1003
</span><span class="lnt">1004
</span><span class="lnt">1005
</span><span class="lnt">1006
</span><span class="lnt">1007
</span><span class="lnt">1008
</span><span class="lnt">1009
</span><span class="lnt">1010
</span><span class="lnt">1011
</span><span class="lnt">1012
</span><span class="lnt">1013
</span><span class="lnt">1014
</span><span class="lnt">1015
</span><span class="lnt">1016
</span><span class="lnt">1017
</span><span class="lnt">1018
</span><span class="lnt">1019
</span><span class="lnt">1020
</span><span class="lnt">1021
</span><span class="lnt">1022
</span><span class="lnt">1023
</span><span class="lnt">1024
</span><span class="lnt">1025
</span><span class="lnt">1026
</span><span class="lnt">1027
</span><span class="lnt">1028
</span><span class="lnt">1029
</span><span class="lnt">1030
</span><span class="lnt">1031
</span><span class="lnt">1032
</span><span class="lnt">1033
</span><span class="lnt">1034
</span><span class="lnt">1035
</span><span class="lnt">1036
</span><span class="lnt">1037
</span><span class="lnt">1038
</span><span class="lnt">1039
</span><span class="lnt">1040
</span><span class="lnt">1041
</span><span class="lnt">1042
</span><span class="lnt">1043
</span><span class="lnt">1044
</span><span class="lnt">1045
</span><span class="lnt">1046
</span><span class="lnt">1047
</span><span class="lnt">1048
</span><span class="lnt">1049
</span><span class="lnt">1050
</span><span class="lnt">1051
</span><span class="lnt">1052
</span><span class="lnt">1053
</span><span class="lnt">1054
</span><span class="lnt">1055
</span><span class="lnt">1056
</span><span class="lnt">1057
</span><span class="lnt">1058
</span><span class="lnt">1059
</span><span class="lnt">1060
</span><span class="lnt">1061
</span><span class="lnt">1062
</span><span class="lnt">1063
</span><span class="lnt">1064
</span><span class="lnt">1065
</span><span class="lnt">1066
</span><span class="lnt">1067
</span><span class="lnt">1068
</span><span class="lnt">1069
</span><span class="lnt">1070
</span><span class="lnt">1071
</span><span class="lnt">1072
</span><span class="lnt">1073
</span><span class="lnt">1074
</span><span class="lnt">1075
</span><span class="lnt">1076
</span><span class="lnt">1077
</span><span class="lnt">1078
</span><span class="lnt">1079
</span><span class="lnt">1080
</span><span class="lnt">1081
</span><span class="lnt">1082
</span><span class="lnt">1083
</span><span class="lnt">1084
</span><span class="lnt">1085
</span><span class="lnt">1086
</span><span class="lnt">1087
</span><span class="lnt">1088
</span><span class="lnt">1089
</span><span class="lnt">1090
</span><span class="lnt">1091
</span><span class="lnt">1092
</span><span class="lnt">1093
</span><span class="lnt">1094
</span><span class="lnt">1095
</span><span class="lnt">1096
</span><span class="lnt">1097
</span><span class="lnt">1098
</span><span class="lnt">1099
</span><span class="lnt">1100
</span><span class="lnt">1101
</span><span class="lnt">1102
</span><span class="lnt">1103
</span><span class="lnt">1104
</span><span class="lnt">1105
</span><span class="lnt">1106
</span><span class="lnt">1107
</span><span class="lnt">1108
</span><span class="lnt">1109
</span><span class="lnt">1110
</span><span class="lnt">1111
</span><span class="lnt">1112
</span><span class="lnt">1113
</span><span class="lnt">1114
</span><span class="lnt">1115
</span><span class="lnt">1116
</span><span class="lnt">1117
</span><span class="lnt">1118
</span><span class="lnt">1119
</span><span class="lnt">1120
</span><span class="lnt">1121
</span><span class="lnt">1122
</span><span class="lnt">1123
</span><span class="lnt">1124
</span><span class="lnt">1125
</span><span class="lnt">1126
</span><span class="lnt">1127
</span><span class="lnt">1128
</span><span class="lnt">1129
</span><span class="lnt">1130
</span><span class="lnt">1131
</span><span class="lnt">1132
</span><span class="lnt">1133
</span><span class="lnt">1134
</span><span class="lnt">1135
</span><span class="lnt">1136
</span><span class="lnt">1137
</span><span class="lnt">1138
</span><span class="lnt">1139
</span><span class="lnt">1140
</span><span class="lnt">1141
</span><span class="lnt">1142
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// Called from runtime·morestack when more stack is needed.
</span></span></span><span class="line"><span class="cl"><span class="c1">// Allocate larger stack and relocate to new stack.
</span></span></span><span class="line"><span class="cl"><span class="c1">// Stack growth is multiplicative, for constant amortized cost.
</span></span></span><span class="line"><span class="cl"><span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1">// g-&gt;atomicstatus will be Grunning or Gscanrunning upon entry.
</span></span></span><span class="line"><span class="cl"><span class="c1">// If the scheduler is trying to stop this g, then it will set preemptStop.
</span></span></span><span class="line"><span class="cl"><span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1">// This must be nowritebarrierrec because it can be called as part of
</span></span></span><span class="line"><span class="cl"><span class="c1">// stack growth from other nowritebarrierrec functions, but the
</span></span></span><span class="line"><span class="cl"><span class="c1">// compiler doesn&#39;t check this.
</span></span></span><span class="line"><span class="cl"><span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1">//go:nowritebarrierrec
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">newstack</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">thisg</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">()</span> <span class="c1">// thisg = g0; 根据morestack()函数的相关代码
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// TODO: double check all gp. shouldn&#39;t be getg().
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 根据morestack()函数的相关代码，这里thisg.m.morebuf.g.ptr()是g不是g0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nx">thisg</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">morebuf</span><span class="p">.</span><span class="nx">g</span><span class="p">.</span><span class="nf">ptr</span><span class="p">().</span><span class="nx">stackguard0</span> <span class="o">==</span> <span class="nx">stackFork</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">throw</span><span class="p">(</span><span class="s">&#34;stack growth after fork&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c1">// m-&gt;curg 是当前m上正在运行的g
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nx">thisg</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">morebuf</span><span class="p">.</span><span class="nx">g</span><span class="p">.</span><span class="nf">ptr</span><span class="p">()</span> <span class="o">!=</span> <span class="nx">thisg</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">curg</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nb">print</span><span class="p">(</span><span class="s">&#34;runtime: newstack called from g=&#34;</span><span class="p">,</span> <span class="nf">hex</span><span class="p">(</span><span class="nx">thisg</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">morebuf</span><span class="p">.</span><span class="nx">g</span><span class="p">),</span> <span class="s">&#34;\n&#34;</span><span class="o">+</span><span class="s">&#34;\tm=&#34;</span><span class="p">,</span> <span class="nx">thisg</span><span class="p">.</span><span class="nx">m</span><span class="p">,</span> <span class="s">&#34; m-&gt;curg=&#34;</span><span class="p">,</span> <span class="nx">thisg</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">curg</span><span class="p">,</span> <span class="s">&#34; m-&gt;g0=&#34;</span><span class="p">,</span> <span class="nx">thisg</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">g0</span><span class="p">,</span> <span class="s">&#34; m-&gt;gsignal=&#34;</span><span class="p">,</span> <span class="nx">thisg</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">gsignal</span><span class="p">,</span> <span class="s">&#34;\n&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="nx">morebuf</span> <span class="o">:=</span> <span class="nx">thisg</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">morebuf</span>
</span></span><span class="line"><span class="cl">        <span class="nf">traceback</span><span class="p">(</span><span class="nx">morebuf</span><span class="p">.</span><span class="nx">pc</span><span class="p">,</span> <span class="nx">morebuf</span><span class="p">.</span><span class="nx">sp</span><span class="p">,</span> <span class="nx">morebuf</span><span class="p">.</span><span class="nx">lr</span><span class="p">,</span> <span class="nx">morebuf</span><span class="p">.</span><span class="nx">g</span><span class="p">.</span><span class="nf">ptr</span><span class="p">())</span>
</span></span><span class="line"><span class="cl">        <span class="nf">throw</span><span class="p">(</span><span class="s">&#34;runtime: wrong goroutine in newstack&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nx">gp</span> <span class="o">:=</span> <span class="nx">thisg</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">curg</span>  <span class="c1">// gp 在这里例子是runtime.main的goroutine
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="c1">// g.throwsplit 在系统调用前会被设置为true或其他地方。因此g出现在这里不合适。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nx">thisg</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">curg</span><span class="p">.</span><span class="nx">throwsplit</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// Update syscallsp, syscallpc in case traceback uses them.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">morebuf</span> <span class="o">:=</span> <span class="nx">thisg</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">morebuf</span>
</span></span><span class="line"><span class="cl">        <span class="nx">gp</span><span class="p">.</span><span class="nx">syscallsp</span> <span class="p">=</span> <span class="nx">morebuf</span><span class="p">.</span><span class="nx">sp</span>
</span></span><span class="line"><span class="cl">        <span class="nx">gp</span><span class="p">.</span><span class="nx">syscallpc</span> <span class="p">=</span> <span class="nx">morebuf</span><span class="p">.</span><span class="nx">pc</span>
</span></span><span class="line"><span class="cl">        <span class="nx">pcname</span><span class="p">,</span> <span class="nx">pcoff</span> <span class="o">:=</span> <span class="s">&#34;(unknown)&#34;</span><span class="p">,</span> <span class="nb">uintptr</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="nx">f</span> <span class="o">:=</span> <span class="nf">findfunc</span><span class="p">(</span><span class="nx">gp</span><span class="p">.</span><span class="nx">sched</span><span class="p">.</span><span class="nx">pc</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="nx">f</span><span class="p">.</span><span class="nf">valid</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nx">pcname</span> <span class="p">=</span> <span class="nf">funcname</span><span class="p">(</span><span class="nx">f</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="nx">pcoff</span> <span class="p">=</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">sched</span><span class="p">.</span><span class="nx">pc</span> <span class="o">-</span> <span class="nx">f</span><span class="p">.</span><span class="nf">entry</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="nb">print</span><span class="p">(</span><span class="s">&#34;runtime: newstack at &#34;</span><span class="p">,</span> <span class="nx">pcname</span><span class="p">,</span> <span class="s">&#34;+&#34;</span><span class="p">,</span> <span class="nf">hex</span><span class="p">(</span><span class="nx">pcoff</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">            <span class="s">&#34; sp=&#34;</span><span class="p">,</span> <span class="nf">hex</span><span class="p">(</span><span class="nx">gp</span><span class="p">.</span><span class="nx">sched</span><span class="p">.</span><span class="nx">sp</span><span class="p">),</span> <span class="s">&#34; stack=[&#34;</span><span class="p">,</span> <span class="nf">hex</span><span class="p">(</span><span class="nx">gp</span><span class="p">.</span><span class="nx">stack</span><span class="p">.</span><span class="nx">lo</span><span class="p">),</span> <span class="s">&#34;, &#34;</span><span class="p">,</span> <span class="nf">hex</span><span class="p">(</span><span class="nx">gp</span><span class="p">.</span><span class="nx">stack</span><span class="p">.</span><span class="nx">hi</span><span class="p">),</span> <span class="s">&#34;]\n&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">            <span class="s">&#34;\tmorebuf={pc:&#34;</span><span class="p">,</span> <span class="nf">hex</span><span class="p">(</span><span class="nx">morebuf</span><span class="p">.</span><span class="nx">pc</span><span class="p">),</span> <span class="s">&#34; sp:&#34;</span><span class="p">,</span> <span class="nf">hex</span><span class="p">(</span><span class="nx">morebuf</span><span class="p">.</span><span class="nx">sp</span><span class="p">),</span> <span class="s">&#34; lr:&#34;</span><span class="p">,</span> <span class="nf">hex</span><span class="p">(</span><span class="nx">morebuf</span><span class="p">.</span><span class="nx">lr</span><span class="p">),</span> <span class="s">&#34;}\n&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">            <span class="s">&#34;\tsched={pc:&#34;</span><span class="p">,</span> <span class="nf">hex</span><span class="p">(</span><span class="nx">gp</span><span class="p">.</span><span class="nx">sched</span><span class="p">.</span><span class="nx">pc</span><span class="p">),</span> <span class="s">&#34; sp:&#34;</span><span class="p">,</span> <span class="nf">hex</span><span class="p">(</span><span class="nx">gp</span><span class="p">.</span><span class="nx">sched</span><span class="p">.</span><span class="nx">sp</span><span class="p">),</span> <span class="s">&#34; lr:&#34;</span><span class="p">,</span> <span class="nf">hex</span><span class="p">(</span><span class="nx">gp</span><span class="p">.</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lr</span><span class="p">),</span> <span class="s">&#34; ctxt:&#34;</span><span class="p">,</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">sched</span><span class="p">.</span><span class="nx">ctxt</span><span class="p">,</span> <span class="s">&#34;}\n&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="nx">thisg</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">traceback</span> <span class="p">=</span> <span class="mi">2</span> <span class="c1">// Include runtime frames
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nf">traceback</span><span class="p">(</span><span class="nx">morebuf</span><span class="p">.</span><span class="nx">pc</span><span class="p">,</span> <span class="nx">morebuf</span><span class="p">.</span><span class="nx">sp</span><span class="p">,</span> <span class="nx">morebuf</span><span class="p">.</span><span class="nx">lr</span><span class="p">,</span> <span class="nx">gp</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="nf">throw</span><span class="p">(</span><span class="s">&#34;runtime: stack split at bad time&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// m.morebuf 在上面的morestack函数中被设置为调用函数的相关信息。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">morebuf</span> <span class="o">:=</span> <span class="nx">thisg</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">morebuf</span>
</span></span><span class="line"><span class="cl">    <span class="nx">thisg</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">morebuf</span><span class="p">.</span><span class="nx">pc</span> <span class="p">=</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">    <span class="nx">thisg</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">morebuf</span><span class="p">.</span><span class="nx">lr</span> <span class="p">=</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">    <span class="nx">thisg</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">morebuf</span><span class="p">.</span><span class="nx">sp</span> <span class="p">=</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">    <span class="nx">thisg</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">morebuf</span><span class="p">.</span><span class="nx">g</span> <span class="p">=</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// NOTE: stackguard0 may change underfoot, if another thread
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// is about to try to preempt gp. Read it just once and use that same
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// value now and below.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 注意：如果另一个线程即将尝试抢占gp，stackguard0可能会在脚下发生变化。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 只需阅读一次并在现在和下面使用相同的值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">stackguard0</span> <span class="o">:=</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Loaduintptr</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">gp</span><span class="p">.</span><span class="nx">stackguard0</span><span class="p">)</span>  <span class="c1">// 获取gp.stackguard0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Be conservative about where we preempt.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// We are interested in preempting user Go code, not runtime code.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// If we&#39;re holding locks, mallocing, or preemption is disabled, don&#39;t
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// preempt.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// This check is very early in newstack so that even the status change
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// from Grunning to Gwaiting and back doesn&#39;t happen in this case.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// That status change by itself can be viewed as a small preemption,
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// because the GC might change Gwaiting to Gscanwaiting, and then
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// this goroutine has to wait for the GC to finish before continuing.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// If the GC is in some way dependent on this goroutine (for example,
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// it needs a lock held by the goroutine), that small preemption turns
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// into a real deadlock.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">preempt</span> <span class="o">:=</span> <span class="nx">stackguard0</span> <span class="o">==</span> <span class="nx">stackPreempt</span>  <span class="c1">// 判断当前是否真需要被抢占
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nx">preempt</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// canPreemptM -&gt; mp.locks == 0 &amp;&amp; mp.mallocing == 0 &amp;&amp; mp.preemptoff == &#34;&#34; &amp;&amp; mp.p.ptr().status == _Prunning
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="p">!</span><span class="nf">canPreemptM</span><span class="p">(</span><span class="nx">thisg</span><span class="p">.</span><span class="nx">m</span><span class="p">)</span> <span class="p">{</span>  <span class="c1">// canPreemptM(thisg.m); true.可以抢占; false.不允许抢占
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// 以下是【不允许】抢占时，再次恢复gp。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            
</span></span><span class="line"><span class="cl">            <span class="c1">// Let the goroutine keep running for now.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// gp-&gt;preempt is set, so it will be preempted next time.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// 现在让goroutine继续运行。gp-&gt;preempt已设置，因此下次将被抢占。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// (gp-&gt;preempt在前面已被设置为true)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// 还原stackguard0为正常值，表示我们已经处理过抢占请求了
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="nx">gp</span><span class="p">.</span><span class="nx">stackguard0</span> <span class="p">=</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">stack</span><span class="p">.</span><span class="nx">lo</span> <span class="o">+</span> <span class="nx">_StackGuard</span> 
</span></span><span class="line"><span class="cl">            <span class="c1">// 恢复gp，这里永远不会返回
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="nf">gogo</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">gp</span><span class="p">.</span><span class="nx">sched</span><span class="p">)</span> <span class="c1">// never return
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">stack</span><span class="p">.</span><span class="nx">lo</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">throw</span><span class="p">(</span><span class="s">&#34;missing stack in newstack&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nx">sp</span> <span class="o">:=</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">sched</span><span class="p">.</span><span class="nx">sp</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">goarch</span><span class="p">.</span><span class="nx">ArchFamily</span> <span class="o">==</span> <span class="nx">goarch</span><span class="p">.</span><span class="nx">AMD64</span> <span class="o">||</span> <span class="nx">goarch</span><span class="p">.</span><span class="nx">ArchFamily</span> <span class="o">==</span> <span class="nx">goarch</span><span class="p">.</span><span class="nx">I386</span> <span class="o">||</span> <span class="nx">goarch</span><span class="p">.</span><span class="nx">ArchFamily</span> <span class="o">==</span> <span class="nx">goarch</span><span class="p">.</span><span class="nx">WASM</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// The call to morestack cost a word.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">sp</span> <span class="o">-=</span> <span class="nx">goarch</span><span class="p">.</span><span class="nx">PtrSize</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">stackDebug</span> <span class="o">&gt;=</span> <span class="mi">1</span> <span class="o">||</span> <span class="nx">sp</span> <span class="p">&lt;</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">stack</span><span class="p">.</span><span class="nx">lo</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nb">print</span><span class="p">(</span><span class="s">&#34;runtime: newstack sp=&#34;</span><span class="p">,</span> <span class="nf">hex</span><span class="p">(</span><span class="nx">sp</span><span class="p">),</span> <span class="s">&#34; stack=[&#34;</span><span class="p">,</span> <span class="nf">hex</span><span class="p">(</span><span class="nx">gp</span><span class="p">.</span><span class="nx">stack</span><span class="p">.</span><span class="nx">lo</span><span class="p">),</span> <span class="s">&#34;, &#34;</span><span class="p">,</span> <span class="nf">hex</span><span class="p">(</span><span class="nx">gp</span><span class="p">.</span><span class="nx">stack</span><span class="p">.</span><span class="nx">hi</span><span class="p">),</span> <span class="s">&#34;]\n&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">            <span class="s">&#34;\tmorebuf={pc:&#34;</span><span class="p">,</span> <span class="nf">hex</span><span class="p">(</span><span class="nx">morebuf</span><span class="p">.</span><span class="nx">pc</span><span class="p">),</span> <span class="s">&#34; sp:&#34;</span><span class="p">,</span> <span class="nf">hex</span><span class="p">(</span><span class="nx">morebuf</span><span class="p">.</span><span class="nx">sp</span><span class="p">),</span> <span class="s">&#34; lr:&#34;</span><span class="p">,</span> <span class="nf">hex</span><span class="p">(</span><span class="nx">morebuf</span><span class="p">.</span><span class="nx">lr</span><span class="p">),</span> <span class="s">&#34;}\n&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">            <span class="s">&#34;\tsched={pc:&#34;</span><span class="p">,</span> <span class="nf">hex</span><span class="p">(</span><span class="nx">gp</span><span class="p">.</span><span class="nx">sched</span><span class="p">.</span><span class="nx">pc</span><span class="p">),</span> <span class="s">&#34; sp:&#34;</span><span class="p">,</span> <span class="nf">hex</span><span class="p">(</span><span class="nx">gp</span><span class="p">.</span><span class="nx">sched</span><span class="p">.</span><span class="nx">sp</span><span class="p">),</span> <span class="s">&#34; lr:&#34;</span><span class="p">,</span> <span class="nf">hex</span><span class="p">(</span><span class="nx">gp</span><span class="p">.</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lr</span><span class="p">),</span> <span class="s">&#34; ctxt:&#34;</span><span class="p">,</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">sched</span><span class="p">.</span><span class="nx">ctxt</span><span class="p">,</span> <span class="s">&#34;}\n&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">sp</span> <span class="p">&lt;</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">stack</span><span class="p">.</span><span class="nx">lo</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nb">print</span><span class="p">(</span><span class="s">&#34;runtime: gp=&#34;</span><span class="p">,</span> <span class="nx">gp</span><span class="p">,</span> <span class="s">&#34;, goid=&#34;</span><span class="p">,</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">goid</span><span class="p">,</span> <span class="s">&#34;, gp-&gt;status=&#34;</span><span class="p">,</span> <span class="nf">hex</span><span class="p">(</span><span class="nf">readgstatus</span><span class="p">(</span><span class="nx">gp</span><span class="p">)),</span> <span class="s">&#34;\n &#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="nb">print</span><span class="p">(</span><span class="s">&#34;runtime: split stack overflow: &#34;</span><span class="p">,</span> <span class="nf">hex</span><span class="p">(</span><span class="nx">sp</span><span class="p">),</span> <span class="s">&#34; &lt; &#34;</span><span class="p">,</span> <span class="nf">hex</span><span class="p">(</span><span class="nx">gp</span><span class="p">.</span><span class="nx">stack</span><span class="p">.</span><span class="nx">lo</span><span class="p">),</span> <span class="s">&#34;\n&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="nf">throw</span><span class="p">(</span><span class="s">&#34;runtime: split stack overflow&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 判断抢占，发起抢占
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nx">preempt</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="nx">gp</span> <span class="o">==</span> <span class="nx">thisg</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">g0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nf">throw</span><span class="p">(</span><span class="s">&#34;runtime: preempt g0&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="nx">thisg</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">p</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">thisg</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">locks</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nf">throw</span><span class="p">(</span><span class="s">&#34;runtime: g is running but p is not&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">preemptShrink</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// We&#39;re at a synchronous safe point now, so
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// do the pending stack shrink.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="nx">gp</span><span class="p">.</span><span class="nx">preemptShrink</span> <span class="p">=</span> <span class="kc">false</span>
</span></span><span class="line"><span class="cl">            <span class="nf">shrinkstack</span><span class="p">(</span><span class="nx">gp</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// 停止抢占，开启下一次调度循环,makeroot期间改值会被设置为true。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">preemptStop</span> <span class="p">{</span>	
</span></span><span class="line"><span class="cl">            <span class="nf">preemptPark</span><span class="p">(</span><span class="nx">gp</span><span class="p">)</span> <span class="c1">// never returns
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// Act like goroutine called runtime.Gosched.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 像调用 runtime.Gosched 的 goroutine 一样
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 调用gopreempt_m把gp切换出去，抢占这个goroutine成功了
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nf">gopreempt_m</span><span class="p">(</span><span class="nx">gp</span><span class="p">)</span> <span class="c1">// never return
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 下面代码是扩大栈相关代码
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    
</span></span><span class="line"><span class="cl">    <span class="c1">// Allocate a bigger segment and move the stack.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">oldsize</span> <span class="o">:=</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">stack</span><span class="p">.</span><span class="nx">hi</span> <span class="o">-</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">stack</span><span class="p">.</span><span class="nx">lo</span>
</span></span><span class="line"><span class="cl">    <span class="nx">newsize</span> <span class="o">:=</span> <span class="nx">oldsize</span> <span class="o">*</span> <span class="mi">2</span> <span class="c1">// 扩大为原来的2倍
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Make sure we grow at least as much as needed to fit the new frame.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// (This is just an optimization - the caller of morestack will
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// recheck the bounds on return.)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nx">f</span> <span class="o">:=</span> <span class="nf">findfunc</span><span class="p">(</span><span class="nx">gp</span><span class="p">.</span><span class="nx">sched</span><span class="p">.</span><span class="nx">pc</span><span class="p">);</span> <span class="nx">f</span><span class="p">.</span><span class="nf">valid</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">max</span> <span class="o">:=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nf">funcMaxSPDelta</span><span class="p">(</span><span class="nx">f</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">        <span class="nx">needed</span> <span class="o">:=</span> <span class="nx">max</span> <span class="o">+</span> <span class="nx">_StackGuard</span>
</span></span><span class="line"><span class="cl">        <span class="nx">used</span> <span class="o">:=</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">stack</span><span class="p">.</span><span class="nx">hi</span> <span class="o">-</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">sched</span><span class="p">.</span><span class="nx">sp</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="nx">newsize</span><span class="o">-</span><span class="nx">used</span> <span class="p">&lt;</span> <span class="nx">needed</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nx">newsize</span> <span class="o">*=</span> <span class="mi">2</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">stackguard0</span> <span class="o">==</span> <span class="nx">stackForceMove</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// Forced stack movement used for debugging.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// Don&#39;t double the stack (or we may quickly run out
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// if this is done repeatedly).
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">newsize</span> <span class="p">=</span> <span class="nx">oldsize</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">newsize</span> <span class="p">&gt;</span> <span class="nx">maxstacksize</span> <span class="o">||</span> <span class="nx">newsize</span> <span class="p">&gt;</span> <span class="nx">maxstackceiling</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="nx">maxstacksize</span> <span class="p">&lt;</span> <span class="nx">maxstackceiling</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nb">print</span><span class="p">(</span><span class="s">&#34;runtime: goroutine stack exceeds &#34;</span><span class="p">,</span> <span class="nx">maxstacksize</span><span class="p">,</span> <span class="s">&#34;-byte limit\n&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nb">print</span><span class="p">(</span><span class="s">&#34;runtime: goroutine stack exceeds &#34;</span><span class="p">,</span> <span class="nx">maxstackceiling</span><span class="p">,</span> <span class="s">&#34;-byte limit\n&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="nb">print</span><span class="p">(</span><span class="s">&#34;runtime: sp=&#34;</span><span class="p">,</span> <span class="nf">hex</span><span class="p">(</span><span class="nx">sp</span><span class="p">),</span> <span class="s">&#34; stack=[&#34;</span><span class="p">,</span> <span class="nf">hex</span><span class="p">(</span><span class="nx">gp</span><span class="p">.</span><span class="nx">stack</span><span class="p">.</span><span class="nx">lo</span><span class="p">),</span> <span class="s">&#34;, &#34;</span><span class="p">,</span> <span class="nf">hex</span><span class="p">(</span><span class="nx">gp</span><span class="p">.</span><span class="nx">stack</span><span class="p">.</span><span class="nx">hi</span><span class="p">),</span> <span class="s">&#34;]\n&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="nf">throw</span><span class="p">(</span><span class="s">&#34;stack overflow&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// The goroutine must be executing in order to call newstack,
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// so it must be Grunning (or Gscanrunning).
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">casgstatus</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="nx">_Grunning</span><span class="p">,</span> <span class="nx">_Gcopystack</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// The concurrent GC will not scan the stack while we are doing the copy since
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// the gp is in a Gcopystack status.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">copystack</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="nx">newsize</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">stackDebug</span> <span class="o">&gt;=</span> <span class="mi">1</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nb">print</span><span class="p">(</span><span class="s">&#34;stack grow done\n&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nf">casgstatus</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="nx">_Gcopystack</span><span class="p">,</span> <span class="nx">_Grunning</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nf">gogo</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">gp</span><span class="p">.</span><span class="nx">sched</span><span class="p">)</span> <span class="c1">// 再次恢复这个goroutine
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="canpreemptm">canPreemptM<a hidden class="anchor" aria-hidden="true" href="#canpreemptm">#</a></h4>
<ol>
<li><code>canPreemptM</code>报告<code>mp</code>是否处于可以安全抢占的状态。</li>
<li>它是<code>nosplit</code>因为它有<code>nosplit</code>的调用者。</li>
<li><strong>go:nosplit</strong>：告诉编译器不要在当前函数中插入任何栈扩展代码，这样可以确保当前函数不会导致栈的大小发生变化。
<ol>
<li>在<code>Go</code>语言中，每个<code>goroutine</code>都有一个固定的栈大小，当栈的大小不足以容纳当前函数的执行时，就会发生栈溢出错误。</li>
<li>因此，使用<code>&quot;go:nosplit&quot;</code>指令可以确保函数的执行不会导致栈的大小发生变化，从而避免栈溢出错误的发生。这个指令通常用于一些关键性的函数中，比如垃圾回收器和调度器等。</li>
<li>需要注意的是，使用<code>&quot;go:nosplit&quot;</code>指令可能会影响程序的性能。因为不再插入栈扩展代码，这意味着在执行函数时，栈的大小不会动态调整。因此，程序员需要在使用<code>&quot;go:nosplit&quot;</code>指令时仔细考虑性能和栈溢出错误之间的权衡。</li>
</ol>
</li>
<li>文件位置：go1.19.3/src/runtime/preempt.go。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">282
</span><span class="lnt">283
</span><span class="lnt">284
</span><span class="lnt">285
</span><span class="lnt">286
</span><span class="lnt">287
</span><span class="lnt">288
</span><span class="lnt">289
</span><span class="lnt">290
</span><span class="lnt">291
</span><span class="lnt">292
</span><span class="lnt">293
</span><span class="lnt">294
</span><span class="lnt">295
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// canPreemptM reports whether mp is in a state that is safe to preempt.
</span></span></span><span class="line"><span class="cl"><span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1">// It is nosplit because it has nosplit callers.
</span></span></span><span class="line"><span class="cl"><span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1">//go:nosplit
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">canPreemptM</span><span class="p">(</span><span class="nx">mp</span> <span class="o">*</span><span class="nx">m</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 能否抢占条件：true.能抢占，false.不能抢占。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//  1. mp.locks == 0：表示当前goroutine持有的互斥锁数量，没到0时，不应该被抢占。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//  2. mp.mallocing == 0：当前goroutine正在分配内存，不应该被抢占。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//  3. mp.preemptoff：如果该值被设置为非空字符串，则表示当前goroutine不应该被抢占。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//  4. mp.p.ptr().status == _Prunning：当前P正在运行中。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 满足以上条件则能抢占g。该函数也会在信号抢占函数isAsyncPreempt()函数中调用，用于判断是否允许抢占
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">return</span> <span class="nx">mp</span><span class="p">.</span><span class="nx">locks</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">mp</span><span class="p">.</span><span class="nx">mallocing</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">mp</span><span class="p">.</span><span class="nx">preemptoff</span> <span class="o">==</span> <span class="s">&#34;&#34;</span> <span class="o">&amp;&amp;</span> <span class="nx">mp</span><span class="p">.</span><span class="nx">p</span><span class="p">.</span><span class="nf">ptr</span><span class="p">().</span><span class="nx">status</span> <span class="o">==</span> <span class="nx">_Prunning</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="gopreempt_m">gopreempt_m<a hidden class="anchor" aria-hidden="true" href="#gopreempt_m">#</a></h4>
<ol>
<li>抢占调度，后逻辑和<code>runtime.Gosched</code>一样。</li>
<li>文件位置：go1.19.3/src/runtime/proc.go。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">3402
</span><span class="lnt">3403
</span><span class="lnt">3404
</span><span class="lnt">3405
</span><span class="lnt">3406
</span><span class="lnt">3407
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">gopreempt_m</span><span class="p">(</span><span class="nx">gp</span> <span class="o">*</span><span class="nx">g</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">trace</span><span class="p">.</span><span class="nx">enabled</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">traceGoPreempt</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nf">goschedImpl</span><span class="p">(</span><span class="nx">gp</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="系统调用前后">系统调用前后<a hidden class="anchor" aria-hidden="true" href="#系统调用前后">#</a></h2>
<ol>
<li><code>handoffp()</code>，<strong>对正在进行系统调用的goroutine的抢占实质上是剥夺与其对应的工作线程所绑定的p</strong>。</li>
<li>虽然说处于系统调用之中的工作线程并不需要<code>p</code>，但一旦从操作系统内核返回到用户空间之后就必须绑定一个<code>p</code>才能运行<code>go</code>代码。</li>
</ol>
<h3 id="系统调用">系统调用<a hidden class="anchor" aria-hidden="true" href="#系统调用">#</a></h3>
<h4 id="syscall6">Syscall6()<a hidden class="anchor" aria-hidden="true" href="#syscall6">#</a></h4>
<ol>
<li>系统调用时<strong>最终</strong>会调用该汇编函数。</li>
<li>文件位置：go1.19.3/src/syscall/asm_unix_amd64.s。</li>
<li>函数原型：<code>func Syscall6(num, a1, a2, a3, a4, a5, a6 uintptr) (r1, r2, errno uintptr)</code>。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-asm" data-lang="asm"><span class="line"><span class="cl"><span class="nf">TEXT</span>    <span class="err">·</span><span class="no">Syscall6</span><span class="p">(</span><span class="no">SB</span><span class="p">),</span><span class="no">NOSPLIT</span><span class="p">,</span><span class="no">$0-80</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># 调用 runtime.entersyscall 函数，保存现场解除绑定关系
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">CALL</span>    <span class="no">runtime</span><span class="err">·</span><span class="no">entersyscall</span><span class="err">&lt;</span><span class="no">ABIInternal</span><span class="err">&gt;</span><span class="p">(</span><span class="no">SB</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># 系统调用参数，按照linux系统约定寄存器并调用SYSCALL执行进入内核。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1"># 系统调用编号放入AX。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">MOVQ</span>    <span class="no">trap</span><span class="err">+</span><span class="mi">0</span><span class="p">(</span><span class="no">FP</span><span class="p">),</span> <span class="no">AX</span>  <span class="c1"># syscall entry
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">MOVQ</span>    <span class="no">a1</span><span class="err">+</span><span class="mi">8</span><span class="p">(</span><span class="no">FP</span><span class="p">),</span> <span class="no">DI</span>
</span></span><span class="line"><span class="cl">    <span class="nf">MOVQ</span>    <span class="no">a2</span><span class="err">+</span><span class="mi">16</span><span class="p">(</span><span class="no">FP</span><span class="p">),</span> <span class="no">SI</span>
</span></span><span class="line"><span class="cl">    <span class="nf">MOVQ</span>    <span class="no">a3</span><span class="err">+</span><span class="mi">24</span><span class="p">(</span><span class="no">FP</span><span class="p">),</span> <span class="no">DX</span>
</span></span><span class="line"><span class="cl">    <span class="nf">MOVQ</span>    <span class="no">a4</span><span class="err">+</span><span class="mi">32</span><span class="p">(</span><span class="no">FP</span><span class="p">),</span> <span class="no">R10</span>
</span></span><span class="line"><span class="cl">    <span class="nf">MOVQ</span>    <span class="no">a5</span><span class="err">+</span><span class="mi">40</span><span class="p">(</span><span class="no">FP</span><span class="p">),</span> <span class="no">R8</span>
</span></span><span class="line"><span class="cl">    <span class="nf">MOVQ</span>    <span class="no">a6</span><span class="err">+</span><span class="mi">48</span><span class="p">(</span><span class="no">FP</span><span class="p">),</span> <span class="no">R9</span>
</span></span><span class="line"><span class="cl">    <span class="nf">SYSCALL</span> <span class="c1"># 进入内核
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1"># 从内核返回，判断标识是否跳转
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">JCC</span>	<span class="no">ok6</span>
</span></span><span class="line"><span class="cl">    <span class="nf">MOVQ</span>    <span class="no">$-1</span><span class="p">,</span> <span class="no">r1</span><span class="err">+</span><span class="mi">56</span><span class="p">(</span><span class="no">FP</span><span class="p">)</span>  <span class="c1"># r1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">MOVQ</span>    <span class="no">$0</span><span class="p">,</span> <span class="no">r2</span><span class="err">+</span><span class="mi">64</span><span class="p">(</span><span class="no">FP</span><span class="p">)</span>   <span class="c1"># r2
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">MOVQ</span>    <span class="no">AX</span><span class="p">,</span> <span class="no">err</span><span class="err">+</span><span class="mi">72</span><span class="p">(</span><span class="no">FP</span><span class="p">)</span>  <span class="c1"># errno
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">CALL</span>    <span class="no">runtime</span><span class="err">·</span><span class="no">exitsyscall</span><span class="err">&lt;</span><span class="no">ABIInternal</span><span class="err">&gt;</span><span class="p">(</span><span class="no">SB</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nf">RET</span>
</span></span><span class="line"><span class="cl"><span class="nl">ok6:</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># 系统调用返回的值保存栈
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">MOVQ</span>    <span class="no">AX</span><span class="p">,</span> <span class="no">r1</span><span class="err">+</span><span class="mi">56</span><span class="p">(</span><span class="no">FP</span><span class="p">)</span>   <span class="c1"># r1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">MOVQ</span>    <span class="no">DX</span><span class="p">,</span> <span class="no">r2</span><span class="err">+</span><span class="mi">64</span><span class="p">(</span><span class="no">FP</span><span class="p">)</span>   <span class="c1"># r2
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">MOVQ</span>    <span class="no">$0</span><span class="p">,</span> <span class="no">err</span><span class="err">+</span><span class="mi">72</span><span class="p">(</span><span class="no">FP</span><span class="p">)</span>  <span class="c1"># errno
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">CALL</span>    <span class="no">runtime</span><span class="err">·</span><span class="no">exitsyscall</span><span class="err">&lt;</span><span class="no">ABIInternal</span><span class="err">&gt;</span><span class="p">(</span><span class="no">SB</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nf">RET</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="系统调用前">系统调用前<a hidden class="anchor" aria-hidden="true" href="#系统调用前">#</a></h3>
<h4 id="entersyscall">entersyscall()<a hidden class="anchor" aria-hidden="true" href="#entersyscall">#</a></h4>
<ol>
<li><code>go</code>系统调用库和普通<code>cgo</code>调用使用的标准系统调用项。</li>
<li>这是通过<code>syscall</code>包和<code>x/sys</code>中的链接名导出到程序集的。</li>
<li>文件位置：go1.19.3/src/runtime/proc.go。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">3672
</span><span class="lnt">3673
</span><span class="lnt">3674
</span><span class="lnt">3675
</span><span class="lnt">3676
</span><span class="lnt">3677
</span><span class="lnt">3678
</span><span class="lnt">3679
</span><span class="lnt">3680
</span><span class="lnt">3681
</span><span class="lnt">3682
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// Standard syscall entry used by the go syscall library and normal cgo calls.
</span></span></span><span class="line"><span class="cl"><span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1">// This is exported via linkname to assembly in the syscall package and x/sys.
</span></span></span><span class="line"><span class="cl"><span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1">//go:nosplit
</span></span></span><span class="line"><span class="cl"><span class="c1">//go:linkname entersyscall
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">entersyscall</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// getcallerpc()：调用者当前PC值。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// getcallersp()：调用者当前SP值。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">reentersyscall</span><span class="p">(</span><span class="nf">getcallerpc</span><span class="p">(),</span> <span class="nf">getcallersp</span><span class="p">())</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="reentersyscall">reentersyscall()<a hidden class="anchor" aria-hidden="true" href="#reentersyscall">#</a></h4>
<ol>
<li>文件位置：go1.19.3/src/runtime/proc.go。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">3575
</span><span class="lnt">3576
</span><span class="lnt">3577
</span><span class="lnt">3578
</span><span class="lnt">3579
</span><span class="lnt">3580
</span><span class="lnt">3581
</span><span class="lnt">3582
</span><span class="lnt">3583
</span><span class="lnt">3584
</span><span class="lnt">3585
</span><span class="lnt">3586
</span><span class="lnt">3587
</span><span class="lnt">3588
</span><span class="lnt">3589
</span><span class="lnt">3590
</span><span class="lnt">3591
</span><span class="lnt">3592
</span><span class="lnt">3593
</span><span class="lnt">3594
</span><span class="lnt">3595
</span><span class="lnt">3596
</span><span class="lnt">3597
</span><span class="lnt">3598
</span><span class="lnt">3599
</span><span class="lnt">3600
</span><span class="lnt">3601
</span><span class="lnt">3602
</span><span class="lnt">3603
</span><span class="lnt">3604
</span><span class="lnt">3605
</span><span class="lnt">3606
</span><span class="lnt">3607
</span><span class="lnt">3608
</span><span class="lnt">3609
</span><span class="lnt">3610
</span><span class="lnt">3611
</span><span class="lnt">3612
</span><span class="lnt">3613
</span><span class="lnt">3614
</span><span class="lnt">3615
</span><span class="lnt">3616
</span><span class="lnt">3617
</span><span class="lnt">3618
</span><span class="lnt">3619
</span><span class="lnt">3620
</span><span class="lnt">3621
</span><span class="lnt">3622
</span><span class="lnt">3623
</span><span class="lnt">3624
</span><span class="lnt">3625
</span><span class="lnt">3626
</span><span class="lnt">3627
</span><span class="lnt">3628
</span><span class="lnt">3629
</span><span class="lnt">3630
</span><span class="lnt">3631
</span><span class="lnt">3632
</span><span class="lnt">3633
</span><span class="lnt">3634
</span><span class="lnt">3635
</span><span class="lnt">3636
</span><span class="lnt">3637
</span><span class="lnt">3638
</span><span class="lnt">3639
</span><span class="lnt">3640
</span><span class="lnt">3641
</span><span class="lnt">3642
</span><span class="lnt">3643
</span><span class="lnt">3644
</span><span class="lnt">3645
</span><span class="lnt">3646
</span><span class="lnt">3647
</span><span class="lnt">3648
</span><span class="lnt">3649
</span><span class="lnt">3650
</span><span class="lnt">3651
</span><span class="lnt">3652
</span><span class="lnt">3653
</span><span class="lnt">3654
</span><span class="lnt">3655
</span><span class="lnt">3656
</span><span class="lnt">3657
</span><span class="lnt">3658
</span><span class="lnt">3659
</span><span class="lnt">3660
</span><span class="lnt">3661
</span><span class="lnt">3662
</span><span class="lnt">3663
</span><span class="lnt">3664
</span><span class="lnt">3665
</span><span class="lnt">3666
</span><span class="lnt">3667
</span><span class="lnt">3668
</span><span class="lnt">3669
</span><span class="lnt">3670
</span><span class="lnt">3671
</span><span class="lnt">3672
</span><span class="lnt">3673
</span><span class="lnt">3674
</span><span class="lnt">3675
</span><span class="lnt">3676
</span><span class="lnt">3677
</span><span class="lnt">3678
</span><span class="lnt">3679
</span><span class="lnt">3680
</span><span class="lnt">3681
</span><span class="lnt">3682
</span><span class="lnt">3683
</span><span class="lnt">3684
</span><span class="lnt">3685
</span><span class="lnt">3686
</span><span class="lnt">3687
</span><span class="lnt">3688
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// The goroutine g is about to enter a system call.
</span></span></span><span class="line"><span class="cl"><span class="c1">// Record that it&#39;s not using the cpu anymore.
</span></span></span><span class="line"><span class="cl"><span class="c1">// This is called only from the go syscall library and cgocall,
</span></span></span><span class="line"><span class="cl"><span class="c1">// not from the low-level system calls used by the runtime.
</span></span></span><span class="line"><span class="cl"><span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1">// Entersyscall cannot split the stack: the save must
</span></span></span><span class="line"><span class="cl"><span class="c1">// make g-&gt;sched refer to the caller&#39;s stack segment, because
</span></span></span><span class="line"><span class="cl"><span class="c1">// entersyscall is going to return immediately after.
</span></span></span><span class="line"><span class="cl"><span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1">// Nothing entersyscall calls can split the stack either.
</span></span></span><span class="line"><span class="cl"><span class="c1">// We cannot safely move the stack during an active call to syscall,
</span></span></span><span class="line"><span class="cl"><span class="c1">// because we do not know which of the uintptr arguments are
</span></span></span><span class="line"><span class="cl"><span class="c1">// really pointers (back into the stack).
</span></span></span><span class="line"><span class="cl"><span class="c1">// In practice, this means that we make the fast path run through
</span></span></span><span class="line"><span class="cl"><span class="c1">// entersyscall doing no-split things, and the slow path has to use systemstack
</span></span></span><span class="line"><span class="cl"><span class="c1">// to run bigger things on the system stack.
</span></span></span><span class="line"><span class="cl"><span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1">// reentersyscall is the entry point used by cgo callbacks, where explicitly
</span></span></span><span class="line"><span class="cl"><span class="c1">// saved SP and PC are restored. This is needed when exitsyscall will be called
</span></span></span><span class="line"><span class="cl"><span class="c1">// from a function further up in the call stack than the parent, as g-&gt;syscallsp
</span></span></span><span class="line"><span class="cl"><span class="c1">// must always point to a valid stack frame. entersyscall below is the normal
</span></span></span><span class="line"><span class="cl"><span class="c1">// entry point for syscalls, which obtains the SP and PC from the caller.
</span></span></span><span class="line"><span class="cl"><span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1">// Syscall tracing:
</span></span></span><span class="line"><span class="cl"><span class="c1">// At the start of a syscall we emit traceGoSysCall to capture the stack trace.
</span></span></span><span class="line"><span class="cl"><span class="c1">// If the syscall does not block, that is it, we do not emit any other events.
</span></span></span><span class="line"><span class="cl"><span class="c1">// If the syscall blocks (that is, P is retaken), retaker emits traceGoSysBlock;
</span></span></span><span class="line"><span class="cl"><span class="c1">// when syscall returns we emit traceGoSysExit and when the goroutine starts running
</span></span></span><span class="line"><span class="cl"><span class="c1">// (potentially instantly, if exitsyscallfast returns true) we emit traceGoStart.
</span></span></span><span class="line"><span class="cl"><span class="c1">// To ensure that traceGoSysExit is emitted strictly after traceGoSysBlock,
</span></span></span><span class="line"><span class="cl"><span class="c1">// we remember current value of syscalltick in m (_g_.m.syscalltick = _g_.m.p.ptr().syscalltick),
</span></span></span><span class="line"><span class="cl"><span class="c1">// whoever emits traceGoSysBlock increments p.syscalltick afterwards;
</span></span></span><span class="line"><span class="cl"><span class="c1">// and we wait for the increment before emitting traceGoSysExit.
</span></span></span><span class="line"><span class="cl"><span class="c1">// Note that the increment is done even if tracing is not enabled,
</span></span></span><span class="line"><span class="cl"><span class="c1">// because tracing can be enabled in the middle of syscall. We don&#39;t want the wait to hang.
</span></span></span><span class="line"><span class="cl"><span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1">//go:nosplit
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">reentersyscall</span><span class="p">(</span><span class="nx">pc</span><span class="p">,</span> <span class="nx">sp</span> <span class="kt">uintptr</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// user goroutine
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">_g_</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">()</span> <span class="c1">// 执行系统调用的goroutine
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Disable preemption because during this function g is in Gsyscall status,
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// but can have inconsistent g-&gt;sched, do not let GC observe it.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 禁用抢占，因为在这个功能期间g处于Gsyscall状态，但可能有不一致的g-&gt;sched，不要让GC观察它。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">locks</span><span class="o">++</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// Entersyscall must not call any function that might split/grow the stack.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// (See details in comment above.)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// Catch calls that might, by replacing the stack guard with something that
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// will trip any stack check and leaving a flag to tell newstack to die.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">_g_</span><span class="p">.</span><span class="nx">stackguard0</span> <span class="p">=</span> <span class="nx">stackPreempt</span> <span class="c1">// 设置抢占，在调用返回时会修改回来
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 不能扩展栈，在调用返回时会修改回来
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">_g_</span><span class="p">.</span><span class="nx">throwsplit</span> <span class="p">=</span> <span class="kc">true</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// Leave SP around for GC and traceback.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">save</span><span class="p">(</span><span class="nx">pc</span><span class="p">,</span> <span class="nx">sp</span><span class="p">)</span> <span class="c1">// 保存g的现场信息，rsp，rbp，rip等
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">_g_</span><span class="p">.</span><span class="nx">syscallsp</span> <span class="p">=</span> <span class="nx">sp</span>
</span></span><span class="line"><span class="cl">    <span class="nx">_g_</span><span class="p">.</span><span class="nx">syscallpc</span> <span class="p">=</span> <span class="nx">pc</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 监控线程依赖_Gsyscall状态实施系统调用时的抢占
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">casgstatus</span><span class="p">(</span><span class="nx">_g_</span><span class="p">,</span> <span class="nx">_Grunning</span><span class="p">,</span> <span class="nx">_Gsyscall</span><span class="p">)</span> <span class="c1">// 切换g状态为系统调用中
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// SP是否在goroutine的栈范围内
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">syscallsp</span> <span class="p">&lt;</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">stack</span><span class="p">.</span><span class="nx">lo</span> <span class="o">||</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">stack</span><span class="p">.</span><span class="nx">hi</span> <span class="p">&lt;</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">syscallsp</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">systemstack</span><span class="p">(</span><span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nb">print</span><span class="p">(</span><span class="s">&#34;entersyscall inconsistent &#34;</span><span class="p">,</span> <span class="nf">hex</span><span class="p">(</span><span class="nx">_g_</span><span class="p">.</span><span class="nx">syscallsp</span><span class="p">),</span> <span class="s">&#34; [&#34;</span><span class="p">,</span> <span class="nf">hex</span><span class="p">(</span><span class="nx">_g_</span><span class="p">.</span><span class="nx">stack</span><span class="p">.</span><span class="nx">lo</span><span class="p">),</span> <span class="s">&#34;,&#34;</span><span class="p">,</span> <span class="nf">hex</span><span class="p">(</span><span class="nx">_g_</span><span class="p">.</span><span class="nx">stack</span><span class="p">.</span><span class="nx">hi</span><span class="p">),</span> <span class="s">&#34;]\n&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="nf">throw</span><span class="p">(</span><span class="s">&#34;entersyscall&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="p">})</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">trace</span><span class="p">.</span><span class="nx">enabled</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">systemstack</span><span class="p">(</span><span class="nx">traceGoSysCall</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// systemstack itself clobbers g.sched.{pc,sp} and we might
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// need them later when the G is genuinely blocked in a
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// syscall
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nf">save</span><span class="p">(</span><span class="nx">pc</span><span class="p">,</span> <span class="nx">sp</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// sysmon 监控线程正挂起在 sched.sysmonwait
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Load</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">sysmonwait</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 切换到g0栈调用 entersyscall_sysmon 函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// entersyscall_sysmon 函数唤醒 sysmon 监控线程
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nf">systemstack</span><span class="p">(</span><span class="nx">entersyscall_sysmon</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="nf">save</span><span class="p">(</span><span class="nx">pc</span><span class="p">,</span> <span class="nx">sp</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">p</span><span class="p">.</span><span class="nf">ptr</span><span class="p">().</span><span class="nx">runSafePointFn</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// runSafePointFn may stack split if run on this stack
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nf">systemstack</span><span class="p">(</span><span class="nx">runSafePointFn</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="nf">save</span><span class="p">(</span><span class="nx">pc</span><span class="p">,</span> <span class="nx">sp</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 把P的调用次数拷贝给M
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">syscalltick</span> <span class="p">=</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">p</span><span class="p">.</span><span class="nf">ptr</span><span class="p">().</span><span class="nx">syscalltick</span>
</span></span><span class="line"><span class="cl">    <span class="nx">_g_</span><span class="p">.</span><span class="nx">sysblocktraced</span> <span class="p">=</span> <span class="kc">true</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// M和P相互解除关联，并把P暂存与m.oldp中，
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 等待系统调用完后使用
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 解除p.m关联的m
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">pp</span> <span class="o">:=</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">p</span><span class="p">.</span><span class="nf">ptr</span><span class="p">()</span> <span class="c1">// pp = p
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">pp</span><span class="p">.</span><span class="nx">m</span> <span class="p">=</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// m.oldp = pp
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">oldp</span><span class="p">.</span><span class="nf">set</span><span class="p">(</span><span class="nx">pp</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 解除 m.p 的关系 p
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">p</span> <span class="p">=</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">    <span class="nx">atomic</span><span class="p">.</span><span class="nf">Store</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">pp</span><span class="p">.</span><span class="nx">status</span><span class="p">,</span> <span class="nx">_Psyscall</span><span class="p">)</span> <span class="c1">// pp.status = _Psyscall
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// STW正在等待时
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nx">sched</span><span class="p">.</span><span class="nx">gcwaiting</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 切换到g0栈调用entersyscall_gcwait函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// entersyscall_gcwait函数，将P状态设置为 _Pgcstop，如果STW已完成则唤醒在sched.stopnote上等待的STW发起的线程。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nf">systemstack</span><span class="p">(</span><span class="nx">entersyscall_gcwait</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="nf">save</span><span class="p">(</span><span class="nx">pc</span><span class="p">,</span> <span class="nx">sp</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">locks</span><span class="o">--</span> 
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="save">save()<a hidden class="anchor" aria-hidden="true" href="#save">#</a></h4>
<ol>
<li>保存<code>goroutine</code>现场。</li>
<li>文件位置：go1.19.3/src/runtime/proc.go。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">3543
</span><span class="lnt">3544
</span><span class="lnt">3545
</span><span class="lnt">3546
</span><span class="lnt">3547
</span><span class="lnt">3548
</span><span class="lnt">3549
</span><span class="lnt">3550
</span><span class="lnt">3551
</span><span class="lnt">3552
</span><span class="lnt">3553
</span><span class="lnt">3554
</span><span class="lnt">3555
</span><span class="lnt">3556
</span><span class="lnt">3557
</span><span class="lnt">3558
</span><span class="lnt">3559
</span><span class="lnt">3560
</span><span class="lnt">3561
</span><span class="lnt">3562
</span><span class="lnt">3563
</span><span class="lnt">3564
</span><span class="lnt">3565
</span><span class="lnt">3566
</span><span class="lnt">3567
</span><span class="lnt">3568
</span><span class="lnt">3569
</span><span class="lnt">3570
</span><span class="lnt">3571
</span><span class="lnt">3572
</span><span class="lnt">3573
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// save updates getg().sched to refer to pc and sp so that a following
</span></span></span><span class="line"><span class="cl"><span class="c1">// gogo will restore pc and sp.
</span></span></span><span class="line"><span class="cl"><span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1">// save must not have write barriers because invoking a write barrier
</span></span></span><span class="line"><span class="cl"><span class="c1">// can clobber getg().sched.
</span></span></span><span class="line"><span class="cl"><span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1">//go:nosplit
</span></span></span><span class="line"><span class="cl"><span class="c1">//go:nowritebarrierrec
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">save</span><span class="p">(</span><span class="nx">pc</span><span class="p">,</span> <span class="nx">sp</span> <span class="kt">uintptr</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">gp</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">gp</span> <span class="o">==</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">g0</span> <span class="o">||</span> <span class="nx">gp</span> <span class="o">==</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">gsignal</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// m.g0.sched is special and must describe the context
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// for exiting the thread. mstart1 writes to it directly.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// m.gsignal.sched should not be used at all.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// This check makes sure save calls do not accidentally
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// run in contexts where they&#39;d write to system g&#39;s.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nf">throw</span><span class="p">(</span><span class="s">&#34;save on system g not allowed&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nx">gp</span><span class="p">.</span><span class="nx">sched</span><span class="p">.</span><span class="nx">pc</span> <span class="p">=</span> <span class="nx">pc</span>
</span></span><span class="line"><span class="cl">    <span class="nx">gp</span><span class="p">.</span><span class="nx">sched</span><span class="p">.</span><span class="nx">sp</span> <span class="p">=</span> <span class="nx">sp</span>
</span></span><span class="line"><span class="cl">    <span class="nx">gp</span><span class="p">.</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lr</span> <span class="p">=</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">    <span class="nx">gp</span><span class="p">.</span><span class="nx">sched</span><span class="p">.</span><span class="nx">ret</span> <span class="p">=</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// We need to ensure ctxt is zero, but can&#39;t have a write
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// barrier here. However, it should always already be zero.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// Assert that.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">sched</span><span class="p">.</span><span class="nx">ctxt</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">badctxt</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="系统调用后">系统调用后<a hidden class="anchor" aria-hidden="true" href="#系统调用后">#</a></h3>
<h4 id="exitsyscall">exitsyscall()<a hidden class="anchor" aria-hidden="true" href="#exitsyscall">#</a></h4>
<ol>
<li>这个<code>goroutine g</code>退出系统调用。安排它再次在<code>cpu</code>上运行。</li>
<li>这仅从<code>go</code>系统调用库中调用，而不是从运行时使用的低级系统调用中调用。</li>
<li>写屏障是不被允许的，因为我们的<code>P</code>可能被偷了。</li>
<li>文件位置：go1.19.3/src/runtime/proc.go。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">3761
</span><span class="lnt">3762
</span><span class="lnt">3763
</span><span class="lnt">3764
</span><span class="lnt">3765
</span><span class="lnt">3766
</span><span class="lnt">3767
</span><span class="lnt">3768
</span><span class="lnt">3769
</span><span class="lnt">3770
</span><span class="lnt">3771
</span><span class="lnt">3772
</span><span class="lnt">3773
</span><span class="lnt">3774
</span><span class="lnt">3775
</span><span class="lnt">3776
</span><span class="lnt">3777
</span><span class="lnt">3778
</span><span class="lnt">3779
</span><span class="lnt">3780
</span><span class="lnt">3781
</span><span class="lnt">3782
</span><span class="lnt">3783
</span><span class="lnt">3784
</span><span class="lnt">3785
</span><span class="lnt">3786
</span><span class="lnt">3787
</span><span class="lnt">3788
</span><span class="lnt">3789
</span><span class="lnt">3790
</span><span class="lnt">3791
</span><span class="lnt">3792
</span><span class="lnt">3793
</span><span class="lnt">3794
</span><span class="lnt">3795
</span><span class="lnt">3796
</span><span class="lnt">3797
</span><span class="lnt">3798
</span><span class="lnt">3799
</span><span class="lnt">3800
</span><span class="lnt">3801
</span><span class="lnt">3802
</span><span class="lnt">3803
</span><span class="lnt">3804
</span><span class="lnt">3805
</span><span class="lnt">3806
</span><span class="lnt">3807
</span><span class="lnt">3808
</span><span class="lnt">3809
</span><span class="lnt">3810
</span><span class="lnt">3811
</span><span class="lnt">3812
</span><span class="lnt">3813
</span><span class="lnt">3814
</span><span class="lnt">3815
</span><span class="lnt">3816
</span><span class="lnt">3817
</span><span class="lnt">3818
</span><span class="lnt">3819
</span><span class="lnt">3820
</span><span class="lnt">3821
</span><span class="lnt">3822
</span><span class="lnt">3823
</span><span class="lnt">3824
</span><span class="lnt">3825
</span><span class="lnt">3826
</span><span class="lnt">3827
</span><span class="lnt">3828
</span><span class="lnt">3829
</span><span class="lnt">3830
</span><span class="lnt">3831
</span><span class="lnt">3832
</span><span class="lnt">3833
</span><span class="lnt">3834
</span><span class="lnt">3835
</span><span class="lnt">3836
</span><span class="lnt">3837
</span><span class="lnt">3838
</span><span class="lnt">3839
</span><span class="lnt">3840
</span><span class="lnt">3841
</span><span class="lnt">3842
</span><span class="lnt">3843
</span><span class="lnt">3844
</span><span class="lnt">3845
</span><span class="lnt">3846
</span><span class="lnt">3847
</span><span class="lnt">3848
</span><span class="lnt">3849
</span><span class="lnt">3850
</span><span class="lnt">3851
</span><span class="lnt">3852
</span><span class="lnt">3853
</span><span class="lnt">3854
</span><span class="lnt">3855
</span><span class="lnt">3856
</span><span class="lnt">3857
</span><span class="lnt">3858
</span><span class="lnt">3859
</span><span class="lnt">3860
</span><span class="lnt">3861
</span><span class="lnt">3862
</span><span class="lnt">3863
</span><span class="lnt">3864
</span><span class="lnt">3865
</span><span class="lnt">3866
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// The goroutine g exited its system call.
</span></span></span><span class="line"><span class="cl"><span class="c1">// Arrange for it to run on a cpu again.
</span></span></span><span class="line"><span class="cl"><span class="c1">// This is called only from the go syscall library, not
</span></span></span><span class="line"><span class="cl"><span class="c1">// from the low-level system calls used by the runtime.
</span></span></span><span class="line"><span class="cl"><span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1">// Write barriers are not allowed because our P may have been stolen.
</span></span></span><span class="line"><span class="cl"><span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1">// This is exported via linkname to assembly in the syscall package.
</span></span></span><span class="line"><span class="cl"><span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1">//go:nosplit
</span></span></span><span class="line"><span class="cl"><span class="c1">//go:nowritebarrierrec
</span></span></span><span class="line"><span class="cl"><span class="c1">//go:linkname exitsyscall
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">exitsyscall</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// user goroutine
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">_g_</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">()</span> <span class="c1">// goroutine g
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">locks</span><span class="o">++</span> <span class="c1">// see comment in entersyscall
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nf">getcallersp</span><span class="p">()</span> <span class="p">&gt;</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">syscallsp</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">throw</span><span class="p">(</span><span class="s">&#34;exitsyscall: syscall frame is no longer valid&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c1">// g.waitsince，g被阻塞的大约时间
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">_g_</span><span class="p">.</span><span class="nx">waitsince</span> <span class="p">=</span> <span class="mi">0</span> 
</span></span><span class="line"><span class="cl">    <span class="c1">// 进入系统调用之前所绑定的p
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">oldp</span> <span class="o">:=</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">oldp</span><span class="p">.</span><span class="nf">ptr</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">oldp</span> <span class="p">=</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// exitsyscallfast 尝试绑定P，成功返回true，失败返回false。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nf">exitsyscallfast</span><span class="p">(</span><span class="nx">oldp</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// When exitsyscallfast returns success, we have a P so can now use
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// write barriers
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="nx">goroutineProfile</span><span class="p">.</span><span class="nx">active</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// Make sure that gp has had its stack written out to the goroutine
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// profile, exactly as it was when the goroutine profiler first
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// stopped the world.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="nf">systemstack</span><span class="p">(</span><span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="nf">tryRecordGoroutineProfileWB</span><span class="p">(</span><span class="nx">_g_</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="p">})</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="nx">trace</span><span class="p">.</span><span class="nx">enabled</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="nx">oldp</span> <span class="o">!=</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">p</span><span class="p">.</span><span class="nf">ptr</span><span class="p">()</span> <span class="o">||</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">syscalltick</span> <span class="o">!=</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">p</span><span class="p">.</span><span class="nf">ptr</span><span class="p">().</span><span class="nx">syscalltick</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="nf">systemstack</span><span class="p">(</span><span class="nx">traceGoStart</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// There&#39;s a cpu for us, so we can run.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">p</span><span class="p">.</span><span class="nf">ptr</span><span class="p">().</span><span class="nx">syscalltick</span><span class="o">++</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// We need to cas the status and scan before resuming...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nf">casgstatus</span><span class="p">(</span><span class="nx">_g_</span><span class="p">,</span> <span class="nx">_Gsyscall</span><span class="p">,</span> <span class="nx">_Grunning</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// Garbage collector isn&#39;t running (since we are),
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// so okay to clear syscallsp.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">_g_</span><span class="p">.</span><span class="nx">syscallsp</span> <span class="p">=</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">        <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">locks</span><span class="o">--</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">preempt</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// restore the preemption request in case we&#39;ve cleared it in newstack
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// 恢复抢占请求，以防我们在newstack中清除了它
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="nx">_g_</span><span class="p">.</span><span class="nx">stackguard0</span> <span class="p">=</span> <span class="nx">stackPreempt</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// otherwise restore the real _StackGuard, we&#39;ve spoiled it in entersyscall/entersyscallblock
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// 否则恢复真正的_StackGuard，我们已经在entersyscall/entersyscallblock中破坏了它
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="nx">_g_</span><span class="p">.</span><span class="nx">stackguard0</span> <span class="p">=</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">stack</span><span class="p">.</span><span class="nx">lo</span> <span class="o">+</span> <span class="nx">_StackGuard</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="nx">_g_</span><span class="p">.</span><span class="nx">throwsplit</span> <span class="p">=</span> <span class="kc">false</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// sched.disable.user == true，用户goroutine被禁止运行
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// schedEnabled判断g是否是系统goroutine
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="nx">sched</span><span class="p">.</span><span class="nx">disable</span><span class="p">.</span><span class="nx">user</span> <span class="o">&amp;&amp;</span> <span class="p">!</span><span class="nf">schedEnabled</span><span class="p">(</span><span class="nx">_g_</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// Scheduling of this goroutine is disabled.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="nf">Gosched</span><span class="p">()</span> <span class="c1">// 让出CPU，当前goroutine。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="k">return</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// M绑定P没有成功时。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    
</span></span><span class="line"><span class="cl">    <span class="nx">_g_</span><span class="p">.</span><span class="nx">sysexitticks</span> <span class="p">=</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">trace</span><span class="p">.</span><span class="nx">enabled</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// Wait till traceGoSysBlock event is emitted.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// This ensures consistency of the trace (the goroutine is started after it is blocked).
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">for</span> <span class="nx">oldp</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="nx">oldp</span><span class="p">.</span><span class="nx">syscalltick</span> <span class="o">==</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">syscalltick</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nf">osyield</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// We can&#39;t trace syscall exit right now because we don&#39;t have a P.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// Tracing code can invoke write barriers that cannot run without a P.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// So instead we remember the syscall exit time and emit the event
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// in execute when we have a P.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">_g_</span><span class="p">.</span><span class="nx">sysexitticks</span> <span class="p">=</span> <span class="nf">cputicks</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">locks</span><span class="o">--</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// Call the scheduler.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 没有绑定到p，调用mcall切换到g0栈执行exitsyscall0函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">mcall</span><span class="p">(</span><span class="nx">exitsyscall0</span><span class="p">)</span> <span class="c1">// mcall函数会保存现场，切换g0调用exitsyscall0函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Scheduler returned, so we&#39;re allowed to run now.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// Delete the syscallsp information that we left for
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// the garbage collector during the system call.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// Must wait until now because until gosched returns
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// we don&#39;t know for sure that the garbage collector
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// is not running.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">_g_</span><span class="p">.</span><span class="nx">syscallsp</span> <span class="p">=</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">    <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">p</span><span class="p">.</span><span class="nf">ptr</span><span class="p">().</span><span class="nx">syscalltick</span><span class="o">++</span>
</span></span><span class="line"><span class="cl">    <span class="nx">_g_</span><span class="p">.</span><span class="nx">throwsplit</span> <span class="p">=</span> <span class="kc">false</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="exitsyscallfast">exitsyscallfast()<a hidden class="anchor" aria-hidden="true" href="#exitsyscallfast">#</a></h4>
<ol>
<li>尝试绑定一个空闲的<code>P</code>。true.绑定成功，false.绑定失败。</li>
<li>文件位置：go1.19.3/src/runtime/proc.go。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">3856
</span><span class="lnt">3857
</span><span class="lnt">3858
</span><span class="lnt">3859
</span><span class="lnt">3860
</span><span class="lnt">3861
</span><span class="lnt">3862
</span><span class="lnt">3863
</span><span class="lnt">3864
</span><span class="lnt">3865
</span><span class="lnt">3866
</span><span class="lnt">3867
</span><span class="lnt">3868
</span><span class="lnt">3869
</span><span class="lnt">3870
</span><span class="lnt">3871
</span><span class="lnt">3872
</span><span class="lnt">3873
</span><span class="lnt">3874
</span><span class="lnt">3875
</span><span class="lnt">3876
</span><span class="lnt">3877
</span><span class="lnt">3878
</span><span class="lnt">3879
</span><span class="lnt">3880
</span><span class="lnt">3881
</span><span class="lnt">3882
</span><span class="lnt">3883
</span><span class="lnt">3884
</span><span class="lnt">3885
</span><span class="lnt">3886
</span><span class="lnt">3887
</span><span class="lnt">3888
</span><span class="lnt">3889
</span><span class="lnt">3890
</span><span class="lnt">3891
</span><span class="lnt">3892
</span><span class="lnt">3893
</span><span class="lnt">3894
</span><span class="lnt">3895
</span><span class="lnt">3896
</span><span class="lnt">3897
</span><span class="lnt">3898
</span><span class="lnt">3899
</span><span class="lnt">3900
</span><span class="lnt">3901
</span><span class="lnt">3902
</span><span class="lnt">3903
</span><span class="lnt">3904
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">//go:nosplit
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">exitsyscallfast</span><span class="p">(</span><span class="nx">oldp</span> <span class="o">*</span><span class="nx">p</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">_g_</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">()</span> <span class="c1">// g
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Freezetheworld sets stopwait but does not retake P&#39;s.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// Freezetheworld 设置停止等待，但不重新获取P。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// const freezeStopWait int = 0x7fffffff
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nx">sched</span><span class="p">.</span><span class="nx">stopwait</span> <span class="o">==</span> <span class="nx">freezeStopWait</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="kc">false</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// Try to re-acquire the last P.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 试着重新获取last P。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nx">oldp</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="nx">oldp</span><span class="p">.</span><span class="nx">status</span> <span class="o">==</span> <span class="nx">_Psyscall</span> <span class="o">&amp;&amp;</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Cas</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">oldp</span><span class="p">.</span><span class="nx">status</span><span class="p">,</span> <span class="nx">_Psyscall</span><span class="p">,</span> <span class="nx">_Pidle</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// There&#39;s a cpu for us, so we can run.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 我们有cpu，所以我们可以运行。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nf">wirep</span><span class="p">(</span><span class="nx">oldp</span><span class="p">)</span> <span class="c1">// 绑定P
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nf">exitsyscallfast_reacquired</span><span class="p">()</span> <span class="c1">// 处理P的syscalltick字段
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">return</span> <span class="kc">true</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// Try to get any other idle P.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 尝试获取一个空闲的P。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nx">sched</span><span class="p">.</span><span class="nx">pidle</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="kd">var</span> <span class="nx">ok</span> <span class="kt">bool</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 切换到g0栈
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nf">systemstack</span><span class="p">(</span><span class="kd">func</span><span class="p">()</span> <span class="p">{</span> 
</span></span><span class="line"><span class="cl">            <span class="c1">// 从全局队列中寻找空闲的p，需要加锁，比较慢
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="nx">ok</span> <span class="p">=</span> <span class="nf">exitsyscallfast_pidle</span><span class="p">()</span> <span class="c1">// 搬到成功返回true，绑定失败返回false。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="k">if</span> <span class="nx">ok</span> <span class="o">&amp;&amp;</span> <span class="nx">trace</span><span class="p">.</span><span class="nx">enabled</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="k">if</span> <span class="nx">oldp</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                    <span class="c1">// Wait till traceGoSysBlock event is emitted.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                    <span class="c1">// This ensures consistency of the trace (the goroutine is started after it is blocked).
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                    <span class="k">for</span> <span class="nx">oldp</span><span class="p">.</span><span class="nx">syscalltick</span> <span class="o">==</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">syscalltick</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                        <span class="nf">osyield</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">                    <span class="p">}</span>
</span></span><span class="line"><span class="cl">                <span class="p">}</span>
</span></span><span class="line"><span class="cl">                <span class="nf">traceGoSysExit</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">})</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="nx">ok</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="kc">true</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="kc">false</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="exitsyscallfast_pidle">exitsyscallfast_pidle()<a hidden class="anchor" aria-hidden="true" href="#exitsyscallfast_pidle">#</a></h4>
<ol>
<li>文件位置：go1.19.3/src/runtime/proc.go。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">3913
</span><span class="lnt">3914
</span><span class="lnt">3915
</span><span class="lnt">3916
</span><span class="lnt">3917
</span><span class="lnt">3918
</span><span class="lnt">3919
</span><span class="lnt">3920
</span><span class="lnt">3921
</span><span class="lnt">3922
</span><span class="lnt">3923
</span><span class="lnt">3924
</span><span class="lnt">3925
</span><span class="lnt">3926
</span><span class="lnt">3927
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">exitsyscallfast_pidle</span><span class="p">()</span> <span class="kt">bool</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nx">_p_</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nf">pidleget</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 处理sysmon，因为在陷入到系统调用是sysmon可能自己把自己挂起，所以需要恢复
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nx">_p_</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Load</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">sysmonwait</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">atomic</span><span class="p">.</span><span class="nf">Store</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">sysmonwait</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="nf">notewakeup</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">sysmonnote</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">_p_</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">acquirep</span><span class="p">(</span><span class="nx">_p_</span><span class="p">)</span> <span class="c1">// 绑定P如果有的话
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">return</span> <span class="kc">true</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="kc">false</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="exitsyscall0">exitsyscall0()<a hidden class="anchor" aria-hidden="true" href="#exitsyscall0">#</a></h4>
<ol>
<li><code>exitsyscall</code>在<code>g0</code>上的慢路径。获取<code>P</code>失败将<code>gp</code>放入可运行队列中。</li>
<li>通过<code>mcall()</code>调用，<code>gp</code>是从这个<code>M</code>调用<code>g</code>。</li>
<li>文件位置：go1.19.3/src/runtime/proc.go。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">3934
</span><span class="lnt">3935
</span><span class="lnt">3936
</span><span class="lnt">3937
</span><span class="lnt">3938
</span><span class="lnt">3939
</span><span class="lnt">3940
</span><span class="lnt">3941
</span><span class="lnt">3942
</span><span class="lnt">3943
</span><span class="lnt">3944
</span><span class="lnt">3945
</span><span class="lnt">3946
</span><span class="lnt">3947
</span><span class="lnt">3948
</span><span class="lnt">3949
</span><span class="lnt">3950
</span><span class="lnt">3951
</span><span class="lnt">3952
</span><span class="lnt">3953
</span><span class="lnt">3954
</span><span class="lnt">3955
</span><span class="lnt">3956
</span><span class="lnt">3957
</span><span class="lnt">3958
</span><span class="lnt">3959
</span><span class="lnt">3960
</span><span class="lnt">3961
</span><span class="lnt">3962
</span><span class="lnt">3963
</span><span class="lnt">3964
</span><span class="lnt">3965
</span><span class="lnt">3966
</span><span class="lnt">3967
</span><span class="lnt">3968
</span><span class="lnt">3969
</span><span class="lnt">3970
</span><span class="lnt">3971
</span><span class="lnt">3972
</span><span class="lnt">3973
</span><span class="lnt">3974
</span><span class="lnt">3975
</span><span class="lnt">3976
</span><span class="lnt">3977
</span><span class="lnt">3978
</span><span class="lnt">3979
</span><span class="lnt">3980
</span><span class="lnt">3981
</span><span class="lnt">3982
</span><span class="lnt">3983
</span><span class="lnt">3984
</span><span class="lnt">3985
</span><span class="lnt">3986
</span><span class="lnt">3987
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// exitsyscall slow path on g0.
</span></span></span><span class="line"><span class="cl"><span class="c1">// Failed to acquire P, enqueue gp as runnable.
</span></span></span><span class="line"><span class="cl"><span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1">// Called via mcall, so gp is the calling g from this M.
</span></span></span><span class="line"><span class="cl"><span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1">//go:nowritebarrierrec
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">exitsyscall0</span><span class="p">(</span><span class="nx">gp</span> <span class="o">*</span><span class="nx">g</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 修改gp状态为_Grunnable
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">casgstatus</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="nx">_Gsyscall</span><span class="p">,</span> <span class="nx">_Grunnable</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nf">dropg</span><span class="p">()</span> <span class="c1">// 解除g关联关系
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="kd">var</span> <span class="nx">_p_</span> <span class="o">*</span><span class="nx">p</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 判断gp是否是系统goroutine，如果是的话再次尝试获取P。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nf">schedEnabled</span><span class="p">(</span><span class="nx">gp</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">_p_</span><span class="p">,</span> <span class="nx">_</span> <span class="p">=</span> <span class="nf">pidleget</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="kd">var</span> <span class="nx">locked</span> <span class="kt">bool</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">_p_</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">globrunqput</span><span class="p">(</span><span class="nx">gp</span><span class="p">)</span> <span class="c1">// gp加入全局可运行队列
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">        <span class="c1">// Below, we stoplockedm if gp is locked. globrunqput releases
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// ownership of gp, so we must check if gp is locked prior to
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// committing the release by unlocking sched.lock, otherwise we
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// could race with another M transitioning gp from unlocked to
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// locked.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 下面，如果gp被锁定，我们将停止阻塞。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// globrunqput释放了gp的所有权，所以我们必须在释放之前通过解锁sched.lock检查gp是否被锁定，否则我们可以与另一个M转换gp从解锁到锁定。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">locked</span> <span class="p">=</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">lockedm</span> <span class="o">!=</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Load</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">sysmonwait</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span> <span class="c1">// 尝试唤醒sysmon，如果有
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">atomic</span><span class="p">.</span><span class="nf">Store</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">sysmonwait</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="nf">notewakeup</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">sysmonnote</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">_p_</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">acquirep</span><span class="p">(</span><span class="nx">_p_</span><span class="p">)</span> <span class="c1">// 绑定P
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// gp 被调度起来运行
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nf">execute</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="kc">false</span><span class="p">)</span> <span class="c1">// Never returns.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">locked</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// Wait until another thread schedules gp and so m again.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// N.B. lockedm must be this M, as this g was running on this M
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// before entersyscall.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 等待另一个线程调度gp，然后再调度m。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 注意，lockedm一定是这个M，因为这个g在entersyscall之前是在这个M上运行的。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nf">stoplockedm</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">        <span class="nf">execute</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="kc">false</span><span class="p">)</span> <span class="c1">// Never returns.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nf">stopm</span><span class="p">()</span> <span class="c1">// 当前工作线程被挂起，等待被唤醒获取P然后运行起来
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 调度循环开始
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">schedule</span><span class="p">()</span> <span class="c1">// Never returns.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="信号形式发送抢占">信号形式发送抢占<a hidden class="anchor" aria-hidden="true" href="#信号形式发送抢占">#</a></h2>
<h3 id="preemptm">preemptM()<a hidden class="anchor" aria-hidden="true" href="#preemptm">#</a></h3>
<ol>
<li><code>preemptM</code>向<code>mp</code>发送抢占请求。该请求可以异步处理，并且可以与对<code>M</code>的其他请求合并。</li>
<li>当接收到请求时，如果正在运行的<code>G</code>或<code>P</code>被标记为抢占，并且<code>goroutine</code>处于异步安全点，则它将抢占 <code>goroutine</code>。</li>
<li>它总是在处理抢占请求后自动递增<code>mp.preemptGen</code>。</li>
<li>通过<code>runtime.signalM()</code>函数向执行<code>M</code>发送<code>sigPreempt</code>信号。</li>
<li>至于<code>signalM()</code>函数，就是调用操作系统的信号相关系统调用，将指定信号发送给目标线程。</li>
<li>至此，异步抢占逻辑的主要工作就算完成了前一半。</li>
<li><code>preemptM</code>这个函数会调用<code>signalM</code>将在初始化的安装的<code>_SIGURG</code>信号发送到指定的<code>M</code>上。</li>
<li>使用 preemptM 发送抢占信号的地方主要有下面几个：
<ol>
<li>Go 后台监控 runtime.sysmon 检测超时发送抢占信号；</li>
<li>Go GC 栈扫描发送抢占信号；</li>
<li>Go GC STW 的时候调用 preemptall 抢占所有 P，让其暂停；</li>
</ol>
</li>
<li>文件位置：go1.19.3/src/runtime/signal_unix.go。</li>
<li>参数<code>mp *m</code>：被抢占的P关联的M。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">362
</span><span class="lnt">363
</span><span class="lnt">364
</span><span class="lnt">365
</span><span class="lnt">366
</span><span class="lnt">367
</span><span class="lnt">368
</span><span class="lnt">369
</span><span class="lnt">370
</span><span class="lnt">371
</span><span class="lnt">372
</span><span class="lnt">373
</span><span class="lnt">374
</span><span class="lnt">375
</span><span class="lnt">376
</span><span class="lnt">377
</span><span class="lnt">378
</span><span class="lnt">379
</span><span class="lnt">380
</span><span class="lnt">381
</span><span class="lnt">382
</span><span class="lnt">383
</span><span class="lnt">384
</span><span class="lnt">385
</span><span class="lnt">386
</span><span class="lnt">387
</span><span class="lnt">388
</span><span class="lnt">389
</span><span class="lnt">390
</span><span class="lnt">391
</span><span class="lnt">392
</span><span class="lnt">393
</span><span class="lnt">394
</span><span class="lnt">395
</span><span class="lnt">396
</span><span class="lnt">397
</span><span class="lnt">398
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// preemptM sends a preemption request to mp. This request may be
</span></span></span><span class="line"><span class="cl"><span class="c1">// handled asynchronously and may be coalesced with other requests to
</span></span></span><span class="line"><span class="cl"><span class="c1">// the M. When the request is received, if the running G or P are
</span></span></span><span class="line"><span class="cl"><span class="c1">// marked for preemption and the goroutine is at an asynchronous
</span></span></span><span class="line"><span class="cl"><span class="c1">// safe-point, it will preempt the goroutine. It always atomically
</span></span></span><span class="line"><span class="cl"><span class="c1">// increments mp.preemptGen after handling a preemption request.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">preemptM</span><span class="p">(</span><span class="nx">mp</span> <span class="o">*</span><span class="nx">m</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// On Darwin, don&#39;t try to preempt threads during exec.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// Issue #41702.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nx">GOOS</span> <span class="o">==</span> <span class="s">&#34;darwin&#34;</span> <span class="o">||</span> <span class="nx">GOOS</span> <span class="o">==</span> <span class="s">&#34;ios&#34;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">execLock</span><span class="p">.</span><span class="nf">rlock</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// mp.signalPending: 这个M上是否有一个待处理的抢占信号。原子操作。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Cas</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">mp</span><span class="p">.</span><span class="nx">signalPending</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="nx">GOOS</span> <span class="o">==</span> <span class="s">&#34;darwin&#34;</span> <span class="o">||</span> <span class="nx">GOOS</span> <span class="o">==</span> <span class="s">&#34;ios&#34;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nx">atomic</span><span class="p">.</span><span class="nf">Xadd</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">pendingPreemptSignals</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// If multiple threads are preempting the same M, it may send many
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// signals to the same M such that it hardly make progress, causing
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// live-lock problem. Apparently this could happen on darwin. See
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// issue #37741.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// Only send a signal if there isn&#39;t already one pending.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 如果多个线程抢占同一个M，它可能会向同一个M发送许多信号，
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 使其几乎无法取得进展，从而导致实时锁定问题。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 显然这可能发生在darwin身上。只有在还没有挂起的情况下才发送信号。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// const sigPreempt int = _SIGURG
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// const _SIGURG = 0x17
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nf">signalM</span><span class="p">(</span><span class="nx">mp</span><span class="p">,</span> <span class="nx">sigPreempt</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">GOOS</span> <span class="o">==</span> <span class="s">&#34;darwin&#34;</span> <span class="o">||</span> <span class="nx">GOOS</span> <span class="o">==</span> <span class="s">&#34;ios&#34;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">execLock</span><span class="p">.</span><span class="nf">runlock</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="signalm">signalM()<a hidden class="anchor" aria-hidden="true" href="#signalm">#</a></h3>
<ol>
<li><code>signalM</code>向<code>mp</code>发送信号。</li>
<li>文件位置：go1.19.3/src/runtime/os_linux.go。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">551
</span><span class="lnt">552
</span><span class="lnt">553
</span><span class="lnt">554
</span><span class="lnt">555
</span><span class="lnt">556
</span><span class="lnt">557
</span><span class="lnt">558
</span><span class="lnt">559
</span><span class="lnt">560
</span><span class="lnt">561
</span><span class="lnt">562
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// signalM sends a signal to mp.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">signalM</span><span class="p">(</span><span class="nx">mp</span> <span class="o">*</span><span class="nx">m</span><span class="p">,</span> <span class="nx">sig</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 将信号sig发送到线程组tgid中具有线程ID tid的线程。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// int tgkill(int tgid, int tid, int sig);
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//  1. tgid：为线程组中主线程的线程ID，或者称为进程号。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//    其实它能起到保护的作用，防止向错误的线程发送信号。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//    比如向线程ID为1234的线程发送信号时，很可能线程1234早就退出了，
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//    而线程ID 1234恰好被内核分配给了另一个不相干的进程。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//  2. tid：线程ID。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//  3. sig：信号值。sigPreempt = _SIGURG = 0x17。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">tgkill</span><span class="p">(</span><span class="nf">getpid</span><span class="p">(),</span> <span class="nb">int</span><span class="p">(</span><span class="nx">mp</span><span class="p">.</span><span class="nx">procid</span><span class="p">),</span> <span class="nx">sig</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="tgkill">tgkill()<a hidden class="anchor" aria-hidden="true" href="#tgkill">#</a></h3>
<ol>
<li>系统调用 <code>tgkill()</code> 函数向进程内的线程发送信号。</li>
<li>文件位置：go1.19.3/src/runtime/sys_linux_amd64.s。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">176
</span><span class="lnt">177
</span><span class="lnt">178
</span><span class="lnt">179
</span><span class="lnt">180
</span><span class="lnt">181
</span><span class="lnt">182
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-asm" data-lang="asm"><span class="line"><span class="cl"><span class="nf">TEXT</span> <span class="err">·</span><span class="no">tgkill</span><span class="p">(</span><span class="no">SB</span><span class="p">),</span><span class="no">NOSPLIT</span><span class="p">,</span><span class="no">$0</span>
</span></span><span class="line"><span class="cl">    <span class="nf">MOVQ</span>    <span class="no">tgid</span><span class="err">+</span><span class="mi">0</span><span class="p">(</span><span class="no">FP</span><span class="p">),</span> <span class="no">DI</span>
</span></span><span class="line"><span class="cl">    <span class="nf">MOVQ</span>    <span class="no">tid</span><span class="err">+</span><span class="mi">8</span><span class="p">(</span><span class="no">FP</span><span class="p">),</span> <span class="no">SI</span>
</span></span><span class="line"><span class="cl">    <span class="nf">MOVQ</span>    <span class="no">sig</span><span class="err">+</span><span class="mi">16</span><span class="p">(</span><span class="no">FP</span><span class="p">),</span> <span class="no">DX</span>
</span></span><span class="line"><span class="cl">    <span class="nf">MOVL</span>    <span class="no">$SYS_tgkill</span><span class="p">,</span> <span class="no">AX</span>
</span></span><span class="line"><span class="cl">    <span class="nf">SYSCALL</span> <span class="c1"># 进入系统调用
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">RET</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="全局信号处理注册">全局信号处理注册<a hidden class="anchor" aria-hidden="true" href="#全局信号处理注册">#</a></h2>
<h3 id="mstart1">mstart1()<a hidden class="anchor" aria-hidden="true" href="#mstart1">#</a></h3>
<ol>
<li>主线程启动运行到<code>mstart()</code>-&gt;<code>mstart0()</code>-&gt;<code>mstart1()</code>函数内时。</li>
<li>文件位置：go1.19.3/src/runtime/proc.go。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1394
</span><span class="lnt">1395
</span><span class="lnt">1396
</span><span class="lnt">1397
</span><span class="lnt">1398
</span><span class="lnt">1399
</span><span class="lnt">1400
</span><span class="lnt">1401
</span><span class="lnt">1402
</span><span class="lnt">1403
</span><span class="lnt">1404
</span><span class="lnt">1405
</span><span class="lnt">1406
</span><span class="lnt">1407
</span><span class="lnt">1408
</span><span class="lnt">1409
</span><span class="lnt">1410
</span><span class="lnt">1411
</span><span class="lnt">1412
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// The go:noinline is to guarantee the getcallerpc/getcallersp below are safe,
</span></span></span><span class="line"><span class="cl"><span class="c1">// so that we can set up g0.sched to return to the call of mstart1 above.
</span></span></span><span class="line"><span class="cl"><span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1">//go:noinline
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">mstart1</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">     <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    
</span></span><span class="line"><span class="cl">    <span class="nf">asminit</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="nf">minit</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c1">// Install signal handlers; after minit so that minit can
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// prepare the thread to be able to handle the signals.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 安装信号处理程序;在minit之后，以便minit可以准备线程，以便能够处理信号。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">m</span> <span class="o">==</span> <span class="o">&amp;</span><span class="nx">m0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">mstartm0</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="mstartm0">mstartm0()<a hidden class="anchor" aria-hidden="true" href="#mstartm0">#</a></h3>
<ol>
<li><code>initsig(false)</code>则是注册信号处理相关。</li>
<li>文件位置：go1.19.3/src/runtime/proc.go。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1435
</span><span class="lnt">1436
</span><span class="lnt">1437
</span><span class="lnt">1438
</span><span class="lnt">1439
</span><span class="lnt">1440
</span><span class="lnt">1441
</span><span class="lnt">1442
</span><span class="lnt">1443
</span><span class="lnt">1444
</span><span class="lnt">1445
</span><span class="lnt">1446
</span><span class="lnt">1447
</span><span class="lnt">1448
</span><span class="lnt">1449
</span><span class="lnt">1450
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// mstartm0 implements part of mstart1 that only runs on the m0.
</span></span></span><span class="line"><span class="cl"><span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1">// Write barriers are allowed here because we know the GC can&#39;t be
</span></span></span><span class="line"><span class="cl"><span class="c1">// running yet, so they&#39;ll be no-ops.
</span></span></span><span class="line"><span class="cl"><span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1">//go:yeswritebarrierrec
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">mstartm0</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Create an extra M for callbacks on threads not created by Go.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// An extra M is also needed on Windows for callbacks created by
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// syscall.NewCallback. See issue #6751 for details.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="nx">iscgo</span> <span class="o">||</span> <span class="nx">GOOS</span> <span class="o">==</span> <span class="s">&#34;windows&#34;</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">!</span><span class="nx">cgoHasExtraM</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">cgoHasExtraM</span> <span class="p">=</span> <span class="kc">true</span>
</span></span><span class="line"><span class="cl">        <span class="nf">newextram</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nf">initsig</span><span class="p">(</span><span class="kc">false</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="initsig">initsig()<a hidden class="anchor" aria-hidden="true" href="#initsig">#</a></h3>
<ol>
<li>信号注册。</li>
<li>文件位置：go1.19.3/src/runtime/signal_unix.go。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span><span class="lnt">113
</span><span class="lnt">114
</span><span class="lnt">115
</span><span class="lnt">116
</span><span class="lnt">117
</span><span class="lnt">118
</span><span class="lnt">119
</span><span class="lnt">120
</span><span class="lnt">121
</span><span class="lnt">122
</span><span class="lnt">123
</span><span class="lnt">124
</span><span class="lnt">125
</span><span class="lnt">126
</span><span class="lnt">127
</span><span class="lnt">128
</span><span class="lnt">129
</span><span class="lnt">130
</span><span class="lnt">131
</span><span class="lnt">132
</span><span class="lnt">133
</span><span class="lnt">134
</span><span class="lnt">135
</span><span class="lnt">136
</span><span class="lnt">137
</span><span class="lnt">138
</span><span class="lnt">139
</span><span class="lnt">140
</span><span class="lnt">141
</span><span class="lnt">142
</span><span class="lnt">143
</span><span class="lnt">144
</span><span class="lnt">145
</span><span class="lnt">146
</span><span class="lnt">147
</span><span class="lnt">148
</span><span class="lnt">149
</span><span class="lnt">150
</span><span class="lnt">151
</span><span class="lnt">152
</span><span class="lnt">153
</span><span class="lnt">154
</span><span class="lnt">155
</span><span class="lnt">156
</span><span class="lnt">157
</span><span class="lnt">158
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// Initialize signals.
</span></span></span><span class="line"><span class="cl"><span class="c1">// Called by libpreinit so runtime may not be initialized.
</span></span></span><span class="line"><span class="cl"><span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1">//go:nosplit
</span></span></span><span class="line"><span class="cl"><span class="c1">//go:nowritebarrierrec
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">initsig</span><span class="p">(</span><span class="nx">preinit</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">!</span><span class="nx">preinit</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// It&#39;s now OK for signal handlers to run.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 现在可以运行信号处理程序了。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">signalsOK</span> <span class="p">=</span> <span class="kc">true</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// For c-archive/c-shared this is called by libpreinit with
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// preinit == true.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="nx">isarchive</span> <span class="o">||</span> <span class="nx">islibrary</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">!</span><span class="nx">preinit</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 遍历信号数组
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// const _NSIG int = 65; 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="nb">uint32</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">_NSIG</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// sigtable 全局变量存储的是所有信号及描述
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">t</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">sigtable</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// const _SigDefault int = 16;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 如果信号没有被显式请求，就不要监视它
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 略过信号，SIGKILL、SIGSTOP、SIGTSTP、SIGCONT、SIGTTIN、SIGTTOU
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="nx">t</span><span class="p">.</span><span class="nx">flags</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="nx">t</span><span class="p">.</span><span class="nx">flags</span><span class="o">&amp;</span><span class="nx">_SigDefault</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">continue</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// We don&#39;t need to use atomic operations here because
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// there shouldn&#39;t be any other goroutines running yet.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">fwdSig</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nf">getsig</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">!</span><span class="nf">sigInstallGoHandler</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// Even if we are not installing a signal handler,
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// set SA_ONSTACK if necessary.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="k">if</span> <span class="nx">fwdSig</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">!=</span> <span class="nx">_SIG_DFL</span> <span class="o">&amp;&amp;</span> <span class="nx">fwdSig</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">!=</span> <span class="nx">_SIG_IGN</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="nf">setsigstack</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nx">fwdSig</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">==</span> <span class="nx">_SIG_IGN</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="nf">sigInitIgnored</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="k">continue</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="nx">handlingSig</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">        <span class="nf">setsig</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span> <span class="nx">abi</span><span class="p">.</span><span class="nf">FuncPCABIInternal</span><span class="p">(</span><span class="nx">sighandler</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="setsig">setsig()<a hidden class="anchor" aria-hidden="true" href="#setsig">#</a></h3>
<ol>
<li>这里需要注意的是，当 fn 等于 sighandler 的时候，调用的函数会被替换成 sigtramp。</li>
<li>sigaction 函数在 Linux 下会调用系统调用函数 sys_signal 以及 sys_rt_sigaction 实现安装信号。</li>
<li>文件位置：go1.19.3/src/runtime/os_linux.go。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span><span class="lnt">113
</span><span class="lnt">114
</span><span class="lnt">115
</span><span class="lnt">116
</span><span class="lnt">117
</span><span class="lnt">118
</span><span class="lnt">119
</span><span class="lnt">120
</span><span class="lnt">121
</span><span class="lnt">122
</span><span class="lnt">123
</span><span class="lnt">124
</span><span class="lnt">125
</span><span class="lnt">126
</span><span class="lnt">127
</span><span class="lnt">128
</span><span class="lnt">129
</span><span class="lnt">130
</span><span class="lnt">131
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">//go:nosplit
</span></span></span><span class="line"><span class="cl"><span class="c1">//go:nowritebarrierrec
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">setsig</span><span class="p">(</span><span class="nx">i</span> <span class="kt">uint32</span><span class="p">,</span> <span class="nx">fn</span> <span class="kt">uintptr</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">var</span> <span class="nx">sa</span> <span class="nx">sigactiont</span>
</span></span><span class="line"><span class="cl">    <span class="nx">sa</span><span class="p">.</span><span class="nx">sa_flags</span> <span class="p">=</span> <span class="nx">_SA_SIGINFO</span> <span class="p">|</span> <span class="nx">_SA_ONSTACK</span> <span class="p">|</span> <span class="nx">_SA_RESTORER</span> <span class="p">|</span> <span class="nx">_SA_RESTART</span>
</span></span><span class="line"><span class="cl">    <span class="nf">sigfillset</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sa</span><span class="p">.</span><span class="nx">sa_mask</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Although Linux manpage says &#34;sa_restorer element is obsolete and
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// should not be used&#34;. x86_64 kernel requires it. Only use it on
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// x86.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nx">GOARCH</span> <span class="o">==</span> <span class="s">&#34;386&#34;</span> <span class="o">||</span> <span class="nx">GOARCH</span> <span class="o">==</span> <span class="s">&#34;amd64&#34;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">sa</span><span class="p">.</span><span class="nx">sa_restorer</span> <span class="p">=</span> <span class="nx">abi</span><span class="p">.</span><span class="nf">FuncPCABI0</span><span class="p">(</span><span class="nx">sigreturn</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">fn</span> <span class="o">==</span> <span class="nx">abi</span><span class="p">.</span><span class="nf">FuncPCABIInternal</span><span class="p">(</span><span class="nx">sighandler</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// abi.FuncPCABIInternal(sighandler) matches the callers in signal_unix.go
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="nx">iscgo</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nx">fn</span> <span class="p">=</span> <span class="nx">abi</span><span class="p">.</span><span class="nf">FuncPCABI0</span><span class="p">(</span><span class="nx">cgoSigtramp</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 替换为调用 sigtramp
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="nx">fn</span> <span class="p">=</span> <span class="nx">abi</span><span class="p">.</span><span class="nf">FuncPCABI0</span><span class="p">(</span><span class="nx">sigtramp</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nx">sa</span><span class="p">.</span><span class="nx">sa_handler</span> <span class="p">=</span> <span class="nx">fn</span>
</span></span><span class="line"><span class="cl">    <span class="nf">sigaction</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">sa</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="信号形式响应抢占">信号形式响应抢占<a hidden class="anchor" aria-hidden="true" href="#信号形式响应抢占">#</a></h2>
<h3 id="sigtramp">sigtramp()<a hidden class="anchor" aria-hidden="true" href="#sigtramp">#</a></h3>
<ol>
<li>函数原型：<code>func sigtramp()</code>。</li>
<li><code>sigtramp()</code>实际上是真正的信号处理函数，进程从内核态收到信号回到用户态调用的处理函数就是它。</li>
<li>注释中表明这个函数以<code>C</code>语言的调用惯例被调用，<code>Go</code>在这里通过<code>PUSH_REGS_HOST_TO_ABI0</code>保存<code>go</code>自己调用惯例用的寄存器后，</li>
<li>转换成自己的调用规范，等函数调用完毕之后，再通过<code>POP_REGS_HOST_TO_ABI0</code>恢复这些寄存器的值。</li>
<li>调度路径<code>sigtramp()</code>-&gt;<code>sigtrampgo()</code>-&gt;<code>sighandler()</code>-&gt;<code>doSigPreempt()</code>。</li>
<li>这里会被调用说明信号已经发送响应了，<code>runtime·sigtramp</code>会进行信号的处理。</li>
<li><code>runtime·sigtramp</code>会继续调用<code>runtime·sigtrampgo</code>。</li>
<li>文件位置：go1.19.3/src/runtime/sys_linux_amd64.s。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">341
</span><span class="lnt">342
</span><span class="lnt">343
</span><span class="lnt">344
</span><span class="lnt">345
</span><span class="lnt">346
</span><span class="lnt">347
</span><span class="lnt">348
</span><span class="lnt">349
</span><span class="lnt">350
</span><span class="lnt">351
</span><span class="lnt">352
</span><span class="lnt">353
</span><span class="lnt">354
</span><span class="lnt">355
</span><span class="lnt">356
</span><span class="lnt">357
</span><span class="lnt">358
</span><span class="lnt">359
</span><span class="lnt">360
</span><span class="lnt">361
</span><span class="lnt">362
</span><span class="lnt">363
</span><span class="lnt">364
</span><span class="lnt">365
</span><span class="lnt">366
</span><span class="lnt">367
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-asm" data-lang="asm"><span class="line"><span class="cl"><span class="c1"># Called using C ABI.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nf">TEXT</span> <span class="no">runtime</span><span class="err">·</span><span class="no">sigtramp</span><span class="p">(</span><span class="no">SB</span><span class="p">),</span><span class="no">NOSPLIT</span><span class="err">|</span><span class="no">TOPFRAME</span><span class="p">,</span><span class="no">$0</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># Transition from C ABI to Go ABI.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">PUSH_REGS_HOST_TO_ABI0</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1"># Set up ABIInternal environment: g in R14, cleared X15.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">get_tls</span><span class="p">(</span><span class="no">R12</span><span class="p">)</span>        <span class="c1"># TLS
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">MOVQ</span>    <span class="no">g</span><span class="p">(</span><span class="no">R12</span><span class="p">),</span> <span class="no">R14</span> <span class="c1"># R14 = g
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">PXOR</span>    <span class="no">X15</span><span class="p">,</span> <span class="no">X15</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1"># Reserve space for spill slots.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">NOP</span> <span class="no">SP</span>  <span class="c1"># disable vet stack checking
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">ADJSP</span>   <span class="no">$24</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1"># Call into the Go signal handler
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">#
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1"># 内核修改用户态寄存器时设置的 rdi、rsi、rdx
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1"># 三个寄存器的值就是内核模仿调用sigtramp时传入的参数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">MOVQ</span>    <span class="no">DI</span><span class="p">,</span> <span class="no">AX</span>	<span class="c1"># sig
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">MOVQ</span>    <span class="no">SI</span><span class="p">,</span> <span class="no">BX</span>	<span class="c1"># info
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">MOVQ</span>    <span class="no">DX</span><span class="p">,</span> <span class="no">CX</span>	<span class="c1"># ctx
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">CALL</span>    <span class="err">·</span><span class="no">sigtrampgo</span><span class="err">&lt;</span><span class="no">ABIInternal</span><span class="err">&gt;</span><span class="p">(</span><span class="no">SB</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nf">ADJSP</span>   <span class="no">$-24</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nf">POP_REGS_HOST_TO_ABI0</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="nf">RET</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="sigtrampgo">sigtrampgo()<a hidden class="anchor" aria-hidden="true" href="#sigtrampgo">#</a></h3>
<ol>
<li>文件位置：go1.19.3/src/runtime/signal_unix.go。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">420
</span><span class="lnt">421
</span><span class="lnt">422
</span><span class="lnt">423
</span><span class="lnt">424
</span><span class="lnt">425
</span><span class="lnt">426
</span><span class="lnt">427
</span><span class="lnt">428
</span><span class="lnt">429
</span><span class="lnt">430
</span><span class="lnt">431
</span><span class="lnt">432
</span><span class="lnt">433
</span><span class="lnt">434
</span><span class="lnt">435
</span><span class="lnt">436
</span><span class="lnt">437
</span><span class="lnt">438
</span><span class="lnt">439
</span><span class="lnt">440
</span><span class="lnt">441
</span><span class="lnt">442
</span><span class="lnt">443
</span><span class="lnt">444
</span><span class="lnt">445
</span><span class="lnt">446
</span><span class="lnt">447
</span><span class="lnt">448
</span><span class="lnt">449
</span><span class="lnt">450
</span><span class="lnt">451
</span><span class="lnt">452
</span><span class="lnt">453
</span><span class="lnt">454
</span><span class="lnt">455
</span><span class="lnt">456
</span><span class="lnt">457
</span><span class="lnt">458
</span><span class="lnt">459
</span><span class="lnt">460
</span><span class="lnt">461
</span><span class="lnt">462
</span><span class="lnt">463
</span><span class="lnt">464
</span><span class="lnt">465
</span><span class="lnt">466
</span><span class="lnt">467
</span><span class="lnt">468
</span><span class="lnt">469
</span><span class="lnt">470
</span><span class="lnt">471
</span><span class="lnt">472
</span><span class="lnt">473
</span><span class="lnt">474
</span><span class="lnt">475
</span><span class="lnt">476
</span><span class="lnt">477
</span><span class="lnt">478
</span><span class="lnt">479
</span><span class="lnt">480
</span><span class="lnt">481
</span><span class="lnt">482
</span><span class="lnt">483
</span><span class="lnt">484
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// sigtrampgo is called from the signal handler function, sigtramp,
</span></span></span><span class="line"><span class="cl"><span class="c1">// written in assembly code.
</span></span></span><span class="line"><span class="cl"><span class="c1">// This is called by the signal handler, and the world may be stopped.
</span></span></span><span class="line"><span class="cl"><span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1">// It must be nosplit because getg() is still the G that was running
</span></span></span><span class="line"><span class="cl"><span class="c1">// (if any) when the signal was delivered, but it&#39;s (usually) called
</span></span></span><span class="line"><span class="cl"><span class="c1">// on the gsignal stack. Until this switches the G to gsignal, the
</span></span></span><span class="line"><span class="cl"><span class="c1">// stack bounds check won&#39;t work.
</span></span></span><span class="line"><span class="cl"><span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1">//go:nosplit
</span></span></span><span class="line"><span class="cl"><span class="c1">//go:nowritebarrierrec
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">sigtrampgo</span><span class="p">(</span><span class="nx">sig</span> <span class="kt">uint32</span><span class="p">,</span> <span class="nx">info</span> <span class="o">*</span><span class="nx">siginfo</span><span class="p">,</span> <span class="nx">ctx</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nf">sigfwdgo</span><span class="p">(</span><span class="nx">sig</span><span class="p">,</span> <span class="nx">info</span><span class="p">,</span> <span class="nx">ctx</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nx">c</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">sigctxt</span><span class="p">{</span><span class="nx">info</span><span class="p">,</span> <span class="nx">ctx</span><span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nx">gp</span> <span class="o">:=</span> <span class="nf">sigFetchG</span><span class="p">(</span><span class="nx">c</span><span class="p">)</span> <span class="c1">// g
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">setg</span><span class="p">(</span><span class="nx">gp</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">gp</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="nx">sig</span> <span class="o">==</span> <span class="nx">_SIGPROF</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// Some platforms (Linux) have per-thread timers, which we use in
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// combination with the process-wide timer. Avoid double-counting.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="k">if</span> <span class="nf">validSIGPROF</span><span class="p">(</span><span class="kc">nil</span><span class="p">,</span> <span class="nx">c</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="nf">sigprofNonGoPC</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nf">sigpc</span><span class="p">())</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="nx">sig</span> <span class="o">==</span> <span class="nx">sigPreempt</span> <span class="o">&amp;&amp;</span> <span class="nx">preemptMSupported</span> <span class="o">&amp;&amp;</span> <span class="nx">debug</span><span class="p">.</span><span class="nx">asyncpreemptoff</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// This is probably a signal from preemptM sent
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// while executing Go code but received while
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// executing non-Go code.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// We got past sigfwdgo, so we know that there is
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// no non-Go signal handler for sigPreempt.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// The default behavior for sigPreempt is to ignore
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// the signal, so badsignal will be a no-op anyway.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="k">if</span> <span class="nx">GOOS</span> <span class="o">==</span> <span class="s">&#34;darwin&#34;</span> <span class="o">||</span> <span class="nx">GOOS</span> <span class="o">==</span> <span class="s">&#34;ios&#34;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="nx">pendingPreemptSignals</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="nx">c</span><span class="p">.</span><span class="nf">fixsigcode</span><span class="p">(</span><span class="nx">sig</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="nf">badsignal</span><span class="p">(</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">sig</span><span class="p">),</span> <span class="nx">c</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nf">setg</span><span class="p">(</span><span class="nx">gp</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">gsignal</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// If some non-Go code called sigaltstack, adjust.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kd">var</span> <span class="nx">gsignalStack</span> <span class="nx">gsignalStack</span>
</span></span><span class="line"><span class="cl">    <span class="nx">setStack</span> <span class="o">:=</span> <span class="nf">adjustSignalStack</span><span class="p">(</span><span class="nx">sig</span><span class="p">,</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">m</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">gsignalStack</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">setStack</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">gp</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">gsignal</span><span class="p">.</span><span class="nx">stktopsp</span> <span class="p">=</span> <span class="nf">getcallersp</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">stackguard0</span> <span class="o">==</span> <span class="nx">stackFork</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">signalDuringFork</span><span class="p">(</span><span class="nx">sig</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nx">c</span><span class="p">.</span><span class="nf">fixsigcode</span><span class="p">(</span><span class="nx">sig</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nf">sighandler</span><span class="p">(</span><span class="nx">sig</span><span class="p">,</span> <span class="nx">info</span><span class="p">,</span> <span class="nx">ctx</span><span class="p">,</span> <span class="nx">gp</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nf">setg</span><span class="p">(</span><span class="nx">gp</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">setStack</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">restoreGsignalStack</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">gsignalStack</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="sighander">sighander()<a hidden class="anchor" aria-hidden="true" href="#sighander">#</a></h3>
<ol>
<li>响应抢占。调度路径<code>sigtramp()</code>-&gt;<code>sigtrampgo()</code>-&gt;<code>sighandler()</code>-&gt;<code>doSigPreempt()</code>。</li>
<li>文件位置：go1.19.3/src/runtime/signal_unix.go。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">597
</span><span class="lnt">598
</span><span class="lnt">599
</span><span class="lnt">600
</span><span class="lnt">601
</span><span class="lnt">602
</span><span class="lnt">603
</span><span class="lnt">604
</span><span class="lnt">605
</span><span class="lnt">606
</span><span class="lnt">607
</span><span class="lnt">608
</span><span class="lnt">609
</span><span class="lnt">610
</span><span class="lnt">611
</span><span class="lnt">612
</span><span class="lnt">613
</span><span class="lnt">614
</span><span class="lnt">615
</span><span class="lnt">616
</span><span class="lnt">617
</span><span class="lnt">618
</span><span class="lnt">619
</span><span class="lnt">620
</span><span class="lnt">621
</span><span class="lnt">622
</span><span class="lnt">623
</span><span class="lnt">624
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// sighandler is invoked when a signal occurs. The global g will be
</span></span></span><span class="line"><span class="cl"><span class="c1">// set to a gsignal goroutine and we will be running on the alternate
</span></span></span><span class="line"><span class="cl"><span class="c1">// signal stack. The parameter g will be the value of the global g
</span></span></span><span class="line"><span class="cl"><span class="c1">// when the signal occurred. The sig, info, and ctxt parameters are
</span></span></span><span class="line"><span class="cl"><span class="c1">// from the system signal handler: they are the parameters passed when
</span></span></span><span class="line"><span class="cl"><span class="c1">// the SA is passed to the sigaction system call.
</span></span></span><span class="line"><span class="cl"><span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1">// The garbage collector may have stopped the world, so write barriers
</span></span></span><span class="line"><span class="cl"><span class="c1">// are not allowed.
</span></span></span><span class="line"><span class="cl"><span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1">//go:nowritebarrierrec
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">sighandler</span><span class="p">(</span><span class="nx">sig</span> <span class="kt">uint32</span><span class="p">,</span> <span class="nx">info</span> <span class="o">*</span><span class="nx">siginfo</span><span class="p">,</span> <span class="nx">ctxt</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">,</span> <span class="nx">gp</span> <span class="o">*</span><span class="nx">g</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// ... ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// sig == sigPreempt：抢占信号
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// debug.asyncpreemptoff == 0：没有禁止抢占
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// delayedSignal：延迟信号?
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="nx">sig</span> <span class="o">==</span> <span class="nx">sigPreempt</span> <span class="o">&amp;&amp;</span> <span class="nx">debug</span><span class="p">.</span><span class="nx">asyncpreemptoff</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="p">!</span><span class="nx">delayedSignal</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// Might be a preemption signal.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// 可能是一个抢占信号。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="nf">doSigPreempt</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="nx">c</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// Even if this was definitely a preemption signal, it
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// may have been coalesced with another signal, so we
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// still let it through to the application.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// 即使这确实是一个抢占信号，它可能已经与另一个信号合并，所以我们仍然让它通过应用程序。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c1">// ... ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="dosigpreempt">doSigPreempt()<a hidden class="anchor" aria-hidden="true" href="#dosigpreempt">#</a></h3>
<ol>
<li>doSigPreempt处理gp上的抢占信号。</li>
<li>调用到<code>doSigPreempt</code>时，会将<code>ctx</code>这个参数传入，其中包含了进程用户态硬件上下文</li>
<li><code>ctxt</code>的类型为<code>*sigctxt</code>，指向的是用户态堆栈中存放内核态堆栈内容的地址。</li>
<li>然后信号处理程序通过<code>isAsyncSafePoint</code>来判断抢占位置是否安全，并返回安全的抢占地址。</li>
<li>如果确认抢占没有问题，接着会调用<code>pushCall</code>方法来修改<code>ctxt</code>中的用户态硬件上下文，</li>
<li>用于稍后再一次从内核态返回用户态时模拟出一个用户态程序调用<code>asyncPreempt</code>的假象。</li>
<li>文件位置：go1.19.3/src/runtime/signal_unix.go。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">340
</span><span class="lnt">341
</span><span class="lnt">342
</span><span class="lnt">343
</span><span class="lnt">344
</span><span class="lnt">345
</span><span class="lnt">346
</span><span class="lnt">347
</span><span class="lnt">348
</span><span class="lnt">349
</span><span class="lnt">350
</span><span class="lnt">351
</span><span class="lnt">352
</span><span class="lnt">353
</span><span class="lnt">354
</span><span class="lnt">355
</span><span class="lnt">356
</span><span class="lnt">357
</span><span class="lnt">358
</span><span class="lnt">359
</span><span class="lnt">360
</span><span class="lnt">361
</span><span class="lnt">362
</span><span class="lnt">363
</span><span class="lnt">364
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// doSigPreempt handles a preemption signal on gp.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">doSigPreempt</span><span class="p">(</span><span class="nx">gp</span> <span class="o">*</span><span class="nx">g</span><span class="p">,</span> <span class="nx">ctxt</span> <span class="o">*</span><span class="nx">sigctxt</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Check if this G wants to be preempted and is safe to
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// preempt.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 检查这个G是否希望被抢占，并且抢占是安全的。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 通过 wantAsyncPreempt 函数确认runtime确实想要对指定的G实施异步抢占
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nf">wantAsyncPreempt</span><span class="p">(</span><span class="nx">gp</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 通过isAsyncSafePoint函数确认G当前执行上下文是能够安全地进行异步抢占的。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="nx">ok</span><span class="p">,</span> <span class="nx">newpc</span> <span class="o">:=</span> <span class="nf">isAsyncSafePoint</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="nx">ctxt</span><span class="p">.</span><span class="nf">sigpc</span><span class="p">(),</span> <span class="nx">ctxt</span><span class="p">.</span><span class="nf">sigsp</span><span class="p">(),</span> <span class="nx">ctxt</span><span class="p">.</span><span class="nf">siglr</span><span class="p">());</span> <span class="nx">ok</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// Adjust the PC and inject a call to asyncPreempt.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// 以上两个函数都确认无误后，才通过pushCall向G的执行上下文中注入一个函数调用，
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// 要调用的目标函数是 runtime.asyncPreempt 函数。这是一个汇编函数，它会先把各个寄存器的值保存在栈上，
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// 也就是将现场保存在栈上，然后调用 runtime.asyncPreempt2函数。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="nx">ctxt</span><span class="p">.</span><span class="nf">pushCall</span><span class="p">(</span><span class="nx">abi</span><span class="p">.</span><span class="nf">FuncPCABI0</span><span class="p">(</span><span class="nx">asyncPreempt</span><span class="p">),</span> <span class="nx">newpc</span><span class="p">)</span> <span class="c1">// 就是向当前运行的goroutine注册加入asyncPreempt函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// Acknowledge the preemption.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">atomic</span><span class="p">.</span><span class="nf">Xadd</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">gp</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">preemptGen</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nx">atomic</span><span class="p">.</span><span class="nf">Store</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">gp</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">signalPending</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">GOOS</span> <span class="o">==</span> <span class="s">&#34;darwin&#34;</span> <span class="o">||</span> <span class="nx">GOOS</span> <span class="o">==</span> <span class="s">&#34;ios&#34;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">atomic</span><span class="p">.</span><span class="nf">Xadd</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">pendingPreemptSignals</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="wantasyncpreempt">wantAsyncPreempt()<a hidden class="anchor" aria-hidden="true" href="#wantasyncpreempt">#</a></h3>
<ol>
<li>wantAsyncPreempt返回异步抢占是否为gp排队。</li>
<li>文件位置：go1.19.3/src/runtime/preempt.go。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">340
</span><span class="lnt">341
</span><span class="lnt">342
</span><span class="lnt">343
</span><span class="lnt">344
</span><span class="lnt">345
</span><span class="lnt">346
</span><span class="lnt">347
</span><span class="lnt">348
</span><span class="lnt">349
</span><span class="lnt">350
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// wantAsyncPreempt returns whether an asynchronous preemption is
</span></span></span><span class="line"><span class="cl"><span class="c1">// queued for gp.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">wantAsyncPreempt</span><span class="p">(</span><span class="nx">gp</span> <span class="o">*</span><span class="nx">g</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Check both the G and the P.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 同时检查G和P的preempt字段，并且G当前需要处于_Grunning状态。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 在每轮调度循环中，P和G的preempt字段都会被置为false，所以这个检测能够避免刚刚切换至一个新的G后马上又被抢占。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// gp.preempt || gp.m.p != 0 &amp;&amp; gp.m.p.ptr().preempt：判断G或P的preempt抢占标识位。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// readgstatus(gp)&amp;^_Gscan == _Grunning：当前G正在运行状态。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 确认是否设置了抢占标志
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">return</span> <span class="p">(</span><span class="nx">gp</span><span class="p">.</span><span class="nx">preempt</span> <span class="o">||</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">p</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">p</span><span class="p">.</span><span class="nf">ptr</span><span class="p">().</span><span class="nx">preempt</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="nf">readgstatus</span><span class="p">(</span><span class="nx">gp</span><span class="p">)</span><span class="o">&amp;^</span><span class="nx">_Gscan</span> <span class="o">==</span> <span class="nx">_Grunning</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="isasyncsafepoint">isAsyncSafePoint()<a hidden class="anchor" aria-hidden="true" href="#isasyncsafepoint">#</a></h3>
<ol>
<li>它从以下几个方面来保证在当前位置进行异步抢占是安全的。
<ol>
<li>可以挂起G并安全的扫描它的栈和寄存器，没有潜在的隐藏指针，而且当前并没有打断一个写屏障。</li>
<li>G还有足够的栈空间来注入一个对asyncPreempt()函数的调用。</li>
<li>可以安全地和 runtime 进行交互，例如未持有 runtime 相关的锁，因此在尝试获得锁时不会造成死锁。</li>
</ol>
</li>
<li>isAsyncSafePoint报告指令PC上的gp是否是异步安全点。这表明：
<ol>
<li>暂停gp并保守地扫描它的堆栈和寄存器是安全的。它没有潜在的隐藏指针值，也不像写屏障那样位于原子序列的中间。</li>
<li>gp有足够的堆栈空间注入asyncPreempt调用。</li>
<li>通常情况下，与运行时交互是安全的，即使我们在信号处理程序中就停在这里。例如，没有持有运行时锁，因此获取运行时锁不会自死锁。</li>
</ol>
</li>
<li>在某些情况下，PC是安全的异步抢占，但它也需要调整恢复PC。新的PC在第二个结果中返回。</li>
<li>文件位置：go1.19.3/src/runtime/preempt.go。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">347
</span><span class="lnt">348
</span><span class="lnt">349
</span><span class="lnt">350
</span><span class="lnt">351
</span><span class="lnt">352
</span><span class="lnt">353
</span><span class="lnt">354
</span><span class="lnt">355
</span><span class="lnt">356
</span><span class="lnt">357
</span><span class="lnt">358
</span><span class="lnt">359
</span><span class="lnt">360
</span><span class="lnt">361
</span><span class="lnt">362
</span><span class="lnt">363
</span><span class="lnt">364
</span><span class="lnt">365
</span><span class="lnt">366
</span><span class="lnt">367
</span><span class="lnt">368
</span><span class="lnt">369
</span><span class="lnt">370
</span><span class="lnt">371
</span><span class="lnt">372
</span><span class="lnt">373
</span><span class="lnt">374
</span><span class="lnt">375
</span><span class="lnt">376
</span><span class="lnt">377
</span><span class="lnt">378
</span><span class="lnt">379
</span><span class="lnt">380
</span><span class="lnt">381
</span><span class="lnt">382
</span><span class="lnt">383
</span><span class="lnt">384
</span><span class="lnt">385
</span><span class="lnt">386
</span><span class="lnt">387
</span><span class="lnt">388
</span><span class="lnt">389
</span><span class="lnt">390
</span><span class="lnt">391
</span><span class="lnt">392
</span><span class="lnt">393
</span><span class="lnt">394
</span><span class="lnt">395
</span><span class="lnt">396
</span><span class="lnt">397
</span><span class="lnt">398
</span><span class="lnt">399
</span><span class="lnt">400
</span><span class="lnt">401
</span><span class="lnt">402
</span><span class="lnt">403
</span><span class="lnt">404
</span><span class="lnt">405
</span><span class="lnt">406
</span><span class="lnt">407
</span><span class="lnt">408
</span><span class="lnt">409
</span><span class="lnt">410
</span><span class="lnt">411
</span><span class="lnt">412
</span><span class="lnt">413
</span><span class="lnt">414
</span><span class="lnt">415
</span><span class="lnt">416
</span><span class="lnt">417
</span><span class="lnt">418
</span><span class="lnt">419
</span><span class="lnt">420
</span><span class="lnt">421
</span><span class="lnt">422
</span><span class="lnt">423
</span><span class="lnt">424
</span><span class="lnt">425
</span><span class="lnt">426
</span><span class="lnt">427
</span><span class="lnt">428
</span><span class="lnt">429
</span><span class="lnt">430
</span><span class="lnt">431
</span><span class="lnt">432
</span><span class="lnt">433
</span><span class="lnt">434
</span><span class="lnt">435
</span><span class="lnt">436
</span><span class="lnt">437
</span><span class="lnt">438
</span><span class="lnt">439
</span><span class="lnt">440
</span><span class="lnt">441
</span><span class="lnt">442
</span><span class="lnt">443
</span><span class="lnt">444
</span><span class="lnt">445
</span><span class="lnt">446
</span><span class="lnt">447
</span><span class="lnt">448
</span><span class="lnt">449
</span><span class="lnt">450
</span><span class="lnt">451
</span><span class="lnt">452
</span><span class="lnt">453
</span><span class="lnt">454
</span><span class="lnt">455
</span><span class="lnt">456
</span><span class="lnt">457
</span><span class="lnt">458
</span><span class="lnt">459
</span><span class="lnt">460
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// isAsyncSafePoint reports whether gp at instruction PC is an
</span></span></span><span class="line"><span class="cl"><span class="c1">// asynchronous safe point. This indicates that:
</span></span></span><span class="line"><span class="cl"><span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1">// 1. It&#39;s safe to suspend gp and conservatively scan its stack and
</span></span></span><span class="line"><span class="cl"><span class="c1">// registers. There are no potentially hidden pointer values and it&#39;s
</span></span></span><span class="line"><span class="cl"><span class="c1">// not in the middle of an atomic sequence like a write barrier.
</span></span></span><span class="line"><span class="cl"><span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1">// 2. gp has enough stack space to inject the asyncPreempt call.
</span></span></span><span class="line"><span class="cl"><span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1">// 3. It&#39;s generally safe to interact with the runtime, even if we&#39;re
</span></span></span><span class="line"><span class="cl"><span class="c1">// in a signal handler stopped here. For example, there are no runtime
</span></span></span><span class="line"><span class="cl"><span class="c1">// locks held, so acquiring a runtime lock won&#39;t self-deadlock.
</span></span></span><span class="line"><span class="cl"><span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1">// In some cases the PC is safe for asynchronous preemption but it
</span></span></span><span class="line"><span class="cl"><span class="c1">// also needs to adjust the resumption PC. The new PC is returned in
</span></span></span><span class="line"><span class="cl"><span class="c1">// the second result.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">isAsyncSafePoint</span><span class="p">(</span><span class="nx">gp</span> <span class="o">*</span><span class="nx">g</span><span class="p">,</span> <span class="nx">pc</span><span class="p">,</span> <span class="nx">sp</span><span class="p">,</span> <span class="nx">lr</span> <span class="kt">uintptr</span><span class="p">)</span> <span class="p">(</span><span class="kt">bool</span><span class="p">,</span> <span class="kt">uintptr</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">mp</span> <span class="o">:=</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">m</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// Only user Gs can have safe-points. We check this first
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// because it&#39;s extremely common that we&#39;ll catch mp in the
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// scheduler processing this G preemption.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 只有用户Gs可以有安全点。我们首先检查这个，因为在处理G抢占的调度器中捕获mp是非常常见的。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nx">mp</span><span class="p">.</span><span class="nx">curg</span> <span class="o">!=</span> <span class="nx">gp</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="kc">false</span><span class="p">,</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// Check M state.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 检查M状态。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// canPreemptM(mp) -&gt; mp.locks == 0 &amp;&amp; mp.mallocing == 0 &amp;&amp; mp.preemptoff == &#34;&#34; &amp;&amp; mp.p.ptr().status == _Prunning
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nx">mp</span><span class="p">.</span><span class="nx">p</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="p">!</span><span class="nf">canPreemptM</span><span class="p">(</span><span class="nx">mp</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="kc">false</span><span class="p">,</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// Check stack space.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 检查栈空间。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// asyncPreemptStack是注入一个asyncPreempt调用所需的栈空间的字节。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nx">sp</span> <span class="p">&lt;</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">stack</span><span class="p">.</span><span class="nx">lo</span> <span class="o">||</span> <span class="nx">sp</span><span class="o">-</span><span class="nx">gp</span><span class="p">.</span><span class="nx">stack</span><span class="p">.</span><span class="nx">lo</span> <span class="p">&lt;</span> <span class="nx">asyncPreemptStack</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="kc">false</span><span class="p">,</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// Check if PC is an unsafe-point.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 检查PC是否为不安全点。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">f</span> <span class="o">:=</span> <span class="nf">findfunc</span><span class="p">(</span><span class="nx">pc</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">!</span><span class="nx">f</span><span class="p">.</span><span class="nf">valid</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// Not Go code.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">return</span> <span class="kc">false</span><span class="p">,</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="nx">GOARCH</span> <span class="o">==</span> <span class="s">&#34;mips&#34;</span> <span class="o">||</span> <span class="nx">GOARCH</span> <span class="o">==</span> <span class="s">&#34;mipsle&#34;</span> <span class="o">||</span> <span class="nx">GOARCH</span> <span class="o">==</span> <span class="s">&#34;mips64&#34;</span> <span class="o">||</span> <span class="nx">GOARCH</span> <span class="o">==</span> <span class="s">&#34;mips64le&#34;</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="nx">lr</span> <span class="o">==</span> <span class="nx">pc</span><span class="o">+</span><span class="mi">8</span> <span class="o">&amp;&amp;</span> <span class="nf">funcspdelta</span><span class="p">(</span><span class="nx">f</span><span class="p">,</span> <span class="nx">pc</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// We probably stopped at a half-executed CALL instruction,
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// where the LR is updated but the PC has not. If we preempt
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// here we&#39;ll see a seemingly self-recursive call, which is in
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// fact not.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// This is normally ok, as we use the return address saved on
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// stack for unwinding, not the LR value. But if this is a
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// call to morestack, we haven&#39;t created the frame, and we&#39;ll
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// use the LR for unwinding, which will be bad.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">return</span> <span class="kc">false</span><span class="p">,</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nx">up</span><span class="p">,</span> <span class="nx">startpc</span> <span class="o">:=</span> <span class="nf">pcdatavalue2</span><span class="p">(</span><span class="nx">f</span><span class="p">,</span> <span class="nx">_PCDATA_UnsafePoint</span><span class="p">,</span> <span class="nx">pc</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">up</span> <span class="o">==</span> <span class="nx">_PCDATA_UnsafePointUnsafe</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// Unsafe-point marked by compiler. This includes
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// atomic sequences (e.g., write barrier) and nosplit
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// functions (except at calls).
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">return</span> <span class="kc">false</span><span class="p">,</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">fd</span> <span class="o">:=</span> <span class="nf">funcdata</span><span class="p">(</span><span class="nx">f</span><span class="p">,</span> <span class="nx">_FUNCDATA_LocalsPointerMaps</span><span class="p">);</span> <span class="nx">fd</span> <span class="o">==</span> <span class="kc">nil</span> <span class="o">||</span> <span class="nx">f</span><span class="p">.</span><span class="nx">flag</span><span class="o">&amp;</span><span class="nx">funcFlag_ASM</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// This is assembly code. Don&#39;t assume it&#39;s well-formed.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// TODO: Empirically we still need the fd == nil check. Why?
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// TODO: Are there cases that are safe but don&#39;t have a
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// locals pointer map, like empty frame functions?
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// It might be possible to preempt any assembly functions
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// except the ones that have funcFlag_SPWRITE set in f.flag.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">return</span> <span class="kc">false</span><span class="p">,</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nx">name</span> <span class="o">:=</span> <span class="nf">funcname</span><span class="p">(</span><span class="nx">f</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">inldata</span> <span class="o">:=</span> <span class="nf">funcdata</span><span class="p">(</span><span class="nx">f</span><span class="p">,</span> <span class="nx">_FUNCDATA_InlTree</span><span class="p">);</span> <span class="nx">inldata</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">inltree</span> <span class="o">:=</span> <span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">20</span><span class="p">]</span><span class="nx">inlinedCall</span><span class="p">)(</span><span class="nx">inldata</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="nx">ix</span> <span class="o">:=</span> <span class="nf">pcdatavalue</span><span class="p">(</span><span class="nx">f</span><span class="p">,</span> <span class="nx">_PCDATA_InlTreeIndex</span><span class="p">,</span> <span class="nx">pc</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="nx">ix</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nx">name</span> <span class="p">=</span> <span class="nf">funcnameFromNameoff</span><span class="p">(</span><span class="nx">f</span><span class="p">,</span> <span class="nx">inltree</span><span class="p">[</span><span class="nx">ix</span><span class="p">].</span><span class="nx">func_</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nf">hasPrefix</span><span class="p">(</span><span class="nx">name</span><span class="p">,</span> <span class="s">&#34;runtime.&#34;</span><span class="p">)</span> <span class="o">||</span>
</span></span><span class="line"><span class="cl">        <span class="nf">hasPrefix</span><span class="p">(</span><span class="nx">name</span><span class="p">,</span> <span class="s">&#34;runtime/internal/&#34;</span><span class="p">)</span> <span class="o">||</span>
</span></span><span class="line"><span class="cl">        <span class="nf">hasPrefix</span><span class="p">(</span><span class="nx">name</span><span class="p">,</span> <span class="s">&#34;reflect.&#34;</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// For now we never async preempt the runtime or
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// anything closely tied to the runtime. Known issues
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// include: various points in the scheduler (&#34;don&#39;t
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// preempt between here and here&#34;), much of the defer
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// implementation (untyped info on stack), bulk write
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// barriers (write barrier check),
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// reflect.{makeFuncStub,methodValueCall}.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// TODO(austin): We should improve this, or opt things
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// in incrementally.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">return</span> <span class="kc">false</span><span class="p">,</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">switch</span> <span class="nx">up</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="nx">_PCDATA_Restart1</span><span class="p">,</span> <span class="nx">_PCDATA_Restart2</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// Restartable instruction sequence. Back off PC to
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// the start PC.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="nx">startpc</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="nx">startpc</span> <span class="p">&gt;</span> <span class="nx">pc</span> <span class="o">||</span> <span class="nx">pc</span><span class="o">-</span><span class="nx">startpc</span> <span class="p">&gt;</span> <span class="mi">20</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nf">throw</span><span class="p">(</span><span class="s">&#34;bad restart PC&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="kc">true</span><span class="p">,</span> <span class="nx">startpc</span>
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="nx">_PCDATA_RestartAtEntry</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// Restart from the function entry at resumption.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">return</span> <span class="kc">true</span><span class="p">,</span> <span class="nx">f</span><span class="p">.</span><span class="nf">entry</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="kc">true</span><span class="p">,</span> <span class="nx">pc</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="pushcall">pushCall()<a hidden class="anchor" aria-hidden="true" href="#pushcall">#</a></h3>
<ol>
<li><code>pushCall</code>干了两件事：
<ul>
<li>修改程序计数器的指向为<code>asyncPreempt</code>函数的地址。</li>
<li>修改栈顶指针，将当前 goroutine 的原本中断地址放入堆栈。</li>
</ul>
</li>
<li>文件位置：go1.19.3/src/runtime/signal_amd64.go。</li>
<li>先把SP向下移动一个指针大小的位置，把PC的值存入栈上SP指向的位置，然后将PC的值更新为targetPC。</li>
<li>这样就模拟了一条CALL指令的效果，栈上存入的PC的旧值就相当于返回地址。</li>
<li>此时整个执行上下文的状态就像是goroutine在被信号打断的位置额外执行了一条CALL targetPC指令。</li>
<li>由于执行流程刚刚跳转到targetPC地址处，所以还没来得及执行目标地址处的指令。</li>
<li>当sighandler()函数处理完信号并返回后，被打断的goroutine得以继续执行，会立即调用被注入的asyncPreempt()函数。经过一连串的函数调用，最终执行到schedule()函数。</li>
<li>参数：
<ul>
<li><code>targetPC uintptr</code>：asyncPreempt 函数的执行入口地址。</li>
<li><code>resumePC uintptr</code>：其实就是发生中断前当前goroutine的下一指令地址，也就是PC的值。</li>
</ul>
</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">80
</span><span class="lnt">81
</span><span class="lnt">82
</span><span class="lnt">83
</span><span class="lnt">84
</span><span class="lnt">85
</span><span class="lnt">86
</span><span class="lnt">87
</span><span class="lnt">88
</span><span class="lnt">89
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">sigctxt</span><span class="p">)</span> <span class="nf">pushCall</span><span class="p">(</span><span class="nx">targetPC</span><span class="p">,</span> <span class="nx">resumePC</span> <span class="kt">uintptr</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Make it look like we called target at resumePC.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 让它看起来像我们在resumePC上调用了target。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">sp</span> <span class="o">:=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nf">rsp</span><span class="p">())</span> <span class="c1">// 当前goroutine的SP
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">sp</span> <span class="o">-=</span> <span class="nx">goarch</span><span class="p">.</span><span class="nx">PtrSize</span>
</span></span><span class="line"><span class="cl">    <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="kt">uintptr</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">sp</span><span class="p">))</span> <span class="p">=</span> <span class="nx">resumePC</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 设置当前中断保存的上下文信息，因为中断结束后从这里恢复。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">c</span><span class="p">.</span><span class="nf">set_rsp</span><span class="p">(</span><span class="nb">uint64</span><span class="p">(</span><span class="nx">sp</span><span class="p">))</span>       <span class="c1">// 修改中断保存的上下文SP
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">c</span><span class="p">.</span><span class="nf">set_rip</span><span class="p">(</span><span class="nb">uint64</span><span class="p">(</span><span class="nx">targetPC</span><span class="p">))</span> <span class="c1">// 修改中断保存的上下文PC
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><img loading="lazy" src="../images/goroutine-015.png" alt=""  />
</p>
<h3 id="asyncpreempt">asyncPreempt()<a hidden class="anchor" aria-hidden="true" href="#asyncpreempt">#</a></h3>
<ol>
<li>中断信号函数处理完后，goroutine得到运行，继续从嵌入的本函数开始执行。</li>
<li>文件位置：go1.19.3/src/runtime/preempt_amd64.s。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span><span class="lnt">77
</span><span class="lnt">78
</span><span class="lnt">79
</span><span class="lnt">80
</span><span class="lnt">81
</span><span class="lnt">82
</span><span class="lnt">83
</span><span class="lnt">84
</span><span class="lnt">85
</span><span class="lnt">86
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-asm" data-lang="asm"><span class="line"><span class="cl"><span class="nf">TEXT</span> <span class="err">·</span><span class="no">asyncPreempt</span><span class="p">(</span><span class="no">SB</span><span class="p">),</span><span class="no">NOSPLIT</span><span class="err">|</span><span class="no">NOFRAME</span><span class="p">,</span><span class="no">$0-0</span>
</span></span><span class="line"><span class="cl">    <span class="nf">PUSHQ</span> <span class="no">BP</span>        <span class="c1"># BP入栈
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">MOVQ</span> <span class="no">SP</span><span class="p">,</span> <span class="no">BP</span>     <span class="c1"># BP = SP
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1"># Save flags before clobbering them
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">PUSHFQ</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># obj doesn&#39;t understand ADD/SUB on SP, but does understand ADJSP
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">ADJSP</span> <span class="no">$368</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># But vet doesn&#39;t know ADJSP, so suppress vet stack checking
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">NOP</span> <span class="no">SP</span>
</span></span><span class="line"><span class="cl">    <span class="nf">MOVQ</span> <span class="no">AX</span><span class="p">,</span> <span class="mi">0</span><span class="p">(</span><span class="no">SP</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nf">MOVQ</span> <span class="no">CX</span><span class="p">,</span> <span class="mi">8</span><span class="p">(</span><span class="no">SP</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nf">MOVQ</span> <span class="no">DX</span><span class="p">,</span> <span class="mi">16</span><span class="p">(</span><span class="no">SP</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nf">MOVQ</span> <span class="no">BX</span><span class="p">,</span> <span class="mi">24</span><span class="p">(</span><span class="no">SP</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nf">MOVQ</span> <span class="no">SI</span><span class="p">,</span> <span class="mi">32</span><span class="p">(</span><span class="no">SP</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nf">MOVQ</span> <span class="no">DI</span><span class="p">,</span> <span class="mi">40</span><span class="p">(</span><span class="no">SP</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nf">MOVQ</span> <span class="no">R8</span><span class="p">,</span> <span class="mi">48</span><span class="p">(</span><span class="no">SP</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nf">MOVQ</span> <span class="no">R9</span><span class="p">,</span> <span class="mi">56</span><span class="p">(</span><span class="no">SP</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nf">MOVQ</span> <span class="no">R10</span><span class="p">,</span> <span class="mi">64</span><span class="p">(</span><span class="no">SP</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nf">MOVQ</span> <span class="no">R11</span><span class="p">,</span> <span class="mi">72</span><span class="p">(</span><span class="no">SP</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nf">MOVQ</span> <span class="no">R12</span><span class="p">,</span> <span class="mi">80</span><span class="p">(</span><span class="no">SP</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nf">MOVQ</span> <span class="no">R13</span><span class="p">,</span> <span class="mi">88</span><span class="p">(</span><span class="no">SP</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nf">MOVQ</span> <span class="no">R14</span><span class="p">,</span> <span class="mi">96</span><span class="p">(</span><span class="no">SP</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nf">MOVQ</span> <span class="no">R15</span><span class="p">,</span> <span class="mi">104</span><span class="p">(</span><span class="no">SP</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="c1">#ifdef GOOS_darwin
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">CMPB</span> <span class="no">internal</span><span class="err">∕</span><span class="no">cpu</span><span class="err">·</span><span class="no">X86</span><span class="err">+</span><span class="no">const_offsetX86HasAVX</span><span class="p">(</span><span class="no">SB</span><span class="p">),</span> <span class="no">$0</span>
</span></span><span class="line"><span class="cl">    <span class="nf">JE</span> <span class="mi">2</span><span class="p">(</span><span class="no">PC</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nf">VZEROUPPER</span>
</span></span><span class="line"><span class="cl">    <span class="c1">#endif
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">MOVUPS</span> <span class="no">X0</span><span class="p">,</span> <span class="mi">112</span><span class="p">(</span><span class="no">SP</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nf">MOVUPS</span> <span class="no">X1</span><span class="p">,</span> <span class="mi">128</span><span class="p">(</span><span class="no">SP</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nf">MOVUPS</span> <span class="no">X2</span><span class="p">,</span> <span class="mi">144</span><span class="p">(</span><span class="no">SP</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nf">MOVUPS</span> <span class="no">X3</span><span class="p">,</span> <span class="mi">160</span><span class="p">(</span><span class="no">SP</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nf">MOVUPS</span> <span class="no">X4</span><span class="p">,</span> <span class="mi">176</span><span class="p">(</span><span class="no">SP</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nf">MOVUPS</span> <span class="no">X5</span><span class="p">,</span> <span class="mi">192</span><span class="p">(</span><span class="no">SP</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nf">MOVUPS</span> <span class="no">X6</span><span class="p">,</span> <span class="mi">208</span><span class="p">(</span><span class="no">SP</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nf">MOVUPS</span> <span class="no">X7</span><span class="p">,</span> <span class="mi">224</span><span class="p">(</span><span class="no">SP</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nf">MOVUPS</span> <span class="no">X8</span><span class="p">,</span> <span class="mi">240</span><span class="p">(</span><span class="no">SP</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nf">MOVUPS</span> <span class="no">X9</span><span class="p">,</span> <span class="mi">256</span><span class="p">(</span><span class="no">SP</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nf">MOVUPS</span> <span class="no">X10</span><span class="p">,</span> <span class="mi">272</span><span class="p">(</span><span class="no">SP</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nf">MOVUPS</span> <span class="no">X11</span><span class="p">,</span> <span class="mi">288</span><span class="p">(</span><span class="no">SP</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nf">MOVUPS</span> <span class="no">X12</span><span class="p">,</span> <span class="mi">304</span><span class="p">(</span><span class="no">SP</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nf">MOVUPS</span> <span class="no">X13</span><span class="p">,</span> <span class="mi">320</span><span class="p">(</span><span class="no">SP</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nf">MOVUPS</span> <span class="no">X14</span><span class="p">,</span> <span class="mi">336</span><span class="p">(</span><span class="no">SP</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nf">MOVUPS</span> <span class="no">X15</span><span class="p">,</span> <span class="mi">352</span><span class="p">(</span><span class="no">SP</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nf">CALL</span> <span class="err">·</span><span class="no">asyncPreempt2</span><span class="p">(</span><span class="no">SB</span><span class="p">)</span> <span class="c1"># 调用asyncPreempt2
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="c1"># 下次goroutine再度被运行起来时，从这里恢复。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">MOVUPS</span> <span class="mi">352</span><span class="p">(</span><span class="no">SP</span><span class="p">),</span> <span class="no">X15</span>
</span></span><span class="line"><span class="cl">    <span class="nf">MOVUPS</span> <span class="mi">336</span><span class="p">(</span><span class="no">SP</span><span class="p">),</span> <span class="no">X14</span>
</span></span><span class="line"><span class="cl">    <span class="nf">MOVUPS</span> <span class="mi">320</span><span class="p">(</span><span class="no">SP</span><span class="p">),</span> <span class="no">X13</span>
</span></span><span class="line"><span class="cl">    <span class="nf">MOVUPS</span> <span class="mi">304</span><span class="p">(</span><span class="no">SP</span><span class="p">),</span> <span class="no">X12</span>
</span></span><span class="line"><span class="cl">    <span class="nf">MOVUPS</span> <span class="mi">288</span><span class="p">(</span><span class="no">SP</span><span class="p">),</span> <span class="no">X11</span>
</span></span><span class="line"><span class="cl">    <span class="nf">MOVUPS</span> <span class="mi">272</span><span class="p">(</span><span class="no">SP</span><span class="p">),</span> <span class="no">X10</span>
</span></span><span class="line"><span class="cl">    <span class="nf">MOVUPS</span> <span class="mi">256</span><span class="p">(</span><span class="no">SP</span><span class="p">),</span> <span class="no">X9</span>
</span></span><span class="line"><span class="cl">    <span class="nf">MOVUPS</span> <span class="mi">240</span><span class="p">(</span><span class="no">SP</span><span class="p">),</span> <span class="no">X8</span>
</span></span><span class="line"><span class="cl">    <span class="nf">MOVUPS</span> <span class="mi">224</span><span class="p">(</span><span class="no">SP</span><span class="p">),</span> <span class="no">X7</span>
</span></span><span class="line"><span class="cl">    <span class="nf">MOVUPS</span> <span class="mi">208</span><span class="p">(</span><span class="no">SP</span><span class="p">),</span> <span class="no">X6</span>
</span></span><span class="line"><span class="cl">    <span class="nf">MOVUPS</span> <span class="mi">192</span><span class="p">(</span><span class="no">SP</span><span class="p">),</span> <span class="no">X5</span>
</span></span><span class="line"><span class="cl">    <span class="nf">MOVUPS</span> <span class="mi">176</span><span class="p">(</span><span class="no">SP</span><span class="p">),</span> <span class="no">X4</span>
</span></span><span class="line"><span class="cl">    <span class="nf">MOVUPS</span> <span class="mi">160</span><span class="p">(</span><span class="no">SP</span><span class="p">),</span> <span class="no">X3</span>
</span></span><span class="line"><span class="cl">    <span class="nf">MOVUPS</span> <span class="mi">144</span><span class="p">(</span><span class="no">SP</span><span class="p">),</span> <span class="no">X2</span>
</span></span><span class="line"><span class="cl">    <span class="nf">MOVUPS</span> <span class="mi">128</span><span class="p">(</span><span class="no">SP</span><span class="p">),</span> <span class="no">X1</span>
</span></span><span class="line"><span class="cl">    <span class="nf">MOVUPS</span> <span class="mi">112</span><span class="p">(</span><span class="no">SP</span><span class="p">),</span> <span class="no">X0</span>
</span></span><span class="line"><span class="cl">    <span class="nf">MOVQ</span> <span class="mi">104</span><span class="p">(</span><span class="no">SP</span><span class="p">),</span> <span class="no">R15</span>
</span></span><span class="line"><span class="cl">    <span class="nf">MOVQ</span> <span class="mi">96</span><span class="p">(</span><span class="no">SP</span><span class="p">),</span> <span class="no">R14</span>
</span></span><span class="line"><span class="cl">    <span class="nf">MOVQ</span> <span class="mi">88</span><span class="p">(</span><span class="no">SP</span><span class="p">),</span> <span class="no">R13</span>
</span></span><span class="line"><span class="cl">    <span class="nf">MOVQ</span> <span class="mi">80</span><span class="p">(</span><span class="no">SP</span><span class="p">),</span> <span class="no">R12</span>
</span></span><span class="line"><span class="cl">    <span class="nf">MOVQ</span> <span class="mi">72</span><span class="p">(</span><span class="no">SP</span><span class="p">),</span> <span class="no">R11</span>
</span></span><span class="line"><span class="cl">    <span class="nf">MOVQ</span> <span class="mi">64</span><span class="p">(</span><span class="no">SP</span><span class="p">),</span> <span class="no">R10</span>
</span></span><span class="line"><span class="cl">    <span class="nf">MOVQ</span> <span class="mi">56</span><span class="p">(</span><span class="no">SP</span><span class="p">),</span> <span class="no">R9</span>
</span></span><span class="line"><span class="cl">    <span class="nf">MOVQ</span> <span class="mi">48</span><span class="p">(</span><span class="no">SP</span><span class="p">),</span> <span class="no">R8</span>
</span></span><span class="line"><span class="cl">    <span class="nf">MOVQ</span> <span class="mi">40</span><span class="p">(</span><span class="no">SP</span><span class="p">),</span> <span class="no">DI</span>
</span></span><span class="line"><span class="cl">    <span class="nf">MOVQ</span> <span class="mi">32</span><span class="p">(</span><span class="no">SP</span><span class="p">),</span> <span class="no">SI</span>
</span></span><span class="line"><span class="cl">    <span class="nf">MOVQ</span> <span class="mi">24</span><span class="p">(</span><span class="no">SP</span><span class="p">),</span> <span class="no">BX</span>
</span></span><span class="line"><span class="cl">    <span class="nf">MOVQ</span> <span class="mi">16</span><span class="p">(</span><span class="no">SP</span><span class="p">),</span> <span class="no">DX</span>
</span></span><span class="line"><span class="cl">    <span class="nf">MOVQ</span> <span class="mi">8</span><span class="p">(</span><span class="no">SP</span><span class="p">),</span> <span class="no">CX</span>
</span></span><span class="line"><span class="cl">    <span class="nf">MOVQ</span> <span class="mi">0</span><span class="p">(</span><span class="no">SP</span><span class="p">),</span> <span class="no">AX</span>
</span></span><span class="line"><span class="cl">    <span class="nf">ADJSP</span> <span class="no">$-368</span>
</span></span><span class="line"><span class="cl">    <span class="nf">POPFQ</span>
</span></span><span class="line"><span class="cl">    <span class="nf">POPQ</span> <span class="no">BP</span>
</span></span><span class="line"><span class="cl">    <span class="nf">RET</span> <span class="c1"># 返回继续去执行原来的goroutine代码
</span></span></span></code></pre></td></tr></table>
</div>
</div><h3 id="asyncpreempt2">asyncPreempt2()<a hidden class="anchor" aria-hidden="true" href="#asyncpreempt2">#</a></h3>
<ol>
<li>文件位置：go1.19.3/src/runtime/preempt.go。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">301
</span><span class="lnt">302
</span><span class="lnt">303
</span><span class="lnt">304
</span><span class="lnt">305
</span><span class="lnt">306
</span><span class="lnt">307
</span><span class="lnt">308
</span><span class="lnt">309
</span><span class="lnt">310
</span><span class="lnt">311
</span><span class="lnt">312
</span><span class="lnt">313
</span><span class="lnt">314
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">//go:nosplit
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">asyncPreempt2</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">gp</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="nx">gp</span><span class="p">.</span><span class="nx">asyncSafePoint</span> <span class="p">=</span> <span class="kc">true</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// preemptStop 主要在GC标记期间被用来挂起运行中的 goroutine
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">preemptStop</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// preemptPark会把当前g切换至_Gpreempted状态，然后调用schedule函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nf">mcall</span><span class="p">(</span><span class="nx">preemptPark</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 通过preemptone函数发起的异步抢占会调用gopreempt_m函数，它最终也会调用schedule函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nf">mcall</span><span class="p">(</span><span class="nx">gopreempt_m</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nx">gp</span><span class="p">.</span><span class="nx">asyncSafePoint</span> <span class="p">=</span> <span class="kc">false</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="gopreempt_m-1">gopreempt_m()<a hidden class="anchor" aria-hidden="true" href="#gopreempt_m-1">#</a></h3>
<ol>
<li>文件位置：go1.19.3/src/runtime/proc.go。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">3402
</span><span class="lnt">3403
</span><span class="lnt">3404
</span><span class="lnt">3405
</span><span class="lnt">3406
</span><span class="lnt">3407
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">gopreempt_m</span><span class="p">(</span><span class="nx">gp</span> <span class="o">*</span><span class="nx">g</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">trace</span><span class="p">.</span><span class="nx">enabled</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">traceGoPreempt</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nf">goschedImpl</span><span class="p">(</span><span class="nx">gp</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="goschedimpl">goschedImpl()<a hidden class="anchor" aria-hidden="true" href="#goschedimpl">#</a></h3>
<ol>
<li>G加入全局队列，解除G与M的关系，再次发起调度循环。</li>
<li>文件位置：go1.19.3/src/runtime/proc.go。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">3366
</span><span class="lnt">3367
</span><span class="lnt">3368
</span><span class="lnt">3369
</span><span class="lnt">3370
</span><span class="lnt">3371
</span><span class="lnt">3372
</span><span class="lnt">3373
</span><span class="lnt">3374
</span><span class="lnt">3375
</span><span class="lnt">3376
</span><span class="lnt">3377
</span><span class="lnt">3378
</span><span class="lnt">3379
</span><span class="lnt">3380
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">goschedImpl</span><span class="p">(</span><span class="nx">gp</span> <span class="o">*</span><span class="nx">g</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">status</span> <span class="o">:=</span> <span class="nf">readgstatus</span><span class="p">(</span><span class="nx">gp</span><span class="p">)</span> <span class="c1">// 获取G状态
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nx">status</span><span class="o">&amp;^</span><span class="nx">_Gscan</span> <span class="o">!=</span> <span class="nx">_Grunning</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">dumpgstatus</span><span class="p">(</span><span class="nx">gp</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="nf">throw</span><span class="p">(</span><span class="s">&#34;bad g status&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 修改G状态 _Grunnable
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">casgstatus</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="nx">_Grunning</span><span class="p">,</span> <span class="nx">_Grunnable</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nf">dropg</span><span class="p">()</span> <span class="c1">// 解除绑定关系
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nf">globrunqput</span><span class="p">(</span><span class="nx">gp</span><span class="p">)</span> <span class="c1">// 加入全局链表
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nf">schedule</span><span class="p">()</span> <span class="c1">// 调度循环
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div>

  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://helium.github.io/tags/golang/">Golang</a></li>
      <li><a href="https://helium.github.io/tags/goroutine/">Goroutine</a></li>
    </ul>
<nav class="paginav">
  <a class="prev" href="https://helium.github.io/posts/golang/goroutine/gosched/">
    <span class="title">« 上一页</span>
    <br>
    <span>主动让出调度</span>
  </a>
  <a class="next" href="https://helium.github.io/posts/golang/goroutine/struct/">
    <span class="title">下一页 »</span>
    <br>
    <span>runtime中重要的结构体</span>
  </a>
</nav>

  </footer>
</article>
    </main>
    
<footer class="footer">
    
    <div class="busuanzi-footer">
    <span id="busuanzi_container_site_pv">
        本站总访问量<span id="busuanzi_value_site_pv"></span>次
    </span>
    <span id="busuanzi_container_site_uv">
        本站访客数<span id="busuanzi_value_site_uv"></span>人次
    </span>
    </div>
        <span>Copyright © 2024 蜀ICP备2024091074号 <a href="#">heliu's blog</a>. All rights reserved</span>  
    
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'Copy';

        function copyingDone() {
            copybutton.innerHTML = 'Done';
            setTimeout(() => {
                copybutton.innerHTML = 'Copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
