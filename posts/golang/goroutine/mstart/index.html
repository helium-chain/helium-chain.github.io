<!DOCTYPE html>
<html lang="zh" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>GMP 调度模型 | Helium</title>
<meta name="keywords" content="golang, Goroutine">
<meta name="description" content="💥本文章所有相关go代码参考自go 1.18&#43;版本">
<meta name="author" content="helium">
<link rel="canonical" href="https://heliu.site/posts/golang/goroutine/mstart/">
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<meta name="referrer" content="no-referrer-when-downgrade">
<link crossorigin="anonymous" href="/assets/css/stylesheet.css" rel="preload stylesheet" as="style">
<link rel="icon" href="https://heliu.site/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://heliu.site/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://heliu.site/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://heliu.site/apple-touch-icon.png">
<link rel="mask-icon" href="https://heliu.site/apple-touch-icon.png">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="zh" href="https://heliu.site/posts/golang/goroutine/mstart/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
<html>
<head>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/jetbrains-mono@1.0.6/css/jetbrains-mono-nl.min.css" />
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lxgw-wenkai-lite-webfont@1.1.0/style.css" />
    <link rel="stylesheet" href="https://cdn.staticfile.org/lxgw-wenkai-screen-webfont/1.6.0/style.css" />
    <style>
        body {
            font-family: "LXGW WenKai Lite", sans-serif;
            font-family: "LXGW WenKai Screen", sans-serif;
        }
    </style>
</head>
</html>

  

<meta property="og:title" content="GMP 调度模型" />
<meta property="og:description" content="💥本文章所有相关go代码参考自go 1.18&#43;版本" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://heliu.site/posts/golang/goroutine/mstart/" />
<meta property="og:image" content="https://heliu.site/favicon-32x32.png" />
<meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-07-30T00:00:00+00:00" />
<meta property="article:modified_time" content="2024-07-30T00:00:00+00:00" /><meta property="og:site_name" content="Helium" />

<meta name="twitter:card" content="summary_large_image" />
<meta name="twitter:image" content="https://heliu.site/favicon-32x32.png" />
<meta name="twitter:title" content="GMP 调度模型"/>
<meta name="twitter:description" content="💥本文章所有相关go代码参考自go 1.18&#43;版本"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Article",
      "item": "https://heliu.site/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Golang",
      "item": "https://heliu.site/posts/golang/"
    }, 
    {
      "@type": "ListItem",
      "position":  3 ,
      "name": "第12章 Goroutine",
      "item": "https://heliu.site/posts/golang/goroutine/"
    }, 
    {
      "@type": "ListItem",
      "position":  4 ,
      "name": "GMP 调度模型",
      "item": "https://heliu.site/posts/golang/goroutine/mstart/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "GMP 调度模型",
  "name": "GMP 调度模型",
  "description": "💥本文章所有相关go代码参考自go 1.18+版本",
  "keywords": [
    "golang", "Goroutine"
  ],
  "articleBody": " 本篇介绍Golang相关调度代码，本篇也是理解GMP模型的重点篇节。 runtime·mstart(SB) 工作线程M的自旋状态(spinning)解释：工作线程在从其它工作线程的本地运行队列中盗取goroutine时的状态称为自旋状态。\n该函数是所有新创建的工作线程需要执行的函数，也是调度循环的入口函数。 所有【新创建的工作线程】开始运行的入口都是从这个函数开始运行的。 文件位置：go1.19.3/src/runtime/asm_amd64.s。 389 390 391 392 393 TEXT runtime·mstart(SB),NOSPLIT|TOPFRAME,$0 # 调用runtime.mstart0函数，该函数永远不会返回 CALL runtime·mstart0(SB) # 未达到。不会到这里来。 RET # not reached mstart0() mstart0是新Ms的Go入口点。该函数是不允许栈增长检查的，因为我们甚至可能还没有设置堆栈边界。 能在STW期间运行（因为它还没有P），所以不允许写屏障。 初始化g0栈大小，以及调用mstart1()函数开启调度循环。 因为可能存在其他刚创建的工作线程并没有初始化g0栈大小，所以这里需要设置一下。 文件位置：go1.19.3/src/runtime/proc.go。 1347 1348 1349 1350 1351 1352 1353 1354 1355 1356 1357 1358 1359 1360 1361 1362 1363 1364 1365 1366 1367 1368 1369 1370 1371 1372 1373 1374 1375 1376 1377 1378 1379 1380 1381 1382 1383 1384 1385 1386 1387 1388 1389 1390 1391 1392 1393 1394 1395 1396 1397 1398 1399 1400 1401 1402 1403 1404 1405 1406 1407 1408 1409 1410 1411 1412 1413 1414 1415 1416 1417 1418 1419 1420 1421 1422 1423 1424 1425 1426 1427 1428 // mstart0 is the Go entry-point for new Ms. // This must not split the stack because we may not even have stack // bounds set up yet. // // May run during STW (because it doesn't have a P yet), so write // barriers are not allowed. // //go:nosplit //go:nowritebarrierrec func mstart0() { // 该函数是工作线程M起来执行的入口函数，这里一定是g0栈。 _g_ := getg() // _g_ = g0 // 当前g是否已分配栈： // 1. 程序刚初始化时前面是分配了大约64KB大小栈。 // 2. 如果是通过wakeup()函数创建的工作线程，这里可能是没有分配栈大小的。 osStack := _g_.stack.lo == 0 // 判断当前g0是否分配栈 if osStack { // 栈未分配大小时，这也是新创建的工作线程需要处理的g栈情况 // Initialize stack bounds from system stack. // Cgo may have left stack size in stack.hi. // minit may update the stack bounds. // // 从系统栈初始化栈边界。Cgo 可能在 stack.hi 中留下了栈大小。minit 可能会更新栈边界。 // // Note: these bounds may not be very accurate. // We set hi to \u0026size, but there are things above // it. The 1024 is supposed to compensate this, // but is somewhat arbitrary. // // 注意：这些界限可能不是很准确。 // 我们将 hi 设置为 \u0026size，但是上面还有一些东西。 // 1024 应该可以弥补这一点，但有些武断。 // 以上的意思是直接在当前工作线程系统栈上给当前这个g0分配栈大小。 // 可能上面有栈数据，偏移1024字节应该能弥补这些数据。 size := _g_.stack.hi // size 多半是0; size 一定是分配在当前栈上的，因此\u0026size就是栈地址。 if size == 0 {\t// sys.StackGuardMultiplier = 1; 可见其他工作线程的g0栈大约为8KB。 size = 8192 * sys.StackGuardMultiplier // 设置size为指定值 } // noescape函数取size地址并与0异或，实际作用是隐藏(防止)size变量逃逸分析指针 // 防止编译器把size变量堆分配，这里需要的是栈分配 // 因此当前_g_的栈备份分配到当前栈的size变量位置 // noescape函数： // func noescape(p unsafe.Pointer) unsafe.Pointer { // x := uintptr(p) // return unsafe.Pointer(x ^ 0) // 防止变量x逃逸 // } // 以\u0026size为起点设置g0栈。g0.stack -\u003e [\u0026size, \u0026size - 8192 + 1024] _g_.stack.hi = uintptr(noescape(unsafe.Pointer(\u0026size))) // hi存储size的地址，也就是rbp _g_.stack.lo = _g_.stack.hi - size + 1024 // lo存储栈顶位置，也就是rsp } // Initialize stack guard so that we can start calling regular // Go code. // // 初始化栈保护，以便我们可以开始调用常规 Go 代码。 // stackguard0 = _g_.stack.lo + 928; 栈溢出检查的阈值点。 _g_.stackguard0 = _g_.stack.lo + _StackGuard // This is the g0, so we can also call go:systemstack // functions, which check stackguard1. // // 这是 g0，所以我们也可以调用 go:systemstack 函数来检查 stackguard1。 _g_.stackguard1 = _g_.stackguard0 mstart1() // 调用mstart1开启调度循环，该函数永远不会返回 // Exit this thread.\t// // 退出这个线程，程序不会到这里。 if mStackIsSystemAllocated() { // Windows, Solaris, illumos, Darwin, AIX and Plan 9 always system-allocate // the stack, but put it in _g_.stack before mstart, // so the logic above hasn't set osStack yet. // // Windows、Solaris、illumos、Darwin、AIX 和Plan 9 总是系统分配栈，但是在mstart 之前放在_g_.stack 中， // 所以上面的逻辑还没有设置osStack osStack = true } mexit(osStack) // 结束当前线程。 } 总结：工作线程开始执行使，先判断g0是否分配了栈大小，没有则分配大约8KB大小栈空间，然后设置stackguard0、stackguard1。 mstart1() 设置g0被调度时的调度信息，比如从哪里进入，栈从哪里开始等，以及给当前工作线程M绑定个P并开启调度循环。 设置g0的调度信息是在于，在调度循环过程中会切换到g0栈执行runtime的相关函数，以免栈无限扩大。 文件位置：go1.19.3/src/runtime/proc.go。 1394 1395 1396 1397 1398 1399 1400 1401 1402 1403 1404 1405 1406 1407 1408 1409 1410 1411 1412 1413 1414 1415 1416 1417 1418 1419 1420 1421 1422 1423 1424 1425 1426 1427 1428 1429 1430 1431 1432 1433 1434 1435 1436 1437 1438 1439 1440 1441 1442 1443 1444 1445 1446 1447 1448 1449 1450 1451 1452 1453 1454 1455 1456 1457 1458 1459 // The go:noinline is to guarantee the getcallerpc/getcallersp below are safe, // so that we can set up g0.sched to return to the call of mstart1 above. //go:noinline func mstart1() { _g_ := getg() // _g_ = g0 // 当前_g_ 一定是g0，因为该函数只有程序初始化或线程刚启动时才会调用。 if _g_ != _g_.m.g0 { throw(\"bad runtime·mstart\") } // Set up m.g0.sched as a label returning to just // after the mstart1 call in mstart0 above, for use by goexit0 and mcall. // We're never coming back to mstart1 after we call schedule, // so other calls can reuse the current frame. // And goexit0 does a gogo that needs to return from mstart1 // and let mstart0 exit the thread. // // 将 m.g0.sched 设置为上面 mstart0 中 mstart1 调用后返回的标签，供 goexit0 和 mcall 使用 // 在调用 schedule 之后，我们永远不会回到 mstart1，因此其他调用可以重用当前帧 // 而goexit0做了一个gogo，需要从mstart1返回，让mstart0退出线程 // g0.sched.g = g0 _g_.sched.g = guintptr(unsafe.Pointer(_g_)) // 设置g0的调度信息是当前g // g0.sched.pc = getcallerpc() // getcallerpc()：调用者函数的下一条指令，也就是mstart0()函数调用mstart1()函数后的if判断指令代码处。 _g_.sched.pc = getcallerpc() // 这里是理解调度循环的关键，调度循环每次切换到g0栈都从这里(指定的固定位置)设置的位置开始使用栈。 // g0.sched.pc = getcallersp() // getcallersp()：调用者当前的SP寄存器值，也就是mstart0()函数调用mstart1()函数时SP寄存器的值。 // 设置rsp寄存器值为master0调用master1时的栈顶处，设置在这里便于每次切换的g0栈都是从固定位置开始 _g_.sched.sp = getcallersp() // go1.19.3/src/runtime/asm_amd64.s // TEXT runtime·asminit(SB),NOSPLIT,$0-0 // // No per-thread init. // RET // 没有什么可做的。 asminit() // 该函数的汇编代码什么都没做，初始化M工作线程 minit() // 调用以初始化一个新的 m（包括引导程序 m），在新线程上调用，无法分配内存 // Install signal handlers; after minit so that minit can // prepare the thread to be able to handle the signals. // // 安装信号处理程序； 在 minit 之后，以便 minit 可以准备线程以处理信号 if _g_.m == \u0026m0 { // 判断g0绑定的m是否是m0，m0是main.goroutine也就是主线程时执行下面方法 mstartm0() } // 如果_g_.m.mstartfn存在则执行该函数： // 1. 一般的情况下该函数是，mspinning()函数。该函数只有一条指令，标记m的mspining字段为true。 // 2. 如果是sysmon线程下，这里是直接调用sysmon()函数，该函数是一个无限循环，这里不会返回。 if fn := _g_.m.mstartfn; fn != nil { fn() } // 程序刚初始化时，一定是m0，因为在前面m0已经绑定了P，所以是m0需要跳过。 // 通过wakeup()函数创建的新的工作线程m时，这里需要绑定个P。 if _g_.m != \u0026m0 { // 不是m0则需要给工作线程M绑定一个P // _g_.m.nextp.ptr()获取下一个P，nextp在wakeup()函数相关被赋值。 acquirep(_g_.m.nextp.ptr()) // 调用acquirep(_g_.m.nextp.ptr())绑定p _g_.m.nextp = 0 } // 开启循环调度，该函数永远不返回 schedule() } minit() 初始化一个新的m（包括引导程序m）。在新线程上调用，无法分配内存。 文件位置：go1.19.3/src/runtime/os_linux.go。 390 391 392 393 394 395 396 397 398 399 400 // Called to initialize a new m (including the bootstrap m). // Called on the new thread, cannot allocate memory. func minit() { // 初始化 Signals minitSignals() // Cgo-created threads and the bootstrap m are missing a // procid. We need this for asynchronous preemption and it's // useful in debuggers. getg().m.procid = uint64(gettid()) } 文件位置：go1.19.3/src/runtime/signal_unix.go。 1192 1193 1194 1195 1196 1197 // minitSignals is called when initializing a new m to set the // thread's alternate signal stack and signal mask. func minitSignals() { minitSignalStack() minitSignalMask() } acquirep() 参数_p_ *p：空闲的p在wakeup()函数时存入m.nextp处，供工作线程启动后绑定这个P。 文件位置：go1.19.3/src/runtime/proc.go。 4938 4939 4940 4941 4942 4943 4944 4945 4946 4947 4948 4949 4950 4951 4952 4953 4954 4955 4956 4957 4958 4959 // Associate p and the current m. // // This function is allowed to have write barriers even if the caller // isn't because it immediately acquires _p_. // //go:yeswritebarrierrec func acquirep(_p_ *p) { // Do the part that isn't allowed to have write barriers. wirep(_p_)\t// 绑定P与当前工作线程M // Have p; write barriers now allowed. // Perform deferred mcache flush before this P can allocate // from a potentially stale mcache. // // 在此 P 可以从可能过时的 mcache 分配之前执行延迟 mcache 刷新 _p_.mcache.prepareForSweep() if trace.enabled { traceProcStart() } } 绑定传入的P在当前工作线程。wirep是acquirep的第一步，实际上是将当前的M关联到_p_。 这是被打破的，所以我们可以禁止这部分的写屏障，因为我们还没有P。 文件位置：go1.19.3/src/runtime/proc.go。 4959 4960 4961 4962 4963 4964 4965 4966 4967 4968 4969 4970 4971 4972 4973 4974 4975 4976 4977 4978 4979 4980 4981 4982 4983 4984 4985 // wirep is the first step of acquirep, which actually associates the // current M to _p_. This is broken out so we can disallow write // barriers for this part, since we don't yet have a P. // //go:nowritebarrierrec //go:nosplit func wirep(_p_ *p) { _g_ := getg() // 获取当前的g if _g_.m.p != 0 { // 当前工作线程如果绑定了P则有问题 throw(\"wirep: already in go\") } // 当前P绑定了工作线程存在问题，该P不是空闲的 或 当前P不处于空闲状态 if _p_.m != 0 || _p_.status != _Pidle { id := int64(0) if _p_.m != 0 { id = _p_.m.ptr().id } print(\"wirep: p-\u003em=\", _p_.m, \"(\", id, \") p-\u003estatus=\", _p_.status, \"\\n\") throw(\"wirep: invalid p state\") } // 当前工作线程M绑定P _g_.m.p.set(_p_) // m.p = _p_\t// 当前P绑定工作线程M _p_.m.set(_g_.m) // _p_.m = m _p_.status = _Prunning // 把当前P状态修改为_Prunning } schedule() 循环调度开始。每轮循环都从这里开始。该函数算是调度器的核心函数，运行起来的线程会一直执行它。 一轮调度器：找到一个可运行的goroutine并执行它。永不返回。 文件位置：go1.19.3/src/runtime/proc.go。 3183 3184 3185 3186 3187 3188 3189 3190 3191 3192 3193 3194 3195 3196 3197 3198 3199 3200 3201 3202 3203 3204 3205 3206 3207 3208 3209 3210 3211 3212 3213 3214 3215 3216 3217 3218 3219 3220 3221 3222 3223 3224 3225 3226 3227 3228 3229 3230 3231 3232 3233 3234 3235 3236 3237 3238 3239 3240 3241 3242 3243 3244 3245 3246 3247 3248 3249 3250 3251 3252 3253 3254 3255 3256 3257 3258 3259 3260 3261 3262 3263 3264 3265 3266 3267 3268 3269 3270 3271 3272 3273 3274 3275 3276 3277 3278 3279 3280 3281 3282 3283 3284 3285 3286 3287 3288 3289 3290 3291 3292 // One round of scheduler: find a runnable goroutine and execute it. // Never returns. func schedule() { // 获取当前正在运行的g，执行该函数时一般都是系统栈g0 _g_ := getg() // _g_ = g0 // 调度开始时 g0.m.locks = 0 // 校验当前线程没有锁，不允许再持有锁的情况下进行调度，以免造成runtime内部错误 // 因为m.locks的加锁和解锁时成对出现的，因此这里应该为0 if _g_.m.locks != 0 { throw(\"schedule: holding locks\") } // g0.m.lockedg = 0 // 判断当前M有没有和G绑定，如果有，这个M就不能用来执行其他的G了, // 只能挂起等待绑定的G得到调度。 if _g_.m.lockedg != 0 { stoplockedm() execute(_g_.m.lockedg.ptr(), false) // Never returns. } // We should not schedule away from a g that is executing a cgo call, // since the cgo call is using the m's g0 stack. // // 我们不应该安排远离正在执行 cgo 调用的 g，因为 cgo 调用正在使用 m 的 g0 堆栈 // 判断线程是不是正在进行cgo函数调用，这种情况下g0栈正在被cgo使用，所以也不允许调度。 if _g_.m.incgo { throw(\"schedule: in cgo\") } top: pp := _g_.m.p.ptr() // pp = p // 通过把preempt字段设置为false，来禁止对P的抢占。 pp.preempt = false // Safety check: if we are spinning, the run queue should be empty. // Check this before calling checkTimers, as that might call // goready to put a ready goroutine on the local run queue. // // 安全检查：如果我们正在自旋，那么运行队列应该是空的。 // 在调用checkTimers之前请检查这一点，因为这可能会调用goready将准备好的goroutine放入本地运行队列。 // 对 spinning 的判断属于一致性检验，在P本地runq有任务的情况下，M不应该处于spinning状态。 if _g_.m.spinning \u0026\u0026 (pp.runnext != 0 || pp.runqhead != pp.runqtail) { throw(\"schedule: spinning with local work\") } // 寻找一个可用的 goroutine // inheritTime：是否继承当前时间片 // 1. true 继承当前时间片 // 2. false 不继承当前时间片 // tryWakeP：当前goroutine是否是普通的。也就是user goroutine。 // 1. false 普通的goroutine。 // 2. true 不是普通的goroutine，可能是GC work、trace reader需要唤醒P。 // gp：当前找到的 goroutine。 gp, inheritTime, tryWakeP := findRunnable() // blocks until work is available // This thread is going to run a goroutine and is not spinning anymore, // so if it was marked as spinning we need to reset it now and potentially // start a new spinning M. // // 这个线程将运行一个goroutine，不再旋转，所以如果它被标记为旋转， // 我们现在需要重置它，并可能启动一个新的旋转M。 if _g_.m.spinning { // 重置当前M位非旋转，并尝试重新启动一个P标记为旋转。 resetspinning() } // sched.disable.user：禁止调度用户goroutine。 // !schedEnabled(gp)：gp是user goroutine。 // 可能来自GC，其中两种模式不允许GC期间运行user goroutine if sched.disable.user \u0026\u0026 !schedEnabled(gp) { // Scheduling of this goroutine is disabled. Put it on // the list of pending runnable goroutines for when we // re-enable user scheduling and look again. // // 此goroutine的调度被禁用。 // 当我们重新启用用户调度并再次查看时，将它放在挂起的可运行goroutine列表中。 lock(\u0026sched.lock) if schedEnabled(gp) { // Something re-enabled scheduling while we // were acquiring the lock. unlock(\u0026sched.lock) } else { // user goroutine 时挂起 sched.disable.runnable.pushBack(gp) sched.disable.n++ unlock(\u0026sched.lock) goto top } } // If about to schedule a not-normal goroutine (a GCworker or tracereader), // wake a P if there is one. // // 如果要调度一个不正常的goroutine (GCworker或tracereader)，如果有P，则唤醒P。 // 尝试换新一个新线程绑定P来工作。 if tryWakeP { wakep() } if gp.lockedm != 0 { // Hands off own p to the locked m, // then blocks waiting for a new p. // // 把自己的p交给锁住的m，然后block等待一个新的p。 startlockedm(gp) goto top } execute(gp, inheritTime) } findRunnable()🚀 查找要执行的可运行goroutine。试图从其他P中窃取，从本地或全局队列、轮询网络中获取g。 tryWakeP表示返回的不是普通的goroutine（GC工作程序、跟踪读取器），因此调用者应该尝试唤醒P。 文件位置：go1.19.3/src/runtime/proc.go。 2651 2652 2653 2654 2655 2656 2657 2658 2659 2660 2661 2662 2663 2664 2665 2666 2667 2668 2669 2670 2671 2672 2673 2674 2675 2676 2677 2678 2679 2680 2681 2682 2683 2684 2685 2686 2687 2688 2689 2690 2691 2692 2693 2694 2695 2696 2697 2698 2699 2700 2701 2702 2703 2704 2705 2706 2707 2708 2709 2710 2711 2712 2713 2714 2715 2716 2717 2718 2719 2720 2721 2722 2723 2724 2725 2726 2727 2728 2729 2730 2731 2732 2733 2734 2735 2736 2737 2738 2739 2740 2741 2742 2743 2744 2745 2746 2747 2748 2749 2750 2751 2752 2753 2754 2755 2756 2757 2758 2759 2760 2761 2762 2763 2764 2765 2766 2767 2768 2769 2770 2771 2772 2773 2774 2775 2776 2777 2778 2779 2780 2781 2782 2783 2784 2785 2786 2787 2788 2789 2790 2791 2792 2793 2794 2795 2796 2797 2798 2799 2800 2801 2802 2803 2804 2805 2806 2807 2808 2809 2810 2811 2812 2813 2814 2815 2816 2817 2818 2819 2820 2821 2822 2823 2824 2825 2826 2827 2828 2829 2830 2831 2832 2833 2834 2835 2836 2837 2838 2839 2840 2841 2842 2843 2844 2845 2846 2847 2848 2849 2850 2851 2852 2853 2854 2855 2856 2857 2858 2859 2860 2861 2862 2863 2864 2865 2866 2867 2868 2869 2870 2871 2872 2873 2874 2875 2876 2877 2878 2879 2880 2881 2882 2883 2884 2885 2886 2887 2888 2889 2890 2891 2892 2893 2894 2895 2896 2897 2898 2899 2900 2901 2902 2903 2904 2905 2906 2907 2908 2909 2910 2911 2912 2913 2914 2915 2916 2917 2918 2919 2920 2921 2922 2923 2924 2925 2926 2927 2928 2929 2930 2931 2932 2933 2934 2935 2936 2937 2938 2939 2940 2941 2942 2943 2944 2945 2946 2947 2948 2949 2950 2951 2952 2953 2954 2955 2956 2957 2958 2959 2960 2961 2962 2963 2964 2965 2966 2967 2968 2969 2970 2971 2972 2973 2974 2975 2976 2977 2978 2979 2980 2981 2982 2983 2984 2985 2986 2987 2988 2989 2990 2991 2992 2993 2994 2995 2996 2997 2998 2999 3000 3001 3002 3003 3004 3005 3006 3007 3008 3009 3010 3011 3012 3013 3014 3015 3016 3017 3018 3019 3020 3021 3022 3023 3024 3025 3026 3027 3028 3029 3030 3031 3032 3033 3034 3035 3036 3037 3038 3039 3040 3041 3042 3043 3044 3045 3046 3047 3048 3049 3050 3051 3052 3053 3054 3055 3056 3057 3058 3059 3060 3061 3062 3063 3064 3065 3066 3067 3068 3069 3070 3071 3072 3073 3074 3075 3076 3077 3078 3079 3080 3081 3082 3083 3084 3085 3086 3087 3088 3089 3090 3091 3092 3093 3094 3095 3096 3097 3098 3099 3100 3101 3102 3103 3104 3105 3106 3107 3108 3109 3110 3111 3112 3113 3114 3115 3116 3117 3118 3119 3120 3121 3122 // Finds a runnable goroutine to execute. // Tries to steal from other P's, get g from local or global queue, poll network. // tryWakeP indicates that the returned goroutine is not normal (GC worker, trace // reader) so the caller should try to wake a P. func findRunnable() (gp *g, inheritTime, tryWakeP bool) { _g_ := getg() // _g_ = g0 // The conditions here and in handoffp must agree: if // findrunnable would return a G to run, handoffp must start // an M. // // 这里和handoffp中的条件必须一致：如果findrunnable将返回一个G来运行，则handoffp必须启动一个M。 top: _p_ := _g_.m.p.ptr() // _p_ = p // 1) 帮助STW，抢占当前P。 // STW 即将开始要求等待，挂起当前M。 // 检测sched.gcwaiting，挂起自己，以便及时响应STW， // 调度逻辑中很多地方都有对gcwaiting的检测。 if sched.gcwaiting != 0 { // 在GC的STW期间被设置 gcstopm() goto top } // 2) 检查当前P是否到达安全点。 // 如果当前P要求运行 runSafePointFn() 函数。 // runSafePointFn() 函数被GC用来在安全点执行清空工作队列之类的操作。 if _p_.runSafePointFn != 0 { runSafePointFn() } // 3) 去 timers 里看看，是否有到点的定时器。 // 这里如果有 timer 到触发点了，会触发并执行注册函数。 // 由于调度循环是以时间片形式调度的，因此 timer 的触发时间上线就是10ms。 // 因此抢占能抢占超过10ms以上的goroutine? // checkTimers 为准备好的 P 运行任何timers // 如果 now 不为 0，则为当前时间，如果 now 被传递为 0，则返回传递的时间或当前时间 // 以及下一个timer应该运行的时间，如果没有下一个计时器，则为 0，并报告它是否运行了任何计时器 // 如果下一个timer应该运行的时间不为0，它总是大于返回的时间 // func checkTimers(pp *p, now int64) (rnow, pollUntil int64, ran bool) // 参数： // 1. pp *p 当前需要检查的P // 2. now int64 当前时间，如果为0则取当前时间 // 返回值： // 1. rnow int64：参数now的时间。 // 2. pollUntil int64：\u003e0.最近timer触发的时间点。0.没有任何timer。 // 3. ran bool timer里面是否存在已经延迟时间到点的g，true存在，false不存在 // now and pollUntil are saved for work stealing later, // which may steal timers. It's important that between now // and then, nothing blocks, so these numbers remain mostly // relevant. // // now和pollUntil被保存以备以后窃取工作，这可能会窃取timers。 // 重要的是，从现在到那时，没有任何阻碍，所以这些数字仍然很重要。 // 处理当前P相关的timers，可能存在一些在timer中的g到时间点了需要放回P中等待被执行 now, pollUntil, _ := checkTimers(_p_, 0) // 4) 尝试安排 trace reader。 // Try to schedule the trace reader. // // 尝试安排 trace reader。 if trace.enabled || trace.shutdown { gp = traceReader() if gp != nil { casgstatus(gp, _Gwaiting, _Grunnable) traceGoUnpark(gp, 0) return gp, false, true } } // 5) 写标记期间，尝试安排 GC worker。 // Try to schedule a GC worker. // 尝试安排 GC worker。 if gcBlackenEnabled != 0 { // 在GC【并发标记】期间被设置 // 唤醒标记协程，参看GC文档 gp, now = gcController.findRunnableGCWorker(_p_, now) // 获取到标记协程 if gp != nil { return gp, false, true // 返回标记协程 } } // 6) P调度次数每满61次需要去全局队列拿去goroutine，防止全局goroutine一直得不到运行。 // Check the global runnable queue once in a while to ensure fairness. // Otherwise two goroutines can completely occupy the local runqueue // by constantly respawning each other. // // 偶尔检查一次全局可运行队列以确保公平性。 // 否则，两个goroutine可以通过不断地相互重新部署来完全占据本地运行队列。 // 为了保证调度的公平性，每个工作线程每进行61次调度就需要优先从全局运行队列中获取goroutine出来运行。 // 因为如果只调度本地运行队列中的goroutine，则全局运行队列中的goroutine有可能得不到运行。 // p.schedtick：记录调度发生的次数，实际上在每发生一次goroutine切换且不继承时间片的情况下，该字段会加一。 // sched.runqsize：记录的是全局就绪队列的长度。也就是全局队列goroutine的个数。 if _p_.schedtick%61 == 0 \u0026\u0026 sched.runqsize \u003e 0 { lock(\u0026sched.lock) // 从sched中获取goroutine需要持有lock锁。 // 从全局队列中获取1个goroutine，然后放入P的本地队列。 gp = globrunqget(_p_, 1) // 只拿取一个 unlock(\u0026sched.lock) // mutex 解锁 if gp != nil { return gp, false, false } } // 7) 是否有 finalizer G。 // Wake up the finalizer G. // // 唤醒 finalizer G。 // 该goroutine由runtime.SetFinalizer函数创造。 // 只会创建一个goroutine。 if fingwait \u0026\u0026 fingwake { if gp := wakefing(); gp != nil { ready(gp, 0, true) } } if *cgo_yield != nil { asmcgocall(*cgo_yield, nil) } // 8) 从P的本地队列拿去 goroutine。 // local runq // 从本地P的队列中获取goroutine。 if gp, inheritTime := runqget(_p_); gp != nil { return gp, inheritTime, false } // 9) 从全局队列中拿去goroutine。 // global runq // 从全局队列中获取goroutine。 if sched.runqsize != 0 { lock(\u0026sched.lock) gp := globrunqget(_p_, 0) // 拿取多个 unlock(\u0026sched.lock) if gp != nil { return gp, false, false } } // 10) netpoll 是否有就绪的goroutine。 // Poll network. // This netpoll is only an optimization before we resort to stealing. // We can safely skip it if there are no waiters or a thread is blocked // in netpoll already. If there is any kind of logical race with that // blocked thread (e.g. it has already returned from netpoll, but does // not set lastpoll yet), this thread will do blocking netpoll below // anyway. // // netpollinited()：判断netpoll是否已经初始化。 // netpollWaiters：是否有等待的goroutine。 // sched.lastpoll：上次网络轮询的时间点。为0时表示有线程正在阻塞式调用netpoll函数 if netpollinited() \u0026\u0026 atomic.Load(\u0026netpollWaiters) \u003e 0 \u0026\u0026 atomic.Load64(\u0026sched.lastpoll) != 0 { // netpoll(0)：判断当前是否有就绪事件，0表示立即返回。非阻塞。 if list := netpoll(0); !list.empty() { // non-blocking gp := list.pop() // 弹出一个goroutine。 injectglist(\u0026list) // 处理剩下的goroutine casgstatus(gp, _Gwaiting, _Grunnable) // 修改goroutine状态 if trace.enabled { traceGoUnpark(gp, 0) } return gp, false, false } } // 11) 以上都没获取到goroutine。标记自旋尝试从其他P中偷取goroutine。 // Spinning Ms: steal work from other Ps. // // Limit the number of spinning Ms to half the number of busy Ps. // This is necessary to prevent excessive CPU consumption when // GOMAXPROCS\u003e\u003e1 but the program parallelism is low. // // Spinning Ms:从其他P那里窃取goroutine。 // 将自旋的M限制为繁忙M的一半。 // 这是必要的，以防止在 GOMAXPROCS\u003e\u003e1 但程序并行性较低时过度消耗CPU。 // 如果当前处于spinning状态的M的数量大于忙碌的P的数量的一半，就让当前M阻塞(休眠)。 // 目的是避免在gomaxprocs较大而程序实际的并发性很低的情况下，造成不必要的CPU消耗。 procs := uint32(gomaxprocs) // 获取当前P的数量 // _g_.m.spinning == true：当前M处于自旋。 // 2*atomic.Load(\u0026sched.nmspinning) \u003c procs-atomic.Load(\u0026sched.npidle)：自旋是繁忙的一半还小时，标记当前M为自旋 if _g_.m.spinning || 2*atomic.Load(\u0026sched.nmspinning) \u003c procs-atomic.Load(\u0026sched.npidle) { if !_g_.m.spinning { // 满足偷取的时候才会标记M为自旋状态 _g_.m.spinning = true // 标记为自旋状态 atomic.Xadd(\u0026sched.nmspinning, 1) // 累加自旋M的数量 } // 去其他P中偷取 goroutine。偷取其他P中goroutine的一半。 // 从p.runnext中偷取的goroutine时，inheritTime该值为true，表示继承上个时间片。 gp, inheritTime, tnow, w, newWork := stealWork(now) now = tnow // 更新当前时间 // 成功偷取到goroutine if gp != nil { // Successfully stole. return gp, inheritTime, false } // newWork 某个P中有timer被触发了，在来一次调度循环 if newWork { // There may be new timer or GC work; restart to // discover. goto top } // w不为0，表示最近触发的timer的时间点 if w != 0 \u0026\u0026 (pollUntil == 0 || w \u003c pollUntil) { // Earlier timer to wait for. pollUntil = w // 记录最近要触发的时间点 } } // 12) 有GC标记工作这去帮助GC // We have nothing to do. // // If we're in the GC mark phase, can safely scan and blacken objects, // and have work to do, run idle-time marking rather than give up the P. // // 我们无事可做。 // 如果我们在GC标记阶段，可以安全地扫描和变黑对象，并且有工作要做，运行空闲时间标记而不是放弃P。 if gcBlackenEnabled != 0 \u0026\u0026 gcMarkWorkAvailable(_p_) \u0026\u0026 gcController.addIdleMarkWorker() { node := (*gcBgMarkWorkerNode)(gcBgMarkWorkerPool.pop()) if node != nil { _p_.gcMarkWorkerMode = gcMarkWorkerIdleMode gp := node.gp.ptr() casgstatus(gp, _Gwaiting, _Grunnable) if trace.enabled { traceGoUnpark(gp, 0) } return gp, false, false } gcController.removeIdleMarkWorker() } // wasm only: // If a callback returned and no other goroutine is awake, // then wake event handler goroutine which pauses execution // until a callback was triggered. gp, otherReady := beforeIdle(now, pollUntil) // 在linux下返回 (nil, false) if gp != nil { casgstatus(gp, _Gwaiting, _Grunnable) if trace.enabled { traceGoUnpark(gp, 0) } return gp, false, false } if otherReady { goto top } // 13) 保存allp、idlepMask和timerpMask的快照 // 当前工作线程即将休眠，休眠前再次去快照里面看看有没有工作要做 // Before we drop our P, make a snapshot of the allp slice, // which can change underfoot once we no longer block // safe-points. We don't need to snapshot the contents because // everything up to cap(allp) is immutable. // // 在我们丢弃P之前，做一个allp切片的快照，一旦我们不再阻塞safe-points，它就会改变。 // 我们不需要对内容进行快照，因为cap(allp)之前的所有内容都是不可变的。 allpSnapshot := allp // Also snapshot masks. Value changes are OK, but we can't allow // len to change out from under us. // // 还有快照掩码。值更改是可以的，但是我们不能允许len从我们下面更改。 idlepMaskSnapshot := idlepMask timerpMaskSnapshot := timerpMask // 14) 在看一下gcwaiting和runSafePointFn，以及全局队列sched.runqsize // return P and block lock(\u0026sched.lock) // 有GC等待 或 P有安全点函数执行 if sched.gcwaiting != 0 || _p_.runSafePointFn != 0 { unlock(\u0026sched.lock) goto top } // 全局队列有 goroutine if sched.runqsize != 0 { // 因为 sched.lock 锁已被持有，所以一定能取出 gp。不为 nil。 gp := globrunqget(_p_, 0) unlock(\u0026sched.lock) return gp, false, false } // 15) 解除当前M与P的绑定关系，并把P加入全局空闲队列中 // 解除m与p的绑定关系，并设置p为空闲状态。 if releasep() != _p_ { throw(\"findrunnable: wrong p\") } // 把P加入空闲队列 now = pidleput(_p_, now) unlock(\u0026sched.lock) // 16) 根据前面快照保存的信息，再次检查其他P是否可偷取，GC有没标记工作需要协助，timer有没触发 // Delicate dance: thread transitions from spinning to non-spinning // state, potentially concurrently with submission of new work. We must // drop nmspinning first and then check all sources again (with // #StoreLoad memory barrier in between). If we do it the other way // around, another thread can submit work after we've checked all // sources but before we drop nmspinning; as a result nobody will // unpark a thread to run the work. // // This applies to the following sources of work: // // * Goroutines added to a per-P run queue. // * New/modified-earlier timers on a per-P timer heap. // * Idle-priority GC work (barring golang.org/issue/19112). // // If we discover new work below, we need to restore m.spinning as a signal // for resetspinning to unpark a new worker thread (because there can be more // than one starving goroutine). However, if after discovering new work // we also observe no idle Ps it is OK to skip unparking a new worker // thread: the system is fully loaded so no spinning threads are required. // Also see \"Worker thread parking/unparking\" comment at the top of the file. wasSpinning := _g_.m.spinning // 处理当前M是自旋状态 if _g_.m.spinning { _g_.m.spinning = false // 标记当前M未非自旋 if int32(atomic.Xadd(\u0026sched.nmspinning, -1)) \u003c 0 { throw(\"findrunnable: negative nmspinning\") } // Note the for correctness, only the last M transitioning from // spinning to non-spinning must perform these rechecks to // ensure no missed work. We are performing it on every M that // transitions as a conservative change to monitor effects on // latency. See golang.org/issue/43997. // Check all runqueues once again. // // 再次检查所有运行队列。 // 检查是否有可偷取的P，如果有则取出一个空闲的P绑定M。 _p_ = checkRunqsNoP(allpSnapshot, idlepMaskSnapshot) if _p_ != nil { acquirep(_p_) // 绑定P _g_.m.spinning = true atomic.Xadd(\u0026sched.nmspinning, 1) goto top // 有工作可做再跑一遍调度循环 } // Check for idle-priority GC work again. // // 再次检查空闲优先级GC工作。是否有编辑工作需要做 _p_, gp = checkIdleGCNoP() if _p_ != nil { acquirep(_p_) // 绑定P _g_.m.spinning = true atomic.Xadd(\u0026sched.nmspinning, 1) // Run the idle worker. _p_.gcMarkWorkerMode = gcMarkWorkerIdleMode casgstatus(gp, _Gwaiting, _Grunnable) if trace.enabled { traceGoUnpark(gp, 0) } return gp, false, false } // Finally, check for timer creation or expiry concurrently with // transitioning from spinning to non-spinning. // // Note that we cannot use checkTimers here because it calls // adjusttimers which may need to allocate memory, and that isn't // allowed when we don't have an active P. // // 最后，再看看timer。 pollUntil = checkTimersNoP(allpSnapshot, timerpMaskSnapshot, pollUntil) } // 17) network 是否有需要处理的goroutine，或timer是否即将触发， // 标记sched.lastpoll为0，阻塞式等待吧。netpoll中一些读写超时需要用到timer // Poll network until next timer. // // Poll network 直到下一个 timer。 // netpollinited()：netpoll 已初始化。 // netpollWaiters：记录当前goroutine被挂在epoll中的等待数量。 // pollUntil：\u003e0.下个timer触发的而时间点。 // atomic.Xchg64(\u0026sched.lastpoll, 0)：这里是唯一的把sched.lastpoll修改为0的情况， // 表示当前需要阻塞式的调用netpoll函数。 // 这里的atomic.Xchg64(\u0026sched.lastpoll, 0) != 0 具有排他性。只能有一个工作线程处于阻塞等待中。 if netpollinited() \u0026\u0026 (atomic.Load(\u0026netpollWaiters) \u003e 0 || pollUntil != 0) \u0026\u0026 atomic.Xchg64(\u0026sched.lastpoll, 0) != 0 { // sched.pollUntil = pollUntil，预计的阻塞时间点。 atomic.Store64(\u0026sched.pollUntil, uint64(pollUntil)) if _g_.m.p != 0 { throw(\"findrunnable: netpoll with p\") } if _g_.m.spinning { throw(\"findrunnable: netpoll with spinning\") } // Refresh now. now = nanotime() delay := int64(-1) if pollUntil != 0 { // 计算预计阻塞的时间 delay = pollUntil - now if delay \u003c 0 { // 触发时间以过，要求立即返回 delay = 0 } } // faketime是自1970年以来模拟的以纳秒为单位的时间。 // 0值意味着不使用faketime。 if faketime != 0 { // When using fake time, just poll. // 当使用 fake time，只是poll。 delay = 0 } // 阻塞直到有新的work可用，delay是一个具体的时间段 list := netpoll(delay) // block until new work is available atomic.Store64(\u0026sched.pollUntil, 0) // sched.pollUntil = 0 atomic.Store64(\u0026sched.lastpoll, uint64(now)) // sched.lastpoll = now if faketime != 0 \u0026\u0026 list.empty() { // Using fake time and nothing is ready; stop M. // When all M's stop, checkdead will call timejump. stopm() goto top } lock(\u0026sched.lock) // 从空闲P链表中获取一个P _p_, _ = pidleget(now) unlock(\u0026sched.lock) if _p_ == nil { // 没有可用的空闲P时。 // 如果有就绪的goroutine放入全局goroutine池。 injectglist(\u0026list) } else { acquirep(_p_) // 绑定P if !list.empty() { // 取出一个goroutine，用于返回 gp := list.pop() // 剩余的优先加入全局池。 injectglist(\u0026list) // 修改goroutine状态为待运行状态 casgstatus(gp, _Gwaiting, _Grunnable) if trace.enabled { traceGoUnpark(gp, 0) } // 返回找到的 goroutine return gp, false, false } // 如果之前M是自旋，则再次标记为自旋并从新再来一次。 if wasSpinning { _g_.m.spinning = true atomic.Xadd(\u0026sched.nmspinning, 1) } goto top } } else if pollUntil != 0 \u0026\u0026 netpollinited() { // 有其他的线程在阻塞 netpoll。 // sched.pollUntil：下次timer应该被唤醒时间点。 pollerPollUntil := int64(atomic.Load64(\u0026sched.pollUntil)) // timer触发了 或 触发时间已到 叫醒阻塞的netpoll if pollerPollUntil == 0 || pollerPollUntil \u003e pollUntil { netpollBreak() // 叫醒epoll } } // 挂起当前线程等待其他线程唤醒。 stopm() goto top } gcstopm() 为stopTheWorld停止当前M。 当TheWordStart时返回。辅助STW。 文件位置：go1.19.3/src/runtime/proc.go。 该方法在GC发起时，其他线程都在这个方法上把自己挂起。 2481 2482 2483 2484 2485 2486 2487 2488 2489 2490 2491 2492 2493 2494 2495 2496 2497 2498 2499 2500 2501 2502 2503 2504 2505 2506 2507 2508 2509 2510 2511 2512 2513 2514 2515 // Stops the current m for stopTheWorld. // Returns when the world is restarted. func gcstopm() { _g_ := getg() // _g_ = g0 // sched.gcwaiting：是1，表示当前STW正在等待P停下来。 if sched.gcwaiting == 0 { throw(\"gcstopm: not waiting for gc\") } // 当前M正处于自旋状态下。 if _g_.m.spinning { _g_.m.spinning = false // 清除自旋标记 // OK to just drop nmspinning here, // startTheWorld will unpark threads as necessary. // // 自旋计数出现错误 if int32(atomic.Xadd(\u0026sched.nmspinning, -1)) \u003c 0 { throw(\"gcstopm: negative nmspinning\") } } // 解绑当前M与P _p_ := releasep() lock(\u0026sched.lock) // _Pgcstop：GC停止状态。 // P被STW挂起以执行GC，所有权归执行STW的M所有，执行STW的M会继续使用处于_Pgcstop状态的P。 _p_.status = _Pgcstop // sched.stopwait：记录了STW需要停止的P的数量 sched.stopwait-- // 已经停下了所有的P，需要唤醒在 sched.stopnote 上发起STW的工作线程。 if sched.stopwait == 0 { notewakeup(\u0026sched.stopnote) } unlock(\u0026sched.lock) stopm() // 停止当前工作线程。 } releasep() 解除p和当前m的关联。 文件位置：go1.19.3/src/runtime/proc.go。 4984 4985 4986 4987 4988 4989 4990 4991 4992 4993 4994 4995 4996 4997 4998 4999 5000 5001 5002 5003 5004 5005 5006 5007 // Disassociate p and the current m. func releasep() *p { _g_ := getg() // _g_ = g0 if _g_.m.p == 0 { throw(\"releasep: invalid arg\") } _p_ := _g_.m.p.ptr() // _p_ = p // _p_.m == _g_.m \u0026\u0026 _p_.status == _Prunning if _p_.m.ptr() != _g_.m || _p_.status != _Prunning { print(\"releasep: m=\", _g_.m, \" m-\u003ep=\", _g_.m.p.ptr(), \" p-\u003em=\", hex(_p_.m), \" p-\u003estatus=\", _p_.status, \"\\n\") throw(\"releasep: invalid p state\") } if trace.enabled { traceProcStop(_g_.m.p.ptr()) } // 解除 p 与 m 相互绑定的关系。 _g_.m.p = 0 _p_.m = 0 // _Pidle：空闲状态。 // 此时的P没有被用来执行用户代码或调度器代码，通常位于空闲链表中，能够被调度器获取。 _p_.status = _Pidle return _p_ } stopm() 停止执行当前m，直到有新的工作可用。返回获取的P。 文件位置：go1.19.3/src/runtime/proc.go。 2229 2230 2231 2232 2233 2234 2235 2236 2237 2238 2239 2240 2241 2242 2243 2244 2245 2246 2247 2248 2249 2250 2251 2252 // Stops execution of the current m until new work is available. // Returns with acquired P. func stopm() { _g_ := getg() // _g_ = g0 if _g_.m.locks != 0 { throw(\"stopm holding locks\") } if _g_.m.p != 0 { throw(\"stopm holding p\") } if _g_.m.spinning { throw(\"stopm spinning\") } lock(\u0026sched.lock) mput(_g_.m) // 把当前m加入sched.midle中。 unlock(\u0026sched.lock) mPark() // 工作线程sleep在m.park上 // 工作线程再次被wakeup时，绑定P。 acquirep(_g_.m.nextp.ptr()) // 此处p来自m.nextp。 _g_.m.nextp = 0 } mput() 把mp列入midle列表中。 sched.lock 必须被持有。 可能在STW期间运行，因此不允许出现写屏障。 文件位置：go1.19.3/src/runtime/proc.go。 5533 5534 5535 5536 5537 5538 5539 5540 5541 5542 5543 5544 5545 5546 // Put mp on midle list. // sched.lock must be held. // May run during STW, so write barriers are not allowed. // //go:nowritebarrierrec func mput(mp *m) { assertLockHeld(\u0026sched.lock) // 把当前m加入sched.midle。 mp.schedlink = sched.midle sched.midle.set(mp) sched.nmidle++ checkdead() // 检查死锁。 } mPark() mPark会导致线程自行停驻，一旦被唤醒就会返回。 文件位置：go1.19.3/src/runtime/proc.go。 1452 1453 1454 1455 1456 1457 1458 1459 // mPark causes a thread to park itself, returning once woken. // //go:nosplit func mPark() { gp := getg() // gp = g0 notesleep(\u0026gp.m.park) // sleep noteclear(\u0026gp.m.park) // 清除 m.park } acquirep() 关联p和当前m。 文件位置：go1.19.3/src/runtime/proc.go。 4938 4939 4940 4941 4942 4943 4944 4945 4946 4947 4948 4949 4950 4951 4952 4953 4954 4955 4956 4957 // Associate p and the current m. // // This function is allowed to have write barriers even if the caller // isn't because it immediately acquires _p_. // //go:yeswritebarrierrec func acquirep(_p_ *p) { // Do the part that isn't allowed to have write barriers. wirep(_p_) // Have p; write barriers now allowed. // Perform deferred mcache flush before this P can allocate // from a potentially stale mcache. _p_.mcache.prepareForSweep() if trace.enabled { traceProcStart() } } globrunqget() 尝试从全局可运行队列中获取一批G，sched.lock必须被持有。 参数： _p_ *p：当前工作线程绑定的P。 max int32：从全局队列中拿多少个g到本地P中。该参数一般是1，如果是其他P偷取则是大于1。 返回值*g：从全局队列中那到的goroutine。 文件位置：go1.19.3/src/runtime/proc.go。 5601 5602 5603 5604 5605 5606 5607 5608 5609 5610 5611 5612 5613 5614 5615 5616 5617 5618 5619 5620 5621 5622 5623 5624 5625 5626 5627 5628 5629 5630 5631 5632 5633 5634 5635 5636 5637 5638 5639 5640 5641 5642 5643 5644 // Try get a batch of G's from the global runnable queue. // sched.lock must be held. func globrunqget(_p_ *p, max int32) *g { assertLockHeld(\u0026sched.lock) // sched.runqsize：记录的是全局就绪队列的长度。 // 也就是全局队列goroutine的个数。 if sched.runqsize == 0 { return nil } // 根据p的数量平分全局运行队列中的goroutines n := sched.runqsize/gomaxprocs + 1 // 上面计算n的方法可能导致n大于全局运行队列中的goroutine数量 if n \u003e sched.runqsize { n = sched.runqsize } // max：表示最多拿去goroutine个数。 if max \u003e 0 \u0026\u0026 n \u003e max { n = max } // 最多只能取本地队列容量的一半。 // _p_.runq：最大256。 if n \u003e int32(len(_p_.runq))/2 { n = int32(len(_p_.runq)) / 2 } sched.runqsize -= n // 减去取出的数量 // pop从全局运行队列的队列头取一个goroutine。 // 这个goroutine用于返回。 gp := sched.runq.pop() n-- // 遍历从全局队列中拿取goroutine到P的本地队列中。 for ; n \u003e 0; n-- { // 从全局运行队列中取出一个goroutine gp1 := sched.runq.pop() // 放入本地运行队列，false.放入尾部。 // 1. go关键字时，调用该方法传入的true // 2. 从全局拿取时，这里传入的时false runqput(_p_, gp1, false) } return gp } runqput() 把gp放入_p_的尾部。 参数： _p_ *p：本地P。 gp *g：需要放入_p_的goroutine。 next bool：true放入本地_p_的开头，false放入本地_p_的尾部。 文件位置：go1.19.3/src/runtime/proc.go。 5780 5781 5782 5783 5784 5785 5786 5787 5788 5789 5790 5791 5792 5793 5794 5795 5796 5797 5798 5799 5800 5801 5802 5803 5804 5805 5806 5807 5808 5809 5810 5811 5812 5813 5814 5815 5816 5817 // runqput tries to put g on the local runnable queue. // If next is false, runqput adds g to the tail of the runnable queue. // If next is true, runqput puts g in the _p_.runnext slot. // If the run queue is full, runnext puts g on the global queue. // Executed only by the owner P. func runqput(_p_ *p, gp *g, next bool) { if randomizeScheduler \u0026\u0026 next \u0026\u0026 fastrandn(2) == 0 { next = false } if next { retryNext: oldnext := _p_.runnext if !_p_.runnext.cas(oldnext, guintptr(unsafe.Pointer(gp))) { goto retryNext } if oldnext == 0 { return } // Kick the old runnext out to the regular run queue. gp = oldnext.ptr() } retry: h := atomic.LoadAcq(\u0026_p_.runqhead) // load-acquire, synchronize with consumers t := _p_.runqtail if t-h \u003c uint32(len(_p_.runq)) { _p_.runq[t%uint32(len(_p_.runq))].set(gp) atomic.StoreRel(\u0026_p_.runqtail, t+1) // store-release, makes the item available for consumption return } // 从_P_中移除一部分到全局中，包含gp。 if runqputslow(_p_, gp, h, t) { return } // the queue is not full, now the put above must succeed goto retry } runqget() 从本地可运行队列中获取goroutine。 如果inheritTime为true，则gp应继承当前时间片中的剩余时间。否则，它应该开始一个新的时间片。 多有者由当前P拥有。 参数：_p_ *p：当前本地P，可能出现其他工作线程M偷取P的情况。 返回值： gp *g：当前获取到的goroutine。 inheritTime bool：是否继承当前时间片。 文件位置：go1.19.3/src/runtime/proc.go。 5893 5894 5895 5896 5897 5898 5899 5900 5901 5902 5903 5904 5905 5906 5907 5908 5909 5910 5911 5912 5913 5914 5915 5916 5917 5918 5919 5920 5921 5922 5923 5924 5925 5926 5927 5928 5929 5930 5931 5932 5933 5934 5935 // Get g from local runnable queue. // If inheritTime is true, gp should inherit the remaining time in the // current time slice. Otherwise, it should start a new time slice. // Executed only by the owner P. func runqget(_p_ *p) (gp *g, inheritTime bool) { // If there's a runnext, it's the next G to run. // // 如果有 runnext，它就是下一个要运行的 G next := _p_.runnext // If the runnext is non-0 and the CAS fails, it could only have been stolen by another P, // because other Ps can race to set runnext to 0, but only the current P can set it to non-0. // Hence, there's no need to retry this CAS if it falls. // // 如果 runnext 是 non-0 并且 CAS 失败，它只能被另一个P窃取，因为其他P可以竞相将runnext设置为0， // 当前P可以将其设置为非 0。 因此，如果该 CAS 失败，则无需重试。 if next != 0 \u0026\u0026 _p_.runnext.cas(next, 0) { // 从 p.runnext上取出的goroutine，都继承了上次的时间片 // channel 的send和recv操作都会把goroutine挂在 p.runnext 上 return next.ptr(), true } // p.runnext == 0 || 当前goroutine已被窃取。 for { // 原子读取 _p_.runqhead。 // 当前P和其他P来偷取goroutine都是从runqhead开始的，因此需要原子读取。 h := atomic.LoadAcq(\u0026_p_.runqhead) // load-acquire, synchronize with other consumers // runqtail：只有本地P会修改这个值加入goroutine。当前P在此操作因此runqtail不会改变不需原子操作。 t := _p_.runqtail // 本地P队列为空。 if t == h { return nil, false } // 取出当前h位置上的g，注意循环队列是通过runqhead和runqtail不断的累加然后通过求余判断位置的 // 由于runqhead和runqtail都是uint32类型循环数组大小为256正好是整倍数， // 因此uint32不断累计最后会从0又开始，形成一个循环 gp := _p_.runq[h%uint32(len(_p_.runq))].ptr() // CAS 设置 _p_.runqhead，这段时间可能 _p_.runqhead 的值发生变化而失败。 if atomic.CasRel(\u0026_p_.runqhead, h, h+1) { // cas-release, commits consume return gp, false } } } injectglist() injectglist 将列表上的每个可运行的G添加到某个运行队列，并清除glist。 如果当前不存在P，则将它们添加到全局队列，并启动多达npim个队列来运行它们。 否则，对于每个空闲的P，将G添加到全局队列，并启动一个m。剩余的G添加到当前P的本地就绪队列。 这可能会临时获取sched.lock。可以与GC并发运行。 该函数在netpoll后调用，可以是监控线程中这种情况下没有P，或则调度循环中。 文件位置：go1.19.3/src/runtime/proc.go。 3113 3114 3115 3116 3117 3118 3119 3120 3121 3122 3123 3124 3125 3126 3127 3128 3129 3130 3131 3132 3133 3134 3135 3136 3137 3138 3139 3140 3141 3142 3143 3144 3145 3146 3147 3148 3149 3150 3151 3152 3153 3154 3155 3156 3157 3158 3159 3160 3161 3162 3163 3164 3165 3166 3167 3168 3169 3170 3171 3172 3173 3174 3175 3176 3177 3178 3179 3180 3181 3182 3183 3184 3185 3186 3187 3188 3189 3190 3191 3192 3193 3194 3195 3196 3197 // injectglist adds each runnable G on the list to some run queue, // and clears glist. If there is no current P, they are added to the // global queue, and up to npidle M's are started to run them. // Otherwise, for each idle P, this adds a G to the global queue // and starts an M. Any remaining G's are added to the current P's // local run queue. // This may temporarily acquire sched.lock. // Can run concurrently with GC. func injectglist(glist *gList) { // goroutine 空列表 if glist.empty() { return } if trace.enabled { for gp := glist.head.ptr(); gp != nil; gp = gp.schedlink.ptr() { traceGoUnpark(gp, 0) } } // Mark all the goroutines as runnable before we put them // on the run queues. head := glist.head.ptr() var tail *g // 获取队列最后一个 goroutine qsize := 0 // 记录goroutine数量 // 修改这些goroutine的状态 for gp := head; gp != nil; gp = gp.schedlink.ptr() { tail = gp qsize++ // _Gwaiting：goroutine阻塞在runtime中，没有执行用户代码。它不在任何runq中，但是应该被记录在其他地方。 // _Grunnable：goroutine应该在某个runq中，当前并没有在运行用户代码，它的栈不归自己所有。 casgstatus(gp, _Gwaiting, _Grunnable) } // Turn the gList into a gQueue. // 将这个gList转换为一个gQueue。 var q gQueue // 双向链表 q.head.set(head) q.tail.set(tail) *glist = gList{} startIdle := func(n int) { // 指定数量的空闲P起来工作 for ; n != 0 \u0026\u0026 sched.npidle != 0; n-- { startm(nil, false) } } pp := getg().m.p.ptr() // pp // 如果来自sysmon监控线程，pp = nil。 if pp == nil { lock(\u0026sched.lock) // 放入全局 sched.runq 池中 globrunqputbatch(\u0026q, int32(qsize)) unlock(\u0026sched.lock) // 唤醒qsize多个空闲P来处理这些goroutine startIdle(qsize) return } // 以下是存在P的情况 // 空闲的P的数量 npidle := int(atomic.Load(\u0026sched.npidle)) var globq gQueue var n int // 把空闲P数量个数的goroutine放入全局池中，然后唤醒P起来工作 for n = 0; n \u003c npidle \u0026\u0026 !q.empty(); n++ { g := q.pop() globq.pushBack(g) } if n \u003e 0 { lock(\u0026sched.lock) // 放入全局 sched.runq 池中 globrunqputbatch(\u0026globq, int32(n)) unlock(\u0026sched.lock) // 唤醒qsize多个空闲P来处理这些goroutine startIdle(n) qsize -= n } if !q.empty() { // 还剩的goroutine放入本地队列中 runqputbatch(pp, \u0026q, qsize) } } stealWork() stealWork试图从任何P中窃取一个可运行的goroutine或timer。 如果返回值newWork为true，则新工作可能已经准备好了。 如果now不是0，则为当前时间。stealWork返回经过的时间，如果now被传递为0，则返回当前时间。 参数now int64：不是 0，则为当前时间。 返回值： gp *g：获取到的goroutine。 inheritTime bool：是否继承当前时间片。 rnow int64：获取时间点。 pollUntil int64：timer的触发时间点。 newWork bool：为 true，则新工作可能已经准备好了。会跳转到findRunnable函数top标签处从新开始。 窃取逻辑会循环尝试4次，最后一次才会窃取runnext和timer，也就是说前3次只会从其他P的本地runq中窃取。 stealOrder用来实现一个公平的随机窃取顺序，timerpMask和idlepMask用来快速判断指定位置的P是否有timer或是空闲。 文件位置：go1.19.3/src/runtime/proc.go。 2899 2900 2901 2902 2903 2904 2905 2906 2907 2908 2909 2910 2911 2912 2913 2914 2915 2916 2917 2918 2919 2920 2921 2922 2923 2924 2925 2926 2927 2928 2929 2930 2931 2932 2933 2934 2935 2936 2937 2938 2939 2940 2941 2942 2943 2944 2945 2946 2947 2948 2949 2950 2951 2952 2953 2954 2955 2956 2957 2958 2959 2960 2961 2962 2963 2964 2965 2966 2967 2968 2969 2970 2971 2972 2973 2974 2975 2976 2977 2978 2979 2980 2981 2982 2983 2984 2985 2986 2987 2988 2989 2990 2991 2992 2993 2994 2995 2996 2997 2998 2999 3000 3001 3002 3003 3004 3005 3006 3007 3008 3009 3010 3011 3012 3013 3014 3015 3016 3017 // stealWork attempts to steal a runnable goroutine or timer from any P. // // If newWork is true, new work may have been readied. // // If now is not 0 it is the current time. stealWork returns the passed time or // the current time if now was passed as 0. func stealWork(now int64) (gp *g, inheritTime bool, rnow, pollUntil int64, newWork bool) { pp := getg().m.p.ptr() // pp = p ranTimer := false // newWork 的返回值 // 尝试偷取最大次数 const stealTries = 4 // 执行四次遍历，就是尽最大努力去其他P中查看 for i := 0; i \u003c stealTries; i++ { // 最后一次时： // 1. 前三次尝试去P的runq本地队列中偷取goroutine。 // 2. 最后一次先去各个P的timers里看看，然后当偷取的P的runq为空时， // 尝试偷取P.runnext上的goroutine。 stealTimersOrRunNextG := i == stealTries-1 // randomOrder/randomEnum 是随机工作窃取的辅助类型，一轮allp遍历开始。 // 它们允许以不同的伪随机顺序枚举所有 P 而不重复。 // 该算法基于这样一个事实： // 如果我们有X使得X和GOMAXPROCS互质，那么(i + X)%GOMAXPROCS的序列给出所需的枚举。 // stealOrder.start(fastrand())：从一个随机位置开始。 // !enum.done()：当前是否已经遍历一圈了。 // enum.next()：跳转到下一个位置。 for enum := stealOrder.start(fastrand()); !enum.done(); enum.next() { // 有STW正在等待P挂起。直接返回。 // 跳转到findRunnable函数top标签处从新开始。 if sched.gcwaiting != 0 { // GC work may be available. return nil, false, now, pollUntil, true } // 随机选的p，如果是当前的跳过。 // enum.position()：当前偷取P的下标。 p2 := allp[enum.position()] if pp == p2 { continue } // Steal timers from p2. This call to checkTimers is the only place // where we might hold a lock on a different P's timers. We do this // once on the last pass before checking runnext because stealing // from the other P's runnext should be the last resort, so if there // are timers to steal do that first. // // We only check timers on one of the stealing iterations because // the time stored in now doesn't change in this loop and checking // the timers for each P more than once with the same value of now // is probably a waste of time. // // timerpMask tells us whether the P may have timers at all. If it // can't, no need to check at all. // // 从p2中窃取 timers。对checkTimers的调用是唯一可以对不同P的timers持有锁的地方。 // 我们在检查runnext之前的最后一遍执行此操作，因为从另一个P的runnext中窃取计时器应该是最后的手段， // 所以如果有timers可以窃取，请先窃取。 // 我们只检查其中一个窃取迭代的定时器，因为存储在now中的时间在这个循环中不会改变， // 如果用相同的now值多次检查每个P的定时器，可能就是浪费时间。 // timerpMask告诉我们P是否有定时器。如果它不能，根本不需要检查。 // timerpMask 是P的位图记录当前P上是否有 timer。 if stealTimersOrRunNextG \u0026\u0026 timerpMask.read(enum.position()) { // 再次看看 timers，是否有到点需要执行的timer。 // tnow：返回的now // w：触发时间点 // ran：timer是否已经运行了 // 如果ran为true，表示checkTimers()执行了p2的timer， // 可能会使某些goroutine变成_Grunnable状态， // 所以先检查当前P的本地runq，如果没有找到继续去偷取。 tnow, w, ran := checkTimers(p2, now) now = tnow // w != 0：还未触发的时间点 // pollUntil == 0：上次检查没有timer // w \u003c pollUntil：触发时间点缩小 if w != 0 \u0026\u0026 (pollUntil == 0 || w \u003c pollUntil) { pollUntil = w // 最近的timer触发的时间点 } // 有触发timer运行，需要去P的本地runq中去找找可能有goroutine被放里面了。 // 比如time.Sleep。 if ran { // Running the timers may have // made an arbitrary number of G's // ready and added them to this P's // local run queue. That invalidates // the assumption of runqsteal // that it always has room to add // stolen G's. So check now if there // is a local G to run. if gp, inheritTime := runqget(pp); gp != nil { return gp, inheritTime, now, pollUntil, ranTimer } // 标记为true，再次跑一边调度循环 ranTimer = true } } // Don't bother to attempt to steal if p2 is idle. // // 如果p2是空闲的不要尝试偷取。 // 在创建goroutine时候我们遇见过idlepMask，该值是P的位图，记录了所有空闲的P的bit位(原子更新)。 // idlepMask.read(enum.position())：true.当前P是空闲的，false.当前P不是空闲的。 if !idlepMask.read(enum.position()) { // runqsteal 函数从p2中偷取goroutine到pp中。 // stealTimersOrRunNextG表示最大程度偷取runnext。 if gp := runqsteal(pp, p2, stealTimersOrRunNextG); gp != nil { return gp, false, now, pollUntil, ranTimer } } } } // No goroutines found to steal. Regardless, running a timer may have // made some goroutine ready that we missed. Indicate the next timer to // wait for. return nil, false, now, pollUntil, ranTimer } runqsteal() 从p2的本地可运行队列中窃取一半的g，并放入p的本地可运行队列中。 返回一个被窃取的g(如果失败则返回nil)。 参数： _p_ *p：当前窃取其他P的工作线程绑定的P。 p2 *p：被窃取的P。 stealRunNextG bool：true尽最大努力去p.runnext上偷取，false不偷取p.runnext的goroutine。 返回值*g：偷取到的goroutine。 文件位置：go1.19.3/src/runtime/proc.go。 6015 6016 6017 6018 6019 6020 6021 6022 6023 6024 6025 6026 6027 6028 6029 6030 6031 6032 6033 6034 6035 6036 6037 6038 6039 6040 6041 6042 6043 // Steal half of elements from local runnable queue of p2 // and put onto local runnable queue of p. // Returns one of the stolen elements (or nil if failed). func runqsteal(_p_, p2 *p, stealRunNextG bool) *g { t := _p_.runqtail // 尝试从p2中偷取一半的goroutine。 n := runqgrab(p2, \u0026_p_.runq, t, stealRunNextG) // p2中也没有 if n == 0 { return nil } // 从p的本地runq中取出一个goroutine，用于返回给调度器调度起来。 n-- // 因为偷取是从runqtail开始的，因此runqtail处也是head头处。 // 其实是取的队列中的最后一个，方便后面 StoreRel 原子操作设置 runqtail 值。 gp := _p_.runq[(t+n)%uint32(len(_p_.runq))].ptr() if n == 0 { return gp } // 还有其他的需要处理，原子读取 _p_.runqhead h := atomic.LoadAcq(\u0026_p_.runqhead) // load-acquire, synchronize with consumers // 这里判断偷取的g是否大于P本地的一半数量，则是溢出了 if t-h+n \u003e= uint32(len(_p_.runq)) { throw(\"runqsteal: runq overflow\") } // 原子设置 _p_.runqtail = t+n atomic.StoreRel(\u0026_p_.runqtail, t+n) // store-release, makes the item available for consumption return gp } runqgrab() 从_p_的可运行队列中获取一批goroutines到batch。 Batch是一个从batchHead开始的环形缓冲区。 返回抓取的goroutines的数量。可以被任意P执行。 参数：假设从p2偷取到p。 _p_ *p：偷取目标的P。就是p2. batch *[256]guintptr：从_p_偷取goroutine需要放到的P的runq本地队列池。就是p的本地runq池。 batchHead uint32：p的runqtail处。 stealRunNextG bool：是否近最大努力去runnext上偷取。 返回值：uint32：偷取goroutine的数量。 文件位置：go1.19.3/src/runtime/proc.go。 5959 5960 5961 5962 5963 5964 5965 5966 5967 5968 5969 5970 5971 5972 5973 5974 5975 5976 5977 5978 5979 5980 5981 5982 5983 5984 5985 5986 5987 5988 5989 5990 5991 5992 5993 5994 5995 5996 5997 5998 5999 6000 6001 6002 6003 6004 6005 6006 6007 6008 6009 6010 6011 6012 6013 6014 6015 6016 6017 6018 6019 6020 6021 6022 6023 6024 6025 6026 6027 6028 6029 6030 6031 6032 6033 6034 6035 6036 6037 6038 6039 6040 6041 6042 6043 6044 6045 6046 6047 6048 // Grabs a batch of goroutines from _p_'s runnable queue into batch. // Batch is a ring buffer starting at batchHead. // Returns number of grabbed goroutines. // Can be executed by any P. func runqgrab(_p_ *p, batch *[256]guintptr, batchHead uint32, stealRunNextG bool) uint32 { // 偷取goroutine的代码采用的是自旋方式，而没有采用锁来实现。 for { // _p_ 是 p2，之所以需要原子读取因为p2正在运行有并发的可能。 h := atomic.LoadAcq(\u0026_p_.runqhead) // load-acquire, synchronize with other consumers t := atomic.LoadAcq(\u0026_p_.runqtail) // load-acquire, synchronize with the producer // 为什么不担心 runqtail 溢出？ // 因为，runqtail和runqhead都是uint32类型，就算溢出也能保证计算正确。比如 0 - 3 也能得到正确值 n := t - h n = n - n/2 // 计算偷取的数量，为当前容量的一半。 // p2 中本地runq池中没有goroutine。 if n == 0 { // p2本地runq池为空，尝试去 runnext 获取goroutine。 if stealRunNextG { // Try to steal from _p_.runnext. // // 尝试从 _p_.runnext 中偷取。 if next := _p_.runnext; next != 0 { // _p_.runnext 上有goroutine。 if _p_.status == _Prunning { // 当前P正在运行中 // Sleep to ensure that _p_ isn't about to run the g // we are about to steal. // The important use case here is when the g running // on _p_ ready()s another g and then almost // immediately blocks. Instead of stealing runnext // in this window, back off to give _p_ a chance to // schedule runnext. This will avoid thrashing gs // between different Ps. // A sync chan send/recv takes ~50ns as of time of // writing, so 3us gives ~50x overshoot. // // Sleep 已确保 _p_ 不会运行我们将要切取的g。 // 这里的重要用例是当 g 在 _p_ ready() 上运行时，另一个 g 然后几乎立即阻塞。 // 不要在这个窗口期切取 runnext，而是退而求其次，让_p_有机会调度runnext。 // 这将避免g在不同的Ps之间的抖动。 // sync chan 的 send/recv 大约需要 ~50ns，所以给出 3us 大约是它的 50x 倍。 if GOOS != \"windows\" \u0026\u0026 GOOS != \"openbsd\" \u0026\u0026 GOOS != \"netbsd\" { usleep(3) // sleep 3us } else { // On some platforms system timer granularity is // 1-15ms, which is way too much for this // optimization. So just yield. // // 在某些平台上，系统计时器粒度为1-15ms，这对于这种优化来说太过了。所以就屈服吧。 osyield() // 在semaphore中有相关的介绍。会尝试让出CPU，让其他优先级更高的线程执行。 } } // CAS 操作交换 _p_.runnext 尝试偷取 goroutine。 // 大概率会失败从这里直接退出。 if !_p_.runnext.cas(next, 0) { continue } // 偷取到goroutine把它放入P的本地runq池。 batch[batchHead%uint32(len(batch))] = next return 1 } } return 0 } // 读取不一致的 h 和 t 值。 // 小细节：按理说队列中的goroutine个数最多就是len(_p_.runq)，所以n的最大值也就是len(_p_.runq)/2， // 那为什么需要这个判断呢？ // 原因：读取runqhead和runqtail是两个操作而非一个原子操作，当我们读取runqhead之后但还未读取runqtail之前， // 如果有其它线程快速的在增加（这是完全有可能的，其它偷取者从队列中偷取goroutine会增加runqhead， // 而队列的所有者往队列中添加goroutine会 增加runqtail）这两个值，则会导致我们读取出来的runqtail已经远远大于 // 我们之前读取出来放在局部变量h里面的runqhead了。 // 也就是代码注释中所说的h和t已经不一致了，所以这里需要这个if判断来检测异常情况。 // 如果 n \u003e uint32(len(_p_.runq)/2) 成立说明在t := atomic.LoadAcq(\u0026_p_.runqtail)代码后runqtail发生了变化。 if n \u003e uint32(len(_p_.runq)/2) { // read inconsistent h and t continue } // 从p2中拷贝goroutine到p的runq本地池 for i := uint32(0); i \u003c n; i++ { g := _p_.runq[(h+i)%uint32(len(_p_.runq))] // 从p2的h处往后取goroutine batch[(batchHead+i)%uint32(len(batch))] = g// 从p.runqtail往后最加 } // CAS 原子交换 p2.runqhead 从 h 修改为 h+n，如果失败说明h被修改了 // 1. 可能其他P也在偷取这个P的goroutine并且偷取成功了。 // 2. 当前被偷取的这个P可能也在取runqhead出的goroutine来运行。导致runqhead变化。 // 为什么不担心 runqtail 的值呢？而是只需要保证 runqhead 和 runqtail 一起是原子的呢？ // 因为，runqtail 只有当前P正最加，并且是递增的，能保证我们要去的数据n。 if atomic.CasRel(\u0026_p_.runqhead, h, h+n) { // cas-release, commits consume return n } } } type randomOrder struct stealOrder用来实现一个公平的随机窃取顺序。 文件位置：go1.19.3/src/runtime/proc.go。 // 关于取P得算法 var stealOrder randomOrder // randomOrder/randomEnum are helper types for randomized work stealing. // They allow to enumerate all Ps in different pseudo-random orders without repetitions. // The algorithm is based on the fact that if we have X such that X and GOMAXPROCS // are coprime, then a sequences of (i + X) % GOMAXPROCS gives the required enumeration. // // randomOrder/randomEnum 是随机工作窃取的辅助类型 // 它们允许以不同的伪随机顺序枚举所有 P 而不重复 // 该算法基于这样一个事实： // 如果我们有 X 使得 X 和 GOMAXPROCS 互质，那么 (i + X) %GOMAXPROCS 的序列给出所需的枚举 type randomOrder struct { count uint32 // 存储当前所有的P数量，也是CPU的核数 coprimes []uint32 // 存储与count互质数集 } type randomEnum struct { i uint32 // 从0开始记录遍历的次数 count uint32 // randomOrder.count pos uint32 // 当前在[0, count-1]范围的下标位置 inc uint32 // 当前在randomOrder.coprimes中选取的值 } // 重置randomOrder func (ord *randomOrder) reset(count uint32) { ord.count = count\t// 记录总个数 ord.coprimes = ord.coprimes[:0] // 清空coprimes for i := uint32(1); i \u003c= count; i++ { if gcd(i, count) == 1 { ord.coprimes = append(ord.coprimes, i) } } } // 生成互质数函数 func gcd(a, b uint32) uint32 { for b != 0 { a, b = b, a%b } return a } // 开始 func (ord *randomOrder) start(i uint32) randomEnum { return randomEnum{ count: ord.count, pos: i % ord.count, inc: ord.coprimes[i%uint32(len(ord.coprimes))], } } // 当前是否遍历一圈了 func (enum *randomEnum) done() bool { return enum.i == enum.count } // 下一个互质数 func (enum *randomEnum) next() { enum.i++ enum.pos = (enum.pos + enum.inc) % enum.count\t// 这里是随机的选取下一个随机处 } // 获取当前位置 func (enum *randomEnum) position() uint32 { return enum.pos } // 盗取算法解释 // 1. 盗取过程用了两个嵌套for循环。 // 2. 内层循环实现了盗取逻辑，从代码可以看出盗取的实质就是遍历allp中的所有p，查看其运行队列是否有goroutine，如果有， // 则取其一半到当前工作线程的运行队列，然后从findrunnable返回，如果没有则继续遍历下一个p // 3. 但这里为了保证公平性，遍历allp时并不是固定的从allp[0]即第一个p开始，而是从随机位置上的p开始， // 而且遍历的顺序也随机化了，并不是现在访问了第i个p下一次就访问第i+1个p， // 而是使用了一种伪随机的方式遍历allp中的每个p，防止每次遍历时使用同样的顺序访问allp中的元素 // 下面是这个算法的伪代码： // offset := uint32(random()) % nprocs // coprime := 随机选取一个小于nprocs且与nprocs互质的数 // for i := 0; i \u003c nprocs; i++ { // p := allp[offset] // 从p的运行队列偷取goroutine // if 偷取成功 { // break // } // offset += coprime // offset = offset % nprocs // } // // 下面举例说明一下上述算法过程，现假设nprocs为8，也就是一共有8个p // 如果第一次随机选择的offset = 6，coprime = 3(3与8互质，满足算法要求)的话，则从allp切片中偷取的下标顺序为 // 6, 1, 4, 7, 2, 5, 0, 3，计算过程： // 6，(6+3)%8=1，(1+3)%8=4, (4+3)%8=7, (7+3)%8=2, (2+3)%8=5, (5+3)%8=0, (0+3)%8=3 // 如果第二次随机选择的offset = 4，coprime = 5的话，则从allp切片中偷取的下标顺序为 // 1, 6, 3, 0, 5, 2, 7, 4，计算过程： // 1，(1+5)%8=6，(6+5)%8=3, (3+5)%8=0, (0+5)%8=5, (5+5)%8=2, (2+5)%8=7, (7+5)%8=4 releasep() 解除当前M和P的绑定关系。 文件位置：go1.19.3/src/runtime/proc.go。 4984 4985 4986 4987 4988 4989 4990 4991 4992 4993 4994 4995 4996 4997 4998 4999 5000 5001 5002 5003 5004 5005 5006 5007 5008 5009 5010 // Disassociate p and the current m. func releasep() *p { _g_ := getg() // 获取当前运行的g，这里是g0 if _g_.m.p == 0 { // 当前要解绑的P不存在，系统代码有逻辑问题 throw(\"releasep: invalid arg\") } _p_ := _g_.m.p.ptr() // 获取当前工作线程M绑定的P，也就是需要解绑的P // _Prunning 表示 P 由 M 拥有并用于运行用户代码或调度程序 // 只有拥有这个 P 的 M 才允许从 _Prunning 更改 P 的状态 // M 可以将 P 转换为 _Pidle（如果它没有更多工作要做）、_Psyscall（当进入系统调用时）或 _Pgcstop（停止 GC） // M 也可以将 P 的所有权直接交给另一个 M（例如，安排锁定的 G） if _p_.m.ptr() != _g_.m || _p_.status != _Prunning { // 当前P绑定的m与g绑定的m不是同一个 或 当前P不是_Prunning状态 print(\"releasep: m=\", _g_.m, \" m-\u003ep=\", _g_.m.p.ptr(), \" p-\u003em=\", hex(_p_.m), \" p-\u003estatus=\", _p_.status, \"\\n\") throw(\"releasep: invalid p state\") } if trace.enabled { traceProcStop(_g_.m.p.ptr()) } _g_.m.p = 0\t// 解绑工作线程M与P的关联 _p_.m = 0\t// 解绑P与M的关联 // _Pidle 表示 P 未用于运行用户代码或调度程序 // 通常，它位于空闲 P 列表中并且可供调度程序使用，但它可能只是在其他状态之间转换 // P 由空闲列表或正在转换其状态的任何东西拥有。 它的运行队列是空的 _p_.status = _Pidle return _p_\t// 返回当前P } pidleput() pidleput 将p放到_Pidle列表中。 这释放了p的所有权。一旦sched.lock被释放，使用p就不再安全了。 sched.lock必须被持有，可以在STW期间运行，因此不允许写入屏障。 文件位置：go1.19.3/src/runtime/proc.go。 5696 5697 5698 5699 5700 5701 5702 5703 5704 5705 5706 5707 5708 5709 5710 5711 5712 5713 5714 5715 5716 5717 5718 5719 // pidleput puts p to on the _Pidle list. // // This releases ownership of p. Once sched.lock is released it is no longer // safe to use p. // // sched.lock must be held. // // May run during STW, so write barriers are not allowed. //go:nowritebarrierrec func pidleput(_p_ *p) { assertLockHeld(\u0026sched.lock) // 判断P的本地队列不应该还有goroutine，判断下 if !runqempty(_p_) { throw(\"pidleput: P has non-empty run queue\") } // 如果P没有timer，将清除timerpMask位上对应的掩码位，timerpMask是记录忙碌的 updateTimerPMask(_p_) // clear if there are no timers. idlepMask.set(_p_.id) // 设置idlepMask对应的P的掩码位，idlepMask是记录空闲的 _p_.link = sched.pidle // 当前P记录全局的空闲链表 sched.pidle.set(_p_) // 把当前P链接到全局空闲链表后 // 使用原子锁把当前sched空闲的P数量加1 atomic.Xadd(\u0026sched.npidle, 1) // TODO: fast atomic } runqempty() runqempty 报告_p_在其本地运行队列中是否没有 Gs。 它永远不会虚假地返回true。 文件位置：go1.19.3/src/runtime/proc.go。 5752 5753 5754 5755 5756 5757 5758 5759 5760 5761 5762 5763 5764 5765 5766 5767 5768 5769 5770 5771 5772 5773 // runqempty reports whether _p_ has no Gs on its local run queue. // It never returns true spuriously. func runqempty(_p_ *p) bool { // Defend against a race where 1) _p_ has G1 in runqnext but runqhead == runqtail, // 2) runqput on _p_ kicks G1 to the runq, 3) runqget on _p_ empties runqnext. // Simply observing that runqhead == runqtail and then observing that runqnext == nil // does not mean the queue is empty. // // 以下情况： // 1. _p_ 在 runqnext 中有 G1 但 runqhead == runqtail // 2. _p_ 上的 runqput 将 G1 踢到 runq // 3. _p_ 上的 runqget 清空 runqnext // 简单地观察 runqhead == runqtail 然后观察 runqnext == nil 并不意味着队列是空的 for { head := atomic.Load(\u0026_p_.runqhead)\ttail := atomic.Load(\u0026_p_.runqtail) runnext := atomic.Loaduintptr((*uintptr)(unsafe.Pointer(\u0026_p_.runnext))) if tail == atomic.Load(\u0026_p_.runqtail) { return head == tail \u0026\u0026 runnext == 0 } } } pidleget() 相关联函数pidleget从空闲列表中获取一个P。 文件位置：go1.19.3/src/runtime/proc.go。 5727 5728 5729 5730 5731 5732 5733 5734 5735 5736 5737 5738 5739 5740 5741 5742 5743 5744 5745 5746 5747 5748 5749 5750 // pidleget tries to get a p from the _Pidle list, acquiring ownership. // // sched.lock must be held. // // May run during STW, so write barriers are not allowed. // //go:nowritebarrierrec func pidleget(now int64) (*p, int64) { assertLockHeld(\u0026sched.lock) _p_ := sched.pidle.ptr() if _p_ != nil { // Timer may get added at any time now. if now == 0 { now = nanotime() } timerpMask.set(_p_.id) idlepMask.clear(_p_.id) sched.pidle = _p_.link atomic.Xadd(\u0026sched.npidle, -1) _p_.limiterEvent.stop(limiterEventIdle, now) } return _p_, now } checkRunqsNoP() 检查快照中所有的P是否有可以偷取的G。 文件位置：go1.19.3/src/runtime/proc.go。 2974 2975 2976 2977 2978 2979 2980 2981 2982 2983 2984 2985 2986 2987 2988 2989 2990 2991 2992 2993 2994 2995 2996 2997 2998 2999 // Check all Ps for a runnable G to steal. // // On entry we have no P. If a G is available to steal and a P is available, // the P is returned which the caller should acquire and attempt to steal the // work to. func checkRunqsNoP(allpSnapshot []*p, idlepMaskSnapshot pMask) *p { // 变量allp的快照，allp记录了所有的P列表 for id, p2 := range allpSnapshot {\t// 休眠之前在看一下是否有工作要做 // idlepMaskSnapshot 快照记录着当前P的状态 // !idlepMaskSnapshot.read(uint32(id)) 当前P状态不为空的 并且 当前P存储groutine的 if !idlepMaskSnapshot.read(uint32(id)) \u0026\u0026 !runqempty(p2) { lock(\u0026sched.lock) pp := pidleget()\t// 从空闲的P中拿去一个P，为后续M绑定P做准备，因为有全局的P存在g可以起去拿来用 unlock(\u0026sched.lock) if pp != nil { return pp } // Can't get a P, don't bother checking remaining Ps. // 拿不到P，别费心检查剩余的P break } } return nil } checkIdleGCNoP() 检查是否有GC需要帮助。 文件位置：go1.19.3/src/runtime/proc.go。 3013 3014 3015 3016 3017 3018 3019 3020 3021 3022 3023 3024 3025 3026 3027 3028 3029 3030 3031 3032 3033 3034 3035 3036 3037 3038 3039 3040 3041 3042 3043 3044 3045 3046 3047 3048 3049 3050 3051 3052 3053 3054 3055 3056 3057 3058 3059 3060 3061 3062 3063 3064 3065 3066 3067 3068 3069 3070 3071 3072 3073 // Check for idle-priority GC, without a P on entry. // // If some GC work, a P, and a worker G are all available, the P and G will be // returned. The returned P has not been wired yet. func checkIdleGCNoP() (*p, *g) { // N.B. Since we have no P, gcBlackenEnabled may change at any time; we // must check again after acquiring a P. As an optimization, we also check // if an idle mark worker is needed at all. This is OK here, because if we // observe that one isn't needed, at least one is currently running. Even if // it stops running, its own journey into the scheduler should schedule it // again, if need be (at which point, this check will pass, if relevant). if atomic.Load(\u0026gcBlackenEnabled) == 0 || !gcController.needIdleMarkWorker() { return nil, nil } if !gcMarkWorkAvailable(nil) { return nil, nil } // Work is available; we can start an idle GC worker only if there is // an available P and available worker G. // // We can attempt to acquire these in either order, though both have // synchronization concerns (see below). Workers are almost always // available (see comment in findRunnableGCWorker for the one case // there may be none). Since we're slightly less likely to find a P, // check for that first. // // Synchronization: note that we must hold sched.lock until we are // committed to keeping it. Otherwise we cannot put the unnecessary P // back in sched.pidle without performing the full set of idle // transition checks. // // If we were to check gcBgMarkWorkerPool first, we must somehow handle // the assumption in gcControllerState.findRunnableGCWorker that an // empty gcBgMarkWorkerPool is only possible if gcMarkDone is running. lock(\u0026sched.lock) pp, now := pidlegetSpinning(0) if pp == nil { unlock(\u0026sched.lock) return nil, nil } // Now that we own a P, gcBlackenEnabled can't change (as it requires STW). if gcBlackenEnabled == 0 || !gcController.addIdleMarkWorker() { pidleput(pp, now) unlock(\u0026sched.lock) return nil, nil } node := (*gcBgMarkWorkerNode)(gcBgMarkWorkerPool.pop()) if node == nil { pidleput(pp, now) unlock(\u0026sched.lock) gcController.removeIdleMarkWorker() return nil, nil } unlock(\u0026sched.lock) return pp, node.gp.ptr() } checkTimersNoP() 检查快照中所有的P是否有timer要触发了。 文件位置：go1.19.3/src/runtime/proc.go。 2997 2998 2999 3000 3001 3002 3003 3004 3005 3006 3007 3008 3009 3010 3011 // Check all Ps for a timer expiring sooner than pollUntil. // // Returns updated pollUntil value. func checkTimersNoP(allpSnapshot []*p, timerpMaskSnapshot pMask, pollUntil int64) int64 { for id, p2 := range allpSnapshot { if timerpMaskSnapshot.read(uint32(id)) { w := nobarrierWakeTime(p2) if w != 0 \u0026\u0026 (pollUntil == 0 || w \u003c pollUntil) { pollUntil = w } } } return pollUntil } stopm() 工作线程进入休眠，等待被其他工作线程唤醒。 文件位置：go1.19.3/src/runtime/proc.go。 2229 2230 2231 2232 2233 2234 2235 2236 2237 2238 2239 2240 2241 2242 2243 2244 2245 2246 2247 2248 2249 2250 // Stops execution of the current m until new work is available. // Returns with acquired P. func stopm() { _g_ := getg() // 获取当前工作线程M绑定的g if _g_.m.locks != 0 { // 判断当前工作线程是否有锁为解锁 throw(\"stopm holding locks\") } if _g_.m.p != 0 { // 判断当前工作线程是否还绑定了P，因为前面M与P已经解绑了 throw(\"stopm holding p\") } if _g_.m.spinning { // 判断当前工作线程是否还处于自旋状态标记，应为前面已经取消了该标记 throw(\"stopm spinning\") } lock(\u0026sched.lock) // 锁住全局sched mput(_g_.m) // 把m结构体对象放入sched.midle空闲队列 unlock(\u0026sched.lock) // 解锁 mPark() // 进入系统调用进入睡眠 acquirep(_g_.m.nextp.ptr()) // 工作线程被唤醒后从这里开始执行，给M绑定P _g_.m.nextp = 0 } mput() 当工作线程空闲时即将进入休眠状态时会判断一次checkdead()。 文件位置：go1.19.3/src/runtime/proc.go。 5533 5534 5535 5536 5537 5538 5539 5540 5541 5542 5543 5544 5545 5546 5547 // Put mp on midle list. // sched.lock must be held. // May run during STW, so write barriers are not allowed. //go:nowritebarrierrec func mput(mp *m) { assertLockHeld(\u0026sched.lock) // 检查sched.lock锁 mp.schedlink = sched.midle // 当前M记录全局空闲M链表 sched.midle.set(mp) // 把当前M追加到全局空闲链表中去 sched.nmidle++ // 全局空闲M数量加一 // 检查死锁情况 // 检查基于运行 M 的数量，如果 0 -\u003e 死锁 // sched.lock 必须被持有 checkdead() } mget() 文件位置：go1.19.3/src/runtime/proc.go。 5547 5548 5549 5550 5551 5552 5553 5554 5555 5556 5557 5558 5559 5560 // Try to get an m from midle list. // sched.lock must be held. // May run during STW, so write barriers are not allowed. //go:nowritebarrierrec func mget() *m { assertLockHeld(\u0026sched.lock) mp := sched.midle.ptr() if mp != nil { sched.midle = mp.schedlink sched.nmidle-- } return mp } mPark() 睡眠函数，mPark()导致线程自行停放，一旦唤醒就返回。 stopm的核心是调用mput把m结构体对象放入sched的midle空闲队列，然后通过notesleep(\u0026m.park)函数让自己进入睡眠状态。 note是go runtime实现的一次性睡眠和唤醒机制，一个线程可以通过调用notesleep(*note)进入睡眠状态，而另外一个线程则可以通过notewakeup(*note)把其唤醒。 note的底层实现机制跟操作系统相关，不同系统使用不同的机制： 比如linux下使用的futex系统调用。 而mac下则是使用的pthread_cond_t条件变量。 note对这些底层机制做了一个抽象和封装，这种封装给扩展性带来了很大的好处，比如当睡眠和唤醒功能需要支持新平台时，只需要在note层增加对特定平台的支持即可，不需要修改上层的任何代码。 回到stopm，当从notesleep函数返回后，需要再次绑定一个p，然后返回到findrunnable函数继续重新寻找可运行的goroutine，一旦找到可运行的goroutine就会返回到schedule函数，并把找到的goroutine调度起来运行，如何把goroutine调度起来运行的代码我们已经分析过了。 文件位置：go1.19.3/src/runtime/proc.go。 1452 1453 1454 1455 1456 1457 1458 // mPark causes a thread to park itself, returning once woken. //go:nosplit func mPark() { gp := getg() notesleep(\u0026gp.m.park) // 进入休眠状态，这里传入M的park，睡眠在这个上面 noteclear(\u0026gp.m.park) // 被其他工作线程唤醒，代码从这里开始执行 } notesleep() 实现休眠的函数。 notesleep函数调用futexsleep进入睡眠，这里之所以需要用一个循环，是因为futexsleep有可能意外从睡眠中返回，所以从futexsleep函数返回后还需要检查note.key是否还是0。 如果是0则表示并不是其它工作线程唤醒了我们，只是futexsleep意外返回了，需要再次调用futexsleep进入睡眠。 文件位置：go1.19.3/src/runtime/lock_futex.go。 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 func notesleep(n *note) { gp := getg() // 获取当前工作线程绑定的g，应该是g0在调度循环过程中被切换到g0了 if gp != gp.m.g0 { throw(\"notesleep not on g0\") } ns := int64(-1) // 超时时间设置为-1，表示无限期等待 if *cgo_yield != nil { // Sleep for an arbitrary-but-moderate interval to poll libc interceptors. // 休眠一个任意但适中的间隔来轮询 libc 拦截器cgo相关的 ns = 10e6 } // 使用循环，保证不是意外被唤醒 for atomic.Load(key32(\u0026n.key)) == 0 { gp.m.blocked = true // blocked表示M在当前的note上被屏蔽 futexsleep(key32(\u0026n.key), 0, ns) // 进入休眠函数 if *cgo_yield != nil { asmcgocall(*cgo_yield, nil) } gp.m.blocked = false } } futexsleep() 原子的if(*addr == val)休眠，可能会被虚假唤醒； 这是允许的睡眠时间不要超过ns；ns \u003c 0意味着永远。 文件位置：go1.19.3/src/runtime/os_linux.go。 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 // Atomically, //\tif(*addr == val) sleep // Might be woken up spuriously; that's allowed. // Don't sleep longer than ns; ns \u003c 0 means forever. // //go:nosplit func futexsleep(addr *uint32, val uint32, ns int64) { // Some Linux kernels have a bug where futex of // FUTEX_WAIT returns an internal error code // as an errno. Libpthread ignores the return value // here, and so can we: as it says a few lines up, // spurious wakeups are allowed. // // 一些 Linux 内核存在一个错误，即 FUTEX_WAIT 的 futex 返回内部错误代码作为 errno // Libpthread 忽略了这里的返回值，我们也可以：正如它所说的几行，虚假唤醒是允许的 if ns \u003c 0 {\t// 永久睡眠 futex(unsafe.Pointer(addr), _FUTEX_WAIT_PRIVATE, val, nil, nil, 0) return } var ts timespec ts.setNsec(ns) // 设置时间 futex(unsafe.Pointer(addr), _FUTEX_WAIT_PRIVATE, val, unsafe.Pointer(\u0026ts), nil, 0) } futex() 函数原型：func futex(addr unsafe.Pointer, op int32, val uint32, ts, addr2 unsafe.Pointer, val3 uint32) int32由汇编实现。 futex系统调用为我们提供的功能为如果*addr == val则进入睡眠，否则直接返回。 文件位置：go1.19.3/src/runtime/sys_linux_amd64.s。 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 # int64 futex(int32 *uaddr, int32 op, int32 val, #\tstruct timespec *timeout, int32 *uaddr2, int32 val2); TEXT runtime·futex(SB),NOSPLIT,$0 # 下面的6条指令在为futex系统调用准备参数 MOVQ addr+0(FP), DI MOVL op+8(FP), SI MOVL val+12(FP), DX MOVQ ts+16(FP), R10 MOVQ addr2+24(FP), R8 MOVL val3+32(FP), R9 MOVL $SYS_futex, AX # 系统调用编号放入AX寄存器 SYSCALL # 执行futex系统调用进入睡眠，从睡眠中被唤醒后接着执行下一条MOVL指令 MOVL AX, ret+40(FP) # 保存系统调用的返回值 RET execute() 🚀 gp放到当前M上取运行。该函数从g0栈切换到普通goroutine栈上。 如果inheritTime为true，则gp将继承当前时间片中的剩余时间。否则，它将启动一个新的时间片。永远不返回。 写屏障是允许的，因为这是在几个地方获得P后立即调用的。 参数： gp *g：当前调度的goroutine。 inheritTime bool：true.继承当前时间片，false.不继承当前时间片。 文件位置：go1.19.3/src/runtime/proc.go。 2508 2509 2510 2511 2512 2513 2514 2515 2516 2517 2518 2519 2520 2521 2522 2523 2524 2525 2526 2527 2528 2529 2530 2531 2532 2533 2534 2535 2536 2537 2538 2539 2540 2541 2542 2543 2544 2545 2546 2547 2548 2549 2550 2551 2552 2553 2554 2555 2556 2557 2558 2559 2560 2561 2562 2563 2564 2565 2566 2567 2568 // Schedules gp to run on the current M. // If inheritTime is true, gp inherits the remaining time in the // current time slice. Otherwise, it starts a new time slice. // Never returns. // // Write barriers are allowed because this is called immediately after // acquiring a P in several places. // //go:yeswritebarrierrec func execute(gp *g, inheritTime bool) { // 当前是在系统g0栈 _g_ := getg() // _g_ = g0 if goroutineProfile.active { // Make sure that gp has had its stack written out to the goroutine // profile, exactly as it was when the goroutine profiler first stopped // the world. tryRecordGoroutineProfile(gp, osyield) } // Assign gp.m before entering _Grunning so running Gs have an // M. // // 在输入_Grunning之前指定gp.m，以便运行Gs具有m。 _g_.m.curg = gp // m.curg = gp gp.m = _g_.m // gp.m = m // _Grunnable：它当前没有执行用户代码。 // _Grunning：表示这个goroutine可以执行用户代码。 casgstatus(gp, _Grunnable, _Grunning) // 修改当前g的状态为运行中 gp.waitsince = 0 // 设置g被阻塞的大约时间 // 抢占信号，重复stackguard0 = stackpreempt gp.preempt = false // const _StackGuard = 928; // 设置当前g栈扩容阈值点。 gp.stackguard0 = gp.stack.lo + _StackGuard // 是否继承当前时间片。具体的抢占在sysmon监控线程中。 if !inheritTime { // 不继承上一个时间片时，调度次数会加一 _g_.m.p.ptr().schedtick++ // 调度次数加一 } // Check whether the profiler needs to be turned on or off. // // 检查分析器是否需要打开或关闭 hz := sched.profilehz // sched.profilehz：用来设置性能分析的采样频率。 if _g_.m.profilehz != hz { setThreadCPUProfiler(hz) } if trace.enabled { // GoSysExit has to happen when we have a P, but before GoStart. // So we emit it here. if gp.syscallsp != 0 \u0026\u0026 gp.sysblocktraced { traceGoSysExit(gp.sysexitticks) } traceGoStart() } // gogo完成从g0到gp真正的切换 gogo(\u0026gp.sched) } gogo() gogo()函数完成从g0到gp的的切换：CPU执行权的转让以及栈的切换。 函数原型：func gogo(buf *gobuf)。 参数buf *gobuf：需要切换的goroutine的调度信息。 文件位置：go1.19.3/src/runtime/asm_amd64.s。 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 # func gogo(buf *gobuf) # restore state from Gobuf; longjmp TEXT runtime·gogo(SB), NOSPLIT, $0-8 # 1) 取出gobuf信息，里面包含需要调度的信息 # 取出需要调度的goroutine，gp.sched.g，判断这个goroutine不为nil # execute函数在调用gogo时把gp的sched成员的地址作为实参（型参buf）传递了过来 # 该参数位于FP寄存器所指的位置，所以第一条指令是获取参数 # buf = \u0026gp.sched; BX = *gobuf MOVQ buf+0(FP), BX # *gobuf # 把buf的值也就是gp.sched的地址放在了BX寄存器之中 # 这样便于后面的指令依靠BX寄存器来存取gp.sched的成员 # 注意这里是间接寻址方式 # gobuf-\u003eg --\u003e dx register MOVQ gobuf_g(BX), DX\t# DX = gp.sched.g; *g # 下面这行代码没有实质作用，检查gp.sched.g是否是nil，如果是nil进程会crash死掉 # 如果DX为空使用0(DX)形式简介寻址会报错。确保 g 不是 nil。 MOVQ 0(DX), CX # make sure g != nil # 2) 使用JMP指令跳转到gogo函数 JMP gogo\u003c\u003e(SB) # 注意这里使用的是JMP 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 TEXT gogo\u003c\u003e(SB), NOSPLIT, $0 # 3) 把gp放入TLS中和R14寄存器中 # 获取当前工作线程M的fs段基址，前面把fs段基址设置成了\u0026m.tls[1]的地址 get_tls(CX) # CX = \u0026m.tls[1] = TLS # 把DX值也就是需要运行的goroutine的指针写入线程本地存储之中 # 运行这条指令之前，线程本地存储存放的是g0的地址 MOVQ DX, g(CX) # TLS = gp.sched.g # 在g1.17和1.18版本中 R14寄存器被用来指向当前goroutine的runtime.g结构 # R14 = gp.sched.g MOVQ DX, R14 # set the g register # 4) 设置栈顶SP寄存器，切gp的栈，切换栈 # 把CPU的SP寄存器设置为sched.sp，完成了栈的切换，gp.sched.sp记录着g的栈顶位置 # 设置CPU的栈顶寄存器SP为gp.sched.sp，这条指令完成了栈的切换，从g0的栈切换到了gp的栈 # rsp = gp.sched.sp MOVQ gobuf_sp(BX), SP # restore SP # 5) 设置 AX = gp.sched.ret # 设置 DX = gp.sched.ctxt 闭包上下文 # 设置 BP = BP = gp.sched.bp 栈底寄存器 # 下面三条同样是恢复调度上下文到CPU相关寄存器 # 需要返回的地址 MOVQ gobuf_ret(BX), AX # AX = gp.sched.ret\t# 上下文环境，也就是当前注册函数的闭包捕获层，funcval地址处 MOVQ gobuf_ctxt(BX), DX # DX = gp.sched.ctxt\t# 设置栈基地址 MOVQ gobuf_bp(BX), BP # BP = gp.sched.bp\t# 6) 清空gp的gobuf.sp、gobuf.ret、gobuf.ctxt、gobuf.bp # 清空gp.sched中不再需要的值，因为我们已把相关值放入CPU对应的寄存器了 # clear to help garbage collector MOVQ $0, gobuf_sp(BX) # g.gobuf.sp = 0 MOVQ $0, gobuf_ret(BX) # g.gobuf.ret = 0 MOVQ $0, gobuf_ctxt(BX) # g.gobuf.ctxt = 0 MOVQ $0, gobuf_bp(BX) # g.gobuf.bp = 0 # 7) 跳转到g.gobuf.pc执行gp的相关代码 # 注意：从g0切换的gp过程中，并没有保存g0的相关栈信息 # gp.sched.pc 记录着注册函数开始的代码地址 # 把gp.sched.pc的值读取到BX寄存器，这个pc值是gp这个goroutine马上需要执行的第一条指令的地址 # 对于runtime.main这个场景来说它现在就是runtime.main函数的第一条指令，现在这条指令的地址就放在BX寄存器里面 # DX寄存器作为上下文，记录着闭包函数的相关捕获变量 MOVQ gobuf_pc(BX), BX # BX = g.gobuf.pc # 这里的JMP BX指令把BX寄存器里面的指令地址放入CPU的rip寄存器 # 于是，CPU就会跳转到该地址继续执行属于gp这个goroutine的代码，这样就完成了goroutine的切换 # 还需要注意的是：DX寄存器的值 gp.sched.ctxt 存储的是闭包的上下文信息，如果闭包捕获了变量则会使用它。 JMP BX # 跳转到注册的goroutine去执行了 总结： execute()函数完成从系统栈g0切换到普通goroutine的过程（这里是参数gp）。 该函数将工作线程m与gp相互绑定，然后切换gp的状态并设置栈溢出相关参数，以及设置调度次数， 接着调用gogo()函数把栈从g0切换成gp的栈，并把gp的调度信息保存在相关寄存器中，然后切换到gp开始执行相关代码。 这里需要注意的是，从g0切换到gp过程中并没有保存g0的相关栈顶SP相关信息，因此g0栈总是从一个固定的开始的位置开始的。 其他相关函数 checkTimers() 该函数是唤醒time.Sleep、time.Timer等的相关函数，查看runtime.timer文档。 文件位置：go1.19.3/src/runtime/proc.go。 3269 3270 3271 3272 3273 3274 3275 3276 3277 3278 3279 3280 3281 3282 3283 3284 3285 3286 3287 3288 3289 3290 3291 3292 3293 3294 3295 3296 3297 3298 3299 3300 3301 3302 3303 3304 3305 3306 3307 3308 3309 3310 3311 3312 3313 3314 3315 3316 3317 3318 3319 3320 3321 3322 3323 3324 3325 3326 3327 3328 3329 3330 3331 3332 3333 3334 3335 3336 3337 3338 3339 3340 3341 3342 3343 3344 // checkTimers runs any timers for the P that are ready. // If now is not 0 it is the current time. // It returns the passed time or the current time if now was passed as 0. // and the time when the next timer should run or 0 if there is no next timer, // and reports whether it ran any timers. // If the time when the next timer should run is not 0, // it is always larger than the returned time. // We pass now in and out to avoid extra calls of nanotime. // //go:yeswritebarrierrec func checkTimers(pp *p, now int64) (rnow, pollUntil int64, ran bool) { // If it's not yet time for the first timer, or the first adjusted // timer, then there is nothing to do. next := int64(atomic.Load64(\u0026pp.timer0When)) nextAdj := int64(atomic.Load64(\u0026pp.timerModifiedEarliest)) if next == 0 || (nextAdj != 0 \u0026\u0026 nextAdj \u003c next) { next = nextAdj } if next == 0 { // No timers to run or adjust. // 无需运行或调整计时器 return now, 0, false } if now == 0 { now = nanotime() } if now \u003c next { // Next timer is not ready to run, but keep going // if we would clear deleted timers. // This corresponds to the condition below where // we decide whether to call clearDeletedTimers. if pp != getg().m.p.ptr() || int(atomic.Load(\u0026pp.deletedTimers)) \u003c= int(atomic.Load(\u0026pp.numTimers)/4) { return now, next, false } } lock(\u0026pp.timersLock) // 如果当前P的timers存在数据 if len(pp.timers) \u003e 0 {\t// pp.timers记录着当前P中所有相关的timer // adjusttimers 在当前 P 的堆中查找任何已修改为更早运行的定时器，并将它们放在堆中的正确位置 // 在查找这些计时器时，它还会移动已修改为稍后运行的计时器，并删除已删除的计时器 // 调用者必须锁定 pp 的计时器 adjusttimers(pp, now) for len(pp.timers) \u003e 0 { // Note that runtimer may temporarily unlock // pp.timersLock. // 请注意，runtimer 可能会暂时解锁 pp.timersLock // runtimer函数 // runtimer 检查timers中的第一个timer。 如果它基于now准备好，它会运行timer并删除或更新它 // 如果它运行了一个timer，则返回 0，如果没有更多的timer，则返回 -1，或者第一个timer应该运行的时间 if tw := runtimer(pp, now); tw != 0 { if tw \u003e 0 { pollUntil = tw } break } ran = true } } // If this is the local P, and there are a lot of deleted timers, // clear them out. We only do this for the local P to reduce // lock contention on timersLock. // 如果当前P是当前工作线程绑定的P，并且有很多被删除的timer，清除它们 // 我们只对本地 P 这样做，以减少 timersLock 上的锁争用 if pp == getg().m.p.ptr() \u0026\u0026 int(atomic.Load(\u0026pp.deletedTimers)) \u003e len(pp.timers)/4 { clearDeletedTimers(pp) } unlock(\u0026pp.timersLock) return now, pollUntil, ran } checkdead() 检查死锁情况。检查基于正在运行的M的数量，如果0 -\u003e deadlock。 sched.lock必须被持有。 文件位置：go1.19.3/src/runtime/proc.go。 5017 5018 5019 5020 5021 5022 5023 5024 5025 5026 5027 5028 5029 5030 5031 5032 5033 5034 5035 5036 5037 5038 5039 5040 5041 5042 5043 5044 5045 5046 5047 5048 5049 5050 5051 5052 5053 5054 5055 5056 5057 5058 5059 5060 5061 5062 5063 5064 5065 5066 5067 5068 5069 5070 5071 5072 5073 5074 5075 5076 5077 5078 5079 5080 5081 5082 5083 5084 5085 5086 5087 5088 5089 5090 5091 5092 5093 5094 5095 5096 5097 5098 5099 5100 5101 5102 5103 5104 5105 5106 5107 5108 5109 5110 5111 5112 5113 5114 5115 5116 5117 5118 5119 5120 5121 5122 5123 5124 5125 5126 // Check for deadlock situation. // The check is based on number of running M's, if 0 -\u003e deadlock. // sched.lock must be held. func checkdead() { // sched.lock 必须被持有 assertLockHeld(\u0026sched.lock) // For -buildmode=c-shared or -buildmode=c-archive it's OK if // there are no running goroutines. The calling program is // assumed to be running. if islibrary || isarchive { return } // If we are dying because of a signal caught on an already idle thread, // freezetheworld will cause all running threads to block. // And runtime will essentially enter into deadlock state, // except that there is a thread that will call exit soon. if panicking.Load() \u003e 0 { return } // If we are not running under cgo, but we have an extra M then account // for it. (It is possible to have an extra M on Windows without cgo to // accommodate callbacks created by syscall.NewCallback. See issue #6751 // for details.) var run0 int32 if !iscgo \u0026\u0026 cgoHasExtraM { mp := lockextra(true) haveExtraM := extraMCount \u003e 0 unlockextra(mp) if haveExtraM { run0 = 1 } } //func mcount() int32 { // return int32(sched.mnext - sched.nmfreed) //} run := mcount() - sched.nmidle - sched.nmidlelocked - sched.nmsys if run \u003e run0 { return } if run \u003c 0 { print(\"runtime: checkdead: nmidle=\", sched.nmidle, \" nmidlelocked=\", sched.nmidlelocked, \" mcount=\", mcount(), \" nmsys=\", sched.nmsys, \"\\n\") throw(\"checkdead: inconsistent counts\") } grunning := 0 forEachG(func(gp *g) { if isSystemGoroutine(gp, false) { return } s := readgstatus(gp) switch s \u0026^ _Gscan { case _Gwaiting, _Gpreempted: grunning++ case _Grunnable, _Grunning, _Gsyscall: print(\"runtime: checkdead: find g \", gp.goid, \" in status \", s, \"\\n\") throw(\"checkdead: runnable g\") } }) if grunning == 0 { // possible if main goroutine calls runtime·Goexit() unlock(\u0026sched.lock) // unlock so that GODEBUG=scheddetail=1 doesn't hang fatal(\"no goroutines (main called runtime.Goexit) - deadlock!\") } // Maybe jump time forward for playground. if faketime != 0 { if when := timeSleepUntil(); when \u003c maxWhen { faketime = when // Start an M to steal the timer. pp, _ := pidleget(faketime) if pp == nil { // There should always be a free P since // nothing is running. throw(\"checkdead: no p for timer\") } mp := mget() if mp == nil { // There should always be a free M since // nothing is running. throw(\"checkdead: no m for timer\") } // M must be spinning to steal. We set this to be // explicit, but since this is the only M it would // become spinning on its own anyways. sched.nmspinning.Add(1) mp.spinning = true mp.nextp.set(pp) notewakeup(\u0026mp.park) return } } // There are no goroutines running, so we can look at the P's. for _, pp := range allp { // 当某个P中存在timer，即使全部P都睡眠了也不会报错 if len(pp.timers) \u003e 0 { return } } unlock(\u0026sched.lock) // unlock so that GODEBUG=scheddetail=1 doesn't hang fatal(\"all goroutines are asleep - deadlock!\") } ",
  "wordCount" : "10915",
  "inLanguage": "zh",
  "image": "https://heliu.site/favicon-32x32.png","datePublished": "2024-07-30T00:00:00Z",
  "dateModified": "2024-07-30T00:00:00Z",
  "author":[{
    "@type": "Person",
    "name": "helium"
  }],
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://heliu.site/posts/golang/goroutine/mstart/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Helium",
    "logo": {
      "@type": "ImageObject",
      "url": "https://heliu.site/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://heliu.site/" accesskey="h" title="Blog (Alt + H)">
                <img src="https://heliu.site/helium.png" alt="" aria-label="logo"
                    height="35">Blog</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://heliu.site/" title="主页">
                    <span>Home</span>
                </a>
            </li>
            <li>
                <a href="https://heliu.site/posts" title="文章">
                    <span>Article</span>
                </a>
            </li>
            <li>
                <a href="https://heliu.site/archives" title="时间轴">
                    <span>Archive</span>
                </a>
            </li>
            <li>
                <a href="https://heliu.site/tags/" title="标签">
                    <span>Tag</span>
                </a>
            </li>
            <li>
                <a href="https://heliu.site/search/" title="搜索 (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
            <li>
                <a href="https://heliu.site/support" title="打赏">
                    <span>🫶Help</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">


<article class="post" autonumbering>
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://heliu.site/">主页</a>&nbsp;»&nbsp;<a href="https://heliu.site/posts/">Article</a>&nbsp;»&nbsp;<a href="https://heliu.site/posts/golang/">Golang</a>&nbsp;»&nbsp;<a href="https://heliu.site/posts/golang/goroutine/">第12章 Goroutine</a></div>
    <h1 class="post-title entry-hint-parent">
      GMP 调度模型
    </h1>
    <div class="post-description">
      💥本文章所有相关go代码参考自go 1.18&#43;版本
    </div>
    <div class="post-meta">










<span class="x-post-meta-item"><svg t="1720837714681" class="icon" viewBox="0 0 1084 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="7520" width="200" height="200"><path d="M123.47509 1023.984942a123.565437 123.565437 0 0 1-123.505206-123.32451V243.863302A123.565437 123.565437 0 0 1 123.47509 120.568908h171.630374V26.06529a26.050232 26.050232 0 0 1 52.070349 0v94.503618h377.592848V26.06529a26.050232 26.050232 0 0 1 52.100464 0v94.503618h183.797189A123.565437 123.565437 0 0 1 1084.171519 243.863302v656.79713A123.565437 123.565437 0 0 1 960.666314 1023.984942H123.47509z m-71.404741-123.32451A71.434857 71.434857 0 0 0 123.47509 971.974825h837.191224a71.434857 71.434857 0 0 0 71.404741-71.314393V442.326922l-946.361273-3.824716a25.598494 25.598494 0 0 1-5.84248-0.692665l-27.796953-6.444798v469.295689zM123.47509 172.579025a71.434857 71.434857 0 0 0-71.404741 71.284277v149.736133l27.796953-6.444797a26.080348 26.080348 0 0 1 5.902712-0.662549l946.301041 3.824716V243.863302a71.404741 71.404741 0 0 0-71.404741-71.284277h-180.183284l-6.173754 12.859479a26.200812 26.200812 0 0 1-23.490383 14.786895 26.261043 26.261043 0 0 1-23.520499-14.786895l-6.173754-12.859479H350.819834l-6.173754 12.859479a26.200812 26.200812 0 0 1-23.490383 14.786895 26.230928 26.230928 0 0 1-23.520499-14.786895l-6.173755-12.859479H123.47509z m156.150814 578.827128a26.050232 26.050232 0 0 1-26.050232-25.990001c0-14.335157 11.68496-26.020116 26.050232-26.020116h521.697312c14.365273 0 26.050232 11.68496 26.050233 26.020116a26.050232 26.050232 0 0 1-26.050233 25.990001H279.625904z" fill="#3D3F42" p-id="7521"></path></svg><span>2024-07-30</span></span>&nbsp;<span class="x-post-meta-item"><svg t="1720839329181" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="14106" width="200" height="200"><path d="M699.270662 190.485379c-0.411369 0-0.821715 0.011256-1.227967 0.032746H507.034407a23.041786 23.041786 0 0 0-1.221828-0.031723c-12.779048 0-23.140023 10.359952-23.140023 23.139 0 12.781094 10.360975 23.141046 23.140023 23.141046v0.032746h193.458083v-0.032746c12.780071 0 23.141046-10.359952 23.141047-23.141046 0-12.780071-10.360975-23.140023-23.141047-23.140023zM979.215516 724.005508c0-142.090159-115.186416-257.277598-257.277598-257.277598-72.245418 0-137.532353 29.777187-184.262654 77.725223l45.868677 31.474852c36.227086-33.873482 84.882226-54.617945 138.393977-54.617945 111.945605 0 202.696492 90.750887 202.696492 202.695468h-43.01263l70.331835 104.289228 70.331835-104.289228H979.215516z" fill="" p-id="14107"></path><path d="M748.885664 588.843132c0-14.881942-12.06785-26.945699-26.947746-26.945698-14.883989 0-26.947745 12.063757-26.947745 26.945698v135.164423c0 14.879895 12.063757 26.945699 26.947745 26.945699h107.786889c14.881942 0 26.945699-12.063757 26.945698-26.945699s-12.063757-26.945699-26.945698-26.945699h-80.839143V588.843132zM721.937918 926.702c-111.947651 0-202.696492-90.74884-202.696492-202.696492 0-0.144286 0.004093-0.285502 0.004094-0.429788h43.004443l-70.330812-104.289228-70.331835 104.289228h43.075051c0 0.144286-0.00307 0.285502-0.00307 0.429788 0 142.091182 115.187439 257.279644 257.278621 257.279645 72.241324 0 137.530306-29.77821 184.260607-77.727269l-45.86663-31.474852c-36.227086 33.873482-84.884272 54.618968-138.393977 54.618968zM694.633039 423.38066c-1.354857-11.487635-11.120268-20.400632-22.972201-20.400632H206.362486c-12.780071 0-23.140023 10.359952-23.140023 23.138999 0 12.781094 10.359952 23.141046 23.140023 23.141047H596.949252c30.209022-13.81668 63.104223-22.76754 97.683787-25.879414zM438.548616 623.143333H206.362486c-12.780071 0-23.140023 10.358929-23.140023 23.140023 0 12.780071 10.359952 23.140023 23.140023 23.140023h219.956598a298.463626 298.463626 0 0 1 12.229532-46.280046zM506.934123 513.062192H206.362486c-12.780071 0-23.140023 10.359952-23.140023 23.139 0 12.781094 10.359952 23.140023 23.140023 23.140023H469.936487a302.241672 302.241672 0 0 1 36.997636-46.279023z" fill="" p-id="14108"></path><path d="M442.765661 835.277778a298.531164 298.531164 0 0 1-14.365173-46.150087H146.542052v-0.065491c-33.036417 0-59.81941-26.78197-59.81941-59.819411V329.36031h704.907545v100.905154a298.561863 298.561863 0 0 1 46.150086 14.996552V194.619536h-0.162706c0-53.422723-43.307342-96.728018-96.730065-96.728018h-68.89409V84.418668c0-33.037441-26.782993-59.81941-59.81941-59.81941v-0.361227h-18.87079v0.032745c-33.038464 0-59.820434 26.78197-59.820433 59.819411 0 0.109494 0.008186 0.218988 0.008186 0.328481h-0.339738v13.47285H345.203648V84.418668c0-33.037441-26.782993-59.81941-59.819411-59.81941v-0.361227h-18.872836v0.032745c-33.036417 0-59.81941 26.78197-59.81941 59.819411 0 0.109494 0.007163 0.218988 0.008186 0.328481h-0.339737v13.47285h-69.189826c-53.4217 0-96.729042 43.306318-96.729041 96.728018 0 1.701758 0.045025 3.39226 0.132006 5.071505v533.785166a98.051153 98.051153 0 0 0-0.132006 5.071506c0 53.4217 43.307342 96.728018 96.729041 96.728018v0.001023h305.595047zM86.723665 204.056466c0-33.037441 26.782993-59.81941 59.819411-59.819411 0.044002 0 0.086981 0.00307 0.130983 0.00307v-0.068561h105.968473V94.874811h0.032746a22.807449 22.807449 0 0 1-0.032746-1.215688c0-12.779048 10.360975-23.140023 23.140023-23.140023s23.140023 10.360975 23.140023 23.140023c0 0.408299-0.010233 0.812505-0.031722 1.215688h0.031722v49.297776h280.508696V94.874811h0.032745a22.807449 22.807449 0 0 1-0.032745-1.215688c0-12.779048 10.361999-23.140023 23.140023-23.140023 12.780071 0 23.141046 10.360975 23.141046 23.140023 0 0.408299-0.011256 0.812505-0.032746 1.215688h0.032746v49.297776h106.10048v0.065492c33.035394 0 59.818387 26.780947 59.818387 59.81941h0.130983V283.080264H86.723665v-79.023798z" fill="" p-id="14109"></path></svg><span>2024-07-30</span></span>&nbsp;<span class="x-post-meta-item"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2" fill="none"
     stroke-linecap="round" stroke-linejoin="round" class="feather feather-file-text" style="user-select: text;">
    <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z" style="user-select: text;"></path>
    <polyline points="14 2 14 8 20 8" style="user-select: text;"></polyline>
    <line x1="16" y1="13" x2="8" y2="13" style="user-select: text;"></line>
    <line x1="16" y1="17" x2="8" y2="17" style="user-select: text;"></line>
    <polyline points="10 9 9 9 8 9" style="user-select: text;"></polyline>
</svg><span>10915字</span></span>&nbsp;<span class="x-post-meta-item"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2" fill="none"
     stroke-linecap="round" stroke-linejoin="round">
    <path stroke="none" d="M0 0h24v24H0z" fill="none"></path>
    <circle cx="12" cy="12" r="9"></circle>
    <polyline points="12 7 12 12 15 15"></polyline>
</svg><span>52分钟</span></span>&nbsp;<span class="x-post-meta-item"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2" fill="none"
     stroke-linecap="round" stroke-linejoin="round">
    <path stroke="none" d="M0 0h24v24H0z" fill="none"></path>
    <circle cx="12" cy="7" r="4"></circle>
    <path d="M6 21v-2a4 4 0 0 1 4 -4h4a4 4 0 0 1 4 4v2"></path>
</svg><span>helium</span></span>
      <span class="x-post-meta-item">
        &nbsp;<svg t="1720840393161" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="18680" width="200" height="200"><path d="M995.125144 559.61812l-415.998603-415.998602A52.986489 52.986489 0 0 0 541.413335 127.99957H338.847348c-3.166656-26.559911-9.286635-51.046495-17.999939-71.333094C299.734146 7.333309 271.154242 0 256.00096 0c-13.939953 0-40.439864 6.339979-61.259794 48.806503-10.473298 21.366595-17.946606 48.966502-21.573261 79.193067H53.334974a53.393154 53.393154 0 0 0-53.333154 53.333154v360.078791a52.986489 52.986489 0 0 0 15.619948 37.713206l415.998602 415.998603a53.333154 53.333154 0 0 0 75.426413 0l26.286579-26.293245 26.286578 26.293245a53.426487 53.426487 0 0 0 16.719944 11.333295 21.333262 21.333262 0 0 0 36.079879 11.293295l382.705381-382.705381a53.399821 53.399821 0 0 0 0-75.426413z m-762.070774-491.998347C241.494342 50.373164 250.667645 42.666523 256.00096 42.666523c5.99998 0 16.573278 9.639968 25.646581 30.806564 6.493312 15.159949 11.333295 33.999886 14.146619 54.526483H216.16776c3.206656-23.419921 9.013303-44.359851 16.88661-60.41313z m243.819181 897.330319a10.666631 10.666631 0 0 1-15.079949 0l-415.998603-415.998603A10.573298 10.573298 0 0 1 42.668343 541.411515V181.332724a10.666631 10.666631 0 0 1 10.666631-10.666631h245.332509c0 47.853173-10.373298 92.15969-27.066575 115.632945-5.926647 8.326639-16.566611 14.186619-22.306592 16.113279C204.041135 314.752276 170.667913 356.218803 170.667913 405.331972c0 58.813136 47.853173 106.666308 106.666309 106.666308s106.666308-47.853173 106.666308-106.666308c0-47.086508-30.666564-87.139707-73.079754-101.246327C330.060711 272.705751 341.334007 223.692582 341.334007 170.666093h72.079758a10.573298 10.573298 0 0 1 7.539974 3.126656l415.998603 415.998603a10.666631 10.666631 0 0 1 0 15.079949zM341.334007 405.331972a63.999785 63.999785 0 1 1-63.999785-63.999785 64.073118 64.073118 0 0 1 63.999785 63.999785z m263.539114 559.61812a10.666631 10.666631 0 0 1-15.079949 0L563.499927 938.663513l303.625647-303.61898a53.399821 53.399821 0 0 0 0-75.426413L478.16688 170.666093h63.246455a10.573298 10.573298 0 0 1 7.539974 3.126656l415.998603 415.998603c0.239999 0.239999 0.466665 0.486665 0.666664 0.746664l0.086667 0.106666a10.666631 10.666631 0 0 1 0 13.373289l-0.086667 0.106666c-0.213333 0.259999-0.439999 0.506665-0.666664 0.746664z" fill="#5C5C66" p-id="18681"></path></svg>
        <ul class="post-tags-meta" style="display: inline-block;font-size: 14px;">
            <a href="https://heliu.site/tags/golang/" target="_blank" rel="noopener">Golang</a>
            <a href="https://heliu.site/tags/goroutine/" target="_blank" rel="noopener">Goroutine</a>
        </ul>
      </span>
      
      <span id="busuanzi_container_page_pv" class="x-post-meta-item">
        &nbsp;<svg t="1720844685710" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="27237" width="200" height="200"><path d="M739.754667 574.08c-121.386667 45.610667-208.469333 169.813333-208.64 316.16 0 33.408 4.693333 65.493333 13.141333 95.914667H94.122667c-26.453333-43.52-41.685333-91.946667-41.685334-143.189334 0-185.173333 192.896-335.104 430.805334-335.104 96.256 0 184.832 24.746667 256.512 66.218667z m-280.490667-114.986667a214.869333 214.869333 0 0 1-214.869333-215.04A215.04 215.04 0 0 1 459.264 28.842667a215.04 215.04 0 0 1 215.04 215.210666 215.04 215.04 0 0 1-215.04 215.04zM974.506667 641.28c9.856 0 17.834667 7.466667 17.834666 16.64v59.989333c-0.341333 8.789333-7.850667 15.786667-17.28 16.085334-9.856 0.341333-18.176-6.826667-18.517333-16.085334v-20.053333l-99.114667 91.093333-0.256 0.256a18.474667 18.474667 0 0 1-14.848 4.352h-0.768a18.176 18.176 0 0 1-9.344-4.608l-0.938666-0.981333-85.930667-80.042667-123.562667 115.072a18.773333 18.773333 0 0 1-25.216 0 15.786667 15.786667 0 0 1 0-23.466666l136.149334-126.848 0.725333-0.597334a18.645333 18.645333 0 0 1 24.362667 0.512l87.253333 81.237334 86.058667-79.232h-21.248c-9.386667-0.298667-16.938667-7.338667-17.28-16.085334-0.341333-9.173333 7.381333-16.896 17.28-17.237333h64.64z m-367.146667 240h48.128c8.874667 0 16.042667 7.168 16.042667 16.042667v72.192a16.042667 16.042667 0 0 1-16.042667 16.042666h-48.128a16.042667 16.042667 0 0 1-16.042667-16.042666v-72.192c0-8.874667 7.210667-16.042667 16.042667-16.042667z m110.805333-106.666667h48.128c8.874667 0 16.042667 7.168 16.042667 16.042667v178.858667a16.042667 16.042667 0 0 1-16.042667 16.042666h-48.128a16.042667 16.042667 0 0 1-16.042666-16.042666v-178.858667c0-8.874667 7.168-16.042667 16.042666-16.042667z m106.538667 80h48.128c8.874667 0 16.042667 7.168 16.042667 16.042667v99.413333a16.042667 16.042667 0 0 1-16.042667 16.042667H824.746667a16.042667 16.042667 0 0 1-16.042667-16.042667v-99.413333c0-8.874667 7.168-16.042667 16.042667-16.042667z m110.165333-80h48.128c8.874667 0 16.042667 7.168 16.042667 16.042667v179.413333a16.042667 16.042667 0 0 1-16.042667 16.042667h-48.128a16.042667 16.042667 0 0 1-16.042666-16.042667v-179.413333c0-8.874667 7.210667-16.042667 16.042666-16.042667z" fill="#999999" p-id="27238"></path></svg>
        <span id="busuanzi_value_page_pv"></span>
      </span>

</div>
  </header> <aside id="toc-container" class="toc-container wide">
    <div class="toc">
        <details  open>
            <summary accesskey="c" title="(Alt + C)">
                <span class="details">目录</span>
            </summary>

            <div class="inner"><ul>
                    <li>
                        <a href="#runtimemstartsb" aria-label="runtime·mstart(SB)">runtime·mstart(SB)</a><ul>
                            
                    <li>
                        <a href="#mstart0" aria-label="mstart0()">mstart0()</a></li>
                    <li>
                        <a href="#mstart1" aria-label="mstart1()">mstart1()</a></li></ul>
                    </li>
                    <li>
                        <a href="#schedule" aria-label="schedule()">schedule()</a><ul>
                            
                    <li>
                        <a href="#findrunnable" aria-label="findRunnable()🚀">findRunnable()🚀</a></li>
                    <li>
                        <a href="#gcstopm" aria-label="gcstopm()">gcstopm()</a><ul>
                            
                    <li>
                        <a href="#releasep" aria-label="releasep()">releasep()</a></li>
                    <li>
                        <a href="#stopm" aria-label="stopm()">stopm()</a></li>
                    <li>
                        <a href="#mput" aria-label="mput()">mput()</a></li>
                    <li>
                        <a href="#mpark" aria-label="mPark()">mPark()</a></li>
                    <li>
                        <a href="#acquirep" aria-label="acquirep()">acquirep()</a></li></ul>
                    </li>
                    <li>
                        <a href="#globrunqget" aria-label="globrunqget()">globrunqget()</a><ul>
                            
                    <li>
                        <a href="#runqput" aria-label="runqput()">runqput()</a></li></ul>
                    </li>
                    <li>
                        <a href="#runqget" aria-label="runqget()">runqget()</a></li>
                    <li>
                        <a href="#injectglist" aria-label="injectglist()">injectglist()</a></li>
                    <li>
                        <a href="#stealwork" aria-label="stealWork()">stealWork()</a><ul>
                            
                    <li>
                        <a href="#runqsteal" aria-label="runqsteal()">runqsteal()</a></li>
                    <li>
                        <a href="#runqgrab" aria-label="runqgrab()">runqgrab()</a></li></ul>
                    </li>
                    <li>
                        <a href="#releasep-1" aria-label="releasep()">releasep()</a></li>
                    <li>
                        <a href="#pidleput" aria-label="pidleput()">pidleput()</a><ul>
                            
                    <li>
                        <a href="#runqempty" aria-label="runqempty()">runqempty()</a></li>
                    <li>
                        <a href="#pidleget" aria-label="pidleget()">pidleget()</a></li></ul>
                    </li>
                    <li>
                        <a href="#checkrunqsnop" aria-label="checkRunqsNoP()">checkRunqsNoP()</a></li>
                    <li>
                        <a href="#checkidlegcnop" aria-label="checkIdleGCNoP()">checkIdleGCNoP()</a></li>
                    <li>
                        <a href="#checktimersnop" aria-label="checkTimersNoP()">checkTimersNoP()</a></li>
                    <li>
                        <a href="#stopm-1" aria-label="stopm()">stopm()</a><ul>
                            
                    <li>
                        <a href="#mput-1" aria-label="mput()">mput()</a></li>
                    <li>
                        <a href="#mget" aria-label="mget()">mget()</a></li>
                    <li>
                        <a href="#mpark-1" aria-label="mPark()">mPark()</a></li>
                    <li>
                        <a href="#notesleep" aria-label="notesleep()">notesleep()</a></li>
                    <li>
                        <a href="#futexsleep" aria-label="futexsleep()">futexsleep()</a></li>
                    <li>
                        <a href="#futex" aria-label="futex()">futex()</a></li></ul>
                    </li></ul>
                    </li>
                    <li>
                        <a href="#execute-" aria-label="execute() 🚀">execute() 🚀</a><ul>
                            
                    <li>
                        <a href="#gogo" aria-label="gogo()">gogo()</a></li></ul>
                    </li>
                    <li>
                        <a href="#%e5%85%b6%e4%bb%96%e7%9b%b8%e5%85%b3%e5%87%bd%e6%95%b0" aria-label="其他相关函数">其他相关函数</a><ul>
                            
                    <li>
                        <a href="#checktimers" aria-label="checkTimers()">checkTimers()</a></li>
                    <li>
                        <a href="#checkdead" aria-label="checkdead()">checkdead()</a>
                    </li>
                </ul>
                </li>
                </ul>
            </div>
        </details>
    </div>
</aside>
<script>
    let activeElement;
    let elements;
    window.addEventListener('DOMContentLoaded', function (event) {
        checkTocPosition();

        elements = document.querySelectorAll('h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]');
         
         activeElement = elements[0];
         const id = encodeURI(activeElement.getAttribute('id')).toLowerCase();
         document.querySelector(`.inner ul li a[href="#${id}"]`).classList.add('active');
     }, false);

    window.addEventListener('resize', function(event) {
        checkTocPosition();
    }, false);

    window.addEventListener('scroll', () => {
        
        activeElement = Array.from(elements).find((element) => {
            if ((getOffsetTop(element) - window.pageYOffset) > 0 && 
                (getOffsetTop(element) - window.pageYOffset) < window.innerHeight/2) {
                return element;
            }
        }) || activeElement

        elements.forEach(element => {
             const id = encodeURI(element.getAttribute('id')).toLowerCase();
             if (element === activeElement){
                 document.querySelector(`.inner ul li a[href="#${id}"]`).classList.add('active');
             } else {
                 document.querySelector(`.inner ul li a[href="#${id}"]`).classList.remove('active');
             }
         })
     }, false);

    const main = parseInt(getComputedStyle(document.body).getPropertyValue('--article-width'), 10);
    const toc = parseInt(getComputedStyle(document.body).getPropertyValue('--toc-width'), 10);
    const gap = parseInt(getComputedStyle(document.body).getPropertyValue('--gap'), 10);

    function checkTocPosition() {
        const width = document.body.scrollWidth;

        if (width - main - (toc * 2) - (gap * 4) > 0) {
            document.getElementById("toc-container").classList.add("wide");
        } else {
            document.getElementById("toc-container").classList.remove("wide");
        }
    }

    function getOffsetTop(element) {
        if (!element.getClientRects().length) {
            return 0;
        }
        let rect = element.getBoundingClientRect();
        let win = element.ownerDocument.defaultView;
        return rect.top + win.pageYOffset;   
    }
</script>
  <div class="post-content"><ul>
<li>本篇介绍Golang相关调度代码，本篇也是理解GMP模型的重点篇节。</li>
</ul>
<h2 id="runtimemstartsb">runtime·mstart(SB)<a hidden class="anchor" aria-hidden="true" href="#runtimemstartsb">#</a></h2>
<p>工作线程<code>M</code>的自旋状态(<code>spinning</code>)解释：<strong>工作线程在从其它工作线程的本地运行队列中盗取<code>goroutine</code>时的状态称为自旋状态</strong>。</p>
<ol>
<li>该函数是所有新创建的工作线程需要执行的函数，也是调度循环的入口函数。</li>
<li>所有【新创建的工作线程】开始运行的入口都是从这个函数开始运行的。</li>
<li>文件位置：<code>go1.19.3/src/runtime/asm_amd64.s</code>。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">389
</span><span class="lnt">390
</span><span class="lnt">391
</span><span class="lnt">392
</span><span class="lnt">393
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-asm" data-lang="asm"><span class="line"><span class="cl"><span class="nf">TEXT</span> <span class="no">runtime</span><span class="err">·</span><span class="no">mstart</span><span class="p">(</span><span class="no">SB</span><span class="p">),</span><span class="no">NOSPLIT</span><span class="err">|</span><span class="no">TOPFRAME</span><span class="p">,</span><span class="no">$0</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># 调用runtime.mstart0函数，该函数永远不会返回
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">CALL</span>    <span class="no">runtime</span><span class="err">·</span><span class="no">mstart0</span><span class="p">(</span><span class="no">SB</span><span class="p">)</span> 
</span></span><span class="line"><span class="cl">    <span class="c1"># 未达到。不会到这里来。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">RET</span> <span class="c1"># not reached
</span></span></span></code></pre></td></tr></table>
</div>
</div><h3 id="mstart0">mstart0()<a hidden class="anchor" aria-hidden="true" href="#mstart0">#</a></h3>
<ol>
<li><code>mstart0</code>是新<code>Ms</code>的<code>Go</code>入口点。该函数是不允许栈增长检查的，因为我们甚至可能还没有设置堆栈边界。</li>
<li>能在<code>STW</code>期间运行（因为它还没有<code>P</code>），所以不允许写屏障。</li>
<li>初始化<code>g0</code>栈大小，以及调用<code>mstart1()</code>函数开启调度循环。</li>
<li>因为可能存在其他刚创建的工作线程并没有初始化<code>g0</code>栈大小，所以这里需要设置一下。</li>
<li>文件位置：<code>go1.19.3/src/runtime/proc.go</code>。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1347
</span><span class="lnt">1348
</span><span class="lnt">1349
</span><span class="lnt">1350
</span><span class="lnt">1351
</span><span class="lnt">1352
</span><span class="lnt">1353
</span><span class="lnt">1354
</span><span class="lnt">1355
</span><span class="lnt">1356
</span><span class="lnt">1357
</span><span class="lnt">1358
</span><span class="lnt">1359
</span><span class="lnt">1360
</span><span class="lnt">1361
</span><span class="lnt">1362
</span><span class="lnt">1363
</span><span class="lnt">1364
</span><span class="lnt">1365
</span><span class="lnt">1366
</span><span class="lnt">1367
</span><span class="lnt">1368
</span><span class="lnt">1369
</span><span class="lnt">1370
</span><span class="lnt">1371
</span><span class="lnt">1372
</span><span class="lnt">1373
</span><span class="lnt">1374
</span><span class="lnt">1375
</span><span class="lnt">1376
</span><span class="lnt">1377
</span><span class="lnt">1378
</span><span class="lnt">1379
</span><span class="lnt">1380
</span><span class="lnt">1381
</span><span class="lnt">1382
</span><span class="lnt">1383
</span><span class="lnt">1384
</span><span class="lnt">1385
</span><span class="lnt">1386
</span><span class="lnt">1387
</span><span class="lnt">1388
</span><span class="lnt">1389
</span><span class="lnt">1390
</span><span class="lnt">1391
</span><span class="lnt">1392
</span><span class="lnt">1393
</span><span class="lnt">1394
</span><span class="lnt">1395
</span><span class="lnt">1396
</span><span class="lnt">1397
</span><span class="lnt">1398
</span><span class="lnt">1399
</span><span class="lnt">1400
</span><span class="lnt">1401
</span><span class="lnt">1402
</span><span class="lnt">1403
</span><span class="lnt">1404
</span><span class="lnt">1405
</span><span class="lnt">1406
</span><span class="lnt">1407
</span><span class="lnt">1408
</span><span class="lnt">1409
</span><span class="lnt">1410
</span><span class="lnt">1411
</span><span class="lnt">1412
</span><span class="lnt">1413
</span><span class="lnt">1414
</span><span class="lnt">1415
</span><span class="lnt">1416
</span><span class="lnt">1417
</span><span class="lnt">1418
</span><span class="lnt">1419
</span><span class="lnt">1420
</span><span class="lnt">1421
</span><span class="lnt">1422
</span><span class="lnt">1423
</span><span class="lnt">1424
</span><span class="lnt">1425
</span><span class="lnt">1426
</span><span class="lnt">1427
</span><span class="lnt">1428
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// mstart0 is the Go entry-point for new Ms.
</span></span></span><span class="line"><span class="cl"><span class="c1">// This must not split the stack because we may not even have stack
</span></span></span><span class="line"><span class="cl"><span class="c1">// bounds set up yet.
</span></span></span><span class="line"><span class="cl"><span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1">// May run during STW (because it doesn&#39;t have a P yet), so write
</span></span></span><span class="line"><span class="cl"><span class="c1">// barriers are not allowed.
</span></span></span><span class="line"><span class="cl"><span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1">//go:nosplit
</span></span></span><span class="line"><span class="cl"><span class="c1">//go:nowritebarrierrec
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">mstart0</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 该函数是工作线程M起来执行的入口函数，这里一定是g0栈。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">_g_</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">()</span>   <span class="c1">// _g_ = g0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 当前g是否已分配栈：
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//  1. 程序刚初始化时前面是分配了大约64KB大小栈。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//  2. 如果是通过wakeup()函数创建的工作线程，这里可能是没有分配栈大小的。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">osStack</span> <span class="o">:=</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">stack</span><span class="p">.</span><span class="nx">lo</span> <span class="o">==</span> <span class="mi">0</span>    <span class="c1">// 判断当前g0是否分配栈
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nx">osStack</span> <span class="p">{</span> <span class="c1">// 栈未分配大小时，这也是新创建的工作线程需要处理的g栈情况
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// Initialize stack bounds from system stack.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// Cgo may have left stack size in stack.hi.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// minit may update the stack bounds.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 从系统栈初始化栈边界。Cgo 可能在 stack.hi 中留下了栈大小。minit 可能会更新栈边界。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// Note: these bounds may not be very accurate.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// We set hi to &amp;size, but there are things above
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// it. The 1024 is supposed to compensate this,
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// but is somewhat arbitrary.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 注意：这些界限可能不是很准确。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 我们将 hi 设置为 &amp;size，但是上面还有一些东西。 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 1024 应该可以弥补这一点，但有些武断。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        
</span></span><span class="line"><span class="cl">        <span class="c1">// 以上的意思是直接在当前工作线程系统栈上给当前这个g0分配栈大小。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 可能上面有栈数据，偏移1024字节应该能弥补这些数据。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">size</span> <span class="o">:=</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">stack</span><span class="p">.</span><span class="nx">hi</span> <span class="c1">// size 多半是0; size 一定是分配在当前栈上的，因此&amp;size就是栈地址。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="nx">size</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>	
</span></span><span class="line"><span class="cl">            <span class="c1">// sys.StackGuardMultiplier = 1; 可见其他工作线程的g0栈大约为8KB。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="nx">size</span> <span class="p">=</span> <span class="mi">8192</span> <span class="o">*</span> <span class="nx">sys</span><span class="p">.</span><span class="nx">StackGuardMultiplier</span>  <span class="c1">// 设置size为指定值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">        <span class="c1">// noescape函数取size地址并与0异或，实际作用是隐藏(防止)size变量逃逸分析指针
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 防止编译器把size变量堆分配，这里需要的是栈分配
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 因此当前_g_的栈备份分配到当前栈的size变量位置
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// noescape函数：
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// func noescape(p unsafe.Pointer) unsafe.Pointer {
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">//      x := uintptr(p)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">//      return unsafe.Pointer(x ^ 0)    // 防止变量x逃逸
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// }
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 以&amp;size为起点设置g0栈。g0.stack -&gt; [&amp;size, &amp;size - 8192 + 1024]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">_g_</span><span class="p">.</span><span class="nx">stack</span><span class="p">.</span><span class="nx">hi</span> <span class="p">=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nf">noescape</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">size</span><span class="p">)))</span> <span class="c1">// hi存储size的地址，也就是rbp
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">_g_</span><span class="p">.</span><span class="nx">stack</span><span class="p">.</span><span class="nx">lo</span> <span class="p">=</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">stack</span><span class="p">.</span><span class="nx">hi</span> <span class="o">-</span> <span class="nx">size</span> <span class="o">+</span> <span class="mi">1024</span>   <span class="c1">// lo存储栈顶位置，也就是rsp
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c1">// Initialize stack guard so that we can start calling regular
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// Go code.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 初始化栈保护，以便我们可以开始调用常规 Go 代码。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// stackguard0 = _g_.stack.lo + 928; 栈溢出检查的阈值点。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">_g_</span><span class="p">.</span><span class="nx">stackguard0</span> <span class="p">=</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">stack</span><span class="p">.</span><span class="nx">lo</span> <span class="o">+</span> <span class="nx">_StackGuard</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c1">// This is the g0, so we can also call go:systemstack
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// functions, which check stackguard1.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 这是 g0，所以我们也可以调用 go:systemstack 函数来检查 stackguard1。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">_g_</span><span class="p">.</span><span class="nx">stackguard1</span> <span class="p">=</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">stackguard0</span>
</span></span><span class="line"><span class="cl">    <span class="nf">mstart1</span><span class="p">()</span> <span class="c1">// 调用mstart1开启调度循环，该函数永远不会返回
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Exit this thread.	
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 退出这个线程，程序不会到这里。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nf">mStackIsSystemAllocated</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// Windows, Solaris, illumos, Darwin, AIX and Plan 9 always system-allocate
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// the stack, but put it in _g_.stack before mstart,
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// so the logic above hasn&#39;t set osStack yet.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// Windows、Solaris、illumos、Darwin、AIX 和Plan 9 总是系统分配栈，但是在mstart 之前放在_g_.stack 中，
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 所以上面的逻辑还没有设置osStack
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">osStack</span> <span class="p">=</span> <span class="kc">true</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nf">mexit</span><span class="p">(</span><span class="nx">osStack</span><span class="p">)</span> <span class="c1">// 结束当前线程。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ol start="6">
<li>总结：工作线程开始执行使，先判断<code>g0</code>是否分配了栈大小，没有则分配大约<code>8KB</code>大小栈空间，然后设置<code>stackguard0</code>、<code>stackguard1</code>。</li>
</ol>
<h3 id="mstart1">mstart1()<a hidden class="anchor" aria-hidden="true" href="#mstart1">#</a></h3>
<ol>
<li>设置<code>g0</code>被调度时的调度信息，比如从哪里进入，栈从哪里开始等，以及给当前工作线程<code>M</code>绑定个<code>P</code>并开启调度循环。</li>
<li>设置<code>g0</code>的调度信息是在于，在调度循环过程中会切换到<code>g0</code>栈执行<code>runtime</code>的相关函数，以免栈无限扩大。</li>
<li>文件位置：<code>go1.19.3/src/runtime/proc.go</code>。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1394
</span><span class="lnt">1395
</span><span class="lnt">1396
</span><span class="lnt">1397
</span><span class="lnt">1398
</span><span class="lnt">1399
</span><span class="lnt">1400
</span><span class="lnt">1401
</span><span class="lnt">1402
</span><span class="lnt">1403
</span><span class="lnt">1404
</span><span class="lnt">1405
</span><span class="lnt">1406
</span><span class="lnt">1407
</span><span class="lnt">1408
</span><span class="lnt">1409
</span><span class="lnt">1410
</span><span class="lnt">1411
</span><span class="lnt">1412
</span><span class="lnt">1413
</span><span class="lnt">1414
</span><span class="lnt">1415
</span><span class="lnt">1416
</span><span class="lnt">1417
</span><span class="lnt">1418
</span><span class="lnt">1419
</span><span class="lnt">1420
</span><span class="lnt">1421
</span><span class="lnt">1422
</span><span class="lnt">1423
</span><span class="lnt">1424
</span><span class="lnt">1425
</span><span class="lnt">1426
</span><span class="lnt">1427
</span><span class="lnt">1428
</span><span class="lnt">1429
</span><span class="lnt">1430
</span><span class="lnt">1431
</span><span class="lnt">1432
</span><span class="lnt">1433
</span><span class="lnt">1434
</span><span class="lnt">1435
</span><span class="lnt">1436
</span><span class="lnt">1437
</span><span class="lnt">1438
</span><span class="lnt">1439
</span><span class="lnt">1440
</span><span class="lnt">1441
</span><span class="lnt">1442
</span><span class="lnt">1443
</span><span class="lnt">1444
</span><span class="lnt">1445
</span><span class="lnt">1446
</span><span class="lnt">1447
</span><span class="lnt">1448
</span><span class="lnt">1449
</span><span class="lnt">1450
</span><span class="lnt">1451
</span><span class="lnt">1452
</span><span class="lnt">1453
</span><span class="lnt">1454
</span><span class="lnt">1455
</span><span class="lnt">1456
</span><span class="lnt">1457
</span><span class="lnt">1458
</span><span class="lnt">1459
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// The go:noinline is to guarantee the getcallerpc/getcallersp below are safe,
</span></span></span><span class="line"><span class="cl"><span class="c1">// so that we can set up g0.sched to return to the call of mstart1 above.
</span></span></span><span class="line"><span class="cl"><span class="c1">//go:noinline
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">mstart1</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">_g_</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">()</span>   <span class="c1">// _g_ = g0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 当前_g_ 一定是g0，因为该函数只有程序初始化或线程刚启动时才会调用。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nx">_g_</span> <span class="o">!=</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">g0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">throw</span><span class="p">(</span><span class="s">&#34;bad runtime·mstart&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// Set up m.g0.sched as a label returning to just
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// after the mstart1 call in mstart0 above, for use by goexit0 and mcall.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// We&#39;re never coming back to mstart1 after we call schedule,
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// so other calls can reuse the current frame.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// And goexit0 does a gogo that needs to return from mstart1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// and let mstart0 exit the thread.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 将 m.g0.sched 设置为上面 mstart0 中 mstart1 调用后返回的标签，供 goexit0 和 mcall 使用
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 在调用 schedule 之后，我们永远不会回到 mstart1，因此其他调用可以重用当前帧
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 而goexit0做了一个gogo，需要从mstart1返回，让mstart0退出线程
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    
</span></span><span class="line"><span class="cl">    <span class="c1">// g0.sched.g = g0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">_g_</span><span class="p">.</span><span class="nx">sched</span><span class="p">.</span><span class="nx">g</span> <span class="p">=</span> <span class="nf">guintptr</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">_g_</span><span class="p">))</span> <span class="c1">// 设置g0的调度信息是当前g
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// g0.sched.pc = getcallerpc()
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// getcallerpc()：调用者函数的下一条指令，也就是mstart0()函数调用mstart1()函数后的if判断指令代码处。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">_g_</span><span class="p">.</span><span class="nx">sched</span><span class="p">.</span><span class="nx">pc</span> <span class="p">=</span> <span class="nf">getcallerpc</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 这里是理解调度循环的关键，调度循环每次切换到g0栈都从这里(指定的固定位置)设置的位置开始使用栈。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// g0.sched.pc = getcallersp()
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// getcallersp()：调用者当前的SP寄存器值，也就是mstart0()函数调用mstart1()函数时SP寄存器的值。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 设置rsp寄存器值为master0调用master1时的栈顶处，设置在这里便于每次切换的g0栈都是从固定位置开始
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">_g_</span><span class="p">.</span><span class="nx">sched</span><span class="p">.</span><span class="nx">sp</span> <span class="p">=</span> <span class="nf">getcallersp</span><span class="p">()</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// go1.19.3/src/runtime/asm_amd64.s
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// TEXT runtime·asminit(SB),NOSPLIT,$0-0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//   // No per-thread init.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//   RET
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 没有什么可做的。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">asminit</span><span class="p">()</span>   <span class="c1">// 该函数的汇编代码什么都没做，初始化M工作线程
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">minit</span><span class="p">()</span>     <span class="c1">// 调用以初始化一个新的 m（包括引导程序 m），在新线程上调用，无法分配内存
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Install signal handlers; after minit so that minit can
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// prepare the thread to be able to handle the signals.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 安装信号处理程序； 在 minit 之后，以便 minit 可以准备线程以处理信号
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span> <span class="o">==</span> <span class="o">&amp;</span><span class="nx">m0</span> <span class="p">{</span>   <span class="c1">// 判断g0绑定的m是否是m0，m0是main.goroutine也就是主线程时执行下面方法
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nf">mstartm0</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 如果_g_.m.mstartfn存在则执行该函数：
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//  1. 一般的情况下该函数是，mspinning()函数。该函数只有一条指令，标记m的mspining字段为true。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//  2. 如果是sysmon线程下，这里是直接调用sysmon()函数，该函数是一个无限循环，这里不会返回。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nx">fn</span> <span class="o">:=</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">mstartfn</span><span class="p">;</span> <span class="nx">fn</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">fn</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 程序刚初始化时，一定是m0，因为在前面m0已经绑定了P，所以是m0需要跳过。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 通过wakeup()函数创建的新的工作线程m时，这里需要绑定个P。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="nx">m0</span> <span class="p">{</span> <span class="c1">// 不是m0则需要给工作线程M绑定一个P
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// _g_.m.nextp.ptr()获取下一个P，nextp在wakeup()函数相关被赋值。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nf">acquirep</span><span class="p">(</span><span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">nextp</span><span class="p">.</span><span class="nf">ptr</span><span class="p">())</span> <span class="c1">// 调用acquirep(_g_.m.nextp.ptr())绑定p
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">nextp</span> <span class="p">=</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 开启循环调度，该函数永远不返回
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">schedule</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div>

<p><details >
  <summary markdown="span">minit()</summary>
  <blockquote>
<ol>
<li>初始化一个新的<code>m</code>（包括引导程序<code>m</code>）。在新线程上调用，无法分配内存。</li>
<li>文件位置：<code>go1.19.3/src/runtime/os_linux.go</code>。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">390
</span><span class="lnt">391
</span><span class="lnt">392
</span><span class="lnt">393
</span><span class="lnt">394
</span><span class="lnt">395
</span><span class="lnt">396
</span><span class="lnt">397
</span><span class="lnt">398
</span><span class="lnt">399
</span><span class="lnt">400
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// Called to initialize a new m (including the bootstrap m).
</span></span></span><span class="line"><span class="cl"><span class="c1">// Called on the new thread, cannot allocate memory.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">minit</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 初始化 Signals
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">minitSignals</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// Cgo-created threads and the bootstrap m are missing a
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// procid. We need this for asynchronous preemption and it&#39;s
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// useful in debuggers.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">getg</span><span class="p">().</span><span class="nx">m</span><span class="p">.</span><span class="nx">procid</span> <span class="p">=</span> <span class="nb">uint64</span><span class="p">(</span><span class="nf">gettid</span><span class="p">())</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ol start="3">
<li>文件位置：<code>go1.19.3/src/runtime/signal_unix.go</code>。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1192
</span><span class="lnt">1193
</span><span class="lnt">1194
</span><span class="lnt">1195
</span><span class="lnt">1196
</span><span class="lnt">1197
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// minitSignals is called when initializing a new m to set the
</span></span></span><span class="line"><span class="cl"><span class="c1">// thread&#39;s alternate signal stack and signal mask.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">minitSignals</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nf">minitSignalStack</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="nf">minitSignalMask</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div></blockquote>

</details></p>



<p><details >
  <summary markdown="span">acquirep()</summary>
  <blockquote>
<ol>
<li>参数<code>_p_ *p</code>：空闲的<code>p</code>在<code>wakeup()</code>函数时存入<code>m.nextp</code>处，供工作线程启动后绑定这个<code>P</code>。</li>
<li>文件位置：<code>go1.19.3/src/runtime/proc.go</code>。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">4938
</span><span class="lnt">4939
</span><span class="lnt">4940
</span><span class="lnt">4941
</span><span class="lnt">4942
</span><span class="lnt">4943
</span><span class="lnt">4944
</span><span class="lnt">4945
</span><span class="lnt">4946
</span><span class="lnt">4947
</span><span class="lnt">4948
</span><span class="lnt">4949
</span><span class="lnt">4950
</span><span class="lnt">4951
</span><span class="lnt">4952
</span><span class="lnt">4953
</span><span class="lnt">4954
</span><span class="lnt">4955
</span><span class="lnt">4956
</span><span class="lnt">4957
</span><span class="lnt">4958
</span><span class="lnt">4959
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// Associate p and the current m.
</span></span></span><span class="line"><span class="cl"><span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1">// This function is allowed to have write barriers even if the caller
</span></span></span><span class="line"><span class="cl"><span class="c1">// isn&#39;t because it immediately acquires _p_.
</span></span></span><span class="line"><span class="cl"><span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1">//go:yeswritebarrierrec
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">acquirep</span><span class="p">(</span><span class="nx">_p_</span> <span class="o">*</span><span class="nx">p</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Do the part that isn&#39;t allowed to have write barriers.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">wirep</span><span class="p">(</span><span class="nx">_p_</span><span class="p">)</span>	<span class="c1">// 绑定P与当前工作线程M
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Have p; write barriers now allowed.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Perform deferred mcache flush before this P can allocate
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// from a potentially stale mcache.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 在此 P 可以从可能过时的 mcache 分配之前执行延迟 mcache 刷新
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">_p_</span><span class="p">.</span><span class="nx">mcache</span><span class="p">.</span><span class="nf">prepareForSweep</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">trace</span><span class="p">.</span><span class="nx">enabled</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">traceProcStart</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ol start="3">
<li>绑定传入的P在当前工作线程。<code>wirep</code>是<code>acquirep</code>的第一步，实际上是将当前的<code>M</code>关联到<code>_p_</code>。</li>
<li>这是被打破的，所以我们可以禁止这部分的写屏障，因为我们还没有<code>P</code>。</li>
<li>文件位置：<code>go1.19.3/src/runtime/proc.go</code>。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">4959
</span><span class="lnt">4960
</span><span class="lnt">4961
</span><span class="lnt">4962
</span><span class="lnt">4963
</span><span class="lnt">4964
</span><span class="lnt">4965
</span><span class="lnt">4966
</span><span class="lnt">4967
</span><span class="lnt">4968
</span><span class="lnt">4969
</span><span class="lnt">4970
</span><span class="lnt">4971
</span><span class="lnt">4972
</span><span class="lnt">4973
</span><span class="lnt">4974
</span><span class="lnt">4975
</span><span class="lnt">4976
</span><span class="lnt">4977
</span><span class="lnt">4978
</span><span class="lnt">4979
</span><span class="lnt">4980
</span><span class="lnt">4981
</span><span class="lnt">4982
</span><span class="lnt">4983
</span><span class="lnt">4984
</span><span class="lnt">4985
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// wirep is the first step of acquirep, which actually associates the
</span></span></span><span class="line"><span class="cl"><span class="c1">// current M to _p_. This is broken out so we can disallow write
</span></span></span><span class="line"><span class="cl"><span class="c1">// barriers for this part, since we don&#39;t yet have a P.
</span></span></span><span class="line"><span class="cl"><span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1">//go:nowritebarrierrec
</span></span></span><span class="line"><span class="cl"><span class="c1">//go:nosplit
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">wirep</span><span class="p">(</span><span class="nx">_p_</span> <span class="o">*</span><span class="nx">p</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">_g_</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">()</span>     <span class="c1">// 获取当前的g
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">p</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span> <span class="c1">// 当前工作线程如果绑定了P则有问题
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nf">throw</span><span class="p">(</span><span class="s">&#34;wirep: already in go&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 当前P绑定了工作线程存在问题，该P不是空闲的 或 当前P不处于空闲状态
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nx">_p_</span><span class="p">.</span><span class="nx">m</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">||</span> <span class="nx">_p_</span><span class="p">.</span><span class="nx">status</span> <span class="o">!=</span> <span class="nx">_Pidle</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">id</span> <span class="o">:=</span> <span class="nb">int64</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="nx">_p_</span><span class="p">.</span><span class="nx">m</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nx">id</span> <span class="p">=</span> <span class="nx">_p_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nf">ptr</span><span class="p">().</span><span class="nx">id</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="nb">print</span><span class="p">(</span><span class="s">&#34;wirep: p-&gt;m=&#34;</span><span class="p">,</span> <span class="nx">_p_</span><span class="p">.</span><span class="nx">m</span><span class="p">,</span> <span class="s">&#34;(&#34;</span><span class="p">,</span> <span class="nx">id</span><span class="p">,</span> <span class="s">&#34;) p-&gt;status=&#34;</span><span class="p">,</span> <span class="nx">_p_</span><span class="p">.</span><span class="nx">status</span><span class="p">,</span> <span class="s">&#34;\n&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="nf">throw</span><span class="p">(</span><span class="s">&#34;wirep: invalid p state&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 当前工作线程M绑定P
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">p</span><span class="p">.</span><span class="nf">set</span><span class="p">(</span><span class="nx">_p_</span><span class="p">)</span>  <span class="c1">// m.p = _p_		
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 当前P绑定工作线程M
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">_p_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nf">set</span><span class="p">(</span><span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">)</span>  <span class="c1">// _p_.m = m  
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">_p_</span><span class="p">.</span><span class="nx">status</span> <span class="p">=</span> <span class="nx">_Prunning</span>    <span class="c1">// 把当前P状态修改为_Prunning
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div></blockquote>

</details></p>

<h2 id="schedule">schedule()<a hidden class="anchor" aria-hidden="true" href="#schedule">#</a></h2>
<ol>
<li>循环调度开始。每轮循环都从这里开始。该函数算是调度器的<strong>核心函数</strong>，运行起来的线程会一直执行它。</li>
<li>一轮调度器：找到一个可运行的<code>goroutine</code>并执行它。永不返回。</li>
<li>文件位置：<code>go1.19.3/src/runtime/proc.go</code>。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">3183
</span><span class="lnt">3184
</span><span class="lnt">3185
</span><span class="lnt">3186
</span><span class="lnt">3187
</span><span class="lnt">3188
</span><span class="lnt">3189
</span><span class="lnt">3190
</span><span class="lnt">3191
</span><span class="lnt">3192
</span><span class="lnt">3193
</span><span class="lnt">3194
</span><span class="lnt">3195
</span><span class="lnt">3196
</span><span class="lnt">3197
</span><span class="lnt">3198
</span><span class="lnt">3199
</span><span class="lnt">3200
</span><span class="lnt">3201
</span><span class="lnt">3202
</span><span class="lnt">3203
</span><span class="lnt">3204
</span><span class="lnt">3205
</span><span class="lnt">3206
</span><span class="lnt">3207
</span><span class="lnt">3208
</span><span class="lnt">3209
</span><span class="lnt">3210
</span><span class="lnt">3211
</span><span class="lnt">3212
</span><span class="lnt">3213
</span><span class="lnt">3214
</span><span class="lnt">3215
</span><span class="lnt">3216
</span><span class="lnt">3217
</span><span class="lnt">3218
</span><span class="lnt">3219
</span><span class="lnt">3220
</span><span class="lnt">3221
</span><span class="lnt">3222
</span><span class="lnt">3223
</span><span class="lnt">3224
</span><span class="lnt">3225
</span><span class="lnt">3226
</span><span class="lnt">3227
</span><span class="lnt">3228
</span><span class="lnt">3229
</span><span class="lnt">3230
</span><span class="lnt">3231
</span><span class="lnt">3232
</span><span class="lnt">3233
</span><span class="lnt">3234
</span><span class="lnt">3235
</span><span class="lnt">3236
</span><span class="lnt">3237
</span><span class="lnt">3238
</span><span class="lnt">3239
</span><span class="lnt">3240
</span><span class="lnt">3241
</span><span class="lnt">3242
</span><span class="lnt">3243
</span><span class="lnt">3244
</span><span class="lnt">3245
</span><span class="lnt">3246
</span><span class="lnt">3247
</span><span class="lnt">3248
</span><span class="lnt">3249
</span><span class="lnt">3250
</span><span class="lnt">3251
</span><span class="lnt">3252
</span><span class="lnt">3253
</span><span class="lnt">3254
</span><span class="lnt">3255
</span><span class="lnt">3256
</span><span class="lnt">3257
</span><span class="lnt">3258
</span><span class="lnt">3259
</span><span class="lnt">3260
</span><span class="lnt">3261
</span><span class="lnt">3262
</span><span class="lnt">3263
</span><span class="lnt">3264
</span><span class="lnt">3265
</span><span class="lnt">3266
</span><span class="lnt">3267
</span><span class="lnt">3268
</span><span class="lnt">3269
</span><span class="lnt">3270
</span><span class="lnt">3271
</span><span class="lnt">3272
</span><span class="lnt">3273
</span><span class="lnt">3274
</span><span class="lnt">3275
</span><span class="lnt">3276
</span><span class="lnt">3277
</span><span class="lnt">3278
</span><span class="lnt">3279
</span><span class="lnt">3280
</span><span class="lnt">3281
</span><span class="lnt">3282
</span><span class="lnt">3283
</span><span class="lnt">3284
</span><span class="lnt">3285
</span><span class="lnt">3286
</span><span class="lnt">3287
</span><span class="lnt">3288
</span><span class="lnt">3289
</span><span class="lnt">3290
</span><span class="lnt">3291
</span><span class="lnt">3292
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// One round of scheduler: find a runnable goroutine and execute it.
</span></span></span><span class="line"><span class="cl"><span class="c1">// Never returns.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">schedule</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 获取当前正在运行的g，执行该函数时一般都是系统栈g0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">_g_</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">()</span> <span class="c1">// _g_ = g0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 调度开始时 g0.m.locks = 0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 校验当前线程没有锁，不允许再持有锁的情况下进行调度，以免造成runtime内部错误
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 因为m.locks的加锁和解锁时成对出现的，因此这里应该为0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">locks</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">throw</span><span class="p">(</span><span class="s">&#34;schedule: holding locks&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// g0.m.lockedg = 0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 判断当前M有没有和G绑定，如果有，这个M就不能用来执行其他的G了,
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 只能挂起等待绑定的G得到调度。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">lockedg</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">stoplockedm</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">        <span class="nf">execute</span><span class="p">(</span><span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">lockedg</span><span class="p">.</span><span class="nf">ptr</span><span class="p">(),</span> <span class="kc">false</span><span class="p">)</span> <span class="c1">// Never returns.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// We should not schedule away from a g that is executing a cgo call,
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// since the cgo call is using the m&#39;s g0 stack.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 我们不应该安排远离正在执行 cgo 调用的 g，因为 cgo 调用正在使用 m 的 g0 堆栈
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 判断线程是不是正在进行cgo函数调用，这种情况下g0栈正在被cgo使用，所以也不允许调度。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">incgo</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">throw</span><span class="p">(</span><span class="s">&#34;schedule: in cgo&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">top</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="nx">pp</span> <span class="o">:=</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">p</span><span class="p">.</span><span class="nf">ptr</span><span class="p">()</span> <span class="c1">// pp = p
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 通过把preempt字段设置为false，来禁止对P的抢占。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">pp</span><span class="p">.</span><span class="nx">preempt</span> <span class="p">=</span> <span class="kc">false</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// Safety check: if we are spinning, the run queue should be empty.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// Check this before calling checkTimers, as that might call
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// goready to put a ready goroutine on the local run queue.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 安全检查：如果我们正在自旋，那么运行队列应该是空的。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 在调用checkTimers之前请检查这一点，因为这可能会调用goready将准备好的goroutine放入本地运行队列。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 对 spinning 的判断属于一致性检验，在P本地runq有任务的情况下，M不应该处于spinning状态。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">spinning</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="nx">pp</span><span class="p">.</span><span class="nx">runnext</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">||</span> <span class="nx">pp</span><span class="p">.</span><span class="nx">runqhead</span> <span class="o">!=</span> <span class="nx">pp</span><span class="p">.</span><span class="nx">runqtail</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">throw</span><span class="p">(</span><span class="s">&#34;schedule: spinning with local work&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 寻找一个可用的 goroutine
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// inheritTime：是否继承当前时间片
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//  1. true  继承当前时间片
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//  2. false 不继承当前时间片
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// tryWakeP：当前goroutine是否是普通的。也就是user goroutine。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//  1. false 普通的goroutine。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//  2. true  不是普通的goroutine，可能是GC work、trace reader需要唤醒P。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// gp：当前找到的 goroutine。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">gp</span><span class="p">,</span> <span class="nx">inheritTime</span><span class="p">,</span> <span class="nx">tryWakeP</span> <span class="o">:=</span> <span class="nf">findRunnable</span><span class="p">()</span> <span class="c1">// blocks until work is available
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="c1">// This thread is going to run a goroutine and is not spinning anymore,
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// so if it was marked as spinning we need to reset it now and potentially
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// start a new spinning M.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 这个线程将运行一个goroutine，不再旋转，所以如果它被标记为旋转，
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 我们现在需要重置它，并可能启动一个新的旋转M。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">spinning</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 重置当前M位非旋转，并尝试重新启动一个P标记为旋转。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nf">resetspinning</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// sched.disable.user：禁止调度用户goroutine。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// !schedEnabled(gp)：gp是user goroutine。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 可能来自GC，其中两种模式不允许GC期间运行user goroutine
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nx">sched</span><span class="p">.</span><span class="nx">disable</span><span class="p">.</span><span class="nx">user</span> <span class="o">&amp;&amp;</span> <span class="p">!</span><span class="nf">schedEnabled</span><span class="p">(</span><span class="nx">gp</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// Scheduling of this goroutine is disabled. Put it on
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// the list of pending runnable goroutines for when we
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// re-enable user scheduling and look again.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 此goroutine的调度被禁用。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 当我们重新启用用户调度并再次查看时，将它放在挂起的可运行goroutine列表中。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="nf">schedEnabled</span><span class="p">(</span><span class="nx">gp</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// Something re-enabled scheduling while we
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// were acquiring the lock.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// user goroutine 时挂起
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="nx">sched</span><span class="p">.</span><span class="nx">disable</span><span class="p">.</span><span class="nx">runnable</span><span class="p">.</span><span class="nf">pushBack</span><span class="p">(</span><span class="nx">gp</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="nx">sched</span><span class="p">.</span><span class="nx">disable</span><span class="p">.</span><span class="nx">n</span><span class="o">++</span>
</span></span><span class="line"><span class="cl">            <span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="k">goto</span> <span class="nx">top</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// If about to schedule a not-normal goroutine (a GCworker or tracereader),
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// wake a P if there is one.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 如果要调度一个不正常的goroutine (GCworker或tracereader)，如果有P，则唤醒P。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 尝试换新一个新线程绑定P来工作。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nx">tryWakeP</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">wakep</span><span class="p">()</span> 
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">lockedm</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// Hands off own p to the locked m,
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// then blocks waiting for a new p.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 把自己的p交给锁住的m，然后block等待一个新的p。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nf">startlockedm</span><span class="p">(</span><span class="nx">gp</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">goto</span> <span class="nx">top</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nf">execute</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="nx">inheritTime</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="findrunnable">findRunnable()🚀<a hidden class="anchor" aria-hidden="true" href="#findrunnable">#</a></h3>
<ol>
<li>查找要执行的可运行<code>goroutine</code>。试图从其他<code>P</code>中窃取，从本地或全局队列、轮询网络中获取g。</li>
<li><code>tryWakeP</code>表示返回的不是普通的<code>goroutine</code>（<code>GC</code>工作程序、跟踪读取器），因此调用者应该尝试唤醒<code>P</code>。</li>
<li>文件位置：<code>go1.19.3/src/runtime/proc.go</code>。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">2651
</span><span class="lnt">2652
</span><span class="lnt">2653
</span><span class="lnt">2654
</span><span class="lnt">2655
</span><span class="lnt">2656
</span><span class="lnt">2657
</span><span class="lnt">2658
</span><span class="lnt">2659
</span><span class="lnt">2660
</span><span class="lnt">2661
</span><span class="lnt">2662
</span><span class="lnt">2663
</span><span class="lnt">2664
</span><span class="lnt">2665
</span><span class="lnt">2666
</span><span class="lnt">2667
</span><span class="lnt">2668
</span><span class="lnt">2669
</span><span class="lnt">2670
</span><span class="lnt">2671
</span><span class="lnt">2672
</span><span class="lnt">2673
</span><span class="lnt">2674
</span><span class="lnt">2675
</span><span class="lnt">2676
</span><span class="lnt">2677
</span><span class="lnt">2678
</span><span class="lnt">2679
</span><span class="lnt">2680
</span><span class="lnt">2681
</span><span class="lnt">2682
</span><span class="lnt">2683
</span><span class="lnt">2684
</span><span class="lnt">2685
</span><span class="lnt">2686
</span><span class="lnt">2687
</span><span class="lnt">2688
</span><span class="lnt">2689
</span><span class="lnt">2690
</span><span class="lnt">2691
</span><span class="lnt">2692
</span><span class="lnt">2693
</span><span class="lnt">2694
</span><span class="lnt">2695
</span><span class="lnt">2696
</span><span class="lnt">2697
</span><span class="lnt">2698
</span><span class="lnt">2699
</span><span class="lnt">2700
</span><span class="lnt">2701
</span><span class="lnt">2702
</span><span class="lnt">2703
</span><span class="lnt">2704
</span><span class="lnt">2705
</span><span class="lnt">2706
</span><span class="lnt">2707
</span><span class="lnt">2708
</span><span class="lnt">2709
</span><span class="lnt">2710
</span><span class="lnt">2711
</span><span class="lnt">2712
</span><span class="lnt">2713
</span><span class="lnt">2714
</span><span class="lnt">2715
</span><span class="lnt">2716
</span><span class="lnt">2717
</span><span class="lnt">2718
</span><span class="lnt">2719
</span><span class="lnt">2720
</span><span class="lnt">2721
</span><span class="lnt">2722
</span><span class="lnt">2723
</span><span class="lnt">2724
</span><span class="lnt">2725
</span><span class="lnt">2726
</span><span class="lnt">2727
</span><span class="lnt">2728
</span><span class="lnt">2729
</span><span class="lnt">2730
</span><span class="lnt">2731
</span><span class="lnt">2732
</span><span class="lnt">2733
</span><span class="lnt">2734
</span><span class="lnt">2735
</span><span class="lnt">2736
</span><span class="lnt">2737
</span><span class="lnt">2738
</span><span class="lnt">2739
</span><span class="lnt">2740
</span><span class="lnt">2741
</span><span class="lnt">2742
</span><span class="lnt">2743
</span><span class="lnt">2744
</span><span class="lnt">2745
</span><span class="lnt">2746
</span><span class="lnt">2747
</span><span class="lnt">2748
</span><span class="lnt">2749
</span><span class="lnt">2750
</span><span class="lnt">2751
</span><span class="lnt">2752
</span><span class="lnt">2753
</span><span class="lnt">2754
</span><span class="lnt">2755
</span><span class="lnt">2756
</span><span class="lnt">2757
</span><span class="lnt">2758
</span><span class="lnt">2759
</span><span class="lnt">2760
</span><span class="lnt">2761
</span><span class="lnt">2762
</span><span class="lnt">2763
</span><span class="lnt">2764
</span><span class="lnt">2765
</span><span class="lnt">2766
</span><span class="lnt">2767
</span><span class="lnt">2768
</span><span class="lnt">2769
</span><span class="lnt">2770
</span><span class="lnt">2771
</span><span class="lnt">2772
</span><span class="lnt">2773
</span><span class="lnt">2774
</span><span class="lnt">2775
</span><span class="lnt">2776
</span><span class="lnt">2777
</span><span class="lnt">2778
</span><span class="lnt">2779
</span><span class="lnt">2780
</span><span class="lnt">2781
</span><span class="lnt">2782
</span><span class="lnt">2783
</span><span class="lnt">2784
</span><span class="lnt">2785
</span><span class="lnt">2786
</span><span class="lnt">2787
</span><span class="lnt">2788
</span><span class="lnt">2789
</span><span class="lnt">2790
</span><span class="lnt">2791
</span><span class="lnt">2792
</span><span class="lnt">2793
</span><span class="lnt">2794
</span><span class="lnt">2795
</span><span class="lnt">2796
</span><span class="lnt">2797
</span><span class="lnt">2798
</span><span class="lnt">2799
</span><span class="lnt">2800
</span><span class="lnt">2801
</span><span class="lnt">2802
</span><span class="lnt">2803
</span><span class="lnt">2804
</span><span class="lnt">2805
</span><span class="lnt">2806
</span><span class="lnt">2807
</span><span class="lnt">2808
</span><span class="lnt">2809
</span><span class="lnt">2810
</span><span class="lnt">2811
</span><span class="lnt">2812
</span><span class="lnt">2813
</span><span class="lnt">2814
</span><span class="lnt">2815
</span><span class="lnt">2816
</span><span class="lnt">2817
</span><span class="lnt">2818
</span><span class="lnt">2819
</span><span class="lnt">2820
</span><span class="lnt">2821
</span><span class="lnt">2822
</span><span class="lnt">2823
</span><span class="lnt">2824
</span><span class="lnt">2825
</span><span class="lnt">2826
</span><span class="lnt">2827
</span><span class="lnt">2828
</span><span class="lnt">2829
</span><span class="lnt">2830
</span><span class="lnt">2831
</span><span class="lnt">2832
</span><span class="lnt">2833
</span><span class="lnt">2834
</span><span class="lnt">2835
</span><span class="lnt">2836
</span><span class="lnt">2837
</span><span class="lnt">2838
</span><span class="lnt">2839
</span><span class="lnt">2840
</span><span class="lnt">2841
</span><span class="lnt">2842
</span><span class="lnt">2843
</span><span class="lnt">2844
</span><span class="lnt">2845
</span><span class="lnt">2846
</span><span class="lnt">2847
</span><span class="lnt">2848
</span><span class="lnt">2849
</span><span class="lnt">2850
</span><span class="lnt">2851
</span><span class="lnt">2852
</span><span class="lnt">2853
</span><span class="lnt">2854
</span><span class="lnt">2855
</span><span class="lnt">2856
</span><span class="lnt">2857
</span><span class="lnt">2858
</span><span class="lnt">2859
</span><span class="lnt">2860
</span><span class="lnt">2861
</span><span class="lnt">2862
</span><span class="lnt">2863
</span><span class="lnt">2864
</span><span class="lnt">2865
</span><span class="lnt">2866
</span><span class="lnt">2867
</span><span class="lnt">2868
</span><span class="lnt">2869
</span><span class="lnt">2870
</span><span class="lnt">2871
</span><span class="lnt">2872
</span><span class="lnt">2873
</span><span class="lnt">2874
</span><span class="lnt">2875
</span><span class="lnt">2876
</span><span class="lnt">2877
</span><span class="lnt">2878
</span><span class="lnt">2879
</span><span class="lnt">2880
</span><span class="lnt">2881
</span><span class="lnt">2882
</span><span class="lnt">2883
</span><span class="lnt">2884
</span><span class="lnt">2885
</span><span class="lnt">2886
</span><span class="lnt">2887
</span><span class="lnt">2888
</span><span class="lnt">2889
</span><span class="lnt">2890
</span><span class="lnt">2891
</span><span class="lnt">2892
</span><span class="lnt">2893
</span><span class="lnt">2894
</span><span class="lnt">2895
</span><span class="lnt">2896
</span><span class="lnt">2897
</span><span class="lnt">2898
</span><span class="lnt">2899
</span><span class="lnt">2900
</span><span class="lnt">2901
</span><span class="lnt">2902
</span><span class="lnt">2903
</span><span class="lnt">2904
</span><span class="lnt">2905
</span><span class="lnt">2906
</span><span class="lnt">2907
</span><span class="lnt">2908
</span><span class="lnt">2909
</span><span class="lnt">2910
</span><span class="lnt">2911
</span><span class="lnt">2912
</span><span class="lnt">2913
</span><span class="lnt">2914
</span><span class="lnt">2915
</span><span class="lnt">2916
</span><span class="lnt">2917
</span><span class="lnt">2918
</span><span class="lnt">2919
</span><span class="lnt">2920
</span><span class="lnt">2921
</span><span class="lnt">2922
</span><span class="lnt">2923
</span><span class="lnt">2924
</span><span class="lnt">2925
</span><span class="lnt">2926
</span><span class="lnt">2927
</span><span class="lnt">2928
</span><span class="lnt">2929
</span><span class="lnt">2930
</span><span class="lnt">2931
</span><span class="lnt">2932
</span><span class="lnt">2933
</span><span class="lnt">2934
</span><span class="lnt">2935
</span><span class="lnt">2936
</span><span class="lnt">2937
</span><span class="lnt">2938
</span><span class="lnt">2939
</span><span class="lnt">2940
</span><span class="lnt">2941
</span><span class="lnt">2942
</span><span class="lnt">2943
</span><span class="lnt">2944
</span><span class="lnt">2945
</span><span class="lnt">2946
</span><span class="lnt">2947
</span><span class="lnt">2948
</span><span class="lnt">2949
</span><span class="lnt">2950
</span><span class="lnt">2951
</span><span class="lnt">2952
</span><span class="lnt">2953
</span><span class="lnt">2954
</span><span class="lnt">2955
</span><span class="lnt">2956
</span><span class="lnt">2957
</span><span class="lnt">2958
</span><span class="lnt">2959
</span><span class="lnt">2960
</span><span class="lnt">2961
</span><span class="lnt">2962
</span><span class="lnt">2963
</span><span class="lnt">2964
</span><span class="lnt">2965
</span><span class="lnt">2966
</span><span class="lnt">2967
</span><span class="lnt">2968
</span><span class="lnt">2969
</span><span class="lnt">2970
</span><span class="lnt">2971
</span><span class="lnt">2972
</span><span class="lnt">2973
</span><span class="lnt">2974
</span><span class="lnt">2975
</span><span class="lnt">2976
</span><span class="lnt">2977
</span><span class="lnt">2978
</span><span class="lnt">2979
</span><span class="lnt">2980
</span><span class="lnt">2981
</span><span class="lnt">2982
</span><span class="lnt">2983
</span><span class="lnt">2984
</span><span class="lnt">2985
</span><span class="lnt">2986
</span><span class="lnt">2987
</span><span class="lnt">2988
</span><span class="lnt">2989
</span><span class="lnt">2990
</span><span class="lnt">2991
</span><span class="lnt">2992
</span><span class="lnt">2993
</span><span class="lnt">2994
</span><span class="lnt">2995
</span><span class="lnt">2996
</span><span class="lnt">2997
</span><span class="lnt">2998
</span><span class="lnt">2999
</span><span class="lnt">3000
</span><span class="lnt">3001
</span><span class="lnt">3002
</span><span class="lnt">3003
</span><span class="lnt">3004
</span><span class="lnt">3005
</span><span class="lnt">3006
</span><span class="lnt">3007
</span><span class="lnt">3008
</span><span class="lnt">3009
</span><span class="lnt">3010
</span><span class="lnt">3011
</span><span class="lnt">3012
</span><span class="lnt">3013
</span><span class="lnt">3014
</span><span class="lnt">3015
</span><span class="lnt">3016
</span><span class="lnt">3017
</span><span class="lnt">3018
</span><span class="lnt">3019
</span><span class="lnt">3020
</span><span class="lnt">3021
</span><span class="lnt">3022
</span><span class="lnt">3023
</span><span class="lnt">3024
</span><span class="lnt">3025
</span><span class="lnt">3026
</span><span class="lnt">3027
</span><span class="lnt">3028
</span><span class="lnt">3029
</span><span class="lnt">3030
</span><span class="lnt">3031
</span><span class="lnt">3032
</span><span class="lnt">3033
</span><span class="lnt">3034
</span><span class="lnt">3035
</span><span class="lnt">3036
</span><span class="lnt">3037
</span><span class="lnt">3038
</span><span class="lnt">3039
</span><span class="lnt">3040
</span><span class="lnt">3041
</span><span class="lnt">3042
</span><span class="lnt">3043
</span><span class="lnt">3044
</span><span class="lnt">3045
</span><span class="lnt">3046
</span><span class="lnt">3047
</span><span class="lnt">3048
</span><span class="lnt">3049
</span><span class="lnt">3050
</span><span class="lnt">3051
</span><span class="lnt">3052
</span><span class="lnt">3053
</span><span class="lnt">3054
</span><span class="lnt">3055
</span><span class="lnt">3056
</span><span class="lnt">3057
</span><span class="lnt">3058
</span><span class="lnt">3059
</span><span class="lnt">3060
</span><span class="lnt">3061
</span><span class="lnt">3062
</span><span class="lnt">3063
</span><span class="lnt">3064
</span><span class="lnt">3065
</span><span class="lnt">3066
</span><span class="lnt">3067
</span><span class="lnt">3068
</span><span class="lnt">3069
</span><span class="lnt">3070
</span><span class="lnt">3071
</span><span class="lnt">3072
</span><span class="lnt">3073
</span><span class="lnt">3074
</span><span class="lnt">3075
</span><span class="lnt">3076
</span><span class="lnt">3077
</span><span class="lnt">3078
</span><span class="lnt">3079
</span><span class="lnt">3080
</span><span class="lnt">3081
</span><span class="lnt">3082
</span><span class="lnt">3083
</span><span class="lnt">3084
</span><span class="lnt">3085
</span><span class="lnt">3086
</span><span class="lnt">3087
</span><span class="lnt">3088
</span><span class="lnt">3089
</span><span class="lnt">3090
</span><span class="lnt">3091
</span><span class="lnt">3092
</span><span class="lnt">3093
</span><span class="lnt">3094
</span><span class="lnt">3095
</span><span class="lnt">3096
</span><span class="lnt">3097
</span><span class="lnt">3098
</span><span class="lnt">3099
</span><span class="lnt">3100
</span><span class="lnt">3101
</span><span class="lnt">3102
</span><span class="lnt">3103
</span><span class="lnt">3104
</span><span class="lnt">3105
</span><span class="lnt">3106
</span><span class="lnt">3107
</span><span class="lnt">3108
</span><span class="lnt">3109
</span><span class="lnt">3110
</span><span class="lnt">3111
</span><span class="lnt">3112
</span><span class="lnt">3113
</span><span class="lnt">3114
</span><span class="lnt">3115
</span><span class="lnt">3116
</span><span class="lnt">3117
</span><span class="lnt">3118
</span><span class="lnt">3119
</span><span class="lnt">3120
</span><span class="lnt">3121
</span><span class="lnt">3122
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// Finds a runnable goroutine to execute.
</span></span></span><span class="line"><span class="cl"><span class="c1">// Tries to steal from other P&#39;s, get g from local or global queue, poll network.
</span></span></span><span class="line"><span class="cl"><span class="c1">// tryWakeP indicates that the returned goroutine is not normal (GC worker, trace
</span></span></span><span class="line"><span class="cl"><span class="c1">// reader) so the caller should try to wake a P.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">findRunnable</span><span class="p">()</span> <span class="p">(</span><span class="nx">gp</span> <span class="o">*</span><span class="nx">g</span><span class="p">,</span> <span class="nx">inheritTime</span><span class="p">,</span> <span class="nx">tryWakeP</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">_g_</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">()</span> <span class="c1">// _g_ = g0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="c1">// The conditions here and in handoffp must agree: if
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// findrunnable would return a G to run, handoffp must start
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// an M.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 这里和handoffp中的条件必须一致：如果findrunnable将返回一个G来运行，则handoffp必须启动一个M。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="nx">top</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="nx">_p_</span> <span class="o">:=</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">p</span><span class="p">.</span><span class="nf">ptr</span><span class="p">()</span> <span class="c1">// _p_ = p
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    
</span></span><span class="line"><span class="cl">    <span class="c1">// 1) 帮助STW，抢占当前P。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    
</span></span><span class="line"><span class="cl">    <span class="c1">// STW 即将开始要求等待，挂起当前M。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 检测sched.gcwaiting，挂起自己，以便及时响应STW，
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 调度逻辑中很多地方都有对gcwaiting的检测。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nx">sched</span><span class="p">.</span><span class="nx">gcwaiting</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span> <span class="c1">// 在GC的STW期间被设置
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nf">gcstopm</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">        <span class="k">goto</span> <span class="nx">top</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c1">// 2) 检查当前P是否到达安全点。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    
</span></span><span class="line"><span class="cl">    <span class="c1">// 如果当前P要求运行 runSafePointFn() 函数。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// runSafePointFn() 函数被GC用来在安全点执行清空工作队列之类的操作。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nx">_p_</span><span class="p">.</span><span class="nx">runSafePointFn</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">runSafePointFn</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 3) 去 timers 里看看，是否有到点的定时器。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 这里如果有 timer 到触发点了，会触发并执行注册函数。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 由于调度循环是以时间片形式调度的，因此 timer 的触发时间上线就是10ms。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 因此抢占能抢占超过10ms以上的goroutine?
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    
</span></span><span class="line"><span class="cl">    <span class="c1">// checkTimers 为准备好的 P 运行任何timers
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 如果 now 不为 0，则为当前时间，如果 now 被传递为 0，则返回传递的时间或当前时间
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 以及下一个timer应该运行的时间，如果没有下一个计时器，则为 0，并报告它是否运行了任何计时器
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 如果下一个timer应该运行的时间不为0，它总是大于返回的时间
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// func checkTimers(pp *p, now int64) (rnow, pollUntil int64, ran bool)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//  参数：
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//    1. pp *p      当前需要检查的P
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//    2. now int64  当前时间，如果为0则取当前时间
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//  返回值：
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//    1. rnow int64：参数now的时间。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//    2. pollUntil int64：&gt;0.最近timer触发的时间点。0.没有任何timer。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//    3. ran bool   timer里面是否存在已经延迟时间到点的g，true存在，false不存在
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    
</span></span><span class="line"><span class="cl">    <span class="c1">// now and pollUntil are saved for work stealing later,
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// which may steal timers. It&#39;s important that between now
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// and then, nothing blocks, so these numbers remain mostly
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// relevant.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// now和pollUntil被保存以备以后窃取工作，这可能会窃取timers。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 重要的是，从现在到那时，没有任何阻碍，所以这些数字仍然很重要。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 处理当前P相关的timers，可能存在一些在timer中的g到时间点了需要放回P中等待被执行
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">now</span><span class="p">,</span> <span class="nx">pollUntil</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nf">checkTimers</span><span class="p">(</span><span class="nx">_p_</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 4) 尝试安排 trace reader。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    
</span></span><span class="line"><span class="cl">    <span class="c1">// Try to schedule the trace reader.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 尝试安排 trace reader。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nx">trace</span><span class="p">.</span><span class="nx">enabled</span> <span class="o">||</span> <span class="nx">trace</span><span class="p">.</span><span class="nx">shutdown</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">gp</span> <span class="p">=</span> <span class="nf">traceReader</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="nx">gp</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nf">casgstatus</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="nx">_Gwaiting</span><span class="p">,</span> <span class="nx">_Grunnable</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="nf">traceGoUnpark</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="nx">gp</span><span class="p">,</span> <span class="kc">false</span><span class="p">,</span> <span class="kc">true</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 5) 写标记期间，尝试安排 GC worker。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    
</span></span><span class="line"><span class="cl">    <span class="c1">// Try to schedule a GC worker.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 尝试安排 GC worker。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nx">gcBlackenEnabled</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span> <span class="c1">// 在GC【并发标记】期间被设置
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 唤醒标记协程，参看GC文档
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">gp</span><span class="p">,</span> <span class="nx">now</span> <span class="p">=</span> <span class="nx">gcController</span><span class="p">.</span><span class="nf">findRunnableGCWorker</span><span class="p">(</span><span class="nx">_p_</span><span class="p">,</span> <span class="nx">now</span><span class="p">)</span> <span class="c1">// 获取到标记协程
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="nx">gp</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="nx">gp</span><span class="p">,</span> <span class="kc">false</span><span class="p">,</span> <span class="kc">true</span> <span class="c1">// 返回标记协程
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 6) P调度次数每满61次需要去全局队列拿去goroutine，防止全局goroutine一直得不到运行。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    
</span></span><span class="line"><span class="cl">    <span class="c1">// Check the global runnable queue once in a while to ensure fairness.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// Otherwise two goroutines can completely occupy the local runqueue
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// by constantly respawning each other.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 偶尔检查一次全局可运行队列以确保公平性。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 否则，两个goroutine可以通过不断地相互重新部署来完全占据本地运行队列。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 为了保证调度的公平性，每个工作线程每进行61次调度就需要优先从全局运行队列中获取goroutine出来运行。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 因为如果只调度本地运行队列中的goroutine，则全局运行队列中的goroutine有可能得不到运行。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// p.schedtick：记录调度发生的次数，实际上在每发生一次goroutine切换且不继承时间片的情况下，该字段会加一。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// sched.runqsize：记录的是全局就绪队列的长度。也就是全局队列goroutine的个数。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nx">_p_</span><span class="p">.</span><span class="nx">schedtick</span><span class="o">%</span><span class="mi">61</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">sched</span><span class="p">.</span><span class="nx">runqsize</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>        <span class="c1">// 从sched中获取goroutine需要持有lock锁。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 从全局队列中获取1个goroutine，然后放入P的本地队列。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">gp</span> <span class="p">=</span> <span class="nf">globrunqget</span><span class="p">(</span><span class="nx">_p_</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="c1">// 只拿取一个
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>      <span class="c1">// mutex 解锁
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="nx">gp</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="nx">gp</span><span class="p">,</span> <span class="kc">false</span><span class="p">,</span> <span class="kc">false</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 7) 是否有 finalizer G。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    
</span></span><span class="line"><span class="cl">    <span class="c1">// Wake up the finalizer G.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 唤醒 finalizer G。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 该goroutine由runtime.SetFinalizer函数创造。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 只会创建一个goroutine。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nx">fingwait</span> <span class="o">&amp;&amp;</span> <span class="nx">fingwake</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="nx">gp</span> <span class="o">:=</span> <span class="nf">wakefing</span><span class="p">();</span> <span class="nx">gp</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nf">ready</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="kc">true</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="o">*</span><span class="nx">cgo_yield</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">asmcgocall</span><span class="p">(</span><span class="o">*</span><span class="nx">cgo_yield</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 8) 从P的本地队列拿去 goroutine。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    
</span></span><span class="line"><span class="cl">    <span class="c1">// local runq
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 从本地P的队列中获取goroutine。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nx">gp</span><span class="p">,</span> <span class="nx">inheritTime</span> <span class="o">:=</span> <span class="nf">runqget</span><span class="p">(</span><span class="nx">_p_</span><span class="p">);</span> <span class="nx">gp</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="nx">gp</span><span class="p">,</span> <span class="nx">inheritTime</span><span class="p">,</span> <span class="kc">false</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 9) 从全局队列中拿去goroutine。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    
</span></span><span class="line"><span class="cl">    <span class="c1">// global runq
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 从全局队列中获取goroutine。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nx">sched</span><span class="p">.</span><span class="nx">runqsize</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="nx">gp</span> <span class="o">:=</span> <span class="nf">globrunqget</span><span class="p">(</span><span class="nx">_p_</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="c1">// 拿取多个
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="nx">gp</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="nx">gp</span><span class="p">,</span> <span class="kc">false</span><span class="p">,</span> <span class="kc">false</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 10) netpoll 是否有就绪的goroutine。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    
</span></span><span class="line"><span class="cl">    <span class="c1">// Poll network.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// This netpoll is only an optimization before we resort to stealing.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// We can safely skip it if there are no waiters or a thread is blocked
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// in netpoll already. If there is any kind of logical race with that
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// blocked thread (e.g. it has already returned from netpoll, but does
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// not set lastpoll yet), this thread will do blocking netpoll below
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// anyway.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// netpollinited()：判断netpoll是否已经初始化。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// netpollWaiters：是否有等待的goroutine。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// sched.lastpoll：上次网络轮询的时间点。为0时表示有线程正在阻塞式调用netpoll函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nf">netpollinited</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Load</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">netpollWaiters</span><span class="p">)</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Load64</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lastpoll</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// netpoll(0)：判断当前是否有就绪事件，0表示立即返回。非阻塞。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="nx">list</span> <span class="o">:=</span> <span class="nf">netpoll</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="p">!</span><span class="nx">list</span><span class="p">.</span><span class="nf">empty</span><span class="p">()</span> <span class="p">{</span> <span class="c1">// non-blocking
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="nx">gp</span> <span class="o">:=</span> <span class="nx">list</span><span class="p">.</span><span class="nf">pop</span><span class="p">()</span> <span class="c1">// 弹出一个goroutine。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="nf">injectglist</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">list</span><span class="p">)</span> <span class="c1">// 处理剩下的goroutine
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="nf">casgstatus</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="nx">_Gwaiting</span><span class="p">,</span> <span class="nx">_Grunnable</span><span class="p">)</span> <span class="c1">// 修改goroutine状态
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="k">if</span> <span class="nx">trace</span><span class="p">.</span><span class="nx">enabled</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="nf">traceGoUnpark</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="nx">gp</span><span class="p">,</span> <span class="kc">false</span><span class="p">,</span> <span class="kc">false</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 11) 以上都没获取到goroutine。标记自旋尝试从其他P中偷取goroutine。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    
</span></span><span class="line"><span class="cl">    <span class="c1">// Spinning Ms: steal work from other Ps.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// Limit the number of spinning Ms to half the number of busy Ps.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// This is necessary to prevent excessive CPU consumption when
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// GOMAXPROCS&gt;&gt;1 but the program parallelism is low.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// Spinning Ms:从其他P那里窃取goroutine。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 将自旋的M限制为繁忙M的一半。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 这是必要的，以防止在 GOMAXPROCS&gt;&gt;1 但程序并行性较低时过度消耗CPU。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 如果当前处于spinning状态的M的数量大于忙碌的P的数量的一半，就让当前M阻塞(休眠)。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 目的是避免在gomaxprocs较大而程序实际的并发性很低的情况下，造成不必要的CPU消耗。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">procs</span> <span class="o">:=</span> <span class="nb">uint32</span><span class="p">(</span><span class="nx">gomaxprocs</span><span class="p">)</span> <span class="c1">// 获取当前P的数量
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// _g_.m.spinning == true：当前M处于自旋。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 2*atomic.Load(&amp;sched.nmspinning) &lt; procs-atomic.Load(&amp;sched.npidle)：自旋是繁忙的一半还小时，标记当前M为自旋
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">spinning</span> <span class="o">||</span> <span class="mi">2</span><span class="o">*</span><span class="nx">atomic</span><span class="p">.</span><span class="nf">Load</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">nmspinning</span><span class="p">)</span> <span class="p">&lt;</span> <span class="nx">procs</span><span class="o">-</span><span class="nx">atomic</span><span class="p">.</span><span class="nf">Load</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">npidle</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">!</span><span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">spinning</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 满足偷取的时候才会标记M为自旋状态            
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">spinning</span> <span class="p">=</span> <span class="kc">true</span> <span class="c1">// 标记为自旋状态
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="nx">atomic</span><span class="p">.</span><span class="nf">Xadd</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">nmspinning</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="c1">// 累加自旋M的数量
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// 去其他P中偷取 goroutine。偷取其他P中goroutine的一半。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 从p.runnext中偷取的goroutine时，inheritTime该值为true，表示继承上个时间片。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">gp</span><span class="p">,</span> <span class="nx">inheritTime</span><span class="p">,</span> <span class="nx">tnow</span><span class="p">,</span> <span class="nx">w</span><span class="p">,</span> <span class="nx">newWork</span> <span class="o">:=</span> <span class="nf">stealWork</span><span class="p">(</span><span class="nx">now</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="nx">now</span> <span class="p">=</span> <span class="nx">tnow</span> <span class="c1">// 更新当前时间
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 成功偷取到goroutine
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="nx">gp</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// Successfully stole.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="k">return</span> <span class="nx">gp</span><span class="p">,</span> <span class="nx">inheritTime</span><span class="p">,</span> <span class="kc">false</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// newWork 某个P中有timer被触发了，在来一次调度循环
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="nx">newWork</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// There may be new timer or GC work; restart to
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// discover.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="k">goto</span> <span class="nx">top</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// w不为0，表示最近触发的timer的时间点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="nx">w</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="nx">pollUntil</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="nx">w</span> <span class="p">&lt;</span> <span class="nx">pollUntil</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// Earlier timer to wait for.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="nx">pollUntil</span> <span class="p">=</span> <span class="nx">w</span> <span class="c1">// 记录最近要触发的时间点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c1">// 12) 有GC标记工作这去帮助GC
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="c1">// We have nothing to do.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// If we&#39;re in the GC mark phase, can safely scan and blacken objects,
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// and have work to do, run idle-time marking rather than give up the P.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 我们无事可做。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 如果我们在GC标记阶段，可以安全地扫描和变黑对象，并且有工作要做，运行空闲时间标记而不是放弃P。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nx">gcBlackenEnabled</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nf">gcMarkWorkAvailable</span><span class="p">(</span><span class="nx">_p_</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="nx">gcController</span><span class="p">.</span><span class="nf">addIdleMarkWorker</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">node</span> <span class="o">:=</span> <span class="p">(</span><span class="o">*</span><span class="nx">gcBgMarkWorkerNode</span><span class="p">)(</span><span class="nx">gcBgMarkWorkerPool</span><span class="p">.</span><span class="nf">pop</span><span class="p">())</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="nx">node</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nx">_p_</span><span class="p">.</span><span class="nx">gcMarkWorkerMode</span> <span class="p">=</span> <span class="nx">gcMarkWorkerIdleMode</span>
</span></span><span class="line"><span class="cl">            <span class="nx">gp</span> <span class="o">:=</span> <span class="nx">node</span><span class="p">.</span><span class="nx">gp</span><span class="p">.</span><span class="nf">ptr</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">            <span class="nf">casgstatus</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="nx">_Gwaiting</span><span class="p">,</span> <span class="nx">_Grunnable</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="nx">trace</span><span class="p">.</span><span class="nx">enabled</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="nf">traceGoUnpark</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="nx">gp</span><span class="p">,</span> <span class="kc">false</span><span class="p">,</span> <span class="kc">false</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="nx">gcController</span><span class="p">.</span><span class="nf">removeIdleMarkWorker</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// wasm only:
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// If a callback returned and no other goroutine is awake,
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// then wake event handler goroutine which pauses execution
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// until a callback was triggered.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">gp</span><span class="p">,</span> <span class="nx">otherReady</span> <span class="o">:=</span> <span class="nf">beforeIdle</span><span class="p">(</span><span class="nx">now</span><span class="p">,</span> <span class="nx">pollUntil</span><span class="p">)</span> <span class="c1">// 在linux下返回 (nil, false)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nx">gp</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">casgstatus</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="nx">_Gwaiting</span><span class="p">,</span> <span class="nx">_Grunnable</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="nx">trace</span><span class="p">.</span><span class="nx">enabled</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nf">traceGoUnpark</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="nx">gp</span><span class="p">,</span> <span class="kc">false</span><span class="p">,</span> <span class="kc">false</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">otherReady</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">goto</span> <span class="nx">top</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c1">// 13) 保存allp、idlepMask和timerpMask的快照
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 当前工作线程即将休眠，休眠前再次去快照里面看看有没有工作要做
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Before we drop our P, make a snapshot of the allp slice,
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// which can change underfoot once we no longer block
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// safe-points. We don&#39;t need to snapshot the contents because
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// everything up to cap(allp) is immutable.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 在我们丢弃P之前，做一个allp切片的快照，一旦我们不再阻塞safe-points，它就会改变。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 我们不需要对内容进行快照，因为cap(allp)之前的所有内容都是不可变的。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">allpSnapshot</span> <span class="o">:=</span> <span class="nx">allp</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Also snapshot masks. Value changes are OK, but we can&#39;t allow
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// len to change out from under us.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 还有快照掩码。值更改是可以的，但是我们不能允许len从我们下面更改。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">idlepMaskSnapshot</span> <span class="o">:=</span> <span class="nx">idlepMask</span>
</span></span><span class="line"><span class="cl">    <span class="nx">timerpMaskSnapshot</span> <span class="o">:=</span> <span class="nx">timerpMask</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 14) 在看一下gcwaiting和runSafePointFn，以及全局队列sched.runqsize
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    
</span></span><span class="line"><span class="cl">    <span class="c1">// return P and block
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 有GC等待 或 P有安全点函数执行
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nx">sched</span><span class="p">.</span><span class="nx">gcwaiting</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">||</span> <span class="nx">_p_</span><span class="p">.</span><span class="nx">runSafePointFn</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">goto</span> <span class="nx">top</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 全局队列有 goroutine
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nx">sched</span><span class="p">.</span><span class="nx">runqsize</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 因为 sched.lock 锁已被持有，所以一定能取出 gp。不为 nil。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">gp</span> <span class="o">:=</span> <span class="nf">globrunqget</span><span class="p">(</span><span class="nx">_p_</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="nx">gp</span><span class="p">,</span> <span class="kc">false</span><span class="p">,</span> <span class="kc">false</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c1">// 15) 解除当前M与P的绑定关系，并把P加入全局空闲队列中
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    
</span></span><span class="line"><span class="cl">    <span class="c1">// 解除m与p的绑定关系，并设置p为空闲状态。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nf">releasep</span><span class="p">()</span> <span class="o">!=</span> <span class="nx">_p_</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">throw</span><span class="p">(</span><span class="s">&#34;findrunnable: wrong p&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 把P加入空闲队列
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">now</span> <span class="p">=</span> <span class="nf">pidleput</span><span class="p">(</span><span class="nx">_p_</span><span class="p">,</span> <span class="nx">now</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 16) 根据前面快照保存的信息，再次检查其他P是否可偷取，GC有没标记工作需要协助，timer有没触发
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    
</span></span><span class="line"><span class="cl">    <span class="c1">// Delicate dance: thread transitions from spinning to non-spinning
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// state, potentially concurrently with submission of new work. We must
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// drop nmspinning first and then check all sources again (with
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// #StoreLoad memory barrier in between). If we do it the other way
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// around, another thread can submit work after we&#39;ve checked all
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// sources but before we drop nmspinning; as a result nobody will
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// unpark a thread to run the work.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// This applies to the following sources of work:
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// * Goroutines added to a per-P run queue.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// * New/modified-earlier timers on a per-P timer heap.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// * Idle-priority GC work (barring golang.org/issue/19112).
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// If we discover new work below, we need to restore m.spinning as a signal
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// for resetspinning to unpark a new worker thread (because there can be more
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// than one starving goroutine). However, if after discovering new work
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// we also observe no idle Ps it is OK to skip unparking a new worker
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// thread: the system is fully loaded so no spinning threads are required.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// Also see &#34;Worker thread parking/unparking&#34; comment at the top of the file.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">wasSpinning</span> <span class="o">:=</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">spinning</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 处理当前M是自旋状态
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">spinning</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">spinning</span> <span class="p">=</span> <span class="kc">false</span> <span class="c1">// 标记当前M未非自旋
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="nb">int32</span><span class="p">(</span><span class="nx">atomic</span><span class="p">.</span><span class="nf">Xadd</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">nmspinning</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span> <span class="p">&lt;</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nf">throw</span><span class="p">(</span><span class="s">&#34;findrunnable: negative nmspinning&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// Note the for correctness, only the last M transitioning from
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// spinning to non-spinning must perform these rechecks to
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// ensure no missed work. We are performing it on every M that
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// transitions as a conservative change to monitor effects on
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// latency. See golang.org/issue/43997.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">        <span class="c1">// Check all runqueues once again.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 再次检查所有运行队列。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 检查是否有可偷取的P，如果有则取出一个空闲的P绑定M。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">_p_</span> <span class="p">=</span> <span class="nf">checkRunqsNoP</span><span class="p">(</span><span class="nx">allpSnapshot</span><span class="p">,</span> <span class="nx">idlepMaskSnapshot</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="nx">_p_</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nf">acquirep</span><span class="p">(</span><span class="nx">_p_</span><span class="p">)</span> <span class="c1">// 绑定P
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">spinning</span> <span class="p">=</span> <span class="kc">true</span>
</span></span><span class="line"><span class="cl">            <span class="nx">atomic</span><span class="p">.</span><span class="nf">Xadd</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">nmspinning</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="k">goto</span> <span class="nx">top</span> <span class="c1">// 有工作可做再跑一遍调度循环
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// Check for idle-priority GC work again.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 再次检查空闲优先级GC工作。是否有编辑工作需要做
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">_p_</span><span class="p">,</span> <span class="nx">gp</span> <span class="p">=</span> <span class="nf">checkIdleGCNoP</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="nx">_p_</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nf">acquirep</span><span class="p">(</span><span class="nx">_p_</span><span class="p">)</span> <span class="c1">// 绑定P
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">spinning</span> <span class="p">=</span> <span class="kc">true</span>
</span></span><span class="line"><span class="cl">            <span class="nx">atomic</span><span class="p">.</span><span class="nf">Xadd</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">nmspinning</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            <span class="c1">// Run the idle worker.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="nx">_p_</span><span class="p">.</span><span class="nx">gcMarkWorkerMode</span> <span class="p">=</span> <span class="nx">gcMarkWorkerIdleMode</span>
</span></span><span class="line"><span class="cl">            <span class="nf">casgstatus</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="nx">_Gwaiting</span><span class="p">,</span> <span class="nx">_Grunnable</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="nx">trace</span><span class="p">.</span><span class="nx">enabled</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="nf">traceGoUnpark</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="nx">gp</span><span class="p">,</span> <span class="kc">false</span><span class="p">,</span> <span class="kc">false</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// Finally, check for timer creation or expiry concurrently with
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// transitioning from spinning to non-spinning.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// Note that we cannot use checkTimers here because it calls
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// adjusttimers which may need to allocate memory, and that isn&#39;t
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// allowed when we don&#39;t have an active P.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 最后，再看看timer。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">pollUntil</span> <span class="p">=</span> <span class="nf">checkTimersNoP</span><span class="p">(</span><span class="nx">allpSnapshot</span><span class="p">,</span> <span class="nx">timerpMaskSnapshot</span><span class="p">,</span> <span class="nx">pollUntil</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 17) network 是否有需要处理的goroutine，或timer是否即将触发，
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 标记sched.lastpoll为0，阻塞式等待吧。netpoll中一些读写超时需要用到timer
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    
</span></span><span class="line"><span class="cl">    <span class="c1">// Poll network until next timer.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// Poll network 直到下一个 timer。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//  netpollinited()：netpoll 已初始化。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//  netpollWaiters：记录当前goroutine被挂在epoll中的等待数量。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//  pollUntil：&gt;0.下个timer触发的而时间点。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//  atomic.Xchg64(&amp;sched.lastpoll, 0)：这里是唯一的把sched.lastpoll修改为0的情况，
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//  表示当前需要阻塞式的调用netpoll函数。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 这里的atomic.Xchg64(&amp;sched.lastpoll, 0) != 0 具有排他性。只能有一个工作线程处于阻塞等待中。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nf">netpollinited</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="nx">atomic</span><span class="p">.</span><span class="nf">Load</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">netpollWaiters</span><span class="p">)</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="nx">pollUntil</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Xchg64</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lastpoll</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// sched.pollUntil = pollUntil，预计的阻塞时间点。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">atomic</span><span class="p">.</span><span class="nf">Store64</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">pollUntil</span><span class="p">,</span> <span class="nb">uint64</span><span class="p">(</span><span class="nx">pollUntil</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">p</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nf">throw</span><span class="p">(</span><span class="s">&#34;findrunnable: netpoll with p&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">spinning</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nf">throw</span><span class="p">(</span><span class="s">&#34;findrunnable: netpoll with spinning&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// Refresh now.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">now</span> <span class="p">=</span> <span class="nf">nanotime</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">        <span class="nx">delay</span> <span class="o">:=</span> <span class="nb">int64</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="nx">pollUntil</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 计算预计阻塞的时间
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="nx">delay</span> <span class="p">=</span> <span class="nx">pollUntil</span> <span class="o">-</span> <span class="nx">now</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="nx">delay</span> <span class="p">&lt;</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="c1">// 触发时间以过，要求立即返回
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="nx">delay</span> <span class="p">=</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// faketime是自1970年以来模拟的以纳秒为单位的时间。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 0值意味着不使用faketime。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="nx">faketime</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// When using fake time, just poll.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// 当使用 fake time，只是poll。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="nx">delay</span> <span class="p">=</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 阻塞直到有新的work可用，delay是一个具体的时间段
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">list</span> <span class="o">:=</span> <span class="nf">netpoll</span><span class="p">(</span><span class="nx">delay</span><span class="p">)</span> <span class="c1">// block until new work is available
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">atomic</span><span class="p">.</span><span class="nf">Store64</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">pollUntil</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="c1">// sched.pollUntil = 0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">atomic</span><span class="p">.</span><span class="nf">Store64</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lastpoll</span><span class="p">,</span> <span class="nb">uint64</span><span class="p">(</span><span class="nx">now</span><span class="p">))</span> <span class="c1">// sched.lastpoll = now
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="nx">faketime</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">list</span><span class="p">.</span><span class="nf">empty</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// Using fake time and nothing is ready; stop M.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// When all M&#39;s stop, checkdead will call timejump.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="nf">stopm</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">            <span class="k">goto</span> <span class="nx">top</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 从空闲P链表中获取一个P
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">_p_</span><span class="p">,</span> <span class="nx">_</span> <span class="p">=</span> <span class="nf">pidleget</span><span class="p">(</span><span class="nx">now</span><span class="p">)</span> 
</span></span><span class="line"><span class="cl">        <span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="nx">_p_</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 没有可用的空闲P时。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// 如果有就绪的goroutine放入全局goroutine池。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="nf">injectglist</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">list</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nf">acquirep</span><span class="p">(</span><span class="nx">_p_</span><span class="p">)</span> <span class="c1">// 绑定P
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="k">if</span> <span class="p">!</span><span class="nx">list</span><span class="p">.</span><span class="nf">empty</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="c1">// 取出一个goroutine，用于返回
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="nx">gp</span> <span class="o">:=</span> <span class="nx">list</span><span class="p">.</span><span class="nf">pop</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">                <span class="c1">// 剩余的优先加入全局池。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="nf">injectglist</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">list</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                <span class="c1">// 修改goroutine状态为待运行状态
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="nf">casgstatus</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="nx">_Gwaiting</span><span class="p">,</span> <span class="nx">_Grunnable</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                <span class="k">if</span> <span class="nx">trace</span><span class="p">.</span><span class="nx">enabled</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                    <span class="nf">traceGoUnpark</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                <span class="p">}</span>
</span></span><span class="line"><span class="cl">                <span class="c1">// 返回找到的 goroutine
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="k">return</span> <span class="nx">gp</span><span class="p">,</span> <span class="kc">false</span><span class="p">,</span> <span class="kc">false</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 如果之前M是自旋，则再次标记为自旋并从新再来一次。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="k">if</span> <span class="nx">wasSpinning</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">spinning</span> <span class="p">=</span> <span class="kc">true</span>
</span></span><span class="line"><span class="cl">                <span class="nx">atomic</span><span class="p">.</span><span class="nf">Xadd</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">nmspinning</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="k">goto</span> <span class="nx">top</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nx">pollUntil</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nf">netpollinited</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 有其他的线程在阻塞 netpoll。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// sched.pollUntil：下次timer应该被唤醒时间点。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">pollerPollUntil</span> <span class="o">:=</span> <span class="nb">int64</span><span class="p">(</span><span class="nx">atomic</span><span class="p">.</span><span class="nf">Load64</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">pollUntil</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// timer触发了 或 触发时间已到 叫醒阻塞的netpoll
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="nx">pollerPollUntil</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="nx">pollerPollUntil</span> <span class="p">&gt;</span> <span class="nx">pollUntil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nf">netpollBreak</span><span class="p">()</span> <span class="c1">// 叫醒epoll
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c1">// 挂起当前线程等待其他线程唤醒。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">stopm</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="k">goto</span> <span class="nx">top</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="gcstopm">gcstopm()<a hidden class="anchor" aria-hidden="true" href="#gcstopm">#</a></h3>
<ol>
<li>为<code>stopTheWorld</code>停止当前<code>M</code>。</li>
<li>当<code>TheWordStart</code>时返回。辅助<code>STW</code>。</li>
<li>文件位置：<code>go1.19.3/src/runtime/proc.go</code>。</li>
<li>该方法在GC发起时，其他线程都在这个方法上把自己挂起。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">2481
</span><span class="lnt">2482
</span><span class="lnt">2483
</span><span class="lnt">2484
</span><span class="lnt">2485
</span><span class="lnt">2486
</span><span class="lnt">2487
</span><span class="lnt">2488
</span><span class="lnt">2489
</span><span class="lnt">2490
</span><span class="lnt">2491
</span><span class="lnt">2492
</span><span class="lnt">2493
</span><span class="lnt">2494
</span><span class="lnt">2495
</span><span class="lnt">2496
</span><span class="lnt">2497
</span><span class="lnt">2498
</span><span class="lnt">2499
</span><span class="lnt">2500
</span><span class="lnt">2501
</span><span class="lnt">2502
</span><span class="lnt">2503
</span><span class="lnt">2504
</span><span class="lnt">2505
</span><span class="lnt">2506
</span><span class="lnt">2507
</span><span class="lnt">2508
</span><span class="lnt">2509
</span><span class="lnt">2510
</span><span class="lnt">2511
</span><span class="lnt">2512
</span><span class="lnt">2513
</span><span class="lnt">2514
</span><span class="lnt">2515
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// Stops the current m for stopTheWorld.
</span></span></span><span class="line"><span class="cl"><span class="c1">// Returns when the world is restarted.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">gcstopm</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">_g_</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">()</span> <span class="c1">// _g_ = g0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="c1">// sched.gcwaiting：是1，表示当前STW正在等待P停下来。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nx">sched</span><span class="p">.</span><span class="nx">gcwaiting</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">throw</span><span class="p">(</span><span class="s">&#34;gcstopm: not waiting for gc&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 当前M正处于自旋状态下。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">spinning</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">spinning</span> <span class="p">=</span> <span class="kc">false</span> <span class="c1">// 清除自旋标记
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// OK to just drop nmspinning here,
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// startTheWorld will unpark threads as necessary.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 自旋计数出现错误
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="nb">int32</span><span class="p">(</span><span class="nx">atomic</span><span class="p">.</span><span class="nf">Xadd</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">nmspinning</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span> <span class="p">&lt;</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nf">throw</span><span class="p">(</span><span class="s">&#34;gcstopm: negative nmspinning&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 解绑当前M与P
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">_p_</span> <span class="o">:=</span> <span class="nf">releasep</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// _Pgcstop：GC停止状态。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// P被STW挂起以执行GC，所有权归执行STW的M所有，执行STW的M会继续使用处于_Pgcstop状态的P。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">_p_</span><span class="p">.</span><span class="nx">status</span> <span class="p">=</span> <span class="nx">_Pgcstop</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// sched.stopwait：记录了STW需要停止的P的数量
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">sched</span><span class="p">.</span><span class="nx">stopwait</span><span class="o">--</span> 
</span></span><span class="line"><span class="cl">    <span class="c1">// 已经停下了所有的P，需要唤醒在 sched.stopnote 上发起STW的工作线程。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nx">sched</span><span class="p">.</span><span class="nx">stopwait</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">notewakeup</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">stopnote</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nf">stopm</span><span class="p">()</span> <span class="c1">// 停止当前工作线程。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="releasep">releasep()<a hidden class="anchor" aria-hidden="true" href="#releasep">#</a></h4>
<ol>
<li>解除<code>p</code>和当前<code>m</code>的关联。</li>
<li>文件位置：<code>go1.19.3/src/runtime/proc.go</code>。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">4984
</span><span class="lnt">4985
</span><span class="lnt">4986
</span><span class="lnt">4987
</span><span class="lnt">4988
</span><span class="lnt">4989
</span><span class="lnt">4990
</span><span class="lnt">4991
</span><span class="lnt">4992
</span><span class="lnt">4993
</span><span class="lnt">4994
</span><span class="lnt">4995
</span><span class="lnt">4996
</span><span class="lnt">4997
</span><span class="lnt">4998
</span><span class="lnt">4999
</span><span class="lnt">5000
</span><span class="lnt">5001
</span><span class="lnt">5002
</span><span class="lnt">5003
</span><span class="lnt">5004
</span><span class="lnt">5005
</span><span class="lnt">5006
</span><span class="lnt">5007
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// Disassociate p and the current m.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">releasep</span><span class="p">()</span> <span class="o">*</span><span class="nx">p</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">_g_</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">()</span> <span class="c1">// _g_ = g0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">p</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">throw</span><span class="p">(</span><span class="s">&#34;releasep: invalid arg&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nx">_p_</span> <span class="o">:=</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">p</span><span class="p">.</span><span class="nf">ptr</span><span class="p">()</span> <span class="c1">// _p_ = p
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// _p_.m == _g_.m &amp;&amp; _p_.status == _Prunning
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nx">_p_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nf">ptr</span><span class="p">()</span> <span class="o">!=</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span> <span class="o">||</span> <span class="nx">_p_</span><span class="p">.</span><span class="nx">status</span> <span class="o">!=</span> <span class="nx">_Prunning</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nb">print</span><span class="p">(</span><span class="s">&#34;releasep: m=&#34;</span><span class="p">,</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">,</span> <span class="s">&#34; m-&gt;p=&#34;</span><span class="p">,</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">p</span><span class="p">.</span><span class="nf">ptr</span><span class="p">(),</span> <span class="s">&#34; p-&gt;m=&#34;</span><span class="p">,</span> <span class="nf">hex</span><span class="p">(</span><span class="nx">_p_</span><span class="p">.</span><span class="nx">m</span><span class="p">),</span> <span class="s">&#34; p-&gt;status=&#34;</span><span class="p">,</span> <span class="nx">_p_</span><span class="p">.</span><span class="nx">status</span><span class="p">,</span> <span class="s">&#34;\n&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="nf">throw</span><span class="p">(</span><span class="s">&#34;releasep: invalid p state&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">trace</span><span class="p">.</span><span class="nx">enabled</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">traceProcStop</span><span class="p">(</span><span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">p</span><span class="p">.</span><span class="nf">ptr</span><span class="p">())</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 解除 p 与 m 相互绑定的关系。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">p</span> <span class="p">=</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">    <span class="nx">_p_</span><span class="p">.</span><span class="nx">m</span> <span class="p">=</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// _Pidle：空闲状态。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 此时的P没有被用来执行用户代码或调度器代码，通常位于空闲链表中，能够被调度器获取。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">_p_</span><span class="p">.</span><span class="nx">status</span> <span class="p">=</span> <span class="nx">_Pidle</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nx">_p_</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="stopm">stopm()<a hidden class="anchor" aria-hidden="true" href="#stopm">#</a></h4>
<ol>
<li>停止执行当前<code>m</code>，直到有新的工作可用。返回获取的<code>P</code>。</li>
<li>文件位置：<code>go1.19.3/src/runtime/proc.go</code>。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">2229
</span><span class="lnt">2230
</span><span class="lnt">2231
</span><span class="lnt">2232
</span><span class="lnt">2233
</span><span class="lnt">2234
</span><span class="lnt">2235
</span><span class="lnt">2236
</span><span class="lnt">2237
</span><span class="lnt">2238
</span><span class="lnt">2239
</span><span class="lnt">2240
</span><span class="lnt">2241
</span><span class="lnt">2242
</span><span class="lnt">2243
</span><span class="lnt">2244
</span><span class="lnt">2245
</span><span class="lnt">2246
</span><span class="lnt">2247
</span><span class="lnt">2248
</span><span class="lnt">2249
</span><span class="lnt">2250
</span><span class="lnt">2251
</span><span class="lnt">2252
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// Stops execution of the current m until new work is available.
</span></span></span><span class="line"><span class="cl"><span class="c1">// Returns with acquired P.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">stopm</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">_g_</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">()</span> <span class="c1">// _g_ = g0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">locks</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">throw</span><span class="p">(</span><span class="s">&#34;stopm holding locks&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">p</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">throw</span><span class="p">(</span><span class="s">&#34;stopm holding p&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">spinning</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">throw</span><span class="p">(</span><span class="s">&#34;stopm spinning&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nf">mput</span><span class="p">(</span><span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">)</span> <span class="c1">// 把当前m加入sched.midle中。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nf">mPark</span><span class="p">()</span> <span class="c1">// 工作线程sleep在m.park上
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    
</span></span><span class="line"><span class="cl">    <span class="c1">// 工作线程再次被wakeup时，绑定P。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">acquirep</span><span class="p">(</span><span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">nextp</span><span class="p">.</span><span class="nf">ptr</span><span class="p">())</span> <span class="c1">// 此处p来自m.nextp。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">nextp</span> <span class="p">=</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="mput">mput()<a hidden class="anchor" aria-hidden="true" href="#mput">#</a></h4>
<ol>
<li>把<code>mp</code>列入<code>midle</code>列表中。</li>
<li><code>sched.lock</code> 必须被持有。</li>
<li>可能在<code>STW</code>期间运行，因此不允许出现写屏障。</li>
<li>文件位置：<code>go1.19.3/src/runtime/proc.go</code>。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">5533
</span><span class="lnt">5534
</span><span class="lnt">5535
</span><span class="lnt">5536
</span><span class="lnt">5537
</span><span class="lnt">5538
</span><span class="lnt">5539
</span><span class="lnt">5540
</span><span class="lnt">5541
</span><span class="lnt">5542
</span><span class="lnt">5543
</span><span class="lnt">5544
</span><span class="lnt">5545
</span><span class="lnt">5546
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// Put mp on midle list.
</span></span></span><span class="line"><span class="cl"><span class="c1">// sched.lock must be held.
</span></span></span><span class="line"><span class="cl"><span class="c1">// May run during STW, so write barriers are not allowed.
</span></span></span><span class="line"><span class="cl"><span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1">//go:nowritebarrierrec
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">mput</span><span class="p">(</span><span class="nx">mp</span> <span class="o">*</span><span class="nx">m</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nf">assertLockHeld</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 把当前m加入sched.midle。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">mp</span><span class="p">.</span><span class="nx">schedlink</span> <span class="p">=</span> <span class="nx">sched</span><span class="p">.</span><span class="nx">midle</span>
</span></span><span class="line"><span class="cl">    <span class="nx">sched</span><span class="p">.</span><span class="nx">midle</span><span class="p">.</span><span class="nf">set</span><span class="p">(</span><span class="nx">mp</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nx">sched</span><span class="p">.</span><span class="nx">nmidle</span><span class="o">++</span>
</span></span><span class="line"><span class="cl">    <span class="nf">checkdead</span><span class="p">()</span> <span class="c1">// 检查死锁。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="mpark">mPark()<a hidden class="anchor" aria-hidden="true" href="#mpark">#</a></h4>
<ol>
<li><code>mPark</code>会导致线程自行停驻，一旦被唤醒就会返回。</li>
<li>文件位置：<code>go1.19.3/src/runtime/proc.go</code>。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1452
</span><span class="lnt">1453
</span><span class="lnt">1454
</span><span class="lnt">1455
</span><span class="lnt">1456
</span><span class="lnt">1457
</span><span class="lnt">1458
</span><span class="lnt">1459
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// mPark causes a thread to park itself, returning once woken.
</span></span></span><span class="line"><span class="cl"><span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1">//go:nosplit
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">mPark</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">gp</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">()</span> <span class="c1">// gp = g0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">notesleep</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">gp</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">park</span><span class="p">)</span> <span class="c1">// sleep
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">noteclear</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">gp</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">park</span><span class="p">)</span> <span class="c1">// 清除 m.park
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="acquirep">acquirep()<a hidden class="anchor" aria-hidden="true" href="#acquirep">#</a></h4>
<ol>
<li>关联<code>p</code>和当前<code>m</code>。</li>
<li>文件位置：<code>go1.19.3/src/runtime/proc.go</code>。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">4938
</span><span class="lnt">4939
</span><span class="lnt">4940
</span><span class="lnt">4941
</span><span class="lnt">4942
</span><span class="lnt">4943
</span><span class="lnt">4944
</span><span class="lnt">4945
</span><span class="lnt">4946
</span><span class="lnt">4947
</span><span class="lnt">4948
</span><span class="lnt">4949
</span><span class="lnt">4950
</span><span class="lnt">4951
</span><span class="lnt">4952
</span><span class="lnt">4953
</span><span class="lnt">4954
</span><span class="lnt">4955
</span><span class="lnt">4956
</span><span class="lnt">4957
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// Associate p and the current m.
</span></span></span><span class="line"><span class="cl"><span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1">// This function is allowed to have write barriers even if the caller
</span></span></span><span class="line"><span class="cl"><span class="c1">// isn&#39;t because it immediately acquires _p_.
</span></span></span><span class="line"><span class="cl"><span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1">//go:yeswritebarrierrec
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">acquirep</span><span class="p">(</span><span class="nx">_p_</span> <span class="o">*</span><span class="nx">p</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Do the part that isn&#39;t allowed to have write barriers.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">wirep</span><span class="p">(</span><span class="nx">_p_</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// Have p; write barriers now allowed.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Perform deferred mcache flush before this P can allocate
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// from a potentially stale mcache.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">_p_</span><span class="p">.</span><span class="nx">mcache</span><span class="p">.</span><span class="nf">prepareForSweep</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">trace</span><span class="p">.</span><span class="nx">enabled</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">traceProcStart</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="globrunqget">globrunqget()<a hidden class="anchor" aria-hidden="true" href="#globrunqget">#</a></h3>
<ol>
<li>尝试从全局可运行队列中获取一批<code>G</code>，<code>sched.lock</code>必须被持有。</li>
<li>参数：
<ol>
<li><code>_p_ *p</code>：当前工作线程绑定的<code>P</code>。</li>
<li><code>max int32</code>：从全局队列中拿多少个<code>g</code>到本地<code>P</code>中。该参数一般是1，如果是其他<code>P</code>偷取则是大于1。</li>
</ol>
</li>
<li>返回值<code>*g</code>：从全局队列中那到的<code>goroutine</code>。</li>
<li>文件位置：<code>go1.19.3/src/runtime/proc.go</code>。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">5601
</span><span class="lnt">5602
</span><span class="lnt">5603
</span><span class="lnt">5604
</span><span class="lnt">5605
</span><span class="lnt">5606
</span><span class="lnt">5607
</span><span class="lnt">5608
</span><span class="lnt">5609
</span><span class="lnt">5610
</span><span class="lnt">5611
</span><span class="lnt">5612
</span><span class="lnt">5613
</span><span class="lnt">5614
</span><span class="lnt">5615
</span><span class="lnt">5616
</span><span class="lnt">5617
</span><span class="lnt">5618
</span><span class="lnt">5619
</span><span class="lnt">5620
</span><span class="lnt">5621
</span><span class="lnt">5622
</span><span class="lnt">5623
</span><span class="lnt">5624
</span><span class="lnt">5625
</span><span class="lnt">5626
</span><span class="lnt">5627
</span><span class="lnt">5628
</span><span class="lnt">5629
</span><span class="lnt">5630
</span><span class="lnt">5631
</span><span class="lnt">5632
</span><span class="lnt">5633
</span><span class="lnt">5634
</span><span class="lnt">5635
</span><span class="lnt">5636
</span><span class="lnt">5637
</span><span class="lnt">5638
</span><span class="lnt">5639
</span><span class="lnt">5640
</span><span class="lnt">5641
</span><span class="lnt">5642
</span><span class="lnt">5643
</span><span class="lnt">5644
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// Try get a batch of G&#39;s from the global runnable queue.
</span></span></span><span class="line"><span class="cl"><span class="c1">// sched.lock must be held.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">globrunqget</span><span class="p">(</span><span class="nx">_p_</span> <span class="o">*</span><span class="nx">p</span><span class="p">,</span> <span class="nx">max</span> <span class="kt">int32</span><span class="p">)</span> <span class="o">*</span><span class="nx">g</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nf">assertLockHeld</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// sched.runqsize：记录的是全局就绪队列的长度。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 也就是全局队列goroutine的个数。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nx">sched</span><span class="p">.</span><span class="nx">runqsize</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 根据p的数量平分全局运行队列中的goroutines
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">n</span> <span class="o">:=</span> <span class="nx">sched</span><span class="p">.</span><span class="nx">runqsize</span><span class="o">/</span><span class="nx">gomaxprocs</span> <span class="o">+</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 上面计算n的方法可能导致n大于全局运行队列中的goroutine数量
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nx">n</span> <span class="p">&gt;</span> <span class="nx">sched</span><span class="p">.</span><span class="nx">runqsize</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">n</span> <span class="p">=</span> <span class="nx">sched</span><span class="p">.</span><span class="nx">runqsize</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// max：表示最多拿去goroutine个数。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nx">max</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">n</span> <span class="p">&gt;</span> <span class="nx">max</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">n</span> <span class="p">=</span> <span class="nx">max</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 最多只能取本地队列容量的一半。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// _p_.runq：最大256。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nx">n</span> <span class="p">&gt;</span> <span class="nb">int32</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">_p_</span><span class="p">.</span><span class="nx">runq</span><span class="p">))</span><span class="o">/</span><span class="mi">2</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">n</span> <span class="p">=</span> <span class="nb">int32</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">_p_</span><span class="p">.</span><span class="nx">runq</span><span class="p">))</span> <span class="o">/</span> <span class="mi">2</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nx">sched</span><span class="p">.</span><span class="nx">runqsize</span> <span class="o">-=</span> <span class="nx">n</span> <span class="c1">// 减去取出的数量
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="c1">// pop从全局运行队列的队列头取一个goroutine。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 这个goroutine用于返回。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">gp</span> <span class="o">:=</span> <span class="nx">sched</span><span class="p">.</span><span class="nx">runq</span><span class="p">.</span><span class="nf">pop</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="nx">n</span><span class="o">--</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 遍历从全局队列中拿取goroutine到P的本地队列中。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">for</span> <span class="p">;</span> <span class="nx">n</span> <span class="p">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">n</span><span class="o">--</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 从全局运行队列中取出一个goroutine
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">gp1</span> <span class="o">:=</span> <span class="nx">sched</span><span class="p">.</span><span class="nx">runq</span><span class="p">.</span><span class="nf">pop</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 放入本地运行队列，false.放入尾部。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">//  1. go关键字时，调用该方法传入的true
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">//  2. 从全局拿取时，这里传入的时false
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nf">runqput</span><span class="p">(</span><span class="nx">_p_</span><span class="p">,</span> <span class="nx">gp1</span><span class="p">,</span> <span class="kc">false</span><span class="p">)</span> 
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nx">gp</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="runqput">runqput()<a hidden class="anchor" aria-hidden="true" href="#runqput">#</a></h4>
<ol>
<li>把<code>gp</code>放入<code>_p_</code>的尾部。</li>
<li>参数：
<ul>
<li><code>_p_ *p</code>：本地<code>P</code>。</li>
<li><code>gp *g</code>：需要放入<code>_p_</code>的<code>goroutine</code>。</li>
<li><code>next bool</code>：<code>true</code>放入本地<code>_p_</code>的开头，<code>false</code>放入本地<code>_p_</code>的尾部。</li>
</ul>
</li>
<li>文件位置：<code>go1.19.3/src/runtime/proc.go</code>。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">5780
</span><span class="lnt">5781
</span><span class="lnt">5782
</span><span class="lnt">5783
</span><span class="lnt">5784
</span><span class="lnt">5785
</span><span class="lnt">5786
</span><span class="lnt">5787
</span><span class="lnt">5788
</span><span class="lnt">5789
</span><span class="lnt">5790
</span><span class="lnt">5791
</span><span class="lnt">5792
</span><span class="lnt">5793
</span><span class="lnt">5794
</span><span class="lnt">5795
</span><span class="lnt">5796
</span><span class="lnt">5797
</span><span class="lnt">5798
</span><span class="lnt">5799
</span><span class="lnt">5800
</span><span class="lnt">5801
</span><span class="lnt">5802
</span><span class="lnt">5803
</span><span class="lnt">5804
</span><span class="lnt">5805
</span><span class="lnt">5806
</span><span class="lnt">5807
</span><span class="lnt">5808
</span><span class="lnt">5809
</span><span class="lnt">5810
</span><span class="lnt">5811
</span><span class="lnt">5812
</span><span class="lnt">5813
</span><span class="lnt">5814
</span><span class="lnt">5815
</span><span class="lnt">5816
</span><span class="lnt">5817
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// runqput tries to put g on the local runnable queue.
</span></span></span><span class="line"><span class="cl"><span class="c1">// If next is false, runqput adds g to the tail of the runnable queue.
</span></span></span><span class="line"><span class="cl"><span class="c1">// If next is true, runqput puts g in the _p_.runnext slot.
</span></span></span><span class="line"><span class="cl"><span class="c1">// If the run queue is full, runnext puts g on the global queue.
</span></span></span><span class="line"><span class="cl"><span class="c1">// Executed only by the owner P.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">runqput</span><span class="p">(</span><span class="nx">_p_</span> <span class="o">*</span><span class="nx">p</span><span class="p">,</span> <span class="nx">gp</span> <span class="o">*</span><span class="nx">g</span><span class="p">,</span> <span class="nx">next</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">randomizeScheduler</span> <span class="o">&amp;&amp;</span> <span class="nx">next</span> <span class="o">&amp;&amp;</span> <span class="nf">fastrandn</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">next</span> <span class="p">=</span> <span class="kc">false</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">next</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">retryNext</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="nx">oldnext</span> <span class="o">:=</span> <span class="nx">_p_</span><span class="p">.</span><span class="nx">runnext</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">!</span><span class="nx">_p_</span><span class="p">.</span><span class="nx">runnext</span><span class="p">.</span><span class="nf">cas</span><span class="p">(</span><span class="nx">oldnext</span><span class="p">,</span> <span class="nf">guintptr</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">gp</span><span class="p">)))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">goto</span> <span class="nx">retryNext</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="nx">oldnext</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// Kick the old runnext out to the regular run queue.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">gp</span> <span class="p">=</span> <span class="nx">oldnext</span><span class="p">.</span><span class="nf">ptr</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">retry</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="nx">h</span> <span class="o">:=</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">LoadAcq</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">_p_</span><span class="p">.</span><span class="nx">runqhead</span><span class="p">)</span> <span class="c1">// load-acquire, synchronize with consumers
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">t</span> <span class="o">:=</span> <span class="nx">_p_</span><span class="p">.</span><span class="nx">runqtail</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">t</span><span class="o">-</span><span class="nx">h</span> <span class="p">&lt;</span> <span class="nb">uint32</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">_p_</span><span class="p">.</span><span class="nx">runq</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">_p_</span><span class="p">.</span><span class="nx">runq</span><span class="p">[</span><span class="nx">t</span><span class="o">%</span><span class="nb">uint32</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">_p_</span><span class="p">.</span><span class="nx">runq</span><span class="p">))].</span><span class="nf">set</span><span class="p">(</span><span class="nx">gp</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="nx">atomic</span><span class="p">.</span><span class="nf">StoreRel</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">_p_</span><span class="p">.</span><span class="nx">runqtail</span><span class="p">,</span> <span class="nx">t</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="c1">// store-release, makes the item available for consumption
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">return</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 从_P_中移除一部分到全局中，包含gp。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nf">runqputslow</span><span class="p">(</span><span class="nx">_p_</span><span class="p">,</span> <span class="nx">gp</span><span class="p">,</span> <span class="nx">h</span><span class="p">,</span> <span class="nx">t</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// the queue is not full, now the put above must succeed
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">goto</span> <span class="nx">retry</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="runqget">runqget()<a hidden class="anchor" aria-hidden="true" href="#runqget">#</a></h3>
<ol>
<li>从本地可运行队列中获取<code>goroutine</code>。</li>
<li>如果<code>inheritTime</code>为<code>true</code>，则<code>gp</code>应继承当前时间片中的剩余时间。否则，它应该开始一个新的时间片。</li>
<li>多有者由当前P拥有。</li>
<li>参数：<code>_p_ *p</code>：当前本地<code>P</code>，可能出现其他工作线程<code>M</code>偷取<code>P</code>的情况。</li>
<li>返回值：
<ol>
<li><code>gp *g</code>：当前获取到的<code>goroutine</code>。</li>
<li><code>inheritTime bool</code>：是否继承当前时间片。</li>
</ol>
</li>
<li>文件位置：<code>go1.19.3/src/runtime/proc.go</code>。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">5893
</span><span class="lnt">5894
</span><span class="lnt">5895
</span><span class="lnt">5896
</span><span class="lnt">5897
</span><span class="lnt">5898
</span><span class="lnt">5899
</span><span class="lnt">5900
</span><span class="lnt">5901
</span><span class="lnt">5902
</span><span class="lnt">5903
</span><span class="lnt">5904
</span><span class="lnt">5905
</span><span class="lnt">5906
</span><span class="lnt">5907
</span><span class="lnt">5908
</span><span class="lnt">5909
</span><span class="lnt">5910
</span><span class="lnt">5911
</span><span class="lnt">5912
</span><span class="lnt">5913
</span><span class="lnt">5914
</span><span class="lnt">5915
</span><span class="lnt">5916
</span><span class="lnt">5917
</span><span class="lnt">5918
</span><span class="lnt">5919
</span><span class="lnt">5920
</span><span class="lnt">5921
</span><span class="lnt">5922
</span><span class="lnt">5923
</span><span class="lnt">5924
</span><span class="lnt">5925
</span><span class="lnt">5926
</span><span class="lnt">5927
</span><span class="lnt">5928
</span><span class="lnt">5929
</span><span class="lnt">5930
</span><span class="lnt">5931
</span><span class="lnt">5932
</span><span class="lnt">5933
</span><span class="lnt">5934
</span><span class="lnt">5935
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// Get g from local runnable queue.
</span></span></span><span class="line"><span class="cl"><span class="c1">// If inheritTime is true, gp should inherit the remaining time in the
</span></span></span><span class="line"><span class="cl"><span class="c1">// current time slice. Otherwise, it should start a new time slice.
</span></span></span><span class="line"><span class="cl"><span class="c1">// Executed only by the owner P.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">runqget</span><span class="p">(</span><span class="nx">_p_</span> <span class="o">*</span><span class="nx">p</span><span class="p">)</span> <span class="p">(</span><span class="nx">gp</span> <span class="o">*</span><span class="nx">g</span><span class="p">,</span> <span class="nx">inheritTime</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// If there&#39;s a runnext, it&#39;s the next G to run.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 如果有 runnext，它就是下一个要运行的 G
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">next</span> <span class="o">:=</span> <span class="nx">_p_</span><span class="p">.</span><span class="nx">runnext</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c1">// If the runnext is non-0 and the CAS fails, it could only have been stolen by another P,
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// because other Ps can race to set runnext to 0, but only the current P can set it to non-0.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// Hence, there&#39;s no need to retry this CAS if it falls.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 如果 runnext 是 non-0 并且 CAS 失败，它只能被另一个P窃取，因为其他P可以竞相将runnext设置为0，
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 当前P可以将其设置为非 0。 因此，如果该 CAS 失败，则无需重试。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nx">next</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">_p_</span><span class="p">.</span><span class="nx">runnext</span><span class="p">.</span><span class="nf">cas</span><span class="p">(</span><span class="nx">next</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 从 p.runnext上取出的goroutine，都继承了上次的时间片
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// channel 的send和recv操作都会把goroutine挂在 p.runnext 上
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">return</span> <span class="nx">next</span><span class="p">.</span><span class="nf">ptr</span><span class="p">(),</span> <span class="kc">true</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// p.runnext == 0 || 当前goroutine已被窃取。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">for</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 原子读取 _p_.runqhead。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 当前P和其他P来偷取goroutine都是从runqhead开始的，因此需要原子读取。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">h</span> <span class="o">:=</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">LoadAcq</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">_p_</span><span class="p">.</span><span class="nx">runqhead</span><span class="p">)</span> <span class="c1">// load-acquire, synchronize with other consumers
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// runqtail：只有本地P会修改这个值加入goroutine。当前P在此操作因此runqtail不会改变不需原子操作。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">t</span> <span class="o">:=</span> <span class="nx">_p_</span><span class="p">.</span><span class="nx">runqtail</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 本地P队列为空。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="nx">t</span> <span class="o">==</span> <span class="nx">h</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="kc">false</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="c1">//  取出当前h位置上的g，注意循环队列是通过runqhead和runqtail不断的累加然后通过求余判断位置的
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 由于runqhead和runqtail都是uint32类型循环数组大小为256正好是整倍数，
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 因此uint32不断累计最后会从0又开始，形成一个循环
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">gp</span> <span class="o">:=</span> <span class="nx">_p_</span><span class="p">.</span><span class="nx">runq</span><span class="p">[</span><span class="nx">h</span><span class="o">%</span><span class="nb">uint32</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">_p_</span><span class="p">.</span><span class="nx">runq</span><span class="p">))].</span><span class="nf">ptr</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// CAS 设置 _p_.runqhead，这段时间可能 _p_.runqhead 的值发生变化而失败。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">CasRel</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">_p_</span><span class="p">.</span><span class="nx">runqhead</span><span class="p">,</span> <span class="nx">h</span><span class="p">,</span> <span class="nx">h</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// cas-release, commits consume
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="k">return</span> <span class="nx">gp</span><span class="p">,</span> <span class="kc">false</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="injectglist">injectglist()<a hidden class="anchor" aria-hidden="true" href="#injectglist">#</a></h3>
<ol>
<li><code>injectglist</code> 将列表上的每个可运行的<code>G</code>添加到某个运行队列，并清除<code>glist</code>。</li>
<li>如果当前不存在<code>P</code>，则将它们添加到全局队列，并启动多达<code>npim</code>个队列来运行它们。</li>
<li>否则，对于每个空闲的<code>P</code>，将<code>G</code>添加到全局队列，并启动一个<code>m</code>。剩余的<code>G</code>添加到当前<code>P</code>的本地就绪队列。</li>
<li>这可能会临时获取<code>sched.lock</code>。可以与<code>GC</code>并发运行。</li>
<li>该函数在<code>netpoll</code>后调用，可以是监控线程中这种情况下没有<code>P</code>，或则调度循环中。</li>
<li>文件位置：<code>go1.19.3/src/runtime/proc.go</code>。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">3113
</span><span class="lnt">3114
</span><span class="lnt">3115
</span><span class="lnt">3116
</span><span class="lnt">3117
</span><span class="lnt">3118
</span><span class="lnt">3119
</span><span class="lnt">3120
</span><span class="lnt">3121
</span><span class="lnt">3122
</span><span class="lnt">3123
</span><span class="lnt">3124
</span><span class="lnt">3125
</span><span class="lnt">3126
</span><span class="lnt">3127
</span><span class="lnt">3128
</span><span class="lnt">3129
</span><span class="lnt">3130
</span><span class="lnt">3131
</span><span class="lnt">3132
</span><span class="lnt">3133
</span><span class="lnt">3134
</span><span class="lnt">3135
</span><span class="lnt">3136
</span><span class="lnt">3137
</span><span class="lnt">3138
</span><span class="lnt">3139
</span><span class="lnt">3140
</span><span class="lnt">3141
</span><span class="lnt">3142
</span><span class="lnt">3143
</span><span class="lnt">3144
</span><span class="lnt">3145
</span><span class="lnt">3146
</span><span class="lnt">3147
</span><span class="lnt">3148
</span><span class="lnt">3149
</span><span class="lnt">3150
</span><span class="lnt">3151
</span><span class="lnt">3152
</span><span class="lnt">3153
</span><span class="lnt">3154
</span><span class="lnt">3155
</span><span class="lnt">3156
</span><span class="lnt">3157
</span><span class="lnt">3158
</span><span class="lnt">3159
</span><span class="lnt">3160
</span><span class="lnt">3161
</span><span class="lnt">3162
</span><span class="lnt">3163
</span><span class="lnt">3164
</span><span class="lnt">3165
</span><span class="lnt">3166
</span><span class="lnt">3167
</span><span class="lnt">3168
</span><span class="lnt">3169
</span><span class="lnt">3170
</span><span class="lnt">3171
</span><span class="lnt">3172
</span><span class="lnt">3173
</span><span class="lnt">3174
</span><span class="lnt">3175
</span><span class="lnt">3176
</span><span class="lnt">3177
</span><span class="lnt">3178
</span><span class="lnt">3179
</span><span class="lnt">3180
</span><span class="lnt">3181
</span><span class="lnt">3182
</span><span class="lnt">3183
</span><span class="lnt">3184
</span><span class="lnt">3185
</span><span class="lnt">3186
</span><span class="lnt">3187
</span><span class="lnt">3188
</span><span class="lnt">3189
</span><span class="lnt">3190
</span><span class="lnt">3191
</span><span class="lnt">3192
</span><span class="lnt">3193
</span><span class="lnt">3194
</span><span class="lnt">3195
</span><span class="lnt">3196
</span><span class="lnt">3197
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// injectglist adds each runnable G on the list to some run queue,
</span></span></span><span class="line"><span class="cl"><span class="c1">// and clears glist. If there is no current P, they are added to the
</span></span></span><span class="line"><span class="cl"><span class="c1">// global queue, and up to npidle M&#39;s are started to run them.
</span></span></span><span class="line"><span class="cl"><span class="c1">// Otherwise, for each idle P, this adds a G to the global queue
</span></span></span><span class="line"><span class="cl"><span class="c1">// and starts an M. Any remaining G&#39;s are added to the current P&#39;s
</span></span></span><span class="line"><span class="cl"><span class="c1">// local run queue.
</span></span></span><span class="line"><span class="cl"><span class="c1">// This may temporarily acquire sched.lock.
</span></span></span><span class="line"><span class="cl"><span class="c1">// Can run concurrently with GC.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">injectglist</span><span class="p">(</span><span class="nx">glist</span> <span class="o">*</span><span class="nx">gList</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// goroutine 空列表
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nx">glist</span><span class="p">.</span><span class="nf">empty</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">trace</span><span class="p">.</span><span class="nx">enabled</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="nx">gp</span> <span class="o">:=</span> <span class="nx">glist</span><span class="p">.</span><span class="nx">head</span><span class="p">.</span><span class="nf">ptr</span><span class="p">();</span> <span class="nx">gp</span> <span class="o">!=</span> <span class="kc">nil</span><span class="p">;</span> <span class="nx">gp</span> <span class="p">=</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">schedlink</span><span class="p">.</span><span class="nf">ptr</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nf">traceGoUnpark</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// Mark all the goroutines as runnable before we put them
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// on the run queues.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">head</span> <span class="o">:=</span> <span class="nx">glist</span><span class="p">.</span><span class="nx">head</span><span class="p">.</span><span class="nf">ptr</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="kd">var</span> <span class="nx">tail</span> <span class="o">*</span><span class="nx">g</span> <span class="c1">// 获取队列最后一个 goroutine
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">qsize</span> <span class="o">:=</span> <span class="mi">0</span> <span class="c1">// 记录goroutine数量
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 修改这些goroutine的状态
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">for</span> <span class="nx">gp</span> <span class="o">:=</span> <span class="nx">head</span><span class="p">;</span> <span class="nx">gp</span> <span class="o">!=</span> <span class="kc">nil</span><span class="p">;</span> <span class="nx">gp</span> <span class="p">=</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">schedlink</span><span class="p">.</span><span class="nf">ptr</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">tail</span> <span class="p">=</span> <span class="nx">gp</span>
</span></span><span class="line"><span class="cl">        <span class="nx">qsize</span><span class="o">++</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// _Gwaiting：goroutine阻塞在runtime中，没有执行用户代码。它不在任何runq中，但是应该被记录在其他地方。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// _Grunnable：goroutine应该在某个runq中，当前并没有在运行用户代码，它的栈不归自己所有。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nf">casgstatus</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="nx">_Gwaiting</span><span class="p">,</span> <span class="nx">_Grunnable</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// Turn the gList into a gQueue.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 将这个gList转换为一个gQueue。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kd">var</span> <span class="nx">q</span> <span class="nx">gQueue</span> <span class="c1">// 双向链表
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">q</span><span class="p">.</span><span class="nx">head</span><span class="p">.</span><span class="nf">set</span><span class="p">(</span><span class="nx">head</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nx">q</span><span class="p">.</span><span class="nx">tail</span><span class="p">.</span><span class="nf">set</span><span class="p">(</span><span class="nx">tail</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="o">*</span><span class="nx">glist</span> <span class="p">=</span> <span class="nx">gList</span><span class="p">{}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nx">startIdle</span> <span class="o">:=</span> <span class="kd">func</span><span class="p">(</span><span class="nx">n</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 指定数量的空闲P起来工作
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">for</span> <span class="p">;</span> <span class="nx">n</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">sched</span><span class="p">.</span><span class="nx">npidle</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">n</span><span class="o">--</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nf">startm</span><span class="p">(</span><span class="kc">nil</span><span class="p">,</span> <span class="kc">false</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nx">pp</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">().</span><span class="nx">m</span><span class="p">.</span><span class="nx">p</span><span class="p">.</span><span class="nf">ptr</span><span class="p">()</span> <span class="c1">// pp
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 如果来自sysmon监控线程，pp = nil。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nx">pp</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 放入全局 sched.runq 池中
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nf">globrunqputbatch</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">q</span><span class="p">,</span> <span class="nb">int32</span><span class="p">(</span><span class="nx">qsize</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">        <span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 唤醒qsize多个空闲P来处理这些goroutine
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nf">startIdle</span><span class="p">(</span><span class="nx">qsize</span><span class="p">)</span> 
</span></span><span class="line"><span class="cl">        <span class="k">return</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 以下是存在P的情况
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    
</span></span><span class="line"><span class="cl">    <span class="c1">// 空闲的P的数量
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">npidle</span> <span class="o">:=</span> <span class="nb">int</span><span class="p">(</span><span class="nx">atomic</span><span class="p">.</span><span class="nf">Load</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">npidle</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">    <span class="kd">var</span> <span class="nx">globq</span> <span class="nx">gQueue</span>
</span></span><span class="line"><span class="cl">    <span class="kd">var</span> <span class="nx">n</span> <span class="kt">int</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 把空闲P数量个数的goroutine放入全局池中，然后唤醒P起来工作
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">for</span> <span class="nx">n</span> <span class="p">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">n</span> <span class="p">&lt;</span> <span class="nx">npidle</span> <span class="o">&amp;&amp;</span> <span class="p">!</span><span class="nx">q</span><span class="p">.</span><span class="nf">empty</span><span class="p">();</span> <span class="nx">n</span><span class="o">++</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">g</span> <span class="o">:=</span> <span class="nx">q</span><span class="p">.</span><span class="nf">pop</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">        <span class="nx">globq</span><span class="p">.</span><span class="nf">pushBack</span><span class="p">(</span><span class="nx">g</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">n</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 放入全局 sched.runq 池中
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nf">globrunqputbatch</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">globq</span><span class="p">,</span> <span class="nb">int32</span><span class="p">(</span><span class="nx">n</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">        <span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 唤醒qsize多个空闲P来处理这些goroutine
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nf">startIdle</span><span class="p">(</span><span class="nx">n</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="nx">qsize</span> <span class="o">-=</span> <span class="nx">n</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">!</span><span class="nx">q</span><span class="p">.</span><span class="nf">empty</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 还剩的goroutine放入本地队列中
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nf">runqputbatch</span><span class="p">(</span><span class="nx">pp</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">q</span><span class="p">,</span> <span class="nx">qsize</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="stealwork">stealWork()<a hidden class="anchor" aria-hidden="true" href="#stealwork">#</a></h3>
<ol>
<li><code>stealWork</code>试图从任何<code>P</code>中窃取一个可运行的<code>goroutine</code>或<code>timer</code>。</li>
<li>如果返回值<code>newWork</code>为<code>true</code>，则新工作可能已经准备好了。</li>
<li>如果<code>now</code>不是0，则为当前时间。<code>stealWork</code>返回经过的时间，如果<code>now</code>被传递为0，则返回当前时间。</li>
<li>参数<code>now int64</code>：不是 0，则为当前时间。</li>
<li>返回值：
<ol>
<li><code>gp *g</code>：获取到的<code>goroutine</code>。</li>
<li><code>inheritTime bool</code>：是否继承当前时间片。</li>
<li><code>rnow int64</code>：获取时间点。</li>
<li><code>pollUntil int64</code>：<code>timer</code>的触发时间点。</li>
<li><code>newWork bool</code>：为 true，则新工作可能已经准备好了。会跳转到findRunnable函数top标签处从新开始。</li>
</ol>
</li>
<li>窃取逻辑会循环尝试4次，最后一次才会窃取<code>runnext</code>和<code>timer</code>，也就是说前3次只会从其他<code>P</code>的本地<code>runq</code>中窃取。</li>
<li><code>stealOrder</code>用来实现一个公平的随机窃取顺序，<code>timerpMask</code>和<code>idlepMask</code>用来快速判断指定位置的<code>P</code>是否有<code>timer</code>或是空闲。</li>
<li>文件位置：<code>go1.19.3/src/runtime/proc.go</code>。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">2899
</span><span class="lnt">2900
</span><span class="lnt">2901
</span><span class="lnt">2902
</span><span class="lnt">2903
</span><span class="lnt">2904
</span><span class="lnt">2905
</span><span class="lnt">2906
</span><span class="lnt">2907
</span><span class="lnt">2908
</span><span class="lnt">2909
</span><span class="lnt">2910
</span><span class="lnt">2911
</span><span class="lnt">2912
</span><span class="lnt">2913
</span><span class="lnt">2914
</span><span class="lnt">2915
</span><span class="lnt">2916
</span><span class="lnt">2917
</span><span class="lnt">2918
</span><span class="lnt">2919
</span><span class="lnt">2920
</span><span class="lnt">2921
</span><span class="lnt">2922
</span><span class="lnt">2923
</span><span class="lnt">2924
</span><span class="lnt">2925
</span><span class="lnt">2926
</span><span class="lnt">2927
</span><span class="lnt">2928
</span><span class="lnt">2929
</span><span class="lnt">2930
</span><span class="lnt">2931
</span><span class="lnt">2932
</span><span class="lnt">2933
</span><span class="lnt">2934
</span><span class="lnt">2935
</span><span class="lnt">2936
</span><span class="lnt">2937
</span><span class="lnt">2938
</span><span class="lnt">2939
</span><span class="lnt">2940
</span><span class="lnt">2941
</span><span class="lnt">2942
</span><span class="lnt">2943
</span><span class="lnt">2944
</span><span class="lnt">2945
</span><span class="lnt">2946
</span><span class="lnt">2947
</span><span class="lnt">2948
</span><span class="lnt">2949
</span><span class="lnt">2950
</span><span class="lnt">2951
</span><span class="lnt">2952
</span><span class="lnt">2953
</span><span class="lnt">2954
</span><span class="lnt">2955
</span><span class="lnt">2956
</span><span class="lnt">2957
</span><span class="lnt">2958
</span><span class="lnt">2959
</span><span class="lnt">2960
</span><span class="lnt">2961
</span><span class="lnt">2962
</span><span class="lnt">2963
</span><span class="lnt">2964
</span><span class="lnt">2965
</span><span class="lnt">2966
</span><span class="lnt">2967
</span><span class="lnt">2968
</span><span class="lnt">2969
</span><span class="lnt">2970
</span><span class="lnt">2971
</span><span class="lnt">2972
</span><span class="lnt">2973
</span><span class="lnt">2974
</span><span class="lnt">2975
</span><span class="lnt">2976
</span><span class="lnt">2977
</span><span class="lnt">2978
</span><span class="lnt">2979
</span><span class="lnt">2980
</span><span class="lnt">2981
</span><span class="lnt">2982
</span><span class="lnt">2983
</span><span class="lnt">2984
</span><span class="lnt">2985
</span><span class="lnt">2986
</span><span class="lnt">2987
</span><span class="lnt">2988
</span><span class="lnt">2989
</span><span class="lnt">2990
</span><span class="lnt">2991
</span><span class="lnt">2992
</span><span class="lnt">2993
</span><span class="lnt">2994
</span><span class="lnt">2995
</span><span class="lnt">2996
</span><span class="lnt">2997
</span><span class="lnt">2998
</span><span class="lnt">2999
</span><span class="lnt">3000
</span><span class="lnt">3001
</span><span class="lnt">3002
</span><span class="lnt">3003
</span><span class="lnt">3004
</span><span class="lnt">3005
</span><span class="lnt">3006
</span><span class="lnt">3007
</span><span class="lnt">3008
</span><span class="lnt">3009
</span><span class="lnt">3010
</span><span class="lnt">3011
</span><span class="lnt">3012
</span><span class="lnt">3013
</span><span class="lnt">3014
</span><span class="lnt">3015
</span><span class="lnt">3016
</span><span class="lnt">3017
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// stealWork attempts to steal a runnable goroutine or timer from any P.
</span></span></span><span class="line"><span class="cl"><span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1">// If newWork is true, new work may have been readied.
</span></span></span><span class="line"><span class="cl"><span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1">// If now is not 0 it is the current time. stealWork returns the passed time or
</span></span></span><span class="line"><span class="cl"><span class="c1">// the current time if now was passed as 0.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">stealWork</span><span class="p">(</span><span class="nx">now</span> <span class="kt">int64</span><span class="p">)</span> <span class="p">(</span><span class="nx">gp</span> <span class="o">*</span><span class="nx">g</span><span class="p">,</span> <span class="nx">inheritTime</span> <span class="kt">bool</span><span class="p">,</span> <span class="nx">rnow</span><span class="p">,</span> <span class="nx">pollUntil</span> <span class="kt">int64</span><span class="p">,</span> <span class="nx">newWork</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">pp</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">().</span><span class="nx">m</span><span class="p">.</span><span class="nx">p</span><span class="p">.</span><span class="nf">ptr</span><span class="p">()</span> <span class="c1">// pp = p
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="nx">ranTimer</span> <span class="o">:=</span> <span class="kc">false</span> <span class="c1">// newWork 的返回值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 尝试偷取最大次数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kd">const</span> <span class="nx">stealTries</span> <span class="p">=</span> <span class="mi">4</span> 
</span></span><span class="line"><span class="cl">    <span class="c1">// 执行四次遍历，就是尽最大努力去其他P中查看
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">stealTries</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 最后一次时：
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">//  1. 前三次尝试去P的runq本地队列中偷取goroutine。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">//  2. 最后一次先去各个P的timers里看看，然后当偷取的P的runq为空时，
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">//     尝试偷取P.runnext上的goroutine。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">stealTimersOrRunNextG</span> <span class="o">:=</span> <span class="nx">i</span> <span class="o">==</span> <span class="nx">stealTries</span><span class="o">-</span><span class="mi">1</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// randomOrder/randomEnum 是随机工作窃取的辅助类型，一轮allp遍历开始。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 它们允许以不同的伪随机顺序枚举所有 P 而不重复。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 该算法基于这样一个事实：
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">//   如果我们有X使得X和GOMAXPROCS互质，那么(i + X)%GOMAXPROCS的序列给出所需的枚举。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// stealOrder.start(fastrand())：从一个随机位置开始。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// !enum.done()：当前是否已经遍历一圈了。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// enum.next()：跳转到下一个位置。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">for</span> <span class="nx">enum</span> <span class="o">:=</span> <span class="nx">stealOrder</span><span class="p">.</span><span class="nf">start</span><span class="p">(</span><span class="nf">fastrand</span><span class="p">());</span> <span class="p">!</span><span class="nx">enum</span><span class="p">.</span><span class="nf">done</span><span class="p">();</span> <span class="nx">enum</span><span class="p">.</span><span class="nf">next</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 有STW正在等待P挂起。直接返回。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// 跳转到findRunnable函数top标签处从新开始。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="k">if</span> <span class="nx">sched</span><span class="p">.</span><span class="nx">gcwaiting</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="c1">// GC work may be available.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="kc">false</span><span class="p">,</span> <span class="nx">now</span><span class="p">,</span> <span class="nx">pollUntil</span><span class="p">,</span> <span class="kc">true</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">            
</span></span><span class="line"><span class="cl">            <span class="c1">// 随机选的p，如果是当前的跳过。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// enum.position()：当前偷取P的下标。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="nx">p2</span> <span class="o">:=</span> <span class="nx">allp</span><span class="p">[</span><span class="nx">enum</span><span class="p">.</span><span class="nf">position</span><span class="p">()]</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="nx">pp</span> <span class="o">==</span> <span class="nx">p2</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="k">continue</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            <span class="c1">// Steal timers from p2. This call to checkTimers is the only place
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// where we might hold a lock on a different P&#39;s timers. We do this
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// once on the last pass before checking runnext because stealing
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// from the other P&#39;s runnext should be the last resort, so if there
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// are timers to steal do that first.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// We only check timers on one of the stealing iterations because
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// the time stored in now doesn&#39;t change in this loop and checking
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// the timers for each P more than once with the same value of now
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// is probably a waste of time.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// timerpMask tells us whether the P may have timers at all. If it
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// can&#39;t, no need to check at all.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// 从p2中窃取 timers。对checkTimers的调用是唯一可以对不同P的timers持有锁的地方。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// 我们在检查runnext之前的最后一遍执行此操作，因为从另一个P的runnext中窃取计时器应该是最后的手段，
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// 所以如果有timers可以窃取，请先窃取。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// 我们只检查其中一个窃取迭代的定时器，因为存储在now中的时间在这个循环中不会改变，
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// 如果用相同的now值多次检查每个P的定时器，可能就是浪费时间。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// timerpMask告诉我们P是否有定时器。如果它不能，根本不需要检查。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// timerpMask 是P的位图记录当前P上是否有 timer。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="k">if</span> <span class="nx">stealTimersOrRunNextG</span> <span class="o">&amp;&amp;</span> <span class="nx">timerpMask</span><span class="p">.</span><span class="nf">read</span><span class="p">(</span><span class="nx">enum</span><span class="p">.</span><span class="nf">position</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="c1">// 再次看看 timers，是否有到点需要执行的timer。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="c1">//   tnow：返回的now
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="c1">//   w：触发时间点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="c1">//   ran：timer是否已经运行了
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="c1">// 如果ran为true，表示checkTimers()执行了p2的timer，
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="c1">// 可能会使某些goroutine变成_Grunnable状态，
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="c1">// 所以先检查当前P的本地runq，如果没有找到继续去偷取。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="nx">tnow</span><span class="p">,</span> <span class="nx">w</span><span class="p">,</span> <span class="nx">ran</span> <span class="o">:=</span> <span class="nf">checkTimers</span><span class="p">(</span><span class="nx">p2</span><span class="p">,</span> <span class="nx">now</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                <span class="nx">now</span> <span class="p">=</span> <span class="nx">tnow</span>
</span></span><span class="line"><span class="cl">                <span class="c1">// w != 0：还未触发的时间点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="c1">// pollUntil == 0：上次检查没有timer
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="c1">// w &lt; pollUntil：触发时间点缩小
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="k">if</span> <span class="nx">w</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="nx">pollUntil</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="nx">w</span> <span class="p">&lt;</span> <span class="nx">pollUntil</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                    <span class="nx">pollUntil</span> <span class="p">=</span> <span class="nx">w</span> <span class="c1">// 最近的timer触发的时间点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="p">}</span>
</span></span><span class="line"><span class="cl">                <span class="c1">// 有触发timer运行，需要去P的本地runq中去找找可能有goroutine被放里面了。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="c1">// 比如time.Sleep。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="k">if</span> <span class="nx">ran</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                    <span class="c1">// Running the timers may have
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                    <span class="c1">// made an arbitrary number of G&#39;s
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                    <span class="c1">// ready and added them to this P&#39;s
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                    <span class="c1">// local run queue. That invalidates
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                    <span class="c1">// the assumption of runqsteal
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                    <span class="c1">// that it always has room to add
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                    <span class="c1">// stolen G&#39;s. So check now if there
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                    <span class="c1">// is a local G to run.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                    <span class="k">if</span> <span class="nx">gp</span><span class="p">,</span> <span class="nx">inheritTime</span> <span class="o">:=</span> <span class="nf">runqget</span><span class="p">(</span><span class="nx">pp</span><span class="p">);</span> <span class="nx">gp</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                        <span class="k">return</span> <span class="nx">gp</span><span class="p">,</span> <span class="nx">inheritTime</span><span class="p">,</span> <span class="nx">now</span><span class="p">,</span> <span class="nx">pollUntil</span><span class="p">,</span> <span class="nx">ranTimer</span>
</span></span><span class="line"><span class="cl">                    <span class="p">}</span>
</span></span><span class="line"><span class="cl">                    <span class="c1">// 标记为true，再次跑一边调度循环
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                    <span class="nx">ranTimer</span> <span class="p">=</span> <span class="kc">true</span>
</span></span><span class="line"><span class="cl">                <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            <span class="c1">// Don&#39;t bother to attempt to steal if p2 is idle.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// 如果p2是空闲的不要尝试偷取。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// 在创建goroutine时候我们遇见过idlepMask，该值是P的位图，记录了所有空闲的P的bit位(原子更新)。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// idlepMask.read(enum.position())：true.当前P是空闲的，false.当前P不是空闲的。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="k">if</span> <span class="p">!</span><span class="nx">idlepMask</span><span class="p">.</span><span class="nf">read</span><span class="p">(</span><span class="nx">enum</span><span class="p">.</span><span class="nf">position</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="c1">// runqsteal 函数从p2中偷取goroutine到pp中。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="c1">// stealTimersOrRunNextG表示最大程度偷取runnext。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="k">if</span> <span class="nx">gp</span> <span class="o">:=</span> <span class="nf">runqsteal</span><span class="p">(</span><span class="nx">pp</span><span class="p">,</span> <span class="nx">p2</span><span class="p">,</span> <span class="nx">stealTimersOrRunNextG</span><span class="p">);</span> <span class="nx">gp</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                    <span class="k">return</span> <span class="nx">gp</span><span class="p">,</span> <span class="kc">false</span><span class="p">,</span> <span class="nx">now</span><span class="p">,</span> <span class="nx">pollUntil</span><span class="p">,</span> <span class="nx">ranTimer</span>
</span></span><span class="line"><span class="cl">                <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// No goroutines found to steal. Regardless, running a timer may have
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// made some goroutine ready that we missed. Indicate the next timer to
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// wait for.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="kc">false</span><span class="p">,</span> <span class="nx">now</span><span class="p">,</span> <span class="nx">pollUntil</span><span class="p">,</span> <span class="nx">ranTimer</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="runqsteal">runqsteal()<a hidden class="anchor" aria-hidden="true" href="#runqsteal">#</a></h4>
<ol>
<li>从<code>p2</code>的本地可运行队列中窃取一半的<code>g</code>，并放入<code>p</code>的本地可运行队列中。</li>
<li>返回一个被窃取的<code>g</code>(如果失败则返回<code>nil</code>)。</li>
<li>参数：
<ul>
<li><code>_p_ *p</code>：当前窃取其他<code>P</code>的工作线程绑定的<code>P</code>。</li>
<li><code>p2 *p</code>：被窃取的<code>P</code>。</li>
<li><code>stealRunNextG bool</code>：<code>true</code>尽最大努力去<code>p.runnext</code>上偷取，<code>false</code>不偷取<code>p.runnext</code>的<code>goroutine</code>。</li>
</ul>
</li>
<li>返回值<code>*g</code>：偷取到的<code>goroutine</code>。</li>
<li>文件位置：<code>go1.19.3/src/runtime/proc.go</code>。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">6015
</span><span class="lnt">6016
</span><span class="lnt">6017
</span><span class="lnt">6018
</span><span class="lnt">6019
</span><span class="lnt">6020
</span><span class="lnt">6021
</span><span class="lnt">6022
</span><span class="lnt">6023
</span><span class="lnt">6024
</span><span class="lnt">6025
</span><span class="lnt">6026
</span><span class="lnt">6027
</span><span class="lnt">6028
</span><span class="lnt">6029
</span><span class="lnt">6030
</span><span class="lnt">6031
</span><span class="lnt">6032
</span><span class="lnt">6033
</span><span class="lnt">6034
</span><span class="lnt">6035
</span><span class="lnt">6036
</span><span class="lnt">6037
</span><span class="lnt">6038
</span><span class="lnt">6039
</span><span class="lnt">6040
</span><span class="lnt">6041
</span><span class="lnt">6042
</span><span class="lnt">6043
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// Steal half of elements from local runnable queue of p2
</span></span></span><span class="line"><span class="cl"><span class="c1">// and put onto local runnable queue of p.
</span></span></span><span class="line"><span class="cl"><span class="c1">// Returns one of the stolen elements (or nil if failed).
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">runqsteal</span><span class="p">(</span><span class="nx">_p_</span><span class="p">,</span> <span class="nx">p2</span> <span class="o">*</span><span class="nx">p</span><span class="p">,</span> <span class="nx">stealRunNextG</span> <span class="kt">bool</span><span class="p">)</span> <span class="o">*</span><span class="nx">g</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">t</span> <span class="o">:=</span> <span class="nx">_p_</span><span class="p">.</span><span class="nx">runqtail</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 尝试从p2中偷取一半的goroutine。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">n</span> <span class="o">:=</span> <span class="nf">runqgrab</span><span class="p">(</span><span class="nx">p2</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">_p_</span><span class="p">.</span><span class="nx">runq</span><span class="p">,</span> <span class="nx">t</span><span class="p">,</span> <span class="nx">stealRunNextG</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// p2中也没有
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nx">n</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 从p的本地runq中取出一个goroutine，用于返回给调度器调度起来。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">n</span><span class="o">--</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 因为偷取是从runqtail开始的，因此runqtail处也是head头处。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 其实是取的队列中的最后一个，方便后面 StoreRel 原子操作设置 runqtail 值。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">gp</span> <span class="o">:=</span> <span class="nx">_p_</span><span class="p">.</span><span class="nx">runq</span><span class="p">[(</span><span class="nx">t</span><span class="o">+</span><span class="nx">n</span><span class="p">)</span><span class="o">%</span><span class="nb">uint32</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">_p_</span><span class="p">.</span><span class="nx">runq</span><span class="p">))].</span><span class="nf">ptr</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">n</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="nx">gp</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 还有其他的需要处理，原子读取 _p_.runqhead
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">h</span> <span class="o">:=</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">LoadAcq</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">_p_</span><span class="p">.</span><span class="nx">runqhead</span><span class="p">)</span> <span class="c1">// load-acquire, synchronize with consumers
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 这里判断偷取的g是否大于P本地的一半数量，则是溢出了
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nx">t</span><span class="o">-</span><span class="nx">h</span><span class="o">+</span><span class="nx">n</span> <span class="o">&gt;=</span> <span class="nb">uint32</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">_p_</span><span class="p">.</span><span class="nx">runq</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">throw</span><span class="p">(</span><span class="s">&#34;runqsteal: runq overflow&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 原子设置 _p_.runqtail = t+n
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">atomic</span><span class="p">.</span><span class="nf">StoreRel</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">_p_</span><span class="p">.</span><span class="nx">runqtail</span><span class="p">,</span> <span class="nx">t</span><span class="o">+</span><span class="nx">n</span><span class="p">)</span> <span class="c1">// store-release, makes the item available for consumption
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">return</span> <span class="nx">gp</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="runqgrab">runqgrab()<a hidden class="anchor" aria-hidden="true" href="#runqgrab">#</a></h4>
<ol>
<li>从<code>_p_</code>的可运行队列中获取一批<code>goroutines</code>到<code>batch</code>。</li>
<li><code>Batch</code>是一个从<code>batchHead</code>开始的环形缓冲区。</li>
<li>返回抓取的<code>goroutines</code>的数量。可以被任意<code>P</code>执行。</li>
<li>参数：假设从<code>p2</code>偷取到<code>p</code>。
<ol>
<li><code>_p_ *p</code>：偷取目标的P。就是p2.</li>
<li><code>batch *[256]guintptr</code>：从<code>_p_</code>偷取<code>goroutine</code>需要放到的<code>P</code>的<code>runq</code>本地队列池。就是p的本地<code>runq</code>池。</li>
<li><code>batchHead uint32</code>：<code>p</code>的<code>runqtail</code>处。</li>
<li><code>stealRunNextG bool</code>：是否近最大努力去<code>runnext</code>上偷取。</li>
</ol>
</li>
<li>返回值：<code>uint32</code>：偷取<code>goroutine</code>的数量。</li>
<li>文件位置：<code>go1.19.3/src/runtime/proc.go</code>。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">5959
</span><span class="lnt">5960
</span><span class="lnt">5961
</span><span class="lnt">5962
</span><span class="lnt">5963
</span><span class="lnt">5964
</span><span class="lnt">5965
</span><span class="lnt">5966
</span><span class="lnt">5967
</span><span class="lnt">5968
</span><span class="lnt">5969
</span><span class="lnt">5970
</span><span class="lnt">5971
</span><span class="lnt">5972
</span><span class="lnt">5973
</span><span class="lnt">5974
</span><span class="lnt">5975
</span><span class="lnt">5976
</span><span class="lnt">5977
</span><span class="lnt">5978
</span><span class="lnt">5979
</span><span class="lnt">5980
</span><span class="lnt">5981
</span><span class="lnt">5982
</span><span class="lnt">5983
</span><span class="lnt">5984
</span><span class="lnt">5985
</span><span class="lnt">5986
</span><span class="lnt">5987
</span><span class="lnt">5988
</span><span class="lnt">5989
</span><span class="lnt">5990
</span><span class="lnt">5991
</span><span class="lnt">5992
</span><span class="lnt">5993
</span><span class="lnt">5994
</span><span class="lnt">5995
</span><span class="lnt">5996
</span><span class="lnt">5997
</span><span class="lnt">5998
</span><span class="lnt">5999
</span><span class="lnt">6000
</span><span class="lnt">6001
</span><span class="lnt">6002
</span><span class="lnt">6003
</span><span class="lnt">6004
</span><span class="lnt">6005
</span><span class="lnt">6006
</span><span class="lnt">6007
</span><span class="lnt">6008
</span><span class="lnt">6009
</span><span class="lnt">6010
</span><span class="lnt">6011
</span><span class="lnt">6012
</span><span class="lnt">6013
</span><span class="lnt">6014
</span><span class="lnt">6015
</span><span class="lnt">6016
</span><span class="lnt">6017
</span><span class="lnt">6018
</span><span class="lnt">6019
</span><span class="lnt">6020
</span><span class="lnt">6021
</span><span class="lnt">6022
</span><span class="lnt">6023
</span><span class="lnt">6024
</span><span class="lnt">6025
</span><span class="lnt">6026
</span><span class="lnt">6027
</span><span class="lnt">6028
</span><span class="lnt">6029
</span><span class="lnt">6030
</span><span class="lnt">6031
</span><span class="lnt">6032
</span><span class="lnt">6033
</span><span class="lnt">6034
</span><span class="lnt">6035
</span><span class="lnt">6036
</span><span class="lnt">6037
</span><span class="lnt">6038
</span><span class="lnt">6039
</span><span class="lnt">6040
</span><span class="lnt">6041
</span><span class="lnt">6042
</span><span class="lnt">6043
</span><span class="lnt">6044
</span><span class="lnt">6045
</span><span class="lnt">6046
</span><span class="lnt">6047
</span><span class="lnt">6048
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// Grabs a batch of goroutines from _p_&#39;s runnable queue into batch.
</span></span></span><span class="line"><span class="cl"><span class="c1">// Batch is a ring buffer starting at batchHead.
</span></span></span><span class="line"><span class="cl"><span class="c1">// Returns number of grabbed goroutines.
</span></span></span><span class="line"><span class="cl"><span class="c1">// Can be executed by any P.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">runqgrab</span><span class="p">(</span><span class="nx">_p_</span> <span class="o">*</span><span class="nx">p</span><span class="p">,</span> <span class="nx">batch</span> <span class="o">*</span><span class="p">[</span><span class="mi">256</span><span class="p">]</span><span class="nx">guintptr</span><span class="p">,</span> <span class="nx">batchHead</span> <span class="kt">uint32</span><span class="p">,</span> <span class="nx">stealRunNextG</span> <span class="kt">bool</span><span class="p">)</span> <span class="kt">uint32</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 偷取goroutine的代码采用的是自旋方式，而没有采用锁来实现。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">for</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// _p_ 是 p2，之所以需要原子读取因为p2正在运行有并发的可能。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">h</span> <span class="o">:=</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">LoadAcq</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">_p_</span><span class="p">.</span><span class="nx">runqhead</span><span class="p">)</span> <span class="c1">// load-acquire, synchronize with other consumers
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">t</span> <span class="o">:=</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">LoadAcq</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">_p_</span><span class="p">.</span><span class="nx">runqtail</span><span class="p">)</span> <span class="c1">// load-acquire, synchronize with the producer
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 为什么不担心 runqtail 溢出？
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">//  因为，runqtail和runqhead都是uint32类型，就算溢出也能保证计算正确。比如 0 - 3 也能得到正确值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">n</span> <span class="o">:=</span> <span class="nx">t</span> <span class="o">-</span> <span class="nx">h</span>
</span></span><span class="line"><span class="cl">        <span class="nx">n</span> <span class="p">=</span> <span class="nx">n</span> <span class="o">-</span> <span class="nx">n</span><span class="o">/</span><span class="mi">2</span> <span class="c1">// 计算偷取的数量，为当前容量的一半。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// p2 中本地runq池中没有goroutine。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="nx">n</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// p2本地runq池为空，尝试去 runnext 获取goroutine。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="k">if</span> <span class="nx">stealRunNextG</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="c1">// Try to steal from _p_.runnext.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="c1">// 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="c1">// 尝试从 _p_.runnext 中偷取。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="k">if</span> <span class="nx">next</span> <span class="o">:=</span> <span class="nx">_p_</span><span class="p">.</span><span class="nx">runnext</span><span class="p">;</span> <span class="nx">next</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span> <span class="c1">// _p_.runnext 上有goroutine。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                    <span class="k">if</span> <span class="nx">_p_</span><span class="p">.</span><span class="nx">status</span> <span class="o">==</span> <span class="nx">_Prunning</span> <span class="p">{</span> <span class="c1">// 当前P正在运行中
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                        <span class="c1">// Sleep to ensure that _p_ isn&#39;t about to run the g
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                        <span class="c1">// we are about to steal.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                        <span class="c1">// The important use case here is when the g running
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                        <span class="c1">// on _p_ ready()s another g and then almost
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                        <span class="c1">// immediately blocks. Instead of stealing runnext
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                        <span class="c1">// in this window, back off to give _p_ a chance to
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                        <span class="c1">// schedule runnext. This will avoid thrashing gs
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                        <span class="c1">// between different Ps.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                        <span class="c1">// A sync chan send/recv takes ~50ns as of time of
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                        <span class="c1">// writing, so 3us gives ~50x overshoot.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                        <span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                        <span class="c1">// Sleep 已确保 _p_ 不会运行我们将要切取的g。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                        <span class="c1">// 这里的重要用例是当 g 在 _p_ ready() 上运行时，另一个 g 然后几乎立即阻塞。 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                        <span class="c1">// 不要在这个窗口期切取 runnext，而是退而求其次，让_p_有机会调度runnext。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                        <span class="c1">// 这将避免g在不同的Ps之间的抖动。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                        <span class="c1">// sync chan 的 send/recv 大约需要 ~50ns，所以给出 3us 大约是它的 50x 倍。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                        <span class="k">if</span> <span class="nx">GOOS</span> <span class="o">!=</span> <span class="s">&#34;windows&#34;</span> <span class="o">&amp;&amp;</span> <span class="nx">GOOS</span> <span class="o">!=</span> <span class="s">&#34;openbsd&#34;</span> <span class="o">&amp;&amp;</span> <span class="nx">GOOS</span> <span class="o">!=</span> <span class="s">&#34;netbsd&#34;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                            <span class="nf">usleep</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="c1">// sleep 3us
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                            <span class="c1">// On some platforms system timer granularity is
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                            <span class="c1">// 1-15ms, which is way too much for this
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                            <span class="c1">// optimization. So just yield.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                            <span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                            <span class="c1">// 在某些平台上，系统计时器粒度为1-15ms，这对于这种优化来说太过了。所以就屈服吧。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                            <span class="nf">osyield</span><span class="p">()</span> <span class="c1">// 在semaphore中有相关的介绍。会尝试让出CPU，让其他优先级更高的线程执行。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                        <span class="p">}</span>
</span></span><span class="line"><span class="cl">                    <span class="p">}</span>
</span></span><span class="line"><span class="cl">                    <span class="c1">// CAS 操作交换 _p_.runnext 尝试偷取 goroutine。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                    <span class="c1">// 大概率会失败从这里直接退出。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                    <span class="k">if</span> <span class="p">!</span><span class="nx">_p_</span><span class="p">.</span><span class="nx">runnext</span><span class="p">.</span><span class="nf">cas</span><span class="p">(</span><span class="nx">next</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                        <span class="k">continue</span>
</span></span><span class="line"><span class="cl">                    <span class="p">}</span>
</span></span><span class="line"><span class="cl">                    <span class="c1">// 偷取到goroutine把它放入P的本地runq池。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                    <span class="nx">batch</span><span class="p">[</span><span class="nx">batchHead</span><span class="o">%</span><span class="nb">uint32</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">batch</span><span class="p">))]</span> <span class="p">=</span> <span class="nx">next</span>
</span></span><span class="line"><span class="cl">                    <span class="k">return</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">                <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">        <span class="c1">// 读取不一致的 h 和 t 值。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">//  小细节：按理说队列中的goroutine个数最多就是len(_p_.runq)，所以n的最大值也就是len(_p_.runq)/2，
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 那为什么需要这个判断呢？
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 	原因：读取runqhead和runqtail是两个操作而非一个原子操作，当我们读取runqhead之后但还未读取runqtail之前，
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 如果有其它线程快速的在增加（这是完全有可能的，其它偷取者从队列中偷取goroutine会增加runqhead，
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 而队列的所有者往队列中添加goroutine会 增加runqtail）这两个值，则会导致我们读取出来的runqtail已经远远大于
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 我们之前读取出来放在局部变量h里面的runqhead了。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 也就是代码注释中所说的h和t已经不一致了，所以这里需要这个if判断来检测异常情况。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 如果 n &gt; uint32(len(_p_.runq)/2) 成立说明在t := atomic.LoadAcq(&amp;_p_.runqtail)代码后runqtail发生了变化。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="nx">n</span> <span class="p">&gt;</span> <span class="nb">uint32</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">_p_</span><span class="p">.</span><span class="nx">runq</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// read inconsistent h and t
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="k">continue</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 从p2中拷贝goroutine到p的runq本地池
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="nb">uint32</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">n</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nx">g</span> <span class="o">:=</span> <span class="nx">_p_</span><span class="p">.</span><span class="nx">runq</span><span class="p">[(</span><span class="nx">h</span><span class="o">+</span><span class="nx">i</span><span class="p">)</span><span class="o">%</span><span class="nb">uint32</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">_p_</span><span class="p">.</span><span class="nx">runq</span><span class="p">))]</span> <span class="c1">// 从p2的h处往后取goroutine
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="nx">batch</span><span class="p">[(</span><span class="nx">batchHead</span><span class="o">+</span><span class="nx">i</span><span class="p">)</span><span class="o">%</span><span class="nb">uint32</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">batch</span><span class="p">))]</span> <span class="p">=</span> <span class="nx">g</span><span class="c1">// 从p.runqtail往后最加
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// CAS 原子交换 p2.runqhead 从 h 修改为 h+n，如果失败说明h被修改了
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">//  1. 可能其他P也在偷取这个P的goroutine并且偷取成功了。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">//  2. 当前被偷取的这个P可能也在取runqhead出的goroutine来运行。导致runqhead变化。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 为什么不担心 runqtail 的值呢？而是只需要保证 runqhead 和 runqtail 一起是原子的呢？
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">//  因为，runqtail 只有当前P正最加，并且是递增的，能保证我们要去的数据n。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">CasRel</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">_p_</span><span class="p">.</span><span class="nx">runqhead</span><span class="p">,</span> <span class="nx">h</span><span class="p">,</span> <span class="nx">h</span><span class="o">+</span><span class="nx">n</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// cas-release, commits consume
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="k">return</span> <span class="nx">n</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div>

<p><details >
  <summary markdown="span">type randomOrder struct</summary>
  <blockquote>
<ol>
<li><code>stealOrder</code>用来实现一个公平的随机窃取顺序。</li>
<li>文件位置：<code>go1.19.3/src/runtime/proc.go</code>。</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// 关于取P得算法
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">var</span> <span class="nx">stealOrder</span> <span class="nx">randomOrder</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// randomOrder/randomEnum are helper types for randomized work stealing.
</span></span></span><span class="line"><span class="cl"><span class="c1">// They allow to enumerate all Ps in different pseudo-random orders without repetitions.
</span></span></span><span class="line"><span class="cl"><span class="c1">// The algorithm is based on the fact that if we have X such that X and GOMAXPROCS
</span></span></span><span class="line"><span class="cl"><span class="c1">// are coprime, then a sequences of (i + X) % GOMAXPROCS gives the required enumeration.
</span></span></span><span class="line"><span class="cl"><span class="c1">// 
</span></span></span><span class="line"><span class="cl"><span class="c1">// randomOrder/randomEnum 是随机工作窃取的辅助类型
</span></span></span><span class="line"><span class="cl"><span class="c1">// 它们允许以不同的伪随机顺序枚举所有 P 而不重复
</span></span></span><span class="line"><span class="cl"><span class="c1">// 该算法基于这样一个事实：
</span></span></span><span class="line"><span class="cl"><span class="c1">//    如果我们有 X 使得 X 和 GOMAXPROCS 互质，那么 (i + X) %GOMAXPROCS 的序列给出所需的枚举
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">type</span> <span class="nx">randomOrder</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">count</span>    <span class="kt">uint32</span>       <span class="c1">// 存储当前所有的P数量，也是CPU的核数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">coprimes</span> <span class="p">[]</span><span class="kt">uint32</span>     <span class="c1">// 存储与count互质数集
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">randomEnum</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">i</span>     <span class="kt">uint32</span>  <span class="c1">// 从0开始记录遍历的次数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">count</span> <span class="kt">uint32</span>  <span class="c1">// randomOrder.count
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">pos</span>   <span class="kt">uint32</span>  <span class="c1">// 当前在[0, count-1]范围的下标位置
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">inc</span>   <span class="kt">uint32</span>  <span class="c1">// 当前在randomOrder.coprimes中选取的值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 重置randomOrder
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">ord</span> <span class="o">*</span><span class="nx">randomOrder</span><span class="p">)</span> <span class="nf">reset</span><span class="p">(</span><span class="nx">count</span> <span class="kt">uint32</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">ord</span><span class="p">.</span><span class="nx">count</span> <span class="p">=</span> <span class="nx">count</span>	                <span class="c1">// 记录总个数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">ord</span><span class="p">.</span><span class="nx">coprimes</span> <span class="p">=</span> <span class="nx">ord</span><span class="p">.</span><span class="nx">coprimes</span><span class="p">[:</span><span class="mi">0</span><span class="p">]</span>   <span class="c1">// 清空coprimes
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="nb">uint32</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span> <span class="nx">i</span> <span class="o">&lt;=</span> <span class="nx">count</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="nf">gcd</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span> <span class="nx">count</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nx">ord</span><span class="p">.</span><span class="nx">coprimes</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">ord</span><span class="p">.</span><span class="nx">coprimes</span><span class="p">,</span> <span class="nx">i</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 生成互质数函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">gcd</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span> <span class="kt">uint32</span><span class="p">)</span> <span class="kt">uint32</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="nx">b</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">a</span><span class="p">,</span> <span class="nx">b</span> <span class="p">=</span> <span class="nx">b</span><span class="p">,</span> <span class="nx">a</span><span class="o">%</span><span class="nx">b</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nx">a</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 开始
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">ord</span> <span class="o">*</span><span class="nx">randomOrder</span><span class="p">)</span> <span class="nf">start</span><span class="p">(</span><span class="nx">i</span> <span class="kt">uint32</span><span class="p">)</span> <span class="nx">randomEnum</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nx">randomEnum</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">count</span><span class="p">:</span> <span class="nx">ord</span><span class="p">.</span><span class="nx">count</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="nx">pos</span><span class="p">:</span>   <span class="nx">i</span> <span class="o">%</span> <span class="nx">ord</span><span class="p">.</span><span class="nx">count</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="nx">inc</span><span class="p">:</span>   <span class="nx">ord</span><span class="p">.</span><span class="nx">coprimes</span><span class="p">[</span><span class="nx">i</span><span class="o">%</span><span class="nb">uint32</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">ord</span><span class="p">.</span><span class="nx">coprimes</span><span class="p">))],</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 当前是否遍历一圈了
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">enum</span> <span class="o">*</span><span class="nx">randomEnum</span><span class="p">)</span> <span class="nf">done</span><span class="p">()</span> <span class="kt">bool</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nx">enum</span><span class="p">.</span><span class="nx">i</span> <span class="o">==</span> <span class="nx">enum</span><span class="p">.</span><span class="nx">count</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 下一个互质数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">enum</span> <span class="o">*</span><span class="nx">randomEnum</span><span class="p">)</span> <span class="nf">next</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">enum</span><span class="p">.</span><span class="nx">i</span><span class="o">++</span>
</span></span><span class="line"><span class="cl">    <span class="nx">enum</span><span class="p">.</span><span class="nx">pos</span> <span class="p">=</span> <span class="p">(</span><span class="nx">enum</span><span class="p">.</span><span class="nx">pos</span> <span class="o">+</span> <span class="nx">enum</span><span class="p">.</span><span class="nx">inc</span><span class="p">)</span> <span class="o">%</span> <span class="nx">enum</span><span class="p">.</span><span class="nx">count</span>	<span class="c1">// 这里是随机的选取下一个随机处
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 获取当前位置
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">enum</span> <span class="o">*</span><span class="nx">randomEnum</span><span class="p">)</span> <span class="nf">position</span><span class="p">()</span> <span class="kt">uint32</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nx">enum</span><span class="p">.</span><span class="nx">pos</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 盗取算法解释
</span></span></span><span class="line"><span class="cl"><span class="c1">//  1. 盗取过程用了两个嵌套for循环。
</span></span></span><span class="line"><span class="cl"><span class="c1">//  2. 内层循环实现了盗取逻辑，从代码可以看出盗取的实质就是遍历allp中的所有p，查看其运行队列是否有goroutine，如果有，
</span></span></span><span class="line"><span class="cl"><span class="c1">//     则取其一半到当前工作线程的运行队列，然后从findrunnable返回，如果没有则继续遍历下一个p
</span></span></span><span class="line"><span class="cl"><span class="c1">//  3. 但这里为了保证公平性，遍历allp时并不是固定的从allp[0]即第一个p开始，而是从随机位置上的p开始，
</span></span></span><span class="line"><span class="cl"><span class="c1">//     而且遍历的顺序也随机化了，并不是现在访问了第i个p下一次就访问第i+1个p，
</span></span></span><span class="line"><span class="cl"><span class="c1">//     而是使用了一种伪随机的方式遍历allp中的每个p，防止每次遍历时使用同样的顺序访问allp中的元素
</span></span></span><span class="line"><span class="cl"><span class="c1">// 下面是这个算法的伪代码：
</span></span></span><span class="line"><span class="cl"><span class="c1">// offset := uint32(random()) % nprocs
</span></span></span><span class="line"><span class="cl"><span class="c1">// coprime := 随机选取一个小于nprocs且与nprocs互质的数
</span></span></span><span class="line"><span class="cl"><span class="c1">// for i := 0; i &lt; nprocs; i++ {
</span></span></span><span class="line"><span class="cl"><span class="c1">//     p := allp[offset]
</span></span></span><span class="line"><span class="cl"><span class="c1">//     从p的运行队列偷取goroutine
</span></span></span><span class="line"><span class="cl"><span class="c1">//     if 偷取成功 {
</span></span></span><span class="line"><span class="cl"><span class="c1">//         break
</span></span></span><span class="line"><span class="cl"><span class="c1">//     }
</span></span></span><span class="line"><span class="cl"><span class="c1">//     offset += coprime
</span></span></span><span class="line"><span class="cl"><span class="c1">//     offset = offset % nprocs
</span></span></span><span class="line"><span class="cl"><span class="c1">// }
</span></span></span><span class="line"><span class="cl"><span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1">// 下面举例说明一下上述算法过程，现假设nprocs为8，也就是一共有8个p
</span></span></span><span class="line"><span class="cl"><span class="c1">//    如果第一次随机选择的offset = 6，coprime = 3(3与8互质，满足算法要求)的话，则从allp切片中偷取的下标顺序为
</span></span></span><span class="line"><span class="cl"><span class="c1">//    6, 1, 4, 7, 2, 5, 0, 3，计算过程：
</span></span></span><span class="line"><span class="cl"><span class="c1">//        6，(6+3)%8=1，(1+3)%8=4, (4+3)%8=7, (7+3)%8=2, (2+3)%8=5, (5+3)%8=0, (0+3)%8=3
</span></span></span><span class="line"><span class="cl"><span class="c1">//  如果第二次随机选择的offset = 4，coprime = 5的话，则从allp切片中偷取的下标顺序为
</span></span></span><span class="line"><span class="cl"><span class="c1">//    1, 6, 3, 0, 5, 2, 7, 4，计算过程：
</span></span></span><span class="line"><span class="cl"><span class="c1">//        1，(1+5)%8=6，(6+5)%8=3, (3+5)%8=0, (0+5)%8=5, (5+5)%8=2, (2+5)%8=7, (7+5)%8=4
</span></span></span></code></pre></div></blockquote>
<pre tabindex="0"><code></code></pre>
</details></p>

<h3 id="releasep-1">releasep()<a hidden class="anchor" aria-hidden="true" href="#releasep-1">#</a></h3>
<ol>
<li>解除当前<code>M</code>和<code>P</code>的绑定关系。</li>
<li>文件位置：<code>go1.19.3/src/runtime/proc.go</code>。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">4984
</span><span class="lnt">4985
</span><span class="lnt">4986
</span><span class="lnt">4987
</span><span class="lnt">4988
</span><span class="lnt">4989
</span><span class="lnt">4990
</span><span class="lnt">4991
</span><span class="lnt">4992
</span><span class="lnt">4993
</span><span class="lnt">4994
</span><span class="lnt">4995
</span><span class="lnt">4996
</span><span class="lnt">4997
</span><span class="lnt">4998
</span><span class="lnt">4999
</span><span class="lnt">5000
</span><span class="lnt">5001
</span><span class="lnt">5002
</span><span class="lnt">5003
</span><span class="lnt">5004
</span><span class="lnt">5005
</span><span class="lnt">5006
</span><span class="lnt">5007
</span><span class="lnt">5008
</span><span class="lnt">5009
</span><span class="lnt">5010
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// Disassociate p and the current m.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">releasep</span><span class="p">()</span> <span class="o">*</span><span class="nx">p</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">_g_</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">()</span> <span class="c1">// 获取当前运行的g，这里是g0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">p</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span> <span class="c1">// 当前要解绑的P不存在，系统代码有逻辑问题
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nf">throw</span><span class="p">(</span><span class="s">&#34;releasep: invalid arg&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nx">_p_</span> <span class="o">:=</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">p</span><span class="p">.</span><span class="nf">ptr</span><span class="p">()</span> <span class="c1">// 获取当前工作线程M绑定的P，也就是需要解绑的P
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// _Prunning 表示 P 由 M 拥有并用于运行用户代码或调度程序
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 只有拥有这个 P 的 M 才允许从 _Prunning 更改 P 的状态
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// M 可以将 P 转换为 _Pidle（如果它没有更多工作要做）、_Psyscall（当进入系统调用时）或 _Pgcstop（停止 GC）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// M 也可以将 P 的所有权直接交给另一个 M（例如，安排锁定的 G）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nx">_p_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nf">ptr</span><span class="p">()</span> <span class="o">!=</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span> <span class="o">||</span> <span class="nx">_p_</span><span class="p">.</span><span class="nx">status</span> <span class="o">!=</span> <span class="nx">_Prunning</span> <span class="p">{</span> <span class="c1">// 当前P绑定的m与g绑定的m不是同一个 或 当前P不是_Prunning状态
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nb">print</span><span class="p">(</span><span class="s">&#34;releasep: m=&#34;</span><span class="p">,</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">,</span> <span class="s">&#34; m-&gt;p=&#34;</span><span class="p">,</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">p</span><span class="p">.</span><span class="nf">ptr</span><span class="p">(),</span> <span class="s">&#34; p-&gt;m=&#34;</span><span class="p">,</span> <span class="nf">hex</span><span class="p">(</span><span class="nx">_p_</span><span class="p">.</span><span class="nx">m</span><span class="p">),</span> <span class="s">&#34; p-&gt;status=&#34;</span><span class="p">,</span> <span class="nx">_p_</span><span class="p">.</span><span class="nx">status</span><span class="p">,</span> <span class="s">&#34;\n&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="nf">throw</span><span class="p">(</span><span class="s">&#34;releasep: invalid p state&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">trace</span><span class="p">.</span><span class="nx">enabled</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">traceProcStop</span><span class="p">(</span><span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">p</span><span class="p">.</span><span class="nf">ptr</span><span class="p">())</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">p</span> <span class="p">=</span> <span class="mi">0</span>		<span class="c1">// 解绑工作线程M与P的关联
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">_p_</span><span class="p">.</span><span class="nx">m</span> <span class="p">=</span> <span class="mi">0</span>		<span class="c1">// 解绑P与M的关联
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// _Pidle 表示 P 未用于运行用户代码或调度程序
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 通常，它位于空闲 P 列表中并且可供调度程序使用，但它可能只是在其他状态之间转换
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// P 由空闲列表或正在转换其状态的任何东西拥有。 它的运行队列是空的
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">_p_</span><span class="p">.</span><span class="nx">status</span> <span class="p">=</span> <span class="nx">_Pidle</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nx">_p_</span>	<span class="c1">// 返回当前P
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="pidleput">pidleput()<a hidden class="anchor" aria-hidden="true" href="#pidleput">#</a></h3>
<ol>
<li>pidleput 将p放到_Pidle列表中。</li>
<li>这释放了p的所有权。一旦sched.lock被释放，使用p就不再安全了。</li>
<li>sched.lock必须被持有，可以在STW期间运行，因此不允许写入屏障。</li>
<li>文件位置：<code>go1.19.3/src/runtime/proc.go</code>。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">5696
</span><span class="lnt">5697
</span><span class="lnt">5698
</span><span class="lnt">5699
</span><span class="lnt">5700
</span><span class="lnt">5701
</span><span class="lnt">5702
</span><span class="lnt">5703
</span><span class="lnt">5704
</span><span class="lnt">5705
</span><span class="lnt">5706
</span><span class="lnt">5707
</span><span class="lnt">5708
</span><span class="lnt">5709
</span><span class="lnt">5710
</span><span class="lnt">5711
</span><span class="lnt">5712
</span><span class="lnt">5713
</span><span class="lnt">5714
</span><span class="lnt">5715
</span><span class="lnt">5716
</span><span class="lnt">5717
</span><span class="lnt">5718
</span><span class="lnt">5719
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// pidleput puts p to on the _Pidle list.
</span></span></span><span class="line"><span class="cl"><span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1">// This releases ownership of p. Once sched.lock is released it is no longer
</span></span></span><span class="line"><span class="cl"><span class="c1">// safe to use p.
</span></span></span><span class="line"><span class="cl"><span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1">// sched.lock must be held.
</span></span></span><span class="line"><span class="cl"><span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1">// May run during STW, so write barriers are not allowed.
</span></span></span><span class="line"><span class="cl"><span class="c1">//go:nowritebarrierrec
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">pidleput</span><span class="p">(</span><span class="nx">_p_</span> <span class="o">*</span><span class="nx">p</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nf">assertLockHeld</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 判断P的本地队列不应该还有goroutine，判断下
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">!</span><span class="nf">runqempty</span><span class="p">(</span><span class="nx">_p_</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">throw</span><span class="p">(</span><span class="s">&#34;pidleput: P has non-empty run queue&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 如果P没有timer，将清除timerpMask位上对应的掩码位，timerpMask是记录忙碌的
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">updateTimerPMask</span><span class="p">(</span><span class="nx">_p_</span><span class="p">)</span>   <span class="c1">// clear if there are no timers.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">idlepMask</span><span class="p">.</span><span class="nf">set</span><span class="p">(</span><span class="nx">_p_</span><span class="p">.</span><span class="nx">id</span><span class="p">)</span>   <span class="c1">// 设置idlepMask对应的P的掩码位，idlepMask是记录空闲的
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">_p_</span><span class="p">.</span><span class="nx">link</span> <span class="p">=</span> <span class="nx">sched</span><span class="p">.</span><span class="nx">pidle</span>  <span class="c1">// 当前P记录全局的空闲链表
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">sched</span><span class="p">.</span><span class="nx">pidle</span><span class="p">.</span><span class="nf">set</span><span class="p">(</span><span class="nx">_p_</span><span class="p">)</span>    <span class="c1">// 把当前P链接到全局空闲链表后
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 使用原子锁把当前sched空闲的P数量加1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">atomic</span><span class="p">.</span><span class="nf">Xadd</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">npidle</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="c1">// TODO: fast atomic
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="runqempty">runqempty()<a hidden class="anchor" aria-hidden="true" href="#runqempty">#</a></h4>
<ol>
<li>runqempty 报告<code>_p_</code>在其本地运行队列中是否没有 Gs。</li>
<li>它永远不会虚假地返回true。</li>
<li>文件位置：<code>go1.19.3/src/runtime/proc.go</code>。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">5752
</span><span class="lnt">5753
</span><span class="lnt">5754
</span><span class="lnt">5755
</span><span class="lnt">5756
</span><span class="lnt">5757
</span><span class="lnt">5758
</span><span class="lnt">5759
</span><span class="lnt">5760
</span><span class="lnt">5761
</span><span class="lnt">5762
</span><span class="lnt">5763
</span><span class="lnt">5764
</span><span class="lnt">5765
</span><span class="lnt">5766
</span><span class="lnt">5767
</span><span class="lnt">5768
</span><span class="lnt">5769
</span><span class="lnt">5770
</span><span class="lnt">5771
</span><span class="lnt">5772
</span><span class="lnt">5773
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// runqempty reports whether _p_ has no Gs on its local run queue.
</span></span></span><span class="line"><span class="cl"><span class="c1">// It never returns true spuriously.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">runqempty</span><span class="p">(</span><span class="nx">_p_</span> <span class="o">*</span><span class="nx">p</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Defend against a race where 1) _p_ has G1 in runqnext but runqhead == runqtail,
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 2) runqput on _p_ kicks G1 to the runq, 3) runqget on _p_ empties runqnext.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// Simply observing that runqhead == runqtail and then observing that runqnext == nil
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// does not mean the queue is empty.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 以下情况：
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//  1. _p_ 在 runqnext 中有 G1 但 runqhead == runqtail
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//  2. _p_ 上的 runqput 将 G1 踢到 runq
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//  3. _p_ 上的 runqget 清空 runqnext
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 简单地观察 runqhead == runqtail 然后观察 runqnext == nil 并不意味着队列是空的
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">for</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">head</span> <span class="o">:=</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Load</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">_p_</span><span class="p">.</span><span class="nx">runqhead</span><span class="p">)</span>	
</span></span><span class="line"><span class="cl">        <span class="nx">tail</span> <span class="o">:=</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Load</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">_p_</span><span class="p">.</span><span class="nx">runqtail</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="nx">runnext</span> <span class="o">:=</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Loaduintptr</span><span class="p">((</span><span class="o">*</span><span class="kt">uintptr</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">_p_</span><span class="p">.</span><span class="nx">runnext</span><span class="p">)))</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="nx">tail</span> <span class="o">==</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Load</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">_p_</span><span class="p">.</span><span class="nx">runqtail</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="nx">head</span> <span class="o">==</span> <span class="nx">tail</span> <span class="o">&amp;&amp;</span> <span class="nx">runnext</span> <span class="o">==</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="pidleget">pidleget()<a hidden class="anchor" aria-hidden="true" href="#pidleget">#</a></h4>
<ol>
<li>相关联函数pidleget从空闲列表中获取一个P。</li>
<li>文件位置：<code>go1.19.3/src/runtime/proc.go</code>。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">5727
</span><span class="lnt">5728
</span><span class="lnt">5729
</span><span class="lnt">5730
</span><span class="lnt">5731
</span><span class="lnt">5732
</span><span class="lnt">5733
</span><span class="lnt">5734
</span><span class="lnt">5735
</span><span class="lnt">5736
</span><span class="lnt">5737
</span><span class="lnt">5738
</span><span class="lnt">5739
</span><span class="lnt">5740
</span><span class="lnt">5741
</span><span class="lnt">5742
</span><span class="lnt">5743
</span><span class="lnt">5744
</span><span class="lnt">5745
</span><span class="lnt">5746
</span><span class="lnt">5747
</span><span class="lnt">5748
</span><span class="lnt">5749
</span><span class="lnt">5750
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// pidleget tries to get a p from the _Pidle list, acquiring ownership.
</span></span></span><span class="line"><span class="cl"><span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1">// sched.lock must be held.
</span></span></span><span class="line"><span class="cl"><span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1">// May run during STW, so write barriers are not allowed.
</span></span></span><span class="line"><span class="cl"><span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1">//go:nowritebarrierrec
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">pidleget</span><span class="p">(</span><span class="nx">now</span> <span class="kt">int64</span><span class="p">)</span> <span class="p">(</span><span class="o">*</span><span class="nx">p</span><span class="p">,</span> <span class="kt">int64</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nf">assertLockHeld</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nx">_p_</span> <span class="o">:=</span> <span class="nx">sched</span><span class="p">.</span><span class="nx">pidle</span><span class="p">.</span><span class="nf">ptr</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">_p_</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// Timer may get added at any time now.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="nx">now</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nx">now</span> <span class="p">=</span> <span class="nf">nanotime</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="nx">timerpMask</span><span class="p">.</span><span class="nf">set</span><span class="p">(</span><span class="nx">_p_</span><span class="p">.</span><span class="nx">id</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="nx">idlepMask</span><span class="p">.</span><span class="nb">clear</span><span class="p">(</span><span class="nx">_p_</span><span class="p">.</span><span class="nx">id</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="nx">sched</span><span class="p">.</span><span class="nx">pidle</span> <span class="p">=</span> <span class="nx">_p_</span><span class="p">.</span><span class="nx">link</span>
</span></span><span class="line"><span class="cl">        <span class="nx">atomic</span><span class="p">.</span><span class="nf">Xadd</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">npidle</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="nx">_p_</span><span class="p">.</span><span class="nx">limiterEvent</span><span class="p">.</span><span class="nf">stop</span><span class="p">(</span><span class="nx">limiterEventIdle</span><span class="p">,</span> <span class="nx">now</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nx">_p_</span><span class="p">,</span> <span class="nx">now</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="checkrunqsnop">checkRunqsNoP()<a hidden class="anchor" aria-hidden="true" href="#checkrunqsnop">#</a></h3>
<ol>
<li>检查快照中所有的<code>P</code>是否有可以偷取的<code>G</code>。</li>
<li>文件位置：<code>go1.19.3/src/runtime/proc.go</code>。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">2974
</span><span class="lnt">2975
</span><span class="lnt">2976
</span><span class="lnt">2977
</span><span class="lnt">2978
</span><span class="lnt">2979
</span><span class="lnt">2980
</span><span class="lnt">2981
</span><span class="lnt">2982
</span><span class="lnt">2983
</span><span class="lnt">2984
</span><span class="lnt">2985
</span><span class="lnt">2986
</span><span class="lnt">2987
</span><span class="lnt">2988
</span><span class="lnt">2989
</span><span class="lnt">2990
</span><span class="lnt">2991
</span><span class="lnt">2992
</span><span class="lnt">2993
</span><span class="lnt">2994
</span><span class="lnt">2995
</span><span class="lnt">2996
</span><span class="lnt">2997
</span><span class="lnt">2998
</span><span class="lnt">2999
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// Check all Ps for a runnable G to steal.
</span></span></span><span class="line"><span class="cl"><span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1">// On entry we have no P. If a G is available to steal and a P is available,
</span></span></span><span class="line"><span class="cl"><span class="c1">// the P is returned which the caller should acquire and attempt to steal the
</span></span></span><span class="line"><span class="cl"><span class="c1">// work to.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">checkRunqsNoP</span><span class="p">(</span><span class="nx">allpSnapshot</span> <span class="p">[]</span><span class="o">*</span><span class="nx">p</span><span class="p">,</span> <span class="nx">idlepMaskSnapshot</span> <span class="nx">pMask</span><span class="p">)</span> <span class="o">*</span><span class="nx">p</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 变量allp的快照，allp记录了所有的P列表
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">for</span> <span class="nx">id</span><span class="p">,</span> <span class="nx">p2</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">allpSnapshot</span> <span class="p">{</span>	<span class="c1">// 休眠之前在看一下是否有工作要做
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// idlepMaskSnapshot 快照记录着当前P的状态
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// !idlepMaskSnapshot.read(uint32(id)) 当前P状态不为空的 并且 当前P存储groutine的
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="p">!</span><span class="nx">idlepMaskSnapshot</span><span class="p">.</span><span class="nf">read</span><span class="p">(</span><span class="nb">uint32</span><span class="p">(</span><span class="nx">id</span><span class="p">))</span> <span class="o">&amp;&amp;</span> <span class="p">!</span><span class="nf">runqempty</span><span class="p">(</span><span class="nx">p2</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="nx">pp</span> <span class="o">:=</span> <span class="nf">pidleget</span><span class="p">()</span>	<span class="c1">// 从空闲的P中拿去一个P，为后续M绑定P做准备，因为有全局的P存在g可以起去拿来用
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="nx">pp</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="k">return</span> <span class="nx">pp</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            <span class="c1">// Can&#39;t get a P, don&#39;t bother checking remaining Ps.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// 拿不到P，别费心检查剩余的P
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="k">break</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="checkidlegcnop">checkIdleGCNoP()<a hidden class="anchor" aria-hidden="true" href="#checkidlegcnop">#</a></h3>
<ol>
<li>检查是否有GC需要帮助。</li>
<li>文件位置：<code>go1.19.3/src/runtime/proc.go</code>。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">3013
</span><span class="lnt">3014
</span><span class="lnt">3015
</span><span class="lnt">3016
</span><span class="lnt">3017
</span><span class="lnt">3018
</span><span class="lnt">3019
</span><span class="lnt">3020
</span><span class="lnt">3021
</span><span class="lnt">3022
</span><span class="lnt">3023
</span><span class="lnt">3024
</span><span class="lnt">3025
</span><span class="lnt">3026
</span><span class="lnt">3027
</span><span class="lnt">3028
</span><span class="lnt">3029
</span><span class="lnt">3030
</span><span class="lnt">3031
</span><span class="lnt">3032
</span><span class="lnt">3033
</span><span class="lnt">3034
</span><span class="lnt">3035
</span><span class="lnt">3036
</span><span class="lnt">3037
</span><span class="lnt">3038
</span><span class="lnt">3039
</span><span class="lnt">3040
</span><span class="lnt">3041
</span><span class="lnt">3042
</span><span class="lnt">3043
</span><span class="lnt">3044
</span><span class="lnt">3045
</span><span class="lnt">3046
</span><span class="lnt">3047
</span><span class="lnt">3048
</span><span class="lnt">3049
</span><span class="lnt">3050
</span><span class="lnt">3051
</span><span class="lnt">3052
</span><span class="lnt">3053
</span><span class="lnt">3054
</span><span class="lnt">3055
</span><span class="lnt">3056
</span><span class="lnt">3057
</span><span class="lnt">3058
</span><span class="lnt">3059
</span><span class="lnt">3060
</span><span class="lnt">3061
</span><span class="lnt">3062
</span><span class="lnt">3063
</span><span class="lnt">3064
</span><span class="lnt">3065
</span><span class="lnt">3066
</span><span class="lnt">3067
</span><span class="lnt">3068
</span><span class="lnt">3069
</span><span class="lnt">3070
</span><span class="lnt">3071
</span><span class="lnt">3072
</span><span class="lnt">3073
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// Check for idle-priority GC, without a P on entry.
</span></span></span><span class="line"><span class="cl"><span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1">// If some GC work, a P, and a worker G are all available, the P and G will be
</span></span></span><span class="line"><span class="cl"><span class="c1">// returned. The returned P has not been wired yet.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">checkIdleGCNoP</span><span class="p">()</span> <span class="p">(</span><span class="o">*</span><span class="nx">p</span><span class="p">,</span> <span class="o">*</span><span class="nx">g</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// N.B. Since we have no P, gcBlackenEnabled may change at any time; we
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// must check again after acquiring a P. As an optimization, we also check
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// if an idle mark worker is needed at all. This is OK here, because if we
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// observe that one isn&#39;t needed, at least one is currently running. Even if
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// it stops running, its own journey into the scheduler should schedule it
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// again, if need be (at which point, this check will pass, if relevant).
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Load</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">gcBlackenEnabled</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="p">!</span><span class="nx">gcController</span><span class="p">.</span><span class="nf">needIdleMarkWorker</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">!</span><span class="nf">gcMarkWorkAvailable</span><span class="p">(</span><span class="kc">nil</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// Work is available; we can start an idle GC worker only if there is
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// an available P and available worker G.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// We can attempt to acquire these in either order, though both have
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// synchronization concerns (see below). Workers are almost always
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// available (see comment in findRunnableGCWorker for the one case
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// there may be none). Since we&#39;re slightly less likely to find a P,
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// check for that first.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// Synchronization: note that we must hold sched.lock until we are
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// committed to keeping it. Otherwise we cannot put the unnecessary P
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// back in sched.pidle without performing the full set of idle
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// transition checks.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// If we were to check gcBgMarkWorkerPool first, we must somehow handle
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// the assumption in gcControllerState.findRunnableGCWorker that an
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// empty gcBgMarkWorkerPool is only possible if gcMarkDone is running.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nx">pp</span><span class="p">,</span> <span class="nx">now</span> <span class="o">:=</span> <span class="nf">pidlegetSpinning</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">pp</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// Now that we own a P, gcBlackenEnabled can&#39;t change (as it requires STW).
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nx">gcBlackenEnabled</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="p">!</span><span class="nx">gcController</span><span class="p">.</span><span class="nf">addIdleMarkWorker</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">pidleput</span><span class="p">(</span><span class="nx">pp</span><span class="p">,</span> <span class="nx">now</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nx">node</span> <span class="o">:=</span> <span class="p">(</span><span class="o">*</span><span class="nx">gcBgMarkWorkerNode</span><span class="p">)(</span><span class="nx">gcBgMarkWorkerPool</span><span class="p">.</span><span class="nf">pop</span><span class="p">())</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">node</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">pidleput</span><span class="p">(</span><span class="nx">pp</span><span class="p">,</span> <span class="nx">now</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="nx">gcController</span><span class="p">.</span><span class="nf">removeIdleMarkWorker</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nx">pp</span><span class="p">,</span> <span class="nx">node</span><span class="p">.</span><span class="nx">gp</span><span class="p">.</span><span class="nf">ptr</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="checktimersnop">checkTimersNoP()<a hidden class="anchor" aria-hidden="true" href="#checktimersnop">#</a></h3>
<ol>
<li>检查快照中所有的P是否有timer要触发了。</li>
<li>文件位置：<code>go1.19.3/src/runtime/proc.go</code>。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">2997
</span><span class="lnt">2998
</span><span class="lnt">2999
</span><span class="lnt">3000
</span><span class="lnt">3001
</span><span class="lnt">3002
</span><span class="lnt">3003
</span><span class="lnt">3004
</span><span class="lnt">3005
</span><span class="lnt">3006
</span><span class="lnt">3007
</span><span class="lnt">3008
</span><span class="lnt">3009
</span><span class="lnt">3010
</span><span class="lnt">3011
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// Check all Ps for a timer expiring sooner than pollUntil.
</span></span></span><span class="line"><span class="cl"><span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1">// Returns updated pollUntil value.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">checkTimersNoP</span><span class="p">(</span><span class="nx">allpSnapshot</span> <span class="p">[]</span><span class="o">*</span><span class="nx">p</span><span class="p">,</span> <span class="nx">timerpMaskSnapshot</span> <span class="nx">pMask</span><span class="p">,</span> <span class="nx">pollUntil</span> <span class="kt">int64</span><span class="p">)</span> <span class="kt">int64</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="nx">id</span><span class="p">,</span> <span class="nx">p2</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">allpSnapshot</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="nx">timerpMaskSnapshot</span><span class="p">.</span><span class="nf">read</span><span class="p">(</span><span class="nb">uint32</span><span class="p">(</span><span class="nx">id</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nx">w</span> <span class="o">:=</span> <span class="nf">nobarrierWakeTime</span><span class="p">(</span><span class="nx">p2</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="nx">w</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="nx">pollUntil</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="nx">w</span> <span class="p">&lt;</span> <span class="nx">pollUntil</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="nx">pollUntil</span> <span class="p">=</span> <span class="nx">w</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nx">pollUntil</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="stopm-1">stopm()<a hidden class="anchor" aria-hidden="true" href="#stopm-1">#</a></h3>
<ol>
<li>工作线程进入休眠，等待被其他工作线程唤醒。</li>
<li>文件位置：<code>go1.19.3/src/runtime/proc.go</code>。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">2229
</span><span class="lnt">2230
</span><span class="lnt">2231
</span><span class="lnt">2232
</span><span class="lnt">2233
</span><span class="lnt">2234
</span><span class="lnt">2235
</span><span class="lnt">2236
</span><span class="lnt">2237
</span><span class="lnt">2238
</span><span class="lnt">2239
</span><span class="lnt">2240
</span><span class="lnt">2241
</span><span class="lnt">2242
</span><span class="lnt">2243
</span><span class="lnt">2244
</span><span class="lnt">2245
</span><span class="lnt">2246
</span><span class="lnt">2247
</span><span class="lnt">2248
</span><span class="lnt">2249
</span><span class="lnt">2250
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// Stops execution of the current m until new work is available.
</span></span></span><span class="line"><span class="cl"><span class="c1">// Returns with acquired P.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">stopm</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">_g_</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">()</span>           <span class="c1">// 获取当前工作线程M绑定的g
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">locks</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>   <span class="c1">// 判断当前工作线程是否有锁为解锁
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nf">throw</span><span class="p">(</span><span class="s">&#34;stopm holding locks&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">p</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>       <span class="c1">// 判断当前工作线程是否还绑定了P，因为前面M与P已经解绑了
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nf">throw</span><span class="p">(</span><span class="s">&#34;stopm holding p&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">spinning</span> <span class="p">{</span>     <span class="c1">// 判断当前工作线程是否还处于自旋状态标记，应为前面已经取消了该标记
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nf">throw</span><span class="p">(</span><span class="s">&#34;stopm spinning&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>       <span class="c1">// 锁住全局sched
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">mput</span><span class="p">(</span><span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">)</span>             <span class="c1">// 把m结构体对象放入sched.midle空闲队列
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>     <span class="c1">// 解锁
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">mPark</span><span class="p">()</span>                 <span class="c1">// 进入系统调用进入睡眠
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">acquirep</span><span class="p">(</span><span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">nextp</span><span class="p">.</span><span class="nf">ptr</span><span class="p">())</span> <span class="c1">// 工作线程被唤醒后从这里开始执行，给M绑定P
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">nextp</span> <span class="p">=</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="mput-1">mput()<a hidden class="anchor" aria-hidden="true" href="#mput-1">#</a></h4>
<ol>
<li>当工作线程空闲时即将进入休眠状态时会判断一次<code>checkdead()</code>。</li>
<li>文件位置：<code>go1.19.3/src/runtime/proc.go</code>。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">5533
</span><span class="lnt">5534
</span><span class="lnt">5535
</span><span class="lnt">5536
</span><span class="lnt">5537
</span><span class="lnt">5538
</span><span class="lnt">5539
</span><span class="lnt">5540
</span><span class="lnt">5541
</span><span class="lnt">5542
</span><span class="lnt">5543
</span><span class="lnt">5544
</span><span class="lnt">5545
</span><span class="lnt">5546
</span><span class="lnt">5547
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// Put mp on midle list.
</span></span></span><span class="line"><span class="cl"><span class="c1">// sched.lock must be held.
</span></span></span><span class="line"><span class="cl"><span class="c1">// May run during STW, so write barriers are not allowed.
</span></span></span><span class="line"><span class="cl"><span class="c1">//go:nowritebarrierrec
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">mput</span><span class="p">(</span><span class="nx">mp</span> <span class="o">*</span><span class="nx">m</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nf">assertLockHeld</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span> <span class="c1">// 检查sched.lock锁
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="nx">mp</span><span class="p">.</span><span class="nx">schedlink</span> <span class="p">=</span> <span class="nx">sched</span><span class="p">.</span><span class="nx">midle</span>  <span class="c1">// 当前M记录全局空闲M链表
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">sched</span><span class="p">.</span><span class="nx">midle</span><span class="p">.</span><span class="nf">set</span><span class="p">(</span><span class="nx">mp</span><span class="p">)</span>         <span class="c1">// 把当前M追加到全局空闲链表中去
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">sched</span><span class="p">.</span><span class="nx">nmidle</span><span class="o">++</span>              <span class="c1">// 全局空闲M数量加一
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 检查死锁情况
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 检查基于运行 M 的数量，如果 0 -&gt; 死锁
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// sched.lock 必须被持有
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">checkdead</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="mget">mget()<a hidden class="anchor" aria-hidden="true" href="#mget">#</a></h4>
<ol>
<li>文件位置：<code>go1.19.3/src/runtime/proc.go</code>。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">5547
</span><span class="lnt">5548
</span><span class="lnt">5549
</span><span class="lnt">5550
</span><span class="lnt">5551
</span><span class="lnt">5552
</span><span class="lnt">5553
</span><span class="lnt">5554
</span><span class="lnt">5555
</span><span class="lnt">5556
</span><span class="lnt">5557
</span><span class="lnt">5558
</span><span class="lnt">5559
</span><span class="lnt">5560
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// Try to get an m from midle list.
</span></span></span><span class="line"><span class="cl"><span class="c1">// sched.lock must be held.
</span></span></span><span class="line"><span class="cl"><span class="c1">// May run during STW, so write barriers are not allowed.
</span></span></span><span class="line"><span class="cl"><span class="c1">//go:nowritebarrierrec
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">mget</span><span class="p">()</span> <span class="o">*</span><span class="nx">m</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nf">assertLockHeld</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nx">mp</span> <span class="o">:=</span> <span class="nx">sched</span><span class="p">.</span><span class="nx">midle</span><span class="p">.</span><span class="nf">ptr</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">mp</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">sched</span><span class="p">.</span><span class="nx">midle</span> <span class="p">=</span> <span class="nx">mp</span><span class="p">.</span><span class="nx">schedlink</span>
</span></span><span class="line"><span class="cl">        <span class="nx">sched</span><span class="p">.</span><span class="nx">nmidle</span><span class="o">--</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nx">mp</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="mpark-1">mPark()<a hidden class="anchor" aria-hidden="true" href="#mpark-1">#</a></h4>
<ol>
<li>睡眠函数，mPark()导致线程自行停放，一旦唤醒就返回。</li>
<li><strong>stopm的核心是调用mput把m结构体对象放入sched的midle空闲队列，然后通过notesleep(&amp;m.park)函数让自己进入睡眠状态</strong>。</li>
<li><strong>note是go runtime实现的一次性睡眠和唤醒机制，一个线程可以通过调用notesleep(*note)进入睡眠状态，而另外一个线程则可以通过notewakeup(*note)把其唤醒</strong>。</li>
<li><code>note</code>的底层实现机制跟操作系统相关，不同系统使用不同的机制：
<ul>
<li>比如<code>linux</code>下使用的<code>futex</code>系统调用。</li>
<li>而<code>mac</code>下则是使用的<code>pthread_cond_t</code>条件变量。</li>
</ul>
</li>
<li><code>note</code>对这些底层机制做了一个抽象和封装，这种封装给扩展性带来了很大的好处，比如当睡眠和唤醒功能需要支持新平台时，只需要在<code>note</code>层增加对特定平台的支持即可，不需要修改上层的任何代码。</li>
<li>回到<code>stopm</code>，当从<code>notesleep</code>函数返回后，需要再次绑定一个<code>p</code>，然后返回到<code>findrunnable</code>函数继续重新寻找可运行的<code>goroutine</code>，一旦找到可运行的<code>goroutine</code>就会返回到<code>schedule</code>函数，并把找到的<code>goroutine</code>调度起来运行，如何把<code>goroutine</code>调度起来运行的代码我们已经分析过了。</li>
<li>文件位置：<code>go1.19.3/src/runtime/proc.go</code>。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1452
</span><span class="lnt">1453
</span><span class="lnt">1454
</span><span class="lnt">1455
</span><span class="lnt">1456
</span><span class="lnt">1457
</span><span class="lnt">1458
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// mPark causes a thread to park itself, returning once woken.
</span></span></span><span class="line"><span class="cl"><span class="c1">//go:nosplit
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">mPark</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">gp</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="nf">notesleep</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">gp</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">park</span><span class="p">)</span>   <span class="c1">// 进入休眠状态，这里传入M的park，睡眠在这个上面
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">noteclear</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">gp</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">park</span><span class="p">)</span>   <span class="c1">// 被其他工作线程唤醒，代码从这里开始执行
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="notesleep">notesleep()<a hidden class="anchor" aria-hidden="true" href="#notesleep">#</a></h4>
<ol>
<li>实现休眠的函数。</li>
<li><code>notesleep</code>函数调用<code>futexsleep</code>进入睡眠，这里之所以需要用一个循环，是因为<strong>futexsleep有可能意外从睡眠中返回</strong>，所以从<code>futexsleep</code>函数返回后还需要检查<code>note.key</code>是否还是0。</li>
<li>如果是0则表示并不是其它工作线程唤醒了我们，只是<code>futexsleep</code>意外返回了，需要再次调用<code>futexsleep</code>进入睡眠。</li>
<li>文件位置：<code>go1.19.3/src/runtime/lock_futex.go</code>。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">148
</span><span class="lnt">149
</span><span class="lnt">150
</span><span class="lnt">151
</span><span class="lnt">152
</span><span class="lnt">153
</span><span class="lnt">154
</span><span class="lnt">155
</span><span class="lnt">156
</span><span class="lnt">157
</span><span class="lnt">158
</span><span class="lnt">159
</span><span class="lnt">160
</span><span class="lnt">161
</span><span class="lnt">162
</span><span class="lnt">163
</span><span class="lnt">164
</span><span class="lnt">165
</span><span class="lnt">166
</span><span class="lnt">167
</span><span class="lnt">168
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">notesleep</span><span class="p">(</span><span class="nx">n</span> <span class="o">*</span><span class="nx">note</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">gp</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">()</span>    <span class="c1">// 获取当前工作线程绑定的g，应该是g0在调度循环过程中被切换到g0了
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nx">gp</span> <span class="o">!=</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">g0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">throw</span><span class="p">(</span><span class="s">&#34;notesleep not on g0&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nx">ns</span> <span class="o">:=</span> <span class="nb">int64</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="c1">// 超时时间设置为-1，表示无限期等待
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="o">*</span><span class="nx">cgo_yield</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// Sleep for an arbitrary-but-moderate interval to poll libc interceptors.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 休眠一个任意但适中的间隔来轮询 libc 拦截器cgo相关的
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">ns</span> <span class="p">=</span> <span class="mf">10e6</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 使用循环，保证不是意外被唤醒
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">for</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Load</span><span class="p">(</span><span class="nf">key32</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">n</span><span class="p">.</span><span class="nx">key</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">gp</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">blocked</span> <span class="p">=</span> <span class="kc">true</span>                 <span class="c1">// blocked表示M在当前的note上被屏蔽
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nf">futexsleep</span><span class="p">(</span><span class="nf">key32</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">n</span><span class="p">.</span><span class="nx">key</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">ns</span><span class="p">)</span>    <span class="c1">// 进入休眠函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="o">*</span><span class="nx">cgo_yield</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nf">asmcgocall</span><span class="p">(</span><span class="o">*</span><span class="nx">cgo_yield</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="nx">gp</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">blocked</span> <span class="p">=</span> <span class="kc">false</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="futexsleep">futexsleep()<a hidden class="anchor" aria-hidden="true" href="#futexsleep">#</a></h4>
<ol>
<li>原子的<code>if(*addr == val)</code>休眠，可能会被虚假唤醒； 这是允许的睡眠时间不要超过ns；ns &lt; 0意味着永远。</li>
<li>文件位置：<code>go1.19.3/src/runtime/os_linux.go</code>。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span><span class="lnt">77
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// Atomically,
</span></span></span><span class="line"><span class="cl"><span class="c1">//	if(*addr == val) sleep
</span></span></span><span class="line"><span class="cl"><span class="c1">// Might be woken up spuriously; that&#39;s allowed.
</span></span></span><span class="line"><span class="cl"><span class="c1">// Don&#39;t sleep longer than ns; ns &lt; 0 means forever.
</span></span></span><span class="line"><span class="cl"><span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1">//go:nosplit
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">futexsleep</span><span class="p">(</span><span class="nx">addr</span> <span class="o">*</span><span class="kt">uint32</span><span class="p">,</span> <span class="nx">val</span> <span class="kt">uint32</span><span class="p">,</span> <span class="nx">ns</span> <span class="kt">int64</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Some Linux kernels have a bug where futex of
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// FUTEX_WAIT returns an internal error code
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// as an errno. Libpthread ignores the return value
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// here, and so can we: as it says a few lines up,
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// spurious wakeups are allowed.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 一些 Linux 内核存在一个错误，即 FUTEX_WAIT 的 futex 返回内部错误代码作为 errno
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// Libpthread 忽略了这里的返回值，我们也可以：正如它所说的几行，虚假唤醒是允许的
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nx">ns</span> <span class="p">&lt;</span> <span class="mi">0</span> <span class="p">{</span>	<span class="c1">// 永久睡眠
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nf">futex</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">addr</span><span class="p">),</span> <span class="nx">_FUTEX_WAIT_PRIVATE</span><span class="p">,</span> <span class="nx">val</span><span class="p">,</span> <span class="kc">nil</span><span class="p">,</span> <span class="kc">nil</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">var</span> <span class="nx">ts</span> <span class="nx">timespec</span>
</span></span><span class="line"><span class="cl">    <span class="nx">ts</span><span class="p">.</span><span class="nf">setNsec</span><span class="p">(</span><span class="nx">ns</span><span class="p">)</span>  <span class="c1">// 设置时间
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">futex</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">addr</span><span class="p">),</span> <span class="nx">_FUTEX_WAIT_PRIVATE</span><span class="p">,</span> <span class="nx">val</span><span class="p">,</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">ts</span><span class="p">),</span> <span class="kc">nil</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="futex">futex()<a hidden class="anchor" aria-hidden="true" href="#futex">#</a></h4>
<ol>
<li>函数原型：<code>func futex(addr unsafe.Pointer, op int32, val uint32, ts, addr2 unsafe.Pointer, val3 uint32) int32</code>由汇编实现。</li>
<li><strong>futex系统调用为我们提供的功能为如果<code>*addr == val</code>则进入睡眠，否则直接返回</strong>。</li>
<li>文件位置：<code>go1.19.3/src/runtime/sys_linux_amd64.s</code>。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">549
</span><span class="lnt">550
</span><span class="lnt">551
</span><span class="lnt">552
</span><span class="lnt">553
</span><span class="lnt">554
</span><span class="lnt">555
</span><span class="lnt">556
</span><span class="lnt">557
</span><span class="lnt">558
</span><span class="lnt">559
</span><span class="lnt">560
</span><span class="lnt">561
</span><span class="lnt">562
</span><span class="lnt">563
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-asm" data-lang="asm"><span class="line"><span class="cl"><span class="c1"># int64 futex(int32 *uaddr, int32 op, int32 val,
</span></span></span><span class="line"><span class="cl"><span class="c1">#	struct timespec *timeout, int32 *uaddr2, int32 val2);
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nf">TEXT</span> <span class="no">runtime</span><span class="err">·</span><span class="no">futex</span><span class="p">(</span><span class="no">SB</span><span class="p">),</span><span class="no">NOSPLIT</span><span class="p">,</span><span class="no">$0</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># 下面的6条指令在为futex系统调用准备参数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">MOVQ</span>    <span class="no">addr</span><span class="err">+</span><span class="mi">0</span><span class="p">(</span><span class="no">FP</span><span class="p">),</span> <span class="no">DI</span>
</span></span><span class="line"><span class="cl">    <span class="nf">MOVL</span>    <span class="no">op</span><span class="err">+</span><span class="mi">8</span><span class="p">(</span><span class="no">FP</span><span class="p">),</span> <span class="no">SI</span>
</span></span><span class="line"><span class="cl">    <span class="nf">MOVL</span>    <span class="no">val</span><span class="err">+</span><span class="mi">12</span><span class="p">(</span><span class="no">FP</span><span class="p">),</span> <span class="no">DX</span>
</span></span><span class="line"><span class="cl">    <span class="nf">MOVQ</span>    <span class="no">ts</span><span class="err">+</span><span class="mi">16</span><span class="p">(</span><span class="no">FP</span><span class="p">),</span> <span class="no">R10</span>
</span></span><span class="line"><span class="cl">    <span class="nf">MOVQ</span>    <span class="no">addr2</span><span class="err">+</span><span class="mi">24</span><span class="p">(</span><span class="no">FP</span><span class="p">),</span> <span class="no">R8</span>
</span></span><span class="line"><span class="cl">    <span class="nf">MOVL</span>    <span class="no">val3</span><span class="err">+</span><span class="mi">32</span><span class="p">(</span><span class="no">FP</span><span class="p">),</span> <span class="no">R9</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="nf">MOVL</span>    <span class="no">$SYS_futex</span><span class="p">,</span> <span class="no">AX</span> <span class="c1"># 系统调用编号放入AX寄存器
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">SYSCALL</span> <span class="c1"># 执行futex系统调用进入睡眠，从睡眠中被唤醒后接着执行下一条MOVL指令
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">MOVL</span>    <span class="no">AX</span><span class="p">,</span> <span class="no">ret</span><span class="err">+</span><span class="mi">40</span><span class="p">(</span><span class="no">FP</span><span class="p">)</span> <span class="c1"># 保存系统调用的返回值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">RET</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="execute-">execute() 🚀<a hidden class="anchor" aria-hidden="true" href="#execute-">#</a></h2>
<ol>
<li><code>gp</code>放到当前<code>M</code>上取运行。该函数从<code>g0</code>栈切换到普通<code>goroutine</code>栈上。</li>
<li>如果<code>inheritTime</code>为<code>true</code>，则<code>gp</code>将继承当前时间片中的剩余时间。否则，它将启动一个新的时间片。永远不返回。</li>
<li>写屏障是允许的，因为这是在几个地方获得<code>P</code>后立即调用的。</li>
<li>参数：
<ol>
<li><code>gp *g</code>：当前调度的<code>goroutine</code>。</li>
<li><code>inheritTime bool</code>：<code>true</code>.继承当前时间片，<code>false</code>.不继承当前时间片。</li>
</ol>
</li>
<li>文件位置：<code>go1.19.3/src/runtime/proc.go</code>。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">2508
</span><span class="lnt">2509
</span><span class="lnt">2510
</span><span class="lnt">2511
</span><span class="lnt">2512
</span><span class="lnt">2513
</span><span class="lnt">2514
</span><span class="lnt">2515
</span><span class="lnt">2516
</span><span class="lnt">2517
</span><span class="lnt">2518
</span><span class="lnt">2519
</span><span class="lnt">2520
</span><span class="lnt">2521
</span><span class="lnt">2522
</span><span class="lnt">2523
</span><span class="lnt">2524
</span><span class="lnt">2525
</span><span class="lnt">2526
</span><span class="lnt">2527
</span><span class="lnt">2528
</span><span class="lnt">2529
</span><span class="lnt">2530
</span><span class="lnt">2531
</span><span class="lnt">2532
</span><span class="lnt">2533
</span><span class="lnt">2534
</span><span class="lnt">2535
</span><span class="lnt">2536
</span><span class="lnt">2537
</span><span class="lnt">2538
</span><span class="lnt">2539
</span><span class="lnt">2540
</span><span class="lnt">2541
</span><span class="lnt">2542
</span><span class="lnt">2543
</span><span class="lnt">2544
</span><span class="lnt">2545
</span><span class="lnt">2546
</span><span class="lnt">2547
</span><span class="lnt">2548
</span><span class="lnt">2549
</span><span class="lnt">2550
</span><span class="lnt">2551
</span><span class="lnt">2552
</span><span class="lnt">2553
</span><span class="lnt">2554
</span><span class="lnt">2555
</span><span class="lnt">2556
</span><span class="lnt">2557
</span><span class="lnt">2558
</span><span class="lnt">2559
</span><span class="lnt">2560
</span><span class="lnt">2561
</span><span class="lnt">2562
</span><span class="lnt">2563
</span><span class="lnt">2564
</span><span class="lnt">2565
</span><span class="lnt">2566
</span><span class="lnt">2567
</span><span class="lnt">2568
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// Schedules gp to run on the current M.
</span></span></span><span class="line"><span class="cl"><span class="c1">// If inheritTime is true, gp inherits the remaining time in the
</span></span></span><span class="line"><span class="cl"><span class="c1">// current time slice. Otherwise, it starts a new time slice.
</span></span></span><span class="line"><span class="cl"><span class="c1">// Never returns.
</span></span></span><span class="line"><span class="cl"><span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1">// Write barriers are allowed because this is called immediately after
</span></span></span><span class="line"><span class="cl"><span class="c1">// acquiring a P in several places.
</span></span></span><span class="line"><span class="cl"><span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1">//go:yeswritebarrierrec
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">execute</span><span class="p">(</span><span class="nx">gp</span> <span class="o">*</span><span class="nx">g</span><span class="p">,</span> <span class="nx">inheritTime</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 当前是在系统g0栈
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">_g_</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">()</span> <span class="c1">// _g_ = g0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">goroutineProfile</span><span class="p">.</span><span class="nx">active</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// Make sure that gp has had its stack written out to the goroutine
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// profile, exactly as it was when the goroutine profiler first stopped
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// the world.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nf">tryRecordGoroutineProfile</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="nx">osyield</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c1">// Assign gp.m before entering _Grunning so running Gs have an
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// M.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 在输入_Grunning之前指定gp.m，以便运行Gs具有m。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">curg</span> <span class="p">=</span> <span class="nx">gp</span> <span class="c1">// m.curg = gp
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">gp</span><span class="p">.</span><span class="nx">m</span> <span class="p">=</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span>    <span class="c1">// gp.m = m
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// _Grunnable：它当前没有执行用户代码。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// _Grunning：表示这个goroutine可以执行用户代码。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">casgstatus</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="nx">_Grunnable</span><span class="p">,</span> <span class="nx">_Grunning</span><span class="p">)</span> <span class="c1">// 修改当前g的状态为运行中
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">gp</span><span class="p">.</span><span class="nx">waitsince</span> <span class="p">=</span> <span class="mi">0</span>    <span class="c1">// 设置g被阻塞的大约时间
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 抢占信号，重复stackguard0 = stackpreempt
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">gp</span><span class="p">.</span><span class="nx">preempt</span> <span class="p">=</span> <span class="kc">false</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// const _StackGuard = 928; 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 设置当前g栈扩容阈值点。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">gp</span><span class="p">.</span><span class="nx">stackguard0</span> <span class="p">=</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">stack</span><span class="p">.</span><span class="nx">lo</span> <span class="o">+</span> <span class="nx">_StackGuard</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 是否继承当前时间片。具体的抢占在sysmon监控线程中。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">!</span><span class="nx">inheritTime</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 不继承上一个时间片时，调度次数会加一
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">p</span><span class="p">.</span><span class="nf">ptr</span><span class="p">().</span><span class="nx">schedtick</span><span class="o">++</span> <span class="c1">// 调度次数加一
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// Check whether the profiler needs to be turned on or off.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 检查分析器是否需要打开或关闭
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">hz</span> <span class="o">:=</span> <span class="nx">sched</span><span class="p">.</span><span class="nx">profilehz</span> <span class="c1">// sched.profilehz：用来设置性能分析的采样频率。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">profilehz</span> <span class="o">!=</span> <span class="nx">hz</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">setThreadCPUProfiler</span><span class="p">(</span><span class="nx">hz</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">trace</span><span class="p">.</span><span class="nx">enabled</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// GoSysExit has to happen when we have a P, but before GoStart.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// So we emit it here.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">syscallsp</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">sysblocktraced</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nf">traceGoSysExit</span><span class="p">(</span><span class="nx">gp</span><span class="p">.</span><span class="nx">sysexitticks</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="nf">traceGoStart</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// gogo完成从g0到gp真正的切换
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">gogo</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">gp</span><span class="p">.</span><span class="nx">sched</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="gogo">gogo()<a hidden class="anchor" aria-hidden="true" href="#gogo">#</a></h3>
<ol>
<li><code>gogo()</code>函数完成从<code>g0</code>到<code>gp</code>的的切换：<strong>CPU执行权的转让以及栈的切换</strong>。</li>
<li>函数原型：<code>func gogo(buf *gobuf)</code>。</li>
<li>参数<code>buf *gobuf</code>：需要切换的<code>goroutine</code>的调度信息。</li>
<li>文件位置：<code>go1.19.3/src/runtime/asm_amd64.s</code>。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">397
</span><span class="lnt">398
</span><span class="lnt">399
</span><span class="lnt">400
</span><span class="lnt">401
</span><span class="lnt">402
</span><span class="lnt">403
</span><span class="lnt">404
</span><span class="lnt">405
</span><span class="lnt">406
</span><span class="lnt">407
</span><span class="lnt">408
</span><span class="lnt">409
</span><span class="lnt">410
</span><span class="lnt">411
</span><span class="lnt">412
</span><span class="lnt">413
</span><span class="lnt">414
</span><span class="lnt">415
</span><span class="lnt">416
</span><span class="lnt">417
</span><span class="lnt">418
</span><span class="lnt">419
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-asm" data-lang="asm"><span class="line"><span class="cl"><span class="c1"># func gogo(buf *gobuf)
</span></span></span><span class="line"><span class="cl"><span class="c1"># restore state from Gobuf; longjmp
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nf">TEXT</span> <span class="no">runtime</span><span class="err">·</span><span class="no">gogo</span><span class="p">(</span><span class="no">SB</span><span class="p">),</span> <span class="no">NOSPLIT</span><span class="p">,</span> <span class="no">$0-8</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># 1) 取出gobuf信息，里面包含需要调度的信息
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1"># 取出需要调度的goroutine，gp.sched.g，判断这个goroutine不为nil
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="c1"># execute函数在调用gogo时把gp的sched成员的地址作为实参（型参buf）传递了过来
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1"># 该参数位于FP寄存器所指的位置，所以第一条指令是获取参数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1"># buf = &amp;gp.sched; BX = *gobuf
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">MOVQ</span>    <span class="no">buf</span><span class="err">+</span><span class="mi">0</span><span class="p">(</span><span class="no">FP</span><span class="p">),</span> <span class="no">BX</span> <span class="c1"># *gobuf
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    
</span></span><span class="line"><span class="cl">    <span class="c1"># 把buf的值也就是gp.sched的地址放在了BX寄存器之中
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1"># 这样便于后面的指令依靠BX寄存器来存取gp.sched的成员
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1"># 注意这里是间接寻址方式
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1"># gobuf-&gt;g --&gt; dx register
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">MOVQ</span>    <span class="no">gobuf_g</span><span class="p">(</span><span class="no">BX</span><span class="p">),</span> <span class="no">DX</span>	<span class="c1"># DX = gp.sched.g; *g
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    
</span></span><span class="line"><span class="cl">    <span class="c1"># 下面这行代码没有实质作用，检查gp.sched.g是否是nil，如果是nil进程会crash死掉
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1"># 如果DX为空使用0(DX)形式简介寻址会报错。确保 g 不是 nil。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">MOVQ</span>    <span class="mi">0</span><span class="p">(</span><span class="no">DX</span><span class="p">),</span> <span class="no">CX</span> <span class="c1"># make sure g != nil
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    
</span></span><span class="line"><span class="cl">    <span class="c1"># 2) 使用JMP指令跳转到gogo函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">JMP</span> <span class="no">gogo</span><span class="err">&lt;&gt;</span><span class="p">(</span><span class="no">SB</span><span class="p">)</span> <span class="c1"># 注意这里使用的是JMP
</span></span></span></code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">420
</span><span class="lnt">421
</span><span class="lnt">422
</span><span class="lnt">423
</span><span class="lnt">424
</span><span class="lnt">425
</span><span class="lnt">426
</span><span class="lnt">427
</span><span class="lnt">428
</span><span class="lnt">429
</span><span class="lnt">430
</span><span class="lnt">431
</span><span class="lnt">432
</span><span class="lnt">433
</span><span class="lnt">434
</span><span class="lnt">435
</span><span class="lnt">436
</span><span class="lnt">437
</span><span class="lnt">438
</span><span class="lnt">439
</span><span class="lnt">440
</span><span class="lnt">441
</span><span class="lnt">442
</span><span class="lnt">443
</span><span class="lnt">444
</span><span class="lnt">445
</span><span class="lnt">446
</span><span class="lnt">447
</span><span class="lnt">448
</span><span class="lnt">449
</span><span class="lnt">450
</span><span class="lnt">451
</span><span class="lnt">452
</span><span class="lnt">453
</span><span class="lnt">454
</span><span class="lnt">455
</span><span class="lnt">456
</span><span class="lnt">457
</span><span class="lnt">458
</span><span class="lnt">459
</span><span class="lnt">460
</span><span class="lnt">461
</span><span class="lnt">462
</span><span class="lnt">463
</span><span class="lnt">464
</span><span class="lnt">465
</span><span class="lnt">466
</span><span class="lnt">467
</span><span class="lnt">468
</span><span class="lnt">469
</span><span class="lnt">470
</span><span class="lnt">471
</span><span class="lnt">472
</span><span class="lnt">473
</span><span class="lnt">474
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-asm" data-lang="asm"><span class="line"><span class="cl"><span class="nf">TEXT</span> <span class="no">gogo</span><span class="err">&lt;&gt;</span><span class="p">(</span><span class="no">SB</span><span class="p">),</span> <span class="no">NOSPLIT</span><span class="p">,</span> <span class="no">$0</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># 3) 把gp放入TLS中和R14寄存器中
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="c1"># 获取当前工作线程M的fs段基址，前面把fs段基址设置成了&amp;m.tls[1]的地址
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">get_tls</span><span class="p">(</span><span class="no">CX</span><span class="p">)</span>         <span class="c1"># CX = &amp;m.tls[1] = TLS
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="c1"># 把DX值也就是需要运行的goroutine的指针写入线程本地存储之中
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1"># 运行这条指令之前，线程本地存储存放的是g0的地址
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">MOVQ</span>    <span class="no">DX</span><span class="p">,</span> <span class="no">g</span><span class="p">(</span><span class="no">CX</span><span class="p">)</span>   <span class="c1"># TLS = gp.sched.g
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="c1"># 在g1.17和1.18版本中 R14寄存器被用来指向当前goroutine的runtime.g结构
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1"># R14 = gp.sched.g
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">MOVQ</span>    <span class="no">DX</span><span class="p">,</span> <span class="no">R14</span>     <span class="c1"># set the g register
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="c1"># 4) 设置栈顶SP寄存器，切gp的栈，切换栈
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="c1"># 把CPU的SP寄存器设置为sched.sp，完成了栈的切换，gp.sched.sp记录着g的栈顶位置
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1"># 设置CPU的栈顶寄存器SP为gp.sched.sp，这条指令完成了栈的切换，从g0的栈切换到了gp的栈
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1"># rsp = gp.sched.sp
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">MOVQ</span>    <span class="no">gobuf_sp</span><span class="p">(</span><span class="no">BX</span><span class="p">),</span> <span class="no">SP</span>    <span class="c1"># restore SP
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="c1"># 5) 设置 AX = gp.sched.ret
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">#    设置 DX = gp.sched.ctxt    闭包上下文
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">#    设置 BP = BP = gp.sched.bp 栈底寄存器
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="c1"># 下面三条同样是恢复调度上下文到CPU相关寄存器
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1"># 需要返回的地址
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">MOVQ</span>    <span class="no">gobuf_ret</span><span class="p">(</span><span class="no">BX</span><span class="p">),</span> <span class="no">AX</span>   <span class="c1"># AX = gp.sched.ret		
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1"># 上下文环境，也就是当前注册函数的闭包捕获层，funcval地址处
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">MOVQ</span>    <span class="no">gobuf_ctxt</span><span class="p">(</span><span class="no">BX</span><span class="p">),</span> <span class="no">DX</span>  <span class="c1"># DX = gp.sched.ctxt	
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1"># 设置栈基地址
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">MOVQ</span>    <span class="no">gobuf_bp</span><span class="p">(</span><span class="no">BX</span><span class="p">),</span> <span class="no">BP</span>    <span class="c1"># BP = gp.sched.bp		
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="c1"># 6) 清空gp的gobuf.sp、gobuf.ret、gobuf.ctxt、gobuf.bp
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="c1"># 清空gp.sched中不再需要的值，因为我们已把相关值放入CPU对应的寄存器了
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1"># clear to help garbage collector
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">MOVQ</span>    <span class="no">$0</span><span class="p">,</span> <span class="no">gobuf_sp</span><span class="p">(</span><span class="no">BX</span><span class="p">)</span>    <span class="c1"># g.gobuf.sp = 0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">MOVQ</span>    <span class="no">$0</span><span class="p">,</span> <span class="no">gobuf_ret</span><span class="p">(</span><span class="no">BX</span><span class="p">)</span>   <span class="c1"># g.gobuf.ret = 0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">MOVQ</span>    <span class="no">$0</span><span class="p">,</span> <span class="no">gobuf_ctxt</span><span class="p">(</span><span class="no">BX</span><span class="p">)</span>  <span class="c1"># g.gobuf.ctxt = 0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">MOVQ</span>    <span class="no">$0</span><span class="p">,</span> <span class="no">gobuf_bp</span><span class="p">(</span><span class="no">BX</span><span class="p">)</span>    <span class="c1"># g.gobuf.bp = 0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="c1"># 7) 跳转到g.gobuf.pc执行gp的相关代码
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1"># 注意：从g0切换的gp过程中，并没有保存g0的相关栈信息
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="c1"># gp.sched.pc 记录着注册函数开始的代码地址
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1"># 把gp.sched.pc的值读取到BX寄存器，这个pc值是gp这个goroutine马上需要执行的第一条指令的地址
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1"># 对于runtime.main这个场景来说它现在就是runtime.main函数的第一条指令，现在这条指令的地址就放在BX寄存器里面
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1"># DX寄存器作为上下文，记录着闭包函数的相关捕获变量
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">MOVQ</span>    <span class="no">gobuf_pc</span><span class="p">(</span><span class="no">BX</span><span class="p">),</span> <span class="no">BX</span>    <span class="c1"># BX = g.gobuf.pc
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="c1"># 这里的JMP BX指令把BX寄存器里面的指令地址放入CPU的rip寄存器
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1"># 于是，CPU就会跳转到该地址继续执行属于gp这个goroutine的代码，这样就完成了goroutine的切换
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1"># 还需要注意的是：DX寄存器的值 gp.sched.ctxt 存储的是闭包的上下文信息，如果闭包捕获了变量则会使用它。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">JMP</span> <span class="no">BX</span>  <span class="c1"># 跳转到注册的goroutine去执行了
</span></span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>总结：
<ol>
<li><code>execute()</code>函数完成从系统栈<code>g0</code>切换到普通<code>goroutine</code>的过程（这里是参数<code>gp</code>）。</li>
<li>该函数将工作线程<code>m</code>与<code>gp</code>相互绑定，然后切换<code>gp</code>的状态并设置栈溢出相关参数，以及设置调度次数，</li>
<li>接着调用<code>gogo()</code>函数把栈从<code>g0</code>切换成<code>gp</code>的栈，并把<code>gp</code>的调度信息保存在相关寄存器中，然后切换到<code>gp</code>开始执行相关代码。</li>
<li>这里需要注意的是，从<code>g0</code>切换到<code>gp</code>过程中并没有保存<code>g0</code>的相关栈顶<code>SP</code>相关信息，因此<code>g0</code>栈总是从一个固定的开始的位置开始的。</li>
</ol>
</li>
</ul>
<h2 id="其他相关函数">其他相关函数<a hidden class="anchor" aria-hidden="true" href="#其他相关函数">#</a></h2>
<h3 id="checktimers">checkTimers()<a hidden class="anchor" aria-hidden="true" href="#checktimers">#</a></h3>
<ol>
<li>该函数是唤醒<code>time.Sleep</code>、<code>time.Timer</code>等的相关函数，查看<code>runtime.timer</code>文档。</li>
<li>文件位置：<code>go1.19.3/src/runtime/proc.go</code>。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">3269
</span><span class="lnt">3270
</span><span class="lnt">3271
</span><span class="lnt">3272
</span><span class="lnt">3273
</span><span class="lnt">3274
</span><span class="lnt">3275
</span><span class="lnt">3276
</span><span class="lnt">3277
</span><span class="lnt">3278
</span><span class="lnt">3279
</span><span class="lnt">3280
</span><span class="lnt">3281
</span><span class="lnt">3282
</span><span class="lnt">3283
</span><span class="lnt">3284
</span><span class="lnt">3285
</span><span class="lnt">3286
</span><span class="lnt">3287
</span><span class="lnt">3288
</span><span class="lnt">3289
</span><span class="lnt">3290
</span><span class="lnt">3291
</span><span class="lnt">3292
</span><span class="lnt">3293
</span><span class="lnt">3294
</span><span class="lnt">3295
</span><span class="lnt">3296
</span><span class="lnt">3297
</span><span class="lnt">3298
</span><span class="lnt">3299
</span><span class="lnt">3300
</span><span class="lnt">3301
</span><span class="lnt">3302
</span><span class="lnt">3303
</span><span class="lnt">3304
</span><span class="lnt">3305
</span><span class="lnt">3306
</span><span class="lnt">3307
</span><span class="lnt">3308
</span><span class="lnt">3309
</span><span class="lnt">3310
</span><span class="lnt">3311
</span><span class="lnt">3312
</span><span class="lnt">3313
</span><span class="lnt">3314
</span><span class="lnt">3315
</span><span class="lnt">3316
</span><span class="lnt">3317
</span><span class="lnt">3318
</span><span class="lnt">3319
</span><span class="lnt">3320
</span><span class="lnt">3321
</span><span class="lnt">3322
</span><span class="lnt">3323
</span><span class="lnt">3324
</span><span class="lnt">3325
</span><span class="lnt">3326
</span><span class="lnt">3327
</span><span class="lnt">3328
</span><span class="lnt">3329
</span><span class="lnt">3330
</span><span class="lnt">3331
</span><span class="lnt">3332
</span><span class="lnt">3333
</span><span class="lnt">3334
</span><span class="lnt">3335
</span><span class="lnt">3336
</span><span class="lnt">3337
</span><span class="lnt">3338
</span><span class="lnt">3339
</span><span class="lnt">3340
</span><span class="lnt">3341
</span><span class="lnt">3342
</span><span class="lnt">3343
</span><span class="lnt">3344
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// checkTimers runs any timers for the P that are ready.
</span></span></span><span class="line"><span class="cl"><span class="c1">// If now is not 0 it is the current time.
</span></span></span><span class="line"><span class="cl"><span class="c1">// It returns the passed time or the current time if now was passed as 0.
</span></span></span><span class="line"><span class="cl"><span class="c1">// and the time when the next timer should run or 0 if there is no next timer,
</span></span></span><span class="line"><span class="cl"><span class="c1">// and reports whether it ran any timers.
</span></span></span><span class="line"><span class="cl"><span class="c1">// If the time when the next timer should run is not 0,
</span></span></span><span class="line"><span class="cl"><span class="c1">// it is always larger than the returned time.
</span></span></span><span class="line"><span class="cl"><span class="c1">// We pass now in and out to avoid extra calls of nanotime.
</span></span></span><span class="line"><span class="cl"><span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1">//go:yeswritebarrierrec
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">checkTimers</span><span class="p">(</span><span class="nx">pp</span> <span class="o">*</span><span class="nx">p</span><span class="p">,</span> <span class="nx">now</span> <span class="kt">int64</span><span class="p">)</span> <span class="p">(</span><span class="nx">rnow</span><span class="p">,</span> <span class="nx">pollUntil</span> <span class="kt">int64</span><span class="p">,</span> <span class="nx">ran</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// If it&#39;s not yet time for the first timer, or the first adjusted
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// timer, then there is nothing to do.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">next</span> <span class="o">:=</span> <span class="nb">int64</span><span class="p">(</span><span class="nx">atomic</span><span class="p">.</span><span class="nf">Load64</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">pp</span><span class="p">.</span><span class="nx">timer0When</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">    <span class="nx">nextAdj</span> <span class="o">:=</span> <span class="nb">int64</span><span class="p">(</span><span class="nx">atomic</span><span class="p">.</span><span class="nf">Load64</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">pp</span><span class="p">.</span><span class="nx">timerModifiedEarliest</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">next</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="p">(</span><span class="nx">nextAdj</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">nextAdj</span> <span class="p">&lt;</span> <span class="nx">next</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">next</span> <span class="p">=</span> <span class="nx">nextAdj</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">next</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// No timers to run or adjust.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 无需运行或调整计时器
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">return</span> <span class="nx">now</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="kc">false</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">now</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">now</span> <span class="p">=</span> <span class="nf">nanotime</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">now</span> <span class="p">&lt;</span> <span class="nx">next</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// Next timer is not ready to run, but keep going
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// if we would clear deleted timers.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// This corresponds to the condition below where
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// we decide whether to call clearDeletedTimers.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="nx">pp</span> <span class="o">!=</span> <span class="nf">getg</span><span class="p">().</span><span class="nx">m</span><span class="p">.</span><span class="nx">p</span><span class="p">.</span><span class="nf">ptr</span><span class="p">()</span> <span class="o">||</span> <span class="nb">int</span><span class="p">(</span><span class="nx">atomic</span><span class="p">.</span><span class="nf">Load</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">pp</span><span class="p">.</span><span class="nx">deletedTimers</span><span class="p">))</span> <span class="o">&lt;=</span> <span class="nb">int</span><span class="p">(</span><span class="nx">atomic</span><span class="p">.</span><span class="nf">Load</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">pp</span><span class="p">.</span><span class="nx">numTimers</span><span class="p">)</span><span class="o">/</span><span class="mi">4</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="nx">now</span><span class="p">,</span> <span class="nx">next</span><span class="p">,</span> <span class="kc">false</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">pp</span><span class="p">.</span><span class="nx">timersLock</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 如果当前P的timers存在数据
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">pp</span><span class="p">.</span><span class="nx">timers</span><span class="p">)</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>	<span class="c1">// pp.timers记录着当前P中所有相关的timer
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// adjusttimers 在当前 P 的堆中查找任何已修改为更早运行的定时器，并将它们放在堆中的正确位置
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 在查找这些计时器时，它还会移动已修改为稍后运行的计时器，并删除已删除的计时器
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 调用者必须锁定 pp 的计时器
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nf">adjusttimers</span><span class="p">(</span><span class="nx">pp</span><span class="p">,</span> <span class="nx">now</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="nb">len</span><span class="p">(</span><span class="nx">pp</span><span class="p">.</span><span class="nx">timers</span><span class="p">)</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// Note that runtimer may temporarily unlock
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// pp.timersLock.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// 请注意，runtimer 可能会暂时解锁 pp.timersLock
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// runtimer函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// runtimer 检查timers中的第一个timer。 如果它基于now准备好，它会运行timer并删除或更新它
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// 如果它运行了一个timer，则返回 0，如果没有更多的timer，则返回 -1，或者第一个timer应该运行的时间
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="k">if</span> <span class="nx">tw</span> <span class="o">:=</span> <span class="nf">runtimer</span><span class="p">(</span><span class="nx">pp</span><span class="p">,</span> <span class="nx">now</span><span class="p">);</span> <span class="nx">tw</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="k">if</span> <span class="nx">tw</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                    <span class="nx">pollUntil</span> <span class="p">=</span> <span class="nx">tw</span>
</span></span><span class="line"><span class="cl">                <span class="p">}</span>
</span></span><span class="line"><span class="cl">                <span class="k">break</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="nx">ran</span> <span class="p">=</span> <span class="kc">true</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// If this is the local P, and there are a lot of deleted timers,
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// clear them out. We only do this for the local P to reduce
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// lock contention on timersLock.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 如果当前P是当前工作线程绑定的P，并且有很多被删除的timer，清除它们
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 我们只对本地 P 这样做，以减少 timersLock 上的锁争用
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nx">pp</span> <span class="o">==</span> <span class="nf">getg</span><span class="p">().</span><span class="nx">m</span><span class="p">.</span><span class="nx">p</span><span class="p">.</span><span class="nf">ptr</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="nb">int</span><span class="p">(</span><span class="nx">atomic</span><span class="p">.</span><span class="nf">Load</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">pp</span><span class="p">.</span><span class="nx">deletedTimers</span><span class="p">))</span> <span class="p">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">pp</span><span class="p">.</span><span class="nx">timers</span><span class="p">)</span><span class="o">/</span><span class="mi">4</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">clearDeletedTimers</span><span class="p">(</span><span class="nx">pp</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">pp</span><span class="p">.</span><span class="nx">timersLock</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nx">now</span><span class="p">,</span> <span class="nx">pollUntil</span><span class="p">,</span> <span class="nx">ran</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="checkdead">checkdead()<a hidden class="anchor" aria-hidden="true" href="#checkdead">#</a></h3>
<ol>
<li>检查死锁情况。检查基于正在运行的M的数量，如果<code>0 -&gt; deadlock</code>。</li>
<li><code>sched.lock</code>必须被持有。</li>
<li>文件位置：<code>go1.19.3/src/runtime/proc.go</code>。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">5017
</span><span class="lnt">5018
</span><span class="lnt">5019
</span><span class="lnt">5020
</span><span class="lnt">5021
</span><span class="lnt">5022
</span><span class="lnt">5023
</span><span class="lnt">5024
</span><span class="lnt">5025
</span><span class="lnt">5026
</span><span class="lnt">5027
</span><span class="lnt">5028
</span><span class="lnt">5029
</span><span class="lnt">5030
</span><span class="lnt">5031
</span><span class="lnt">5032
</span><span class="lnt">5033
</span><span class="lnt">5034
</span><span class="lnt">5035
</span><span class="lnt">5036
</span><span class="lnt">5037
</span><span class="lnt">5038
</span><span class="lnt">5039
</span><span class="lnt">5040
</span><span class="lnt">5041
</span><span class="lnt">5042
</span><span class="lnt">5043
</span><span class="lnt">5044
</span><span class="lnt">5045
</span><span class="lnt">5046
</span><span class="lnt">5047
</span><span class="lnt">5048
</span><span class="lnt">5049
</span><span class="lnt">5050
</span><span class="lnt">5051
</span><span class="lnt">5052
</span><span class="lnt">5053
</span><span class="lnt">5054
</span><span class="lnt">5055
</span><span class="lnt">5056
</span><span class="lnt">5057
</span><span class="lnt">5058
</span><span class="lnt">5059
</span><span class="lnt">5060
</span><span class="lnt">5061
</span><span class="lnt">5062
</span><span class="lnt">5063
</span><span class="lnt">5064
</span><span class="lnt">5065
</span><span class="lnt">5066
</span><span class="lnt">5067
</span><span class="lnt">5068
</span><span class="lnt">5069
</span><span class="lnt">5070
</span><span class="lnt">5071
</span><span class="lnt">5072
</span><span class="lnt">5073
</span><span class="lnt">5074
</span><span class="lnt">5075
</span><span class="lnt">5076
</span><span class="lnt">5077
</span><span class="lnt">5078
</span><span class="lnt">5079
</span><span class="lnt">5080
</span><span class="lnt">5081
</span><span class="lnt">5082
</span><span class="lnt">5083
</span><span class="lnt">5084
</span><span class="lnt">5085
</span><span class="lnt">5086
</span><span class="lnt">5087
</span><span class="lnt">5088
</span><span class="lnt">5089
</span><span class="lnt">5090
</span><span class="lnt">5091
</span><span class="lnt">5092
</span><span class="lnt">5093
</span><span class="lnt">5094
</span><span class="lnt">5095
</span><span class="lnt">5096
</span><span class="lnt">5097
</span><span class="lnt">5098
</span><span class="lnt">5099
</span><span class="lnt">5100
</span><span class="lnt">5101
</span><span class="lnt">5102
</span><span class="lnt">5103
</span><span class="lnt">5104
</span><span class="lnt">5105
</span><span class="lnt">5106
</span><span class="lnt">5107
</span><span class="lnt">5108
</span><span class="lnt">5109
</span><span class="lnt">5110
</span><span class="lnt">5111
</span><span class="lnt">5112
</span><span class="lnt">5113
</span><span class="lnt">5114
</span><span class="lnt">5115
</span><span class="lnt">5116
</span><span class="lnt">5117
</span><span class="lnt">5118
</span><span class="lnt">5119
</span><span class="lnt">5120
</span><span class="lnt">5121
</span><span class="lnt">5122
</span><span class="lnt">5123
</span><span class="lnt">5124
</span><span class="lnt">5125
</span><span class="lnt">5126
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// Check for deadlock situation.
</span></span></span><span class="line"><span class="cl"><span class="c1">// The check is based on number of running M&#39;s, if 0 -&gt; deadlock.
</span></span></span><span class="line"><span class="cl"><span class="c1">// sched.lock must be held.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">checkdead</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// sched.lock 必须被持有
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">assertLockHeld</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// For -buildmode=c-shared or -buildmode=c-archive it&#39;s OK if
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// there are no running goroutines. The calling program is
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// assumed to be running.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nx">islibrary</span> <span class="o">||</span> <span class="nx">isarchive</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// If we are dying because of a signal caught on an already idle thread,
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// freezetheworld will cause all running threads to block.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// And runtime will essentially enter into deadlock state,
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// except that there is a thread that will call exit soon.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nx">panicking</span><span class="p">.</span><span class="nf">Load</span><span class="p">()</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// If we are not running under cgo, but we have an extra M then account
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// for it. (It is possible to have an extra M on Windows without cgo to
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// accommodate callbacks created by syscall.NewCallback. See issue #6751
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// for details.)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kd">var</span> <span class="nx">run0</span> <span class="kt">int32</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">!</span><span class="nx">iscgo</span> <span class="o">&amp;&amp;</span> <span class="nx">cgoHasExtraM</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">mp</span> <span class="o">:=</span> <span class="nf">lockextra</span><span class="p">(</span><span class="kc">true</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="nx">haveExtraM</span> <span class="o">:=</span> <span class="nx">extraMCount</span> <span class="p">&gt;</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">        <span class="nf">unlockextra</span><span class="p">(</span><span class="nx">mp</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="nx">haveExtraM</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nx">run0</span> <span class="p">=</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">//func mcount() int32 {
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//    return int32(sched.mnext - sched.nmfreed)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//}
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">run</span> <span class="o">:=</span> <span class="nf">mcount</span><span class="p">()</span> <span class="o">-</span> <span class="nx">sched</span><span class="p">.</span><span class="nx">nmidle</span> <span class="o">-</span> <span class="nx">sched</span><span class="p">.</span><span class="nx">nmidlelocked</span> <span class="o">-</span> <span class="nx">sched</span><span class="p">.</span><span class="nx">nmsys</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">run</span> <span class="p">&gt;</span> <span class="nx">run0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">run</span> <span class="p">&lt;</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nb">print</span><span class="p">(</span><span class="s">&#34;runtime: checkdead: nmidle=&#34;</span><span class="p">,</span> <span class="nx">sched</span><span class="p">.</span><span class="nx">nmidle</span><span class="p">,</span> <span class="s">&#34; nmidlelocked=&#34;</span><span class="p">,</span> <span class="nx">sched</span><span class="p">.</span><span class="nx">nmidlelocked</span><span class="p">,</span> <span class="s">&#34; mcount=&#34;</span><span class="p">,</span> <span class="nf">mcount</span><span class="p">(),</span> <span class="s">&#34; nmsys=&#34;</span><span class="p">,</span> <span class="nx">sched</span><span class="p">.</span><span class="nx">nmsys</span><span class="p">,</span> <span class="s">&#34;\n&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="nf">throw</span><span class="p">(</span><span class="s">&#34;checkdead: inconsistent counts&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nx">grunning</span> <span class="o">:=</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">    <span class="nf">forEachG</span><span class="p">(</span><span class="kd">func</span><span class="p">(</span><span class="nx">gp</span> <span class="o">*</span><span class="nx">g</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="nf">isSystemGoroutine</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="kc">false</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="nx">s</span> <span class="o">:=</span> <span class="nf">readgstatus</span><span class="p">(</span><span class="nx">gp</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">switch</span> <span class="nx">s</span> <span class="o">&amp;^</span> <span class="nx">_Gscan</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">case</span> <span class="nx">_Gwaiting</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">            <span class="nx">_Gpreempted</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">            <span class="nx">grunning</span><span class="o">++</span>
</span></span><span class="line"><span class="cl">        <span class="k">case</span> <span class="nx">_Grunnable</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">            <span class="nx">_Grunning</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">            <span class="nx">_Gsyscall</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">            <span class="nb">print</span><span class="p">(</span><span class="s">&#34;runtime: checkdead: find g &#34;</span><span class="p">,</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">goid</span><span class="p">,</span> <span class="s">&#34; in status &#34;</span><span class="p">,</span> <span class="nx">s</span><span class="p">,</span> <span class="s">&#34;\n&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="nf">throw</span><span class="p">(</span><span class="s">&#34;checkdead: runnable g&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">})</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">grunning</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span> <span class="c1">// possible if main goroutine calls runtime·Goexit()
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span> <span class="c1">// unlock so that GODEBUG=scheddetail=1 doesn&#39;t hang
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nf">fatal</span><span class="p">(</span><span class="s">&#34;no goroutines (main called runtime.Goexit) - deadlock!&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// Maybe jump time forward for playground.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nx">faketime</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="nx">when</span> <span class="o">:=</span> <span class="nf">timeSleepUntil</span><span class="p">();</span> <span class="nx">when</span> <span class="p">&lt;</span> <span class="nx">maxWhen</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nx">faketime</span> <span class="p">=</span> <span class="nx">when</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            <span class="c1">// Start an M to steal the timer.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="nx">pp</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nf">pidleget</span><span class="p">(</span><span class="nx">faketime</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="nx">pp</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="c1">// There should always be a free P since
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="c1">// nothing is running.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="nf">throw</span><span class="p">(</span><span class="s">&#34;checkdead: no p for timer&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="nx">mp</span> <span class="o">:=</span> <span class="nf">mget</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="nx">mp</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="c1">// There should always be a free M since
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="c1">// nothing is running.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="nf">throw</span><span class="p">(</span><span class="s">&#34;checkdead: no m for timer&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// M must be spinning to steal. We set this to be
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// explicit, but since this is the only M it would
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// become spinning on its own anyways.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="nx">sched</span><span class="p">.</span><span class="nx">nmspinning</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="nx">mp</span><span class="p">.</span><span class="nx">spinning</span> <span class="p">=</span> <span class="kc">true</span>
</span></span><span class="line"><span class="cl">            <span class="nx">mp</span><span class="p">.</span><span class="nx">nextp</span><span class="p">.</span><span class="nf">set</span><span class="p">(</span><span class="nx">pp</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="nf">notewakeup</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">mp</span><span class="p">.</span><span class="nx">park</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// There are no goroutines running, so we can look at the P&#39;s.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">pp</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">allp</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 当某个P中存在timer，即使全部P都睡眠了也不会报错
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">pp</span><span class="p">.</span><span class="nx">timers</span><span class="p">)</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span> <span class="c1">// unlock so that GODEBUG=scheddetail=1 doesn&#39;t hang
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">fatal</span><span class="p">(</span><span class="s">&#34;all goroutines are asleep - deadlock!&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div>

  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://heliu.site/tags/golang/">Golang</a></li>
      <li><a href="https://heliu.site/tags/goroutine/">Goroutine</a></li>
    </ul>
<nav class="paginav">
  <a class="prev" href="https://heliu.site/posts/golang/goroutine/main/">
    <span class="title">« 上一页</span>
    <br>
    <span>main goroutine</span>
  </a>
  <a class="next" href="https://heliu.site/posts/golang/goroutine/sysmon/">
    <span class="title">下一页 »</span>
    <br>
    <span>sysmon 监控线程</span>
  </a>
</nav>

  </footer>
</article>
    </main>
    
<footer class="footer">
    
    <div class="busuanzi-footer">
    <span id="busuanzi_container_site_pv">
        本站总访问量<span id="busuanzi_value_site_pv"></span>次
    </span>
    <span id="busuanzi_container_site_uv">
        本站访客数<span id="busuanzi_value_site_uv"></span>人次
    </span>
    </div>
        <span>Copyright © 2024 蜀ICP备2024091074号 <a href="#">heliu's blog</a>. All rights reserved</span>  
    
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'Copy';

        function copyingDone() {
            copybutton.innerHTML = 'Done';
            setTimeout(() => {
                copybutton.innerHTML = 'Copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
