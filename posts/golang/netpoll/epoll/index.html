<!DOCTYPE html>
<html lang="zh" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Golang epoll | Helium</title>
<meta name="keywords" content="golang, netpoll">
<meta name="description" content="💥本文章所有相关go代码参考自go 1.18&#43;版本">
<meta name="author" content="helium">
<link rel="canonical" href="https://heliu.site/posts/golang/netpoll/epoll/">
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<meta name="referrer" content="no-referrer-when-downgrade">
<link crossorigin="anonymous" href="/assets/css/stylesheet.css" rel="preload stylesheet" as="style">
<link rel="icon" href="https://heliu.site/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://heliu.site/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://heliu.site/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://heliu.site/apple-touch-icon.png">
<link rel="mask-icon" href="https://heliu.site/apple-touch-icon.png">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="zh" href="https://heliu.site/posts/golang/netpoll/epoll/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
<html>
<head>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/jetbrains-mono@1.0.6/css/jetbrains-mono-nl.min.css" />
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lxgw-wenkai-lite-webfont@1.1.0/style.css" />
    <link rel="stylesheet" href="https://cdn.staticfile.org/lxgw-wenkai-screen-webfont/1.6.0/style.css" />
    <style>
        body {
            font-family: "LXGW WenKai Lite", sans-serif;
            font-family: "LXGW WenKai Screen", sans-serif;
        }
    </style>
</head>
</html>

  

<meta property="og:title" content="Golang epoll" />
<meta property="og:description" content="💥本文章所有相关go代码参考自go 1.18&#43;版本" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://heliu.site/posts/golang/netpoll/epoll/" />
<meta property="og:image" content="https://heliu.site/favicon-32x32.png" />
<meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-07-20T21:59:40+08:00" />
<meta property="article:modified_time" content="2024-07-20T21:59:40+08:00" /><meta property="og:site_name" content="Helium" />

<meta name="twitter:card" content="summary_large_image" />
<meta name="twitter:image" content="https://heliu.site/favicon-32x32.png" />
<meta name="twitter:title" content="Golang epoll"/>
<meta name="twitter:description" content="💥本文章所有相关go代码参考自go 1.18&#43;版本"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Article",
      "item": "https://heliu.site/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Golang 合集",
      "item": "https://heliu.site/posts/golang/"
    }, 
    {
      "@type": "ListItem",
      "position":  3 ,
      "name": "第16章 netpoll",
      "item": "https://heliu.site/posts/golang/netpoll/"
    }, 
    {
      "@type": "ListItem",
      "position":  4 ,
      "name": "Golang epoll",
      "item": "https://heliu.site/posts/golang/netpoll/epoll/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Golang epoll",
  "name": "Golang epoll",
  "description": "💥本文章所有相关go代码参考自go 1.18+版本",
  "keywords": [
    "golang", "netpoll"
  ],
  "articleBody": " 以下来自go1.19.3/src/runtime/netpoll_epoll.go文件。 本篇文章是针对netpoll_epoll.go文件的源码走读。 variables 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 var ( // epoll 描述符, epollcreate 函数创建返回的文件描述符 epfd int32 = -1 // epoll descriptor // 保存的是pipe2()或pip()函数创建的读写描述符，pip2()或pip()函数创建的read和write，只要任意一方操作另一方能获取到数据 // netpollBreakRd会被注册到epoll中，当写描述符向里写数据时会触发wait监听函数返回就绪的事件集 // 这对读写描述符的作用在于通信，当有其他协程在wait阻塞等待时，可以通过写描述符写入数据让等待的协程返回 // 主要针对 epoll_wait() 函数阻塞的线程，通过这里的事件使调用 epoll_wait() 函数的线程陷入内核返回。 // 对于 epoll_wait() 的 timeout 参数为0的情况，这里的事件会被忽略 netpollBreakRd, netpollBreakWr uintptr // for netpollBreak // 用于避免重复调用 netpollBreak() // 在向netpollBreakWr中写入数据时，该值会从0变成1，控制只写一次标志符号 // 该参数是原子性的 netpollWakeSig uint32 // used to avoid duplicate calls of netpollBreak ) netpollGenericInit() 初始化netpoll。go1.19.3/src/runtime/netpoll.go文件。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 func netpollGenericInit() { // var netpollInited uint32 // 是否已初始化epoll标志 0.未初始化 1.已初始化 if atomic.Load(\u0026netpollInited) == 0 { // var netpollInitLock mutex 初始化 lockInit(\u0026netpollInitLock, lockRankNetpollInit) lock(\u0026netpollInitLock) // 这里需要判断 netpollInited == 0；原因在于可能存在多个协程并发在等待初始化epoll // 当这些协程获取的锁权限时，这里的netpollInited已被设置成1了，已经被初始化了 if netpollInited == 0 { netpollinit() // 初始化netpoll atomic.Store(\u0026netpollInited, 1)\t// netpollInited } unlock(\u0026netpollInitLock) } } netpollinit() go1.19.3/src/runtime/netpoll_epoll.go。 调用epollcreate创建netpoller。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 func netpollinit() { // epollcreate 函数内会调用 epollcreate1 // _EPOLL_CLOEXEC：当前进程fork出来的任何子进程在执行前都会关闭epoll描述符，也因此，子进程不能够访问epoll实例 epfd = epollcreate1(_EPOLL_CLOEXEC) // 小于0表示创建出错，大于0表示返回的创建后的文件句柄ID if epfd \u003c 0 {\tepfd = epollcreate(1024) if epfd \u003c 0 { println(\"runtime: epollcreate failed with\", -epfd) throw(\"runtime: netpollinit failed\") } // 系统调用 fcntl 设置 FD_CLOEXEC，参看 epollcreate1 函数参数 // fcntl：fd, F_SETFD, FD_CLOEXEC closeonexec(epfd) } // 创建一个用于通信的管道,返回读写,主要用于那些等待在IO轮询中的线程通信 // 创建一个非阻塞式pipe，用来唤醒阻塞中的 netpoller。 // pipe2(_O_NONBLOCK | _O_CLOEXEC) r, w, errno := nonblockingPipe() // 主要用于Break相关的函数，主要用于网络轮询唤醒信号 if errno != 0 { println(\"runtime: pipe failed with\", -errno) throw(\"runtime: pipe failed\") } // epollevent 是事件类型 // type epollevent struct { //\tevents uint32 // 事件类型 //\tdata [8]byte // 存储用户数据，刚好是一个指针存储的大小，该数据用户是可以修改的 // } ev := epollevent{ // 注意：这里默认注册的是水平触发，因此会一直触发 events: _EPOLLIN, // EPOLLIN 表示对应的文件描述符可以读（包括对端SOCKET正常关闭） } // var netpollBreakRd uintptr *(**uintptr)(unsafe.Pointer(\u0026ev.data)) = \u0026netpollBreakRd // ev.data = \u0026netpollBreakRd // 将读取数据的文件描述符加入监听，当使用w写数据时，该r会被触发 // func epollctl(epfd, op, fd int32, ev *epollevent) int32 // _EPOLL_CTL_ADD 将目标文件描述符fd添加到epoll描述符epfd中，并将事件event与fd链接的内部文件关联起来。 errno = epollctl(epfd, _EPOLL_CTL_ADD, r, \u0026ev) // r 被添加到epoll中 if errno != 0 { println(\"runtime: epollctl failed with\", -errno) throw(\"runtime: epollctl failed\") } // netpollBreakRd、netpollBreakWr 是非阻塞管道两端的文件描述符，分别被用作读取端和写入端。 // 读取端 netpollBreakRd 被添加到 epoll 中监听 _EPOLLIN 事件，后续从写入端netpollBreakWr // 写入数据就能唤醒阻塞中的 poller。 netpollBreakRd = uintptr(r) // netpollBreakRd保存pip2的read netpollBreakWr = uintptr(w) // netpollBreakRd保存pip2的write } netpollopen() 把要监听的文件描述符fd和与之关联的pollDesc结构添加到poller实例中。 该方法对于一个socket只需调用一次即可，表示注册fd到epoll中。 参数： fd uintptr：文件描述符。 pd *pollDesc：用户数据。 返回值：int32：0-注册成功。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 func netpollopen(fd uintptr, pd *pollDesc) int32 { // type epollevent struct { // events uint32 // 事件类型 // data [8]byte // 存储用户数据，刚好是一个指针存储的大小，该数据用户是可以修改的 // } var ev epollevent // EPOLLIN：表示对应的文件描述符可以读（包括对端SOCKET正常关闭） // EPOLLOUT：表示对应的文件描述符可以写 // EPOLLRDHUP：对端描述符产生一个挂断事件，比如来自对端的socket挂断事件等 // EPOLLET：将EPOLL设为边缘触发(Edge Triggered)模式，这是相对于水平触发(Level Triggered)来说的 // pollDesc：类型的数据结构pd作为与fd关联的自定数据会被一同添加到epoll中。 ev.events = _EPOLLIN | _EPOLLOUT | _EPOLLRDHUP | _EPOLLET // epollevent 是由events和data组成，data来自用户空间传入的数据 *(**pollDesc)(unsafe.Pointer(\u0026ev.data)) = pd // ev.data = pd // _EPOLL_CTL_ADD 将目标文件描述符fd添加到epoll描述符epfd中，并将事件event与fd链接的内部文件关联起来。 return -epollctl(epfd, _EPOLL_CTL_ADD, int32(fd), \u0026ev) } 触发模式LT\\ ET： 水平触发：LT 对于读操作，只要缓冲内容不为空，LT模式返回读就绪。 对于写操作，只要缓冲区还不满，LT模式会返回写就绪。 水平触发描述： 当被监控的文件描述符上有可读写事件发生时，epoll_wait()会通知处理程序去读写。 如果这次没有把数据一次性全部读写完(如读写缓冲区太小)，那么下次调用 epoll_wait()时，它还会通知你在上没读写完的文件描述符上继续读写，当然如果你一直不去读写，它会一直通知你。 如果系统中有大量你不需要读写的就绪文件描述符，而它们每次都会返回，这样会大大降低处理程序检索自己关心的就绪文件描述符的效率。 边缘触发：ET 对于读操作： 当缓冲区由不可读变为可读的时候，即缓冲区由空变为不空的时候。 当有新数据到达时，即缓冲区中的待读数据变多的时候。 当缓冲区有数据可读，且应用进程对相应的描述符进行EPOLL_CTL_MOD修改EPOLLIN事件时。 对于写操作： 当缓冲区由不可写变为可写时。 当有旧数据被发送走，即缓冲区中的内容变少的时候。 当缓冲区有空间可写，且应用进程对相应的描述符进行EPOLL_CTL_MOD修改EPOLLOUT事件时。 边缘触发描述： 当被监控的文件描述符上有可读写事件发生时，epoll_wait()会通知处理程序去读写。 如果这次没有把数据全部读写完(如读写缓冲区太小)，那么下次调用 epoll_wait()时，它不会通知你，也就是它只会通知你一次，直到该文件描述符上出现第二次可读写事件才会通知你。 这种模式比水平触发效率高，系统不会充斥大量你不关心的就绪文件描述符。 在ET模式下，缓冲区从不可读变成可读，会唤醒应用进程，缓冲区数据变少的情况，则不会再唤醒应用进程。 举例： 举例1： 读缓冲区刚开始是空的 读缓冲区写入2KB数据 水平触发和边缘触发模式此时都会发出可读信号 收到信号通知后，读取了1KB的数据，读缓冲区还剩余1KB数据 水平触发会再次进行通知，而边缘触发不会再进行通知 举例2： 水平触发：0为无数据，1为有数据。缓冲区有数据则一直为1，则一直触发。 边缘触发：0为无数据，1为有数据，只要在0变到1的上升沿才触发。 netpollclose() 把文件描述符fd从poller实例中移除，也就是从epoll中删除。 1 2 3 4 5 6 func netpollclose(fd uintptr) int32 { var ev epollevent // _EPOLL_CTL_DEL 从epoll文件描述符epfd中删除目标文件描述符fd。 // 该事件被忽略，可以为NULL。 return -epollctl(epfd, _EPOLL_CTL_DEL, int32(fd), \u0026ev)\t} netpollIsPollDescriptor() 判断是否是顶层poll，以及是pip2创建的读和写文件描述符。 判断文件描述符是否被poller使用。epfd、netpollBreakRd、netpollBreakWr属于被poller使用的描述符。 1 2 3 func netpollIsPollDescriptor(fd uintptr) bool { return fd == uintptr(epfd) || fd == netpollBreakRd || fd == netpollBreakWr } netpollBreak() 用来唤醒阻塞中的netpoll，它实际上就是向netpollBreakWr描述符中写入数据，这样一来epoll就会监听到。 netpollBreakRd的EPOLLIN事件(EPOLLIN表示对应的文件描述符可以读（包括对端SOCKET正常关闭）)。netpollBreak中断epollwait。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 // netpollBreak interrupts an epollwait. func netpollBreak() { // netpollWakeSig信号主要用于本轮已经通知过IO轮询，但是还没处理有其他的调用此方法时 // 使用原子操作将netpollWakeSig由0变成1，表示正在唤醒epoll。 if atomic.Cas(\u0026netpollWakeSig, 0, 1) {\tfor { var b byte // 向netpollBreakWr中写入数据，会导致那些阻塞在netpoll函数中的线程直接返回去执行后面代码 // netpollBreakWr在pipe2函数中注册时已经设置了非阻塞。因此这里不会阻塞。 n := write(netpollBreakWr, unsafe.Pointer(\u0026b), 1) // 写入成功 if n == 1 { break } // 在写入任何数据之前，调用被信号中断。 if n == -_EINTR { continue // 重试。 } // 已使用 O_NONBLOCK 选择了非阻塞 I/O，并且写入将阻塞。 // _EAGAIN：表示目前没有可用的数据 if n == -_EAGAIN { return } println(\"runtime: netpollBreak write failed with\", -n) throw(\"runtime: netpollBreak write failed\") } } } netpoll() netpoll检查准备就绪的网络连接。返回可运行的goroutine列表。 参数： delay \u003c 0：无限期阻塞。 delay == 0：不阻塞，立即返回。 delay \u003e 0：阻塞长达delay纳秒。 返回值：gList：一组就绪的goroutine。 根据入参delay设置调用epoll_wait的timeout值，调用epoll_wait从epoll的eventpoll.rdllist双向列表中获取IO就绪的fd列表，遍历epoll_wait返回的fd列表， 根据调用epoll_ctl注册fd时封装的上下文信息组装可运行的goroutine并返回。 执行完netpoll之后，会返回一个就绪fd列表对应的goroutine列表，接下来将就绪的goroutine加入到调度队列中，等待调度运行。 netpoll的调用时机： 在调度器中执行runtime.schedule()，该方法中会执行runtime.findrunnable()函数中调用了runtime.netpoll获取待执行的goroutine。 Go runtime在程序启动的时候会创建一个独立的sysmon监控线程，sysmon每20us~10ms运行一次，每次运行会检查距离上一次执行netpoll是否超过10ms，如果是则会调用一次runtime.netpoll。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 // netpoll checks for ready network connections. // Returns list of goroutines that become runnable. // // delay \u003c 0: blocks indefinitely;\t// delay == 0: does not block, just polls; // delay \u003e 0: block for up to that many nanoseconds; func netpoll(delay int64) gList { // 1) epoll没有初始化 if epfd == -1 {\treturn gList{} } // 2) 下面把纳秒级的 delay 转换成毫秒级的 waitms。 var waitms int32 if delay \u003c 0 { waitms = -1 // 永久阻塞，直到事件就绪返回 } else if delay == 0 { waitms = 0 // 不阻塞，立即返回 } else if delay \u003c 1e6 { // 小于1毫秒，修改为阻塞1毫秒 waitms = 1 // 阻塞1毫秒 } else if delay \u003c 1e15 { // 小于 11.5 day // 1e6 表示 1毫秒 waitms = int32(delay / 1e6) // 阻塞指定毫秒 } else { // An arbitrary cap on how long to wait for a timer. // 1e9 ms == ~11.5 days. waitms = 1e9 // 最长 11.5天 } // 3) 通过epollwait函数等待IO事件，缓冲区大小为128个epollevent。 // 超时时间是 waitms 毫秒。如果 epollwait函数被中断打断，就通过goto来重试。 // waitms 大于0时不会重试，因为需要返回调用者中去重新计算超时时间。 // 下面传入epollwait的数量是128，表示一次最大就绪128个事件 // 这样可能存在此次大于128数量时，需要等到下一个IO轮询时间窗口 // type epollevent struct { // events uint32 // 事件类型 // data [8]byte // 存储用户数据，刚好是一个指针存储的大小，该数据用户是可以修改的 // } var events [128]epollevent // 用于存储已经准备好的描述符的事件数据 retry: // 调用epollwait等待文件描述符转换成可写或可读，如果没有epollwait会阻塞 n := epollwait(epfd, \u0026events[0], int32(len(events)), waitms) // 返回活跃的数量n if n \u003c 0 { // EBADF：epfd 不是有效的文件描述符。 // EFAULT：事件指向的内存区域无法用写权限访问。 // EINVAL：epfd 不是epoll文件描述符，或者maxevents(第三个参数)小于等于0。 if n != -_EINTR { // EINTR 被CPU中断 println(\"runtime: epollwait on fd\", epfd, \"failed with\", -n) throw(\"runtime: netpoll failed\") } // If a timed sleep was interrupted, just return to // recalculate how long we should sleep now. // // 如果定时睡眠被中断，只需返回重新计算我们现在应该睡多久。 // _EINTR: 在任何请求的事件发生或超时到期之前，该调用被信号处理程序中断。 if waitms \u003e 0 { return gList{} } // 被中断 AND waitms \u003c= 0 情况重试 goto retry } // type gList struct { head guintptr } var toRun gList // 意味着被监控的文件描述符出现了待处理的事件 for i := int32(0); i \u003c n; i++ { // 就绪的IO事件集 ev := \u0026events[i] // 当前就绪描述符没有事件类型，直接跳过 if ev.events == 0 { continue } // 事件来源是否是netpollBreakRd，该描述符来之pipe2函数创建 // 来自pipe2函数创建的通信，netpollBreakRd是LT水平触发如果不读取会一直触发 // 该事件来自 netpollBreak() 方法，该方法只会在创建timer时和findRunnable()函数中被调用。 if *(**uintptr)(unsafe.Pointer(\u0026ev.data)) == \u0026netpollBreakRd { // 对于文件描述符 netpollBreakRd 而言，只有 _EPOLLIN 事件是正常的，其他都会被视为异常。 if ev.events != _EPOLLIN { println(\"runtime: netpoll: break fd ready for\", ev.events) throw(\"runtime: netpoll: break fd ready for something unexpected\") } // 这种情况下只处理不是立即返回情况下，如果是立即返回情况时，数据并未被读取，下次还会触发该信号 // 这种情况下只在runtime.findrunnable()函数中存在，线程在寻找g无果时，最后只能在IO轮询处等待 // 只有在 delay 不为0，也就是阻塞式netpoll时，才读取netpollBreakRd中的数据。 if delay != 0 { // netpollBreakRd 的本意也是只唤醒delay != 0的netpoll，因为这些在阻塞需要返回 // netpollBreak could be picked up by a // nonblocking poll. Only read the byte // if blocking. // netpollBreak 可以通过非阻塞轮询来获取。 仅在阻塞时读取字节。 var tmp [16]byte // 把写入的数据读取让缓存区为空 read(int32(netpollBreakRd), noescape(unsafe.Pointer(\u0026tmp[0])), int32(len(tmp)))\t// 将netpollWakeSig由1变成0，表示当前事件已被读取 atomic.Store(\u0026netpollWakeSig, 0)\t} continue } // 根据epoll返回的IO事件标志位为mode赋值 // r 表示可读，w 表示可写，r+w 表示既可读又可写。 // 检测IO事件中的错误标志位，并相应的为pd.everr赋值。 // 判断发生的事件类型,读类型或者写类型 var mode int32\t// 存储当前类型 // EPOLLIN ：表示对应的文件描述符可以读（包括对端SOCKET正常关闭） // EPOLLRDHUP：对端描述符产生一个挂断事件 // EPOLLHUP：本端描述符产生一个挂断事件，默认监测事件 // EPOLLERR：表示对应的文件描述符发生错误 if ev.events\u0026(_EPOLLIN|_EPOLLRDHUP|_EPOLLHUP|_EPOLLERR) != 0 { mode += 'r' } // EPOLLOUT：表示对应的文件描述符可以写 // EPOLLHUP：本端描述符产生一个挂断事件，默认监测事件 // EPOLLERR：表示对应的文件描述符发生错误 if ev.events\u0026(_EPOLLOUT|_EPOLLHUP|_EPOLLERR) != 0 { mode += 'w' } // mode不为0，表示有IO事件，需要从ev.data字段得到与IO事件关联的pollDesc。 if mode != 0 { // 取出保存在 epollevent 里的pollDesc，因为要根据这个内容去恢复g如果g已被挂起时 pd := *(**pollDesc)(unsafe.Pointer(\u0026ev.data)) // *pollDesc // 对应的_EPOLLERR文件描述符出现错误时，标记错误 pd.setEventErr(ev.events == _EPOLLERR)\t// 设置pollDesc的EpollErr错误位，如果是这种状态 netpollready(\u0026toRun, pd, mode)\t// 处理就绪的描述符 } } return toRun } netpollready() go1.19.3/src/runtime/runtime/netpoll.go。 netpollready由特定于平台的netpoll函数调用。它声明与pd相关的fd已经为I/O做好了准备。 toRun参数用于构建一个从netpoll返回的goroutines列表。mode参数是'r'、'w'或'r'+'w'，表示fd是否准备好读、写或同时读和写。 这可能会在整个系统停止时运行，因此不允许设置写屏障。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 // netpollready is called by the platform-specific netpoll function. // It declares that the fd associated with pd is ready for I/O. // The toRun argument is used to build a list of goroutines to return // from netpoll. The mode argument is 'r', 'w', or 'r'+'w' to indicate // whether the fd is ready for reading or writing or both. // // This may run while the world is stopped, so write barriers are not allowed. //go:nowritebarrier func netpollready(toRun *gList, pd *pollDesc, mode int32) { var rg, wg *g if mode == 'r' || mode == 'r'+'w' { // netpollunblock 可能返回 goroutine 或 nil rg = netpollunblock(pd, 'r', true) } if mode == 'w' || mode == 'r'+'w' { wg = netpollunblock(pd, 'w', true) } if rg != nil { // 并入 toRun 中，这部分 goroutine 等待放入调度池中 toRun.push(rg) } if wg != nil { toRun.push(wg) } } netpollunblock() go1.19.3/src/runtime/runtime/netpoll.go。 netpollunblock解除阻塞。 参数： pd *pollDesc：pollDesc。 mode int32：读r或写w。 ioready bool：true-I/O读（用于从pollDesc中获取 goroutine），false-读写超时从pollDesc中获取goroutine。 返回值：*g返回就绪的goroutine，可能是nil。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 func netpollunblock(pd *pollDesc, mode int32, ioready bool) *g { // 根据 mode 从rg或wg取出 goroutine。 gpp := \u0026pd.rg if mode == 'w' { gpp = \u0026pd.wg } for { // 原子读取 old := gpp.Load() // pdReady：表示fd的数据已经就绪，可供读取或写。该值从g修改pdReady。 // 这种情况可能 goroutine 已经被返回给调用者了。什么都不做直接返回。 if old == pdReady { return nil } // nil：没有什么可做的 if old == 0 \u0026\u0026 !ioready { // Only set pdReady for ioready. runtime_pollWait // will check for timeout/cancel before waiting. // // 只在ioready中设置pdReady。runtime_pollWait将在等待之前检查 timeout/cancel。 return nil } // old是0、goroutine、pdWait这三种情况。 var new uintptr if ioready { // 修改为pdReady，表示数据已就绪或写 new = pdReady } // CAS 交换 if gpp.CompareAndSwap(old, new) { // pdWait：表示某个goroutine即将挂起并等待fd的可读可写事件。 if old == pdWait { old = 0 // nil } return (*g)(unsafe.Pointer(old)) // nil 或 *g } } } wakeNetPoller() 该函数在time源码中被调用，用于判断是否需要发起I/O网络轮询。 该方法是为了防止定时器触发时间到了没有线程能触发的情况，当只剩阻塞在netpoll的线程或所有的线程都处于等待中时，timer可能不能按时触发的情况。 wakeenetpoller唤醒在网络轮询器(network poller)中睡眠的线程，如果它不打算在when参数之前被唤醒; 或者唤醒一个空闲的P来服务计时器(timers)和网络轮询器(network poller)(如果还没有的话)。 when int64：表示最近的timer触发的时间点，因此为了避免当前最近的timer到时间能准时触发，需要调整netpoll的阻塞事件点。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 // wakeNetPoller wakes up the thread sleeping in the network poller if it isn't // going to wake up before the when argument; or it wakes an idle P to service // timers and the network poller if there isn't one already. func wakeNetPoller(when int64) { // sched.lastpoll：记录的是上次执行netpoll的时间，如果等于0，则表示某个线程正在阻塞式地执行netpoll。 // sched.lastpoll 被设置为0只会在 findrunnable 函数中。 if atomic.Load64(\u0026sched.lastpoll) == 0 { // In findrunnable we ensure that when polling the pollUntil // field is either zero or the time to which the current // poll is expected to run. This can have a spurious wakeup // but should never miss a wakeup. // // 在 findrunnable 中，我们要确保轮询时 pollUntil 字段要么是0，要么为当前poll预期运行的时间。 // 这里可能会是一个虚假的唤醒，但不应该错过唤醒。 // sched.pollUntil：表示阻塞式地netpoll将在何时被唤醒。该值在 findrunnable 函数中被设置。 // sched.pollUntil 值大于0时，表示最近的timer触发时间段。 pollerPollUntil := int64(atomic.Load64(\u0026sched.pollUntil)) // pollerPollUntil \u003e when：存在最新的计时器被加入when时间段后触发 if pollerPollUntil == 0 || pollerPollUntil \u003e when { netpollBreak() } } else { // There are no threads in the network poller, try to get // one there so it can handle new timers. if GOOS != \"plan9\" { // Temporary workaround - see issue #42303. wakep() // 尝试唤醒一个空闲的P起来服务timer和network poller。 } } } netpollarm() 该函数在linux上不会调用，充当一个占位作用。 1 2 3 func netpollarm(pd *pollDesc, mode int) { throw(\"runtime: unused\") // runtime: 未使用的 } 参考 详解Go语言I/O多路复用netpoller模型 epoll详解 epoll源码解析(1) epoll_create ",
  "wordCount" : "1886",
  "inLanguage": "zh",
  "image": "https://heliu.site/favicon-32x32.png","datePublished": "2024-07-20T21:59:40+08:00",
  "dateModified": "2024-07-20T21:59:40+08:00",
  "author":[{
    "@type": "Person",
    "name": "helium"
  }],
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://heliu.site/posts/golang/netpoll/epoll/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Helium",
    "logo": {
      "@type": "ImageObject",
      "url": "https://heliu.site/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://heliu.site/" accesskey="h" title="Blog (Alt + H)">
                <img src="https://heliu.site/helium.png" alt="" aria-label="logo"
                    height="35">Blog</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://heliu.site/" title="主页">
                    <span>Home</span>
                </a>
            </li>
            <li>
                <a href="https://heliu.site/posts" title="文章">
                    <span>Article</span>
                </a>
            </li>
            <li>
                <a href="https://heliu.site/archives" title="时间轴">
                    <span>Archive</span>
                </a>
            </li>
            <li>
                <a href="https://heliu.site/tags/" title="标签">
                    <span>Tag</span>
                </a>
            </li>
            <li>
                <a href="https://heliu.site/search/" title="搜索 (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
            <li>
                <a href="https://heliu.site/support" title="打赏">
                    <span>🫶Help</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">


<article class="post" autonumbering>
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://heliu.site/">主页</a>&nbsp;»&nbsp;<a href="https://heliu.site/posts/">Article</a>&nbsp;»&nbsp;<a href="https://heliu.site/posts/golang/">Golang 合集</a>&nbsp;»&nbsp;<a href="https://heliu.site/posts/golang/netpoll/">第16章 netpoll</a></div>
    <h1 class="post-title entry-hint-parent">
      Golang epoll
    </h1>
    <div class="post-description">
      💥本文章所有相关go代码参考自go 1.18&#43;版本
    </div>
    <div class="post-meta">










<span class="x-post-meta-item"><svg t="1720837714681" class="icon" viewBox="0 0 1084 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="7520" width="200" height="200"><path d="M123.47509 1023.984942a123.565437 123.565437 0 0 1-123.505206-123.32451V243.863302A123.565437 123.565437 0 0 1 123.47509 120.568908h171.630374V26.06529a26.050232 26.050232 0 0 1 52.070349 0v94.503618h377.592848V26.06529a26.050232 26.050232 0 0 1 52.100464 0v94.503618h183.797189A123.565437 123.565437 0 0 1 1084.171519 243.863302v656.79713A123.565437 123.565437 0 0 1 960.666314 1023.984942H123.47509z m-71.404741-123.32451A71.434857 71.434857 0 0 0 123.47509 971.974825h837.191224a71.434857 71.434857 0 0 0 71.404741-71.314393V442.326922l-946.361273-3.824716a25.598494 25.598494 0 0 1-5.84248-0.692665l-27.796953-6.444798v469.295689zM123.47509 172.579025a71.434857 71.434857 0 0 0-71.404741 71.284277v149.736133l27.796953-6.444797a26.080348 26.080348 0 0 1 5.902712-0.662549l946.301041 3.824716V243.863302a71.404741 71.404741 0 0 0-71.404741-71.284277h-180.183284l-6.173754 12.859479a26.200812 26.200812 0 0 1-23.490383 14.786895 26.261043 26.261043 0 0 1-23.520499-14.786895l-6.173754-12.859479H350.819834l-6.173754 12.859479a26.200812 26.200812 0 0 1-23.490383 14.786895 26.230928 26.230928 0 0 1-23.520499-14.786895l-6.173755-12.859479H123.47509z m156.150814 578.827128a26.050232 26.050232 0 0 1-26.050232-25.990001c0-14.335157 11.68496-26.020116 26.050232-26.020116h521.697312c14.365273 0 26.050232 11.68496 26.050233 26.020116a26.050232 26.050232 0 0 1-26.050233 25.990001H279.625904z" fill="#3D3F42" p-id="7521"></path></svg><span>2024-07-20</span></span>&nbsp;<span class="x-post-meta-item"><svg t="1720839329181" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="14106" width="200" height="200"><path d="M699.270662 190.485379c-0.411369 0-0.821715 0.011256-1.227967 0.032746H507.034407a23.041786 23.041786 0 0 0-1.221828-0.031723c-12.779048 0-23.140023 10.359952-23.140023 23.139 0 12.781094 10.360975 23.141046 23.140023 23.141046v0.032746h193.458083v-0.032746c12.780071 0 23.141046-10.359952 23.141047-23.141046 0-12.780071-10.360975-23.140023-23.141047-23.140023zM979.215516 724.005508c0-142.090159-115.186416-257.277598-257.277598-257.277598-72.245418 0-137.532353 29.777187-184.262654 77.725223l45.868677 31.474852c36.227086-33.873482 84.882226-54.617945 138.393977-54.617945 111.945605 0 202.696492 90.750887 202.696492 202.695468h-43.01263l70.331835 104.289228 70.331835-104.289228H979.215516z" fill="" p-id="14107"></path><path d="M748.885664 588.843132c0-14.881942-12.06785-26.945699-26.947746-26.945698-14.883989 0-26.947745 12.063757-26.947745 26.945698v135.164423c0 14.879895 12.063757 26.945699 26.947745 26.945699h107.786889c14.881942 0 26.945699-12.063757 26.945698-26.945699s-12.063757-26.945699-26.945698-26.945699h-80.839143V588.843132zM721.937918 926.702c-111.947651 0-202.696492-90.74884-202.696492-202.696492 0-0.144286 0.004093-0.285502 0.004094-0.429788h43.004443l-70.330812-104.289228-70.331835 104.289228h43.075051c0 0.144286-0.00307 0.285502-0.00307 0.429788 0 142.091182 115.187439 257.279644 257.278621 257.279645 72.241324 0 137.530306-29.77821 184.260607-77.727269l-45.86663-31.474852c-36.227086 33.873482-84.884272 54.618968-138.393977 54.618968zM694.633039 423.38066c-1.354857-11.487635-11.120268-20.400632-22.972201-20.400632H206.362486c-12.780071 0-23.140023 10.359952-23.140023 23.138999 0 12.781094 10.359952 23.141046 23.140023 23.141047H596.949252c30.209022-13.81668 63.104223-22.76754 97.683787-25.879414zM438.548616 623.143333H206.362486c-12.780071 0-23.140023 10.358929-23.140023 23.140023 0 12.780071 10.359952 23.140023 23.140023 23.140023h219.956598a298.463626 298.463626 0 0 1 12.229532-46.280046zM506.934123 513.062192H206.362486c-12.780071 0-23.140023 10.359952-23.140023 23.139 0 12.781094 10.359952 23.140023 23.140023 23.140023H469.936487a302.241672 302.241672 0 0 1 36.997636-46.279023z" fill="" p-id="14108"></path><path d="M442.765661 835.277778a298.531164 298.531164 0 0 1-14.365173-46.150087H146.542052v-0.065491c-33.036417 0-59.81941-26.78197-59.81941-59.819411V329.36031h704.907545v100.905154a298.561863 298.561863 0 0 1 46.150086 14.996552V194.619536h-0.162706c0-53.422723-43.307342-96.728018-96.730065-96.728018h-68.89409V84.418668c0-33.037441-26.782993-59.81941-59.81941-59.81941v-0.361227h-18.87079v0.032745c-33.038464 0-59.820434 26.78197-59.820433 59.819411 0 0.109494 0.008186 0.218988 0.008186 0.328481h-0.339738v13.47285H345.203648V84.418668c0-33.037441-26.782993-59.81941-59.819411-59.81941v-0.361227h-18.872836v0.032745c-33.036417 0-59.81941 26.78197-59.81941 59.819411 0 0.109494 0.007163 0.218988 0.008186 0.328481h-0.339737v13.47285h-69.189826c-53.4217 0-96.729042 43.306318-96.729041 96.728018 0 1.701758 0.045025 3.39226 0.132006 5.071505v533.785166a98.051153 98.051153 0 0 0-0.132006 5.071506c0 53.4217 43.307342 96.728018 96.729041 96.728018v0.001023h305.595047zM86.723665 204.056466c0-33.037441 26.782993-59.81941 59.819411-59.819411 0.044002 0 0.086981 0.00307 0.130983 0.00307v-0.068561h105.968473V94.874811h0.032746a22.807449 22.807449 0 0 1-0.032746-1.215688c0-12.779048 10.360975-23.140023 23.140023-23.140023s23.140023 10.360975 23.140023 23.140023c0 0.408299-0.010233 0.812505-0.031722 1.215688h0.031722v49.297776h280.508696V94.874811h0.032745a22.807449 22.807449 0 0 1-0.032745-1.215688c0-12.779048 10.361999-23.140023 23.140023-23.140023 12.780071 0 23.141046 10.360975 23.141046 23.140023 0 0.408299-0.011256 0.812505-0.032746 1.215688h0.032746v49.297776h106.10048v0.065492c33.035394 0 59.818387 26.780947 59.818387 59.81941h0.130983V283.080264H86.723665v-79.023798z" fill="" p-id="14109"></path></svg><span>2024-07-20</span></span>&nbsp;<span class="x-post-meta-item"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2" fill="none"
     stroke-linecap="round" stroke-linejoin="round" class="feather feather-file-text" style="user-select: text;">
    <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z" style="user-select: text;"></path>
    <polyline points="14 2 14 8 20 8" style="user-select: text;"></polyline>
    <line x1="16" y1="13" x2="8" y2="13" style="user-select: text;"></line>
    <line x1="16" y1="17" x2="8" y2="17" style="user-select: text;"></line>
    <polyline points="10 9 9 9 8 9" style="user-select: text;"></polyline>
</svg><span>1886字</span></span>&nbsp;<span class="x-post-meta-item"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2" fill="none"
     stroke-linecap="round" stroke-linejoin="round">
    <path stroke="none" d="M0 0h24v24H0z" fill="none"></path>
    <circle cx="12" cy="12" r="9"></circle>
    <polyline points="12 7 12 12 15 15"></polyline>
</svg><span>9分钟</span></span>&nbsp;<span class="x-post-meta-item"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2" fill="none"
     stroke-linecap="round" stroke-linejoin="round">
    <path stroke="none" d="M0 0h24v24H0z" fill="none"></path>
    <circle cx="12" cy="7" r="4"></circle>
    <path d="M6 21v-2a4 4 0 0 1 4 -4h4a4 4 0 0 1 4 4v2"></path>
</svg><span>helium</span></span>
      <span class="x-post-meta-item">
        &nbsp;<svg t="1720840393161" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="18680" width="200" height="200"><path d="M995.125144 559.61812l-415.998603-415.998602A52.986489 52.986489 0 0 0 541.413335 127.99957H338.847348c-3.166656-26.559911-9.286635-51.046495-17.999939-71.333094C299.734146 7.333309 271.154242 0 256.00096 0c-13.939953 0-40.439864 6.339979-61.259794 48.806503-10.473298 21.366595-17.946606 48.966502-21.573261 79.193067H53.334974a53.393154 53.393154 0 0 0-53.333154 53.333154v360.078791a52.986489 52.986489 0 0 0 15.619948 37.713206l415.998602 415.998603a53.333154 53.333154 0 0 0 75.426413 0l26.286579-26.293245 26.286578 26.293245a53.426487 53.426487 0 0 0 16.719944 11.333295 21.333262 21.333262 0 0 0 36.079879 11.293295l382.705381-382.705381a53.399821 53.399821 0 0 0 0-75.426413z m-762.070774-491.998347C241.494342 50.373164 250.667645 42.666523 256.00096 42.666523c5.99998 0 16.573278 9.639968 25.646581 30.806564 6.493312 15.159949 11.333295 33.999886 14.146619 54.526483H216.16776c3.206656-23.419921 9.013303-44.359851 16.88661-60.41313z m243.819181 897.330319a10.666631 10.666631 0 0 1-15.079949 0l-415.998603-415.998603A10.573298 10.573298 0 0 1 42.668343 541.411515V181.332724a10.666631 10.666631 0 0 1 10.666631-10.666631h245.332509c0 47.853173-10.373298 92.15969-27.066575 115.632945-5.926647 8.326639-16.566611 14.186619-22.306592 16.113279C204.041135 314.752276 170.667913 356.218803 170.667913 405.331972c0 58.813136 47.853173 106.666308 106.666309 106.666308s106.666308-47.853173 106.666308-106.666308c0-47.086508-30.666564-87.139707-73.079754-101.246327C330.060711 272.705751 341.334007 223.692582 341.334007 170.666093h72.079758a10.573298 10.573298 0 0 1 7.539974 3.126656l415.998603 415.998603a10.666631 10.666631 0 0 1 0 15.079949zM341.334007 405.331972a63.999785 63.999785 0 1 1-63.999785-63.999785 64.073118 64.073118 0 0 1 63.999785 63.999785z m263.539114 559.61812a10.666631 10.666631 0 0 1-15.079949 0L563.499927 938.663513l303.625647-303.61898a53.399821 53.399821 0 0 0 0-75.426413L478.16688 170.666093h63.246455a10.573298 10.573298 0 0 1 7.539974 3.126656l415.998603 415.998603c0.239999 0.239999 0.466665 0.486665 0.666664 0.746664l0.086667 0.106666a10.666631 10.666631 0 0 1 0 13.373289l-0.086667 0.106666c-0.213333 0.259999-0.439999 0.506665-0.666664 0.746664z" fill="#5C5C66" p-id="18681"></path></svg>
        <ul class="post-tags-meta" style="display: inline-block;font-size: 14px;">
            <a href="https://heliu.site/tags/golang/" target="_blank" rel="noopener">Golang</a>
            <a href="https://heliu.site/tags/netpoll/" target="_blank" rel="noopener">Netpoll</a>
        </ul>
      </span>
      
      <span id="busuanzi_container_page_pv" class="x-post-meta-item">
        &nbsp;<svg t="1720844685710" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="27237" width="200" height="200"><path d="M739.754667 574.08c-121.386667 45.610667-208.469333 169.813333-208.64 316.16 0 33.408 4.693333 65.493333 13.141333 95.914667H94.122667c-26.453333-43.52-41.685333-91.946667-41.685334-143.189334 0-185.173333 192.896-335.104 430.805334-335.104 96.256 0 184.832 24.746667 256.512 66.218667z m-280.490667-114.986667a214.869333 214.869333 0 0 1-214.869333-215.04A215.04 215.04 0 0 1 459.264 28.842667a215.04 215.04 0 0 1 215.04 215.210666 215.04 215.04 0 0 1-215.04 215.04zM974.506667 641.28c9.856 0 17.834667 7.466667 17.834666 16.64v59.989333c-0.341333 8.789333-7.850667 15.786667-17.28 16.085334-9.856 0.341333-18.176-6.826667-18.517333-16.085334v-20.053333l-99.114667 91.093333-0.256 0.256a18.474667 18.474667 0 0 1-14.848 4.352h-0.768a18.176 18.176 0 0 1-9.344-4.608l-0.938666-0.981333-85.930667-80.042667-123.562667 115.072a18.773333 18.773333 0 0 1-25.216 0 15.786667 15.786667 0 0 1 0-23.466666l136.149334-126.848 0.725333-0.597334a18.645333 18.645333 0 0 1 24.362667 0.512l87.253333 81.237334 86.058667-79.232h-21.248c-9.386667-0.298667-16.938667-7.338667-17.28-16.085334-0.341333-9.173333 7.381333-16.896 17.28-17.237333h64.64z m-367.146667 240h48.128c8.874667 0 16.042667 7.168 16.042667 16.042667v72.192a16.042667 16.042667 0 0 1-16.042667 16.042666h-48.128a16.042667 16.042667 0 0 1-16.042667-16.042666v-72.192c0-8.874667 7.210667-16.042667 16.042667-16.042667z m110.805333-106.666667h48.128c8.874667 0 16.042667 7.168 16.042667 16.042667v178.858667a16.042667 16.042667 0 0 1-16.042667 16.042666h-48.128a16.042667 16.042667 0 0 1-16.042666-16.042666v-178.858667c0-8.874667 7.168-16.042667 16.042666-16.042667z m106.538667 80h48.128c8.874667 0 16.042667 7.168 16.042667 16.042667v99.413333a16.042667 16.042667 0 0 1-16.042667 16.042667H824.746667a16.042667 16.042667 0 0 1-16.042667-16.042667v-99.413333c0-8.874667 7.168-16.042667 16.042667-16.042667z m110.165333-80h48.128c8.874667 0 16.042667 7.168 16.042667 16.042667v179.413333a16.042667 16.042667 0 0 1-16.042667 16.042667h-48.128a16.042667 16.042667 0 0 1-16.042666-16.042667v-179.413333c0-8.874667 7.210667-16.042667 16.042666-16.042667z" fill="#999999" p-id="27238"></path></svg>
        <span id="busuanzi_value_page_pv"></span>
      </span>

</div>
  </header> <aside id="toc-container" class="toc-container wide">
    <div class="toc">
        <details  open>
            <summary accesskey="c" title="(Alt + C)">
                <span class="details">目录</span>
            </summary>

            <div class="inner"><ul>
                    <li>
                        <a href="#variables" aria-label="variables">variables</a></li>
                    <li>
                        <a href="#netpollgenericinit" aria-label="netpollGenericInit()"><code>netpollGenericInit()</code></a><ul>
                            
                    <li>
                        <a href="#netpollinit" aria-label="netpollinit()"><code>netpollinit()</code></a></li></ul>
                    </li>
                    <li>
                        <a href="#netpollopen" aria-label="netpollopen()"><code>netpollopen()</code></a></li>
                    <li>
                        <a href="#netpollclose" aria-label="netpollclose()"><code>netpollclose()</code></a></li>
                    <li>
                        <a href="#netpollispolldescriptor" aria-label="netpollIsPollDescriptor()"><code>netpollIsPollDescriptor()</code></a></li>
                    <li>
                        <a href="#netpollbreak" aria-label="netpollBreak()"><code>netpollBreak()</code></a></li>
                    <li>
                        <a href="#netpoll" aria-label="netpoll()"><code>netpoll()</code></a><ul>
                            
                    <li>
                        <a href="#netpollready" aria-label="netpollready()"><code>netpollready()</code></a></li>
                    <li>
                        <a href="#netpollunblock" aria-label="netpollunblock()"><code>netpollunblock()</code></a></li></ul>
                    </li>
                    <li>
                        <a href="#wakenetpoller" aria-label="wakeNetPoller()"><code>wakeNetPoller()</code></a></li>
                    <li>
                        <a href="#netpollarm" aria-label="netpollarm()"><code>netpollarm()</code></a></li>
                    <li>
                        <a href="#%e5%8f%82%e8%80%83" aria-label="参考">参考</a>
                    </li>
                </ul>
            </div>
        </details>
    </div>
</aside>
<script>
    let activeElement;
    let elements;
    window.addEventListener('DOMContentLoaded', function (event) {
        checkTocPosition();

        elements = document.querySelectorAll('h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]');
         
         activeElement = elements[0];
         const id = encodeURI(activeElement.getAttribute('id')).toLowerCase();
         document.querySelector(`.inner ul li a[href="#${id}"]`).classList.add('active');
     }, false);

    window.addEventListener('resize', function(event) {
        checkTocPosition();
    }, false);

    window.addEventListener('scroll', () => {
        
        activeElement = Array.from(elements).find((element) => {
            if ((getOffsetTop(element) - window.pageYOffset) > 0 && 
                (getOffsetTop(element) - window.pageYOffset) < window.innerHeight/2) {
                return element;
            }
        }) || activeElement

        elements.forEach(element => {
             const id = encodeURI(element.getAttribute('id')).toLowerCase();
             if (element === activeElement){
                 document.querySelector(`.inner ul li a[href="#${id}"]`).classList.add('active');
             } else {
                 document.querySelector(`.inner ul li a[href="#${id}"]`).classList.remove('active');
             }
         })
     }, false);

    const main = parseInt(getComputedStyle(document.body).getPropertyValue('--article-width'), 10);
    const toc = parseInt(getComputedStyle(document.body).getPropertyValue('--toc-width'), 10);
    const gap = parseInt(getComputedStyle(document.body).getPropertyValue('--gap'), 10);

    function checkTocPosition() {
        const width = document.body.scrollWidth;

        if (width - main - (toc * 2) - (gap * 4) > 0) {
            document.getElementById("toc-container").classList.add("wide");
        } else {
            document.getElementById("toc-container").classList.remove("wide");
        }
    }

    function getOffsetTop(element) {
        if (!element.getClientRects().length) {
            return 0;
        }
        let rect = element.getBoundingClientRect();
        let win = element.ownerDocument.defaultView;
        return rect.top + win.pageYOffset;   
    }
</script>
  <div class="post-content"><ul>
<li>以下来自<code>go1.19.3/src/runtime/netpoll_epoll.go</code>文件。</li>
<li>本篇文章是针对<code>netpoll_epoll.go</code>文件的源码走读。</li>
</ul>
<h2 id="variables">variables<a hidden class="anchor" aria-hidden="true" href="#variables">#</a></h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">var</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// epoll 描述符, epollcreate 函数创建返回的文件描述符
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">epfd</span> <span class="kt">int32</span> <span class="p">=</span> <span class="o">-</span><span class="mi">1</span> <span class="c1">// epoll descriptor
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 保存的是pipe2()或pip()函数创建的读写描述符，pip2()或pip()函数创建的read和write，只要任意一方操作另一方能获取到数据
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// netpollBreakRd会被注册到epoll中，当写描述符向里写数据时会触发wait监听函数返回就绪的事件集
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 这对读写描述符的作用在于通信，当有其他协程在wait阻塞等待时，可以通过写描述符写入数据让等待的协程返回
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 主要针对 epoll_wait() 函数阻塞的线程，通过这里的事件使调用 epoll_wait() 函数的线程陷入内核返回。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 对于 epoll_wait() 的 timeout 参数为0的情况，这里的事件会被忽略
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">netpollBreakRd</span><span class="p">,</span> <span class="nx">netpollBreakWr</span> <span class="kt">uintptr</span> <span class="c1">// for netpollBreak
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 用于避免重复调用 netpollBreak()
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 在向netpollBreakWr中写入数据时，该值会从0变成1，控制只写一次标志符号
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 该参数是原子性的
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">netpollWakeSig</span> <span class="kt">uint32</span> <span class="c1">// used to avoid duplicate calls of netpollBreak
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">)</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><img loading="lazy" src="../images/epoll-002.png" alt=""  />
</p>
<h2 id="netpollgenericinit"><code>netpollGenericInit()</code><a hidden class="anchor" aria-hidden="true" href="#netpollgenericinit">#</a></h2>
<ol>
<li>初始化netpoll。<code>go1.19.3/src/runtime/netpoll.go</code>文件。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">netpollGenericInit</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// var netpollInited uint32 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 是否已初始化epoll标志 0.未初始化 1.已初始化
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Load</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">netpollInited</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// var netpollInitLock mutex 初始化
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nf">lockInit</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">netpollInitLock</span><span class="p">,</span> <span class="nx">lockRankNetpollInit</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">netpollInitLock</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 这里需要判断 netpollInited == 0；原因在于可能存在多个协程并发在等待初始化epoll
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 当这些协程获取的锁权限时，这里的netpollInited已被设置成1了，已经被初始化了
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="nx">netpollInited</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nf">netpollinit</span><span class="p">()</span>   <span class="c1">// 初始化netpoll
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="nx">atomic</span><span class="p">.</span><span class="nf">Store</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">netpollInited</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>	<span class="c1">// netpollInited
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">netpollInitLock</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="netpollinit"><code>netpollinit()</code><a hidden class="anchor" aria-hidden="true" href="#netpollinit">#</a></h3>
<ol>
<li><code>go1.19.3/src/runtime/netpoll_epoll.go</code>。</li>
<li>调用epollcreate创建netpoller。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">netpollinit</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// epollcreate 函数内会调用 epollcreate1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    
</span></span><span class="line"><span class="cl">    <span class="c1">// _EPOLL_CLOEXEC：当前进程fork出来的任何子进程在执行前都会关闭epoll描述符，也因此，子进程不能够访问epoll实例
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">epfd</span> <span class="p">=</span> <span class="nf">epollcreate1</span><span class="p">(</span><span class="nx">_EPOLL_CLOEXEC</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 小于0表示创建出错，大于0表示返回的创建后的文件句柄ID
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nx">epfd</span> <span class="p">&lt;</span> <span class="mi">0</span> <span class="p">{</span>	
</span></span><span class="line"><span class="cl">        <span class="nx">epfd</span> <span class="p">=</span> <span class="nf">epollcreate</span><span class="p">(</span><span class="mi">1024</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="nx">epfd</span> <span class="p">&lt;</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nb">println</span><span class="p">(</span><span class="s">&#34;runtime: epollcreate failed with&#34;</span><span class="p">,</span> <span class="o">-</span><span class="nx">epfd</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="nf">throw</span><span class="p">(</span><span class="s">&#34;runtime: netpollinit failed&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 系统调用 fcntl 设置 FD_CLOEXEC，参看 epollcreate1 函数参数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// fcntl：fd, F_SETFD, FD_CLOEXEC
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nf">closeonexec</span><span class="p">(</span><span class="nx">epfd</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 创建一个用于通信的管道,返回读写,主要用于那些等待在IO轮询中的线程通信
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 创建一个非阻塞式pipe，用来唤醒阻塞中的 netpoller。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// pipe2(_O_NONBLOCK | _O_CLOEXEC)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">r</span><span class="p">,</span> <span class="nx">w</span><span class="p">,</span> <span class="nx">errno</span> <span class="o">:=</span> <span class="nf">nonblockingPipe</span><span class="p">()</span>    <span class="c1">// 主要用于Break相关的函数，主要用于网络轮询唤醒信号
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nx">errno</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nb">println</span><span class="p">(</span><span class="s">&#34;runtime: pipe failed with&#34;</span><span class="p">,</span> <span class="o">-</span><span class="nx">errno</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="nf">throw</span><span class="p">(</span><span class="s">&#34;runtime: pipe failed&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// epollevent 是事件类型
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 	type epollevent struct {
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//		events uint32   // 事件类型
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//		data [8]byte    // 存储用户数据，刚好是一个指针存储的大小，该数据用户是可以修改的
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 	}
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">ev</span> <span class="o">:=</span> <span class="nx">epollevent</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 注意：这里默认注册的是水平触发，因此会一直触发
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">events</span><span class="p">:</span> <span class="nx">_EPOLLIN</span><span class="p">,</span>   <span class="c1">// EPOLLIN 表示对应的文件描述符可以读（包括对端SOCKET正常关闭）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// var netpollBreakRd uintptr
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="o">*</span><span class="p">(</span><span class="o">**</span><span class="kt">uintptr</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">ev</span><span class="p">.</span><span class="nx">data</span><span class="p">))</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">netpollBreakRd</span> <span class="c1">// ev.data = &amp;netpollBreakRd
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 将读取数据的文件描述符加入监听，当使用w写数据时，该r会被触发
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// func epollctl(epfd, op, fd int32, ev *epollevent) int32
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// _EPOLL_CTL_ADD 将目标文件描述符fd添加到epoll描述符epfd中，并将事件event与fd链接的内部文件关联起来。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">errno</span> <span class="p">=</span> <span class="nf">epollctl</span><span class="p">(</span><span class="nx">epfd</span><span class="p">,</span> <span class="nx">_EPOLL_CTL_ADD</span><span class="p">,</span> <span class="nx">r</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">ev</span><span class="p">)</span>      <span class="c1">// r 被添加到epoll中
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nx">errno</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nb">println</span><span class="p">(</span><span class="s">&#34;runtime: epollctl failed with&#34;</span><span class="p">,</span> <span class="o">-</span><span class="nx">errno</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="nf">throw</span><span class="p">(</span><span class="s">&#34;runtime: epollctl failed&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// netpollBreakRd、netpollBreakWr 是非阻塞管道两端的文件描述符，分别被用作读取端和写入端。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 读取端 netpollBreakRd 被添加到 epoll 中监听 _EPOLLIN 事件，后续从写入端netpollBreakWr
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 写入数据就能唤醒阻塞中的 poller。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">netpollBreakRd</span> <span class="p">=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">r</span><span class="p">)</span> <span class="c1">// netpollBreakRd保存pip2的read
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">netpollBreakWr</span> <span class="p">=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">w</span><span class="p">)</span> <span class="c1">// netpollBreakRd保存pip2的write
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="netpollopen"><code>netpollopen()</code><a hidden class="anchor" aria-hidden="true" href="#netpollopen">#</a></h2>
<ol>
<li>把要监听的文件描述符<code>fd</code>和与之关联的<code>pollDesc</code>结构添加到<code>poller</code>实例中。</li>
<li>该方法对于一个<code>socket</code>只需调用一次即可，表示注册<code>fd</code>到<code>epoll</code>中。</li>
<li>参数：
<ul>
<li><code>fd uintptr</code>：文件描述符。</li>
<li><code>pd *pollDesc</code>：用户数据。</li>
</ul>
</li>
<li>返回值：<code>int32</code>：0-注册成功。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">netpollopen</span><span class="p">(</span><span class="nx">fd</span> <span class="kt">uintptr</span><span class="p">,</span> <span class="nx">pd</span> <span class="o">*</span><span class="nx">pollDesc</span><span class="p">)</span> <span class="kt">int32</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 	type epollevent struct {
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//      events uint32   // 事件类型
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//      data [8]byte    // 存储用户数据，刚好是一个指针存储的大小，该数据用户是可以修改的
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 	}
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kd">var</span> <span class="nx">ev</span> <span class="nx">epollevent</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// EPOLLIN：表示对应的文件描述符可以读（包括对端SOCKET正常关闭）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// EPOLLOUT：表示对应的文件描述符可以写
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// EPOLLRDHUP：对端描述符产生一个挂断事件，比如来自对端的socket挂断事件等
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// EPOLLET：将EPOLL设为边缘触发(Edge Triggered)模式，这是相对于水平触发(Level Triggered)来说的
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// pollDesc：类型的数据结构pd作为与fd关联的自定数据会被一同添加到epoll中。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">ev</span><span class="p">.</span><span class="nx">events</span> <span class="p">=</span> <span class="nx">_EPOLLIN</span> <span class="p">|</span> <span class="nx">_EPOLLOUT</span> <span class="p">|</span> <span class="nx">_EPOLLRDHUP</span> <span class="p">|</span> <span class="nx">_EPOLLET</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// epollevent 是由events和data组成，data来自用户空间传入的数据
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="o">*</span><span class="p">(</span><span class="o">**</span><span class="nx">pollDesc</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">ev</span><span class="p">.</span><span class="nx">data</span><span class="p">))</span> <span class="p">=</span> <span class="nx">pd</span> <span class="c1">// ev.data = pd
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// _EPOLL_CTL_ADD 将目标文件描述符fd添加到epoll描述符epfd中，并将事件event与fd链接的内部文件关联起来。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">return</span> <span class="o">-</span><span class="nf">epollctl</span><span class="p">(</span><span class="nx">epfd</span><span class="p">,</span> <span class="nx">_EPOLL_CTL_ADD</span><span class="p">,</span> <span class="nb">int32</span><span class="p">(</span><span class="nx">fd</span><span class="p">),</span> <span class="o">&amp;</span><span class="nx">ev</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div>

<p><details >
  <summary markdown="span">触发模式<code>LT</code>\ <code>ET</code>：</summary>
  <blockquote>
<ul>
<li><strong>水平触发</strong>：<code>LT</code>
<ol>
<li>对于读操作，只要缓冲内容不为空，LT模式返回读就绪。</li>
<li>对于写操作，只要缓冲区还不满，LT模式会返回写就绪。</li>
</ol>
</li>
<li>水平触发描述：
<ol>
<li>当被监控的文件描述符上有可读写事件发生时，<code>epoll_wait()</code>会通知处理程序去读写。</li>
<li>如果这次没有把数据一次性全部读写完(如读写缓冲区太小)，那么下次调用 <code>epoll_wait()</code>时，它还会通知你在上没读写完的文件描述符上继续读写，当然如果你一直不去读写，它会一直通知你。</li>
<li>如果系统中有大量你不需要读写的就绪文件描述符，而它们每次都会返回，这样会大大降低处理程序检索自己关心的就绪文件描述符的效率。</li>
</ol>
</li>
<li><strong>边缘触发</strong>：<code>ET</code>
<ol>
<li>对于读操作：
<ul>
<li>当缓冲区由不可读变为可读的时候，即缓冲区由空变为不空的时候。</li>
<li>当有新数据到达时，即缓冲区中的待读数据变多的时候。</li>
<li>当缓冲区有数据可读，且应用进程对相应的描述符进行EPOLL_CTL_MOD修改EPOLLIN事件时。</li>
</ul>
</li>
<li>对于写操作：
<ul>
<li>当缓冲区由不可写变为可写时。</li>
<li>当有旧数据被发送走，即缓冲区中的内容变少的时候。</li>
<li>当缓冲区有空间可写，且应用进程对相应的描述符进行EPOLL_CTL_MOD修改EPOLLOUT事件时。</li>
</ul>
</li>
</ol>
</li>
<li>边缘触发描述：
<ol>
<li>当被监控的文件描述符上有可读写事件发生时，<code>epoll_wait()</code>会通知处理程序去读写。</li>
<li>如果这次没有把数据全部读写完(如读写缓冲区太小)，那么下次调用 <code>epoll_wait()</code>时，它不会通知你，也就是它只会通知你一次，直到该文件描述符上出现第二次可读写事件才会通知你。</li>
<li>这种模式比水平触发效率高，系统不会充斥大量你不关心的就绪文件描述符。</li>
<li>在ET模式下，缓冲区从不可读变成可读，会唤醒应用进程，缓冲区数据变少的情况，则不会再唤醒应用进程。</li>
</ol>
</li>
<li>举例：
<ol>
<li>举例1：
<ul>
<li>读缓冲区刚开始是空的</li>
<li>读缓冲区写入2KB数据</li>
<li>水平触发和边缘触发模式此时都会发出可读信号</li>
<li>收到信号通知后，读取了1KB的数据，读缓冲区还剩余1KB数据</li>
<li>水平触发会再次进行通知，而边缘触发不会再进行通知</li>
</ul>
</li>
<li>举例2：
<ul>
<li><strong>水平触发</strong>：0为无数据，1为有数据。缓冲区有数据则一直为1，则一直触发。</li>
<li><strong>边缘触发</strong>：0为无数据，1为有数据，只要在0变到1的上升沿才触发。</li>
</ul>
</li>
</ol>
</li>
</ul>
</blockquote>

</details></p>

<h2 id="netpollclose"><code>netpollclose()</code><a hidden class="anchor" aria-hidden="true" href="#netpollclose">#</a></h2>
<ol>
<li>把文件描述符<code>fd</code>从<code>poller</code>实例中移除，也就是从<code>epoll</code>中删除。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">netpollclose</span><span class="p">(</span><span class="nx">fd</span> <span class="kt">uintptr</span><span class="p">)</span> <span class="kt">int32</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">var</span> <span class="nx">ev</span> <span class="nx">epollevent</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// _EPOLL_CTL_DEL 从epoll文件描述符epfd中删除目标文件描述符fd。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 该事件被忽略，可以为NULL。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">return</span> <span class="o">-</span><span class="nf">epollctl</span><span class="p">(</span><span class="nx">epfd</span><span class="p">,</span> <span class="nx">_EPOLL_CTL_DEL</span><span class="p">,</span> <span class="nb">int32</span><span class="p">(</span><span class="nx">fd</span><span class="p">),</span> <span class="o">&amp;</span><span class="nx">ev</span><span class="p">)</span>	
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="netpollispolldescriptor"><code>netpollIsPollDescriptor()</code><a hidden class="anchor" aria-hidden="true" href="#netpollispolldescriptor">#</a></h2>
<ol>
<li>判断是否是顶层<code>poll</code>，以及是<code>pip2</code>创建的读和写文件描述符。</li>
<li>判断文件描述符是否被<code>poller</code>使用。<code>epfd</code>、<code>netpollBreakRd</code>、<code>netpollBreakWr</code>属于被<code>poller</code>使用的描述符。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">netpollIsPollDescriptor</span><span class="p">(</span><span class="nx">fd</span> <span class="kt">uintptr</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nx">fd</span> <span class="o">==</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">epfd</span><span class="p">)</span> <span class="o">||</span> <span class="nx">fd</span> <span class="o">==</span> <span class="nx">netpollBreakRd</span> <span class="o">||</span> <span class="nx">fd</span> <span class="o">==</span> <span class="nx">netpollBreakWr</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="netpollbreak"><code>netpollBreak()</code><a hidden class="anchor" aria-hidden="true" href="#netpollbreak">#</a></h2>
<ol>
<li>用来唤醒<strong>阻塞中</strong>的<code>netpoll</code>，它实际上就是向<code>netpollBreakWr</code>描述符中写入数据，这样一来<code>epoll</code>就会监听到。</li>
<li><code>netpollBreakRd</code>的<code>EPOLLIN</code>事件(<code>EPOLLIN</code>表示对应的文件描述符可以读（包括对端<code>SOCKET</code>正常关闭）)。<code>netpollBreak</code>中断<code>epollwait</code>。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// netpollBreak interrupts an epollwait.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">netpollBreak</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// netpollWakeSig信号主要用于本轮已经通知过IO轮询，但是还没处理有其他的调用此方法时
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 使用原子操作将netpollWakeSig由0变成1，表示正在唤醒epoll。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Cas</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">netpollWakeSig</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>	
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="kd">var</span> <span class="nx">b</span> <span class="kt">byte</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 向netpollBreakWr中写入数据，会导致那些阻塞在netpoll函数中的线程直接返回去执行后面代码
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// netpollBreakWr在pipe2函数中注册时已经设置了非阻塞。因此这里不会阻塞。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="nx">n</span> <span class="o">:=</span> <span class="nf">write</span><span class="p">(</span><span class="nx">netpollBreakWr</span><span class="p">,</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">b</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 写入成功
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="k">if</span> <span class="nx">n</span> <span class="o">==</span> <span class="mi">1</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="k">break</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 在写入任何数据之前，调用被信号中断。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="k">if</span> <span class="nx">n</span> <span class="o">==</span> <span class="o">-</span><span class="nx">_EINTR</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="k">continue</span> <span class="c1">// 重试。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 已使用 O_NONBLOCK 选择了非阻塞 I/O，并且写入将阻塞。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// _EAGAIN：表示目前没有可用的数据
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="k">if</span> <span class="nx">n</span> <span class="o">==</span> <span class="o">-</span><span class="nx">_EAGAIN</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="k">return</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="nb">println</span><span class="p">(</span><span class="s">&#34;runtime: netpollBreak write failed with&#34;</span><span class="p">,</span> <span class="o">-</span><span class="nx">n</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="nf">throw</span><span class="p">(</span><span class="s">&#34;runtime: netpollBreak write failed&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="netpoll"><code>netpoll()</code><a hidden class="anchor" aria-hidden="true" href="#netpoll">#</a></h2>
<ol>
<li><code>netpoll</code>检查准备就绪的网络连接。返回可运行的<code>goroutine</code>列表。</li>
<li>参数：
<ul>
<li><code>delay &lt; 0</code>：无限期阻塞。</li>
<li><code>delay == 0</code>：不阻塞，立即返回。</li>
<li><code>delay &gt; 0</code>：阻塞长达delay纳秒。</li>
</ul>
</li>
<li>返回值：<code>gList</code>：一组就绪的goroutine。</li>
<li>根据入参delay设置调用<code>epoll_wait</code>的<code>timeout</code>值，调用<code>epoll_wait</code>从<code>epoll</code>的<code>eventpoll.rdllist</code>双向列表中获取IO就绪的fd列表，遍历<code>epoll_wait</code>返回的<code>fd</code>列表， 根据调用<code>epoll_ctl</code>注册<code>fd</code>时封装的上下文信息组装可运行的<code>goroutine</code>并返回。</li>
<li>执行完<code>netpoll</code>之后，会返回一个就绪<code>fd</code>列表对应的<code>goroutine</code>列表，接下来将就绪的<code>goroutine</code>加入到调度队列中，等待调度运行。</li>
<li><strong>netpoll的调用时机</strong>：
<ul>
<li>在调度器中执行<code>runtime.schedule()</code>，该方法中会执行<code>runtime.findrunnable()</code>函数中调用了<code>runtime.netpoll</code>获取待执行的goroutine。</li>
<li>Go runtime在程序启动的时候会创建一个独立的<code>sysmon</code>监控线程，<code>sysmon</code>每20us~10ms运行一次，每次运行会检查距离上一次执行<code>netpoll</code>是否超过10ms，如果是则会调用一次<code>runtime.netpoll</code>。</li>
</ul>
</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span><span class="lnt">113
</span><span class="lnt">114
</span><span class="lnt">115
</span><span class="lnt">116
</span><span class="lnt">117
</span><span class="lnt">118
</span><span class="lnt">119
</span><span class="lnt">120
</span><span class="lnt">121
</span><span class="lnt">122
</span><span class="lnt">123
</span><span class="lnt">124
</span><span class="lnt">125
</span><span class="lnt">126
</span><span class="lnt">127
</span><span class="lnt">128
</span><span class="lnt">129
</span><span class="lnt">130
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// netpoll checks for ready network connections.
</span></span></span><span class="line"><span class="cl"><span class="c1">// Returns list of goroutines that become runnable.
</span></span></span><span class="line"><span class="cl"><span class="c1">// 
</span></span></span><span class="line"><span class="cl"><span class="c1">// delay &lt; 0: blocks indefinitely;	
</span></span></span><span class="line"><span class="cl"><span class="c1">// delay == 0: does not block, just polls;
</span></span></span><span class="line"><span class="cl"><span class="c1">// delay &gt; 0: block for up to that many nanoseconds;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">netpoll</span><span class="p">(</span><span class="nx">delay</span> <span class="kt">int64</span><span class="p">)</span> <span class="nx">gList</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 1) epoll没有初始化
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nx">epfd</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="p">{</span>		
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="nx">gList</span><span class="p">{}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c1">// 2) 下面把纳秒级的 delay 转换成毫秒级的 waitms。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kd">var</span> <span class="nx">waitms</span> <span class="kt">int32</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">delay</span> <span class="p">&lt;</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">waitms</span> <span class="p">=</span> <span class="o">-</span><span class="mi">1</span> <span class="c1">// 永久阻塞，直到事件就绪返回
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nx">delay</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">waitms</span> <span class="p">=</span> <span class="mi">0</span> 	<span class="c1">// 不阻塞，立即返回
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nx">delay</span> <span class="p">&lt;</span> <span class="mf">1e6</span> <span class="p">{</span> <span class="c1">// 小于1毫秒，修改为阻塞1毫秒
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">waitms</span> <span class="p">=</span> <span class="mi">1</span> 	<span class="c1">// 阻塞1毫秒
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nx">delay</span> <span class="p">&lt;</span> <span class="mf">1e15</span> <span class="p">{</span> <span class="c1">// 小于 11.5 day
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 1e6 表示 1毫秒
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">waitms</span> <span class="p">=</span> <span class="nb">int32</span><span class="p">(</span><span class="nx">delay</span> <span class="o">/</span> <span class="mf">1e6</span><span class="p">)</span> <span class="c1">// 阻塞指定毫秒
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// An arbitrary cap on how long to wait for a timer.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 1e9 ms == ~11.5 days.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">waitms</span> <span class="p">=</span> <span class="mf">1e9</span>    <span class="c1">// 最长 11.5天
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c1">// 3) 通过epollwait函数等待IO事件，缓冲区大小为128个epollevent。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 超时时间是 waitms 毫秒。如果 epollwait函数被中断打断，就通过goto来重试。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// waitms 大于0时不会重试，因为需要返回调用者中去重新计算超时时间。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    
</span></span><span class="line"><span class="cl">    <span class="c1">// 下面传入epollwait的数量是128，表示一次最大就绪128个事件
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 这样可能存在此次大于128数量时，需要等到下一个IO轮询时间窗口
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//  type epollevent struct {
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//      events uint32   // 事件类型
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//      data [8]byte    // 存储用户数据，刚好是一个指针存储的大小，该数据用户是可以修改的
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//  }
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kd">var</span> <span class="nx">events</span> <span class="p">[</span><span class="mi">128</span><span class="p">]</span><span class="nx">epollevent</span>  <span class="c1">// 用于存储已经准备好的描述符的事件数据
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">retry</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 调用epollwait等待文件描述符转换成可写或可读，如果没有epollwait会阻塞
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">n</span> <span class="o">:=</span> <span class="nf">epollwait</span><span class="p">(</span><span class="nx">epfd</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">events</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">int32</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">events</span><span class="p">)),</span> <span class="nx">waitms</span><span class="p">)</span>    <span class="c1">// 返回活跃的数量n
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nx">n</span> <span class="p">&lt;</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// EBADF：epfd 不是有效的文件描述符。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// EFAULT：事件指向的内存区域无法用写权限访问。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// EINVAL：epfd 不是epoll文件描述符，或者maxevents(第三个参数)小于等于0。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="nx">n</span> <span class="o">!=</span> <span class="o">-</span><span class="nx">_EINTR</span> <span class="p">{</span> <span class="c1">// EINTR 被CPU中断
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="nb">println</span><span class="p">(</span><span class="s">&#34;runtime: epollwait on fd&#34;</span><span class="p">,</span> <span class="nx">epfd</span><span class="p">,</span> <span class="s">&#34;failed with&#34;</span><span class="p">,</span> <span class="o">-</span><span class="nx">n</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="nf">throw</span><span class="p">(</span><span class="s">&#34;runtime: netpoll failed&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// If a timed sleep was interrupted, just return to
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// recalculate how long we should sleep now.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 如果定时睡眠被中断，只需返回重新计算我们现在应该睡多久。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// _EINTR: 在任何请求的事件发生或超时到期之前，该调用被信号处理程序中断。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="nx">waitms</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="nx">gList</span><span class="p">{}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 被中断 AND waitms &lt;= 0 情况重试
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">goto</span> <span class="nx">retry</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// type gList struct { head guintptr }
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kd">var</span> <span class="nx">toRun</span> <span class="nx">gList</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 意味着被监控的文件描述符出现了待处理的事件
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="nb">int32</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">n</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 就绪的IO事件集
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">ev</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">events</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> 
</span></span><span class="line"><span class="cl">        <span class="c1">// 当前就绪描述符没有事件类型，直接跳过
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="nx">ev</span><span class="p">.</span><span class="nx">events</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">continue</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// 事件来源是否是netpollBreakRd，该描述符来之pipe2函数创建
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 来自pipe2函数创建的通信，netpollBreakRd是LT水平触发如果不读取会一直触发
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 该事件来自 netpollBreak() 方法，该方法只会在创建timer时和findRunnable()函数中被调用。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="o">*</span><span class="p">(</span><span class="o">**</span><span class="kt">uintptr</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">ev</span><span class="p">.</span><span class="nx">data</span><span class="p">))</span> <span class="o">==</span> <span class="o">&amp;</span><span class="nx">netpollBreakRd</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 对于文件描述符 netpollBreakRd 而言，只有 _EPOLLIN 事件是正常的，其他都会被视为异常。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="k">if</span> <span class="nx">ev</span><span class="p">.</span><span class="nx">events</span> <span class="o">!=</span> <span class="nx">_EPOLLIN</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="nb">println</span><span class="p">(</span><span class="s">&#34;runtime: netpoll: break fd ready for&#34;</span><span class="p">,</span> <span class="nx">ev</span><span class="p">.</span><span class="nx">events</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                <span class="nf">throw</span><span class="p">(</span><span class="s">&#34;runtime: netpoll: break fd ready for something unexpected&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">            
</span></span><span class="line"><span class="cl">            <span class="c1">// 这种情况下只处理不是立即返回情况下，如果是立即返回情况时，数据并未被读取，下次还会触发该信号
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// 这种情况下只在runtime.findrunnable()函数中存在，线程在寻找g无果时，最后只能在IO轮询处等待
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// 只有在 delay 不为0，也就是阻塞式netpoll时，才读取netpollBreakRd中的数据。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="k">if</span> <span class="nx">delay</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span> <span class="c1">// netpollBreakRd 的本意也是只唤醒delay != 0的netpoll，因为这些在阻塞需要返回
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="c1">// netpollBreak could be picked up by a
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="c1">// nonblocking poll. Only read the byte
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="c1">// if blocking.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="c1">// netpollBreak 可以通过非阻塞轮询来获取。 仅在阻塞时读取字节。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="kd">var</span> <span class="nx">tmp</span> <span class="p">[</span><span class="mi">16</span><span class="p">]</span><span class="kt">byte</span>
</span></span><span class="line"><span class="cl">                <span class="c1">// 把写入的数据读取让缓存区为空
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="nf">read</span><span class="p">(</span><span class="nb">int32</span><span class="p">(</span><span class="nx">netpollBreakRd</span><span class="p">),</span> <span class="nf">noescape</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">tmp</span><span class="p">[</span><span class="mi">0</span><span class="p">])),</span> <span class="nb">int32</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">tmp</span><span class="p">)))</span>	
</span></span><span class="line"><span class="cl">                <span class="c1">// 将netpollWakeSig由1变成0，表示当前事件已被读取
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="nx">atomic</span><span class="p">.</span><span class="nf">Store</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">netpollWakeSig</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>	
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="k">continue</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">        <span class="c1">// 根据epoll返回的IO事件标志位为mode赋值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">//  r 表示可读，w 表示可写，r+w 表示既可读又可写。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 检测IO事件中的错误标志位，并相应的为pd.everr赋值。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        
</span></span><span class="line"><span class="cl">        <span class="c1">// 判断发生的事件类型,读类型或者写类型
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="kd">var</span> <span class="nx">mode</span> <span class="kt">int32</span>		<span class="c1">// 存储当前类型 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// EPOLLIN ：表示对应的文件描述符可以读（包括对端SOCKET正常关闭）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// EPOLLRDHUP：对端描述符产生一个挂断事件
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// EPOLLHUP：本端描述符产生一个挂断事件，默认监测事件
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// EPOLLERR：表示对应的文件描述符发生错误
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="nx">ev</span><span class="p">.</span><span class="nx">events</span><span class="o">&amp;</span><span class="p">(</span><span class="nx">_EPOLLIN</span><span class="p">|</span><span class="nx">_EPOLLRDHUP</span><span class="p">|</span><span class="nx">_EPOLLHUP</span><span class="p">|</span><span class="nx">_EPOLLERR</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nx">mode</span> <span class="o">+=</span> <span class="sc">&#39;r&#39;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// EPOLLOUT：表示对应的文件描述符可以写
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// EPOLLHUP：本端描述符产生一个挂断事件，默认监测事件
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// EPOLLERR：表示对应的文件描述符发生错误
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="nx">ev</span><span class="p">.</span><span class="nx">events</span><span class="o">&amp;</span><span class="p">(</span><span class="nx">_EPOLLOUT</span><span class="p">|</span><span class="nx">_EPOLLHUP</span><span class="p">|</span><span class="nx">_EPOLLERR</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nx">mode</span> <span class="o">+=</span> <span class="sc">&#39;w&#39;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// mode不为0，表示有IO事件，需要从ev.data字段得到与IO事件关联的pollDesc。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="nx">mode</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 取出保存在 epollevent 里的pollDesc，因为要根据这个内容去恢复g如果g已被挂起时
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="nx">pd</span> <span class="o">:=</span> <span class="o">*</span><span class="p">(</span><span class="o">**</span><span class="nx">pollDesc</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">ev</span><span class="p">.</span><span class="nx">data</span><span class="p">))</span> <span class="c1">// *pollDesc
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// 对应的_EPOLLERR文件描述符出现错误时，标记错误
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="nx">pd</span><span class="p">.</span><span class="nf">setEventErr</span><span class="p">(</span><span class="nx">ev</span><span class="p">.</span><span class="nx">events</span> <span class="o">==</span> <span class="nx">_EPOLLERR</span><span class="p">)</span>	<span class="c1">// 设置pollDesc的EpollErr错误位，如果是这种状态
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="nf">netpollready</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">toRun</span><span class="p">,</span> <span class="nx">pd</span><span class="p">,</span> <span class="nx">mode</span><span class="p">)</span>	<span class="c1">// 处理就绪的描述符
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nx">toRun</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="netpollready"><code>netpollready()</code><a hidden class="anchor" aria-hidden="true" href="#netpollready">#</a></h3>
<ol>
<li><code>go1.19.3/src/runtime/runtime/netpoll.go</code>。</li>
<li><code>netpollready</code>由特定于平台的<code>netpoll</code>函数调用。它声明与<code>pd</code>相关的<code>fd</code>已经为I/O做好了准备。</li>
<li><code>toRun</code>参数用于构建一个从<code>netpoll</code>返回的<code>goroutines</code>列表。<code>mode</code>参数是<code>'r'</code>、<code>'w'</code>或<code>'r'+'w'</code>，表示<code>fd</code>是否准备好读、写或同时读和写。</li>
<li>这可能会在整个系统停止时运行，因此不允许设置写屏障。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// netpollready is called by the platform-specific netpoll function.
</span></span></span><span class="line"><span class="cl"><span class="c1">// It declares that the fd associated with pd is ready for I/O.
</span></span></span><span class="line"><span class="cl"><span class="c1">// The toRun argument is used to build a list of goroutines to return
</span></span></span><span class="line"><span class="cl"><span class="c1">// from netpoll. The mode argument is &#39;r&#39;, &#39;w&#39;, or &#39;r&#39;+&#39;w&#39; to indicate
</span></span></span><span class="line"><span class="cl"><span class="c1">// whether the fd is ready for reading or writing or both.
</span></span></span><span class="line"><span class="cl"><span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1">// This may run while the world is stopped, so write barriers are not allowed.
</span></span></span><span class="line"><span class="cl"><span class="c1">//go:nowritebarrier
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">netpollready</span><span class="p">(</span><span class="nx">toRun</span> <span class="o">*</span><span class="nx">gList</span><span class="p">,</span> <span class="nx">pd</span> <span class="o">*</span><span class="nx">pollDesc</span><span class="p">,</span> <span class="nx">mode</span> <span class="kt">int32</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">var</span> <span class="nx">rg</span><span class="p">,</span> <span class="nx">wg</span> <span class="o">*</span><span class="nx">g</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">mode</span> <span class="o">==</span> <span class="sc">&#39;r&#39;</span> <span class="o">||</span> <span class="nx">mode</span> <span class="o">==</span> <span class="sc">&#39;r&#39;</span><span class="o">+</span><span class="sc">&#39;w&#39;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// netpollunblock 可能返回 goroutine 或 nil
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">rg</span> <span class="p">=</span> <span class="nf">netpollunblock</span><span class="p">(</span><span class="nx">pd</span><span class="p">,</span> <span class="sc">&#39;r&#39;</span><span class="p">,</span> <span class="kc">true</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">mode</span> <span class="o">==</span> <span class="sc">&#39;w&#39;</span> <span class="o">||</span> <span class="nx">mode</span> <span class="o">==</span> <span class="sc">&#39;r&#39;</span><span class="o">+</span><span class="sc">&#39;w&#39;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">wg</span> <span class="p">=</span> <span class="nf">netpollunblock</span><span class="p">(</span><span class="nx">pd</span><span class="p">,</span> <span class="sc">&#39;w&#39;</span><span class="p">,</span> <span class="kc">true</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">rg</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 并入 toRun 中，这部分 goroutine 等待放入调度池中
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">toRun</span><span class="p">.</span><span class="nf">push</span><span class="p">(</span><span class="nx">rg</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">wg</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">toRun</span><span class="p">.</span><span class="nf">push</span><span class="p">(</span><span class="nx">wg</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="netpollunblock"><code>netpollunblock()</code><a hidden class="anchor" aria-hidden="true" href="#netpollunblock">#</a></h3>
<ol>
<li><code>go1.19.3/src/runtime/runtime/netpoll.go</code>。</li>
<li>netpollunblock解除阻塞。</li>
<li>参数：
<ul>
<li><code>pd *pollDesc</code>：pollDesc。</li>
<li><code>mode int32</code>：读<code>r</code>或写<code>w</code>。</li>
<li><code>ioready bool</code>：<strong>true</strong>-I/O读（用于从pollDesc中获取 goroutine），<strong>false</strong>-读写超时从pollDesc中获取goroutine。</li>
</ul>
</li>
<li>返回值：<code>*g</code>返回就绪的goroutine，可能是nil。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">netpollunblock</span><span class="p">(</span><span class="nx">pd</span> <span class="o">*</span><span class="nx">pollDesc</span><span class="p">,</span> <span class="nx">mode</span> <span class="kt">int32</span><span class="p">,</span> <span class="nx">ioready</span> <span class="kt">bool</span><span class="p">)</span> <span class="o">*</span><span class="nx">g</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 根据 mode 从rg或wg取出 goroutine。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">gpp</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">pd</span><span class="p">.</span><span class="nx">rg</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">mode</span> <span class="o">==</span> <span class="sc">&#39;w&#39;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">gpp</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">pd</span><span class="p">.</span><span class="nx">wg</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 原子读取
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">old</span> <span class="o">:=</span> <span class="nx">gpp</span><span class="p">.</span><span class="nf">Load</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// pdReady：表示fd的数据已经就绪，可供读取或写。该值从g修改pdReady。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 这种情况可能 goroutine 已经被返回给调用者了。什么都不做直接返回。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="nx">old</span> <span class="o">==</span> <span class="nx">pdReady</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// nil：没有什么可做的
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="nx">old</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="p">!</span><span class="nx">ioready</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// Only set pdReady for ioready. runtime_pollWait
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// will check for timeout/cancel before waiting.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// 只在ioready中设置pdReady。runtime_pollWait将在等待之前检查 timeout/cancel。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="k">return</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// old是0、goroutine、pdWait这三种情况。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="kd">var</span> <span class="nx">new</span> <span class="kt">uintptr</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="nx">ioready</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 修改为pdReady，表示数据已就绪或写
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="nx">new</span> <span class="p">=</span> <span class="nx">pdReady</span> 
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// CAS 交换
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="nx">gpp</span><span class="p">.</span><span class="nf">CompareAndSwap</span><span class="p">(</span><span class="nx">old</span><span class="p">,</span> <span class="nx">new</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// pdWait：表示某个goroutine即将挂起并等待fd的可读可写事件。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="k">if</span> <span class="nx">old</span> <span class="o">==</span> <span class="nx">pdWait</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="nx">old</span> <span class="p">=</span> <span class="mi">0</span> <span class="c1">// nil
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="p">(</span><span class="o">*</span><span class="nx">g</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">old</span><span class="p">))</span> <span class="c1">// nil 或 *g
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="wakenetpoller"><code>wakeNetPoller()</code><a hidden class="anchor" aria-hidden="true" href="#wakenetpoller">#</a></h2>
<ol>
<li>该函数在<code>time</code>源码中被调用，用于判断是否需要发起I/O网络轮询。</li>
<li>该方法是为了防止定时器触发时间到了没有线程能触发的情况，当只剩阻塞在<code>netpoll</code>的线程或所有的线程都处于等待中时，<code>timer</code>可能不能按时触发的情况。</li>
<li><code>wakeenetpoller</code>唤醒在网络轮询器(<code>network poller</code>)中睡眠的线程，如果它不打算在<code>when</code>参数之前被唤醒;</li>
<li>或者唤醒一个空闲的<code>P</code>来服务计时器(<code>timers</code>)和网络轮询器(<code>network poller</code>)(如果还没有的话)。</li>
<li><code>when int64</code>：表示最近的<code>timer</code>触发的时间点，因此为了避免当前最近的<code>timer</code>到时间能准时触发，需要调整<code>netpoll</code>的阻塞事件点。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// wakeNetPoller wakes up the thread sleeping in the network poller if it isn&#39;t
</span></span></span><span class="line"><span class="cl"><span class="c1">// going to wake up before the when argument; or it wakes an idle P to service
</span></span></span><span class="line"><span class="cl"><span class="c1">// timers and the network poller if there isn&#39;t one already.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">wakeNetPoller</span><span class="p">(</span><span class="nx">when</span> <span class="kt">int64</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// sched.lastpoll：记录的是上次执行netpoll的时间，如果等于0，则表示某个线程正在阻塞式地执行netpoll。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// sched.lastpoll 被设置为0只会在 findrunnable 函数中。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Load64</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lastpoll</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// In findrunnable we ensure that when polling the pollUntil
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// field is either zero or the time to which the current
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// poll is expected to run. This can have a spurious wakeup
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// but should never miss a wakeup.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 在 findrunnable 中，我们要确保轮询时 pollUntil 字段要么是0，要么为当前poll预期运行的时间。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 这里可能会是一个虚假的唤醒，但不应该错过唤醒。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// sched.pollUntil：表示阻塞式地netpoll将在何时被唤醒。该值在 findrunnable 函数中被设置。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// sched.pollUntil 值大于0时，表示最近的timer触发时间段。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">pollerPollUntil</span> <span class="o">:=</span> <span class="nb">int64</span><span class="p">(</span><span class="nx">atomic</span><span class="p">.</span><span class="nf">Load64</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">pollUntil</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// pollerPollUntil &gt; when：存在最新的计时器被加入when时间段后触发
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="nx">pollerPollUntil</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="nx">pollerPollUntil</span> <span class="p">&gt;</span> <span class="nx">when</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nf">netpollBreak</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// There are no threads in the network poller, try to get
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// one there so it can handle new timers.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="nx">GOOS</span> <span class="o">!=</span> <span class="s">&#34;plan9&#34;</span> <span class="p">{</span> <span class="c1">// Temporary workaround - see issue #42303.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="nf">wakep</span><span class="p">()</span> <span class="c1">// 尝试唤醒一个空闲的P起来服务timer和network poller。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="netpollarm"><code>netpollarm()</code><a hidden class="anchor" aria-hidden="true" href="#netpollarm">#</a></h2>
<ol>
<li>该函数在linux上不会调用，充当一个占位作用。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">netpollarm</span><span class="p">(</span><span class="nx">pd</span> <span class="o">*</span><span class="nx">pollDesc</span><span class="p">,</span> <span class="nx">mode</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;runtime: unused&#34;</span><span class="p">)</span> <span class="c1">// runtime: 未使用的
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="参考">参考<a hidden class="anchor" aria-hidden="true" href="#参考">#</a></h2>
<ol>
<li><a href="https://www.cnblogs.com/luozhiyun/p/14390824.html" target="_blank" rel="noopener">详解Go语言I/O多路复用netpoller模型</a></li>
<li><a href="https://blog.csdn.net/daocaokafei/article/details/117397600" target="_blank" rel="noopener">epoll详解</a></li>
<li><a href="https://blog.csdn.net/weixin_43705457/article/details/104522820" target="_blank" rel="noopener">epoll源码解析(1) epoll_create</a></li>
</ol>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://heliu.site/tags/golang/">Golang</a></li>
      <li><a href="https://heliu.site/tags/netpoll/">Netpoll</a></li>
    </ul>
<nav class="paginav">
  <a class="prev" href="https://heliu.site/posts/golang/netpoll/linux/">
    <span class="title">« 上一页</span>
    <br>
    <span>Linux epoll</span>
  </a>
</nav>

  </footer>
</article>
    </main>
    
<footer class="footer">
    
    <div class="busuanzi-footer">
    <span id="busuanzi_container_site_pv">
        本站总访问量<span id="busuanzi_value_site_pv"></span>次
    </span>
    <span id="busuanzi_container_site_uv">
        本站访客数<span id="busuanzi_value_site_uv"></span>人次
    </span>
    </div>
        <span>Copyright © 2020-2024 <a href="#">heliu's blog</a>. All rights reserved</span>  
    
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'Copy';

        function copyingDone() {
            copybutton.innerHTML = 'Done';
            setTimeout(() => {
                copybutton.innerHTML = 'Copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
