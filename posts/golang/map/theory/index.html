<!DOCTYPE html>
<html lang="zh" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Map(原理) | Helium</title>
<meta name="keywords" content="golang, 字典">
<meta name="description" content="💥本文章所有相关go代码参考自go 1.18&#43;版本">
<meta name="author" content="helium">
<link rel="canonical" href="https://heliu.site/posts/golang/map/theory/">
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<meta name="referrer" content="no-referrer-when-downgrade">
<link crossorigin="anonymous" href="/assets/css/stylesheet.css" rel="preload stylesheet" as="style">
<link rel="icon" href="https://heliu.site/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://heliu.site/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://heliu.site/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://heliu.site/apple-touch-icon.png">
<link rel="mask-icon" href="https://heliu.site/apple-touch-icon.png">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="zh" href="https://heliu.site/posts/golang/map/theory/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
<html>
<head>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/jetbrains-mono@1.0.6/css/jetbrains-mono-nl.min.css" />
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lxgw-wenkai-lite-webfont@1.1.0/style.css" />
    <link rel="stylesheet" href="https://cdn.staticfile.org/lxgw-wenkai-screen-webfont/1.6.0/style.css" />
    <style>
        body {
            font-family: "LXGW WenKai Lite", sans-serif;
            font-family: "LXGW WenKai Screen", sans-serif;
        }
    </style>
</head>
</html>

  

<meta property="og:title" content="Map(原理)" />
<meta property="og:description" content="💥本文章所有相关go代码参考自go 1.18&#43;版本" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://heliu.site/posts/golang/map/theory/" />
<meta property="og:image" content="https://heliu.site/favicon-32x32.png" />
<meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-01-27T00:00:00+00:00" />
<meta property="article:modified_time" content="2024-04-27T00:00:00+00:00" /><meta property="og:site_name" content="Helium" />

<meta name="twitter:card" content="summary_large_image" />
<meta name="twitter:image" content="https://heliu.site/favicon-32x32.png" />
<meta name="twitter:title" content="Map(原理)"/>
<meta name="twitter:description" content="💥本文章所有相关go代码参考自go 1.18&#43;版本"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Article",
      "item": "https://heliu.site/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Golang 合集",
      "item": "https://heliu.site/posts/golang/"
    }, 
    {
      "@type": "ListItem",
      "position":  3 ,
      "name": "第8章 Map",
      "item": "https://heliu.site/posts/golang/map/"
    }, 
    {
      "@type": "ListItem",
      "position":  4 ,
      "name": "Map(原理)",
      "item": "https://heliu.site/posts/golang/map/theory/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Map(原理)",
  "name": "Map(原理)",
  "description": "💥本文章所有相关go代码参考自go 1.18+版本",
  "keywords": [
    "golang", "字典"
  ],
  "articleBody": " 本篇介绍map的golang源码，全篇代码较多比较枯燥。 map 包说明： map 只是一个 hash 表。数据被安排在桶数组中。每个桶最多包含8个 key/elem 对。 hash 的low-order bits(hash\u00261\u003c",
  "wordCount" : "11229",
  "inLanguage": "zh",
  "image": "https://heliu.site/favicon-32x32.png","datePublished": "2021-01-27T00:00:00Z",
  "dateModified": "2024-04-27T00:00:00Z",
  "author":[{
    "@type": "Person",
    "name": "helium"
  }],
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://heliu.site/posts/golang/map/theory/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Helium",
    "logo": {
      "@type": "ImageObject",
      "url": "https://heliu.site/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://heliu.site/" accesskey="h" title="Blog (Alt + H)">
                <img src="https://heliu.site/helium.png" alt="" aria-label="logo"
                    height="35">Blog</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://heliu.site/" title="主页">
                    <span>Home</span>
                </a>
            </li>
            <li>
                <a href="https://heliu.site/posts" title="文章">
                    <span>Article</span>
                </a>
            </li>
            <li>
                <a href="https://heliu.site/archives" title="时间轴">
                    <span>Archive</span>
                </a>
            </li>
            <li>
                <a href="https://heliu.site/tags/" title="标签">
                    <span>Tag</span>
                </a>
            </li>
            <li>
                <a href="https://heliu.site/search/" title="搜索 (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
            <li>
                <a href="https://heliu.site/support" title="打赏">
                    <span>🫶Help</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">


<article class="post" autonumbering>
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://heliu.site/">主页</a>&nbsp;»&nbsp;<a href="https://heliu.site/posts/">Article</a>&nbsp;»&nbsp;<a href="https://heliu.site/posts/golang/">Golang 合集</a>&nbsp;»&nbsp;<a href="https://heliu.site/posts/golang/map/">第8章 Map</a></div>
    <h1 class="post-title entry-hint-parent">
      Map(原理)
    </h1>
    <div class="post-description">
      💥本文章所有相关go代码参考自go 1.18&#43;版本
    </div>
    <div class="post-meta">










<span class="x-post-meta-item"><svg t="1720837714681" class="icon" viewBox="0 0 1084 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="7520" width="200" height="200"><path d="M123.47509 1023.984942a123.565437 123.565437 0 0 1-123.505206-123.32451V243.863302A123.565437 123.565437 0 0 1 123.47509 120.568908h171.630374V26.06529a26.050232 26.050232 0 0 1 52.070349 0v94.503618h377.592848V26.06529a26.050232 26.050232 0 0 1 52.100464 0v94.503618h183.797189A123.565437 123.565437 0 0 1 1084.171519 243.863302v656.79713A123.565437 123.565437 0 0 1 960.666314 1023.984942H123.47509z m-71.404741-123.32451A71.434857 71.434857 0 0 0 123.47509 971.974825h837.191224a71.434857 71.434857 0 0 0 71.404741-71.314393V442.326922l-946.361273-3.824716a25.598494 25.598494 0 0 1-5.84248-0.692665l-27.796953-6.444798v469.295689zM123.47509 172.579025a71.434857 71.434857 0 0 0-71.404741 71.284277v149.736133l27.796953-6.444797a26.080348 26.080348 0 0 1 5.902712-0.662549l946.301041 3.824716V243.863302a71.404741 71.404741 0 0 0-71.404741-71.284277h-180.183284l-6.173754 12.859479a26.200812 26.200812 0 0 1-23.490383 14.786895 26.261043 26.261043 0 0 1-23.520499-14.786895l-6.173754-12.859479H350.819834l-6.173754 12.859479a26.200812 26.200812 0 0 1-23.490383 14.786895 26.230928 26.230928 0 0 1-23.520499-14.786895l-6.173755-12.859479H123.47509z m156.150814 578.827128a26.050232 26.050232 0 0 1-26.050232-25.990001c0-14.335157 11.68496-26.020116 26.050232-26.020116h521.697312c14.365273 0 26.050232 11.68496 26.050233 26.020116a26.050232 26.050232 0 0 1-26.050233 25.990001H279.625904z" fill="#3D3F42" p-id="7521"></path></svg><span>2021-01-27</span></span>&nbsp;<span class="x-post-meta-item"><svg t="1720839329181" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="14106" width="200" height="200"><path d="M699.270662 190.485379c-0.411369 0-0.821715 0.011256-1.227967 0.032746H507.034407a23.041786 23.041786 0 0 0-1.221828-0.031723c-12.779048 0-23.140023 10.359952-23.140023 23.139 0 12.781094 10.360975 23.141046 23.140023 23.141046v0.032746h193.458083v-0.032746c12.780071 0 23.141046-10.359952 23.141047-23.141046 0-12.780071-10.360975-23.140023-23.141047-23.140023zM979.215516 724.005508c0-142.090159-115.186416-257.277598-257.277598-257.277598-72.245418 0-137.532353 29.777187-184.262654 77.725223l45.868677 31.474852c36.227086-33.873482 84.882226-54.617945 138.393977-54.617945 111.945605 0 202.696492 90.750887 202.696492 202.695468h-43.01263l70.331835 104.289228 70.331835-104.289228H979.215516z" fill="" p-id="14107"></path><path d="M748.885664 588.843132c0-14.881942-12.06785-26.945699-26.947746-26.945698-14.883989 0-26.947745 12.063757-26.947745 26.945698v135.164423c0 14.879895 12.063757 26.945699 26.947745 26.945699h107.786889c14.881942 0 26.945699-12.063757 26.945698-26.945699s-12.063757-26.945699-26.945698-26.945699h-80.839143V588.843132zM721.937918 926.702c-111.947651 0-202.696492-90.74884-202.696492-202.696492 0-0.144286 0.004093-0.285502 0.004094-0.429788h43.004443l-70.330812-104.289228-70.331835 104.289228h43.075051c0 0.144286-0.00307 0.285502-0.00307 0.429788 0 142.091182 115.187439 257.279644 257.278621 257.279645 72.241324 0 137.530306-29.77821 184.260607-77.727269l-45.86663-31.474852c-36.227086 33.873482-84.884272 54.618968-138.393977 54.618968zM694.633039 423.38066c-1.354857-11.487635-11.120268-20.400632-22.972201-20.400632H206.362486c-12.780071 0-23.140023 10.359952-23.140023 23.138999 0 12.781094 10.359952 23.141046 23.140023 23.141047H596.949252c30.209022-13.81668 63.104223-22.76754 97.683787-25.879414zM438.548616 623.143333H206.362486c-12.780071 0-23.140023 10.358929-23.140023 23.140023 0 12.780071 10.359952 23.140023 23.140023 23.140023h219.956598a298.463626 298.463626 0 0 1 12.229532-46.280046zM506.934123 513.062192H206.362486c-12.780071 0-23.140023 10.359952-23.140023 23.139 0 12.781094 10.359952 23.140023 23.140023 23.140023H469.936487a302.241672 302.241672 0 0 1 36.997636-46.279023z" fill="" p-id="14108"></path><path d="M442.765661 835.277778a298.531164 298.531164 0 0 1-14.365173-46.150087H146.542052v-0.065491c-33.036417 0-59.81941-26.78197-59.81941-59.819411V329.36031h704.907545v100.905154a298.561863 298.561863 0 0 1 46.150086 14.996552V194.619536h-0.162706c0-53.422723-43.307342-96.728018-96.730065-96.728018h-68.89409V84.418668c0-33.037441-26.782993-59.81941-59.81941-59.81941v-0.361227h-18.87079v0.032745c-33.038464 0-59.820434 26.78197-59.820433 59.819411 0 0.109494 0.008186 0.218988 0.008186 0.328481h-0.339738v13.47285H345.203648V84.418668c0-33.037441-26.782993-59.81941-59.819411-59.81941v-0.361227h-18.872836v0.032745c-33.036417 0-59.81941 26.78197-59.81941 59.819411 0 0.109494 0.007163 0.218988 0.008186 0.328481h-0.339737v13.47285h-69.189826c-53.4217 0-96.729042 43.306318-96.729041 96.728018 0 1.701758 0.045025 3.39226 0.132006 5.071505v533.785166a98.051153 98.051153 0 0 0-0.132006 5.071506c0 53.4217 43.307342 96.728018 96.729041 96.728018v0.001023h305.595047zM86.723665 204.056466c0-33.037441 26.782993-59.81941 59.819411-59.819411 0.044002 0 0.086981 0.00307 0.130983 0.00307v-0.068561h105.968473V94.874811h0.032746a22.807449 22.807449 0 0 1-0.032746-1.215688c0-12.779048 10.360975-23.140023 23.140023-23.140023s23.140023 10.360975 23.140023 23.140023c0 0.408299-0.010233 0.812505-0.031722 1.215688h0.031722v49.297776h280.508696V94.874811h0.032745a22.807449 22.807449 0 0 1-0.032745-1.215688c0-12.779048 10.361999-23.140023 23.140023-23.140023 12.780071 0 23.141046 10.360975 23.141046 23.140023 0 0.408299-0.011256 0.812505-0.032746 1.215688h0.032746v49.297776h106.10048v0.065492c33.035394 0 59.818387 26.780947 59.818387 59.81941h0.130983V283.080264H86.723665v-79.023798z" fill="" p-id="14109"></path></svg><span>2024-04-27</span></span>&nbsp;<span class="x-post-meta-item"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2" fill="none"
     stroke-linecap="round" stroke-linejoin="round" class="feather feather-file-text" style="user-select: text;">
    <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z" style="user-select: text;"></path>
    <polyline points="14 2 14 8 20 8" style="user-select: text;"></polyline>
    <line x1="16" y1="13" x2="8" y2="13" style="user-select: text;"></line>
    <line x1="16" y1="17" x2="8" y2="17" style="user-select: text;"></line>
    <polyline points="10 9 9 9 8 9" style="user-select: text;"></polyline>
</svg><span>11229字</span></span>&nbsp;<span class="x-post-meta-item"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2" fill="none"
     stroke-linecap="round" stroke-linejoin="round">
    <path stroke="none" d="M0 0h24v24H0z" fill="none"></path>
    <circle cx="12" cy="12" r="9"></circle>
    <polyline points="12 7 12 12 15 15"></polyline>
</svg><span>53分钟</span></span>&nbsp;<span class="x-post-meta-item"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2" fill="none"
     stroke-linecap="round" stroke-linejoin="round">
    <path stroke="none" d="M0 0h24v24H0z" fill="none"></path>
    <circle cx="12" cy="7" r="4"></circle>
    <path d="M6 21v-2a4 4 0 0 1 4 -4h4a4 4 0 0 1 4 4v2"></path>
</svg><span>helium</span></span>
      <span class="x-post-meta-item">
        &nbsp;<svg t="1720840393161" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="18680" width="200" height="200"><path d="M995.125144 559.61812l-415.998603-415.998602A52.986489 52.986489 0 0 0 541.413335 127.99957H338.847348c-3.166656-26.559911-9.286635-51.046495-17.999939-71.333094C299.734146 7.333309 271.154242 0 256.00096 0c-13.939953 0-40.439864 6.339979-61.259794 48.806503-10.473298 21.366595-17.946606 48.966502-21.573261 79.193067H53.334974a53.393154 53.393154 0 0 0-53.333154 53.333154v360.078791a52.986489 52.986489 0 0 0 15.619948 37.713206l415.998602 415.998603a53.333154 53.333154 0 0 0 75.426413 0l26.286579-26.293245 26.286578 26.293245a53.426487 53.426487 0 0 0 16.719944 11.333295 21.333262 21.333262 0 0 0 36.079879 11.293295l382.705381-382.705381a53.399821 53.399821 0 0 0 0-75.426413z m-762.070774-491.998347C241.494342 50.373164 250.667645 42.666523 256.00096 42.666523c5.99998 0 16.573278 9.639968 25.646581 30.806564 6.493312 15.159949 11.333295 33.999886 14.146619 54.526483H216.16776c3.206656-23.419921 9.013303-44.359851 16.88661-60.41313z m243.819181 897.330319a10.666631 10.666631 0 0 1-15.079949 0l-415.998603-415.998603A10.573298 10.573298 0 0 1 42.668343 541.411515V181.332724a10.666631 10.666631 0 0 1 10.666631-10.666631h245.332509c0 47.853173-10.373298 92.15969-27.066575 115.632945-5.926647 8.326639-16.566611 14.186619-22.306592 16.113279C204.041135 314.752276 170.667913 356.218803 170.667913 405.331972c0 58.813136 47.853173 106.666308 106.666309 106.666308s106.666308-47.853173 106.666308-106.666308c0-47.086508-30.666564-87.139707-73.079754-101.246327C330.060711 272.705751 341.334007 223.692582 341.334007 170.666093h72.079758a10.573298 10.573298 0 0 1 7.539974 3.126656l415.998603 415.998603a10.666631 10.666631 0 0 1 0 15.079949zM341.334007 405.331972a63.999785 63.999785 0 1 1-63.999785-63.999785 64.073118 64.073118 0 0 1 63.999785 63.999785z m263.539114 559.61812a10.666631 10.666631 0 0 1-15.079949 0L563.499927 938.663513l303.625647-303.61898a53.399821 53.399821 0 0 0 0-75.426413L478.16688 170.666093h63.246455a10.573298 10.573298 0 0 1 7.539974 3.126656l415.998603 415.998603c0.239999 0.239999 0.466665 0.486665 0.666664 0.746664l0.086667 0.106666a10.666631 10.666631 0 0 1 0 13.373289l-0.086667 0.106666c-0.213333 0.259999-0.439999 0.506665-0.666664 0.746664z" fill="#5C5C66" p-id="18681"></path></svg>
        <ul class="post-tags-meta" style="display: inline-block;font-size: 14px;">
            <a href="https://heliu.site/tags/golang/" target="_blank" rel="noopener">Golang</a>
            <a href="https://heliu.site/tags/%E5%AD%97%E5%85%B8/" target="_blank" rel="noopener">字典</a>
        </ul>
      </span>
      
      <span id="busuanzi_container_page_pv" class="x-post-meta-item">
        &nbsp;<svg t="1720844685710" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="27237" width="200" height="200"><path d="M739.754667 574.08c-121.386667 45.610667-208.469333 169.813333-208.64 316.16 0 33.408 4.693333 65.493333 13.141333 95.914667H94.122667c-26.453333-43.52-41.685333-91.946667-41.685334-143.189334 0-185.173333 192.896-335.104 430.805334-335.104 96.256 0 184.832 24.746667 256.512 66.218667z m-280.490667-114.986667a214.869333 214.869333 0 0 1-214.869333-215.04A215.04 215.04 0 0 1 459.264 28.842667a215.04 215.04 0 0 1 215.04 215.210666 215.04 215.04 0 0 1-215.04 215.04zM974.506667 641.28c9.856 0 17.834667 7.466667 17.834666 16.64v59.989333c-0.341333 8.789333-7.850667 15.786667-17.28 16.085334-9.856 0.341333-18.176-6.826667-18.517333-16.085334v-20.053333l-99.114667 91.093333-0.256 0.256a18.474667 18.474667 0 0 1-14.848 4.352h-0.768a18.176 18.176 0 0 1-9.344-4.608l-0.938666-0.981333-85.930667-80.042667-123.562667 115.072a18.773333 18.773333 0 0 1-25.216 0 15.786667 15.786667 0 0 1 0-23.466666l136.149334-126.848 0.725333-0.597334a18.645333 18.645333 0 0 1 24.362667 0.512l87.253333 81.237334 86.058667-79.232h-21.248c-9.386667-0.298667-16.938667-7.338667-17.28-16.085334-0.341333-9.173333 7.381333-16.896 17.28-17.237333h64.64z m-367.146667 240h48.128c8.874667 0 16.042667 7.168 16.042667 16.042667v72.192a16.042667 16.042667 0 0 1-16.042667 16.042666h-48.128a16.042667 16.042667 0 0 1-16.042667-16.042666v-72.192c0-8.874667 7.210667-16.042667 16.042667-16.042667z m110.805333-106.666667h48.128c8.874667 0 16.042667 7.168 16.042667 16.042667v178.858667a16.042667 16.042667 0 0 1-16.042667 16.042666h-48.128a16.042667 16.042667 0 0 1-16.042666-16.042666v-178.858667c0-8.874667 7.168-16.042667 16.042666-16.042667z m106.538667 80h48.128c8.874667 0 16.042667 7.168 16.042667 16.042667v99.413333a16.042667 16.042667 0 0 1-16.042667 16.042667H824.746667a16.042667 16.042667 0 0 1-16.042667-16.042667v-99.413333c0-8.874667 7.168-16.042667 16.042667-16.042667z m110.165333-80h48.128c8.874667 0 16.042667 7.168 16.042667 16.042667v179.413333a16.042667 16.042667 0 0 1-16.042667 16.042667h-48.128a16.042667 16.042667 0 0 1-16.042666-16.042667v-179.413333c0-8.874667 7.210667-16.042667 16.042666-16.042667z" fill="#999999" p-id="27238"></path></svg>
        <span id="busuanzi_value_page_pv"></span>
      </span>

</div>
  </header> <aside id="toc-container" class="toc-container wide">
    <div class="toc">
        <details  open>
            <summary accesskey="c" title="(Alt + C)">
                <span class="details">目录</span>
            </summary>

            <div class="inner"><ul>
                    <li>
                        <a href="#hmap-" aria-label="hmap 🚀">hmap 🚀</a><ul>
                            
                    <li>
                        <a href="#type-hmap-struct" aria-label="type hmap struct">type hmap struct</a><ul>
                            
                    <li>
                        <a href="#createoverflow" aria-label="createOverflow()">createOverflow()</a></li>
                    <li>
                        <a href="#growing" aria-label="growing()">growing()</a></li>
                    <li>
                        <a href="#samesizegrow" aria-label="sameSizeGrow()">sameSizeGrow()</a></li>
                    <li>
                        <a href="#noldbuckets" aria-label="noldbuckets()">noldbuckets()</a></li>
                    <li>
                        <a href="#oldbucketmask" aria-label="oldbucketmask()">oldbucketmask()</a></li>
                    <li>
                        <a href="#incrnoverflow" aria-label="incrnoverflow()">incrnoverflow()</a></li>
                    <li>
                        <a href="#newoverflow" aria-label="newoverflow()">newoverflow()</a></li></ul>
                    </li>
                    <li>
                        <a href="#type-bmap-struct" aria-label="type bmap struct">type bmap struct</a><ul>
                            
                    <li>
                        <a href="#evacuated" aria-label="evacuated()">evacuated()</a></li>
                    <li>
                        <a href="#overflow" aria-label="overflow()">overflow()</a></li>
                    <li>
                        <a href="#setoverflow" aria-label="setoverflow()">setoverflow()</a></li>
                    <li>
                        <a href="#keys" aria-label="keys()">keys()</a></li></ul>
                    </li>
                    <li>
                        <a href="#type-mapextra-struct" aria-label="type mapextra struct">type mapextra struct</a></li>
                    <li>
                        <a href="#constant" aria-label="constant">constant</a></li>
                    <li>
                        <a href="#type-maptype-struct" aria-label="type maptype struct">type maptype struct</a><ul>
                            
                    <li>
                        <a href="#indirectkey" aria-label="indirectkey()">indirectkey()</a></li>
                    <li>
                        <a href="#indirectelem" aria-label="indirectelem()">indirectelem()</a></li>
                    <li>
                        <a href="#reflexivekey" aria-label="reflexivekey()">reflexivekey()</a></li>
                    <li>
                        <a href="#needkeyupdate" aria-label="needkeyupdate()">needkeyupdate()</a></li>
                    <li>
                        <a href="#hashmightpanic" aria-label="hashMightPanic()">hashMightPanic()</a></li></ul>
                    </li></ul>
                    </li>
                    <li>
                        <a href="#make-" aria-label="make() 🚀">make() 🚀</a><ul>
                            
                    <li>
                        <a href="#overloadfactor" aria-label="overLoadFactor()">overLoadFactor()</a></li>
                    <li>
                        <a href="#bucketshift" aria-label="bucketShift()">bucketShift()</a></li>
                    <li>
                        <a href="#makebucketarray" aria-label="makeBucketArray()">makeBucketArray()</a></li>
                    <li>
                        <a href="#newarray" aria-label="newarray()">newarray()</a></li>
                    <li>
                        <a href="#makemap_small" aria-label="makemap_small()">makemap_small()</a></li></ul>
                    </li>
                    <li>
                        <a href="#map-get-" aria-label="map Get 🚀">map Get 🚀</a><ul>
                            
                    <li>
                        <a href="#v--hkey" aria-label="v := h[key]">v := h[key]</a><ul>
                            
                    <li>
                        <a href="#mapaccess1_fat" aria-label="mapaccess1_fat()">mapaccess1_fat()</a></li>
                    <li>
                        <a href="#mapaccess1" aria-label="mapaccess1()">mapaccess1()</a></li>
                    <li>
                        <a href="#bucketmask" aria-label="bucketMask()">bucketMask()</a></li>
                    <li>
                        <a href="#tophash" aria-label="tophash()">tophash()</a></li>
                    <li>
                        <a href="#evacuated-1" aria-label="evacuated()">evacuated()</a></li></ul>
                    </li>
                    <li>
                        <a href="#v-b--hkey" aria-label="v, b := h[key]">v, b := h[key]</a><ul>
                            
                    <li>
                        <a href="#mapaccess2_fat" aria-label="mapaccess2_fat()">mapaccess2_fat()</a></li>
                    <li>
                        <a href="#mapaccess2" aria-label="mapaccess2()">mapaccess2()</a></li></ul>
                    </li></ul>
                    </li>
                    <li>
                        <a href="#map-set-" aria-label="map Set 🚀">map Set 🚀</a><ul>
                            
                    <li>
                        <a href="#hk--v" aria-label="h[k] = v">h[k] = v</a><ul>
                            
                    <li>
                        <a href="#reflect_mapassign" aria-label="reflect_mapassign()">reflect_mapassign()</a></li>
                    <li>
                        <a href="#mapassign" aria-label="mapassign()">mapassign()</a></li>
                    <li>
                        <a href="#isempty" aria-label="isEmpty()">isEmpty()</a></li>
                    <li>
                        <a href="#overloadfactor-1" aria-label="overLoadFactor()">overLoadFactor()</a></li>
                    <li>
                        <a href="#toomanyoverflowbuckets" aria-label="tooManyOverflowBuckets()">tooManyOverflowBuckets()</a></li></ul>
                    </li></ul>
                    </li>
                    <li>
                        <a href="#%e6%89%a9%e5%ae%b9-" aria-label="扩容 🚀">扩容 🚀</a><ul>
                            
                    <li>
                        <a href="#%e7%bf%bb%e5%80%8d%e6%89%a9%e5%ae%b9%e6%9d%a1%e4%bb%b6" aria-label="翻倍扩容条件">翻倍扩容条件</a><ul>
                            
                    <li>
                        <a href="#overloadfactor-2" aria-label="overLoadFactor()">overLoadFactor()</a></li></ul>
                    </li>
                    <li>
                        <a href="#%e7%ad%89%e9%87%8f%e6%89%a9%e5%ae%b9%e6%9d%a1%e4%bb%b6" aria-label="等量扩容条件">等量扩容条件</a><ul>
                            
                    <li>
                        <a href="#toomanyoverflowbuckets-1" aria-label="tooManyOverflowBuckets()">tooManyOverflowBuckets()</a></li></ul>
                    </li>
                    <li>
                        <a href="#%e6%89%a9%e5%ae%b9%e5%88%9d%e5%a7%8b%e5%8c%96" aria-label="扩容初始化">扩容初始化</a><ul>
                            
                    <li>
                        <a href="#hashgrow" aria-label="hashGrow()">hashGrow()</a></li></ul>
                    </li>
                    <li>
                        <a href="#%e6%b8%90%e8%bf%9b%e5%bc%8f%e8%bf%81%e7%a7%bb" aria-label="渐进式迁移">渐进式迁移</a><ul>
                            
                    <li>
                        <a href="#growwork" aria-label="growWork()">growWork()</a></li>
                    <li>
                        <a href="#evacuate" aria-label="evacuate()">evacuate()</a></li>
                    <li>
                        <a href="#evacuated-2" aria-label="evacuated()">evacuated()</a></li>
                    <li>
                        <a href="#type-evacdst-struct" aria-label="type evacDst struct">type evacDst struct</a></li>
                    <li>
                        <a href="#isempty-1" aria-label="isEmpty()">isEmpty()</a></li>
                    <li>
                        <a href="#advanceevacuationmark" aria-label="advanceEvacuationMark()">advanceEvacuationMark()</a></li>
                    <li>
                        <a href="#bucketevacuated" aria-label="bucketEvacuated()">bucketEvacuated()</a></li></ul>
                    </li></ul>
                    </li>
                    <li>
                        <a href="#%e5%88%a0%e9%99%a4-" aria-label="删除 🚀">删除 🚀</a><ul>
                            
                    <li>
                        <a href="#delete" aria-label="delete()">delete()</a></li>
                    <li>
                        <a href="#mapdelete" aria-label="mapdelete()">mapdelete()</a></li></ul>
                    </li>
                    <li>
                        <a href="#len-" aria-label="len() 🚀">len() 🚀</a><ul>
                            
                    <li>
                        <a href="#reflect_maplen" aria-label="reflect_maplen()">reflect_maplen()</a></li></ul>
                    </li>
                    <li>
                        <a href="#%e8%bf%ad%e4%bb%a3%e5%99%a8-" aria-label="迭代器 🚀">迭代器 🚀</a><ul>
                            
                    <li>
                        <a href="#type-hiter-struct" aria-label="type hiter struct">type hiter struct</a></li>
                    <li>
                        <a href="#%e5%88%9d%e5%a7%8b%e5%8c%96%e8%bf%ad%e4%bb%a3%e5%99%a8" aria-label="初始化迭代器">初始化迭代器</a><ul>
                            
                    <li>
                        <a href="#mapiterinit" aria-label="mapiterinit()">mapiterinit()</a></li></ul>
                    </li>
                    <li>
                        <a href="#%e8%bf%ad%e4%bb%a3" aria-label="迭代">迭代</a><ul>
                            
                    <li>
                        <a href="#mapiternext" aria-label="mapiternext()">mapiternext()</a></li>
                    <li>
                        <a href="#mapaccessk" aria-label="mapaccessK()">mapaccessK()</a></li></ul>
                    </li></ul>
                    </li>
                    <li>
                        <a href="#%e4%b8%8d%e8%83%bd%e4%bd%9c%e4%b8%bamap-key%e7%b1%bb%e5%9e%8b" aria-label="不能作为map key类型">不能作为map key类型</a><ul>
                            
                    <li>
                        <a href="#%e5%ae%98%e6%96%b9%e8%a7%a3%e9%87%8a" aria-label="官方解释">官方解释</a></li>
                    <li>
                        <a href="#slice%e4%b8%8d%e8%83%bd%e4%bd%9c%e4%b8%bamap-key" aria-label="slice不能作为map key">slice不能作为map key</a></li>
                    <li>
                        <a href="#map%e4%b8%8d%e8%83%bd%e4%bd%9c%e4%b8%bakey" aria-label="map不能作为key">map不能作为key</a></li>
                    <li>
                        <a href="#function%e4%b8%8d%e8%83%bd%e4%bd%9c%e4%b8%bakey" aria-label="function不能作为key">function不能作为key</a></li></ul>
                    </li>
                    <li>
                        <a href="#for-range" aria-label="for range">for range</a></li>
                    <li>
                        <a href="#map%e7%9b%b8%e5%85%b3%e7%bb%83%e4%b9%a0%e9%a2%98" aria-label="map相关练习题">map相关练习题</a><ul>
                            
                    <li>
                        <a href="#%e7%a4%ba%e4%be%8b%e4%b8%80" aria-label="示例一">示例一</a></li>
                    <li>
                        <a href="#%e7%a4%ba%e4%be%8b%e4%ba%8c" aria-label="示例二">示例二</a>
                    </li>
                </ul>
                </li>
                </ul>
            </div>
        </details>
    </div>
</aside>
<script>
    let activeElement;
    let elements;
    window.addEventListener('DOMContentLoaded', function (event) {
        checkTocPosition();

        elements = document.querySelectorAll('h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]');
         
         activeElement = elements[0];
         const id = encodeURI(activeElement.getAttribute('id')).toLowerCase();
         document.querySelector(`.inner ul li a[href="#${id}"]`).classList.add('active');
     }, false);

    window.addEventListener('resize', function(event) {
        checkTocPosition();
    }, false);

    window.addEventListener('scroll', () => {
        
        activeElement = Array.from(elements).find((element) => {
            if ((getOffsetTop(element) - window.pageYOffset) > 0 && 
                (getOffsetTop(element) - window.pageYOffset) < window.innerHeight/2) {
                return element;
            }
        }) || activeElement

        elements.forEach(element => {
             const id = encodeURI(element.getAttribute('id')).toLowerCase();
             if (element === activeElement){
                 document.querySelector(`.inner ul li a[href="#${id}"]`).classList.add('active');
             } else {
                 document.querySelector(`.inner ul li a[href="#${id}"]`).classList.remove('active');
             }
         })
     }, false);

    const main = parseInt(getComputedStyle(document.body).getPropertyValue('--article-width'), 10);
    const toc = parseInt(getComputedStyle(document.body).getPropertyValue('--toc-width'), 10);
    const gap = parseInt(getComputedStyle(document.body).getPropertyValue('--gap'), 10);

    function checkTocPosition() {
        const width = document.body.scrollWidth;

        if (width - main - (toc * 2) - (gap * 4) > 0) {
            document.getElementById("toc-container").classList.add("wide");
        } else {
            document.getElementById("toc-container").classList.remove("wide");
        }
    }

    function getOffsetTop(element) {
        if (!element.getClientRects().length) {
            return 0;
        }
        let rect = element.getBoundingClientRect();
        let win = element.ownerDocument.defaultView;
        return rect.top + win.pageYOffset;   
    }
</script>
  <div class="post-content"><ol>
<li>本篇介绍map的golang源码，全篇代码较多比较枯燥。</li>
<li>map 包说明：
<ol>
<li>map 只是一个 hash 表。数据被安排在桶数组中。每个桶最多包含8个 key/elem 对。</li>
<li>hash 的<code>low-order bits(hash&amp;1&lt;&lt;B - 1)</code>用于选择桶。每个桶包含 high-order bits（高8位）用于区分每个桶中的 entries（就是tophash）。</li>
<li>如果有超过 8 个 keys，hash 到一个桶中，我们将额外的 extra 桶链接起来。</li>
<li>当 hashtable 增长时，我们分配一个<strong>两倍</strong>大小的新桶数组。桶会从旧的桶数组<strong>渐进式</strong>复制到新的桶数组中。</li>
<li>Map 迭代器遍历桶数组，并按遍历顺序返回keys。（常规桶后是按照溢出桶的顺序返回桶索引）</li>
<li>为了维护迭代语义，我们从不将 keys 移动到桶中(如果移动，键可能会返回0或2次)。</li>
<li>在增长 table 时，迭代器仍然在迭代旧表，并且必须检查新表是否已经移动(“evacuated”)到新表。</li>
</ol>
</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// This file contains the implementation of Go&#39;s map type.
</span></span></span><span class="line"><span class="cl"><span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1">// A map is just a hash table. The data is arranged
</span></span></span><span class="line"><span class="cl"><span class="c1">// into an array of buckets. Each bucket contains up to
</span></span></span><span class="line"><span class="cl"><span class="c1">// 8 key/elem pairs. The low-order bits of the hash are
</span></span></span><span class="line"><span class="cl"><span class="c1">// used to select a bucket. Each bucket contains a few
</span></span></span><span class="line"><span class="cl"><span class="c1">// high-order bits of each hash to distinguish the entries
</span></span></span><span class="line"><span class="cl"><span class="c1">// within a single bucket.
</span></span></span><span class="line"><span class="cl"><span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1">// If more than 8 keys hash to a bucket, we chain on
</span></span></span><span class="line"><span class="cl"><span class="c1">// extra buckets.
</span></span></span><span class="line"><span class="cl"><span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1">// When the hashtable grows, we allocate a new array
</span></span></span><span class="line"><span class="cl"><span class="c1">// of buckets twice as big. Buckets are incrementally
</span></span></span><span class="line"><span class="cl"><span class="c1">// copied from the old bucket array to the new bucket array.
</span></span></span><span class="line"><span class="cl"><span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1">// Map iterators walk through the array of buckets and
</span></span></span><span class="line"><span class="cl"><span class="c1">// return the keys in walk order (bucket #, then overflow
</span></span></span><span class="line"><span class="cl"><span class="c1">// chain order, then bucket index).  To maintain iteration
</span></span></span><span class="line"><span class="cl"><span class="c1">// semantics, we never move keys within their bucket (if
</span></span></span><span class="line"><span class="cl"><span class="c1">// we did, keys might be returned 0 or 2 times).  When
</span></span></span><span class="line"><span class="cl"><span class="c1">// growing the table, iterators remain iterating through the
</span></span></span><span class="line"><span class="cl"><span class="c1">// old table and must check the new table if the bucket
</span></span></span><span class="line"><span class="cl"><span class="c1">// they are iterating through has been moved (&#34;evacuated&#34;)
</span></span></span><span class="line"><span class="cl"><span class="c1">// to the new table.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// Picking loadFactor: too large and we have lots of overflow
</span></span></span><span class="line"><span class="cl"><span class="c1">// buckets, too small and we waste a lot of space. I wrote
</span></span></span><span class="line"><span class="cl"><span class="c1">// a simple program to check some stats for different loads:
</span></span></span><span class="line"><span class="cl"><span class="c1">// (64-bit, 8 byte keys and elems)
</span></span></span><span class="line"><span class="cl"><span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1">// Picking loadFactor: 太大会有很多溢出的桶，太小会浪费很多空间。
</span></span></span><span class="line"><span class="cl"><span class="c1">// 我写了一个简单的程序来检查不同加载的一些统计信息:(64-bit, 8 byte keys and elems)
</span></span></span><span class="line"><span class="cl"><span class="c1">//  loadFactor    %overflow  bytes/entry     hitprobe    missprobe
</span></span></span><span class="line"><span class="cl"><span class="c1">//        4.00         2.13        20.77         3.00         4.00
</span></span></span><span class="line"><span class="cl"><span class="c1">//        4.50         4.05        17.30         3.25         4.50
</span></span></span><span class="line"><span class="cl"><span class="c1">//        5.00         6.85        14.77         3.50         5.00
</span></span></span><span class="line"><span class="cl"><span class="c1">//        5.50        10.55        12.94         3.75         5.50
</span></span></span><span class="line"><span class="cl"><span class="c1">//        6.00        15.27        11.67         4.00         6.00
</span></span></span><span class="line"><span class="cl"><span class="c1">//        6.50        20.90        10.79         4.25         6.50  -- loadFactor = 13/2
</span></span></span><span class="line"><span class="cl"><span class="c1">//        7.00        27.14        10.15         4.50         7.00
</span></span></span><span class="line"><span class="cl"><span class="c1">//        7.50        34.03         9.73         4.75         7.50
</span></span></span><span class="line"><span class="cl"><span class="c1">//        8.00        41.10         9.40         5.00         8.00
</span></span></span><span class="line"><span class="cl"><span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1">// %overflow   = percentage of buckets which have an overflow bucket # 有溢出桶的桶的百分比
</span></span></span><span class="line"><span class="cl"><span class="c1">// bytes/entry = overhead bytes used per key/elem pair  # 每个 key/elem 对使用的开销字节数
</span></span></span><span class="line"><span class="cl"><span class="c1">// hitprobe    = # of entries to check when looking up a present key # 在查找当前键时要检查的条目
</span></span></span><span class="line"><span class="cl"><span class="c1">// missprobe   = # of entries to check when looking up an absent key # 在查找缺失键时要检查的条目
</span></span></span><span class="line"><span class="cl"><span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1">// Keep in mind this data is for maximally loaded tables, i.e. just
</span></span></span><span class="line"><span class="cl"><span class="c1">// before the table grows. Typical tables will be somewhat less loaded.
</span></span></span></code></pre></td></tr></table>
</div>
</div><h2 id="hmap-">hmap 🚀<a hidden class="anchor" aria-hidden="true" href="#hmap-">#</a></h2>
<h3 id="type-hmap-struct">type hmap struct<a hidden class="anchor" aria-hidden="true" href="#type-hmap-struct">#</a></h3>
<p>结构说明：go的map中存储的是hmap的指针。map分配的是一块连续的内存，包括常规桶和溢出桶的内存。</p>
<ol>
<li><strong>count</strong>：记录map中存储的键值对数量。该值也是<code>len(map)</code>返回值。<code>cap()</code>函数对map没有实际作用。</li>
<li><strong>flags</strong>：扩容、迭代相关标志位。</li>
<li><strong>B</strong>：<strong>常规桶</strong>个数<code>2^B</code>，此处的B是幂次方。注意这里<strong>并没</strong>有包括溢出桶数量。</li>
<li><strong>noverflow</strong>：已使用的溢出桶数量，该值用于<strong>等量扩容</strong>的判断值。</li>
<li><strong>hash0</strong>：生成的随机值，扩容时候该值不会被刷新。但是在删除时map为空时会刷新。</li>
<li><strong>buckets</strong>：常规桶起始地址。</li>
<li><strong>oldbuckets</strong>：扩容时用于存储旧常规桶的起始地址也就是buckets的值，当<code>oldbuckets != nil</code>时也是扩容正在进行的条件。</li>
<li><strong>nevacuate</strong>：扩容正在进行中下一个要被迁移的旧桶编号。</li>
<li><strong>extra</strong>：溢出桶相关信息。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// A header for a Go map.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">type</span> <span class="nx">hmap</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Note: the format of the hmap is also encoded in cmd/compile/internal/gc/reflect.go.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// Make sure this stays in sync with the compiler&#39;s definition.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    
</span></span><span class="line"><span class="cl">    <span class="c1">// 1. 已经存储的键值对个数，len(map) == count
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 2. map不能使用cap()函数，cap()函数是计算容量，对于map来说意义不大
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">count</span>     <span class="kt">int</span> <span class="c1">// # live cells == size of map.  Must be first (used by len() builtin)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">flags</span>     <span class="kt">uint8</span> <span class="c1">// 当前hmap的状态，比如正处于写入数据中等，参看下面的常量
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 【常规桶】个数等于 2^B，make()初始化时该值会被设置，注意这里并【没用】包含溢出桶的数量
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">B</span>         <span class="kt">uint8</span>  <span class="c1">// log_2 of # of buckets (最多可以容纳 loadFactor * 2^B items)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 已使用的溢出桶数量，用于是否等量扩容判断，在make初始化和扩容初始化时被重置为0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 已使用溢出桶的计数规则：
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//  1. 常规桶 h.B &lt;= 15 时，每使用了一个溢出桶 h.noverflow++
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//  2. 常规桶 h.B &gt; 16 时，按照一定概率增加溢出桶 1/((1 &lt;&lt; (h.B-15))-1) 的概率 h.noverflow++
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">noverflow</span> <span class="kt">uint16</span> <span class="c1">// approximate number of overflow buckets; see incrnoverflow for details
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 在make初始化时根据随机数生成
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// hash随机数，用于生成key的hash值，make初始化时该值会被设置
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">hash0</span>     <span class="kt">uint32</span> <span class="c1">// hash seed	
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 常规桶起始地址，make初始化时该值会被设置
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 该值也许为nil，当count==0时，在【[key] = elem】时会初始化分配内存
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">buckets</span>    <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span> <span class="c1">// array of 2^B Buckets. may be nil if count==0.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 当存在扩容时会把hmap.buckets值拷贝到hmap.oldbuckets
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 这也是判断扩容的条件 hmap.oldbuckets != nil
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">oldbuckets</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span> <span class="c1">// previous bucket array of half the size, non-nil only when growing
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 记录下一个要被迁移的旧桶编号，在扩容初始化时被重置为0，被分摊到到每次map操作中渐进迁移
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">nevacuate</span>  <span class="kt">uintptr</span>  <span class="c1">// progress counter for evacuation (buckets less than this have been evacuated)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="c1">// make初始化时extra.nextOverflow改值会被设置，记录溢出桶的首地址
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//  溢出桶分配规则常规桶 【h.B &gt;= 4】，就会预分配 【h.B-4】 个溢出桶备用
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// extra 主要是记录分配的备用空闲溢出桶地址 extra.nextOverflow，以及分配过的无指针溢出桶记录在extra.overflow
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">extra</span> <span class="o">*</span><span class="nx">mapextra</span> <span class="c1">// optional fields	溢出桶信息 以及 扩容信息
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="createoverflow">createOverflow()<a hidden class="anchor" aria-hidden="true" href="#createoverflow">#</a></h4>
<ol>
<li>创建一个 extra 或 extra.overflow。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">h</span> <span class="o">*</span><span class="nx">hmap</span><span class="p">)</span> <span class="nf">createOverflow</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">h</span><span class="p">.</span><span class="nx">extra</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>	
</span></span><span class="line"><span class="cl">        <span class="nx">h</span><span class="p">.</span><span class="nx">extra</span> <span class="p">=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">mapextra</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">h</span><span class="p">.</span><span class="nx">extra</span><span class="p">.</span><span class="nx">overflow</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// slice多采用make()创建，这里采用new创建
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 也就是只是创建24B大小内存，&amp;slice{0,0,0}
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 后续overflow字段会通过append()函数添加元素
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 当bmap是指针类型时，用于存储溢出bmap，以免被GC给回收了
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">h</span><span class="p">.</span><span class="nx">extra</span><span class="p">.</span><span class="nx">overflow</span> <span class="p">=</span> <span class="nb">new</span><span class="p">([]</span><span class="o">*</span><span class="nx">bmap</span><span class="p">)</span> 
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="growing">growing()<a hidden class="anchor" aria-hidden="true" href="#growing">#</a></h4>
<ol>
<li>判断当前map是否处于<strong>扩容状态</strong>，可能是<strong>翻倍扩容</strong>或<strong>等量扩容</strong>。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// growing reports whether h is growing. The growth may be to the same size or bigger.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">h</span> <span class="o">*</span><span class="nx">hmap</span><span class="p">)</span> <span class="nf">growing</span><span class="p">()</span> <span class="kt">bool</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nx">h</span><span class="p">.</span><span class="nx">oldbuckets</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="c1">// true.处于扩容状态
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="samesizegrow">sameSizeGrow()<a hidden class="anchor" aria-hidden="true" href="#samesizegrow">#</a></h4>
<ol>
<li>sameSizeGrow 表示当前正在处于<strong>等量扩容</strong>状态。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// sameSizeGrow reports whether the current growth is to a map of the same size.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">h</span> <span class="o">*</span><span class="nx">hmap</span><span class="p">)</span> <span class="nf">sameSizeGrow</span><span class="p">()</span> <span class="kt">bool</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nx">h</span><span class="p">.</span><span class="nx">flags</span><span class="o">&amp;</span><span class="nx">sameSizeGrow</span> <span class="o">!=</span> <span class="mi">0</span> <span class="c1">// true.等量扩容
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="noldbuckets">noldbuckets()<a hidden class="anchor" aria-hidden="true" href="#noldbuckets">#</a></h4>
<ol>
<li>noldbuckets 计算当前 map 扩容之前的常规桶数。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// noldbuckets calculates the number of buckets prior to the current map growth.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">h</span> <span class="o">*</span><span class="nx">hmap</span><span class="p">)</span> <span class="nf">noldbuckets</span><span class="p">()</span> <span class="kt">uintptr</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">oldB</span> <span class="o">:=</span> <span class="nx">h</span><span class="p">.</span><span class="nx">B</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">!</span><span class="nx">h</span><span class="p">.</span><span class="nf">sameSizeGrow</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">oldB</span><span class="o">--</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nf">bucketShift</span><span class="p">(</span><span class="nx">oldB</span><span class="p">)</span> <span class="c1">// 1 &lt;&lt; B
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="oldbucketmask">oldbucketmask()<a hidden class="anchor" aria-hidden="true" href="#oldbucketmask">#</a></h4>
<ol>
<li>常规桶扩容之前的掩码数。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// oldbucketmask provides a mask that can be applied to calculate n % noldbuckets().
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">h</span> <span class="o">*</span><span class="nx">hmap</span><span class="p">)</span> <span class="nf">oldbucketmask</span><span class="p">()</span> <span class="kt">uintptr</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nx">h</span><span class="p">.</span><span class="nf">noldbuckets</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span>  <span class="c1">// 桶增长之前的掩码
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="incrnoverflow">incrnoverflow()<a hidden class="anchor" aria-hidden="true" href="#incrnoverflow">#</a></h4>
<ol>
<li>Incrnoverflow 增加 h.noverflow。noverflow 统计溢出桶的数量。</li>
<li>这用于触发等量扩容大小的map增长。等量扩容条件参看 tooManyOverflowBuckets 方法。</li>
<li>为了保持hmap较小，noverflow是uint16类型。</li>
<li>当桶很少时，noverflow是一个精确的计数。当有很多桶时，noverflow是一个近似的计数。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// incrnoverflow increments h.noverflow.
</span></span></span><span class="line"><span class="cl"><span class="c1">// noverflow counts the number of overflow buckets.
</span></span></span><span class="line"><span class="cl"><span class="c1">// This is used to trigger same-size map growth.
</span></span></span><span class="line"><span class="cl"><span class="c1">// See also tooManyOverflowBuckets.
</span></span></span><span class="line"><span class="cl"><span class="c1">// To keep hmap small, noverflow is a uint16.
</span></span></span><span class="line"><span class="cl"><span class="c1">// When there are few buckets, noverflow is an exact count.
</span></span></span><span class="line"><span class="cl"><span class="c1">// When there are many buckets, noverflow is an approximate count.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">h</span> <span class="o">*</span><span class="nx">hmap</span><span class="p">)</span> <span class="nf">incrnoverflow</span><span class="p">()</span> <span class="p">{</span>	<span class="c1">// 增加使用的溢出桶计数器
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// We trigger same-size map growth if there are
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// as many overflow buckets as buckets.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// We need to be able to count to 1&lt;&lt;h.B.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 如果溢出桶和常规桶一样多，我们就会触发等量扩容map。我们需要能够数到 1&lt;&lt;h.B。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nx">h</span><span class="p">.</span><span class="nx">B</span> <span class="p">&lt;</span> <span class="mi">16</span> <span class="p">{</span>       <span class="c1">// 当桶的数量 &lt;= 2^15 溢出桶加一
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">h</span><span class="p">.</span><span class="nx">noverflow</span><span class="o">++</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Increment with probability 1/(1&lt;&lt;(h.B-15)).
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// When we reach 1&lt;&lt;15 - 1, we will have approximately
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// as many overflow buckets as buckets.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 以1/(1&lt;&lt;(h.B-15))概率递增加一
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">mask</span> <span class="o">:=</span> <span class="nb">uint32</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="nx">h</span><span class="p">.</span><span class="nx">B</span><span class="o">-</span><span class="mi">15</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>	
</span></span><span class="line"><span class="cl">    <span class="c1">// Example: if h.B == 18, then mask == 7,
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// and fastrand &amp; 7 == 0 with probability 1/8.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nf">fastrand</span><span class="p">()</span><span class="o">&amp;</span><span class="nx">mask</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">h</span><span class="p">.</span><span class="nx">noverflow</span><span class="o">++</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="newoverflow">newoverflow()<a hidden class="anchor" aria-hidden="true" href="#newoverflow">#</a></h4>
<ol>
<li>分配新的溢出桶，如果当前桶满了则需要分配溢出桶调用此方法返回溢出桶。</li>
<li>该方法有备用的溢出桶已用完重新分配溢出桶情况。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">h</span> <span class="o">*</span><span class="nx">hmap</span><span class="p">)</span> <span class="nf">newoverflow</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">maptype</span><span class="p">,</span> <span class="nx">b</span> <span class="o">*</span><span class="nx">bmap</span><span class="p">)</span> <span class="o">*</span><span class="nx">bmap</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">var</span> <span class="nx">ovf</span> <span class="o">*</span><span class="nx">bmap</span> <span class="c1">// 分配的溢出桶 *bmap
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 当前溢出桶信息不为空 并且 下一个溢出桶不为空 直接从后面获取
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nx">h</span><span class="p">.</span><span class="nx">extra</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="nx">h</span><span class="p">.</span><span class="nx">extra</span><span class="p">.</span><span class="nx">nextOverflow</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>	
</span></span><span class="line"><span class="cl">        <span class="c1">// We have preallocated overflow buckets available.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// See makeBucketArray for more details.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 我们有预先分配的溢出桶可用。更多细节请参见makeBucketArray方法。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">ovf</span> <span class="p">=</span> <span class="nx">h</span><span class="p">.</span><span class="nx">extra</span><span class="p">.</span><span class="nx">nextOverflow</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 判断溢出桶的overflow字段是否为nil，用于判断分配的备用溢出桶使用已用完
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 参看makeBucketArray方法中把最后一个溢出桶overflow指向了第一个常规桶地址
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="nx">ovf</span><span class="p">.</span><span class="nf">overflow</span><span class="p">(</span><span class="nx">t</span><span class="p">)</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// We&#39;re not at the end of the preallocated overflow buckets. Bump the pointer.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// 我们还没有到达预分配的溢出桶的末尾。碰一下指针。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="nx">h</span><span class="p">.</span><span class="nx">extra</span><span class="p">.</span><span class="nx">nextOverflow</span> <span class="p">=</span> <span class="p">(</span><span class="o">*</span><span class="nx">bmap</span><span class="p">)(</span><span class="nf">add</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">ovf</span><span class="p">),</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">bucketsize</span><span class="p">)))</span>	<span class="c1">// 下一个空闲的溢出桶
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span> <span class="c1">// 已经是最后一个备用的溢出桶了（最后一个溢出桶指向了第一个常规桶，其他溢出桶都应该未nil）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// This is the last preallocated overflow bucket.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// Reset the overflow pointer on this bucket,
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// which was set to a non-nil sentinel value.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// 这是最后一个预分配的溢出桶。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// 重置此桶上的溢出指针，该指针被设置为非nil哨兵值。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="nx">ovf</span><span class="p">.</span><span class="nf">setoverflow</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span> <span class="c1">// ovf.overflow = nil
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="nx">h</span><span class="p">.</span><span class="nx">extra</span><span class="p">.</span><span class="nx">nextOverflow</span> <span class="p">=</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 溢出桶以分配完了 或者 没有分配溢出桶时
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 注意：这里直接调用new()函数分配的
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">ovf</span> <span class="p">=</span> <span class="p">(</span><span class="o">*</span><span class="nx">bmap</span><span class="p">)(</span><span class="nf">newobject</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">bucket</span><span class="p">))</span>	
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c1">// 已使用溢出桶计数器
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">h</span><span class="p">.</span><span class="nf">incrnoverflow</span><span class="p">()</span>	
</span></span><span class="line"><span class="cl">    <span class="c1">// 桶不包含指针
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nx">t</span><span class="p">.</span><span class="nx">bucket</span><span class="p">.</span><span class="nx">ptrdata</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">h</span><span class="p">.</span><span class="nf">createOverflow</span><span class="p">()</span>	<span class="c1">// 防止 h.extra 或 h.extra.overflow 没有初始化
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 将分配的溢出桶保存在h.extra.overflow中，主要是防止这部分内存不该被GC清理，结果被清除了
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="o">*</span><span class="nx">h</span><span class="p">.</span><span class="nx">extra</span><span class="p">.</span><span class="nx">overflow</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="o">*</span><span class="nx">h</span><span class="p">.</span><span class="nx">extra</span><span class="p">.</span><span class="nx">overflow</span><span class="p">,</span> <span class="nx">ovf</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nx">b</span><span class="p">.</span><span class="nf">setoverflow</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">ovf</span><span class="p">)</span>   <span class="c1">// b.overflow = ovf
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">return</span> <span class="nx">ovf</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="type-bmap-struct">type bmap struct<a hidden class="anchor" aria-hidden="true" href="#type-bmap-struct">#</a></h3>
<ol>
<li>bmap 用来装 map 的桶。</li>
<li>bmap 前8字节是 <code>tophash</code> 值，后面分别是8个连续的 <code>key</code> 和8个连续的 <code>value</code> 然后是一个溢出桶指针。</li>
<li>之所以桶按照这个结构设计是为了内存紧凑。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// A bucket for a Go map.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">type</span> <span class="nx">bmap</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// tophash generally contains the top byte of the hash value
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// for each key in this bucket. If tophash[0] &lt; minTopHash,
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// tophash[0] is a bucket evacuation state instead.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// Tophash通常包含该桶中每个键的散列值的顶部字节。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 如果tophash[0] &lt; minTopHash，则tophash[0]为桶疏散状态。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// const minTopHash = 5 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// const bucketCnt = 8;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">tophash</span> <span class="p">[</span><span class="nx">bucketCnt</span><span class="p">]</span><span class="kt">uint8</span>    <span class="c1">// [8]uint8
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// Followed by bucketCnt keys and then bucketCnt elems.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// NOTE: packing all the keys together and then all the elems together makes the
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// code a bit more complicated than alternating key/elem/key/elem/... but it allows
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// us to eliminate padding which would be needed for, e.g., map[int64]int8.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// Followed by an overflow pointer. 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 接下来是bucketCnt的keys，然后是bucketCnt的elems。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 注意: 将所有key打包在一起，然后将所有elem打包在一起
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 这比交替使用key/elem/key/elem/…但它允许我们消除所需的内边距，例如 map[int64]int8。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 后跟一个溢出指针。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ol start="4">
<li><strong>bmap</strong> 结构：
<ol>
<li><strong>h1 - h8</strong>：8个hash值分别是key的hash高八位，主要用于快速查找key和bmap桶的相关迁移状态标记。</li>
<li><strong>k1 - k8</strong>：8个key的值。</li>
<li><strong>v1 - v8</strong>：8个value的值。</li>
<li><strong>overflow</strong>：指向后面溢出桶的指针。</li>
</ol>
</li>
</ol>
<p><img loading="lazy" src="../images/map-001.png" alt=""  />
</p>
<h4 id="evacuated">evacuated()<a hidden class="anchor" aria-hidden="true" href="#evacuated">#</a></h4>
<ol>
<li>该 bmap 桶是否是<strong>疏散的</strong>，1 &lt; tophash[0] &lt; 5，表明该 bmap 桶数据已被迁移。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">evacuated</span><span class="p">(</span><span class="nx">b</span> <span class="o">*</span><span class="nx">bmap</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">h</span> <span class="o">:=</span> <span class="nx">b</span><span class="p">.</span><span class="nx">tophash</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 参看后面 consts 中相关常量定义
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// const emptyOne = 1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// const minTopHash = 5
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// return h IN (2,3,4)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">return</span> <span class="nx">h</span> <span class="p">&gt;</span> <span class="nx">emptyOne</span> <span class="o">&amp;&amp;</span> <span class="nx">h</span> <span class="p">&lt;</span> <span class="nx">minTopHash</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="overflow">overflow()<a hidden class="anchor" aria-hidden="true" href="#overflow">#</a></h4>
<ol>
<li>该 bmap 桶的 overflow 字段指向的溢出桶 <code>*bmap</code>。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">b</span> <span class="o">*</span><span class="nx">bmap</span><span class="p">)</span> <span class="nf">overflow</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">maptype</span><span class="p">)</span> <span class="o">*</span><span class="nx">bmap</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// b + bucketsize - goarch.PtrSize
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">return</span> <span class="o">*</span><span class="p">(</span><span class="o">**</span><span class="nx">bmap</span><span class="p">)(</span><span class="nf">add</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">b</span><span class="p">),</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">bucketsize</span><span class="p">)</span><span class="o">-</span><span class="nx">goarch</span><span class="p">.</span><span class="nx">PtrSize</span><span class="p">))</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="setoverflow">setoverflow()<a hidden class="anchor" aria-hidden="true" href="#setoverflow">#</a></h4>
<ol>
<li>该 bmap 桶的 overflow 字段指向 ovf *bmap 这个桶。</li>
<li>等价于 <strong><code>bmap.overflow = ovf </code></strong>。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">b</span> <span class="o">*</span><span class="nx">bmap</span><span class="p">)</span> <span class="nf">setoverflow</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">maptype</span><span class="p">,</span> <span class="nx">ovf</span> <span class="o">*</span><span class="nx">bmap</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// bmap.overflow = ovf
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="o">*</span><span class="p">(</span><span class="o">**</span><span class="nx">bmap</span><span class="p">)(</span><span class="nf">add</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">b</span><span class="p">),</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">bucketsize</span><span class="p">)</span><span class="o">-</span><span class="nx">goarch</span><span class="p">.</span><span class="nx">PtrSize</span><span class="p">))</span> <span class="p">=</span> <span class="nx">ovf</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="keys">keys()<a hidden class="anchor" aria-hidden="true" href="#keys">#</a></h4>
<ol>
<li>返回该 bmap 桶的 key 开始地址。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">b</span> <span class="o">*</span><span class="nx">bmap</span><span class="p">)</span> <span class="nf">keys</span><span class="p">()</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// dataOffset 参看后面 consts 中的常量定义
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// dataOffset -&gt; [8]uint8
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">return</span> <span class="nf">add</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">b</span><span class="p">),</span> <span class="nx">dataOffset</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="type-mapextra-struct">type mapextra struct<a hidden class="anchor" aria-hidden="true" href="#type-mapextra-struct">#</a></h3>
<ol>
<li>Mapextra 持有一些在所有map中都不存在的字段。主要是溢出桶相关。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// mapextra holds fields that are not present on all maps.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">type</span> <span class="nx">mapextra</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// If both key and elem do not contain pointers and are inline, then we mark bucket
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// type as containing no pointers. This avoids scanning such maps.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// However, bmap.overflow is a pointer. In order to keep overflow buckets
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// alive, we store pointers to all overflow buckets in hmap.extra.overflow and hmap.extra.oldoverflow.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// overflow and oldoverflow are only used if key and elem do not contain pointers.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// overflow contains overflow buckets for hmap.buckets.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// oldoverflow contains overflow buckets for hmap.oldbuckets.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// The indirection allows to store a pointer to the slice in hiter.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 如果 key 和 elem 都不包含指针并且是允许内联(inline)的，那么我们将bucket类型标记为【不包含指针】。这样避免了扫描这样的map。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 然而 bmap.overflow 是一个指针。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 为了保持overflow桶是alive(活跃的不被GC回收)，我们将指向所有overflow桶的指针存储在hmap.extra.overflow和hmap.extra.oldoverflow中
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 【仅当 key 和 elem 不包含指针时，才使用 overflow 和 oldoverflow。】因为不包含指针才容易被GC回收，因此需要保存。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// overflow 包含用于 hmap.buckets 的overflow桶集
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// oldoverflow 包含用于 hmap.oldbuckets 的overflow桶集
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 间接允许在hiter中存储一个指向切片的指针。(hiter是遍历相关结构)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">overflow</span>    <span class="o">*</span><span class="p">[]</span><span class="o">*</span><span class="nx">bmap</span> <span class="c1">// 在 key 和 elem 不包含指针时，把已经用到的溢出桶存储起来，主要是保存 alive
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">oldoverflow</span> <span class="o">*</span><span class="p">[]</span><span class="o">*</span><span class="nx">bmap</span> <span class="c1">// 扩容正在进行时，把 overflow 数据拷贝到这里 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="c1">// nextOverflow holds a pointer to a free overflow bucket.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// nextOverflow保存了一个指向空闲溢出桶的指针。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 下一个尚未使用的溢出桶，这里桶之间是一个链表链接所有的溢出桶。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 该值在make函数中被设置成申请的首个溢出桶
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">nextOverflow</span> <span class="o">*</span><span class="nx">bmap</span>	
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><img loading="lazy" src="../images/map-002.png" alt=""  />
</p>
<h3 id="constant">constant<a hidden class="anchor" aria-hidden="true" href="#constant">#</a></h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">const</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Maximum number of key/elem pairs a bucket can hold.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 一个桶可以容纳的最大 key/elem 对数量
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">bucketCntBits</span> <span class="p">=</span> <span class="mi">3</span>
</span></span><span class="line"><span class="cl">    <span class="nx">bucketCnt</span>     <span class="p">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="nx">bucketCntBits</span> <span class="c1">// 2^3 = 8
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Maximum average load of a bucket that triggers growth is 6.5.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// Represent as loadFactorNum/loadFactorDen, to allow integer math.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 触发增长的桶的最大平均负载为13/2 = 6.5。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 表示为 loadFactorNum/loadFactorDen ，允许进行整数运算。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">loadFactorNum</span> <span class="p">=</span> <span class="mi">13</span>  <span class="c1">// loadFactorNum/loadFactorDen = 6.5
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">loadFactorDen</span> <span class="p">=</span> <span class="mi">2</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// Maximum key or elem size to keep inline (instead of mallocing per element).
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// Must fit in a uint8.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// Fast versions cannot handle big elems - the cutoff size for
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// fast versions in cmd/compile/internal/gc/walk.go must be at most this elem.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 保存inline的最大 key 或 elem 大小(而不是为每个元素分配内存)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 必须适配在uint8中。快速版本不能处理大元素-在cmd/compile/internal/gc/walk中快速版本的截止大小。Go最多只能是这个elem。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">maxKeySize</span>  <span class="p">=</span> <span class="mi">128</span> <span class="c1">// map键最大内存值 128B，超过该值则是桶的key是间接存储的，也就是只是存储的是指针
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">maxElemSize</span> <span class="p">=</span> <span class="mi">128</span> <span class="c1">// map值最大内存值 128B，超过该值则是桶的elem是间接存储的，也就是只是存储的是指针
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="c1">// data offset should be the size of the bmap struct, but needs to be
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// aligned correctly. For amd64p32 this means 64-bit alignment
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// even though pointers are 32 bit.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// dataOffset 是bmap结构体的长度，但需要正确对齐
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 对于amd64p32，这意味着即使指针是32位，也会进行64位对齐。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">dataOffset</span> <span class="p">=</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Offsetof</span><span class="p">(</span><span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">b</span> <span class="nx">bmap</span>      <span class="c1">// 8B
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">v</span> <span class="kt">int64</span>     <span class="c1">// 8B
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}{}.</span><span class="nx">v</span><span class="p">)</span> <span class="c1">// dataOffset = 8B   bmap桶的第一个key偏移量
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Possible tophash values. We reserve a few possibilities for special marks.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// Each bucket (including its overflow buckets, if any) will have either all or none of its
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// entries in the evacuated* states (except during the evacuate() method, which only happens
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// during map writes and thus no one else can observe the map during that time).
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 可能的 tophash 值。我们保留一些特殊标记的可能性。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 每个桶(包括它的溢出桶，如果有的话)的所有条目都将处于 evacuated* 状态(除非在使用evacuate()方法时，这种情况只发生在map写操作期间，
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 因此，在这段时间内，没有其他人可以观察map)。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 当前格为空的默认状态，后面格都为空不存在其他数据
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">emptyRest</span>      <span class="p">=</span> <span class="mi">0</span> <span class="c1">// this cell is empty, and there are no more non-empty cells at higher indexes or overflows.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 当前格为空，后面格还存在其他数据。在当前格被删除时会被标记为1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">emptyOne</span>       <span class="p">=</span> <span class="mi">1</span> <span class="c1">// this cell is empty
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// key/elem是有效的，entry已被疏散到翻倍后的新桶里，原来的桶号处
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">evacuatedX</span>     <span class="p">=</span> <span class="mi">2</span> <span class="c1">// key/elem is valid.  Entry has been evacuated to first half of larger table.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// key/elem是有效的，entry已被疏散到翻倍后的新桶里，原来桶号的2倍处
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">evacuatedY</span>     <span class="p">=</span> <span class="mi">3</span> <span class="c1">// same as above, but evacuated to second half of larger table.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 单元格是空的。在扩容进行中被标记从 0或1标记为4
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">evacuatedEmpty</span> <span class="p">=</span> <span class="mi">4</span> <span class="c1">// cell is empty, bucket is evacuated.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 正常填充单元格的最小值，比如某个key计算后的hash值为0则填充为5。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">minTopHash</span>     <span class="p">=</span> <span class="mi">5</span> <span class="c1">// minimum tophash for a normal filled cell.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="c1">// flags
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 可能有一个使用buckets的迭代器
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">iterator</span>     <span class="p">=</span> <span class="mi">1</span> <span class="c1">// there may be an iterator using buckets
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 可能有一个使用oldbuckets的迭代器
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">oldIterator</span>  <span class="p">=</span> <span class="mi">2</span> <span class="c1">// there may be an iterator using oldbuckets
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 一个goroutine正在向map写入数据，用于判断map是否在读写删除并发操作
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 在m[key] = elem时被设置或在delete删除key时被设置
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">hashWriting</span>  <span class="p">=</span> <span class="mi">4</span> <span class="c1">// a goroutine is writing to the map
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 等量扩容标志位
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">sameSizeGrow</span> <span class="p">=</span> <span class="mi">8</span> <span class="c1">// the current map growth is to a new map of the same size
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="c1">// sentinel bucket ID for iterator checks
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 迭代器检查的哨兵桶ID，如果桶号为该值不需要检查
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 迭代器相关，在扩容进行中迭代器用于检查的桶号
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">noCheck</span> <span class="p">=</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="mi">8</span><span class="o">*</span><span class="nx">goarch</span><span class="p">.</span><span class="nx">PtrSize</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>	
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="type-maptype-struct">type maptype struct<a hidden class="anchor" aria-hidden="true" href="#type-maptype-struct">#</a></h3>
<ol>
<li>map 元类型，<code>runtime/type.go</code>。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">maptype</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">typ</span>    <span class="nx">_type</span>        <span class="c1">// map类型
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">key</span>    <span class="o">*</span><span class="nx">_type</span>       <span class="c1">// key类型
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">elem</span>   <span class="o">*</span><span class="nx">_type</span>       <span class="c1">// elem类型
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    
</span></span><span class="line"><span class="cl">    <span class="c1">// 桶的类型，桶包含tophashs、keys、elems、overflow这四块
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 由于key/elem是不确定的类型，所以bucket也是不同的类型
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// bucket是否包含指针类型，是取决于该结构中是否存在指针
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//	1. tophashs 是非指针
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//  2. keys、elems 是根据具体情况的
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//  3. overflow 是个指针，那么是否意味则bucket是否包含指针类型?
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 其实bucket是否包含指针类型是根据keys、elems决定的，原因是overflow是用户操作不到的
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 因此处理这个特殊情况时，采用了非指针形式采用mapextra结构保存溢出桶数据，以便不被GC回收
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">bucket</span> <span class="o">*</span><span class="nx">_type</span> <span class="c1">// internal type representing a hash bucket
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// function for hashing keys (ptr to key, seed) -&gt; hash
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// hash函数，用于(key, h.hash0)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">hasher</span>     <span class="kd">func</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">,</span> <span class="kt">uintptr</span><span class="p">)</span> <span class="kt">uintptr</span>	
</span></span><span class="line"><span class="cl">    <span class="c1">// size of key slot
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">keysize</span>    <span class="kt">uint8</span>  <span class="c1">// key值大小
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// size of elem slot
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">elemsize</span>   <span class="kt">uint8</span>  <span class="c1">// value值大小
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// size of bucket
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">bucketsize</span> <span class="kt">uint16</span> <span class="c1">// 桶大小
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">flags</span>      <span class="kt">uint32</span> <span class="c1">// map的标志位
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="indirectkey">indirectkey()<a hidden class="anchor" aria-hidden="true" href="#indirectkey">#</a></h4>
<ol>
<li>当 key 大于128B时key存的是它的指针，key 是否是<strong>间接存储</strong>的。采用这种间接存储是为了满足GC的位图。</li>
<li>一个桶最多支持 <code>bucketSize*(1+maxKeySize+maxValSize)+ptrSize</code> 字节，即2064字节，或258个指针大小的字，或33字节的指针位图。</li>
<li>因为键和值都小于128字节，所以可以保证它们有位图而不是GC程序。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// Note: flag values must match those used in the TMAP case
</span></span></span><span class="line"><span class="cl"><span class="c1">// in ../cmd/compile/internal/reflectdata/reflect.go:writeType.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">mt</span> <span class="o">*</span><span class="nx">maptype</span><span class="p">)</span> <span class="nf">indirectkey</span><span class="p">()</span> <span class="kt">bool</span> <span class="p">{</span> <span class="c1">// store ptr to key instead of key itself
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// flags = 1：key占用内存大于 128B
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">return</span> <span class="nx">mt</span><span class="p">.</span><span class="nx">flags</span><span class="o">&amp;</span><span class="mi">1</span> <span class="o">!=</span> <span class="mi">0</span>	
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="indirectelem">indirectelem()<a hidden class="anchor" aria-hidden="true" href="#indirectelem">#</a></h4>
<ol>
<li>当elem大于128B时key存的是它的指针，elem是否是<strong>间接存储</strong>的。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">mt</span> <span class="o">*</span><span class="nx">maptype</span><span class="p">)</span> <span class="nf">indirectelem</span><span class="p">()</span> <span class="kt">bool</span> <span class="p">{</span> <span class="c1">// store ptr to elem instead of elem itself
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// flags = 2：elem占用内存大于 128B
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">return</span> <span class="nx">mt</span><span class="p">.</span><span class="nx">flags</span><span class="o">&amp;</span><span class="mi">2</span> <span class="o">!=</span> <span class="mi">0</span>	
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="reflexivekey">reflexivekey()<a hidden class="anchor" aria-hidden="true" href="#reflexivekey">#</a></h4>
<ol>
<li><strong>map key是NaN时</strong>，判断 key 满足 <strong>x == x</strong> 成立?</li>
<li><strong>x != x</strong> 成立情况：
<ul>
<li>float32、float64、complex64、complex128（当为NaN时）。</li>
<li>any：存储的是 NaN 时。</li>
<li>Array 时判断数组的元素类型。切片不能作为map的key因此排除。</li>
<li>String 时，判断字段类型。</li>
</ul>
</li>
<li>根据 IEEE754 标准，当浮点数的指数位全为1时，该数处于非正常是标准多用于表示正无穷大或负无穷大及NaN，因此其他位可能是不同的数值。</li>
<li>x != x 情况是<strong>会影响</strong>hash，因此NaN的位值不一定全部相等。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">mt</span> <span class="o">*</span><span class="nx">maptype</span><span class="p">)</span> <span class="nf">reflexivekey</span><span class="p">()</span> <span class="kt">bool</span> <span class="p">{</span> <span class="c1">// true if k==k for all keys
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// flags = 4：说明 x == x始终是成立的
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">return</span> <span class="nx">mt</span><span class="p">.</span><span class="nx">flags</span><span class="o">&amp;</span><span class="mi">4</span> <span class="o">!=</span> <span class="mi">0</span>	
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="needkeyupdate">needkeyupdate()<a hidden class="anchor" aria-hidden="true" href="#needkeyupdate">#</a></h4>
<ol>
<li><strong>map key的值需要更新</strong>，这种情况出现在 key == key，但是 key 生成的 hash 可能不相同，这会影响到 tophash 存储值。</li>
<li>需要更新的类型：
<ul>
<li>float32、float64、complex64、complex128（floats and complex can be +0/-0）。
<ul>
<li>浮点数和复数可以是+0/-0，浮点数中这两个数保存的符号位是不同得，但是比较这两个数确实是相等的。</li>
</ul>
</li>
<li>any  由于 any 能存储任何类型，所有可以存储浮点数等因此也需要更新。</li>
<li>string：（strings might have smaller backing stores）
<ul>
<li>字符串可能有较小的后备存储器</li>
</ul>
</li>
<li>Array 类型时判断数组元素，可能是上面类型。</li>
<li>Struct 时判断结构体的元素，可能是上面类型。</li>
</ul>
</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">mt</span> <span class="o">*</span><span class="nx">maptype</span><span class="p">)</span> <span class="nf">needkeyupdate</span><span class="p">()</span> <span class="kt">bool</span> <span class="p">{</span> <span class="c1">// true if we need to update key on an overwrite
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// flags = 8：需要更新slot的key
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">return</span> <span class="nx">mt</span><span class="p">.</span><span class="nx">flags</span><span class="o">&amp;</span><span class="mi">8</span> <span class="o">!=</span> <span class="mi">0</span>	
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="hashmightpanic">hashMightPanic()<a hidden class="anchor" aria-hidden="true" href="#hashmightpanic">#</a></h4>
<ol>
<li><strong><code>key</code> 生成 <code>hash</code> 可能发生 <code>panic</code></strong>，这是由于<code>slice</code>、<code>map</code>、<code>function</code>不能作为<code>map key</code>，而<code>any</code>可以存储任何类型。</li>
<li>存在可能的类型：
<ul>
<li><code>any</code>、<code>slice</code>、<code>map</code>、<code>function</code>; 当<code>any</code>存储的<code>slice</code>或<code>map</code>或<code>function</code>时就会<code>panic</code>。</li>
<li><code>Array</code> 类型时判断数组的元素，该元素时<code>slice</code>或<code>map</code>或包含它们都会<code>panic</code>。<code>Slice</code> 不能作为<code>key</code>。</li>
<li><code>Struct</code> 类型时判断结构体的元素，该元素时<code>slice</code>或<code>map</code>或包含它们都会<code>panic</code>。</li>
<li>但是如果是它们类型的指针则不会发生<code>panic</code>。</li>
</ul>
</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">mt</span> <span class="o">*</span><span class="nx">maptype</span><span class="p">)</span> <span class="nf">hashMightPanic</span><span class="p">()</span> <span class="kt">bool</span> <span class="p">{</span> <span class="c1">// true if hash function might panic
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// flags = 16：key生成hash可能panic的
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">return</span> <span class="nx">mt</span><span class="p">.</span><span class="nx">flags</span><span class="o">&amp;</span><span class="mi">16</span> <span class="o">!=</span> <span class="mi">0</span>	
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="make-">make() 🚀<a hidden class="anchor" aria-hidden="true" href="#make-">#</a></h2>
<ol>
<li>makemap() 实现为 <code>make(map[k]v, hint)</code> 创建 Go map。</li>
<li>如果编译器已经确定可以在栈上创建map或第一个bucket，h and/or bucket 可能是 non-nil。</li>
<li>如果 h != nil，则可以直接在h中创建map。</li>
<li>如果 h.buckets != nil，则指向的桶可以用作第一个桶。</li>
<li>参数：
<ul>
<li><strong><code>t *maptype</code></strong>：map 的元类型。</li>
<li><strong><code>hint int</code></strong>：<code>key/elem</code>对的数量，<strong>不是桶的数量</strong>。hint能保证一定能存储key/elem对数据而不扩容。</li>
<li><strong><code>h *hmap</code></strong>：map 指针，可能是 nil 或 non-nil。</li>
</ul>
</li>
<li>返回值：
<ul>
<li><code>*hmap</code>：生成的 map 的值，也就是 <code>*hmap</code>。</li>
</ul>
</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// makemap implements Go map creation for make(map[k]v, hint).
</span></span></span><span class="line"><span class="cl"><span class="c1">// If the compiler has determined that the map or the first bucket
</span></span></span><span class="line"><span class="cl"><span class="c1">// can be created on the stack, h and/or bucket may be non-nil.
</span></span></span><span class="line"><span class="cl"><span class="c1">// If h != nil, the map can be created directly in h.
</span></span></span><span class="line"><span class="cl"><span class="c1">// If h.buckets != nil, bucket pointed to can be used as the first bucket.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">makemap</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">maptype</span><span class="p">,</span> <span class="nx">hint</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">h</span> <span class="o">*</span><span class="nx">hmap</span><span class="p">)</span> <span class="o">*</span><span class="nx">hmap</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// MulUintptr 返回 a * b 以及乘法是否溢出
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//      mem = uintptr(hint) * t.bucket.size
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 这里使用 key/elem 对乘上 桶大小 显示是在扩大计算内存，因为 hint 一定是大于 桶的数量的
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">mem</span><span class="p">,</span> <span class="nx">overflow</span> <span class="o">:=</span> <span class="nx">math</span><span class="p">.</span><span class="nf">MulUintptr</span><span class="p">(</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">hint</span><span class="p">),</span> <span class="nx">t</span><span class="p">.</span><span class="nx">bucket</span><span class="p">.</span><span class="nx">size</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">overflow</span> <span class="o">||</span> <span class="nx">mem</span> <span class="p">&gt;</span> <span class="nx">maxAlloc</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">hint</span> <span class="p">=</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// initialize Hmap
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nx">h</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 初始化 hmap
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 注意这里使用了new函数创建的
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">h</span> <span class="p">=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">hmap</span><span class="p">)</span>	
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 生成一个随机数用于后续key的hash，该值在桶每次清空时该值会从新生成随机值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">h</span><span class="p">.</span><span class="nx">hash0</span> <span class="p">=</span> <span class="nf">fastrand</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// Find the size parameter B which will hold the requested # of elements.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// For hint &lt; 0 overLoadFactor returns false since hint &lt; bucketCnt.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 找到参数B的大小，它将保存请求的元素
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 对于 hint &lt; 0 overLoadFactor 返回 false，因为 hint &lt; bucketCnt。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">B</span> <span class="o">:=</span> <span class="nb">uint8</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 计算保存hint个key/elem对不扩容最小需要的B的数量
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">for</span> <span class="nf">overLoadFactor</span><span class="p">(</span><span class="nx">hint</span><span class="p">,</span> <span class="nx">B</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">B</span><span class="o">++</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nx">h</span><span class="p">.</span><span class="nx">B</span> <span class="p">=</span> <span class="nx">B</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// allocate initial hash table
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// if B == 0, the buckets field is allocated lazily later (in mapassign)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// If hint is large zeroing this memory could take a while.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 分配初始hash表，如果B == 0，则稍后(在mapassign中，也就是存储数据过程中)延迟分配buckets字段，
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 如果hint很大，则清空该内存可能需要一段时间。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nx">h</span><span class="p">.</span><span class="nx">B</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="kd">var</span> <span class="nx">nextOverflow</span> <span class="o">*</span><span class="nx">bmap</span>  <span class="c1">// 用于记录 makeBucketArray 是否分配了溢出桶
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// makeBucketArray 根据B分配常规桶和溢出桶，如果分配了溢出桶则将最后一个溢出桶地址指向第一个常规桶地址
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 溢出桶分配规则 B &gt;= 4 分配最少 B-4 个溢出桶备用，溢出桶数量 &gt;= 1 &lt;&lt; (B-4)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">h</span><span class="p">.</span><span class="nx">buckets</span><span class="p">,</span> <span class="nx">nextOverflow</span> <span class="p">=</span> <span class="nf">makeBucketArray</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">h</span><span class="p">.</span><span class="nx">B</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="nx">nextOverflow</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nx">h</span><span class="p">.</span><span class="nx">extra</span> <span class="p">=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">mapextra</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 记录下一个可使用的溢出桶
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="nx">h</span><span class="p">.</span><span class="nx">extra</span><span class="p">.</span><span class="nx">nextOverflow</span> <span class="p">=</span> <span class="nx">nextOverflow</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nx">h</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="overloadfactor">overLoadFactor()<a hidden class="anchor" aria-hidden="true" href="#overloadfactor">#</a></h3>
<ol>
<li>overLoadFactor 报告放置在 1&laquo;B 桶中的项目数量是否超过 loadFactor。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// overLoadFactor reports whether count items placed in 1&lt;&lt;B buckets is over loadFactor.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">overLoadFactor</span><span class="p">(</span><span class="nx">count</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">B</span> <span class="kt">uint8</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// const (
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//  bucketCnt = 8
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//  loadFactorNum = 13
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//  loadFactorDen = 2
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// )
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// bucketShift(B) == 1 &lt;&lt; B
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// uintptr(count)/bucketShift(B) &lt; loadFactorNum/loadFactorDen
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// return count &gt; 8 &amp;&amp; count &gt; 6.5 * (1 &lt;&lt; B)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">return</span> <span class="nx">count</span> <span class="p">&gt;</span> <span class="nx">bucketCnt</span> <span class="o">&amp;&amp;</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">count</span><span class="p">)</span> <span class="p">&gt;</span> <span class="nx">loadFactorNum</span><span class="o">*</span><span class="p">(</span><span class="nf">bucketShift</span><span class="p">(</span><span class="nx">B</span><span class="p">)</span><span class="o">/</span><span class="nx">loadFactorDen</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="bucketshift">bucketShift()<a hidden class="anchor" aria-hidden="true" href="#bucketshift">#</a></h3>
<ol>
<li>bucketShift 返回 <code>1&lt;&lt;b</code>，为代码生成做了优化。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// bucketShift returns 1&lt;&lt;b, optimized for code generation.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">bucketShift</span><span class="p">(</span><span class="nx">b</span> <span class="kt">uint8</span><span class="p">)</span> <span class="kt">uintptr</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Masking the shift amount allows overflow checks to be elided.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 屏蔽移位量可以省略溢出检查。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// goarch.PtrSize 64位下为8，32位下为4; goarch.PtrSize*8 - 1 掩码为了防止溢出
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">return</span> <span class="nb">uintptr</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="nx">b</span> <span class="o">&amp;</span> <span class="p">(</span><span class="nx">goarch</span><span class="p">.</span><span class="nx">PtrSize</span><span class="o">*</span><span class="mi">8</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>   <span class="c1">// 1 &lt;&lt; b
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="makebucketarray">makeBucketArray()<a hidden class="anchor" aria-hidden="true" href="#makebucketarray">#</a></h3>
<ol>
<li><code>makeBucketArray()</code> 为 <code>map</code> 桶初始化一个后备数组。</li>
<li><code>1&lt;&lt;b</code>是要分配的最小桶数。</li>
<li><code>dirtyalloc</code>要么是<code>nil</code>，要么是<code>makeBucketArray</code>之前分配的具有相同<code>t</code>和<code>b</code>参数的桶数组。</li>
<li>如果<code>dirtyalloc</code>为<code>nil</code>，将分配一个新的后备数组，否则将清除<code>dirtyalloc</code>并作为后备数组重用。</li>
<li>参数：
<ul>
<li><code>t *maptype</code>：<code>map</code>的类型结构。</li>
<li><code>b uint8</code>：<code>h.B</code>的值。</li>
<li><code>dirtyalloc unsafe.Pointer</code>：<code>nil</code>时重新申请块内存，不是<code>nil</code>时，继续使用<code>dirtyalloc </code>指向的内存地址。</li>
</ul>
</li>
<li>返回值：
<ul>
<li><code>buckets unsafe.Pointer</code>：分配的常规桶首地址。</li>
<li><code>nextOverflow *bmap</code>：分配的溢出桶首地址。</li>
</ul>
</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// makeBucketArray initializes a backing array for map buckets.
</span></span></span><span class="line"><span class="cl"><span class="c1">// 1&lt;&lt;b is the minimum number of buckets to allocate.
</span></span></span><span class="line"><span class="cl"><span class="c1">// dirtyalloc should either be nil or a bucket array previously
</span></span></span><span class="line"><span class="cl"><span class="c1">// allocated by makeBucketArray with the same t and b parameters.
</span></span></span><span class="line"><span class="cl"><span class="c1">// If dirtyalloc is nil a new backing array will be alloced and
</span></span></span><span class="line"><span class="cl"><span class="c1">// otherwise dirtyalloc will be cleared and reused as backing array.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">makeBucketArray</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">maptype</span><span class="p">,</span> <span class="nx">b</span> <span class="kt">uint8</span><span class="p">,</span> <span class="nx">dirtyalloc</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">)</span> <span class="p">(</span><span class="nx">buckets</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">,</span> <span class="nx">nextOverflow</span> <span class="o">*</span><span class="nx">bmap</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// base := 1 &lt;&lt; b
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">base</span> <span class="o">:=</span> <span class="nf">bucketShift</span><span class="p">(</span><span class="nx">b</span><span class="p">)</span> <span class="c1">// 常规桶数量 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">nbuckets</span> <span class="o">:=</span> <span class="nx">base</span> <span class="c1">// 存储(常规桶 + 溢出桶)的总数量
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// For small b, overflow buckets are unlikely.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// Avoid the overhead of the calculation.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 对于小值b来说，溢出桶不太可能出现。避免计算的开销。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 溢出桶分配规则 B &gt;= 4 分配最少 B-4 个溢出桶备用。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nx">b</span> <span class="o">&gt;=</span> <span class="mi">4</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// Add on the estimated number of overflow buckets
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// required to insert the median number of elements
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// used with this value of b.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 再加上用该值b插入元素的中位数所需的溢出桶的估计数量。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// nbuckets += 1 &lt;&lt; (b - 4)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">nbuckets</span> <span class="o">+=</span> <span class="nf">bucketShift</span><span class="p">(</span><span class="nx">b</span> <span class="o">-</span> <span class="mi">4</span><span class="p">)</span> <span class="c1">// 常规桶 + 溢出桶
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">sz</span> <span class="o">:=</span> <span class="nx">t</span><span class="p">.</span><span class="nx">bucket</span><span class="p">.</span><span class="nx">size</span> <span class="o">*</span> <span class="nx">nbuckets</span> <span class="c1">// 计算全部桶(常规桶 + 溢出桶)所需内存大小
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">up</span> <span class="o">:=</span> <span class="nf">roundupsize</span><span class="p">(</span><span class="nx">sz</span><span class="p">)</span> <span class="c1">// 匹配最接近sz的内存大小规格
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="nx">up</span> <span class="o">!=</span> <span class="nx">sz</span> <span class="p">{</span> <span class="c1">// 匹配的内存规格偏大	
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// 调整 nbuckets 数量，这里应该是偏大设置
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// 因为不能能匹配后出现偏小的情况
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="nx">nbuckets</span> <span class="p">=</span> <span class="nx">up</span> <span class="o">/</span> <span class="nx">t</span><span class="p">.</span><span class="nx">bucket</span><span class="p">.</span><span class="nx">size</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">dirtyalloc</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 没有可重新利用的内存块，重新向内存管理系统申请内存
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// buckets 申请的桶首地址 包含常规桶和溢出桶，因此常规桶和溢出桶是一整块连续的内存
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">buckets</span> <span class="p">=</span> <span class="nf">newarray</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">bucket</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="nx">nbuckets</span><span class="p">))</span>	
</span></span><span class="line"><span class="cl">    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// dirtyalloc was previously generated by
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// the above newarray(t.bucket, int(nbuckets))
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// but may not be empty.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// dirtyalloc是由上述 newarray(t.bucket, int(nbuckets)) 生成的，但不能为空。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">buckets</span> <span class="p">=</span> <span class="nx">dirtyalloc</span> <span class="c1">// 桶内存块地址
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">size</span> <span class="o">:=</span> <span class="nx">t</span><span class="p">.</span><span class="nx">bucket</span><span class="p">.</span><span class="nx">size</span> <span class="o">*</span> <span class="nx">nbuckets</span> <span class="c1">// 内存块大小
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="nx">t</span><span class="p">.</span><span class="nx">bucket</span><span class="p">.</span><span class="nx">ptrdata</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 当前桶中存在指针数据时
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// 重置从buckets地址开始长度为size大小的内存
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="nf">memclrHasPointers</span><span class="p">(</span><span class="nx">buckets</span><span class="p">,</span> <span class="nx">size</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 当前桶中不存在指针数据时
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// 重置从buckets地址开始长度为size大小的内存
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="nf">memclrNoHeapPointers</span><span class="p">(</span><span class="nx">buckets</span><span class="p">,</span> <span class="nx">size</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 分配了溢出桶
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nx">base</span> <span class="o">!=</span> <span class="nx">nbuckets</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// We preallocated some overflow buckets.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// To keep the overhead of tracking these overflow buckets to a minimum,
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// we use the convention that if a preallocated overflow bucket&#39;s overflow
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// pointer is nil, then there are more available by bumping the pointer.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// We need a safe non-nil pointer for the last overflow bucket; just use buckets.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 我们预先分配了一些溢出桶。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 为了将跟踪这些溢出桶的开销降到最低，我们使用约定:如果预分配的溢出桶的overflow指针为nil，则通过碰撞指针来提供更多可用的内存。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 我们需要为最后一个溢出桶提供一个安全的 non-nil 指针; 就用常规桶吧。用于在分配溢出桶时判断溢出桶以分配完
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">nextOverflow</span> <span class="p">=</span> <span class="p">(</span><span class="o">*</span><span class="nx">bmap</span><span class="p">)(</span><span class="nf">add</span><span class="p">(</span><span class="nx">buckets</span><span class="p">,</span> <span class="nx">base</span><span class="o">*</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">bucketsize</span><span class="p">)))</span> <span class="c1">// 首个溢出桶 *bmap
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">last</span> <span class="o">:=</span> <span class="p">(</span><span class="o">*</span><span class="nx">bmap</span><span class="p">)(</span><span class="nf">add</span><span class="p">(</span><span class="nx">buckets</span><span class="p">,</span> <span class="p">(</span><span class="nx">nbuckets</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">bucketsize</span><span class="p">)))</span><span class="c1">// 最后一个溢出桶 *bmap
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 之所以将最后一个溢出桶overflow指向第一个常规桶地址是用于分配溢出桶是判断是否分配完参看(*hmap).newoverflow()方法
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">last</span><span class="p">.</span><span class="nf">setoverflow</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="p">(</span><span class="o">*</span><span class="nx">bmap</span><span class="p">)(</span><span class="nx">buckets</span><span class="p">))</span>   <span class="c1">// 最后一个溢出桶指针指向首个常规桶
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nx">buckets</span><span class="p">,</span> <span class="nx">nextOverflow</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><img loading="lazy" src="../images/map-003.png" alt=""  />
</p>
<h3 id="newarray">newarray()<a hidden class="anchor" aria-hidden="true" href="#newarray">#</a></h3>
<ol>
<li><code>newarray()</code> 分配一个包含 n 个类型为 typ 的元素的数组。</li>
<li>参数：
<ul>
<li><code>typ *_type</code>：桶的类型结构。</li>
<li><code>n int</code>：桶的个数（常规桶 + 溢出桶）总数。</li>
</ul>
</li>
<li>返回值：
<ul>
<li><code>unsafe.Pointer</code>：申请到的内存首地址。</li>
</ul>
</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// newarray allocates an array of n elements of type typ.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">newarray</span><span class="p">(</span><span class="nx">typ</span> <span class="o">*</span><span class="nx">_type</span><span class="p">,</span> <span class="nx">n</span> <span class="kt">int</span><span class="p">)</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">n</span> <span class="o">==</span> <span class="mi">1</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 只有一个桶，直接申请
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">return</span> <span class="nf">mallocgc</span><span class="p">(</span><span class="nx">typ</span><span class="p">.</span><span class="nx">size</span><span class="p">,</span> <span class="nx">typ</span><span class="p">,</span> <span class="kc">true</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 溢出判断，typ.size * uintptr(n) 为桶总共占用的内存
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">mem</span><span class="p">,</span> <span class="nx">overflow</span> <span class="o">:=</span> <span class="nx">math</span><span class="p">.</span><span class="nf">MulUintptr</span><span class="p">(</span><span class="nx">typ</span><span class="p">.</span><span class="nx">size</span><span class="p">,</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">n</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">overflow</span> <span class="o">||</span> <span class="nx">mem</span> <span class="p">&gt;</span> <span class="nx">maxAlloc</span> <span class="o">||</span> <span class="nx">n</span> <span class="p">&lt;</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nb">panic</span><span class="p">(</span><span class="nf">plainError</span><span class="p">(</span><span class="s">&#34;runtime: allocation size out of range&#34;</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nf">mallocgc</span><span class="p">(</span><span class="nx">mem</span><span class="p">,</span> <span class="nx">typ</span><span class="p">,</span> <span class="kc">true</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="makemap_small">makemap_small()<a hidden class="anchor" aria-hidden="true" href="#makemap_small">#</a></h3>
<ol>
<li><code>makemap_small()</code> 实现了 <code>make(map[k]v)</code> 和 <code>make(map[k]v, hint)</code> 的<code>Go map</code>创建。</li>
<li>当<code>hint(&lt;= 8)</code>在编译时已知最多为 <code>bucketCnt</code> (8)，并且需要在堆上分配<code>map</code>时。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// makemap_small implements Go map creation for make(map[k]v) and
</span></span></span><span class="line"><span class="cl"><span class="c1">// make(map[k]v, hint) when hint is known to be at most bucketCnt
</span></span></span><span class="line"><span class="cl"><span class="c1">// at compile time and the map needs to be allocated on the heap.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">makemap_small</span><span class="p">()</span> <span class="o">*</span><span class="nx">hmap</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 当 hint &lt;= 8 时
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 初始化 map
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">h</span> <span class="o">:=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">hmap</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nx">h</span><span class="p">.</span><span class="nx">hash0</span> <span class="p">=</span> <span class="nf">fastrand</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nx">h</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="map-get-">map Get 🚀<a hidden class="anchor" aria-hidden="true" href="#map-get-">#</a></h2>
<ol>
<li>获取 map 中指定 key 的值</li>
</ol>
<h3 id="v--hkey">v := h[key]<a hidden class="anchor" aria-hidden="true" href="#v--hkey">#</a></h3>
<h4 id="mapaccess1_fat">mapaccess1_fat()<a hidden class="anchor" aria-hidden="true" href="#mapaccess1_fat">#</a></h4>
<ol>
<li>可以指定默认值 <code>zero</code>，当分0内存是返回<code>zero</code>值。</li>
<li>该函数返回一个地址，地址指向的值就是要取得<code>v</code>值。</li>
<li>参数：
<ul>
<li><code>t *maptype</code>：<code>map</code>的类型结构。</li>
<li><code>h *hmap</code>：<code>map</code>的内存结构。</li>
<li><code>key unsafe.Pointer</code>：<code>key</code>的地址。</li>
<li><code>zero unsafe.Pointer</code>：零值地址，用于返回值。</li>
</ul>
</li>
<li>返回值：
<ul>
<li><code>unsafe.Pointer</code>：获取到的<code>elem</code>地址。</li>
</ul>
</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">mapaccess1_fat</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">maptype</span><span class="p">,</span> <span class="nx">h</span> <span class="o">*</span><span class="nx">hmap</span><span class="p">,</span> <span class="nx">key</span><span class="p">,</span> <span class="nx">zero</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">)</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">e</span> <span class="o">:=</span> <span class="nf">mapaccess1</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">h</span><span class="p">,</span> <span class="nx">key</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">e</span> <span class="o">==</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">zeroVal</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="nx">zero</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nx">e</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="mapaccess1">mapaccess1()<a hidden class="anchor" aria-hidden="true" href="#mapaccess1">#</a></h4>
<ol>
<li><code>mapaccess1()</code> 返回一个指向<code>h[key]</code>的指针。</li>
<li>永远不要返回nil，相反，如果<code>key</code>不在<code>map</code>中，它会返回一个指向<code>elem</code>类型的<code>zero</code>对象的引用。
<ul>
<li><code>zero</code>对象就是全局变量<code>&amp;zeroVal[0]</code>地址值。</li>
</ul>
</li>
<li>注意：返回的指针可能会使整个<code>map</code>保持活动状态，所以不要占用它太长时间。</li>
<li>go map 是<strong>不支持</strong>多线程的写，但是多线程的读是没有问题的。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// mapaccess1 returns a pointer to h[key].  Never returns nil, instead
</span></span></span><span class="line"><span class="cl"><span class="c1">// it will return a reference to the zero object for the elem type if
</span></span></span><span class="line"><span class="cl"><span class="c1">// the key is not in the map.
</span></span></span><span class="line"><span class="cl"><span class="c1">// NOTE: The returned pointer may keep the whole map live, so don&#39;t
</span></span></span><span class="line"><span class="cl"><span class="c1">// hold onto it for very long.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">mapaccess1</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">maptype</span><span class="p">,</span> <span class="nx">h</span> <span class="o">*</span><span class="nx">hmap</span><span class="p">,</span> <span class="nx">key</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">)</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">raceenabled</span> <span class="o">&amp;&amp;</span> <span class="nx">h</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">callerpc</span> <span class="o">:=</span> <span class="nf">getcallerpc</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">        <span class="nx">pc</span> <span class="o">:=</span> <span class="nx">abi</span><span class="p">.</span><span class="nf">FuncPCABIInternal</span><span class="p">(</span><span class="nx">mapaccess1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="nf">racereadpc</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">h</span><span class="p">),</span> <span class="nx">callerpc</span><span class="p">,</span> <span class="nx">pc</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="nf">raceReadObjectPC</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">key</span><span class="p">,</span> <span class="nx">key</span><span class="p">,</span> <span class="nx">callerpc</span><span class="p">,</span> <span class="nx">pc</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">msanenabled</span> <span class="o">&amp;&amp;</span> <span class="nx">h</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">msanread</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="nx">t</span><span class="p">.</span><span class="nx">key</span><span class="p">.</span><span class="nx">size</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">asanenabled</span> <span class="o">&amp;&amp;</span> <span class="nx">h</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">asanread</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="nx">t</span><span class="p">.</span><span class="nx">key</span><span class="p">.</span><span class="nx">size</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c1">// 1) map未初始化 或 没有key/elem对
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nx">h</span> <span class="o">==</span> <span class="kc">nil</span> <span class="o">||</span> <span class="nx">h</span><span class="p">.</span><span class="nx">count</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 当key为any类型时，在key经过hash时可能会发生panic
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// t.hashMightPanic()判断当前hash函数是否可能发生panic
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 这是因为 any 存储的值可能不适合作为 map 的 key
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="nx">t</span><span class="p">.</span><span class="nf">hashMightPanic</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 尝试hash panic
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="nx">t</span><span class="p">.</span><span class="nf">hasher</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="c1">// see issue 23734
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 直接返回 &amp;zeroVal[0]，返回默认值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">return</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">zeroVal</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c1">// 2) 当前map存在其他goroutine正在写操作，直接报错不支持并发
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// hashWriting 标志在写map或delete map时被设置
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nx">h</span><span class="p">.</span><span class="nx">flags</span><span class="o">&amp;</span><span class="nx">hashWriting</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">fatal</span><span class="p">(</span><span class="s">&#34;concurrent map read and map write&#34;</span><span class="p">)</span>  <span class="c1">// 并发的map读写操作
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c1">// 3) key根据h.hash0生成hash值，根据上面key为any时这里hash可能会panic
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">hash</span> <span class="o">:=</span> <span class="nx">t</span><span class="p">.</span><span class="nf">hasher</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">h</span><span class="p">.</span><span class="nx">hash0</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">    <span class="nx">m</span> <span class="o">:=</span> <span class="nf">bucketMask</span><span class="p">(</span><span class="nx">h</span><span class="p">.</span><span class="nx">B</span><span class="p">)</span> <span class="c1">// map常规桶数量; m = (1 &lt;&lt; B) - 1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 4) 偏移到当前key对应的常规桶处 *bmap
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">b</span> <span class="o">:=</span> <span class="p">(</span><span class="o">*</span><span class="nx">bmap</span><span class="p">)(</span><span class="nf">add</span><span class="p">(</span><span class="nx">h</span><span class="p">.</span><span class="nx">buckets</span><span class="p">,</span> <span class="p">(</span><span class="nx">hash</span><span class="o">&amp;</span><span class="nx">m</span><span class="p">)</span><span class="o">*</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">bucketsize</span><span class="p">)))</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 5) c != nil 当前map正在扩容中，需要判断当前旧桶数据是否迁移，没迁移数据还在旧桶中
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nx">c</span> <span class="o">:=</span> <span class="nx">h</span><span class="p">.</span><span class="nx">oldbuckets</span><span class="p">;</span> <span class="nx">c</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// !h.sameSizeGrow() == true; 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 翻倍扩容时
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="p">!</span><span class="nx">h</span><span class="p">.</span><span class="nf">sameSizeGrow</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// There used to be half as many buckets; mask down one more power of two.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// 过去桶的数量只有现在的一半;再除一个2的倍数。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="nx">m</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span> <span class="c1">// 需要把m缩小两倍
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="nx">oldb</span> <span class="o">:=</span> <span class="p">(</span><span class="o">*</span><span class="nx">bmap</span><span class="p">)(</span><span class="nf">add</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="p">(</span><span class="nx">hash</span><span class="o">&amp;</span><span class="nx">m</span><span class="p">)</span><span class="o">*</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">bucketsize</span><span class="p">)))</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 判断旧桶是否已经迁移了，没有迁移则从旧桶里面取数据
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 不是2|3|4时表示数据还在旧桶里面，tophash[0] NOT IN (2,3,4)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="p">!</span><span class="nf">evacuated</span><span class="p">(</span><span class="nx">oldb</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nx">b</span> <span class="p">=</span> <span class="nx">oldb</span>    <span class="c1">// 替换为旧桶 *bmap
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c1">// 6) top 是 hash 的高八位值，用于快速比对 key
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// hash &gt;&gt; (8*8 - 8)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">top</span> <span class="o">:=</span> <span class="nf">tophash</span><span class="p">(</span><span class="nx">hash</span><span class="p">)</span> <span class="c1">// uint8
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">bucketloop</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 7) 遍历当前桶以及后面的溢出桶
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">for</span> <span class="p">;</span> <span class="nx">b</span> <span class="o">!=</span> <span class="kc">nil</span><span class="p">;</span> <span class="nx">b</span> <span class="p">=</span> <span class="nx">b</span><span class="p">.</span><span class="nf">overflow</span><span class="p">(</span><span class="nx">t</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 遍历当前桶; bucketCnt = 8
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">bucketCnt</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 7.1) 当前 tophash 不相等
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="k">if</span> <span class="nx">b</span><span class="p">.</span><span class="nx">tophash</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">!=</span> <span class="nx">top</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="c1">// const emptyRest = 0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="c1">// 当前桶包括溢出桶后面没有数据了
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="k">if</span> <span class="nx">b</span><span class="p">.</span><span class="nx">tophash</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">==</span> <span class="nx">emptyRest</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                    <span class="k">break</span> <span class="nx">bucketloop</span>    <span class="c1">// 结束遍历
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="p">}</span>
</span></span><span class="line"><span class="cl">                <span class="k">continue</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">            
</span></span><span class="line"><span class="cl">            <span class="c1">// 7.2) b.tophash[i] == top; 并不代表一定找到key，可能出现tophash冲突情况
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="nx">k</span> <span class="o">:=</span> <span class="nf">add</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">b</span><span class="p">),</span> <span class="nx">dataOffset</span><span class="o">+</span><span class="nx">i</span><span class="o">*</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">keysize</span><span class="p">))</span> <span class="c1">// 找到当前key的地址
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// key的数据是间接存储的，关于常量maxKeySize的相关情况
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="k">if</span> <span class="nx">t</span><span class="p">.</span><span class="nf">indirectkey</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="nx">k</span> <span class="p">=</span> <span class="o">*</span><span class="p">((</span><span class="o">*</span><span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">)(</span><span class="nx">k</span><span class="p">))</span> <span class="c1">// 拿到key地址
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 7.3) 调用key的比较函数，比较key和k是否相等。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// 这里也是key必须是可比较类型的原因
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// 不可比较的类型：
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">//  1. map，以及包含map的结构
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">//  2. slice，以及包含slice的结构
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// 这里key如果是 NaN 的话比对不通过。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="k">if</span> <span class="nx">t</span><span class="p">.</span><span class="nx">key</span><span class="p">.</span><span class="nf">equal</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="nx">k</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="c1">// 比对成功。偏移到elem元素地址处
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="nx">e</span> <span class="o">:=</span> <span class="nf">add</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">b</span><span class="p">),</span> <span class="nx">dataOffset</span><span class="o">+</span><span class="nx">bucketCnt</span><span class="o">*</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">keysize</span><span class="p">)</span><span class="o">+</span><span class="nx">i</span><span class="o">*</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">elemsize</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">                <span class="c1">// elem的数据是间接存储的，关于常量maxElemSize的相关情况
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="k">if</span> <span class="nx">t</span><span class="p">.</span><span class="nf">indirectelem</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                    <span class="nx">e</span> <span class="p">=</span> <span class="o">*</span><span class="p">((</span><span class="o">*</span><span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">)(</span><span class="nx">e</span><span class="p">))</span> <span class="c1">// 拿到elem地址
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="p">}</span>
</span></span><span class="line"><span class="cl">                <span class="k">return</span> <span class="nx">e</span>    <span class="c1">// 成功返回找到的elem地址指针
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="p">}</span>
</span></span><span class="line"><span class="cl">            
</span></span><span class="line"><span class="cl">            <span class="c1">// 未匹配成功出现tophash【冲突】情况
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// map 中没有 key，返回默认值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">return</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">zeroVal</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="bucketmask">bucketMask()<a hidden class="anchor" aria-hidden="true" href="#bucketmask">#</a></h4>
<ol>
<li>bucketMask 返回<code>1&lt;&lt;b - 1</code>，为代码生成做了优化。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// bucketMask returns 1&lt;&lt;b - 1, optimized for code generation.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">bucketMask</span><span class="p">(</span><span class="nx">b</span> <span class="kt">uint8</span><span class="p">)</span> <span class="kt">uintptr</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nf">bucketShift</span><span class="p">(</span><span class="nx">b</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span> <span class="c1">// (1&lt;&lt;b) - 1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="tophash">tophash()<a hidden class="anchor" aria-hidden="true" href="#tophash">#</a></h4>
<ol>
<li>tophash 计算 hash 的 Tophash 值。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// tophash calculates the tophash value for hash.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">tophash</span><span class="p">(</span><span class="nx">hash</span> <span class="kt">uintptr</span><span class="p">)</span> <span class="kt">uint8</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// hash &gt;&gt; (8*8 - 8)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// hash高八位
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">top</span> <span class="o">:=</span> <span class="nb">uint8</span><span class="p">(</span><span class="nx">hash</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="nx">goarch</span><span class="p">.</span><span class="nx">PtrSize</span><span class="o">*</span><span class="mi">8</span> <span class="o">-</span> <span class="mi">8</span><span class="p">))</span>	
</span></span><span class="line"><span class="cl">    <span class="c1">// top &lt; 5
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nx">top</span> <span class="p">&lt;</span> <span class="nx">minTopHash</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">top</span> <span class="o">+=</span> <span class="nx">minTopHash</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nx">top</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="evacuated-1">evacuated()<a hidden class="anchor" aria-hidden="true" href="#evacuated-1">#</a></h4>
<ol>
<li>桶数据是否已迁移。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">evacuated</span><span class="p">(</span><span class="nx">b</span> <span class="o">*</span><span class="nx">bmap</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">h</span> <span class="o">:=</span> <span class="nx">b</span><span class="p">.</span><span class="nx">tophash</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// b.tophash[0] IN (2,3,4)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">return</span> <span class="nx">h</span> <span class="p">&gt;</span> <span class="nx">emptyOne</span> <span class="o">&amp;&amp;</span> <span class="nx">h</span> <span class="p">&lt;</span> <span class="nx">minTopHash</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="v-b--hkey">v, b := h[key]<a hidden class="anchor" aria-hidden="true" href="#v-b--hkey">#</a></h3>
<h4 id="mapaccess2_fat">mapaccess2_fat()<a hidden class="anchor" aria-hidden="true" href="#mapaccess2_fat">#</a></h4>
<ol>
<li>可以指定默认值 zero。当分0内存是返回 <code>zero</code> 值。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">mapaccess2_fat</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">maptype</span><span class="p">,</span> <span class="nx">h</span> <span class="o">*</span><span class="nx">hmap</span><span class="p">,</span> <span class="nx">key</span><span class="p">,</span> <span class="nx">zero</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">)</span> <span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 没看错，这里依然是调用的 mapaccess1() 函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 因为如果没找到key会返回&amp;zeroVal[0]，根据该值能判断bool。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">e</span> <span class="o">:=</span> <span class="nf">mapaccess1</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">h</span><span class="p">,</span> <span class="nx">key</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">e</span> <span class="o">==</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">zeroVal</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="nx">zero</span><span class="p">,</span> <span class="kc">false</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nx">e</span><span class="p">,</span> <span class="kc">true</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="mapaccess2">mapaccess2()<a hidden class="anchor" aria-hidden="true" href="#mapaccess2">#</a></h4>
<ol>
<li>mapaccess2() 和 mapaccess1() 代码基本一样，只多返回个获取成失败的值。</li>
<li>该函数在反射相关中被调用，正常map这里不会调用该函数。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">mapaccess2</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">maptype</span><span class="p">,</span> <span class="nx">h</span> <span class="o">*</span><span class="nx">hmap</span><span class="p">,</span> <span class="nx">key</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">)</span> <span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">raceenabled</span> <span class="o">&amp;&amp;</span> <span class="nx">h</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">callerpc</span> <span class="o">:=</span> <span class="nf">getcallerpc</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">        <span class="nx">pc</span> <span class="o">:=</span> <span class="nx">abi</span><span class="p">.</span><span class="nf">FuncPCABIInternal</span><span class="p">(</span><span class="nx">mapaccess2</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="nf">racereadpc</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">h</span><span class="p">),</span> <span class="nx">callerpc</span><span class="p">,</span> <span class="nx">pc</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="nf">raceReadObjectPC</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">key</span><span class="p">,</span> <span class="nx">key</span><span class="p">,</span> <span class="nx">callerpc</span><span class="p">,</span> <span class="nx">pc</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">msanenabled</span> <span class="o">&amp;&amp;</span> <span class="nx">h</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">msanread</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="nx">t</span><span class="p">.</span><span class="nx">key</span><span class="p">.</span><span class="nx">size</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">asanenabled</span> <span class="o">&amp;&amp;</span> <span class="nx">h</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">asanread</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="nx">t</span><span class="p">.</span><span class="nx">key</span><span class="p">.</span><span class="nx">size</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">h</span> <span class="o">==</span> <span class="kc">nil</span> <span class="o">||</span> <span class="nx">h</span><span class="p">.</span><span class="nx">count</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="nx">t</span><span class="p">.</span><span class="nf">hashMightPanic</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nx">t</span><span class="p">.</span><span class="nf">hasher</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="c1">// see issue 23734
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">zeroVal</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="kc">false</span> <span class="c1">// 这里获取失败返回 false
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">h</span><span class="p">.</span><span class="nx">flags</span><span class="o">&amp;</span><span class="nx">hashWriting</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">fatal</span><span class="p">(</span><span class="s">&#34;concurrent map read and map write&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nx">hash</span> <span class="o">:=</span> <span class="nx">t</span><span class="p">.</span><span class="nf">hasher</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">h</span><span class="p">.</span><span class="nx">hash0</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">    <span class="nx">m</span> <span class="o">:=</span> <span class="nf">bucketMask</span><span class="p">(</span><span class="nx">h</span><span class="p">.</span><span class="nx">B</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nx">b</span> <span class="o">:=</span> <span class="p">(</span><span class="o">*</span><span class="nx">bmap</span><span class="p">)(</span><span class="nf">add</span><span class="p">(</span><span class="nx">h</span><span class="p">.</span><span class="nx">buckets</span><span class="p">,</span> <span class="p">(</span><span class="nx">hash</span><span class="o">&amp;</span><span class="nx">m</span><span class="p">)</span><span class="o">*</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">bucketsize</span><span class="p">)))</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">c</span> <span class="o">:=</span> <span class="nx">h</span><span class="p">.</span><span class="nx">oldbuckets</span><span class="p">;</span> <span class="nx">c</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">!</span><span class="nx">h</span><span class="p">.</span><span class="nf">sameSizeGrow</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// There used to be half as many buckets; mask down one more power of two.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="nx">m</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="nx">oldb</span> <span class="o">:=</span> <span class="p">(</span><span class="o">*</span><span class="nx">bmap</span><span class="p">)(</span><span class="nf">add</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="p">(</span><span class="nx">hash</span><span class="o">&amp;</span><span class="nx">m</span><span class="p">)</span><span class="o">*</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">bucketsize</span><span class="p">)))</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">!</span><span class="nf">evacuated</span><span class="p">(</span><span class="nx">oldb</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nx">b</span> <span class="p">=</span> <span class="nx">oldb</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nx">top</span> <span class="o">:=</span> <span class="nf">tophash</span><span class="p">(</span><span class="nx">hash</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nx">bucketloop</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">;</span> <span class="nx">b</span> <span class="o">!=</span> <span class="kc">nil</span><span class="p">;</span> <span class="nx">b</span> <span class="p">=</span> <span class="nx">b</span><span class="p">.</span><span class="nf">overflow</span><span class="p">(</span><span class="nx">t</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">bucketCnt</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="nx">b</span><span class="p">.</span><span class="nx">tophash</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">!=</span> <span class="nx">top</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="k">if</span> <span class="nx">b</span><span class="p">.</span><span class="nx">tophash</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">==</span> <span class="nx">emptyRest</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                    <span class="k">break</span> <span class="nx">bucketloop</span>
</span></span><span class="line"><span class="cl">                <span class="p">}</span>
</span></span><span class="line"><span class="cl">                <span class="k">continue</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="nx">k</span> <span class="o">:=</span> <span class="nf">add</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">b</span><span class="p">),</span> <span class="nx">dataOffset</span><span class="o">+</span><span class="nx">i</span><span class="o">*</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">keysize</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="nx">t</span><span class="p">.</span><span class="nf">indirectkey</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="nx">k</span> <span class="p">=</span> <span class="o">*</span><span class="p">((</span><span class="o">*</span><span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">)(</span><span class="nx">k</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="nx">t</span><span class="p">.</span><span class="nx">key</span><span class="p">.</span><span class="nf">equal</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="nx">k</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="nx">e</span> <span class="o">:=</span> <span class="nf">add</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">b</span><span class="p">),</span> <span class="nx">dataOffset</span><span class="o">+</span><span class="nx">bucketCnt</span><span class="o">*</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">keysize</span><span class="p">)</span><span class="o">+</span><span class="nx">i</span><span class="o">*</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">elemsize</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">                <span class="k">if</span> <span class="nx">t</span><span class="p">.</span><span class="nf">indirectelem</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                    <span class="nx">e</span> <span class="p">=</span> <span class="o">*</span><span class="p">((</span><span class="o">*</span><span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">)(</span><span class="nx">e</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">                <span class="p">}</span>
</span></span><span class="line"><span class="cl">                <span class="k">return</span> <span class="nx">e</span><span class="p">,</span> <span class="kc">true</span> <span class="c1">// 这里获取成功返回 true
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">zeroVal</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="kc">false</span> <span class="c1">// 这里获取失败返回 false
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="map-set-">map Set 🚀<a hidden class="anchor" aria-hidden="true" href="#map-set-">#</a></h2>
<h3 id="hk--v">h[k] = v<a hidden class="anchor" aria-hidden="true" href="#hk--v">#</a></h3>
<h4 id="reflect_mapassign">reflect_mapassign()<a hidden class="anchor" aria-hidden="true" href="#reflect_mapassign">#</a></h4>
<ol>
<li><code>key</code>和<code>elem</code>分别代表的是各自的地址。</li>
<li>当 <code>key != key</code> 时，存入的数据<code>for range</code>情况是取不出来的。</li>
<li>参数：
<ul>
<li><code>t *maptype</code>：<code>map</code>类型结构。</li>
<li><code>h *hmap</code>：<code>map</code>内存结构。</li>
<li><code>key unsafe.Pointer</code>：<code>map</code>的<code>key</code>地址。</li>
<li><code>elem unsafe.Pointer</code>：<code>map</code>要写入的<code>v</code>地址。</li>
</ul>
</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">//go:linkname reflect_mapassign reflect.mapassign
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">reflect_mapassign</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">maptype</span><span class="p">,</span> <span class="nx">h</span> <span class="o">*</span><span class="nx">hmap</span><span class="p">,</span> <span class="nx">key</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">,</span> <span class="nx">elem</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 从map中找到elem应该放入插槽的地址
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">p</span> <span class="o">:=</span> <span class="nf">mapassign</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">h</span><span class="p">,</span> <span class="nx">key</span><span class="p">)</span>	
</span></span><span class="line"><span class="cl">    <span class="c1">// 拷贝数据，也就四把&amp;v复制给map插槽
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">typedmemmove</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">elem</span><span class="p">,</span> <span class="nx">p</span><span class="p">,</span> <span class="nx">elem</span><span class="p">)</span>	
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="mapassign">mapassign()<a hidden class="anchor" aria-hidden="true" href="#mapassign">#</a></h4>
<ol>
<li>类似于mapaccess，但如果key在map中不存在，则会为键分配一个位置。</li>
<li>存在两种情况：
<ul>
<li><strong>新增</strong>：可能<code>k</code>是从来没存在<code>map</code>中。</li>
<li><strong>修改</strong>：可能<code>k</code>已经存储在<code>map</code>中。</li>
</ul>
</li>
<li><code>map</code> 是<strong>并发不安全</strong>的。</li>
<li><code>map</code> 必须要经过<code>make()</code>函数初始化才能使用。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span><span class="lnt">113
</span><span class="lnt">114
</span><span class="lnt">115
</span><span class="lnt">116
</span><span class="lnt">117
</span><span class="lnt">118
</span><span class="lnt">119
</span><span class="lnt">120
</span><span class="lnt">121
</span><span class="lnt">122
</span><span class="lnt">123
</span><span class="lnt">124
</span><span class="lnt">125
</span><span class="lnt">126
</span><span class="lnt">127
</span><span class="lnt">128
</span><span class="lnt">129
</span><span class="lnt">130
</span><span class="lnt">131
</span><span class="lnt">132
</span><span class="lnt">133
</span><span class="lnt">134
</span><span class="lnt">135
</span><span class="lnt">136
</span><span class="lnt">137
</span><span class="lnt">138
</span><span class="lnt">139
</span><span class="lnt">140
</span><span class="lnt">141
</span><span class="lnt">142
</span><span class="lnt">143
</span><span class="lnt">144
</span><span class="lnt">145
</span><span class="lnt">146
</span><span class="lnt">147
</span><span class="lnt">148
</span><span class="lnt">149
</span><span class="lnt">150
</span><span class="lnt">151
</span><span class="lnt">152
</span><span class="lnt">153
</span><span class="lnt">154
</span><span class="lnt">155
</span><span class="lnt">156
</span><span class="lnt">157
</span><span class="lnt">158
</span><span class="lnt">159
</span><span class="lnt">160
</span><span class="lnt">161
</span><span class="lnt">162
</span><span class="lnt">163
</span><span class="lnt">164
</span><span class="lnt">165
</span><span class="lnt">166
</span><span class="lnt">167
</span><span class="lnt">168
</span><span class="lnt">169
</span><span class="lnt">170
</span><span class="lnt">171
</span><span class="lnt">172
</span><span class="lnt">173
</span><span class="lnt">174
</span><span class="lnt">175
</span><span class="lnt">176
</span><span class="lnt">177
</span><span class="lnt">178
</span><span class="lnt">179
</span><span class="lnt">180
</span><span class="lnt">181
</span><span class="lnt">182
</span><span class="lnt">183
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// Like mapaccess, but allocates a slot for the key if it is not present in the map.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">mapassign</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">maptype</span><span class="p">,</span> <span class="nx">h</span> <span class="o">*</span><span class="nx">hmap</span><span class="p">,</span> <span class="nx">key</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">)</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 1) 未初始化的map不允许写操作
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 这里就是为什么向nil的map写入数据会panic原因
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nx">h</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nb">panic</span><span class="p">(</span><span class="nf">plainError</span><span class="p">(</span><span class="s">&#34;assignment to entry in nil map&#34;</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">raceenabled</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">callerpc</span> <span class="o">:=</span> <span class="nf">getcallerpc</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">        <span class="nx">pc</span> <span class="o">:=</span> <span class="nx">abi</span><span class="p">.</span><span class="nf">FuncPCABIInternal</span><span class="p">(</span><span class="nx">mapassign</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="nf">racewritepc</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">h</span><span class="p">),</span> <span class="nx">callerpc</span><span class="p">,</span> <span class="nx">pc</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="nf">raceReadObjectPC</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">key</span><span class="p">,</span> <span class="nx">key</span><span class="p">,</span> <span class="nx">callerpc</span><span class="p">,</span> <span class="nx">pc</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">msanenabled</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">msanread</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="nx">t</span><span class="p">.</span><span class="nx">key</span><span class="p">.</span><span class="nx">size</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">asanenabled</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">asanread</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="nx">t</span><span class="p">.</span><span class="nx">key</span><span class="p">.</span><span class="nx">size</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 2) 检查map是否存在并发的写操作，删除也是写操作。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nx">h</span><span class="p">.</span><span class="nx">flags</span><span class="o">&amp;</span><span class="nx">hashWriting</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">fatal</span><span class="p">(</span><span class="s">&#34;concurrent map writes&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 3) key根据h.hash0生成hash值，根据上面key为any时这里hash可能会panic。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">hash</span> <span class="o">:=</span> <span class="nx">t</span><span class="p">.</span><span class="nf">hasher</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">h</span><span class="p">.</span><span class="nx">hash0</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// Set hashWriting after calling t.hasher, since t.hasher may panic,
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// in which case we have not actually done a write.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 在调用t.hasher之后设置hashWriting，因为t.hasher可能会出错，在这种情况下我们实际上并没有写入。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 这里使用 ^= 有点小窍门，因为在并发写的情况下可能存在上面的h.flags&amp;hashWriting != 0检查时被跳过了，
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 所以这个函数最后还需要判断并是否已经发生 ^ 异或 相同得0，不同得1; hashWriting = 4 = 0b100
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 按照正常逻辑 h.flags 的3bit位应该是0，那么0^1=1。在函数的最后 h.flags&amp;hashWriting == 0 判断时 1&amp;1=1。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 异常逻辑 h.flags 的3bit位是1，那么 1^1=0。在函数的最后 h.flags&amp;hashWriting == 0 判断时 0&amp;1=0。因此判断并发发生
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">h</span><span class="p">.</span><span class="nx">flags</span> <span class="p">^=</span> <span class="nx">hashWriting</span>  <span class="c1">// 写状态标记
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 4) 没有分配常规桶，这种情况来自makemap_small()函数，hint&lt;=8 时
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nx">h</span><span class="p">.</span><span class="nx">buckets</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 申请一个常规桶内存块
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">h</span><span class="p">.</span><span class="nx">buckets</span> <span class="p">=</span> <span class="nf">newobject</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">bucket</span><span class="p">)</span> <span class="c1">// newarray(t.bucket, 1)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">again</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 5) 根据 hash 映射到指定桶号
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">bucket</span> <span class="o">:=</span> <span class="nx">hash</span> <span class="o">&amp;</span> <span class="nf">bucketMask</span><span class="p">(</span><span class="nx">h</span><span class="p">.</span><span class="nx">B</span><span class="p">)</span> <span class="c1">// bucket = hash &amp; ((1 &lt;&lt; B) - 1)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 6) 是否正处于扩容中：【等量扩容】 或 【翻倍扩容】
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nx">h</span><span class="p">.</span><span class="nf">growing</span><span class="p">()</span> <span class="p">{</span>    <span class="c1">// h.oldbuckets != nil
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 迁移当前key对应的桶数据到新桶完成部分扩容任务
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 迁移后会把旧桶数据迁移到新桶，因此以下代码处理新桶即可
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// growWork() 函数在delete(map)和map[k]=v时被调用，渐进式迁移数据
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nf">growWork</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">h</span><span class="p">,</span> <span class="nx">bucket</span><span class="p">)</span>	
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c1">// 7) 寻找对应的桶(*bmap)，key对应的桶 *bmap
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">b</span> <span class="o">:=</span> <span class="p">(</span><span class="o">*</span><span class="nx">bmap</span><span class="p">)(</span><span class="nf">add</span><span class="p">(</span><span class="nx">h</span><span class="p">.</span><span class="nx">buckets</span><span class="p">,</span> <span class="nx">bucket</span><span class="o">*</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">bucketsize</span><span class="p">)))</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// top = uint8( hash &amp; (1&gt;&gt;8*8-8) )
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">top</span> <span class="o">:=</span> <span class="nf">tophash</span><span class="p">(</span><span class="nx">hash</span><span class="p">)</span>    <span class="c1">// hash 高八位，用于快速判断 key
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="c1">// inserti 对应key应该放入tophash的slot位置地址
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kd">var</span> <span class="nx">inserti</span> <span class="o">*</span><span class="kt">uint8</span>	
</span></span><span class="line"><span class="cl">    <span class="c1">// insertk 对应key应该放入keys的slot位置地址
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kd">var</span> <span class="nx">insertk</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// elem 对应key应该放入elems的slot位置地址
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kd">var</span> <span class="nx">elem</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span>	
</span></span><span class="line"><span class="cl"><span class="nx">bucketloop</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 8) 遍历常规桶和溢出桶，寻找slot位置
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 被删除的slot会被优先使用来存储数据
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">for</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 8.1) 遍历单个桶; const bucketCnt = 8
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">bucketCnt</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 8.1.1) tophash 比对失败
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="k">if</span> <span class="nx">b</span><span class="p">.</span><span class="nx">tophash</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">!=</span> <span class="nx">top</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="c1">// isEmpty(b.tophash[i]) --&gt; b.tophash[i] &lt;= 1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="c1">// inserti == nil; 寻找到slot后不会再进入这里
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="c1">// 这里也是判断当前可能是新增的情况，当前位可以插入数据如果是新增的话。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="k">if</span> <span class="nf">isEmpty</span><span class="p">(</span><span class="nx">b</span><span class="p">.</span><span class="nx">tophash</span><span class="p">[</span><span class="nx">i</span><span class="p">])</span> <span class="o">&amp;&amp;</span> <span class="nx">inserti</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                    <span class="c1">// 记录当前插槽位置
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                    <span class="nx">inserti</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">b</span><span class="p">.</span><span class="nx">tophash</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">                    <span class="nx">insertk</span> <span class="p">=</span> <span class="nf">add</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">b</span><span class="p">),</span> <span class="nx">dataOffset</span><span class="o">+</span><span class="nx">i</span><span class="o">*</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">keysize</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">                    <span class="nx">elem</span> <span class="p">=</span> <span class="nf">add</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">b</span><span class="p">),</span> <span class="nx">dataOffset</span><span class="o">+</span><span class="nx">bucketCnt</span><span class="o">*</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">keysize</span><span class="p">)</span><span class="o">+</span><span class="nx">i</span><span class="o">*</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">elemsize</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">                <span class="p">}</span>
</span></span><span class="line"><span class="cl">                
</span></span><span class="line"><span class="cl">                <span class="c1">// b.tophash[i] == 0; 后面没有数据了
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="k">if</span> <span class="nx">b</span><span class="p">.</span><span class="nx">tophash</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">==</span> <span class="nx">emptyRest</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                    <span class="k">break</span> <span class="nx">bucketloop</span>
</span></span><span class="line"><span class="cl">                <span class="p">}</span>
</span></span><span class="line"><span class="cl">                
</span></span><span class="line"><span class="cl">                <span class="c1">// b.tophash[i] == 1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="c1">// 后面有数据需要继续遍历判断是否当前key已经存在在map中了
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="k">continue</span>    <span class="c1">// continue的作用就是继续遍历map寻找key
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="p">}</span>
</span></span><span class="line"><span class="cl">            
</span></span><span class="line"><span class="cl">            <span class="c1">// tophash匹配成功
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">//  1. 可能是hash冲突，继续向后寻找
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">//  2. 可能是匹配到了key，则是更新
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            
</span></span><span class="line"><span class="cl">            <span class="c1">// 8.1.2) 当前key的slot地址
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="nx">k</span> <span class="o">:=</span> <span class="nf">add</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">b</span><span class="p">),</span> <span class="nx">dataOffset</span><span class="o">+</span><span class="nx">i</span><span class="o">*</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">keysize</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="nx">t</span><span class="p">.</span><span class="nf">indirectkey</span><span class="p">()</span> <span class="p">{</span>    <span class="c1">// key 间接存储
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="nx">k</span> <span class="p">=</span> <span class="o">*</span><span class="p">((</span><span class="o">*</span><span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">)(</span><span class="nx">k</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 8.1.3) 比较key和k是否相等，不相等说明 tophash冲突了
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// 如果存储的 key 是 NaN 这里比对不通过。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="k">if</span> <span class="p">!</span><span class="nx">t</span><span class="p">.</span><span class="nx">key</span><span class="p">.</span><span class="nf">equal</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="nx">k</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="k">continue</span>    <span class="c1">// key != k 继续向后寻找
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="p">}</span>
</span></span><span class="line"><span class="cl">            
</span></span><span class="line"><span class="cl">            <span class="c1">// key == k; 匹配成功则本次是更新操作
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                
</span></span><span class="line"><span class="cl">            <span class="c1">// already have a mapping for key. Update it.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// 已经有一个key的映射。【更新它】。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// key == key成立，但是可能生成的hash值不同，比如+0和-0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="k">if</span> <span class="nx">t</span><span class="p">.</span><span class="nf">needkeyupdate</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="nf">typedmemmove</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">key</span><span class="p">,</span> <span class="nx">k</span><span class="p">,</span> <span class="nx">key</span><span class="p">)</span> <span class="c1">// 把k更新为key
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 8.1.4) 找到elem地址
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="nx">elem</span> <span class="p">=</span> <span class="nf">add</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">b</span><span class="p">),</span> <span class="nx">dataOffset</span><span class="o">+</span><span class="nx">bucketCnt</span><span class="o">*</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">keysize</span><span class="p">)</span><span class="o">+</span><span class="nx">i</span><span class="o">*</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">elemsize</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">            <span class="k">goto</span> <span class="nx">done</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="nx">ovf</span> <span class="o">:=</span> <span class="nx">b</span><span class="p">.</span><span class="nf">overflow</span><span class="p">(</span><span class="nx">t</span><span class="p">)</span>    <span class="c1">// b后面链接的溢出桶
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 没有溢出桶了
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="nx">ovf</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">break</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="nx">b</span> <span class="p">=</span> <span class="nx">ovf</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c1">// Did not find mapping for key. Allocate new cell &amp; add entry.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 9) 没有找到key的映射。分配新的单元格并添加entry。新增 key/elem 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="c1">// If we hit the max load factor or we have too many overflow buckets,
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// and we&#39;re not already in the middle of growing, start growing.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 10) 如果我们达到了最大负载系数，或者我们有太多溢出桶，而我们还没有达到增长的一半，就开始增长。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// h.growing() -&gt; (h.oldbuckets != nil); 是否正在扩容中
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">!</span><span class="nx">h</span><span class="p">.</span><span class="nf">growing</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="nf">overLoadFactor</span><span class="p">(</span><span class="nx">h</span><span class="p">.</span><span class="nx">count</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="nx">h</span><span class="p">.</span><span class="nx">B</span><span class="p">)</span> <span class="o">||</span> <span class="nf">tooManyOverflowBuckets</span><span class="p">(</span><span class="nx">h</span><span class="p">.</span><span class="nx">noverflow</span><span class="p">,</span> <span class="nx">h</span><span class="p">.</span><span class="nx">B</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">hashGrow</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">h</span><span class="p">)</span>  <span class="c1">// 扩容初始化
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 扩容hash table会使上面的所有操作失效，所以再试一次
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">goto</span> <span class="nx">again</span> <span class="c1">// Growing the table invalidates everything, so try again
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 11) 常规桶和溢出桶(如果存在)都没找到slot，这时候需要分配新的溢出桶
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nx">inserti</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// The current bucket and all the overflow buckets connected to it are full, allocate a new one.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 当前桶和连接到它的所有溢出桶已满，分配一个新的桶。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">newb</span> <span class="o">:=</span> <span class="nx">h</span><span class="p">.</span><span class="nf">newoverflow</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">b</span><span class="p">)</span> <span class="c1">// 分配一个溢出桶 *bmap
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">inserti</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">newb</span><span class="p">.</span><span class="nx">tophash</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">        <span class="nx">insertk</span> <span class="p">=</span> <span class="nf">add</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">newb</span><span class="p">),</span> <span class="nx">dataOffset</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="nx">elem</span> <span class="p">=</span> <span class="nf">add</span><span class="p">(</span><span class="nx">insertk</span><span class="p">,</span> <span class="nx">bucketCnt</span><span class="o">*</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">keysize</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// store new key/elem at insert position
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 12) 将新的键/elem存储在插入位置
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nx">t</span><span class="p">.</span><span class="nf">indirectkey</span><span class="p">()</span> <span class="p">{</span>    <span class="c1">// key 间接存储
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">kmem</span> <span class="o">:=</span> <span class="nf">newobject</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">key</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">)(</span><span class="nx">insertk</span><span class="p">)</span> <span class="p">=</span> <span class="nx">kmem</span>
</span></span><span class="line"><span class="cl">        <span class="nx">insertk</span> <span class="p">=</span> <span class="nx">kmem</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">t</span><span class="p">.</span><span class="nf">indirectelem</span><span class="p">()</span> <span class="p">{</span>   <span class="c1">// elem 间接存储
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">vmem</span> <span class="o">:=</span> <span class="nf">newobject</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">elem</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">)(</span><span class="nx">elem</span><span class="p">)</span> <span class="p">=</span> <span class="nx">vmem</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 由于done后面有 t.indirectelem() 判断所有这里没有 elem = vmem 这行代码
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 13) 拷贝数据
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">typedmemmove</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">key</span><span class="p">,</span> <span class="nx">insertk</span><span class="p">,</span> <span class="nx">key</span><span class="p">)</span> <span class="c1">// 保存key的值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="o">*</span><span class="nx">inserti</span> <span class="p">=</span> <span class="nx">top</span> <span class="c1">// tophash 保存
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">h</span><span class="p">.</span><span class="nx">count</span><span class="o">++</span> <span class="c1">// key/elem 对加一
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="nx">done</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 14) 再次判断是否有其他goroutine正在对map进行写操作
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nx">h</span><span class="p">.</span><span class="nx">flags</span><span class="o">&amp;</span><span class="nx">hashWriting</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">fatal</span><span class="p">(</span><span class="s">&#34;concurrent map writes&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nx">h</span><span class="p">.</span><span class="nx">flags</span> <span class="o">&amp;^=</span> <span class="nx">hashWriting</span> <span class="c1">// 清除hashWriting标志位
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nx">t</span><span class="p">.</span><span class="nf">indirectelem</span><span class="p">()</span> <span class="p">{</span> <span class="c1">// elem 间接存储
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">elem</span> <span class="p">=</span> <span class="o">*</span><span class="p">((</span><span class="o">*</span><span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">)(</span><span class="nx">elem</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nx">elem</span> <span class="c1">// 返回当前slot的地址
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="isempty">isEmpty()<a hidden class="anchor" aria-hidden="true" href="#isempty">#</a></h4>
<ol>
<li><code>isEmpty</code>报告给定的<code>tophash</code>数组项是否表示空桶项。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// isEmpty reports whether the given tophash array entry represents an empty bucket entry.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">isEmpty</span><span class="p">(</span><span class="nx">x</span> <span class="kt">uint8</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nx">x</span> <span class="o">&lt;=</span> <span class="nx">emptyOne</span>    <span class="c1">// x &lt;= 1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="overloadfactor-1">overLoadFactor()<a hidden class="anchor" aria-hidden="true" href="#overloadfactor-1">#</a></h4>
<ol>
<li>翻倍扩容判断条件。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// overLoadFactor reports whether count items placed in 1&lt;&lt;B buckets is over loadFactor.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">overLoadFactor</span><span class="p">(</span><span class="nx">count</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">B</span> <span class="kt">uint8</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// count &gt; 8 &amp;&amp; count &gt; 13*((1&lt;&lt;B) / 2)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">return</span> <span class="nx">count</span> <span class="p">&gt;</span> <span class="nx">bucketCnt</span> <span class="o">&amp;&amp;</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">count</span><span class="p">)</span> <span class="p">&gt;</span> <span class="nx">loadFactorNum</span><span class="o">*</span><span class="p">(</span><span class="nf">bucketShift</span><span class="p">(</span><span class="nx">B</span><span class="p">)</span><span class="o">/</span><span class="nx">loadFactorDen</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="toomanyoverflowbuckets">tooManyOverflowBuckets()<a hidden class="anchor" aria-hidden="true" href="#toomanyoverflowbuckets">#</a></h4>
<ol>
<li>等量扩容判断条件。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// tooManyOverflowBuckets reports whether noverflow buckets is too many for a map with 1&lt;&lt;B buckets.
</span></span></span><span class="line"><span class="cl"><span class="c1">// Note that most of these overflow buckets must be in sparse use;
</span></span></span><span class="line"><span class="cl"><span class="c1">// if use was dense, then we&#39;d have already triggered regular map growth.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">tooManyOverflowBuckets</span><span class="p">(</span><span class="nx">noverflow</span> <span class="kt">uint16</span><span class="p">,</span> <span class="nx">B</span> <span class="kt">uint8</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// If the threshold is too low, we do extraneous work.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// If the threshold is too high, maps that grow and shrink can hold on to lots of unused memory.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// &#34;too many&#34; means (approximately) as many overflow buckets as regular buckets.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// See incrnoverflow for more details.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nx">B</span> <span class="p">&gt;</span> <span class="mi">15</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">B</span> <span class="p">=</span> <span class="mi">15</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// The compiler doesn&#39;t see here that B &lt; 16; mask B to generate shorter shift code.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">return</span> <span class="nx">noverflow</span> <span class="o">&gt;=</span> <span class="nb">uint16</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="nx">B</span><span class="o">&amp;</span><span class="mi">15</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="扩容-">扩容 🚀<a hidden class="anchor" aria-hidden="true" href="#扩容-">#</a></h2>
<h3 id="翻倍扩容条件">翻倍扩容条件<a hidden class="anchor" aria-hidden="true" href="#翻倍扩容条件">#</a></h3>
<ol>
<li><code>h.oldbuckets == nil</code>; 未处于扩容过程中。</li>
<li>存储的<code>key/elem</code>对数量大于常规桶数量的 6.5 倍。</li>
<li><code>key/elem</code>对数量大于8</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// 1) h.oldbuckets != nil; 处于扩容中。!h.growing()：没有处于扩容中
</span></span></span><span class="line"><span class="cl"><span class="c1">// 2) overLoadFactor(h.count+1, h.B)：新增一个元素是否需要扩容判断
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">if</span> <span class="p">!</span><span class="nx">h</span><span class="p">.</span><span class="nf">growing</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="nf">overLoadFactor</span><span class="p">(</span><span class="nx">h</span><span class="p">.</span><span class="nx">count</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="nx">h</span><span class="p">.</span><span class="nx">B</span><span class="p">)</span> <span class="p">{}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="overloadfactor-2">overLoadFactor()<a hidden class="anchor" aria-hidden="true" href="#overloadfactor-2">#</a></h4>
<ol>
<li><code>overLoadFactor</code> 报告放置在 <code>1&lt;&lt;B</code> 桶中的项目数量是否超过 <code>loadFactor</code>。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// overLoadFactor reports whether count items placed in 1&lt;&lt;B buckets is over loadFactor.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">overLoadFactor</span><span class="p">(</span><span class="nx">count</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">B</span> <span class="kt">uint8</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// count &gt; 8 &amp;&amp; count &gt; 13*( (1&lt;&lt;B) / 2)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// count &gt; 8 &amp;&amp; count &gt; 6.5 * (1&lt;&lt;B)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">return</span> <span class="nx">count</span> <span class="p">&gt;</span> <span class="nx">bucketCnt</span> <span class="o">&amp;&amp;</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">count</span><span class="p">)</span> <span class="p">&gt;</span> <span class="nx">loadFactorNum</span><span class="o">*</span><span class="p">(</span><span class="nf">bucketShift</span><span class="p">(</span><span class="nx">B</span><span class="p">)</span><span class="o">/</span><span class="nx">loadFactorDen</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="等量扩容条件">等量扩容条件<a hidden class="anchor" aria-hidden="true" href="#等量扩容条件">#</a></h3>
<ol>
<li>当常规桶(<code>h.B</code>)小于等于15时，溢出桶数量 <strong>大于等于</strong> 常规桶数量(<code>1 &lt;&lt; h.B</code>) 就要扩容。</li>
<li>当常规桶(<code>h.B</code>)大于15时，溢出桶数量 <strong>大于等于</strong> (<code>1 &lt;&lt; 15</code>) 就要扩容了。</li>
<li>溢出桶的分配规则：<strong>当<code>B&gt;=4</code>时则分配(<code>B-4</code>)个溢出桶备用</strong>，因此常规桶数量大于溢出桶数量。等量扩容时备用的溢出桶一定是被用完了。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// 1) !h.growing()：没有处于扩容中
</span></span></span><span class="line"><span class="cl"><span class="c1">// 2) tooManyOverflowBuckets(h.noverflow, h.B)：满足等量扩容条件
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">if</span> <span class="p">!</span><span class="nx">h</span><span class="p">.</span><span class="nf">growing</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="nf">tooManyOverflowBuckets</span><span class="p">(</span><span class="nx">h</span><span class="p">.</span><span class="nx">noverflow</span><span class="p">,</span> <span class="nx">h</span><span class="p">.</span><span class="nx">B</span><span class="p">)</span> <span class="p">{}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="toomanyoverflowbuckets-1">tooManyOverflowBuckets()<a hidden class="anchor" aria-hidden="true" href="#toomanyoverflowbuckets-1">#</a></h4>
<ol>
<li><code>tooManyOverflowBuckets</code> 报告 <code>noverflow</code> 桶对于一个包含 <code>1&lt;&lt;B</code> 桶的 <code>map</code> 来说是否太多。</li>
<li>请注意，大多数溢出桶必须稀疏使用;</li>
<li>如果使用是密集的，那么我们就已经触发了常规的 <code>map</code> 增长。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// tooManyOverflowBuckets reports whether noverflow buckets is too many for a map with 1&lt;&lt;B buckets.
</span></span></span><span class="line"><span class="cl"><span class="c1">// Note that most of these overflow buckets must be in sparse use;
</span></span></span><span class="line"><span class="cl"><span class="c1">// if use was dense, then we&#39;d have already triggered regular map growth.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">tooManyOverflowBuckets</span><span class="p">(</span><span class="nx">noverflow</span> <span class="kt">uint16</span><span class="p">,</span> <span class="nx">B</span> <span class="kt">uint8</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// If the threshold is too low, we do extraneous work.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// If the threshold is too high, maps that grow and shrink can hold on to lots of unused memory.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// &#34;too many&#34; means (approximately) as many overflow buckets as regular buckets.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// See incrnoverflow for more details.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 如果阈值太低，我们做多余的工作。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 如果阈值过高，则增大和缩小的映射会占用大量未使用的内存。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// &#34;too many&#34;是指溢出桶的数量(大约)与普通桶相同。更多细节请参见h.incnoverflow()。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nx">B</span> <span class="p">&gt;</span> <span class="mi">15</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">B</span> <span class="p">=</span> <span class="mi">15</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// The compiler doesn&#39;t see here that B &lt; 16; mask B to generate shorter shift code.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 编译器没有看到B &lt; 16;掩码B以生成更短的移位码。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// noverflow：表示已使用的溢出桶数量
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">return</span> <span class="nx">noverflow</span> <span class="o">&gt;=</span> <span class="nb">uint16</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="nx">B</span><span class="o">&amp;</span><span class="mi">15</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="扩容初始化">扩容初始化<a hidden class="anchor" aria-hidden="true" href="#扩容初始化">#</a></h3>
<h4 id="hashgrow">hashGrow()<a hidden class="anchor" aria-hidden="true" href="#hashgrow">#</a></h4>
<ol>
<li>扩容初始化开始。</li>
<li>参数：
<ul>
<li><code>t *maptype</code>：当前 map 的类型结构。</li>
<li><code>h *hmap</code>：当前 map 的内存结构。</li>
</ul>
</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">hashGrow</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">maptype</span><span class="p">,</span> <span class="nx">h</span> <span class="o">*</span><span class="nx">hmap</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// If we&#39;ve hit the load factor, get bigger.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// Otherwise, there are too many overflow buckets,
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// so keep the same number of buckets and &#34;grow&#34; laterally.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 1) 如果我们达到了满载系数，就会变大。否则，溢出桶太多，所以保持相同数量的桶，横向“增长”。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">bigger</span> <span class="o">:=</span> <span class="nb">uint8</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>	<span class="c1">// bigger是翻倍扩容还是等量扩容 1.【翻倍扩容】 0.【等量扩容】	
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">!</span><span class="nf">overLoadFactor</span><span class="p">(</span><span class="nx">h</span><span class="p">.</span><span class="nx">count</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="nx">h</span><span class="p">.</span><span class="nx">B</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">bigger</span> <span class="p">=</span> <span class="mi">0</span> <span class="c1">// 标记等量扩容
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">h</span><span class="p">.</span><span class="nx">flags</span> <span class="o">|=</span> <span class="nx">sameSizeGrow</span>	<span class="c1">// 设置等量扩容标志位
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nx">oldbuckets</span> <span class="o">:=</span> <span class="nx">h</span><span class="p">.</span><span class="nx">buckets</span> <span class="c1">// 记录旧桶地址
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 2) 申请一块新内存，当做新桶地址
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">newbuckets</span><span class="p">,</span> <span class="nx">nextOverflow</span> <span class="o">:=</span> <span class="nf">makeBucketArray</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">h</span><span class="p">.</span><span class="nx">B</span><span class="o">+</span><span class="nx">bigger</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span>	
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 3) 清除iterator 和 oldIterator标志的flags
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">flags</span> <span class="o">:=</span> <span class="nx">h</span><span class="p">.</span><span class="nx">flags</span> <span class="o">&amp;^</span> <span class="p">(</span><span class="nx">iterator</span> <span class="p">|</span> <span class="nx">oldIterator</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 迭代器在扩容的前面时
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nx">h</span><span class="p">.</span><span class="nx">flags</span><span class="o">&amp;</span><span class="nx">iterator</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>	<span class="c1">// 迭代器正在运行
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">flags</span> <span class="o">|=</span> <span class="nx">oldIterator</span> <span class="c1">// 标记迭代旧数据
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c1">// 4) 设置 hmap 相关参数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// commit the grow (atomic wrt gc)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">h</span><span class="p">.</span><span class="nx">B</span> <span class="o">+=</span> <span class="nx">bigger</span>       <span class="c1">// 扩容后的B
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">h</span><span class="p">.</span><span class="nx">flags</span> <span class="p">=</span> <span class="nx">flags</span>     <span class="c1">// 最新的flags状态
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">h</span><span class="p">.</span><span class="nx">oldbuckets</span> <span class="p">=</span> <span class="nx">oldbuckets</span> <span class="c1">// 旧桶地址
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">h</span><span class="p">.</span><span class="nx">buckets</span> <span class="p">=</span> <span class="nx">newbuckets</span>  <span class="c1">// 新桶地址
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">h</span><span class="p">.</span><span class="nx">nevacuate</span> <span class="p">=</span> <span class="mi">0</span>	<span class="c1">// 下一个需要迁移的旧桶号
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">h</span><span class="p">.</span><span class="nx">noverflow</span> <span class="p">=</span> <span class="mi">0</span> <span class="c1">// 已使用的溢出桶
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="c1">// h.extra.overflow 和 h.extra.oldoverflow
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 5) 溢出桶相关设置（主要是GC相关），作用在前面已经介绍了
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nx">h</span><span class="p">.</span><span class="nx">extra</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="nx">h</span><span class="p">.</span><span class="nx">extra</span><span class="p">.</span><span class="nx">overflow</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// Promote current overflow buckets to the old generation.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="nx">h</span><span class="p">.</span><span class="nx">extra</span><span class="p">.</span><span class="nx">oldoverflow</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nf">throw</span><span class="p">(</span><span class="s">&#34;oldoverflow is not nil&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="nx">h</span><span class="p">.</span><span class="nx">extra</span><span class="p">.</span><span class="nx">oldoverflow</span> <span class="p">=</span> <span class="nx">h</span><span class="p">.</span><span class="nx">extra</span><span class="p">.</span><span class="nx">overflow</span>
</span></span><span class="line"><span class="cl">        <span class="nx">h</span><span class="p">.</span><span class="nx">extra</span><span class="p">.</span><span class="nx">overflow</span> <span class="p">=</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 6) 分配了备用溢出桶
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nx">nextOverflow</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="nx">h</span><span class="p">.</span><span class="nx">extra</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nx">h</span><span class="p">.</span><span class="nx">extra</span> <span class="p">=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">mapextra</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="nx">h</span><span class="p">.</span><span class="nx">extra</span><span class="p">.</span><span class="nx">nextOverflow</span> <span class="p">=</span> <span class="nx">nextOverflow</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// the actual copying of the hash table data is done incrementally
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// by growWork() and evacuate().
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 实际的哈希表数据复制是通过growWork()和evacuate()完成的。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 渐进式扩容分配到【写】和【删除】中调用growWork()和evacuate()完成的。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 注意：读操作【并没有】渐进式迁移部分数据。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="渐进式迁移">渐进式迁移<a hidden class="anchor" aria-hidden="true" href="#渐进式迁移">#</a></h3>
<h4 id="growwork">growWork()<a hidden class="anchor" aria-hidden="true" href="#growwork">#</a></h4>
<ol>
<li>渐进式迁移桶数据。<strong>先迁移当前传入的桶号，再去迁移下次需要迁移的桶号</strong>。</li>
<li>因为当前传入的桶号一定是当前正在写或删除的key对应的桶号，因此先迁移该桶，然后迁移固定增长的桶号。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">growWork</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">maptype</span><span class="p">,</span> <span class="nx">h</span> <span class="o">*</span><span class="nx">hmap</span><span class="p">,</span> <span class="nx">bucket</span> <span class="kt">uintptr</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// make sure we evacuate the oldbucket corresponding
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// to the bucket we&#39;re about to use
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 确保我们清空了将要使用的桶对应的oldbucket
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">evacuate</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">h</span><span class="p">,</span> <span class="nx">bucket</span><span class="o">&amp;</span><span class="nx">h</span><span class="p">.</span><span class="nf">oldbucketmask</span><span class="p">())</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// evacuate one more oldbucket to make progress on growing
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 疏散更多的旧桶，以取得进展的增长
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nx">h</span><span class="p">.</span><span class="nf">growing</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">evacuate</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">h</span><span class="p">,</span> <span class="nx">h</span><span class="p">.</span><span class="nx">nevacuate</span><span class="p">)</span>	<span class="c1">// 注意这里传的桶号是h.nevacuate
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="evacuate">evacuate()<a hidden class="anchor" aria-hidden="true" href="#evacuate">#</a></h4>
<ol>
<li>执行<strong>一次</strong>桶迁移，在疏散旧桶时只修改了<code>topHash</code>，并且在<strong>没有迭代器</strong>情况下才清除<code>key/elem</code>。</li>
<li>参数：
<ul>
<li><code>t *maptype</code>：map 类型结构。</li>
<li><code>h *hmap</code>：map 内存结构。</li>
<li><code>oldbucket uintptr</code>：当前需要迁移桶的编号。</li>
</ul>
</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span><span class="lnt">113
</span><span class="lnt">114
</span><span class="lnt">115
</span><span class="lnt">116
</span><span class="lnt">117
</span><span class="lnt">118
</span><span class="lnt">119
</span><span class="lnt">120
</span><span class="lnt">121
</span><span class="lnt">122
</span><span class="lnt">123
</span><span class="lnt">124
</span><span class="lnt">125
</span><span class="lnt">126
</span><span class="lnt">127
</span><span class="lnt">128
</span><span class="lnt">129
</span><span class="lnt">130
</span><span class="lnt">131
</span><span class="lnt">132
</span><span class="lnt">133
</span><span class="lnt">134
</span><span class="lnt">135
</span><span class="lnt">136
</span><span class="lnt">137
</span><span class="lnt">138
</span><span class="lnt">139
</span><span class="lnt">140
</span><span class="lnt">141
</span><span class="lnt">142
</span><span class="lnt">143
</span><span class="lnt">144
</span><span class="lnt">145
</span><span class="lnt">146
</span><span class="lnt">147
</span><span class="lnt">148
</span><span class="lnt">149
</span><span class="lnt">150
</span><span class="lnt">151
</span><span class="lnt">152
</span><span class="lnt">153
</span><span class="lnt">154
</span><span class="lnt">155
</span><span class="lnt">156
</span><span class="lnt">157
</span><span class="lnt">158
</span><span class="lnt">159
</span><span class="lnt">160
</span><span class="lnt">161
</span><span class="lnt">162
</span><span class="lnt">163
</span><span class="lnt">164
</span><span class="lnt">165
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">evacuate</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">maptype</span><span class="p">,</span> <span class="nx">h</span> <span class="o">*</span><span class="nx">hmap</span><span class="p">,</span> <span class="nx">oldbucket</span> <span class="kt">uintptr</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 1) oldbucket 桶号对应的 *bmap 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">b</span> <span class="o">:=</span> <span class="p">(</span><span class="o">*</span><span class="nx">bmap</span><span class="p">)(</span><span class="nf">add</span><span class="p">(</span><span class="nx">h</span><span class="p">.</span><span class="nx">oldbuckets</span><span class="p">,</span> <span class="nx">oldbucket</span><span class="o">*</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">bucketsize</span><span class="p">)))</span>    <span class="c1">// *bmap
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">newbit</span> <span class="o">:=</span> <span class="nx">h</span><span class="p">.</span><span class="nf">noldbuckets</span><span class="p">()</span> <span class="c1">// 旧桶数量，等量扩容就是 1&lt;&lt;h.B，翻倍扩容为 1&lt;&lt;(h.B-1)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 2) 当前桶没有被迁移，tophash[0] not in (2,3,4)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">!</span><span class="nf">evacuated</span><span class="p">(</span><span class="nx">b</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// TODO: reuse overflow buckets instead of using new ones, if there
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// is no iterator using the old buckets.  (If !oldIterator.)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// TODO: 如果没有迭代器使用旧的桶，则重用溢出的桶，而不是使用新的桶。(If !oldIterator)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">        <span class="c1">// xy contains the x and y (low and high) evacuation destinations.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// xy包含x和y(low and high)疏散目的地。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 2.1) 记录迁移后桶的去向，x与旧桶，y则是新桶
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="kd">var</span> <span class="nx">xy</span> <span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="nx">evacDst</span>	
</span></span><span class="line"><span class="cl">        <span class="nx">x</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">xy</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="c1">// 流向旧桶时的桶信息。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">x</span><span class="p">.</span><span class="nx">b</span> <span class="p">=</span> <span class="p">(</span><span class="o">*</span><span class="nx">bmap</span><span class="p">)(</span><span class="nf">add</span><span class="p">(</span><span class="nx">h</span><span class="p">.</span><span class="nx">buckets</span><span class="p">,</span> <span class="nx">oldbucket</span><span class="o">*</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">bucketsize</span><span class="p">)))</span>
</span></span><span class="line"><span class="cl">        <span class="nx">x</span><span class="p">.</span><span class="nx">k</span> <span class="p">=</span> <span class="nf">add</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">x</span><span class="p">.</span><span class="nx">b</span><span class="p">),</span> <span class="nx">dataOffset</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="nx">x</span><span class="p">.</span><span class="nx">e</span> <span class="p">=</span> <span class="nf">add</span><span class="p">(</span><span class="nx">x</span><span class="p">.</span><span class="nx">k</span><span class="p">,</span> <span class="nx">bucketCnt</span><span class="o">*</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">keysize</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// 2.2) 翻倍扩容
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="p">!</span><span class="nx">h</span><span class="p">.</span><span class="nf">sameSizeGrow</span><span class="p">()</span> <span class="p">{</span>	
</span></span><span class="line"><span class="cl">            <span class="c1">// Only calculate y pointers if we&#39;re growing bigger.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// Otherwise GC can see bad pointers.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// 只有当y指针翻倍扩容时才计算。否则GC会看到坏指针。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="nx">y</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">xy</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="c1">// 流向新桶时的桶信息。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="nx">y</span><span class="p">.</span><span class="nx">b</span> <span class="p">=</span> <span class="p">(</span><span class="o">*</span><span class="nx">bmap</span><span class="p">)(</span><span class="nf">add</span><span class="p">(</span><span class="nx">h</span><span class="p">.</span><span class="nx">buckets</span><span class="p">,</span> <span class="p">(</span><span class="nx">oldbucket</span><span class="o">+</span><span class="nx">newbit</span><span class="p">)</span><span class="o">*</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">bucketsize</span><span class="p">)))</span>
</span></span><span class="line"><span class="cl">            <span class="nx">y</span><span class="p">.</span><span class="nx">k</span> <span class="p">=</span> <span class="nf">add</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">y</span><span class="p">.</span><span class="nx">b</span><span class="p">),</span> <span class="nx">dataOffset</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="nx">y</span><span class="p">.</span><span class="nx">e</span> <span class="p">=</span> <span class="nf">add</span><span class="p">(</span><span class="nx">y</span><span class="p">.</span><span class="nx">k</span><span class="p">,</span> <span class="nx">bucketCnt</span><span class="o">*</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">keysize</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// 2.3) 遍历【常规桶】和后面的【溢出桶】
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">for</span> <span class="p">;</span> <span class="nx">b</span> <span class="o">!=</span> <span class="kc">nil</span><span class="p">;</span> <span class="nx">b</span> <span class="p">=</span> <span class="nx">b</span><span class="p">.</span><span class="nf">overflow</span><span class="p">(</span><span class="nx">t</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nx">k</span> <span class="o">:=</span> <span class="nf">add</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">b</span><span class="p">),</span> <span class="nx">dataOffset</span><span class="p">)</span> <span class="c1">// key开始首地址
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="nx">e</span> <span class="o">:=</span> <span class="nf">add</span><span class="p">(</span><span class="nx">k</span><span class="p">,</span> <span class="nx">bucketCnt</span><span class="o">*</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">keysize</span><span class="p">))</span> <span class="c1">// elem开始首地址
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// 2.4) 遍历当前桶 i、k、e 分别对应当前桶 index、key、elem
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// const bucketCnt = 8
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">bucketCnt</span><span class="p">;</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">k</span><span class="p">,</span> <span class="nx">e</span> <span class="p">=</span> <span class="nx">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="nf">add</span><span class="p">(</span><span class="nx">k</span><span class="p">,</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">keysize</span><span class="p">)),</span> <span class="nf">add</span><span class="p">(</span><span class="nx">e</span><span class="p">,</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">elemsize</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="nx">top</span> <span class="o">:=</span> <span class="nx">b</span><span class="p">.</span><span class="nx">tophash</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">                <span class="c1">// 2.4.1) 当前i处为空，top &lt;= 1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="k">if</span> <span class="nf">isEmpty</span><span class="p">(</span><span class="nx">top</span><span class="p">)</span> <span class="p">{</span> 
</span></span><span class="line"><span class="cl">                    <span class="c1">// const evacuatedEmpty = 4
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                    <span class="c1">// 0或1 标记为 4
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                    <span class="nx">b</span><span class="p">.</span><span class="nx">tophash</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nx">evacuatedEmpty</span>	
</span></span><span class="line"><span class="cl">                    <span class="k">continue</span>
</span></span><span class="line"><span class="cl">                <span class="p">}</span>
</span></span><span class="line"><span class="cl">                <span class="c1">// const minTopHash = 5
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="k">if</span> <span class="nx">top</span> <span class="p">&lt;</span> <span class="nx">minTopHash</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                    <span class="nf">throw</span><span class="p">(</span><span class="s">&#34;bad map state&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                <span class="p">}</span>
</span></span><span class="line"><span class="cl">                
</span></span><span class="line"><span class="cl">                <span class="c1">// 2.4.2) 有数据需要迁移
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="nx">k2</span> <span class="o">:=</span> <span class="nx">k</span>	<span class="c1">// k是当前遍历桶&amp;key	unsafe.Pointer
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="k">if</span> <span class="nx">t</span><span class="p">.</span><span class="nf">indirectkey</span><span class="p">()</span> <span class="p">{</span>    <span class="c1">// 间接存储
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                    <span class="nx">k2</span> <span class="p">=</span> <span class="o">*</span><span class="p">((</span><span class="o">*</span><span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">)(</span><span class="nx">k2</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">                <span class="p">}</span>
</span></span><span class="line"><span class="cl">                <span class="c1">// 由于记录桶的流向 0.旧桶 1.新桶
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="kd">var</span> <span class="nx">useY</span> <span class="kt">uint8</span>	
</span></span><span class="line"><span class="cl">                <span class="k">if</span> <span class="p">!</span><span class="nx">h</span><span class="p">.</span><span class="nf">sameSizeGrow</span><span class="p">()</span> <span class="p">{</span>  <span class="c1">// 翻倍扩容
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                    <span class="c1">// Compute hash to make our evacuation decision (whether we need
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                    <span class="c1">// to send this key/elem to bucket x or bucket y).
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                    <span class="c1">// 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                    <span class="c1">// 计算哈希值以做出疏散决策(我们需要将这个键/elem发送到桶x还是桶y)。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                    <span class="nx">hash</span> <span class="o">:=</span> <span class="nx">t</span><span class="p">.</span><span class="nf">hasher</span><span class="p">(</span><span class="nx">k2</span><span class="p">,</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">h</span><span class="p">.</span><span class="nx">hash0</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">                    <span class="c1">// !t.reflexivekey() == true 说明 k2 != k2 成立，比如 NaN
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                    <span class="c1">// h.flags&amp;iterator != 0 迭代器在扩容后
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                    <span class="k">if</span> <span class="nx">h</span><span class="p">.</span><span class="nx">flags</span><span class="o">&amp;</span><span class="nx">iterator</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="p">!</span><span class="nx">t</span><span class="p">.</span><span class="nf">reflexivekey</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="p">!</span><span class="nx">t</span><span class="p">.</span><span class="nx">key</span><span class="p">.</span><span class="nf">equal</span><span class="p">(</span><span class="nx">k2</span><span class="p">,</span> <span class="nx">k2</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                        <span class="c1">// If key != key (NaNs), then the hash could be (and probably
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                        <span class="c1">// will be) entirely different from the old hash. Moreover,
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                        <span class="c1">// it isn&#39;t reproducible. Reproducibility is required in the
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                        <span class="c1">// presence of iterators, as our evacuation decision must
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                        <span class="c1">// match whatever decision the iterator made.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                        <span class="c1">// Fortunately, we have the freedom to send these keys either
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                        <span class="c1">// way. Also, tophash is meaningless for these kinds of keys.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                        <span class="c1">// We let the low bit of tophash drive the evacuation decision.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                        <span class="c1">// We recompute a new random tophash for the next level so
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                        <span class="c1">// these keys will get evenly distributed across all buckets
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                        <span class="c1">// after multiple grows.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                        <span class="c1">// 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                        <span class="c1">// 如果 key != key (NaNs)，那么这个hash值可能(也可能会)与旧的hash值完全不同。此外，它是不可复制的。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                        <span class="c1">// 在迭代器存在的情况下，需要重现性，因为我们的疏散决策必须匹配迭代器所做的任何决策。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                        <span class="c1">// 幸运的是，我们可以自由地以任何方式发送这些keys。而且，tophash对于这种类型的键没有意义。(因为无法取出来)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                        <span class="c1">// 我们让低bit位的tophash来决定疏散。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                        <span class="c1">// 我们为下一层重新计算一个新的随机tophash值，这样这些键在增长多次后将均匀分布到所有桶中。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                        <span class="c1">// 注意这里的top是旧桶的tophash在计算疏散方向
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                        <span class="nx">useY</span> <span class="p">=</span> <span class="nx">top</span> <span class="o">&amp;</span> <span class="mi">1</span>  <span class="c1">// top的最低位用来随机计算，以便均匀的分布这些key到存储桶中去
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                        <span class="nx">top</span> <span class="p">=</span> <span class="nf">tophash</span><span class="p">(</span><span class="nx">hash</span><span class="p">)</span> <span class="c1">// 从新计算tophash，该top存储在新桶
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                        <span class="c1">// 没有迭代器在运行 或 k == k成立
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                        
</span></span><span class="line"><span class="cl">                        <span class="c1">// 流向新桶，newbit是旧桶数量为2的幂次方
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                        <span class="k">if</span> <span class="nx">hash</span><span class="o">&amp;</span><span class="nx">newbit</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>	
</span></span><span class="line"><span class="cl">                            <span class="nx">useY</span> <span class="p">=</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">                        <span class="p">}</span>
</span></span><span class="line"><span class="cl">                    <span class="p">}</span>
</span></span><span class="line"><span class="cl">                <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                <span class="c1">// const evacuatedX = 2 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="c1">// const evacuatedY = 3
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="k">if</span> <span class="nx">evacuatedX</span><span class="o">+</span><span class="mi">1</span> <span class="o">!=</span> <span class="nx">evacuatedY</span> <span class="o">||</span> <span class="nx">evacuatedX</span><span class="p">^</span><span class="mi">1</span> <span class="o">!=</span> <span class="nx">evacuatedY</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                    <span class="nf">throw</span><span class="p">(</span><span class="s">&#34;bad evacuatedN&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                <span class="c1">// tophash = 2 或 3，数据流向; 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="c1">// 注意上面的 useY = top &amp; 1; 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="c1">// 即使这里修改了旧桶的topHash也能知道疏散方向，因为2和3代表疏散方向
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="nx">b</span><span class="p">.</span><span class="nx">tophash</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nx">evacuatedX</span> <span class="o">+</span> <span class="nx">useY</span> <span class="c1">// evacuatedX + 1 == evacuatedY
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="c1">// dst目标桶
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="nx">dst</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">xy</span><span class="p">[</span><span class="nx">useY</span><span class="p">]</span> <span class="c1">// evacuation destination
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">                <span class="c1">// 当前桶已经存满了
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="c1">// const bucketCnt = 8
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="k">if</span> <span class="nx">dst</span><span class="p">.</span><span class="nx">i</span> <span class="o">==</span> <span class="nx">bucketCnt</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                    <span class="nx">dst</span><span class="p">.</span><span class="nx">b</span> <span class="p">=</span> <span class="nx">h</span><span class="p">.</span><span class="nf">newoverflow</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">dst</span><span class="p">.</span><span class="nx">b</span><span class="p">)</span>	<span class="c1">// 关联桶并分配新的溢出桶
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                    <span class="nx">dst</span><span class="p">.</span><span class="nx">i</span> <span class="p">=</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">                    <span class="nx">dst</span><span class="p">.</span><span class="nx">k</span> <span class="p">=</span> <span class="nf">add</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">dst</span><span class="p">.</span><span class="nx">b</span><span class="p">),</span> <span class="nx">dataOffset</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                    <span class="nx">dst</span><span class="p">.</span><span class="nx">e</span> <span class="p">=</span> <span class="nf">add</span><span class="p">(</span><span class="nx">dst</span><span class="p">.</span><span class="nx">k</span><span class="p">,</span> <span class="nx">bucketCnt</span><span class="o">*</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">keysize</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">                <span class="p">}</span>
</span></span><span class="line"><span class="cl">                <span class="c1">// tophash 迁移
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="nx">dst</span><span class="p">.</span><span class="nx">b</span><span class="p">.</span><span class="nx">tophash</span><span class="p">[</span><span class="nx">dst</span><span class="p">.</span><span class="nx">i</span><span class="o">&amp;</span><span class="p">(</span><span class="nx">bucketCnt</span><span class="o">-</span><span class="mi">1</span><span class="p">)]</span> <span class="p">=</span> <span class="nx">top</span> <span class="c1">// mask dst.i as an optimization, to avoid a bounds check
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="k">if</span> <span class="nx">t</span><span class="p">.</span><span class="nf">indirectkey</span><span class="p">()</span> <span class="p">{</span>    <span class="c1">// 间接存储
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                    <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">)(</span><span class="nx">dst</span><span class="p">.</span><span class="nx">k</span><span class="p">)</span> <span class="p">=</span> <span class="nx">k2</span> <span class="c1">// copy pointer
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                    <span class="nf">typedmemmove</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">key</span><span class="p">,</span> <span class="nx">dst</span><span class="p">.</span><span class="nx">k</span><span class="p">,</span> <span class="nx">k</span><span class="p">)</span> <span class="c1">// copy elem
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="p">}</span>
</span></span><span class="line"><span class="cl">                <span class="k">if</span> <span class="nx">t</span><span class="p">.</span><span class="nf">indirectelem</span><span class="p">()</span> <span class="p">{</span>   <span class="c1">// 间接存储
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                    <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">)(</span><span class="nx">dst</span><span class="p">.</span><span class="nx">e</span><span class="p">)</span> <span class="p">=</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">)(</span><span class="nx">e</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                    <span class="nf">typedmemmove</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">elem</span><span class="p">,</span> <span class="nx">dst</span><span class="p">.</span><span class="nx">e</span><span class="p">,</span> <span class="nx">e</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                <span class="p">}</span>
</span></span><span class="line"><span class="cl">                <span class="nx">dst</span><span class="p">.</span><span class="nx">i</span><span class="o">++</span>
</span></span><span class="line"><span class="cl">                <span class="c1">// These updates might push these pointers past the end of the
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="c1">// key or elem arrays.  That&#39;s ok, as we have the overflow pointer
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="c1">// at the end of the bucket to protect against pointing past the
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="c1">// end of the bucket.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="nx">dst</span><span class="p">.</span><span class="nx">k</span> <span class="p">=</span> <span class="nf">add</span><span class="p">(</span><span class="nx">dst</span><span class="p">.</span><span class="nx">k</span><span class="p">,</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">keysize</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">                <span class="nx">dst</span><span class="p">.</span><span class="nx">e</span> <span class="p">=</span> <span class="nf">add</span><span class="p">(</span><span class="nx">dst</span><span class="p">.</span><span class="nx">e</span><span class="p">,</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">elemsize</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// Unlink the overflow buckets &amp; clear key/elem to help GC.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 当前桶及溢出桶都被疏散完成后；断开溢出桶 并 清除key/elem以帮助GC
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// h.flags&amp;oldIterator == 0：遍历器没有在遍历旧数据
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// t.bucket.ptrdata != 0：桶类型中存在指针，也就是 key/elem 类型中存在指针
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="nx">h</span><span class="p">.</span><span class="nx">flags</span><span class="o">&amp;</span><span class="nx">oldIterator</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">t</span><span class="p">.</span><span class="nx">bucket</span><span class="p">.</span><span class="nx">ptrdata</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 当前清除旧桶所在桶地址
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="nx">b</span> <span class="o">:=</span> <span class="nf">add</span><span class="p">(</span><span class="nx">h</span><span class="p">.</span><span class="nx">oldbuckets</span><span class="p">,</span> <span class="nx">oldbucket</span><span class="o">*</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">bucketsize</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// Preserve b.tophash because the evacuation
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// state is maintained there.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// 保留b.tophash，因为疏散状态在那里保持。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="nx">ptr</span> <span class="o">:=</span> <span class="nf">add</span><span class="p">(</span><span class="nx">b</span><span class="p">,</span> <span class="nx">dataOffset</span><span class="p">)</span> <span class="c1">// key开始地址
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="nx">n</span> <span class="o">:=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">bucketsize</span><span class="p">)</span> <span class="o">-</span> <span class="nx">dataOffset</span> <span class="c1">// 需要清除的字节长度
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// 清除keys、elems、overflow帮助GC
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="nf">memclrHasPointers</span><span class="p">(</span><span class="nx">ptr</span><span class="p">,</span> <span class="nx">n</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// growWork方法在迁移了本次桶后会再迁移一次h.nevacuate，因此这里得到执行
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nx">oldbucket</span> <span class="o">==</span> <span class="nx">h</span><span class="p">.</span><span class="nx">nevacuate</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">advanceEvacuationMark</span><span class="p">(</span><span class="nx">h</span><span class="p">,</span> <span class="nx">t</span><span class="p">,</span> <span class="nx">newbit</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="evacuated-2">evacuated()<a hidden class="anchor" aria-hidden="true" href="#evacuated-2">#</a></h4>
<ol>
<li>判断当前桶是否已被迁移。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">evacuated</span><span class="p">(</span><span class="nx">b</span> <span class="o">*</span><span class="nx">bmap</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">h</span> <span class="o">:=</span> <span class="nx">b</span><span class="p">.</span><span class="nx">tophash</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// const emptyOne = 1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// const minTopHash = 5
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// b.tophash[0] IN (2,3,4)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">return</span> <span class="nx">h</span> <span class="p">&gt;</span> <span class="nx">emptyOne</span> <span class="o">&amp;&amp;</span> <span class="nx">h</span> <span class="p">&lt;</span> <span class="nx">minTopHash</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="type-evacdst-struct">type evacDst struct<a hidden class="anchor" aria-hidden="true" href="#type-evacdst-struct">#</a></h4>
<ol>
<li>evacDst 是桶数据迁移流转的一个存储器。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// evacDst is an evacuation destination.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">type</span> <span class="nx">evacDst</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 当前流转的目地桶 *bmap
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 也就是迁移后的新桶的桶地址，比如从A桶迁移到B桶，这里就是B桶的桶地址。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">b</span> <span class="o">*</span><span class="nx">bmap</span>          <span class="c1">// current destination bucket
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// key/elem 索引到b
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 该值默认为0，表示第一个索引下标
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">i</span> <span class="kt">int</span>            <span class="c1">// key/elem index into b
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 指向当前key存储的指针
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 该值默认指向第一个key的地址
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">k</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span> <span class="c1">// pointer to current key storage
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 指向当前elem存储的指针
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 该值默认指向第一个elem的地址
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">e</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span> <span class="c1">// pointer to current elem storage
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="isempty-1">isEmpty()<a hidden class="anchor" aria-hidden="true" href="#isempty-1">#</a></h4>
<ol>
<li>判断当前 slot 处是否为空。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// isEmpty reports whether the given tophash array entry represents an empty bucket entry.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">isEmpty</span><span class="p">(</span><span class="nx">x</span> <span class="kt">uint8</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// const emptyOne = 1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">return</span> <span class="nx">x</span> <span class="o">&lt;=</span> <span class="nx">emptyOne</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="advanceevacuationmark">advanceEvacuationMark()<a hidden class="anchor" aria-hidden="true" href="#advanceevacuationmark">#</a></h4>
<ol>
<li><code>h.nevacuate</code> 桶号得到迁移后相关判断迁移完毕代码。</li>
<li>参数：
<ul>
<li><code>h *hmap</code>：map 的内存结构。</li>
<li><code>t *maptype</code>：map 的类型结构。</li>
<li><code>newbit uintptr</code>：扩容后的总数量，翻倍扩容是之前容量的两倍，等量扩容就是之前的容量。</li>
</ul>
</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">advanceEvacuationMark</span><span class="p">(</span><span class="nx">h</span> <span class="o">*</span><span class="nx">hmap</span><span class="p">,</span> <span class="nx">t</span> <span class="o">*</span><span class="nx">maptype</span><span class="p">,</span> <span class="nx">newbit</span> <span class="kt">uintptr</span><span class="p">)</span> <span class="p">{</span>	
</span></span><span class="line"><span class="cl">    <span class="nx">h</span><span class="p">.</span><span class="nx">nevacuate</span><span class="o">++</span>   <span class="c1">// 下一个需要迁移的桶号
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// Experiments suggest that 1024 is overkill by at least an order of magnitude.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// Put it in there as a safeguard anyway, to ensure O(1) behavior.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 实验表明，1024是多余的，至少是一个数量级。把它放在那里作为一种保护措施，以确保O(1)行为。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">stop</span> <span class="o">:=</span> <span class="nx">h</span><span class="p">.</span><span class="nx">nevacuate</span> <span class="o">+</span> <span class="mi">1024</span>  <span class="c1">// stop是一个循环次数最大1024次
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// newbit 未扩容前桶数量，stop &gt; newbit 剩余扩容数量在[0,1024]间
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nx">stop</span> <span class="p">&gt;</span> <span class="nx">newbit</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">stop</span> <span class="p">=</span> <span class="nx">newbit</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 循环一定的次数，判断后面的桶是否已经迁移了
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">for</span> <span class="nx">h</span><span class="p">.</span><span class="nx">nevacuate</span> <span class="o">!=</span> <span class="nx">stop</span> <span class="o">&amp;&amp;</span> <span class="nf">bucketEvacuated</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">h</span><span class="p">,</span> <span class="nx">h</span><span class="p">.</span><span class="nx">nevacuate</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">h</span><span class="p">.</span><span class="nx">nevacuate</span><span class="o">++</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 桶已经迁移完
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nx">h</span><span class="p">.</span><span class="nx">nevacuate</span> <span class="o">==</span> <span class="nx">newbit</span> <span class="p">{</span> <span class="c1">// newbit == # of oldbuckets
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// Growing is all done. Free old main bucket array.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">h</span><span class="p">.</span><span class="nx">oldbuckets</span> <span class="p">=</span> <span class="kc">nil</span>  <span class="c1">// 释放oldbuckets
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// Can discard old overflow buckets as well.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// If they are still referenced by an iterator,
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// then the iterator holds a pointers to the slice.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 可以丢弃旧的溢出桶。如果它们仍然被迭代器引用，则迭代器保存一个指向片的指针。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="nx">h</span><span class="p">.</span><span class="nx">extra</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nx">h</span><span class="p">.</span><span class="nx">extra</span><span class="p">.</span><span class="nx">oldoverflow</span> <span class="p">=</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="nx">h</span><span class="p">.</span><span class="nx">flags</span> <span class="o">&amp;^=</span> <span class="nx">sameSizeGrow</span>    <span class="c1">// 清除sameSizeGrow标志位，如果设置了的话
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="bucketevacuated">bucketEvacuated()<a hidden class="anchor" aria-hidden="true" href="#bucketevacuated">#</a></h4>
<ol>
<li>判断 bucket 桶是否已经迁移了。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">bucketEvacuated</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">maptype</span><span class="p">,</span> <span class="nx">h</span> <span class="o">*</span><span class="nx">hmap</span><span class="p">,</span> <span class="nx">bucket</span> <span class="kt">uintptr</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">b</span> <span class="o">:=</span> <span class="p">(</span><span class="o">*</span><span class="nx">bmap</span><span class="p">)(</span><span class="nf">add</span><span class="p">(</span><span class="nx">h</span><span class="p">.</span><span class="nx">oldbuckets</span><span class="p">,</span> <span class="nx">bucket</span><span class="o">*</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">bucketsize</span><span class="p">)))</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nf">evacuated</span><span class="p">(</span><span class="nx">b</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="删除-">删除 🚀<a hidden class="anchor" aria-hidden="true" href="#删除-">#</a></h2>
<h3 id="delete">delete()<a hidden class="anchor" aria-hidden="true" href="#delete">#</a></h3>
<ol>
<li>内置函数<code>delete()</code>将指定键值(<code>m[key]</code>)的元素从<code>map</code>中删除。</li>
<li>如果<code>m</code>为<code>nil</code>或不存在这样的元素，则<code>delete()</code>为空操作。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// The delete built-in function deletes the element with the specified key
</span></span></span><span class="line"><span class="cl"><span class="c1">// (m[key]) from the map. If m is nil or there is no such element, delete
</span></span></span><span class="line"><span class="cl"><span class="c1">// is a no-op.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nb">delete</span><span class="p">(</span><span class="nx">m</span> <span class="kd">map</span><span class="p">[</span><span class="nx">Type</span><span class="p">]</span><span class="nx">Type1</span><span class="p">,</span> <span class="nx">key</span> <span class="nx">Type</span><span class="p">)</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="mapdelete">mapdelete()<a hidden class="anchor" aria-hidden="true" href="#mapdelete">#</a></h3>
<ol>
<li><code>delete</code>删除<code>map</code>。</li>
<li>如果删除的是中间数据直接标记并清除<code>key</code>和<code>elem</code>即可。</li>
<li>如果删除的是最后一个则需要向前判断前面是否已被删除依次标记<code>tophash</code>为0。</li>
<li>参数：
<ul>
<li><code>t *maptype</code>：map类型结构。</li>
<li><code>h *hmap</code>：map内存结构。</li>
<li><code>key unsafe.Pointer</code>：需要删除的<code>key</code>地址。</li>
</ul>
</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span><span class="lnt">113
</span><span class="lnt">114
</span><span class="lnt">115
</span><span class="lnt">116
</span><span class="lnt">117
</span><span class="lnt">118
</span><span class="lnt">119
</span><span class="lnt">120
</span><span class="lnt">121
</span><span class="lnt">122
</span><span class="lnt">123
</span><span class="lnt">124
</span><span class="lnt">125
</span><span class="lnt">126
</span><span class="lnt">127
</span><span class="lnt">128
</span><span class="lnt">129
</span><span class="lnt">130
</span><span class="lnt">131
</span><span class="lnt">132
</span><span class="lnt">133
</span><span class="lnt">134
</span><span class="lnt">135
</span><span class="lnt">136
</span><span class="lnt">137
</span><span class="lnt">138
</span><span class="lnt">139
</span><span class="lnt">140
</span><span class="lnt">141
</span><span class="lnt">142
</span><span class="lnt">143
</span><span class="lnt">144
</span><span class="lnt">145
</span><span class="lnt">146
</span><span class="lnt">147
</span><span class="lnt">148
</span><span class="lnt">149
</span><span class="lnt">150
</span><span class="lnt">151
</span><span class="lnt">152
</span><span class="lnt">153
</span><span class="lnt">154
</span><span class="lnt">155
</span><span class="lnt">156
</span><span class="lnt">157
</span><span class="lnt">158
</span><span class="lnt">159
</span><span class="lnt">160
</span><span class="lnt">161
</span><span class="lnt">162
</span><span class="lnt">163
</span><span class="lnt">164
</span><span class="lnt">165
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">mapdelete</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">maptype</span><span class="p">,</span> <span class="nx">h</span> <span class="o">*</span><span class="nx">hmap</span><span class="p">,</span> <span class="nx">key</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">raceenabled</span> <span class="o">&amp;&amp;</span> <span class="nx">h</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">callerpc</span> <span class="o">:=</span> <span class="nf">getcallerpc</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">        <span class="nx">pc</span> <span class="o">:=</span> <span class="nx">abi</span><span class="p">.</span><span class="nf">FuncPCABIInternal</span><span class="p">(</span><span class="nx">mapdelete</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="nf">racewritepc</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">h</span><span class="p">),</span> <span class="nx">callerpc</span><span class="p">,</span> <span class="nx">pc</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="nf">raceReadObjectPC</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">key</span><span class="p">,</span> <span class="nx">key</span><span class="p">,</span> <span class="nx">callerpc</span><span class="p">,</span> <span class="nx">pc</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">msanenabled</span> <span class="o">&amp;&amp;</span> <span class="nx">h</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">msanread</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="nx">t</span><span class="p">.</span><span class="nx">key</span><span class="p">.</span><span class="nx">size</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">asanenabled</span> <span class="o">&amp;&amp;</span> <span class="nx">h</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">asanread</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="nx">t</span><span class="p">.</span><span class="nx">key</span><span class="p">.</span><span class="nx">size</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 1) 未初始的map 或 map没有key/elem对
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nx">h</span> <span class="o">==</span> <span class="kc">nil</span> <span class="o">||</span> <span class="nx">h</span><span class="p">.</span><span class="nx">count</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 当key为any类型时，在key经过hash时可能会发生panic
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// t.hashMightPanic()判断当前hash函数是否可能发生panic
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="nx">t</span><span class="p">.</span><span class="nf">hashMightPanic</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 尝试hash panic
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="nx">t</span><span class="p">.</span><span class="nf">hasher</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="c1">// see issue 23734
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 2) 当前map正在并发写操作
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nx">h</span><span class="p">.</span><span class="nx">flags</span><span class="o">&amp;</span><span class="nx">hashWriting</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">fatal</span><span class="p">(</span><span class="s">&#34;concurrent map writes&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 3) key根据h.hash0生成hash值，根据上面key为any时这里hash可能会panic
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">hash</span> <span class="o">:=</span> <span class="nx">t</span><span class="p">.</span><span class="nf">hasher</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">h</span><span class="p">.</span><span class="nx">hash0</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// Set hashWriting after calling t.hasher, since t.hasher may panic,
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// in which case we have not actually done a write (delete).
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 在调用t.hasher之后设置hashWriting，因为t.hasher可能会发生错误，
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 在这种情况下我们实际上并没有执行写入(delete)操作。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">h</span><span class="p">.</span><span class="nx">flags</span> <span class="p">^=</span> <span class="nx">hashWriting</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nx">bucket</span> <span class="o">:=</span> <span class="nx">hash</span> <span class="o">&amp;</span> <span class="nf">bucketMask</span><span class="p">(</span><span class="nx">h</span><span class="p">.</span><span class="nx">B</span><span class="p">)</span>    <span class="c1">// 当前key对应桶号
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 4) 正在扩容进行中，去迁移该桶的数据
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nx">h</span><span class="p">.</span><span class="nf">growing</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">growWork</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">h</span><span class="p">,</span> <span class="nx">bucket</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nx">b</span> <span class="o">:=</span> <span class="p">(</span><span class="o">*</span><span class="nx">bmap</span><span class="p">)(</span><span class="nf">add</span><span class="p">(</span><span class="nx">h</span><span class="p">.</span><span class="nx">buckets</span><span class="p">,</span> <span class="nx">bucket</span><span class="o">*</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">bucketsize</span><span class="p">)))</span>  <span class="c1">// *bmap
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">bOrig</span> <span class="o">:=</span> <span class="nx">b</span>	<span class="c1">// 当前变量开始桶，用于向前遍历时判断结束点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">top</span> <span class="o">:=</span> <span class="nf">tophash</span><span class="p">(</span><span class="nx">hash</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nx">search</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 5) 变量当前常规桶以及后面溢出桶(如果存在)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">for</span> <span class="p">;</span> <span class="nx">b</span> <span class="o">!=</span> <span class="kc">nil</span><span class="p">;</span> <span class="nx">b</span> <span class="p">=</span> <span class="nx">b</span><span class="p">.</span><span class="nf">overflow</span><span class="p">(</span><span class="nx">t</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 遍历当前桶 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// const bucketCnt = 8
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">bucketCnt</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// tophash比对失败
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="k">if</span> <span class="nx">b</span><span class="p">.</span><span class="nx">tophash</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">!=</span> <span class="nx">top</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="c1">// const emptyRest = 0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="c1">// 后面slot都没有数据
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="k">if</span> <span class="nx">b</span><span class="p">.</span><span class="nx">tophash</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">==</span> <span class="nx">emptyRest</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                    <span class="k">break</span> <span class="nx">search</span>
</span></span><span class="line"><span class="cl">                <span class="p">}</span>
</span></span><span class="line"><span class="cl">                <span class="k">continue</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">            
</span></span><span class="line"><span class="cl">            <span class="c1">// tophash比对成功; 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// 可能是【tophash冲突】 或 【匹配到了key】
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="nx">k</span> <span class="o">:=</span> <span class="nf">add</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">b</span><span class="p">),</span> <span class="nx">dataOffset</span><span class="o">+</span><span class="nx">i</span><span class="o">*</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">keysize</span><span class="p">))</span> <span class="c1">// key
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="nx">k2</span> <span class="o">:=</span> <span class="nx">k</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="nx">t</span><span class="p">.</span><span class="nf">indirectkey</span><span class="p">()</span> <span class="p">{</span>	<span class="c1">// 间接存储
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="nx">k2</span> <span class="p">=</span> <span class="o">*</span><span class="p">((</span><span class="o">*</span><span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">)(</span><span class="nx">k2</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 比对失败 tophash冲突
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// NaN 的 key 无法被删除
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="k">if</span> <span class="p">!</span><span class="nx">t</span><span class="p">.</span><span class="nx">key</span><span class="p">.</span><span class="nf">equal</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="nx">k2</span><span class="p">)</span> <span class="p">{</span>	
</span></span><span class="line"><span class="cl">                <span class="k">continue</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">            
</span></span><span class="line"><span class="cl">            <span class="c1">// key 比对成功
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            
</span></span><span class="line"><span class="cl">            <span class="c1">// Only clear key if there are pointers in it.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// 只有在 key 中有指针时才清除 key。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="k">if</span> <span class="nx">t</span><span class="p">.</span><span class="nf">indirectkey</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="c1">// 间接存储时
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">)(</span><span class="nx">k</span><span class="p">)</span> <span class="p">=</span> <span class="kc">nil</span> <span class="c1">// 清空key
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nx">t</span><span class="p">.</span><span class="nx">key</span><span class="p">.</span><span class="nx">ptrdata</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="c1">// key 中存在指针类型数据时
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="nf">memclrHasPointers</span><span class="p">(</span><span class="nx">k</span><span class="p">,</span> <span class="nx">t</span><span class="p">.</span><span class="nx">key</span><span class="p">.</span><span class="nx">size</span><span class="p">)</span> <span class="c1">// 清空key
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="nx">e</span> <span class="o">:=</span> <span class="nf">add</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">b</span><span class="p">),</span> <span class="nx">dataOffset</span><span class="o">+</span><span class="nx">bucketCnt</span><span class="o">*</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">keysize</span><span class="p">)</span><span class="o">+</span><span class="nx">i</span><span class="o">*</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">elemsize</span><span class="p">))</span> <span class="c1">// elem
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="k">if</span> <span class="nx">t</span><span class="p">.</span><span class="nf">indirectelem</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="c1">// 简介存储时
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">)(</span><span class="nx">e</span><span class="p">)</span> <span class="p">=</span> <span class="kc">nil</span> <span class="c1">// 清空elem
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nx">t</span><span class="p">.</span><span class="nx">elem</span><span class="p">.</span><span class="nx">ptrdata</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="c1">// elem 中存在指针类型数据时
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="nf">memclrHasPointers</span><span class="p">(</span><span class="nx">e</span><span class="p">,</span> <span class="nx">t</span><span class="p">.</span><span class="nx">elem</span><span class="p">.</span><span class="nx">size</span><span class="p">)</span> <span class="c1">// 清空elem
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="c1">// elem 中不存在指针类型数据时
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="nf">memclrNoHeapPointers</span><span class="p">(</span><span class="nx">e</span><span class="p">,</span> <span class="nx">t</span><span class="p">.</span><span class="nx">elem</span><span class="p">.</span><span class="nx">size</span><span class="p">)</span> <span class="c1">// 清空elem
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 标记 tophash 位为 1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="nx">b</span><span class="p">.</span><span class="nx">tophash</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nx">emptyOne</span> <span class="c1">// emptyOne == 1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// If the bucket now ends in a bunch of emptyOne states,
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// change those to emptyRest states.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// It would be nice to make this a separate function, but
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// for loops are not currently inlineable.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// 当前桶最后一个 key
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="k">if</span> <span class="nx">i</span> <span class="o">==</span> <span class="nx">bucketCnt</span><span class="o">-</span><span class="mi">1</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="k">if</span> <span class="nx">b</span><span class="p">.</span><span class="nf">overflow</span><span class="p">(</span><span class="nx">t</span><span class="p">)</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="nx">b</span><span class="p">.</span><span class="nf">overflow</span><span class="p">(</span><span class="nx">t</span><span class="p">).</span><span class="nx">tophash</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="nx">emptyRest</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                    <span class="c1">// 存在溢出桶并且后面还有数据，处理后续后直接返回。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                    <span class="c1">// 因为后面有数据不需要清楚已被删除的其他slot。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                    <span class="k">goto</span> <span class="nx">notLast</span>
</span></span><span class="line"><span class="cl">                <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="c1">// 后面一个tophash != 0; 后面还有数据
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="c1">// const emptyRest = 0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="k">if</span> <span class="nx">b</span><span class="p">.</span><span class="nx">tophash</span><span class="p">[</span><span class="nx">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="nx">emptyRest</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                    <span class="k">goto</span> <span class="nx">notLast</span>
</span></span><span class="line"><span class="cl">                <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">            
</span></span><span class="line"><span class="cl">            <span class="c1">// 后面没有数据了，需要向前遍历处理已经删除的slot
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="k">for</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="c1">// const emptyRest = 0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="c1">// 标记当前tophash为0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="nx">b</span><span class="p">.</span><span class="nx">tophash</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nx">emptyRest</span>	
</span></span><span class="line"><span class="cl">                <span class="c1">// 当前桶的第一个slot
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="k">if</span> <span class="nx">i</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                    <span class="k">if</span> <span class="nx">b</span> <span class="o">==</span> <span class="nx">bOrig</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                        <span class="c1">// 已经到最前的常规桶了
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                        <span class="k">break</span> <span class="c1">// beginning of initial bucket, we&#39;re done.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                    <span class="p">}</span>
</span></span><span class="line"><span class="cl">                    <span class="c1">// Find previous bucket, continue at its last entry.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                    <span class="nx">c</span> <span class="o">:=</span> <span class="nx">b</span>
</span></span><span class="line"><span class="cl">                    <span class="k">for</span> <span class="nx">b</span> <span class="p">=</span> <span class="nx">bOrig</span><span class="p">;</span> <span class="nx">b</span><span class="p">.</span><span class="nf">overflow</span><span class="p">(</span><span class="nx">t</span><span class="p">)</span> <span class="o">!=</span> <span class="nx">c</span><span class="p">;</span> <span class="nx">b</span> <span class="p">=</span> <span class="nx">b</span><span class="p">.</span><span class="nf">overflow</span><span class="p">(</span><span class="nx">t</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                    <span class="p">}</span>
</span></span><span class="line"><span class="cl">                    <span class="nx">i</span> <span class="p">=</span> <span class="nx">bucketCnt</span> <span class="o">-</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">                <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                    <span class="c1">// 向前回溯
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                    <span class="nx">i</span><span class="o">--</span>
</span></span><span class="line"><span class="cl">                <span class="p">}</span>
</span></span><span class="line"><span class="cl">                <span class="c1">// const emptyOne = 1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="c1">// 因为删除的空格全部标记为了1，因此!=1说明存在数据了直接退出
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="k">if</span> <span class="nx">b</span><span class="p">.</span><span class="nx">tophash</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">!=</span> <span class="nx">emptyOne</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                    <span class="k">break</span>
</span></span><span class="line"><span class="cl">                <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="nx">notLast</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// key/elem对数量减一
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="nx">h</span><span class="p">.</span><span class="nx">count</span><span class="o">--</span>	
</span></span><span class="line"><span class="cl">            <span class="c1">// Reset the hash seed to make it more difficult for attackers to
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// repeatedly trigger hash collisions. See issue 25237.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// 重置hash值，使攻击者更难触发hash碰撞。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="k">if</span> <span class="nx">h</span><span class="p">.</span><span class="nx">count</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="nx">h</span><span class="p">.</span><span class="nx">hash0</span> <span class="p">=</span> <span class="nf">fastrand</span><span class="p">()</span>    <span class="c1">// 重置hash0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="k">break</span> <span class="nx">search</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 并发判断
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nx">h</span><span class="p">.</span><span class="nx">flags</span><span class="o">&amp;</span><span class="nx">hashWriting</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>	
</span></span><span class="line"><span class="cl">        <span class="nf">fatal</span><span class="p">(</span><span class="s">&#34;concurrent map writes&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nx">h</span><span class="p">.</span><span class="nx">flags</span> <span class="o">&amp;^=</span> <span class="nx">hashWriting</span> <span class="c1">// 清除hashWriting标志位
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="len-">len() 🚀<a hidden class="anchor" aria-hidden="true" href="#len-">#</a></h2>
<h3 id="reflect_maplen">reflect_maplen()<a hidden class="anchor" aria-hidden="true" href="#reflect_maplen">#</a></h3>
<ol>
<li>len() 函数实现。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">//go:linkname reflect_maplen reflect.maplen
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">reflect_maplen</span><span class="p">(</span><span class="nx">h</span> <span class="o">*</span><span class="nx">hmap</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">h</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">raceenabled</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">callerpc</span> <span class="o">:=</span> <span class="nf">getcallerpc</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">        <span class="nf">racereadpc</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">h</span><span class="p">),</span> <span class="nx">callerpc</span><span class="p">,</span> <span class="nx">abi</span><span class="p">.</span><span class="nf">FuncPCABIInternal</span><span class="p">(</span><span class="nx">reflect_maplen</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 直接取值 hmap.count
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">return</span> <span class="nx">h</span><span class="p">.</span><span class="nx">count</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="迭代器-">迭代器 🚀<a hidden class="anchor" aria-hidden="true" href="#迭代器-">#</a></h2>
<h3 id="type-hiter-struct">type hiter struct<a hidden class="anchor" aria-hidden="true" href="#type-hiter-struct">#</a></h3>
<ol>
<li>hash 迭代器。</li>
<li>如果你修改了hiter，也要修改 cmd/compile/internal/reflectdata/reflect.go 和 reflect/value.go 来匹配这个结构的布局。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// A hash iteration structure.
</span></span></span><span class="line"><span class="cl"><span class="c1">// If you modify hiter, also change cmd/compile/internal/reflectdata/reflect.go
</span></span></span><span class="line"><span class="cl"><span class="c1">// and reflect/value.go to match the layout of this structure.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">type</span> <span class="nx">hiter</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 必须在第一位置。写入nil来表示迭代结束(参见cmd/compile/internal/walk/range.go)。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">key</span>         <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span> <span class="c1">// Must be in first position.  Write nil to indicate iteration end (see cmd/compile/internal/walk/range.go).
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 必须在第二位置(参见cmd/compile/internal/walk/range.go)。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">elem</span>        <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span> <span class="c1">// Must be in second position (see cmd/compile/internal/walk/range.go).
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// map类型结构
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">t</span>           <span class="o">*</span><span class="nx">maptype</span>	
</span></span><span class="line"><span class="cl">    <span class="c1">// map内存结构
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">h</span>           <span class="o">*</span><span class="nx">hmap</span>	
</span></span><span class="line"><span class="cl">    <span class="c1">// 常规桶地址
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">buckets</span>     <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span> <span class="c1">// bucket ptr at hash_iter initialization time
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 正在迭代的桶，如果bptr == nil则从bucket获取桶号迭代
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">bptr</span>        <span class="o">*</span><span class="nx">bmap</span>          <span class="c1">// current bucket
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">overflow</span>    <span class="o">*</span><span class="p">[]</span><span class="o">*</span><span class="nx">bmap</span>       <span class="c1">// keeps overflow buckets of hmap.buckets alive
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">oldoverflow</span> <span class="o">*</span><span class="p">[]</span><span class="o">*</span><span class="nx">bmap</span>       <span class="c1">// keeps overflow buckets of hmap.oldbuckets alive
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 开始遍历的桶号，随机的，用于开始遍历的起点以及结束遍历的终点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">startBucket</span> <span class="kt">uintptr</span>        <span class="c1">// bucket iteration started at
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// tophash偏移值，在[0,7]中随机生成的值，用于后续 i + offset &amp; 7 用作偏移量
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">offset</span>      <span class="kt">uint8</span>          <span class="c1">// intra-bucket offset to start from during iteration (should be big enough to hold bucketCnt-1)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 当前遍历已过最大桶(1 &lt;&lt; B)时被设置为true
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">wrapped</span>     <span class="kt">bool</span>           <span class="c1">// already wrapped around from end of bucket array to beginning
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">B</span>           <span class="kt">uint8</span>   <span class="c1">// 初始化时桶的数量 1 &lt;&lt; B
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 当前桶遍历的索引，默认值从0开始，该值配合offset遍历tophash，i + offset &amp; 7
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">i</span>           <span class="kt">uint8</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 初始化时是startBucket的值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//   1. bptr == nil时bucket存储需要遍历的桶号
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//   2. bptr != nil时bucket下个桶的桶号
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">bucket</span>      <span class="kt">uintptr</span> <span class="c1">// 下个迭代器迭代的桶号
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">checkBucket</span> <span class="kt">uintptr</span> <span class="c1">// 需要检查的桶号
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="初始化迭代器">初始化迭代器<a hidden class="anchor" aria-hidden="true" href="#初始化迭代器">#</a></h3>
<h4 id="mapiterinit">mapiterinit()<a hidden class="anchor" aria-hidden="true" href="#mapiterinit">#</a></h4>
<ol>
<li><code>mapiterinit()</code> 初始化用于在 <code>map</code> 上进行范围搜索的 <code>hiter</code> 结构体。</li>
<li><code>'it'</code>指向的<code>hiter</code>结构体由编译器<code>order pass</code>分配到栈上，或由<code>reflect_mapiterinit</code>分配到堆上。</li>
<li>两者都需要将<code>hiter</code>置零，因为该结构体包含指针。</li>
<li>参数：
<ul>
<li><code>t *maptype</code>：map 类型结构。</li>
<li><code>h *hmap</code>：map 内存结构。</li>
<li><code>it *hiter</code>：遍历器存储的结构。</li>
</ul>
</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// mapiterinit initializes the hiter struct used for ranging over maps.
</span></span></span><span class="line"><span class="cl"><span class="c1">// The hiter struct pointed to by &#39;it&#39; is allocated on the stack
</span></span></span><span class="line"><span class="cl"><span class="c1">// by the compilers order pass or on the heap by reflect_mapiterinit.
</span></span></span><span class="line"><span class="cl"><span class="c1">// Both need to have zeroed hiter since the struct contains pointers.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">mapiterinit</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">maptype</span><span class="p">,</span> <span class="nx">h</span> <span class="o">*</span><span class="nx">hmap</span><span class="p">,</span> <span class="nx">it</span> <span class="o">*</span><span class="nx">hiter</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">raceenabled</span> <span class="o">&amp;&amp;</span> <span class="nx">h</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">callerpc</span> <span class="o">:=</span> <span class="nf">getcallerpc</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">        <span class="nf">racereadpc</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">h</span><span class="p">),</span> <span class="nx">callerpc</span><span class="p">,</span> <span class="nx">abi</span><span class="p">.</span><span class="nf">FuncPCABIInternal</span><span class="p">(</span><span class="nx">mapiterinit</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nx">it</span><span class="p">.</span><span class="nx">t</span> <span class="p">=</span> <span class="nx">t</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 1) 未初始化的map 或 key/elem对为空的map
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nx">h</span> <span class="o">==</span> <span class="kc">nil</span> <span class="o">||</span> <span class="nx">h</span><span class="p">.</span><span class="nx">count</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Sizeof</span><span class="p">(</span><span class="nx">hiter</span><span class="p">{})</span><span class="o">/</span><span class="nx">goarch</span><span class="p">.</span><span class="nx">PtrSize</span> <span class="o">!=</span> <span class="mi">12</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">throw</span><span class="p">(</span><span class="s">&#34;hash_iter size incorrect&#34;</span><span class="p">)</span> <span class="c1">// see cmd/compile/internal/reflectdata/reflect.go
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nx">it</span><span class="p">.</span><span class="nx">h</span> <span class="p">=</span> <span class="nx">h</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// grab snapshot of bucket state
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>       <span class="c1">// 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 2) 抓取桶状态快照
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">it</span><span class="p">.</span><span class="nx">B</span> <span class="p">=</span> <span class="nx">h</span><span class="p">.</span><span class="nx">B</span>
</span></span><span class="line"><span class="cl">    <span class="nx">it</span><span class="p">.</span><span class="nx">buckets</span> <span class="p">=</span> <span class="nx">h</span><span class="p">.</span><span class="nx">buckets</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">t</span><span class="p">.</span><span class="nx">bucket</span><span class="p">.</span><span class="nx">ptrdata</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// Allocate the current slice and remember pointers to both current and old.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// This preserves all relevant overflow buckets alive even if
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// the table grows and/or overflow buckets are added to the table
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// while we are iterating.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 分配当前切片并记住指向当前和旧切片的指针。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 这使得所有相关的溢出桶都保持活跃，即使表增长，and/or 在迭代时溢出桶被添加到表中。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">h</span><span class="p">.</span><span class="nf">createOverflow</span><span class="p">()</span>	<span class="c1">// 判断h.extra是否初始化
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">it</span><span class="p">.</span><span class="nx">overflow</span> <span class="p">=</span> <span class="nx">h</span><span class="p">.</span><span class="nx">extra</span><span class="p">.</span><span class="nx">overflow</span>
</span></span><span class="line"><span class="cl">        <span class="nx">it</span><span class="p">.</span><span class="nx">oldoverflow</span> <span class="p">=</span> <span class="nx">h</span><span class="p">.</span><span class="nx">extra</span><span class="p">.</span><span class="nx">oldoverflow</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// decide where to start
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 3) 决定从哪里开始
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kd">var</span> <span class="nx">r</span> <span class="kt">uintptr</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">h</span><span class="p">.</span><span class="nx">B</span> <span class="p">&gt;</span> <span class="mi">31</span><span class="o">-</span><span class="nx">bucketCntBits</span> <span class="p">{</span>	<span class="c1">// h.B &gt; 31 - 3
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">r</span> <span class="p">=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nf">fastrand64</span><span class="p">())</span>   <span class="c1">// uint64
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">r</span> <span class="p">=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nf">fastrand</span><span class="p">())</span> <span class="c1">// uint32
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 4) 用于确定从那个桶开始遍历
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">it</span><span class="p">.</span><span class="nx">startBucket</span> <span class="p">=</span> <span class="nx">r</span> <span class="o">&amp;</span> <span class="nf">bucketMask</span><span class="p">(</span><span class="nx">h</span><span class="p">.</span><span class="nx">B</span><span class="p">)</span>    <span class="c1">// 随机数确定开始的桶号
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 5) 用于确定在每个桶的随机偏移量
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">it</span><span class="p">.</span><span class="nx">offset</span> <span class="p">=</span> <span class="nb">uint8</span><span class="p">(</span><span class="nx">r</span> <span class="o">&gt;&gt;</span> <span class="nx">h</span><span class="p">.</span><span class="nx">B</span> <span class="o">&amp;</span> <span class="p">(</span><span class="nx">bucketCnt</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>   <span class="c1">// 随机的偏移量[0,7]中随机数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="c1">// iterator state
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">it</span><span class="p">.</span><span class="nx">bucket</span> <span class="p">=</span> <span class="nx">it</span><span class="p">.</span><span class="nx">startBucket</span>	<span class="c1">// 当前迭代桶号
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Remember we have an iterator.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// Can run concurrently with another mapiterinit().
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 6) 记住我们有一个迭代器。可以与另一个mapiterinit()并发运行。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nx">old</span> <span class="o">:=</span> <span class="nx">h</span><span class="p">.</span><span class="nx">flags</span><span class="p">;</span> <span class="nx">old</span><span class="o">&amp;</span><span class="p">(</span><span class="nx">iterator</span><span class="p">|</span><span class="nx">oldIterator</span><span class="p">)</span> <span class="o">!=</span> <span class="nx">iterator</span><span class="p">|</span><span class="nx">oldIterator</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">atomic</span><span class="p">.</span><span class="nf">Or8</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">h</span><span class="p">.</span><span class="nx">flags</span><span class="p">,</span> <span class="nx">iterator</span><span class="p">|</span><span class="nx">oldIterator</span><span class="p">)</span>  <span class="c1">// 设置迭代标志 iterator和oldIterator
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nf">mapiternext</span><span class="p">(</span><span class="nx">it</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="迭代">迭代<a hidden class="anchor" aria-hidden="true" href="#迭代">#</a></h3>
<h4 id="mapiternext">mapiternext()<a hidden class="anchor" aria-hidden="true" href="#mapiternext">#</a></h4>
<ol>
<li>扩容发生在迭代器之前，此时应该去变量扩容后的所有桶，都是从旧桶出发。这种情况旧桶里面可能没key/elem以及overflow信息。</li>
<li>扩容发生在迭代器之后，此时应该遍历所有的旧桶数量，从旧桶出发。这种情况旧桶保留了所有的key/elem以及overflow信息。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span><span class="lnt">113
</span><span class="lnt">114
</span><span class="lnt">115
</span><span class="lnt">116
</span><span class="lnt">117
</span><span class="lnt">118
</span><span class="lnt">119
</span><span class="lnt">120
</span><span class="lnt">121
</span><span class="lnt">122
</span><span class="lnt">123
</span><span class="lnt">124
</span><span class="lnt">125
</span><span class="lnt">126
</span><span class="lnt">127
</span><span class="lnt">128
</span><span class="lnt">129
</span><span class="lnt">130
</span><span class="lnt">131
</span><span class="lnt">132
</span><span class="lnt">133
</span><span class="lnt">134
</span><span class="lnt">135
</span><span class="lnt">136
</span><span class="lnt">137
</span><span class="lnt">138
</span><span class="lnt">139
</span><span class="lnt">140
</span><span class="lnt">141
</span><span class="lnt">142
</span><span class="lnt">143
</span><span class="lnt">144
</span><span class="lnt">145
</span><span class="lnt">146
</span><span class="lnt">147
</span><span class="lnt">148
</span><span class="lnt">149
</span><span class="lnt">150
</span><span class="lnt">151
</span><span class="lnt">152
</span><span class="lnt">153
</span><span class="lnt">154
</span><span class="lnt">155
</span><span class="lnt">156
</span><span class="lnt">157
</span><span class="lnt">158
</span><span class="lnt">159
</span><span class="lnt">160
</span><span class="lnt">161
</span><span class="lnt">162
</span><span class="lnt">163
</span><span class="lnt">164
</span><span class="lnt">165
</span><span class="lnt">166
</span><span class="lnt">167
</span><span class="lnt">168
</span><span class="lnt">169
</span><span class="lnt">170
</span><span class="lnt">171
</span><span class="lnt">172
</span><span class="lnt">173
</span><span class="lnt">174
</span><span class="lnt">175
</span><span class="lnt">176
</span><span class="lnt">177
</span><span class="lnt">178
</span><span class="lnt">179
</span><span class="lnt">180
</span><span class="lnt">181
</span><span class="lnt">182
</span><span class="lnt">183
</span><span class="lnt">184
</span><span class="lnt">185
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">mapiternext</span><span class="p">(</span><span class="nx">it</span> <span class="o">*</span><span class="nx">hiter</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">h</span> <span class="o">:=</span> <span class="nx">it</span><span class="p">.</span><span class="nx">h</span>	<span class="c1">// *hmap
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nx">raceenabled</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">callerpc</span> <span class="o">:=</span> <span class="nf">getcallerpc</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">        <span class="nf">racereadpc</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">h</span><span class="p">),</span> <span class="nx">callerpc</span><span class="p">,</span> <span class="nx">abi</span><span class="p">.</span><span class="nf">FuncPCABIInternal</span><span class="p">(</span><span class="nx">mapiternext</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">h</span><span class="p">.</span><span class="nx">flags</span><span class="o">&amp;</span><span class="nx">hashWriting</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">fatal</span><span class="p">(</span><span class="s">&#34;concurrent map iteration and map write&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nx">t</span> <span class="o">:=</span> <span class="nx">it</span><span class="p">.</span><span class="nx">t</span>   <span class="c1">// *maptype
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">bucket</span> <span class="o">:=</span> <span class="nx">it</span><span class="p">.</span><span class="nx">bucket</span>	<span class="c1">// 需要迭代桶号
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">b</span> <span class="o">:=</span> <span class="nx">it</span><span class="p">.</span><span class="nx">bptr</span>    <span class="c1">// 当前正在迭代的桶 *bmap
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">i</span> <span class="o">:=</span> <span class="nx">it</span><span class="p">.</span><span class="nx">i</span>   <span class="c1">// 当前遍历bptr桶的索引
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">checkBucket</span> <span class="o">:=</span> <span class="nx">it</span><span class="p">.</span><span class="nx">checkBucket</span>   <span class="c1">// 需要检查的桶
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="nx">next</span><span class="p">:</span>	
</span></span><span class="line"><span class="cl">    <span class="c1">// 根据bucket获取*bmap
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nx">b</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>	
</span></span><span class="line"><span class="cl">        <span class="c1">// map遍历完了
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="nx">bucket</span> <span class="o">==</span> <span class="nx">it</span><span class="p">.</span><span class="nx">startBucket</span> <span class="o">&amp;&amp;</span> <span class="nx">it</span><span class="p">.</span><span class="nx">wrapped</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// end of iteration
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// 结束迭代器
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="nx">it</span><span class="p">.</span><span class="nx">key</span> <span class="p">=</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl">            <span class="nx">it</span><span class="p">.</span><span class="nx">elem</span> <span class="p">=</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// h.growing()：正在扩容中
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// it.B == h.B：扩容发生在迭代器之前，迭代器开始时已经在进行扩容了
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">//  1. 这种情况可能发生部分数据还在旧桶里面，也可能在新桶里面
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 	2. 随着扩容在进行中，可能出现部分数据在旧桶部分数据在新桶
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="nx">h</span><span class="p">.</span><span class="nf">growing</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="nx">it</span><span class="p">.</span><span class="nx">B</span> <span class="o">==</span> <span class="nx">h</span><span class="p">.</span><span class="nx">B</span> <span class="p">{</span>	<span class="c1">// 数据可能在旧桶里面，可能在新桶里
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// Iterator was started in the middle of a grow, and the grow isn&#39;t done yet.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// If the bucket we&#39;re looking at hasn&#39;t been filled in yet (i.e. the old
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// bucket hasn&#39;t been evacuated) then we need to iterate through the old
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// bucket and only return the ones that will be migrated to this bucket.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// 迭代器是在扩容过程进行中启动的，而且扩容还没有完成
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// 如果我们查看的桶还没有被填充（即旧桶还没有被清空），那么我们需要迭代旧桶，并只返回将要迁移到此桶的那些。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="nx">oldbucket</span> <span class="o">:=</span> <span class="nx">bucket</span> <span class="o">&amp;</span> <span class="nx">it</span><span class="p">.</span><span class="nx">h</span><span class="p">.</span><span class="nf">oldbucketmask</span><span class="p">()</span>  <span class="c1">// 旧桶编号
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="nx">b</span> <span class="p">=</span> <span class="p">(</span><span class="o">*</span><span class="nx">bmap</span><span class="p">)(</span><span class="nf">add</span><span class="p">(</span><span class="nx">h</span><span class="p">.</span><span class="nx">oldbuckets</span><span class="p">,</span> <span class="nx">oldbucket</span><span class="o">*</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">bucketsize</span><span class="p">)))</span>	<span class="c1">// 旧桶 *bmap
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// 其实这种情况一直是在检查旧桶，旧桶数据有没被迁移迁移到哪里了
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="k">if</span> <span class="p">!</span><span class="nf">evacuated</span><span class="p">(</span><span class="nx">b</span><span class="p">)</span> <span class="p">{</span>  <span class="c1">// 旧桶有数据，可能下面数据被迁移到新桶了
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="c1">// 需要检查新桶的桶好，因此新桶旧桶都要查看
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="nx">checkBucket</span> <span class="p">=</span> <span class="nx">bucket</span>	
</span></span><span class="line"><span class="cl">            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="c1">// 如果旧桶没有数据则说明数据一定在新桶
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="nx">b</span> <span class="p">=</span> <span class="p">(</span><span class="o">*</span><span class="nx">bmap</span><span class="p">)(</span><span class="nf">add</span><span class="p">(</span><span class="nx">it</span><span class="p">.</span><span class="nx">buckets</span><span class="p">,</span> <span class="nx">bucket</span><span class="o">*</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">bucketsize</span><span class="p">)))</span>  <span class="c1">// 新桶 *bmap
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="c1">// 因此不需要再检查其他的桶了
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="nx">checkBucket</span> <span class="p">=</span> <span class="nx">noCheck</span> 
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// !h.growing() || h.growing() &amp;&amp; it.B != h.B
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">//  1. !h.growing(): (没有扩容)数据在b桶里，遍历b桶即可。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">//  2. h.growing() &amp;&amp; it.B != h.B; (扩容发生在迭代之后)可能b桶被迁移了但是b桶仍然保持着key/elem;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">//  (2)这种情况我们为什么不能直接拿去b桶的elem，因为可能key又被删除或更新了需要查看新数据
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// 这里可以看出迭代数据时是按照保存快照的数据为准的。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="nx">b</span> <span class="p">=</span> <span class="p">(</span><span class="o">*</span><span class="nx">bmap</span><span class="p">)(</span><span class="nf">add</span><span class="p">(</span><span class="nx">it</span><span class="p">.</span><span class="nx">buckets</span><span class="p">,</span> <span class="nx">bucket</span><span class="o">*</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">bucketsize</span><span class="p">)))</span>
</span></span><span class="line"><span class="cl">            <span class="nx">checkBucket</span> <span class="p">=</span> <span class="nx">noCheck</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="nx">bucket</span><span class="o">++</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 迭代过了最大桶号
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">//  1. 扩容发生在迭代之前，需要遍历所有扩容后的桶数量，被疏散的key/elem不管
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">//  2. 扩容发生在迭代之后，则只会迭代旧桶数量，被疏散的key/elem去新桶里面找
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="nx">bucket</span> <span class="o">==</span> <span class="nf">bucketShift</span><span class="p">(</span><span class="nx">it</span><span class="p">.</span><span class="nx">B</span><span class="p">)</span> <span class="p">{</span>    <span class="c1">// bucket == 1 &lt;&lt; B
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="nx">bucket</span> <span class="p">=</span> <span class="mi">0</span>	<span class="c1">// 桶号重置为0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="nx">it</span><span class="p">.</span><span class="nx">wrapped</span> <span class="p">=</span> <span class="kc">true</span>   <span class="c1">// 标记wrapped已过最大桶号
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="nx">i</span> <span class="p">=</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 迭代桶
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">for</span> <span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">bucketCnt</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">offi</span> <span class="o">:=</span> <span class="p">(</span><span class="nx">i</span> <span class="o">+</span> <span class="nx">it</span><span class="p">.</span><span class="nx">offset</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="nx">bucketCnt</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// tophash[offi] &lt;= 1 || tophash[offi] == 4
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 当前slot处没有数据，因为一直遍历的是旧桶b，如果是下面这两种条件直接跳过即可
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="nf">isEmpty</span><span class="p">(</span><span class="nx">b</span><span class="p">.</span><span class="nx">tophash</span><span class="p">[</span><span class="nx">offi</span><span class="p">])</span> <span class="o">||</span> <span class="nx">b</span><span class="p">.</span><span class="nx">tophash</span><span class="p">[</span><span class="nx">offi</span><span class="p">]</span> <span class="o">==</span> <span class="nx">evacuatedEmpty</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// TODO: emptyRest is hard to use here, as we start iterating
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// in the middle of a bucket. It&#39;s feasible, just tricky.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="k">continue</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="nx">k</span> <span class="o">:=</span> <span class="nf">add</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">b</span><span class="p">),</span> <span class="nx">dataOffset</span><span class="o">+</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">offi</span><span class="p">)</span><span class="o">*</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">keysize</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="nx">t</span><span class="p">.</span><span class="nf">indirectkey</span><span class="p">()</span> <span class="p">{</span>    <span class="c1">// 间接存储
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="nx">k</span> <span class="p">=</span> <span class="o">*</span><span class="p">((</span><span class="o">*</span><span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">)(</span><span class="nx">k</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="nx">e</span> <span class="o">:=</span> <span class="nf">add</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">b</span><span class="p">),</span> <span class="nx">dataOffset</span><span class="o">+</span><span class="nx">bucketCnt</span><span class="o">*</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">keysize</span><span class="p">)</span><span class="o">+</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">offi</span><span class="p">)</span><span class="o">*</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">elemsize</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 扩容发生在迭代器之前; 翻倍扩容才需要检查旧桶
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// checkBucket != noCheck：有需要特殊检查的桶
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// !h.sameSizeGrow()：当前是翻倍扩容
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="nx">checkBucket</span> <span class="o">!=</span> <span class="nx">noCheck</span> <span class="o">&amp;&amp;</span> <span class="p">!</span><span class="nx">h</span><span class="p">.</span><span class="nf">sameSizeGrow</span><span class="p">()</span> <span class="p">{</span>	
</span></span><span class="line"><span class="cl">            <span class="c1">// Special case: iterator was started during a grow to a larger size
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// and the grow is not done yet. We&#39;re working on a bucket whose
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// oldbucket has not been evacuated yet. Or at least, it wasn&#39;t
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// evacuated when we started the bucket. So we&#39;re iterating
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// through the oldbucket, skipping any keys that will go
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// to the other new bucket (each oldbucket expands to two
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// buckets during a grow).
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// 特殊情况:迭代器在增长到更大的尺寸期间启动，但增长还没有完成。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// 我们正在处理一个桶，它的旧桶还没有被清空。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// 至少，我们启动水桶时还没人撤离。因此，我们遍历oldbucket，跳过所有将进入另一个新桶的键(每个oldbucket在增长过程中会扩展到两个桶)。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// k == k 成立，这种请款出现在 +0和-0虽然相等但是生成的hash确实不相同
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="k">if</span> <span class="nx">t</span><span class="p">.</span><span class="nf">reflexivekey</span><span class="p">()</span> <span class="o">||</span> <span class="nx">t</span><span class="p">.</span><span class="nx">key</span><span class="p">.</span><span class="nf">equal</span><span class="p">(</span><span class="nx">k</span><span class="p">,</span> <span class="nx">k</span><span class="p">)</span> <span class="p">{</span>	
</span></span><span class="line"><span class="cl">                <span class="c1">// If the item in the oldbucket is not destined for
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="c1">// the current new bucket in the iteration, skip it.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="c1">// 如果旧桶中的项在迭代中不是为当前的新桶指定的，则跳过它。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="nx">hash</span> <span class="o">:=</span> <span class="nx">t</span><span class="p">.</span><span class="nf">hasher</span><span class="p">(</span><span class="nx">k</span><span class="p">,</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">h</span><span class="p">.</span><span class="nx">hash0</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">                <span class="c1">// hash&amp;bucketMask(it.B) != checkBucket; 表示当前key/elem不应该在checkBucket桶中
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="c1">// 则跳过后续到，后续会去找这种情况
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="k">if</span> <span class="nx">hash</span><span class="o">&amp;</span><span class="nf">bucketMask</span><span class="p">(</span><span class="nx">it</span><span class="p">.</span><span class="nx">B</span><span class="p">)</span> <span class="o">!=</span> <span class="nx">checkBucket</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                    <span class="k">continue</span>
</span></span><span class="line"><span class="cl">                <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="c1">// Hash isn&#39;t repeatable if k != k (NaNs).  We need a
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="c1">// repeatable and randomish choice of which direction
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="c1">// to send NaNs during evacuation. We&#39;ll use the low
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="c1">// bit of tophash to decide which way NaNs go.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="c1">// NOTE: this case is why we need two evacuate tophash
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="c1">// values, evacuatedX and evacuatedY, that differ in
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="c1">// their low bit.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="c1">// 如果 k != k (NaNs)，则 hash 是不可重复的。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="c1">// 在疏散过程中，我们需要一个可重复且随机的选择将NaNs派往哪个方向。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="c1">// 我们将使用tophash的低位来决定NaNs的方向。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="c1">// 注意:在这种情况下，我们需要两个疏散tophash值evacuatedX和evacuatedY，它们的低位不同。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="k">if</span> <span class="nx">checkBucket</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="nx">it</span><span class="p">.</span><span class="nx">B</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">b</span><span class="p">.</span><span class="nx">tophash</span><span class="p">[</span><span class="nx">offi</span><span class="p">]</span><span class="o">&amp;</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                    <span class="k">continue</span>	<span class="c1">// 疏散的不是当前桶则跳过后续会去查找
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">        <span class="c1">// const evacuatedX = 2
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// const evacuatedY = 3
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// tophash[offi] != 2或3 || k != k
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// tophash[offi] != 2或3; 存在数据
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// k != k：NaN 情况
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="nx">b</span><span class="p">.</span><span class="nx">tophash</span><span class="p">[</span><span class="nx">offi</span><span class="p">]</span> <span class="o">!=</span> <span class="nx">evacuatedX</span> <span class="o">&amp;&amp;</span> <span class="nx">b</span><span class="p">.</span><span class="nx">tophash</span><span class="p">[</span><span class="nx">offi</span><span class="p">]</span> <span class="o">!=</span> <span class="nx">evacuatedY</span><span class="p">)</span> <span class="o">||</span>
</span></span><span class="line"><span class="cl">            <span class="p">!(</span><span class="nx">t</span><span class="p">.</span><span class="nf">reflexivekey</span><span class="p">()</span> <span class="o">||</span> <span class="nx">t</span><span class="p">.</span><span class="nx">key</span><span class="p">.</span><span class="nf">equal</span><span class="p">(</span><span class="nx">k</span><span class="p">,</span> <span class="nx">k</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// This is the golden data, we can return it.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// OR
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// key!=key, so the entry can&#39;t be deleted or updated, so we can just return it.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// That&#39;s lucky for us because when key!=key we can&#39;t look it up successfully.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// 这是黄金数据，我们可以返回它。或 key!=key，因此entry不能被删除或更新，因此我们可以直接返回它。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// 这对我们来说是幸运的，因为当 key!=key 无法成功查找时。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="nx">it</span><span class="p">.</span><span class="nx">key</span> <span class="p">=</span> <span class="nx">k</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="nx">t</span><span class="p">.</span><span class="nf">indirectelem</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="nx">e</span> <span class="p">=</span> <span class="o">*</span><span class="p">((</span><span class="o">*</span><span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">)(</span><span class="nx">e</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="nx">it</span><span class="p">.</span><span class="nx">elem</span> <span class="p">=</span> <span class="nx">e</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>	<span class="c1">// tophash[offi] == 2或3；数据被迁移了
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// The hash table has grown since the iterator was started.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// The golden data for this key is now somewhere else.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// Check the current hash table for the data.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// This code handles the case where the key
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// has been deleted, updated, or deleted and reinserted.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// NOTE: we need to regrab the key as it has potentially been
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// updated to an equal() but not identical key (e.g. +0.0 vs -0.0).
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// 自迭代器启动以来，散列表一直在增长。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// 这个密钥的黄金数据现在在其他地方。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// 检查当前散列表中的数据。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// 这段代码处理键被删除、更新或删除并重新插入的情况。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// 注意:我们需要重新获取密钥，因为它可能已经更新到equal()，但key不相同(例如+0.0 vs -0.0)。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="nx">rk</span><span class="p">,</span> <span class="nx">re</span> <span class="o">:=</span> <span class="nf">mapaccessK</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">h</span><span class="p">,</span> <span class="nx">k</span><span class="p">)</span>   <span class="c1">// 根据k查找数据
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="k">if</span> <span class="nx">rk</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="k">continue</span> <span class="c1">// key has been deleted
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="nx">it</span><span class="p">.</span><span class="nx">key</span> <span class="p">=</span> <span class="nx">rk</span>
</span></span><span class="line"><span class="cl">            <span class="nx">it</span><span class="p">.</span><span class="nx">elem</span> <span class="p">=</span> <span class="nx">re</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="nx">it</span><span class="p">.</span><span class="nx">bucket</span> <span class="p">=</span> <span class="nx">bucket</span>  <span class="c1">// 记录当前正在迭代的桶号
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="nx">it</span><span class="p">.</span><span class="nx">bptr</span> <span class="o">!=</span> <span class="nx">b</span> <span class="p">{</span> <span class="c1">// avoid unnecessary write barrier; see issue 14921
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="nx">it</span><span class="p">.</span><span class="nx">bptr</span> <span class="p">=</span> <span class="nx">b</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="nx">it</span><span class="p">.</span><span class="nx">i</span> <span class="p">=</span> <span class="nx">i</span> <span class="o">+</span> <span class="mi">1</span>    <span class="c1">// 下次需要迭代的tophash索引
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">it</span><span class="p">.</span><span class="nx">checkBucket</span> <span class="p">=</span> <span class="nx">checkBucket</span>    <span class="c1">// 需要检查的桶号
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">return</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c1">// 迭代b桶的溢出桶
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">b</span> <span class="p">=</span> <span class="nx">b</span><span class="p">.</span><span class="nf">overflow</span><span class="p">(</span><span class="nx">t</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nx">i</span> <span class="p">=</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">    <span class="k">goto</span> <span class="nx">next</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="mapaccessk">mapaccessK()<a hidden class="anchor" aria-hidden="true" href="#mapaccessk">#</a></h4>
<ol>
<li>同时返回key和elem。由map迭代器使用</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// returns both key and elem. Used by map iterator
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">mapaccessK</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">maptype</span><span class="p">,</span> <span class="nx">h</span> <span class="o">*</span><span class="nx">hmap</span><span class="p">,</span> <span class="nx">key</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">)</span> <span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">,</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">h</span> <span class="o">==</span> <span class="kc">nil</span> <span class="o">||</span> <span class="nx">h</span><span class="p">.</span><span class="nx">count</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nx">hash</span> <span class="o">:=</span> <span class="nx">t</span><span class="p">.</span><span class="nf">hasher</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">h</span><span class="p">.</span><span class="nx">hash0</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">    <span class="nx">m</span> <span class="o">:=</span> <span class="nf">bucketMask</span><span class="p">(</span><span class="nx">h</span><span class="p">.</span><span class="nx">B</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nx">b</span> <span class="o">:=</span> <span class="p">(</span><span class="o">*</span><span class="nx">bmap</span><span class="p">)(</span><span class="nf">add</span><span class="p">(</span><span class="nx">h</span><span class="p">.</span><span class="nx">buckets</span><span class="p">,</span> <span class="p">(</span><span class="nx">hash</span><span class="o">&amp;</span><span class="nx">m</span><span class="p">)</span><span class="o">*</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">bucketsize</span><span class="p">)))</span>    <span class="c1">// *bmap
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nx">c</span> <span class="o">:=</span> <span class="nx">h</span><span class="p">.</span><span class="nx">oldbuckets</span><span class="p">;</span> <span class="nx">c</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>    <span class="c1">// 正处于扩容状态
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="p">!</span><span class="nx">h</span><span class="p">.</span><span class="nf">sameSizeGrow</span><span class="p">()</span> <span class="p">{</span>  <span class="c1">// 翻倍扩容
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// There used to be half as many buckets; mask down one more power of two.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="nx">m</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="nx">oldb</span> <span class="o">:=</span> <span class="p">(</span><span class="o">*</span><span class="nx">bmap</span><span class="p">)(</span><span class="nf">add</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="p">(</span><span class="nx">hash</span><span class="o">&amp;</span><span class="nx">m</span><span class="p">)</span><span class="o">*</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">bucketsize</span><span class="p">)))</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">!</span><span class="nf">evacuated</span><span class="p">(</span><span class="nx">oldb</span><span class="p">)</span> <span class="p">{</span>   <span class="c1">// 查看旧桶是否有数据
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="nx">b</span> <span class="p">=</span> <span class="nx">oldb</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nx">top</span> <span class="o">:=</span> <span class="nf">tophash</span><span class="p">(</span><span class="nx">hash</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nx">bucketloop</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">;</span> <span class="nx">b</span> <span class="o">!=</span> <span class="kc">nil</span><span class="p">;</span> <span class="nx">b</span> <span class="p">=</span> <span class="nx">b</span><span class="p">.</span><span class="nf">overflow</span><span class="p">(</span><span class="nx">t</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">bucketCnt</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="nx">b</span><span class="p">.</span><span class="nx">tophash</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">!=</span> <span class="nx">top</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="k">if</span> <span class="nx">b</span><span class="p">.</span><span class="nx">tophash</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">==</span> <span class="nx">emptyRest</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                    <span class="k">break</span> <span class="nx">bucketloop</span>
</span></span><span class="line"><span class="cl">                <span class="p">}</span>
</span></span><span class="line"><span class="cl">                <span class="k">continue</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="nx">k</span> <span class="o">:=</span> <span class="nf">add</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">b</span><span class="p">),</span> <span class="nx">dataOffset</span><span class="o">+</span><span class="nx">i</span><span class="o">*</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">keysize</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="nx">t</span><span class="p">.</span><span class="nf">indirectkey</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="nx">k</span> <span class="p">=</span> <span class="o">*</span><span class="p">((</span><span class="o">*</span><span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">)(</span><span class="nx">k</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="nx">t</span><span class="p">.</span><span class="nx">key</span><span class="p">.</span><span class="nf">equal</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="nx">k</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="nx">e</span> <span class="o">:=</span> <span class="nf">add</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">b</span><span class="p">),</span> <span class="nx">dataOffset</span><span class="o">+</span><span class="nx">bucketCnt</span><span class="o">*</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">keysize</span><span class="p">)</span><span class="o">+</span><span class="nx">i</span><span class="o">*</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">elemsize</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">                <span class="k">if</span> <span class="nx">t</span><span class="p">.</span><span class="nf">indirectelem</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                    <span class="nx">e</span> <span class="p">=</span> <span class="o">*</span><span class="p">((</span><span class="o">*</span><span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">)(</span><span class="nx">e</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">                <span class="p">}</span>
</span></span><span class="line"><span class="cl">                <span class="k">return</span> <span class="nx">k</span><span class="p">,</span> <span class="nx">e</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="不能作为map-key类型">不能作为map key类型<a hidden class="anchor" aria-hidden="true" href="#不能作为map-key类型">#</a></h2>
<h3 id="官方解释">官方解释<a hidden class="anchor" aria-hidden="true" href="#官方解释">#</a></h3>
<ol>
<li><code>map</code>的键可以是任何<strong>可比较</strong>的类型。</li>
<li>语言规范精确地定义了这一点，简而言之，可比类型是<code>boolean</code>, <code>numeric</code>, <code>string</code>, <code>pointer</code>, <code>channel</code>, and <code>interface</code>类型，以及只包含这些类型的结构体或数组。</li>
<li>值得注意的是，列表中没有【<code>slices</code>】,【 <code>maps</code>】, and 【<code>functions</code>】; 这些类型不能使用<code>==</code>进行比较，也不能用作映射键。</li>
<li>但是<code>slice</code>、<code>map</code>、<code>function</code>能与<code>nil</code>作为比较。</li>
</ol>
<h3 id="slice不能作为map-key">slice不能作为map key<a hidden class="anchor" aria-hidden="true" href="#slice不能作为map-key">#</a></h3>
<ol>
<li><code>slice</code> 不能比较，因此也不能作为<code>map key</code>。更深层的原因应该是 <code>Slice</code> 不能作为<code>map key</code>因此<code>Slice</code>定义为不可比较类型。</li>
<li>根本原因是 <code>slice</code> 是不可比较类型，在<code>Go</code>中<code>Slice</code>作为只是底层数组的连续的描述符，如果按照元素的比较方式<code>Slice</code>可以像<code>Array</code>一样进行比较，但是当<code>Slice</code>作为<code>map key</code>值则会出现这种情况当一个<code>slice</code>作为<code>key</code>保存在<code>map</code>中，我们修改当前<code>slice</code>的元素值会修改<code>map</code>中的<code>slice</code>的<code>key</code>值，这与<code>map</code>的存储意义相违背。因此<code>Go</code>干脆不支持<code>Slice</code>的比较，比较函数为<code>nil</code>。另外一方面<code>slice</code>的<code>cap</code>在比较中又显得不是很重要，比如 <code>make([]int64, 0, 10)</code> 和 <code>make([]int64, 0, 9)</code> 是否相等呢，因此<code>Slice</code>作为可比较类型是有歧义的。</li>
<li>如果Array作为由于Array是固定长度的因此比较元素即可，另外array作为map key是副本的形式不存在slice的情况。</li>
</ol>
<h3 id="map不能作为key">map不能作为key<a hidden class="anchor" aria-hidden="true" href="#map不能作为key">#</a></h3>
<ol>
<li><code>map</code> 不能比较，因此也不能作为<code>map key</code>。更深层的原因应该是 <code>map</code> 不能作为<code>map key</code>因此<code>map</code>定义为不可比较类型。</li>
<li>如果<code>map</code>能比较，那么比较 <code>map</code> 的所有 <code>key/elem</code> 对即可，但是当<code>map</code>作为<code>map key</code>时<code>key</code>中保存的是<code>*hmap</code>，因此当我们修改这个作为<code>map key</code>的<code>map</code>值也会修改到<code>map</code>中相应的<code>key</code>值，这种问题和<code>slice</code>类似这与<code>map</code>的存储意义相违背。因此<code>Go</code>干脆不支持<code>Map</code>的比较，比较函数为<code>nil</code>。</li>
</ol>
<h3 id="function不能作为key">function不能作为key<a hidden class="anchor" aria-hidden="true" href="#function不能作为key">#</a></h3>
<ol>
<li><code>function</code> 不能比较，因此不能作为<code>map key</code>。更深层的原因应该是 <code>function</code> 不能作为<code>map key</code>因此<code>function</code>定义为不可比较类型。</li>
<li><code>function</code>类型的组成由<code>funcval{fn uintptr}</code>结构体以及一系列捕获列表。如果直接判断函数的签名可能存在不同的签名函数实现的函数体不同，因此函数签名不能作为判断函数相等依据，如果使用<code>&amp;funcval</code>作为<code>map key</code>，会出现如果相同的<code>&amp;funcval</code>不同的捕获列表其实并没有成功匹配到<code>key</code>。</li>
</ol>
<h2 id="for-range">for range<a hidden class="anchor" aria-hidden="true" href="#for-range">#</a></h2>
<ol>
<li><code>range map</code>只是此时<code>map</code>的一个快照。</li>
<li>对于<code>key</code>为<code>NaN</code>的，<code>for range</code>能遍历出来。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="nx">map1</span> <span class="o">:=</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">string</span><span class="p">{</span><span class="s">&#34;one&#34;</span><span class="p">:</span><span class="s">&#34;1&#34;</span><span class="p">,</span> <span class="s">&#34;tow&#34;</span><span class="p">:</span><span class="s">&#34;2&#34;</span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">map1</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span> <span class="nx">v</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// original body
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// -------------------------------
</span></span></span><span class="line"><span class="cl"><span class="c1">// 下面是上面编译后代码
</span></span></span><span class="line"><span class="cl"><span class="c1">// -------------------------------
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// 定义遍历所需要的key和value变量
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">var</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">v</span> <span class="kt">string</span>					
</span></span><span class="line"><span class="cl"><span class="c1">// map_iteration_struct是一个hiter结构体，存储着map的遍历相关信息
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">var</span> <span class="nx">hiter</span> <span class="nx">map_iteration_struct</span>	 
</span></span><span class="line"><span class="cl"><span class="c1">// mapiterinit 初始化map参看runtime/map.go文件
</span></span></span><span class="line"><span class="cl"><span class="c1">// hiter是一个哈希迭代结构，mapiternext迭代下一个哈希
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">for</span> <span class="nf">mapiterinit</span><span class="p">(</span><span class="kd">type</span><span class="p">,</span> <span class="k">range</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">hiter</span><span class="p">);</span> <span class="nx">hiter</span><span class="p">.</span><span class="nx">key</span> <span class="o">!=</span> <span class="kc">nil</span><span class="p">;</span> <span class="nf">mapiternext</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">hiter</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">index_temp</span> <span class="o">:=</span> <span class="o">*</span><span class="nx">hiter</span><span class="p">.</span><span class="nx">key</span>
</span></span><span class="line"><span class="cl">    <span class="nx">value_temp</span> <span class="o">:=</span> <span class="o">*</span><span class="nx">hiter</span><span class="p">.</span><span class="nx">val</span>
</span></span><span class="line"><span class="cl">    <span class="nx">i</span> <span class="p">=</span> <span class="nx">index_temp</span>
</span></span><span class="line"><span class="cl">    <span class="nx">v</span> <span class="p">=</span> <span class="nx">value_temp</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span> <span class="nx">v</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// original body
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="map相关练习题">map相关练习题<a hidden class="anchor" aria-hidden="true" href="#map相关练习题">#</a></h2>
<h3 id="示例一">示例一<a hidden class="anchor" aria-hidden="true" href="#示例一">#</a></h3>
<ol>
<li><code>map[string]map[string]string</code>类型遍历。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kn">package</span> <span class="nx">main</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="s">&#34;fmt&#34;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">mm</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">string</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">init</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">mm</span> <span class="p">=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">string</span><span class="p">,</span> <span class="mi">1024</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 测试验证
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">modifyUser</span><span class="p">(</span><span class="nx">mm</span><span class="p">,</span> <span class="s">&#34;one&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nf">modifyUser</span><span class="p">(</span><span class="nx">mm</span><span class="p">,</span> <span class="s">&#34;two&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nf">modifyUser</span><span class="p">(</span><span class="nx">mm</span><span class="p">,</span> <span class="s">&#34;three&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">mm</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nf">modifyUser</span><span class="p">(</span><span class="nx">mm</span><span class="p">,</span> <span class="s">&#34;one&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">mm</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 1. 使用map[string]map[string]string类型
</span></span></span><span class="line"><span class="cl"><span class="c1">// 2. key：表示用户名，是唯一的，不可以重复
</span></span></span><span class="line"><span class="cl"><span class="c1">// 3. 如果某个用户名存在，就将其密码修改&#34;888888&#34;，如果不存在就增加这个用户信息（包括昵称nickname和密码pwd）
</span></span></span><span class="line"><span class="cl"><span class="c1">// 4. 编写一个函数modifyUser(users map[string]map[string]string, name string)完成上述功能
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">modifyUser</span><span class="p">(</span><span class="nx">user</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">string</span><span class="p">,</span> <span class="nx">name</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">v</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">user</span><span class="p">[</span><span class="nx">name</span><span class="p">];</span> <span class="nx">ok</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 因为v存储的时*hmap指针
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 因此直接修改v[&#34;pwd&#34;]时可行的
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">v</span><span class="p">[</span><span class="s">&#34;pwd&#34;</span><span class="p">]</span> <span class="p">=</span> <span class="s">&#34;888888&#34;</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nx">user</span><span class="p">[</span><span class="nx">name</span><span class="p">]</span> <span class="p">=</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">string</span><span class="p">{</span><span class="s">&#34;pwd&#34;</span><span class="p">:</span> <span class="nx">name</span><span class="p">,</span> <span class="s">&#34;nickname&#34;</span><span class="p">:</span> <span class="s">&#34;nickname&#34;</span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="示例二">示例二<a hidden class="anchor" aria-hidden="true" href="#示例二">#</a></h3>
<ol>
<li><code>map</code>作为集合使用。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kn">package</span> <span class="nx">main</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="s">&#34;fmt&#34;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 1. map作为集合使用
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">mm</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kd">struct</span><span class="p">{}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">init</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">mm</span> <span class="p">=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kd">struct</span><span class="p">{},</span> <span class="mi">8</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nx">mm</span><span class="p">[</span><span class="s">&#34;redis&#34;</span><span class="p">]</span> <span class="p">=</span> <span class="kd">struct</span><span class="p">{}{}</span>
</span></span><span class="line"><span class="cl">    <span class="nx">mm</span><span class="p">[</span><span class="s">&#34;mysql&#34;</span><span class="p">]</span> <span class="p">=</span> <span class="kd">struct</span><span class="p">{}{}</span>
</span></span><span class="line"><span class="cl">    <span class="nx">mm</span><span class="p">[</span><span class="s">&#34;nginx&#34;</span><span class="p">]</span> <span class="p">=</span> <span class="kd">struct</span><span class="p">{}{}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">mm</span><span class="p">[</span><span class="s">&#34;php&#34;</span><span class="p">];</span> <span class="nx">ok</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 指定元素存在
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="nx">k</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">mm</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">k</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div>

  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://heliu.site/tags/golang/">Golang</a></li>
      <li><a href="https://heliu.site/tags/%E5%AD%97%E5%85%B8/">字典</a></li>
    </ul>
<nav class="paginav">
  <a class="prev" href="https://heliu.site/posts/golang/map/use/">
    <span class="title">« 上一页</span>
    <br>
    <span>Map(使用)</span>
  </a>
  <a class="next" href="https://heliu.site/posts/golang/map/meta/">
    <span class="title">下一页 »</span>
    <br>
    <span>Map 元类型</span>
  </a>
</nav>

  </footer>
</article>
    </main>
    
<footer class="footer">
    
    <div class="busuanzi-footer">
    <span id="busuanzi_container_site_pv">
        本站总访问量<span id="busuanzi_value_site_pv"></span>次
    </span>
    <span id="busuanzi_container_site_uv">
        本站访客数<span id="busuanzi_value_site_uv"></span>人次
    </span>
    </div>
        <span>Copyright © 2020-2024 <a href="#">heliu's blog</a>. All rights reserved</span>  
    
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'Copy';

        function copyingDone() {
            copybutton.innerHTML = 'Done';
            setTimeout(() => {
                copybutton.innerHTML = 'Copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
