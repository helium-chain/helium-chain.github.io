<!DOCTYPE html>
<html lang="zh" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>sync.Mutex | Helium</title>
<meta name="keywords" content="golang, sync, Mutex">
<meta name="description" content="💥本文章所有相关go代码参考自go 1.18版本">
<meta name="author" content="helium">
<link rel="canonical" href="https://heliu.site/posts/golang/sync/mutex/">
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<meta name="referrer" content="no-referrer-when-downgrade">
<link crossorigin="anonymous" href="/assets/css/stylesheet.css" rel="preload stylesheet" as="style">
<link rel="icon" href="https://heliu.site/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://heliu.site/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://heliu.site/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://heliu.site/apple-touch-icon.png">
<link rel="mask-icon" href="https://heliu.site/apple-touch-icon.png">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="zh" href="https://heliu.site/posts/golang/sync/mutex/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
<html>
<head>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/jetbrains-mono@1.0.6/css/jetbrains-mono-nl.min.css" />
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lxgw-wenkai-lite-webfont@1.1.0/style.css" />
    <link rel="stylesheet" href="https://cdn.staticfile.org/lxgw-wenkai-screen-webfont/1.6.0/style.css" />
    <style>
        body {
            font-family: "LXGW WenKai Lite", sans-serif;
            font-family: "LXGW WenKai Screen", sans-serif;
        }
    </style>
</head>
</html>

  

<meta property="og:title" content="sync.Mutex" />
<meta property="og:description" content="💥本文章所有相关go代码参考自go 1.18版本" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://heliu.site/posts/golang/sync/mutex/" />
<meta property="og:image" content="https://heliu.site/images/Mutex-cover.png" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-03-10T17:42:36+08:00" />
<meta property="article:modified_time" content="2023-02-14T00:40:08+08:00" /><meta property="og:site_name" content="Helium" />

<meta name="twitter:card" content="summary_large_image" />
<meta name="twitter:image" content="https://heliu.site/images/Mutex-cover.png" />
<meta name="twitter:title" content="sync.Mutex"/>
<meta name="twitter:description" content="💥本文章所有相关go代码参考自go 1.18版本"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Article",
      "item": "https://heliu.site/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Golang 合集",
      "item": "https://heliu.site/posts/golang/"
    }, 
    {
      "@type": "ListItem",
      "position":  3 ,
      "name": "sync",
      "item": "https://heliu.site/posts/golang/sync/"
    }, 
    {
      "@type": "ListItem",
      "position":  4 ,
      "name": "sync.Mutex",
      "item": "https://heliu.site/posts/golang/sync/mutex/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "sync.Mutex",
  "name": "sync.Mutex",
  "description": "💥本文章所有相关go代码参考自go 1.18版本",
  "keywords": [
    "golang", "sync", "Mutex"
  ],
  "articleBody": "type Mutex struct 🚀 包说明：\nsync 包提供了基本的同步原语，如互斥锁。 除了 Once 和 WaitGroup 类型之外，大多数都供底层库例程使用。 更高层次的同步最好通过 channels 和通信来完成。 包含在此包中定义的类型的值不应被复制。 1 2 3 4 5 6 7 // Package sync provides basic synchronization primitives such as mutual // exclusion locks. Other than the Once and WaitGroup types, most are intended // for use by low-level library routines. Higher-level synchronization is // better done via channels and communication. // // Values containing the types defined in this package should not be copied. package sync Mutex 是一把互斥锁。互斥锁的零值是未锁定的。 Mutex 在第一次使用后不能被复制。 在 Go 内存模型的术语中，第 n 次调用 Unlock，第 m 次调用 Lock 在同步完成以前 任何 n \u003c m。 成功调用 TryLock 等同于调用 Lock。调用 TryLock 失败根本不会建立任何关系 在同步完成以前。 它是一把结合了【自旋锁】和【信号量】优化过的锁。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 // A Mutex is a mutual exclusion lock. // The zero value for a Mutex is an unlocked mutex. // // A Mutex must not be copied after first use. // // In the terminology of the Go memory model, // the n'th call to Unlock “synchronizes before” the m'th call to Lock // for any n \u003c m. // A successful call to TryLock is equivalent to a call to Lock. // A failed call to TryLock does not establish any “synchronizes before” // relation at all. type Mutex struct { // Mutex 的状态信息 state int32\t// 初始时为 0 // semaphore 相关字段，该字段也是为什么 Mutex 不让拷贝的原因 sema uint32 // 初始时为 0 } Mutex 的内存布局： Mutex 是一个互斥锁，可以创建为其他结构体的字段，零值为解锁状态。 Mutex 类型的锁和线程无关，可以由不同的线程加锁和解锁。 Mutex 结构布局： state 记录 Mutex 的相关信息。 sema 在 Mutex 中没有任何作用，主要是在 semaphore 中，该字段是 Mutex 不能被拷贝的根本原因，在 semaphore 中主要标识有 wakeup 发生。 【正常模式】和【饥饿模式】： 正常模式：一个尝试加锁的 goroutine 会先自旋几次，尝试通过原子操作获得锁，若几次自旋之后仍不能获得锁，则通过信号量（semaphore）排队等待。所有的等待者会按照先入先出（FIFO）的顺序排队，但是当一个等待者被唤醒后并不会直接拥有锁，而是需要和后来者（处于自旋阶段，尚未排队等待的协程）竞争。这种情况下后来者更有优势，一方面原因是后来者正在CPU上运行，自然比刚唤醒的 goroutine 更有优势，另一方面处于自旋状态的 goroutine 可以有很多，而被唤醒的 goroutine 每次只有一个，所以被唤醒的 goroutine 有很大概率获取不到锁，这种情况下它会被重新插入队列的头部，而不是尾部。当一个 goroutine 本次加锁等待的时间超过了 1ms 后，它会把当前 Mutex 切换至饥饿状态。 饥饿模式：Mutex 的所有权从执行 Unlock 的 goroutine 直接传递给等待队列头部的 goroutine。后来者不会自旋，也不会尝试获得锁，它们会直接从队列的尾部排队等待，即使 Mutex 处于 Unlocked 状态。当一个等待者获得了锁之后，它会在以下两种情况时将 Mutex 由饥饿模式切换回正常模式：(1)它是最后一个等待者，即等待队列空了。(2)它的等待时间小于1ms，也就是它刚来不久，后面自然更没有饥饿的 goroutine 了。 正常模式下 Mutex 有更好的性能，但是饥饿模式对于防止尾端延长（队列尾端的 goroutine 迟迟抢不到锁）来讲特别重要。 const 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 const ( // 是否上锁标志位；0-未上锁，1-已上锁； mutexLocked = 1 \u003c\u003c iota\t// 001 // 是否有 goroutine 从阻塞中被唤醒；0-没有；1-有； // 当该标志位被设置时，Unlock 操作不会唤醒排队的 goroutine。 mutexWoken\t// 010 // 是否处于饥饿模式；0-非饥饿，1-饥饿； mutexStarving\t// 100 // 最低位存在3个bit位标识特俗信息，分别为上述的 mutexLocked、mutexWoken、mutexStarving mutexWaiterShift = iota\t// 3 // 互斥公平 // 互斥量可以有两种操作模式:正常(normal)和饥饿(starvation)。 // 在正常模式(normal mode)下：等待的waiters按FIFO(先进先出)顺序排队，但被唤醒的waiter不拥有互斥锁，并与新到达的goroutines竞争所有权。 // 新加入的goroutines有一个优势，它们已经在CPU上运行，并且可能有很多，所以唤醒的waiters很有可能会失败。 // 在这种情况下，它被重新安排在等待队列的前面。如果waiter超过1ms未能获取互斥锁，它将互斥锁切换到饥饿模式。 // 在饥饿模式(starvation mode)下：互斥锁的所有权直接从正在解锁的goroutine移交给队列前面的waiter。 // 新到达的goroutines不会尝试获取互斥锁，即使它看起来已经解锁，也不会尝试旋转。相反，它们把自己排在等待队列的尾部。 // 如果一个waiter收到互斥锁的所有权，并且发现 //\t1) 它是队列中最后一个waiter，或者 //\t2) 它等待的时间少于1毫秒，它会将互斥锁切换回正常工作模式。 // 普通模式(Normal mode)具有更好的性能，因为goroutine可以连续多次获取互斥量，即使有阻塞的等待。 // 饥饿模式(Starvation mode)对于预防有些g一值获取不到锁的尾延迟具有重要意义。(该模式防止有些始终拿不到锁的一直等待在信号池里面的goroutine) // 正常模式 \u003c-\u003e 饥饿模式 相互转换的时间阀门 // 饥饿模式，当前从semaphore中wakeup的goroutine的sleep时间超过1ms，再次获取锁失败时会被标记为饥饿模式 // 饥饿模式下：state 值的 mutexLocked和mutexWoken 位可能为0或1，被唤醒的goroutine mutexLocked和mutexWoken 位都为0 starvationThresholdNs = 1e6\t// sync.Mutex 进入饥饿模式的等待时间阈值1ms。 ) Lock() Lock 锁住 m。 如果锁已经被使用，调用 goroutine 会阻塞，直到 mutex 可用。 Lock 和 Unlock 是一对操作。 该方法主要通过 atomic 函数实现了Fast path，相应的Slow path被单独放在了lockSlow()方法中。 根据源码注释的说法，这样是为了便于编译器对 Fast path 进行内联优化。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 // Lock locks m. // If the lock is already in use, the calling goroutine // blocks until the mutex is available. func (m *Mutex) Lock() { // 1) 使用CAS尝试获取锁 // Fast path期望 Mutex 处于 Unlocked 状态，没有 goroutine 在排队，更不会饥饿。 // 理想状态下，一个CAS操作就可以获得锁。 // Fast path: grab unlocked mutex. // // 快速路径：获取解锁的互斥量。 // 原子操作比较 m.state 的旧值为 0 并交换成新值 1，成功则表示获取到锁。 // 这种情况发生在 state=0 时，没有等待的goroutine。 if atomic.CompareAndSwapInt32(\u0026m.state, 0, mutexLocked) { if race.Enabled { race.Acquire(unsafe.Pointer(m)) } return } // 2) m.state != 0 时都会走 Slow path // CAS 操作没能获得锁，就需要进入 Slow path了。 // Slow path (outlined so that the fast path can be inlined) // // 如果上面快速方式拿取不到锁，则去和其他竞争。上面情况拿不到锁，可能： // 1. 存在有其他goroutine正在持有锁。 // 2. 不存在其他goroutine持有锁，存在被唤醒的goroutine或还有等待的goroutine。 // 当前可能处于【正常模式】或【饥饿模式】 m.lockSlow() } lockSlow() 如果调用者拿取不到锁，则下面操作流程是先自旋试图拿去锁，实在拿取不到锁则进入信号池去等待拿取锁。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 // 竞争获取锁 // 1. 先自旋等待其他goroutine解锁（满足自旋条件时） // 2. 尝试修改 state 值竞争锁 // 3. 竞争成功，获取锁退出 // 4. 竞争失败，sleep goroutine func (m *Mutex) lockSlow() { // 1. 当前goroutine首次进入semaphore池sleep的时间/纳秒，下次wakeup后用于判断 正常模式 \u003c-\u003e 饥饿模式 转换 // 2. queueLifo := waitStartTime != 0; 进入 semaphore 池的首或尾，false.尾 true.首 var waitStartTime int64\t// mutex模式 【false.正常模式】 【true.饥饿模式】 // 1. 正常模式下，新来获取锁的goroutine如果满足条件会进行自旋等待锁被释放，如果还拿取不到锁则去信号池最前面等待。 // 2. 饥饿模式下，新来获取锁的goroutine不会进行自旋，直接去信号池的末尾去等待。 starving := false\t// 是否有goroutine被唤醒 false.没有 // 有被唤醒的goroutine时，会试图去拿去锁，可能是跟当前正在获取锁的goroutine竞争 // 1. 在自旋情况下满足条件设置 awoke 为 true // 2. 非饥饿模式下被唤醒的goroutine awoke 会被设置为 true // 3. 在饥饿模式下 awoke 变量没有用 awoke := false\t// 用于原子设置 mutexWoken 位，通知 Unlock 函数有 woken 的goroutine了，不要去wakeup goroutine // 记录旋转的次数，当没有获取锁时，会尝试4次去自旋获取 iter := 0\t// 自旋计数器\t// 以下代码都是从 old -\u003e new 的原子操作，去尝试修改 state 值 old := m.state\t// 旧值state // 该循环只有在获取到锁的时候才会退出，因此所有未获取到锁的goroutine都将在这里等待获取锁 for { // 1) 饥饿模式下不要自旋，因为所有权按照顺序传递，自旋没有意义。 // 正常模式下锁没有被释放满足自旋条件需要自旋。 // Don't spin in starvation mode, ownership is handed off to waiters // so we won't be able to acquire the mutex anyway. // // 不要在饥饿模式下旋转，所有权已移交给waiters，因此我们无论如何都无法获得互斥锁 // 1. old\u0026(mutexLocked|mutexStarving) == mutexLocked; Mutex没有处于饥饿模式并且已被锁定。 // 2. runtime_canSpin(iter); 报告当前旋转要求条件。 //\t主动旋转条件： //\t旋转次数小于4次 并且 多核CPU运行 并且除了当前P还有其他P正在运行（不是空闲或自旋状态的P）并且 当前P没有其他g了 //\t这种情况需要去尝试自旋获取下锁，其他情况则不需要自旋去获取锁 // 以下自旋的意义，停留片刻等待其他goroutine让出锁，然后标记mutexWoken存在被唤醒的goroutine使自己获取锁优先级更高 if old\u0026(mutexLocked|mutexStarving) == mutexLocked \u0026\u0026 runtime_canSpin(iter) {\t// 自旋在这里 // Active spinning makes sense. // Try to set mutexWoken flag to inform Unlock // to not wake other blocked goroutines. // // 主动旋转是有道理的。 // 尝试设置 mutexflag 来通知 Unlock 不要唤醒其他被阻塞在信号池的goroutines。 // 以下逻辑是处于自旋，自旋的意义在于标记有正在被唤醒的goroutine，其他线程不要再次唤醒导致过多goroutine被唤醒 // // 1. !awoke; ：没有标记当前goroutine被唤醒 // 2. old\u0026mutexWoken == 0; ：没有被唤醒的goroutine，包括其他g和当前g // 3. old\u003e\u003emutexWaiterShift != 0; ：存在等待排队在信号池的goroutine // 4. atomic.CompareAndSwapInt32(\u0026m.state, old, old|mutexWoken); //\t设置标志有goroutine被唤醒，这里设置成功那unlock则不会再去唤醒goroutine if !awoke \u0026\u0026 old\u0026mutexWoken == 0 \u0026\u0026 old\u003e\u003emutexWaiterShift != 0 \u0026\u0026 atomic.CompareAndSwapInt32(\u0026m.state, old, old|mutexWoken) { // 标记为唤醒状态，主要是告诉unlock不要再去唤醒goroutine了，这里有自旋的在等待 awoke = true } // 短暂延迟一段时间，主要是等待其他g解锁 // 如果此时Unlock了第一个if则不会再判断为true，直接去争抢锁了 runtime_doSpin()\titer++ old = m.state\t// 从新赋值给old continue } // 2) 锁可能已被释放尝试竞争获取，或锁还未解除去sleep。 // 代码执行到这里，只可能处于以下几种情况 // 1. 自旋次数以完，状态依然是 mutexLocked。 // 2. 状态是 mutexStarving 处于饥饿状态。 // 3. 状态是未加锁状态，锁已被解除。 // （处于饥饿模式） 或 （自旋次数超过4次） 或 （当前其他goroutine已Unlock）或 （不满足自旋条件） //\t如果锁已Unlock，那么尝试去获取锁；如果锁处于Lock，那么也尝试获取，否则加入到信号池中等待 // old 是本轮原子操作的 state 值 // new 是本轮需要争抢锁修改后的 state 值 // 正常模式下: // 1. 在old未持有锁情况下，谁先原子操作从 old 修改为 new 谁就先获取到锁 // 2. 在old持有锁情况下，当前goroutine需要sleep new := old // 2.1) 正常模式下需要争抢锁，因此需要设置mutexLocked状态 // Don't try to acquire starving mutex, new arriving goroutines must queue. // // 不要尝试获取处于饥饿的Mutex，后来的goroutines必须排队。 // // 处于饥饿模式下，为什么不需要设置mutexLocked标志呢？ // 1. 处于饥饿模式下锁的持有权是手把手交给后面等待的goroutine，因此mutexLocked标志设置不设置不重要 // 2. 对于新来的goroutine，mutexLocked位可能为0或1，但是当前goroutine不会去挣抢锁直接sleep，因此mutexLocked位不重要 // 3. 对于从sleep中wakeup的goroutine，一定是来自Unlock函数而来自该函数mutexLocked位一定是0，已被解锁 if old\u0026mutexStarving == 0 {\t// 处于正常模式 // new表示新值修改的状态 mutexLocked需要锁，不管当前是Lock或Unlock当前都需要设置mutexLocked表示需要去争抢锁 new |= mutexLocked\t} // 2.2) 锁还未被释放 或 处于饥饿模式下 这两种情况下都会去sleep，因此需要加一。 // 如果old锁没释放 或 处于饥饿状态，那么当前的goroutine则是需要被加入到信号池里面去的 if old\u0026(mutexLocked|mutexStarving) != 0 {\t// 处于Lock或则饥饿模式当前g需要加入到信号池 new += 1 \u003c\u003c mutexWaiterShift\t// 数量增加1 } // 2.3) 当前 goroutine 将 mutex 切换至饥饿模式 // 如果 mutex 已经处于 unlocked 状态，就不要切换了， // 因为 Unlock() 函数认为处于饥饿模式的 mutex 等待队列不为空。 // The current goroutine switches mutex to starvation mode. // But if the mutex is currently unlocked, don't do the switch. // Unlock expects that starving mutex has waiters, which will not // be true in this case. // // 当前的 goroutine 将互斥锁切换到饥饿模式，但如果互斥锁当前已解锁，就不要切换。 // Unlock期望处于饥饿状态的互斥锁有waiters，但在本例中并非如此。 // // starving=true 发生在：这个goroutine被加入到信号池后再度被唤醒去争抢锁时，发现等待时间已经超过1ms时 // old\u0026mutexLocked != 0，表示这个被唤醒的goroutine再次争抢锁时锁没被其他gorutine释放，这次再争抢将失败则会标记成饥饿模式 if starving \u0026\u0026 old\u0026mutexLocked != 0 {\t// 这种情况下当前goroutine基本拿去不到锁 new |= mutexStarving // 标记成饥饿模式时，锁一定被其他持有；但是唤醒的g处于饥饿模式时，锁一定是Unlock状态 } // 2.4) 当前goroutine是被唤醒的，检查并清除标志位 // awoke=true 表示来自自旋或被唤醒的goroutine两种形式 // 1. 自旋状态下 awoke=true，state 中 mutexWoken 位已被设置为 1 // 2. 被唤醒的goroutine下 awoke=true 在本函数的唤醒后被设置，而 state 中 mutexWoken 位在Unlock函数中被设置 // 因此 awoke=true 就一定存在 state 中 mutexWoken 位为1，new\u0026mutexWoken != 0成立 if awoke {\t// awoke有等待的goroutine被唤醒 // The goroutine has been woken from sleep, // so we need to reset the flag in either case. // // goroutine 已经从睡眠中唤醒，所以我们需要在任何一种情况下重置标志 if new\u0026mutexWoken == 0 {\t// 不论来自自旋或被唤醒的goroutine这里都不能为0，正常状况下 throw(\"sync: inconsistent mutex state\") } new \u0026^= mutexWoken // 清除被唤醒标志位mutexWoken，因为下面即将去争抢锁，或者载入去信号池等待 } // 尝试使用原子修改state，所有的goroutine都会通过该条件，但是一轮只能成功一个 // 这里修改m.state成功了，并不代表一定获取到了锁，也有可能是当前g需要加入到信号池中去 if atomic.CompareAndSwapInt32(\u0026m.state, old, new) {\t// 如果上一个拿去到锁的state是正常模式并没有锁，则这里直接退出，这里表示当前goroutine获取到了锁，正常模式都是从这里退出的 // 正常模式下获取到锁的情况，这里不会出现标记成饥饿模式但这里又判断为true退出了的情况，原因是标记成饥饿模式的前置条件是当前old是Lock if old\u0026(mutexLocked|mutexStarving) == 0 {\t// 谁先拿到锁退出，接到执行goroutine后面代码 break // locked the mutex with CAS } // 后面处理逻辑是之前有锁，这个goroutine需要去排队情况，或当前模式处于饥饿模式，直接把该goroutine加入到尾部 // If we were already waiting before, queue at the front of the queue. // // 如果我们之前已经在等待，请在队列的前面排队 // waitStartTime如果不等于0说明先前入队过有被唤醒过，正常第一次入队这里是false // 被唤醒之后没有抢到锁，需要插入队列头部，而不是尾部。 queueLifo := waitStartTime != 0 // 首次进入信号池去等待时 if waitStartTime == 0 {\t// 这里表示这个goroutine从信号池中第一次被唤醒依然没有获取到锁，从新设置时间 waitStartTime = runtime_nanotime()\t// 注意：除第一次入队后后面每次缓存waitStartTime时间都不会被刷新 } // 这里存在被唤醒但是还是没拿到锁的情况会再次被入队 // runtime_SemacquireMutex的queueLifo参数为true则是插入的信号池头部，false插入到尾部 //\t首次进入信号池，则直接排在尾部 //\t从信号池中出来又争抢失败进入信号池排在头部 // 如我们取出gorutine则是从头部开始往后取，这也就是我们说的先进先出 // 因为第一次加入信号池的都是插入到尾部，当再被唤醒依然没有获取到锁时，则是被放回到头部 // 当前goroutine去排队，这里当前groutine被调离工作线程等待抢到锁后继续后面执行 runtime_SemacquireMutex(\u0026m.sema, queueLifo, 1)\t// 被唤醒的g，接到从这里执行尝试去获取锁；可能当前处于饥饿模式或处于正常模式，唤醒g的相关代码位于Unlock函数 // 如果等待的时间大于1ms则标记成饥饿模式，以下逻辑是当前goroutine被唤醒后再次尝试获取锁 // 等待时间超过了1ms，等待时间太久需要被标记为饥饿状态 starving = starving || runtime_nanotime()-waitStartTime \u003e starvationThresholdNs old = m.state\t// 获取当前的状态 // 如果处于饥饿模式，处于饥饿模式下唤醒的goroutine立即获取锁，因为正常来抢的goroutine都会被入队， // 然后一个个来获取 // 所有饥饿模式下获取锁的出口都在这里，该条件满足说明当前goroutine获取到锁持有权 if old\u0026mutexStarving != 0 {\t// If this goroutine was woken and mutex is in starvation mode, // ownership was handed off to us but mutex is in somewhat // inconsistent state: mutexLocked is not set and we are still // accounted as waiter. Fix that. // // 当前代码位置的 goroutine 肯定是被唤醒的，而且 Mutex 处于饥饿模式 // 所有权被直接交给当前 goroutine // 但是这种情况下 mutex 的 state 会与实际情况不一致 // mutexLocked 标志位没有设置 // 而且等待者计数中也没有减去当前 goroutine。需要修复 state // 注意饥饿模式下传递 mutex 所有权不会设置 mutexWoken 标志，只有正常模式下唤醒才会 // // 饥饿模式下 old\u003e\u003emutexWaiterShift != 0，当前一定不能是最后一个， // 因为下面 old\u003e\u003emutexWaiterShift == 1 会退出饥饿模式 // old\u0026(mutexLocked|mutexWoken) != 0 因为处于饥饿模式下，所有的goroutine都会去排队sleep， // 被wakeup的goroutine一定来自Unlock函数， // 此时mutexLocked一定解锁，mutexWoken一定是被清除的 if old\u0026(mutexLocked|mutexWoken) != 0 || old\u003e\u003emutexWaiterShift == 0 { // 饥饿模式下，mutexLocked和mutexWoken必定为0，参看上面代码。 throw(\"sync: inconsistent mutex state\") } // +mutexLocked -1\u003c",
  "wordCount" : "3402",
  "inLanguage": "zh",
  "image":"https://heliu.site/images/Mutex-cover.png","datePublished": "2020-03-10T17:42:36+08:00",
  "dateModified": "2023-02-14T00:40:08+08:00",
  "author":[{
    "@type": "Person",
    "name": "helium"
  }],
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://heliu.site/posts/golang/sync/mutex/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Helium",
    "logo": {
      "@type": "ImageObject",
      "url": "https://heliu.site/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://heliu.site/" accesskey="h" title="Blog (Alt + H)">
                <img src="https://heliu.site/helium.png" alt="" aria-label="logo"
                    height="35">Blog</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://heliu.site/" title="主页">
                    <span>Home</span>
                </a>
            </li>
            <li>
                <a href="https://heliu.site/posts" title="文章">
                    <span>Article</span>
                </a>
            </li>
            <li>
                <a href="https://heliu.site/archives" title="时间轴">
                    <span>Archive</span>
                </a>
            </li>
            <li>
                <a href="https://heliu.site/tags/" title="标签">
                    <span>Tag</span>
                </a>
            </li>
            <li>
                <a href="https://heliu.site/search/" title="搜索 (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
            <li>
                <a href="https://heliu.site/support" title="打赏">
                    <span>🫶Help</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">


<article class="post" autonumbering>
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://heliu.site/">主页</a>&nbsp;»&nbsp;<a href="https://heliu.site/posts/">Article</a>&nbsp;»&nbsp;<a href="https://heliu.site/posts/golang/">Golang 合集</a>&nbsp;»&nbsp;<a href="https://heliu.site/posts/golang/sync/">sync</a></div>
    <h1 class="post-title entry-hint-parent">
      sync.Mutex
    </h1>
    <div class="post-description">
      💥本文章所有相关go代码参考自go 1.18版本
    </div>
    <div class="post-meta">










<span class="x-post-meta-item"><svg t="1720837714681" class="icon" viewBox="0 0 1084 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="7520" width="200" height="200"><path d="M123.47509 1023.984942a123.565437 123.565437 0 0 1-123.505206-123.32451V243.863302A123.565437 123.565437 0 0 1 123.47509 120.568908h171.630374V26.06529a26.050232 26.050232 0 0 1 52.070349 0v94.503618h377.592848V26.06529a26.050232 26.050232 0 0 1 52.100464 0v94.503618h183.797189A123.565437 123.565437 0 0 1 1084.171519 243.863302v656.79713A123.565437 123.565437 0 0 1 960.666314 1023.984942H123.47509z m-71.404741-123.32451A71.434857 71.434857 0 0 0 123.47509 971.974825h837.191224a71.434857 71.434857 0 0 0 71.404741-71.314393V442.326922l-946.361273-3.824716a25.598494 25.598494 0 0 1-5.84248-0.692665l-27.796953-6.444798v469.295689zM123.47509 172.579025a71.434857 71.434857 0 0 0-71.404741 71.284277v149.736133l27.796953-6.444797a26.080348 26.080348 0 0 1 5.902712-0.662549l946.301041 3.824716V243.863302a71.404741 71.404741 0 0 0-71.404741-71.284277h-180.183284l-6.173754 12.859479a26.200812 26.200812 0 0 1-23.490383 14.786895 26.261043 26.261043 0 0 1-23.520499-14.786895l-6.173754-12.859479H350.819834l-6.173754 12.859479a26.200812 26.200812 0 0 1-23.490383 14.786895 26.230928 26.230928 0 0 1-23.520499-14.786895l-6.173755-12.859479H123.47509z m156.150814 578.827128a26.050232 26.050232 0 0 1-26.050232-25.990001c0-14.335157 11.68496-26.020116 26.050232-26.020116h521.697312c14.365273 0 26.050232 11.68496 26.050233 26.020116a26.050232 26.050232 0 0 1-26.050233 25.990001H279.625904z" fill="#3D3F42" p-id="7521"></path></svg><span>2020-03-10</span></span>&nbsp;<span class="x-post-meta-item"><svg t="1720839329181" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="14106" width="200" height="200"><path d="M699.270662 190.485379c-0.411369 0-0.821715 0.011256-1.227967 0.032746H507.034407a23.041786 23.041786 0 0 0-1.221828-0.031723c-12.779048 0-23.140023 10.359952-23.140023 23.139 0 12.781094 10.360975 23.141046 23.140023 23.141046v0.032746h193.458083v-0.032746c12.780071 0 23.141046-10.359952 23.141047-23.141046 0-12.780071-10.360975-23.140023-23.141047-23.140023zM979.215516 724.005508c0-142.090159-115.186416-257.277598-257.277598-257.277598-72.245418 0-137.532353 29.777187-184.262654 77.725223l45.868677 31.474852c36.227086-33.873482 84.882226-54.617945 138.393977-54.617945 111.945605 0 202.696492 90.750887 202.696492 202.695468h-43.01263l70.331835 104.289228 70.331835-104.289228H979.215516z" fill="" p-id="14107"></path><path d="M748.885664 588.843132c0-14.881942-12.06785-26.945699-26.947746-26.945698-14.883989 0-26.947745 12.063757-26.947745 26.945698v135.164423c0 14.879895 12.063757 26.945699 26.947745 26.945699h107.786889c14.881942 0 26.945699-12.063757 26.945698-26.945699s-12.063757-26.945699-26.945698-26.945699h-80.839143V588.843132zM721.937918 926.702c-111.947651 0-202.696492-90.74884-202.696492-202.696492 0-0.144286 0.004093-0.285502 0.004094-0.429788h43.004443l-70.330812-104.289228-70.331835 104.289228h43.075051c0 0.144286-0.00307 0.285502-0.00307 0.429788 0 142.091182 115.187439 257.279644 257.278621 257.279645 72.241324 0 137.530306-29.77821 184.260607-77.727269l-45.86663-31.474852c-36.227086 33.873482-84.884272 54.618968-138.393977 54.618968zM694.633039 423.38066c-1.354857-11.487635-11.120268-20.400632-22.972201-20.400632H206.362486c-12.780071 0-23.140023 10.359952-23.140023 23.138999 0 12.781094 10.359952 23.141046 23.140023 23.141047H596.949252c30.209022-13.81668 63.104223-22.76754 97.683787-25.879414zM438.548616 623.143333H206.362486c-12.780071 0-23.140023 10.358929-23.140023 23.140023 0 12.780071 10.359952 23.140023 23.140023 23.140023h219.956598a298.463626 298.463626 0 0 1 12.229532-46.280046zM506.934123 513.062192H206.362486c-12.780071 0-23.140023 10.359952-23.140023 23.139 0 12.781094 10.359952 23.140023 23.140023 23.140023H469.936487a302.241672 302.241672 0 0 1 36.997636-46.279023z" fill="" p-id="14108"></path><path d="M442.765661 835.277778a298.531164 298.531164 0 0 1-14.365173-46.150087H146.542052v-0.065491c-33.036417 0-59.81941-26.78197-59.81941-59.819411V329.36031h704.907545v100.905154a298.561863 298.561863 0 0 1 46.150086 14.996552V194.619536h-0.162706c0-53.422723-43.307342-96.728018-96.730065-96.728018h-68.89409V84.418668c0-33.037441-26.782993-59.81941-59.81941-59.81941v-0.361227h-18.87079v0.032745c-33.038464 0-59.820434 26.78197-59.820433 59.819411 0 0.109494 0.008186 0.218988 0.008186 0.328481h-0.339738v13.47285H345.203648V84.418668c0-33.037441-26.782993-59.81941-59.819411-59.81941v-0.361227h-18.872836v0.032745c-33.036417 0-59.81941 26.78197-59.81941 59.819411 0 0.109494 0.007163 0.218988 0.008186 0.328481h-0.339737v13.47285h-69.189826c-53.4217 0-96.729042 43.306318-96.729041 96.728018 0 1.701758 0.045025 3.39226 0.132006 5.071505v533.785166a98.051153 98.051153 0 0 0-0.132006 5.071506c0 53.4217 43.307342 96.728018 96.729041 96.728018v0.001023h305.595047zM86.723665 204.056466c0-33.037441 26.782993-59.81941 59.819411-59.819411 0.044002 0 0.086981 0.00307 0.130983 0.00307v-0.068561h105.968473V94.874811h0.032746a22.807449 22.807449 0 0 1-0.032746-1.215688c0-12.779048 10.360975-23.140023 23.140023-23.140023s23.140023 10.360975 23.140023 23.140023c0 0.408299-0.010233 0.812505-0.031722 1.215688h0.031722v49.297776h280.508696V94.874811h0.032745a22.807449 22.807449 0 0 1-0.032745-1.215688c0-12.779048 10.361999-23.140023 23.140023-23.140023 12.780071 0 23.141046 10.360975 23.141046 23.140023 0 0.408299-0.011256 0.812505-0.032746 1.215688h0.032746v49.297776h106.10048v0.065492c33.035394 0 59.818387 26.780947 59.818387 59.81941h0.130983V283.080264H86.723665v-79.023798z" fill="" p-id="14109"></path></svg><span>2023-02-14</span></span>&nbsp;<span class="x-post-meta-item"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2" fill="none"
     stroke-linecap="round" stroke-linejoin="round" class="feather feather-file-text" style="user-select: text;">
    <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z" style="user-select: text;"></path>
    <polyline points="14 2 14 8 20 8" style="user-select: text;"></polyline>
    <line x1="16" y1="13" x2="8" y2="13" style="user-select: text;"></line>
    <line x1="16" y1="17" x2="8" y2="17" style="user-select: text;"></line>
    <polyline points="10 9 9 9 8 9" style="user-select: text;"></polyline>
</svg><span>3402字</span></span>&nbsp;<span class="x-post-meta-item"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2" fill="none"
     stroke-linecap="round" stroke-linejoin="round">
    <path stroke="none" d="M0 0h24v24H0z" fill="none"></path>
    <circle cx="12" cy="12" r="9"></circle>
    <polyline points="12 7 12 12 15 15"></polyline>
</svg><span>16分钟</span></span>&nbsp;<span class="x-post-meta-item"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2" fill="none"
     stroke-linecap="round" stroke-linejoin="round">
    <path stroke="none" d="M0 0h24v24H0z" fill="none"></path>
    <circle cx="12" cy="7" r="4"></circle>
    <path d="M6 21v-2a4 4 0 0 1 4 -4h4a4 4 0 0 1 4 4v2"></path>
</svg><span>helium</span></span>
      <span class="x-post-meta-item">
        &nbsp;<svg t="1720840393161" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="18680" width="200" height="200"><path d="M995.125144 559.61812l-415.998603-415.998602A52.986489 52.986489 0 0 0 541.413335 127.99957H338.847348c-3.166656-26.559911-9.286635-51.046495-17.999939-71.333094C299.734146 7.333309 271.154242 0 256.00096 0c-13.939953 0-40.439864 6.339979-61.259794 48.806503-10.473298 21.366595-17.946606 48.966502-21.573261 79.193067H53.334974a53.393154 53.393154 0 0 0-53.333154 53.333154v360.078791a52.986489 52.986489 0 0 0 15.619948 37.713206l415.998602 415.998603a53.333154 53.333154 0 0 0 75.426413 0l26.286579-26.293245 26.286578 26.293245a53.426487 53.426487 0 0 0 16.719944 11.333295 21.333262 21.333262 0 0 0 36.079879 11.293295l382.705381-382.705381a53.399821 53.399821 0 0 0 0-75.426413z m-762.070774-491.998347C241.494342 50.373164 250.667645 42.666523 256.00096 42.666523c5.99998 0 16.573278 9.639968 25.646581 30.806564 6.493312 15.159949 11.333295 33.999886 14.146619 54.526483H216.16776c3.206656-23.419921 9.013303-44.359851 16.88661-60.41313z m243.819181 897.330319a10.666631 10.666631 0 0 1-15.079949 0l-415.998603-415.998603A10.573298 10.573298 0 0 1 42.668343 541.411515V181.332724a10.666631 10.666631 0 0 1 10.666631-10.666631h245.332509c0 47.853173-10.373298 92.15969-27.066575 115.632945-5.926647 8.326639-16.566611 14.186619-22.306592 16.113279C204.041135 314.752276 170.667913 356.218803 170.667913 405.331972c0 58.813136 47.853173 106.666308 106.666309 106.666308s106.666308-47.853173 106.666308-106.666308c0-47.086508-30.666564-87.139707-73.079754-101.246327C330.060711 272.705751 341.334007 223.692582 341.334007 170.666093h72.079758a10.573298 10.573298 0 0 1 7.539974 3.126656l415.998603 415.998603a10.666631 10.666631 0 0 1 0 15.079949zM341.334007 405.331972a63.999785 63.999785 0 1 1-63.999785-63.999785 64.073118 64.073118 0 0 1 63.999785 63.999785z m263.539114 559.61812a10.666631 10.666631 0 0 1-15.079949 0L563.499927 938.663513l303.625647-303.61898a53.399821 53.399821 0 0 0 0-75.426413L478.16688 170.666093h63.246455a10.573298 10.573298 0 0 1 7.539974 3.126656l415.998603 415.998603c0.239999 0.239999 0.466665 0.486665 0.666664 0.746664l0.086667 0.106666a10.666631 10.666631 0 0 1 0 13.373289l-0.086667 0.106666c-0.213333 0.259999-0.439999 0.506665-0.666664 0.746664z" fill="#5C5C66" p-id="18681"></path></svg>
        <ul class="post-tags-meta" style="display: inline-block;font-size: 14px;">
            <a href="https://heliu.site/tags/golang/" target="_blank" rel="noopener">Golang</a>
            <a href="https://heliu.site/tags/sync/" target="_blank" rel="noopener">Sync</a>
            <a href="https://heliu.site/tags/mutex/" target="_blank" rel="noopener">Mutex</a>
        </ul>
      </span>
      
      <span id="busuanzi_container_page_pv" class="x-post-meta-item">
        &nbsp;<svg t="1720844685710" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="27237" width="200" height="200"><path d="M739.754667 574.08c-121.386667 45.610667-208.469333 169.813333-208.64 316.16 0 33.408 4.693333 65.493333 13.141333 95.914667H94.122667c-26.453333-43.52-41.685333-91.946667-41.685334-143.189334 0-185.173333 192.896-335.104 430.805334-335.104 96.256 0 184.832 24.746667 256.512 66.218667z m-280.490667-114.986667a214.869333 214.869333 0 0 1-214.869333-215.04A215.04 215.04 0 0 1 459.264 28.842667a215.04 215.04 0 0 1 215.04 215.210666 215.04 215.04 0 0 1-215.04 215.04zM974.506667 641.28c9.856 0 17.834667 7.466667 17.834666 16.64v59.989333c-0.341333 8.789333-7.850667 15.786667-17.28 16.085334-9.856 0.341333-18.176-6.826667-18.517333-16.085334v-20.053333l-99.114667 91.093333-0.256 0.256a18.474667 18.474667 0 0 1-14.848 4.352h-0.768a18.176 18.176 0 0 1-9.344-4.608l-0.938666-0.981333-85.930667-80.042667-123.562667 115.072a18.773333 18.773333 0 0 1-25.216 0 15.786667 15.786667 0 0 1 0-23.466666l136.149334-126.848 0.725333-0.597334a18.645333 18.645333 0 0 1 24.362667 0.512l87.253333 81.237334 86.058667-79.232h-21.248c-9.386667-0.298667-16.938667-7.338667-17.28-16.085334-0.341333-9.173333 7.381333-16.896 17.28-17.237333h64.64z m-367.146667 240h48.128c8.874667 0 16.042667 7.168 16.042667 16.042667v72.192a16.042667 16.042667 0 0 1-16.042667 16.042666h-48.128a16.042667 16.042667 0 0 1-16.042667-16.042666v-72.192c0-8.874667 7.210667-16.042667 16.042667-16.042667z m110.805333-106.666667h48.128c8.874667 0 16.042667 7.168 16.042667 16.042667v178.858667a16.042667 16.042667 0 0 1-16.042667 16.042666h-48.128a16.042667 16.042667 0 0 1-16.042666-16.042666v-178.858667c0-8.874667 7.168-16.042667 16.042666-16.042667z m106.538667 80h48.128c8.874667 0 16.042667 7.168 16.042667 16.042667v99.413333a16.042667 16.042667 0 0 1-16.042667 16.042667H824.746667a16.042667 16.042667 0 0 1-16.042667-16.042667v-99.413333c0-8.874667 7.168-16.042667 16.042667-16.042667z m110.165333-80h48.128c8.874667 0 16.042667 7.168 16.042667 16.042667v179.413333a16.042667 16.042667 0 0 1-16.042667 16.042667h-48.128a16.042667 16.042667 0 0 1-16.042666-16.042667v-179.413333c0-8.874667 7.210667-16.042667 16.042666-16.042667z" fill="#999999" p-id="27238"></path></svg>
        <span id="busuanzi_value_page_pv"></span>
      </span>

</div>
  </header> 
<figure class="entry-cover1">
        <img loading="eager" srcset="https://heliu.site/posts/golang/sync/mutex/images/Mutex-cover_huc2ccb710628246fc3a8289f0c5ffc978_48767_360x0_resize_box_3.png 360w ,https://heliu.site/posts/golang/sync/mutex/images/Mutex-cover_huc2ccb710628246fc3a8289f0c5ffc978_48767_480x0_resize_box_3.png 480w ,https://heliu.site/posts/golang/sync/mutex/images/Mutex-cover_huc2ccb710628246fc3a8289f0c5ffc978_48767_720x0_resize_box_3.png 720w ,https://heliu.site/posts/golang/sync/mutex/images/Mutex-cover.png 800w" 
            sizes="(min-width: 768px) 720px, 100vw" src="https://heliu.site/posts/golang/sync/mutex/images/Mutex-cover.png" alt="" 
            width="800" height="600">
        
</figure><aside id="toc-container" class="toc-container wide">
    <div class="toc">
        <details  open>
            <summary accesskey="c" title="(Alt + C)">
                <span class="details">目录</span>
            </summary>

            <div class="inner"><ul>
                    <li>
                        <a href="#type-mutex-struct-" aria-label="type Mutex struct 🚀">type Mutex struct 🚀</a><ul>
                            
                    <li>
                        <a href="#const" aria-label="const">const</a></li>
                    <li>
                        <a href="#lock" aria-label="Lock()">Lock()</a><ul>
                            
                    <li>
                        <a href="#lockslow" aria-label="lockSlow()">lockSlow()</a></li>
                    <li>
                        <a href="#sync_runtime_canspin" aria-label="sync_runtime_canSpin()">sync_runtime_canSpin()</a></li>
                    <li>
                        <a href="#sync_runtime_dospin" aria-label="sync_runtime_doSpin()">sync_runtime_doSpin()</a></li>
                    <li>
                        <a href="#procyield" aria-label="procyield()">procyield()</a></li></ul>
                    </li>
                    <li>
                        <a href="#unlock" aria-label="Unlock()">Unlock()</a><ul>
                            
                    <li>
                        <a href="#unlockslow" aria-label="unlockSlow()">unlockSlow()</a></li></ul>
                    </li>
                    <li>
                        <a href="#trylock" aria-label="TryLock()">TryLock()</a></li></ul>
                    </li>
                    <li>
                        <a href="#type-locker-interface" aria-label="type Locker interface">type Locker interface</a></li>
                    <li>
                        <a href="#%e4%bd%bf%e7%94%a8%e7%a4%ba%e4%be%8b" aria-label="使用示例">使用示例</a><ul>
                            
                    <li>
                        <a href="#syncmutex" aria-label="sync.Mutex">sync.Mutex</a></li></ul>
                    </li>
                    <li>
                        <a href="#%e6%b3%a8%e6%84%8f%e4%ba%8b%e9%a1%b9" aria-label="注意事项">注意事项</a>
                    </li>
                </ul>
            </div>
        </details>
    </div>
</aside>
<script>
    let activeElement;
    let elements;
    window.addEventListener('DOMContentLoaded', function (event) {
        checkTocPosition();

        elements = document.querySelectorAll('h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]');
         
         activeElement = elements[0];
         const id = encodeURI(activeElement.getAttribute('id')).toLowerCase();
         document.querySelector(`.inner ul li a[href="#${id}"]`).classList.add('active');
     }, false);

    window.addEventListener('resize', function(event) {
        checkTocPosition();
    }, false);

    window.addEventListener('scroll', () => {
        
        activeElement = Array.from(elements).find((element) => {
            if ((getOffsetTop(element) - window.pageYOffset) > 0 && 
                (getOffsetTop(element) - window.pageYOffset) < window.innerHeight/2) {
                return element;
            }
        }) || activeElement

        elements.forEach(element => {
             const id = encodeURI(element.getAttribute('id')).toLowerCase();
             if (element === activeElement){
                 document.querySelector(`.inner ul li a[href="#${id}"]`).classList.add('active');
             } else {
                 document.querySelector(`.inner ul li a[href="#${id}"]`).classList.remove('active');
             }
         })
     }, false);

    const main = parseInt(getComputedStyle(document.body).getPropertyValue('--article-width'), 10);
    const toc = parseInt(getComputedStyle(document.body).getPropertyValue('--toc-width'), 10);
    const gap = parseInt(getComputedStyle(document.body).getPropertyValue('--gap'), 10);

    function checkTocPosition() {
        const width = document.body.scrollWidth;

        if (width - main - (toc * 2) - (gap * 4) > 0) {
            document.getElementById("toc-container").classList.add("wide");
        } else {
            document.getElementById("toc-container").classList.remove("wide");
        }
    }

    function getOffsetTop(element) {
        if (!element.getClientRects().length) {
            return 0;
        }
        let rect = element.getBoundingClientRect();
        let win = element.ownerDocument.defaultView;
        return rect.top + win.pageYOffset;   
    }
</script>
  <div class="post-content"><h2 id="type-mutex-struct-">type Mutex struct 🚀<a hidden class="anchor" aria-hidden="true" href="#type-mutex-struct-">#</a></h2>
<p>包说明：</p>
<ol>
<li>sync 包提供了基本的<strong>同步原语</strong>，如互斥锁。</li>
<li>除了 Once 和 WaitGroup 类型之外，大多数都供底层库例程使用。</li>
<li>更高层次的同步最好通过 channels 和通信来完成。</li>
<li>包含在此包中定义的类型的值<strong>不应被复制</strong>。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// Package sync provides basic synchronization primitives such as mutual
</span></span></span><span class="line"><span class="cl"><span class="c1">// exclusion locks. Other than the Once and WaitGroup types, most are intended
</span></span></span><span class="line"><span class="cl"><span class="c1">// for use by low-level library routines. Higher-level synchronization is
</span></span></span><span class="line"><span class="cl"><span class="c1">// better done via channels and communication.
</span></span></span><span class="line"><span class="cl"><span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1">// Values containing the types defined in this package should not be copied.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kn">package</span> <span class="nx">sync</span>
</span></span></code></pre></td></tr></table>
</div>
</div><hr>
<ol>
<li>Mutex 是一把互斥锁。互斥锁的零值是未锁定的。</li>
<li>Mutex 在第一次使用后不能被复制。</li>
<li>在 Go 内存模型的术语中，第 n 次调用 Unlock，第 m 次调用 Lock 在同步完成以前 任何 n &lt; m。</li>
<li>成功调用 TryLock 等同于调用 Lock。调用 TryLock 失败根本不会建立任何关系 在同步完成以前。</li>
<li>它是一把结合了【自旋锁】和【信号量】优化过的锁。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// A Mutex is a mutual exclusion lock.
</span></span></span><span class="line"><span class="cl"><span class="c1">// The zero value for a Mutex is an unlocked mutex.
</span></span></span><span class="line"><span class="cl"><span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1">// A Mutex must not be copied after first use.
</span></span></span><span class="line"><span class="cl"><span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1">// In the terminology of the Go memory model,
</span></span></span><span class="line"><span class="cl"><span class="c1">// the n&#39;th call to Unlock “synchronizes before” the m&#39;th call to Lock
</span></span></span><span class="line"><span class="cl"><span class="c1">// for any n &lt; m.
</span></span></span><span class="line"><span class="cl"><span class="c1">// A successful call to TryLock is equivalent to a call to Lock.
</span></span></span><span class="line"><span class="cl"><span class="c1">// A failed call to TryLock does not establish any “synchronizes before”
</span></span></span><span class="line"><span class="cl"><span class="c1">// relation at all.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">type</span> <span class="nx">Mutex</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Mutex 的状态信息
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">state</span> <span class="kt">int32</span>	<span class="c1">// 初始时为 0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    
</span></span><span class="line"><span class="cl">    <span class="c1">// semaphore 相关字段，该字段也是为什么 Mutex 不让拷贝的原因
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">sema</span>  <span class="kt">uint32</span> <span class="c1">// 初始时为 0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><img loading="lazy" src="images/Mutex-001.png" alt=""  />
</p>


<p><details >
  <summary markdown="span">Mutex 的内存布局：</summary>
  <blockquote>
<ol>
<li>Mutex 是一个互斥锁，可以创建为其他结构体的字段，零值为解锁状态。</li>
<li>Mutex 类型的锁和线程无关，可以由不同的线程加锁和解锁。</li>
<li><strong>Mutex</strong> 结构布局：
<ul>
<li><strong>state</strong> 记录 Mutex 的相关信息。</li>
<li><strong>sema</strong> 在 Mutex 中没有任何作用，主要是在 semaphore 中，该字段是 Mutex 不能被拷贝的根本原因，在 semaphore 中主要标识有 wakeup 发生。</li>
</ul>
</li>
</ol>
</blockquote>

</details></p>



<p><details >
  <summary markdown="span">【<strong>正常模式</strong>】和【<strong>饥饿模式</strong>】：</summary>
  <blockquote>
<ol>
<li><strong>正常模式</strong>：一个尝试加锁的 goroutine 会先自旋几次，尝试通过原子操作获得锁，若几次自旋之后仍不能获得锁，则通过信号量（semaphore）排队等待。所有的等待者会按照先入先出（FIFO）的顺序排队，但是当一个等待者被唤醒后并不会直接拥有锁，而是需要和后来者（处于自旋阶段，尚未排队等待的协程）竞争。这种情况下后来者更有优势，一方面原因是后来者正在CPU上运行，自然比刚唤醒的 goroutine 更有优势，另一方面处于自旋状态的 goroutine 可以有很多，而被唤醒的 goroutine 每次只有一个，所以被唤醒的 goroutine 有很大概率获取不到锁，这种情况下它会被重新插入队列的头部，而不是尾部。当一个 goroutine 本次加锁等待的时间超过了 1ms 后，它会把当前 Mutex 切换至饥饿状态。</li>
<li><strong>饥饿模式</strong>：Mutex 的所有权从执行 Unlock 的 goroutine 直接传递给等待队列头部的 goroutine。后来者不会自旋，也不会尝试获得锁，它们会直接从队列的尾部排队等待，即使 Mutex 处于 Unlocked 状态。当一个等待者获得了锁之后，它会在以下两种情况时将 Mutex 由饥饿模式切换回正常模式：(1)它是最后一个等待者，即等待队列空了。(2)它的等待时间小于1ms，也就是它刚来不久，后面自然更没有饥饿的 goroutine 了。</li>
</ol>
<ul>
<li>正常模式下 Mutex 有更好的性能，但是饥饿模式对于防止尾端延长（队列尾端的 goroutine 迟迟抢不到锁）来讲特别重要。</li>
</ul>
</blockquote>

</details></p>

<h3 id="const">const<a hidden class="anchor" aria-hidden="true" href="#const">#</a></h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">const</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 是否上锁标志位；0-未上锁，1-已上锁；
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">mutexLocked</span> <span class="p">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="kc">iota</span>	   <span class="c1">// 001
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 是否有 goroutine 从阻塞中被唤醒；0-没有；1-有；
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 当该标志位被设置时，Unlock 操作不会唤醒排队的 goroutine。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">mutexWoken</span>				   <span class="c1">// 010
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 是否处于饥饿模式；0-非饥饿，1-饥饿；
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">mutexStarving</span>			   <span class="c1">// 100
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 最低位存在3个bit位标识特俗信息，分别为上述的 mutexLocked、mutexWoken、mutexStarving
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">mutexWaiterShift</span> <span class="p">=</span> <span class="kc">iota</span>		<span class="c1">// 3
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    
</span></span><span class="line"><span class="cl">    <span class="c1">// 互斥公平
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 互斥量可以有两种操作模式:正常(normal)和饥饿(starvation)。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 在正常模式(normal mode)下：等待的waiters按FIFO(先进先出)顺序排队，但被唤醒的waiter不拥有互斥锁，并与新到达的goroutines竞争所有权。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 		新加入的goroutines有一个优势，它们已经在CPU上运行，并且可能有很多，所以唤醒的waiters很有可能会失败。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 		在这种情况下，它被重新安排在等待队列的前面。如果waiter超过1ms未能获取互斥锁，它将互斥锁切换到饥饿模式。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 在饥饿模式(starvation mode)下：互斥锁的所有权直接从正在解锁的goroutine移交给队列前面的waiter。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 		新到达的goroutines不会尝试获取互斥锁，即使它看起来已经解锁，也不会尝试旋转。相反，它们把自己排在等待队列的尾部。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 如果一个waiter收到互斥锁的所有权，并且发现
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//		1) 它是队列中最后一个waiter，或者 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//		2) 它等待的时间少于1毫秒，它会将互斥锁切换回正常工作模式。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 普通模式(Normal mode)具有更好的性能，因为goroutine可以连续多次获取互斥量，即使有阻塞的等待。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 饥饿模式(Starvation mode)对于预防有些g一值获取不到锁的尾延迟具有重要意义。(该模式防止有些始终拿不到锁的一直等待在信号池里面的goroutine)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    
</span></span><span class="line"><span class="cl">    <span class="c1">// 正常模式 &lt;-&gt; 饥饿模式 相互转换的时间阀门
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 饥饿模式，当前从semaphore中wakeup的goroutine的sleep时间超过1ms，再次获取锁失败时会被标记为饥饿模式
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 饥饿模式下：state 值的 mutexLocked和mutexWoken 位可能为0或1，被唤醒的goroutine mutexLocked和mutexWoken 位都为0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">starvationThresholdNs</span> <span class="p">=</span> <span class="mf">1e6</span>	<span class="c1">// sync.Mutex 进入饥饿模式的等待时间阈值1ms。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">)</span>
</span></span></code></pre></td></tr></table>
</div>
</div><hr>
<h3 id="lock">Lock()<a hidden class="anchor" aria-hidden="true" href="#lock">#</a></h3>
<ol>
<li>Lock 锁住 m。</li>
<li>如果锁已经被使用，调用 goroutine 会阻塞，直到 mutex 可用。</li>
<li>Lock 和 Unlock 是一对操作。</li>
<li>该方法主要通过 atomic 函数实现了Fast path，相应的Slow path被单独放在了lockSlow()方法中。</li>
<li>根据源码注释的说法，这样是为了便于编译器对 Fast path 进行内联优化。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// Lock locks m.
</span></span></span><span class="line"><span class="cl"><span class="c1">// If the lock is already in use, the calling goroutine
</span></span></span><span class="line"><span class="cl"><span class="c1">// blocks until the mutex is available.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">m</span> <span class="o">*</span><span class="nx">Mutex</span><span class="p">)</span> <span class="nf">Lock</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 1) 使用CAS尝试获取锁
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// Fast path期望 Mutex 处于 Unlocked 状态，没有 goroutine 在排队，更不会饥饿。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 理想状态下，一个CAS操作就可以获得锁。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    
</span></span><span class="line"><span class="cl">    <span class="c1">// Fast path: grab unlocked mutex.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 快速路径：获取解锁的互斥量。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 原子操作比较 m.state 的旧值为 0 并交换成新值 1，成功则表示获取到锁。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 这种情况发生在 state=0 时，没有等待的goroutine。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">CompareAndSwapInt32</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">m</span><span class="p">.</span><span class="nx">state</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">mutexLocked</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="nx">race</span><span class="p">.</span><span class="nx">Enabled</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nx">race</span><span class="p">.</span><span class="nf">Acquire</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">m</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c1">// 2) m.state != 0 时都会走 Slow path
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// CAS 操作没能获得锁，就需要进入 Slow path了。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    
</span></span><span class="line"><span class="cl">    <span class="c1">// Slow path (outlined so that the fast path can be inlined)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 如果上面快速方式拿取不到锁，则去和其他竞争。上面情况拿不到锁，可能：
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//  1. 存在有其他goroutine正在持有锁。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//  2. 不存在其他goroutine持有锁，存在被唤醒的goroutine或还有等待的goroutine。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 当前可能处于【正常模式】或【饥饿模式】
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">m</span><span class="p">.</span><span class="nf">lockSlow</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="lockslow">lockSlow()<a hidden class="anchor" aria-hidden="true" href="#lockslow">#</a></h4>
<ol>
<li>如果调用者拿取不到锁，则下面操作流程是先自旋试图拿去锁，实在拿取不到锁则进入信号池去等待拿取锁。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span><span class="lnt">113
</span><span class="lnt">114
</span><span class="lnt">115
</span><span class="lnt">116
</span><span class="lnt">117
</span><span class="lnt">118
</span><span class="lnt">119
</span><span class="lnt">120
</span><span class="lnt">121
</span><span class="lnt">122
</span><span class="lnt">123
</span><span class="lnt">124
</span><span class="lnt">125
</span><span class="lnt">126
</span><span class="lnt">127
</span><span class="lnt">128
</span><span class="lnt">129
</span><span class="lnt">130
</span><span class="lnt">131
</span><span class="lnt">132
</span><span class="lnt">133
</span><span class="lnt">134
</span><span class="lnt">135
</span><span class="lnt">136
</span><span class="lnt">137
</span><span class="lnt">138
</span><span class="lnt">139
</span><span class="lnt">140
</span><span class="lnt">141
</span><span class="lnt">142
</span><span class="lnt">143
</span><span class="lnt">144
</span><span class="lnt">145
</span><span class="lnt">146
</span><span class="lnt">147
</span><span class="lnt">148
</span><span class="lnt">149
</span><span class="lnt">150
</span><span class="lnt">151
</span><span class="lnt">152
</span><span class="lnt">153
</span><span class="lnt">154
</span><span class="lnt">155
</span><span class="lnt">156
</span><span class="lnt">157
</span><span class="lnt">158
</span><span class="lnt">159
</span><span class="lnt">160
</span><span class="lnt">161
</span><span class="lnt">162
</span><span class="lnt">163
</span><span class="lnt">164
</span><span class="lnt">165
</span><span class="lnt">166
</span><span class="lnt">167
</span><span class="lnt">168
</span><span class="lnt">169
</span><span class="lnt">170
</span><span class="lnt">171
</span><span class="lnt">172
</span><span class="lnt">173
</span><span class="lnt">174
</span><span class="lnt">175
</span><span class="lnt">176
</span><span class="lnt">177
</span><span class="lnt">178
</span><span class="lnt">179
</span><span class="lnt">180
</span><span class="lnt">181
</span><span class="lnt">182
</span><span class="lnt">183
</span><span class="lnt">184
</span><span class="lnt">185
</span><span class="lnt">186
</span><span class="lnt">187
</span><span class="lnt">188
</span><span class="lnt">189
</span><span class="lnt">190
</span><span class="lnt">191
</span><span class="lnt">192
</span><span class="lnt">193
</span><span class="lnt">194
</span><span class="lnt">195
</span><span class="lnt">196
</span><span class="lnt">197
</span><span class="lnt">198
</span><span class="lnt">199
</span><span class="lnt">200
</span><span class="lnt">201
</span><span class="lnt">202
</span><span class="lnt">203
</span><span class="lnt">204
</span><span class="lnt">205
</span><span class="lnt">206
</span><span class="lnt">207
</span><span class="lnt">208
</span><span class="lnt">209
</span><span class="lnt">210
</span><span class="lnt">211
</span><span class="lnt">212
</span><span class="lnt">213
</span><span class="lnt">214
</span><span class="lnt">215
</span><span class="lnt">216
</span><span class="lnt">217
</span><span class="lnt">218
</span><span class="lnt">219
</span><span class="lnt">220
</span><span class="lnt">221
</span><span class="lnt">222
</span><span class="lnt">223
</span><span class="lnt">224
</span><span class="lnt">225
</span><span class="lnt">226
</span><span class="lnt">227
</span><span class="lnt">228
</span><span class="lnt">229
</span><span class="lnt">230
</span><span class="lnt">231
</span><span class="lnt">232
</span><span class="lnt">233
</span><span class="lnt">234
</span><span class="lnt">235
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// 竞争获取锁
</span></span></span><span class="line"><span class="cl"><span class="c1">//  1. 先自旋等待其他goroutine解锁（满足自旋条件时）
</span></span></span><span class="line"><span class="cl"><span class="c1">//  2. 尝试修改 state 值竞争锁
</span></span></span><span class="line"><span class="cl"><span class="c1">//  3. 竞争成功，获取锁退出
</span></span></span><span class="line"><span class="cl"><span class="c1">//  4. 竞争失败，sleep goroutine
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">m</span> <span class="o">*</span><span class="nx">Mutex</span><span class="p">)</span> <span class="nf">lockSlow</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 1. 当前goroutine首次进入semaphore池sleep的时间/纳秒，下次wakeup后用于判断 正常模式 &lt;-&gt; 饥饿模式 转换
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 2. queueLifo := waitStartTime != 0; 进入 semaphore 池的首或尾，false.尾 true.首
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kd">var</span> <span class="nx">waitStartTime</span> <span class="kt">int64</span>		
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c1">// mutex模式 【false.正常模式】 【true.饥饿模式】
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//  1. 正常模式下，新来获取锁的goroutine如果满足条件会进行自旋等待锁被释放，如果还拿取不到锁则去信号池最前面等待。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//  2. 饥饿模式下，新来获取锁的goroutine不会进行自旋，直接去信号池的末尾去等待。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">starving</span> <span class="o">:=</span> <span class="kc">false</span>		    
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c1">// 是否有goroutine被唤醒 false.没有
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 有被唤醒的goroutine时，会试图去拿去锁，可能是跟当前正在获取锁的goroutine竞争
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//  1. 在自旋情况下满足条件设置 awoke 为 true
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//  2. 非饥饿模式下被唤醒的goroutine awoke 会被设置为 true
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//  3. 在饥饿模式下 awoke 变量没有用
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">awoke</span> <span class="o">:=</span> <span class="kc">false</span>	<span class="c1">// 用于原子设置 mutexWoken 位，通知 Unlock 函数有 woken 的goroutine了，不要去wakeup goroutine
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    
</span></span><span class="line"><span class="cl">    <span class="c1">// 记录旋转的次数，当没有获取锁时，会尝试4次去自旋获取
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">iter</span> <span class="o">:=</span> <span class="mi">0</span>	<span class="c1">// 自旋计数器	
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    
</span></span><span class="line"><span class="cl">    <span class="c1">// 以下代码都是从 old -&gt; new 的原子操作，去尝试修改 state 值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    
</span></span><span class="line"><span class="cl">    <span class="nx">old</span> <span class="o">:=</span> <span class="nx">m</span><span class="p">.</span><span class="nx">state</span>	<span class="c1">// 旧值state
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    
</span></span><span class="line"><span class="cl">    <span class="c1">// 该循环只有在获取到锁的时候才会退出，因此所有未获取到锁的goroutine都将在这里等待获取锁
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">for</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 1) 饥饿模式下不要自旋，因为所有权按照顺序传递，自旋没有意义。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 正常模式下锁没有被释放满足自旋条件需要自旋。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        
</span></span><span class="line"><span class="cl">        <span class="c1">// Don&#39;t spin in starvation mode, ownership is handed off to waiters
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// so we won&#39;t be able to acquire the mutex anyway.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 不要在饥饿模式下旋转，所有权已移交给waiters，因此我们无论如何都无法获得互斥锁
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">//  1. old&amp;(mutexLocked|mutexStarving) == mutexLocked; Mutex没有处于饥饿模式并且已被锁定。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">//  2. runtime_canSpin(iter); 报告当前旋转要求条件。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">//	主动旋转条件：
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">//		旋转次数小于4次 并且 多核CPU运行 并且除了当前P还有其他P正在运行（不是空闲或自旋状态的P）并且 当前P没有其他g了
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">//		这种情况需要去尝试自旋获取下锁，其他情况则不需要自旋去获取锁
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 以下自旋的意义，停留片刻等待其他goroutine让出锁，然后标记mutexWoken存在被唤醒的goroutine使自己获取锁优先级更高
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="nx">old</span><span class="o">&amp;</span><span class="p">(</span><span class="nx">mutexLocked</span><span class="p">|</span><span class="nx">mutexStarving</span><span class="p">)</span> <span class="o">==</span> <span class="nx">mutexLocked</span> <span class="o">&amp;&amp;</span> <span class="nf">runtime_canSpin</span><span class="p">(</span><span class="nx">iter</span><span class="p">)</span> <span class="p">{</span>	<span class="c1">// 自旋在这里
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// Active spinning makes sense.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// Try to set mutexWoken flag to inform Unlock
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// to not wake other blocked goroutines.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// 主动旋转是有道理的。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// 尝试设置 mutexflag 来通知 Unlock 不要唤醒其他被阻塞在信号池的goroutines。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// 以下逻辑是处于自旋，自旋的意义在于标记有正在被唤醒的goroutine，其他线程不要再次唤醒导致过多goroutine被唤醒
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">//  1. !awoke; ：没有标记当前goroutine被唤醒
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">//  2. old&amp;mutexWoken == 0; ：没有被唤醒的goroutine，包括其他g和当前g
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">//  3. old&gt;&gt;mutexWaiterShift != 0; ：存在等待排队在信号池的goroutine
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">//  4. atomic.CompareAndSwapInt32(&amp;m.state, old, old|mutexWoken); 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">//		设置标志有goroutine被唤醒，这里设置成功那unlock则不会再去唤醒goroutine
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="k">if</span> <span class="p">!</span><span class="nx">awoke</span> <span class="o">&amp;&amp;</span> <span class="nx">old</span><span class="o">&amp;</span><span class="nx">mutexWoken</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">old</span><span class="o">&gt;&gt;</span><span class="nx">mutexWaiterShift</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
</span></span><span class="line"><span class="cl">                <span class="nx">atomic</span><span class="p">.</span><span class="nf">CompareAndSwapInt32</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">m</span><span class="p">.</span><span class="nx">state</span><span class="p">,</span> <span class="nx">old</span><span class="p">,</span> <span class="nx">old</span><span class="p">|</span><span class="nx">mutexWoken</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="c1">// 标记为唤醒状态，主要是告诉unlock不要再去唤醒goroutine了，这里有自旋的在等待
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="nx">awoke</span> <span class="p">=</span> <span class="kc">true</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 短暂延迟一段时间，主要是等待其他g解锁
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// 如果此时Unlock了第一个if则不会再判断为true，直接去争抢锁了
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="nf">runtime_doSpin</span><span class="p">()</span>	
</span></span><span class="line"><span class="cl">            <span class="nx">iter</span><span class="o">++</span>
</span></span><span class="line"><span class="cl">            <span class="nx">old</span> <span class="p">=</span> <span class="nx">m</span><span class="p">.</span><span class="nx">state</span>	<span class="c1">// 从新赋值给old
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="k">continue</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">        <span class="c1">// 2) 锁可能已被释放尝试竞争获取，或锁还未解除去sleep。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        
</span></span><span class="line"><span class="cl">        <span class="c1">// 代码执行到这里，只可能处于以下几种情况
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">//  1. 自旋次数以完，状态依然是 mutexLocked。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">//  2. 状态是 mutexStarving 处于饥饿状态。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">//  3. 状态是未加锁状态，锁已被解除。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 	（处于饥饿模式） 或 （自旋次数超过4次） 或 （当前其他goroutine已Unlock）或 （不满足自旋条件）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">//	如果锁已Unlock，那么尝试去获取锁；如果锁处于Lock，那么也尝试获取，否则加入到信号池中等待
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        
</span></span><span class="line"><span class="cl">        <span class="c1">// old 是本轮原子操作的 state 值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// new 是本轮需要争抢锁修改后的 state 值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 正常模式下:
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">//  1. 在old未持有锁情况下，谁先原子操作从 old 修改为 new 谁就先获取到锁
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">//  2. 在old持有锁情况下，当前goroutine需要sleep
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">new</span> <span class="o">:=</span> <span class="nx">old</span>
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">        <span class="c1">// 2.1) 正常模式下需要争抢锁，因此需要设置mutexLocked状态
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        
</span></span><span class="line"><span class="cl">        <span class="c1">// Don&#39;t try to acquire starving mutex, new arriving goroutines must queue.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 不要尝试获取处于饥饿的Mutex，后来的goroutines必须排队。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 处于饥饿模式下，为什么不需要设置mutexLocked标志呢？
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">//  1. 处于饥饿模式下锁的持有权是手把手交给后面等待的goroutine，因此mutexLocked标志设置不设置不重要
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">//  2. 对于新来的goroutine，mutexLocked位可能为0或1，但是当前goroutine不会去挣抢锁直接sleep，因此mutexLocked位不重要
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 	3. 对于从sleep中wakeup的goroutine，一定是来自Unlock函数而来自该函数mutexLocked位一定是0，已被解锁
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="nx">old</span><span class="o">&amp;</span><span class="nx">mutexStarving</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>	<span class="c1">// 处于正常模式
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// new表示新值修改的状态 mutexLocked需要锁，不管当前是Lock或Unlock当前都需要设置mutexLocked表示需要去争抢锁
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="nx">new</span> <span class="o">|=</span> <span class="nx">mutexLocked</span>	
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">        <span class="c1">// 2.2) 锁还未被释放 或 处于饥饿模式下 这两种情况下都会去sleep，因此需要加一。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        
</span></span><span class="line"><span class="cl">        <span class="c1">// 如果old锁没释放 或 处于饥饿状态，那么当前的goroutine则是需要被加入到信号池里面去的
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="nx">old</span><span class="o">&amp;</span><span class="p">(</span><span class="nx">mutexLocked</span><span class="p">|</span><span class="nx">mutexStarving</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>	<span class="c1">// 处于Lock或则饥饿模式当前g需要加入到信号池
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="nx">new</span> <span class="o">+=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="nx">mutexWaiterShift</span>	<span class="c1">// 数量增加1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">        <span class="c1">// 2.3) 当前 goroutine 将 mutex 切换至饥饿模式
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 如果 mutex 已经处于 unlocked 状态，就不要切换了，
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 因为 Unlock() 函数认为处于饥饿模式的 mutex 等待队列不为空。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        
</span></span><span class="line"><span class="cl">        <span class="c1">// The current goroutine switches mutex to starvation mode.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// But if the mutex is currently unlocked, don&#39;t do the switch.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// Unlock expects that starving mutex has waiters, which will not
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// be true in this case.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 当前的 goroutine 将互斥锁切换到饥饿模式，但如果互斥锁当前已解锁，就不要切换。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// Unlock期望处于饥饿状态的互斥锁有waiters，但在本例中并非如此。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// starving=true 发生在：这个goroutine被加入到信号池后再度被唤醒去争抢锁时，发现等待时间已经超过1ms时
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// old&amp;mutexLocked != 0，表示这个被唤醒的goroutine再次争抢锁时锁没被其他gorutine释放，这次再争抢将失败则会标记成饥饿模式
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="nx">starving</span> <span class="o">&amp;&amp;</span> <span class="nx">old</span><span class="o">&amp;</span><span class="nx">mutexLocked</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>	<span class="c1">// 这种情况下当前goroutine基本拿去不到锁
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="nx">new</span> <span class="o">|=</span> <span class="nx">mutexStarving</span> <span class="c1">// 标记成饥饿模式时，锁一定被其他持有；但是唤醒的g处于饥饿模式时，锁一定是Unlock状态
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">        <span class="c1">// 2.4) 当前goroutine是被唤醒的，检查并清除标志位
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        
</span></span><span class="line"><span class="cl">        <span class="c1">// awoke=true 表示来自自旋或被唤醒的goroutine两种形式
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">//  1. 自旋状态下 awoke=true，state 中 mutexWoken 位已被设置为 1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">//  2. 被唤醒的goroutine下 awoke=true 在本函数的唤醒后被设置，而 state 中 mutexWoken 位在Unlock函数中被设置
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 因此 awoke=true 就一定存在 state 中 mutexWoken 位为1，new&amp;mutexWoken != 0成立
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="nx">awoke</span> <span class="p">{</span>	<span class="c1">// awoke有等待的goroutine被唤醒
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// The goroutine has been woken from sleep,
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// so we need to reset the flag in either case.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// goroutine 已经从睡眠中唤醒，所以我们需要在任何一种情况下重置标志
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="k">if</span> <span class="nx">new</span><span class="o">&amp;</span><span class="nx">mutexWoken</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>	<span class="c1">// 不论来自自旋或被唤醒的goroutine这里都不能为0，正常状况下
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="nf">throw</span><span class="p">(</span><span class="s">&#34;sync: inconsistent mutex state&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="nx">new</span> <span class="o">&amp;^=</span> <span class="nx">mutexWoken</span> <span class="c1">// 清除被唤醒标志位mutexWoken，因为下面即将去争抢锁，或者载入去信号池等待
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">        <span class="c1">// 尝试使用原子修改state，所有的goroutine都会通过该条件，但是一轮只能成功一个
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 这里修改m.state成功了，并不代表一定获取到了锁，也有可能是当前g需要加入到信号池中去
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">CompareAndSwapInt32</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">m</span><span class="p">.</span><span class="nx">state</span><span class="p">,</span> <span class="nx">old</span><span class="p">,</span> <span class="nx">new</span><span class="p">)</span> <span class="p">{</span>	
</span></span><span class="line"><span class="cl">            <span class="c1">// 如果上一个拿去到锁的state是正常模式并没有锁，则这里直接退出，这里表示当前goroutine获取到了锁，正常模式都是从这里退出的
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// 正常模式下获取到锁的情况，这里不会出现标记成饥饿模式但这里又判断为true退出了的情况，原因是标记成饥饿模式的前置条件是当前old是Lock
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="k">if</span> <span class="nx">old</span><span class="o">&amp;</span><span class="p">(</span><span class="nx">mutexLocked</span><span class="p">|</span><span class="nx">mutexStarving</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>	<span class="c1">// 谁先拿到锁退出，接到执行goroutine后面代码
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="k">break</span> <span class="c1">// locked the mutex with CAS
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="p">}</span>
</span></span><span class="line"><span class="cl">            
</span></span><span class="line"><span class="cl">            <span class="c1">// 后面处理逻辑是之前有锁，这个goroutine需要去排队情况，或当前模式处于饥饿模式，直接把该goroutine加入到尾部
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            
</span></span><span class="line"><span class="cl">            <span class="c1">// If we were already waiting before, queue at the front of the queue.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// 如果我们之前已经在等待，请在队列的前面排队
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// waitStartTime如果不等于0说明先前入队过有被唤醒过，正常第一次入队这里是false
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// 被唤醒之后没有抢到锁，需要插入队列头部，而不是尾部。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="nx">queueLifo</span> <span class="o">:=</span> <span class="nx">waitStartTime</span> <span class="o">!=</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 首次进入信号池去等待时
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="k">if</span> <span class="nx">waitStartTime</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>	<span class="c1">// 这里表示这个goroutine从信号池中第一次被唤醒依然没有获取到锁，从新设置时间
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="nx">waitStartTime</span> <span class="p">=</span> <span class="nf">runtime_nanotime</span><span class="p">()</span>	<span class="c1">// 注意：除第一次入队后后面每次缓存waitStartTime时间都不会被刷新
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="p">}</span>
</span></span><span class="line"><span class="cl">            
</span></span><span class="line"><span class="cl">            <span class="c1">// 这里存在被唤醒但是还是没拿到锁的情况会再次被入队
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// runtime_SemacquireMutex的queueLifo参数为true则是插入的信号池头部，false插入到尾部
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">//		首次进入信号池，则直接排在尾部
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">//		从信号池中出来又争抢失败进入信号池排在头部
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// 如我们取出gorutine则是从头部开始往后取，这也就是我们说的先进先出
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// 因为第一次加入信号池的都是插入到尾部，当再被唤醒依然没有获取到锁时，则是被放回到头部
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// 当前goroutine去排队，这里当前groutine被调离工作线程等待抢到锁后继续后面执行
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="nf">runtime_SemacquireMutex</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">m</span><span class="p">.</span><span class="nx">sema</span><span class="p">,</span> <span class="nx">queueLifo</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>	
</span></span><span class="line"><span class="cl">            
</span></span><span class="line"><span class="cl">            <span class="c1">// 被唤醒的g，接到从这里执行尝试去获取锁；可能当前处于饥饿模式或处于正常模式，唤醒g的相关代码位于Unlock函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            
</span></span><span class="line"><span class="cl">            <span class="c1">// 如果等待的时间大于1ms则标记成饥饿模式，以下逻辑是当前goroutine被唤醒后再次尝试获取锁
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// 等待时间超过了1ms，等待时间太久需要被标记为饥饿状态
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="nx">starving</span> <span class="p">=</span> <span class="nx">starving</span> <span class="o">||</span> <span class="nf">runtime_nanotime</span><span class="p">()</span><span class="o">-</span><span class="nx">waitStartTime</span> <span class="p">&gt;</span> <span class="nx">starvationThresholdNs</span>
</span></span><span class="line"><span class="cl">            <span class="nx">old</span> <span class="p">=</span> <span class="nx">m</span><span class="p">.</span><span class="nx">state</span>	<span class="c1">// 获取当前的状态
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// 如果处于饥饿模式，处于饥饿模式下唤醒的goroutine立即获取锁，因为正常来抢的goroutine都会被入队，
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// 然后一个个来获取
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// 所有饥饿模式下获取锁的出口都在这里，该条件满足说明当前goroutine获取到锁持有权
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="k">if</span> <span class="nx">old</span><span class="o">&amp;</span><span class="nx">mutexStarving</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>	
</span></span><span class="line"><span class="cl">                <span class="c1">// If this goroutine was woken and mutex is in starvation mode,
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="c1">// ownership was handed off to us but mutex is in somewhat
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="c1">// inconsistent state: mutexLocked is not set and we are still
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="c1">// accounted as waiter. Fix that.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="c1">// 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="c1">// 当前代码位置的 goroutine 肯定是被唤醒的，而且 Mutex 处于饥饿模式
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="c1">// 所有权被直接交给当前 goroutine
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="c1">// 但是这种情况下 mutex 的 state 会与实际情况不一致
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="c1">// mutexLocked 标志位没有设置
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="c1">// 而且等待者计数中也没有减去当前 goroutine。需要修复 state
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="c1">// 注意饥饿模式下传递 mutex 所有权不会设置 mutexWoken 标志，只有正常模式下唤醒才会
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="c1">// 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="c1">// 饥饿模式下 old&gt;&gt;mutexWaiterShift != 0，当前一定不能是最后一个，
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="c1">// 因为下面 old&gt;&gt;mutexWaiterShift == 1 会退出饥饿模式
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="c1">// old&amp;(mutexLocked|mutexWoken) != 0 因为处于饥饿模式下，所有的goroutine都会去排队sleep，
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="c1">// 被wakeup的goroutine一定来自Unlock函数，
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="c1">// 此时mutexLocked一定解锁，mutexWoken一定是被清除的
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="k">if</span> <span class="nx">old</span><span class="o">&amp;</span><span class="p">(</span><span class="nx">mutexLocked</span><span class="p">|</span><span class="nx">mutexWoken</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">||</span> <span class="nx">old</span><span class="o">&gt;&gt;</span><span class="nx">mutexWaiterShift</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                    <span class="c1">// 饥饿模式下，mutexLocked和mutexWoken必定为0，参看上面代码。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                    <span class="nf">throw</span><span class="p">(</span><span class="s">&#34;sync: inconsistent mutex state&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                <span class="p">}</span>
</span></span><span class="line"><span class="cl">                <span class="c1">// +mutexLocked -1&lt;&lt;mutexWaiterShift
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="nx">delta</span> <span class="o">:=</span> <span class="nb">int32</span><span class="p">(</span><span class="nx">mutexLocked</span> <span class="o">-</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="nx">mutexWaiterShift</span><span class="p">)</span>	<span class="c1">// 将等待的数量减一
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="c1">// 等待时间小于1ms 或 当前goroutine是队列最后一个，则标记退出饥饿模式
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="k">if</span> <span class="p">!</span><span class="nx">starving</span> <span class="o">||</span> <span class="nx">old</span><span class="o">&gt;&gt;</span><span class="nx">mutexWaiterShift</span> <span class="o">==</span> <span class="mi">1</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                    <span class="c1">// Exit starvation mode.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                    <span class="c1">// Critical to do it here and consider wait time.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                    <span class="c1">// Starvation mode is so inefficient, that two goroutines
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                    <span class="c1">// can go lock-step infinitely once they switch mutex
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                    <span class="c1">// to starvation mode.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                    <span class="nx">delta</span> <span class="o">-=</span> <span class="nx">mutexStarving</span>	<span class="c1">// 退出饥饿模式
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="p">}</span>
</span></span><span class="line"><span class="cl">                <span class="nx">atomic</span><span class="p">.</span><span class="nf">AddInt32</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">m</span><span class="p">.</span><span class="nx">state</span><span class="p">,</span> <span class="nx">delta</span><span class="p">)</span> <span class="c1">// 修改state，返回直接返回，应为该goroutine 获取到锁了
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="k">break</span>	<span class="c1">// 饥饿模式从这里退出，因此饥饿模式下被唤醒的goroutine直接从这里退出
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="p">}</span>
</span></span><span class="line"><span class="cl">            
</span></span><span class="line"><span class="cl">            <span class="c1">// 正常模式下，设置为唤醒去争抢锁
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            
</span></span><span class="line"><span class="cl">            <span class="nx">awoke</span> <span class="p">=</span> <span class="kc">true</span>	<span class="c1">// state的mutexWoken位在Unlock函数中被设置
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="nx">iter</span> <span class="p">=</span> <span class="mi">0</span>	<span class="c1">// 自旋次数重置
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 从old-&gt;new 原子设置，如果设置失败从新再来
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="nx">old</span> <span class="p">=</span> <span class="nx">m</span><span class="p">.</span><span class="nx">state</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">race</span><span class="p">.</span><span class="nx">Enabled</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">race</span><span class="p">.</span><span class="nf">Acquire</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">m</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="sync_runtime_canspin">sync_runtime_canSpin()<a hidden class="anchor" aria-hidden="true" href="#sync_runtime_canspin">#</a></h4>
<ol>
<li>sync.Mutex 主动旋转条件。</li>
<li>不主动旋转条件：
<ol>
<li>【旋转次数大于等于4次】或【单核CPU在运行】 或【除了当前P其他P都处于空闲或自旋状态】，不需要主动去旋转等待获取锁。</li>
<li>如果当前P的runq不为空，也没必要去自旋，因为里面的g还等着去执行，直接把当前g挂起。</li>
</ol>
</li>
<li>主动旋转条件：
<ol>
<li>【旋转次数小于4次】并且【多核CPU运行】并且【除了当前P还有其他P正在运行】（不是空闲或自旋状态的P）并且 【当前P没有其他g了】。</li>
<li>这种情况需要去尝试自旋获取下锁，其他情况则不需要自旋去获取锁。</li>
</ol>
</li>
<li><code>runtime/proc.go</code>文件中。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// Active spinning for sync.Mutex.
</span></span></span><span class="line"><span class="cl"><span class="c1">//go:linkname sync_runtime_canSpin sync.runtime_canSpin
</span></span></span><span class="line"><span class="cl"><span class="c1">//go:nosplit
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">sync_runtime_canSpin</span><span class="p">(</span><span class="nx">i</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// sync.Mutex is cooperative, so we are conservative with spinning.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// Spin only few times and only if running on a multicore machine and
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// GOMAXPROCS&gt;1 and there is at least one other running P and local runq is empty.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// As opposed to runtime mutex we don&#39;t do passive spinning here,
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// because there can be work on global runq or on other Ps.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// sync.Mutex是合作性的，所以我们对spinning是保守的。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 只旋转几次，且仅当运行在多核计算机和GOMAXPROCS&gt;1上，并且至少有一个其他运行P且本地runq为空时。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 与运行时互斥锁相反，我们在这里不做被动旋转，因为可以在全局runq或其他P上进行工作。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 以下条件满足一项都不会再次自旋去获取锁
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 	1. const active_spin = 4; 最多尝试4次自旋获取
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 	2. var ncpu int32 &lt;= 1; 如果是单核CPU
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 	3. gomaxprocs &lt;= int32(sched.npidle+sched.nmspinning)+1;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//    3.1 gomaxprocs：表示总的P
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//    3.2 sched.npidle空闲的P数量
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//    3.3 sched.nmspinning正在自旋的M数量(这里面可能存在正在争抢锁，处在自旋都是只有一个g的情况)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//  除了当前P其他的P都很闲，也不必要自旋了。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nx">i</span> <span class="o">&gt;=</span> <span class="nx">active_spin</span> <span class="o">||</span> <span class="nx">ncpu</span> <span class="o">&lt;=</span> <span class="mi">1</span> <span class="o">||</span> <span class="nx">gomaxprocs</span> <span class="o">&lt;=</span> <span class="nb">int32</span><span class="p">(</span><span class="nx">sched</span><span class="p">.</span><span class="nx">npidle</span><span class="o">+</span><span class="nx">sched</span><span class="p">.</span><span class="nx">nmspinning</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="kc">false</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c1">// 这里不像 runtime.mutex 那样进行消极自旋，因为全局 runq 或其他 P 上或许还有可运行的任务。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    
</span></span><span class="line"><span class="cl">    <span class="c1">// 当前本地P不为空，也不需要自旋再出去尝试获取锁，其他goroutine还等起的。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nx">p</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">().</span><span class="nx">m</span><span class="p">.</span><span class="nx">p</span><span class="p">.</span><span class="nf">ptr</span><span class="p">();</span> <span class="p">!</span><span class="nf">runqempty</span><span class="p">(</span><span class="nx">p</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="kc">false</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="kc">true</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="sync_runtime_dospin">sync_runtime_doSpin()<a hidden class="anchor" aria-hidden="true" href="#sync_runtime_dospin">#</a></h4>
<ol>
<li>短暂的延迟。</li>
<li><code>runtime/proc.go</code> 文件中。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">//go:linkname sync_runtime_doSpin sync.runtime_doSpin
</span></span></span><span class="line"><span class="cl"><span class="c1">//go:nosplit
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">sync_runtime_doSpin</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 循环30次等待
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">procyield</span><span class="p">(</span><span class="nx">active_spin_cnt</span><span class="p">)</span>	<span class="c1">// active_spin_cnt=30
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="procyield">procyield()<a hidden class="anchor" aria-hidden="true" href="#procyield">#</a></h4>
<ol>
<li>短暂的延迟。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-asm" data-lang="asm"><span class="line"><span class="cl"><span class="c1"># runtime/asm_amd.64.s
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nf">TEXT</span> <span class="no">runtime</span><span class="err">·</span><span class="no">procyield</span><span class="p">(</span><span class="no">SB</span><span class="p">),</span><span class="no">NOSPLIT</span><span class="p">,</span><span class="no">$0-0</span>
</span></span><span class="line"><span class="cl">    <span class="nf">MOVL</span>	<span class="no">cycles</span><span class="err">+</span><span class="mi">0</span><span class="p">(</span><span class="no">FP</span><span class="p">),</span> <span class="no">AX</span>	<span class="c1"># AX=30 参数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nl">again:</span>
</span></span><span class="line"><span class="cl">    <span class="nf">PAUSE</span> <span class="c1"># 自旋降低CPU发热和性能优化。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">SUBL</span>	<span class="no">$1</span><span class="p">,</span> <span class="no">AX</span>			<span class="c1"># AX -= 1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">JNZ</span>	<span class="no">again</span>
</span></span><span class="line"><span class="cl">    <span class="nf">RET</span>
</span></span></code></pre></td></tr></table>
</div>
</div><hr>
<h3 id="unlock">Unlock()<a hidden class="anchor" aria-hidden="true" href="#unlock">#</a></h3>
<ol>
<li>Unlock解锁m。</li>
<li>如果m在进入解锁时没有被锁定，则是一个运行时错误。</li>
<li>一个锁定的互斥量与一个特定的goroutine无关。</li>
<li>允许一个goroutine锁定一个互斥量，然后安排另一个goroutine解锁它。</li>
<li>该方法主要通过 atomic 函数实现了 Fast path，相应的 Slow path被单独放在了 unlockSlow() 方法中。</li>
<li>根据源码注释的说法，这样是为了便于编译器对 Fast path 进行内联优化。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// Unlock unlocks m.
</span></span></span><span class="line"><span class="cl"><span class="c1">// It is a run-time error if m is not locked on entry to Unlock.
</span></span></span><span class="line"><span class="cl"><span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1">// A locked Mutex is not associated with a particular goroutine.
</span></span></span><span class="line"><span class="cl"><span class="c1">// It is allowed for one goroutine to lock a Mutex and then
</span></span></span><span class="line"><span class="cl"><span class="c1">// arrange for another goroutine to unlock it.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">m</span> <span class="o">*</span><span class="nx">Mutex</span><span class="p">)</span> <span class="nf">Unlock</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">race</span><span class="p">.</span><span class="nx">Enabled</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">_</span> <span class="p">=</span> <span class="nx">m</span><span class="p">.</span><span class="nx">state</span>
</span></span><span class="line"><span class="cl">        <span class="nx">race</span><span class="p">.</span><span class="nf">Release</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">m</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c1">// 1) 通过原子操作从 state 中减去 mutexLocked，也就是释放锁
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 然后根据 state 的新值(new)来判断是否需要执行 Slow path。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Fast path: drop lock bit.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// Fast path: 直接把锁标志位放开
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 如果之前mutexLocked位为1则修改为0；如果之前mutexLocked位为0则修改为1；
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">new</span> <span class="o">:=</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">AddInt32</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">m</span><span class="p">.</span><span class="nx">state</span><span class="p">,</span> <span class="o">-</span><span class="nx">mutexLocked</span><span class="p">)</span>	<span class="c1">// 如果删除了锁的bit位，state等于0说明没有等待抢锁的goroutine直接返回
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    
</span></span><span class="line"><span class="cl">    <span class="c1">// new为0，意味着没有其他 goroutine 在排队，所以不需要执行额外操作。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// new不为0，则可能需要唤醒某个 goroutine。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    
</span></span><span class="line"><span class="cl">    <span class="c1">// Unlock 执行完后mutex.state!=0 则存在以下可能
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 	正常模式下
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 		1. 当前存在等待的goroutine去唤醒它
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//		2. 当前存在自旋等待的goroutine，则不唤醒其他等待的goroutine
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 饥饿模式下
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 		1. 直接将锁交给等待队列的第一个goroutine
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nx">new</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>	<span class="c1">// 还存在其他等待队列中的goroutine
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// Outlined slow path to allow inlining the fast path.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// To hide unlockSlow during tracing we skip one extra frame when tracing GoUnblock.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 概述了慢速路径以允许内联快速路径
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 为了在跟踪过程中隐藏 unlockSlow，我们在跟踪 GoUnblock 时会跳过一个额外的帧
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">m</span><span class="p">.</span><span class="nf">unlockSlow</span><span class="p">(</span><span class="nx">new</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="unlockslow">unlockSlow()<a hidden class="anchor" aria-hidden="true" href="#unlockslow">#</a></h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">m</span> <span class="o">*</span><span class="nx">Mutex</span><span class="p">)</span> <span class="nf">unlockSlow</span><span class="p">(</span><span class="nx">new</span> <span class="kt">int32</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 判断未加锁的情况下不能多次调用unlock
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 正常逻辑这里 new+mutexLocked 应该为1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="nx">new</span><span class="o">+</span><span class="nx">mutexLocked</span><span class="p">)</span><span class="o">&amp;</span><span class="nx">mutexLocked</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>	<span class="c1">// 这种情况判断之前根本就没加过锁，则去解锁这会直接报错误
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nf">throw</span><span class="p">(</span><span class="s">&#34;sync: unlock of unlocked mutex&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 正常模式下
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nx">new</span><span class="o">&amp;</span><span class="nx">mutexStarving</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 从 old -&gt; new 原子操作，主要是唤醒goroutine
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">old</span> <span class="o">:=</span> <span class="nx">new</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="p">{</span>	<span class="c1">// 以下代码是通过唤醒goroutine和其他正在运行的goroutine去争抢锁
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// If there are no waiters or a goroutine has already
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// been woken or grabbed the lock, no need to wake anyone.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// In starvation mode ownership is directly handed off from unlocking
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// goroutine to the next waiter. We are not part of this chain,
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// since we did not observe mutexStarving when we unlocked the mutex above.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// So get off the way.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// 如果没有waiters，或goroutine已经被叫醒或抢了锁，没有必要叫醒任何人。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// 在饥饿模式下，所有权会从解锁goroutine直接移交给下一个waiter。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// 我们不是这个链的一部分，因为我们在上面解锁互斥锁时没有观察到mutexStarving。所以别挡道。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// 没有等待的goroutine 或 (有其他的goroutine已近获得锁 或 有被唤醒的goroutine 或 当前处于饥饿模式下)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="k">if</span> <span class="nx">old</span><span class="o">&gt;&gt;</span><span class="nx">mutexWaiterShift</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="nx">old</span><span class="o">&amp;</span><span class="p">(</span><span class="nx">mutexLocked</span><span class="p">|</span><span class="nx">mutexWoken</span><span class="p">|</span><span class="nx">mutexStarving</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="k">return</span>	<span class="c1">// 直接返回，不需要再去后续处理
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="p">}</span>
</span></span><span class="line"><span class="cl">            
</span></span><span class="line"><span class="cl">            <span class="c1">// Grab the right to wake someone.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// 等在被唤醒的goroutine数量减一，设置有被唤醒标志
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="nx">new</span> <span class="p">=</span> <span class="p">(</span><span class="nx">old</span> <span class="o">-</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="nx">mutexWaiterShift</span><span class="p">)</span> <span class="p">|</span> <span class="nx">mutexWoken</span>	<span class="c1">// 设置需要唤醒一个goroutine的新状态
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="k">if</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">CompareAndSwapInt32</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">m</span><span class="p">.</span><span class="nx">state</span><span class="p">,</span> <span class="nx">old</span><span class="p">,</span> <span class="nx">new</span><span class="p">)</span> <span class="p">{</span>	<span class="c1">// 原子设置成功，说明没有其他正在争抢或当前争抢成功
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="nf">runtime_Semrelease</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">m</span><span class="p">.</span><span class="nx">sema</span><span class="p">,</span> <span class="kc">false</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>	<span class="c1">// 取出等待的goroutine放入本地P等待被调度，饭后返回
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="k">return</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="nx">old</span> <span class="p">=</span> <span class="nx">m</span><span class="p">.</span><span class="nx">state</span>	<span class="c1">// 没有获取成功，则直接替换旧state，再次尝试
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>	<span class="c1">// 饥饿模式下
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// Starving mode: handoff mutex ownership to the next waiter, and yield
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// our time slice so that the next waiter can start to run immediately.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// Note: mutexLocked is not set, the waiter will set it after wakeup.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// But mutex is still considered locked if mutexStarving is set,
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// so new coming goroutines won&#39;t acquire it.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 饥饿模式：将mutex所有权移交给下一个waiter，并让出我们的时间片，以便下一个waiter可以立即开始运行
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 注意：mutexLocked 没有设置，waiter会在唤醒后设置
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 但是如果设置了 mutexStarving，mutex 仍然被认为是锁定的，所以新的 goroutines 不会获取它
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 处于饥饿模式下从这里唤醒的goroutine，state中mutexLocked位，一定为0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nf">runtime_Semrelease</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">m</span><span class="p">.</span><span class="nx">sema</span><span class="p">,</span> <span class="kc">true</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>	<span class="c1">// 饥饿模式下只从首部取出goroutine等待被调度即可
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        
</span></span><span class="line"><span class="cl">        <span class="c1">// 这里在饥饿模式下为甚不判断等待的goroutine数量？
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 原因是：处于饥饿模式下等待的goroutine数量一定是&gt;=1的。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 因为最后一个goroutine会把模式切换成正常模式，相关代码位于Lock函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><hr>
<h3 id="trylock">TryLock()<a hidden class="anchor" aria-hidden="true" href="#trylock">#</a></h3>
<ol>
<li>TryLock试图锁定m并报告是否成功。</li>
<li>请注意，虽然确实存在正确使用TryLock的情况，但很少，而且TryLock的使用通常表明互斥量的特定使用中存在更深层的问题。</li>
<li>TryLock 可以用于在业务比较繁忙时去尝试获取锁，失败则提示相关文案等</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// TryLock tries to lock m and reports whether it succeeded.
</span></span></span><span class="line"><span class="cl"><span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1">// Note that while correct uses of TryLock do exist, they are rare,
</span></span></span><span class="line"><span class="cl"><span class="c1">// and use of TryLock is often a sign of a deeper problem
</span></span></span><span class="line"><span class="cl"><span class="c1">// in a particular use of mutexes.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">m</span> <span class="o">*</span><span class="nx">Mutex</span><span class="p">)</span> <span class="nf">TryLock</span><span class="p">()</span> <span class="kt">bool</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">old</span> <span class="o">:=</span> <span class="nx">m</span><span class="p">.</span><span class="nx">state</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 当前锁存在 或 当前处于饥饿模式
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nx">old</span><span class="o">&amp;</span><span class="p">(</span><span class="nx">mutexLocked</span><span class="p">|</span><span class="nx">mutexStarving</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="kc">false</span>	<span class="c1">// 获取失败
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// There may be a goroutine waiting for the mutex, but we are
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// running now and can try to grab the mutex before that
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// goroutine wakes up.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 可能有一个goroutine在等待互斥量，但我们现在正在运行，并且可以尝试在goroutine唤醒之前获取互斥量。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 尝试去争抢锁，这里的old一定是没加锁并处于正常模式下去尝试争抢
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">!</span><span class="nx">atomic</span><span class="p">.</span><span class="nf">CompareAndSwapInt32</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">m</span><span class="p">.</span><span class="nx">state</span><span class="p">,</span> <span class="nx">old</span><span class="p">,</span> <span class="nx">old</span><span class="p">|</span><span class="nx">mutexLocked</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="kc">false</span>	<span class="c1">// 争抢失败情况
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">race</span><span class="p">.</span><span class="nx">Enabled</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">race</span><span class="p">.</span><span class="nf">Acquire</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">m</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="kc">true</span>	<span class="c1">// 争抢成功
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="type-locker-interface">type Locker interface<a hidden class="anchor" aria-hidden="true" href="#type-locker-interface">#</a></h2>
<ol>
<li>Locker接口代表一个可以加锁和解锁的对象</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// A Locker represents an object that can be locked and unlocked.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">type</span> <span class="nx">Locker</span> <span class="kd">interface</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nf">Lock</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="nf">Unlock</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="使用示例">使用示例<a hidden class="anchor" aria-hidden="true" href="#使用示例">#</a></h2>
<h3 id="syncmutex">sync.Mutex<a hidden class="anchor" aria-hidden="true" href="#syncmutex">#</a></h3>
<ul>
<li>互斥锁：是传统的并发程序对<strong>共享资源</strong>进行访问控制的主要手段，<code>Go</code>语言中推荐使用通道(channel)来实现<strong>资源共享</strong>和<strong>通信</strong></li>
<li>互斥锁：由标准库 <strong>sync</strong> 包中分的 <strong>Mutex</strong> 结构体类型实现
<ul>
<li>只有两个公开方法：
<ol>
<li><strong>Lock()</strong> ：获得锁</li>
<li><strong>Unlock()</strong> ：释放锁</li>
</ol>
</li>
</ul>
</li>
<li><strong>同一个协程</strong>中<strong>同步调用</strong>使用Lock()加锁后，不能再对其加锁，否则会引发运行时异常，只能在 Unlock() 之后再次 Lock()</li>
<li><strong>多个协程</strong>中<strong>异步</strong>调用Lock()没有问题，但每个协程只能调用一次Lock()，由于多个协程之间产生了锁竞争，因此不会有运行时异常</li>
<li>互斥锁：适用于只允许有一个读或者写的场景，所以该锁也叫全局锁</li>
<li>如果在使用 Unlock() 前未加锁，就会引起一个运行错误，已经锁定的 Mutex 并不与特定的协程相关，这样可以利用一个协程对其加锁，在利用其它协程对其解锁</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// LockA() 中有 Lock()
</span></span></span><span class="line"><span class="cl"><span class="c1">// LockB() 中也有 Lock()
</span></span></span><span class="line"><span class="cl"><span class="c1">// LockB() 的 Lock() 运行时，锁还没有 Unlock()，程序发生 panic
</span></span></span><span class="line"><span class="cl"><span class="c1">// 这是在同步调用互斥锁中常见的问题，一般在一对互斥锁中间不要调用其它函数，即使要用也尽量采用异步方式
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="kn">package</span> <span class="nx">main</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="s">&#34;fmt&#34;</span>
</span></span><span class="line"><span class="cl">    <span class="s">&#34;sync&#34;</span>
</span></span><span class="line"><span class="cl">    <span class="s">&#34;time&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">mutex</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">Mutex</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nf">LockA</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">LockA</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">mutex</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>		<span class="c1">// 加锁
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;Lock in A&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nf">LockB</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;Wake up in A&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nx">mutex</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>		<span class="c1">// 解锁
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;Unlock in A&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">LockB</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;B&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nx">mutex</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>		<span class="c1">// 加锁	main goroutine在这里被阻塞，导致deadlock
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;Lock in B&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nx">mutex</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>		<span class="c1">// 解锁
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;Unlock in B&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="cm">/*
</span></span></span><span class="line"><span class="cl"><span class="cm">Lock in A
</span></span></span><span class="line"><span class="cl"><span class="cm">B
</span></span></span><span class="line"><span class="cl"><span class="cm">fatal error: all goroutines are asleep - deadlock!
</span></span></span><span class="line"><span class="cl"><span class="cm">
</span></span></span><span class="line"><span class="cl"><span class="cm">goroutine 1 [semacquire]:
</span></span></span><span class="line"><span class="cl"><span class="cm">sync.runtime_SemacquireMutex(0x593b24, 0x0, 0x1)
</span></span></span><span class="line"><span class="cl"><span class="cm">        D:/True-False/Go/src/runtime/sema.go:71 +0x4e
</span></span></span><span class="line"><span class="cl"><span class="cm">sync.(*Mutex).lockSlow(0x593b20)
</span></span></span><span class="line"><span class="cl"><span class="cm">        D:/True-False/Go/src/sync/mutex.go:138 +0x103
</span></span></span><span class="line"><span class="cl"><span class="cm">sync.(*Mutex).Lock(...)
</span></span></span><span class="line"><span class="cl"><span class="cm">        D:/True-False/Go/src/sync/mutex.go:81
</span></span></span><span class="line"><span class="cl"><span class="cm">main.LockB()
</span></span></span><span class="line"><span class="cl"><span class="cm">        D:/True-False/WWW/GoLang/src/xuexi/mutex.go:28 +0x194
</span></span></span><span class="line"><span class="cl"><span class="cm">main.LockA()
</span></span></span><span class="line"><span class="cl"><span class="cm">        D:/True-False/WWW/GoLang/src/xuexi/mutex.go:19 +0xa2
</span></span></span><span class="line"><span class="cl"><span class="cm">main.main()
</span></span></span><span class="line"><span class="cl"><span class="cm">        D:/True-False/WWW/GoLang/src/xuexi/mutex.go:12 +0x29
</span></span></span><span class="line"><span class="cl"><span class="cm">exit status 2
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>把上面同步改为异步，把LockA()的LockB()改为<strong>go LockB()</strong></li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kn">package</span> <span class="nx">main</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="s">&#34;fmt&#34;</span>
</span></span><span class="line"><span class="cl">    <span class="s">&#34;sync&#34;</span>
</span></span><span class="line"><span class="cl">    <span class="s">&#34;time&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">mutex</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">Mutex</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nf">LockA</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">LockA</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">mutex</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>		<span class="c1">// 加锁
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;Lock in A&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">go</span> <span class="nf">LockB</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;Wake up in A&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nx">mutex</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>		<span class="c1">// 解锁
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;Unlock in A&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">LockB</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;B&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nx">mutex</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>		<span class="c1">// 加锁	lockB goroutine等待LockA解锁，先自旋再是被挂起
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;Lock in B&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nx">mutex</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>		<span class="c1">// 解锁
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;Unlock in B&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="cm">/*
</span></span></span><span class="line"><span class="cl"><span class="cm">Lock in A
</span></span></span><span class="line"><span class="cl"><span class="cm">B
</span></span></span><span class="line"><span class="cl"><span class="cm">Wake up in A
</span></span></span><span class="line"><span class="cl"><span class="cm">Unlock in A
</span></span></span><span class="line"><span class="cl"><span class="cm">Lock in B
</span></span></span><span class="line"><span class="cl"><span class="cm">Unlock in B
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>建议：同一个互斥锁的成对锁定和解锁操作可以放在同一层次的代码块中</li>
<li>经典用法如下：</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">lck</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">Mutex</span>
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">foo</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">lck</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>			<span class="c1">// 加锁
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">defer</span> <span class="nx">lck</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>	<span class="c1">// 解锁
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// ... ... 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// lck.Lock() 会阻塞直到获取锁，然后利用defer语句在函数返回时自动释放锁
</span></span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>示例代码，通过三个协程来体现sync.Mutex对资源的访问控制特征</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kn">package</span> <span class="nx">main</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="s">&#34;fmt&#34;</span>
</span></span><span class="line"><span class="cl">    <span class="s">&#34;sync&#34;</span>
</span></span><span class="line"><span class="cl">    <span class="s">&#34;time&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//var wg sync.WaitGroup
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">wg</span> <span class="o">:=</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">WaitGroup</span><span class="p">{}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">var</span> <span class="nx">mutex</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">Mutex</span>
</span></span><span class="line"><span class="cl">    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;Locking (G0)&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nx">mutex</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>		<span class="c1">// 加锁
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;locked (G0)&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nx">wg</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">4</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">go</span> <span class="kd">func</span><span class="p">(</span><span class="nx">i</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;Locking (G%d)\n&#34;</span><span class="p">,</span> <span class="nx">i</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="nx">mutex</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>				<span class="c1">// 加锁
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;Locked (G%d)\n&#34;</span><span class="p">,</span> <span class="nx">i</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            <span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span>	<span class="c1">// 延迟2s
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="nx">mutex</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>				<span class="c1">// 解锁
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;unlocked (G%d)\n&#34;</span><span class="p">,</span> <span class="nx">i</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="nx">wg</span><span class="p">.</span><span class="nf">Done</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">        <span class="p">}(</span><span class="nx">i</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span> <span class="o">*</span> <span class="mi">5</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;ready unlock (G0)&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nx">mutex</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>				<span class="c1">// 解锁
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;unlocked (G0)&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nx">wg</span><span class="p">.</span><span class="nf">Wait</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">// 程序运行结果可以看出，当有锁释放时，才能进行加锁动作
</span></span><span class="line"><span class="cl">// 运行结果如下
</span></span><span class="line"><span class="cl">Locking (G0)
</span></span><span class="line"><span class="cl">locked (G0)
</span></span><span class="line"><span class="cl">Locking (G1)
</span></span><span class="line"><span class="cl">Locking (G2)
</span></span><span class="line"><span class="cl">Locking (G3)
</span></span><span class="line"><span class="cl">ready unlock (G0)
</span></span><span class="line"><span class="cl">unlocked (G0)Locked (G1)
</span></span><span class="line"><span class="cl">unlocked (G1)
</span></span><span class="line"><span class="cl">Locked (G2)
</span></span><span class="line"><span class="cl">unlocked (G2)
</span></span><span class="line"><span class="cl">Locked (G3)
</span></span><span class="line"><span class="cl">unlocked (G3)
</span></span></code></pre></div><ul>
<li>Mutex 也可以作为结构体的一部分，这样结构体在被多线程处理时数据安全才有保障</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kn">package</span> <span class="nx">main</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="s">&#34;fmt&#34;</span>
</span></span><span class="line"><span class="cl">    <span class="s">&#34;sync&#34;</span>
</span></span><span class="line"><span class="cl">    <span class="s">&#34;time&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">Book</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">BookName</span> <span class="kt">string</span>
</span></span><span class="line"><span class="cl">    <span class="nx">L</span> <span class="o">*</span><span class="nx">sync</span><span class="p">.</span><span class="nx">Mutex</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">bk</span> <span class="o">*</span><span class="nx">Book</span><span class="p">)</span> <span class="nf">SetName</span><span class="p">(</span><span class="nx">wg</span> <span class="o">*</span><span class="nx">sync</span><span class="p">.</span><span class="nx">WaitGroup</span><span class="p">,</span> <span class="nx">name</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">defer</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;Unlock set name:&#34;</span><span class="p">,</span> <span class="nx">name</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="nx">bk</span><span class="p">.</span><span class="nx">L</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>		<span class="c1">// 解锁
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">wg</span><span class="p">.</span><span class="nf">Done</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="p">}()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nx">bk</span><span class="p">.</span><span class="nx">L</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>		<span class="c1">// 加锁
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;Lock set name:&#34;</span><span class="p">,</span> <span class="nx">name</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="mi">1</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nx">bk</span><span class="p">.</span><span class="nx">BookName</span> <span class="p">=</span> <span class="nx">name</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">bk</span> <span class="o">:=</span> <span class="nx">Book</span><span class="p">{}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//bk.L = &amp;sync.Mutex{}
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">bk</span><span class="p">.</span><span class="nx">L</span> <span class="p">=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">sync</span><span class="p">.</span><span class="nx">Mutex</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//wg := new(sync.WaitGroup)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">wg</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">sync</span><span class="p">.</span><span class="nx">WaitGroup</span><span class="p">{}</span>
</span></span><span class="line"><span class="cl">    <span class="nx">books</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">string</span><span class="p">{</span><span class="s">&#34;&lt;&lt;三国演义&gt;&gt;&#34;</span><span class="p">,</span> <span class="s">&#34;&lt;&lt;道德经&gt;&gt;&#34;</span><span class="p">,</span> <span class="s">&#34;&lt;&lt;西游记&gt;&gt;&#34;</span><span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">book</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">books</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">wg</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">go</span> <span class="nx">bk</span><span class="p">.</span><span class="nf">SetName</span><span class="p">(</span><span class="nx">wg</span><span class="p">,</span> <span class="nx">book</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nx">wg</span><span class="p">.</span><span class="nf">Wait</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">Lock set name: &lt;&lt;西游记&gt;&gt;
</span></span><span class="line"><span class="cl">Unlock set name: &lt;&lt;西游记&gt;&gt;
</span></span><span class="line"><span class="cl">Lock set name: &lt;&lt;三国演义&gt;&gt;
</span></span><span class="line"><span class="cl">Unlock set name: &lt;&lt;三国演义&gt;&gt;
</span></span><span class="line"><span class="cl">Lock set name: &lt;&lt;道德经&gt;&gt;
</span></span><span class="line"><span class="cl">Unlock set name: &lt;&lt;道德经&gt;&gt;
</span></span></code></pre></div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kn">package</span> <span class="nx">main</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="s">&#34;fmt&#34;</span>
</span></span><span class="line"><span class="cl">    <span class="s">&#34;sync&#34;</span>
</span></span><span class="line"><span class="cl">    <span class="s">&#34;time&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">var</span> <span class="nx">m</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">Mutex</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">m</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="k">defer</span> <span class="nx">m</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;1&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="nx">m</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>		<span class="c1">// 这里当前goroutine将被永久保存到信号池中得不到运行机会
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">        <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;2&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="k">defer</span> <span class="nx">m</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;3&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="mi">5</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// Output:
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="注意事项">注意事项<a hidden class="anchor" aria-hidden="true" href="#注意事项">#</a></h2>
<ul>
<li>Lock() 和 UnLock() 方法应该成对出现。</li>
<li>sync.Mutex 不允许被值拷贝，拷贝地址可以。</li>
</ul>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://heliu.site/tags/golang/">Golang</a></li>
      <li><a href="https://heliu.site/tags/sync/">Sync</a></li>
      <li><a href="https://heliu.site/tags/mutex/">Mutex</a></li>
    </ul>
<nav class="paginav">
  <a class="prev" href="https://heliu.site/posts/ssl/acme/">
    <span class="title">« 上一页</span>
    <br>
    <span>acme.sh</span>
  </a>
  <a class="next" href="https://heliu.site/posts/golang/type/typ/">
    <span class="title">下一页 »</span>
    <br>
    <span>type</span>
  </a>
</nav>

  </footer>
</article>
    </main>
    
<footer class="footer">
    
    <div class="busuanzi-footer">
    <span id="busuanzi_container_site_pv">
        本站总访问量<span id="busuanzi_value_site_pv"></span>次
    </span>
    <span id="busuanzi_container_site_uv">
        本站访客数<span id="busuanzi_value_site_uv"></span>人次
    </span>
    </div>
        <span>Copyright © 2020-2024 <a href="#">heliu's blog</a>. All rights reserved</span>  
    
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'Copy';

        function copyingDone() {
            copybutton.innerHTML = 'Done';
            setTimeout(() => {
                copybutton.innerHTML = 'Copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
