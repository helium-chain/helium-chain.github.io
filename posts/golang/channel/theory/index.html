<!DOCTYPE html>
<html lang="zh" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Channel(原理) | Helium</title>
<meta name="keywords" content="golang, Channel">
<meta name="description" content="💥本文章所有相关go代码参考自go 1.18&#43;版本">
<meta name="author" content="helium">
<link rel="canonical" href="https://helium-chain.github.io/posts/golang/channel/theory/">
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<meta name="referrer" content="no-referrer-when-downgrade">
<link crossorigin="anonymous" href="/assets/css/stylesheet.css" rel="preload stylesheet" as="style">
<link rel="icon" href="https://helium-chain.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://helium-chain.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://helium-chain.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://helium-chain.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://helium-chain.github.io/apple-touch-icon.png">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="zh" href="https://helium-chain.github.io/posts/golang/channel/theory/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
<html>
<head>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/jetbrains-mono@1.0.6/css/jetbrains-mono-nl.min.css" />
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lxgw-wenkai-lite-webfont@1.1.0/style.css" />
    <link rel="stylesheet" href="https://cdn.staticfile.org/lxgw-wenkai-screen-webfont/1.6.0/style.css" />
    <style>
        body {
            font-family: "LXGW WenKai Lite", sans-serif;
            font-family: "LXGW WenKai Screen", sans-serif;
        }
    </style>
</head>
</html>

  

<meta property="og:title" content="Channel(原理)" />
<meta property="og:description" content="💥本文章所有相关go代码参考自go 1.18&#43;版本" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://helium-chain.github.io/posts/golang/channel/theory/" />
<meta property="og:image" content="https://helium-chain.github.io/favicon-32x32.png" />
<meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-08-01T00:00:00+00:00" />
<meta property="article:modified_time" content="2024-08-01T00:00:00+00:00" /><meta property="og:site_name" content="Helium" />

<meta name="twitter:card" content="summary_large_image" />
<meta name="twitter:image" content="https://helium-chain.github.io/favicon-32x32.png" />
<meta name="twitter:title" content="Channel(原理)"/>
<meta name="twitter:description" content="💥本文章所有相关go代码参考自go 1.18&#43;版本"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Article",
      "item": "https://helium-chain.github.io/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Golang",
      "item": "https://helium-chain.github.io/posts/golang/"
    }, 
    {
      "@type": "ListItem",
      "position":  3 ,
      "name": "第13章 Channel",
      "item": "https://helium-chain.github.io/posts/golang/channel/"
    }, 
    {
      "@type": "ListItem",
      "position":  4 ,
      "name": "Channel(原理)",
      "item": "https://helium-chain.github.io/posts/golang/channel/theory/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Channel(原理)",
  "name": "Channel(原理)",
  "description": "💥本文章所有相关go代码参考自go 1.18+版本",
  "keywords": [
    "golang", "Channel"
  ],
  "articleBody": "包解释：\n该文件包含 Go channels 的实现。 c.sendq 和 c.recvq 中至少有一个是空的，除了使用 select 语句发送和接收的无缓冲 chan 上阻止了单个 goroutine 的情况外，在这种情况下，c.sendq 和c.recvq 的长度仅受 select 语句的大小限制。 select 同时操作单个无缓冲 chan 的读和写这种情况下可能存在 c.sendq 和 c.recvq 都不为空（这种情况下 select不能有 default 分支）。 对于缓冲 channels，也是: c.qcount \u003e 0 表示 c.recvq 为空。缓存区有值则 c.recvq 一定为空。 c.qcount \u003c c.dataqsiz 意味着 c.sendq 是空的。缓存区没有满则 c.sendq 一定为空。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 package runtime // This file contains the implementation of Go channels. // Invariants: // At least one of c.sendq and c.recvq is empty, // except for the case of an unbuffered channel with a single goroutine // blocked on it for both sending and receiving using a select statement, // in which case the length of c.sendq and c.recvq is limited only by the // size of the select statement. // // For buffered channels, also: // c.qcount \u003e 0 implies that c.recvq is empty. // c.qcount \u003c c.dataqsiz implies that c.sendq is empty. type hchan struct hchan 结构其实就是一个【有缓冲】和【双向链表】组成的队列。 这个队列维护着通信的数据，以及挂起等待的 goroutine。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 type hchan struct { // 已有元素个数（也就是通道中元素个数）len(chan) // 缓存区元素个数，不包括sendq上面的goroutine数量(如果存在) qcount uint // total data in the queue // 数组容量（也就是chan容量）cap(chan)\t// 也就是 make(chan int, size) 这里的size dataqsiz uint // size of the circular queue // 有缓冲数组地址指针，这里是根据 dataqsiz*elemsize 计算分配的内存数组大小 buf unsafe.Pointer // points to an array of dataqsiz elements // 元素大小，比如int这里存储的就是8，string的话这里存储的就是16 elemsize uint16 // 通道是否被关闭 1.被关闭 0.正常 closed uint32 // chan元素类型，指向类型元数据，比如chan int这里记录的就是int的元类型 elemtype *_type // element type // 当前索引（记录下一次send下标），下一次写取位置。 sendx uint // send index // 当前索引（记录下一次recv下标），下一次读入位置。 recvx uint // receive index // 等待写的队列，是一个双向的goroutine链表 recvq waitq // list of recv waiters // 等待读的队列，是一个双向的goroutine链表 sendq waitq // list of send waiters // lock protects all fields in hchan, as well as several // fields in sudogs blocked on this channel. // // Do not change another G's status while holding this lock // (in particular, do not ready a G), as this can deadlock // with stack shrinking. // // lock保护hchan中的所有字段，以及sudogs中的一些字段在这个通道上被阻塞。 // 在持有该锁时，不要改变另一个G的状态(特别是不要准备一个G)，因为这可能会导致栈收缩死锁。 lock mutex\t// runtime.mutex 为了应对并发的读写chan，参看runtime.mutex相关文档 } hchan 缓存区内存布局图（如果存在缓存区时） raceaddr() 该函数主要用于 make() 函数中，当申请总内存为0时，返回当前buf字段地址作为 buf 的值。形成指针指向闭环。 1 2 3 4 5 6 7 8 9 10 11 func (c *hchan) raceaddr() unsafe.Pointer { // Treat read-like and write-like operations on the channel to // happen at this address. Avoid using the address of qcount // or dataqsiz, because the len() and cap() builtins read // those addresses, and we don't want them racing with // operations like close(). // // 将channel上的read-like和write-like操作视为在此地址发生。 // 避免使用qcount或dataqsiz的地址，因为len()和cap()内置函数会读取这些地址，我们不希望它们与close()等操作竞争。 return unsafe.Pointer(\u0026c.buf) } sortkey() 该函数在 goselect() 函数中使用，用于返回 chan 地址升序排序 channels。 select 中相关用到的函数。在后面介绍select时，会被使用。 1 2 3 func (c *hchan) sortkey() uintptr { return uintptr(unsafe.Pointer(c)) } Constant 1 2 3 4 5 6 7 8 9 10 11 const ( // 最大对齐字节数，主要用于下面的定义。 maxAlign = 8 // hchan 占用内存大小字节，使 hchan 按照 maxAlign 大小对齐 // 比如 hchan 是 12byte，那么 hchanSize 则是 16byte // 为什么要使 hchan 对齐 maxAlign？原因是 hchan 后接着是 chan 元素的内存空间块(如果是有缓冲情况下) // 这种情况是为了兼容32位，因为在64位下hchan就是8字节对齐的，该字段用于make函数中申请 chan 内存需要。 hchanSize = unsafe.Sizeof(hchan{}) + uintptr(-int(unsafe.Sizeof(hchan{}))\u0026(maxAlign-1)) debugChan = false\t// debug ) type waitq struct waitq 根据 sudog 形成一个双向链表。 其实就是一个队列的功能，元素【从 last 处添加】，【从 first 处取出】。 1 2 3 4 type waitq struct { first *sudog // 指向链表的首个 *sudog last *sudog // 指向链表的尾部 *sudog } dequeue() 从 first 中取出一个 *sudog。相当于从队列头（first）取出一个 *sudog。 调用该方法时 chan lock 锁一定是被持有的。下面函数中需要 for {} 的原因是最后一个 if 条件的 CAS 操作。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 func (q *waitq) dequeue() *sudog { for { sgp := q.first // 从first处取一个 *sudog if sgp == nil { return nil } y := sgp.next if y == nil { // 最后一个 *sudog q.first = nil q.last = nil } else { y.prev = nil q.first = y // 标记已删除（参看 dequeueSudoG） sgp.next = nil // mark as removed (see dequeueSudoG) } // 为什么需要下面的判断条件？ // 1. select 语句中阻塞了一组 chan 时，所有 channels 的 lock 锁都已被持有。 // 2. 当前执行select语句的goroutine会被封装到多个*sudog中通过waitlink字段形成链表，然后把各个*sudog的isSelect字段标记为true。 // 3. 把各个*sudog分别挂在各自的sendq或recvq链表中。等待goroutine被唤醒。 // 4. 某一时刻*sudog被选中唤醒，则一定会执行当前函数 *sudog.isSelect 是 true，并且通过 CAS 把 g.selectDone 从0标记为1。 // 5. 注意此时唤醒的goroutine可能在多个channel上面等待。此时可能会出现在其他chan上这个goroutine也被选中了，也在执行当前函数。 // 6. 则这里会直接跳过。因为当前goroutine已被唤醒，后续会在唤醒的goroutine移除这里goroutine的goselect函数中。 // 7. goroutine 唤醒后会获取所有的 channels lock，然后把selectDone设置为0，此时因为所有的channel lock已被持有所以能立即修改selectDone。 // if a goroutine was put on this queue because of a // select, there is a small window between the goroutine // being woken up by a different case and it grabbing the // channel locks. Once it has the lock // it removes itself from the queue, so we won't see it after that. // We use a flag in the G struct to tell us when someone // else has won the race to signal this goroutine but the goroutine // hasn't removed itself from the queue yet. // // 如果一个goroutine因为select被放到这个队列上，那么在goroutine被不同的情况唤醒和它获取通道锁之间有一个小窗口。 // 一旦它有了锁，它就会从队列中移除自己，所以在那之后我们就看不到它了。 // 我们在G结构体中使用一个标志来告诉我们，当有其他人赢得比赛时，向这个goroutine发出信号，但该goroutine还没有从队列中删除自己。 if sgp.isSelect \u0026\u0026 !atomic.Cas(\u0026sgp.g.selectDone, 0, 1) { continue } return sgp } } enqueue() 从 last 放入 *sudog。相当于从队列尾（last）添加元素。 调用该方法时 chan lock 已被持有。 1 2 3 4 5 6 7 8 9 10 11 12 13 func (q *waitq) enqueue(sgp *sudog) { sgp.next = nil x := q.last if x == nil { // waitq 是空的 sgp.prev = nil q.first = sgp q.last = sgp return } sgp.prev = x x.next = sgp q.last = sgp } dequeueSudoG() 在 selectgo() 函数中被用到，用于将指定的 *sudog 取出。 因为 select 不能立即完成时会挂在所有的 channel，当有 channel 就绪后其他 recvq、sendq 上的需要调用这个函数剔除掉。 调用该函数是相关的 channel lock 已被持有。 参数：sgp *sudog 是通过 waitlink 字段组成的 *sudog 链表。 该函数也是在 go1.19.3/src/runtime/select.go 文件中。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 func (q *waitq) dequeueSudoG(sgp *sudog) { // 当前 sgp 可能处在链表的任何位置，或者不在链表中。 x := sgp.prev y := sgp.next if x != nil { if y != nil { // middle of queue // // 在 queue 的中间 x.next = y y.prev = x sgp.next = nil sgp.prev = nil return } // end of queue // // 在 queue 的最后 x.next = nil q.last = x sgp.prev = nil return } if y != nil { // start of queue // // 在queue开头 y.prev = nil q.first = y sgp.next = nil return } // x==y==nil. Either sgp is the only element in the queue, // or it has already been removed. Use q.first to disambiguate. // // x==y==nil。 // 要么 sgp 是队列中唯一的成员，要么它已经被删除。使用 q.first 来消除歧义。 if q.first == sgp { q.first = nil q.last = nil } } type sudog struct sudog 表示等待列表中的 g，例如用于在 channel 上 sending/receiving 。 sudog 是必要的，因为 g↔synchronization 对象关系是多对多的。 一个 g 可能会出现在许多等待列表中，所以一个g可能会有许多 sudog; 并且许多 g 可能在同一个 same 对象上等待，因此一个对象可能有许多 sudog。 sudog 是从一个特殊的池中分配的。使用 acquireSudog 和 releaseSudog 来分配和释放它们。 文件位置：go1.19.3/src/runtime2.go。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 // sudog represents a g in a wait list, such as for sending/receiving // on a channel. // // sudog is necessary because the g ↔ synchronization object relation // is many-to-many. A g can be on many wait lists, so there may be // many sudogs for one g; and many gs may be waiting on the same // synchronization object, so there may be many sudogs for one object. // // sudogs are allocated from a special pool. Use acquireSudog and // releaseSudog to allocate and free them. type sudog struct { // The following fields are protected by the hchan.lock of the // channel this sudog is blocking on. shrinkstack depends on // this for sudogs involved in channel ops. g *g // 等待的goroutine next *sudog // 链接下一个*sudog 对于二叉树就是left prev *sudog // 链接前一个*sudog 对于二叉树就是right // seampher中：保存来自信号量的地址；比如在sync.Mutex中则是\u0026sync.Mutex.sema该字段的地址。 // channels中：则是保存需要传递的值的地址。（需要交换的数据地址） elem unsafe.Pointer // data element (may point to stack) // The following fields are never accessed concurrently. // For channels, waitlink is only accessed by g. // For semaphores, all fields (including the ones above) // are only accessed when holding a semaRoot lock. // // 以下字段永远不会并发访问。 // 对于 channels，waitlink 只能由 g 访问。 // 对于 semaphores，所有字段(包括上面的字段)只有在持有 semaRoot 锁时才能访问。 // 以下时间都是为了分析 sudog acquiretime int64 // 获得 sudog 的时间 releasetime int64 // 释放时间\t// ticket 用于形成最小堆，从root往下按照 s.ticket \u003c= both s.prev.ticket AND s.next.ticket; 最小堆就是一种完全二叉树 // 1. ticket 在 semaRoot.queue 函数中作为二叉树枝干情况下被初始化为 s.ticket = fastrand() | 1; s.ticket \u003e= 0 // 2. ticket 在 semaRoot.dequeue 函数中返回 sudog 时，被重置为0 // 3. ticket 在 sync_runtime_SemacquireMutex 函数中 如果是饥饿模式则标记为1 // 最小堆百度百科：https://baike.baidu.com/item/%E6%9C%80%E5%B0%8F%E5%A0%86/9139372 ticket uint32 // isSelect indicates g is participating in a select, so // g.selectDone must be CAS'd to win the wake-up race. // // isSelect 表示 g 正在参与一个 select，因此 g.selectDone 必须经过 CAS 处理才能赢得唤醒竞赛。 // 具体参考 goselect() 函数。当前是因为 select 语句被挂起时，该字段会被设置为 true。 isSelect bool // 在select结构中被使用 // success indicates whether communication over channel c // succeeded. It is true if the goroutine was awoken because a // value was delivered over channel c, and false if awoken // because c was closed. // // success c 通道通信是否成功。 // 如果 goroutine 因为通过通道 c 传递值而被唤醒，则为 true，如果因为通道 c 被关闭而被唤醒，则为 false。 success bool // 在chan中被使用，用于判断本次通信是否成功 // semaRoot的二叉树 parent *sudog // semaRoot binary tree // g.waiting 列表或 semaRoot 的等待链表，指向链表的头。 // 在 goselect() 函数中，挂起的 goroutine 组装的 *sudog 通过 waitlink 字段形成链表。 // waitlink 只在 semapher 或 select 语句中被用来形成链表。 waitlink *sudog // g.waiting list or semaRoot // 等待尾部 semaRoot，指向链表的尾部 waittail *sudog // semaRoot // 当前sudog所属*hchan，select不能就绪要被挂起时用到。 c *hchan // channel } make() 初始化 channel。\nmakechan() 函数原型：make(chan Type, size int) 参数： t *chantype：chan 元类型结构。 size int：chan 大小，默认0无缓冲 chan；\u003e=1 都是有缓冲 chan。 type chantype struct { typ _type // chan元类型 elem *_type // chan 元素元类型 dir uintptr // 通道方向 } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 func makechan(t *chantype, size int) *hchan { elem := t.elem // chan元素元类型 // compiler checks this but be safe. // // 编译器会检查这一点，但这是安全的。 if elem.size \u003e= 1\u003c\u003c16 { // chan元素类型内存 \u003e= 1\u003c\u003c16时不适合chan throw(\"makechan: invalid channel element type\") } // hchan 是否对齐 maxAlign if hchanSize%maxAlign != 0 || elem.align \u003e maxAlign { throw(\"makechan: bad alignment\") } // mem = elem.size * uintptr(size) mem, overflow := math.MulUintptr(elem.size, uintptr(size)) if overflow || mem \u003e maxAlloc-hchanSize || size \u003c 0 { // 内存溢出 panic(plainError(\"makechan: size out of range\")) } // Hchan does not contain pointers interesting for GC when elements stored in buf do not contain pointers. // buf points into the same allocation, elemtype is persistent. // SudoG's are referenced from their owning thread so they can't be collected. // TODO(dvyukov,rlh): Rethink when collector can move allocated objects. // // 当存储在buf中的元素不包含指针时，hchan不包含GC感兴趣的指针。 // (因此可直接在无指针内存块分配)。buf指向相同的内存分配，elemtype是持久的。 // Sudog 是在它们自己的线程中引用的，所以它们无法被收集。 // TODO(dvyukov,rlh):重新考虑收集器何时可以移动已分配的对象。 var c *hchan // nil switch { // 【make(chan struct{}, n)】 OR 【make(chan int, 0)】 形式 case mem == 0: // channel 内存为零 // Queue or element size is zero. // // Queue 或 element 的大小为0。 // 注意这里申请的内存规格块是无指针的，具体原因前面注释有解释 c = (*hchan)(mallocgc(hchanSize, nil, true)) // 申请hchan需要的内存空间 // Race detector uses this location for synchronization. // // 竞态检测器使用此位置进行同步。 c.buf = c.raceaddr() // c.buf = \u0026c.buf case elem.ptrdata == 0: // channel 内存不为零，元素不包含指针 // Elements do not contain pointers. // Allocate hchan and buf in one call. // // 元素不包含指针。一次调用即可分配 hchan 和 buf。 // hchanSize 主要是为了这里的对齐。注意这里申请的内存规格块是无指针的，具体原因前面注释有解释 c = (*hchan)(mallocgc(hchanSize+mem, nil, true)) // 申请【hchan + buf】需要内存块 c.buf = add(unsafe.Pointer(c), hchanSize) // 可见申请的是一整块内存空间 default: // channel 内存不为零，元素包含指针 // Elements contain pointers. // // 元素包含指针。 c = new(hchan) // 申请元素需要的内存块 // 注意这里申请的是有指针内存规格块，具体原因是chan元素类型有指针可能存在多级指针引用，需要GC帮助 c.buf = mallocgc(mem, elem, true) } c.elemsize = uint16(elem.size) // chan 元素大小 c.elemtype = elem // chan元素元类型 c.dataqsiz = uint(size) // 有缓存容量，一旦初始化就是确定的值 // 初始化 runtime.mutex，主要是初始化锁排名 lockInit(\u0026c.lock, lockRankHchan)\tif debugChan { print(\"makechan: chan=\", c, \"; elemsize=\", elem.size, \"; dataqsiz=\", size, \"\\n\") } return c } makechan64() 1 2 3 4 5 6 7 func makechan64(t *chantype, size int64) *hchan { if int64(int(size)) != size { // 如果在32位系统下这里会报错 panic(plainError(\"makechan: size out of range\")) } return makechan(t, int(size)) } c \u003c- ep ep 发送到 c 中。\nchansend1() 编译后代码中 c \u003c- x 的入口点。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 // // c \u003c- ep // // as // // chansend1(c, \u0026ep) // // entry point for c \u003c- x from compiled code // //go:nosplit func chansend1(c *hchan, elem unsafe.Pointer) { chansend(c, elem, true, getcallerpc()) } chansend() 通用单通道 send/recv，如果 block 不是 nil，那么协议将不会进入睡眠状态，如果无法完成则返回。 当涉及 sleep 的通道被关闭时，sleep 可以使用 g.param == nil 唤醒。循环并重新运行操作是最简单的;我们会看到它现在已经关闭了。 参数： c *hchan：hchan 结构体的指针。指向要来用 send 数据的 channel。 ep unsafe.Pointer：ep 是 c \u003c- ep 需要发送到 chan 的数据地址。 是一个指针，指向要被送入通道 c 的数据，数据类型要和 c 的元素类型一致。 block bool：false.不能立即完成时不阻塞。 true.不能立即完成时阻塞。 表示如果 send 操作不能立即完成，是否想要阻塞等待。 block bool 参数 false 状态用于 select{case: default:} 形式中。true 状态用于 c \u003c- ep 情况下。 callerpc uintptr：是 c \u003c- ep 的下一条代码指令地址。用于进行race相关检测。 返回值： bool：true.数据 send 完成。false.表示目前不能发送，但因为不想阻塞(block为false)而返回。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 /* * generic single channel send/recv * If block is not nil, * then the protocol will not * sleep but return if it could * not complete. * * sleep can wake up with g.param == nil * when a channel involved in the sleep has * been closed. it is easiest to loop and re-run * the operation; we'll see that it's now closed. */ func chansend(c *hchan, ep unsafe.Pointer, block bool, callerpc uintptr) bool { // 1) chan没有初始化，比如 var c chan int形式 if c == nil { if !block { // select{case: default:} 块 return false // 返回false，表示未发送数据。 } // nil \u003c- x：如果block为true，就让当前协程永久地阻塞在这个nil通道上。 // 处理相关goroutine然后再次进行新一轮调度。 // 注意：这里的goroutine将永久丢失，因为这个goroutine没有被放入队列中等待被调度， // 还有就是c \u003c- x这行代码后的所有代码都不会在被执行。 gopark(nil, nil, waitReasonChanSendNilChan, traceEvGoStop, 2) throw(\"unreachable\") } if debugChan { // debug print(\"chansend: chan=\", c, \"\\n\") } if raceenabled { racereadpc(c.raceaddr(), callerpc, abi.FuncPCABIInternal(chansend)) } // Fast path: check for failed non-blocking operation without acquiring the lock. // // After observing that the channel is not closed, we observe that the channel is // not ready for sending. Each of these observations is a single word-sized read // (first c.closed and second full()). // Because a closed channel cannot transition from 'ready for sending' to // 'not ready for sending', even if the channel is closed between the two observations, // they imply a moment between the two when the channel was both not yet closed // and not ready for sending. We behave as if we observed the channel at that moment, // and report that the send cannot proceed. // // It is okay if the reads are reordered here: if we observe that the channel is not // ready for sending and then observe that it is not closed, that implies that the // channel wasn't closed during the first observation. However, nothing here // guarantees forward progress. We rely on the side effects of lock release in // chanrecv() and closechan() to update this thread's view of c.closed and full(). // // Fast path: 在未获得锁的情况下检查失败的非阻塞操作。 // 在观察到通道没有关闭之后，我们观察到通道还没有准备好发送。每个观察值都是单个word-sized的读取(第一个是c.closed，第二个是full())。 // 因为一个封闭的通道不能从'ready for sending'过渡到'not ready for sending'，即使在两次观测之间通道是关闭的， // 它们也意味着在两次观测之间通道既没有关闭也没有准备好发送的时刻。 // 我们的行为就像我们当时观察到通道一样，并报告发送无法继续。 // 在这里，如果读操作被重新排序是可以的:如果我们观察到通道还没有准备好发送，然后又观察到它没有关闭，这意味着在第一次观察期间通道没有关闭。 // 然而，这里没有任何东西能保证取得进展。我们依赖chanrecv()和closechan()中锁释放的副作用来更新这个线程的c.closed和full()视图。 if !block \u0026\u0026 c.closed == 0 \u0026\u0026 full(c) { // select块中 \u0026\u0026 chan未关闭 \u0026\u0026 c已满 // 如果block为false且closed为0，也就是在不想阻塞且通道未关闭的前提下，如果通道满了（无缓冲且recvq为空，或者有缓存且缓冲已用尽）， // 则直接返回false。 // 本步判断是在不加锁的情况下进行的，目的是让非阻塞send在无法立即完成时能真正不阻塞（加锁操作可能阻塞）。 return false } var t0 int64 if blockprofilerate \u003e 0 { t0 = cputicks() } // 2) 尝试获取 runtime.mutex 互斥锁 // 对hchan加锁，如果closed不为0，即通道已经关闭，则先解锁，然后panic。因为不允许用已关闭的通道进行send。 lock(\u0026c.lock) // 3) 向已关闭的chan 发送数据直接panic // 这里存在获取runtime.mutex期间其他协程已经把c关闭的情况，这里会直接panic // 因此chan的关闭是要确保所有的send操作已完成后再进行 if c.closed != 0 { unlock(\u0026c.lock) panic(plainError(\"send on closed channel\")) } // 4) 从 recvq 中去找出一个正在等待的 *sudog // 如果 recvq 不为空，隐含了缓冲区为空，就从中取出第1个排队的协程，将数据传给这个协程，并将该协程置为ready状态 //（放入run queue，进而得到调度），然后解锁，然后返回true。 if sg := c.recvq.dequeue(); sg != nil { // 存在等待的 goroutine 直接交换数据即可 // Found a waiting receiver. We pass the value we want to send // directly to the receiver, bypassing the channel buffer (if any). // // 找到了一个等待的接收器。我们将想要直接发送的值传递给接收器，绕过通道缓冲区(如果有的话)。 send(c, sg, ep, func() { unlock(\u0026c.lock) }, 3) return true } // 5) 缓冲区还有空间，直接把数据放入即可 // 通过比较 qcount 和 dataqsiz 判断缓存区是否还有剩余空间，在这里无缓冲的通道被视为没有剩余空间。 // 如果有剩余空间，将数据追加到缓冲区中，相应地移动 sendx，增加 qcount，然后解锁，返回值为 true。 if c.qcount \u003c c.dataqsiz { // Space is available in the channel buffer. Enqueue the element to send. // // 通道缓冲区中有可用空间。对要发送的元素进行排队。 qp := chanbuf(c, c.sendx) // 下一个空闲插槽地址 if raceenabled { racenotify(c, c.sendx, nil) } // 把c \u003c- ep这里的ep值复制到qp这个地址中，实现把ep放入buf中 typedmemmove(c.elemtype, qp, ep) // 如果元素大小为0不会有任何操作 c.sendx++ // 下一次空闲位置 if c.sendx == c.dataqsiz { // 到达最大索引 c.sendx = 0 } c.qcount++ // 已存储的数量加一 unlock(\u0026c.lock) return true } // 6) 如果上面4和5都不满足，并且是在select中，那么就直接返回false，表示当前分支不会选中 // 运行到这里表明通道已满，如果block为false，即不想阻塞，则解锁，返回值为false。 if !block { unlock(\u0026c.lock) return false } // 7) 下面是 c \u003c- x 写操作需要阻塞的情况 // Block on the channel. Some receiver will complete our operation for us. // // 在通道上阻塞。有人会替我们完成我们的操作。 gp := getg() // goroutine // 获取一个空闲的 *sudog mysg := acquireSudog()\tmysg.releasetime = 0 if t0 != 0 { mysg.releasetime = -1 } // No stack splits between assigning elem and enqueuing mysg // on gp.waiting where copystack can find it. // // 在分配elem和在gp上排队mysg之间没有堆栈分裂。在拷贝堆能找到的地方等待。 mysg.elem = ep // waitlink 只在 semapher 或 select 语句中被使用到。 // 用来链接多个 sudog mysg.waitlink = nil mysg.g = gp // 标记当前 sudog 不是来自select语句 mysg.isSelect = false mysg.c = c // 标记goroutine正在*sudog这中等待（一个有效的elem ptr）; in lock order gp.waiting = mysg gp.param = nil // 放入 sendq queue 中等待 c.sendq.enqueue(mysg)\t// Signal to anyone trying to shrink our stack that we're about // to park on a channel. The window between when this G's status // changes and when we set gp.activeStackChans is not safe for // stack shrinking. // // 向任何试图缩小堆栈的人发出信号，我们即将停在一个channel上。 // 当G的状态改变和我们设置gp之间的窗口。activeStackChans 对堆栈收缩不安全。 // goroutine.parkingOnChan表示该goroutine即将停在一个chansend或chanrecv上。 // 用于指示堆栈收缩的不安全点。它是一个布尔值，但会自动更新。 atomic.Store8(\u0026gp.parkingOnChan, 1) // 表示这段时间chan正在parking中 // gopark—\u003emcall-\u003epark_m-\u003eschedule() gopark(chanparkcommit, unsafe.Pointer(\u0026c.lock), waitReasonChanSend, traceEvGoBlockSend, 2)\t// 调离当前g进入调度循环 // 当前g被再次调度起来时，继续这里执行 // Ensure the value being sent is kept alive until the // receiver copies it out. The sudog has a pointer to the // stack object, but sudogs aren't considered as roots of the // stack tracer. // // 确保正在发送的值在接收方复制出来之前都是有效的。 // sudog有一个指向栈对象的指针，但sudogs不被认为是栈跟踪器的roots。 // https://zhuanlan.zhihu.com/p/213744309 KeepAlive(ep) // 保持ep是活跃的，因为ep来自用户端可能ep会被回收 // someone woke us up. // // 有人把我们叫醒了，可能是正常 \u003c-c 或者 close() 函数 if mysg != gp.waiting {\t// 当前 gp 是否等待在 mysq 上 throw(\"G waiting list is corrupted\") } gp.waiting = nil // activeStackChans表示有未锁定的通道指向这个goroutine的堆栈。 // 如果为true，堆栈复制需要获得通道锁来保护堆栈的这些区域。 // activeStackChans 字段在 gopark 中 chanparkcommit 函数中被设置为true，因此是go被调离CPU时候设置为true，在唤醒后设置为false。 // 具体参看栈 runtime.copystack 函数。 gp.activeStackChans = false // 来自close()函数唤醒时，closed为true。 closed := !mysg.success // 如果是有close唤醒的这里success为false并closed为1 gp.param = nil if mysg.releasetime \u003e 0 { blockevent(mysg.releasetime-t0, 2) } mysg.c = nil releaseSudog(mysg)\t// 回收*sudog // 这里也解释了关闭channel需要谨慎操作。 // 一个goroutine正在send，而另外一个goroutine却close了，这里就会panic。 if closed { // 来自close()函数唤醒时closed字段应该为1。 if c.closed == 0 { throw(\"chansend: spurious wakeup\") // chansend 虚假唤醒 } // c.closed == 1时，还存在send的g却关闭了chan报错 // 因此 close() 函数不要在还有send未完成时调用。 panic(plainError(\"send on closed channel\")) // send 在关闭的 channel 上 } return true } full() full() 报告在 c 上的发送是否会阻塞(即通道已满)。 它使用了一个可变状态的word-sized的读取，因此尽管答案立即为true，但在调用函数收到返回值时，正确的答案可能已经改变了。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // full reports whether a send on c would block (that is, the channel is full). // It uses a single word-sized read of mutable state, so although // the answer is instantaneously true, the correct answer may have changed // by the time the calling function receives the return value. func full(c *hchan) bool { // c.dataqsiz is immutable (never written after the channel is created) // so it is safe to read at any time during channel operation. // // c.dataqsiz是不可变的(在通道创建后永不写入)，因此在通道操作期间的任何时候读取都是安全的。 if c.dataqsiz == 0 { // Assumes that a pointer read is relaxed-atomic. // // 假定指针读取是relaxed-atomic的。 return c.recvq.first == nil } // Assumes that a uint read is relaxed-atomic. // // 假设uint read是relax-atomic。 return c.qcount == c.dataqsiz } send() 交换数据，并调用goready把等待的G放入p中等待调度。 send 处理空通道 c 上的发送操作。 发送端发送的值 ep 被复制到接收端sg。然后，接收者被唤醒，继续它的快乐之路。 通道c必须是空的并被锁定。用unlockf发送解锁c。sg必须已经从c中退出队列。 ep必须是非空值，并且指向堆或调用者的堆栈。 参数： c *hchan：hchan 结构体指针。 sg *sudog：是等待 ep \u003c- c 的 g。 ep unsafe.Pointer：是 c \u003c- ep 的数据地址。 unlockf func()：闭包函数解锁 c.lock。 skip int：skip 跳过步骤。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 // send processes a send operation on an empty channel c. // The value ep sent by the sender is copied to the receiver sg. // The receiver is then woken up to go on its merry way. // Channel c must be empty and locked. send unlocks c with unlockf. // sg must already be dequeued from c. // ep must be non-nil and point to the heap or the caller's stack. func send(c *hchan, sg *sudog, ep unsafe.Pointer, unlockf func(), skip int) { if raceenabled { if c.dataqsiz == 0 { racesync(c, sg) } else { // Pretend we go through the buffer, even though // we copy directly. Note that we need to increment // the head/tail locations only when raceenabled. racenotify(c, c.recvx, nil) racenotify(c, c.recvx, sg) c.recvx++ if c.recvx == c.dataqsiz { c.recvx = 0 } c.sendx = c.recvx // c.sendx = (c.sendx+1) % c.dataqsiz } } // sg.elem 是等待读的地址，也就是ep \u003c- c这里的ep地址 if sg.elem != nil { // 把ep复制到sg.elem中，这样就完成了chan的数据交换 sendDirect(c.elemtype, sg, ep) sg.elem = nil } gp := sg.g // 取出准备恢复的g // 把 hchan 解锁。 unlockf() // 唤醒时传递的参数。主要用与 select 语句唤醒后使用。 // select 拿着这个参数的值做比对，是哪个 case 就绪了。 gp.param = unsafe.Pointer(sg) // g.param = *sudog // 把sg.success标记为true表示数据已经交换成功 sg.success = true if sg.releasetime != 0 { sg.releasetime = cputicks() } goready(gp, skip+1) } sendDirect() 从 src -\u003e sg.elem。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 func sendDirect(t *_type, sg *sudog, src unsafe.Pointer) { // src is on our stack, dst is a slot on another stack. // // src在我们的堆栈上，dst是另一个堆栈上的插槽。 // Once we read sg.elem out of sg, it will no longer // be updated if the destination's stack gets copied (shrunk). // So make sure that no preemption points can happen between read \u0026 use. // // 一旦我们从sg中读入sg.elem，如果目标堆栈被复制(收缩)，它将不再被更新。 // 因此，请确保在读取和使用之间不会发生抢占点。 dst := sg.elem // typeBitsBulkBarrier对memmove使用类型位图定位指针槽将[src, src+size)复制到[dst, dst+size)的每个指针执行写屏障。 // 类型typ必须精确对应于[src, src+size)和[dst, dst+size)。dst、src和size必须是指针对齐的。 typeBitsBulkBarrier(t, uintptr(dst), uintptr(src), t.size) // No need for cgo write barrier checks because dst is always // Go memory. // // 不需要cgo写屏障检查，因为dst总是Go内存。 memmove(dst, src, t.size)\t// src -\u003e dst } goready() 恢复gp也就是goroutine前进行栈切换到g0栈。 1 2 3 4 5 func goready(gp *g, traceskip int) { systemstack(func() {\t// 切换到g0栈 ready(gp, traceskip, true) }) } ready() 恢复gp也就是这个goroutine相关的状态，然后放入P中等待被调度。 标记 gp 准备运行。 参数： gp *g：当前需要恢复的goroutine traceskip int：检查跳过步骤 next bool：next为true时，则将gp放入到_p_.runnext中 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 // Mark gp ready to run. func ready(gp *g, traceskip int, next bool) { if trace.enabled { traceGoUnpark(gp, traceskip) } // 获取当前gp这个goroutine的状态 status := readgstatus(gp) // Mark runnable. _g_ := getg() // 当前正在运行的g这里是g0 // 禁用抢占，因为它可以在本地变量中持有p mp := acquirem() // disable preemption because it can be holding p in a local var if status\u0026^_Gscan != _Gwaiting { dumpgstatus(gp) throw(\"bad g-\u003estatus in ready\") } // status is Gwaiting or Gscanwaiting, make Grunnable and put on runq casgstatus(gp, _Gwaiting, _Grunnable) // 切换gp的状态 // gp放入p的本地队列，这里next是true时，会放入next字段会优先调度起来 runqput(_g_.m.p.ptr(), gp, next) // 因为有goroutine放入队列中，尝试唤醒其他工作线程起来工作 wakep() // 有goroutine被放回队列该函数就会紧接着被调用 releasem(mp) } chanbuf() chanbuf(c, i) 是指向缓冲区第 i 个槽的指针。 1 2 3 4 // chanbuf(c, i) is pointer to the i'th slot in the buffer. func chanbuf(c *hchan, i uint) unsafe.Pointer { return add(c.buf, uintptr(i)*uintptr(c.elemsize)) } ep \u003c- c 从 c 中读取数据。 编译后代码中 \u003c- c 的入口点。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 // // ep \u003c- c // // as // // chanrecv1(c, \u0026ep) // // entry points for \u003c- c from compiled code // //go:nosplit func chanrecv1(c *hchan, elem unsafe.Pointer) { chanrecv(c, elem, true) } chanrecv() chanrecv 在通道 c 接收数据，并将接收到的数据写入 ep。 ep可以是nil，在这种情况下接收到的数据将被忽略。 如果block == false且没有元素可用，则返回(false, false)。否则，如果c是关闭的，则*ep设置成零值并返回(true, false)。否则，用一个元素填充*ep并返回(true, true)。 非nil的ep必须指向堆或调用者的堆栈。 参数： c *hchan：hchan结构体指针，也就是 ep \u003c- c 中 c 的结构体指针。指向要从recv数据的channel。 ep unsafe.Pointer：接收变量地址，也就是 ep \u003c- c 中ep变量的地址。是一个指针，指向用来接收数据的内存，数据类型要和c的元素类型一致。 block bool：true.表示如果recv操作不能立即完成，是否想要阻塞等待。true.不能立即完成则阻塞，false.不能立即完成不阻塞，用于select{case: default:}形式。 返回值：这两个参数都是用于 select{case: default:}形式的。selected表示当前case被选中。received表示数据有没交换成功。 selected bool：true.表示操作完成（可能因为通道已经关闭）。false.表示目前不能立即完成recv，但因为不想阻塞（block为false）而返回。 received bool：true.表示数据确实是从通道中接收的，不是因为通道关闭而得到的零值。false.可能是因为通道关闭而得到的零值（selected为true），或者因为不想阻塞而返回（selected为false）。 返回值的组成： (true, true)：操作已完成，确实是从channel中接收的（不是因为channel关闭而得到的零值）。（当前分支被选中，数据也交换成功了） (false, false)：目前不能立即完成，因为不想阻塞而返回。（当前分支没被选中，走default吧） (true, false)：操作已完成，因为通道关闭而返回零值。（当前分支被选中，因close而返回默认零值） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 // chanrecv receives on channel c and writes the received data to ep. // ep may be nil, in which case received data is ignored. // If block == false and no elements are available, returns (false, false). // Otherwise, if c is closed, zeros *ep and returns (true, false). // Otherwise, fills in *ep with an element and returns (true, true). // A non-nil ep must point to the heap or the caller's stack. func chanrecv(c *hchan, ep unsafe.Pointer, block bool) (selected, received bool) { // raceenabled: don't need to check ep, as it is always on the stack // or is new memory allocated by reflect. // // Raceenabled:不需要检查ep，因为它总是在堆栈上或由reflect分配新的内存。 if debugChan { // debug print(\"chanrecv: chan=\", c, \"\\n\") } // 1) chan未初始化时，比如 var c chan int if c == nil { if !block { // 来自select{case: default:}块 return // false, false } // \u003c- nil // 这里在nil的chan中读取数据，直接切换到调度循环进行新一轮调度 // 这个G后面的代码将不会得到执行，应该当前G既没有加入到P中等待调度，也没有在chan中，永久丢失了 gopark(nil, nil, waitReasonChanReceiveNilChan, traceEvGoStop, 2) throw(\"unreachable\") } // 2) Fast path：在未加锁下，判断block为false时，send为空时。 // Fast path: check for failed non-blocking operation without acquiring the lock. // // Fast path: 检查未获得锁的失败的非阻塞操作。 if !block \u0026\u0026 empty(c) { // select{case: default:}块，c为空 // After observing that the channel is not ready for receiving, we observe whether the // channel is closed. // // Reordering of these checks could lead to incorrect behavior when racing with a close. // For example, if the channel was open and not empty, was closed, and then drained, // reordered reads could incorrectly indicate \"open and empty\". To prevent reordering, // we use atomic loads for both checks, and rely on emptying and closing to happen in // separate critical sections under the same lock. This assumption fails when closing // an unbuffered channel with a blocked send, but that is an error condition anyway. // // 在观察到通道还没有准备好接收之后，我们观察通道是否关闭。 // // 在与close竞争时，这些检查的重新排序可能会导致错误的行为。 // 例如，如果channel是打开的且不是空的，被关闭，然后全部取出，重新排序的读数可能会错误地指示\"open and empty\"。 // 为了防止重新排序，我们对这两种检查都使用了原子加载，并依赖于在同一锁下的不同临界区中进行清空和关闭操作。 // 当以阻塞的发送方式关闭无缓冲的通道时，这个假设就失败了，但无论如何这都是一个错误条件。 if atomic.Load(\u0026c.closed) == 0 { // send为空 并 closed 未关闭，返回 (false, false) // Because a channel cannot be reopened, the later observation of the channel // being not closed implies that it was also not closed at the moment of the // first observation. We behave as if we observed the channel at that moment // and report that the receive cannot proceed. // // 因为channel不能重新打开，所以后来观察到的channel没有关闭意味着在第一次观察的时候它也没有关闭。 // 我们的行为就像我们当时观察到了channel，并报告说接收无法继续。 return } // The channel is irreversibly closed. Re-check whether the channel has any pending data // to receive, which could have arrived between the empty and closed checks above. // Sequential consistency is also required here, when racing with such a send. // // channel是不可逆关闭的。重新检查信道是否有待处理的数据要接收，这些数据可能是在上面的空检查和关闭检查之间到达的。 // 当使用这样的发送方式比赛时，顺序的一致性也是必需的。 if empty(c) { // send为空 并且 closed 已关闭，返回 (true, false) // The channel is irreversibly closed and empty. if raceenabled { raceacquire(c.raceaddr()) } if ep != nil { typedmemclr(c.elemtype, ep) } return true, false } } var t0 int64 if blockprofilerate \u003e 0 { t0 = cputicks() } // 3) 加锁情况下去判断 send 和 sendq 是否有等待 send 的数据。 lock(\u0026c.lock) // 获取runtime.mutex // channel 已关闭 if c.closed != 0 {\t// send buf缓冲区没数据 if c.qcount == 0 {\tif raceenabled { raceacquire(c.raceaddr()) } unlock(\u0026c.lock) // 拷贝对应类型的零值 if ep != nil { // Typedmemclr清除类型为typ的ptr的类型化内存。 typedmemclr(c.elemtype, ep) // ep 赋值chan元素类型的默认值 } return true, false } // The channel has been closed, but the channel's buffer have data. // // channel 已经关闭，但通道的缓冲区有数据。 } else { // channel 未关闭 // Just found waiting sender with not closed. // // 刚刚发现等待send未关闭。取出first上的第一个*sudog，这个需要处理 // 这里隐含了 buf 缓存区为空的情况。 if sg := c.sendq.dequeue(); sg != nil { // Found a waiting sender. If buffer is size 0, receive value // directly from sender. Otherwise, receive from head of queue // and add sender's value to the tail of the queue (both map to // the same buffer slot because the queue is full). // // 发现一个等待发送者。如果缓冲区大小是0，接收值直接从发送方。 // 否则，从队列的头部接收并将发送方的值添加到队列的尾部(两者映射到相同的缓冲槽，因为队列已满)。 recv(c, sg, ep, func() { unlock(\u0026c.lock) }, 3) return true, true } } // buf 缓冲区有数据 if c.qcount \u003e 0 { // Receive directly from queue // 直接从缓存区队列中接收数据 qp := chanbuf(c, c.recvx) if raceenabled { racenotify(c, c.recvx, nil) } // 交换数据 if ep != nil { typedmemmove(c.elemtype, ep, qp) // ep = qp } typedmemclr(c.elemtype, qp) // 清除 qp c.recvx++ if c.recvx == c.dataqsiz { c.recvx = 0 } c.qcount-- // 缓存区元素个数 unlock(\u0026c.lock) return true, true } // 下面代码是需要被阻塞的情况，当前goroutine被动执行调度到c.sendq中去等待 // block 为 false，不想阻塞而返回。 if !block { unlock(\u0026c.lock) return false, false } // 4) send buf取没有数据或sendq中没有等待的goroutine时。 // no sender available: block on this channel. // 没有可用的发送者:在此通道上阻塞。 gp := getg() // g mysg := acquireSudog() // 获取一个空闲的 *sudog mysg.releasetime = 0 if t0 != 0 { mysg.releasetime = -1 } // No stack splits between assigning elem and enqueuing mysg // on gp.waiting where copystack can find it. // 在分配elem和在gp.waiting上对mysg进行排队之间没有栈拆分，因为在gp.waiting上copystack可以找到它。 mysg.elem = ep mysg.waitlink = nil gp.waiting = mysg mysg.g = gp mysg.isSelect = false // 标记不是在select块中来的 mysg.c = c gp.param = nil c.recvq.enqueue(mysg) // 加入 recvq 队列中 // Signal to anyone trying to shrink our stack that we're about // to park on a channel. The window between when this G's status // changes and when we set gp.activeStackChans is not safe for // stack shrinking. // 向任何试图缩小堆栈的人发出信号，我们即将停在一个channel上。 // 当G的状态改变和我们设置gp之间的窗口。activeStackChans 对堆栈收缩不安全。 // goroutine.parkingOnChan表示该goroutine即将停在一个chansend或chanrecv上。用于指示堆栈收缩的不安全点。它是一个布尔值，但会自动更新。 atomic.Store8(\u0026gp.parkingOnChan, 1) // gopark 保存当前goroutine线程; 调用 releasem(mp) 解除当前m和P的绑定 // 调用mcall(park_m) mcall切换栈到g0 park_m 解除m和g的关联 调用schedule再次开启调度循环 gopark(chanparkcommit, unsafe.Pointer(\u0026c.lock), waitReasonChanReceive, traceEvGoBlockRecv, 2) // someone woke us up if mysg != gp.waiting { throw(\"G waiting list is corrupted\") } gp.waiting = nil gp.activeStackChans = false if mysg.releasetime \u003e 0 { blockevent(mysg.releasetime-t0, 2) } success := mysg.success gp.param = nil mysg.c = nil releaseSudog(mysg) // 回收 sudog return true, success } empty() Empty报告从c读取数据是否会阻塞(即channel是空的)。它使用单个原子读取可变状态。 1 2 3 4 5 6 7 8 9 10 11 12 13 // empty reports whether a read from c would block (that is, the channel is // empty). It uses a single atomic read of mutable state. func empty(c *hchan) bool { // c.dataqsiz is immutable. // // c.dataqsiz 是不可变的 if c.dataqsiz == 0 { // 是否有等待 send 的 goroutine return atomic.Loadp(unsafe.Pointer(\u0026c.sendq.first)) == nil } // 缓存区是否有数据 return atomic.Loaduint(\u0026c.qcount) == 0 } recv() recv 在一个满的缓存区的channel c上处理接收操作 有以下两部分： 发送放sg发送的值被放入channel，发送方被唤醒 接收端接收到的值(当前G)被写入ep 对于同步channel，这两个值是相同的 对于异步channel，接收方从通道缓冲区获取数据，发送方的数据放在通道缓冲区中。 通道c必须已满且已锁定。recv用unlockf解锁c。sg必须已经从c中退出队列。 非nil的ep必须指向堆或调用者的堆栈。 参数： c *hchan：当前 chan sg *sudog：从 recvq 中的first取出的第一个 *sudog ep unsafe.Pointer：v \u003c- c 中的v地址 unlockf func()：解锁 runtime.mutex 的闭包函数 skip int：调试相关 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 // recv processes a receive operation on a full channel c. // There are 2 parts: // 1. The value sent by the sender sg is put into the channel // and the sender is woken up to go on its merry way. // 2. The value received by the receiver (the current G) is // written to ep. // // For synchronous channels, both values are the same. // For asynchronous channels, the receiver gets its data from // the channel buffer and the sender's data is put in the // channel buffer. // Channel c must be full and locked. recv unlocks c with unlockf. // sg must already be dequeued from c. // A non-nil ep must point to the heap or the caller's stack. func recv(c *hchan, sg *sudog, ep unsafe.Pointer, unlockf func(), skip int) { if c.dataqsiz == 0 { // 无缓冲 chan if raceenabled { racesync(c, sg) } if ep != nil { // copy data from sender // 从发送方复制数据 recvDirect(c.elemtype, sg, ep) // ep = sg } } else { // 有缓冲 chan // Queue is full. Take the item at the // head of the queue. Make the sender enqueue // its item at the tail of the queue. Since the // queue is full, those are both the same slot. // 队列已满。以队列最前面的项为例。 // 让发送方在队列的尾部将其项目入队。 // 因为队列已经满了，所以它们是同一个槽。 // 以上意思是从sendq.first取出的*sudog需要恢复这个g并把数据放入缓存区，从缓存区取出下一个数据交换 qp := chanbuf(c, c.recvx) // 数据区的下一个需要交换的数据 if raceenabled { racenotify(c, c.recvx, nil) racenotify(c, c.recvx, sg) } // copy data from queue to receiver // 将数据从队列复制到接收器 if ep != nil { typedmemmove(c.elemtype, ep, qp) // ep = qp } // copy data from sender to queue // 从发送端复制数据到队列 typedmemmove(c.elemtype, qp, sg.elem) // qp = sg.elem c.recvx++\t// 下一次recv数据索引 if c.recvx == c.dataqsiz {\t// 如果超过最大重置为0 c.recvx = 0 } // 设置缓存区是满的，因为这种情况缓存区一定是full // 此时需要调整 sendx 的值，因为之前就是满的 说明之前 c.sendx == c.recvx c.sendx = c.recvx // c.sendx = (c.sendx+1) % c.dataqsiz } // sg 中的 *sudog 的g需要被恢复让其从新被调度 sg.elem = nil // 数据已被放入缓存区，情况即可 gp := sg.g // 需要恢复的g unlockf() // runtime.mutex 解锁 // 当一个channel操作唤醒一个被阻塞的goroutine时，它将param设置为指向已完成阻塞操作的sudog。 // select 拿着这个参数的值做比对，是哪个 case 就绪了。 gp.param = unsafe.Pointer(sg) // 主要用与 select 语句唤醒后使用。 sg.success = true // success 标记了 true，交换数据成功 if sg.releasetime != 0 { sg.releasetime = cputicks() } goready(gp, skip+1)\t// 放入队列中等待唤醒g } goready() 恢复gp也就是goroutine前进行栈切换到g0栈。 1 2 3 4 5 func goready(gp *g, traceskip int) { systemstack(func() { // 切换到 g0 栈 ready(gp, traceskip, true) }) } ready() 标记gp准备运行。 参数： gp *g：准备恢复的 goroutine traceskip int：测试相关 next bool：true.下次调度优先调度当前goroutine 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 // Mark gp ready to run. func ready(gp *g, traceskip int, next bool) { if trace.enabled { traceGoUnpark(gp, traceskip) } // goroutine 状态 status := readgstatus(gp) // Mark runnable. _g_ := getg() // 当前g0 // 禁止当前m被抢占，因为即将把gp放入m关联的本地P中去 mp := acquirem() // disable preemption because it can be holding p in a local var // 如果当前gp状态处理后不等于_Gwaiting等待中，那说明这个gp是有问题的 if status\u0026^_Gscan != _Gwaiting { dumpgstatus(gp) throw(\"bad g-\u003estatus in ready\") } // status is Gwaiting or Gscanwaiting, make Grunnable and put on runq // 把当前gp这个goroutine状态从_Gwaiting等待中修改为_Grunnable可以运行的状态 casgstatus(gp, _Gwaiting, _Grunnable) // 然后把gp放入m的本地关联P中，next为true表示放入前面 runqput(_g_.m.p.ptr(), gp, next) wakep() // 尝试唤醒其他线程 releasem(mp) // 解除前面的 acquirem() 函数的抢占，并判断是否有抢占发生 } runqput() runqput 试图将g放到本地可运行队列上。 如果 next 为 false, runqput 将 g 添加到可运行队列的尾部。 如果 next 为 true, runqput 将 g 放入_p_.runnext位置。 如果就绪队列已满，runnext 将 g 放置到全局队列中。 仅由所有者P执行。 参数： _p_ *p：当前工作线程绑定的 P gp *g：需要处理的 goroutine next bool：true.下次调度优先调度当前goroutine 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 // runqput tries to put g on the local runnable queue. // If next is false, runqput adds g to the tail of the runnable queue. // If next is true, runqput puts g in the _p_.runnext slot. // If the run queue is full, runnext puts g on the global queue. // Executed only by the owner P. func runqput(_p_ *p, gp *g, next bool) { // 这里是为了测试用例增加随机性的代码 // randomizeScheduler在测试代码中这里会设置为true，正常是false if randomizeScheduler \u0026\u0026 next \u0026\u0026 fastrandn(2) == 0 { next = false } // next=true，将gp添加到_p_.runnext中。_p_.runnext 如果是非nil，是一个可运行的G // 如果在运行 G 的时间片中有剩余时间，那么应该运行下一个而不是 runq 中的内容 if next { retryNext: oldnext := _p_.runnext // 原子交换 if !_p_.runnext.cas(oldnext, guintptr(unsafe.Pointer(gp))) { goto retryNext } if oldnext == 0 { return } // Kick the old runnext out to the regular run queue. // 把旧的runnext踢到常规的run队列。 gp = oldnext.ptr() } retry: // _p_的runq是一个256大小的循环数组，runqhead指向开始，runqtail指向尾部 h := atomic.LoadAcq(\u0026_p_.runqhead) // load-acquire, synchronize with consumers t := _p_.runqtail // 这里之所以没有使用锁，是由于这个runqtail在其他地方不会被修改 // 如果t-h小于总runq的大小，说明还没有存满 if t-h \u003c uint32(len(_p_.runq)) { // 这里使用t%uint32(len(_p_.runq))是由于可能出现h \u003e t的情况，那么需要始终放在t的后面 _p_.runq[t%uint32(len(_p_.runq))].set(gp) atomic.StoreRel(\u0026_p_.runqtail, t+1) // store-release, makes the item available for consumption return } // 如果本地P已经存满，那么需要去全局里面存数据 if runqputslow(_p_, gp, h, t) { return } // the queue is not full, now the put above must succeed // 如果上面都没有存储成功，那么跳转到retry标签继续存储数据，直到成功 goto retry } runqputslow() 把gp及_p_中的一半的G尝试加入全局G中去 将g和一批来自本地可运行队列的工作放到全局队列上。 仅由所有者P执行。 参数： _p_ *p：当前工作线程绑定的P gp *g：当前需要处理的 goroutine h, t uint32：_p_的runq是一个256大小的循环数组，runqhead指向开始，runqtail指向尾部 返回值： bool：true.放入成功，false.放入失败 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 // Put g and a batch of work from local runnable queue on global queue. // Executed only by the owner P. func runqputslow(_p_ *p, gp *g, h, t uint32) bool { // 首先定义batch数组，这是需要取出的G放入的数组 // 这里的len(_p_.runq)/2 + 1是把gp放入这个+1这里算在一起的 var batch [len(_p_.runq)/2 + 1]*g // 临时容器 // First, grab a batch from local queue. // 首先，从本地队列中获取一个批。 n := t - h n = n / 2 // 取一半 if n != uint32(len(_p_.runq)/2) { throw(\"runqputslow: queue is not full\") } // 取出一半放入容器 for i := uint32(0); i \u003c n; i++ { batch[i] = _p_.runq[(h+i)%uint32(len(_p_.runq))].ptr() } // 原子交换head索引值 if !atomic.CasRel(\u0026_p_.runqhead, h, h+n) { // cas-release, commits consume return false } batch[n] = gp // gp 放入最后一位 // 这里如果开始起了随机性，那么会把batch顺序打乱 if randomizeScheduler { for i := uint32(1); i \u003c= n; i++ { j := fastrandn(i + 1) // fastrand() % (i+1) batch[i], batch[j] = batch[j], batch[i] } } // Link the goroutines. // 把batch中的所有G形成一个链表链接起来 for i := uint32(0); i \u003c n; i++ { batch[i].schedlink.set(batch[i+1]) } // 是一个双向链表，head和tail分别表示正序和倒叙 var q gQueue q.head.set(batch[0]) // 把batch[0]指向q.head q.tail.set(batch[n]) // 把batch[n]指向q.tail // Now put the batch on global queue. // 现在将batch放到全局队列中。 lock(\u0026sched.lock) // 获取 sched 上的 runtime.mutex // 把设置好的G链表链接拿到shced.runq上去 globrunqputbatch(\u0026q, int32(n+1)) unlock(\u0026sched.lock) // 解锁 return true } globrunqputbatch() 把设置好的G链表链接拿到shced.runq上去 将一批可运行的 goroutines 放到全局可运行队列中。清除 *batch。 sched.lock 必须被持有。. 可能在STW期间运行，因此不允许写入障碍。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // Put a batch of runnable goroutines on the global runnable queue. // This clears *batch. // sched.lock must be held. // May run during STW, so write barriers are not allowed. // //go:nowritebarrierrec func globrunqputbatch(batch *gQueue, n int32) { // 判断 sched.lock 锁是否持有 assertLockHeld(\u0026sched.lock) // 把设置好的G链表链接到sched.runq上去 sched.runq.pushBackAll(*batch) sched.runqsize += n // 把全局链表总数量加上n *batch = gQueue{} // 清空这个batch，减轻GC压力 } v, ok := \u003c-c 编译后是通过调用 chanrecv2 函数。 ok：true.确实从channel中接收的值（不是因为channel关闭而得到的零值）。false.因为channel关闭而返回的零值。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 // 通过编译后： // // if v, ok := \u003c-c; ok { // ... foo // } // // as // // if _, ok = chanrecv2(c, \u0026v); ok { // ... foo // } //go:nosplit func chanrecv2(c *hchan, elem unsafe.Pointer) (received bool) { // 1. (_, true)：数据交换成功，得到对应交换的数据。 // 2. (_, false)：因close导致获取到了零值数据。 _, received = chanrecv(c, elem, true) return } gopark() 将当前例程置于等待状态并调用系统堆栈上的 unlock。 如果 unlock 返回 false，则继续执行该 goroutine。 unlockf 不能访问这个 G 的堆栈，因为它可能在调用 gopark 和调用 unlockf 之间移动。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 // Puts the current goroutine into a waiting state and calls unlockf on the // system stack. // // If unlockf returns false, the goroutine is resumed. // // unlockf must not access this G's stack, as it may be moved between // the call to gopark and the call to unlockf. // // Note that because unlockf is called after putting the G into a waiting // state, the G may have already been readied by the time unlockf is called // unless there is external synchronization preventing the G from being // readied. If unlockf returns false, it must guarantee that the G cannot be // externally readied. // // Reason explains why the goroutine has been parked. It is displayed in stack // traces and heap dumps. Reasons should be unique and descriptive. Do not // re-use reasons, add new ones. func gopark(unlockf func(*g, unsafe.Pointer) bool, lock unsafe.Pointer, reason waitReason, traceEv byte, traceskip int) { // const waitReasonSleep = 19 // 等待原因不是因为sleep时，按需调用checkTimeouts()，检查timer。 if reason != waitReasonSleep { // timeouts 可能会在两个goroutine使调度程序繁忙时过期。 // 检查 p.timers 在调度循环时或 goroutine 被调离CPU 或 sysmon 监控线程中都会轮询查看。 checkTimeouts() // timeouts may expire while two goroutines keep the scheduler busy } mp := acquirem() gp := mp.curg // 当前gp status := readgstatus(gp) // 获取状态 if status != _Grunning \u0026\u0026 status != _Gscanrunning { throw(\"gopark: bad g status\") } mp.waitlock = lock // 等待的锁，unlockf的第二个参数 mp.waitunlockf = unlockf// 调离前需要执行的闭包 gp.waitreason = reason mp.waittraceev = traceEv mp.waittraceskip = traceskip releasem(mp) // can't do anything that might move the G between Ms here. mcall(park_m) // mcall保存现场并切换g0调用park_m函数。 } park_m() 该函数在g0上。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 // park continuation on g0. func park_m(gp *g) { mp := getg().m if trace.enabled { traceGoPark(mp.waittraceev, mp.waittraceskip) } // N.B. Not using casGToWaiting here because the waitreason is // set by park_m's caller. casgstatus(gp, _Grunning, _Gwaiting) // 切换gp的状态 dropg() // 解除m与gp的绑定 if fn := mp.waitunlockf; fn != nil { ok := fn(gp, mp.waitlock) // 调用waitunlockf mp.waitunlockf = nil mp.waitlock = nil // 返回false时，再次运行gp if !ok { if trace.enabled { traceGoUnpark(gp, 2) } casgstatus(gp, _Gwaiting, _Grunnable) execute(gp, true) // Schedule it back, never returns. } } schedule() // 调度循环 } close() 关闭 hchan。 几种关闭 channel 的情况： close 关闭时，sendq 上有等待的 goroutine，会 panic。【“panic: send on closed channel”】。 close 关闭时，再有 send 操作，会 panic。【“panic: send on closed channel”】。 close 关闭时，buf 中有数据，不会 panic，recv 可以读取它们。 向 nil 的 channel，send 或 recv 时当前 goroutine 会panic。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 func closechan(c *hchan) { // 1) nil 的 chan 是不允许被 close 的 if c == nil {\tpanic(plainError(\"close of nil channel\")) } lock(\u0026c.lock) // 尝试获取 runtime.mutex // 2) 已经关闭的 chan 不能再次关闭 if c.closed != 0 {\tunlock(\u0026c.lock) panic(plainError(\"close of closed channel\")) } if raceenabled { callerpc := getcallerpc() racewritepc(c.raceaddr(), callerpc, abi.FuncPCABIInternal(closechan)) racerelease(c.raceaddr()) } // 3) 获取到互斥锁后首先标记closed字段 c.closed = 1 // 标记chan状态为关闭 0.未关闭 1.已关闭 // gList是一个goroutine的链表 // 当前要关闭的c还未处理的goroutine var glist gList // 4) 处理 recvq 上的 goroutine // release all readers for { // 如果同一个goroutine在多个channel上时（这种情况发生在goselect时） // dequeue() 函数有相关的排重，CAS操作。 sg := c.recvq.dequeue() if sg == nil { break } if sg.elem != nil { typedmemclr(c.elemtype, sg.elem) sg.elem = nil } if sg.releasetime != 0 { sg.releasetime = cputicks() } gp := sg.g // 主要用与 select 语句唤醒后使用。 gp.param = unsafe.Pointer(sg) // g.param = *sudog sg.success = false if raceenabled { raceacquireg(gp, c.raceaddr()) } glist.push(gp) } // 5) 处理 sendq 上的 goroutine，这些goroutine得到运行后会 panic。 // 因为不能向close的channel有send操作，其中一种情况体现在这里。 // release all writers (they will panic) for { sg := c.sendq.dequeue() if sg == nil { break } sg.elem = nil if sg.releasetime != 0 { sg.releasetime = cputicks() } gp := sg.g // 主要用与 select 语句唤醒后使用。 gp.param = unsafe.Pointer(sg) // g.param = *sudog sg.success = false if raceenabled { raceacquireg(gp, c.raceaddr()) } glist.push(gp) } unlock(\u0026c.lock) // 6) 将这些 goroutine 放回等待队列中 // Ready all Gs now that we've dropped the channel lock. for !glist.empty() { gp := glist.pop() gp.schedlink = 0 // 将gp放入本地P的队列中 goready(gp, 3) } } type guintptr uintptr 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 // A guintptr holds a goroutine pointer, but typed as a uintptr // to bypass write barriers. It is used in the Gobuf goroutine state // and in scheduling lists that are manipulated without a P. // // The Gobuf.g goroutine pointer is almost always updated by assembly code. // In one of the few places it is updated by Go code - func save - it must be // treated as a uintptr to avoid a write barrier being emitted at a bad time. // Instead of figuring out how to emit the write barriers missing in the // assembly manipulation, we change the type of the field to uintptr, // so that it does not require write barriers at all. // // Goroutine structs are published in the allg list and never freed. // That will keep the goroutine structs from being collected. // There is never a time that Gobuf.g's contain the only references // to a goroutine: the publishing of the goroutine in allg comes first. // Goroutine pointers are also kept in non-GC-visible places like TLS, // so I can't see them ever moving. If we did want to start moving data // in the GC, we'd need to allocate the goroutine structs from an // alternate arena. Using guintptr doesn't make that problem any worse. // Note that pollDesc.rg, pollDesc.wg also store g in uintptr form, // so they would need to be updated too if g's start moving. type guintptr uintptr //go:nosplit func (gp guintptr) ptr() *g { return (*g)(unsafe.Pointer(gp)) } //go:nosplit func (gp *guintptr) set(g *g) { *gp = guintptr(unsafe.Pointer(g)) } //go:nosplit func (gp *guintptr) cas(old, new guintptr) bool { return atomic.Casuintptr((*uintptr)(unsafe.Pointer(gp)), uintptr(old), uintptr(new)) } type gList struct 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 // A gList is a list of Gs linked through g.schedlink. A G can only be // on one gQueue or gList at a time. type gList struct { head guintptr } // empty reports whether l is empty. func (l *gList) empty() bool { return l.head == 0 } // push adds gp to the head of l. func (l *gList) push(gp *g) { gp.schedlink = l.head l.head.set(gp) } // pushAll prepends all Gs in q to l. func (l *gList) pushAll(q gQueue) { if !q.empty() { q.tail.ptr().schedlink = l.head l.head = q.head } } // pop removes and returns the head of l. If l is empty, it returns nil. func (l *gList) pop() *g { gp := l.head.ptr() if gp != nil { l.head = gp.schedlink } return gp } len() 获取 chan 的元素个数。（获取的是缓存区的个数，没有挂在链表中的数量） 1 2 3 4 5 6 7 //go:linkname reflect_chanlen reflect.chanlen func reflect_chanlen(c *hchan) int { if c == nil { return 0 } return int(c.qcount) } 1 2 3 4 5 6 7 //go:linkname reflectlite_chanlen internal/reflectlite.chanlen func reflectlite_chanlen(c *hchan) int { if c == nil { return 0 } return int(c.qcount) } cap() 返回值和len()函数一致。 1 2 3 4 5 6 7 //go:linkname reflect_chancap reflect.chancap func reflect_chancap(c *hchan) int { if c == nil { return 0 } return int(c.dataqsiz) } select default 以下是存在 default 默认分支情况。意思类似于 tryLock 函数，尝试一次。 以下只是特例，编译器不采用 goselect() 函数时。都是 select {case: default:} 这种形式。 select 中 c \u003c- v 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 // compiler implements // //\tselect { //\tcase c \u003c- v: //\t... foo //\tdefault: //\t... bar //\t} // // as // //\tif selectnbsend(c, v) { //\t... foo //\t} else { //\t... bar //\t} func selectnbsend(c *hchan, elem unsafe.Pointer) (selected bool) { // true. 数据send完成。 // false. 表示目前不能发送，因为不想阻塞(block为false)而返回。 // false只在这里被传入使用。 return chansend(c, elem, false, getcallerpc()) } 验证上面代码。 1 2 3 4 5 6 7 8 9 10 11 func chanTs() { ch := make(chan int) a, b := 1, 2 select { case ch \u003c- a: a = b default: b = a } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 TEXT main.chanTs(SB) G:/workspace/hello/main.go func chanTs() { 0x490ae0 493b6610 CMPQ 0x10(R14), SP 0x490ae4 0f8685000000 JBE 0x490b6f 0x490aea 4883ec40 SUBQ $0x40, SP 0x490aee 48896c2438 MOVQ BP, 0x38(SP) 0x490af3 488d6c2438 LEAQ 0x38(SP), BP ch := make(chan int) 0x490af8 488d05419b0000 LEAQ runtime.rodata+30272(SB), AX 0x490aff 31db XORL BX, BX 0x490b01 e8da3cf7ff CALL runtime.makechan(SB) 0x490b06 4889442428 MOVQ AX, 0x28(SP) a, b := 1, 2 0x490b0b 48c744241801000000 MOVQ $0x1, 0x18(SP) 0x490b14 48c744241002000000 MOVQ $0x2, 0x10(SP) case ch \u003c- a: 0x490b1d 488b4c2428 MOVQ 0x28(SP), CX 0x490b22 48894c2430 MOVQ CX, 0x30(SP) 0x490b27 488b4c2418 MOVQ 0x18(SP), CX 0x490b2c 48894c2420 MOVQ CX, 0x20(SP) 0x490b31 488b442430 MOVQ 0x30(SP), AX # 参数 c 0x490b36 488d5c2420 LEAQ 0x20(SP), BX # 参数 elem 0x490b3b 0f1f440000 NOPL 0(AX)(AX*1) 0x490b40 e89b55f7ff CALL runtime.selectnbsend(SB) # 调用selectnbsend 0x490b45 84c0 TESTL AL, AL 0x490b47 7502 JNE 0x490b4b 0x490b49 eb0c JMP 0x490b57 a = b 0x490b4b 488b442410 MOVQ 0x10(SP), AX 0x490b50 4889442418 MOVQ AX, 0x18(SP) 0x490b55 eb0c JMP 0x490b63 b = a 0x490b57 488b442418 MOVQ 0x18(SP), AX 0x490b5c 4889442410 MOVQ AX, 0x10(SP) 0x490b61 eb00 JMP 0x490b63 case ch \u003c- a: 0x490b63 eb00 JMP 0x490b65 } 0x490b65 488b6c2438 MOVQ 0x38(SP), BP 0x490b6a 4883c440 ADDQ $0x40, SP 0x490b6e c3 RET func chanTs() { 0x490b6f e8ecb4fcff CALL runtime.morestack_noctxt.abi0(SB) 0x490b74 e967ffffff JMP main.chanTs(SB) 0x490b79 cc INT $0x3 0x490b7a cc INT $0x3 0x490b7b cc INT $0x3 0x490b7c cc INT $0x3 0x490b7d cc INT $0x3 0x490b7e cc INT $0x3 0x490b7f cc INT $0x3 select 中 v \u003c- c 在 go1.18版本前。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 // compiler implements // // select { // case v = \u003c-c: // ... foo // default: // ... bar // } // // as // // if selectnbrecv(\u0026v, c) { // ... foo // } else { // ... bar // } // func selectnbrecv(elem unsafe.Pointer, c *hchan) (selected bool) { // selected：表示当前分支是否选中 selected, _ = chanrecv(c, elem, false) return } select 中 v, ok = \u003c- c 在 go1.18版本前。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 // compiler implements // // select { // case v, ok = \u003c-c: // ... foo // default: // ... bar // } // // as // // if c != nil \u0026\u0026 selectnbrecv2(\u0026v, \u0026ok, c) { // ... foo // } else { // ... bar // } // func selectnbrecv2(elem unsafe.Pointer, received *bool, c *hchan) (selected bool) { // TODO(khr): just return 2 values from this function, now that it is in Go. // selected：表示当前分支是否选中 // received：表示当前是否因为 close 而关闭的零值 selected, *received = chanrecv(c, elem, false) return } 其他版本 在go1.19.3中，\u003c-c 有所改变但是原理都一样。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 // compiler implements // // select { // case v, ok = \u003c-c: // ... foo // default: // ... bar // } // // as // // if selected, ok = selectnbrecv(\u0026v, c); selected { // ... foo // } else { // ... bar // } func selectnbrecv(elem unsafe.Pointer, c *hchan) (selected, received bool) { // selected：表示当前分支是否选中 // received：表示当前是否因为 close 而关闭的零值 return chanrecv(c, elem, false) } // // select { // case v = \u003c-c: // ... foo // default: // ... bar // } // // as // // if selected, _ = selectnbrecv(\u0026v, c); selected { // ... foo // } else { // ... bar // } 验证上面代码。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 func chanTs() { ch := make(chan int) a, b := 1, 2 var ok bool select { case a, ok = \u003c-ch: b = a if ok { b = 100 } default: a = b } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 TEXT main.chanTs(SB) G:/workspace/hello/main.go func chanTs() { 0x490ae0 493b6610 CMPQ 0x10(R14), SP 0x490ae4 0f86aa000000 JBE 0x490b94 0x490aea 4883ec48 SUBQ $0x48, SP 0x490aee 48896c2440 MOVQ BP, 0x40(SP) 0x490af3 488d6c2440 LEAQ 0x40(SP), BP ch := make(chan int) 0x490af8 488d05419b0000 LEAQ runtime.rodata+30272(SB), AX 0x490aff 31db XORL BX, BX 0x490b01 e8da3cf7ff CALL runtime.makechan(SB) 0x490b06 4889442430 MOVQ AX, 0x30(SP) a, b := 1, 2 0x490b0b 48c744242001000000 MOVQ $0x1, 0x20(SP) 0x490b14 48c744241802000000 MOVQ $0x2, 0x18(SP) var ok bool 0x490b1d c644241500 MOVB $0x0, 0x15(SP) case a, ok = \u003c-ch: 0x490b22 488b5c2430 MOVQ 0x30(SP), BX 0x490b27 48895c2438 MOVQ BX, 0x38(SP) 0x490b2c 488d442428 LEAQ 0x28(SP), AX 0x490b31 e8aa55f7ff CALL runtime.selectnbrecv(SB) # selectnbrecv 0x490b36 88442416 MOVB AL, 0x16(SP) 0x490b3a 885c2417 MOVB BL, 0x17(SP) 0x490b3e 807c241600 CMPB $0x0, 0x16(SP) if ok { 0x490b64 807c241500 CMPB $0x0, 0x15(SP) 0x490b69 7502 JNE 0x490b6d 0x490b6b eb0b JMP 0x490b78 b = 100 0x490b6d 48c744241864000000 MOVQ $0x64, 0x18(SP) 0x490b76 eb02 JMP 0x490b7a if ok { 0x490b78 eb00 JMP 0x490b7a case a, ok = \u003c-ch: 0x490b7a eb0c JMP 0x490b88 a = b 0x490b7c 488b442418 MOVQ 0x18(SP), AX 0x490b81 4889442420 MOVQ AX, 0x20(SP) 0x490b86 eb00 JMP 0x490b88 case a, ok = \u003c-ch: 0x490b88 eb00 JMP 0x490b8a } 0x490b8a 488b6c2440 MOVQ 0x40(SP), BP 0x490b8f 4883c448 ADDQ $0x48, SP 0x490b93 c3 RET func chanTs() { 0x490b94 e8c7b4fcff CALL runtime.morestack_noctxt.abi0(SB) 0x490b99 e942ffffff JMP main.chanTs(SB) 0x490b9e cc INT $0x3 0x490b9f cc INT $0x3 for range 参考 流程控制(range迭代)。 总结 向(没在select块中) nil 的 channel 中 send、recv 会 panic。在select块中 nil 的 channel 会被丢弃。 send 总是先判断的 close（panic），再判断的数据能否交换(select中的也一样)。recv 也是先判断 close 但是不会panic，再判断 buf 有没数据，有则取出，不会去 sendq 中查看挂起的 sudog。 nil 的 channel 不允许 close 操作，会 panic。close 已经 close 的 channel 会 panic。 参考 https://mp.weixin.qq.com/s/6ZEGtXRGKm2qP5b-rGLyVg https://mp.weixin.qq.com/s?__biz=Mzg5NjIwNzIxNQ==\u0026mid=2247484471\u0026idx=2\u0026sn=49af599b9c3796857459a14d040586fd\u0026scene=19#wechat_redirect ",
  "wordCount" : "9192",
  "inLanguage": "zh",
  "image": "https://helium-chain.github.io/favicon-32x32.png","datePublished": "2024-08-01T00:00:00Z",
  "dateModified": "2024-08-01T00:00:00Z",
  "author":[{
    "@type": "Person",
    "name": "helium"
  }],
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://helium-chain.github.io/posts/golang/channel/theory/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Helium",
    "logo": {
      "@type": "ImageObject",
      "url": "https://helium-chain.github.io/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://helium-chain.github.io/" accesskey="h" title="Blog (Alt + H)">
                <img src="https://helium-chain.github.io/helium.png" alt="" aria-label="logo"
                    height="35">Blog</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://helium-chain.github.io/" title="主页">
                    <span>Home</span>
                </a>
            </li>
            <li>
                <a href="https://helium-chain.github.io/posts" title="文章">
                    <span>Article</span>
                </a>
            </li>
            <li>
                <a href="https://helium-chain.github.io/archives" title="时间轴">
                    <span>Archive</span>
                </a>
            </li>
            <li>
                <a href="https://helium-chain.github.io/tags/" title="标签">
                    <span>Tag</span>
                </a>
            </li>
            <li>
                <a href="https://helium-chain.github.io/search/" title="搜索 (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
            <li>
                <a href="https://helium-chain.github.io/support" title="打赏">
                    <span>🫶Help</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">


<article class="post" autonumbering>
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://helium-chain.github.io/">主页</a>&nbsp;»&nbsp;<a href="https://helium-chain.github.io/posts/">Article</a>&nbsp;»&nbsp;<a href="https://helium-chain.github.io/posts/golang/">Golang</a>&nbsp;»&nbsp;<a href="https://helium-chain.github.io/posts/golang/channel/">第13章 Channel</a></div>
    <h1 class="post-title entry-hint-parent">
      Channel(原理)
    </h1>
    <div class="post-description">
      💥本文章所有相关go代码参考自go 1.18&#43;版本
    </div>
    <div class="post-meta">










<span class="x-post-meta-item"><svg t="1720837714681" class="icon" viewBox="0 0 1084 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="7520" width="200" height="200"><path d="M123.47509 1023.984942a123.565437 123.565437 0 0 1-123.505206-123.32451V243.863302A123.565437 123.565437 0 0 1 123.47509 120.568908h171.630374V26.06529a26.050232 26.050232 0 0 1 52.070349 0v94.503618h377.592848V26.06529a26.050232 26.050232 0 0 1 52.100464 0v94.503618h183.797189A123.565437 123.565437 0 0 1 1084.171519 243.863302v656.79713A123.565437 123.565437 0 0 1 960.666314 1023.984942H123.47509z m-71.404741-123.32451A71.434857 71.434857 0 0 0 123.47509 971.974825h837.191224a71.434857 71.434857 0 0 0 71.404741-71.314393V442.326922l-946.361273-3.824716a25.598494 25.598494 0 0 1-5.84248-0.692665l-27.796953-6.444798v469.295689zM123.47509 172.579025a71.434857 71.434857 0 0 0-71.404741 71.284277v149.736133l27.796953-6.444797a26.080348 26.080348 0 0 1 5.902712-0.662549l946.301041 3.824716V243.863302a71.404741 71.404741 0 0 0-71.404741-71.284277h-180.183284l-6.173754 12.859479a26.200812 26.200812 0 0 1-23.490383 14.786895 26.261043 26.261043 0 0 1-23.520499-14.786895l-6.173754-12.859479H350.819834l-6.173754 12.859479a26.200812 26.200812 0 0 1-23.490383 14.786895 26.230928 26.230928 0 0 1-23.520499-14.786895l-6.173755-12.859479H123.47509z m156.150814 578.827128a26.050232 26.050232 0 0 1-26.050232-25.990001c0-14.335157 11.68496-26.020116 26.050232-26.020116h521.697312c14.365273 0 26.050232 11.68496 26.050233 26.020116a26.050232 26.050232 0 0 1-26.050233 25.990001H279.625904z" fill="#3D3F42" p-id="7521"></path></svg><span>2024-08-01</span></span>&nbsp;<span class="x-post-meta-item"><svg t="1720839329181" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="14106" width="200" height="200"><path d="M699.270662 190.485379c-0.411369 0-0.821715 0.011256-1.227967 0.032746H507.034407a23.041786 23.041786 0 0 0-1.221828-0.031723c-12.779048 0-23.140023 10.359952-23.140023 23.139 0 12.781094 10.360975 23.141046 23.140023 23.141046v0.032746h193.458083v-0.032746c12.780071 0 23.141046-10.359952 23.141047-23.141046 0-12.780071-10.360975-23.140023-23.141047-23.140023zM979.215516 724.005508c0-142.090159-115.186416-257.277598-257.277598-257.277598-72.245418 0-137.532353 29.777187-184.262654 77.725223l45.868677 31.474852c36.227086-33.873482 84.882226-54.617945 138.393977-54.617945 111.945605 0 202.696492 90.750887 202.696492 202.695468h-43.01263l70.331835 104.289228 70.331835-104.289228H979.215516z" fill="" p-id="14107"></path><path d="M748.885664 588.843132c0-14.881942-12.06785-26.945699-26.947746-26.945698-14.883989 0-26.947745 12.063757-26.947745 26.945698v135.164423c0 14.879895 12.063757 26.945699 26.947745 26.945699h107.786889c14.881942 0 26.945699-12.063757 26.945698-26.945699s-12.063757-26.945699-26.945698-26.945699h-80.839143V588.843132zM721.937918 926.702c-111.947651 0-202.696492-90.74884-202.696492-202.696492 0-0.144286 0.004093-0.285502 0.004094-0.429788h43.004443l-70.330812-104.289228-70.331835 104.289228h43.075051c0 0.144286-0.00307 0.285502-0.00307 0.429788 0 142.091182 115.187439 257.279644 257.278621 257.279645 72.241324 0 137.530306-29.77821 184.260607-77.727269l-45.86663-31.474852c-36.227086 33.873482-84.884272 54.618968-138.393977 54.618968zM694.633039 423.38066c-1.354857-11.487635-11.120268-20.400632-22.972201-20.400632H206.362486c-12.780071 0-23.140023 10.359952-23.140023 23.138999 0 12.781094 10.359952 23.141046 23.140023 23.141047H596.949252c30.209022-13.81668 63.104223-22.76754 97.683787-25.879414zM438.548616 623.143333H206.362486c-12.780071 0-23.140023 10.358929-23.140023 23.140023 0 12.780071 10.359952 23.140023 23.140023 23.140023h219.956598a298.463626 298.463626 0 0 1 12.229532-46.280046zM506.934123 513.062192H206.362486c-12.780071 0-23.140023 10.359952-23.140023 23.139 0 12.781094 10.359952 23.140023 23.140023 23.140023H469.936487a302.241672 302.241672 0 0 1 36.997636-46.279023z" fill="" p-id="14108"></path><path d="M442.765661 835.277778a298.531164 298.531164 0 0 1-14.365173-46.150087H146.542052v-0.065491c-33.036417 0-59.81941-26.78197-59.81941-59.819411V329.36031h704.907545v100.905154a298.561863 298.561863 0 0 1 46.150086 14.996552V194.619536h-0.162706c0-53.422723-43.307342-96.728018-96.730065-96.728018h-68.89409V84.418668c0-33.037441-26.782993-59.81941-59.81941-59.81941v-0.361227h-18.87079v0.032745c-33.038464 0-59.820434 26.78197-59.820433 59.819411 0 0.109494 0.008186 0.218988 0.008186 0.328481h-0.339738v13.47285H345.203648V84.418668c0-33.037441-26.782993-59.81941-59.819411-59.81941v-0.361227h-18.872836v0.032745c-33.036417 0-59.81941 26.78197-59.81941 59.819411 0 0.109494 0.007163 0.218988 0.008186 0.328481h-0.339737v13.47285h-69.189826c-53.4217 0-96.729042 43.306318-96.729041 96.728018 0 1.701758 0.045025 3.39226 0.132006 5.071505v533.785166a98.051153 98.051153 0 0 0-0.132006 5.071506c0 53.4217 43.307342 96.728018 96.729041 96.728018v0.001023h305.595047zM86.723665 204.056466c0-33.037441 26.782993-59.81941 59.819411-59.819411 0.044002 0 0.086981 0.00307 0.130983 0.00307v-0.068561h105.968473V94.874811h0.032746a22.807449 22.807449 0 0 1-0.032746-1.215688c0-12.779048 10.360975-23.140023 23.140023-23.140023s23.140023 10.360975 23.140023 23.140023c0 0.408299-0.010233 0.812505-0.031722 1.215688h0.031722v49.297776h280.508696V94.874811h0.032745a22.807449 22.807449 0 0 1-0.032745-1.215688c0-12.779048 10.361999-23.140023 23.140023-23.140023 12.780071 0 23.141046 10.360975 23.141046 23.140023 0 0.408299-0.011256 0.812505-0.032746 1.215688h0.032746v49.297776h106.10048v0.065492c33.035394 0 59.818387 26.780947 59.818387 59.81941h0.130983V283.080264H86.723665v-79.023798z" fill="" p-id="14109"></path></svg><span>2024-08-01</span></span>&nbsp;<span class="x-post-meta-item"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2" fill="none"
     stroke-linecap="round" stroke-linejoin="round" class="feather feather-file-text" style="user-select: text;">
    <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z" style="user-select: text;"></path>
    <polyline points="14 2 14 8 20 8" style="user-select: text;"></polyline>
    <line x1="16" y1="13" x2="8" y2="13" style="user-select: text;"></line>
    <line x1="16" y1="17" x2="8" y2="17" style="user-select: text;"></line>
    <polyline points="10 9 9 9 8 9" style="user-select: text;"></polyline>
</svg><span>9192字</span></span>&nbsp;<span class="x-post-meta-item"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2" fill="none"
     stroke-linecap="round" stroke-linejoin="round">
    <path stroke="none" d="M0 0h24v24H0z" fill="none"></path>
    <circle cx="12" cy="12" r="9"></circle>
    <polyline points="12 7 12 12 15 15"></polyline>
</svg><span>44分钟</span></span>&nbsp;<span class="x-post-meta-item"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2" fill="none"
     stroke-linecap="round" stroke-linejoin="round">
    <path stroke="none" d="M0 0h24v24H0z" fill="none"></path>
    <circle cx="12" cy="7" r="4"></circle>
    <path d="M6 21v-2a4 4 0 0 1 4 -4h4a4 4 0 0 1 4 4v2"></path>
</svg><span>helium</span></span>
      <span class="x-post-meta-item">
        &nbsp;<svg t="1720840393161" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="18680" width="200" height="200"><path d="M995.125144 559.61812l-415.998603-415.998602A52.986489 52.986489 0 0 0 541.413335 127.99957H338.847348c-3.166656-26.559911-9.286635-51.046495-17.999939-71.333094C299.734146 7.333309 271.154242 0 256.00096 0c-13.939953 0-40.439864 6.339979-61.259794 48.806503-10.473298 21.366595-17.946606 48.966502-21.573261 79.193067H53.334974a53.393154 53.393154 0 0 0-53.333154 53.333154v360.078791a52.986489 52.986489 0 0 0 15.619948 37.713206l415.998602 415.998603a53.333154 53.333154 0 0 0 75.426413 0l26.286579-26.293245 26.286578 26.293245a53.426487 53.426487 0 0 0 16.719944 11.333295 21.333262 21.333262 0 0 0 36.079879 11.293295l382.705381-382.705381a53.399821 53.399821 0 0 0 0-75.426413z m-762.070774-491.998347C241.494342 50.373164 250.667645 42.666523 256.00096 42.666523c5.99998 0 16.573278 9.639968 25.646581 30.806564 6.493312 15.159949 11.333295 33.999886 14.146619 54.526483H216.16776c3.206656-23.419921 9.013303-44.359851 16.88661-60.41313z m243.819181 897.330319a10.666631 10.666631 0 0 1-15.079949 0l-415.998603-415.998603A10.573298 10.573298 0 0 1 42.668343 541.411515V181.332724a10.666631 10.666631 0 0 1 10.666631-10.666631h245.332509c0 47.853173-10.373298 92.15969-27.066575 115.632945-5.926647 8.326639-16.566611 14.186619-22.306592 16.113279C204.041135 314.752276 170.667913 356.218803 170.667913 405.331972c0 58.813136 47.853173 106.666308 106.666309 106.666308s106.666308-47.853173 106.666308-106.666308c0-47.086508-30.666564-87.139707-73.079754-101.246327C330.060711 272.705751 341.334007 223.692582 341.334007 170.666093h72.079758a10.573298 10.573298 0 0 1 7.539974 3.126656l415.998603 415.998603a10.666631 10.666631 0 0 1 0 15.079949zM341.334007 405.331972a63.999785 63.999785 0 1 1-63.999785-63.999785 64.073118 64.073118 0 0 1 63.999785 63.999785z m263.539114 559.61812a10.666631 10.666631 0 0 1-15.079949 0L563.499927 938.663513l303.625647-303.61898a53.399821 53.399821 0 0 0 0-75.426413L478.16688 170.666093h63.246455a10.573298 10.573298 0 0 1 7.539974 3.126656l415.998603 415.998603c0.239999 0.239999 0.466665 0.486665 0.666664 0.746664l0.086667 0.106666a10.666631 10.666631 0 0 1 0 13.373289l-0.086667 0.106666c-0.213333 0.259999-0.439999 0.506665-0.666664 0.746664z" fill="#5C5C66" p-id="18681"></path></svg>
        <ul class="post-tags-meta" style="display: inline-block;font-size: 14px;">
            <a href="https://helium-chain.github.io/tags/golang/" target="_blank" rel="noopener">Golang</a>
            <a href="https://helium-chain.github.io/tags/channel/" target="_blank" rel="noopener">Channel</a>
        </ul>
      </span>
      
      <span id="busuanzi_container_page_pv" class="x-post-meta-item">
        &nbsp;<svg t="1720844685710" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="27237" width="200" height="200"><path d="M739.754667 574.08c-121.386667 45.610667-208.469333 169.813333-208.64 316.16 0 33.408 4.693333 65.493333 13.141333 95.914667H94.122667c-26.453333-43.52-41.685333-91.946667-41.685334-143.189334 0-185.173333 192.896-335.104 430.805334-335.104 96.256 0 184.832 24.746667 256.512 66.218667z m-280.490667-114.986667a214.869333 214.869333 0 0 1-214.869333-215.04A215.04 215.04 0 0 1 459.264 28.842667a215.04 215.04 0 0 1 215.04 215.210666 215.04 215.04 0 0 1-215.04 215.04zM974.506667 641.28c9.856 0 17.834667 7.466667 17.834666 16.64v59.989333c-0.341333 8.789333-7.850667 15.786667-17.28 16.085334-9.856 0.341333-18.176-6.826667-18.517333-16.085334v-20.053333l-99.114667 91.093333-0.256 0.256a18.474667 18.474667 0 0 1-14.848 4.352h-0.768a18.176 18.176 0 0 1-9.344-4.608l-0.938666-0.981333-85.930667-80.042667-123.562667 115.072a18.773333 18.773333 0 0 1-25.216 0 15.786667 15.786667 0 0 1 0-23.466666l136.149334-126.848 0.725333-0.597334a18.645333 18.645333 0 0 1 24.362667 0.512l87.253333 81.237334 86.058667-79.232h-21.248c-9.386667-0.298667-16.938667-7.338667-17.28-16.085334-0.341333-9.173333 7.381333-16.896 17.28-17.237333h64.64z m-367.146667 240h48.128c8.874667 0 16.042667 7.168 16.042667 16.042667v72.192a16.042667 16.042667 0 0 1-16.042667 16.042666h-48.128a16.042667 16.042667 0 0 1-16.042667-16.042666v-72.192c0-8.874667 7.210667-16.042667 16.042667-16.042667z m110.805333-106.666667h48.128c8.874667 0 16.042667 7.168 16.042667 16.042667v178.858667a16.042667 16.042667 0 0 1-16.042667 16.042666h-48.128a16.042667 16.042667 0 0 1-16.042666-16.042666v-178.858667c0-8.874667 7.168-16.042667 16.042666-16.042667z m106.538667 80h48.128c8.874667 0 16.042667 7.168 16.042667 16.042667v99.413333a16.042667 16.042667 0 0 1-16.042667 16.042667H824.746667a16.042667 16.042667 0 0 1-16.042667-16.042667v-99.413333c0-8.874667 7.168-16.042667 16.042667-16.042667z m110.165333-80h48.128c8.874667 0 16.042667 7.168 16.042667 16.042667v179.413333a16.042667 16.042667 0 0 1-16.042667 16.042667h-48.128a16.042667 16.042667 0 0 1-16.042666-16.042667v-179.413333c0-8.874667 7.210667-16.042667 16.042666-16.042667z" fill="#999999" p-id="27238"></path></svg>
        <span id="busuanzi_value_page_pv"></span>
      </span>

</div>
  </header> <aside id="toc-container" class="toc-container wide">
    <div class="toc">
        <details  open>
            <summary accesskey="c" title="(Alt + C)">
                <span class="details">目录</span>
            </summary>

            <div class="inner"><ul>
                    <li>
                        <a href="#type-hchan-struct" aria-label="type hchan struct">type hchan struct</a><ul>
                            
                    <li>
                        <a href="#raceaddr" aria-label="raceaddr()">raceaddr()</a></li>
                    <li>
                        <a href="#sortkey" aria-label="sortkey()">sortkey()</a></li></ul>
                    </li>
                    <li>
                        <a href="#constant" aria-label="Constant">Constant</a></li>
                    <li>
                        <a href="#type-waitq-struct" aria-label="type waitq struct">type waitq struct</a><ul>
                            
                    <li>
                        <a href="#dequeue" aria-label="dequeue()">dequeue()</a></li>
                    <li>
                        <a href="#enqueue" aria-label="enqueue()">enqueue()</a></li>
                    <li>
                        <a href="#dequeuesudog" aria-label="dequeueSudoG()">dequeueSudoG()</a></li></ul>
                    </li>
                    <li>
                        <a href="#type-sudog-struct" aria-label="type sudog struct">type sudog struct</a></li>
                    <li>
                        <a href="#make" aria-label="make()">make()</a><ul>
                            
                    <li>
                        <a href="#makechan" aria-label="makechan()">makechan()</a></li>
                    <li>
                        <a href="#makechan64" aria-label="makechan64()">makechan64()</a></li></ul>
                    </li>
                    <li>
                        <a href="#c---ep" aria-label="c &amp;lt;- ep">c &lt;- ep</a><ul>
                            
                    <li>
                        <a href="#chansend1" aria-label="chansend1()">chansend1()</a></li>
                    <li>
                        <a href="#chansend" aria-label="chansend()">chansend()</a></li>
                    <li>
                        <a href="#full" aria-label="full()">full()</a></li>
                    <li>
                        <a href="#send" aria-label="send()">send()</a><ul>
                            
                    <li>
                        <a href="#senddirect" aria-label="sendDirect()">sendDirect()</a></li>
                    <li>
                        <a href="#goready" aria-label="goready()">goready()</a></li>
                    <li>
                        <a href="#ready" aria-label="ready()">ready()</a></li></ul>
                    </li>
                    <li>
                        <a href="#chanbuf" aria-label="chanbuf()">chanbuf()</a></li></ul>
                    </li>
                    <li>
                        <a href="#ep---c" aria-label="ep &amp;lt;- c">ep &lt;- c</a><ul>
                            
                    <li>
                        <a href="#chanrecv" aria-label="chanrecv()">chanrecv()</a></li>
                    <li>
                        <a href="#empty" aria-label="empty()">empty()</a></li>
                    <li>
                        <a href="#recv" aria-label="recv()">recv()</a><ul>
                            
                    <li>
                        <a href="#goready-1" aria-label="goready()">goready()</a></li>
                    <li>
                        <a href="#ready-1" aria-label="ready()">ready()</a></li>
                    <li>
                        <a href="#runqput" aria-label="runqput()">runqput()</a></li>
                    <li>
                        <a href="#runqputslow" aria-label="runqputslow()">runqputslow()</a></li>
                    <li>
                        <a href="#globrunqputbatch" aria-label="globrunqputbatch()">globrunqputbatch()</a></li></ul>
                    </li></ul>
                    </li>
                    <li>
                        <a href="#v-ok---c" aria-label="v, ok := &amp;lt;-c">v, ok := &lt;-c</a></li>
                    <li>
                        <a href="#gopark" aria-label="gopark()">gopark()</a><ul>
                            
                    <li>
                        <a href="#park_m" aria-label="park_m()">park_m()</a></li></ul>
                    </li>
                    <li>
                        <a href="#close" aria-label="close()">close()</a><ul>
                            
                    <li>
                        <a href="#type-guintptr-uintptr" aria-label="type guintptr uintptr">type guintptr uintptr</a></li>
                    <li>
                        <a href="#type-glist-struct" aria-label="type gList struct">type gList struct</a></li></ul>
                    </li>
                    <li>
                        <a href="#len" aria-label="len()">len()</a></li>
                    <li>
                        <a href="#cap" aria-label="cap()">cap()</a></li>
                    <li>
                        <a href="#select-default" aria-label="select default">select default</a><ul>
                            
                    <li>
                        <a href="#select-%e4%b8%ad-c---v" aria-label="select 中 c &amp;lt;- v">select 中 c &lt;- v</a></li>
                    <li>
                        <a href="#select-%e4%b8%ad-v---c" aria-label="select 中 v &amp;lt;- c">select 中 v &lt;- c</a></li>
                    <li>
                        <a href="#select-%e4%b8%ad-v-ok----c" aria-label="select 中 v, ok = &amp;lt;- c">select 中 v, ok = &lt;- c</a><ul>
                            
                    <li>
                        <a href="#%e5%85%b6%e4%bb%96%e7%89%88%e6%9c%ac" aria-label="其他版本">其他版本</a></li></ul>
                    </li></ul>
                    </li>
                    <li>
                        <a href="#for-range" aria-label="for range">for range</a></li>
                    <li>
                        <a href="#%e6%80%bb%e7%bb%93" aria-label="总结">总结</a></li>
                    <li>
                        <a href="#%e5%8f%82%e8%80%83" aria-label="参考">参考</a>
                    </li>
                </ul>
            </div>
        </details>
    </div>
</aside>
<script>
    let activeElement;
    let elements;
    window.addEventListener('DOMContentLoaded', function (event) {
        checkTocPosition();

        elements = document.querySelectorAll('h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]');
         
         activeElement = elements[0];
         const id = encodeURI(activeElement.getAttribute('id')).toLowerCase();
         document.querySelector(`.inner ul li a[href="#${id}"]`).classList.add('active');
     }, false);

    window.addEventListener('resize', function(event) {
        checkTocPosition();
    }, false);

    window.addEventListener('scroll', () => {
        
        activeElement = Array.from(elements).find((element) => {
            if ((getOffsetTop(element) - window.pageYOffset) > 0 && 
                (getOffsetTop(element) - window.pageYOffset) < window.innerHeight/2) {
                return element;
            }
        }) || activeElement

        elements.forEach(element => {
             const id = encodeURI(element.getAttribute('id')).toLowerCase();
             if (element === activeElement){
                 document.querySelector(`.inner ul li a[href="#${id}"]`).classList.add('active');
             } else {
                 document.querySelector(`.inner ul li a[href="#${id}"]`).classList.remove('active');
             }
         })
     }, false);

    const main = parseInt(getComputedStyle(document.body).getPropertyValue('--article-width'), 10);
    const toc = parseInt(getComputedStyle(document.body).getPropertyValue('--toc-width'), 10);
    const gap = parseInt(getComputedStyle(document.body).getPropertyValue('--gap'), 10);

    function checkTocPosition() {
        const width = document.body.scrollWidth;

        if (width - main - (toc * 2) - (gap * 4) > 0) {
            document.getElementById("toc-container").classList.add("wide");
        } else {
            document.getElementById("toc-container").classList.remove("wide");
        }
    }

    function getOffsetTop(element) {
        if (!element.getClientRects().length) {
            return 0;
        }
        let rect = element.getBoundingClientRect();
        let win = element.ownerDocument.defaultView;
        return rect.top + win.pageYOffset;   
    }
</script>
  <div class="post-content"><p><strong>包解释</strong>：</p>
<ol>
<li>该文件包含 Go channels 的实现。</li>
<li>c.sendq 和 c.recvq 中至少有一个是空的，除了使用 select 语句发送和接收的无缓冲 chan 上阻止了单个 goroutine 的情况外，在这种情况下，c.sendq 和c.recvq 的长度仅受 select 语句的大小限制。</li>
<li>select 同时操作单个无缓冲 chan 的读和写这种情况下可能存在 c.sendq 和 c.recvq 都不为空（这种情况下 select不能有 default 分支）。</li>
<li>对于缓冲 channels，也是:
<ul>
<li>c.qcount &gt; 0 表示 c.recvq 为空。缓存区有值则 c.recvq 一定为空。</li>
<li>c.qcount &lt; c.dataqsiz 意味着 c.sendq 是空的。缓存区没有满则 c.sendq 一定为空。</li>
</ul>
</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kn">package</span> <span class="nx">runtime</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// This file contains the implementation of Go channels.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// Invariants:
</span></span></span><span class="line"><span class="cl"><span class="c1">//  At least one of c.sendq and c.recvq is empty,
</span></span></span><span class="line"><span class="cl"><span class="c1">//  except for the case of an unbuffered channel with a single goroutine
</span></span></span><span class="line"><span class="cl"><span class="c1">//  blocked on it for both sending and receiving using a select statement,
</span></span></span><span class="line"><span class="cl"><span class="c1">//  in which case the length of c.sendq and c.recvq is limited only by the
</span></span></span><span class="line"><span class="cl"><span class="c1">//  size of the select statement.
</span></span></span><span class="line"><span class="cl"><span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1">// For buffered channels, also:
</span></span></span><span class="line"><span class="cl"><span class="c1">//  c.qcount &gt; 0 implies that c.recvq is empty.
</span></span></span><span class="line"><span class="cl"><span class="c1">//  c.qcount &lt; c.dataqsiz implies that c.sendq is empty.
</span></span></span></code></pre></td></tr></table>
</div>
</div><h2 id="type-hchan-struct">type hchan struct<a hidden class="anchor" aria-hidden="true" href="#type-hchan-struct">#</a></h2>
<ol>
<li>hchan 结构其实就是一个【有缓冲】和【双向链表】组成的队列。</li>
<li>这个队列维护着通信的数据，以及挂起等待的 goroutine。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">hchan</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 已有元素个数（也就是通道中元素个数）len(chan)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 缓存区元素个数，不包括sendq上面的goroutine数量(如果存在)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">qcount</span>   <span class="kt">uint</span>   <span class="c1">// total data in the queue
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 数组容量（也就是chan容量）cap(chan)	
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 也就是 make(chan int, size) 这里的size
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">dataqsiz</span> <span class="kt">uint</span>   <span class="c1">// size of the circular queue
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 有缓冲数组地址指针，这里是根据 dataqsiz*elemsize 计算分配的内存数组大小
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">buf</span>      <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span> <span class="c1">// points to an array of dataqsiz elements
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 元素大小，比如int这里存储的就是8，string的话这里存储的就是16
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">elemsize</span> <span class="kt">uint16</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 通道是否被关闭 1.被关闭 0.正常
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">closed</span>   <span class="kt">uint32</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// chan元素类型，指向类型元数据，比如chan int这里记录的就是int的元类型
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">elemtype</span> <span class="o">*</span><span class="nx">_type</span> <span class="c1">// element type
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 当前索引（记录下一次send下标），下一次写取位置。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">sendx</span>    <span class="kt">uint</span>   <span class="c1">// send index
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 当前索引（记录下一次recv下标），下一次读入位置。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">recvx</span>    <span class="kt">uint</span>   <span class="c1">// receive index
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 等待写的队列，是一个双向的goroutine链表
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">recvq</span>    <span class="nx">waitq</span>  <span class="c1">// list of recv waiters
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 等待读的队列，是一个双向的goroutine链表
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">sendq</span>    <span class="nx">waitq</span>  <span class="c1">// list of send waiters
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="c1">// lock protects all fields in hchan, as well as several
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// fields in sudogs blocked on this channel.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// Do not change another G&#39;s status while holding this lock
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// (in particular, do not ready a G), as this can deadlock
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// with stack shrinking.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// lock保护hchan中的所有字段，以及sudogs中的一些字段在这个通道上被阻塞。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 在持有该锁时，不要改变另一个G的状态(特别是不要准备一个G)，因为这可能会导致栈收缩死锁。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">lock</span> <span class="nx">mutex</span>	<span class="c1">// runtime.mutex 为了应对并发的读写chan，参看runtime.mutex相关文档
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ol start="3">
<li>hchan 缓存区内存布局图（如果存在缓存区时）</li>
</ol>
<p><img loading="lazy" src="../images/channel-001.png" alt=""  />
</p>
<h3 id="raceaddr">raceaddr()<a hidden class="anchor" aria-hidden="true" href="#raceaddr">#</a></h3>
<ol>
<li>该函数主要用于 make() 函数中，当申请总内存为0时，返回当前buf字段地址作为 buf 的值。形成指针指向闭环。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">hchan</span><span class="p">)</span> <span class="nf">raceaddr</span><span class="p">()</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Treat read-like and write-like operations on the channel to
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// happen at this address. Avoid using the address of qcount
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// or dataqsiz, because the len() and cap() builtins read
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// those addresses, and we don&#39;t want them racing with
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// operations like close().
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 将channel上的read-like和write-like操作视为在此地址发生。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 避免使用qcount或dataqsiz的地址，因为len()和cap()内置函数会读取这些地址，我们不希望它们与close()等操作竞争。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">return</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">c</span><span class="p">.</span><span class="nx">buf</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="sortkey">sortkey()<a hidden class="anchor" aria-hidden="true" href="#sortkey">#</a></h3>
<ol>
<li>该函数在 goselect() 函数中使用，用于返回 chan 地址升序排序 channels。</li>
<li>select 中相关用到的函数。在后面介绍select时，会被使用。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">hchan</span><span class="p">)</span> <span class="nf">sortkey</span><span class="p">()</span> <span class="kt">uintptr</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">c</span><span class="p">))</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="constant">Constant<a hidden class="anchor" aria-hidden="true" href="#constant">#</a></h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">const</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 最大对齐字节数，主要用于下面的定义。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">maxAlign</span>  <span class="p">=</span> <span class="mi">8</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c1">// hchan 占用内存大小字节，使 hchan 按照 maxAlign 大小对齐
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 比如 hchan 是 12byte，那么 hchanSize 则是 16byte
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 为什么要使 hchan 对齐 maxAlign？原因是 hchan 后接着是 chan 元素的内存空间块(如果是有缓冲情况下)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 这种情况是为了兼容32位，因为在64位下hchan就是8字节对齐的，该字段用于make函数中申请 chan 内存需要。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">hchanSize</span> <span class="p">=</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Sizeof</span><span class="p">(</span><span class="nx">hchan</span><span class="p">{})</span> <span class="o">+</span> <span class="nb">uintptr</span><span class="p">(</span><span class="o">-</span><span class="nb">int</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Sizeof</span><span class="p">(</span><span class="nx">hchan</span><span class="p">{}))</span><span class="o">&amp;</span><span class="p">(</span><span class="nx">maxAlign</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">    <span class="nx">debugChan</span> <span class="p">=</span> <span class="kc">false</span>	<span class="c1">// debug
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">)</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="type-waitq-struct">type waitq struct<a hidden class="anchor" aria-hidden="true" href="#type-waitq-struct">#</a></h2>
<ol>
<li>waitq 根据 sudog 形成一个双向链表。</li>
<li>其实就是一个队列的功能，元素【从 last 处添加】，【从 first 处取出】。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">waitq</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">first</span> <span class="o">*</span><span class="nx">sudog</span>    <span class="c1">// 指向链表的首个 *sudog
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">last</span>  <span class="o">*</span><span class="nx">sudog</span>    <span class="c1">// 指向链表的尾部 *sudog
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><img loading="lazy" src="../images/channel-002.png" alt=""  />
</p>
<h3 id="dequeue">dequeue()<a hidden class="anchor" aria-hidden="true" href="#dequeue">#</a></h3>
<ol>
<li>从 first 中取出一个 *sudog。相当于从队列头（first）取出一个 *sudog。</li>
<li>调用该方法时 chan lock 锁一定是被持有的。下面函数中需要 <code>for {}</code> 的原因是最后一个 <code>if</code> 条件的 <code>CAS</code> 操作。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">q</span> <span class="o">*</span><span class="nx">waitq</span><span class="p">)</span> <span class="nf">dequeue</span><span class="p">()</span> <span class="o">*</span><span class="nx">sudog</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">sgp</span> <span class="o">:=</span> <span class="nx">q</span><span class="p">.</span><span class="nx">first</span>  <span class="c1">// 从first处取一个 *sudog
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="nx">sgp</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="nx">y</span> <span class="o">:=</span> <span class="nx">sgp</span><span class="p">.</span><span class="nx">next</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="nx">y</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>   <span class="c1">// 最后一个 *sudog
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="nx">q</span><span class="p">.</span><span class="nx">first</span> <span class="p">=</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl">            <span class="nx">q</span><span class="p">.</span><span class="nx">last</span> <span class="p">=</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nx">y</span><span class="p">.</span><span class="nx">prev</span> <span class="p">=</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl">            <span class="nx">q</span><span class="p">.</span><span class="nx">first</span> <span class="p">=</span> <span class="nx">y</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 标记已删除（参看 dequeueSudoG）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="nx">sgp</span><span class="p">.</span><span class="nx">next</span> <span class="p">=</span> <span class="kc">nil</span> <span class="c1">// mark as removed (see dequeueSudoG)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// 为什么需要下面的判断条件？
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">//  1. select 语句中阻塞了一组 chan 时，所有 channels 的 lock 锁都已被持有。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">//  2. 当前执行select语句的goroutine会被封装到多个*sudog中通过waitlink字段形成链表，然后把各个*sudog的isSelect字段标记为true。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">//  3. 把各个*sudog分别挂在各自的sendq或recvq链表中。等待goroutine被唤醒。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">//  4. 某一时刻*sudog被选中唤醒，则一定会执行当前函数 *sudog.isSelect 是 true，并且通过 CAS 把 g.selectDone 从0标记为1。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">//  5. 注意此时唤醒的goroutine可能在多个channel上面等待。此时可能会出现在其他chan上这个goroutine也被选中了，也在执行当前函数。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">//  6. 则这里会直接跳过。因为当前goroutine已被唤醒，后续会在唤醒的goroutine移除这里goroutine的goselect函数中。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">//  7. goroutine 唤醒后会获取所有的 channels lock，然后把selectDone设置为0，此时因为所有的channel lock已被持有所以能立即修改selectDone。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        
</span></span><span class="line"><span class="cl">        <span class="c1">// if a goroutine was put on this queue because of a
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// select, there is a small window between the goroutine
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// being woken up by a different case and it grabbing the
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// channel locks. Once it has the lock
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// it removes itself from the queue, so we won&#39;t see it after that.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// We use a flag in the G struct to tell us when someone
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// else has won the race to signal this goroutine but the goroutine
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// hasn&#39;t removed itself from the queue yet.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 如果一个goroutine因为select被放到这个队列上，那么在goroutine被不同的情况唤醒和它获取通道锁之间有一个小窗口。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 一旦它有了锁，它就会从队列中移除自己，所以在那之后我们就看不到它了。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 我们在G结构体中使用一个标志来告诉我们，当有其他人赢得比赛时，向这个goroutine发出信号，但该goroutine还没有从队列中删除自己。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="nx">sgp</span><span class="p">.</span><span class="nx">isSelect</span> <span class="o">&amp;&amp;</span> <span class="p">!</span><span class="nx">atomic</span><span class="p">.</span><span class="nf">Cas</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sgp</span><span class="p">.</span><span class="nx">g</span><span class="p">.</span><span class="nx">selectDone</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">continue</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="nx">sgp</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="enqueue">enqueue()<a hidden class="anchor" aria-hidden="true" href="#enqueue">#</a></h3>
<ol>
<li>从 last 放入 *sudog。相当于从队列尾（last）添加元素。</li>
<li>调用该方法时 chan lock 已被持有。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">q</span> <span class="o">*</span><span class="nx">waitq</span><span class="p">)</span> <span class="nf">enqueue</span><span class="p">(</span><span class="nx">sgp</span> <span class="o">*</span><span class="nx">sudog</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">sgp</span><span class="p">.</span><span class="nx">next</span> <span class="p">=</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl">    <span class="nx">x</span> <span class="o">:=</span> <span class="nx">q</span><span class="p">.</span><span class="nx">last</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">x</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>   <span class="c1">// waitq 是空的
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">sgp</span><span class="p">.</span><span class="nx">prev</span> <span class="p">=</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl">        <span class="nx">q</span><span class="p">.</span><span class="nx">first</span> <span class="p">=</span> <span class="nx">sgp</span>
</span></span><span class="line"><span class="cl">        <span class="nx">q</span><span class="p">.</span><span class="nx">last</span> <span class="p">=</span> <span class="nx">sgp</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nx">sgp</span><span class="p">.</span><span class="nx">prev</span> <span class="p">=</span> <span class="nx">x</span>
</span></span><span class="line"><span class="cl">    <span class="nx">x</span><span class="p">.</span><span class="nx">next</span> <span class="p">=</span> <span class="nx">sgp</span>
</span></span><span class="line"><span class="cl">    <span class="nx">q</span><span class="p">.</span><span class="nx">last</span> <span class="p">=</span> <span class="nx">sgp</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="dequeuesudog">dequeueSudoG()<a hidden class="anchor" aria-hidden="true" href="#dequeuesudog">#</a></h3>
<ol>
<li>在 selectgo() 函数中被用到，用于将<strong>指定</strong>的 *sudog 取出。</li>
<li>因为 select 不能立即完成时会挂在所有的 channel，当有 channel 就绪后其他 recvq、sendq 上的需要调用这个函数剔除掉。</li>
<li>调用该函数是相关的 channel lock 已被持有。</li>
<li>参数：<code>sgp *sudog</code> 是通过 waitlink 字段组成的 *sudog 链表。</li>
<li>该函数也是在 <code>go1.19.3/src/runtime/select.go</code> 文件中。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">q</span> <span class="o">*</span><span class="nx">waitq</span><span class="p">)</span> <span class="nf">dequeueSudoG</span><span class="p">(</span><span class="nx">sgp</span> <span class="o">*</span><span class="nx">sudog</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 当前 sgp 可能处在链表的任何位置，或者不在链表中。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">x</span> <span class="o">:=</span> <span class="nx">sgp</span><span class="p">.</span><span class="nx">prev</span>
</span></span><span class="line"><span class="cl">    <span class="nx">y</span> <span class="o">:=</span> <span class="nx">sgp</span><span class="p">.</span><span class="nx">next</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">x</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="nx">y</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// middle of queue
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// 在 queue 的中间
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="nx">x</span><span class="p">.</span><span class="nx">next</span> <span class="p">=</span> <span class="nx">y</span>
</span></span><span class="line"><span class="cl">            <span class="nx">y</span><span class="p">.</span><span class="nx">prev</span> <span class="p">=</span> <span class="nx">x</span>
</span></span><span class="line"><span class="cl">            <span class="nx">sgp</span><span class="p">.</span><span class="nx">next</span> <span class="p">=</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl">            <span class="nx">sgp</span><span class="p">.</span><span class="nx">prev</span> <span class="p">=</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// end of queue
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 在 queue 的最后
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">x</span><span class="p">.</span><span class="nx">next</span> <span class="p">=</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl">        <span class="nx">q</span><span class="p">.</span><span class="nx">last</span> <span class="p">=</span> <span class="nx">x</span>
</span></span><span class="line"><span class="cl">        <span class="nx">sgp</span><span class="p">.</span><span class="nx">prev</span> <span class="p">=</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">y</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// start of queue
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 在queue开头
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">y</span><span class="p">.</span><span class="nx">prev</span> <span class="p">=</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl">        <span class="nx">q</span><span class="p">.</span><span class="nx">first</span> <span class="p">=</span> <span class="nx">y</span>
</span></span><span class="line"><span class="cl">        <span class="nx">sgp</span><span class="p">.</span><span class="nx">next</span> <span class="p">=</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// x==y==nil. Either sgp is the only element in the queue,
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// or it has already been removed. Use q.first to disambiguate.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// x==y==nil。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 要么 sgp 是队列中唯一的成员，要么它已经被删除。使用 q.first 来消除歧义。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nx">q</span><span class="p">.</span><span class="nx">first</span> <span class="o">==</span> <span class="nx">sgp</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">q</span><span class="p">.</span><span class="nx">first</span> <span class="p">=</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl">        <span class="nx">q</span><span class="p">.</span><span class="nx">last</span> <span class="p">=</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="type-sudog-struct">type sudog struct<a hidden class="anchor" aria-hidden="true" href="#type-sudog-struct">#</a></h2>
<ol>
<li>sudog 表示等待列表中的 g，例如用于在 channel 上 sending/receiving 。</li>
<li>sudog 是必要的，因为 g↔synchronization 对象关系是多对多的。</li>
<li>一个 g 可能会出现在许多等待列表中，所以一个g可能会有许多 sudog;</li>
<li>并且许多 g 可能在同一个 same 对象上等待，因此一个对象可能有许多 sudog。</li>
<li>sudog 是从一个特殊的池中分配的。使用 acquireSudog 和 releaseSudog 来分配和释放它们。</li>
<li>文件位置：go1.19.3/src/runtime2.go。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// sudog represents a g in a wait list, such as for sending/receiving
</span></span></span><span class="line"><span class="cl"><span class="c1">// on a channel.
</span></span></span><span class="line"><span class="cl"><span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1">// sudog is necessary because the g ↔ synchronization object relation
</span></span></span><span class="line"><span class="cl"><span class="c1">// is many-to-many. A g can be on many wait lists, so there may be
</span></span></span><span class="line"><span class="cl"><span class="c1">// many sudogs for one g; and many gs may be waiting on the same
</span></span></span><span class="line"><span class="cl"><span class="c1">// synchronization object, so there may be many sudogs for one object.
</span></span></span><span class="line"><span class="cl"><span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1">// sudogs are allocated from a special pool. Use acquireSudog and
</span></span></span><span class="line"><span class="cl"><span class="c1">// releaseSudog to allocate and free them.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">type</span> <span class="nx">sudog</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// The following fields are protected by the hchan.lock of the
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// channel this sudog is blocking on. shrinkstack depends on
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// this for sudogs involved in channel ops.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="nx">g</span> <span class="o">*</span><span class="nx">g</span>        <span class="c1">// 等待的goroutine
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="nx">next</span> <span class="o">*</span><span class="nx">sudog</span> <span class="c1">// 链接下一个*sudog     对于二叉树就是left
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">prev</span> <span class="o">*</span><span class="nx">sudog</span> <span class="c1">// 链接前一个*sudog     对于二叉树就是right
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// seampher中：保存来自信号量的地址；比如在sync.Mutex中则是&amp;sync.Mutex.sema该字段的地址。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// channels中：则是保存需要传递的值的地址。（需要交换的数据地址）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">elem</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span> <span class="c1">// data element (may point to stack)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="c1">// The following fields are never accessed concurrently.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// For channels, waitlink is only accessed by g.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// For semaphores, all fields (including the ones above)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// are only accessed when holding a semaRoot lock.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 以下字段永远不会并发访问。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 对于 channels，waitlink 只能由 g 访问。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 对于 semaphores，所有字段(包括上面的字段)只有在持有 semaRoot 锁时才能访问。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 以下时间都是为了分析 sudog
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">acquiretime</span> <span class="kt">int64</span>   <span class="c1">// 获得 sudog 的时间
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">releasetime</span> <span class="kt">int64</span>   <span class="c1">// 释放时间	
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    
</span></span><span class="line"><span class="cl">    <span class="c1">// ticket 用于形成最小堆，从root往下按照 s.ticket &lt;= both s.prev.ticket AND s.next.ticket; 最小堆就是一种完全二叉树
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//  1. ticket 在 semaRoot.queue 函数中作为二叉树枝干情况下被初始化为 s.ticket = fastrand() | 1;  s.ticket &gt;= 0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//  2. ticket 在 semaRoot.dequeue 函数中返回 sudog 时，被重置为0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//  3. ticket 在 sync_runtime_SemacquireMutex 函数中 如果是饥饿模式则标记为1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 最小堆百度百科：https://baike.baidu.com/item/%E6%9C%80%E5%B0%8F%E5%A0%86/9139372
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">ticket</span>      <span class="kt">uint32</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// isSelect indicates g is participating in a select, so
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// g.selectDone must be CAS&#39;d to win the wake-up race.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// isSelect 表示 g 正在参与一个 select，因此 g.selectDone 必须经过 CAS 处理才能赢得唤醒竞赛。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 具体参考 goselect() 函数。当前是因为 select 语句被挂起时，该字段会被设置为 true。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">isSelect</span> <span class="kt">bool</span> <span class="c1">// 在select结构中被使用
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="c1">// success indicates whether communication over channel c
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// succeeded. It is true if the goroutine was awoken because a
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// value was delivered over channel c, and false if awoken
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// because c was closed.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// success c 通道通信是否成功。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 如果 goroutine 因为通过通道 c 传递值而被唤醒，则为 true，如果因为通道 c 被关闭而被唤醒，则为 false。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">success</span> <span class="kt">bool</span>  <span class="c1">// 在chan中被使用，用于判断本次通信是否成功
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="c1">// semaRoot的二叉树
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">parent</span>   <span class="o">*</span><span class="nx">sudog</span> <span class="c1">// semaRoot binary tree
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// g.waiting 列表或 semaRoot 的等待链表，指向链表的头。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 在 goselect() 函数中，挂起的 goroutine 组装的 *sudog 通过 waitlink 字段形成链表。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// waitlink 只在 semapher 或 select 语句中被用来形成链表。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">waitlink</span> <span class="o">*</span><span class="nx">sudog</span> <span class="c1">// g.waiting list or semaRoot
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 等待尾部 semaRoot，指向链表的尾部
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">waittail</span> <span class="o">*</span><span class="nx">sudog</span> <span class="c1">// semaRoot
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 当前sudog所属*hchan，select不能就绪要被挂起时用到。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">c</span>        <span class="o">*</span><span class="nx">hchan</span> <span class="c1">// channel
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="make">make()<a hidden class="anchor" aria-hidden="true" href="#make">#</a></h2>
<p>初始化 channel。</p>
<h3 id="makechan">makechan()<a hidden class="anchor" aria-hidden="true" href="#makechan">#</a></h3>
<ol>
<li>函数原型：make(chan Type, size int)</li>
<li>参数：
<ul>
<li><strong>t *chantype</strong>：chan 元类型结构。</li>
<li><strong>size int</strong>：chan 大小，默认0无缓冲 chan；&gt;=1 都是有缓冲 chan。</li>
</ul>
</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">chantype</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">typ</span>  <span class="nx">_type</span>      <span class="c1">// chan元类型
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">elem</span> <span class="o">*</span><span class="nx">_type</span>     <span class="c1">// chan 元素元类型
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">dir</span>  <span class="kt">uintptr</span>    <span class="c1">// 通道方向
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">makechan</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">chantype</span><span class="p">,</span> <span class="nx">size</span> <span class="kt">int</span><span class="p">)</span> <span class="o">*</span><span class="nx">hchan</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">elem</span> <span class="o">:=</span> <span class="nx">t</span><span class="p">.</span><span class="nx">elem</span>  <span class="c1">// chan元素元类型
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="c1">// compiler checks this but be safe.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 编译器会检查这一点，但这是安全的。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nx">elem</span><span class="p">.</span><span class="nx">size</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">16</span> <span class="p">{</span> <span class="c1">// chan元素类型内存 &gt;= 1&lt;&lt;16时不适合chan
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nf">throw</span><span class="p">(</span><span class="s">&#34;makechan: invalid channel element type&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// hchan 是否对齐 maxAlign
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nx">hchanSize</span><span class="o">%</span><span class="nx">maxAlign</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">||</span> <span class="nx">elem</span><span class="p">.</span><span class="nx">align</span> <span class="p">&gt;</span> <span class="nx">maxAlign</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">throw</span><span class="p">(</span><span class="s">&#34;makechan: bad alignment&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// mem = elem.size * uintptr(size)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">mem</span><span class="p">,</span> <span class="nx">overflow</span> <span class="o">:=</span> <span class="nx">math</span><span class="p">.</span><span class="nf">MulUintptr</span><span class="p">(</span><span class="nx">elem</span><span class="p">.</span><span class="nx">size</span><span class="p">,</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">size</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">overflow</span> <span class="o">||</span> <span class="nx">mem</span> <span class="p">&gt;</span> <span class="nx">maxAlloc</span><span class="o">-</span><span class="nx">hchanSize</span> <span class="o">||</span> <span class="nx">size</span> <span class="p">&lt;</span> <span class="mi">0</span> <span class="p">{</span> <span class="c1">// 内存溢出
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nb">panic</span><span class="p">(</span><span class="nf">plainError</span><span class="p">(</span><span class="s">&#34;makechan: size out of range&#34;</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// Hchan does not contain pointers interesting for GC when elements stored in buf do not contain pointers.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// buf points into the same allocation, elemtype is persistent.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// SudoG&#39;s are referenced from their owning thread so they can&#39;t be collected.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// TODO(dvyukov,rlh): Rethink when collector can move allocated objects.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 当存储在buf中的元素不包含指针时，hchan不包含GC感兴趣的指针。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// (因此可直接在无指针内存块分配)。buf指向相同的内存分配，elemtype是持久的。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// Sudog 是在它们自己的线程中引用的，所以它们无法被收集。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// TODO(dvyukov,rlh):重新考虑收集器何时可以移动已分配的对象。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kd">var</span> <span class="nx">c</span> <span class="o">*</span><span class="nx">hchan</span> <span class="c1">// nil
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">switch</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 【make(chan struct{}, n)】 OR 【make(chan int, 0)】 形式
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">case</span> <span class="nx">mem</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="c1">// channel 内存为零
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// Queue or element size is zero.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// Queue 或 element 的大小为0。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 注意这里申请的内存规格块是无指针的，具体原因前面注释有解释
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">c</span> <span class="p">=</span> <span class="p">(</span><span class="o">*</span><span class="nx">hchan</span><span class="p">)(</span><span class="nf">mallocgc</span><span class="p">(</span><span class="nx">hchanSize</span><span class="p">,</span> <span class="kc">nil</span><span class="p">,</span> <span class="kc">true</span><span class="p">))</span> <span class="c1">// 申请hchan需要的内存空间
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// Race detector uses this location for synchronization.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 竞态检测器使用此位置进行同步。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">c</span><span class="p">.</span><span class="nx">buf</span> <span class="p">=</span> <span class="nx">c</span><span class="p">.</span><span class="nf">raceaddr</span><span class="p">()</span> <span class="c1">// c.buf = &amp;c.buf
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">case</span> <span class="nx">elem</span><span class="p">.</span><span class="nx">ptrdata</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="c1">// channel 内存不为零，元素不包含指针
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// Elements do not contain pointers.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// Allocate hchan and buf in one call.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 元素不包含指针。一次调用即可分配 hchan 和 buf。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// hchanSize 主要是为了这里的对齐。注意这里申请的内存规格块是无指针的，具体原因前面注释有解释
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">c</span> <span class="p">=</span> <span class="p">(</span><span class="o">*</span><span class="nx">hchan</span><span class="p">)(</span><span class="nf">mallocgc</span><span class="p">(</span><span class="nx">hchanSize</span><span class="o">+</span><span class="nx">mem</span><span class="p">,</span> <span class="kc">nil</span><span class="p">,</span> <span class="kc">true</span><span class="p">))</span> <span class="c1">// 申请【hchan + buf】需要内存块
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">c</span><span class="p">.</span><span class="nx">buf</span> <span class="p">=</span> <span class="nf">add</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">c</span><span class="p">),</span> <span class="nx">hchanSize</span><span class="p">)</span> <span class="c1">// 可见申请的是一整块内存空间
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">default</span><span class="p">:</span> <span class="c1">// channel 内存不为零，元素包含指针
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// Elements contain pointers.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 元素包含指针。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">c</span> <span class="p">=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">hchan</span><span class="p">)</span> 
</span></span><span class="line"><span class="cl">        <span class="c1">// 申请元素需要的内存块
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 注意这里申请的是有指针内存规格块，具体原因是chan元素类型有指针可能存在多级指针引用，需要GC帮助
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">c</span><span class="p">.</span><span class="nx">buf</span> <span class="p">=</span> <span class="nf">mallocgc</span><span class="p">(</span><span class="nx">mem</span><span class="p">,</span> <span class="nx">elem</span><span class="p">,</span> <span class="kc">true</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nx">c</span><span class="p">.</span><span class="nx">elemsize</span> <span class="p">=</span> <span class="nb">uint16</span><span class="p">(</span><span class="nx">elem</span><span class="p">.</span><span class="nx">size</span><span class="p">)</span> <span class="c1">// chan 元素大小
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">c</span><span class="p">.</span><span class="nx">elemtype</span> <span class="p">=</span> <span class="nx">elem</span>              <span class="c1">// chan元素元类型
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">c</span><span class="p">.</span><span class="nx">dataqsiz</span> <span class="p">=</span> <span class="nb">uint</span><span class="p">(</span><span class="nx">size</span><span class="p">)</span>        <span class="c1">// 有缓存容量，一旦初始化就是确定的值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 初始化 runtime.mutex，主要是初始化锁排名
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">lockInit</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">c</span><span class="p">.</span><span class="nx">lock</span><span class="p">,</span> <span class="nx">lockRankHchan</span><span class="p">)</span>	
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">debugChan</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nb">print</span><span class="p">(</span><span class="s">&#34;makechan: chan=&#34;</span><span class="p">,</span> <span class="nx">c</span><span class="p">,</span> <span class="s">&#34;; elemsize=&#34;</span><span class="p">,</span> <span class="nx">elem</span><span class="p">.</span><span class="nx">size</span><span class="p">,</span> <span class="s">&#34;; dataqsiz=&#34;</span><span class="p">,</span> <span class="nx">size</span><span class="p">,</span> <span class="s">&#34;\n&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nx">c</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><img loading="lazy" src="../images/channel-003.png" alt=""  />
</p>
<h3 id="makechan64">makechan64()<a hidden class="anchor" aria-hidden="true" href="#makechan64">#</a></h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">makechan64</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">chantype</span><span class="p">,</span> <span class="nx">size</span> <span class="kt">int64</span><span class="p">)</span> <span class="o">*</span><span class="nx">hchan</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nb">int64</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="nx">size</span><span class="p">))</span> <span class="o">!=</span> <span class="nx">size</span> <span class="p">{</span> <span class="c1">// 如果在32位系统下这里会报错
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nb">panic</span><span class="p">(</span><span class="nf">plainError</span><span class="p">(</span><span class="s">&#34;makechan: size out of range&#34;</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nf">makechan</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="nx">size</span><span class="p">))</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="c---ep">c &lt;- ep<a hidden class="anchor" aria-hidden="true" href="#c---ep">#</a></h2>
<p>ep 发送到 c 中。</p>
<h3 id="chansend1">chansend1()<a hidden class="anchor" aria-hidden="true" href="#chansend1">#</a></h3>
<ol>
<li>编译后代码中 <strong>c &lt;- x</strong> 的入口点。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1">// c &lt;- ep
</span></span></span><span class="line"><span class="cl"><span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1">// as 
</span></span></span><span class="line"><span class="cl"><span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1">// chansend1(c, &amp;ep)
</span></span></span><span class="line"><span class="cl"><span class="c1">// 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// entry point for c &lt;- x from compiled code
</span></span></span><span class="line"><span class="cl"><span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1">//go:nosplit
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">chansend1</span><span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">hchan</span><span class="p">,</span> <span class="nx">elem</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nf">chansend</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">elem</span><span class="p">,</span> <span class="kc">true</span><span class="p">,</span> <span class="nf">getcallerpc</span><span class="p">())</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="chansend">chansend()<a hidden class="anchor" aria-hidden="true" href="#chansend">#</a></h3>
<ol>
<li>通用单通道 send/recv，如果 block 不是 nil，那么协议将不会进入睡眠状态，如果无法完成则返回。</li>
<li>当涉及 sleep 的通道被关闭时，sleep 可以使用 g.param == nil 唤醒。循环并重新运行操作是最简单的;我们会看到它现在已经关闭了。</li>
<li>参数：
<ul>
<li><strong><code>c *hchan</code></strong>：hchan 结构体的指针。指向要来用 send 数据的 channel。</li>
<li><strong><code>ep unsafe.Pointer</code></strong>：ep 是 c &lt;- ep 需要发送到 chan 的数据地址。
<ul>
<li>是一个指针，指向要被送入通道 c 的数据，数据类型要和 c 的元素类型一致。</li>
</ul>
</li>
<li><strong><code>block bool</code></strong>：false.不能立即完成时不阻塞。 true.不能立即完成时阻塞。
<ul>
<li>表示如果 send 操作不能立即完成，是否想要阻塞等待。</li>
<li>block bool 参数 false 状态用于 <strong>select{case: default:}</strong> 形式中。true 状态用于 c &lt;- ep 情况下。</li>
</ul>
</li>
<li><strong><code>callerpc uintptr</code></strong>：是 c &lt;- ep 的下一条代码指令地址。用于进行race相关检测。</li>
</ul>
</li>
<li>返回值：
<ul>
<li><strong><code>bool</code></strong>：true.数据 send 完成。false.表示目前不能发送，但因为不想阻塞(block为false)而返回。</li>
</ul>
</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span><span class="lnt">113
</span><span class="lnt">114
</span><span class="lnt">115
</span><span class="lnt">116
</span><span class="lnt">117
</span><span class="lnt">118
</span><span class="lnt">119
</span><span class="lnt">120
</span><span class="lnt">121
</span><span class="lnt">122
</span><span class="lnt">123
</span><span class="lnt">124
</span><span class="lnt">125
</span><span class="lnt">126
</span><span class="lnt">127
</span><span class="lnt">128
</span><span class="lnt">129
</span><span class="lnt">130
</span><span class="lnt">131
</span><span class="lnt">132
</span><span class="lnt">133
</span><span class="lnt">134
</span><span class="lnt">135
</span><span class="lnt">136
</span><span class="lnt">137
</span><span class="lnt">138
</span><span class="lnt">139
</span><span class="lnt">140
</span><span class="lnt">141
</span><span class="lnt">142
</span><span class="lnt">143
</span><span class="lnt">144
</span><span class="lnt">145
</span><span class="lnt">146
</span><span class="lnt">147
</span><span class="lnt">148
</span><span class="lnt">149
</span><span class="lnt">150
</span><span class="lnt">151
</span><span class="lnt">152
</span><span class="lnt">153
</span><span class="lnt">154
</span><span class="lnt">155
</span><span class="lnt">156
</span><span class="lnt">157
</span><span class="lnt">158
</span><span class="lnt">159
</span><span class="lnt">160
</span><span class="lnt">161
</span><span class="lnt">162
</span><span class="lnt">163
</span><span class="lnt">164
</span><span class="lnt">165
</span><span class="lnt">166
</span><span class="lnt">167
</span><span class="lnt">168
</span><span class="lnt">169
</span><span class="lnt">170
</span><span class="lnt">171
</span><span class="lnt">172
</span><span class="lnt">173
</span><span class="lnt">174
</span><span class="lnt">175
</span><span class="lnt">176
</span><span class="lnt">177
</span><span class="lnt">178
</span><span class="lnt">179
</span><span class="lnt">180
</span><span class="lnt">181
</span><span class="lnt">182
</span><span class="lnt">183
</span><span class="lnt">184
</span><span class="lnt">185
</span><span class="lnt">186
</span><span class="lnt">187
</span><span class="lnt">188
</span><span class="lnt">189
</span><span class="lnt">190
</span><span class="lnt">191
</span><span class="lnt">192
</span><span class="lnt">193
</span><span class="lnt">194
</span><span class="lnt">195
</span><span class="lnt">196
</span><span class="lnt">197
</span><span class="lnt">198
</span><span class="lnt">199
</span><span class="lnt">200
</span><span class="lnt">201
</span><span class="lnt">202
</span><span class="lnt">203
</span><span class="lnt">204
</span><span class="lnt">205
</span><span class="lnt">206
</span><span class="lnt">207
</span><span class="lnt">208
</span><span class="lnt">209
</span><span class="lnt">210
</span><span class="lnt">211
</span><span class="lnt">212
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="cm">/*
</span></span></span><span class="line"><span class="cl"><span class="cm"> * generic single channel send/recv
</span></span></span><span class="line"><span class="cl"><span class="cm"> * If block is not nil,
</span></span></span><span class="line"><span class="cl"><span class="cm"> * then the protocol will not
</span></span></span><span class="line"><span class="cl"><span class="cm"> * sleep but return if it could
</span></span></span><span class="line"><span class="cl"><span class="cm"> * not complete.
</span></span></span><span class="line"><span class="cl"><span class="cm"> *
</span></span></span><span class="line"><span class="cl"><span class="cm"> * sleep can wake up with g.param == nil
</span></span></span><span class="line"><span class="cl"><span class="cm"> * when a channel involved in the sleep has
</span></span></span><span class="line"><span class="cl"><span class="cm"> * been closed.  it is easiest to loop and re-run
</span></span></span><span class="line"><span class="cl"><span class="cm"> * the operation; we&#39;ll see that it&#39;s now closed.
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span>
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">chansend</span><span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">hchan</span><span class="p">,</span> <span class="nx">ep</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">,</span> <span class="nx">block</span> <span class="kt">bool</span><span class="p">,</span> <span class="nx">callerpc</span> <span class="kt">uintptr</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 1) chan没有初始化，比如 var c chan int形式
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nx">c</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">!</span><span class="nx">block</span> <span class="p">{</span>      <span class="c1">// select{case: default:} 块
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="k">return</span> <span class="kc">false</span> <span class="c1">// 返回false，表示未发送数据。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">        <span class="c1">// nil &lt;- x：如果block为true，就让当前协程永久地阻塞在这个nil通道上。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        
</span></span><span class="line"><span class="cl">        <span class="c1">// 处理相关goroutine然后再次进行新一轮调度。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 注意：这里的goroutine将永久丢失，因为这个goroutine没有被放入队列中等待被调度，
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 还有就是c &lt;- x这行代码后的所有代码都不会在被执行。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nf">gopark</span><span class="p">(</span><span class="kc">nil</span><span class="p">,</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">waitReasonChanSendNilChan</span><span class="p">,</span> <span class="nx">traceEvGoStop</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="nf">throw</span><span class="p">(</span><span class="s">&#34;unreachable&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">debugChan</span> <span class="p">{</span> <span class="c1">// debug
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nb">print</span><span class="p">(</span><span class="s">&#34;chansend: chan=&#34;</span><span class="p">,</span> <span class="nx">c</span><span class="p">,</span> <span class="s">&#34;\n&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">raceenabled</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">racereadpc</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nf">raceaddr</span><span class="p">(),</span> <span class="nx">callerpc</span><span class="p">,</span> <span class="nx">abi</span><span class="p">.</span><span class="nf">FuncPCABIInternal</span><span class="p">(</span><span class="nx">chansend</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// Fast path: check for failed non-blocking operation without acquiring the lock.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// After observing that the channel is not closed, we observe that the channel is
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// not ready for sending. Each of these observations is a single word-sized read
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// (first c.closed and second full()).
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// Because a closed channel cannot transition from &#39;ready for sending&#39; to
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// &#39;not ready for sending&#39;, even if the channel is closed between the two observations,
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// they imply a moment between the two when the channel was both not yet closed
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// and not ready for sending. We behave as if we observed the channel at that moment,
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// and report that the send cannot proceed.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// It is okay if the reads are reordered here: if we observe that the channel is not
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// ready for sending and then observe that it is not closed, that implies that the
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// channel wasn&#39;t closed during the first observation. However, nothing here
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// guarantees forward progress. We rely on the side effects of lock release in
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// chanrecv() and closechan() to update this thread&#39;s view of c.closed and full().
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// Fast path: 在未获得锁的情况下检查失败的非阻塞操作。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 在观察到通道没有关闭之后，我们观察到通道还没有准备好发送。每个观察值都是单个word-sized的读取(第一个是c.closed，第二个是full())。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 因为一个封闭的通道不能从&#39;ready for sending&#39;过渡到&#39;not ready for sending&#39;，即使在两次观测之间通道是关闭的，
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 它们也意味着在两次观测之间通道既没有关闭也没有准备好发送的时刻。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 我们的行为就像我们当时观察到通道一样，并报告发送无法继续。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 在这里，如果读操作被重新排序是可以的:如果我们观察到通道还没有准备好发送，然后又观察到它没有关闭，这意味着在第一次观察期间通道没有关闭。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 然而，这里没有任何东西能保证取得进展。我们依赖chanrecv()和closechan()中锁释放的副作用来更新这个线程的c.closed和full()视图。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">!</span><span class="nx">block</span> <span class="o">&amp;&amp;</span> <span class="nx">c</span><span class="p">.</span><span class="nx">closed</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nf">full</span><span class="p">(</span><span class="nx">c</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// select块中 &amp;&amp; chan未关闭 &amp;&amp; c已满
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 如果block为false且closed为0，也就是在不想阻塞且通道未关闭的前提下，如果通道满了（无缓冲且recvq为空，或者有缓存且缓冲已用尽），
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 则直接返回false。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 本步判断是在不加锁的情况下进行的，目的是让非阻塞send在无法立即完成时能真正不阻塞（加锁操作可能阻塞）。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">return</span> <span class="kc">false</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">var</span> <span class="nx">t0</span> <span class="kt">int64</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">blockprofilerate</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">t0</span> <span class="p">=</span> <span class="nf">cputicks</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 2) 尝试获取 runtime.mutex 互斥锁
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 对hchan加锁，如果closed不为0，即通道已经关闭，则先解锁，然后panic。因为不允许用已关闭的通道进行send。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">c</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 3) 向已关闭的chan 发送数据直接panic
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 这里存在获取runtime.mutex期间其他协程已经把c关闭的情况，这里会直接panic
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 因此chan的关闭是要确保所有的send操作已完成后再进行
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nx">c</span><span class="p">.</span><span class="nx">closed</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">c</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="nb">panic</span><span class="p">(</span><span class="nf">plainError</span><span class="p">(</span><span class="s">&#34;send on closed channel&#34;</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 4) 从 recvq 中去找出一个正在等待的 *sudog
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 如果 recvq 不为空，隐含了缓冲区为空，就从中取出第1个排队的协程，将数据传给这个协程，并将该协程置为ready状态
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//（放入run queue，进而得到调度），然后解锁，然后返回true。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nx">sg</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">recvq</span><span class="p">.</span><span class="nf">dequeue</span><span class="p">();</span> <span class="nx">sg</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span> <span class="c1">// 存在等待的 goroutine 直接交换数据即可
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// Found a waiting receiver. We pass the value we want to send
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// directly to the receiver, bypassing the channel buffer (if any).
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 找到了一个等待的接收器。我们将想要直接发送的值传递给接收器，绕过通道缓冲区(如果有的话)。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nf">send</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">sg</span><span class="p">,</span> <span class="nx">ep</span><span class="p">,</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span> <span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">c</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span> <span class="p">},</span> <span class="mi">3</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="kc">true</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 5) 缓冲区还有空间，直接把数据放入即可
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 通过比较 qcount 和 dataqsiz 判断缓存区是否还有剩余空间，在这里无缓冲的通道被视为没有剩余空间。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 如果有剩余空间，将数据追加到缓冲区中，相应地移动 sendx，增加 qcount，然后解锁，返回值为 true。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nx">c</span><span class="p">.</span><span class="nx">qcount</span> <span class="p">&lt;</span> <span class="nx">c</span><span class="p">.</span><span class="nx">dataqsiz</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// Space is available in the channel buffer. Enqueue the element to send.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 通道缓冲区中有可用空间。对要发送的元素进行排队。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">qp</span> <span class="o">:=</span> <span class="nf">chanbuf</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">c</span><span class="p">.</span><span class="nx">sendx</span><span class="p">)</span>           <span class="c1">// 下一个空闲插槽地址
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="nx">raceenabled</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nf">racenotify</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">c</span><span class="p">.</span><span class="nx">sendx</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 把c &lt;- ep这里的ep值复制到qp这个地址中，实现把ep放入buf中
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nf">typedmemmove</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">elemtype</span><span class="p">,</span> <span class="nx">qp</span><span class="p">,</span> <span class="nx">ep</span><span class="p">)</span>    <span class="c1">// 如果元素大小为0不会有任何操作
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">c</span><span class="p">.</span><span class="nx">sendx</span><span class="o">++</span>                           <span class="c1">// 下一次空闲位置
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="nx">c</span><span class="p">.</span><span class="nx">sendx</span> <span class="o">==</span> <span class="nx">c</span><span class="p">.</span><span class="nx">dataqsiz</span> <span class="p">{</span>          <span class="c1">// 到达最大索引
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="nx">c</span><span class="p">.</span><span class="nx">sendx</span> <span class="p">=</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="nx">c</span><span class="p">.</span><span class="nx">qcount</span><span class="o">++</span>                          <span class="c1">// 已存储的数量加一
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">c</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="kc">true</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 6) 如果上面4和5都不满足，并且是在select中，那么就直接返回false，表示当前分支不会选中 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 运行到这里表明通道已满，如果block为false，即不想阻塞，则解锁，返回值为false。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">!</span><span class="nx">block</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">c</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="kc">false</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c1">// 7) 下面是 c &lt;- x 写操作需要阻塞的情况 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Block on the channel. Some receiver will complete our operation for us.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 在通道上阻塞。有人会替我们完成我们的操作。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">gp</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">()</span> <span class="c1">// goroutine
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 获取一个空闲的 *sudog
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">mysg</span> <span class="o">:=</span> <span class="nf">acquireSudog</span><span class="p">()</span>	
</span></span><span class="line"><span class="cl">    <span class="nx">mysg</span><span class="p">.</span><span class="nx">releasetime</span> <span class="p">=</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">t0</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">mysg</span><span class="p">.</span><span class="nx">releasetime</span> <span class="p">=</span> <span class="o">-</span><span class="mi">1</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// No stack splits between assigning elem and enqueuing mysg
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// on gp.waiting where copystack can find it.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 在分配elem和在gp上排队mysg之间没有堆栈分裂。在拷贝堆能找到的地方等待。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">mysg</span><span class="p">.</span><span class="nx">elem</span> <span class="p">=</span> <span class="nx">ep</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// waitlink 只在 semapher 或 select 语句中被使用到。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 用来链接多个 sudog
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">mysg</span><span class="p">.</span><span class="nx">waitlink</span> <span class="p">=</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl">    <span class="nx">mysg</span><span class="p">.</span><span class="nx">g</span> <span class="p">=</span> <span class="nx">gp</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 标记当前 sudog 不是来自select语句
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">mysg</span><span class="p">.</span><span class="nx">isSelect</span> <span class="p">=</span> <span class="kc">false</span>
</span></span><span class="line"><span class="cl">    <span class="nx">mysg</span><span class="p">.</span><span class="nx">c</span> <span class="p">=</span> <span class="nx">c</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 标记goroutine正在*sudog这中等待（一个有效的elem ptr）; in lock order
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">gp</span><span class="p">.</span><span class="nx">waiting</span> <span class="p">=</span> <span class="nx">mysg</span>
</span></span><span class="line"><span class="cl">    <span class="nx">gp</span><span class="p">.</span><span class="nx">param</span> <span class="p">=</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 放入 sendq queue 中等待
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">c</span><span class="p">.</span><span class="nx">sendq</span><span class="p">.</span><span class="nf">enqueue</span><span class="p">(</span><span class="nx">mysg</span><span class="p">)</span>	
</span></span><span class="line"><span class="cl">    <span class="c1">// Signal to anyone trying to shrink our stack that we&#39;re about
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// to park on a channel. The window between when this G&#39;s status
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// changes and when we set gp.activeStackChans is not safe for
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// stack shrinking.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 向任何试图缩小堆栈的人发出信号，我们即将停在一个channel上。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 当G的状态改变和我们设置gp之间的窗口。activeStackChans 对堆栈收缩不安全。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// goroutine.parkingOnChan表示该goroutine即将停在一个chansend或chanrecv上。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 用于指示堆栈收缩的不安全点。它是一个布尔值，但会自动更新。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">atomic</span><span class="p">.</span><span class="nf">Store8</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">gp</span><span class="p">.</span><span class="nx">parkingOnChan</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="c1">// 表示这段时间chan正在parking中
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// gopark—&gt;mcall-&gt;park_m-&gt;schedule()
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">gopark</span><span class="p">(</span><span class="nx">chanparkcommit</span><span class="p">,</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">c</span><span class="p">.</span><span class="nx">lock</span><span class="p">),</span> <span class="nx">waitReasonChanSend</span><span class="p">,</span> <span class="nx">traceEvGoBlockSend</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>	<span class="c1">// 调离当前g进入调度循环
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    
</span></span><span class="line"><span class="cl">    <span class="c1">// 当前g被再次调度起来时，继续这里执行
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    
</span></span><span class="line"><span class="cl">    <span class="c1">// Ensure the value being sent is kept alive until the
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// receiver copies it out. The sudog has a pointer to the
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// stack object, but sudogs aren&#39;t considered as roots of the
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// stack tracer.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 确保正在发送的值在接收方复制出来之前都是有效的。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// sudog有一个指向栈对象的指针，但sudogs不被认为是栈跟踪器的roots。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// https://zhuanlan.zhihu.com/p/213744309
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">KeepAlive</span><span class="p">(</span><span class="nx">ep</span><span class="p">)</span> <span class="c1">// 保持ep是活跃的，因为ep来自用户端可能ep会被回收
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="c1">// someone woke us up.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 有人把我们叫醒了，可能是正常 &lt;-c 或者 close() 函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nx">mysg</span> <span class="o">!=</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">waiting</span> <span class="p">{</span>	<span class="c1">// 当前 gp 是否等待在 mysq 上
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nf">throw</span><span class="p">(</span><span class="s">&#34;G waiting list is corrupted&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nx">gp</span><span class="p">.</span><span class="nx">waiting</span> <span class="p">=</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// activeStackChans表示有未锁定的通道指向这个goroutine的堆栈。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 如果为true，堆栈复制需要获得通道锁来保护堆栈的这些区域。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// activeStackChans 字段在 gopark 中 chanparkcommit 函数中被设置为true，因此是go被调离CPU时候设置为true，在唤醒后设置为false。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 具体参看栈 runtime.copystack 函数。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">gp</span><span class="p">.</span><span class="nx">activeStackChans</span> <span class="p">=</span> <span class="kc">false</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 来自close()函数唤醒时，closed为true。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">closed</span> <span class="o">:=</span> <span class="p">!</span><span class="nx">mysg</span><span class="p">.</span><span class="nx">success</span> <span class="c1">// 如果是有close唤醒的这里success为false并closed为1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">gp</span><span class="p">.</span><span class="nx">param</span> <span class="p">=</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">mysg</span><span class="p">.</span><span class="nx">releasetime</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">blockevent</span><span class="p">(</span><span class="nx">mysg</span><span class="p">.</span><span class="nx">releasetime</span><span class="o">-</span><span class="nx">t0</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nx">mysg</span><span class="p">.</span><span class="nx">c</span> <span class="p">=</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl">    <span class="nf">releaseSudog</span><span class="p">(</span><span class="nx">mysg</span><span class="p">)</span>	<span class="c1">// 回收*sudog
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 这里也解释了关闭channel需要谨慎操作。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 一个goroutine正在send，而另外一个goroutine却close了，这里就会panic。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nx">closed</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 来自close()函数唤醒时closed字段应该为1。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="nx">c</span><span class="p">.</span><span class="nx">closed</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nf">throw</span><span class="p">(</span><span class="s">&#34;chansend: spurious wakeup&#34;</span><span class="p">)</span> <span class="c1">// chansend 虚假唤醒
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// c.closed == 1时，还存在send的g却关闭了chan报错
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 因此 close() 函数不要在还有send未完成时调用。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nb">panic</span><span class="p">(</span><span class="nf">plainError</span><span class="p">(</span><span class="s">&#34;send on closed channel&#34;</span><span class="p">))</span> <span class="c1">// send 在关闭的 channel 上
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="kc">true</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="full">full()<a hidden class="anchor" aria-hidden="true" href="#full">#</a></h3>
<ol>
<li>full() 报告在 c 上的发送是否会阻塞(即通道已满)。</li>
<li>它使用了一个可变状态的word-sized的读取，因此尽管答案立即为true，但在调用函数收到返回值时，正确的答案可能已经改变了。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// full reports whether a send on c would block (that is, the channel is full).
</span></span></span><span class="line"><span class="cl"><span class="c1">// It uses a single word-sized read of mutable state, so although
</span></span></span><span class="line"><span class="cl"><span class="c1">// the answer is instantaneously true, the correct answer may have changed
</span></span></span><span class="line"><span class="cl"><span class="c1">// by the time the calling function receives the return value.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">full</span><span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">hchan</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// c.dataqsiz is immutable (never written after the channel is created)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// so it is safe to read at any time during channel operation.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// c.dataqsiz是不可变的(在通道创建后永不写入)，因此在通道操作期间的任何时候读取都是安全的。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nx">c</span><span class="p">.</span><span class="nx">dataqsiz</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// Assumes that a pointer read is relaxed-atomic.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 假定指针读取是relaxed-atomic的。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">return</span> <span class="nx">c</span><span class="p">.</span><span class="nx">recvq</span><span class="p">.</span><span class="nx">first</span> <span class="o">==</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Assumes that a uint read is relaxed-atomic.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 假设uint read是relax-atomic。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">return</span> <span class="nx">c</span><span class="p">.</span><span class="nx">qcount</span> <span class="o">==</span> <span class="nx">c</span><span class="p">.</span><span class="nx">dataqsiz</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="send">send()<a hidden class="anchor" aria-hidden="true" href="#send">#</a></h3>
<ol>
<li>交换数据，并调用<code>goready</code>把等待的<code>G</code>放入<code>p</code>中等待调度。</li>
<li>send 处理空通道 c 上的发送操作。</li>
<li>发送端发送的值 ep 被复制到接收端sg。然后，接收者被唤醒，继续它的快乐之路。</li>
<li>通道c必须是空的并被锁定。用unlockf发送解锁c。sg必须已经从c中退出队列。</li>
<li>ep必须是非空值，并且指向堆或调用者的堆栈。</li>
<li>参数：
<ul>
<li><strong><code>c *hchan</code></strong>：hchan 结构体指针。</li>
<li><strong><code>sg *sudog</code></strong>：是等待 ep &lt;- c 的 g。</li>
<li><strong><code>ep unsafe.Pointer</code></strong>：是 c &lt;- ep 的数据地址。</li>
<li><strong><code>unlockf func()</code></strong>：闭包函数解锁 c.lock。</li>
<li><strong><code>skip int</code></strong>：skip 跳过步骤。</li>
</ul>
</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// send processes a send operation on an empty channel c.
</span></span></span><span class="line"><span class="cl"><span class="c1">// The value ep sent by the sender is copied to the receiver sg.
</span></span></span><span class="line"><span class="cl"><span class="c1">// The receiver is then woken up to go on its merry way.
</span></span></span><span class="line"><span class="cl"><span class="c1">// Channel c must be empty and locked.  send unlocks c with unlockf.
</span></span></span><span class="line"><span class="cl"><span class="c1">// sg must already be dequeued from c.
</span></span></span><span class="line"><span class="cl"><span class="c1">// ep must be non-nil and point to the heap or the caller&#39;s stack.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">send</span><span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">hchan</span><span class="p">,</span> <span class="nx">sg</span> <span class="o">*</span><span class="nx">sudog</span><span class="p">,</span> <span class="nx">ep</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">,</span> <span class="nx">unlockf</span> <span class="kd">func</span><span class="p">(),</span> <span class="nx">skip</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">raceenabled</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="nx">c</span><span class="p">.</span><span class="nx">dataqsiz</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nf">racesync</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">sg</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// Pretend we go through the buffer, even though
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// we copy directly. Note that we need to increment
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// the head/tail locations only when raceenabled.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="nf">racenotify</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">c</span><span class="p">.</span><span class="nx">recvx</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="nf">racenotify</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">c</span><span class="p">.</span><span class="nx">recvx</span><span class="p">,</span> <span class="nx">sg</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="nx">c</span><span class="p">.</span><span class="nx">recvx</span><span class="o">++</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="nx">c</span><span class="p">.</span><span class="nx">recvx</span> <span class="o">==</span> <span class="nx">c</span><span class="p">.</span><span class="nx">dataqsiz</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="nx">c</span><span class="p">.</span><span class="nx">recvx</span> <span class="p">=</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="nx">c</span><span class="p">.</span><span class="nx">sendx</span> <span class="p">=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">recvx</span> <span class="c1">// c.sendx = (c.sendx+1) % c.dataqsiz
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// sg.elem 是等待读的地址，也就是ep &lt;- c这里的ep地址 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nx">sg</span><span class="p">.</span><span class="nx">elem</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 把ep复制到sg.elem中，这样就完成了chan的数据交换
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nf">sendDirect</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">elemtype</span><span class="p">,</span> <span class="nx">sg</span><span class="p">,</span> <span class="nx">ep</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="nx">sg</span><span class="p">.</span><span class="nx">elem</span> <span class="p">=</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nx">gp</span> <span class="o">:=</span> <span class="nx">sg</span><span class="p">.</span><span class="nx">g</span>  <span class="c1">// 取出准备恢复的g
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 把 hchan 解锁。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">unlockf</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 唤醒时传递的参数。主要用与 select 语句唤醒后使用。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// select 拿着这个参数的值做比对，是哪个 case 就绪了。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">gp</span><span class="p">.</span><span class="nx">param</span> <span class="p">=</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">sg</span><span class="p">)</span> <span class="c1">// g.param = *sudog
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 把sg.success标记为true表示数据已经交换成功
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">sg</span><span class="p">.</span><span class="nx">success</span> <span class="p">=</span> <span class="kc">true</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">sg</span><span class="p">.</span><span class="nx">releasetime</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">sg</span><span class="p">.</span><span class="nx">releasetime</span> <span class="p">=</span> <span class="nf">cputicks</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nf">goready</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="nx">skip</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="senddirect">sendDirect()<a hidden class="anchor" aria-hidden="true" href="#senddirect">#</a></h4>
<ol>
<li>从 src -&gt; sg.elem。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">sendDirect</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">_type</span><span class="p">,</span> <span class="nx">sg</span> <span class="o">*</span><span class="nx">sudog</span><span class="p">,</span> <span class="nx">src</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// src is on our stack, dst is a slot on another stack.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// src在我们的堆栈上，dst是另一个堆栈上的插槽。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Once we read sg.elem out of sg, it will no longer
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// be updated if the destination&#39;s stack gets copied (shrunk).
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// So make sure that no preemption points can happen between read &amp; use.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 一旦我们从sg中读入sg.elem，如果目标堆栈被复制(收缩)，它将不再被更新。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 因此，请确保在读取和使用之间不会发生抢占点。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">dst</span> <span class="o">:=</span> <span class="nx">sg</span><span class="p">.</span><span class="nx">elem</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// typeBitsBulkBarrier对memmove使用类型位图定位指针槽将[src, src+size)复制到[dst, dst+size)的每个指针执行写屏障。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 类型typ必须精确对应于[src, src+size)和[dst, dst+size)。dst、src和size必须是指针对齐的。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">typeBitsBulkBarrier</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">dst</span><span class="p">),</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">src</span><span class="p">),</span> <span class="nx">t</span><span class="p">.</span><span class="nx">size</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// No need for cgo write barrier checks because dst is always
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// Go memory.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 不需要cgo写屏障检查，因为dst总是Go内存。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">memmove</span><span class="p">(</span><span class="nx">dst</span><span class="p">,</span> <span class="nx">src</span><span class="p">,</span> <span class="nx">t</span><span class="p">.</span><span class="nx">size</span><span class="p">)</span>	<span class="c1">// src -&gt; dst
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="goready">goready()<a hidden class="anchor" aria-hidden="true" href="#goready">#</a></h4>
<ol>
<li>恢复<code>gp</code>也就是<code>goroutine</code>前进行栈切换到<code>g0</code>栈。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">goready</span><span class="p">(</span><span class="nx">gp</span> <span class="o">*</span><span class="nx">g</span><span class="p">,</span> <span class="nx">traceskip</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nf">systemstack</span><span class="p">(</span><span class="kd">func</span><span class="p">()</span> <span class="p">{</span>	<span class="c1">// 切换到g0栈
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nf">ready</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="nx">traceskip</span><span class="p">,</span> <span class="kc">true</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">})</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="ready">ready()<a hidden class="anchor" aria-hidden="true" href="#ready">#</a></h4>
<ol>
<li>恢复<code>gp</code>也就是这个<code>goroutine</code>相关的状态，然后放入<code>P</code>中等待被调度。</li>
<li>标记 gp 准备运行。</li>
<li>参数：
<ul>
<li><strong><code>gp *g</code></strong>：当前需要恢复的goroutine</li>
<li><strong><code>traceskip int</code></strong>：检查跳过步骤</li>
<li><strong><code>next bool</code></strong>：<code>next</code>为<code>true</code>时，则将<code>gp</code>放入到<code>_p_.runnext</code>中</li>
</ul>
</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// Mark gp ready to run.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">ready</span><span class="p">(</span><span class="nx">gp</span> <span class="o">*</span><span class="nx">g</span><span class="p">,</span> <span class="nx">traceskip</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">next</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">trace</span><span class="p">.</span><span class="nx">enabled</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">traceGoUnpark</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="nx">traceskip</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 获取当前gp这个goroutine的状态
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">status</span> <span class="o">:=</span> <span class="nf">readgstatus</span><span class="p">(</span><span class="nx">gp</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// Mark runnable.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">_g_</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">()</span>    <span class="c1">// 当前正在运行的g这里是g0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 禁用抢占，因为它可以在本地变量中持有p
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">mp</span> <span class="o">:=</span> <span class="nf">acquirem</span><span class="p">()</span> <span class="c1">// disable preemption because it can be holding p in a local var
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nx">status</span><span class="o">&amp;^</span><span class="nx">_Gscan</span> <span class="o">!=</span> <span class="nx">_Gwaiting</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">dumpgstatus</span><span class="p">(</span><span class="nx">gp</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="nf">throw</span><span class="p">(</span><span class="s">&#34;bad g-&gt;status in ready&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// status is Gwaiting or Gscanwaiting, make Grunnable and put on runq
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">casgstatus</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="nx">_Gwaiting</span><span class="p">,</span> <span class="nx">_Grunnable</span><span class="p">)</span> <span class="c1">// 切换gp的状态
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// gp放入p的本地队列，这里next是true时，会放入next字段会优先调度起来
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">runqput</span><span class="p">(</span><span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">p</span><span class="p">.</span><span class="nf">ptr</span><span class="p">(),</span> <span class="nx">gp</span><span class="p">,</span> <span class="nx">next</span><span class="p">)</span> 
</span></span><span class="line"><span class="cl">    <span class="c1">// 因为有goroutine放入队列中，尝试唤醒其他工作线程起来工作
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">wakep</span><span class="p">()</span> <span class="c1">// 有goroutine被放回队列该函数就会紧接着被调用
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">releasem</span><span class="p">(</span><span class="nx">mp</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="chanbuf">chanbuf()<a hidden class="anchor" aria-hidden="true" href="#chanbuf">#</a></h3>
<ol>
<li>chanbuf(c, i) 是指向缓冲区第 i 个槽的指针。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// chanbuf(c, i) is pointer to the i&#39;th slot in the buffer.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">chanbuf</span><span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">hchan</span><span class="p">,</span> <span class="nx">i</span> <span class="kt">uint</span><span class="p">)</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nf">add</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">buf</span><span class="p">,</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span><span class="o">*</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">elemsize</span><span class="p">))</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="ep---c">ep &lt;- c<a hidden class="anchor" aria-hidden="true" href="#ep---c">#</a></h2>
<ol>
<li>从 c 中读取数据。</li>
<li>编译后代码中 <strong>&lt;- c</strong> 的入口点。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1">// ep &lt;- c
</span></span></span><span class="line"><span class="cl"><span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1">// as  
</span></span></span><span class="line"><span class="cl"><span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1">// chanrecv1(c, &amp;ep)
</span></span></span><span class="line"><span class="cl"><span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// entry points for &lt;- c from compiled code
</span></span></span><span class="line"><span class="cl"><span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1">//go:nosplit
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">chanrecv1</span><span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">hchan</span><span class="p">,</span> <span class="nx">elem</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nf">chanrecv</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">elem</span><span class="p">,</span> <span class="kc">true</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="chanrecv">chanrecv()<a hidden class="anchor" aria-hidden="true" href="#chanrecv">#</a></h3>
<ol>
<li>chanrecv 在通道 c 接收数据，并将接收到的数据写入 ep。</li>
<li>ep可以是nil，在这种情况下接收到的数据将被忽略。</li>
<li>如果block == false且没有元素可用，则返回(false, false)。否则，如果c是关闭的，则<code>*ep</code>设置成零值并返回(true, false)。否则，用一个元素填充<code>*ep</code>并返回(true, true)。</li>
<li>非nil的ep必须指向堆或调用者的堆栈。</li>
<li>参数：
<ul>
<li><strong><code>c *hchan</code></strong>：hchan结构体指针，也就是 <code>ep &lt;- c</code> 中 c 的结构体指针。指向要从recv数据的channel。</li>
<li><strong><code>ep unsafe.Pointer</code></strong>：接收变量地址，也就是 <code>ep &lt;- c</code> 中ep变量的地址。是一个指针，指向用来接收数据的内存，数据类型要和c的元素类型一致。</li>
<li><strong><code>block bool</code></strong>：true.表示如果recv操作不能立即完成，是否想要阻塞等待。true.不能立即完成则阻塞，false.不能立即完成不阻塞，用于select{case: default:}形式。</li>
</ul>
</li>
<li>返回值：这两个参数都是用于 select{case: default:}形式的。selected表示当前case被选中。received表示数据有没交换成功。
<ul>
<li><strong><code>selected bool</code></strong>：true.表示操作完成（可能因为通道已经关闭）。false.表示目前不能立即完成recv，但因为不想阻塞（block为false）而返回。</li>
<li><strong><code>received bool</code></strong>：true.表示数据确实是从通道中接收的，不是因为通道关闭而得到的零值。false.可能是因为通道关闭而得到的零值（selected为true），或者因为不想阻塞而返回（selected为false）。</li>
</ul>
</li>
<li>返回值的组成：
<ol>
<li><strong>(true, true)</strong>：操作已完成，确实是从channel中接收的（不是因为channel关闭而得到的零值）。（当前分支被选中，数据也交换成功了）</li>
<li><strong>(false, false)</strong>：目前不能立即完成，因为不想阻塞而返回。（当前分支没被选中，走default吧）</li>
<li><strong>(true, false)</strong>：操作已完成，因为通道关闭而返回零值。（当前分支被选中，因close而返回默认零值）</li>
</ol>
</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span><span class="lnt">113
</span><span class="lnt">114
</span><span class="lnt">115
</span><span class="lnt">116
</span><span class="lnt">117
</span><span class="lnt">118
</span><span class="lnt">119
</span><span class="lnt">120
</span><span class="lnt">121
</span><span class="lnt">122
</span><span class="lnt">123
</span><span class="lnt">124
</span><span class="lnt">125
</span><span class="lnt">126
</span><span class="lnt">127
</span><span class="lnt">128
</span><span class="lnt">129
</span><span class="lnt">130
</span><span class="lnt">131
</span><span class="lnt">132
</span><span class="lnt">133
</span><span class="lnt">134
</span><span class="lnt">135
</span><span class="lnt">136
</span><span class="lnt">137
</span><span class="lnt">138
</span><span class="lnt">139
</span><span class="lnt">140
</span><span class="lnt">141
</span><span class="lnt">142
</span><span class="lnt">143
</span><span class="lnt">144
</span><span class="lnt">145
</span><span class="lnt">146
</span><span class="lnt">147
</span><span class="lnt">148
</span><span class="lnt">149
</span><span class="lnt">150
</span><span class="lnt">151
</span><span class="lnt">152
</span><span class="lnt">153
</span><span class="lnt">154
</span><span class="lnt">155
</span><span class="lnt">156
</span><span class="lnt">157
</span><span class="lnt">158
</span><span class="lnt">159
</span><span class="lnt">160
</span><span class="lnt">161
</span><span class="lnt">162
</span><span class="lnt">163
</span><span class="lnt">164
</span><span class="lnt">165
</span><span class="lnt">166
</span><span class="lnt">167
</span><span class="lnt">168
</span><span class="lnt">169
</span><span class="lnt">170
</span><span class="lnt">171
</span><span class="lnt">172
</span><span class="lnt">173
</span><span class="lnt">174
</span><span class="lnt">175
</span><span class="lnt">176
</span><span class="lnt">177
</span><span class="lnt">178
</span><span class="lnt">179
</span><span class="lnt">180
</span><span class="lnt">181
</span><span class="lnt">182
</span><span class="lnt">183
</span><span class="lnt">184
</span><span class="lnt">185
</span><span class="lnt">186
</span><span class="lnt">187
</span><span class="lnt">188
</span><span class="lnt">189
</span><span class="lnt">190
</span><span class="lnt">191
</span><span class="lnt">192
</span><span class="lnt">193
</span><span class="lnt">194
</span><span class="lnt">195
</span><span class="lnt">196
</span><span class="lnt">197
</span><span class="lnt">198
</span><span class="lnt">199
</span><span class="lnt">200
</span><span class="lnt">201
</span><span class="lnt">202
</span><span class="lnt">203
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// chanrecv receives on channel c and writes the received data to ep.
</span></span></span><span class="line"><span class="cl"><span class="c1">// ep may be nil, in which case received data is ignored.
</span></span></span><span class="line"><span class="cl"><span class="c1">// If block == false and no elements are available, returns (false, false).
</span></span></span><span class="line"><span class="cl"><span class="c1">// Otherwise, if c is closed, zeros *ep and returns (true, false).
</span></span></span><span class="line"><span class="cl"><span class="c1">// Otherwise, fills in *ep with an element and returns (true, true).
</span></span></span><span class="line"><span class="cl"><span class="c1">// A non-nil ep must point to the heap or the caller&#39;s stack.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">chanrecv</span><span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">hchan</span><span class="p">,</span> <span class="nx">ep</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">,</span> <span class="nx">block</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">(</span><span class="nx">selected</span><span class="p">,</span> <span class="nx">received</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// raceenabled: don&#39;t need to check ep, as it is always on the stack
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// or is new memory allocated by reflect.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// Raceenabled:不需要检查ep，因为它总是在堆栈上或由reflect分配新的内存。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">debugChan</span> <span class="p">{</span>  <span class="c1">// debug
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nb">print</span><span class="p">(</span><span class="s">&#34;chanrecv: chan=&#34;</span><span class="p">,</span> <span class="nx">c</span><span class="p">,</span> <span class="s">&#34;\n&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 1) chan未初始化时，比如 var c chan int
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nx">c</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">!</span><span class="nx">block</span> <span class="p">{</span> <span class="c1">// 来自select{case: default:}块
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="k">return</span>  <span class="c1">// false, false
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">        <span class="c1">// &lt;- nil
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        
</span></span><span class="line"><span class="cl">        <span class="c1">// 这里在nil的chan中读取数据，直接切换到调度循环进行新一轮调度
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 这个G后面的代码将不会得到执行，应该当前G既没有加入到P中等待调度，也没有在chan中，永久丢失了
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nf">gopark</span><span class="p">(</span><span class="kc">nil</span><span class="p">,</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">waitReasonChanReceiveNilChan</span><span class="p">,</span> <span class="nx">traceEvGoStop</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="nf">throw</span><span class="p">(</span><span class="s">&#34;unreachable&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 2) Fast path：在未加锁下，判断block为false时，send为空时。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    
</span></span><span class="line"><span class="cl">    <span class="c1">// Fast path: check for failed non-blocking operation without acquiring the lock.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// Fast path: 检查未获得锁的失败的非阻塞操作。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">!</span><span class="nx">block</span> <span class="o">&amp;&amp;</span> <span class="nf">empty</span><span class="p">(</span><span class="nx">c</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// select{case: default:}块，c为空
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// After observing that the channel is not ready for receiving, we observe whether the
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// channel is closed.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// Reordering of these checks could lead to incorrect behavior when racing with a close.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// For example, if the channel was open and not empty, was closed, and then drained,
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// reordered reads could incorrectly indicate &#34;open and empty&#34;. To prevent reordering,
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// we use atomic loads for both checks, and rely on emptying and closing to happen in
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// separate critical sections under the same lock.  This assumption fails when closing
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// an unbuffered channel with a blocked send, but that is an error condition anyway.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 在观察到通道还没有准备好接收之后，我们观察通道是否关闭。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 在与close竞争时，这些检查的重新排序可能会导致错误的行为。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 例如，如果channel是打开的且不是空的，被关闭，然后全部取出，重新排序的读数可能会错误地指示&#34;open and empty&#34;。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 为了防止重新排序，我们对这两种检查都使用了原子加载，并依赖于在同一锁下的不同临界区中进行清空和关闭操作。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 当以阻塞的发送方式关闭无缓冲的通道时，这个假设就失败了，但无论如何这都是一个错误条件。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Load</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">c</span><span class="p">.</span><span class="nx">closed</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span> <span class="c1">// send为空 并 closed 未关闭，返回 (false, false)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// Because a channel cannot be reopened, the later observation of the channel
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// being not closed implies that it was also not closed at the moment of the
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// first observation. We behave as if we observed the channel at that moment
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// and report that the receive cannot proceed.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// 因为channel不能重新打开，所以后来观察到的channel没有关闭意味着在第一次观察的时候它也没有关闭。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// 我们的行为就像我们当时观察到了channel，并报告说接收无法继续。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="k">return</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// The channel is irreversibly closed. Re-check whether the channel has any pending data
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// to receive, which could have arrived between the empty and closed checks above.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// Sequential consistency is also required here, when racing with such a send.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// channel是不可逆关闭的。重新检查信道是否有待处理的数据要接收，这些数据可能是在上面的空检查和关闭检查之间到达的。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 当使用这样的发送方式比赛时，顺序的一致性也是必需的。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="nf">empty</span><span class="p">(</span><span class="nx">c</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// send为空 并且 closed 已关闭，返回 (true, false)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// The channel is irreversibly closed and empty.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="k">if</span> <span class="nx">raceenabled</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="nf">raceacquire</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nf">raceaddr</span><span class="p">())</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="nx">ep</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="nf">typedmemclr</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">elemtype</span><span class="p">,</span> <span class="nx">ep</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="kc">true</span><span class="p">,</span> <span class="kc">false</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">var</span> <span class="nx">t0</span> <span class="kt">int64</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">blockprofilerate</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">t0</span> <span class="p">=</span> <span class="nf">cputicks</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 3) 加锁情况下去判断 send 和 sendq 是否有等待 send 的数据。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    
</span></span><span class="line"><span class="cl">    <span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">c</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span> <span class="c1">// 获取runtime.mutex
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="c1">// channel 已关闭
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nx">c</span><span class="p">.</span><span class="nx">closed</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>	
</span></span><span class="line"><span class="cl">        <span class="c1">// send buf缓冲区没数据
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="nx">c</span><span class="p">.</span><span class="nx">qcount</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>	
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="nx">raceenabled</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="nf">raceacquire</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nf">raceaddr</span><span class="p">())</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">c</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 拷贝对应类型的零值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="k">if</span> <span class="nx">ep</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="c1">// Typedmemclr清除类型为typ的ptr的类型化内存。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="nf">typedmemclr</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">elemtype</span><span class="p">,</span> <span class="nx">ep</span><span class="p">)</span> <span class="c1">// ep 赋值chan元素类型的默认值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="kc">true</span><span class="p">,</span> <span class="kc">false</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// The channel has been closed, but the channel&#39;s buffer have data.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// channel 已经关闭，但通道的缓冲区有数据。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span> <span class="c1">// channel 未关闭
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// Just found waiting sender with not closed.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 刚刚发现等待send未关闭。取出first上的第一个*sudog，这个需要处理
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 这里隐含了 buf 缓存区为空的情况。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="nx">sg</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">sendq</span><span class="p">.</span><span class="nf">dequeue</span><span class="p">();</span> <span class="nx">sg</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// Found a waiting sender. If buffer is size 0, receive value
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// directly from sender. Otherwise, receive from head of queue
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// and add sender&#39;s value to the tail of the queue (both map to
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// the same buffer slot because the queue is full).
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// 发现一个等待发送者。如果缓冲区大小是0，接收值直接从发送方。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// 否则，从队列的头部接收并将发送方的值添加到队列的尾部(两者映射到相同的缓冲槽，因为队列已满)。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="nf">recv</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">sg</span><span class="p">,</span> <span class="nx">ep</span><span class="p">,</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span> <span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">c</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span> <span class="p">},</span> <span class="mi">3</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="kc">true</span><span class="p">,</span> <span class="kc">true</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// buf 缓冲区有数据
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nx">c</span><span class="p">.</span><span class="nx">qcount</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// Receive directly from queue
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 直接从缓存区队列中接收数据
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">qp</span> <span class="o">:=</span> <span class="nf">chanbuf</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">c</span><span class="p">.</span><span class="nx">recvx</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="nx">raceenabled</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nf">racenotify</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">c</span><span class="p">.</span><span class="nx">recvx</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 交换数据
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="nx">ep</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nf">typedmemmove</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">elemtype</span><span class="p">,</span> <span class="nx">ep</span><span class="p">,</span> <span class="nx">qp</span><span class="p">)</span> <span class="c1">// ep = qp
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="nf">typedmemclr</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">elemtype</span><span class="p">,</span> <span class="nx">qp</span><span class="p">)</span>          <span class="c1">// 清除 qp
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">c</span><span class="p">.</span><span class="nx">recvx</span><span class="o">++</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="nx">c</span><span class="p">.</span><span class="nx">recvx</span> <span class="o">==</span> <span class="nx">c</span><span class="p">.</span><span class="nx">dataqsiz</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nx">c</span><span class="p">.</span><span class="nx">recvx</span> <span class="p">=</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="nx">c</span><span class="p">.</span><span class="nx">qcount</span><span class="o">--</span>                           <span class="c1">// 缓存区元素个数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">c</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="kc">true</span><span class="p">,</span> <span class="kc">true</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 下面代码是需要被阻塞的情况，当前goroutine被动执行调度到c.sendq中去等待
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    
</span></span><span class="line"><span class="cl">    <span class="c1">// block 为 false，不想阻塞而返回。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">!</span><span class="nx">block</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">c</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="kc">false</span><span class="p">,</span> <span class="kc">false</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 4) send buf取没有数据或sendq中没有等待的goroutine时。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    
</span></span><span class="line"><span class="cl">    <span class="c1">// no sender available: block on this channel.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 没有可用的发送者:在此通道上阻塞。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">gp</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">()</span>            <span class="c1">// g
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">mysg</span> <span class="o">:=</span> <span class="nf">acquireSudog</span><span class="p">()</span>  <span class="c1">// 获取一个空闲的 *sudog
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">mysg</span><span class="p">.</span><span class="nx">releasetime</span> <span class="p">=</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">t0</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">mysg</span><span class="p">.</span><span class="nx">releasetime</span> <span class="p">=</span> <span class="o">-</span><span class="mi">1</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// No stack splits between assigning elem and enqueuing mysg
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// on gp.waiting where copystack can find it.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 在分配elem和在gp.waiting上对mysg进行排队之间没有栈拆分，因为在gp.waiting上copystack可以找到它。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">mysg</span><span class="p">.</span><span class="nx">elem</span> <span class="p">=</span> <span class="nx">ep</span>
</span></span><span class="line"><span class="cl">    <span class="nx">mysg</span><span class="p">.</span><span class="nx">waitlink</span> <span class="p">=</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl">    <span class="nx">gp</span><span class="p">.</span><span class="nx">waiting</span> <span class="p">=</span> <span class="nx">mysg</span>
</span></span><span class="line"><span class="cl">    <span class="nx">mysg</span><span class="p">.</span><span class="nx">g</span> <span class="p">=</span> <span class="nx">gp</span>
</span></span><span class="line"><span class="cl">    <span class="nx">mysg</span><span class="p">.</span><span class="nx">isSelect</span> <span class="p">=</span> <span class="kc">false</span>   <span class="c1">// 标记不是在select块中来的
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">mysg</span><span class="p">.</span><span class="nx">c</span> <span class="p">=</span> <span class="nx">c</span>
</span></span><span class="line"><span class="cl">    <span class="nx">gp</span><span class="p">.</span><span class="nx">param</span> <span class="p">=</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl">    <span class="nx">c</span><span class="p">.</span><span class="nx">recvq</span><span class="p">.</span><span class="nf">enqueue</span><span class="p">(</span><span class="nx">mysg</span><span class="p">)</span>   <span class="c1">// 加入 recvq 队列中
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// Signal to anyone trying to shrink our stack that we&#39;re about
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// to park on a channel. The window between when this G&#39;s status
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// changes and when we set gp.activeStackChans is not safe for
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// stack shrinking.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 向任何试图缩小堆栈的人发出信号，我们即将停在一个channel上。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 当G的状态改变和我们设置gp之间的窗口。activeStackChans 对堆栈收缩不安全。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// goroutine.parkingOnChan表示该goroutine即将停在一个chansend或chanrecv上。用于指示堆栈收缩的不安全点。它是一个布尔值，但会自动更新。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">atomic</span><span class="p">.</span><span class="nf">Store8</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">gp</span><span class="p">.</span><span class="nx">parkingOnChan</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// gopark 保存当前goroutine线程; 调用 releasem(mp) 解除当前m和P的绑定
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 调用mcall(park_m) mcall切换栈到g0 park_m 解除m和g的关联 调用schedule再次开启调度循环
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">gopark</span><span class="p">(</span><span class="nx">chanparkcommit</span><span class="p">,</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">c</span><span class="p">.</span><span class="nx">lock</span><span class="p">),</span> <span class="nx">waitReasonChanReceive</span><span class="p">,</span> <span class="nx">traceEvGoBlockRecv</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// someone woke us up
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nx">mysg</span> <span class="o">!=</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">waiting</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">throw</span><span class="p">(</span><span class="s">&#34;G waiting list is corrupted&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nx">gp</span><span class="p">.</span><span class="nx">waiting</span> <span class="p">=</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl">    <span class="nx">gp</span><span class="p">.</span><span class="nx">activeStackChans</span> <span class="p">=</span> <span class="kc">false</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">mysg</span><span class="p">.</span><span class="nx">releasetime</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">blockevent</span><span class="p">(</span><span class="nx">mysg</span><span class="p">.</span><span class="nx">releasetime</span><span class="o">-</span><span class="nx">t0</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nx">success</span> <span class="o">:=</span> <span class="nx">mysg</span><span class="p">.</span><span class="nx">success</span>
</span></span><span class="line"><span class="cl">    <span class="nx">gp</span><span class="p">.</span><span class="nx">param</span> <span class="p">=</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl">    <span class="nx">mysg</span><span class="p">.</span><span class="nx">c</span> <span class="p">=</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl">    <span class="nf">releaseSudog</span><span class="p">(</span><span class="nx">mysg</span><span class="p">)</span> <span class="c1">// 回收 sudog
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">return</span> <span class="kc">true</span><span class="p">,</span> <span class="nx">success</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="empty">empty()<a hidden class="anchor" aria-hidden="true" href="#empty">#</a></h3>
<ol>
<li>Empty报告从c读取数据是否会阻塞(即channel是空的)。它使用单个原子读取可变状态。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// empty reports whether a read from c would block (that is, the channel is
</span></span></span><span class="line"><span class="cl"><span class="c1">// empty).  It uses a single atomic read of mutable state.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">empty</span><span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">hchan</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// c.dataqsiz is immutable.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// c.dataqsiz 是不可变的
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nx">c</span><span class="p">.</span><span class="nx">dataqsiz</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 是否有等待 send 的 goroutine
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">return</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Loadp</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">c</span><span class="p">.</span><span class="nx">sendq</span><span class="p">.</span><span class="nx">first</span><span class="p">))</span> <span class="o">==</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 缓存区是否有数据
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">return</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Loaduint</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">c</span><span class="p">.</span><span class="nx">qcount</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="recv">recv()<a hidden class="anchor" aria-hidden="true" href="#recv">#</a></h3>
<ol>
<li>recv 在一个满的缓存区的channel c上处理接收操作</li>
<li>有以下两部分：
<ol>
<li>发送放sg发送的值被放入channel，发送方被唤醒</li>
<li>接收端接收到的值(当前G)被写入ep</li>
</ol>
</li>
<li>对于同步channel，这两个值是相同的</li>
<li>对于异步channel，接收方从通道缓冲区获取数据，发送方的数据放在通道缓冲区中。</li>
<li>通道c必须已满且已锁定。recv用unlockf解锁c。sg必须已经从c中退出队列。</li>
<li>非nil的ep必须指向堆或调用者的堆栈。</li>
<li>参数：
<ol>
<li><strong><code>c *hchan</code></strong>：当前 chan</li>
<li><strong><code>sg *sudog</code></strong>：从 recvq 中的first取出的第一个 *sudog</li>
<li><strong><code>ep unsafe.Pointer</code></strong>：v &lt;- c 中的v地址</li>
<li><strong><code>unlockf func()</code></strong>：解锁 runtime.mutex 的闭包函数</li>
<li><strong><code>skip int</code></strong>：调试相关</li>
</ol>
</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// recv processes a receive operation on a full channel c.
</span></span></span><span class="line"><span class="cl"><span class="c1">// There are 2 parts:
</span></span></span><span class="line"><span class="cl"><span class="c1">//  1. The value sent by the sender sg is put into the channel
</span></span></span><span class="line"><span class="cl"><span class="c1">//     and the sender is woken up to go on its merry way.
</span></span></span><span class="line"><span class="cl"><span class="c1">//  2. The value received by the receiver (the current G) is
</span></span></span><span class="line"><span class="cl"><span class="c1">//     written to ep.
</span></span></span><span class="line"><span class="cl"><span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1">// For synchronous channels, both values are the same.
</span></span></span><span class="line"><span class="cl"><span class="c1">// For asynchronous channels, the receiver gets its data from
</span></span></span><span class="line"><span class="cl"><span class="c1">// the channel buffer and the sender&#39;s data is put in the
</span></span></span><span class="line"><span class="cl"><span class="c1">// channel buffer.
</span></span></span><span class="line"><span class="cl"><span class="c1">// Channel c must be full and locked. recv unlocks c with unlockf.
</span></span></span><span class="line"><span class="cl"><span class="c1">// sg must already be dequeued from c.
</span></span></span><span class="line"><span class="cl"><span class="c1">// A non-nil ep must point to the heap or the caller&#39;s stack.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">recv</span><span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">hchan</span><span class="p">,</span> <span class="nx">sg</span> <span class="o">*</span><span class="nx">sudog</span><span class="p">,</span> <span class="nx">ep</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">,</span> <span class="nx">unlockf</span> <span class="kd">func</span><span class="p">(),</span> <span class="nx">skip</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">c</span><span class="p">.</span><span class="nx">dataqsiz</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span> <span class="c1">// 无缓冲 chan
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="nx">raceenabled</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nf">racesync</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">sg</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="nx">ep</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// copy data from sender
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// 从发送方复制数据
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="nf">recvDirect</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">elemtype</span><span class="p">,</span> <span class="nx">sg</span><span class="p">,</span> <span class="nx">ep</span><span class="p">)</span> <span class="c1">// ep = sg
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>            <span class="c1">// 有缓冲 chan
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// Queue is full. Take the item at the
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// head of the queue. Make the sender enqueue
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// its item at the tail of the queue. Since the
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// queue is full, those are both the same slot.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 队列已满。以队列最前面的项为例。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 让发送方在队列的尾部将其项目入队。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 因为队列已经满了，所以它们是同一个槽。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 以上意思是从sendq.first取出的*sudog需要恢复这个g并把数据放入缓存区，从缓存区取出下一个数据交换
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">qp</span> <span class="o">:=</span> <span class="nf">chanbuf</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">c</span><span class="p">.</span><span class="nx">recvx</span><span class="p">)</span> <span class="c1">// 数据区的下一个需要交换的数据
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="nx">raceenabled</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nf">racenotify</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">c</span><span class="p">.</span><span class="nx">recvx</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="nf">racenotify</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">c</span><span class="p">.</span><span class="nx">recvx</span><span class="p">,</span> <span class="nx">sg</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// copy data from queue to receiver
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 将数据从队列复制到接收器
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="nx">ep</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nf">typedmemmove</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">elemtype</span><span class="p">,</span> <span class="nx">ep</span><span class="p">,</span> <span class="nx">qp</span><span class="p">)</span>    <span class="c1">// ep = qp
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// copy data from sender to queue
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 从发送端复制数据到队列
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nf">typedmemmove</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">elemtype</span><span class="p">,</span> <span class="nx">qp</span><span class="p">,</span> <span class="nx">sg</span><span class="p">.</span><span class="nx">elem</span><span class="p">)</span>   <span class="c1">// qp = sg.elem
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">c</span><span class="p">.</span><span class="nx">recvx</span><span class="o">++</span>	<span class="c1">// 下一次recv数据索引
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="nx">c</span><span class="p">.</span><span class="nx">recvx</span> <span class="o">==</span> <span class="nx">c</span><span class="p">.</span><span class="nx">dataqsiz</span> <span class="p">{</span>	<span class="c1">// 如果超过最大重置为0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="nx">c</span><span class="p">.</span><span class="nx">recvx</span> <span class="p">=</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 设置缓存区是满的，因为这种情况缓存区一定是full
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 此时需要调整 sendx 的值，因为之前就是满的 说明之前 c.sendx == c.recvx
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">c</span><span class="p">.</span><span class="nx">sendx</span> <span class="p">=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">recvx</span> <span class="c1">// c.sendx = (c.sendx+1) % c.dataqsiz
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// sg 中的 *sudog 的g需要被恢复让其从新被调度
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">sg</span><span class="p">.</span><span class="nx">elem</span> <span class="p">=</span> <span class="kc">nil</span>   <span class="c1">// 数据已被放入缓存区，情况即可
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">gp</span> <span class="o">:=</span> <span class="nx">sg</span><span class="p">.</span><span class="nx">g</span>      <span class="c1">// 需要恢复的g
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">unlockf</span><span class="p">()</span>       <span class="c1">// runtime.mutex 解锁
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 当一个channel操作唤醒一个被阻塞的goroutine时，它将param设置为指向已完成阻塞操作的sudog。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// select 拿着这个参数的值做比对，是哪个 case 就绪了。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">gp</span><span class="p">.</span><span class="nx">param</span> <span class="p">=</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">sg</span><span class="p">)</span> <span class="c1">// 主要用与 select 语句唤醒后使用。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">sg</span><span class="p">.</span><span class="nx">success</span> <span class="p">=</span> <span class="kc">true</span> <span class="c1">// success 标记了 true，交换数据成功
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nx">sg</span><span class="p">.</span><span class="nx">releasetime</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">sg</span><span class="p">.</span><span class="nx">releasetime</span> <span class="p">=</span> <span class="nf">cputicks</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nf">goready</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="nx">skip</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>	<span class="c1">// 放入队列中等待唤醒g
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="goready-1">goready()<a hidden class="anchor" aria-hidden="true" href="#goready-1">#</a></h4>
<ol>
<li>恢复<code>gp</code>也就是<code>goroutine</code>前进行栈切换到<code>g0栈</code>。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">goready</span><span class="p">(</span><span class="nx">gp</span> <span class="o">*</span><span class="nx">g</span><span class="p">,</span> <span class="nx">traceskip</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nf">systemstack</span><span class="p">(</span><span class="kd">func</span><span class="p">()</span> <span class="p">{</span> <span class="c1">// 切换到 g0 栈
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nf">ready</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="nx">traceskip</span><span class="p">,</span> <span class="kc">true</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">})</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="ready-1">ready()<a hidden class="anchor" aria-hidden="true" href="#ready-1">#</a></h4>
<ol>
<li>标记gp准备运行。</li>
<li>参数：
<ol>
<li><strong>gp *g</strong>：准备恢复的 goroutine</li>
<li><strong>traceskip int</strong>：测试相关</li>
<li><strong>next bool</strong>：true.下次调度优先调度当前goroutine</li>
</ol>
</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// Mark gp ready to run.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">ready</span><span class="p">(</span><span class="nx">gp</span> <span class="o">*</span><span class="nx">g</span><span class="p">,</span> <span class="nx">traceskip</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">next</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">trace</span><span class="p">.</span><span class="nx">enabled</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">traceGoUnpark</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="nx">traceskip</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// goroutine 状态
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">status</span> <span class="o">:=</span> <span class="nf">readgstatus</span><span class="p">(</span><span class="nx">gp</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// Mark runnable.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">_g_</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">()</span>    <span class="c1">// 当前g0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 禁止当前m被抢占，因为即将把gp放入m关联的本地P中去
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">mp</span> <span class="o">:=</span> <span class="nf">acquirem</span><span class="p">()</span> <span class="c1">// disable preemption because it can be holding p in a local var
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 如果当前gp状态处理后不等于_Gwaiting等待中，那说明这个gp是有问题的
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nx">status</span><span class="o">&amp;^</span><span class="nx">_Gscan</span> <span class="o">!=</span> <span class="nx">_Gwaiting</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">dumpgstatus</span><span class="p">(</span><span class="nx">gp</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="nf">throw</span><span class="p">(</span><span class="s">&#34;bad g-&gt;status in ready&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// status is Gwaiting or Gscanwaiting, make Grunnable and put on runq
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 把当前gp这个goroutine状态从_Gwaiting等待中修改为_Grunnable可以运行的状态
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">casgstatus</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="nx">_Gwaiting</span><span class="p">,</span> <span class="nx">_Grunnable</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 然后把gp放入m的本地关联P中，next为true表示放入前面
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">runqput</span><span class="p">(</span><span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">p</span><span class="p">.</span><span class="nf">ptr</span><span class="p">(),</span> <span class="nx">gp</span><span class="p">,</span> <span class="nx">next</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nf">wakep</span><span class="p">()</span>         <span class="c1">// 尝试唤醒其他线程
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">releasem</span><span class="p">(</span><span class="nx">mp</span><span class="p">)</span>    <span class="c1">// 解除前面的 acquirem() 函数的抢占，并判断是否有抢占发生
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="runqput">runqput()<a hidden class="anchor" aria-hidden="true" href="#runqput">#</a></h4>
<ol>
<li>runqput 试图将g放到本地可运行队列上。</li>
<li>如果 next 为 false, runqput 将 g 添加到可运行队列的尾部。</li>
<li>如果 next 为 true, runqput 将 g 放入<code>_p_.runnext</code>位置。</li>
<li>如果就绪队列已满，runnext 将 g 放置到全局队列中。</li>
<li>仅由所有者P执行。</li>
<li>参数：
<ol>
<li><code>_p_ *p</code>：当前工作线程绑定的 P</li>
<li><code>gp *g</code>：需要处理的 goroutine</li>
<li><code>next bool</code>：true.下次调度优先调度当前goroutine</li>
</ol>
</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// runqput tries to put g on the local runnable queue.
</span></span></span><span class="line"><span class="cl"><span class="c1">// If next is false, runqput adds g to the tail of the runnable queue.
</span></span></span><span class="line"><span class="cl"><span class="c1">// If next is true, runqput puts g in the _p_.runnext slot.
</span></span></span><span class="line"><span class="cl"><span class="c1">// If the run queue is full, runnext puts g on the global queue.
</span></span></span><span class="line"><span class="cl"><span class="c1">// Executed only by the owner P.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">runqput</span><span class="p">(</span><span class="nx">_p_</span> <span class="o">*</span><span class="nx">p</span><span class="p">,</span> <span class="nx">gp</span> <span class="o">*</span><span class="nx">g</span><span class="p">,</span> <span class="nx">next</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 这里是为了测试用例增加随机性的代码
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// randomizeScheduler在测试代码中这里会设置为true，正常是false
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nx">randomizeScheduler</span> <span class="o">&amp;&amp;</span> <span class="nx">next</span> <span class="o">&amp;&amp;</span> <span class="nf">fastrandn</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">next</span> <span class="p">=</span> <span class="kc">false</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// next=true，将gp添加到_p_.runnext中。_p_.runnext 如果是非nil，是一个可运行的G
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 如果在运行 G 的时间片中有剩余时间，那么应该运行下一个而不是 runq 中的内容
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nx">next</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">retryNext</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="nx">oldnext</span> <span class="o">:=</span> <span class="nx">_p_</span><span class="p">.</span><span class="nx">runnext</span>  <span class="c1">// 原子交换
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="p">!</span><span class="nx">_p_</span><span class="p">.</span><span class="nx">runnext</span><span class="p">.</span><span class="nf">cas</span><span class="p">(</span><span class="nx">oldnext</span><span class="p">,</span> <span class="nf">guintptr</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">gp</span><span class="p">)))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">goto</span> <span class="nx">retryNext</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="nx">oldnext</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// Kick the old runnext out to the regular run queue.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 把旧的runnext踢到常规的run队列。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">gp</span> <span class="p">=</span> <span class="nx">oldnext</span><span class="p">.</span><span class="nf">ptr</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">retry</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// _p_的runq是一个256大小的循环数组，runqhead指向开始，runqtail指向尾部
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">h</span> <span class="o">:=</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">LoadAcq</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">_p_</span><span class="p">.</span><span class="nx">runqhead</span><span class="p">)</span> <span class="c1">// load-acquire, synchronize with consumers
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">t</span> <span class="o">:=</span> <span class="nx">_p_</span><span class="p">.</span><span class="nx">runqtail</span>   <span class="c1">// 这里之所以没有使用锁，是由于这个runqtail在其他地方不会被修改
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 如果t-h小于总runq的大小，说明还没有存满
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nx">t</span><span class="o">-</span><span class="nx">h</span> <span class="p">&lt;</span> <span class="nb">uint32</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">_p_</span><span class="p">.</span><span class="nx">runq</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 这里使用t%uint32(len(_p_.runq))是由于可能出现h &gt; t的情况，那么需要始终放在t的后面
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">_p_</span><span class="p">.</span><span class="nx">runq</span><span class="p">[</span><span class="nx">t</span><span class="o">%</span><span class="nb">uint32</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">_p_</span><span class="p">.</span><span class="nx">runq</span><span class="p">))].</span><span class="nf">set</span><span class="p">(</span><span class="nx">gp</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="nx">atomic</span><span class="p">.</span><span class="nf">StoreRel</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">_p_</span><span class="p">.</span><span class="nx">runqtail</span><span class="p">,</span> <span class="nx">t</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="c1">// store-release, makes the item available for consumption
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">return</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 如果本地P已经存满，那么需要去全局里面存数据 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nf">runqputslow</span><span class="p">(</span><span class="nx">_p_</span><span class="p">,</span> <span class="nx">gp</span><span class="p">,</span> <span class="nx">h</span><span class="p">,</span> <span class="nx">t</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// the queue is not full, now the put above must succeed
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 如果上面都没有存储成功，那么跳转到retry标签继续存储数据，直到成功
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">goto</span> <span class="nx">retry</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="runqputslow">runqputslow()<a hidden class="anchor" aria-hidden="true" href="#runqputslow">#</a></h4>
<ol>
<li>把<code>gp</code>及<code>_p_</code>中的一半的<code>G</code>尝试加入全局<code>G</code>中去</li>
<li>将g和一批来自本地可运行队列的工作放到全局队列上。</li>
<li>仅由所有者P执行。</li>
<li>参数：
<ol>
<li><code>_p_ *p</code>：当前工作线程绑定的P</li>
<li><code>gp *g</code>：当前需要处理的 goroutine</li>
<li><code>h, t uint32</code>：<code>_p_</code>的runq是一个256大小的循环数组，runqhead指向开始，runqtail指向尾部</li>
</ol>
</li>
<li>返回值：
<ol>
<li><code>bool</code>：true.放入成功，false.放入失败</li>
</ol>
</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// Put g and a batch of work from local runnable queue on global queue.
</span></span></span><span class="line"><span class="cl"><span class="c1">// Executed only by the owner P.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">runqputslow</span><span class="p">(</span><span class="nx">_p_</span> <span class="o">*</span><span class="nx">p</span><span class="p">,</span> <span class="nx">gp</span> <span class="o">*</span><span class="nx">g</span><span class="p">,</span> <span class="nx">h</span><span class="p">,</span> <span class="nx">t</span> <span class="kt">uint32</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 首先定义batch数组，这是需要取出的G放入的数组
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 这里的len(_p_.runq)/2 + 1是把gp放入这个+1这里算在一起的
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kd">var</span> <span class="nx">batch</span> <span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="nx">_p_</span><span class="p">.</span><span class="nx">runq</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="nx">g</span>   <span class="c1">// 临时容器
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="c1">// First, grab a batch from local queue.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 首先，从本地队列中获取一个批。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">n</span> <span class="o">:=</span> <span class="nx">t</span> <span class="o">-</span> <span class="nx">h</span>
</span></span><span class="line"><span class="cl">    <span class="nx">n</span> <span class="p">=</span> <span class="nx">n</span> <span class="o">/</span> <span class="mi">2</span>   <span class="c1">// 取一半
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nx">n</span> <span class="o">!=</span> <span class="nb">uint32</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">_p_</span><span class="p">.</span><span class="nx">runq</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">throw</span><span class="p">(</span><span class="s">&#34;runqputslow: queue is not full&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 取出一半放入容器
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="nb">uint32</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">n</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">batch</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nx">_p_</span><span class="p">.</span><span class="nx">runq</span><span class="p">[(</span><span class="nx">h</span><span class="o">+</span><span class="nx">i</span><span class="p">)</span><span class="o">%</span><span class="nb">uint32</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">_p_</span><span class="p">.</span><span class="nx">runq</span><span class="p">))].</span><span class="nf">ptr</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 原子交换head索引值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">!</span><span class="nx">atomic</span><span class="p">.</span><span class="nf">CasRel</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">_p_</span><span class="p">.</span><span class="nx">runqhead</span><span class="p">,</span> <span class="nx">h</span><span class="p">,</span> <span class="nx">h</span><span class="o">+</span><span class="nx">n</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// cas-release, commits consume
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">return</span> <span class="kc">false</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nx">batch</span><span class="p">[</span><span class="nx">n</span><span class="p">]</span> <span class="p">=</span> <span class="nx">gp</span>   <span class="c1">// gp 放入最后一位
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 这里如果开始起了随机性，那么会把batch顺序打乱
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nx">randomizeScheduler</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="nb">uint32</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span> <span class="nx">i</span> <span class="o">&lt;=</span> <span class="nx">n</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nx">j</span> <span class="o">:=</span> <span class="nf">fastrandn</span><span class="p">(</span><span class="nx">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>   <span class="c1">// fastrand() % (i+1)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="nx">batch</span><span class="p">[</span><span class="nx">i</span><span class="p">],</span> <span class="nx">batch</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span> <span class="p">=</span> <span class="nx">batch</span><span class="p">[</span><span class="nx">j</span><span class="p">],</span> <span class="nx">batch</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// Link the goroutines.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 把batch中的所有G形成一个链表链接起来
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="nb">uint32</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">n</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">batch</span><span class="p">[</span><span class="nx">i</span><span class="p">].</span><span class="nx">schedlink</span><span class="p">.</span><span class="nf">set</span><span class="p">(</span><span class="nx">batch</span><span class="p">[</span><span class="nx">i</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 是一个双向链表，head和tail分别表示正序和倒叙
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kd">var</span> <span class="nx">q</span> <span class="nx">gQueue</span>
</span></span><span class="line"><span class="cl">    <span class="nx">q</span><span class="p">.</span><span class="nx">head</span><span class="p">.</span><span class="nf">set</span><span class="p">(</span><span class="nx">batch</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>    <span class="c1">// 把batch[0]指向q.head
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">q</span><span class="p">.</span><span class="nx">tail</span><span class="p">.</span><span class="nf">set</span><span class="p">(</span><span class="nx">batch</span><span class="p">[</span><span class="nx">n</span><span class="p">])</span>    <span class="c1">// 把batch[n]指向q.tail
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Now put the batch on global queue.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 现在将batch放到全局队列中。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>       <span class="c1">// 获取 sched 上的 runtime.mutex
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 把设置好的G链表链接拿到shced.runq上去
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">globrunqputbatch</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">q</span><span class="p">,</span> <span class="nb">int32</span><span class="p">(</span><span class="nx">n</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">    <span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>     <span class="c1">// 解锁
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">return</span> <span class="kc">true</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="globrunqputbatch">globrunqputbatch()<a hidden class="anchor" aria-hidden="true" href="#globrunqputbatch">#</a></h4>
<ol>
<li>把设置好的<code>G</code>链表链接拿到<code>shced.runq</code>上去</li>
<li>将一批可运行的 goroutines 放到全局可运行队列中。清除 *batch。</li>
<li>sched.lock 必须被持有。.</li>
<li>可能在STW期间运行，因此不允许写入障碍。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// Put a batch of runnable goroutines on the global runnable queue.
</span></span></span><span class="line"><span class="cl"><span class="c1">// This clears *batch.
</span></span></span><span class="line"><span class="cl"><span class="c1">// sched.lock must be held.
</span></span></span><span class="line"><span class="cl"><span class="c1">// May run during STW, so write barriers are not allowed.
</span></span></span><span class="line"><span class="cl"><span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1">//go:nowritebarrierrec
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">globrunqputbatch</span><span class="p">(</span><span class="nx">batch</span> <span class="o">*</span><span class="nx">gQueue</span><span class="p">,</span> <span class="nx">n</span> <span class="kt">int32</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 判断 sched.lock 锁是否持有
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">assertLockHeld</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 把设置好的G链表链接到sched.runq上去
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">sched</span><span class="p">.</span><span class="nx">runq</span><span class="p">.</span><span class="nf">pushBackAll</span><span class="p">(</span><span class="o">*</span><span class="nx">batch</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nx">sched</span><span class="p">.</span><span class="nx">runqsize</span> <span class="o">+=</span> <span class="nx">n</span> <span class="c1">// 把全局链表总数量加上n
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="o">*</span><span class="nx">batch</span> <span class="p">=</span> <span class="nx">gQueue</span><span class="p">{}</span>   <span class="c1">// 清空这个batch，减轻GC压力
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="v-ok---c">v, ok := &lt;-c<a hidden class="anchor" aria-hidden="true" href="#v-ok---c">#</a></h2>
<ol>
<li>编译后是通过调用 chanrecv2 函数。</li>
<li>ok：true.确实从channel中接收的值（不是因为channel关闭而得到的零值）。false.因为channel关闭而返回的零值。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// 通过编译后：
</span></span></span><span class="line"><span class="cl"><span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1">// if v, ok := &lt;-c; ok {
</span></span></span><span class="line"><span class="cl"><span class="c1">//      ... foo
</span></span></span><span class="line"><span class="cl"><span class="c1">// }
</span></span></span><span class="line"><span class="cl"><span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1">// as 
</span></span></span><span class="line"><span class="cl"><span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1">// if _, ok = chanrecv2(c, &amp;v); ok {
</span></span></span><span class="line"><span class="cl"><span class="c1">//      ... foo
</span></span></span><span class="line"><span class="cl"><span class="c1">// }
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">//go:nosplit
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">chanrecv2</span><span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">hchan</span><span class="p">,</span> <span class="nx">elem</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">)</span> <span class="p">(</span><span class="nx">received</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 1. (_, true)：数据交换成功，得到对应交换的数据。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 2. (_, false)：因close导致获取到了零值数据。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">_</span><span class="p">,</span> <span class="nx">received</span> <span class="p">=</span> <span class="nf">chanrecv</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">elem</span><span class="p">,</span> <span class="kc">true</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="gopark">gopark()<a hidden class="anchor" aria-hidden="true" href="#gopark">#</a></h2>
<ol>
<li>将当前例程置于等待状态并调用系统堆栈上的 unlock。</li>
<li>如果 unlock 返回 false，则继续执行该 goroutine。</li>
<li>unlockf 不能访问这个 G 的堆栈，因为它可能在调用 gopark 和调用 unlockf 之间移动。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// Puts the current goroutine into a waiting state and calls unlockf on the
</span></span></span><span class="line"><span class="cl"><span class="c1">// system stack.
</span></span></span><span class="line"><span class="cl"><span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1">// If unlockf returns false, the goroutine is resumed.
</span></span></span><span class="line"><span class="cl"><span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1">// unlockf must not access this G&#39;s stack, as it may be moved between
</span></span></span><span class="line"><span class="cl"><span class="c1">// the call to gopark and the call to unlockf.
</span></span></span><span class="line"><span class="cl"><span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1">// Note that because unlockf is called after putting the G into a waiting
</span></span></span><span class="line"><span class="cl"><span class="c1">// state, the G may have already been readied by the time unlockf is called
</span></span></span><span class="line"><span class="cl"><span class="c1">// unless there is external synchronization preventing the G from being
</span></span></span><span class="line"><span class="cl"><span class="c1">// readied. If unlockf returns false, it must guarantee that the G cannot be
</span></span></span><span class="line"><span class="cl"><span class="c1">// externally readied.
</span></span></span><span class="line"><span class="cl"><span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1">// Reason explains why the goroutine has been parked. It is displayed in stack
</span></span></span><span class="line"><span class="cl"><span class="c1">// traces and heap dumps. Reasons should be unique and descriptive. Do not
</span></span></span><span class="line"><span class="cl"><span class="c1">// re-use reasons, add new ones.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">gopark</span><span class="p">(</span><span class="nx">unlockf</span> <span class="kd">func</span><span class="p">(</span><span class="o">*</span><span class="nx">g</span><span class="p">,</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">)</span> <span class="kt">bool</span><span class="p">,</span> <span class="nx">lock</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">,</span> <span class="nx">reason</span> <span class="nx">waitReason</span><span class="p">,</span> <span class="nx">traceEv</span> <span class="kt">byte</span><span class="p">,</span> <span class="nx">traceskip</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// const waitReasonSleep = 19
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 等待原因不是因为sleep时，按需调用checkTimeouts()，检查timer。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nx">reason</span> <span class="o">!=</span> <span class="nx">waitReasonSleep</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// timeouts 可能会在两个goroutine使调度程序繁忙时过期。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 检查 p.timers 在调度循环时或 goroutine 被调离CPU 或 sysmon 监控线程中都会轮询查看。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nf">checkTimeouts</span><span class="p">()</span> <span class="c1">// timeouts may expire while two goroutines keep the scheduler busy
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nx">mp</span> <span class="o">:=</span> <span class="nf">acquirem</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="nx">gp</span> <span class="o">:=</span> <span class="nx">mp</span><span class="p">.</span><span class="nx">curg</span> <span class="c1">// 当前gp
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">status</span> <span class="o">:=</span> <span class="nf">readgstatus</span><span class="p">(</span><span class="nx">gp</span><span class="p">)</span> <span class="c1">// 获取状态
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nx">status</span> <span class="o">!=</span> <span class="nx">_Grunning</span> <span class="o">&amp;&amp;</span> <span class="nx">status</span> <span class="o">!=</span> <span class="nx">_Gscanrunning</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">throw</span><span class="p">(</span><span class="s">&#34;gopark: bad g status&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nx">mp</span><span class="p">.</span><span class="nx">waitlock</span> <span class="p">=</span> <span class="nx">lock</span>      <span class="c1">// 等待的锁，unlockf的第二个参数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">mp</span><span class="p">.</span><span class="nx">waitunlockf</span> <span class="p">=</span> <span class="nx">unlockf</span><span class="c1">// 调离前需要执行的闭包
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">gp</span><span class="p">.</span><span class="nx">waitreason</span> <span class="p">=</span> <span class="nx">reason</span>
</span></span><span class="line"><span class="cl">    <span class="nx">mp</span><span class="p">.</span><span class="nx">waittraceev</span> <span class="p">=</span> <span class="nx">traceEv</span>
</span></span><span class="line"><span class="cl">    <span class="nx">mp</span><span class="p">.</span><span class="nx">waittraceskip</span> <span class="p">=</span> <span class="nx">traceskip</span>
</span></span><span class="line"><span class="cl">    <span class="nf">releasem</span><span class="p">(</span><span class="nx">mp</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// can&#39;t do anything that might move the G between Ms here.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">mcall</span><span class="p">(</span><span class="nx">park_m</span><span class="p">)</span> <span class="c1">// mcall保存现场并切换g0调用park_m函数。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="park_m">park_m()<a hidden class="anchor" aria-hidden="true" href="#park_m">#</a></h3>
<ol>
<li>该函数在<code>g0</code>上。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// park continuation on g0.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">park_m</span><span class="p">(</span><span class="nx">gp</span> <span class="o">*</span><span class="nx">g</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">mp</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">().</span><span class="nx">m</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">trace</span><span class="p">.</span><span class="nx">enabled</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">traceGoPark</span><span class="p">(</span><span class="nx">mp</span><span class="p">.</span><span class="nx">waittraceev</span><span class="p">,</span> <span class="nx">mp</span><span class="p">.</span><span class="nx">waittraceskip</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// N.B. Not using casGToWaiting here because the waitreason is
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// set by park_m&#39;s caller.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">casgstatus</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="nx">_Grunning</span><span class="p">,</span> <span class="nx">_Gwaiting</span><span class="p">)</span> <span class="c1">// 切换gp的状态
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">dropg</span><span class="p">()</span> <span class="c1">// 解除m与gp的绑定
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">fn</span> <span class="o">:=</span> <span class="nx">mp</span><span class="p">.</span><span class="nx">waitunlockf</span><span class="p">;</span> <span class="nx">fn</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">ok</span> <span class="o">:=</span> <span class="nf">fn</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="nx">mp</span><span class="p">.</span><span class="nx">waitlock</span><span class="p">)</span> <span class="c1">// 调用waitunlockf
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">mp</span><span class="p">.</span><span class="nx">waitunlockf</span> <span class="p">=</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl">        <span class="nx">mp</span><span class="p">.</span><span class="nx">waitlock</span> <span class="p">=</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 返回false时，再次运行gp
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="p">!</span><span class="nx">ok</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="nx">trace</span><span class="p">.</span><span class="nx">enabled</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="nf">traceGoUnpark</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="nf">casgstatus</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="nx">_Gwaiting</span><span class="p">,</span> <span class="nx">_Grunnable</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="nf">execute</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="kc">true</span><span class="p">)</span> <span class="c1">// Schedule it back, never returns.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nf">schedule</span><span class="p">()</span> <span class="c1">// 调度循环
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="close">close()<a hidden class="anchor" aria-hidden="true" href="#close">#</a></h2>
<ol>
<li>关闭 hchan。</li>
<li>几种关闭 channel 的情况：
<ol>
<li>close 关闭时，sendq 上有等待的 goroutine，会 panic。【&ldquo;panic: send on closed channel&rdquo;】。</li>
<li>close 关闭时，再有 send 操作，会 panic。【&ldquo;panic: send on closed channel&rdquo;】。</li>
<li>close 关闭时，buf 中有数据，不会 panic，recv 可以读取它们。</li>
</ol>
</li>
<li>向 nil 的 channel，send 或 recv 时当前 goroutine 会panic。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span><span class="lnt">77
</span><span class="lnt">78
</span><span class="lnt">79
</span><span class="lnt">80
</span><span class="lnt">81
</span><span class="lnt">82
</span><span class="lnt">83
</span><span class="lnt">84
</span><span class="lnt">85
</span><span class="lnt">86
</span><span class="lnt">87
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">closechan</span><span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">hchan</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 1) nil 的 chan 是不允许被 close 的
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nx">c</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>	
</span></span><span class="line"><span class="cl">        <span class="nb">panic</span><span class="p">(</span><span class="nf">plainError</span><span class="p">(</span><span class="s">&#34;close of nil channel&#34;</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">c</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span> <span class="c1">// 尝试获取 runtime.mutex
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 2) 已经关闭的 chan 不能再次关闭
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nx">c</span><span class="p">.</span><span class="nx">closed</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>	
</span></span><span class="line"><span class="cl">        <span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">c</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="nb">panic</span><span class="p">(</span><span class="nf">plainError</span><span class="p">(</span><span class="s">&#34;close of closed channel&#34;</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">raceenabled</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">callerpc</span> <span class="o">:=</span> <span class="nf">getcallerpc</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">        <span class="nf">racewritepc</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nf">raceaddr</span><span class="p">(),</span> <span class="nx">callerpc</span><span class="p">,</span> <span class="nx">abi</span><span class="p">.</span><span class="nf">FuncPCABIInternal</span><span class="p">(</span><span class="nx">closechan</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">        <span class="nf">racerelease</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nf">raceaddr</span><span class="p">())</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 3) 获取到互斥锁后首先标记closed字段
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">c</span><span class="p">.</span><span class="nx">closed</span> <span class="p">=</span> <span class="mi">1</span> <span class="c1">// 标记chan状态为关闭 0.未关闭 1.已关闭
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="c1">// gList是一个goroutine的链表
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 当前要关闭的c还未处理的goroutine
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kd">var</span> <span class="nx">glist</span> <span class="nx">gList</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 4) 处理 recvq 上的 goroutine
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="c1">// release all readers
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">for</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 如果同一个goroutine在多个channel上时（这种情况发生在goselect时）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// dequeue() 函数有相关的排重，CAS操作。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">sg</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">recvq</span><span class="p">.</span><span class="nf">dequeue</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="nx">sg</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">break</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="nx">sg</span><span class="p">.</span><span class="nx">elem</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nf">typedmemclr</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">elemtype</span><span class="p">,</span> <span class="nx">sg</span><span class="p">.</span><span class="nx">elem</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="nx">sg</span><span class="p">.</span><span class="nx">elem</span> <span class="p">=</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="nx">sg</span><span class="p">.</span><span class="nx">releasetime</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nx">sg</span><span class="p">.</span><span class="nx">releasetime</span> <span class="p">=</span> <span class="nf">cputicks</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="nx">gp</span> <span class="o">:=</span> <span class="nx">sg</span><span class="p">.</span><span class="nx">g</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 主要用与 select 语句唤醒后使用。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">gp</span><span class="p">.</span><span class="nx">param</span> <span class="p">=</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">sg</span><span class="p">)</span> <span class="c1">// g.param = *sudog
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">sg</span><span class="p">.</span><span class="nx">success</span> <span class="p">=</span> <span class="kc">false</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="nx">raceenabled</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nf">raceacquireg</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="nx">c</span><span class="p">.</span><span class="nf">raceaddr</span><span class="p">())</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="nx">glist</span><span class="p">.</span><span class="nf">push</span><span class="p">(</span><span class="nx">gp</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 5) 处理 sendq 上的 goroutine，这些goroutine得到运行后会 panic。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 因为不能向close的channel有send操作，其中一种情况体现在这里。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="c1">// release all writers (they will panic)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">for</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">sg</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">sendq</span><span class="p">.</span><span class="nf">dequeue</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="nx">sg</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">break</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="nx">sg</span><span class="p">.</span><span class="nx">elem</span> <span class="p">=</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="nx">sg</span><span class="p">.</span><span class="nx">releasetime</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nx">sg</span><span class="p">.</span><span class="nx">releasetime</span> <span class="p">=</span> <span class="nf">cputicks</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="nx">gp</span> <span class="o">:=</span> <span class="nx">sg</span><span class="p">.</span><span class="nx">g</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 主要用与 select 语句唤醒后使用。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">gp</span><span class="p">.</span><span class="nx">param</span> <span class="p">=</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">sg</span><span class="p">)</span> <span class="c1">// g.param = *sudog
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">sg</span><span class="p">.</span><span class="nx">success</span> <span class="p">=</span> <span class="kc">false</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="nx">raceenabled</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nf">raceacquireg</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="nx">c</span><span class="p">.</span><span class="nf">raceaddr</span><span class="p">())</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="nx">glist</span><span class="p">.</span><span class="nf">push</span><span class="p">(</span><span class="nx">gp</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">c</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 6) 将这些 goroutine 放回等待队列中
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Ready all Gs now that we&#39;ve dropped the channel lock.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">for</span> <span class="p">!</span><span class="nx">glist</span><span class="p">.</span><span class="nf">empty</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">gp</span> <span class="o">:=</span> <span class="nx">glist</span><span class="p">.</span><span class="nf">pop</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">        <span class="nx">gp</span><span class="p">.</span><span class="nx">schedlink</span> <span class="p">=</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 将gp放入本地P的队列中
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nf">goready</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="type-guintptr-uintptr">type guintptr uintptr<a hidden class="anchor" aria-hidden="true" href="#type-guintptr-uintptr">#</a></h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// A guintptr holds a goroutine pointer, but typed as a uintptr
</span></span></span><span class="line"><span class="cl"><span class="c1">// to bypass write barriers. It is used in the Gobuf goroutine state
</span></span></span><span class="line"><span class="cl"><span class="c1">// and in scheduling lists that are manipulated without a P.
</span></span></span><span class="line"><span class="cl"><span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1">// The Gobuf.g goroutine pointer is almost always updated by assembly code.
</span></span></span><span class="line"><span class="cl"><span class="c1">// In one of the few places it is updated by Go code - func save - it must be
</span></span></span><span class="line"><span class="cl"><span class="c1">// treated as a uintptr to avoid a write barrier being emitted at a bad time.
</span></span></span><span class="line"><span class="cl"><span class="c1">// Instead of figuring out how to emit the write barriers missing in the
</span></span></span><span class="line"><span class="cl"><span class="c1">// assembly manipulation, we change the type of the field to uintptr,
</span></span></span><span class="line"><span class="cl"><span class="c1">// so that it does not require write barriers at all.
</span></span></span><span class="line"><span class="cl"><span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1">// Goroutine structs are published in the allg list and never freed.
</span></span></span><span class="line"><span class="cl"><span class="c1">// That will keep the goroutine structs from being collected.
</span></span></span><span class="line"><span class="cl"><span class="c1">// There is never a time that Gobuf.g&#39;s contain the only references
</span></span></span><span class="line"><span class="cl"><span class="c1">// to a goroutine: the publishing of the goroutine in allg comes first.
</span></span></span><span class="line"><span class="cl"><span class="c1">// Goroutine pointers are also kept in non-GC-visible places like TLS,
</span></span></span><span class="line"><span class="cl"><span class="c1">// so I can&#39;t see them ever moving. If we did want to start moving data
</span></span></span><span class="line"><span class="cl"><span class="c1">// in the GC, we&#39;d need to allocate the goroutine structs from an
</span></span></span><span class="line"><span class="cl"><span class="c1">// alternate arena. Using guintptr doesn&#39;t make that problem any worse.
</span></span></span><span class="line"><span class="cl"><span class="c1">// Note that pollDesc.rg, pollDesc.wg also store g in uintptr form,
</span></span></span><span class="line"><span class="cl"><span class="c1">// so they would need to be updated too if g&#39;s start moving.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">type</span> <span class="nx">guintptr</span> <span class="kt">uintptr</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//go:nosplit
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">gp</span> <span class="nx">guintptr</span><span class="p">)</span> <span class="nf">ptr</span><span class="p">()</span> <span class="o">*</span><span class="nx">g</span> <span class="p">{</span> <span class="k">return</span> <span class="p">(</span><span class="o">*</span><span class="nx">g</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">gp</span><span class="p">))</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//go:nosplit
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">gp</span> <span class="o">*</span><span class="nx">guintptr</span><span class="p">)</span> <span class="nf">set</span><span class="p">(</span><span class="nx">g</span> <span class="o">*</span><span class="nx">g</span><span class="p">)</span> <span class="p">{</span> <span class="o">*</span><span class="nx">gp</span> <span class="p">=</span> <span class="nf">guintptr</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">g</span><span class="p">))</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//go:nosplit
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">gp</span> <span class="o">*</span><span class="nx">guintptr</span><span class="p">)</span> <span class="nf">cas</span><span class="p">(</span><span class="nx">old</span><span class="p">,</span> <span class="nx">new</span> <span class="nx">guintptr</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Casuintptr</span><span class="p">((</span><span class="o">*</span><span class="kt">uintptr</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">gp</span><span class="p">)),</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">old</span><span class="p">),</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">new</span><span class="p">))</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="type-glist-struct">type gList struct<a hidden class="anchor" aria-hidden="true" href="#type-glist-struct">#</a></h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// A gList is a list of Gs linked through g.schedlink. A G can only be
</span></span></span><span class="line"><span class="cl"><span class="c1">// on one gQueue or gList at a time.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">type</span> <span class="nx">gList</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">head</span> <span class="nx">guintptr</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// empty reports whether l is empty.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">l</span> <span class="o">*</span><span class="nx">gList</span><span class="p">)</span> <span class="nf">empty</span><span class="p">()</span> <span class="kt">bool</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nx">l</span><span class="p">.</span><span class="nx">head</span> <span class="o">==</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// push adds gp to the head of l.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">l</span> <span class="o">*</span><span class="nx">gList</span><span class="p">)</span> <span class="nf">push</span><span class="p">(</span><span class="nx">gp</span> <span class="o">*</span><span class="nx">g</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">gp</span><span class="p">.</span><span class="nx">schedlink</span> <span class="p">=</span> <span class="nx">l</span><span class="p">.</span><span class="nx">head</span>
</span></span><span class="line"><span class="cl">    <span class="nx">l</span><span class="p">.</span><span class="nx">head</span><span class="p">.</span><span class="nf">set</span><span class="p">(</span><span class="nx">gp</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// pushAll prepends all Gs in q to l.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">l</span> <span class="o">*</span><span class="nx">gList</span><span class="p">)</span> <span class="nf">pushAll</span><span class="p">(</span><span class="nx">q</span> <span class="nx">gQueue</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">!</span><span class="nx">q</span><span class="p">.</span><span class="nf">empty</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">q</span><span class="p">.</span><span class="nx">tail</span><span class="p">.</span><span class="nf">ptr</span><span class="p">().</span><span class="nx">schedlink</span> <span class="p">=</span> <span class="nx">l</span><span class="p">.</span><span class="nx">head</span>
</span></span><span class="line"><span class="cl">        <span class="nx">l</span><span class="p">.</span><span class="nx">head</span> <span class="p">=</span> <span class="nx">q</span><span class="p">.</span><span class="nx">head</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// pop removes and returns the head of l. If l is empty, it returns nil.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">l</span> <span class="o">*</span><span class="nx">gList</span><span class="p">)</span> <span class="nf">pop</span><span class="p">()</span> <span class="o">*</span><span class="nx">g</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">gp</span> <span class="o">:=</span> <span class="nx">l</span><span class="p">.</span><span class="nx">head</span><span class="p">.</span><span class="nf">ptr</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">gp</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">l</span><span class="p">.</span><span class="nx">head</span> <span class="p">=</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">schedlink</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nx">gp</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="len">len()<a hidden class="anchor" aria-hidden="true" href="#len">#</a></h2>
<ol>
<li>获取 chan 的元素个数。（获取的是缓存区的个数，没有挂在链表中的数量）</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">//go:linkname reflect_chanlen reflect.chanlen
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">reflect_chanlen</span><span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">hchan</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">c</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">qcount</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">//go:linkname reflectlite_chanlen internal/reflectlite.chanlen
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">reflectlite_chanlen</span><span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">hchan</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">c</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">qcount</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="cap">cap()<a hidden class="anchor" aria-hidden="true" href="#cap">#</a></h2>
<ol>
<li>返回值和<code>len()</code>函数一致。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">//go:linkname reflect_chancap reflect.chancap
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">reflect_chancap</span><span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">hchan</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">c</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">dataqsiz</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="select-default">select default<a hidden class="anchor" aria-hidden="true" href="#select-default">#</a></h2>
<ol>
<li>以下是存在 default 默认分支情况。意思类似于 tryLock 函数，尝试一次。</li>
<li>以下只是特例，编译器不采用 goselect() 函数时。都是 select {case: default:} 这种形式。</li>
</ol>
<h3 id="select-中-c---v">select 中 c &lt;- v<a hidden class="anchor" aria-hidden="true" href="#select-中-c---v">#</a></h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// compiler implements
</span></span></span><span class="line"><span class="cl"><span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1">//	select {
</span></span></span><span class="line"><span class="cl"><span class="c1">//	case c &lt;- v:
</span></span></span><span class="line"><span class="cl"><span class="c1">//		... foo
</span></span></span><span class="line"><span class="cl"><span class="c1">//	default:
</span></span></span><span class="line"><span class="cl"><span class="c1">//		... bar
</span></span></span><span class="line"><span class="cl"><span class="c1">//	}
</span></span></span><span class="line"><span class="cl"><span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1">// as
</span></span></span><span class="line"><span class="cl"><span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1">//	if selectnbsend(c, v) {
</span></span></span><span class="line"><span class="cl"><span class="c1">//		... foo
</span></span></span><span class="line"><span class="cl"><span class="c1">//	} else {
</span></span></span><span class="line"><span class="cl"><span class="c1">//		... bar
</span></span></span><span class="line"><span class="cl"><span class="c1">//	}
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">selectnbsend</span><span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">hchan</span><span class="p">,</span> <span class="nx">elem</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">)</span> <span class="p">(</span><span class="nx">selected</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// true. 数据send完成。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// false. 表示目前不能发送，因为不想阻塞(block为false)而返回。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// false只在这里被传入使用。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">return</span> <span class="nf">chansend</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">elem</span><span class="p">,</span> <span class="kc">false</span><span class="p">,</span> <span class="nf">getcallerpc</span><span class="p">())</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ol>
<li>验证上面代码。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">chanTs</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">ch</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nx">a</span><span class="p">,</span> <span class="nx">b</span> <span class="o">:=</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">select</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="nx">ch</span> <span class="o">&lt;-</span> <span class="nx">a</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="nx">a</span> <span class="p">=</span> <span class="nx">b</span>
</span></span><span class="line"><span class="cl">    <span class="k">default</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="nx">b</span> <span class="p">=</span> <span class="nx">a</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-asm" data-lang="asm"><span class="line"><span class="cl"><span class="nf">TEXT</span> <span class="no">main.chanTs</span><span class="p">(</span><span class="no">SB</span><span class="p">)</span> <span class="no">G</span><span class="p">:</span><span class="err">/</span><span class="no">workspace</span><span class="err">/</span><span class="no">hello</span><span class="err">/</span><span class="no">main.go</span>
</span></span><span class="line"><span class="cl"><span class="nf">func</span> <span class="no">chanTs</span><span class="p">()</span> <span class="err">{</span>
</span></span><span class="line"><span class="cl">  <span class="err">0</span><span class="nf">x490ae0</span>              <span class="mi">493</span><span class="no">b6610</span>                <span class="no">CMPQ</span> <span class="mi">0x10</span><span class="p">(</span><span class="no">R14</span><span class="p">),</span> <span class="no">SP</span>
</span></span><span class="line"><span class="cl">  <span class="err">0</span><span class="nf">x490ae4</span>              <span class="mi">0</span><span class="no">f8685000000</span>            <span class="no">JBE</span> <span class="mi">0x490b6f</span>
</span></span><span class="line"><span class="cl">  <span class="err">0</span><span class="nf">x490aea</span>              <span class="mi">4883</span><span class="no">ec40</span>                <span class="no">SUBQ</span> <span class="no">$0x40</span><span class="p">,</span> <span class="no">SP</span>
</span></span><span class="line"><span class="cl">  <span class="err">0</span><span class="nf">x490aee</span>              <span class="mi">48896</span><span class="no">c2438</span>              <span class="no">MOVQ</span> <span class="no">BP</span><span class="p">,</span> <span class="mi">0x38</span><span class="p">(</span><span class="no">SP</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="err">0</span><span class="nf">x490af3</span>              <span class="mi">488</span><span class="no">d6c2438</span>              <span class="no">LEAQ</span> <span class="mi">0x38</span><span class="p">(</span><span class="no">SP</span><span class="p">),</span> <span class="no">BP</span>
</span></span><span class="line"><span class="cl">        <span class="nf">ch</span> <span class="p">:</span><span class="err">=</span> <span class="no">make</span><span class="p">(</span><span class="no">chan</span> <span class="no">int</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="err">0</span><span class="nf">x490af8</span>              <span class="mi">488</span><span class="no">d05419b0000</span>          <span class="no">LEAQ</span> <span class="no">runtime.rodata</span><span class="err">+</span><span class="mi">30272</span><span class="p">(</span><span class="no">SB</span><span class="p">),</span> <span class="no">AX</span>
</span></span><span class="line"><span class="cl">  <span class="err">0</span><span class="nf">x490aff</span>              <span class="mi">31</span><span class="no">db</span>                    <span class="no">XORL</span> <span class="no">BX</span><span class="p">,</span> <span class="no">BX</span>
</span></span><span class="line"><span class="cl">  <span class="err">0</span><span class="nf">x490b01</span>              <span class="no">e8da3cf7ff</span>              <span class="no">CALL</span> <span class="no">runtime.makechan</span><span class="p">(</span><span class="no">SB</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="err">0</span><span class="nf">x490b06</span>              <span class="mi">4889442428</span>              <span class="no">MOVQ</span> <span class="no">AX</span><span class="p">,</span> <span class="mi">0x28</span><span class="p">(</span><span class="no">SP</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="nf">a</span><span class="p">,</span> <span class="no">b</span> <span class="p">:</span><span class="err">=</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span>
</span></span><span class="line"><span class="cl">  <span class="err">0</span><span class="nf">x490b0b</span>              <span class="mi">48</span><span class="no">c744241801000000</span>      <span class="no">MOVQ</span> <span class="no">$0x1</span><span class="p">,</span> <span class="mi">0x18</span><span class="p">(</span><span class="no">SP</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="err">0</span><span class="nf">x490b14</span>              <span class="mi">48</span><span class="no">c744241002000000</span>      <span class="no">MOVQ</span> <span class="no">$0x2</span><span class="p">,</span> <span class="mi">0x10</span><span class="p">(</span><span class="no">SP</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="nf">case</span> <span class="no">ch</span> <span class="err">&lt;</span><span class="p">-</span> <span class="no">a</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">  <span class="err">0</span><span class="nf">x490b1d</span>              <span class="mi">488</span><span class="no">b4c2428</span>              <span class="no">MOVQ</span> <span class="mi">0x28</span><span class="p">(</span><span class="no">SP</span><span class="p">),</span> <span class="no">CX</span>
</span></span><span class="line"><span class="cl">  <span class="err">0</span><span class="nf">x490b22</span>              <span class="mi">48894</span><span class="no">c2430</span>              <span class="no">MOVQ</span> <span class="no">CX</span><span class="p">,</span> <span class="mi">0x30</span><span class="p">(</span><span class="no">SP</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="err">0</span><span class="nf">x490b27</span>              <span class="mi">488</span><span class="no">b4c2418</span>              <span class="no">MOVQ</span> <span class="mi">0x18</span><span class="p">(</span><span class="no">SP</span><span class="p">),</span> <span class="no">CX</span>
</span></span><span class="line"><span class="cl">  <span class="err">0</span><span class="nf">x490b2c</span>              <span class="mi">48894</span><span class="no">c2420</span>              <span class="no">MOVQ</span> <span class="no">CX</span><span class="p">,</span> <span class="mi">0x20</span><span class="p">(</span><span class="no">SP</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="err">0</span><span class="nf">x490b31</span>              <span class="mi">488</span><span class="no">b442430</span>              <span class="no">MOVQ</span> <span class="mi">0x30</span><span class="p">(</span><span class="no">SP</span><span class="p">),</span> <span class="no">AX</span>   <span class="c1"># 参数 c
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="err">0</span><span class="nf">x490b36</span>              <span class="mi">488</span><span class="no">d5c2420</span>              <span class="no">LEAQ</span> <span class="mi">0x20</span><span class="p">(</span><span class="no">SP</span><span class="p">),</span> <span class="no">BX</span>   <span class="c1"># 参数 elem
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="err">0</span><span class="nf">x490b3b</span>              <span class="mi">0</span><span class="no">f1f440000</span>              <span class="no">NOPL</span> <span class="mi">0</span><span class="p">(</span><span class="no">AX</span><span class="p">)(</span><span class="no">AX</span><span class="p">*</span><span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="err">0</span><span class="nf">x490b40</span>              <span class="no">e89b55f7ff</span>              <span class="no">CALL</span> <span class="no">runtime.selectnbsend</span><span class="p">(</span><span class="no">SB</span><span class="p">)</span> <span class="c1"># 调用selectnbsend
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="err">0</span><span class="nf">x490b45</span>              <span class="mi">84</span><span class="no">c0</span>                    <span class="no">TESTL</span> <span class="no">AL</span><span class="p">,</span> <span class="no">AL</span>
</span></span><span class="line"><span class="cl">  <span class="err">0</span><span class="nf">x490b47</span>              <span class="mi">7502</span>                    <span class="no">JNE</span> <span class="mi">0x490b4b</span>
</span></span><span class="line"><span class="cl">  <span class="err">0</span><span class="nf">x490b49</span>              <span class="no">eb0c</span>                    <span class="no">JMP</span> <span class="mi">0x490b57</span>
</span></span><span class="line"><span class="cl">                <span class="nf">a</span> <span class="err">=</span> <span class="no">b</span>
</span></span><span class="line"><span class="cl">  <span class="err">0</span><span class="nf">x490b4b</span>              <span class="mi">488</span><span class="no">b442410</span>              <span class="no">MOVQ</span> <span class="mi">0x10</span><span class="p">(</span><span class="no">SP</span><span class="p">),</span> <span class="no">AX</span>
</span></span><span class="line"><span class="cl">  <span class="err">0</span><span class="nf">x490b50</span>              <span class="mi">4889442418</span>              <span class="no">MOVQ</span> <span class="no">AX</span><span class="p">,</span> <span class="mi">0x18</span><span class="p">(</span><span class="no">SP</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="err">0</span><span class="nf">x490b55</span>              <span class="no">eb0c</span>                    <span class="no">JMP</span> <span class="mi">0x490b63</span>
</span></span><span class="line"><span class="cl">                <span class="nf">b</span> <span class="err">=</span> <span class="no">a</span>
</span></span><span class="line"><span class="cl">  <span class="err">0</span><span class="nf">x490b57</span>              <span class="mi">488</span><span class="no">b442418</span>              <span class="no">MOVQ</span> <span class="mi">0x18</span><span class="p">(</span><span class="no">SP</span><span class="p">),</span> <span class="no">AX</span>
</span></span><span class="line"><span class="cl">  <span class="err">0</span><span class="nf">x490b5c</span>              <span class="mi">4889442410</span>              <span class="no">MOVQ</span> <span class="no">AX</span><span class="p">,</span> <span class="mi">0x10</span><span class="p">(</span><span class="no">SP</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="err">0</span><span class="nf">x490b61</span>              <span class="no">eb00</span>                    <span class="no">JMP</span> <span class="mi">0x490b63</span>
</span></span><span class="line"><span class="cl">        <span class="nf">case</span> <span class="no">ch</span> <span class="err">&lt;</span><span class="p">-</span> <span class="no">a</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">  <span class="err">0</span><span class="nf">x490b63</span>              <span class="no">eb00</span>                    <span class="no">JMP</span> <span class="mi">0x490b65</span>
</span></span><span class="line"><span class="cl"><span class="err">}</span>
</span></span><span class="line"><span class="cl">  <span class="err">0</span><span class="nf">x490b65</span>              <span class="mi">488</span><span class="no">b6c2438</span>              <span class="no">MOVQ</span> <span class="mi">0x38</span><span class="p">(</span><span class="no">SP</span><span class="p">),</span> <span class="no">BP</span>
</span></span><span class="line"><span class="cl">  <span class="err">0</span><span class="nf">x490b6a</span>              <span class="mi">4883</span><span class="no">c440</span>                <span class="no">ADDQ</span> <span class="no">$0x40</span><span class="p">,</span> <span class="no">SP</span>
</span></span><span class="line"><span class="cl">  <span class="err">0</span><span class="nf">x490b6e</span>              <span class="no">c3</span>                      <span class="no">RET</span>
</span></span><span class="line"><span class="cl"><span class="nf">func</span> <span class="no">chanTs</span><span class="p">()</span> <span class="err">{</span>
</span></span><span class="line"><span class="cl">  <span class="err">0</span><span class="nf">x490b6f</span>              <span class="no">e8ecb4fcff</span>              <span class="no">CALL</span> <span class="no">runtime.morestack_noctxt.abi0</span><span class="p">(</span><span class="no">SB</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="err">0</span><span class="nf">x490b74</span>              <span class="no">e967ffffff</span>              <span class="no">JMP</span> <span class="no">main.chanTs</span><span class="p">(</span><span class="no">SB</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="err">0</span><span class="nf">x490b79</span>              <span class="no">cc</span>                      <span class="no">INT</span> <span class="no">$0x3</span>
</span></span><span class="line"><span class="cl">  <span class="err">0</span><span class="nf">x490b7a</span>              <span class="no">cc</span>                      <span class="no">INT</span> <span class="no">$0x3</span>
</span></span><span class="line"><span class="cl">  <span class="err">0</span><span class="nf">x490b7b</span>              <span class="no">cc</span>                      <span class="no">INT</span> <span class="no">$0x3</span>
</span></span><span class="line"><span class="cl">  <span class="err">0</span><span class="nf">x490b7c</span>              <span class="no">cc</span>                      <span class="no">INT</span> <span class="no">$0x3</span>
</span></span><span class="line"><span class="cl">  <span class="err">0</span><span class="nf">x490b7d</span>              <span class="no">cc</span>                      <span class="no">INT</span> <span class="no">$0x3</span>
</span></span><span class="line"><span class="cl">  <span class="err">0</span><span class="nf">x490b7e</span>              <span class="no">cc</span>                      <span class="no">INT</span> <span class="no">$0x3</span>
</span></span><span class="line"><span class="cl">  <span class="err">0</span><span class="nf">x490b7f</span>              <span class="no">cc</span>                      <span class="no">INT</span> <span class="no">$0x3</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="select-中-v---c">select 中 v &lt;- c<a hidden class="anchor" aria-hidden="true" href="#select-中-v---c">#</a></h3>
<ol>
<li>在 <code>go1.18</code>版本前。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// compiler implements
</span></span></span><span class="line"><span class="cl"><span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1">//  select {
</span></span></span><span class="line"><span class="cl"><span class="c1">//  case v = &lt;-c:
</span></span></span><span class="line"><span class="cl"><span class="c1">//      ... foo
</span></span></span><span class="line"><span class="cl"><span class="c1">//  default:
</span></span></span><span class="line"><span class="cl"><span class="c1">//      ... bar
</span></span></span><span class="line"><span class="cl"><span class="c1">//  }
</span></span></span><span class="line"><span class="cl"><span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1">// as
</span></span></span><span class="line"><span class="cl"><span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1">//  if selectnbrecv(&amp;v, c) {
</span></span></span><span class="line"><span class="cl"><span class="c1">//      ... foo
</span></span></span><span class="line"><span class="cl"><span class="c1">//  } else {
</span></span></span><span class="line"><span class="cl"><span class="c1">//      ... bar
</span></span></span><span class="line"><span class="cl"><span class="c1">//  }
</span></span></span><span class="line"><span class="cl"><span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">selectnbrecv</span><span class="p">(</span><span class="nx">elem</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">,</span> <span class="nx">c</span> <span class="o">*</span><span class="nx">hchan</span><span class="p">)</span> <span class="p">(</span><span class="nx">selected</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// selected：表示当前分支是否选中
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">selected</span><span class="p">,</span> <span class="nx">_</span> <span class="p">=</span> <span class="nf">chanrecv</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">elem</span><span class="p">,</span> <span class="kc">false</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="select-中-v-ok----c">select 中 v, ok = &lt;- c<a hidden class="anchor" aria-hidden="true" href="#select-中-v-ok----c">#</a></h3>
<ol>
<li>在 <code>go1.18</code>版本前。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// compiler implements
</span></span></span><span class="line"><span class="cl"><span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1">//  select {
</span></span></span><span class="line"><span class="cl"><span class="c1">//  case v, ok = &lt;-c:
</span></span></span><span class="line"><span class="cl"><span class="c1">//      ... foo
</span></span></span><span class="line"><span class="cl"><span class="c1">//  default:
</span></span></span><span class="line"><span class="cl"><span class="c1">//      ... bar
</span></span></span><span class="line"><span class="cl"><span class="c1">//  }
</span></span></span><span class="line"><span class="cl"><span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1">// as
</span></span></span><span class="line"><span class="cl"><span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1">//  if c != nil &amp;&amp; selectnbrecv2(&amp;v, &amp;ok, c) {
</span></span></span><span class="line"><span class="cl"><span class="c1">//      ... foo
</span></span></span><span class="line"><span class="cl"><span class="c1">//  } else {
</span></span></span><span class="line"><span class="cl"><span class="c1">//      ... bar
</span></span></span><span class="line"><span class="cl"><span class="c1">//  }
</span></span></span><span class="line"><span class="cl"><span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">selectnbrecv2</span><span class="p">(</span><span class="nx">elem</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">,</span> <span class="nx">received</span> <span class="o">*</span><span class="kt">bool</span><span class="p">,</span> <span class="nx">c</span> <span class="o">*</span><span class="nx">hchan</span><span class="p">)</span> <span class="p">(</span><span class="nx">selected</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// TODO(khr): just return 2 values from this function, now that it is in Go.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// selected：表示当前分支是否选中
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// received：表示当前是否因为 close 而关闭的零值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">selected</span><span class="p">,</span> <span class="o">*</span><span class="nx">received</span> <span class="p">=</span> <span class="nf">chanrecv</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">elem</span><span class="p">,</span> <span class="kc">false</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="其他版本">其他版本<a hidden class="anchor" aria-hidden="true" href="#其他版本">#</a></h4>
<ol>
<li>在go1.19.3中，&lt;-c 有所改变但是原理都一样。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// compiler implements
</span></span></span><span class="line"><span class="cl"><span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1">//  select {
</span></span></span><span class="line"><span class="cl"><span class="c1">//  case v, ok = &lt;-c:
</span></span></span><span class="line"><span class="cl"><span class="c1">//      ... foo
</span></span></span><span class="line"><span class="cl"><span class="c1">//  default:
</span></span></span><span class="line"><span class="cl"><span class="c1">//      ... bar
</span></span></span><span class="line"><span class="cl"><span class="c1">//  }
</span></span></span><span class="line"><span class="cl"><span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1">// as
</span></span></span><span class="line"><span class="cl"><span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1">//  if selected, ok = selectnbrecv(&amp;v, c); selected {
</span></span></span><span class="line"><span class="cl"><span class="c1">//      ... foo
</span></span></span><span class="line"><span class="cl"><span class="c1">//  } else {
</span></span></span><span class="line"><span class="cl"><span class="c1">//      ... bar
</span></span></span><span class="line"><span class="cl"><span class="c1">//  }
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">selectnbrecv</span><span class="p">(</span><span class="nx">elem</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">,</span> <span class="nx">c</span> <span class="o">*</span><span class="nx">hchan</span><span class="p">)</span> <span class="p">(</span><span class="nx">selected</span><span class="p">,</span> <span class="nx">received</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// selected：表示当前分支是否选中
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// received：表示当前是否因为 close 而关闭的零值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">return</span> <span class="nf">chanrecv</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">elem</span><span class="p">,</span> <span class="kc">false</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1">//  select {
</span></span></span><span class="line"><span class="cl"><span class="c1">//  case v = &lt;-c:
</span></span></span><span class="line"><span class="cl"><span class="c1">//      ... foo
</span></span></span><span class="line"><span class="cl"><span class="c1">//  default:
</span></span></span><span class="line"><span class="cl"><span class="c1">//      ... bar
</span></span></span><span class="line"><span class="cl"><span class="c1">//  }
</span></span></span><span class="line"><span class="cl"><span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1">// as 
</span></span></span><span class="line"><span class="cl"><span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1">//  if selected, _ = selectnbrecv(&amp;v, c); selected {
</span></span></span><span class="line"><span class="cl"><span class="c1">//      ... foo
</span></span></span><span class="line"><span class="cl"><span class="c1">//  } else {
</span></span></span><span class="line"><span class="cl"><span class="c1">//      ... bar
</span></span></span><span class="line"><span class="cl"><span class="c1">//  }
</span></span></span></code></pre></td></tr></table>
</div>
</div><ol start="2">
<li>验证上面代码。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">chanTs</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">ch</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nx">a</span><span class="p">,</span> <span class="nx">b</span> <span class="o">:=</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span>
</span></span><span class="line"><span class="cl">    <span class="kd">var</span> <span class="nx">ok</span> <span class="kt">bool</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">select</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="nx">a</span><span class="p">,</span> <span class="nx">ok</span> <span class="p">=</span> <span class="o">&lt;-</span><span class="nx">ch</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="nx">b</span> <span class="p">=</span> <span class="nx">a</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="nx">ok</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nx">b</span> <span class="p">=</span> <span class="mi">100</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">default</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="nx">a</span> <span class="p">=</span> <span class="nx">b</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-asm" data-lang="asm"><span class="line"><span class="cl"><span class="nf">TEXT</span> <span class="no">main.chanTs</span><span class="p">(</span><span class="no">SB</span><span class="p">)</span> <span class="no">G</span><span class="p">:</span><span class="err">/</span><span class="no">workspace</span><span class="err">/</span><span class="no">hello</span><span class="err">/</span><span class="no">main.go</span>
</span></span><span class="line"><span class="cl"><span class="nf">func</span> <span class="no">chanTs</span><span class="p">()</span> <span class="err">{</span>
</span></span><span class="line"><span class="cl">  <span class="err">0</span><span class="nf">x490ae0</span>              <span class="mi">493</span><span class="no">b6610</span>                <span class="no">CMPQ</span> <span class="mi">0x10</span><span class="p">(</span><span class="no">R14</span><span class="p">),</span> <span class="no">SP</span>
</span></span><span class="line"><span class="cl">  <span class="err">0</span><span class="nf">x490ae4</span>              <span class="mi">0</span><span class="no">f86aa000000</span>            <span class="no">JBE</span> <span class="mi">0x490b94</span>
</span></span><span class="line"><span class="cl">  <span class="err">0</span><span class="nf">x490aea</span>              <span class="mi">4883</span><span class="no">ec48</span>                <span class="no">SUBQ</span> <span class="no">$0x48</span><span class="p">,</span> <span class="no">SP</span>
</span></span><span class="line"><span class="cl">  <span class="err">0</span><span class="nf">x490aee</span>              <span class="mi">48896</span><span class="no">c2440</span>              <span class="no">MOVQ</span> <span class="no">BP</span><span class="p">,</span> <span class="mi">0x40</span><span class="p">(</span><span class="no">SP</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="err">0</span><span class="nf">x490af3</span>              <span class="mi">488</span><span class="no">d6c2440</span>              <span class="no">LEAQ</span> <span class="mi">0x40</span><span class="p">(</span><span class="no">SP</span><span class="p">),</span> <span class="no">BP</span>
</span></span><span class="line"><span class="cl">        <span class="nf">ch</span> <span class="p">:</span><span class="err">=</span> <span class="no">make</span><span class="p">(</span><span class="no">chan</span> <span class="no">int</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="err">0</span><span class="nf">x490af8</span>              <span class="mi">488</span><span class="no">d05419b0000</span>          <span class="no">LEAQ</span> <span class="no">runtime.rodata</span><span class="err">+</span><span class="mi">30272</span><span class="p">(</span><span class="no">SB</span><span class="p">),</span> <span class="no">AX</span>
</span></span><span class="line"><span class="cl">  <span class="err">0</span><span class="nf">x490aff</span>              <span class="mi">31</span><span class="no">db</span>                    <span class="no">XORL</span> <span class="no">BX</span><span class="p">,</span> <span class="no">BX</span>
</span></span><span class="line"><span class="cl">  <span class="err">0</span><span class="nf">x490b01</span>              <span class="no">e8da3cf7ff</span>              <span class="no">CALL</span> <span class="no">runtime.makechan</span><span class="p">(</span><span class="no">SB</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="err">0</span><span class="nf">x490b06</span>              <span class="mi">4889442430</span>              <span class="no">MOVQ</span> <span class="no">AX</span><span class="p">,</span> <span class="mi">0x30</span><span class="p">(</span><span class="no">SP</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="nf">a</span><span class="p">,</span> <span class="no">b</span> <span class="p">:</span><span class="err">=</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span>
</span></span><span class="line"><span class="cl">  <span class="err">0</span><span class="nf">x490b0b</span>              <span class="mi">48</span><span class="no">c744242001000000</span>      <span class="no">MOVQ</span> <span class="no">$0x1</span><span class="p">,</span> <span class="mi">0x20</span><span class="p">(</span><span class="no">SP</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="err">0</span><span class="nf">x490b14</span>              <span class="mi">48</span><span class="no">c744241802000000</span>      <span class="no">MOVQ</span> <span class="no">$0x2</span><span class="p">,</span> <span class="mi">0x18</span><span class="p">(</span><span class="no">SP</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="nf">var</span> <span class="no">ok</span> <span class="no">bool</span>
</span></span><span class="line"><span class="cl">  <span class="err">0</span><span class="nf">x490b1d</span>              <span class="no">c644241500</span>              <span class="no">MOVB</span> <span class="no">$0x0</span><span class="p">,</span> <span class="mi">0x15</span><span class="p">(</span><span class="no">SP</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="nf">case</span> <span class="no">a</span><span class="p">,</span> <span class="no">ok</span> <span class="err">=</span> <span class="err">&lt;</span><span class="p">-</span><span class="no">ch</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">  <span class="err">0</span><span class="nf">x490b22</span>              <span class="mi">488</span><span class="no">b5c2430</span>              <span class="no">MOVQ</span> <span class="mi">0x30</span><span class="p">(</span><span class="no">SP</span><span class="p">),</span> <span class="no">BX</span>
</span></span><span class="line"><span class="cl">  <span class="err">0</span><span class="nf">x490b27</span>              <span class="mi">48895</span><span class="no">c2438</span>              <span class="no">MOVQ</span> <span class="no">BX</span><span class="p">,</span> <span class="mi">0x38</span><span class="p">(</span><span class="no">SP</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="err">0</span><span class="nf">x490b2c</span>              <span class="mi">488</span><span class="no">d442428</span>              <span class="no">LEAQ</span> <span class="mi">0x28</span><span class="p">(</span><span class="no">SP</span><span class="p">),</span> <span class="no">AX</span>
</span></span><span class="line"><span class="cl">  <span class="err">0</span><span class="nf">x490b31</span>              <span class="no">e8aa55f7ff</span>              <span class="no">CALL</span> <span class="no">runtime.selectnbrecv</span><span class="p">(</span><span class="no">SB</span><span class="p">)</span> <span class="c1"># selectnbrecv
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="err">0</span><span class="nf">x490b36</span>              <span class="mi">88442416</span>                <span class="no">MOVB</span> <span class="no">AL</span><span class="p">,</span> <span class="mi">0x16</span><span class="p">(</span><span class="no">SP</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="err">0</span><span class="nf">x490b3a</span>              <span class="mi">885</span><span class="no">c2417</span>                <span class="no">MOVB</span> <span class="no">BL</span><span class="p">,</span> <span class="mi">0x17</span><span class="p">(</span><span class="no">SP</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="err">0</span><span class="nf">x490b3e</span>              <span class="mi">807</span><span class="no">c241600</span>              <span class="no">CMPB</span> <span class="no">$0x0</span><span class="p">,</span> <span class="mi">0x16</span><span class="p">(</span><span class="no">SP</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                <span class="nf">if</span> <span class="no">ok</span> <span class="err">{</span>
</span></span><span class="line"><span class="cl">  <span class="err">0</span><span class="nf">x490b64</span>              <span class="mi">807</span><span class="no">c241500</span>              <span class="no">CMPB</span> <span class="no">$0x0</span><span class="p">,</span> <span class="mi">0x15</span><span class="p">(</span><span class="no">SP</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="err">0</span><span class="nf">x490b69</span>              <span class="mi">7502</span>                    <span class="no">JNE</span> <span class="mi">0x490b6d</span>
</span></span><span class="line"><span class="cl">  <span class="err">0</span><span class="nf">x490b6b</span>              <span class="no">eb0b</span>                    <span class="no">JMP</span> <span class="mi">0x490b78</span>
</span></span><span class="line"><span class="cl">                        <span class="nf">b</span> <span class="err">=</span> <span class="mi">100</span>
</span></span><span class="line"><span class="cl">  <span class="err">0</span><span class="nf">x490b6d</span>              <span class="mi">48</span><span class="no">c744241864000000</span>      <span class="no">MOVQ</span> <span class="no">$0x64</span><span class="p">,</span> <span class="mi">0x18</span><span class="p">(</span><span class="no">SP</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="err">0</span><span class="nf">x490b76</span>              <span class="no">eb02</span>                    <span class="no">JMP</span> <span class="mi">0x490b7a</span>
</span></span><span class="line"><span class="cl">                <span class="nf">if</span> <span class="no">ok</span> <span class="err">{</span>
</span></span><span class="line"><span class="cl">  <span class="err">0</span><span class="nf">x490b78</span>              <span class="no">eb00</span>                    <span class="no">JMP</span> <span class="mi">0x490b7a</span>
</span></span><span class="line"><span class="cl">        <span class="nf">case</span> <span class="no">a</span><span class="p">,</span> <span class="no">ok</span> <span class="err">=</span> <span class="err">&lt;</span><span class="p">-</span><span class="no">ch</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">  <span class="err">0</span><span class="nf">x490b7a</span>              <span class="no">eb0c</span>                    <span class="no">JMP</span> <span class="mi">0x490b88</span>
</span></span><span class="line"><span class="cl">                <span class="nf">a</span> <span class="err">=</span> <span class="no">b</span>
</span></span><span class="line"><span class="cl">  <span class="err">0</span><span class="nf">x490b7c</span>              <span class="mi">488</span><span class="no">b442418</span>              <span class="no">MOVQ</span> <span class="mi">0x18</span><span class="p">(</span><span class="no">SP</span><span class="p">),</span> <span class="no">AX</span>
</span></span><span class="line"><span class="cl">  <span class="err">0</span><span class="nf">x490b81</span>              <span class="mi">4889442420</span>              <span class="no">MOVQ</span> <span class="no">AX</span><span class="p">,</span> <span class="mi">0x20</span><span class="p">(</span><span class="no">SP</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="err">0</span><span class="nf">x490b86</span>              <span class="no">eb00</span>                    <span class="no">JMP</span> <span class="mi">0x490b88</span>
</span></span><span class="line"><span class="cl">        <span class="nf">case</span> <span class="no">a</span><span class="p">,</span> <span class="no">ok</span> <span class="err">=</span> <span class="err">&lt;</span><span class="p">-</span><span class="no">ch</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">  <span class="err">0</span><span class="nf">x490b88</span>              <span class="no">eb00</span>                    <span class="no">JMP</span> <span class="mi">0x490b8a</span>
</span></span><span class="line"><span class="cl"><span class="err">}</span>
</span></span><span class="line"><span class="cl">  <span class="err">0</span><span class="nf">x490b8a</span>              <span class="mi">488</span><span class="no">b6c2440</span>              <span class="no">MOVQ</span> <span class="mi">0x40</span><span class="p">(</span><span class="no">SP</span><span class="p">),</span> <span class="no">BP</span>
</span></span><span class="line"><span class="cl">  <span class="err">0</span><span class="nf">x490b8f</span>              <span class="mi">4883</span><span class="no">c448</span>                <span class="no">ADDQ</span> <span class="no">$0x48</span><span class="p">,</span> <span class="no">SP</span>
</span></span><span class="line"><span class="cl">  <span class="err">0</span><span class="nf">x490b93</span>              <span class="no">c3</span>                      <span class="no">RET</span>
</span></span><span class="line"><span class="cl"><span class="nf">func</span> <span class="no">chanTs</span><span class="p">()</span> <span class="err">{</span>
</span></span><span class="line"><span class="cl">  <span class="err">0</span><span class="nf">x490b94</span>              <span class="no">e8c7b4fcff</span>              <span class="no">CALL</span> <span class="no">runtime.morestack_noctxt.abi0</span><span class="p">(</span><span class="no">SB</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="err">0</span><span class="nf">x490b99</span>              <span class="no">e942ffffff</span>              <span class="no">JMP</span> <span class="no">main.chanTs</span><span class="p">(</span><span class="no">SB</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="err">0</span><span class="nf">x490b9e</span>              <span class="no">cc</span>                      <span class="no">INT</span> <span class="no">$0x3</span>
</span></span><span class="line"><span class="cl">  <span class="err">0</span><span class="nf">x490b9f</span>              <span class="no">cc</span>                      <span class="no">INT</span> <span class="no">$0x3</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="for-range">for range<a hidden class="anchor" aria-hidden="true" href="#for-range">#</a></h2>
<ol>
<li>参考 <a href="/posts/golang/process/range/#%e8%bf%ad%e4%bb%a3channel">流程控制(range迭代)</a>。</li>
</ol>
<h2 id="总结">总结<a hidden class="anchor" aria-hidden="true" href="#总结">#</a></h2>
<ol>
<li>向(没在select块中) nil 的 channel 中 send、recv 会 panic。在select块中 nil 的 channel 会被丢弃。</li>
<li>send 总是先判断的 close（panic），再判断的数据能否交换(select中的也一样)。recv 也是先判断 close 但是不会panic，再判断 buf 有没数据，有则取出，不会去 sendq 中查看挂起的 sudog。</li>
<li>nil 的 channel 不允许 close 操作，会 panic。close 已经 close 的 channel 会 panic。</li>
</ol>
<h2 id="参考">参考<a hidden class="anchor" aria-hidden="true" href="#参考">#</a></h2>
<ol>
<li><a href="https://mp.weixin.qq.com/s/6ZEGtXRGKm2qP5b-rGLyVg" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/6ZEGtXRGKm2qP5b-rGLyVg</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=Mzg5NjIwNzIxNQ==&amp;mid=2247484471&amp;idx=2&amp;sn=49af599b9c3796857459a14d040586fd&amp;scene=19#wechat_redirect" target="_blank" rel="noopener">https://mp.weixin.qq.com/s?__biz=Mzg5NjIwNzIxNQ==&mid=2247484471&idx=2&sn=49af599b9c3796857459a14d040586fd&scene=19#wechat_redirect</a></li>
</ol>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://helium-chain.github.io/tags/golang/">Golang</a></li>
      <li><a href="https://helium-chain.github.io/tags/channel/">Channel</a></li>
    </ul>
<nav class="paginav">
  <a class="prev" href="https://helium-chain.github.io/posts/golang/channel/use/">
    <span class="title">« 上一页</span>
    <br>
    <span>Channel(使用)</span>
  </a>
  <a class="next" href="https://helium-chain.github.io/posts/golang/channel/select/">
    <span class="title">下一页 »</span>
    <br>
    <span>select(原理)</span>
  </a>
</nav>

  </footer>
</article>
    </main>
    
<footer class="footer">
    
    <div class="busuanzi-footer">
    <span id="busuanzi_container_site_pv">
        本站总访问量<span id="busuanzi_value_site_pv"></span>次
    </span>
    <span id="busuanzi_container_site_uv">
        本站访客数<span id="busuanzi_value_site_uv"></span>人次
    </span>
    </div>
        <span>Copyright © 2024 蜀ICP备2024091074号 <a href="#">heliu's blog</a>. All rights reserved</span>  
    
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'Copy';

        function copyingDone() {
            copybutton.innerHTML = 'Done';
            setTimeout(() => {
                copybutton.innerHTML = 'Copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
