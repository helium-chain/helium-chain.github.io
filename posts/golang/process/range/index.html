<!DOCTYPE html>
<html lang="zh" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>流程控制(range迭代) | Helium</title>
<meta name="keywords" content="golang, 流程控制">
<meta name="description" content="💥本文章所有相关go代码参考自go 1.18&#43;版本">
<meta name="author" content="helium">
<link rel="canonical" href="https://heliu.site/posts/golang/process/range/">
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<meta name="referrer" content="no-referrer-when-downgrade">
<link crossorigin="anonymous" href="/assets/css/stylesheet.css" rel="preload stylesheet" as="style">
<link rel="icon" href="https://heliu.site/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://heliu.site/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://heliu.site/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://heliu.site/apple-touch-icon.png">
<link rel="mask-icon" href="https://heliu.site/apple-touch-icon.png">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="zh" href="https://heliu.site/posts/golang/process/range/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
<html>
<head>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/jetbrains-mono@1.0.6/css/jetbrains-mono-nl.min.css" />
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lxgw-wenkai-lite-webfont@1.1.0/style.css" />
    <link rel="stylesheet" href="https://cdn.staticfile.org/lxgw-wenkai-screen-webfont/1.6.0/style.css" />
    <style>
        body {
            font-family: "LXGW WenKai Lite", sans-serif;
            font-family: "LXGW WenKai Screen", sans-serif;
        }
    </style>
</head>
</html>

  

<meta property="og:title" content="流程控制(range迭代)" />
<meta property="og:description" content="💥本文章所有相关go代码参考自go 1.18&#43;版本" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://heliu.site/posts/golang/process/range/" />
<meta property="og:image" content="https://heliu.site/favicon-32x32.png" />
<meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-10-05T00:00:00+00:00" />
<meta property="article:modified_time" content="2020-07-20T00:00:00+00:00" /><meta property="og:site_name" content="Helium" />

<meta name="twitter:card" content="summary_large_image" />
<meta name="twitter:image" content="https://heliu.site/favicon-32x32.png" />
<meta name="twitter:title" content="流程控制(range迭代)"/>
<meta name="twitter:description" content="💥本文章所有相关go代码参考自go 1.18&#43;版本"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Article",
      "item": "https://heliu.site/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Golang 合集",
      "item": "https://heliu.site/posts/golang/"
    }, 
    {
      "@type": "ListItem",
      "position":  3 ,
      "name": "第3章 流程控制",
      "item": "https://heliu.site/posts/golang/process/"
    }, 
    {
      "@type": "ListItem",
      "position":  4 ,
      "name": "流程控制(range迭代)",
      "item": "https://heliu.site/posts/golang/process/range/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "流程控制(range迭代)",
  "name": "流程控制(range迭代)",
  "description": "💥本文章所有相关go代码参考自go 1.18+版本",
  "keywords": [
    "golang", "流程控制"
  ],
  "articleBody": "迭代string range迭代string，key为int类型，value为rune类型。 1 2 3 4 5 str := \"hello world! Gopher\" for i, v := range str { // 【int, rune】 fmt.Println(i, v) // original body } 上面迭代字符串代码等效于下面代码。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 // 1) 获取字符串长度 // 字符串总长度，该长度是字节数量用于遍历字符串的总长度 lenTemp := len(str) // 下一次遍历的下标位置，这是由于utf8是不定长编码需要记录上一次处理后的位置 var nextIndexTemp int\t// 2) key/value // 注意：这里的key和value，定义在for外，也是\u0026i和\u0026v是固定的原因 var i int // 遍历用到的索引，也就是index var v rune // 遍历出来存储的值，也就是value // 遍历字符串 for indexTemp := 0; indexTemp \u003c lenTemp; indexTemp = nextIndexTemp { // 获取开头8bit的大小，因为该8bit能区分存储的是ASCII 1bit还是多个使用utf8编码的字节 valueTemp := rune(str[indexTemp])\t// utf8.RuneSelf = 0x80 = 128 单字符最大值 // ASCII码字符占1字节，该条件满足说明，存储的是ASCII码占用一个字节 if valueTemp \u003c utf8.RuneSelf {\tnextIndexTemp = indexTemp + 1 } else { // 该条件满足说明是使用utf8编码的多个字节占用， // 使用decoderune获取该Unicode值和在Utf8中编码占用的字节大小数目 // decoderune解码字符串str从indexTemp位置开始，具体方法在runtime/utf8.go文件中 // 该函数与utf8编码相关 // valueTemp解析的rune，nextIndexTemp当前的indexTemp+解析的rune的长度 valueTemp, nextIndexTemp = decoderune(str, indexTemp)\t} // 3) 拷贝赋值 // 注意：这里就是为什么for range中取\u0026i和\u0026v地址是固定的原因 i = indexTemp // 当前获取到的索引 v = valueTemp // 当前获取到的字符 fmt.Println(i, v) // original body } decoderune()。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 // runtime/utf8.go 文件中decoderune方法 // decoderune returns the non-ASCII rune at the start of // s[k:] and the index after the rune in s. // // decoderune assumes that caller has checked that // the to be decoded rune is a non-ASCII rune. // // If the string appears to be incomplete or decoding problems // are encountered (runeerror, k + 1) is returned to ensure // progress when decoderune is used to iterate over a string. func decoderune(s string, k int) (r rune, pos int) { pos = k // 解析开始位置 if k \u003e= len(s) { // 已经到字符串的最大长度了 return runeError, k + 1 } s = s[k:] // 从k位置分割字符串 switch { // [t2, t3) --\u003e [11000000, 11100000) case t2 \u003c= s[0] \u0026\u0026 s[0] \u003c t3: // 该字段2字节编码 // 0080-07FF two byte sequence // [locb, hicb] 是第二个字节的范围大小 [10000000, 10111111] if len(s) \u003e 1 \u0026\u0026 (locb \u003c= s[1] \u0026\u0026 s[1] \u003c= hicb) { // 从编码中取出编码的数据组成rune // mask2 = 00011111，maskx = 00111111 r = rune(s[0]\u0026mask2)\u003c\u003c6 | rune(s[1]\u0026maskx) pos += 2 if rune1Max \u003c r { return } } // [t3, t4) --\u003e [11100000, 11110000) case t3 \u003c= s[0] \u0026\u0026 s[0] \u003c t4: // 该字段3字节编码 // 0800-FFFF three byte sequence if len(s) \u003e 2 \u0026\u0026 (locb \u003c= s[1] \u0026\u0026 s[1] \u003c= hicb) \u0026\u0026 (locb \u003c= s[2] \u0026\u0026 s[2] \u003c= hicb) { r = rune(s[0]\u0026mask3)\u003c\u003c12 | rune(s[1]\u0026maskx)\u003c\u003c6 | rune(s[2]\u0026maskx) pos += 3 if rune2Max \u003c r \u0026\u0026 !(surrogateMin \u003c= r \u0026\u0026 r \u003c= surrogateMax) { return } } // [t4, t5) --\u003e [11110000, 11111000) case t4 \u003c= s[0] \u0026\u0026 s[0] \u003c t5: // 该字段4字节编码 // 10000-1FFFFF four byte sequence if len(s) \u003e 3 \u0026\u0026 (locb \u003c= s[1] \u0026\u0026 s[1] \u003c= hicb) \u0026\u0026 (locb \u003c= s[2] \u0026\u0026 s[2] \u003c= hicb) \u0026\u0026 (locb \u003c= s[3] \u0026\u0026 s[3] \u003c= hicb) { r = rune(s[0]\u0026mask4)\u003c\u003c18 | rune(s[1]\u0026maskx)\u003c\u003c12 | rune(s[2]\u0026maskx)\u003c\u003c6 | rune(s[3]\u0026maskx) pos += 4 if rune3Max \u003c r \u0026\u0026 r \u003c= maxRune { return } } } return runeError, k + 1 } for-range不能遍历*string类型。 for-range对于字符串并没有复制一份字符串进行编码，其实也不必要因为字符串的语义本来就是不可变数据。 迭代array range迭代array，key为int类型，value为数组的元素类型。 1 2 3 4 5 arr := [5]int{0,1,2,3,4} for i, v := range arr { // 【int, int】 fmt.Println(i, v) // original body } 上面迭代数组代码等效于下面代码。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 // 1) 获取数组长度 // 注意：这里支持指针数组，比如len(*[2]int) == 2 lenTemp := len(arr) // 2) 拷贝数组 // 注意：这里支持指针数组，比如arr是*[2]int // 这里也就是为什么使用数组指针和数组本身的性能差异， // 使用数组指针这里的赋值是指针赋值，而使用数组这里是值复制当数据量大时性能差别还是比较明显 rangeArr := arr // 复制一份需要遍历的数组，注意这里的副本是与原数组没有任何联系 // 3) key/value // 注意：这里的key和value，定义在for外，也是\u0026i和\u0026v是固定的原因 var i, v int // 定义遍历需要接收的key和value变量 // for range的编译等同代码 for indexTemp := 0; indexTemp \u003c lenTemp; indexTemp++ { // 注意：这里支持指针数组赋值 valueTemp := rangeArr[indexTemp] // 数组支持语法糖 // 4) 拷贝赋值 // 注意：这里就是为什么for range中取\u0026i和\u0026v地址是固定的原因 i = indexTemp // 拷贝赋值 v = valueTemp // 拷贝赋值 fmt.Println(i, v) // original body } 数组遍历和切片遍历最主要的区别就是遍历副本，数组的副本与原数组没有任何关联只是值全部相同而已，而切片则是副本和原切片数共用同一个底层数组。 range能遍历【数组指针】而【不能】遍历切片指针，这得益于数值指针在赋值和len()函数上Go支持的【语法糖】转换使得range对数组指针同样适用。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 // range遍历指针数组时，会解引用数组指针拷贝副本遍历 package main import \"fmt\" func main() { var aa *[2]string = new([2]string) // 1) 语法糖1：赋值 //(*aa)[0] = \"a\" aa[0] = \"a\" // 语法糖 //(*aa)[1] = \"bb\" aa[1] = \"bb\"// 语法糖 // 2) 语法糖2：取值 // c := (*aa)[1] c := aa[1] // 语法糖 // 3) 语法糖3：求长度 // l := len(aa) // len(*aa) // 在Go中支持数组的指针相关的语法糖，所以导致使用数组和数组指针好像并没有多大的区别 // 比如数组指针aa能使用aa[0] = \"a\"这种形式赋值，也能使用len(aa)这种形式求长度， // 其他类型的指针则不支持 // 这些语法糖也导致了能使用range遍历数组指针 // range 拷贝 *aa 副本遍历 for i, s := range aa { // 当数组很大时，遍历数组指针是一个不错的选择 if i == 0 { aa[1] = \"cc\" } fmt.Println(i, s) } fmt.Println(aa) // Output: // 0 a // 1 cc // \u0026[a cc] } 验证数组遍历是值拷贝。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 {\tslice1 := [4]int{0,1,2,3} // 这里拷贝的是数组的副本，因此if条件成立不会影响值 for i, v := range slice1 { // [4]int if i == 1 { slice1[3] += 10 } fmt.Println(i, v) } fmt.Println(slice1) // Output: // 0 0 // 1 1 // 2 2 // 3 3 // [0 1 2 13] } { slice1 := [4]int{0,1,2,3} // 这里拷贝的是数组的指针，因此if条件成立会影响值 for i, v := range \u0026slice1 { // *[4]int if i == 1 { slice1[3] += 10 } fmt.Println(i, v) } // Output: // 0 0 // 1 1 // 2 2 // 3 13 } 迭代slice 遍历slice前会先获取slice的长度lenTemp来作为循环次数，循环体中，每次循环会先获取元素值。 如果for-range中接收index和value的话，则会对index和value进行一次赋值。 数组与数组指针的遍历过程与slice基本一致，但是也有区别，区别在于副本复制的是与原数组是一个完全不相干的数组。 for-range迭代slice，key为int，value为存储的元素类型。 1 2 3 4 5 slice1 := []int{0,1,2,3} for i, v := range slice1 { // 【int, int】 fmt.Println(i, v) // original body } 上面迭代切片代码等效于下面代码。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 // 1) 拷贝切片 // 注意：拷贝的切片与原切片共用了同一个底层数组 // 也需要注意，len和cap也拷贝元切片的值，因此for range修改不起作用， rangeSlice := slice1 // 2) 获取切片长度，也是遍历的次数 // 遍历的此时切片长度是固定的 lenTemp := len(rangeSlice) // 拿到需要遍历的切片总长度 // 3) key/value // 注意：这里的key和value，定义在for外，也是\u0026i和\u0026v是固定的原因 var i, v int // 定义遍历需要的key和value变量 // for range的编译等同代码 for indexTemp := 0; indexTemp \u003c lenTemp; indexTemp++ { valueTemp := rangeSlice[indexTemp] // 4) 拷贝赋值 // 注意：这里就是为什么for range中取\u0026i和\u0026v地址是固定的原因 i = indexTemp v = valueTemp fmt.Println(i, v) // original body } 由于循环开始前循环次数就已经确定了，所以循环过程中新添加的元素是无法遍历到的。 但是循环过程中修改后面还未循环的值，则会影响，这是由于在range循环前赋值的副本与原切片共用了一个底层数组导致的，所以能相互影响。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 { slice1 := []int{0,1,2,3} for i, v := range slice1 { // 【int, int】 if i == 1 { slice1[3] += 10 } fmt.Println(i, v) } // Output: // 0 0 // 1 1 // 2 2 // 3 13 } 迭代channel channel遍历是依次从channel中读取数据，读取前是不知道里面有多少个元素的。 如果channel中没有元素，则会阻塞等待，如果channel已被关闭，则会解除阻塞并退出循环。 for-range迭代channel，只能获取一个值，key为channel存储的元素类型。 1 2 3 4 5 6 c := make(chan int) // range遍历chan for v := range c { // 【int】 fmt.Println(v) // original body } 上面迭代channel代码等效于下面代码。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // 这里是\u0026v为什么都是同一个地址的原因 var v int // v其实就是固定的一个变量 for { // 注意如果不关闭channel这里会一直阻塞 // 我们知道 \u003c- 符号会调用相关的函数，如果chan关闭了会返回false退出循环 value_temp, ok := \u003c- c\t// 有数据则会直接返回数据，没有数据则会阻塞，通过chan的学习知道阻塞意味着 // 当前goroutine被调离调度循环等待数据到来被重新调起 // ok = false，通道已经关闭。 if !ok { break } // 2) 拷贝值 v = value_temp fmt.Println(v) // original body } 编译后的伪代码，与上面等价。关于chanrecv2()在channel中介绍。 1 2 3 4 5 6 7 8 9 10 11 12 13 var v int for { ok := chanrecv2(c, \u0026value_temp) if !ok { break } v = index_temp fmt.Println(v) // original body } 注意： 使用for-range遍历channel时只能获取一个返回值。 【for-range \u003c-ch】情况，该情况可以用在 【channel map、channel array|*array、channel slice、channel string】。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 func chanTs2() { ch := make(chan map[int]int) // 注意：这里是 \u003c-ch，前面的是 ch for k, v := range \u003c-ch { println(k, v) } // --------------------------- // as 等价于下面代码 // --------------------------- // 注意：这里只会执行一次 a := \u003c-ch for k, v := range a { println(k, v) } } 迭代map for-range迭代map，key为map的键，value为map的值。 1 2 3 4 5 map1 := map[string]string{\"one\":\"1\", \"tow\":\"2\"} for i, v := range map1 { // 【string, string】 fmt.Println(i, v) // original body } 上面迭代map代码等效于下面代码。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 // 1) key/value // 这里也是为什么\u0026i和\u0026v是一个固定的地址的原因 // 定义遍历所需要的key和value变量 var i, v string // 2) map_iteration_struct // map_iteration_struct是一个hiter结构体，存储着map的遍历相关信息 var hiter map_iteration_struct\t// mapiterinit 初始化map参看runtime/map.go文件 // hiter是一个哈希迭代结构，mapiternext迭代下一个哈希 for mapiterinit(type, range, \u0026hiter); hiter.key != nil; mapiternext(\u0026hiter) { index_temp := *hiter.key value_temp := *hiter.val // 3) 拷贝数据 i = index_temp v = value_temp fmt.Println(i, v) // original body } 遍历map时没有指定循环次数，循环体与遍历slice类似。由于map底层实现与slice不同，map底层使用 hash表实现的。 插入数据位置是随机的，所以遍历过程中新插入的数据不能保证遍历到。 以下相关的函数在map篇中还会详细的讨论。 type hiter struct。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 // A hash iteration structure. // If you modify hiter, also change cmd/compile/internal/reflectdata/reflect.go // and reflect/value.go to match the layout of this structure. type hiter struct { // 当前遍历的key地址 key unsafe.Pointer // Must be in first position. Write nil to indicate iteration end (see cmd/compile/internal/walk/range.go). // 当前遍历的elem地址 elem unsafe.Pointer // Must be in second position (see cmd/compile/internal/walk/range.go). // 当前map的类型结构 t *maptype // 当前map的内存结构 h *hmap\t// 当前map的常规桶地址 buckets unsafe.Pointer // bucket ptr at hash_iter initialization time // 当前正在遍历的桶 bptr *bmap // current bucket 当前存储桶 // h.extra.overflow overflow *[]*bmap // keeps overflow buckets of hmap.buckets alive\t// h.extra.oldoverflow oldoverflow *[]*bmap // keeps overflow buckets of hmap.oldbuckets alive // 开始遍历的桶号，随机的，用于开始遍历的起点以及结束遍历的终点 startBucket uintptr // bucket iteration started at // tophash偏移值，在[0,7]中随机生成的值，用于后续 i + offset \u0026 7 用作偏移量 offset uint8 // intra-bucket offset to start from during iteration (should be big enough to hold bucketCnt-1) // 当前遍历已过最大桶(1 \u003c\u003c B)时被设置为true wrapped bool // already wrapped around from end of bucket array to beginning // 初始化时桶的数量 1 \u003c\u003c B B uint8 // 当前桶遍历的索引，默认值从0开始，该值配合offset遍历tophash，i + offset \u0026 7 i uint8 // 初始化时是startBucket的值 // 1. bptr == nil时bucket存储需要遍历的桶号 // 2. bptr != nil时bucket下个桶的桶号 bucket uintptr // 存储的是当前迭代器的桶号 // noCheck.不需要检查，数据在bptr桶里面 // 其他需要检查 checkBucket uintptr // 需要检查的桶号 } mapiterinit()。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 // mapiterinit initializes the hiter struct used for ranging over maps. // The hiter struct pointed to by 'it' is allocated on the stack // by the compilers order pass or on the heap by reflect_mapiterinit. // Both need to have zeroed hiter since the struct contains pointers. // mapiterinit 初始化用于在map上的 hiter 结构 // 'it' 指向的 hiter 结构由编译器顺序传递在堆栈上分配，或者由 reflect_mapiterinit 在堆上分配。 // 由于结构包含指针，因此两者都需要将 hiter 归零。 // // 迭代初始化 // t *maptype：当前map的元素类型 // h *hmap：当前map的内存结构 // it *hiter：迭代器结构 func mapiterinit(t *maptype, h *hmap, it *hiter) { if raceenabled \u0026\u0026 h != nil { callerpc := getcallerpc() racereadpc(unsafe.Pointer(h), callerpc, abi.FuncPCABIInternal(mapiterinit)) } it.t = t // 存储当前map的类型结构地址 if h == nil || h.count == 0 { // 如果当前map为空直接返回 return } if unsafe.Sizeof(hiter{})/goarch.PtrSize != 12 { // 判断hiter结构是否正确 throw(\"hash_iter size incorrect\") // see cmd/compile/internal/reflectdata/reflect.go } it.h = h // 存储当前map的内存结构地址 // grab snapshot of bucket state it.B = h.B // 记录当前map的桶数量 it.buckets = h.buckets // 记录当前map的常规桶地址 if t.bucket.ptrdata == 0 { // 判断当前桶类型的ptrdata字段，该字段为0说明存储的都是标量数据 // 分配当前切片并记住指向当前切片和旧切片的指针。 // 即使表增长 and/or 在我们迭代时将溢出桶添加到表中，这也会保留所有相关的溢出桶。 h.createOverflow() // 创建溢出桶 it.overflow = h.extra.overflow it.oldoverflow = h.extra.oldoverflow } // decide where to start // 决定从哪里开始 r := uintptr(fastrand()) // 生成随机数决定从哪里开始 // bucketCntBits = 3 if h.B \u003e 31-bucketCntBits { // 如果当前的桶数 \u003e 31 - 3 r += uintptr(fastrand()) \u003c\u003c 31 } it.startBucket = r \u0026 bucketMask(h.B) // 确定开始的桶号，这里也是for range随机的原因 it.offset = uint8(r \u003e\u003e h.B \u0026 (bucketCnt - 1)) // 开始的tophash位置处 // iterator state it.bucket = it.startBucket // 记住我们有一个迭代器。 // 可以与另一个 mapiterinit() 并发运行。\t// iterator = 1 存在桶正在在使用迭代器标志 // oldIterator = 2 存在旧桶正在使用迭代器标志 // 设置正在迭代的标志位 if old := h.flags; old\u0026(iterator|oldIterator) != iterator|oldIterator { atomic.Or8(\u0026h.flags, iterator|oldIterator) // 原子锁设置hmap的flags参数标志正在使用迭代器 } mapiternext(it) } mapiternext()。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 // 向下寻找下一个key func mapiternext(it *hiter) { h := it.h // 获取当前hmap内存结构 if raceenabled { callerpc := getcallerpc() racereadpc(unsafe.Pointer(h), callerpc, abi.FuncPCABIInternal(mapiternext)) } // 当前有hashWriting操作时，比如m[k]=v或delete函数时都会报错 if h.flags\u0026hashWriting != 0 { throw(\"concurrent map iteration and map write\") } t := it.t // 获取map的结构 // 本次需要遍历的桶号 bucket := it.bucket // 当前的桶号 // 本次需要遍历的桶，如果为nil说明需要去bucket寻找 b := it.bptr // 当前存储桶 // 本次应该遍历的索引 i := it.i // 遍历索引默认0 checkBucket := it.checkBucket // 遍历一遍当前桶及其溢出桶直到b=nil next: // 当前桶遍历完时，切换到下一个桶去遍历 if b == nil { // 当前遍历的桶和开始的桶相等 并且 已经遍历过了最大桶数，说明遍历了一圈了 if bucket == it.startBucket \u0026\u0026 it.wrapped { // 结束遍历的条件 // end of iteration it.key = nil it.elem = nil return } // h.growing() 当前正在扩容中 if h.growing() \u0026\u0026 it.B == h.B { // h.growing()当前map正处于扩容状态 // 迭代器是在增长过程中启动的，但增长尚未完成。 // 如果我们查看的bucket尚未填充（即，旧bucket未被清空），那么我们需要遍历旧buckets，只返回将迁移到此bucket的buckets。 oldbucket := bucket \u0026 it.h.oldbucketmask() // 旧桶的桶号 b = (*bmap)(add(h.oldbuckets, oldbucket*uintptr(t.bucketsize)))\t// 获取桶位置 // 当前桶的tophash[0]不是2|3|4时，说明数据没有被迁移 if !evacuated(b) {\tcheckBucket = bucket // 需要检查的桶号 } else { // 说明数据在新桶里面，数据已被迁移 b = (*bmap)(add(it.buckets, bucket*uintptr(t.bucketsize)))\tcheckBucket = noCheck } } else { // 1.没有扩容 2.扩容了但是it.B != h.B b = (*bmap)(add(it.buckets, bucket*uintptr(t.bucketsize))) // 新桶 checkBucket = noCheck } bucket++ // 桶号加一 // 当前桶号等于最大桶号 if bucket == bucketShift(it.B) { // bucketShift(it.B) 等于 1 \u003e\u003e B bucket = 0 // 标记从0号桶开始 it.wrapped = true // 标记已经过了最大桶了 } i = 0 // 新桶重置索引为0 } // 遍历当前桶的所有元素\tbucketCnt = 8 // 从当前桶遍历数据 for ; i \u003c bucketCnt; i++ { offi := (i + it.offset) \u0026 (bucketCnt - 1) // 根据it.offset偏移量开始随机遍历元素[0,7] // b.tophash[offi] \u003c= 1 或 evacuatedEmpty = 4 表示桶数据为空 if isEmpty(b.tophash[offi]) || b.tophash[offi] == evacuatedEmpty { // 如果当前位置为0或1或4表示桶为空 continue } k := add(unsafe.Pointer(b), dataOffset+uintptr(offi)*uintptr(t.keysize)) // 偏移到当前key位置 if t.indirectkey() { // 判断当前key存储是否是已指针存储而不是存储的key本身 k = *((*unsafe.Pointer)(k)) } // 偏移到当前elem位置 e := add(unsafe.Pointer(b), dataOffset+bucketCnt*uintptr(t.keysize)+uintptr(offi)*uintptr(t.elemsize)) // checkBucket != noCheck 数据在旧桶 并且 !h.sameSizeGrow() 翻倍扩容 // 需要验证桶时，旧桶存在数据 if checkBucket != noCheck \u0026\u0026 !h.sameSizeGrow() { // 存在没有迁移完的旧桶时，去检查旧桶 // t.reflexivekey() 为true表示 k == k 始终成立 // t.reflexivekey() || t.key.equal(k, k) -\u003e k == k 始终成立情况 if t.reflexivekey() || t.key.equal(k, k) { // 如果oldbucket中的项不是针对迭代中的当前新bucket，请跳过它 hash := t.hasher(k, uintptr(h.hash0)) if hash\u0026bucketMask(it.B) != checkBucket { // 需要跳过的情况 continue } } else { // k == k 不是始终成立 // b.tophash[offi]\u00261 的最低位 参看数据迁移部分的去向 if checkBucket\u003e\u003e(it.B-1) != uintptr(b.tophash[offi]\u00261) { continue } } } // 将找到的k和e保存到hiter中 // evacuatedX = 2、evacuatedY = 3 // b.tophash[offi] != evacuatedX \u0026\u0026 b.tophash[offi] != evacuatedY 存在有效数据 // !(t.reflexivekey() || t.key.equal(k, k))\t-\u003e x == x 不是始终成立 if (b.tophash[offi] != evacuatedX \u0026\u0026 b.tophash[offi] != evacuatedY) || !(t.reflexivekey() || t.key.equal(k, k)) { // 这是需要的数据，我们可以返回它 // 或 // key!=key，因此无法删除或更新条目，因此我们可以只返回它 // 这对我们来说很幸运，因为当key!=key关键是我们找不到它 it.key = k if t.indirectelem() { e = *((*unsafe.Pointer)(e)) } it.elem = e } else { // 数据被迁移到其他地方了 // 自从迭代器启动以来，哈希表一直在增长 // 这个key的数据现在在其他地方 // 检查数据的当前哈希表 // 此代码处理以下情况： //\t已被删除、更新或删除并重新插入 //\t注意：我们需要重新标记密钥，因为它可能已更新为equal()，但不是相同的key（例如+0.0 vs-0.0） rk, re := mapaccessK(t, h, k) // 根据key去寻找相应的数据，可能是新桶也可能是旧桶 // 每寻找到，可能key已被删除 if rk == nil { continue // key has been deleted } it.key = rk it.elem = re } it.bucket = bucket // 回写桶号 // 记录当前正在遍历的桶 if it.bptr != b { // avoid unnecessary write barrier; see issue 14921 it.bptr = b\t// 避免不必要的写入障碍 } it.i = i + 1 // i加一 it.checkBucket = checkBucket return } b = b.overflow(t) // 如果上面桶遍历完接到去后面桶找 i = 0 goto next } mapaccessK()。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 // returns both key and elem. Used by map iterator // 根据key找到相应的值 func mapaccessK(t *maptype, h *hmap, key unsafe.Pointer) (unsafe.Pointer, unsafe.Pointer) { if h == nil || h.count == 0 { return nil, nil } hash := t.hasher(key, uintptr(h.hash0)) // 当前key生成的hash值 m := bucketMask(h.B) // (1 \u003c\u003c B) - 1 b := (*bmap)(add(h.buckets, (hash\u0026m)*uintptr(t.bucketsize))) // key存储的当前桶 // 是否在扩容中 if c := h.oldbuckets; c != nil { if !h.sameSizeGrow() {\t// 翻倍扩容 // There used to be half as many buckets; mask down one more power of two. m \u003e\u003e= 1 } // 去旧桶里面查看数据是否被迁移了 oldb := (*bmap)(add(c, (hash\u0026m)*uintptr(t.bucketsize)))\t// 数据没有被迁移 tophash[0] != [2,3,4] if !evacuated(oldb) { b = oldb } } top := tophash(hash) // tophash bucketloop: // 遍历当前桶及溢出桶寻找 key for ; b != nil; b = b.overflow(t) { for i := uintptr(0); i \u003c bucketCnt; i++ { if b.tophash[i] != top { if b.tophash[i] == emptyRest { // emptyRest = 0 break bucketloop } continue } // 找到了key // 1. 可能是hash冲突则还需要向后去查找 // 2. 确实找到了key直接返回即可 k := add(unsafe.Pointer(b), dataOffset+i*uintptr(t.keysize)) if t.indirectkey() { k = *((*unsafe.Pointer)(k)) } // key匹配成功 if t.key.equal(key, k) { e := add(unsafe.Pointer(b), dataOffset+bucketCnt*uintptr(t.keysize)+i*uintptr(t.elemsize)) if t.indirectelem() { e = *((*unsafe.Pointer)(e)) } return k, e } } } return nil, nil } 总结 for-range不支持【字符串指针】、【切片指针】、【map指针】、【channel指针】，但支持【数组指针】遍历。 ",
  "wordCount" : "2902",
  "inLanguage": "zh",
  "image": "https://heliu.site/favicon-32x32.png","datePublished": "2019-10-05T00:00:00Z",
  "dateModified": "2020-07-20T00:00:00Z",
  "author":[{
    "@type": "Person",
    "name": "helium"
  }],
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://heliu.site/posts/golang/process/range/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Helium",
    "logo": {
      "@type": "ImageObject",
      "url": "https://heliu.site/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://heliu.site/" accesskey="h" title="Blog (Alt + H)">
                <img src="https://heliu.site/helium.png" alt="" aria-label="logo"
                    height="35">Blog</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://heliu.site/" title="主页">
                    <span>Home</span>
                </a>
            </li>
            <li>
                <a href="https://heliu.site/posts" title="文章">
                    <span>Article</span>
                </a>
            </li>
            <li>
                <a href="https://heliu.site/archives" title="时间轴">
                    <span>Archive</span>
                </a>
            </li>
            <li>
                <a href="https://heliu.site/tags/" title="标签">
                    <span>Tag</span>
                </a>
            </li>
            <li>
                <a href="https://heliu.site/search/" title="搜索 (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
            <li>
                <a href="https://heliu.site/support" title="打赏">
                    <span>🫶Help</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">


<article class="post" autonumbering>
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://heliu.site/">主页</a>&nbsp;»&nbsp;<a href="https://heliu.site/posts/">Article</a>&nbsp;»&nbsp;<a href="https://heliu.site/posts/golang/">Golang 合集</a>&nbsp;»&nbsp;<a href="https://heliu.site/posts/golang/process/">第3章 流程控制</a></div>
    <h1 class="post-title entry-hint-parent">
      流程控制(range迭代)
    </h1>
    <div class="post-description">
      💥本文章所有相关go代码参考自go 1.18&#43;版本
    </div>
    <div class="post-meta">










<span class="x-post-meta-item"><svg t="1720837714681" class="icon" viewBox="0 0 1084 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="7520" width="200" height="200"><path d="M123.47509 1023.984942a123.565437 123.565437 0 0 1-123.505206-123.32451V243.863302A123.565437 123.565437 0 0 1 123.47509 120.568908h171.630374V26.06529a26.050232 26.050232 0 0 1 52.070349 0v94.503618h377.592848V26.06529a26.050232 26.050232 0 0 1 52.100464 0v94.503618h183.797189A123.565437 123.565437 0 0 1 1084.171519 243.863302v656.79713A123.565437 123.565437 0 0 1 960.666314 1023.984942H123.47509z m-71.404741-123.32451A71.434857 71.434857 0 0 0 123.47509 971.974825h837.191224a71.434857 71.434857 0 0 0 71.404741-71.314393V442.326922l-946.361273-3.824716a25.598494 25.598494 0 0 1-5.84248-0.692665l-27.796953-6.444798v469.295689zM123.47509 172.579025a71.434857 71.434857 0 0 0-71.404741 71.284277v149.736133l27.796953-6.444797a26.080348 26.080348 0 0 1 5.902712-0.662549l946.301041 3.824716V243.863302a71.404741 71.404741 0 0 0-71.404741-71.284277h-180.183284l-6.173754 12.859479a26.200812 26.200812 0 0 1-23.490383 14.786895 26.261043 26.261043 0 0 1-23.520499-14.786895l-6.173754-12.859479H350.819834l-6.173754 12.859479a26.200812 26.200812 0 0 1-23.490383 14.786895 26.230928 26.230928 0 0 1-23.520499-14.786895l-6.173755-12.859479H123.47509z m156.150814 578.827128a26.050232 26.050232 0 0 1-26.050232-25.990001c0-14.335157 11.68496-26.020116 26.050232-26.020116h521.697312c14.365273 0 26.050232 11.68496 26.050233 26.020116a26.050232 26.050232 0 0 1-26.050233 25.990001H279.625904z" fill="#3D3F42" p-id="7521"></path></svg><span>2019-10-05</span></span>&nbsp;<span class="x-post-meta-item"><svg t="1720839329181" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="14106" width="200" height="200"><path d="M699.270662 190.485379c-0.411369 0-0.821715 0.011256-1.227967 0.032746H507.034407a23.041786 23.041786 0 0 0-1.221828-0.031723c-12.779048 0-23.140023 10.359952-23.140023 23.139 0 12.781094 10.360975 23.141046 23.140023 23.141046v0.032746h193.458083v-0.032746c12.780071 0 23.141046-10.359952 23.141047-23.141046 0-12.780071-10.360975-23.140023-23.141047-23.140023zM979.215516 724.005508c0-142.090159-115.186416-257.277598-257.277598-257.277598-72.245418 0-137.532353 29.777187-184.262654 77.725223l45.868677 31.474852c36.227086-33.873482 84.882226-54.617945 138.393977-54.617945 111.945605 0 202.696492 90.750887 202.696492 202.695468h-43.01263l70.331835 104.289228 70.331835-104.289228H979.215516z" fill="" p-id="14107"></path><path d="M748.885664 588.843132c0-14.881942-12.06785-26.945699-26.947746-26.945698-14.883989 0-26.947745 12.063757-26.947745 26.945698v135.164423c0 14.879895 12.063757 26.945699 26.947745 26.945699h107.786889c14.881942 0 26.945699-12.063757 26.945698-26.945699s-12.063757-26.945699-26.945698-26.945699h-80.839143V588.843132zM721.937918 926.702c-111.947651 0-202.696492-90.74884-202.696492-202.696492 0-0.144286 0.004093-0.285502 0.004094-0.429788h43.004443l-70.330812-104.289228-70.331835 104.289228h43.075051c0 0.144286-0.00307 0.285502-0.00307 0.429788 0 142.091182 115.187439 257.279644 257.278621 257.279645 72.241324 0 137.530306-29.77821 184.260607-77.727269l-45.86663-31.474852c-36.227086 33.873482-84.884272 54.618968-138.393977 54.618968zM694.633039 423.38066c-1.354857-11.487635-11.120268-20.400632-22.972201-20.400632H206.362486c-12.780071 0-23.140023 10.359952-23.140023 23.138999 0 12.781094 10.359952 23.141046 23.140023 23.141047H596.949252c30.209022-13.81668 63.104223-22.76754 97.683787-25.879414zM438.548616 623.143333H206.362486c-12.780071 0-23.140023 10.358929-23.140023 23.140023 0 12.780071 10.359952 23.140023 23.140023 23.140023h219.956598a298.463626 298.463626 0 0 1 12.229532-46.280046zM506.934123 513.062192H206.362486c-12.780071 0-23.140023 10.359952-23.140023 23.139 0 12.781094 10.359952 23.140023 23.140023 23.140023H469.936487a302.241672 302.241672 0 0 1 36.997636-46.279023z" fill="" p-id="14108"></path><path d="M442.765661 835.277778a298.531164 298.531164 0 0 1-14.365173-46.150087H146.542052v-0.065491c-33.036417 0-59.81941-26.78197-59.81941-59.819411V329.36031h704.907545v100.905154a298.561863 298.561863 0 0 1 46.150086 14.996552V194.619536h-0.162706c0-53.422723-43.307342-96.728018-96.730065-96.728018h-68.89409V84.418668c0-33.037441-26.782993-59.81941-59.81941-59.81941v-0.361227h-18.87079v0.032745c-33.038464 0-59.820434 26.78197-59.820433 59.819411 0 0.109494 0.008186 0.218988 0.008186 0.328481h-0.339738v13.47285H345.203648V84.418668c0-33.037441-26.782993-59.81941-59.819411-59.81941v-0.361227h-18.872836v0.032745c-33.036417 0-59.81941 26.78197-59.81941 59.819411 0 0.109494 0.007163 0.218988 0.008186 0.328481h-0.339737v13.47285h-69.189826c-53.4217 0-96.729042 43.306318-96.729041 96.728018 0 1.701758 0.045025 3.39226 0.132006 5.071505v533.785166a98.051153 98.051153 0 0 0-0.132006 5.071506c0 53.4217 43.307342 96.728018 96.729041 96.728018v0.001023h305.595047zM86.723665 204.056466c0-33.037441 26.782993-59.81941 59.819411-59.819411 0.044002 0 0.086981 0.00307 0.130983 0.00307v-0.068561h105.968473V94.874811h0.032746a22.807449 22.807449 0 0 1-0.032746-1.215688c0-12.779048 10.360975-23.140023 23.140023-23.140023s23.140023 10.360975 23.140023 23.140023c0 0.408299-0.010233 0.812505-0.031722 1.215688h0.031722v49.297776h280.508696V94.874811h0.032745a22.807449 22.807449 0 0 1-0.032745-1.215688c0-12.779048 10.361999-23.140023 23.140023-23.140023 12.780071 0 23.141046 10.360975 23.141046 23.140023 0 0.408299-0.011256 0.812505-0.032746 1.215688h0.032746v49.297776h106.10048v0.065492c33.035394 0 59.818387 26.780947 59.818387 59.81941h0.130983V283.080264H86.723665v-79.023798z" fill="" p-id="14109"></path></svg><span>2020-07-20</span></span>&nbsp;<span class="x-post-meta-item"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2" fill="none"
     stroke-linecap="round" stroke-linejoin="round" class="feather feather-file-text" style="user-select: text;">
    <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z" style="user-select: text;"></path>
    <polyline points="14 2 14 8 20 8" style="user-select: text;"></polyline>
    <line x1="16" y1="13" x2="8" y2="13" style="user-select: text;"></line>
    <line x1="16" y1="17" x2="8" y2="17" style="user-select: text;"></line>
    <polyline points="10 9 9 9 8 9" style="user-select: text;"></polyline>
</svg><span>2902字</span></span>&nbsp;<span class="x-post-meta-item"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2" fill="none"
     stroke-linecap="round" stroke-linejoin="round">
    <path stroke="none" d="M0 0h24v24H0z" fill="none"></path>
    <circle cx="12" cy="12" r="9"></circle>
    <polyline points="12 7 12 12 15 15"></polyline>
</svg><span>14分钟</span></span>&nbsp;<span class="x-post-meta-item"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2" fill="none"
     stroke-linecap="round" stroke-linejoin="round">
    <path stroke="none" d="M0 0h24v24H0z" fill="none"></path>
    <circle cx="12" cy="7" r="4"></circle>
    <path d="M6 21v-2a4 4 0 0 1 4 -4h4a4 4 0 0 1 4 4v2"></path>
</svg><span>helium</span></span>
      <span class="x-post-meta-item">
        &nbsp;<svg t="1720840393161" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="18680" width="200" height="200"><path d="M995.125144 559.61812l-415.998603-415.998602A52.986489 52.986489 0 0 0 541.413335 127.99957H338.847348c-3.166656-26.559911-9.286635-51.046495-17.999939-71.333094C299.734146 7.333309 271.154242 0 256.00096 0c-13.939953 0-40.439864 6.339979-61.259794 48.806503-10.473298 21.366595-17.946606 48.966502-21.573261 79.193067H53.334974a53.393154 53.393154 0 0 0-53.333154 53.333154v360.078791a52.986489 52.986489 0 0 0 15.619948 37.713206l415.998602 415.998603a53.333154 53.333154 0 0 0 75.426413 0l26.286579-26.293245 26.286578 26.293245a53.426487 53.426487 0 0 0 16.719944 11.333295 21.333262 21.333262 0 0 0 36.079879 11.293295l382.705381-382.705381a53.399821 53.399821 0 0 0 0-75.426413z m-762.070774-491.998347C241.494342 50.373164 250.667645 42.666523 256.00096 42.666523c5.99998 0 16.573278 9.639968 25.646581 30.806564 6.493312 15.159949 11.333295 33.999886 14.146619 54.526483H216.16776c3.206656-23.419921 9.013303-44.359851 16.88661-60.41313z m243.819181 897.330319a10.666631 10.666631 0 0 1-15.079949 0l-415.998603-415.998603A10.573298 10.573298 0 0 1 42.668343 541.411515V181.332724a10.666631 10.666631 0 0 1 10.666631-10.666631h245.332509c0 47.853173-10.373298 92.15969-27.066575 115.632945-5.926647 8.326639-16.566611 14.186619-22.306592 16.113279C204.041135 314.752276 170.667913 356.218803 170.667913 405.331972c0 58.813136 47.853173 106.666308 106.666309 106.666308s106.666308-47.853173 106.666308-106.666308c0-47.086508-30.666564-87.139707-73.079754-101.246327C330.060711 272.705751 341.334007 223.692582 341.334007 170.666093h72.079758a10.573298 10.573298 0 0 1 7.539974 3.126656l415.998603 415.998603a10.666631 10.666631 0 0 1 0 15.079949zM341.334007 405.331972a63.999785 63.999785 0 1 1-63.999785-63.999785 64.073118 64.073118 0 0 1 63.999785 63.999785z m263.539114 559.61812a10.666631 10.666631 0 0 1-15.079949 0L563.499927 938.663513l303.625647-303.61898a53.399821 53.399821 0 0 0 0-75.426413L478.16688 170.666093h63.246455a10.573298 10.573298 0 0 1 7.539974 3.126656l415.998603 415.998603c0.239999 0.239999 0.466665 0.486665 0.666664 0.746664l0.086667 0.106666a10.666631 10.666631 0 0 1 0 13.373289l-0.086667 0.106666c-0.213333 0.259999-0.439999 0.506665-0.666664 0.746664z" fill="#5C5C66" p-id="18681"></path></svg>
        <ul class="post-tags-meta" style="display: inline-block;font-size: 14px;">
            <a href="https://heliu.site/tags/golang/" target="_blank" rel="noopener">Golang</a>
            <a href="https://heliu.site/tags/%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/" target="_blank" rel="noopener">流程控制</a>
        </ul>
      </span>
      
      <span id="busuanzi_container_page_pv" class="x-post-meta-item">
        &nbsp;<svg t="1720844685710" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="27237" width="200" height="200"><path d="M739.754667 574.08c-121.386667 45.610667-208.469333 169.813333-208.64 316.16 0 33.408 4.693333 65.493333 13.141333 95.914667H94.122667c-26.453333-43.52-41.685333-91.946667-41.685334-143.189334 0-185.173333 192.896-335.104 430.805334-335.104 96.256 0 184.832 24.746667 256.512 66.218667z m-280.490667-114.986667a214.869333 214.869333 0 0 1-214.869333-215.04A215.04 215.04 0 0 1 459.264 28.842667a215.04 215.04 0 0 1 215.04 215.210666 215.04 215.04 0 0 1-215.04 215.04zM974.506667 641.28c9.856 0 17.834667 7.466667 17.834666 16.64v59.989333c-0.341333 8.789333-7.850667 15.786667-17.28 16.085334-9.856 0.341333-18.176-6.826667-18.517333-16.085334v-20.053333l-99.114667 91.093333-0.256 0.256a18.474667 18.474667 0 0 1-14.848 4.352h-0.768a18.176 18.176 0 0 1-9.344-4.608l-0.938666-0.981333-85.930667-80.042667-123.562667 115.072a18.773333 18.773333 0 0 1-25.216 0 15.786667 15.786667 0 0 1 0-23.466666l136.149334-126.848 0.725333-0.597334a18.645333 18.645333 0 0 1 24.362667 0.512l87.253333 81.237334 86.058667-79.232h-21.248c-9.386667-0.298667-16.938667-7.338667-17.28-16.085334-0.341333-9.173333 7.381333-16.896 17.28-17.237333h64.64z m-367.146667 240h48.128c8.874667 0 16.042667 7.168 16.042667 16.042667v72.192a16.042667 16.042667 0 0 1-16.042667 16.042666h-48.128a16.042667 16.042667 0 0 1-16.042667-16.042666v-72.192c0-8.874667 7.210667-16.042667 16.042667-16.042667z m110.805333-106.666667h48.128c8.874667 0 16.042667 7.168 16.042667 16.042667v178.858667a16.042667 16.042667 0 0 1-16.042667 16.042666h-48.128a16.042667 16.042667 0 0 1-16.042666-16.042666v-178.858667c0-8.874667 7.168-16.042667 16.042666-16.042667z m106.538667 80h48.128c8.874667 0 16.042667 7.168 16.042667 16.042667v99.413333a16.042667 16.042667 0 0 1-16.042667 16.042667H824.746667a16.042667 16.042667 0 0 1-16.042667-16.042667v-99.413333c0-8.874667 7.168-16.042667 16.042667-16.042667z m110.165333-80h48.128c8.874667 0 16.042667 7.168 16.042667 16.042667v179.413333a16.042667 16.042667 0 0 1-16.042667 16.042667h-48.128a16.042667 16.042667 0 0 1-16.042666-16.042667v-179.413333c0-8.874667 7.210667-16.042667 16.042666-16.042667z" fill="#999999" p-id="27238"></path></svg>
        <span id="busuanzi_value_page_pv"></span>
      </span>

</div>
  </header> <aside id="toc-container" class="toc-container wide">
    <div class="toc">
        <details  open>
            <summary accesskey="c" title="(Alt + C)">
                <span class="details">目录</span>
            </summary>

            <div class="inner"><ul>
                    <li>
                        <a href="#%e8%bf%ad%e4%bb%a3string" aria-label="迭代string">迭代<code>string</code></a></li>
                    <li>
                        <a href="#%e8%bf%ad%e4%bb%a3array" aria-label="迭代array">迭代<code>array</code></a></li>
                    <li>
                        <a href="#%e8%bf%ad%e4%bb%a3slice" aria-label="迭代slice">迭代<code>slice</code></a></li>
                    <li>
                        <a href="#%e8%bf%ad%e4%bb%a3channel" aria-label="迭代channel">迭代<code>channel</code></a></li>
                    <li>
                        <a href="#%e8%bf%ad%e4%bb%a3map" aria-label="迭代map">迭代<code>map</code></a></li>
                    <li>
                        <a href="#%e6%80%bb%e7%bb%93" aria-label="总结">总结</a>
                    </li>
                </ul>
            </div>
        </details>
    </div>
</aside>
<script>
    let activeElement;
    let elements;
    window.addEventListener('DOMContentLoaded', function (event) {
        checkTocPosition();

        elements = document.querySelectorAll('h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]');
         
         activeElement = elements[0];
         const id = encodeURI(activeElement.getAttribute('id')).toLowerCase();
         document.querySelector(`.inner ul li a[href="#${id}"]`).classList.add('active');
     }, false);

    window.addEventListener('resize', function(event) {
        checkTocPosition();
    }, false);

    window.addEventListener('scroll', () => {
        
        activeElement = Array.from(elements).find((element) => {
            if ((getOffsetTop(element) - window.pageYOffset) > 0 && 
                (getOffsetTop(element) - window.pageYOffset) < window.innerHeight/2) {
                return element;
            }
        }) || activeElement

        elements.forEach(element => {
             const id = encodeURI(element.getAttribute('id')).toLowerCase();
             if (element === activeElement){
                 document.querySelector(`.inner ul li a[href="#${id}"]`).classList.add('active');
             } else {
                 document.querySelector(`.inner ul li a[href="#${id}"]`).classList.remove('active');
             }
         })
     }, false);

    const main = parseInt(getComputedStyle(document.body).getPropertyValue('--article-width'), 10);
    const toc = parseInt(getComputedStyle(document.body).getPropertyValue('--toc-width'), 10);
    const gap = parseInt(getComputedStyle(document.body).getPropertyValue('--gap'), 10);

    function checkTocPosition() {
        const width = document.body.scrollWidth;

        if (width - main - (toc * 2) - (gap * 4) > 0) {
            document.getElementById("toc-container").classList.add("wide");
        } else {
            document.getElementById("toc-container").classList.remove("wide");
        }
    }

    function getOffsetTop(element) {
        if (!element.getClientRects().length) {
            return 0;
        }
        let rect = element.getBoundingClientRect();
        let win = element.ownerDocument.defaultView;
        return rect.top + win.pageYOffset;   
    }
</script>
  <div class="post-content"><h2 id="迭代string">迭代<code>string</code><a hidden class="anchor" aria-hidden="true" href="#迭代string">#</a></h2>
<ol>
<li><code>range</code>迭代<code>string</code>，<code>key</code>为<code>int</code>类型，<code>value</code>为<code>rune</code>类型。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="nx">str</span> <span class="o">:=</span> <span class="s">&#34;hello world! Gopher&#34;</span>
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">str</span> <span class="p">{</span> <span class="c1">// 【int, rune】
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span> <span class="nx">v</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// original body
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ol start="2">
<li>上面迭代字符串代码等效于下面代码。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// 1) 获取字符串长度
</span></span></span><span class="line"><span class="cl"><span class="c1">// 字符串总长度，该长度是字节数量用于遍历字符串的总长度
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">lenTemp</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">str</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 下一次遍历的下标位置，这是由于utf8是不定长编码需要记录上一次处理后的位置
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">var</span> <span class="nx">nextIndexTemp</span> <span class="kt">int</span>	
</span></span><span class="line"><span class="cl"><span class="c1">// 2) key/value
</span></span></span><span class="line"><span class="cl"><span class="c1">// 注意：这里的key和value，定义在for外，也是&amp;i和&amp;v是固定的原因
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">var</span> <span class="nx">i</span> <span class="kt">int</span>       <span class="c1">// 遍历用到的索引，也就是index
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">var</span> <span class="nx">v</span> <span class="kt">rune</span>      <span class="c1">// 遍历出来存储的值，也就是value
</span></span></span><span class="line"><span class="cl"><span class="c1">// 遍历字符串
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">for</span> <span class="nx">indexTemp</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">indexTemp</span> <span class="p">&lt;</span> <span class="nx">lenTemp</span><span class="p">;</span> <span class="nx">indexTemp</span> <span class="p">=</span> <span class="nx">nextIndexTemp</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 获取开头8bit的大小，因为该8bit能区分存储的是ASCII 1bit还是多个使用utf8编码的字节
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">valueTemp</span> <span class="o">:=</span> <span class="nb">rune</span><span class="p">(</span><span class="nx">str</span><span class="p">[</span><span class="nx">indexTemp</span><span class="p">])</span>	
</span></span><span class="line"><span class="cl">    <span class="c1">// utf8.RuneSelf = 0x80 = 128 单字符最大值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// ASCII码字符占1字节，该条件满足说明，存储的是ASCII码占用一个字节
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nx">valueTemp</span> <span class="p">&lt;</span> <span class="nx">utf8</span><span class="p">.</span><span class="nx">RuneSelf</span> <span class="p">{</span>		
</span></span><span class="line"><span class="cl">        <span class="nx">nextIndexTemp</span> <span class="p">=</span> <span class="nx">indexTemp</span> <span class="o">+</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 该条件满足说明是使用utf8编码的多个字节占用，
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 使用decoderune获取该Unicode值和在Utf8中编码占用的字节大小数目
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// decoderune解码字符串str从indexTemp位置开始，具体方法在runtime/utf8.go文件中
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 该函数与utf8编码相关
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// valueTemp解析的rune，nextIndexTemp当前的indexTemp+解析的rune的长度
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">valueTemp</span><span class="p">,</span> <span class="nx">nextIndexTemp</span> <span class="p">=</span> <span class="nf">decoderune</span><span class="p">(</span><span class="nx">str</span><span class="p">,</span> <span class="nx">indexTemp</span><span class="p">)</span>	
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c1">// 3) 拷贝赋值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 注意：这里就是为什么for range中取&amp;i和&amp;v地址是固定的原因
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">i</span> <span class="p">=</span> <span class="nx">indexTemp</span>   <span class="c1">// 当前获取到的索引
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">v</span> <span class="p">=</span> <span class="nx">valueTemp</span>   <span class="c1">// 当前获取到的字符
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    
</span></span><span class="line"><span class="cl">    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span> <span class="nx">v</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// original body
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ol start="3">
<li><code>decoderune()</code>。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// runtime/utf8.go 文件中decoderune方法
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// decoderune returns the non-ASCII rune at the start of
</span></span></span><span class="line"><span class="cl"><span class="c1">// s[k:] and the index after the rune in s.
</span></span></span><span class="line"><span class="cl"><span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1">// decoderune assumes that caller has checked that
</span></span></span><span class="line"><span class="cl"><span class="c1">// the to be decoded rune is a non-ASCII rune.
</span></span></span><span class="line"><span class="cl"><span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1">// If the string appears to be incomplete or decoding problems
</span></span></span><span class="line"><span class="cl"><span class="c1">// are encountered (runeerror, k + 1) is returned to ensure
</span></span></span><span class="line"><span class="cl"><span class="c1">// progress when decoderune is used to iterate over a string.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">decoderune</span><span class="p">(</span><span class="nx">s</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">k</span> <span class="kt">int</span><span class="p">)</span> <span class="p">(</span><span class="nx">r</span> <span class="kt">rune</span><span class="p">,</span> <span class="nx">pos</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">pos</span> <span class="p">=</span> <span class="nx">k</span> <span class="c1">// 解析开始位置
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">k</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span> <span class="p">{</span>    <span class="c1">// 已经到字符串的最大长度了
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">return</span> <span class="nx">runeError</span><span class="p">,</span> <span class="nx">k</span> <span class="o">+</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nx">s</span> <span class="p">=</span> <span class="nx">s</span><span class="p">[</span><span class="nx">k</span><span class="p">:]</span>   <span class="c1">// 从k位置分割字符串
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="k">switch</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// [t2, t3) --&gt; [11000000, 11100000)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">case</span> <span class="nx">t2</span> <span class="o">&lt;=</span> <span class="nx">s</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="nx">s</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">&lt;</span> <span class="nx">t3</span><span class="p">:</span>   <span class="c1">// 该字段2字节编码
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 0080-07FF two byte sequence
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// [locb, hicb] 是第二个字节的范围大小 [10000000, 10111111]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span> <span class="p">&gt;</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="nx">locb</span> <span class="o">&lt;=</span> <span class="nx">s</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="nx">s</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="nx">hicb</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 从编码中取出编码的数据组成rune
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// mask2 = 00011111，maskx = 00111111
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="nx">r</span> <span class="p">=</span> <span class="nb">rune</span><span class="p">(</span><span class="nx">s</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">&amp;</span><span class="nx">mask2</span><span class="p">)</span><span class="o">&lt;&lt;</span><span class="mi">6</span> <span class="p">|</span> <span class="nb">rune</span><span class="p">(</span><span class="nx">s</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">&amp;</span><span class="nx">maskx</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="nx">pos</span> <span class="o">+=</span> <span class="mi">2</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="nx">rune1Max</span> <span class="p">&lt;</span> <span class="nx">r</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="k">return</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// [t3, t4) --&gt; [11100000, 11110000)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">case</span> <span class="nx">t3</span> <span class="o">&lt;=</span> <span class="nx">s</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="nx">s</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">&lt;</span> <span class="nx">t4</span><span class="p">:</span>   <span class="c1">// 该字段3字节编码
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 0800-FFFF three byte sequence
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span> <span class="p">&gt;</span> <span class="mi">2</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="nx">locb</span> <span class="o">&lt;=</span> <span class="nx">s</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="nx">s</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="nx">hicb</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="nx">locb</span> <span class="o">&lt;=</span> <span class="nx">s</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="nx">s</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="nx">hicb</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nx">r</span> <span class="p">=</span> <span class="nb">rune</span><span class="p">(</span><span class="nx">s</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">&amp;</span><span class="nx">mask3</span><span class="p">)</span><span class="o">&lt;&lt;</span><span class="mi">12</span> <span class="p">|</span> <span class="nb">rune</span><span class="p">(</span><span class="nx">s</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">&amp;</span><span class="nx">maskx</span><span class="p">)</span><span class="o">&lt;&lt;</span><span class="mi">6</span> <span class="p">|</span> <span class="nb">rune</span><span class="p">(</span><span class="nx">s</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">&amp;</span><span class="nx">maskx</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="nx">pos</span> <span class="o">+=</span> <span class="mi">3</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="nx">rune2Max</span> <span class="p">&lt;</span> <span class="nx">r</span> <span class="o">&amp;&amp;</span> <span class="p">!(</span><span class="nx">surrogateMin</span> <span class="o">&lt;=</span> <span class="nx">r</span> <span class="o">&amp;&amp;</span> <span class="nx">r</span> <span class="o">&lt;=</span> <span class="nx">surrogateMax</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="k">return</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// [t4, t5) --&gt; [11110000, 11111000)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">case</span> <span class="nx">t4</span> <span class="o">&lt;=</span> <span class="nx">s</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="nx">s</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">&lt;</span> <span class="nx">t5</span><span class="p">:</span>   <span class="c1">// 该字段4字节编码
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 10000-1FFFFF four byte sequence
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span> <span class="p">&gt;</span> <span class="mi">3</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="nx">locb</span> <span class="o">&lt;=</span> <span class="nx">s</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="nx">s</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="nx">hicb</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="nx">locb</span> <span class="o">&lt;=</span> <span class="nx">s</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="nx">s</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="nx">hicb</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="nx">locb</span> <span class="o">&lt;=</span> <span class="nx">s</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="nx">s</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="nx">hicb</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nx">r</span> <span class="p">=</span> <span class="nb">rune</span><span class="p">(</span><span class="nx">s</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">&amp;</span><span class="nx">mask4</span><span class="p">)</span><span class="o">&lt;&lt;</span><span class="mi">18</span> <span class="p">|</span> <span class="nb">rune</span><span class="p">(</span><span class="nx">s</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">&amp;</span><span class="nx">maskx</span><span class="p">)</span><span class="o">&lt;&lt;</span><span class="mi">12</span> <span class="p">|</span> <span class="nb">rune</span><span class="p">(</span><span class="nx">s</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">&amp;</span><span class="nx">maskx</span><span class="p">)</span><span class="o">&lt;&lt;</span><span class="mi">6</span> <span class="p">|</span> <span class="nb">rune</span><span class="p">(</span><span class="nx">s</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">&amp;</span><span class="nx">maskx</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="nx">pos</span> <span class="o">+=</span> <span class="mi">4</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="nx">rune3Max</span> <span class="p">&lt;</span> <span class="nx">r</span> <span class="o">&amp;&amp;</span> <span class="nx">r</span> <span class="o">&lt;=</span> <span class="nx">maxRune</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="k">return</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nx">runeError</span><span class="p">,</span> <span class="nx">k</span> <span class="o">+</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ol>
<li><code>for-range</code>不能遍历<code>*string</code>类型。</li>
<li><code>for-range</code>对于字符串并没有复制一份字符串进行编码，其实也不必要因为字符串的语义本来就是不可变数据。</li>
</ol>
<h2 id="迭代array">迭代<code>array</code><a hidden class="anchor" aria-hidden="true" href="#迭代array">#</a></h2>
<ol>
<li><code>range</code>迭代<code>array</code>，<code>key</code>为<code>int</code>类型，<code>value</code>为数组的元素类型。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="nx">arr</span> <span class="o">:=</span> <span class="p">[</span><span class="mi">5</span><span class="p">]</span><span class="kt">int</span><span class="p">{</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">arr</span> <span class="p">{</span> <span class="c1">// 【int, int】
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span> <span class="nx">v</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// original body
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ol start="2">
<li>上面迭代数组代码等效于下面代码。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// 1) 获取数组长度
</span></span></span><span class="line"><span class="cl"><span class="c1">// 注意：这里支持指针数组，比如len(*[2]int) == 2
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">lenTemp</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">arr</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 2) 拷贝数组
</span></span></span><span class="line"><span class="cl"><span class="c1">// 注意：这里支持指针数组，比如arr是*[2]int
</span></span></span><span class="line"><span class="cl"><span class="c1">// 这里也就是为什么使用数组指针和数组本身的性能差异，
</span></span></span><span class="line"><span class="cl"><span class="c1">// 使用数组指针这里的赋值是指针赋值，而使用数组这里是值复制当数据量大时性能差别还是比较明显
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">rangeArr</span> <span class="o">:=</span> <span class="nx">arr</span> <span class="c1">// 复制一份需要遍历的数组，注意这里的副本是与原数组没有任何联系
</span></span></span><span class="line"><span class="cl"><span class="c1">// 3) key/value
</span></span></span><span class="line"><span class="cl"><span class="c1">// 注意：这里的key和value，定义在for外，也是&amp;i和&amp;v是固定的原因
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">var</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">v</span> <span class="kt">int</span>    <span class="c1">// 定义遍历需要接收的key和value变量
</span></span></span><span class="line"><span class="cl"><span class="c1">// for range的编译等同代码
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">for</span> <span class="nx">indexTemp</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">indexTemp</span> <span class="p">&lt;</span> <span class="nx">lenTemp</span><span class="p">;</span> <span class="nx">indexTemp</span><span class="o">++</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 注意：这里支持指针数组赋值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">valueTemp</span> <span class="o">:=</span> <span class="nx">rangeArr</span><span class="p">[</span><span class="nx">indexTemp</span><span class="p">]</span> <span class="c1">// 数组支持语法糖 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 4) 拷贝赋值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 注意：这里就是为什么for range中取&amp;i和&amp;v地址是固定的原因
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">i</span> <span class="p">=</span> <span class="nx">indexTemp</span> <span class="c1">// 拷贝赋值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">v</span> <span class="p">=</span> <span class="nx">valueTemp</span> <span class="c1">// 拷贝赋值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    
</span></span><span class="line"><span class="cl">    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span> <span class="nx">v</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// original body
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ol start="3">
<li>数组遍历和切片遍历最主要的区别就是遍历副本，数组的副本与原数组没有任何关联只是值全部相同而已，而切片则是副本和原切片数共用同一个底层数组。</li>
<li><code>range</code>能遍历【数组指针】而【<strong>不能</strong>】遍历切片指针，这得益于数值指针在赋值和<code>len()</code>函数上Go支持的【<strong>语法糖</strong>】转换使得range对数组指针同样适用。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// range遍历指针数组时，会解引用数组指针拷贝副本遍历
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kn">package</span> <span class="nx">main</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="s">&#34;fmt&#34;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">var</span> <span class="nx">aa</span> <span class="o">*</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="kt">string</span> <span class="p">=</span> <span class="nb">new</span><span class="p">([</span><span class="mi">2</span><span class="p">]</span><span class="kt">string</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 1) 语法糖1：赋值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//(*aa)[0] = &#34;a&#34;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">aa</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">=</span> <span class="s">&#34;a&#34;</span> <span class="c1">// 语法糖
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//(*aa)[1] = &#34;bb&#34;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">aa</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="p">=</span> <span class="s">&#34;bb&#34;</span><span class="c1">// 语法糖
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    
</span></span><span class="line"><span class="cl">    <span class="c1">// 2) 语法糖2：取值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// c := (*aa)[1]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">c</span> <span class="o">:=</span> <span class="nx">aa</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>  <span class="c1">// 语法糖
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    
</span></span><span class="line"><span class="cl">    <span class="c1">// 3) 语法糖3：求长度
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// l := len(aa) // len(*aa)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 在Go中支持数组的指针相关的语法糖，所以导致使用数组和数组指针好像并没有多大的区别
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 比如数组指针aa能使用aa[0] = &#34;a&#34;这种形式赋值，也能使用len(aa)这种形式求长度，
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 其他类型的指针则不支持
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 这些语法糖也导致了能使用range遍历数组指针
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    
</span></span><span class="line"><span class="cl">    <span class="c1">// range 拷贝 *aa 副本遍历
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">for</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">s</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">aa</span> <span class="p">{</span>  <span class="c1">// 当数组很大时，遍历数组指针是一个不错的选择
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="nx">i</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nx">aa</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="p">=</span> <span class="s">&#34;cc&#34;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span> <span class="nx">s</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">aa</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// Output:
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 0 a
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 1 cc
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// &amp;[a cc]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ol start="5">
<li>验证数组遍历是值拷贝。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="p">{</span>	
</span></span><span class="line"><span class="cl">    <span class="nx">slice1</span> <span class="o">:=</span> <span class="p">[</span><span class="mi">4</span><span class="p">]</span><span class="kt">int</span><span class="p">{</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 这里拷贝的是数组的副本，因此if条件成立不会影响值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">for</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">slice1</span> <span class="p">{</span> <span class="c1">// [4]int
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="nx">i</span> <span class="o">==</span> <span class="mi">1</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nx">slice1</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">10</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span> <span class="nx">v</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">slice1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// Output:
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 0 0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 1 1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 2 2
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 3 3
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// [0 1 2 13]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">slice1</span> <span class="o">:=</span> <span class="p">[</span><span class="mi">4</span><span class="p">]</span><span class="kt">int</span><span class="p">{</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 这里拷贝的是数组的指针，因此if条件成立会影响值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">for</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="o">&amp;</span><span class="nx">slice1</span> <span class="p">{</span> <span class="c1">// *[4]int
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="nx">i</span> <span class="o">==</span> <span class="mi">1</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nx">slice1</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">10</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span> <span class="nx">v</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// Output:
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 0 0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 1 1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 2 2
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 3 13
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="迭代slice">迭代<code>slice</code><a hidden class="anchor" aria-hidden="true" href="#迭代slice">#</a></h2>
<ol>
<li>遍历<code>slice</code>前会先获取<code>slice</code>的长度<code>lenTemp</code>来作为循环次数，循环体中，每次循环会先获取元素值。</li>
<li>如果<code>for-range</code>中接收<code>index</code>和<code>value</code>的话，则会对<code>index</code>和<code>value</code>进行一次赋值。</li>
<li>数组与数组指针的遍历过程与<code>slice</code>基本一致，但是也有区别，区别在于副本复制的是与原数组是一个完全不相干的数组。</li>
<li><code>for-range</code>迭代<code>slice</code>，<code>key</code>为<code>int</code>，<code>value</code>为存储的元素类型。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="nx">slice1</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">slice1</span> <span class="p">{</span> <span class="c1">// 【int, int】
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span> <span class="nx">v</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// original body
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ol start="5">
<li>上面迭代切片代码等效于下面代码。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// 1) 拷贝切片
</span></span></span><span class="line"><span class="cl"><span class="c1">// 注意：拷贝的切片与原切片共用了同一个底层数组
</span></span></span><span class="line"><span class="cl"><span class="c1">// 也需要注意，len和cap也拷贝元切片的值，因此for range修改不起作用，
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">rangeSlice</span> <span class="o">:=</span> <span class="nx">slice1</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 2) 获取切片长度，也是遍历的次数
</span></span></span><span class="line"><span class="cl"><span class="c1">// 遍历的此时切片长度是固定的
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">lenTemp</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">rangeSlice</span><span class="p">)</span>  <span class="c1">// 拿到需要遍历的切片总长度
</span></span></span><span class="line"><span class="cl"><span class="c1">// 3) key/value
</span></span></span><span class="line"><span class="cl"><span class="c1">// 注意：这里的key和value，定义在for外，也是&amp;i和&amp;v是固定的原因
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">var</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">v</span> <span class="kt">int</span> <span class="c1">// 定义遍历需要的key和value变量
</span></span></span><span class="line"><span class="cl"><span class="c1">// for range的编译等同代码
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">for</span> <span class="nx">indexTemp</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">indexTemp</span> <span class="p">&lt;</span> <span class="nx">lenTemp</span><span class="p">;</span> <span class="nx">indexTemp</span><span class="o">++</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">valueTemp</span> <span class="o">:=</span> <span class="nx">rangeSlice</span><span class="p">[</span><span class="nx">indexTemp</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 4) 拷贝赋值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 注意：这里就是为什么for range中取&amp;i和&amp;v地址是固定的原因
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">i</span> <span class="p">=</span> <span class="nx">indexTemp</span>
</span></span><span class="line"><span class="cl">    <span class="nx">v</span> <span class="p">=</span> <span class="nx">valueTemp</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span> <span class="nx">v</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// original body
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ol start="6">
<li><strong>由于循环开始前循环次数就已经确定了，所以循环过程中新添加的元素是无法遍历到的。</strong></li>
<li>但是循环过程中修改后面还未循环的值，则会影响，这是由于在range循环前赋值的副本与原切片共用了一个底层数组导致的，所以能相互影响。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">slice1</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">slice1</span> <span class="p">{</span> <span class="c1">// 【int, int】
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="nx">i</span> <span class="o">==</span> <span class="mi">1</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nx">slice1</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">10</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span> <span class="nx">v</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// Output:
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 0 0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 1 1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 2 2
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 3 13
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="迭代channel">迭代<code>channel</code><a hidden class="anchor" aria-hidden="true" href="#迭代channel">#</a></h2>
<ol>
<li><code>channel</code>遍历是依次从<code>channel</code>中读取数据，读取前是不知道里面有多少个元素的。</li>
<li>如果<code>channel</code>中没有元素，则会<strong>阻塞</strong>等待，如果<code>channel</code>已被关闭，则会解除阻塞并退出循环。</li>
<li><code>for-range</code>迭代<code>channel</code>，只能获取一个值，<code>key</code>为<code>channel</code>存储的元素类型。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="nx">c</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="c1">// range遍历chan
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">for</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">c</span> <span class="p">{</span> <span class="c1">// 【int】
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">v</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// original body
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ol start="4">
<li>上面迭代channel代码等效于下面代码。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// 这里是&amp;v为什么都是同一个地址的原因
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">var</span> <span class="nx">v</span> <span class="kt">int</span> <span class="c1">// v其实就是固定的一个变量
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">for</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 注意如果不关闭channel这里会一直阻塞
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 我们知道 &lt;- 符号会调用相关的函数，如果chan关闭了会返回false退出循环
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">value_temp</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="o">&lt;-</span> <span class="nx">c</span>		
</span></span><span class="line"><span class="cl">    <span class="c1">// 有数据则会直接返回数据，没有数据则会阻塞，通过chan的学习知道阻塞意味着
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 当前goroutine被调离调度循环等待数据到来被重新调起
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    
</span></span><span class="line"><span class="cl">    <span class="c1">// ok = false，通道已经关闭。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">!</span><span class="nx">ok</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">break</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c1">// 2) 拷贝值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">v</span> <span class="p">=</span> <span class="nx">value_temp</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">v</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// original body
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ol start="5">
<li>编译后的伪代码，与上面等价。关于<code>chanrecv2()</code>在channel中介绍。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">v</span> <span class="kt">int</span>
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">ok</span> <span class="o">:=</span> <span class="nf">chanrecv2</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">value_temp</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">!</span><span class="nx">ok</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">break</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="nx">v</span> <span class="p">=</span> <span class="nx">index_temp</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">v</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// original body
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ol start="6">
<li>注意：
<ul>
<li>使用<code>for-range</code>遍历<code>channel</code>时只能获取一个返回值。</li>
<li>【<code>for-range &lt;-ch</code>】情况，该情况可以用在 【<code>channel map</code>、<code>channel array|*array</code>、<code>channel slice</code>、<code>channel string</code>】。</li>
</ul>
</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">chanTs2</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">ch</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kd">map</span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="kt">int</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 注意：这里是 &lt;-ch，前面的是 ch
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">for</span> <span class="nx">k</span><span class="p">,</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="o">&lt;-</span><span class="nx">ch</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nb">println</span><span class="p">(</span><span class="nx">k</span><span class="p">,</span> <span class="nx">v</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// ---------------------------
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// as   等价于下面代码
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// ---------------------------
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 注意：这里只会执行一次
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">a</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">ch</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="nx">k</span><span class="p">,</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">a</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nb">println</span><span class="p">(</span><span class="nx">k</span><span class="p">,</span> <span class="nx">v</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="迭代map">迭代<code>map</code><a hidden class="anchor" aria-hidden="true" href="#迭代map">#</a></h2>
<ol>
<li><code>for-range</code>迭代<code>map</code>，<code>key</code>为<code>map</code>的键，<code>value</code>为<code>map</code>的值。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="nx">map1</span> <span class="o">:=</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">string</span><span class="p">{</span><span class="s">&#34;one&#34;</span><span class="p">:</span><span class="s">&#34;1&#34;</span><span class="p">,</span> <span class="s">&#34;tow&#34;</span><span class="p">:</span><span class="s">&#34;2&#34;</span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">map1</span> <span class="p">{</span> <span class="c1">// 【string, string】
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span> <span class="nx">v</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// original body
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ol start="2">
<li>上面迭代map代码等效于下面代码。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// 1) key/value
</span></span></span><span class="line"><span class="cl"><span class="c1">// 这里也是为什么&amp;i和&amp;v是一个固定的地址的原因
</span></span></span><span class="line"><span class="cl"><span class="c1">// 定义遍历所需要的key和value变量
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">var</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">v</span> <span class="kt">string</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 2) map_iteration_struct
</span></span></span><span class="line"><span class="cl"><span class="c1">// map_iteration_struct是一个hiter结构体，存储着map的遍历相关信息
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">var</span> <span class="nx">hiter</span> <span class="nx">map_iteration_struct</span>	 
</span></span><span class="line"><span class="cl"><span class="c1">// mapiterinit 初始化map参看runtime/map.go文件
</span></span></span><span class="line"><span class="cl"><span class="c1">// hiter是一个哈希迭代结构，mapiternext迭代下一个哈希
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">for</span> <span class="nf">mapiterinit</span><span class="p">(</span><span class="kd">type</span><span class="p">,</span> <span class="k">range</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">hiter</span><span class="p">);</span> <span class="nx">hiter</span><span class="p">.</span><span class="nx">key</span> <span class="o">!=</span> <span class="kc">nil</span><span class="p">;</span> <span class="nf">mapiternext</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">hiter</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">index_temp</span> <span class="o">:=</span> <span class="o">*</span><span class="nx">hiter</span><span class="p">.</span><span class="nx">key</span>
</span></span><span class="line"><span class="cl">    <span class="nx">value_temp</span> <span class="o">:=</span> <span class="o">*</span><span class="nx">hiter</span><span class="p">.</span><span class="nx">val</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 3) 拷贝数据
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">i</span> <span class="p">=</span> <span class="nx">index_temp</span>
</span></span><span class="line"><span class="cl">    <span class="nx">v</span> <span class="p">=</span> <span class="nx">value_temp</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span> <span class="nx">v</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// original body
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ol start="3">
<li>遍历<code>map</code>时没有指定循环次数，循环体与遍历<code>slice</code>类似。由于<code>map</code>底层实现与<code>slice</code>不同，<code>map</code>底层使用 <code>hash</code>表实现的。</li>
<li><strong>插入数据位置是随机的，所以遍历过程中新插入的数据不能保证遍历到。</strong></li>
<li>以下相关的函数在<code>map</code>篇中还会详细的讨论。</li>
<li><code>type hiter struct</code>。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// A hash iteration structure.
</span></span></span><span class="line"><span class="cl"><span class="c1">// If you modify hiter, also change cmd/compile/internal/reflectdata/reflect.go
</span></span></span><span class="line"><span class="cl"><span class="c1">// and reflect/value.go to match the layout of this structure.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">type</span> <span class="nx">hiter</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 当前遍历的key地址
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">key</span>         <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span> <span class="c1">// Must be in first position.  Write nil to indicate iteration end (see cmd/compile/internal/walk/range.go).
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 当前遍历的elem地址
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">elem</span>        <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span> <span class="c1">// Must be in second position (see cmd/compile/internal/walk/range.go).
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 当前map的类型结构
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">t</span>           <span class="o">*</span><span class="nx">maptype</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 当前map的内存结构
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">h</span>           <span class="o">*</span><span class="nx">hmap</span>		 
</span></span><span class="line"><span class="cl">    <span class="c1">// 当前map的常规桶地址
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">buckets</span>     <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span> <span class="c1">// bucket ptr at hash_iter initialization time
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 当前正在遍历的桶
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">bptr</span>        <span class="o">*</span><span class="nx">bmap</span>          <span class="c1">// current bucket 当前存储桶
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// h.extra.overflow
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">overflow</span>    <span class="o">*</span><span class="p">[]</span><span class="o">*</span><span class="nx">bmap</span>       <span class="c1">// keeps overflow buckets of hmap.buckets alive	
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// h.extra.oldoverflow
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">oldoverflow</span> <span class="o">*</span><span class="p">[]</span><span class="o">*</span><span class="nx">bmap</span>       <span class="c1">// keeps overflow buckets of hmap.oldbuckets alive 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 开始遍历的桶号，随机的，用于开始遍历的起点以及结束遍历的终点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">startBucket</span> <span class="kt">uintptr</span>        <span class="c1">// bucket iteration started at
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// tophash偏移值，在[0,7]中随机生成的值，用于后续 i + offset &amp; 7 用作偏移量
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">offset</span>      <span class="kt">uint8</span>          <span class="c1">// intra-bucket offset to start from during iteration (should be big enough to hold bucketCnt-1) 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 当前遍历已过最大桶(1 &lt;&lt; B)时被设置为true
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">wrapped</span>     <span class="kt">bool</span>           <span class="c1">// already wrapped around from end of bucket array to beginning
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 初始化时桶的数量 1 &lt;&lt; B
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">B</span>           <span class="kt">uint8</span>   
</span></span><span class="line"><span class="cl">    <span class="c1">// 当前桶遍历的索引，默认值从0开始，该值配合offset遍历tophash，i + offset &amp; 7
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">i</span>           <span class="kt">uint8</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 初始化时是startBucket的值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//  1. bptr == nil时bucket存储需要遍历的桶号
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 	2. bptr != nil时bucket下个桶的桶号
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">bucket</span>      <span class="kt">uintptr</span>     <span class="c1">// 存储的是当前迭代器的桶号
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// noCheck.不需要检查，数据在bptr桶里面
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 其他需要检查
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">checkBucket</span> <span class="kt">uintptr</span>     <span class="c1">// 需要检查的桶号
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ol start="7">
<li><code>mapiterinit()</code>。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// mapiterinit initializes the hiter struct used for ranging over maps.
</span></span></span><span class="line"><span class="cl"><span class="c1">// The hiter struct pointed to by &#39;it&#39; is allocated on the stack
</span></span></span><span class="line"><span class="cl"><span class="c1">// by the compilers order pass or on the heap by reflect_mapiterinit.
</span></span></span><span class="line"><span class="cl"><span class="c1">// Both need to have zeroed hiter since the struct contains pointers.
</span></span></span><span class="line"><span class="cl"><span class="c1">// mapiterinit 初始化用于在map上的 hiter 结构
</span></span></span><span class="line"><span class="cl"><span class="c1">// &#39;it&#39; 指向的 hiter 结构由编译器顺序传递在堆栈上分配，或者由 reflect_mapiterinit 在堆上分配。
</span></span></span><span class="line"><span class="cl"><span class="c1">// 由于结构包含指针，因此两者都需要将 hiter 归零。 
</span></span></span><span class="line"><span class="cl"><span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1">// 迭代初始化
</span></span></span><span class="line"><span class="cl"><span class="c1">// t *maptype：当前map的元素类型
</span></span></span><span class="line"><span class="cl"><span class="c1">// h *hmap：当前map的内存结构
</span></span></span><span class="line"><span class="cl"><span class="c1">// it *hiter：迭代器结构
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">mapiterinit</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">maptype</span><span class="p">,</span> <span class="nx">h</span> <span class="o">*</span><span class="nx">hmap</span><span class="p">,</span> <span class="nx">it</span> <span class="o">*</span><span class="nx">hiter</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">raceenabled</span> <span class="o">&amp;&amp;</span> <span class="nx">h</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">callerpc</span> <span class="o">:=</span> <span class="nf">getcallerpc</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">        <span class="nf">racereadpc</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">h</span><span class="p">),</span> <span class="nx">callerpc</span><span class="p">,</span> <span class="nx">abi</span><span class="p">.</span><span class="nf">FuncPCABIInternal</span><span class="p">(</span><span class="nx">mapiterinit</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nx">it</span><span class="p">.</span><span class="nx">t</span> <span class="p">=</span> <span class="nx">t</span> <span class="c1">// 存储当前map的类型结构地址
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nx">h</span> <span class="o">==</span> <span class="kc">nil</span> <span class="o">||</span> <span class="nx">h</span><span class="p">.</span><span class="nx">count</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span> <span class="c1">// 如果当前map为空直接返回
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">return</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Sizeof</span><span class="p">(</span><span class="nx">hiter</span><span class="p">{})</span><span class="o">/</span><span class="nx">goarch</span><span class="p">.</span><span class="nx">PtrSize</span> <span class="o">!=</span> <span class="mi">12</span> <span class="p">{</span> <span class="c1">// 判断hiter结构是否正确
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nf">throw</span><span class="p">(</span><span class="s">&#34;hash_iter size incorrect&#34;</span><span class="p">)</span> <span class="c1">// see cmd/compile/internal/reflectdata/reflect.go
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nx">it</span><span class="p">.</span><span class="nx">h</span> <span class="p">=</span> <span class="nx">h</span> <span class="c1">// 存储当前map的内存结构地址
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="c1">// grab snapshot of bucket state
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">it</span><span class="p">.</span><span class="nx">B</span> <span class="p">=</span> <span class="nx">h</span><span class="p">.</span><span class="nx">B</span> <span class="c1">// 记录当前map的桶数量
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">it</span><span class="p">.</span><span class="nx">buckets</span> <span class="p">=</span> <span class="nx">h</span><span class="p">.</span><span class="nx">buckets</span> <span class="c1">// 记录当前map的常规桶地址
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nx">t</span><span class="p">.</span><span class="nx">bucket</span><span class="p">.</span><span class="nx">ptrdata</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span> <span class="c1">// 判断当前桶类型的ptrdata字段，该字段为0说明存储的都是标量数据
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 分配当前切片并记住指向当前切片和旧切片的指针。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 即使表增长 and/or 在我们迭代时将溢出桶添加到表中，这也会保留所有相关的溢出桶。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">h</span><span class="p">.</span><span class="nf">createOverflow</span><span class="p">()</span> <span class="c1">// 创建溢出桶
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">it</span><span class="p">.</span><span class="nx">overflow</span> <span class="p">=</span> <span class="nx">h</span><span class="p">.</span><span class="nx">extra</span><span class="p">.</span><span class="nx">overflow</span>
</span></span><span class="line"><span class="cl">        <span class="nx">it</span><span class="p">.</span><span class="nx">oldoverflow</span> <span class="p">=</span> <span class="nx">h</span><span class="p">.</span><span class="nx">extra</span><span class="p">.</span><span class="nx">oldoverflow</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// decide where to start
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 决定从哪里开始
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">r</span> <span class="o">:=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nf">fastrand</span><span class="p">())</span> <span class="c1">// 生成随机数决定从哪里开始
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// bucketCntBits = 3
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nx">h</span><span class="p">.</span><span class="nx">B</span> <span class="p">&gt;</span> <span class="mi">31</span><span class="o">-</span><span class="nx">bucketCntBits</span> <span class="p">{</span> <span class="c1">// 如果当前的桶数 &gt; 31 - 3
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">r</span> <span class="o">+=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nf">fastrand</span><span class="p">())</span> <span class="o">&lt;&lt;</span> <span class="mi">31</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nx">it</span><span class="p">.</span><span class="nx">startBucket</span> <span class="p">=</span> <span class="nx">r</span> <span class="o">&amp;</span> <span class="nf">bucketMask</span><span class="p">(</span><span class="nx">h</span><span class="p">.</span><span class="nx">B</span><span class="p">)</span> <span class="c1">// 确定开始的桶号，这里也是for range随机的原因
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">it</span><span class="p">.</span><span class="nx">offset</span> <span class="p">=</span> <span class="nb">uint8</span><span class="p">(</span><span class="nx">r</span> <span class="o">&gt;&gt;</span> <span class="nx">h</span><span class="p">.</span><span class="nx">B</span> <span class="o">&amp;</span> <span class="p">(</span><span class="nx">bucketCnt</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="c1">// 开始的tophash位置处
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="c1">// iterator state
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">it</span><span class="p">.</span><span class="nx">bucket</span> <span class="p">=</span> <span class="nx">it</span><span class="p">.</span><span class="nx">startBucket</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 记住我们有一个迭代器。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 可以与另一个 mapiterinit() 并发运行。	
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// iterator = 1 存在桶正在在使用迭代器标志
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// oldIterator = 2 存在旧桶正在使用迭代器标志
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 设置正在迭代的标志位
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nx">old</span> <span class="o">:=</span> <span class="nx">h</span><span class="p">.</span><span class="nx">flags</span><span class="p">;</span> <span class="nx">old</span><span class="o">&amp;</span><span class="p">(</span><span class="nx">iterator</span><span class="p">|</span><span class="nx">oldIterator</span><span class="p">)</span> <span class="o">!=</span> <span class="nx">iterator</span><span class="p">|</span><span class="nx">oldIterator</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">atomic</span><span class="p">.</span><span class="nf">Or8</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">h</span><span class="p">.</span><span class="nx">flags</span><span class="p">,</span> <span class="nx">iterator</span><span class="p">|</span><span class="nx">oldIterator</span><span class="p">)</span> <span class="c1">// 原子锁设置hmap的flags参数标志正在使用迭代器
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nf">mapiternext</span><span class="p">(</span><span class="nx">it</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ol start="8">
<li><code>mapiternext()</code>。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span><span class="lnt">113
</span><span class="lnt">114
</span><span class="lnt">115
</span><span class="lnt">116
</span><span class="lnt">117
</span><span class="lnt">118
</span><span class="lnt">119
</span><span class="lnt">120
</span><span class="lnt">121
</span><span class="lnt">122
</span><span class="lnt">123
</span><span class="lnt">124
</span><span class="lnt">125
</span><span class="lnt">126
</span><span class="lnt">127
</span><span class="lnt">128
</span><span class="lnt">129
</span><span class="lnt">130
</span><span class="lnt">131
</span><span class="lnt">132
</span><span class="lnt">133
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// 向下寻找下一个key
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">mapiternext</span><span class="p">(</span><span class="nx">it</span> <span class="o">*</span><span class="nx">hiter</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">h</span> <span class="o">:=</span> <span class="nx">it</span><span class="p">.</span><span class="nx">h</span> <span class="c1">// 获取当前hmap内存结构
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nx">raceenabled</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">callerpc</span> <span class="o">:=</span> <span class="nf">getcallerpc</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">        <span class="nf">racereadpc</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">h</span><span class="p">),</span> <span class="nx">callerpc</span><span class="p">,</span> <span class="nx">abi</span><span class="p">.</span><span class="nf">FuncPCABIInternal</span><span class="p">(</span><span class="nx">mapiternext</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 当前有hashWriting操作时，比如m[k]=v或delete函数时都会报错
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nx">h</span><span class="p">.</span><span class="nx">flags</span><span class="o">&amp;</span><span class="nx">hashWriting</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">throw</span><span class="p">(</span><span class="s">&#34;concurrent map iteration and map write&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nx">t</span> <span class="o">:=</span> <span class="nx">it</span><span class="p">.</span><span class="nx">t</span> <span class="c1">// 获取map的结构
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 本次需要遍历的桶号
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">bucket</span> <span class="o">:=</span> <span class="nx">it</span><span class="p">.</span><span class="nx">bucket</span> <span class="c1">// 当前的桶号
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 本次需要遍历的桶，如果为nil说明需要去bucket寻找
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">b</span> <span class="o">:=</span> <span class="nx">it</span><span class="p">.</span><span class="nx">bptr</span> <span class="c1">// 当前存储桶
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 本次应该遍历的索引
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">i</span> <span class="o">:=</span> <span class="nx">it</span><span class="p">.</span><span class="nx">i</span> <span class="c1">// 遍历索引默认0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">checkBucket</span> <span class="o">:=</span> <span class="nx">it</span><span class="p">.</span><span class="nx">checkBucket</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 遍历一遍当前桶及其溢出桶直到b=nil
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">next</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 当前桶遍历完时，切换到下一个桶去遍历
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nx">b</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 当前遍历的桶和开始的桶相等 并且 已经遍历过了最大桶数，说明遍历了一圈了
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="nx">bucket</span> <span class="o">==</span> <span class="nx">it</span><span class="p">.</span><span class="nx">startBucket</span> <span class="o">&amp;&amp;</span> <span class="nx">it</span><span class="p">.</span><span class="nx">wrapped</span> <span class="p">{</span> <span class="c1">// 结束遍历的条件
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// end of iteration
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="nx">it</span><span class="p">.</span><span class="nx">key</span> <span class="p">=</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl">            <span class="nx">it</span><span class="p">.</span><span class="nx">elem</span> <span class="p">=</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// h.growing() 当前正在扩容中
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="nx">h</span><span class="p">.</span><span class="nf">growing</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="nx">it</span><span class="p">.</span><span class="nx">B</span> <span class="o">==</span> <span class="nx">h</span><span class="p">.</span><span class="nx">B</span> <span class="p">{</span> <span class="c1">// h.growing()当前map正处于扩容状态
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// 迭代器是在增长过程中启动的，但增长尚未完成。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// 如果我们查看的bucket尚未填充（即，旧bucket未被清空），那么我们需要遍历旧buckets，只返回将迁移到此bucket的buckets。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="nx">oldbucket</span> <span class="o">:=</span> <span class="nx">bucket</span> <span class="o">&amp;</span> <span class="nx">it</span><span class="p">.</span><span class="nx">h</span><span class="p">.</span><span class="nf">oldbucketmask</span><span class="p">()</span> <span class="c1">// 旧桶的桶号
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="nx">b</span> <span class="p">=</span> <span class="p">(</span><span class="o">*</span><span class="nx">bmap</span><span class="p">)(</span><span class="nf">add</span><span class="p">(</span><span class="nx">h</span><span class="p">.</span><span class="nx">oldbuckets</span><span class="p">,</span> <span class="nx">oldbucket</span><span class="o">*</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">bucketsize</span><span class="p">)))</span>	<span class="c1">// 获取桶位置
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// 当前桶的tophash[0]不是2|3|4时，说明数据没有被迁移
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="k">if</span> <span class="p">!</span><span class="nf">evacuated</span><span class="p">(</span><span class="nx">b</span><span class="p">)</span> <span class="p">{</span>	
</span></span><span class="line"><span class="cl">                <span class="nx">checkBucket</span> <span class="p">=</span> <span class="nx">bucket</span> <span class="c1">// 需要检查的桶号
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span> <span class="c1">// 说明数据在新桶里面，数据已被迁移
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="nx">b</span> <span class="p">=</span> <span class="p">(</span><span class="o">*</span><span class="nx">bmap</span><span class="p">)(</span><span class="nf">add</span><span class="p">(</span><span class="nx">it</span><span class="p">.</span><span class="nx">buckets</span><span class="p">,</span> <span class="nx">bucket</span><span class="o">*</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">bucketsize</span><span class="p">)))</span>	
</span></span><span class="line"><span class="cl">                <span class="nx">checkBucket</span> <span class="p">=</span> <span class="nx">noCheck</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span> <span class="c1">// 1.没有扩容 2.扩容了但是it.B != h.B
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="nx">b</span> <span class="p">=</span> <span class="p">(</span><span class="o">*</span><span class="nx">bmap</span><span class="p">)(</span><span class="nf">add</span><span class="p">(</span><span class="nx">it</span><span class="p">.</span><span class="nx">buckets</span><span class="p">,</span> <span class="nx">bucket</span><span class="o">*</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">bucketsize</span><span class="p">)))</span> <span class="c1">// 新桶
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="nx">checkBucket</span> <span class="p">=</span> <span class="nx">noCheck</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="nx">bucket</span><span class="o">++</span> <span class="c1">// 桶号加一
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 当前桶号等于最大桶号
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="nx">bucket</span> <span class="o">==</span> <span class="nf">bucketShift</span><span class="p">(</span><span class="nx">it</span><span class="p">.</span><span class="nx">B</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// bucketShift(it.B) 等于 1 &gt;&gt; B
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="nx">bucket</span> <span class="p">=</span> <span class="mi">0</span> <span class="c1">// 标记从0号桶开始
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="nx">it</span><span class="p">.</span><span class="nx">wrapped</span> <span class="p">=</span> <span class="kc">true</span> <span class="c1">// 标记已经过了最大桶了
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="nx">i</span> <span class="p">=</span> <span class="mi">0</span> <span class="c1">// 新桶重置索引为0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c1">// 遍历当前桶的所有元素	bucketCnt = 8
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 从当前桶遍历数据
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">for</span> <span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">bucketCnt</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">offi</span> <span class="o">:=</span> <span class="p">(</span><span class="nx">i</span> <span class="o">+</span> <span class="nx">it</span><span class="p">.</span><span class="nx">offset</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="nx">bucketCnt</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="c1">// 根据it.offset偏移量开始随机遍历元素[0,7]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// b.tophash[offi] &lt;= 1 或 evacuatedEmpty = 4 表示桶数据为空
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="nf">isEmpty</span><span class="p">(</span><span class="nx">b</span><span class="p">.</span><span class="nx">tophash</span><span class="p">[</span><span class="nx">offi</span><span class="p">])</span> <span class="o">||</span> <span class="nx">b</span><span class="p">.</span><span class="nx">tophash</span><span class="p">[</span><span class="nx">offi</span><span class="p">]</span> <span class="o">==</span> <span class="nx">evacuatedEmpty</span> <span class="p">{</span> <span class="c1">// 如果当前位置为0或1或4表示桶为空
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="k">continue</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="nx">k</span> <span class="o">:=</span> <span class="nf">add</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">b</span><span class="p">),</span> <span class="nx">dataOffset</span><span class="o">+</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">offi</span><span class="p">)</span><span class="o">*</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">keysize</span><span class="p">))</span> <span class="c1">// 偏移到当前key位置
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="nx">t</span><span class="p">.</span><span class="nf">indirectkey</span><span class="p">()</span> <span class="p">{</span> <span class="c1">// 判断当前key存储是否是已指针存储而不是存储的key本身
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="nx">k</span> <span class="p">=</span> <span class="o">*</span><span class="p">((</span><span class="o">*</span><span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">)(</span><span class="nx">k</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 偏移到当前elem位置
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">e</span> <span class="o">:=</span> <span class="nf">add</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">b</span><span class="p">),</span> <span class="nx">dataOffset</span><span class="o">+</span><span class="nx">bucketCnt</span><span class="o">*</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">keysize</span><span class="p">)</span><span class="o">+</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">offi</span><span class="p">)</span><span class="o">*</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">elemsize</span><span class="p">))</span> 
</span></span><span class="line"><span class="cl">        <span class="c1">// checkBucket != noCheck 数据在旧桶 并且 !h.sameSizeGrow() 翻倍扩容
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 需要验证桶时，旧桶存在数据
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="nx">checkBucket</span> <span class="o">!=</span> <span class="nx">noCheck</span> <span class="o">&amp;&amp;</span> <span class="p">!</span><span class="nx">h</span><span class="p">.</span><span class="nf">sameSizeGrow</span><span class="p">()</span> <span class="p">{</span> <span class="c1">// 存在没有迁移完的旧桶时，去检查旧桶
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// t.reflexivekey() 为true表示 k == k 始终成立
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// t.reflexivekey() || t.key.equal(k, k) -&gt; k == k 始终成立情况
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="k">if</span> <span class="nx">t</span><span class="p">.</span><span class="nf">reflexivekey</span><span class="p">()</span> <span class="o">||</span> <span class="nx">t</span><span class="p">.</span><span class="nx">key</span><span class="p">.</span><span class="nf">equal</span><span class="p">(</span><span class="nx">k</span><span class="p">,</span> <span class="nx">k</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="c1">// 如果oldbucket中的项不是针对迭代中的当前新bucket，请跳过它
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="nx">hash</span> <span class="o">:=</span> <span class="nx">t</span><span class="p">.</span><span class="nf">hasher</span><span class="p">(</span><span class="nx">k</span><span class="p">,</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">h</span><span class="p">.</span><span class="nx">hash0</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">                <span class="k">if</span> <span class="nx">hash</span><span class="o">&amp;</span><span class="nf">bucketMask</span><span class="p">(</span><span class="nx">it</span><span class="p">.</span><span class="nx">B</span><span class="p">)</span> <span class="o">!=</span> <span class="nx">checkBucket</span> <span class="p">{</span> <span class="c1">// 需要跳过的情况
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                    <span class="k">continue</span>
</span></span><span class="line"><span class="cl">                <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span> <span class="c1">//  k == k 不是始终成立
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="c1">// b.tophash[offi]&amp;1 的最低位 参看数据迁移部分的去向
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="k">if</span> <span class="nx">checkBucket</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="nx">it</span><span class="p">.</span><span class="nx">B</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">b</span><span class="p">.</span><span class="nx">tophash</span><span class="p">[</span><span class="nx">offi</span><span class="p">]</span><span class="o">&amp;</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                    <span class="k">continue</span>
</span></span><span class="line"><span class="cl">                <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">        <span class="c1">// 将找到的k和e保存到hiter中
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// evacuatedX = 2、evacuatedY = 3
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// b.tophash[offi] != evacuatedX &amp;&amp; b.tophash[offi] != evacuatedY 存在有效数据
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// !(t.reflexivekey() || t.key.equal(k, k))	 -&gt; x == x 不是始终成立
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="nx">b</span><span class="p">.</span><span class="nx">tophash</span><span class="p">[</span><span class="nx">offi</span><span class="p">]</span> <span class="o">!=</span> <span class="nx">evacuatedX</span> <span class="o">&amp;&amp;</span> <span class="nx">b</span><span class="p">.</span><span class="nx">tophash</span><span class="p">[</span><span class="nx">offi</span><span class="p">]</span> <span class="o">!=</span> <span class="nx">evacuatedY</span><span class="p">)</span> <span class="o">||</span>
</span></span><span class="line"><span class="cl">            <span class="p">!(</span><span class="nx">t</span><span class="p">.</span><span class="nf">reflexivekey</span><span class="p">()</span> <span class="o">||</span> <span class="nx">t</span><span class="p">.</span><span class="nx">key</span><span class="p">.</span><span class="nf">equal</span><span class="p">(</span><span class="nx">k</span><span class="p">,</span> <span class="nx">k</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 这是需要的数据，我们可以返回它
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// 或
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// key!=key，因此无法删除或更新条目，因此我们可以只返回它
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// 这对我们来说很幸运，因为当key!=key关键是我们找不到它
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="nx">it</span><span class="p">.</span><span class="nx">key</span> <span class="p">=</span> <span class="nx">k</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="nx">t</span><span class="p">.</span><span class="nf">indirectelem</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="nx">e</span> <span class="p">=</span> <span class="o">*</span><span class="p">((</span><span class="o">*</span><span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">)(</span><span class="nx">e</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="nx">it</span><span class="p">.</span><span class="nx">elem</span> <span class="p">=</span> <span class="nx">e</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span> <span class="c1">// 数据被迁移到其他地方了
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// 自从迭代器启动以来，哈希表一直在增长
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// 这个key的数据现在在其他地方
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// 检查数据的当前哈希表
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// 此代码处理以下情况：
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">//	已被删除、更新或删除并重新插入
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">//	注意：我们需要重新标记密钥，因为它可能已更新为equal()，但不是相同的key（例如+0.0 vs-0.0）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="nx">rk</span><span class="p">,</span> <span class="nx">re</span> <span class="o">:=</span> <span class="nf">mapaccessK</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">h</span><span class="p">,</span> <span class="nx">k</span><span class="p">)</span> <span class="c1">// 根据key去寻找相应的数据，可能是新桶也可能是旧桶
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// 每寻找到，可能key已被删除
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="k">if</span> <span class="nx">rk</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="k">continue</span> <span class="c1">// key has been deleted
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="nx">it</span><span class="p">.</span><span class="nx">key</span> <span class="p">=</span> <span class="nx">rk</span>
</span></span><span class="line"><span class="cl">            <span class="nx">it</span><span class="p">.</span><span class="nx">elem</span> <span class="p">=</span> <span class="nx">re</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="nx">it</span><span class="p">.</span><span class="nx">bucket</span> <span class="p">=</span> <span class="nx">bucket</span> <span class="c1">// 回写桶号
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 记录当前正在遍历的桶
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="nx">it</span><span class="p">.</span><span class="nx">bptr</span> <span class="o">!=</span> <span class="nx">b</span> <span class="p">{</span> <span class="c1">// avoid unnecessary write barrier; see issue 14921
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="nx">it</span><span class="p">.</span><span class="nx">bptr</span> <span class="p">=</span> <span class="nx">b</span>	<span class="c1">// 避免不必要的写入障碍
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="nx">it</span><span class="p">.</span><span class="nx">i</span> <span class="p">=</span> <span class="nx">i</span> <span class="o">+</span> <span class="mi">1</span> <span class="c1">// i加一
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">it</span><span class="p">.</span><span class="nx">checkBucket</span> <span class="p">=</span> <span class="nx">checkBucket</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nx">b</span> <span class="p">=</span> <span class="nx">b</span><span class="p">.</span><span class="nf">overflow</span><span class="p">(</span><span class="nx">t</span><span class="p">)</span> <span class="c1">// 如果上面桶遍历完接到去后面桶找
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">i</span> <span class="p">=</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">    <span class="k">goto</span> <span class="nx">next</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ol start="9">
<li><code>mapaccessK()</code>。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// returns both key and elem. Used by map iterator
</span></span></span><span class="line"><span class="cl"><span class="c1">// 根据key找到相应的值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">mapaccessK</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">maptype</span><span class="p">,</span> <span class="nx">h</span> <span class="o">*</span><span class="nx">hmap</span><span class="p">,</span> <span class="nx">key</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">)</span> <span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">,</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">h</span> <span class="o">==</span> <span class="kc">nil</span> <span class="o">||</span> <span class="nx">h</span><span class="p">.</span><span class="nx">count</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nx">hash</span> <span class="o">:=</span> <span class="nx">t</span><span class="p">.</span><span class="nf">hasher</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">h</span><span class="p">.</span><span class="nx">hash0</span><span class="p">))</span> <span class="c1">// 当前key生成的hash值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">m</span> <span class="o">:=</span> <span class="nf">bucketMask</span><span class="p">(</span><span class="nx">h</span><span class="p">.</span><span class="nx">B</span><span class="p">)</span> <span class="c1">// (1 &lt;&lt; B) - 1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">b</span> <span class="o">:=</span> <span class="p">(</span><span class="o">*</span><span class="nx">bmap</span><span class="p">)(</span><span class="nf">add</span><span class="p">(</span><span class="nx">h</span><span class="p">.</span><span class="nx">buckets</span><span class="p">,</span> <span class="p">(</span><span class="nx">hash</span><span class="o">&amp;</span><span class="nx">m</span><span class="p">)</span><span class="o">*</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">bucketsize</span><span class="p">)))</span> <span class="c1">// key存储的当前桶
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 是否在扩容中
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nx">c</span> <span class="o">:=</span> <span class="nx">h</span><span class="p">.</span><span class="nx">oldbuckets</span><span class="p">;</span> <span class="nx">c</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">!</span><span class="nx">h</span><span class="p">.</span><span class="nf">sameSizeGrow</span><span class="p">()</span> <span class="p">{</span>	<span class="c1">// 翻倍扩容
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// There used to be half as many buckets; mask down one more power of two.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="nx">m</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 去旧桶里面查看数据是否被迁移了
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">oldb</span> <span class="o">:=</span> <span class="p">(</span><span class="o">*</span><span class="nx">bmap</span><span class="p">)(</span><span class="nf">add</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="p">(</span><span class="nx">hash</span><span class="o">&amp;</span><span class="nx">m</span><span class="p">)</span><span class="o">*</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">bucketsize</span><span class="p">)))</span>	
</span></span><span class="line"><span class="cl">        <span class="c1">// 数据没有被迁移 tophash[0] != [2,3,4]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="p">!</span><span class="nf">evacuated</span><span class="p">(</span><span class="nx">oldb</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nx">b</span> <span class="p">=</span> <span class="nx">oldb</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nx">top</span> <span class="o">:=</span> <span class="nf">tophash</span><span class="p">(</span><span class="nx">hash</span><span class="p">)</span> <span class="c1">// tophash
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">bucketloop</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 遍历当前桶及溢出桶寻找 key
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">for</span> <span class="p">;</span> <span class="nx">b</span> <span class="o">!=</span> <span class="kc">nil</span><span class="p">;</span> <span class="nx">b</span> <span class="p">=</span> <span class="nx">b</span><span class="p">.</span><span class="nf">overflow</span><span class="p">(</span><span class="nx">t</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">bucketCnt</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="nx">b</span><span class="p">.</span><span class="nx">tophash</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">!=</span> <span class="nx">top</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="k">if</span> <span class="nx">b</span><span class="p">.</span><span class="nx">tophash</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">==</span> <span class="nx">emptyRest</span> <span class="p">{</span> <span class="c1">// emptyRest = 0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                    <span class="k">break</span> <span class="nx">bucketloop</span>
</span></span><span class="line"><span class="cl">                <span class="p">}</span>
</span></span><span class="line"><span class="cl">                <span class="k">continue</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">            
</span></span><span class="line"><span class="cl">            <span class="c1">// 找到了key 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// 1. 可能是hash冲突则还需要向后去查找
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// 2. 确实找到了key直接返回即可
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="nx">k</span> <span class="o">:=</span> <span class="nf">add</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">b</span><span class="p">),</span> <span class="nx">dataOffset</span><span class="o">+</span><span class="nx">i</span><span class="o">*</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">keysize</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="nx">t</span><span class="p">.</span><span class="nf">indirectkey</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="nx">k</span> <span class="p">=</span> <span class="o">*</span><span class="p">((</span><span class="o">*</span><span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">)(</span><span class="nx">k</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// key匹配成功
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="k">if</span> <span class="nx">t</span><span class="p">.</span><span class="nx">key</span><span class="p">.</span><span class="nf">equal</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="nx">k</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="nx">e</span> <span class="o">:=</span> <span class="nf">add</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">b</span><span class="p">),</span> <span class="nx">dataOffset</span><span class="o">+</span><span class="nx">bucketCnt</span><span class="o">*</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">keysize</span><span class="p">)</span><span class="o">+</span><span class="nx">i</span><span class="o">*</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">elemsize</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">                <span class="k">if</span> <span class="nx">t</span><span class="p">.</span><span class="nf">indirectelem</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                    <span class="nx">e</span> <span class="p">=</span> <span class="o">*</span><span class="p">((</span><span class="o">*</span><span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">)(</span><span class="nx">e</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">                <span class="p">}</span>
</span></span><span class="line"><span class="cl">                <span class="k">return</span> <span class="nx">k</span><span class="p">,</span> <span class="nx">e</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="总结">总结<a hidden class="anchor" aria-hidden="true" href="#总结">#</a></h2>
<ol>
<li><code>for-range</code>不支持【<strong>字符串指针</strong>】、【<strong>切片指针</strong>】、【<strong>map指针</strong>】、【<strong>channel指针</strong>】，但支持【<strong>数组指针</strong>】遍历。</li>
</ol>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://heliu.site/tags/golang/">Golang</a></li>
      <li><a href="https://heliu.site/tags/%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/">流程控制</a></li>
    </ul>
<nav class="paginav">
  <a class="prev" href="https://heliu.site/posts/golang/process/for/">
    <span class="title">« 上一页</span>
    <br>
    <span>流程控制(循环语句)</span>
  </a>
  <a class="next" href="https://heliu.site/posts/golang/process/switch/">
    <span class="title">下一页 »</span>
    <br>
    <span>流程控制(switch)</span>
  </a>
</nav>

  </footer>
</article>
    </main>
    
<footer class="footer">
    
    <div class="busuanzi-footer">
    <span id="busuanzi_container_site_pv">
        本站总访问量<span id="busuanzi_value_site_pv"></span>次
    </span>
    <span id="busuanzi_container_site_uv">
        本站访客数<span id="busuanzi_value_site_uv"></span>人次
    </span>
    </div>
        <span>Copyright © 2020-2024 <a href="#">heliu's blog</a>. All rights reserved</span>  
    
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'Copy';

        function copyingDone() {
            copybutton.innerHTML = 'Done';
            setTimeout(() => {
                copybutton.innerHTML = 'Copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
