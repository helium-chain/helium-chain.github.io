<!DOCTYPE html>
<html lang="zh" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Slice(åŸç†) | Helium</title>
<meta name="keywords" content="golang, Slice">
<meta name="description" content="ğŸ’¥æœ¬æ–‡ç« æ‰€æœ‰ç›¸å…³goä»£ç å‚è€ƒè‡ªgo 1.18&#43;ç‰ˆæœ¬">
<meta name="author" content="helium">
<link rel="canonical" href="https://heliu.site/posts/golang/slice/theory/">
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<meta name="referrer" content="no-referrer-when-downgrade">
<link crossorigin="anonymous" href="/assets/css/stylesheet.css" rel="preload stylesheet" as="style">
<link rel="icon" href="https://heliu.site/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://heliu.site/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://heliu.site/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://heliu.site/apple-touch-icon.png">
<link rel="mask-icon" href="https://heliu.site/apple-touch-icon.png">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="zh" href="https://heliu.site/posts/golang/slice/theory/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
<html>
<head>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/jetbrains-mono@1.0.6/css/jetbrains-mono-nl.min.css" />
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lxgw-wenkai-lite-webfont@1.1.0/style.css" />
    <link rel="stylesheet" href="https://cdn.staticfile.org/lxgw-wenkai-screen-webfont/1.6.0/style.css" />
    <style>
        body {
            font-family: "LXGW WenKai Lite", sans-serif;
            font-family: "LXGW WenKai Screen", sans-serif;
        }
    </style>
</head>
</html>

  

<meta property="og:title" content="Slice(åŸç†)" />
<meta property="og:description" content="ğŸ’¥æœ¬æ–‡ç« æ‰€æœ‰ç›¸å…³goä»£ç å‚è€ƒè‡ªgo 1.18&#43;ç‰ˆæœ¬" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://heliu.site/posts/golang/slice/theory/" />
<meta property="og:image" content="https://heliu.site/favicon-32x32.png" />
<meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-07-21T17:58:15+08:00" />
<meta property="article:modified_time" content="2024-07-21T17:58:15+08:00" /><meta property="og:site_name" content="Helium" />

<meta name="twitter:card" content="summary_large_image" />
<meta name="twitter:image" content="https://heliu.site/favicon-32x32.png" />
<meta name="twitter:title" content="Slice(åŸç†)"/>
<meta name="twitter:description" content="ğŸ’¥æœ¬æ–‡ç« æ‰€æœ‰ç›¸å…³goä»£ç å‚è€ƒè‡ªgo 1.18&#43;ç‰ˆæœ¬"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Article",
      "item": "https://heliu.site/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "golang åˆé›†",
      "item": "https://heliu.site/posts/golang/"
    }, 
    {
      "@type": "ListItem",
      "position":  3 ,
      "name": "ç¬¬7ç«  Slice",
      "item": "https://heliu.site/posts/golang/slice/"
    }, 
    {
      "@type": "ListItem",
      "position":  4 ,
      "name": "Slice(åŸç†)",
      "item": "https://heliu.site/posts/golang/slice/theory/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Slice(åŸç†)",
  "name": "Slice(åŸç†)",
  "description": "ğŸ’¥æœ¬æ–‡ç« æ‰€æœ‰ç›¸å…³goä»£ç å‚è€ƒè‡ªgo 1.18+ç‰ˆæœ¬",
  "keywords": [
    "golang", "Slice"
  ],
  "articleBody": " æœ¬ç¯‡æ–‡ç« éƒ½æ˜¯sliceçš„æºç èµ°è¯»ã€‚ æ³¨æ„ï¼šslice ä¸æ˜¯å¹¶å‘å®‰å…¨çš„æ•°æ®ç»“æ„ï¼Œå¤§å®¶åœ¨ä½¿ç”¨æ—¶è¯·åŠ¡å¿…æ³¨æ„å¹¶å‘å®‰å…¨é—®é¢˜ã€‚ type slice struct åˆ‡ç‰‡çš„å†…å­˜å¸ƒå±€ã€‚ arrayï¼šæŒ‡å‘ä¸€ä¸ª[cap]Tå¤§å°çš„æ•°ç»„åœ°å€ã€‚å°±æ˜¯æŒ‡å‘ä¸€ä¸ªcapå®¹é‡å¤§å°çš„æ•°ç»„é¦–åœ°å€ã€‚ lenï¼šè®°å½•åˆ‡ç‰‡å·²å­˜å‚¨å…ƒç´ çš„é•¿åº¦ï¼Œä¹Ÿæ˜¯å¯è®¿é—®çš„æœ€å¤§ä¸‹æ ‡len - 1ã€‚ capï¼šè®°å½•åˆ‡ç‰‡çš„å®¹é‡ï¼Œä¹Ÿå°±æ˜¯å½“å‰åˆ‡ç‰‡å­˜å‚¨çš„æœ€å¤§å…ƒç´ æ•°é‡ï¼ˆæœªæ‰©å®¹å‰ï¼‰ã€‚ type slice struct { array unsafe.Pointer len int cap int } type notInHeapSlice struct notInHeapSliceæ˜¯go:notinheapå†…å­˜æ”¯æŒçš„sliceã€‚ ä¹Ÿå°±æ˜¯è¯¥ç±»å‹çš„å¯¹è±¡ä¸æ˜¯åœ¨å †ä¸­åˆ›å»ºçš„ï¼Œä¹Ÿå°±æ˜¯GCä¸ä¼šæ‰«æï¼Œå¤šç”¨äºå†…å­˜ç®¡ç†æ¨¡å—ä¸­ã€‚ 1 2 3 4 5 6 // A notInHeapSlice is a slice backed by go:notinheap memory. type notInHeapSlice struct { array *notInHeap // æŒ‡å‘ä¸€ä¸ªèµ·å§‹åœ°å€ len int cap int } type notInHeap struct notInHeapæ˜¯ç”±sysAllocæˆ–persistentAllocç­‰åº•å±‚åˆ†é…å™¨åˆ†é…çš„å †å¤–å†…å­˜ã€‚ ä¸€èˆ¬æ¥è¯´ï¼Œæœ€å¥½ä½¿ç”¨æ ‡è®°ä¸ºgo:notinheapçš„çœŸå®ç±»å‹ï¼Œä½†åœ¨æ— æ³•è¿™æ ·åšçš„æƒ…å†µä¸‹(æ¯”å¦‚åœ¨åˆ†é…å™¨ä¸­)ï¼Œå®ƒç”¨ä½œé€šç”¨ç±»å‹ã€‚ TODOï¼šä½¿ç”¨å®ƒä½œä¸ºsysAlloc,persistentAllocç­‰çš„è¿”å›ç±»å‹? 1 2 3 4 5 6 7 8 9 10 11 // notInHeap is off-heap memory allocated by a lower-level allocator // like sysAlloc or persistentAlloc. // // In general, it's better to use real types marked as go:notinheap, // but this serves as a generic type for situations where that isn't // possible (like in the allocators). // // TODO: Use this as the return type of sysAlloc, persistentAlloc, etc? // //go:notinheap type notInHeap struct{} add() 1 2 3 4 func (p *notInHeap) add(bytes uintptr) *notInHeap { // p + bytes return (*notInHeap)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + bytes)) } make() makeå†…ç½®å‡½æ•°åˆ†é…å¹¶åˆå§‹åŒ–ä¸€ä¸ªç±»å‹ä¸ºsliceã€mapæˆ–chançš„å¯¹è±¡(only)ã€‚ å’Œnewä¸€æ ·ï¼Œç¬¬ä¸€ä¸ªå‚æ•°æ˜¯ç±»å‹ï¼Œè€Œä¸æ˜¯å€¼ã€‚ä¸newä¸åŒï¼Œmakeçš„è¿”å›å€¼ç±»å‹ä¸å…¶å‚æ•°çš„ç±»å‹ç›¸åŒï¼Œè€Œä¸æ˜¯æŒ‡å‘å‚æ•°çš„æŒ‡é’ˆã€‚ å…·ä½“çš„ç»“æœå–å†³äºç±»å‹ï¼š Sliceï¼š sizeæŒ‡å®šäº†é•¿åº¦ã€‚åˆ‡ç‰‡çš„å®¹é‡ç­‰äºå®ƒçš„é•¿åº¦ã€‚ ä»¥æä¾›ç¬¬äºŒä¸ªæ•´æ•°å‚æ•°æ¥æŒ‡å®šä¸åŒçš„å®¹é‡;å®ƒå¿…é¡»ä¸å°äºé•¿åº¦ã€‚ ä¾‹å¦‚ï¼Œmake([]int, 0, 10)ä¼šåˆ†é…ä¸€ä¸ªé•¿åº¦ä¸º10çš„åº•å±‚æ•°ç»„ï¼Œå¹¶è¿”å›ä¸€ä¸ªé•¿åº¦ä¸º0ã€å®¹é‡ä¸º10çš„åˆ‡ç‰‡ã€‚ Mapï¼šä¸€ä¸ªç©ºçš„mapåˆ†é…äº†è¶³å¤Ÿçš„ç©ºé—´æ¥ä¿å­˜æŒ‡å®šæ•°é‡çš„å…ƒç´ ã€‚åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œå¯ä»¥çœç•¥é•¿åº¦ï¼Œåˆ†é…ä¸€ä¸ªè¾ƒå°çš„èµ·å§‹é•¿åº¦ã€‚ Channelï¼šchannelç¼“å†²åŒºä½¿ç”¨æŒ‡å®šçš„ç¼“å†²åŒºå®¹é‡åˆå§‹åŒ–ã€‚å¦‚æœä¸º0ï¼Œæˆ–è€…sizeè¢«çœç•¥ï¼Œåˆ™channelæ˜¯æ— ç¼“å†²çš„ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 // The make built-in function allocates and initializes an object of type // slice, map, or chan (only). Like new, the first argument is a type, not a // value. Unlike new, make's return type is the same as the type of its // argument, not a pointer to it. The specification of the result depends on // the type: //\tSlice: The size specifies the length. The capacity of the slice is //\tequal to its length. A second integer argument may be provided to //\tspecify a different capacity; it must be no smaller than the //\tlength. For example, make([]int, 0, 10) allocates an underlying array //\tof size 10 and returns a slice of length 0 and capacity 10 that is //\tbacked by this underlying array. //\tMap: An empty map is allocated with enough space to hold the //\tspecified number of elements. The size may be omitted, in which case //\ta small starting size is allocated. //\tChannel: The channel's buffer is initialized with the specified //\tbuffer capacity. If zero, or the size is omitted, the channel is //\tunbuffered. func make(t Type, size ...IntegerType) Type makeslice() make([]T *_type, len, cap int) *_typeï¼šè®°å½•ç€åˆ‡ç‰‡å…ƒç´ ç±»å‹ï¼Œæ¯”å¦‚[]stringåˆ‡ç‰‡è¿™é‡Œæ˜¯stringçš„å…ƒç±»å‹ã€‚ lenï¼šåˆ‡ç‰‡çš„é•¿åº¦ï¼Œè¯¥å‚æ•°æ˜¯å¿…ä¼ ã€‚ capï¼šåˆ‡ç‰‡çš„å®¹é‡ï¼Œè¯¥å‚æ•°æ˜¯å¯ä¼ ï¼Œé»˜è®¤ä¼šä¼ lenå¤§å°ã€‚ makeslice()å‡½æ•°æ˜¯åˆ‡ç‰‡ç”³è¯·å†…å­˜çš„make()å‡½æ•°åŸå‹ï¼Œä¸»è¦è´Ÿè´£ç”³è¯·slice.arrayå­—æ®µæŒ‡å‘çš„å†…å­˜å¤§å°ã€‚ é‚£ä¹ˆåˆ‡ç‰‡çš„24å­—èŠ‚å¤§å°å†…å­˜æ˜¯åœ¨ä»€ä¹ˆæ—¶å€™åˆ†é…çš„ï¼Ÿï¼ˆ64ä½ç³»ç»Ÿä¸‹ä¸º24å­—èŠ‚å†…å­˜ï¼Œ32ç³»ç»Ÿä¸‹ä¸º12å­—èŠ‚å†…å­˜ï¼‰ å¯èƒ½åœ¨å‡½æ•°æ ˆä¸Šç›´æ¥åˆ†é…24å­—èŠ‚å¤§å°å†…å­˜ã€‚ ä¹Ÿå¯èƒ½åœ¨å †ä¸Šåˆ†é…24å­—èŠ‚å¤§å°å†…å­˜ã€‚ è°ƒç”¨äº†makeslice()å‡½æ•°ï¼Œå…¶slice.arrayæŒ‡å‘çš„å†…å­˜å—ä¸€å®šæ˜¯åœ¨å †ä¸Šã€‚æ²¡æœ‰è°ƒè¯¥å‡½æ•°æ—¶å¯èƒ½å†…å­˜åˆ†é…åœ¨æ ˆä¸Šã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 func makeslice(et *_type, len, cap int) unsafe.Pointer { // 1ï¼‰åˆ¤æ–­et.size * uintptr(cap)æ˜¯å¦é€ æˆå†…å­˜æº¢å‡º mem, overflow := math.MulUintptr(et.size, uintptr(cap)) // æŒ‰ç…§capè®¡ç®—çš„ // 1. ã€overflow == trueã€‘ï¼šæº¢å‡º // 2. ã€mem \u003e maxAllocã€‘ï¼šè¶…è¿‡æ“ä½œç³»ç»Ÿæœ€å¤§å†…å­˜ // 3. ã€len \u003c 0ã€‘ï¼šé”™è¯¯çš„lenå‚æ•° // 4. ã€len \u003e capã€‘ï¼šé•¿åº¦å¤§äºå®¹é‡ if overflow || mem \u003e maxAlloc || len \u003c 0 || len \u003e cap { // NOTE: Produce a 'len out of range' error instead of a // 'cap out of range' error when someone does make([]T, bignumber). // 'cap out of range' is true too, but since the cap is only being // supplied implicitly, saying len is clearer. // See golang.org/issue/4085. // // å½“æœ‰äºº make([]T, bignumber) æ—¶ï¼Œäº§ç”Ÿä¸€ä¸ª 'len out of range' é”™è¯¯è€Œä¸æ˜¯ 'cap out of range' é”™è¯¯æç¤º // å½“ 'cap out of range' ä¹Ÿæ˜¯å¤ªé•¿äº†ï¼Œç”±äºcapåªæ˜¯éšå¼åœ°æä¾›ï¼Œæ‰€ä»¥è¯´lenæ›´æ¸…æ¥šçš„æç¤ºã€‚ mem, overflow := math.MulUintptr(et.size, uintptr(len))\t// æ ¹æ®lenè®¡ç®— if overflow || mem \u003e maxAlloc || len \u003c 0 { panicmakeslicelen() // painc 'len out of range' } panicmakeslicecap() // panic 'cap out of range' } // 2ï¼‰å‘æ“ä½œç³»ç»Ÿç”³è¯·memå¤§å°çš„å†…å­˜å—ï¼Œè¿”å›ç”³è¯·åˆ°å†…å­˜å—çš„é¦–åœ°å€ return mallocgc(mem, et, true) } makeslice64() int64ç‰ˆæœ¬ï¼Œå¦‚æœå½“å‰æ˜¯åœ¨32ä½ç³»ç»Ÿä¸­æ—¶ï¼Œintå…¶å®æ˜¯int32å¤§å°ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 func makeslice64(et *_type, len64, cap64 int64) unsafe.Pointer { len := int(len64) // 32ä½ç³»ç»Ÿä¸‹è½¬æ¢ä¼šä¸¢å¤±éƒ¨åˆ†æ•°æ® if int64(len) != len64 { panicmakeslicelen() // painc 'len out of range' } cap := int(cap64) if int64(cap) != cap64 { panicmakeslicecap() // panic 'cap out of range' } return makeslice(et, len, cap) } len() ä»¥ä¸‹ä¼ªä»£ç è·å–åˆ‡ç‰‡çš„é•¿åº¦ã€‚ lenå‡½æ•°çš„åŸå‹ï¼šfunc len(array []T) intã€‚ 1 2 3 4 // ä¼ªä»£ç ç¤ºä¾‹ func len(array []T) int { return array.len } cap() ä»¥ä¸‹ä¼ªä»£ç è·å–åˆ‡ç‰‡çš„å®¹é‡ã€‚ capå‡½æ•°çš„åŸå‹ï¼šfunc cap(array []T) intã€‚ 1 2 3 4 // ä¼ªä»£ç ç¤ºä¾‹ func cap(array []T) int { return array.cap } copy() copyå†…ç½®å‡½æ•°å°†å…ƒç´ ä»æºç‰‡å¤åˆ¶åˆ°ç›®æ ‡ç‰‡ã€‚(ä½œä¸ºç‰¹æ®Šæƒ…å†µï¼Œå®ƒä¹Ÿä¼šå°†bytesä»stringå¤åˆ¶åˆ°byteåˆ‡ç‰‡ã€‚) æºå’Œç›®æ ‡å¯èƒ½é‡å ã€‚ copyè¿”å›å¤åˆ¶çš„å…ƒç´ æ•°é‡ï¼Œè¿™å°†æ˜¯len(src)å’Œlen(dst)çš„æœ€å°å€¼ã€‚src-\u003edstã€‚ 1 2 3 4 5 6 // The copy built-in function copies elements from a source slice into a // destination slice. (As a special case, it also will copy bytes from a // string to a slice of bytes.) The source and destination may overlap. Copy // returns the number of elements copied, which will be the minimum of // len(src) and len(dst). func copy(dst, src []Type) int slicecopy() slicecopyç”¨äºå°†pointerlesså…ƒç´ çš„å­—ç¬¦ä¸²æˆ–åˆ‡ç‰‡å¤åˆ¶åˆ°åˆ‡ç‰‡ä¸­ã€‚ æ³¨æ„ï¼šcopy()çš„å‡½æ•°åŸå‹ä¸­æ²¡æœ‰å¯å˜å‚æ•°ï¼ˆ... Tï¼‰çš„å½¢å¼å‚æ•°ã€‚ slicecopy é€‚ç”¨ä»¥ä¸‹ä¸¤ç§æƒ…å†µï¼šfm -\u003e to ã€copy(to, fm []T) intã€‘ ã€copy(to []byte, fm string) intã€‘ æ³¨æ„ä»¥ä¸‹slicecopyå‡½æ•°å¯èƒ½åœ¨go1.18+ç‰ˆæœ¬ä¸­ä¸æ˜¯è¿™æ ·çš„ï¼Œè¿™ä¸€ç‰ˆé‡‡ç”¨çš„æ˜¯go1.22å·¦å³ç‰ˆæœ¬çš„æºç ï¼Œä½†æ˜¯åªæ˜¯å‘ç”Ÿäº†å˜åŒ–å…·ä½“é€»è¾‘æ²¡å˜ã€‚ å‚æ•°ï¼šfromPtr -\u003e toPtr toPtr unsafe.Pointerï¼šç›®æ ‡åœ°å€ï¼Œä¹Ÿå°±æ˜¯ä¸Šé¢çš„to.arrayå€¼ã€‚ toLen intï¼šç›®æ ‡é•¿åº¦ï¼Œä¹Ÿå°±æ˜¯ä¸Šé¢çš„to.lenå€¼ã€‚ fromPtr unsafe.Pointerï¼šæ¥æºåœ°å€ï¼Œä¹Ÿå°±æ˜¯ä¸Šé¢çš„fm.arrayå€¼ã€‚ fromLen intï¼šæ¥æºé•¿åº¦ï¼Œä¹Ÿå°±æ˜¯ä¸Šé¢çš„fm.lenå€¼ã€‚ width uintptrï¼šåˆ‡ç‰‡ç±»å‹å ç”¨å†…å­˜å¤§å°ï¼Œä¹Ÿå°±æ˜¯[]Tçš„Tç±»å‹çš„å¤§å°ã€‚ è¿”å›å€¼ï¼š intï¼šæ‹·è´çš„å…ƒç´ æ•°é‡ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 // slicecopy is used to copy from a string or slice of pointerless elements into a slice. func slicecopy(toPtr unsafe.Pointer, toLen int, fromPtr unsafe.Pointer, fromLen int, width uintptr) int { // 1) æ‹·è´æˆ–è¢«æ‹·è´é•¿åº¦ä¸º0ç›´æ¥è¿”å› if fromLen == 0 || toLen == 0 { return 0 } // 2) æ‹·è´å…ƒç´ çš„ä¸ªæ•°å–å†³äºæ‹·è´æˆ–è¢«æ‹·è´çš„æœ€å°é•¿åº¦ n := fromLen if toLen \u003c n { n = toLen } // 3) æ‹·è´çš„å…ƒç´ å¤§å°ä¸º0ï¼Œç›´æ¥è¿”å›n if width == 0 {\t// []struct{} return n } // 4) size éœ€è¦æ‹·è´çš„æ€»å†…å­˜å¤§å°/å­—èŠ‚ã€‚ size := uintptr(n) * width if raceenabled { callerpc := getcallerpc() pc := abi.FuncPCABIInternal(slicecopy) racereadrangepc(fromPtr, size, callerpc, pc) racewriterangepc(toPtr, size, callerpc, pc) } if msanenabled { msanread(fromPtr, size) msanwrite(toPtr, size) } if asanenabled { asanread(fromPtr, size) asanwrite(toPtr, size) } // ä¸€èˆ¬æƒ…å†µä¸‹ï¼Œè¿™é‡Œçš„å€¼å¤§çº¦æ˜¯2xï¼ˆåªæœ‰1å­—èŠ‚éœ€è¦æ‹·è´ï¼‰ // to := make([]byte, 1); copy(to, \"hello\") // ã€[]byteã€‘ OR ã€[]uint8ã€‘ OR ã€[]int8ã€‘ OR ã€[]boolã€‘ if size == 1 { // common case worth about 2x to do here // TODO: is this still worth it with new memmove impl? // // TODO: ä½¿ç”¨æ–°çš„memmove implï¼Œè¿™ä»ç„¶å€¼å¾—å—? // å·²çŸ¥fromPtrå’ŒtoPtræ˜¯ byte æŒ‡é’ˆ *(*byte)(toPtr) = *(*byte)(fromPtr) // known to be a byte pointer } else { memmove(toPtr, fromPtr, size) // æ‹·è´æ•°æ® } return n } memmove() memmoveä»fromå¤åˆ¶nä¸ªå­—èŠ‚åˆ°toã€‚ memmoveç¡®ä¿ä»»ä½•ä½äºfromä¸­çš„æŒ‡é’ˆéƒ½ä»¥ä¸å¯åˆ†å‰²çš„å†™å…¥æ–¹å¼å†™å…¥åˆ°toä¸­ï¼Œå› æ­¤ï¼ŒåŠ¨æ€è¯»å–æ— æ³•è§‚å¯Ÿåˆ°ä¸€ä¸ªåªå†™äº†ä¸€åŠçš„æŒ‡é’ˆã€‚ è¿™æ˜¯å¿…è¦çš„ï¼Œä»¥é˜²æ­¢åƒåœ¾æ”¶é›†å™¨å‘ç°æ— æ•ˆæŒ‡é’ˆï¼Œè¿™ä¸éæ‰˜ç®¡è¯­è¨€ä¸­çš„memmoveä¸åŒã€‚ ä¸è¿‡ï¼Œåªæœ‰å½“fromå’Œtoå¯èƒ½åŒ…å«æŒ‡é’ˆæ—¶ï¼Œmemmove()æ‰éœ€è¦è¿™ä¹ˆåšï¼Œåªæœ‰å½“fromã€toå’Œnéƒ½æ˜¯ word-alignedæ—¶æ‰ä¼šè¿™æ ·åšã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 // memmove copies n bytes from \"from\" to \"to\". // // memmove ensures that any pointer in \"from\" is written to \"to\" with // an indivisible write, so that racy reads cannot observe a // half-written pointer. This is necessary to prevent the garbage // collector from observing invalid pointers, and differs from memmove // in unmanaged languages. However, memmove is only required to do // this if \"from\" and \"to\" may contain pointers, which can only be the // case if \"from\", \"to\", and \"n\" are all be word-aligned. // // Implementations are in memmove_*.s. // //go:noescape func memmove(to, from unsafe.Pointer, n uintptr) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 TEXT runtimeÂ·memmove\u003cABIInternal\u003e(SB), NOSPLIT, $0-24 // AX = to // BX = from // CX = n MOVQ AX, DI MOVQ BX, SI MOVQ CX, BX tail: // TESTæŒ‡ä»¤ç”¨äºå¯¹BXå¯„å­˜å™¨çš„å†…å®¹å’Œè‡ªèº«è¿›è¡ŒæŒ‰ä½ä¸æ“ä½œï¼Œä½†æ˜¯ä¸æ”¹å˜å¯„å­˜å™¨çš„å†…å®¹ã€‚ TESTQ BX, BX # æ£€æŸ¥BXæ˜¯å¦ä¸º0 // æ£€æŸ¥ä¸Šä¸€æ¡æŒ‡ä»¤ï¼ˆTESTï¼‰æ‰§è¡Œåæ˜¯å¦è®¾ç½®äº†é›¶æ ‡å¿—ï¼ˆZFï¼‰ JEQ move_0 # Jump if Equal // è¿™æ˜¯ä¸€ä¸ªæ¯”è¾ƒæŒ‡ä»¤ï¼Œç”¨äºæ¯”è¾ƒBXå¯„å­˜å™¨ä¸­çš„å€¼å’Œç«‹å³æ•°2ã€‚ // å…·ä½“æ¥è¯´ï¼Œå®ƒä¼šå°†BXå¯„å­˜å™¨çš„å€¼å’Œ2ç›¸å‡ï¼Œä½†ä¸æ”¹å˜ä»»ä½•å¯„å­˜å™¨çš„å€¼ï¼Œåªæ˜¯æ ¹æ®ç»“æœè®¾ç½®çŠ¶æ€æ ‡å¿—ã€‚ CMPQ BX, $2 // BX \u003c= 2 æˆç«‹ JBE move_1or2 # Jump if Below or Equal CMPQ BX, $4 # \u003c= 4 JB move_3 JBE move_4 CMPQ BX, $8 # \u003c= 8 JB move_5through7 JE move_8 CMPQ BX, $16 JBE move_9through16 CMPQ BX, $32 JBE move_17through32 CMPQ BX, $64 JBE move_33through64 CMPQ BX, $128 JBE move_65through128 CMPQ BX, $256 JBE move_129through256 TESTB $1, runtimeÂ·useAVXmemmove(SB) JNZ avxUnaligned //... ... append() å†…ç½®å‡½æ•°append()å°†å…ƒç´ æ·»åŠ åˆ°åˆ‡ç‰‡çš„æœ«å°¾ã€‚ å¦‚æœå®ƒæœ‰è¶³å¤Ÿçš„å®¹é‡ï¼Œç›®çš„åœ°å°†è¢«é‡æ–°åˆ’åˆ†ä»¥å®¹çº³æ–°çš„å…ƒç´ ã€‚å¦‚æœæ²¡æœ‰ï¼Œå°†åˆ†é…ä¸€ä¸ªæ–°çš„åº•å±‚æ•°ç»„ã€‚ æ³¨æ„ï¼šappend()å‡½æ•°å­˜åœ¨å¯å˜å‚æ•°ï¼ˆ... Tï¼‰çš„å½¢å¼çš„å‚æ•°ã€‚ append()è¿”å›æ›´æ–°åçš„sliceã€‚å› æ­¤ï¼Œæœ‰å¿…è¦å°†append()çš„ç»“æœå­˜å‚¨åœ¨ä¿å­˜åˆ‡ç‰‡æœ¬èº«çš„å˜é‡ä¸­ï¼š ã€slice = append(slice, elem1, elem2)ã€‘ ã€slice = append(slice, anotherSlice...)ã€‘ ä½œä¸ºä¸€ç§ç‰¹æ®Šæƒ…å†µï¼Œå¯ä»¥å°†å­—ç¬¦ä¸²æ·»åŠ åˆ°å­—èŠ‚åˆ‡ç‰‡ä¸­ï¼Œå¦‚ä¸‹æ‰€ç¤ºï¼š ã€slice = append([]byte(\"hello \"), \"world\"...)ã€‘ 1 2 3 4 5 6 7 8 9 10 11 12 13 // The append built-in function appends elements to the end of a slice. If // it has sufficient capacity, the destination is resliced to accommodate the // new elements. If it does not, a new underlying array will be allocated. // Append returns the updated slice. It is therefore necessary to store the // result of append, often in the variable holding the slice itself: // //\tslice = append(slice, elem1, elem2) //\tslice = append(slice, anotherSlice...) // // As a special case, it is legal to append a string to a byte slice, like this: // //\tslice = append([]byte(\"hello \"), \"world\"...) func append(slice []Type, elems ...Type) []Type append æ‰§è¡Œæ­¥éª¤ï¼š å¦‚æœå½“å‰append()å‡½æ•°æ‰§è¡Œå®Œååˆ‡ç‰‡ä¸ä¼šâ€œç¿»å€æ‰©å®¹\"é‚£ä¹ˆï¼Œç›´æ¥æ˜¯æŠŠappend()åè¿½åŠ çš„æ•°æ®æ‹·è´åˆ°åˆ‡ç‰‡çš„åç»­ç©ºé—´å³å¯ã€‚ å¦‚æœå½“å‰append()å‡½æ•°æ‰§è¡Œå®Œåéœ€è¦â€œç¿»å€æ‰©å®¹â€ï¼Œé‚£ä¹ˆå…ˆè°ƒç”¨runtime.growslice()æ‰©å®¹å‡½æ•°ï¼Œç„¶ååœ¨æ‹·è´æ•°æ®è¿½åŠ åˆ°æ–°çš„å†…å­˜ç©ºé—´ã€‚ growslice() growslice()åœ¨append()å‡½æ•°æœŸé—´å¤„ç†åˆ‡ç‰‡å¢é•¿ã€‚ å®ƒå°†sliceå…ƒç´ ç±»å‹ã€æ—§çš„sliceå’Œæ‰€éœ€çš„æ–°æœ€å°å®¹é‡ä¼ é€’ç»™å®ƒï¼Œç„¶åè¿”å›ä¸€ä¸ªè‡³å°‘å…·æœ‰è¯¥å®¹é‡çš„æ–°sliceï¼Œå¹¶å°†æ—§æ•°æ®å¤åˆ¶åˆ°å…¶ä¸­ã€‚ æ–°sliceçš„é•¿åº¦è¢«è®¾ç½®ä¸ºæ—§sliceçš„é•¿åº¦ï¼Œè€Œä¸æ˜¯æ–°è¯·æ±‚çš„å®¹é‡ã€‚ è¿™æ˜¯ä¸ºäº†æ–¹ä¾¿codegenã€‚æ—§ç‰‡çš„é•¿åº¦ç«‹å³ç”¨äºè®¡ç®—åœ¨è¿½åŠ æœŸé—´åœ¨ä½•å¤„å†™å…¥æ–°å€¼ã€‚ TODOï¼šå½“æ—§çš„åç«¯æ¶ˆå¤±æ—¶ï¼Œé‡æ–°è€ƒè™‘è¿™ä¸ªå†³å®šã€‚ SSAåç«¯å¯èƒ½æ›´å–œæ¬¢æ–°çš„é•¿åº¦ï¼Œæˆ–è€…åªè¿”å›ptr/capä»¥èŠ‚çœæ ˆç©ºé—´ã€‚ å‚æ•°ï¼š et *_typeï¼šåˆ‡ç‰‡å…ƒç´ çš„å…ƒç±»å‹ã€‚ old sliceï¼šæœªç¿»å€æ‰©å®¹å‰åˆ‡ç‰‡ã€‚ cap intï¼šappend()å‡½æ•°åéœ€è¦çš„é•¿åº¦ old.len + n = capã€‚ä¹Ÿå°±æ˜¯append(s S, x ...T) Så‡½æ•°ä¸­len(S) + len(x) = capåçš„é•¿åº¦ã€‚ è¿”å›å€¼ï¼šslice slice.dataï¼šæ–°ç”³è¯·çš„åœ°å€ã€‚ slice.lenï¼šold.lençš„å€¼ã€‚æ³¨æ„è¿™é‡Œæ˜¯æ—§åˆ‡ç‰‡çš„é•¿åº¦ã€‚ slice.capï¼šæ‰©å®¹åçš„å®¹é‡ã€‚ è¯¥å‡½æ•°åœ¨append()å‡½æ•°è°ƒç”¨æ—¶æ ¹æ®æ¡ä»¶è§¦å‘ã€‚å¦‚old = append(old, 1, 2, 1), len(old) + 3 \u003e cap(old)æ—¶å°±éœ€è¦æ‰©å®¹äº†ã€‚ æ³¨æ„ï¼Œå…³äºsliceçš„æ‰©å®¹è§„åˆ™åœ¨go1.18å‰æ˜¯æ ¹æ®lençš„ä¸€å¥—è§„åˆ™ï¼Œè€Œåœ¨ä»¥åç‰ˆæœ¬åˆæ˜¯æ ¹æ®capçš„ä¸€å¥—è§„åˆ™ï¼Œæœ¬ç¯‡é‡‡ç”¨çš„æ˜¯go1.22å·¦å³ç‰ˆæœ¬çš„ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 // growslice handles slice growth during append. // It is passed the slice element type, the old slice, and the desired new minimum capacity, // and it returns a new slice with at least that capacity, with the old data // copied into it. // The new slice's length is set to the old slice's length, // NOT to the new requested capacity. // This is for codegen convenience. The old slice's length is used immediately // to calculate where to write new values during an append. // TODO: When the old backend is gone, reconsider this decision. // The SSA backend might prefer the new length or to return only ptr/cap and save stack space. func growslice(et *_type, old slice, cap int) slice { if raceenabled { callerpc := getcallerpc() racereadrangepc(old.array, uintptr(old.len*int(et.size)), callerpc, abi.FuncPCABIInternal(growslice)) } if msanenabled { msanread(old.array, uintptr(old.len*int(et.size))) } if asanenabled { asanread(old.array, uintptr(old.len*int(et.size))) } // 1) åˆ‡ç‰‡é•¿åº¦æº¢å‡ºåˆ¤æ–­ if cap \u003c old.cap { panic(errorString(\"growslice: cap out of range\")) } // 2) åˆ‡ç‰‡å…ƒç´ ç±»å‹ å ç”¨å†…å­˜ä¸ºé›¶ æƒ…å†µ // è¿™ç§æƒ…å†µå‡ºç°åœ¨ï¼š // var s []struct{} // s = append(s, struct{}{}, struct{}{}) if et.size == 0 { // append should not create a slice with nil pointer but non-zero len. // We assume that append doesn't need to preserve old.array in this case. // // Appendä¸åº”è¯¥åˆ›å»ºä¸€ä¸ªæŒ‡é’ˆä¸ºnilçš„åˆ‡ç‰‡ï¼Œè€Œæ˜¯ä¸€ä¸ªlenä¸ºnon-zeroçš„åˆ‡ç‰‡ã€‚ // åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œæˆ‘ä»¬å‡è®¾appendä¸éœ€è¦ä¿å­˜old.arrayã€‚ // èµ‹å€¼slice.arrayæŒ‡å®šåœ°å€ï¼Œä¸ºäº†ç¡®ä¿sliceä¸æ˜¯nil // sliceä¸ºnilçš„åˆ¤æ–­æ¡ä»¶æ˜¯ï¼Œåªè¦slice.array==0x00,ä¸ç®¡lenå’Œcapçš„å€¼ä¸ºå¤šå°‘éƒ½ä¸ºnil return slice{unsafe.Pointer(\u0026zerobase), old.len, cap} } // 3) è¯„ä¼°æ‰©å®¹åçš„å®¹é‡ // ---+-------+----------------------------------------------------------------------------------- // é¢„ | if | oldCap * 2 \u003c cap ------\u003e newCap = cap ä½¿ç”¨capå€¼ // ä¼° |-------+----------------------------------------------------------------------------------- // è§„ | else | oldCap \u003c 256 ------\u003e newCap = oldCap * 2 ç¿»å€æ‰©å®¹ // åˆ™ | | oldCap \u003e= 256 ------\u003e newCap = oldCap * 5/4 + 256 * 3/4 åœ¨åŸå®¹é‡ä¸Šæ‰©å®¹1/4åœ¨æ‰©å®¹192 // ---+-------+----------------------------------------------------------------------------------- newcap := old.cap doublecap := newcap + newcap if cap \u003e doublecap { // 2å€æ—§å®¹é‡ \u003c capæ—¶ï¼Œåˆ™æŒ‰ç…§capç®—ã€‚ newcap = cap } else { const threshold = 256 if old.cap \u003c threshold { newcap = doublecap } else { // Check 0 \u003c newcap to detect overflow // and prevent an infinite loop. // // æ£€æŸ¥ 0 \u003c newcap ä»¥æ£€æµ‹æº¢å‡ºå¹¶é˜²æ­¢æ— é™å¾ªç¯ã€‚ for 0 \u003c newcap \u0026\u0026 newcap \u003c cap { // Transition from growing 2x for small slices // to growing 1.25x for large slices. This formula // gives a smooth-ish transition between the two. newcap += (newcap + 3*threshold) / 4 } // Set newcap to the requested cap when // the newcap calculation overflowed. if newcap \u003c= 0 { newcap = cap } } } // 4) å†…å­˜è§„æ ¼åŒ¹é… // å†…å­˜æ˜¯å¦æº¢å‡º true.æº¢å‡º false.æ²¡æœ‰æº¢å‡º var overflow bool\t// lenmem æ—§åˆ‡ç‰‡å…ƒç´ å ç”¨çš„å†…å­˜å¤§å° // è¯¥å€¼ç”¨äºè¿ç§»æ—§æ•°æ®çš„ä¾æ®/å­—èŠ‚ // newlenmem ç¿»å€ååˆ‡ç‰‡å…ƒç´ å ç”¨çš„å†…å­˜å¤§å° // è¯¥å€¼æ˜¯å½“å‰æ‰©å®¹åå®é™…å ç”¨çš„å¤§å°/å­—èŠ‚ // å› æ­¤capmem-newlenmemè¿™éƒ¨åˆ†å†…å­˜æ˜¯å¤šä½™çš„ï¼Œä¸ä¼šè¢«ç”¨åˆ°ã€‚ // capmem ç¿»å€åæ–°å®¹é‡å ç”¨çš„å†…å­˜å¤§å°ï¼Œ // ç”¨äºå‘æ“ä½œç³»ç»Ÿç”³è¯·çš„å†…å­˜å¤§å°/å­—èŠ‚ // è¿™éƒ¨åˆ†å†…å­˜å¯èƒ½å¤§äºnewlenmemçš„å€¼ï¼Œå› ä¸ºGoçš„å†…å­˜ç”³è¯·æ˜¯æœ‰è§„æ ¼çš„ã€‚ var lenmem, newlenmem, capmem uintptr // Specialize for common values of et.size. // For 1 we don't need any division/multiplication. // For goarch.PtrSize, compiler will optimize division/multiplication into a shift by a constant. // For powers of 2, use a variable shift. // // ä¸“é—¨ç”¨äº et.size çš„å…±åŒå€¼ã€‚ // å¯¹äº1ï¼Œæˆ‘ä»¬ä¸éœ€è¦ä»»ä½•é™¤æ³•/ä¹˜æ³• // å¯¹äº goarch.PtrSizeï¼Œç¼–è¯‘å™¨å°†é™¤æ³•/ä¹˜æ³• ä¼˜åŒ–ä¸ºä¸€ä¸ªå¸¸é‡çš„ä½ç§» // å¯¹äº2çš„å¹‚æ¬¡æ–¹ï¼Œä½¿ç”¨å¯å˜ä½ç§» switch { // å€˜è‹¥æ•°ç»„å…ƒç´ çš„å¤§å°ä¸º 1ï¼Œåˆ™æ–°å®¹é‡å¤§å°ä¸º 1 * newcap. // åŒæ—¶ä¼šé’ˆå¯¹ span class è¿›è¡Œå–æ•´ case et.size == 1: // 1å­—èŠ‚ lenmem = uintptr(old.len) newlenmem = uintptr(cap) capmem = roundupsize(uintptr(newcap)) // åŒ¹é…æœ€è¿‘æ¥çš„å†…å­˜å—è§„æ ¼ overflow = uintptr(newcap) \u003e maxAlloc // æ˜¯å¦å†…å­˜æº¢å‡º newcap = int(capmem) // ä»æ–°è°ƒæ•´ç¿»å€åæ–°å®¹é‡ // å€˜è‹¥æ•°ç»„å…ƒç´ ä¸ºæŒ‡é’ˆç±»å‹ï¼Œåˆ™æ ¹æ®æŒ‡é’ˆå ç”¨ç©ºé—´ç»“åˆå…ƒç´ ä¸ªæ•°è®¡ç®—ç©ºé—´å¤§å° // å¹¶ä¼šé’ˆå¯¹ span class è¿›è¡Œå–æ•´ case et.size == goarch.PtrSize: // 4æˆ–8å­—èŠ‚ lenmem = uintptr(old.len) * goarch.PtrSize newlenmem = uintptr(cap) * goarch.PtrSize capmem = roundupsize(uintptr(newcap) * goarch.PtrSize) overflow = uintptr(newcap) \u003e maxAlloc/goarch.PtrSize newcap = int(capmem / goarch.PtrSize) // å€˜è‹¥å…ƒç´ å¤§å°ä¸º 2 çš„æŒ‡æ•°ï¼Œåˆ™ç›´æ¥é€šè¿‡ä½è¿ç®—è¿›è¡Œç©ºé—´å¤§å°çš„è®¡ç®— case isPowerOfTwo(et.size): // 2çš„å¹‚æ¬¡æ–¹ var shift uintptr if goarch.PtrSize == 8 { // Mask shift for better code generation. // // æ©ç ç§»ä½ä»¥æ›´å¥½åœ°ç”Ÿæˆä»£ç ã€‚ // sys.Ctz64å‡½æ•°è®¡æ•°å°¾éƒ¨(ä½é˜¶)é›¶ï¼Œå¦‚æœå…¨éƒ¨ä¸ºé›¶ï¼Œåˆ™ä¸º64ã€‚ // æ¯”å¦‚ et.size æ˜¯2^8ä¹Ÿå°±æ˜¯ 1_0000_0000ï¼Œä¹Ÿå°±æ˜¯8ä¸ªé›¶ shift = uintptr(sys.Ctz64(uint64(et.size))) \u0026 63 // 64ä½ } else { shift = uintptr(sys.Ctz32(uint32(et.size))) \u0026 31 // 32ä½ } lenmem = uintptr(old.len) \u003c\u003c shift newlenmem = uintptr(cap) \u003c\u003c shift capmem = roundupsize(uintptr(newcap) \u003c\u003c shift) overflow = uintptr(newcap) \u003e (maxAlloc \u003e\u003e shift) newcap = int(capmem \u003e\u003e shift) // å…œåº•åˆ†æ”¯ï¼šæ ¹æ®å…ƒç´ å¤§å°ä¹˜ä»¥å…ƒç´ ä¸ªæ•° // å†é’ˆå¯¹ span class è¿›è¡Œå–æ•´ default: lenmem = uintptr(old.len) * et.size newlenmem = uintptr(cap) * et.size // math.MulUintptr è¿”å› capmem = et.size * uintptr(newcap); overflow æ˜¯å¦æº¢å‡º capmem, overflow = math.MulUintptr(et.size, uintptr(newcap)) capmem = roundupsize(capmem) newcap = int(capmem / et.size) } // ä»¥ä¸Šä»£ç å› ä¸ºä¼šå»åŒ¹é…å†…å­˜è§„æ ¼ï¼Œæ‰€ä»¥ä¼šä»æ–°è®¡ç®—newcapè¿™ä¸ªç¿»å€åçš„å€¼ // The check of overflow in addition to capmem \u003e maxAlloc is needed // to prevent an overflow which can be used to trigger a segfault // on 32bit architectures with this example program: // // é™¤äº†capmem \u003e maxAllocä¹‹å¤–ï¼Œè¿˜éœ€è¦æ£€æŸ¥æº¢å‡ºï¼Œä»¥é˜²æ­¢æº¢å‡ºï¼Œ // è¯¥æº¢å‡ºå¯ç”¨äºåœ¨32ä½ä½“ç³»ç»“æ„ä¸Šè§¦å‘æ®µæ•…éšœï¼Œç¤ºä¾‹ç¨‹åºå¦‚ä¸‹: // // type T [1\u003c\u003c27 + 1]int64 // // var d T // var s []T // // func main() { // s = append(s, d, d, d, d)\t// print(len(s), \"\\n\") // } // 4*(1\u003c\u003c27 + 1)*8 if overflow || capmem \u003e maxAlloc { panic(errorString(\"growslice: cap out of range\")) } // ç”³è¯·åˆ°çš„å†…å­˜é¦–åœ°å€ var p unsafe.Pointer if et.ptrdata == 0 { // åˆ‡ç‰‡å…ƒç´ ç±»å‹ä¸åŒ…å«æŒ‡é’ˆ // capmem ç”³è¯·çš„å†…å­˜; nil ç±»å‹å…ƒç±»å‹ç”¨äºåˆ¤æ–­æ˜¯å¦ä¸ºæŒ‡é’ˆç±»å‹; false æ˜¯å¦é‡ç½®å†…å­˜ä¸ºé›¶å€¼; p = mallocgc(capmem, nil, false) // å‘æ“ä½œç³»ç»Ÿç”³è¯·å†…å­˜å— // The append() that calls growslice is going to overwrite from // old.len to cap (which will be the new length). // Only clear the part that will not be overwritten. // // è°ƒç”¨ growslice çš„ append() æ–¹æ³•ä¼šå°† old.len è¦†ç›–åˆ° cap(è¿™å°†æ˜¯æ–°çš„é•¿åº¦)ã€‚ // åªæ¸…é™¤ä¸ä¼šè¢«è¦†ç›–çš„éƒ¨åˆ†ã€‚ // æ¸…é›¶capmem-newlenmemè¿™å—å†…å­˜ï¼Œè¿™å¿«å†…å­˜æ˜¯å¤šä½™çš„ï¼Œä¸ä¼šè¢«ç”¨åˆ°ã€‚ memclrNoHeapPointers(add(p, newlenmem), capmem-newlenmem)\t} else { // åˆ‡ç‰‡å…ƒç´ ç±»å‹åŒ…å«æŒ‡é’ˆ // Note: can't use rawmem (which avoids zeroing of memory), // because then GC can scan uninitialized memory. // // Note: ä¸èƒ½ä½¿ç”¨rawmem(å®ƒå¯ä»¥é¿å…å†…å­˜å½’é›¶)ï¼Œå› ä¸ºè¿™æ ·GCä¼šæ‰«ææœªåˆå§‹åŒ–çš„å†…å­˜ã€‚ p = mallocgc(capmem, et, true) // å‘æ“ä½œç³»ç»Ÿç”³è¯·å†…å­˜å— if lenmem \u003e 0 \u0026\u0026 writeBarrier.enabled { // å¼€å¯äº†å†™å±éšœ // Only shade the pointers in old.array since we know the destination slice p // only contains nil pointers because it has been cleared during alloc. // // åœ¨ old.array ä¸­åªå¯¹æŒ‡é’ˆè¿›è¡Œ shade å¤„ç†ï¼Œå› ä¸ºæˆ‘ä»¬çŸ¥é“ç›®æ ‡åˆ‡ç‰‡ p åªåŒ…å«nilæŒ‡é’ˆï¼Œ // å› ä¸ºå®ƒåœ¨allocæœŸé—´å·²è¢«æ¸…é™¤ã€‚ // lenmem-et.size+et.ptrdata åˆšå¥½æ˜¯old.arrayå­˜åœ¨çš„éƒ½æ˜¯æŒ‡é’ˆ // -et.sizeï¼šå‡å»æœ€åä¸€ä¸ªå…ƒç´ çš„å†…å­˜ // +et.ptrdataï¼šå†åŠ ä¸Šæœ€åä¸€ä¸ªå…ƒç´ çš„æŒ‡é’ˆ // åˆšå¥½å¤„ç†å®Œæœ€åä¸€ä¸ªå…ƒç´ åé¢ä¸æ˜¯æŒ‡é’ˆçš„éƒ¨åˆ†å†…å­˜ã€‚ // [dst, dst+size] bulkBarrierPreWriteSrcOnly(uintptr(p), uintptr(old.array), lenmem-et.size+et.ptrdata)\t} } // ä»old.arrayä¸­è¿ç§»lenmemå¤§å°å†…å­˜æ•°æ®åˆ°pä¸­ memmove(p, old.array, lenmem) // æ³¨æ„ï¼šè¿™é‡Œè¿”å›çš„æ˜¯ old.lenï¼Œå› ä¸ºæ­¤æ—¶è¿˜æ˜¯ä¹‹å‰çš„æ—§æ•°æ® return slice{p, old.len, newcap} } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 // bulkBarrierPreWriteSrcOnly is like bulkBarrierPreWrite but // does not execute write barriers for [dst, dst+size). // // In addition to the requirements of bulkBarrierPreWrite // callers need to ensure [dst, dst+size) is zeroed. // // This is used for special cases where e.g. dst was just // created and zeroed with malloc. // // The type of the space can be provided purely as an optimization, // however it is not used with GOEXPERIMENT=noallocheaders. // //go:nosplit func bulkBarrierPreWriteSrcOnly(dst, src, size uintptr, _ *abi.Type) { // GCå¹¶å‘æ ‡è®°é˜¶æ®µï¼Œè¿™é‡Œéœ€è¦å¤„ç†æ··åˆå†™å±éšœç›¸å…³äº‹é¡¹ï¼Œå› ä¸ºåœ¨æ‹·è´æŒ‡é’ˆæ•°æ® if (dst|src|size)\u0026(goarch.PtrSize-1) != 0 { throw(\"bulkBarrierPreWrite: unaligned arguments\") } if !writeBarrier.enabled { return // å¹¶å‘æ ‡è®°å·²ç»“æŸ } buf := \u0026getg().m.p.ptr().wbBuf // å†™å±éšœç¼“å†²åŒº h := heapBitsForAddr(dst, size) for { var addr uintptr if h, addr = h.next(); addr == 0 { break } srcx := (*uintptr)(unsafe.Pointer(addr - dst + src)) p := buf.get1() p[0] = *srcx } } æ‰€æœ‰0å­—èŠ‚åˆ†é…çš„åŸºåœ°å€ã€‚ 1 2 // base address for all 0-byte allocations var zerobase uintptr roundupsize() mallocgcè¿”å›å°†åˆ†é…çš„å†…å­˜å—çš„å¤§å°ï¼Œå¦‚æœæ‚¨è¦æ±‚è¯¥å¤§å°ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // Returns size of the memory block that mallocgc will allocate if you ask for the size. func roundupsize(size uintptr) uintptr { // _MaxSmallSize = 32768 if size \u003c _MaxSmallSize { // smallSizeMax = 1024 if size \u003c= smallSizeMax-8 { // ä»¥æœ€ä¸‹8Bå€æ•°å¯¹é½ // smallSizeDiv = 8ï¼ŒdivRoundUp ç­‰ä»·äº ceil(size/8) // size_to_class8å’Œclass_to_size è®°å½•ç€ size çš„æ˜ å°„å…³ç³» return uintptr(class_to_size[size_to_class8[divRoundUp(size, smallSizeDiv)]]) } else { // ä»¥æœ€å°128Bå€æ•°å¯¹é½ // largeSizeDiv = 128 return uintptr(class_to_size[size_to_class128[divRoundUp(size-smallSizeMax, largeSizeDiv)]]) } } // _PageSize = 8192 if size+_PageSize \u003c size { return size } return alignUp(size, _PageSize) // å¯¹é½8KB } alignUp() alignUpå°†nå–æ•´ä¸ºaçš„å€æ•°ã€‚aå¿…é¡»æ˜¯2çš„å¹‚ã€‚ 1 2 3 4 // alignUp rounds n up to a multiple of a. a must be a power of 2. func alignUp(n, a uintptr) uintptr { return (n + a - 1) \u0026^ (a - 1) } MulUintptr() MulUintptrè¿”å›a * bä»¥åŠä¹˜æ³•è¿ç®—æ˜¯å¦æº¢å‡ºã€‚ åœ¨å—æ”¯æŒçš„å¹³å°ä¸Šï¼Œè¿™æ˜¯ç”±ç¼–è¯‘å™¨é™ä½çš„å›ºæœ‰ç‰¹æ€§ã€‚ 1 2 3 4 5 6 7 8 9 10 11 // MulUintptr returns a * b and whether the multiplication overflowed. // On supported platforms this is an intrinsic lowered by the compiler. func MulUintptr(a, b uintptr) (uintptr, bool) { // a|b \u003c 1\u003c\u003c16 || a|b \u003c 1\u003c\u003c32 if a|b \u003c 1\u003c\u003c(4*goarch.PtrSize) || a == 0 { return a * b, false } // const MaxUintptr = ^uintptr(0) overflow := b \u003e MaxUintptr/a return a * b, overflow } ",
  "wordCount" : "3102",
  "inLanguage": "zh",
  "image": "https://heliu.site/favicon-32x32.png","datePublished": "2024-07-21T17:58:15+08:00",
  "dateModified": "2024-07-21T17:58:15+08:00",
  "author":[{
    "@type": "Person",
    "name": "helium"
  }],
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://heliu.site/posts/golang/slice/theory/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Helium",
    "logo": {
      "@type": "ImageObject",
      "url": "https://heliu.site/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://heliu.site/" accesskey="h" title="Blog (Alt + H)">
                <img src="https://heliu.site/helium.png" alt="" aria-label="logo"
                    height="35">Blog</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://heliu.site/" title="ä¸»é¡µ">
                    <span>Home</span>
                </a>
            </li>
            <li>
                <a href="https://heliu.site/posts" title="æ–‡ç« ">
                    <span>Article</span>
                </a>
            </li>
            <li>
                <a href="https://heliu.site/archives" title="æ—¶é—´è½´">
                    <span>Archive</span>
                </a>
            </li>
            <li>
                <a href="https://heliu.site/tags/" title="æ ‡ç­¾">
                    <span>Tag</span>
                </a>
            </li>
            <li>
                <a href="https://heliu.site/search/" title="æœç´¢ (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
            <li>
                <a href="https://heliu.site/support" title="æ‰“èµ">
                    <span>ğŸ«¶Help</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">


<article class="post" autonumbering>
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://heliu.site/">ä¸»é¡µ</a>&nbsp;Â»&nbsp;<a href="https://heliu.site/posts/">Article</a>&nbsp;Â»&nbsp;<a href="https://heliu.site/posts/golang/">golang åˆé›†</a>&nbsp;Â»&nbsp;<a href="https://heliu.site/posts/golang/slice/">ç¬¬7ç«  Slice</a></div>
    <h1 class="post-title entry-hint-parent">
      Slice(åŸç†)
    </h1>
    <div class="post-description">
      ğŸ’¥æœ¬æ–‡ç« æ‰€æœ‰ç›¸å…³goä»£ç å‚è€ƒè‡ªgo 1.18&#43;ç‰ˆæœ¬
    </div>
    <div class="post-meta">










<span class="x-post-meta-item"><svg t="1720837714681" class="icon" viewBox="0 0 1084 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="7520" width="200" height="200"><path d="M123.47509 1023.984942a123.565437 123.565437 0 0 1-123.505206-123.32451V243.863302A123.565437 123.565437 0 0 1 123.47509 120.568908h171.630374V26.06529a26.050232 26.050232 0 0 1 52.070349 0v94.503618h377.592848V26.06529a26.050232 26.050232 0 0 1 52.100464 0v94.503618h183.797189A123.565437 123.565437 0 0 1 1084.171519 243.863302v656.79713A123.565437 123.565437 0 0 1 960.666314 1023.984942H123.47509z m-71.404741-123.32451A71.434857 71.434857 0 0 0 123.47509 971.974825h837.191224a71.434857 71.434857 0 0 0 71.404741-71.314393V442.326922l-946.361273-3.824716a25.598494 25.598494 0 0 1-5.84248-0.692665l-27.796953-6.444798v469.295689zM123.47509 172.579025a71.434857 71.434857 0 0 0-71.404741 71.284277v149.736133l27.796953-6.444797a26.080348 26.080348 0 0 1 5.902712-0.662549l946.301041 3.824716V243.863302a71.404741 71.404741 0 0 0-71.404741-71.284277h-180.183284l-6.173754 12.859479a26.200812 26.200812 0 0 1-23.490383 14.786895 26.261043 26.261043 0 0 1-23.520499-14.786895l-6.173754-12.859479H350.819834l-6.173754 12.859479a26.200812 26.200812 0 0 1-23.490383 14.786895 26.230928 26.230928 0 0 1-23.520499-14.786895l-6.173755-12.859479H123.47509z m156.150814 578.827128a26.050232 26.050232 0 0 1-26.050232-25.990001c0-14.335157 11.68496-26.020116 26.050232-26.020116h521.697312c14.365273 0 26.050232 11.68496 26.050233 26.020116a26.050232 26.050232 0 0 1-26.050233 25.990001H279.625904z" fill="#3D3F42" p-id="7521"></path></svg><span>2024-07-21</span></span>&nbsp;<span class="x-post-meta-item"><svg t="1720839329181" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="14106" width="200" height="200"><path d="M699.270662 190.485379c-0.411369 0-0.821715 0.011256-1.227967 0.032746H507.034407a23.041786 23.041786 0 0 0-1.221828-0.031723c-12.779048 0-23.140023 10.359952-23.140023 23.139 0 12.781094 10.360975 23.141046 23.140023 23.141046v0.032746h193.458083v-0.032746c12.780071 0 23.141046-10.359952 23.141047-23.141046 0-12.780071-10.360975-23.140023-23.141047-23.140023zM979.215516 724.005508c0-142.090159-115.186416-257.277598-257.277598-257.277598-72.245418 0-137.532353 29.777187-184.262654 77.725223l45.868677 31.474852c36.227086-33.873482 84.882226-54.617945 138.393977-54.617945 111.945605 0 202.696492 90.750887 202.696492 202.695468h-43.01263l70.331835 104.289228 70.331835-104.289228H979.215516z" fill="" p-id="14107"></path><path d="M748.885664 588.843132c0-14.881942-12.06785-26.945699-26.947746-26.945698-14.883989 0-26.947745 12.063757-26.947745 26.945698v135.164423c0 14.879895 12.063757 26.945699 26.947745 26.945699h107.786889c14.881942 0 26.945699-12.063757 26.945698-26.945699s-12.063757-26.945699-26.945698-26.945699h-80.839143V588.843132zM721.937918 926.702c-111.947651 0-202.696492-90.74884-202.696492-202.696492 0-0.144286 0.004093-0.285502 0.004094-0.429788h43.004443l-70.330812-104.289228-70.331835 104.289228h43.075051c0 0.144286-0.00307 0.285502-0.00307 0.429788 0 142.091182 115.187439 257.279644 257.278621 257.279645 72.241324 0 137.530306-29.77821 184.260607-77.727269l-45.86663-31.474852c-36.227086 33.873482-84.884272 54.618968-138.393977 54.618968zM694.633039 423.38066c-1.354857-11.487635-11.120268-20.400632-22.972201-20.400632H206.362486c-12.780071 0-23.140023 10.359952-23.140023 23.138999 0 12.781094 10.359952 23.141046 23.140023 23.141047H596.949252c30.209022-13.81668 63.104223-22.76754 97.683787-25.879414zM438.548616 623.143333H206.362486c-12.780071 0-23.140023 10.358929-23.140023 23.140023 0 12.780071 10.359952 23.140023 23.140023 23.140023h219.956598a298.463626 298.463626 0 0 1 12.229532-46.280046zM506.934123 513.062192H206.362486c-12.780071 0-23.140023 10.359952-23.140023 23.139 0 12.781094 10.359952 23.140023 23.140023 23.140023H469.936487a302.241672 302.241672 0 0 1 36.997636-46.279023z" fill="" p-id="14108"></path><path d="M442.765661 835.277778a298.531164 298.531164 0 0 1-14.365173-46.150087H146.542052v-0.065491c-33.036417 0-59.81941-26.78197-59.81941-59.819411V329.36031h704.907545v100.905154a298.561863 298.561863 0 0 1 46.150086 14.996552V194.619536h-0.162706c0-53.422723-43.307342-96.728018-96.730065-96.728018h-68.89409V84.418668c0-33.037441-26.782993-59.81941-59.81941-59.81941v-0.361227h-18.87079v0.032745c-33.038464 0-59.820434 26.78197-59.820433 59.819411 0 0.109494 0.008186 0.218988 0.008186 0.328481h-0.339738v13.47285H345.203648V84.418668c0-33.037441-26.782993-59.81941-59.819411-59.81941v-0.361227h-18.872836v0.032745c-33.036417 0-59.81941 26.78197-59.81941 59.819411 0 0.109494 0.007163 0.218988 0.008186 0.328481h-0.339737v13.47285h-69.189826c-53.4217 0-96.729042 43.306318-96.729041 96.728018 0 1.701758 0.045025 3.39226 0.132006 5.071505v533.785166a98.051153 98.051153 0 0 0-0.132006 5.071506c0 53.4217 43.307342 96.728018 96.729041 96.728018v0.001023h305.595047zM86.723665 204.056466c0-33.037441 26.782993-59.81941 59.819411-59.819411 0.044002 0 0.086981 0.00307 0.130983 0.00307v-0.068561h105.968473V94.874811h0.032746a22.807449 22.807449 0 0 1-0.032746-1.215688c0-12.779048 10.360975-23.140023 23.140023-23.140023s23.140023 10.360975 23.140023 23.140023c0 0.408299-0.010233 0.812505-0.031722 1.215688h0.031722v49.297776h280.508696V94.874811h0.032745a22.807449 22.807449 0 0 1-0.032745-1.215688c0-12.779048 10.361999-23.140023 23.140023-23.140023 12.780071 0 23.141046 10.360975 23.141046 23.140023 0 0.408299-0.011256 0.812505-0.032746 1.215688h0.032746v49.297776h106.10048v0.065492c33.035394 0 59.818387 26.780947 59.818387 59.81941h0.130983V283.080264H86.723665v-79.023798z" fill="" p-id="14109"></path></svg><span>2024-07-21</span></span>&nbsp;<span class="x-post-meta-item"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2" fill="none"
     stroke-linecap="round" stroke-linejoin="round" class="feather feather-file-text" style="user-select: text;">
    <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z" style="user-select: text;"></path>
    <polyline points="14 2 14 8 20 8" style="user-select: text;"></polyline>
    <line x1="16" y1="13" x2="8" y2="13" style="user-select: text;"></line>
    <line x1="16" y1="17" x2="8" y2="17" style="user-select: text;"></line>
    <polyline points="10 9 9 9 8 9" style="user-select: text;"></polyline>
</svg><span>3102å­—</span></span>&nbsp;<span class="x-post-meta-item"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2" fill="none"
     stroke-linecap="round" stroke-linejoin="round">
    <path stroke="none" d="M0 0h24v24H0z" fill="none"></path>
    <circle cx="12" cy="12" r="9"></circle>
    <polyline points="12 7 12 12 15 15"></polyline>
</svg><span>15åˆ†é’Ÿ</span></span>&nbsp;<span class="x-post-meta-item"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2" fill="none"
     stroke-linecap="round" stroke-linejoin="round">
    <path stroke="none" d="M0 0h24v24H0z" fill="none"></path>
    <circle cx="12" cy="7" r="4"></circle>
    <path d="M6 21v-2a4 4 0 0 1 4 -4h4a4 4 0 0 1 4 4v2"></path>
</svg><span>helium</span></span>
      <span class="x-post-meta-item">
        &nbsp;<svg t="1720840393161" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="18680" width="200" height="200"><path d="M995.125144 559.61812l-415.998603-415.998602A52.986489 52.986489 0 0 0 541.413335 127.99957H338.847348c-3.166656-26.559911-9.286635-51.046495-17.999939-71.333094C299.734146 7.333309 271.154242 0 256.00096 0c-13.939953 0-40.439864 6.339979-61.259794 48.806503-10.473298 21.366595-17.946606 48.966502-21.573261 79.193067H53.334974a53.393154 53.393154 0 0 0-53.333154 53.333154v360.078791a52.986489 52.986489 0 0 0 15.619948 37.713206l415.998602 415.998603a53.333154 53.333154 0 0 0 75.426413 0l26.286579-26.293245 26.286578 26.293245a53.426487 53.426487 0 0 0 16.719944 11.333295 21.333262 21.333262 0 0 0 36.079879 11.293295l382.705381-382.705381a53.399821 53.399821 0 0 0 0-75.426413z m-762.070774-491.998347C241.494342 50.373164 250.667645 42.666523 256.00096 42.666523c5.99998 0 16.573278 9.639968 25.646581 30.806564 6.493312 15.159949 11.333295 33.999886 14.146619 54.526483H216.16776c3.206656-23.419921 9.013303-44.359851 16.88661-60.41313z m243.819181 897.330319a10.666631 10.666631 0 0 1-15.079949 0l-415.998603-415.998603A10.573298 10.573298 0 0 1 42.668343 541.411515V181.332724a10.666631 10.666631 0 0 1 10.666631-10.666631h245.332509c0 47.853173-10.373298 92.15969-27.066575 115.632945-5.926647 8.326639-16.566611 14.186619-22.306592 16.113279C204.041135 314.752276 170.667913 356.218803 170.667913 405.331972c0 58.813136 47.853173 106.666308 106.666309 106.666308s106.666308-47.853173 106.666308-106.666308c0-47.086508-30.666564-87.139707-73.079754-101.246327C330.060711 272.705751 341.334007 223.692582 341.334007 170.666093h72.079758a10.573298 10.573298 0 0 1 7.539974 3.126656l415.998603 415.998603a10.666631 10.666631 0 0 1 0 15.079949zM341.334007 405.331972a63.999785 63.999785 0 1 1-63.999785-63.999785 64.073118 64.073118 0 0 1 63.999785 63.999785z m263.539114 559.61812a10.666631 10.666631 0 0 1-15.079949 0L563.499927 938.663513l303.625647-303.61898a53.399821 53.399821 0 0 0 0-75.426413L478.16688 170.666093h63.246455a10.573298 10.573298 0 0 1 7.539974 3.126656l415.998603 415.998603c0.239999 0.239999 0.466665 0.486665 0.666664 0.746664l0.086667 0.106666a10.666631 10.666631 0 0 1 0 13.373289l-0.086667 0.106666c-0.213333 0.259999-0.439999 0.506665-0.666664 0.746664z" fill="#5C5C66" p-id="18681"></path></svg>
        <ul class="post-tags-meta" style="display: inline-block;font-size: 14px;">
            <a href="https://heliu.site/tags/golang/" target="_blank" rel="noopener">Golang</a>
            <a href="https://heliu.site/tags/slice/" target="_blank" rel="noopener">Slice</a>
        </ul>
      </span>
      
      <span id="busuanzi_container_page_pv" class="x-post-meta-item">
        &nbsp;<svg t="1720844685710" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="27237" width="200" height="200"><path d="M739.754667 574.08c-121.386667 45.610667-208.469333 169.813333-208.64 316.16 0 33.408 4.693333 65.493333 13.141333 95.914667H94.122667c-26.453333-43.52-41.685333-91.946667-41.685334-143.189334 0-185.173333 192.896-335.104 430.805334-335.104 96.256 0 184.832 24.746667 256.512 66.218667z m-280.490667-114.986667a214.869333 214.869333 0 0 1-214.869333-215.04A215.04 215.04 0 0 1 459.264 28.842667a215.04 215.04 0 0 1 215.04 215.210666 215.04 215.04 0 0 1-215.04 215.04zM974.506667 641.28c9.856 0 17.834667 7.466667 17.834666 16.64v59.989333c-0.341333 8.789333-7.850667 15.786667-17.28 16.085334-9.856 0.341333-18.176-6.826667-18.517333-16.085334v-20.053333l-99.114667 91.093333-0.256 0.256a18.474667 18.474667 0 0 1-14.848 4.352h-0.768a18.176 18.176 0 0 1-9.344-4.608l-0.938666-0.981333-85.930667-80.042667-123.562667 115.072a18.773333 18.773333 0 0 1-25.216 0 15.786667 15.786667 0 0 1 0-23.466666l136.149334-126.848 0.725333-0.597334a18.645333 18.645333 0 0 1 24.362667 0.512l87.253333 81.237334 86.058667-79.232h-21.248c-9.386667-0.298667-16.938667-7.338667-17.28-16.085334-0.341333-9.173333 7.381333-16.896 17.28-17.237333h64.64z m-367.146667 240h48.128c8.874667 0 16.042667 7.168 16.042667 16.042667v72.192a16.042667 16.042667 0 0 1-16.042667 16.042666h-48.128a16.042667 16.042667 0 0 1-16.042667-16.042666v-72.192c0-8.874667 7.210667-16.042667 16.042667-16.042667z m110.805333-106.666667h48.128c8.874667 0 16.042667 7.168 16.042667 16.042667v178.858667a16.042667 16.042667 0 0 1-16.042667 16.042666h-48.128a16.042667 16.042667 0 0 1-16.042666-16.042666v-178.858667c0-8.874667 7.168-16.042667 16.042666-16.042667z m106.538667 80h48.128c8.874667 0 16.042667 7.168 16.042667 16.042667v99.413333a16.042667 16.042667 0 0 1-16.042667 16.042667H824.746667a16.042667 16.042667 0 0 1-16.042667-16.042667v-99.413333c0-8.874667 7.168-16.042667 16.042667-16.042667z m110.165333-80h48.128c8.874667 0 16.042667 7.168 16.042667 16.042667v179.413333a16.042667 16.042667 0 0 1-16.042667 16.042667h-48.128a16.042667 16.042667 0 0 1-16.042666-16.042667v-179.413333c0-8.874667 7.210667-16.042667 16.042666-16.042667z" fill="#999999" p-id="27238"></path></svg>
        <span id="busuanzi_value_page_pv"></span>
      </span>

</div>
  </header> <aside id="toc-container" class="toc-container wide">
    <div class="toc">
        <details  open>
            <summary accesskey="c" title="(Alt + C)">
                <span class="details">ç›®å½•</span>
            </summary>

            <div class="inner"><ul>
                    <li>
                        <a href="#type-slice-struct" aria-label="type slice struct"><code>type slice struct</code></a></li>
                    <li>
                        <a href="#type-notinheapslice-struct" aria-label="type notInHeapSlice struct"><code>type notInHeapSlice struct</code></a><ul>
                            
                    <li>
                        <a href="#type-notinheap-struct" aria-label="type notInHeap struct"><code>type notInHeap struct</code></a></li>
                    <li>
                        <a href="#add" aria-label="add()"><code>add()</code></a></li></ul>
                    </li>
                    <li>
                        <a href="#make" aria-label="make()"><code>make()</code></a><ul>
                            
                    <li>
                        <a href="#makeslice" aria-label="makeslice()"><code>makeslice()</code></a></li>
                    <li>
                        <a href="#makeslice64" aria-label="makeslice64()"><code>makeslice64()</code></a></li></ul>
                    </li>
                    <li>
                        <a href="#len" aria-label="len()"><code>len()</code></a></li>
                    <li>
                        <a href="#cap" aria-label="cap()"><code>cap()</code></a></li>
                    <li>
                        <a href="#copy" aria-label="copy()"><code>copy()</code></a><ul>
                            
                    <li>
                        <a href="#slicecopy" aria-label="slicecopy()"><code>slicecopy()</code></a></li>
                    <li>
                        <a href="#memmove" aria-label="memmove()"><code>memmove()</code></a></li></ul>
                    </li>
                    <li>
                        <a href="#append" aria-label="append()"><code>append()</code></a><ul>
                            
                    <li>
                        <a href="#growslice" aria-label="growslice()"><code>growslice()</code></a></li>
                    <li>
                        <a href="#roundupsize" aria-label="roundupsize()"><code>roundupsize()</code></a></li>
                    <li>
                        <a href="#alignup" aria-label="alignUp()"><code>alignUp()</code></a></li>
                    <li>
                        <a href="#muluintptr" aria-label="MulUintptr()"><code>MulUintptr()</code></a>
                    </li>
                </ul>
                </li>
                </ul>
            </div>
        </details>
    </div>
</aside>
<script>
    let activeElement;
    let elements;
    window.addEventListener('DOMContentLoaded', function (event) {
        checkTocPosition();

        elements = document.querySelectorAll('h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]');
         
         activeElement = elements[0];
         const id = encodeURI(activeElement.getAttribute('id')).toLowerCase();
         document.querySelector(`.inner ul li a[href="#${id}"]`).classList.add('active');
     }, false);

    window.addEventListener('resize', function(event) {
        checkTocPosition();
    }, false);

    window.addEventListener('scroll', () => {
        
        activeElement = Array.from(elements).find((element) => {
            if ((getOffsetTop(element) - window.pageYOffset) > 0 && 
                (getOffsetTop(element) - window.pageYOffset) < window.innerHeight/2) {
                return element;
            }
        }) || activeElement

        elements.forEach(element => {
             const id = encodeURI(element.getAttribute('id')).toLowerCase();
             if (element === activeElement){
                 document.querySelector(`.inner ul li a[href="#${id}"]`).classList.add('active');
             } else {
                 document.querySelector(`.inner ul li a[href="#${id}"]`).classList.remove('active');
             }
         })
     }, false);

    const main = parseInt(getComputedStyle(document.body).getPropertyValue('--article-width'), 10);
    const toc = parseInt(getComputedStyle(document.body).getPropertyValue('--toc-width'), 10);
    const gap = parseInt(getComputedStyle(document.body).getPropertyValue('--gap'), 10);

    function checkTocPosition() {
        const width = document.body.scrollWidth;

        if (width - main - (toc * 2) - (gap * 4) > 0) {
            document.getElementById("toc-container").classList.add("wide");
        } else {
            document.getElementById("toc-container").classList.remove("wide");
        }
    }

    function getOffsetTop(element) {
        if (!element.getClientRects().length) {
            return 0;
        }
        let rect = element.getBoundingClientRect();
        let win = element.ownerDocument.defaultView;
        return rect.top + win.pageYOffset;   
    }
</script>
  <div class="post-content"><ul>
<li>æœ¬ç¯‡æ–‡ç« éƒ½æ˜¯<code>slice</code>çš„æºç èµ°è¯»ã€‚</li>
<li>æ³¨æ„ï¼šslice <strong>ä¸æ˜¯å¹¶å‘å®‰å…¨</strong>çš„æ•°æ®ç»“æ„ï¼Œå¤§å®¶åœ¨ä½¿ç”¨æ—¶è¯·åŠ¡å¿…æ³¨æ„å¹¶å‘å®‰å…¨é—®é¢˜ã€‚</li>
</ul>
<h2 id="type-slice-struct"><code>type slice struct</code><a hidden class="anchor" aria-hidden="true" href="#type-slice-struct">#</a></h2>
<ol>
<li>åˆ‡ç‰‡çš„å†…å­˜å¸ƒå±€ã€‚
<ul>
<li><code>array</code>ï¼šæŒ‡å‘ä¸€ä¸ª<code>[cap]T</code>å¤§å°çš„æ•°ç»„åœ°å€ã€‚å°±æ˜¯æŒ‡å‘ä¸€ä¸ª<code>cap</code>å®¹é‡å¤§å°çš„æ•°ç»„é¦–åœ°å€ã€‚</li>
<li><code>len</code>ï¼šè®°å½•åˆ‡ç‰‡å·²å­˜å‚¨å…ƒç´ çš„é•¿åº¦ï¼Œä¹Ÿæ˜¯å¯è®¿é—®çš„æœ€å¤§ä¸‹æ ‡<code>len - 1</code>ã€‚</li>
<li><code>cap</code>ï¼šè®°å½•åˆ‡ç‰‡çš„å®¹é‡ï¼Œä¹Ÿå°±æ˜¯å½“å‰åˆ‡ç‰‡å­˜å‚¨çš„æœ€å¤§å…ƒç´ æ•°é‡ï¼ˆæœªæ‰©å®¹å‰ï¼‰ã€‚</li>
</ul>
</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">slice</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">array</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span>
</span></span><span class="line"><span class="cl">    <span class="nx">len</span>   <span class="kt">int</span>
</span></span><span class="line"><span class="cl">    <span class="nx">cap</span>   <span class="kt">int</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p><img loading="lazy" src="../images/slice-001.png" alt=""  />
</p>
<h2 id="type-notinheapslice-struct"><code>type notInHeapSlice struct</code><a hidden class="anchor" aria-hidden="true" href="#type-notinheapslice-struct">#</a></h2>
<ol>
<li><code>notInHeapSlice</code>æ˜¯<code>go:notinheap</code>å†…å­˜æ”¯æŒçš„<code>slice</code>ã€‚</li>
<li>ä¹Ÿå°±æ˜¯è¯¥ç±»å‹çš„å¯¹è±¡<strong>ä¸æ˜¯åœ¨å †</strong>ä¸­åˆ›å»ºçš„ï¼Œä¹Ÿå°±æ˜¯GCä¸ä¼šæ‰«æï¼Œå¤šç”¨äºå†…å­˜ç®¡ç†æ¨¡å—ä¸­ã€‚</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// A notInHeapSlice is a slice backed by go:notinheap memory.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">type</span> <span class="nx">notInHeapSlice</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">array</span> <span class="o">*</span><span class="nx">notInHeap</span>    <span class="c1">// æŒ‡å‘ä¸€ä¸ªèµ·å§‹åœ°å€
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">len</span>   <span class="kt">int</span>
</span></span><span class="line"><span class="cl">    <span class="nx">cap</span>   <span class="kt">int</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="type-notinheap-struct"><code>type notInHeap struct</code><a hidden class="anchor" aria-hidden="true" href="#type-notinheap-struct">#</a></h3>
<ol>
<li><code>notInHeap</code>æ˜¯ç”±<code>sysAlloc</code>æˆ–<code>persistentAlloc</code>ç­‰åº•å±‚åˆ†é…å™¨åˆ†é…çš„å †å¤–å†…å­˜ã€‚</li>
<li>ä¸€èˆ¬æ¥è¯´ï¼Œæœ€å¥½ä½¿ç”¨æ ‡è®°ä¸º<code>go:notinheap</code>çš„çœŸå®ç±»å‹ï¼Œä½†åœ¨æ— æ³•è¿™æ ·åšçš„æƒ…å†µä¸‹(æ¯”å¦‚åœ¨åˆ†é…å™¨ä¸­)ï¼Œå®ƒç”¨ä½œé€šç”¨ç±»å‹ã€‚</li>
<li>TODOï¼šä½¿ç”¨å®ƒä½œä¸º<code>sysAlloc</code>,<code>persistentAlloc</code>ç­‰çš„è¿”å›ç±»å‹?</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// notInHeap is off-heap memory allocated by a lower-level allocator
</span></span></span><span class="line"><span class="cl"><span class="c1">// like sysAlloc or persistentAlloc.
</span></span></span><span class="line"><span class="cl"><span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1">// In general, it&#39;s better to use real types marked as go:notinheap,
</span></span></span><span class="line"><span class="cl"><span class="c1">// but this serves as a generic type for situations where that isn&#39;t
</span></span></span><span class="line"><span class="cl"><span class="c1">// possible (like in the allocators).
</span></span></span><span class="line"><span class="cl"><span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1">// TODO: Use this as the return type of sysAlloc, persistentAlloc, etc?
</span></span></span><span class="line"><span class="cl"><span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1">//go:notinheap
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">type</span> <span class="nx">notInHeap</span> <span class="kd">struct</span><span class="p">{}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="add"><code>add()</code><a hidden class="anchor" aria-hidden="true" href="#add">#</a></h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">p</span> <span class="o">*</span><span class="nx">notInHeap</span><span class="p">)</span> <span class="nf">add</span><span class="p">(</span><span class="nx">bytes</span> <span class="kt">uintptr</span><span class="p">)</span> <span class="o">*</span><span class="nx">notInHeap</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// p + bytes
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">return</span> <span class="p">(</span><span class="o">*</span><span class="nx">notInHeap</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">p</span><span class="p">))</span> <span class="o">+</span> <span class="nx">bytes</span><span class="p">))</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="make"><code>make()</code><a hidden class="anchor" aria-hidden="true" href="#make">#</a></h2>
<ol>
<li><code>make</code>å†…ç½®å‡½æ•°åˆ†é…å¹¶åˆå§‹åŒ–ä¸€ä¸ªç±»å‹ä¸º<code>slice</code>ã€<code>map</code>æˆ–<code>chan</code>çš„å¯¹è±¡(only)ã€‚</li>
<li>å’Œ<code>new</code>ä¸€æ ·ï¼Œç¬¬ä¸€ä¸ªå‚æ•°æ˜¯ç±»å‹ï¼Œè€Œä¸æ˜¯å€¼ã€‚ä¸<code>new</code>ä¸åŒï¼Œ<code>make</code>çš„è¿”å›å€¼ç±»å‹ä¸å…¶å‚æ•°çš„ç±»å‹ç›¸åŒï¼Œè€Œä¸æ˜¯æŒ‡å‘å‚æ•°çš„æŒ‡é’ˆã€‚</li>
<li>å…·ä½“çš„ç»“æœå–å†³äºç±»å‹ï¼š
<ol>
<li><code>Slice</code>ï¼š
<ul>
<li>sizeæŒ‡å®šäº†é•¿åº¦ã€‚åˆ‡ç‰‡çš„å®¹é‡ç­‰äºå®ƒçš„é•¿åº¦ã€‚</li>
<li>ä»¥æä¾›ç¬¬äºŒä¸ªæ•´æ•°å‚æ•°æ¥æŒ‡å®šä¸åŒçš„å®¹é‡;å®ƒå¿…é¡»ä¸å°äºé•¿åº¦ã€‚</li>
<li>ä¾‹å¦‚ï¼Œ<code>make([]int, 0, 10)</code>ä¼šåˆ†é…ä¸€ä¸ªé•¿åº¦ä¸º10çš„åº•å±‚æ•°ç»„ï¼Œå¹¶è¿”å›ä¸€ä¸ªé•¿åº¦ä¸º0ã€å®¹é‡ä¸º10çš„åˆ‡ç‰‡ã€‚</li>
</ul>
</li>
<li><code>Map</code>ï¼šä¸€ä¸ªç©ºçš„<code>map</code>åˆ†é…äº†è¶³å¤Ÿçš„ç©ºé—´æ¥ä¿å­˜æŒ‡å®šæ•°é‡çš„å…ƒç´ ã€‚åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œå¯ä»¥çœç•¥é•¿åº¦ï¼Œåˆ†é…ä¸€ä¸ªè¾ƒå°çš„èµ·å§‹é•¿åº¦ã€‚</li>
<li><code>Channel</code>ï¼šchannelç¼“å†²åŒºä½¿ç”¨æŒ‡å®šçš„ç¼“å†²åŒºå®¹é‡åˆå§‹åŒ–ã€‚å¦‚æœä¸º0ï¼Œæˆ–è€…sizeè¢«çœç•¥ï¼Œåˆ™channelæ˜¯æ— ç¼“å†²çš„ã€‚</li>
</ol>
</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// The make built-in function allocates and initializes an object of type
</span></span></span><span class="line"><span class="cl"><span class="c1">// slice, map, or chan (only). Like new, the first argument is a type, not a
</span></span></span><span class="line"><span class="cl"><span class="c1">// value. Unlike new, make&#39;s return type is the same as the type of its
</span></span></span><span class="line"><span class="cl"><span class="c1">// argument, not a pointer to it. The specification of the result depends on
</span></span></span><span class="line"><span class="cl"><span class="c1">// the type:
</span></span></span><span class="line"><span class="cl"><span class="c1">//	Slice: The size specifies the length. The capacity of the slice is
</span></span></span><span class="line"><span class="cl"><span class="c1">//	equal to its length. A second integer argument may be provided to
</span></span></span><span class="line"><span class="cl"><span class="c1">//	specify a different capacity; it must be no smaller than the
</span></span></span><span class="line"><span class="cl"><span class="c1">//	length. For example, make([]int, 0, 10) allocates an underlying array
</span></span></span><span class="line"><span class="cl"><span class="c1">//	of size 10 and returns a slice of length 0 and capacity 10 that is
</span></span></span><span class="line"><span class="cl"><span class="c1">//	backed by this underlying array.
</span></span></span><span class="line"><span class="cl"><span class="c1">//	Map: An empty map is allocated with enough space to hold the
</span></span></span><span class="line"><span class="cl"><span class="c1">//	specified number of elements. The size may be omitted, in which case
</span></span></span><span class="line"><span class="cl"><span class="c1">//	a small starting size is allocated.
</span></span></span><span class="line"><span class="cl"><span class="c1">//	Channel: The channel&#39;s buffer is initialized with the specified
</span></span></span><span class="line"><span class="cl"><span class="c1">//	buffer capacity. If zero, or the size is omitted, the channel is
</span></span></span><span class="line"><span class="cl"><span class="c1">//	unbuffered.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nb">make</span><span class="p">(</span><span class="nx">t</span> <span class="nx">Type</span><span class="p">,</span> <span class="nx">size</span> <span class="o">...</span><span class="nx">IntegerType</span><span class="p">)</span> <span class="nx">Type</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="makeslice"><code>makeslice()</code><a hidden class="anchor" aria-hidden="true" href="#makeslice">#</a></h3>
<ol>
<li><code>make([]T *_type, len, cap int)</code>
<ul>
<li><code>*_type</code>ï¼šè®°å½•ç€åˆ‡ç‰‡å…ƒç´ ç±»å‹ï¼Œæ¯”å¦‚<code>[]string</code>åˆ‡ç‰‡è¿™é‡Œæ˜¯<code>string</code>çš„å…ƒç±»å‹ã€‚</li>
<li><code>len</code>ï¼šåˆ‡ç‰‡çš„é•¿åº¦ï¼Œè¯¥å‚æ•°æ˜¯å¿…ä¼ ã€‚</li>
<li><code>cap</code>ï¼šåˆ‡ç‰‡çš„å®¹é‡ï¼Œè¯¥å‚æ•°æ˜¯å¯ä¼ ï¼Œé»˜è®¤ä¼šä¼ <code>len</code>å¤§å°ã€‚</li>
</ul>
</li>
<li><code>makeslice()</code>å‡½æ•°æ˜¯åˆ‡ç‰‡ç”³è¯·å†…å­˜çš„make()å‡½æ•°åŸå‹ï¼Œä¸»è¦è´Ÿè´£ç”³è¯·<code>slice.array</code>å­—æ®µæŒ‡å‘çš„å†…å­˜å¤§å°ã€‚</li>
<li>é‚£ä¹ˆåˆ‡ç‰‡çš„24å­—èŠ‚å¤§å°å†…å­˜æ˜¯åœ¨ä»€ä¹ˆæ—¶å€™åˆ†é…çš„ï¼Ÿï¼ˆ64ä½ç³»ç»Ÿä¸‹ä¸º24å­—èŠ‚å†…å­˜ï¼Œ32ç³»ç»Ÿä¸‹ä¸º12å­—èŠ‚å†…å­˜ï¼‰
<ul>
<li>å¯èƒ½åœ¨å‡½æ•°æ ˆä¸Šç›´æ¥åˆ†é…24å­—èŠ‚å¤§å°å†…å­˜ã€‚</li>
<li>ä¹Ÿå¯èƒ½åœ¨å †ä¸Šåˆ†é…24å­—èŠ‚å¤§å°å†…å­˜ã€‚</li>
</ul>
</li>
<li>è°ƒç”¨äº†<code>makeslice()</code>å‡½æ•°ï¼Œå…¶<code>slice.array</code>æŒ‡å‘çš„å†…å­˜å—ä¸€å®šæ˜¯åœ¨<strong>å †</strong>ä¸Šã€‚æ²¡æœ‰è°ƒè¯¥å‡½æ•°æ—¶å¯èƒ½å†…å­˜åˆ†é…åœ¨<strong>æ ˆ</strong>ä¸Šã€‚</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">makeslice</span><span class="p">(</span><span class="nx">et</span> <span class="o">*</span><span class="nx">_type</span><span class="p">,</span> <span class="nx">len</span><span class="p">,</span> <span class="nx">cap</span> <span class="kt">int</span><span class="p">)</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 1ï¼‰åˆ¤æ–­et.size * uintptr(cap)æ˜¯å¦é€ æˆå†…å­˜æº¢å‡º
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">mem</span><span class="p">,</span> <span class="nx">overflow</span> <span class="o">:=</span> <span class="nx">math</span><span class="p">.</span><span class="nf">MulUintptr</span><span class="p">(</span><span class="nx">et</span><span class="p">.</span><span class="nx">size</span><span class="p">,</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">cap</span><span class="p">))</span> <span class="c1">// æŒ‰ç…§capè®¡ç®—çš„
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//  1. ã€overflow == trueã€‘ï¼šæº¢å‡º
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//  2. ã€mem &gt; maxAllocã€‘ï¼šè¶…è¿‡æ“ä½œç³»ç»Ÿæœ€å¤§å†…å­˜
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//  3. ã€len &lt; 0ã€‘ï¼šé”™è¯¯çš„lenå‚æ•°
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//  4. ã€len &gt; capã€‘ï¼šé•¿åº¦å¤§äºå®¹é‡
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nx">overflow</span> <span class="o">||</span> <span class="nx">mem</span> <span class="p">&gt;</span> <span class="nx">maxAlloc</span> <span class="o">||</span> <span class="nx">len</span> <span class="p">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="nx">len</span> <span class="p">&gt;</span> <span class="nx">cap</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// NOTE: Produce a &#39;len out of range&#39; error instead of a
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// &#39;cap out of range&#39; error when someone does make([]T, bignumber).
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// &#39;cap out of range&#39; is true too, but since the cap is only being
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// supplied implicitly, saying len is clearer.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// See golang.org/issue/4085.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// å½“æœ‰äºº make([]T, bignumber) æ—¶ï¼Œäº§ç”Ÿä¸€ä¸ª &#39;len out of range&#39; é”™è¯¯è€Œä¸æ˜¯ &#39;cap out of range&#39; é”™è¯¯æç¤º
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// å½“ &#39;cap out of range&#39; ä¹Ÿæ˜¯å¤ªé•¿äº†ï¼Œç”±äºcapåªæ˜¯éšå¼åœ°æä¾›ï¼Œæ‰€ä»¥è¯´lenæ›´æ¸…æ¥šçš„æç¤ºã€‚
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">mem</span><span class="p">,</span> <span class="nx">overflow</span> <span class="o">:=</span> <span class="nx">math</span><span class="p">.</span><span class="nf">MulUintptr</span><span class="p">(</span><span class="nx">et</span><span class="p">.</span><span class="nx">size</span><span class="p">,</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">len</span><span class="p">))</span>	<span class="c1">// æ ¹æ®lenè®¡ç®—
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="nx">overflow</span> <span class="o">||</span> <span class="nx">mem</span> <span class="p">&gt;</span> <span class="nx">maxAlloc</span> <span class="o">||</span> <span class="nx">len</span> <span class="p">&lt;</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nf">panicmakeslicelen</span><span class="p">()</span> <span class="c1">// painc &#39;len out of range&#39;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="nf">panicmakeslicecap</span><span class="p">()</span> <span class="c1">// panic &#39;cap out of range&#39;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 2ï¼‰å‘æ“ä½œç³»ç»Ÿç”³è¯·memå¤§å°çš„å†…å­˜å—ï¼Œè¿”å›ç”³è¯·åˆ°å†…å­˜å—çš„é¦–åœ°å€
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">return</span> <span class="nf">mallocgc</span><span class="p">(</span><span class="nx">mem</span><span class="p">,</span> <span class="nx">et</span><span class="p">,</span> <span class="kc">true</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="makeslice64"><code>makeslice64()</code><a hidden class="anchor" aria-hidden="true" href="#makeslice64">#</a></h3>
<ol>
<li>int64ç‰ˆæœ¬ï¼Œå¦‚æœå½“å‰æ˜¯åœ¨32ä½ç³»ç»Ÿä¸­æ—¶ï¼Œ<code>int</code>å…¶å®æ˜¯<code>int32</code>å¤§å°ã€‚</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">makeslice64</span><span class="p">(</span><span class="nx">et</span> <span class="o">*</span><span class="nx">_type</span><span class="p">,</span> <span class="nx">len64</span><span class="p">,</span> <span class="nx">cap64</span> <span class="kt">int64</span><span class="p">)</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">len</span> <span class="o">:=</span> <span class="nb">int</span><span class="p">(</span><span class="nx">len64</span><span class="p">)</span> <span class="c1">// 32ä½ç³»ç»Ÿä¸‹è½¬æ¢ä¼šä¸¢å¤±éƒ¨åˆ†æ•°æ®
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nb">int64</span><span class="p">(</span><span class="nx">len</span><span class="p">)</span> <span class="o">!=</span> <span class="nx">len64</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">panicmakeslicelen</span><span class="p">()</span> <span class="c1">// painc &#39;len out of range&#39;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nx">cap</span> <span class="o">:=</span> <span class="nb">int</span><span class="p">(</span><span class="nx">cap64</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nb">int64</span><span class="p">(</span><span class="nx">cap</span><span class="p">)</span> <span class="o">!=</span> <span class="nx">cap64</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">panicmakeslicecap</span><span class="p">()</span> <span class="c1">// panic &#39;cap out of range&#39;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nf">makeslice</span><span class="p">(</span><span class="nx">et</span><span class="p">,</span> <span class="nx">len</span><span class="p">,</span> <span class="nx">cap</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="len"><code>len()</code><a hidden class="anchor" aria-hidden="true" href="#len">#</a></h2>
<ol>
<li>ä»¥ä¸‹ä¼ªä»£ç è·å–åˆ‡ç‰‡çš„é•¿åº¦ã€‚</li>
<li>lenå‡½æ•°çš„åŸå‹ï¼š<code>func len(array []T) int</code>ã€‚</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// ä¼ªä»£ç ç¤ºä¾‹
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nb">len</span><span class="p">(</span><span class="nx">array</span> <span class="p">[]</span><span class="nx">T</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nx">array</span><span class="p">.</span><span class="nx">len</span>   
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="cap"><code>cap()</code><a hidden class="anchor" aria-hidden="true" href="#cap">#</a></h2>
<ol>
<li>ä»¥ä¸‹ä¼ªä»£ç è·å–åˆ‡ç‰‡çš„å®¹é‡ã€‚</li>
<li>capå‡½æ•°çš„åŸå‹ï¼š<code>func cap(array []T) int</code>ã€‚</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// ä¼ªä»£ç ç¤ºä¾‹
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nb">cap</span><span class="p">(</span><span class="nx">array</span> <span class="p">[]</span><span class="nx">T</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nx">array</span><span class="p">.</span><span class="nx">cap</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="copy"><code>copy()</code><a hidden class="anchor" aria-hidden="true" href="#copy">#</a></h2>
<ol>
<li>copyå†…ç½®å‡½æ•°å°†å…ƒç´ <strong>ä»æºç‰‡å¤åˆ¶åˆ°ç›®æ ‡ç‰‡</strong>ã€‚(ä½œä¸ºç‰¹æ®Šæƒ…å†µï¼Œå®ƒä¹Ÿä¼šå°†bytesä»stringå¤åˆ¶åˆ°byteåˆ‡ç‰‡ã€‚)</li>
<li>æºå’Œç›®æ ‡å¯èƒ½é‡å ã€‚</li>
<li>copyè¿”å›å¤åˆ¶çš„å…ƒç´ æ•°é‡ï¼Œè¿™å°†æ˜¯<code>len(src)</code>å’Œ<code>len(dst)</code>çš„æœ€å°å€¼ã€‚<code>src</code>-&gt;<code>dst</code>ã€‚</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// The copy built-in function copies elements from a source slice into a
</span></span></span><span class="line"><span class="cl"><span class="c1">// destination slice. (As a special case, it also will copy bytes from a
</span></span></span><span class="line"><span class="cl"><span class="c1">// string to a slice of bytes.) The source and destination may overlap. Copy
</span></span></span><span class="line"><span class="cl"><span class="c1">// returns the number of elements copied, which will be the minimum of
</span></span></span><span class="line"><span class="cl"><span class="c1">// len(src) and len(dst).
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nb">copy</span><span class="p">(</span><span class="nx">dst</span><span class="p">,</span> <span class="nx">src</span> <span class="p">[]</span><span class="nx">Type</span><span class="p">)</span> <span class="kt">int</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="slicecopy"><code>slicecopy()</code><a hidden class="anchor" aria-hidden="true" href="#slicecopy">#</a></h3>
<ol>
<li>slicecopyç”¨äºå°†pointerlesså…ƒç´ çš„å­—ç¬¦ä¸²æˆ–åˆ‡ç‰‡å¤åˆ¶åˆ°åˆ‡ç‰‡ä¸­ã€‚</li>
<li>æ³¨æ„ï¼š<code>copy()</code>çš„å‡½æ•°åŸå‹ä¸­æ²¡æœ‰å¯å˜å‚æ•°ï¼ˆ<code>... T</code>ï¼‰çš„å½¢å¼å‚æ•°ã€‚</li>
<li>slicecopy é€‚ç”¨ä»¥ä¸‹ä¸¤ç§æƒ…å†µï¼š<code>fm -&gt; to</code>
<ul>
<li>ã€<strong><code>copy(to, fm []T) int</code></strong>ã€‘</li>
<li>ã€<strong><code>copy(to []byte, fm string) int</code></strong>ã€‘</li>
</ul>
</li>
<li>æ³¨æ„ä»¥ä¸‹slicecopyå‡½æ•°å¯èƒ½åœ¨go1.18+ç‰ˆæœ¬ä¸­ä¸æ˜¯è¿™æ ·çš„ï¼Œè¿™ä¸€ç‰ˆé‡‡ç”¨çš„æ˜¯go1.22å·¦å³ç‰ˆæœ¬çš„æºç ï¼Œä½†æ˜¯åªæ˜¯å‘ç”Ÿäº†å˜åŒ–å…·ä½“é€»è¾‘æ²¡å˜ã€‚</li>
<li>å‚æ•°ï¼š<code>fromPtr -&gt; toPtr</code>
<ul>
<li><code>toPtr unsafe.Pointer</code>ï¼šç›®æ ‡åœ°å€ï¼Œä¹Ÿå°±æ˜¯ä¸Šé¢çš„<code>to.array</code>å€¼ã€‚</li>
<li><code>toLen int</code>ï¼šç›®æ ‡é•¿åº¦ï¼Œä¹Ÿå°±æ˜¯ä¸Šé¢çš„<code>to.len</code>å€¼ã€‚</li>
<li><code>fromPtr unsafe.Pointer</code>ï¼šæ¥æºåœ°å€ï¼Œä¹Ÿå°±æ˜¯ä¸Šé¢çš„<code>fm.array</code>å€¼ã€‚</li>
<li><code>fromLen int</code>ï¼šæ¥æºé•¿åº¦ï¼Œä¹Ÿå°±æ˜¯ä¸Šé¢çš„<code>fm.len</code>å€¼ã€‚</li>
<li><code>width uintptr</code>ï¼šåˆ‡ç‰‡ç±»å‹å ç”¨å†…å­˜å¤§å°ï¼Œä¹Ÿå°±æ˜¯<code>[]T</code>çš„<code>T</code>ç±»å‹çš„å¤§å°ã€‚</li>
</ul>
</li>
<li>è¿”å›å€¼ï¼š
<ul>
<li><code>int</code>ï¼šæ‹·è´çš„å…ƒç´ æ•°é‡ã€‚</li>
</ul>
</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// slicecopy is used to copy from a string or slice of pointerless elements into a slice.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">slicecopy</span><span class="p">(</span><span class="nx">toPtr</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">,</span> <span class="nx">toLen</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">fromPtr</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">,</span> <span class="nx">fromLen</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">width</span> <span class="kt">uintptr</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 1) æ‹·è´æˆ–è¢«æ‹·è´é•¿åº¦ä¸º0ç›´æ¥è¿”å›
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nx">fromLen</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="nx">toLen</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 2) æ‹·è´å…ƒç´ çš„ä¸ªæ•°å–å†³äºæ‹·è´æˆ–è¢«æ‹·è´çš„æœ€å°é•¿åº¦
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">n</span> <span class="o">:=</span> <span class="nx">fromLen</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">toLen</span> <span class="p">&lt;</span> <span class="nx">n</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">n</span> <span class="p">=</span> <span class="nx">toLen</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 3) æ‹·è´çš„å…ƒç´ å¤§å°ä¸º0ï¼Œç›´æ¥è¿”å›n
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nx">width</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>	<span class="c1">// []struct{}
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">return</span> <span class="nx">n</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 4) size éœ€è¦æ‹·è´çš„æ€»å†…å­˜å¤§å°/å­—èŠ‚ã€‚
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">size</span> <span class="o">:=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">n</span><span class="p">)</span> <span class="o">*</span> <span class="nx">width</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">raceenabled</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">callerpc</span> <span class="o">:=</span> <span class="nf">getcallerpc</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">        <span class="nx">pc</span> <span class="o">:=</span> <span class="nx">abi</span><span class="p">.</span><span class="nf">FuncPCABIInternal</span><span class="p">(</span><span class="nx">slicecopy</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="nf">racereadrangepc</span><span class="p">(</span><span class="nx">fromPtr</span><span class="p">,</span> <span class="nx">size</span><span class="p">,</span> <span class="nx">callerpc</span><span class="p">,</span> <span class="nx">pc</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="nf">racewriterangepc</span><span class="p">(</span><span class="nx">toPtr</span><span class="p">,</span> <span class="nx">size</span><span class="p">,</span> <span class="nx">callerpc</span><span class="p">,</span> <span class="nx">pc</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">msanenabled</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">msanread</span><span class="p">(</span><span class="nx">fromPtr</span><span class="p">,</span> <span class="nx">size</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="nf">msanwrite</span><span class="p">(</span><span class="nx">toPtr</span><span class="p">,</span> <span class="nx">size</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">asanenabled</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">asanread</span><span class="p">(</span><span class="nx">fromPtr</span><span class="p">,</span> <span class="nx">size</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="nf">asanwrite</span><span class="p">(</span><span class="nx">toPtr</span><span class="p">,</span> <span class="nx">size</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// ä¸€èˆ¬æƒ…å†µä¸‹ï¼Œè¿™é‡Œçš„å€¼å¤§çº¦æ˜¯2xï¼ˆåªæœ‰1å­—èŠ‚éœ€è¦æ‹·è´ï¼‰
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 	to := make([]byte, 1); copy(to, &#34;hello&#34;)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// ã€[]byteã€‘ OR ã€[]uint8ã€‘ OR ã€[]int8ã€‘ OR ã€[]boolã€‘
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nx">size</span> <span class="o">==</span> <span class="mi">1</span> <span class="p">{</span> <span class="c1">// common case worth about 2x to do here
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// TODO: is this still worth it with new memmove impl?
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// TODO: ä½¿ç”¨æ–°çš„memmove implï¼Œè¿™ä»ç„¶å€¼å¾—å—?
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// å·²çŸ¥fromPtrå’ŒtoPtræ˜¯ byte æŒ‡é’ˆ
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="kt">byte</span><span class="p">)(</span><span class="nx">toPtr</span><span class="p">)</span> <span class="p">=</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="kt">byte</span><span class="p">)(</span><span class="nx">fromPtr</span><span class="p">)</span> <span class="c1">// known to be a byte pointer
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">memmove</span><span class="p">(</span><span class="nx">toPtr</span><span class="p">,</span> <span class="nx">fromPtr</span><span class="p">,</span> <span class="nx">size</span><span class="p">)</span>   <span class="c1">// æ‹·è´æ•°æ®
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nx">n</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="memmove"><code>memmove()</code><a hidden class="anchor" aria-hidden="true" href="#memmove">#</a></h3>
<ol>
<li>memmoveä»<code>from</code>å¤åˆ¶<code>n</code>ä¸ªå­—èŠ‚åˆ°<code>to</code>ã€‚</li>
<li>memmoveç¡®ä¿ä»»ä½•ä½äº<code>from</code>ä¸­çš„æŒ‡é’ˆéƒ½ä»¥<strong>ä¸å¯åˆ†å‰²</strong>çš„å†™å…¥æ–¹å¼å†™å…¥åˆ°<code>to</code>ä¸­ï¼Œå› æ­¤ï¼ŒåŠ¨æ€è¯»å–æ— æ³•è§‚å¯Ÿåˆ°ä¸€ä¸ªåªå†™äº†ä¸€åŠçš„æŒ‡é’ˆã€‚</li>
<li>è¿™æ˜¯å¿…è¦çš„ï¼Œä»¥é˜²æ­¢åƒåœ¾æ”¶é›†å™¨å‘ç°æ— æ•ˆæŒ‡é’ˆï¼Œè¿™ä¸éæ‰˜ç®¡è¯­è¨€ä¸­çš„memmoveä¸åŒã€‚</li>
<li>ä¸è¿‡ï¼Œåªæœ‰å½“<code>from</code>å’Œ<code>to</code><strong>å¯èƒ½åŒ…å«æŒ‡é’ˆæ—¶</strong>ï¼Œmemmove()æ‰éœ€è¦è¿™ä¹ˆåšï¼Œåªæœ‰å½“fromã€toå’Œnéƒ½æ˜¯ word-alignedæ—¶æ‰ä¼šè¿™æ ·åšã€‚</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// memmove copies n bytes from &#34;from&#34; to &#34;to&#34;.
</span></span></span><span class="line"><span class="cl"><span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1">// memmove ensures that any pointer in &#34;from&#34; is written to &#34;to&#34; with
</span></span></span><span class="line"><span class="cl"><span class="c1">// an indivisible write, so that racy reads cannot observe a
</span></span></span><span class="line"><span class="cl"><span class="c1">// half-written pointer. This is necessary to prevent the garbage
</span></span></span><span class="line"><span class="cl"><span class="c1">// collector from observing invalid pointers, and differs from memmove
</span></span></span><span class="line"><span class="cl"><span class="c1">// in unmanaged languages. However, memmove is only required to do
</span></span></span><span class="line"><span class="cl"><span class="c1">// this if &#34;from&#34; and &#34;to&#34; may contain pointers, which can only be the
</span></span></span><span class="line"><span class="cl"><span class="c1">// case if &#34;from&#34;, &#34;to&#34;, and &#34;n&#34; are all be word-aligned.
</span></span></span><span class="line"><span class="cl"><span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1">// Implementations are in memmove_*.s.
</span></span></span><span class="line"><span class="cl"><span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1">//go:noescape
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">memmove</span><span class="p">(</span><span class="nx">to</span><span class="p">,</span> <span class="nx">from</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">,</span> <span class="nx">n</span> <span class="kt">uintptr</span><span class="p">)</span>
</span></span></code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-asm" data-lang="asm"><span class="line"><span class="cl"><span class="nf">TEXT</span> <span class="no">runtime</span><span class="err">Â·</span><span class="no">memmove</span><span class="err">&lt;</span><span class="no">ABIInternal</span><span class="err">&gt;</span><span class="p">(</span><span class="no">SB</span><span class="p">),</span> <span class="no">NOSPLIT</span><span class="p">,</span> <span class="no">$0-24</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// AX = to
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// BX = from
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// CX = n
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">MOVQ</span>    <span class="no">AX</span><span class="p">,</span> <span class="no">DI</span>
</span></span><span class="line"><span class="cl">    <span class="nf">MOVQ</span>    <span class="no">BX</span><span class="p">,</span> <span class="no">SI</span>
</span></span><span class="line"><span class="cl">    <span class="nf">MOVQ</span>    <span class="no">CX</span><span class="p">,</span> <span class="no">BX</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl"><span class="nl">tail:</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// TESTæŒ‡ä»¤ç”¨äºå¯¹BXå¯„å­˜å™¨çš„å†…å®¹å’Œè‡ªèº«è¿›è¡ŒæŒ‰ä½ä¸æ“ä½œï¼Œä½†æ˜¯ä¸æ”¹å˜å¯„å­˜å™¨çš„å†…å®¹ã€‚
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">TESTQ</span>   <span class="no">BX</span><span class="p">,</span> <span class="no">BX</span> <span class="c1"># æ£€æŸ¥BXæ˜¯å¦ä¸º0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// æ£€æŸ¥ä¸Šä¸€æ¡æŒ‡ä»¤ï¼ˆTESTï¼‰æ‰§è¡Œåæ˜¯å¦è®¾ç½®äº†é›¶æ ‡å¿—ï¼ˆZFï¼‰
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">JEQ</span> <span class="no">move_0</span>  <span class="c1"># Jump if Equal
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// è¿™æ˜¯ä¸€ä¸ªæ¯”è¾ƒæŒ‡ä»¤ï¼Œç”¨äºæ¯”è¾ƒBXå¯„å­˜å™¨ä¸­çš„å€¼å’Œç«‹å³æ•°2ã€‚
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// å…·ä½“æ¥è¯´ï¼Œå®ƒä¼šå°†BXå¯„å­˜å™¨çš„å€¼å’Œ2ç›¸å‡ï¼Œä½†ä¸æ”¹å˜ä»»ä½•å¯„å­˜å™¨çš„å€¼ï¼Œåªæ˜¯æ ¹æ®ç»“æœè®¾ç½®çŠ¶æ€æ ‡å¿—ã€‚
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">CMPQ</span>    <span class="no">BX</span><span class="p">,</span> <span class="no">$2</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// BX &lt;= 2 æˆç«‹
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">JBE</span> <span class="no">move_1or2</span> <span class="c1"># Jump if Below or Equal
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">CMPQ</span>    <span class="no">BX</span><span class="p">,</span> <span class="no">$4</span> <span class="c1"># &lt;= 4
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">JB</span>  <span class="no">move_3</span>
</span></span><span class="line"><span class="cl">    <span class="nf">JBE</span> <span class="no">move_4</span>
</span></span><span class="line"><span class="cl">    <span class="nf">CMPQ</span>    <span class="no">BX</span><span class="p">,</span> <span class="no">$8</span> <span class="c1"># &lt;= 8
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">JB</span>  <span class="no">move_5through7</span>
</span></span><span class="line"><span class="cl">    <span class="nf">JE</span>  <span class="no">move_8</span>
</span></span><span class="line"><span class="cl">    <span class="nf">CMPQ</span>    <span class="no">BX</span><span class="p">,</span> <span class="no">$16</span>
</span></span><span class="line"><span class="cl">    <span class="nf">JBE</span> <span class="no">move_9through16</span>
</span></span><span class="line"><span class="cl">    <span class="nf">CMPQ</span>    <span class="no">BX</span><span class="p">,</span> <span class="no">$32</span>
</span></span><span class="line"><span class="cl">    <span class="nf">JBE</span> <span class="no">move_17through32</span>
</span></span><span class="line"><span class="cl">    <span class="nf">CMPQ</span>    <span class="no">BX</span><span class="p">,</span> <span class="no">$64</span>
</span></span><span class="line"><span class="cl">    <span class="nf">JBE</span> <span class="no">move_33through64</span>
</span></span><span class="line"><span class="cl">    <span class="nf">CMPQ</span>    <span class="no">BX</span><span class="p">,</span> <span class="no">$128</span>
</span></span><span class="line"><span class="cl">    <span class="nf">JBE</span> <span class="no">move_65through128</span>
</span></span><span class="line"><span class="cl">    <span class="nf">CMPQ</span>    <span class="no">BX</span><span class="p">,</span> <span class="no">$256</span>
</span></span><span class="line"><span class="cl">    <span class="nf">JBE</span> <span class="no">move_129through256</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nf">TESTB</span>   <span class="no">$1</span><span class="p">,</span> <span class="no">runtime</span><span class="err">Â·</span><span class="no">useAVXmemmove</span><span class="p">(</span><span class="no">SB</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nf">JNZ</span> <span class="no">avxUnaligned</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c1">//... ...
</span></span></span></code></pre></td></tr></table>
</div>
</div><h2 id="append"><code>append()</code><a hidden class="anchor" aria-hidden="true" href="#append">#</a></h2>
<ol>
<li>å†…ç½®å‡½æ•°<code>append()</code>å°†å…ƒç´ æ·»åŠ åˆ°åˆ‡ç‰‡çš„æœ«å°¾ã€‚</li>
<li>å¦‚æœå®ƒæœ‰è¶³å¤Ÿçš„å®¹é‡ï¼Œç›®çš„åœ°å°†è¢«é‡æ–°åˆ’åˆ†ä»¥å®¹çº³æ–°çš„å…ƒç´ ã€‚å¦‚æœæ²¡æœ‰ï¼Œå°†åˆ†é…ä¸€ä¸ªæ–°çš„åº•å±‚æ•°ç»„ã€‚</li>
<li>æ³¨æ„ï¼š<code>append()</code>å‡½æ•°å­˜åœ¨å¯å˜å‚æ•°ï¼ˆ<code>... T</code>ï¼‰çš„å½¢å¼çš„å‚æ•°ã€‚</li>
<li><code>append()</code>è¿”å›æ›´æ–°åçš„<code>slice</code>ã€‚å› æ­¤ï¼Œæœ‰å¿…è¦å°†<code>append()</code>çš„ç»“æœå­˜å‚¨åœ¨ä¿å­˜åˆ‡ç‰‡æœ¬èº«çš„å˜é‡ä¸­ï¼š
<ul>
<li>ã€<strong><code>slice = append(slice, elem1, elem2)</code></strong>ã€‘</li>
<li>ã€<strong><code>slice = append(slice, anotherSlice...)</code></strong>ã€‘</li>
</ul>
</li>
<li>ä½œä¸ºä¸€ç§ç‰¹æ®Šæƒ…å†µï¼Œå¯ä»¥å°†å­—ç¬¦ä¸²æ·»åŠ åˆ°å­—èŠ‚åˆ‡ç‰‡ä¸­ï¼Œå¦‚ä¸‹æ‰€ç¤ºï¼š
<ul>
<li>ã€<strong><code>slice = append([]byte(&quot;hello &quot;), &quot;world&quot;...)</code></strong>ã€‘</li>
</ul>
</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// The append built-in function appends elements to the end of a slice. If
</span></span></span><span class="line"><span class="cl"><span class="c1">// it has sufficient capacity, the destination is resliced to accommodate the
</span></span></span><span class="line"><span class="cl"><span class="c1">// new elements. If it does not, a new underlying array will be allocated.
</span></span></span><span class="line"><span class="cl"><span class="c1">// Append returns the updated slice. It is therefore necessary to store the
</span></span></span><span class="line"><span class="cl"><span class="c1">// result of append, often in the variable holding the slice itself:
</span></span></span><span class="line"><span class="cl"><span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1">//	slice = append(slice, elem1, elem2)
</span></span></span><span class="line"><span class="cl"><span class="c1">//	slice = append(slice, anotherSlice...)
</span></span></span><span class="line"><span class="cl"><span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1">// As a special case, it is legal to append a string to a byte slice, like this:
</span></span></span><span class="line"><span class="cl"><span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1">//	slice = append([]byte(&#34;hello &#34;), &#34;world&#34;...)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nb">append</span><span class="p">(</span><span class="nx">slice</span> <span class="p">[]</span><span class="nx">Type</span><span class="p">,</span> <span class="nx">elems</span> <span class="o">...</span><span class="nx">Type</span><span class="p">)</span> <span class="p">[]</span><span class="nx">Type</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ol start="6">
<li>append æ‰§è¡Œæ­¥éª¤ï¼š
<ul>
<li>å¦‚æœå½“å‰<code>append()</code>å‡½æ•°æ‰§è¡Œå®Œååˆ‡ç‰‡<strong>ä¸ä¼š</strong>&ldquo;ç¿»å€æ‰©å®¹&quot;é‚£ä¹ˆï¼Œç›´æ¥æ˜¯æŠŠ<code>append()</code>åè¿½åŠ çš„æ•°æ®æ‹·è´åˆ°åˆ‡ç‰‡çš„åç»­ç©ºé—´å³å¯ã€‚</li>
<li>å¦‚æœå½“å‰<code>append()</code>å‡½æ•°æ‰§è¡Œå®Œå<strong>éœ€è¦</strong>&ldquo;ç¿»å€æ‰©å®¹&rdquo;ï¼Œé‚£ä¹ˆå…ˆè°ƒç”¨<code>runtime.growslice()</code>æ‰©å®¹å‡½æ•°ï¼Œç„¶ååœ¨æ‹·è´æ•°æ®è¿½åŠ åˆ°æ–°çš„å†…å­˜ç©ºé—´ã€‚</li>
</ul>
</li>
</ol>
<h3 id="growslice"><code>growslice()</code><a hidden class="anchor" aria-hidden="true" href="#growslice">#</a></h3>
<ol>
<li><code>growslice()</code>åœ¨<code>append()</code>å‡½æ•°æœŸé—´å¤„ç†åˆ‡ç‰‡å¢é•¿ã€‚</li>
<li>å®ƒå°†<code>slice</code>å…ƒç´ ç±»å‹ã€æ—§çš„<code>slice</code>å’Œæ‰€éœ€çš„æ–°æœ€å°å®¹é‡ä¼ é€’ç»™å®ƒï¼Œç„¶åè¿”å›ä¸€ä¸ªè‡³å°‘å…·æœ‰è¯¥å®¹é‡çš„æ–°<code>slice</code>ï¼Œå¹¶å°†æ—§æ•°æ®å¤åˆ¶åˆ°å…¶ä¸­ã€‚</li>
<li>æ–°sliceçš„é•¿åº¦è¢«è®¾ç½®ä¸ºæ—§<code>slice</code>çš„é•¿åº¦ï¼Œè€Œä¸æ˜¯æ–°è¯·æ±‚çš„å®¹é‡ã€‚</li>
<li>è¿™æ˜¯ä¸ºäº†æ–¹ä¾¿codegenã€‚æ—§ç‰‡çš„é•¿åº¦ç«‹å³ç”¨äºè®¡ç®—åœ¨è¿½åŠ æœŸé—´åœ¨ä½•å¤„å†™å…¥æ–°å€¼ã€‚</li>
<li>TODOï¼šå½“æ—§çš„åç«¯æ¶ˆå¤±æ—¶ï¼Œé‡æ–°è€ƒè™‘è¿™ä¸ªå†³å®šã€‚</li>
<li>SSAåç«¯å¯èƒ½æ›´å–œæ¬¢æ–°çš„é•¿åº¦ï¼Œæˆ–è€…åªè¿”å›ptr/capä»¥èŠ‚çœæ ˆç©ºé—´ã€‚</li>
<li>å‚æ•°ï¼š
<ul>
<li><code>et *_type</code>ï¼šåˆ‡ç‰‡å…ƒç´ çš„å…ƒç±»å‹ã€‚</li>
<li><code>old slice</code>ï¼šæœªç¿»å€æ‰©å®¹å‰åˆ‡ç‰‡ã€‚</li>
<li><code>cap int</code>ï¼š<code>append()</code>å‡½æ•°åéœ€è¦çš„é•¿åº¦ <code>old.len + n = cap</code>ã€‚ä¹Ÿå°±æ˜¯<code>append(s S, x ...T) S</code>å‡½æ•°ä¸­<code>len(S) + len(x) = cap</code>åçš„é•¿åº¦ã€‚</li>
</ul>
</li>
<li>è¿”å›å€¼ï¼š<code>slice</code>
<ul>
<li><code>slice.data</code>ï¼šæ–°ç”³è¯·çš„åœ°å€ã€‚</li>
<li><code>slice.len</code>ï¼š<code>old.len</code>çš„å€¼ã€‚æ³¨æ„è¿™é‡Œæ˜¯æ—§åˆ‡ç‰‡çš„é•¿åº¦ã€‚</li>
<li><code>slice.cap</code>ï¼šæ‰©å®¹åçš„å®¹é‡ã€‚</li>
</ul>
</li>
<li>è¯¥å‡½æ•°åœ¨<code>append()</code>å‡½æ•°è°ƒç”¨æ—¶æ ¹æ®æ¡ä»¶è§¦å‘ã€‚å¦‚<code>old = append(old, 1, 2, 1)</code>, <code>len(old) + 3 &gt; cap(old)</code>æ—¶å°±éœ€è¦æ‰©å®¹äº†ã€‚</li>
<li>æ³¨æ„ï¼Œå…³äºsliceçš„æ‰©å®¹è§„åˆ™åœ¨go1.18å‰æ˜¯æ ¹æ®lençš„ä¸€å¥—è§„åˆ™ï¼Œè€Œåœ¨ä»¥åç‰ˆæœ¬åˆæ˜¯æ ¹æ®capçš„ä¸€å¥—è§„åˆ™ï¼Œæœ¬ç¯‡é‡‡ç”¨çš„æ˜¯go1.22å·¦å³ç‰ˆæœ¬çš„ã€‚</li>
</ol>
<p><img loading="lazy" src="../images/slice-002.png" alt=""  />
</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span><span class="lnt">113
</span><span class="lnt">114
</span><span class="lnt">115
</span><span class="lnt">116
</span><span class="lnt">117
</span><span class="lnt">118
</span><span class="lnt">119
</span><span class="lnt">120
</span><span class="lnt">121
</span><span class="lnt">122
</span><span class="lnt">123
</span><span class="lnt">124
</span><span class="lnt">125
</span><span class="lnt">126
</span><span class="lnt">127
</span><span class="lnt">128
</span><span class="lnt">129
</span><span class="lnt">130
</span><span class="lnt">131
</span><span class="lnt">132
</span><span class="lnt">133
</span><span class="lnt">134
</span><span class="lnt">135
</span><span class="lnt">136
</span><span class="lnt">137
</span><span class="lnt">138
</span><span class="lnt">139
</span><span class="lnt">140
</span><span class="lnt">141
</span><span class="lnt">142
</span><span class="lnt">143
</span><span class="lnt">144
</span><span class="lnt">145
</span><span class="lnt">146
</span><span class="lnt">147
</span><span class="lnt">148
</span><span class="lnt">149
</span><span class="lnt">150
</span><span class="lnt">151
</span><span class="lnt">152
</span><span class="lnt">153
</span><span class="lnt">154
</span><span class="lnt">155
</span><span class="lnt">156
</span><span class="lnt">157
</span><span class="lnt">158
</span><span class="lnt">159
</span><span class="lnt">160
</span><span class="lnt">161
</span><span class="lnt">162
</span><span class="lnt">163
</span><span class="lnt">164
</span><span class="lnt">165
</span><span class="lnt">166
</span><span class="lnt">167
</span><span class="lnt">168
</span><span class="lnt">169
</span><span class="lnt">170
</span><span class="lnt">171
</span><span class="lnt">172
</span><span class="lnt">173
</span><span class="lnt">174
</span><span class="lnt">175
</span><span class="lnt">176
</span><span class="lnt">177
</span><span class="lnt">178
</span><span class="lnt">179
</span><span class="lnt">180
</span><span class="lnt">181
</span><span class="lnt">182
</span><span class="lnt">183
</span><span class="lnt">184
</span><span class="lnt">185
</span><span class="lnt">186
</span><span class="lnt">187
</span><span class="lnt">188
</span><span class="lnt">189
</span><span class="lnt">190
</span><span class="lnt">191
</span><span class="lnt">192
</span><span class="lnt">193
</span><span class="lnt">194
</span><span class="lnt">195
</span><span class="lnt">196
</span><span class="lnt">197
</span><span class="lnt">198
</span><span class="lnt">199
</span><span class="lnt">200
</span><span class="lnt">201
</span><span class="lnt">202
</span><span class="lnt">203
</span><span class="lnt">204
</span><span class="lnt">205
</span><span class="lnt">206
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// growslice handles slice growth during append.
</span></span></span><span class="line"><span class="cl"><span class="c1">// It is passed the slice element type, the old slice, and the desired new minimum capacity,
</span></span></span><span class="line"><span class="cl"><span class="c1">// and it returns a new slice with at least that capacity, with the old data
</span></span></span><span class="line"><span class="cl"><span class="c1">// copied into it.
</span></span></span><span class="line"><span class="cl"><span class="c1">// The new slice&#39;s length is set to the old slice&#39;s length,
</span></span></span><span class="line"><span class="cl"><span class="c1">// NOT to the new requested capacity.
</span></span></span><span class="line"><span class="cl"><span class="c1">// This is for codegen convenience. The old slice&#39;s length is used immediately
</span></span></span><span class="line"><span class="cl"><span class="c1">// to calculate where to write new values during an append.
</span></span></span><span class="line"><span class="cl"><span class="c1">// TODO: When the old backend is gone, reconsider this decision.
</span></span></span><span class="line"><span class="cl"><span class="c1">// The SSA backend might prefer the new length or to return only ptr/cap and save stack space.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">growslice</span><span class="p">(</span><span class="nx">et</span> <span class="o">*</span><span class="nx">_type</span><span class="p">,</span> <span class="nx">old</span> <span class="nx">slice</span><span class="p">,</span> <span class="nx">cap</span> <span class="kt">int</span><span class="p">)</span> <span class="nx">slice</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">raceenabled</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">callerpc</span> <span class="o">:=</span> <span class="nf">getcallerpc</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">        <span class="nf">racereadrangepc</span><span class="p">(</span><span class="nx">old</span><span class="p">.</span><span class="nx">array</span><span class="p">,</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">old</span><span class="p">.</span><span class="nx">len</span><span class="o">*</span><span class="nb">int</span><span class="p">(</span><span class="nx">et</span><span class="p">.</span><span class="nx">size</span><span class="p">)),</span> <span class="nx">callerpc</span><span class="p">,</span> <span class="nx">abi</span><span class="p">.</span><span class="nf">FuncPCABIInternal</span><span class="p">(</span><span class="nx">growslice</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">msanenabled</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">msanread</span><span class="p">(</span><span class="nx">old</span><span class="p">.</span><span class="nx">array</span><span class="p">,</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">old</span><span class="p">.</span><span class="nx">len</span><span class="o">*</span><span class="nb">int</span><span class="p">(</span><span class="nx">et</span><span class="p">.</span><span class="nx">size</span><span class="p">)))</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">asanenabled</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">asanread</span><span class="p">(</span><span class="nx">old</span><span class="p">.</span><span class="nx">array</span><span class="p">,</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">old</span><span class="p">.</span><span class="nx">len</span><span class="o">*</span><span class="nb">int</span><span class="p">(</span><span class="nx">et</span><span class="p">.</span><span class="nx">size</span><span class="p">)))</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 1) åˆ‡ç‰‡é•¿åº¦æº¢å‡ºåˆ¤æ–­
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nx">cap</span> <span class="p">&lt;</span> <span class="nx">old</span><span class="p">.</span><span class="nx">cap</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nb">panic</span><span class="p">(</span><span class="nf">errorString</span><span class="p">(</span><span class="s">&#34;growslice: cap out of range&#34;</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 2) åˆ‡ç‰‡å…ƒç´ ç±»å‹ å ç”¨å†…å­˜ä¸ºé›¶ æƒ…å†µ
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// è¿™ç§æƒ…å†µå‡ºç°åœ¨ï¼š
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//      var s []struct{}
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//      s = append(s, struct{}{}, struct{}{})
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nx">et</span><span class="p">.</span><span class="nx">size</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// append should not create a slice with nil pointer but non-zero len.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// We assume that append doesn&#39;t need to preserve old.array in this case.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// Appendä¸åº”è¯¥åˆ›å»ºä¸€ä¸ªæŒ‡é’ˆä¸ºnilçš„åˆ‡ç‰‡ï¼Œè€Œæ˜¯ä¸€ä¸ªlenä¸ºnon-zeroçš„åˆ‡ç‰‡ã€‚
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œæˆ‘ä»¬å‡è®¾appendä¸éœ€è¦ä¿å­˜old.arrayã€‚
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// èµ‹å€¼slice.arrayæŒ‡å®šåœ°å€ï¼Œä¸ºäº†ç¡®ä¿sliceä¸æ˜¯nil
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// sliceä¸ºnilçš„åˆ¤æ–­æ¡ä»¶æ˜¯ï¼Œåªè¦slice.array==0x00,ä¸ç®¡lenå’Œcapçš„å€¼ä¸ºå¤šå°‘éƒ½ä¸ºnil
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">return</span> <span class="nx">slice</span><span class="p">{</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">zerobase</span><span class="p">),</span> <span class="nx">old</span><span class="p">.</span><span class="nx">len</span><span class="p">,</span> <span class="nx">cap</span><span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 3) è¯„ä¼°æ‰©å®¹åçš„å®¹é‡
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// ---+-------+-----------------------------------------------------------------------------------
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// é¢„ |   if  | oldCap * 2 &lt; cap ------&gt; newCap = cap               ä½¿ç”¨capå€¼
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// ä¼° |-------+-----------------------------------------------------------------------------------
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// è§„ |  else | oldCap &lt; 256     ------&gt; newCap = oldCap * 2        ç¿»å€æ‰©å®¹
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// åˆ™ |       | oldCap &gt;= 256    ------&gt; newCap = oldCap * 5/4 + 256 * 3/4 åœ¨åŸå®¹é‡ä¸Šæ‰©å®¹1/4åœ¨æ‰©å®¹192
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// ---+-------+-----------------------------------------------------------------------------------
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">newcap</span> <span class="o">:=</span> <span class="nx">old</span><span class="p">.</span><span class="nx">cap</span>
</span></span><span class="line"><span class="cl">    <span class="nx">doublecap</span> <span class="o">:=</span> <span class="nx">newcap</span> <span class="o">+</span> <span class="nx">newcap</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">cap</span> <span class="p">&gt;</span> <span class="nx">doublecap</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 2å€æ—§å®¹é‡ &lt; capæ—¶ï¼Œåˆ™æŒ‰ç…§capç®—ã€‚
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">newcap</span> <span class="p">=</span> <span class="nx">cap</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="kd">const</span> <span class="nx">threshold</span> <span class="p">=</span> <span class="mi">256</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="nx">old</span><span class="p">.</span><span class="nx">cap</span> <span class="p">&lt;</span> <span class="nx">threshold</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nx">newcap</span> <span class="p">=</span> <span class="nx">doublecap</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// Check 0 &lt; newcap to detect overflow
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// and prevent an infinite loop.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// æ£€æŸ¥ 0 &lt; newcap ä»¥æ£€æµ‹æº¢å‡ºå¹¶é˜²æ­¢æ— é™å¾ªç¯ã€‚
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="k">for</span> <span class="mi">0</span> <span class="p">&lt;</span> <span class="nx">newcap</span> <span class="o">&amp;&amp;</span> <span class="nx">newcap</span> <span class="p">&lt;</span> <span class="nx">cap</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="c1">// Transition from growing 2x for small slices
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="c1">// to growing 1.25x for large slices. This formula
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="c1">// gives a smooth-ish transition between the two.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="nx">newcap</span> <span class="o">+=</span> <span class="p">(</span><span class="nx">newcap</span> <span class="o">+</span> <span class="mi">3</span><span class="o">*</span><span class="nx">threshold</span><span class="p">)</span> <span class="o">/</span> <span class="mi">4</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// Set newcap to the requested cap when
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// the newcap calculation overflowed.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="k">if</span> <span class="nx">newcap</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="nx">newcap</span> <span class="p">=</span> <span class="nx">cap</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 4) å†…å­˜è§„æ ¼åŒ¹é…
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    
</span></span><span class="line"><span class="cl">    <span class="c1">// å†…å­˜æ˜¯å¦æº¢å‡º true.æº¢å‡º false.æ²¡æœ‰æº¢å‡º
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kd">var</span> <span class="nx">overflow</span> <span class="kt">bool</span>	
</span></span><span class="line"><span class="cl">    <span class="c1">// lenmem æ—§åˆ‡ç‰‡å…ƒç´ å ç”¨çš„å†…å­˜å¤§å°
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//      è¯¥å€¼ç”¨äºè¿ç§»æ—§æ•°æ®çš„ä¾æ®/å­—èŠ‚
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// newlenmem ç¿»å€ååˆ‡ç‰‡å…ƒç´ å ç”¨çš„å†…å­˜å¤§å°
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//      è¯¥å€¼æ˜¯å½“å‰æ‰©å®¹åå®é™…å ç”¨çš„å¤§å°/å­—èŠ‚
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//      å› æ­¤capmem-newlenmemè¿™éƒ¨åˆ†å†…å­˜æ˜¯å¤šä½™çš„ï¼Œä¸ä¼šè¢«ç”¨åˆ°ã€‚
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// capmem ç¿»å€åæ–°å®¹é‡å ç”¨çš„å†…å­˜å¤§å°ï¼Œ
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//      ç”¨äºå‘æ“ä½œç³»ç»Ÿç”³è¯·çš„å†…å­˜å¤§å°/å­—èŠ‚
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//      è¿™éƒ¨åˆ†å†…å­˜å¯èƒ½å¤§äºnewlenmemçš„å€¼ï¼Œå› ä¸ºGoçš„å†…å­˜ç”³è¯·æ˜¯æœ‰è§„æ ¼çš„ã€‚
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kd">var</span> <span class="nx">lenmem</span><span class="p">,</span> <span class="nx">newlenmem</span><span class="p">,</span> <span class="nx">capmem</span> <span class="kt">uintptr</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Specialize for common values of et.size.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// For 1 we don&#39;t need any division/multiplication.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// For goarch.PtrSize, compiler will optimize division/multiplication into a shift by a constant.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// For powers of 2, use a variable shift.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// ä¸“é—¨ç”¨äº et.size çš„å…±åŒå€¼ã€‚
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// å¯¹äº1ï¼Œæˆ‘ä»¬ä¸éœ€è¦ä»»ä½•é™¤æ³•/ä¹˜æ³•
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// å¯¹äº goarch.PtrSizeï¼Œç¼–è¯‘å™¨å°†é™¤æ³•/ä¹˜æ³• ä¼˜åŒ–ä¸ºä¸€ä¸ªå¸¸é‡çš„ä½ç§»
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// å¯¹äº2çš„å¹‚æ¬¡æ–¹ï¼Œä½¿ç”¨å¯å˜ä½ç§»
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">switch</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// å€˜è‹¥æ•°ç»„å…ƒç´ çš„å¤§å°ä¸º 1ï¼Œåˆ™æ–°å®¹é‡å¤§å°ä¸º 1 * newcap.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// åŒæ—¶ä¼šé’ˆå¯¹ span class è¿›è¡Œå–æ•´
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">case</span> <span class="nx">et</span><span class="p">.</span><span class="nx">size</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>  <span class="c1">// 1å­—èŠ‚
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">lenmem</span> <span class="p">=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">old</span><span class="p">.</span><span class="nx">len</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="nx">newlenmem</span> <span class="p">=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">cap</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="nx">capmem</span> <span class="p">=</span> <span class="nf">roundupsize</span><span class="p">(</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">newcap</span><span class="p">))</span>   <span class="c1">// åŒ¹é…æœ€è¿‘æ¥çš„å†…å­˜å—è§„æ ¼
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">overflow</span> <span class="p">=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">newcap</span><span class="p">)</span> <span class="p">&gt;</span> <span class="nx">maxAlloc</span>   <span class="c1">// æ˜¯å¦å†…å­˜æº¢å‡º
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">newcap</span> <span class="p">=</span> <span class="nb">int</span><span class="p">(</span><span class="nx">capmem</span><span class="p">)</span>                    <span class="c1">// ä»æ–°è°ƒæ•´ç¿»å€åæ–°å®¹é‡
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// å€˜è‹¥æ•°ç»„å…ƒç´ ä¸ºæŒ‡é’ˆç±»å‹ï¼Œåˆ™æ ¹æ®æŒ‡é’ˆå ç”¨ç©ºé—´ç»“åˆå…ƒç´ ä¸ªæ•°è®¡ç®—ç©ºé—´å¤§å°
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// å¹¶ä¼šé’ˆå¯¹ span class è¿›è¡Œå–æ•´
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">case</span> <span class="nx">et</span><span class="p">.</span><span class="nx">size</span> <span class="o">==</span> <span class="nx">goarch</span><span class="p">.</span><span class="nx">PtrSize</span><span class="p">:</span> <span class="c1">// 4æˆ–8å­—èŠ‚
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">lenmem</span> <span class="p">=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">old</span><span class="p">.</span><span class="nx">len</span><span class="p">)</span> <span class="o">*</span> <span class="nx">goarch</span><span class="p">.</span><span class="nx">PtrSize</span>
</span></span><span class="line"><span class="cl">        <span class="nx">newlenmem</span> <span class="p">=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">cap</span><span class="p">)</span> <span class="o">*</span> <span class="nx">goarch</span><span class="p">.</span><span class="nx">PtrSize</span>
</span></span><span class="line"><span class="cl">        <span class="nx">capmem</span> <span class="p">=</span> <span class="nf">roundupsize</span><span class="p">(</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">newcap</span><span class="p">)</span> <span class="o">*</span> <span class="nx">goarch</span><span class="p">.</span><span class="nx">PtrSize</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="nx">overflow</span> <span class="p">=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">newcap</span><span class="p">)</span> <span class="p">&gt;</span> <span class="nx">maxAlloc</span><span class="o">/</span><span class="nx">goarch</span><span class="p">.</span><span class="nx">PtrSize</span>
</span></span><span class="line"><span class="cl">        <span class="nx">newcap</span> <span class="p">=</span> <span class="nb">int</span><span class="p">(</span><span class="nx">capmem</span> <span class="o">/</span> <span class="nx">goarch</span><span class="p">.</span><span class="nx">PtrSize</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// å€˜è‹¥å…ƒç´ å¤§å°ä¸º 2 çš„æŒ‡æ•°ï¼Œåˆ™ç›´æ¥é€šè¿‡ä½è¿ç®—è¿›è¡Œç©ºé—´å¤§å°çš„è®¡ç®—  
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">case</span> <span class="nf">isPowerOfTwo</span><span class="p">(</span><span class="nx">et</span><span class="p">.</span><span class="nx">size</span><span class="p">):</span> <span class="c1">// 2çš„å¹‚æ¬¡æ–¹
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="kd">var</span> <span class="nx">shift</span> <span class="kt">uintptr</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="nx">goarch</span><span class="p">.</span><span class="nx">PtrSize</span> <span class="o">==</span> <span class="mi">8</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// Mask shift for better code generation.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// æ©ç ç§»ä½ä»¥æ›´å¥½åœ°ç”Ÿæˆä»£ç ã€‚
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// sys.Ctz64å‡½æ•°è®¡æ•°å°¾éƒ¨(ä½é˜¶)é›¶ï¼Œå¦‚æœå…¨éƒ¨ä¸ºé›¶ï¼Œåˆ™ä¸º64ã€‚
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// æ¯”å¦‚ et.size æ˜¯2^8ä¹Ÿå°±æ˜¯ 1_0000_0000ï¼Œä¹Ÿå°±æ˜¯8ä¸ªé›¶
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="nx">shift</span> <span class="p">=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">sys</span><span class="p">.</span><span class="nf">Ctz64</span><span class="p">(</span><span class="nb">uint64</span><span class="p">(</span><span class="nx">et</span><span class="p">.</span><span class="nx">size</span><span class="p">)))</span> <span class="o">&amp;</span> <span class="mi">63</span>    <span class="c1">// 64ä½
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nx">shift</span> <span class="p">=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">sys</span><span class="p">.</span><span class="nf">Ctz32</span><span class="p">(</span><span class="nb">uint32</span><span class="p">(</span><span class="nx">et</span><span class="p">.</span><span class="nx">size</span><span class="p">)))</span> <span class="o">&amp;</span> <span class="mi">31</span>    <span class="c1">// 32ä½
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="nx">lenmem</span> <span class="p">=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">old</span><span class="p">.</span><span class="nx">len</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="nx">shift</span>
</span></span><span class="line"><span class="cl">        <span class="nx">newlenmem</span> <span class="p">=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">cap</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="nx">shift</span>
</span></span><span class="line"><span class="cl">        <span class="nx">capmem</span> <span class="p">=</span> <span class="nf">roundupsize</span><span class="p">(</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">newcap</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="nx">shift</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="nx">overflow</span> <span class="p">=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">newcap</span><span class="p">)</span> <span class="p">&gt;</span> <span class="p">(</span><span class="nx">maxAlloc</span> <span class="o">&gt;&gt;</span> <span class="nx">shift</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="nx">newcap</span> <span class="p">=</span> <span class="nb">int</span><span class="p">(</span><span class="nx">capmem</span> <span class="o">&gt;&gt;</span> <span class="nx">shift</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// å…œåº•åˆ†æ”¯ï¼šæ ¹æ®å…ƒç´ å¤§å°ä¹˜ä»¥å…ƒç´ ä¸ªæ•°
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// å†é’ˆå¯¹ span class è¿›è¡Œå–æ•´     
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">default</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="nx">lenmem</span> <span class="p">=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">old</span><span class="p">.</span><span class="nx">len</span><span class="p">)</span> <span class="o">*</span> <span class="nx">et</span><span class="p">.</span><span class="nx">size</span>
</span></span><span class="line"><span class="cl">        <span class="nx">newlenmem</span> <span class="p">=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">cap</span><span class="p">)</span> <span class="o">*</span> <span class="nx">et</span><span class="p">.</span><span class="nx">size</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// math.MulUintptr è¿”å› capmem = et.size * uintptr(newcap); overflow æ˜¯å¦æº¢å‡º
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">capmem</span><span class="p">,</span> <span class="nx">overflow</span> <span class="p">=</span> <span class="nx">math</span><span class="p">.</span><span class="nf">MulUintptr</span><span class="p">(</span><span class="nx">et</span><span class="p">.</span><span class="nx">size</span><span class="p">,</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">newcap</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">        <span class="nx">capmem</span> <span class="p">=</span> <span class="nf">roundupsize</span><span class="p">(</span><span class="nx">capmem</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="nx">newcap</span> <span class="p">=</span> <span class="nb">int</span><span class="p">(</span><span class="nx">capmem</span> <span class="o">/</span> <span class="nx">et</span><span class="p">.</span><span class="nx">size</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// ä»¥ä¸Šä»£ç å› ä¸ºä¼šå»åŒ¹é…å†…å­˜è§„æ ¼ï¼Œæ‰€ä»¥ä¼šä»æ–°è®¡ç®—newcapè¿™ä¸ªç¿»å€åçš„å€¼
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="c1">// The check of overflow in addition to capmem &gt; maxAlloc is needed
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// to prevent an overflow which can be used to trigger a segfault
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// on 32bit architectures with this example program:
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// é™¤äº†capmem &gt; maxAllocä¹‹å¤–ï¼Œè¿˜éœ€è¦æ£€æŸ¥æº¢å‡ºï¼Œä»¥é˜²æ­¢æº¢å‡ºï¼Œ
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// è¯¥æº¢å‡ºå¯ç”¨äºåœ¨32ä½ä½“ç³»ç»“æ„ä¸Šè§¦å‘æ®µæ•…éšœï¼Œç¤ºä¾‹ç¨‹åºå¦‚ä¸‹:
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// type T [1&lt;&lt;27 + 1]int64
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// var d T
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// var s []T
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// func main() {
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//   s = append(s, d, d, d, d)	
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//   print(len(s), &#34;\n&#34;)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// }
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 4*(1&lt;&lt;27 + 1)*8
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nx">overflow</span> <span class="o">||</span> <span class="nx">capmem</span> <span class="p">&gt;</span> <span class="nx">maxAlloc</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nb">panic</span><span class="p">(</span><span class="nf">errorString</span><span class="p">(</span><span class="s">&#34;growslice: cap out of range&#34;</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// ç”³è¯·åˆ°çš„å†…å­˜é¦–åœ°å€
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kd">var</span> <span class="nx">p</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">et</span><span class="p">.</span><span class="nx">ptrdata</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span> <span class="c1">// åˆ‡ç‰‡å…ƒç´ ç±»å‹ä¸åŒ…å«æŒ‡é’ˆ
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// capmem ç”³è¯·çš„å†…å­˜; nil ç±»å‹å…ƒç±»å‹ç”¨äºåˆ¤æ–­æ˜¯å¦ä¸ºæŒ‡é’ˆç±»å‹; false æ˜¯å¦é‡ç½®å†…å­˜ä¸ºé›¶å€¼;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">p</span> <span class="p">=</span> <span class="nf">mallocgc</span><span class="p">(</span><span class="nx">capmem</span><span class="p">,</span> <span class="kc">nil</span><span class="p">,</span> <span class="kc">false</span><span class="p">)</span> <span class="c1">// å‘æ“ä½œç³»ç»Ÿç”³è¯·å†…å­˜å—
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// The append() that calls growslice is going to overwrite from 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// old.len to cap (which will be the new length).
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// Only clear the part that will not be overwritten.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// è°ƒç”¨ growslice çš„ append() æ–¹æ³•ä¼šå°† old.len è¦†ç›–åˆ° cap(è¿™å°†æ˜¯æ–°çš„é•¿åº¦)ã€‚
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// åªæ¸…é™¤ä¸ä¼šè¢«è¦†ç›–çš„éƒ¨åˆ†ã€‚
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// æ¸…é›¶capmem-newlenmemè¿™å—å†…å­˜ï¼Œè¿™å¿«å†…å­˜æ˜¯å¤šä½™çš„ï¼Œä¸ä¼šè¢«ç”¨åˆ°ã€‚
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nf">memclrNoHeapPointers</span><span class="p">(</span><span class="nf">add</span><span class="p">(</span><span class="nx">p</span><span class="p">,</span> <span class="nx">newlenmem</span><span class="p">),</span> <span class="nx">capmem</span><span class="o">-</span><span class="nx">newlenmem</span><span class="p">)</span>	
</span></span><span class="line"><span class="cl">    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span> <span class="c1">// åˆ‡ç‰‡å…ƒç´ ç±»å‹åŒ…å«æŒ‡é’ˆ
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// Note: can&#39;t use rawmem (which avoids zeroing of memory), 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// because then GC can scan uninitialized memory.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// Note: ä¸èƒ½ä½¿ç”¨rawmem(å®ƒå¯ä»¥é¿å…å†…å­˜å½’é›¶)ï¼Œå› ä¸ºè¿™æ ·GCä¼šæ‰«ææœªåˆå§‹åŒ–çš„å†…å­˜ã€‚
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">p</span> <span class="p">=</span> <span class="nf">mallocgc</span><span class="p">(</span><span class="nx">capmem</span><span class="p">,</span> <span class="nx">et</span><span class="p">,</span> <span class="kc">true</span><span class="p">)</span> <span class="c1">// å‘æ“ä½œç³»ç»Ÿç”³è¯·å†…å­˜å—
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="nx">lenmem</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">writeBarrier</span><span class="p">.</span><span class="nx">enabled</span> <span class="p">{</span> <span class="c1">// å¼€å¯äº†å†™å±éšœ
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// Only shade the pointers in old.array since we know the destination slice p
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// only contains nil pointers because it has been cleared during alloc.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// åœ¨ old.array ä¸­åªå¯¹æŒ‡é’ˆè¿›è¡Œ shade å¤„ç†ï¼Œå› ä¸ºæˆ‘ä»¬çŸ¥é“ç›®æ ‡åˆ‡ç‰‡ p åªåŒ…å«nilæŒ‡é’ˆï¼Œ
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// å› ä¸ºå®ƒåœ¨allocæœŸé—´å·²è¢«æ¸…é™¤ã€‚
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// lenmem-et.size+et.ptrdata åˆšå¥½æ˜¯old.arrayå­˜åœ¨çš„éƒ½æ˜¯æŒ‡é’ˆ
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">//      -et.sizeï¼šå‡å»æœ€åä¸€ä¸ªå…ƒç´ çš„å†…å­˜
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">//      +et.ptrdataï¼šå†åŠ ä¸Šæœ€åä¸€ä¸ªå…ƒç´ çš„æŒ‡é’ˆ
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// åˆšå¥½å¤„ç†å®Œæœ€åä¸€ä¸ªå…ƒç´ åé¢ä¸æ˜¯æŒ‡é’ˆçš„éƒ¨åˆ†å†…å­˜ã€‚
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// [dst, dst+size]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="nf">bulkBarrierPreWriteSrcOnly</span><span class="p">(</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">p</span><span class="p">),</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">old</span><span class="p">.</span><span class="nx">array</span><span class="p">),</span> <span class="nx">lenmem</span><span class="o">-</span><span class="nx">et</span><span class="p">.</span><span class="nx">size</span><span class="o">+</span><span class="nx">et</span><span class="p">.</span><span class="nx">ptrdata</span><span class="p">)</span>	
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// ä»old.arrayä¸­è¿ç§»lenmemå¤§å°å†…å­˜æ•°æ®åˆ°pä¸­
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">memmove</span><span class="p">(</span><span class="nx">p</span><span class="p">,</span> <span class="nx">old</span><span class="p">.</span><span class="nx">array</span><span class="p">,</span> <span class="nx">lenmem</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// æ³¨æ„ï¼šè¿™é‡Œè¿”å›çš„æ˜¯ old.lenï¼Œå› ä¸ºæ­¤æ—¶è¿˜æ˜¯ä¹‹å‰çš„æ—§æ•°æ®
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">return</span> <span class="nx">slice</span><span class="p">{</span><span class="nx">p</span><span class="p">,</span> <span class="nx">old</span><span class="p">.</span><span class="nx">len</span><span class="p">,</span> <span class="nx">newcap</span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// bulkBarrierPreWriteSrcOnly is like bulkBarrierPreWrite but
</span></span></span><span class="line"><span class="cl"><span class="c1">// does not execute write barriers for [dst, dst+size).
</span></span></span><span class="line"><span class="cl"><span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1">// In addition to the requirements of bulkBarrierPreWrite
</span></span></span><span class="line"><span class="cl"><span class="c1">// callers need to ensure [dst, dst+size) is zeroed.
</span></span></span><span class="line"><span class="cl"><span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1">// This is used for special cases where e.g. dst was just
</span></span></span><span class="line"><span class="cl"><span class="c1">// created and zeroed with malloc.
</span></span></span><span class="line"><span class="cl"><span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1">// The type of the space can be provided purely as an optimization,
</span></span></span><span class="line"><span class="cl"><span class="c1">// however it is not used with GOEXPERIMENT=noallocheaders.
</span></span></span><span class="line"><span class="cl"><span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1">//go:nosplit
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">bulkBarrierPreWriteSrcOnly</span><span class="p">(</span><span class="nx">dst</span><span class="p">,</span> <span class="nx">src</span><span class="p">,</span> <span class="nx">size</span> <span class="kt">uintptr</span><span class="p">,</span> <span class="nx">_</span> <span class="o">*</span><span class="nx">abi</span><span class="p">.</span><span class="nx">Type</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// GCå¹¶å‘æ ‡è®°é˜¶æ®µï¼Œè¿™é‡Œéœ€è¦å¤„ç†æ··åˆå†™å±éšœç›¸å…³äº‹é¡¹ï¼Œå› ä¸ºåœ¨æ‹·è´æŒ‡é’ˆæ•°æ®
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="nx">dst</span><span class="p">|</span><span class="nx">src</span><span class="p">|</span><span class="nx">size</span><span class="p">)</span><span class="o">&amp;</span><span class="p">(</span><span class="nx">goarch</span><span class="p">.</span><span class="nx">PtrSize</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">throw</span><span class="p">(</span><span class="s">&#34;bulkBarrierPreWrite: unaligned arguments&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">!</span><span class="nx">writeBarrier</span><span class="p">.</span><span class="nx">enabled</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="c1">// å¹¶å‘æ ‡è®°å·²ç»“æŸ
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nx">buf</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nf">getg</span><span class="p">().</span><span class="nx">m</span><span class="p">.</span><span class="nx">p</span><span class="p">.</span><span class="nf">ptr</span><span class="p">().</span><span class="nx">wbBuf</span> <span class="c1">// å†™å±éšœç¼“å†²åŒº
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">h</span> <span class="o">:=</span> <span class="nf">heapBitsForAddr</span><span class="p">(</span><span class="nx">dst</span><span class="p">,</span> <span class="nx">size</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="kd">var</span> <span class="nx">addr</span> <span class="kt">uintptr</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="nx">h</span><span class="p">,</span> <span class="nx">addr</span> <span class="p">=</span> <span class="nx">h</span><span class="p">.</span><span class="nf">next</span><span class="p">();</span> <span class="nx">addr</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">break</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="nx">srcx</span> <span class="o">:=</span> <span class="p">(</span><span class="o">*</span><span class="kt">uintptr</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">addr</span> <span class="o">-</span> <span class="nx">dst</span> <span class="o">+</span> <span class="nx">src</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">        <span class="nx">p</span> <span class="o">:=</span> <span class="nx">buf</span><span class="p">.</span><span class="nf">get1</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">        <span class="nx">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">=</span> <span class="o">*</span><span class="nx">srcx</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>æ‰€æœ‰0å­—èŠ‚åˆ†é…çš„åŸºåœ°å€ã€‚</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// base address for all 0-byte allocations
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">var</span> <span class="nx">zerobase</span> <span class="kt">uintptr</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="roundupsize"><code>roundupsize()</code><a hidden class="anchor" aria-hidden="true" href="#roundupsize">#</a></h3>
<ol>
<li>mallocgcè¿”å›å°†åˆ†é…çš„å†…å­˜å—çš„å¤§å°ï¼Œå¦‚æœæ‚¨è¦æ±‚è¯¥å¤§å°ã€‚</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// Returns size of the memory block that mallocgc will allocate if you ask for the size.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">roundupsize</span><span class="p">(</span><span class="nx">size</span> <span class="kt">uintptr</span><span class="p">)</span> <span class="kt">uintptr</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// _MaxSmallSize = 32768
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nx">size</span> <span class="p">&lt;</span> <span class="nx">_MaxSmallSize</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// smallSizeMax = 1024
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="nx">size</span> <span class="o">&lt;=</span> <span class="nx">smallSizeMax</span><span class="o">-</span><span class="mi">8</span> <span class="p">{</span> <span class="c1">// ä»¥æœ€ä¸‹8Bå€æ•°å¯¹é½
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// smallSizeDiv = 8ï¼ŒdivRoundUp ç­‰ä»·äº ceil(size/8)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// size_to_class8å’Œclass_to_size è®°å½•ç€ size çš„æ˜ å°„å…³ç³»
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="k">return</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">class_to_size</span><span class="p">[</span><span class="nx">size_to_class8</span><span class="p">[</span><span class="nf">divRoundUp</span><span class="p">(</span><span class="nx">size</span><span class="p">,</span> <span class="nx">smallSizeDiv</span><span class="p">)]])</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>    <span class="c1">// ä»¥æœ€å°128Bå€æ•°å¯¹é½
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// largeSizeDiv = 128
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="k">return</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">class_to_size</span><span class="p">[</span><span class="nx">size_to_class128</span><span class="p">[</span><span class="nf">divRoundUp</span><span class="p">(</span><span class="nx">size</span><span class="o">-</span><span class="nx">smallSizeMax</span><span class="p">,</span> <span class="nx">largeSizeDiv</span><span class="p">)]])</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// _PageSize = 8192
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nx">size</span><span class="o">+</span><span class="nx">_PageSize</span> <span class="p">&lt;</span> <span class="nx">size</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="nx">size</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nf">alignUp</span><span class="p">(</span><span class="nx">size</span><span class="p">,</span> <span class="nx">_PageSize</span><span class="p">)</span> <span class="c1">// å¯¹é½8KB
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="alignup"><code>alignUp()</code><a hidden class="anchor" aria-hidden="true" href="#alignup">#</a></h3>
<ol>
<li>alignUpå°†nå–æ•´ä¸ºaçš„å€æ•°ã€‚aå¿…é¡»æ˜¯2çš„å¹‚ã€‚</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// alignUp rounds n up to a multiple of a. a must be a power of 2.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">alignUp</span><span class="p">(</span><span class="nx">n</span><span class="p">,</span> <span class="nx">a</span> <span class="kt">uintptr</span><span class="p">)</span> <span class="kt">uintptr</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="p">(</span><span class="nx">n</span> <span class="o">+</span> <span class="nx">a</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;^</span> <span class="p">(</span><span class="nx">a</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="muluintptr"><code>MulUintptr()</code><a hidden class="anchor" aria-hidden="true" href="#muluintptr">#</a></h3>
<ol>
<li><code>MulUintptr</code>è¿”å›<code>a * b</code>ä»¥åŠä¹˜æ³•è¿ç®—æ˜¯å¦æº¢å‡ºã€‚</li>
<li>åœ¨å—æ”¯æŒçš„å¹³å°ä¸Šï¼Œè¿™æ˜¯ç”±ç¼–è¯‘å™¨é™ä½çš„å›ºæœ‰ç‰¹æ€§ã€‚</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// MulUintptr returns a * b and whether the multiplication overflowed.
</span></span></span><span class="line"><span class="cl"><span class="c1">// On supported platforms this is an intrinsic lowered by the compiler.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">MulUintptr</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span> <span class="kt">uintptr</span><span class="p">)</span> <span class="p">(</span><span class="kt">uintptr</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// a|b &lt; 1&lt;&lt;16 || a|b &lt; 1&lt;&lt;32
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nx">a</span><span class="p">|</span><span class="nx">b</span> <span class="p">&lt;</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="mi">4</span><span class="o">*</span><span class="nx">goarch</span><span class="p">.</span><span class="nx">PtrSize</span><span class="p">)</span> <span class="o">||</span> <span class="nx">a</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="nx">a</span> <span class="o">*</span> <span class="nx">b</span><span class="p">,</span> <span class="kc">false</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// const MaxUintptr = ^uintptr(0)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">overflow</span> <span class="o">:=</span> <span class="nx">b</span> <span class="p">&gt;</span> <span class="nx">MaxUintptr</span><span class="o">/</span><span class="nx">a</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nx">a</span> <span class="o">*</span> <span class="nx">b</span><span class="p">,</span> <span class="nx">overflow</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div>

  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://heliu.site/tags/golang/">Golang</a></li>
      <li><a href="https://heliu.site/tags/slice/">Slice</a></li>
    </ul>
<nav class="paginav">
  <a class="prev" href="https://heliu.site/posts/golang/package/publish-mod/">
    <span class="title">Â« ä¸Šä¸€é¡µ</span>
    <br>
    <span>å¼€å‘å’Œå‘å¸ƒæ¨¡å—</span>
  </a>
  <a class="next" href="https://heliu.site/posts/golang/slice/check/">
    <span class="title">ä¸‹ä¸€é¡µ Â»</span>
    <br>
    <span>è¾¹ç•Œæ£€æŸ¥</span>
  </a>
</nav>

  </footer>
</article>
    </main>
    
<footer class="footer">
    
    <div class="busuanzi-footer">
    <span id="busuanzi_container_site_pv">
        æœ¬ç«™æ€»è®¿é—®é‡<span id="busuanzi_value_site_pv"></span>æ¬¡
    </span>
    <span id="busuanzi_container_site_uv">
        æœ¬ç«™è®¿å®¢æ•°<span id="busuanzi_value_site_uv"></span>äººæ¬¡
    </span>
    </div>
        <span>Copyright Â© 2020-2024 <a href="#">heliu's blog</a>. All rights reserved</span>  
    
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'Copy';

        function copyingDone() {
            copybutton.innerHTML = 'Done';
            setTimeout(() => {
                copybutton.innerHTML = 'Copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
