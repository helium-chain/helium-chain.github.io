<!DOCTYPE html>
<html lang="zh" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Slice(原理) | Helium</title>
<meta name="keywords" content="golang, 切片">
<meta name="description" content="💥本文章所有相关go代码参考自go 1.18&#43;版本">
<meta name="author" content="helium">
<link rel="canonical" href="https://heliu.site/posts/golang/slice/theory/">
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<meta name="referrer" content="no-referrer-when-downgrade">
<link crossorigin="anonymous" href="/assets/css/stylesheet.css" rel="preload stylesheet" as="style">
<link rel="icon" href="https://heliu.site/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://heliu.site/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://heliu.site/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://heliu.site/apple-touch-icon.png">
<link rel="mask-icon" href="https://heliu.site/apple-touch-icon.png">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="zh" href="https://heliu.site/posts/golang/slice/theory/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
<html>
<head>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/jetbrains-mono@1.0.6/css/jetbrains-mono-nl.min.css" />
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lxgw-wenkai-lite-webfont@1.1.0/style.css" />
    <link rel="stylesheet" href="https://cdn.staticfile.org/lxgw-wenkai-screen-webfont/1.6.0/style.css" />
    <style>
        body {
            font-family: "LXGW WenKai Lite", sans-serif;
            font-family: "LXGW WenKai Screen", sans-serif;
        }
    </style>
</head>
</html>

  

<meta property="og:title" content="Slice(原理)" />
<meta property="og:description" content="💥本文章所有相关go代码参考自go 1.18&#43;版本" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://heliu.site/posts/golang/slice/theory/" />
<meta property="og:image" content="https://heliu.site/favicon-32x32.png" />
<meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-09-02T00:00:00+00:00" />
<meta property="article:modified_time" content="2024-01-21T00:00:00+00:00" /><meta property="og:site_name" content="Helium" />

<meta name="twitter:card" content="summary_large_image" />
<meta name="twitter:image" content="https://heliu.site/favicon-32x32.png" />
<meta name="twitter:title" content="Slice(原理)"/>
<meta name="twitter:description" content="💥本文章所有相关go代码参考自go 1.18&#43;版本"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Article",
      "item": "https://heliu.site/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Golang 合集",
      "item": "https://heliu.site/posts/golang/"
    }, 
    {
      "@type": "ListItem",
      "position":  3 ,
      "name": "第7章 Slice",
      "item": "https://heliu.site/posts/golang/slice/"
    }, 
    {
      "@type": "ListItem",
      "position":  4 ,
      "name": "Slice(原理)",
      "item": "https://heliu.site/posts/golang/slice/theory/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Slice(原理)",
  "name": "Slice(原理)",
  "description": "💥本文章所有相关go代码参考自go 1.18+版本",
  "keywords": [
    "golang", "切片"
  ],
  "articleBody": " 本篇文章都是slice的源码走读。 注意：slice 不是并发安全的数据结构，大家在使用时请务必注意并发安全问题。 type slice struct 切片的内存布局。 array：指向一个[cap]T大小的数组地址。就是指向一个cap容量大小的数组首地址。 len：记录切片已存储元素的长度，也是可访问的最大下标len - 1。 cap：记录切片的容量，也就是当前切片存储的最大元素数量（未扩容前）。 type slice struct { array unsafe.Pointer len int cap int } type notInHeapSlice struct notInHeapSlice是go:notinheap内存支持的slice。 也就是该类型的对象不是在堆中创建的，也就是GC不会扫描，多用于内存管理模块中。 1 2 3 4 5 6 // A notInHeapSlice is a slice backed by go:notinheap memory. type notInHeapSlice struct { array *notInHeap // 指向一个起始地址 len int cap int } type notInHeap struct notInHeap是由sysAlloc或persistentAlloc等底层分配器分配的堆外内存。 一般来说，最好使用标记为go:notinheap的真实类型，但在无法这样做的情况下(比如在分配器中)，它用作通用类型。 TODO：使用它作为sysAlloc,persistentAlloc等的返回类型? 1 2 3 4 5 6 7 8 9 10 11 // notInHeap is off-heap memory allocated by a lower-level allocator // like sysAlloc or persistentAlloc. // // In general, it's better to use real types marked as go:notinheap, // but this serves as a generic type for situations where that isn't // possible (like in the allocators). // // TODO: Use this as the return type of sysAlloc, persistentAlloc, etc? // //go:notinheap type notInHeap struct{} add() 1 2 3 4 func (p *notInHeap) add(bytes uintptr) *notInHeap { // p + bytes return (*notInHeap)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + bytes)) } make() make内置函数分配并初始化一个类型为slice、map或chan的对象(only)。 和new一样，第一个参数是类型，而不是值。与new不同，make的返回值类型与其参数的类型相同，而不是指向参数的指针。 具体的结果取决于类型： Slice： size指定了长度。切片的容量等于它的长度。 以提供第二个整数参数来指定不同的容量;它必须不小于长度。 例如，make([]int, 0, 10)会分配一个长度为10的底层数组，并返回一个长度为0、容量为10的切片。 Map：一个空的map分配了足够的空间来保存指定数量的元素。在这种情况下，可以省略长度，分配一个较小的起始长度。 Channel：channel缓冲区使用指定的缓冲区容量初始化。如果为0，或者size被省略，则channel是无缓冲的。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 // The make built-in function allocates and initializes an object of type // slice, map, or chan (only). Like new, the first argument is a type, not a // value. Unlike new, make's return type is the same as the type of its // argument, not a pointer to it. The specification of the result depends on // the type: //\tSlice: The size specifies the length. The capacity of the slice is //\tequal to its length. A second integer argument may be provided to //\tspecify a different capacity; it must be no smaller than the //\tlength. For example, make([]int, 0, 10) allocates an underlying array //\tof size 10 and returns a slice of length 0 and capacity 10 that is //\tbacked by this underlying array. //\tMap: An empty map is allocated with enough space to hold the //\tspecified number of elements. The size may be omitted, in which case //\ta small starting size is allocated. //\tChannel: The channel's buffer is initialized with the specified //\tbuffer capacity. If zero, or the size is omitted, the channel is //\tunbuffered. func make(t Type, size ...IntegerType) Type makeslice() make([]T *_type, len, cap int) *_type：记录着切片元素类型，比如[]string切片这里是string的元类型。 len：切片的长度，该参数是必传。 cap：切片的容量，该参数是可传，默认会传len大小。 makeslice()函数是切片申请内存的make()函数原型，主要负责申请slice.array字段指向的内存大小。 那么切片的24字节大小内存是在什么时候分配的？（64位系统下为24字节内存，32系统下为12字节内存） 可能在函数栈上直接分配24字节大小内存。 也可能在堆上分配24字节大小内存。 调用了makeslice()函数，其slice.array指向的内存块一定是在堆上。没有调该函数时可能内存分配在栈上。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 func makeslice(et *_type, len, cap int) unsafe.Pointer { // 1）判断et.size * uintptr(cap)是否造成内存溢出 mem, overflow := math.MulUintptr(et.size, uintptr(cap)) // 按照cap计算的 // 1. 【overflow == true】：溢出 // 2. 【mem \u003e maxAlloc】：超过操作系统最大内存 // 3. 【len \u003c 0】：错误的len参数 // 4. 【len \u003e cap】：长度大于容量 if overflow || mem \u003e maxAlloc || len \u003c 0 || len \u003e cap { // NOTE: Produce a 'len out of range' error instead of a // 'cap out of range' error when someone does make([]T, bignumber). // 'cap out of range' is true too, but since the cap is only being // supplied implicitly, saying len is clearer. // See golang.org/issue/4085. // // 当有人 make([]T, bignumber) 时，产生一个 'len out of range' 错误而不是 'cap out of range' 错误提示 // 当 'cap out of range' 也是太长了，由于cap只是隐式地提供，所以说len更清楚的提示。 mem, overflow := math.MulUintptr(et.size, uintptr(len))\t// 根据len计算 if overflow || mem \u003e maxAlloc || len \u003c 0 { panicmakeslicelen() // painc 'len out of range' } panicmakeslicecap() // panic 'cap out of range' } // 2）向操作系统申请mem大小的内存块，返回申请到内存块的首地址 return mallocgc(mem, et, true) } makeslice64() int64版本，如果当前是在32位系统中时，int其实是int32大小。 1 2 3 4 5 6 7 8 9 10 11 12 13 func makeslice64(et *_type, len64, cap64 int64) unsafe.Pointer { len := int(len64) // 32位系统下转换会丢失部分数据 if int64(len) != len64 { panicmakeslicelen() // painc 'len out of range' } cap := int(cap64) if int64(cap) != cap64 { panicmakeslicecap() // panic 'cap out of range' } return makeslice(et, len, cap) } len() 以下伪代码获取切片的长度。 len函数的原型：func len(array []T) int。 1 2 3 4 // 伪代码示例 func len(array []T) int { return array.len } cap() 以下伪代码获取切片的容量。 cap函数的原型：func cap(array []T) int。 1 2 3 4 // 伪代码示例 func cap(array []T) int { return array.cap } copy() copy内置函数将元素从源片复制到目标片。(作为特殊情况，它也会将bytes从string复制到byte切片。) 源和目标可能重叠。 copy返回复制的元素数量，这将是len(src)和len(dst)的最小值。src-\u003edst。 1 2 3 4 5 6 // The copy built-in function copies elements from a source slice into a // destination slice. (As a special case, it also will copy bytes from a // string to a slice of bytes.) The source and destination may overlap. Copy // returns the number of elements copied, which will be the minimum of // len(src) and len(dst). func copy(dst, src []Type) int slicecopy() slicecopy用于将pointerless元素的字符串或切片复制到切片中。 注意：copy()的函数原型中没有可变参数（... T）的形式参数。 slicecopy 适用以下两种情况：fm -\u003e to 【copy(to, fm []T) int】 【copy(to []byte, fm string) int】 注意以下slicecopy函数可能在go1.18+版本中不是这样的，这一版采用的是go1.22左右版本的源码，但是只是发生了变化具体逻辑没变。 参数：fromPtr -\u003e toPtr toPtr unsafe.Pointer：目标地址，也就是上面的to.array值。 toLen int：目标长度，也就是上面的to.len值。 fromPtr unsafe.Pointer：来源地址，也就是上面的fm.array值。 fromLen int：来源长度，也就是上面的fm.len值。 width uintptr：切片类型占用内存大小，也就是[]T的T类型的大小。 返回值： int：拷贝的元素数量。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 // slicecopy is used to copy from a string or slice of pointerless elements into a slice. func slicecopy(toPtr unsafe.Pointer, toLen int, fromPtr unsafe.Pointer, fromLen int, width uintptr) int { // 1) 拷贝或被拷贝长度为0直接返回 if fromLen == 0 || toLen == 0 { return 0 } // 2) 拷贝元素的个数取决于拷贝或被拷贝的最小长度 n := fromLen if toLen \u003c n { n = toLen } // 3) 拷贝的元素大小为0，直接返回n if width == 0 {\t// []struct{} return n } // 4) size 需要拷贝的总内存大小/字节。 size := uintptr(n) * width if raceenabled { callerpc := getcallerpc() pc := abi.FuncPCABIInternal(slicecopy) racereadrangepc(fromPtr, size, callerpc, pc) racewriterangepc(toPtr, size, callerpc, pc) } if msanenabled { msanread(fromPtr, size) msanwrite(toPtr, size) } if asanenabled { asanread(fromPtr, size) asanwrite(toPtr, size) } // 一般情况下，这里的值大约是2x（只有1字节需要拷贝） // to := make([]byte, 1); copy(to, \"hello\") // 【[]byte】 OR 【[]uint8】 OR 【[]int8】 OR 【[]bool】 if size == 1 { // common case worth about 2x to do here // TODO: is this still worth it with new memmove impl? // // TODO: 使用新的memmove impl，这仍然值得吗? // 已知fromPtr和toPtr是 byte 指针 *(*byte)(toPtr) = *(*byte)(fromPtr) // known to be a byte pointer } else { memmove(toPtr, fromPtr, size) // 拷贝数据 } return n } memmove() memmove从from复制n个字节到to。 memmove确保任何位于from中的指针都以不可分割的写入方式写入到to中，因此，动态读取无法观察到一个只写了一半的指针。 这是必要的，以防止垃圾收集器发现无效指针，这与非托管语言中的memmove不同。 不过，只有当from和to可能包含指针时，memmove()才需要这么做，只有当from、to和n都是 word-aligned时才会这样做。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 // memmove copies n bytes from \"from\" to \"to\". // // memmove ensures that any pointer in \"from\" is written to \"to\" with // an indivisible write, so that racy reads cannot observe a // half-written pointer. This is necessary to prevent the garbage // collector from observing invalid pointers, and differs from memmove // in unmanaged languages. However, memmove is only required to do // this if \"from\" and \"to\" may contain pointers, which can only be the // case if \"from\", \"to\", and \"n\" are all be word-aligned. // // Implementations are in memmove_*.s. // //go:noescape func memmove(to, from unsafe.Pointer, n uintptr) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 TEXT runtime·memmove\u003cABIInternal\u003e(SB), NOSPLIT, $0-24 // AX = to // BX = from // CX = n MOVQ AX, DI MOVQ BX, SI MOVQ CX, BX tail: // TEST指令用于对BX寄存器的内容和自身进行按位与操作，但是不改变寄存器的内容。 TESTQ BX, BX # 检查BX是否为0 // 检查上一条指令（TEST）执行后是否设置了零标志（ZF） JEQ move_0 # Jump if Equal // 这是一个比较指令，用于比较BX寄存器中的值和立即数2。 // 具体来说，它会将BX寄存器的值和2相减，但不改变任何寄存器的值，只是根据结果设置状态标志。 CMPQ BX, $2 // BX \u003c= 2 成立 JBE move_1or2 # Jump if Below or Equal CMPQ BX, $4 # \u003c= 4 JB move_3 JBE move_4 CMPQ BX, $8 # \u003c= 8 JB move_5through7 JE move_8 CMPQ BX, $16 JBE move_9through16 CMPQ BX, $32 JBE move_17through32 CMPQ BX, $64 JBE move_33through64 CMPQ BX, $128 JBE move_65through128 CMPQ BX, $256 JBE move_129through256 TESTB $1, runtime·useAVXmemmove(SB) JNZ avxUnaligned //... ... append() 内置函数append()将元素添加到切片的末尾。 如果它有足够的容量，目的地将被重新划分以容纳新的元素。如果没有，将分配一个新的底层数组。 注意：append()函数存在可变参数（... T）的形式的参数。 append()返回更新后的slice。因此，有必要将append()的结果存储在保存切片本身的变量中： 【slice = append(slice, elem1, elem2)】 【slice = append(slice, anotherSlice...)】 作为一种特殊情况，可以将字符串添加到字节切片中，如下所示： 【slice = append([]byte(\"hello \"), \"world\"...)】 1 2 3 4 5 6 7 8 9 10 11 12 13 // The append built-in function appends elements to the end of a slice. If // it has sufficient capacity, the destination is resliced to accommodate the // new elements. If it does not, a new underlying array will be allocated. // Append returns the updated slice. It is therefore necessary to store the // result of append, often in the variable holding the slice itself: // //\tslice = append(slice, elem1, elem2) //\tslice = append(slice, anotherSlice...) // // As a special case, it is legal to append a string to a byte slice, like this: // //\tslice = append([]byte(\"hello \"), \"world\"...) func append(slice []Type, elems ...Type) []Type append 执行步骤： 如果当前append()函数执行完后切片不会“翻倍扩容\"那么，直接是把append()后追加的数据拷贝到切片的后续空间即可。 如果当前append()函数执行完后需要“翻倍扩容”，那么先调用runtime.growslice()扩容函数，然后在拷贝数据追加到新的内存空间。 growslice() growslice()在append()函数期间处理切片增长。 它将slice元素类型、旧的slice和所需的新最小容量传递给它，然后返回一个至少具有该容量的新slice，并将旧数据复制到其中。 新slice的长度被设置为旧slice的长度，而不是新请求的容量。 这是为了方便codegen。旧片的长度立即用于计算在追加期间在何处写入新值。 TODO：当旧的后端消失时，重新考虑这个决定。 SSA后端可能更喜欢新的长度，或者只返回ptr/cap以节省栈空间。 参数： et *_type：切片元素的元类型。 old slice：未翻倍扩容前切片。 cap int：append()函数后需要的长度 old.len + n = cap。也就是append(s S, x ...T) S函数中len(S) + len(x) = cap后的长度。 返回值：slice slice.data：新申请的地址。 slice.len：old.len的值。注意这里是旧切片的长度。 slice.cap：扩容后的容量。 该函数在append()函数调用时根据条件触发。如old = append(old, 1, 2, 1), len(old) + 3 \u003e cap(old)时就需要扩容了。 注意，关于slice的扩容规则在go1.18前是根据len的一套规则，而在以后版本又是根据cap的一套规则，本篇采用的是go1.22左右版本的。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 // growslice handles slice growth during append. // It is passed the slice element type, the old slice, and the desired new minimum capacity, // and it returns a new slice with at least that capacity, with the old data // copied into it. // The new slice's length is set to the old slice's length, // NOT to the new requested capacity. // This is for codegen convenience. The old slice's length is used immediately // to calculate where to write new values during an append. // TODO: When the old backend is gone, reconsider this decision. // The SSA backend might prefer the new length or to return only ptr/cap and save stack space. func growslice(et *_type, old slice, cap int) slice { if raceenabled { callerpc := getcallerpc() racereadrangepc(old.array, uintptr(old.len*int(et.size)), callerpc, abi.FuncPCABIInternal(growslice)) } if msanenabled { msanread(old.array, uintptr(old.len*int(et.size))) } if asanenabled { asanread(old.array, uintptr(old.len*int(et.size))) } // 1) 切片长度溢出判断 if cap \u003c old.cap { panic(errorString(\"growslice: cap out of range\")) } // 2) 切片元素类型 占用内存为零 情况 // 这种情况出现在： // var s []struct{} // s = append(s, struct{}{}, struct{}{}) if et.size == 0 { // append should not create a slice with nil pointer but non-zero len. // We assume that append doesn't need to preserve old.array in this case. // // Append不应该创建一个指针为nil的切片，而是一个len为non-zero的切片。 // 在这种情况下，我们假设append不需要保存old.array。 // 赋值slice.array指定地址，为了确保slice不是nil // slice为nil的判断条件是，只要slice.array==0x00,不管len和cap的值为多少都为nil return slice{unsafe.Pointer(\u0026zerobase), old.len, cap} } // 3) 评估扩容后的容量 // ---+-------+----------------------------------------------------------------------------------- // 预 | if | oldCap * 2 \u003c cap ------\u003e newCap = cap 使用cap值 // 估 |-------+----------------------------------------------------------------------------------- // 规 | else | oldCap \u003c 256 ------\u003e newCap = oldCap * 2 翻倍扩容 // 则 | | oldCap \u003e= 256 ------\u003e newCap = oldCap * 5/4 + 256 * 3/4 在原容量上扩容1/4在扩容192 // ---+-------+----------------------------------------------------------------------------------- newcap := old.cap doublecap := newcap + newcap if cap \u003e doublecap { // 2倍旧容量 \u003c cap时，则按照cap算。 newcap = cap } else { const threshold = 256 if old.cap \u003c threshold { newcap = doublecap } else { // Check 0 \u003c newcap to detect overflow // and prevent an infinite loop. // // 检查 0 \u003c newcap 以检测溢出并防止无限循环。 for 0 \u003c newcap \u0026\u0026 newcap \u003c cap { // Transition from growing 2x for small slices // to growing 1.25x for large slices. This formula // gives a smooth-ish transition between the two. newcap += (newcap + 3*threshold) / 4 } // Set newcap to the requested cap when // the newcap calculation overflowed. if newcap \u003c= 0 { newcap = cap } } } // 4) 内存规格匹配 // 内存是否溢出 true.溢出 false.没有溢出 var overflow bool\t// lenmem 旧切片元素占用的内存大小 // 该值用于迁移旧数据的依据/字节 // newlenmem 翻倍后切片元素占用的内存大小 // 该值是当前扩容后实际占用的大小/字节 // 因此capmem-newlenmem这部分内存是多余的，不会被用到。 // capmem 翻倍后新容量占用的内存大小， // 用于向操作系统申请的内存大小/字节 // 这部分内存可能大于newlenmem的值，因为Go的内存申请是有规格的。 var lenmem, newlenmem, capmem uintptr // Specialize for common values of et.size. // For 1 we don't need any division/multiplication. // For goarch.PtrSize, compiler will optimize division/multiplication into a shift by a constant. // For powers of 2, use a variable shift. // // 专门用于 et.size 的共同值。 // 对于1，我们不需要任何除法/乘法 // 对于 goarch.PtrSize，编译器将除法/乘法 优化为一个常量的位移 // 对于2的幂次方，使用可变位移 switch { // 倘若数组元素的大小为 1，则新容量大小为 1 * newcap. // 同时会针对 span class 进行取整 case et.size == 1: // 1字节 lenmem = uintptr(old.len) newlenmem = uintptr(cap) capmem = roundupsize(uintptr(newcap)) // 匹配最近接的内存块规格 overflow = uintptr(newcap) \u003e maxAlloc // 是否内存溢出 newcap = int(capmem) // 从新调整翻倍后新容量 // 倘若数组元素为指针类型，则根据指针占用空间结合元素个数计算空间大小 // 并会针对 span class 进行取整 case et.size == goarch.PtrSize: // 4或8字节 lenmem = uintptr(old.len) * goarch.PtrSize newlenmem = uintptr(cap) * goarch.PtrSize capmem = roundupsize(uintptr(newcap) * goarch.PtrSize) overflow = uintptr(newcap) \u003e maxAlloc/goarch.PtrSize newcap = int(capmem / goarch.PtrSize) // 倘若元素大小为 2 的指数，则直接通过位运算进行空间大小的计算 case isPowerOfTwo(et.size): // 2的幂次方 var shift uintptr if goarch.PtrSize == 8 { // Mask shift for better code generation. // // 掩码移位以更好地生成代码。 // sys.Ctz64函数计数尾部(低阶)零，如果全部为零，则为64。 // 比如 et.size 是2^8也就是 1_0000_0000，也就是8个零 shift = uintptr(sys.Ctz64(uint64(et.size))) \u0026 63 // 64位 } else { shift = uintptr(sys.Ctz32(uint32(et.size))) \u0026 31 // 32位 } lenmem = uintptr(old.len) \u003c\u003c shift newlenmem = uintptr(cap) \u003c\u003c shift capmem = roundupsize(uintptr(newcap) \u003c\u003c shift) overflow = uintptr(newcap) \u003e (maxAlloc \u003e\u003e shift) newcap = int(capmem \u003e\u003e shift) // 兜底分支：根据元素大小乘以元素个数 // 再针对 span class 进行取整 default: lenmem = uintptr(old.len) * et.size newlenmem = uintptr(cap) * et.size // math.MulUintptr 返回 capmem = et.size * uintptr(newcap); overflow 是否溢出 capmem, overflow = math.MulUintptr(et.size, uintptr(newcap)) capmem = roundupsize(capmem) newcap = int(capmem / et.size) } // 以上代码因为会去匹配内存规格，所以会从新计算newcap这个翻倍后的值 // The check of overflow in addition to capmem \u003e maxAlloc is needed // to prevent an overflow which can be used to trigger a segfault // on 32bit architectures with this example program: // // 除了capmem \u003e maxAlloc之外，还需要检查溢出，以防止溢出， // 该溢出可用于在32位体系结构上触发段故障，示例程序如下: // // type T [1\u003c\u003c27 + 1]int64 // // var d T // var s []T // // func main() { // s = append(s, d, d, d, d)\t// print(len(s), \"\\n\") // } // 4*(1\u003c\u003c27 + 1)*8 if overflow || capmem \u003e maxAlloc { panic(errorString(\"growslice: cap out of range\")) } // 申请到的内存首地址 var p unsafe.Pointer if et.ptrdata == 0 { // 切片元素类型不包含指针 // capmem 申请的内存; nil 类型元类型用于判断是否为指针类型; false 是否重置内存为零值; p = mallocgc(capmem, nil, false) // 向操作系统申请内存块 // The append() that calls growslice is going to overwrite from // old.len to cap (which will be the new length). // Only clear the part that will not be overwritten. // // 调用 growslice 的 append() 方法会将 old.len 覆盖到 cap(这将是新的长度)。 // 只清除不会被覆盖的部分。 // 清零capmem-newlenmem这块内存，这快内存是多余的，不会被用到。 memclrNoHeapPointers(add(p, newlenmem), capmem-newlenmem)\t} else { // 切片元素类型包含指针 // Note: can't use rawmem (which avoids zeroing of memory), // because then GC can scan uninitialized memory. // // Note: 不能使用rawmem(它可以避免内存归零)，因为这样GC会扫描未初始化的内存。 p = mallocgc(capmem, et, true) // 向操作系统申请内存块 if lenmem \u003e 0 \u0026\u0026 writeBarrier.enabled { // 开启了写屏障 // Only shade the pointers in old.array since we know the destination slice p // only contains nil pointers because it has been cleared during alloc. // // 在 old.array 中只对指针进行 shade 处理，因为我们知道目标切片 p 只包含nil指针， // 因为它在alloc期间已被清除。 // lenmem-et.size+et.ptrdata 刚好是old.array存在的都是指针 // -et.size：减去最后一个元素的内存 // +et.ptrdata：再加上最后一个元素的指针 // 刚好处理完最后一个元素后面不是指针的部分内存。 // [dst, dst+size] bulkBarrierPreWriteSrcOnly(uintptr(p), uintptr(old.array), lenmem-et.size+et.ptrdata)\t} } // 从old.array中迁移lenmem大小内存数据到p中 memmove(p, old.array, lenmem) // 注意：这里返回的是 old.len，因为此时还是之前的旧数据 return slice{p, old.len, newcap} } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 // bulkBarrierPreWriteSrcOnly is like bulkBarrierPreWrite but // does not execute write barriers for [dst, dst+size). // // In addition to the requirements of bulkBarrierPreWrite // callers need to ensure [dst, dst+size) is zeroed. // // This is used for special cases where e.g. dst was just // created and zeroed with malloc. // // The type of the space can be provided purely as an optimization, // however it is not used with GOEXPERIMENT=noallocheaders. // //go:nosplit func bulkBarrierPreWriteSrcOnly(dst, src, size uintptr, _ *abi.Type) { // GC并发标记阶段，这里需要处理混合写屏障相关事项，因为在拷贝指针数据 if (dst|src|size)\u0026(goarch.PtrSize-1) != 0 { throw(\"bulkBarrierPreWrite: unaligned arguments\") } if !writeBarrier.enabled { return // 并发标记已结束 } buf := \u0026getg().m.p.ptr().wbBuf // 写屏障缓冲区 h := heapBitsForAddr(dst, size) for { var addr uintptr if h, addr = h.next(); addr == 0 { break } srcx := (*uintptr)(unsafe.Pointer(addr - dst + src)) p := buf.get1() p[0] = *srcx } } 所有0字节分配的基地址。 1 2 // base address for all 0-byte allocations var zerobase uintptr roundupsize() mallocgc返回将分配的内存块的大小，如果您要求该大小。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // Returns size of the memory block that mallocgc will allocate if you ask for the size. func roundupsize(size uintptr) uintptr { // _MaxSmallSize = 32768 if size \u003c _MaxSmallSize { // smallSizeMax = 1024 if size \u003c= smallSizeMax-8 { // 以最下8B倍数对齐 // smallSizeDiv = 8，divRoundUp 等价于 ceil(size/8) // size_to_class8和class_to_size 记录着 size 的映射关系 return uintptr(class_to_size[size_to_class8[divRoundUp(size, smallSizeDiv)]]) } else { // 以最小128B倍数对齐 // largeSizeDiv = 128 return uintptr(class_to_size[size_to_class128[divRoundUp(size-smallSizeMax, largeSizeDiv)]]) } } // _PageSize = 8192 if size+_PageSize \u003c size { return size } return alignUp(size, _PageSize) // 对齐8KB } alignUp() alignUp将n取整为a的倍数。a必须是2的幂。 1 2 3 4 // alignUp rounds n up to a multiple of a. a must be a power of 2. func alignUp(n, a uintptr) uintptr { return (n + a - 1) \u0026^ (a - 1) } MulUintptr() MulUintptr返回a * b以及乘法运算是否溢出。 在受支持的平台上，这是由编译器降低的固有特性。 1 2 3 4 5 6 7 8 9 10 11 // MulUintptr returns a * b and whether the multiplication overflowed. // On supported platforms this is an intrinsic lowered by the compiler. func MulUintptr(a, b uintptr) (uintptr, bool) { // a|b \u003c 1\u003c\u003c16 || a|b \u003c 1\u003c\u003c32 if a|b \u003c 1\u003c\u003c(4*goarch.PtrSize) || a == 0 { return a * b, false } // const MaxUintptr = ^uintptr(0) overflow := b \u003e MaxUintptr/a return a * b, overflow } ",
  "wordCount" : "3102",
  "inLanguage": "zh",
  "image": "https://heliu.site/favicon-32x32.png","datePublished": "2020-09-02T00:00:00Z",
  "dateModified": "2024-01-21T00:00:00Z",
  "author":[{
    "@type": "Person",
    "name": "helium"
  }],
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://heliu.site/posts/golang/slice/theory/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Helium",
    "logo": {
      "@type": "ImageObject",
      "url": "https://heliu.site/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://heliu.site/" accesskey="h" title="Blog (Alt + H)">
                <img src="https://heliu.site/helium.png" alt="" aria-label="logo"
                    height="35">Blog</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://heliu.site/" title="主页">
                    <span>Home</span>
                </a>
            </li>
            <li>
                <a href="https://heliu.site/posts" title="文章">
                    <span>Article</span>
                </a>
            </li>
            <li>
                <a href="https://heliu.site/archives" title="时间轴">
                    <span>Archive</span>
                </a>
            </li>
            <li>
                <a href="https://heliu.site/tags/" title="标签">
                    <span>Tag</span>
                </a>
            </li>
            <li>
                <a href="https://heliu.site/search/" title="搜索 (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
            <li>
                <a href="https://heliu.site/support" title="打赏">
                    <span>🫶Help</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">


<article class="post" autonumbering>
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://heliu.site/">主页</a>&nbsp;»&nbsp;<a href="https://heliu.site/posts/">Article</a>&nbsp;»&nbsp;<a href="https://heliu.site/posts/golang/">Golang 合集</a>&nbsp;»&nbsp;<a href="https://heliu.site/posts/golang/slice/">第7章 Slice</a></div>
    <h1 class="post-title entry-hint-parent">
      Slice(原理)
    </h1>
    <div class="post-description">
      💥本文章所有相关go代码参考自go 1.18&#43;版本
    </div>
    <div class="post-meta">










<span class="x-post-meta-item"><svg t="1720837714681" class="icon" viewBox="0 0 1084 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="7520" width="200" height="200"><path d="M123.47509 1023.984942a123.565437 123.565437 0 0 1-123.505206-123.32451V243.863302A123.565437 123.565437 0 0 1 123.47509 120.568908h171.630374V26.06529a26.050232 26.050232 0 0 1 52.070349 0v94.503618h377.592848V26.06529a26.050232 26.050232 0 0 1 52.100464 0v94.503618h183.797189A123.565437 123.565437 0 0 1 1084.171519 243.863302v656.79713A123.565437 123.565437 0 0 1 960.666314 1023.984942H123.47509z m-71.404741-123.32451A71.434857 71.434857 0 0 0 123.47509 971.974825h837.191224a71.434857 71.434857 0 0 0 71.404741-71.314393V442.326922l-946.361273-3.824716a25.598494 25.598494 0 0 1-5.84248-0.692665l-27.796953-6.444798v469.295689zM123.47509 172.579025a71.434857 71.434857 0 0 0-71.404741 71.284277v149.736133l27.796953-6.444797a26.080348 26.080348 0 0 1 5.902712-0.662549l946.301041 3.824716V243.863302a71.404741 71.404741 0 0 0-71.404741-71.284277h-180.183284l-6.173754 12.859479a26.200812 26.200812 0 0 1-23.490383 14.786895 26.261043 26.261043 0 0 1-23.520499-14.786895l-6.173754-12.859479H350.819834l-6.173754 12.859479a26.200812 26.200812 0 0 1-23.490383 14.786895 26.230928 26.230928 0 0 1-23.520499-14.786895l-6.173755-12.859479H123.47509z m156.150814 578.827128a26.050232 26.050232 0 0 1-26.050232-25.990001c0-14.335157 11.68496-26.020116 26.050232-26.020116h521.697312c14.365273 0 26.050232 11.68496 26.050233 26.020116a26.050232 26.050232 0 0 1-26.050233 25.990001H279.625904z" fill="#3D3F42" p-id="7521"></path></svg><span>2020-09-02</span></span>&nbsp;<span class="x-post-meta-item"><svg t="1720839329181" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="14106" width="200" height="200"><path d="M699.270662 190.485379c-0.411369 0-0.821715 0.011256-1.227967 0.032746H507.034407a23.041786 23.041786 0 0 0-1.221828-0.031723c-12.779048 0-23.140023 10.359952-23.140023 23.139 0 12.781094 10.360975 23.141046 23.140023 23.141046v0.032746h193.458083v-0.032746c12.780071 0 23.141046-10.359952 23.141047-23.141046 0-12.780071-10.360975-23.140023-23.141047-23.140023zM979.215516 724.005508c0-142.090159-115.186416-257.277598-257.277598-257.277598-72.245418 0-137.532353 29.777187-184.262654 77.725223l45.868677 31.474852c36.227086-33.873482 84.882226-54.617945 138.393977-54.617945 111.945605 0 202.696492 90.750887 202.696492 202.695468h-43.01263l70.331835 104.289228 70.331835-104.289228H979.215516z" fill="" p-id="14107"></path><path d="M748.885664 588.843132c0-14.881942-12.06785-26.945699-26.947746-26.945698-14.883989 0-26.947745 12.063757-26.947745 26.945698v135.164423c0 14.879895 12.063757 26.945699 26.947745 26.945699h107.786889c14.881942 0 26.945699-12.063757 26.945698-26.945699s-12.063757-26.945699-26.945698-26.945699h-80.839143V588.843132zM721.937918 926.702c-111.947651 0-202.696492-90.74884-202.696492-202.696492 0-0.144286 0.004093-0.285502 0.004094-0.429788h43.004443l-70.330812-104.289228-70.331835 104.289228h43.075051c0 0.144286-0.00307 0.285502-0.00307 0.429788 0 142.091182 115.187439 257.279644 257.278621 257.279645 72.241324 0 137.530306-29.77821 184.260607-77.727269l-45.86663-31.474852c-36.227086 33.873482-84.884272 54.618968-138.393977 54.618968zM694.633039 423.38066c-1.354857-11.487635-11.120268-20.400632-22.972201-20.400632H206.362486c-12.780071 0-23.140023 10.359952-23.140023 23.138999 0 12.781094 10.359952 23.141046 23.140023 23.141047H596.949252c30.209022-13.81668 63.104223-22.76754 97.683787-25.879414zM438.548616 623.143333H206.362486c-12.780071 0-23.140023 10.358929-23.140023 23.140023 0 12.780071 10.359952 23.140023 23.140023 23.140023h219.956598a298.463626 298.463626 0 0 1 12.229532-46.280046zM506.934123 513.062192H206.362486c-12.780071 0-23.140023 10.359952-23.140023 23.139 0 12.781094 10.359952 23.140023 23.140023 23.140023H469.936487a302.241672 302.241672 0 0 1 36.997636-46.279023z" fill="" p-id="14108"></path><path d="M442.765661 835.277778a298.531164 298.531164 0 0 1-14.365173-46.150087H146.542052v-0.065491c-33.036417 0-59.81941-26.78197-59.81941-59.819411V329.36031h704.907545v100.905154a298.561863 298.561863 0 0 1 46.150086 14.996552V194.619536h-0.162706c0-53.422723-43.307342-96.728018-96.730065-96.728018h-68.89409V84.418668c0-33.037441-26.782993-59.81941-59.81941-59.81941v-0.361227h-18.87079v0.032745c-33.038464 0-59.820434 26.78197-59.820433 59.819411 0 0.109494 0.008186 0.218988 0.008186 0.328481h-0.339738v13.47285H345.203648V84.418668c0-33.037441-26.782993-59.81941-59.819411-59.81941v-0.361227h-18.872836v0.032745c-33.036417 0-59.81941 26.78197-59.81941 59.819411 0 0.109494 0.007163 0.218988 0.008186 0.328481h-0.339737v13.47285h-69.189826c-53.4217 0-96.729042 43.306318-96.729041 96.728018 0 1.701758 0.045025 3.39226 0.132006 5.071505v533.785166a98.051153 98.051153 0 0 0-0.132006 5.071506c0 53.4217 43.307342 96.728018 96.729041 96.728018v0.001023h305.595047zM86.723665 204.056466c0-33.037441 26.782993-59.81941 59.819411-59.819411 0.044002 0 0.086981 0.00307 0.130983 0.00307v-0.068561h105.968473V94.874811h0.032746a22.807449 22.807449 0 0 1-0.032746-1.215688c0-12.779048 10.360975-23.140023 23.140023-23.140023s23.140023 10.360975 23.140023 23.140023c0 0.408299-0.010233 0.812505-0.031722 1.215688h0.031722v49.297776h280.508696V94.874811h0.032745a22.807449 22.807449 0 0 1-0.032745-1.215688c0-12.779048 10.361999-23.140023 23.140023-23.140023 12.780071 0 23.141046 10.360975 23.141046 23.140023 0 0.408299-0.011256 0.812505-0.032746 1.215688h0.032746v49.297776h106.10048v0.065492c33.035394 0 59.818387 26.780947 59.818387 59.81941h0.130983V283.080264H86.723665v-79.023798z" fill="" p-id="14109"></path></svg><span>2024-01-21</span></span>&nbsp;<span class="x-post-meta-item"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2" fill="none"
     stroke-linecap="round" stroke-linejoin="round" class="feather feather-file-text" style="user-select: text;">
    <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z" style="user-select: text;"></path>
    <polyline points="14 2 14 8 20 8" style="user-select: text;"></polyline>
    <line x1="16" y1="13" x2="8" y2="13" style="user-select: text;"></line>
    <line x1="16" y1="17" x2="8" y2="17" style="user-select: text;"></line>
    <polyline points="10 9 9 9 8 9" style="user-select: text;"></polyline>
</svg><span>3102字</span></span>&nbsp;<span class="x-post-meta-item"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2" fill="none"
     stroke-linecap="round" stroke-linejoin="round">
    <path stroke="none" d="M0 0h24v24H0z" fill="none"></path>
    <circle cx="12" cy="12" r="9"></circle>
    <polyline points="12 7 12 12 15 15"></polyline>
</svg><span>15分钟</span></span>&nbsp;<span class="x-post-meta-item"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2" fill="none"
     stroke-linecap="round" stroke-linejoin="round">
    <path stroke="none" d="M0 0h24v24H0z" fill="none"></path>
    <circle cx="12" cy="7" r="4"></circle>
    <path d="M6 21v-2a4 4 0 0 1 4 -4h4a4 4 0 0 1 4 4v2"></path>
</svg><span>helium</span></span>
      <span class="x-post-meta-item">
        &nbsp;<svg t="1720840393161" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="18680" width="200" height="200"><path d="M995.125144 559.61812l-415.998603-415.998602A52.986489 52.986489 0 0 0 541.413335 127.99957H338.847348c-3.166656-26.559911-9.286635-51.046495-17.999939-71.333094C299.734146 7.333309 271.154242 0 256.00096 0c-13.939953 0-40.439864 6.339979-61.259794 48.806503-10.473298 21.366595-17.946606 48.966502-21.573261 79.193067H53.334974a53.393154 53.393154 0 0 0-53.333154 53.333154v360.078791a52.986489 52.986489 0 0 0 15.619948 37.713206l415.998602 415.998603a53.333154 53.333154 0 0 0 75.426413 0l26.286579-26.293245 26.286578 26.293245a53.426487 53.426487 0 0 0 16.719944 11.333295 21.333262 21.333262 0 0 0 36.079879 11.293295l382.705381-382.705381a53.399821 53.399821 0 0 0 0-75.426413z m-762.070774-491.998347C241.494342 50.373164 250.667645 42.666523 256.00096 42.666523c5.99998 0 16.573278 9.639968 25.646581 30.806564 6.493312 15.159949 11.333295 33.999886 14.146619 54.526483H216.16776c3.206656-23.419921 9.013303-44.359851 16.88661-60.41313z m243.819181 897.330319a10.666631 10.666631 0 0 1-15.079949 0l-415.998603-415.998603A10.573298 10.573298 0 0 1 42.668343 541.411515V181.332724a10.666631 10.666631 0 0 1 10.666631-10.666631h245.332509c0 47.853173-10.373298 92.15969-27.066575 115.632945-5.926647 8.326639-16.566611 14.186619-22.306592 16.113279C204.041135 314.752276 170.667913 356.218803 170.667913 405.331972c0 58.813136 47.853173 106.666308 106.666309 106.666308s106.666308-47.853173 106.666308-106.666308c0-47.086508-30.666564-87.139707-73.079754-101.246327C330.060711 272.705751 341.334007 223.692582 341.334007 170.666093h72.079758a10.573298 10.573298 0 0 1 7.539974 3.126656l415.998603 415.998603a10.666631 10.666631 0 0 1 0 15.079949zM341.334007 405.331972a63.999785 63.999785 0 1 1-63.999785-63.999785 64.073118 64.073118 0 0 1 63.999785 63.999785z m263.539114 559.61812a10.666631 10.666631 0 0 1-15.079949 0L563.499927 938.663513l303.625647-303.61898a53.399821 53.399821 0 0 0 0-75.426413L478.16688 170.666093h63.246455a10.573298 10.573298 0 0 1 7.539974 3.126656l415.998603 415.998603c0.239999 0.239999 0.466665 0.486665 0.666664 0.746664l0.086667 0.106666a10.666631 10.666631 0 0 1 0 13.373289l-0.086667 0.106666c-0.213333 0.259999-0.439999 0.506665-0.666664 0.746664z" fill="#5C5C66" p-id="18681"></path></svg>
        <ul class="post-tags-meta" style="display: inline-block;font-size: 14px;">
            <a href="https://heliu.site/tags/golang/" target="_blank" rel="noopener">Golang</a>
            <a href="https://heliu.site/tags/%E5%88%87%E7%89%87/" target="_blank" rel="noopener">切片</a>
        </ul>
      </span>
      
      <span id="busuanzi_container_page_pv" class="x-post-meta-item">
        &nbsp;<svg t="1720844685710" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="27237" width="200" height="200"><path d="M739.754667 574.08c-121.386667 45.610667-208.469333 169.813333-208.64 316.16 0 33.408 4.693333 65.493333 13.141333 95.914667H94.122667c-26.453333-43.52-41.685333-91.946667-41.685334-143.189334 0-185.173333 192.896-335.104 430.805334-335.104 96.256 0 184.832 24.746667 256.512 66.218667z m-280.490667-114.986667a214.869333 214.869333 0 0 1-214.869333-215.04A215.04 215.04 0 0 1 459.264 28.842667a215.04 215.04 0 0 1 215.04 215.210666 215.04 215.04 0 0 1-215.04 215.04zM974.506667 641.28c9.856 0 17.834667 7.466667 17.834666 16.64v59.989333c-0.341333 8.789333-7.850667 15.786667-17.28 16.085334-9.856 0.341333-18.176-6.826667-18.517333-16.085334v-20.053333l-99.114667 91.093333-0.256 0.256a18.474667 18.474667 0 0 1-14.848 4.352h-0.768a18.176 18.176 0 0 1-9.344-4.608l-0.938666-0.981333-85.930667-80.042667-123.562667 115.072a18.773333 18.773333 0 0 1-25.216 0 15.786667 15.786667 0 0 1 0-23.466666l136.149334-126.848 0.725333-0.597334a18.645333 18.645333 0 0 1 24.362667 0.512l87.253333 81.237334 86.058667-79.232h-21.248c-9.386667-0.298667-16.938667-7.338667-17.28-16.085334-0.341333-9.173333 7.381333-16.896 17.28-17.237333h64.64z m-367.146667 240h48.128c8.874667 0 16.042667 7.168 16.042667 16.042667v72.192a16.042667 16.042667 0 0 1-16.042667 16.042666h-48.128a16.042667 16.042667 0 0 1-16.042667-16.042666v-72.192c0-8.874667 7.210667-16.042667 16.042667-16.042667z m110.805333-106.666667h48.128c8.874667 0 16.042667 7.168 16.042667 16.042667v178.858667a16.042667 16.042667 0 0 1-16.042667 16.042666h-48.128a16.042667 16.042667 0 0 1-16.042666-16.042666v-178.858667c0-8.874667 7.168-16.042667 16.042666-16.042667z m106.538667 80h48.128c8.874667 0 16.042667 7.168 16.042667 16.042667v99.413333a16.042667 16.042667 0 0 1-16.042667 16.042667H824.746667a16.042667 16.042667 0 0 1-16.042667-16.042667v-99.413333c0-8.874667 7.168-16.042667 16.042667-16.042667z m110.165333-80h48.128c8.874667 0 16.042667 7.168 16.042667 16.042667v179.413333a16.042667 16.042667 0 0 1-16.042667 16.042667h-48.128a16.042667 16.042667 0 0 1-16.042666-16.042667v-179.413333c0-8.874667 7.210667-16.042667 16.042666-16.042667z" fill="#999999" p-id="27238"></path></svg>
        <span id="busuanzi_value_page_pv"></span>
      </span>

</div>
  </header> <aside id="toc-container" class="toc-container wide">
    <div class="toc">
        <details  open>
            <summary accesskey="c" title="(Alt + C)">
                <span class="details">目录</span>
            </summary>

            <div class="inner"><ul>
                    <li>
                        <a href="#type-slice-struct" aria-label="type slice struct"><code>type slice struct</code></a></li>
                    <li>
                        <a href="#type-notinheapslice-struct" aria-label="type notInHeapSlice struct"><code>type notInHeapSlice struct</code></a><ul>
                            
                    <li>
                        <a href="#type-notinheap-struct" aria-label="type notInHeap struct"><code>type notInHeap struct</code></a></li>
                    <li>
                        <a href="#add" aria-label="add()"><code>add()</code></a></li></ul>
                    </li>
                    <li>
                        <a href="#make" aria-label="make()"><code>make()</code></a><ul>
                            
                    <li>
                        <a href="#makeslice" aria-label="makeslice()"><code>makeslice()</code></a></li>
                    <li>
                        <a href="#makeslice64" aria-label="makeslice64()"><code>makeslice64()</code></a></li></ul>
                    </li>
                    <li>
                        <a href="#len" aria-label="len()"><code>len()</code></a></li>
                    <li>
                        <a href="#cap" aria-label="cap()"><code>cap()</code></a></li>
                    <li>
                        <a href="#copy" aria-label="copy()"><code>copy()</code></a><ul>
                            
                    <li>
                        <a href="#slicecopy" aria-label="slicecopy()"><code>slicecopy()</code></a></li>
                    <li>
                        <a href="#memmove" aria-label="memmove()"><code>memmove()</code></a></li></ul>
                    </li>
                    <li>
                        <a href="#append" aria-label="append()"><code>append()</code></a><ul>
                            
                    <li>
                        <a href="#growslice" aria-label="growslice()"><code>growslice()</code></a></li>
                    <li>
                        <a href="#roundupsize" aria-label="roundupsize()"><code>roundupsize()</code></a></li>
                    <li>
                        <a href="#alignup" aria-label="alignUp()"><code>alignUp()</code></a></li>
                    <li>
                        <a href="#muluintptr" aria-label="MulUintptr()"><code>MulUintptr()</code></a>
                    </li>
                </ul>
                </li>
                </ul>
            </div>
        </details>
    </div>
</aside>
<script>
    let activeElement;
    let elements;
    window.addEventListener('DOMContentLoaded', function (event) {
        checkTocPosition();

        elements = document.querySelectorAll('h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]');
         
         activeElement = elements[0];
         const id = encodeURI(activeElement.getAttribute('id')).toLowerCase();
         document.querySelector(`.inner ul li a[href="#${id}"]`).classList.add('active');
     }, false);

    window.addEventListener('resize', function(event) {
        checkTocPosition();
    }, false);

    window.addEventListener('scroll', () => {
        
        activeElement = Array.from(elements).find((element) => {
            if ((getOffsetTop(element) - window.pageYOffset) > 0 && 
                (getOffsetTop(element) - window.pageYOffset) < window.innerHeight/2) {
                return element;
            }
        }) || activeElement

        elements.forEach(element => {
             const id = encodeURI(element.getAttribute('id')).toLowerCase();
             if (element === activeElement){
                 document.querySelector(`.inner ul li a[href="#${id}"]`).classList.add('active');
             } else {
                 document.querySelector(`.inner ul li a[href="#${id}"]`).classList.remove('active');
             }
         })
     }, false);

    const main = parseInt(getComputedStyle(document.body).getPropertyValue('--article-width'), 10);
    const toc = parseInt(getComputedStyle(document.body).getPropertyValue('--toc-width'), 10);
    const gap = parseInt(getComputedStyle(document.body).getPropertyValue('--gap'), 10);

    function checkTocPosition() {
        const width = document.body.scrollWidth;

        if (width - main - (toc * 2) - (gap * 4) > 0) {
            document.getElementById("toc-container").classList.add("wide");
        } else {
            document.getElementById("toc-container").classList.remove("wide");
        }
    }

    function getOffsetTop(element) {
        if (!element.getClientRects().length) {
            return 0;
        }
        let rect = element.getBoundingClientRect();
        let win = element.ownerDocument.defaultView;
        return rect.top + win.pageYOffset;   
    }
</script>
  <div class="post-content"><ul>
<li>本篇文章都是<code>slice</code>的源码走读。</li>
<li>注意：slice <strong>不是并发安全</strong>的数据结构，大家在使用时请务必注意并发安全问题。</li>
</ul>
<h2 id="type-slice-struct"><code>type slice struct</code><a hidden class="anchor" aria-hidden="true" href="#type-slice-struct">#</a></h2>
<ol>
<li>切片的内存布局。
<ul>
<li><code>array</code>：指向一个<code>[cap]T</code>大小的数组地址。就是指向一个<code>cap</code>容量大小的数组首地址。</li>
<li><code>len</code>：记录切片已存储元素的长度，也是可访问的最大下标<code>len - 1</code>。</li>
<li><code>cap</code>：记录切片的容量，也就是当前切片存储的最大元素数量（未扩容前）。</li>
</ul>
</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">slice</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">array</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span>
</span></span><span class="line"><span class="cl">    <span class="nx">len</span>   <span class="kt">int</span>
</span></span><span class="line"><span class="cl">    <span class="nx">cap</span>   <span class="kt">int</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p><img loading="lazy" src="../images/slice-001.png" alt=""  />
</p>
<h2 id="type-notinheapslice-struct"><code>type notInHeapSlice struct</code><a hidden class="anchor" aria-hidden="true" href="#type-notinheapslice-struct">#</a></h2>
<ol>
<li><code>notInHeapSlice</code>是<code>go:notinheap</code>内存支持的<code>slice</code>。</li>
<li>也就是该类型的对象<strong>不是在堆</strong>中创建的，也就是GC不会扫描，多用于内存管理模块中。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// A notInHeapSlice is a slice backed by go:notinheap memory.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">type</span> <span class="nx">notInHeapSlice</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">array</span> <span class="o">*</span><span class="nx">notInHeap</span>    <span class="c1">// 指向一个起始地址
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">len</span>   <span class="kt">int</span>
</span></span><span class="line"><span class="cl">    <span class="nx">cap</span>   <span class="kt">int</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="type-notinheap-struct"><code>type notInHeap struct</code><a hidden class="anchor" aria-hidden="true" href="#type-notinheap-struct">#</a></h3>
<ol>
<li><code>notInHeap</code>是由<code>sysAlloc</code>或<code>persistentAlloc</code>等底层分配器分配的堆外内存。</li>
<li>一般来说，最好使用标记为<code>go:notinheap</code>的真实类型，但在无法这样做的情况下(比如在分配器中)，它用作通用类型。</li>
<li>TODO：使用它作为<code>sysAlloc</code>,<code>persistentAlloc</code>等的返回类型?</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// notInHeap is off-heap memory allocated by a lower-level allocator
</span></span></span><span class="line"><span class="cl"><span class="c1">// like sysAlloc or persistentAlloc.
</span></span></span><span class="line"><span class="cl"><span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1">// In general, it&#39;s better to use real types marked as go:notinheap,
</span></span></span><span class="line"><span class="cl"><span class="c1">// but this serves as a generic type for situations where that isn&#39;t
</span></span></span><span class="line"><span class="cl"><span class="c1">// possible (like in the allocators).
</span></span></span><span class="line"><span class="cl"><span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1">// TODO: Use this as the return type of sysAlloc, persistentAlloc, etc?
</span></span></span><span class="line"><span class="cl"><span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1">//go:notinheap
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">type</span> <span class="nx">notInHeap</span> <span class="kd">struct</span><span class="p">{}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="add"><code>add()</code><a hidden class="anchor" aria-hidden="true" href="#add">#</a></h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">p</span> <span class="o">*</span><span class="nx">notInHeap</span><span class="p">)</span> <span class="nf">add</span><span class="p">(</span><span class="nx">bytes</span> <span class="kt">uintptr</span><span class="p">)</span> <span class="o">*</span><span class="nx">notInHeap</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// p + bytes
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">return</span> <span class="p">(</span><span class="o">*</span><span class="nx">notInHeap</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">p</span><span class="p">))</span> <span class="o">+</span> <span class="nx">bytes</span><span class="p">))</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="make"><code>make()</code><a hidden class="anchor" aria-hidden="true" href="#make">#</a></h2>
<ol>
<li><code>make</code>内置函数分配并初始化一个类型为<code>slice</code>、<code>map</code>或<code>chan</code>的对象(only)。</li>
<li>和<code>new</code>一样，第一个参数是类型，而不是值。与<code>new</code>不同，<code>make</code>的返回值类型与其参数的类型相同，而不是指向参数的指针。</li>
<li>具体的结果取决于类型：
<ol>
<li><code>Slice</code>：
<ul>
<li>size指定了长度。切片的容量等于它的长度。</li>
<li>以提供第二个整数参数来指定不同的容量;它必须不小于长度。</li>
<li>例如，<code>make([]int, 0, 10)</code>会分配一个长度为10的底层数组，并返回一个长度为0、容量为10的切片。</li>
</ul>
</li>
<li><code>Map</code>：一个空的<code>map</code>分配了足够的空间来保存指定数量的元素。在这种情况下，可以省略长度，分配一个较小的起始长度。</li>
<li><code>Channel</code>：channel缓冲区使用指定的缓冲区容量初始化。如果为0，或者size被省略，则channel是无缓冲的。</li>
</ol>
</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// The make built-in function allocates and initializes an object of type
</span></span></span><span class="line"><span class="cl"><span class="c1">// slice, map, or chan (only). Like new, the first argument is a type, not a
</span></span></span><span class="line"><span class="cl"><span class="c1">// value. Unlike new, make&#39;s return type is the same as the type of its
</span></span></span><span class="line"><span class="cl"><span class="c1">// argument, not a pointer to it. The specification of the result depends on
</span></span></span><span class="line"><span class="cl"><span class="c1">// the type:
</span></span></span><span class="line"><span class="cl"><span class="c1">//	Slice: The size specifies the length. The capacity of the slice is
</span></span></span><span class="line"><span class="cl"><span class="c1">//	equal to its length. A second integer argument may be provided to
</span></span></span><span class="line"><span class="cl"><span class="c1">//	specify a different capacity; it must be no smaller than the
</span></span></span><span class="line"><span class="cl"><span class="c1">//	length. For example, make([]int, 0, 10) allocates an underlying array
</span></span></span><span class="line"><span class="cl"><span class="c1">//	of size 10 and returns a slice of length 0 and capacity 10 that is
</span></span></span><span class="line"><span class="cl"><span class="c1">//	backed by this underlying array.
</span></span></span><span class="line"><span class="cl"><span class="c1">//	Map: An empty map is allocated with enough space to hold the
</span></span></span><span class="line"><span class="cl"><span class="c1">//	specified number of elements. The size may be omitted, in which case
</span></span></span><span class="line"><span class="cl"><span class="c1">//	a small starting size is allocated.
</span></span></span><span class="line"><span class="cl"><span class="c1">//	Channel: The channel&#39;s buffer is initialized with the specified
</span></span></span><span class="line"><span class="cl"><span class="c1">//	buffer capacity. If zero, or the size is omitted, the channel is
</span></span></span><span class="line"><span class="cl"><span class="c1">//	unbuffered.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nb">make</span><span class="p">(</span><span class="nx">t</span> <span class="nx">Type</span><span class="p">,</span> <span class="nx">size</span> <span class="o">...</span><span class="nx">IntegerType</span><span class="p">)</span> <span class="nx">Type</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="makeslice"><code>makeslice()</code><a hidden class="anchor" aria-hidden="true" href="#makeslice">#</a></h3>
<ol>
<li><code>make([]T *_type, len, cap int)</code>
<ul>
<li><code>*_type</code>：记录着切片元素类型，比如<code>[]string</code>切片这里是<code>string</code>的元类型。</li>
<li><code>len</code>：切片的长度，该参数是必传。</li>
<li><code>cap</code>：切片的容量，该参数是可传，默认会传<code>len</code>大小。</li>
</ul>
</li>
<li><code>makeslice()</code>函数是切片申请内存的make()函数原型，主要负责申请<code>slice.array</code>字段指向的内存大小。</li>
<li>那么切片的24字节大小内存是在什么时候分配的？（64位系统下为24字节内存，32系统下为12字节内存）
<ul>
<li>可能在函数栈上直接分配24字节大小内存。</li>
<li>也可能在堆上分配24字节大小内存。</li>
</ul>
</li>
<li>调用了<code>makeslice()</code>函数，其<code>slice.array</code>指向的内存块一定是在<strong>堆</strong>上。没有调该函数时可能内存分配在<strong>栈</strong>上。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">makeslice</span><span class="p">(</span><span class="nx">et</span> <span class="o">*</span><span class="nx">_type</span><span class="p">,</span> <span class="nx">len</span><span class="p">,</span> <span class="nx">cap</span> <span class="kt">int</span><span class="p">)</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 1）判断et.size * uintptr(cap)是否造成内存溢出
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">mem</span><span class="p">,</span> <span class="nx">overflow</span> <span class="o">:=</span> <span class="nx">math</span><span class="p">.</span><span class="nf">MulUintptr</span><span class="p">(</span><span class="nx">et</span><span class="p">.</span><span class="nx">size</span><span class="p">,</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">cap</span><span class="p">))</span> <span class="c1">// 按照cap计算的
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//  1. 【overflow == true】：溢出
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//  2. 【mem &gt; maxAlloc】：超过操作系统最大内存
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//  3. 【len &lt; 0】：错误的len参数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//  4. 【len &gt; cap】：长度大于容量
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nx">overflow</span> <span class="o">||</span> <span class="nx">mem</span> <span class="p">&gt;</span> <span class="nx">maxAlloc</span> <span class="o">||</span> <span class="nx">len</span> <span class="p">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="nx">len</span> <span class="p">&gt;</span> <span class="nx">cap</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// NOTE: Produce a &#39;len out of range&#39; error instead of a
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// &#39;cap out of range&#39; error when someone does make([]T, bignumber).
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// &#39;cap out of range&#39; is true too, but since the cap is only being
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// supplied implicitly, saying len is clearer.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// See golang.org/issue/4085.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 当有人 make([]T, bignumber) 时，产生一个 &#39;len out of range&#39; 错误而不是 &#39;cap out of range&#39; 错误提示
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 当 &#39;cap out of range&#39; 也是太长了，由于cap只是隐式地提供，所以说len更清楚的提示。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">mem</span><span class="p">,</span> <span class="nx">overflow</span> <span class="o">:=</span> <span class="nx">math</span><span class="p">.</span><span class="nf">MulUintptr</span><span class="p">(</span><span class="nx">et</span><span class="p">.</span><span class="nx">size</span><span class="p">,</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">len</span><span class="p">))</span>	<span class="c1">// 根据len计算
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="nx">overflow</span> <span class="o">||</span> <span class="nx">mem</span> <span class="p">&gt;</span> <span class="nx">maxAlloc</span> <span class="o">||</span> <span class="nx">len</span> <span class="p">&lt;</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nf">panicmakeslicelen</span><span class="p">()</span> <span class="c1">// painc &#39;len out of range&#39;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="nf">panicmakeslicecap</span><span class="p">()</span> <span class="c1">// panic &#39;cap out of range&#39;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 2）向操作系统申请mem大小的内存块，返回申请到内存块的首地址
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">return</span> <span class="nf">mallocgc</span><span class="p">(</span><span class="nx">mem</span><span class="p">,</span> <span class="nx">et</span><span class="p">,</span> <span class="kc">true</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="makeslice64"><code>makeslice64()</code><a hidden class="anchor" aria-hidden="true" href="#makeslice64">#</a></h3>
<ol>
<li>int64版本，如果当前是在32位系统中时，<code>int</code>其实是<code>int32</code>大小。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">makeslice64</span><span class="p">(</span><span class="nx">et</span> <span class="o">*</span><span class="nx">_type</span><span class="p">,</span> <span class="nx">len64</span><span class="p">,</span> <span class="nx">cap64</span> <span class="kt">int64</span><span class="p">)</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">len</span> <span class="o">:=</span> <span class="nb">int</span><span class="p">(</span><span class="nx">len64</span><span class="p">)</span> <span class="c1">// 32位系统下转换会丢失部分数据
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nb">int64</span><span class="p">(</span><span class="nx">len</span><span class="p">)</span> <span class="o">!=</span> <span class="nx">len64</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">panicmakeslicelen</span><span class="p">()</span> <span class="c1">// painc &#39;len out of range&#39;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nx">cap</span> <span class="o">:=</span> <span class="nb">int</span><span class="p">(</span><span class="nx">cap64</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nb">int64</span><span class="p">(</span><span class="nx">cap</span><span class="p">)</span> <span class="o">!=</span> <span class="nx">cap64</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">panicmakeslicecap</span><span class="p">()</span> <span class="c1">// panic &#39;cap out of range&#39;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nf">makeslice</span><span class="p">(</span><span class="nx">et</span><span class="p">,</span> <span class="nx">len</span><span class="p">,</span> <span class="nx">cap</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="len"><code>len()</code><a hidden class="anchor" aria-hidden="true" href="#len">#</a></h2>
<ol>
<li>以下伪代码获取切片的长度。</li>
<li>len函数的原型：<code>func len(array []T) int</code>。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// 伪代码示例
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nb">len</span><span class="p">(</span><span class="nx">array</span> <span class="p">[]</span><span class="nx">T</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nx">array</span><span class="p">.</span><span class="nx">len</span>   
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="cap"><code>cap()</code><a hidden class="anchor" aria-hidden="true" href="#cap">#</a></h2>
<ol>
<li>以下伪代码获取切片的容量。</li>
<li>cap函数的原型：<code>func cap(array []T) int</code>。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// 伪代码示例
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nb">cap</span><span class="p">(</span><span class="nx">array</span> <span class="p">[]</span><span class="nx">T</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nx">array</span><span class="p">.</span><span class="nx">cap</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="copy"><code>copy()</code><a hidden class="anchor" aria-hidden="true" href="#copy">#</a></h2>
<ol>
<li>copy内置函数将元素<strong>从源片复制到目标片</strong>。(作为特殊情况，它也会将bytes从string复制到byte切片。)</li>
<li>源和目标可能重叠。</li>
<li>copy返回复制的元素数量，这将是<code>len(src)</code>和<code>len(dst)</code>的最小值。<code>src</code>-&gt;<code>dst</code>。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// The copy built-in function copies elements from a source slice into a
</span></span></span><span class="line"><span class="cl"><span class="c1">// destination slice. (As a special case, it also will copy bytes from a
</span></span></span><span class="line"><span class="cl"><span class="c1">// string to a slice of bytes.) The source and destination may overlap. Copy
</span></span></span><span class="line"><span class="cl"><span class="c1">// returns the number of elements copied, which will be the minimum of
</span></span></span><span class="line"><span class="cl"><span class="c1">// len(src) and len(dst).
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nb">copy</span><span class="p">(</span><span class="nx">dst</span><span class="p">,</span> <span class="nx">src</span> <span class="p">[]</span><span class="nx">Type</span><span class="p">)</span> <span class="kt">int</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="slicecopy"><code>slicecopy()</code><a hidden class="anchor" aria-hidden="true" href="#slicecopy">#</a></h3>
<ol>
<li>slicecopy用于将pointerless元素的字符串或切片复制到切片中。</li>
<li>注意：<code>copy()</code>的函数原型中没有可变参数（<code>... T</code>）的形式参数。</li>
<li>slicecopy 适用以下两种情况：<code>fm -&gt; to</code>
<ul>
<li>【<strong><code>copy(to, fm []T) int</code></strong>】</li>
<li>【<strong><code>copy(to []byte, fm string) int</code></strong>】</li>
</ul>
</li>
<li>注意以下slicecopy函数可能在go1.18+版本中不是这样的，这一版采用的是go1.22左右版本的源码，但是只是发生了变化具体逻辑没变。</li>
<li>参数：<code>fromPtr -&gt; toPtr</code>
<ul>
<li><code>toPtr unsafe.Pointer</code>：目标地址，也就是上面的<code>to.array</code>值。</li>
<li><code>toLen int</code>：目标长度，也就是上面的<code>to.len</code>值。</li>
<li><code>fromPtr unsafe.Pointer</code>：来源地址，也就是上面的<code>fm.array</code>值。</li>
<li><code>fromLen int</code>：来源长度，也就是上面的<code>fm.len</code>值。</li>
<li><code>width uintptr</code>：切片类型占用内存大小，也就是<code>[]T</code>的<code>T</code>类型的大小。</li>
</ul>
</li>
<li>返回值：
<ul>
<li><code>int</code>：拷贝的元素数量。</li>
</ul>
</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// slicecopy is used to copy from a string or slice of pointerless elements into a slice.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">slicecopy</span><span class="p">(</span><span class="nx">toPtr</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">,</span> <span class="nx">toLen</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">fromPtr</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">,</span> <span class="nx">fromLen</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">width</span> <span class="kt">uintptr</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 1) 拷贝或被拷贝长度为0直接返回
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nx">fromLen</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="nx">toLen</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 2) 拷贝元素的个数取决于拷贝或被拷贝的最小长度
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">n</span> <span class="o">:=</span> <span class="nx">fromLen</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">toLen</span> <span class="p">&lt;</span> <span class="nx">n</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">n</span> <span class="p">=</span> <span class="nx">toLen</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 3) 拷贝的元素大小为0，直接返回n
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nx">width</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>	<span class="c1">// []struct{}
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">return</span> <span class="nx">n</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 4) size 需要拷贝的总内存大小/字节。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">size</span> <span class="o">:=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">n</span><span class="p">)</span> <span class="o">*</span> <span class="nx">width</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">raceenabled</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">callerpc</span> <span class="o">:=</span> <span class="nf">getcallerpc</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">        <span class="nx">pc</span> <span class="o">:=</span> <span class="nx">abi</span><span class="p">.</span><span class="nf">FuncPCABIInternal</span><span class="p">(</span><span class="nx">slicecopy</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="nf">racereadrangepc</span><span class="p">(</span><span class="nx">fromPtr</span><span class="p">,</span> <span class="nx">size</span><span class="p">,</span> <span class="nx">callerpc</span><span class="p">,</span> <span class="nx">pc</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="nf">racewriterangepc</span><span class="p">(</span><span class="nx">toPtr</span><span class="p">,</span> <span class="nx">size</span><span class="p">,</span> <span class="nx">callerpc</span><span class="p">,</span> <span class="nx">pc</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">msanenabled</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">msanread</span><span class="p">(</span><span class="nx">fromPtr</span><span class="p">,</span> <span class="nx">size</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="nf">msanwrite</span><span class="p">(</span><span class="nx">toPtr</span><span class="p">,</span> <span class="nx">size</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">asanenabled</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">asanread</span><span class="p">(</span><span class="nx">fromPtr</span><span class="p">,</span> <span class="nx">size</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="nf">asanwrite</span><span class="p">(</span><span class="nx">toPtr</span><span class="p">,</span> <span class="nx">size</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 一般情况下，这里的值大约是2x（只有1字节需要拷贝）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 	to := make([]byte, 1); copy(to, &#34;hello&#34;)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 【[]byte】 OR 【[]uint8】 OR 【[]int8】 OR 【[]bool】
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nx">size</span> <span class="o">==</span> <span class="mi">1</span> <span class="p">{</span> <span class="c1">// common case worth about 2x to do here
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// TODO: is this still worth it with new memmove impl?
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// TODO: 使用新的memmove impl，这仍然值得吗?
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 已知fromPtr和toPtr是 byte 指针
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="kt">byte</span><span class="p">)(</span><span class="nx">toPtr</span><span class="p">)</span> <span class="p">=</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="kt">byte</span><span class="p">)(</span><span class="nx">fromPtr</span><span class="p">)</span> <span class="c1">// known to be a byte pointer
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">memmove</span><span class="p">(</span><span class="nx">toPtr</span><span class="p">,</span> <span class="nx">fromPtr</span><span class="p">,</span> <span class="nx">size</span><span class="p">)</span>   <span class="c1">// 拷贝数据
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nx">n</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="memmove"><code>memmove()</code><a hidden class="anchor" aria-hidden="true" href="#memmove">#</a></h3>
<ol>
<li>memmove从<code>from</code>复制<code>n</code>个字节到<code>to</code>。</li>
<li>memmove确保任何位于<code>from</code>中的指针都以<strong>不可分割</strong>的写入方式写入到<code>to</code>中，因此，动态读取无法观察到一个只写了一半的指针。</li>
<li>这是必要的，以防止垃圾收集器发现无效指针，这与非托管语言中的memmove不同。</li>
<li>不过，只有当<code>from</code>和<code>to</code><strong>可能包含指针时</strong>，memmove()才需要这么做，只有当from、to和n都是 word-aligned时才会这样做。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// memmove copies n bytes from &#34;from&#34; to &#34;to&#34;.
</span></span></span><span class="line"><span class="cl"><span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1">// memmove ensures that any pointer in &#34;from&#34; is written to &#34;to&#34; with
</span></span></span><span class="line"><span class="cl"><span class="c1">// an indivisible write, so that racy reads cannot observe a
</span></span></span><span class="line"><span class="cl"><span class="c1">// half-written pointer. This is necessary to prevent the garbage
</span></span></span><span class="line"><span class="cl"><span class="c1">// collector from observing invalid pointers, and differs from memmove
</span></span></span><span class="line"><span class="cl"><span class="c1">// in unmanaged languages. However, memmove is only required to do
</span></span></span><span class="line"><span class="cl"><span class="c1">// this if &#34;from&#34; and &#34;to&#34; may contain pointers, which can only be the
</span></span></span><span class="line"><span class="cl"><span class="c1">// case if &#34;from&#34;, &#34;to&#34;, and &#34;n&#34; are all be word-aligned.
</span></span></span><span class="line"><span class="cl"><span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1">// Implementations are in memmove_*.s.
</span></span></span><span class="line"><span class="cl"><span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1">//go:noescape
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">memmove</span><span class="p">(</span><span class="nx">to</span><span class="p">,</span> <span class="nx">from</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">,</span> <span class="nx">n</span> <span class="kt">uintptr</span><span class="p">)</span>
</span></span></code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-asm" data-lang="asm"><span class="line"><span class="cl"><span class="nf">TEXT</span> <span class="no">runtime</span><span class="err">·</span><span class="no">memmove</span><span class="err">&lt;</span><span class="no">ABIInternal</span><span class="err">&gt;</span><span class="p">(</span><span class="no">SB</span><span class="p">),</span> <span class="no">NOSPLIT</span><span class="p">,</span> <span class="no">$0-24</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// AX = to
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// BX = from
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// CX = n
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">MOVQ</span>    <span class="no">AX</span><span class="p">,</span> <span class="no">DI</span>
</span></span><span class="line"><span class="cl">    <span class="nf">MOVQ</span>    <span class="no">BX</span><span class="p">,</span> <span class="no">SI</span>
</span></span><span class="line"><span class="cl">    <span class="nf">MOVQ</span>    <span class="no">CX</span><span class="p">,</span> <span class="no">BX</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl"><span class="nl">tail:</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// TEST指令用于对BX寄存器的内容和自身进行按位与操作，但是不改变寄存器的内容。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">TESTQ</span>   <span class="no">BX</span><span class="p">,</span> <span class="no">BX</span> <span class="c1"># 检查BX是否为0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 检查上一条指令（TEST）执行后是否设置了零标志（ZF）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">JEQ</span> <span class="no">move_0</span>  <span class="c1"># Jump if Equal
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 这是一个比较指令，用于比较BX寄存器中的值和立即数2。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 具体来说，它会将BX寄存器的值和2相减，但不改变任何寄存器的值，只是根据结果设置状态标志。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">CMPQ</span>    <span class="no">BX</span><span class="p">,</span> <span class="no">$2</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// BX &lt;= 2 成立
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">JBE</span> <span class="no">move_1or2</span> <span class="c1"># Jump if Below or Equal
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">CMPQ</span>    <span class="no">BX</span><span class="p">,</span> <span class="no">$4</span> <span class="c1"># &lt;= 4
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">JB</span>  <span class="no">move_3</span>
</span></span><span class="line"><span class="cl">    <span class="nf">JBE</span> <span class="no">move_4</span>
</span></span><span class="line"><span class="cl">    <span class="nf">CMPQ</span>    <span class="no">BX</span><span class="p">,</span> <span class="no">$8</span> <span class="c1"># &lt;= 8
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">JB</span>  <span class="no">move_5through7</span>
</span></span><span class="line"><span class="cl">    <span class="nf">JE</span>  <span class="no">move_8</span>
</span></span><span class="line"><span class="cl">    <span class="nf">CMPQ</span>    <span class="no">BX</span><span class="p">,</span> <span class="no">$16</span>
</span></span><span class="line"><span class="cl">    <span class="nf">JBE</span> <span class="no">move_9through16</span>
</span></span><span class="line"><span class="cl">    <span class="nf">CMPQ</span>    <span class="no">BX</span><span class="p">,</span> <span class="no">$32</span>
</span></span><span class="line"><span class="cl">    <span class="nf">JBE</span> <span class="no">move_17through32</span>
</span></span><span class="line"><span class="cl">    <span class="nf">CMPQ</span>    <span class="no">BX</span><span class="p">,</span> <span class="no">$64</span>
</span></span><span class="line"><span class="cl">    <span class="nf">JBE</span> <span class="no">move_33through64</span>
</span></span><span class="line"><span class="cl">    <span class="nf">CMPQ</span>    <span class="no">BX</span><span class="p">,</span> <span class="no">$128</span>
</span></span><span class="line"><span class="cl">    <span class="nf">JBE</span> <span class="no">move_65through128</span>
</span></span><span class="line"><span class="cl">    <span class="nf">CMPQ</span>    <span class="no">BX</span><span class="p">,</span> <span class="no">$256</span>
</span></span><span class="line"><span class="cl">    <span class="nf">JBE</span> <span class="no">move_129through256</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nf">TESTB</span>   <span class="no">$1</span><span class="p">,</span> <span class="no">runtime</span><span class="err">·</span><span class="no">useAVXmemmove</span><span class="p">(</span><span class="no">SB</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nf">JNZ</span> <span class="no">avxUnaligned</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c1">//... ...
</span></span></span></code></pre></td></tr></table>
</div>
</div><h2 id="append"><code>append()</code><a hidden class="anchor" aria-hidden="true" href="#append">#</a></h2>
<ol>
<li>内置函数<code>append()</code>将元素添加到切片的末尾。</li>
<li>如果它有足够的容量，目的地将被重新划分以容纳新的元素。如果没有，将分配一个新的底层数组。</li>
<li>注意：<code>append()</code>函数存在可变参数（<code>... T</code>）的形式的参数。</li>
<li><code>append()</code>返回更新后的<code>slice</code>。因此，有必要将<code>append()</code>的结果存储在保存切片本身的变量中：
<ul>
<li>【<strong><code>slice = append(slice, elem1, elem2)</code></strong>】</li>
<li>【<strong><code>slice = append(slice, anotherSlice...)</code></strong>】</li>
</ul>
</li>
<li>作为一种特殊情况，可以将字符串添加到字节切片中，如下所示：
<ul>
<li>【<strong><code>slice = append([]byte(&quot;hello &quot;), &quot;world&quot;...)</code></strong>】</li>
</ul>
</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// The append built-in function appends elements to the end of a slice. If
</span></span></span><span class="line"><span class="cl"><span class="c1">// it has sufficient capacity, the destination is resliced to accommodate the
</span></span></span><span class="line"><span class="cl"><span class="c1">// new elements. If it does not, a new underlying array will be allocated.
</span></span></span><span class="line"><span class="cl"><span class="c1">// Append returns the updated slice. It is therefore necessary to store the
</span></span></span><span class="line"><span class="cl"><span class="c1">// result of append, often in the variable holding the slice itself:
</span></span></span><span class="line"><span class="cl"><span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1">//	slice = append(slice, elem1, elem2)
</span></span></span><span class="line"><span class="cl"><span class="c1">//	slice = append(slice, anotherSlice...)
</span></span></span><span class="line"><span class="cl"><span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1">// As a special case, it is legal to append a string to a byte slice, like this:
</span></span></span><span class="line"><span class="cl"><span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1">//	slice = append([]byte(&#34;hello &#34;), &#34;world&#34;...)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nb">append</span><span class="p">(</span><span class="nx">slice</span> <span class="p">[]</span><span class="nx">Type</span><span class="p">,</span> <span class="nx">elems</span> <span class="o">...</span><span class="nx">Type</span><span class="p">)</span> <span class="p">[]</span><span class="nx">Type</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ol start="6">
<li>append 执行步骤：
<ul>
<li>如果当前<code>append()</code>函数执行完后切片<strong>不会</strong>&ldquo;翻倍扩容&quot;那么，直接是把<code>append()</code>后追加的数据拷贝到切片的后续空间即可。</li>
<li>如果当前<code>append()</code>函数执行完后<strong>需要</strong>&ldquo;翻倍扩容&rdquo;，那么先调用<code>runtime.growslice()</code>扩容函数，然后在拷贝数据追加到新的内存空间。</li>
</ul>
</li>
</ol>
<h3 id="growslice"><code>growslice()</code><a hidden class="anchor" aria-hidden="true" href="#growslice">#</a></h3>
<ol>
<li><code>growslice()</code>在<code>append()</code>函数期间处理切片增长。</li>
<li>它将<code>slice</code>元素类型、旧的<code>slice</code>和所需的新最小容量传递给它，然后返回一个至少具有该容量的新<code>slice</code>，并将旧数据复制到其中。</li>
<li>新slice的长度被设置为旧<code>slice</code>的长度，而不是新请求的容量。</li>
<li>这是为了方便codegen。旧片的长度立即用于计算在追加期间在何处写入新值。</li>
<li>TODO：当旧的后端消失时，重新考虑这个决定。</li>
<li>SSA后端可能更喜欢新的长度，或者只返回ptr/cap以节省栈空间。</li>
<li>参数：
<ul>
<li><code>et *_type</code>：切片元素的元类型。</li>
<li><code>old slice</code>：未翻倍扩容前切片。</li>
<li><code>cap int</code>：<code>append()</code>函数后需要的长度 <code>old.len + n = cap</code>。也就是<code>append(s S, x ...T) S</code>函数中<code>len(S) + len(x) = cap</code>后的长度。</li>
</ul>
</li>
<li>返回值：<code>slice</code>
<ul>
<li><code>slice.data</code>：新申请的地址。</li>
<li><code>slice.len</code>：<code>old.len</code>的值。注意这里是旧切片的长度。</li>
<li><code>slice.cap</code>：扩容后的容量。</li>
</ul>
</li>
<li>该函数在<code>append()</code>函数调用时根据条件触发。如<code>old = append(old, 1, 2, 1)</code>, <code>len(old) + 3 &gt; cap(old)</code>时就需要扩容了。</li>
<li>注意，关于slice的扩容规则在go1.18前是根据len的一套规则，而在以后版本又是根据cap的一套规则，本篇采用的是go1.22左右版本的。</li>
</ol>
<p><img loading="lazy" src="../images/slice-002.png" alt=""  />
</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span><span class="lnt">113
</span><span class="lnt">114
</span><span class="lnt">115
</span><span class="lnt">116
</span><span class="lnt">117
</span><span class="lnt">118
</span><span class="lnt">119
</span><span class="lnt">120
</span><span class="lnt">121
</span><span class="lnt">122
</span><span class="lnt">123
</span><span class="lnt">124
</span><span class="lnt">125
</span><span class="lnt">126
</span><span class="lnt">127
</span><span class="lnt">128
</span><span class="lnt">129
</span><span class="lnt">130
</span><span class="lnt">131
</span><span class="lnt">132
</span><span class="lnt">133
</span><span class="lnt">134
</span><span class="lnt">135
</span><span class="lnt">136
</span><span class="lnt">137
</span><span class="lnt">138
</span><span class="lnt">139
</span><span class="lnt">140
</span><span class="lnt">141
</span><span class="lnt">142
</span><span class="lnt">143
</span><span class="lnt">144
</span><span class="lnt">145
</span><span class="lnt">146
</span><span class="lnt">147
</span><span class="lnt">148
</span><span class="lnt">149
</span><span class="lnt">150
</span><span class="lnt">151
</span><span class="lnt">152
</span><span class="lnt">153
</span><span class="lnt">154
</span><span class="lnt">155
</span><span class="lnt">156
</span><span class="lnt">157
</span><span class="lnt">158
</span><span class="lnt">159
</span><span class="lnt">160
</span><span class="lnt">161
</span><span class="lnt">162
</span><span class="lnt">163
</span><span class="lnt">164
</span><span class="lnt">165
</span><span class="lnt">166
</span><span class="lnt">167
</span><span class="lnt">168
</span><span class="lnt">169
</span><span class="lnt">170
</span><span class="lnt">171
</span><span class="lnt">172
</span><span class="lnt">173
</span><span class="lnt">174
</span><span class="lnt">175
</span><span class="lnt">176
</span><span class="lnt">177
</span><span class="lnt">178
</span><span class="lnt">179
</span><span class="lnt">180
</span><span class="lnt">181
</span><span class="lnt">182
</span><span class="lnt">183
</span><span class="lnt">184
</span><span class="lnt">185
</span><span class="lnt">186
</span><span class="lnt">187
</span><span class="lnt">188
</span><span class="lnt">189
</span><span class="lnt">190
</span><span class="lnt">191
</span><span class="lnt">192
</span><span class="lnt">193
</span><span class="lnt">194
</span><span class="lnt">195
</span><span class="lnt">196
</span><span class="lnt">197
</span><span class="lnt">198
</span><span class="lnt">199
</span><span class="lnt">200
</span><span class="lnt">201
</span><span class="lnt">202
</span><span class="lnt">203
</span><span class="lnt">204
</span><span class="lnt">205
</span><span class="lnt">206
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// growslice handles slice growth during append.
</span></span></span><span class="line"><span class="cl"><span class="c1">// It is passed the slice element type, the old slice, and the desired new minimum capacity,
</span></span></span><span class="line"><span class="cl"><span class="c1">// and it returns a new slice with at least that capacity, with the old data
</span></span></span><span class="line"><span class="cl"><span class="c1">// copied into it.
</span></span></span><span class="line"><span class="cl"><span class="c1">// The new slice&#39;s length is set to the old slice&#39;s length,
</span></span></span><span class="line"><span class="cl"><span class="c1">// NOT to the new requested capacity.
</span></span></span><span class="line"><span class="cl"><span class="c1">// This is for codegen convenience. The old slice&#39;s length is used immediately
</span></span></span><span class="line"><span class="cl"><span class="c1">// to calculate where to write new values during an append.
</span></span></span><span class="line"><span class="cl"><span class="c1">// TODO: When the old backend is gone, reconsider this decision.
</span></span></span><span class="line"><span class="cl"><span class="c1">// The SSA backend might prefer the new length or to return only ptr/cap and save stack space.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">growslice</span><span class="p">(</span><span class="nx">et</span> <span class="o">*</span><span class="nx">_type</span><span class="p">,</span> <span class="nx">old</span> <span class="nx">slice</span><span class="p">,</span> <span class="nx">cap</span> <span class="kt">int</span><span class="p">)</span> <span class="nx">slice</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">raceenabled</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">callerpc</span> <span class="o">:=</span> <span class="nf">getcallerpc</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">        <span class="nf">racereadrangepc</span><span class="p">(</span><span class="nx">old</span><span class="p">.</span><span class="nx">array</span><span class="p">,</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">old</span><span class="p">.</span><span class="nx">len</span><span class="o">*</span><span class="nb">int</span><span class="p">(</span><span class="nx">et</span><span class="p">.</span><span class="nx">size</span><span class="p">)),</span> <span class="nx">callerpc</span><span class="p">,</span> <span class="nx">abi</span><span class="p">.</span><span class="nf">FuncPCABIInternal</span><span class="p">(</span><span class="nx">growslice</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">msanenabled</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">msanread</span><span class="p">(</span><span class="nx">old</span><span class="p">.</span><span class="nx">array</span><span class="p">,</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">old</span><span class="p">.</span><span class="nx">len</span><span class="o">*</span><span class="nb">int</span><span class="p">(</span><span class="nx">et</span><span class="p">.</span><span class="nx">size</span><span class="p">)))</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">asanenabled</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">asanread</span><span class="p">(</span><span class="nx">old</span><span class="p">.</span><span class="nx">array</span><span class="p">,</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">old</span><span class="p">.</span><span class="nx">len</span><span class="o">*</span><span class="nb">int</span><span class="p">(</span><span class="nx">et</span><span class="p">.</span><span class="nx">size</span><span class="p">)))</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 1) 切片长度溢出判断
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nx">cap</span> <span class="p">&lt;</span> <span class="nx">old</span><span class="p">.</span><span class="nx">cap</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nb">panic</span><span class="p">(</span><span class="nf">errorString</span><span class="p">(</span><span class="s">&#34;growslice: cap out of range&#34;</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 2) 切片元素类型 占用内存为零 情况
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 这种情况出现在：
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//      var s []struct{}
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//      s = append(s, struct{}{}, struct{}{})
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nx">et</span><span class="p">.</span><span class="nx">size</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// append should not create a slice with nil pointer but non-zero len.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// We assume that append doesn&#39;t need to preserve old.array in this case.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// Append不应该创建一个指针为nil的切片，而是一个len为non-zero的切片。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 在这种情况下，我们假设append不需要保存old.array。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 赋值slice.array指定地址，为了确保slice不是nil
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// slice为nil的判断条件是，只要slice.array==0x00,不管len和cap的值为多少都为nil
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">return</span> <span class="nx">slice</span><span class="p">{</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">zerobase</span><span class="p">),</span> <span class="nx">old</span><span class="p">.</span><span class="nx">len</span><span class="p">,</span> <span class="nx">cap</span><span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 3) 评估扩容后的容量
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// ---+-------+-----------------------------------------------------------------------------------
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 预 |   if  | oldCap * 2 &lt; cap ------&gt; newCap = cap               使用cap值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 估 |-------+-----------------------------------------------------------------------------------
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 规 |  else | oldCap &lt; 256     ------&gt; newCap = oldCap * 2        翻倍扩容
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 则 |       | oldCap &gt;= 256    ------&gt; newCap = oldCap * 5/4 + 256 * 3/4 在原容量上扩容1/4在扩容192
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// ---+-------+-----------------------------------------------------------------------------------
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">newcap</span> <span class="o">:=</span> <span class="nx">old</span><span class="p">.</span><span class="nx">cap</span>
</span></span><span class="line"><span class="cl">    <span class="nx">doublecap</span> <span class="o">:=</span> <span class="nx">newcap</span> <span class="o">+</span> <span class="nx">newcap</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">cap</span> <span class="p">&gt;</span> <span class="nx">doublecap</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 2倍旧容量 &lt; cap时，则按照cap算。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">newcap</span> <span class="p">=</span> <span class="nx">cap</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="kd">const</span> <span class="nx">threshold</span> <span class="p">=</span> <span class="mi">256</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="nx">old</span><span class="p">.</span><span class="nx">cap</span> <span class="p">&lt;</span> <span class="nx">threshold</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nx">newcap</span> <span class="p">=</span> <span class="nx">doublecap</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// Check 0 &lt; newcap to detect overflow
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// and prevent an infinite loop.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// 检查 0 &lt; newcap 以检测溢出并防止无限循环。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="k">for</span> <span class="mi">0</span> <span class="p">&lt;</span> <span class="nx">newcap</span> <span class="o">&amp;&amp;</span> <span class="nx">newcap</span> <span class="p">&lt;</span> <span class="nx">cap</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="c1">// Transition from growing 2x for small slices
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="c1">// to growing 1.25x for large slices. This formula
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="c1">// gives a smooth-ish transition between the two.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="nx">newcap</span> <span class="o">+=</span> <span class="p">(</span><span class="nx">newcap</span> <span class="o">+</span> <span class="mi">3</span><span class="o">*</span><span class="nx">threshold</span><span class="p">)</span> <span class="o">/</span> <span class="mi">4</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// Set newcap to the requested cap when
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// the newcap calculation overflowed.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="k">if</span> <span class="nx">newcap</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="nx">newcap</span> <span class="p">=</span> <span class="nx">cap</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 4) 内存规格匹配
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    
</span></span><span class="line"><span class="cl">    <span class="c1">// 内存是否溢出 true.溢出 false.没有溢出
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kd">var</span> <span class="nx">overflow</span> <span class="kt">bool</span>	
</span></span><span class="line"><span class="cl">    <span class="c1">// lenmem 旧切片元素占用的内存大小
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//      该值用于迁移旧数据的依据/字节
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// newlenmem 翻倍后切片元素占用的内存大小
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//      该值是当前扩容后实际占用的大小/字节
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//      因此capmem-newlenmem这部分内存是多余的，不会被用到。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// capmem 翻倍后新容量占用的内存大小，
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//      用于向操作系统申请的内存大小/字节
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//      这部分内存可能大于newlenmem的值，因为Go的内存申请是有规格的。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kd">var</span> <span class="nx">lenmem</span><span class="p">,</span> <span class="nx">newlenmem</span><span class="p">,</span> <span class="nx">capmem</span> <span class="kt">uintptr</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Specialize for common values of et.size.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// For 1 we don&#39;t need any division/multiplication.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// For goarch.PtrSize, compiler will optimize division/multiplication into a shift by a constant.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// For powers of 2, use a variable shift.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 专门用于 et.size 的共同值。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 对于1，我们不需要任何除法/乘法
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 对于 goarch.PtrSize，编译器将除法/乘法 优化为一个常量的位移
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 对于2的幂次方，使用可变位移
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">switch</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 倘若数组元素的大小为 1，则新容量大小为 1 * newcap.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 同时会针对 span class 进行取整
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">case</span> <span class="nx">et</span><span class="p">.</span><span class="nx">size</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>  <span class="c1">// 1字节
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">lenmem</span> <span class="p">=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">old</span><span class="p">.</span><span class="nx">len</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="nx">newlenmem</span> <span class="p">=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">cap</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="nx">capmem</span> <span class="p">=</span> <span class="nf">roundupsize</span><span class="p">(</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">newcap</span><span class="p">))</span>   <span class="c1">// 匹配最近接的内存块规格
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">overflow</span> <span class="p">=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">newcap</span><span class="p">)</span> <span class="p">&gt;</span> <span class="nx">maxAlloc</span>   <span class="c1">// 是否内存溢出
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">newcap</span> <span class="p">=</span> <span class="nb">int</span><span class="p">(</span><span class="nx">capmem</span><span class="p">)</span>                    <span class="c1">// 从新调整翻倍后新容量
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 倘若数组元素为指针类型，则根据指针占用空间结合元素个数计算空间大小
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 并会针对 span class 进行取整
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">case</span> <span class="nx">et</span><span class="p">.</span><span class="nx">size</span> <span class="o">==</span> <span class="nx">goarch</span><span class="p">.</span><span class="nx">PtrSize</span><span class="p">:</span> <span class="c1">// 4或8字节
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">lenmem</span> <span class="p">=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">old</span><span class="p">.</span><span class="nx">len</span><span class="p">)</span> <span class="o">*</span> <span class="nx">goarch</span><span class="p">.</span><span class="nx">PtrSize</span>
</span></span><span class="line"><span class="cl">        <span class="nx">newlenmem</span> <span class="p">=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">cap</span><span class="p">)</span> <span class="o">*</span> <span class="nx">goarch</span><span class="p">.</span><span class="nx">PtrSize</span>
</span></span><span class="line"><span class="cl">        <span class="nx">capmem</span> <span class="p">=</span> <span class="nf">roundupsize</span><span class="p">(</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">newcap</span><span class="p">)</span> <span class="o">*</span> <span class="nx">goarch</span><span class="p">.</span><span class="nx">PtrSize</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="nx">overflow</span> <span class="p">=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">newcap</span><span class="p">)</span> <span class="p">&gt;</span> <span class="nx">maxAlloc</span><span class="o">/</span><span class="nx">goarch</span><span class="p">.</span><span class="nx">PtrSize</span>
</span></span><span class="line"><span class="cl">        <span class="nx">newcap</span> <span class="p">=</span> <span class="nb">int</span><span class="p">(</span><span class="nx">capmem</span> <span class="o">/</span> <span class="nx">goarch</span><span class="p">.</span><span class="nx">PtrSize</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 倘若元素大小为 2 的指数，则直接通过位运算进行空间大小的计算  
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">case</span> <span class="nf">isPowerOfTwo</span><span class="p">(</span><span class="nx">et</span><span class="p">.</span><span class="nx">size</span><span class="p">):</span> <span class="c1">// 2的幂次方
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="kd">var</span> <span class="nx">shift</span> <span class="kt">uintptr</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="nx">goarch</span><span class="p">.</span><span class="nx">PtrSize</span> <span class="o">==</span> <span class="mi">8</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// Mask shift for better code generation.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// 掩码移位以更好地生成代码。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// sys.Ctz64函数计数尾部(低阶)零，如果全部为零，则为64。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// 比如 et.size 是2^8也就是 1_0000_0000，也就是8个零
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="nx">shift</span> <span class="p">=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">sys</span><span class="p">.</span><span class="nf">Ctz64</span><span class="p">(</span><span class="nb">uint64</span><span class="p">(</span><span class="nx">et</span><span class="p">.</span><span class="nx">size</span><span class="p">)))</span> <span class="o">&amp;</span> <span class="mi">63</span>    <span class="c1">// 64位
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nx">shift</span> <span class="p">=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">sys</span><span class="p">.</span><span class="nf">Ctz32</span><span class="p">(</span><span class="nb">uint32</span><span class="p">(</span><span class="nx">et</span><span class="p">.</span><span class="nx">size</span><span class="p">)))</span> <span class="o">&amp;</span> <span class="mi">31</span>    <span class="c1">// 32位
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="nx">lenmem</span> <span class="p">=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">old</span><span class="p">.</span><span class="nx">len</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="nx">shift</span>
</span></span><span class="line"><span class="cl">        <span class="nx">newlenmem</span> <span class="p">=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">cap</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="nx">shift</span>
</span></span><span class="line"><span class="cl">        <span class="nx">capmem</span> <span class="p">=</span> <span class="nf">roundupsize</span><span class="p">(</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">newcap</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="nx">shift</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="nx">overflow</span> <span class="p">=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">newcap</span><span class="p">)</span> <span class="p">&gt;</span> <span class="p">(</span><span class="nx">maxAlloc</span> <span class="o">&gt;&gt;</span> <span class="nx">shift</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="nx">newcap</span> <span class="p">=</span> <span class="nb">int</span><span class="p">(</span><span class="nx">capmem</span> <span class="o">&gt;&gt;</span> <span class="nx">shift</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 兜底分支：根据元素大小乘以元素个数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 再针对 span class 进行取整     
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">default</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="nx">lenmem</span> <span class="p">=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">old</span><span class="p">.</span><span class="nx">len</span><span class="p">)</span> <span class="o">*</span> <span class="nx">et</span><span class="p">.</span><span class="nx">size</span>
</span></span><span class="line"><span class="cl">        <span class="nx">newlenmem</span> <span class="p">=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">cap</span><span class="p">)</span> <span class="o">*</span> <span class="nx">et</span><span class="p">.</span><span class="nx">size</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// math.MulUintptr 返回 capmem = et.size * uintptr(newcap); overflow 是否溢出
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">capmem</span><span class="p">,</span> <span class="nx">overflow</span> <span class="p">=</span> <span class="nx">math</span><span class="p">.</span><span class="nf">MulUintptr</span><span class="p">(</span><span class="nx">et</span><span class="p">.</span><span class="nx">size</span><span class="p">,</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">newcap</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">        <span class="nx">capmem</span> <span class="p">=</span> <span class="nf">roundupsize</span><span class="p">(</span><span class="nx">capmem</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="nx">newcap</span> <span class="p">=</span> <span class="nb">int</span><span class="p">(</span><span class="nx">capmem</span> <span class="o">/</span> <span class="nx">et</span><span class="p">.</span><span class="nx">size</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 以上代码因为会去匹配内存规格，所以会从新计算newcap这个翻倍后的值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="c1">// The check of overflow in addition to capmem &gt; maxAlloc is needed
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// to prevent an overflow which can be used to trigger a segfault
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// on 32bit architectures with this example program:
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 除了capmem &gt; maxAlloc之外，还需要检查溢出，以防止溢出，
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 该溢出可用于在32位体系结构上触发段故障，示例程序如下:
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// type T [1&lt;&lt;27 + 1]int64
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// var d T
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// var s []T
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// func main() {
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//   s = append(s, d, d, d, d)	
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//   print(len(s), &#34;\n&#34;)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// }
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 4*(1&lt;&lt;27 + 1)*8
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nx">overflow</span> <span class="o">||</span> <span class="nx">capmem</span> <span class="p">&gt;</span> <span class="nx">maxAlloc</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nb">panic</span><span class="p">(</span><span class="nf">errorString</span><span class="p">(</span><span class="s">&#34;growslice: cap out of range&#34;</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 申请到的内存首地址
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kd">var</span> <span class="nx">p</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">et</span><span class="p">.</span><span class="nx">ptrdata</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span> <span class="c1">// 切片元素类型不包含指针
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// capmem 申请的内存; nil 类型元类型用于判断是否为指针类型; false 是否重置内存为零值;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">p</span> <span class="p">=</span> <span class="nf">mallocgc</span><span class="p">(</span><span class="nx">capmem</span><span class="p">,</span> <span class="kc">nil</span><span class="p">,</span> <span class="kc">false</span><span class="p">)</span> <span class="c1">// 向操作系统申请内存块
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// The append() that calls growslice is going to overwrite from 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// old.len to cap (which will be the new length).
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// Only clear the part that will not be overwritten.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 调用 growslice 的 append() 方法会将 old.len 覆盖到 cap(这将是新的长度)。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 只清除不会被覆盖的部分。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 清零capmem-newlenmem这块内存，这快内存是多余的，不会被用到。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nf">memclrNoHeapPointers</span><span class="p">(</span><span class="nf">add</span><span class="p">(</span><span class="nx">p</span><span class="p">,</span> <span class="nx">newlenmem</span><span class="p">),</span> <span class="nx">capmem</span><span class="o">-</span><span class="nx">newlenmem</span><span class="p">)</span>	
</span></span><span class="line"><span class="cl">    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span> <span class="c1">// 切片元素类型包含指针
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// Note: can&#39;t use rawmem (which avoids zeroing of memory), 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// because then GC can scan uninitialized memory.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// Note: 不能使用rawmem(它可以避免内存归零)，因为这样GC会扫描未初始化的内存。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">p</span> <span class="p">=</span> <span class="nf">mallocgc</span><span class="p">(</span><span class="nx">capmem</span><span class="p">,</span> <span class="nx">et</span><span class="p">,</span> <span class="kc">true</span><span class="p">)</span> <span class="c1">// 向操作系统申请内存块
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="nx">lenmem</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">writeBarrier</span><span class="p">.</span><span class="nx">enabled</span> <span class="p">{</span> <span class="c1">// 开启了写屏障
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// Only shade the pointers in old.array since we know the destination slice p
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// only contains nil pointers because it has been cleared during alloc.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// 在 old.array 中只对指针进行 shade 处理，因为我们知道目标切片 p 只包含nil指针，
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// 因为它在alloc期间已被清除。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// lenmem-et.size+et.ptrdata 刚好是old.array存在的都是指针
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">//      -et.size：减去最后一个元素的内存
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">//      +et.ptrdata：再加上最后一个元素的指针
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// 刚好处理完最后一个元素后面不是指针的部分内存。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// [dst, dst+size]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="nf">bulkBarrierPreWriteSrcOnly</span><span class="p">(</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">p</span><span class="p">),</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">old</span><span class="p">.</span><span class="nx">array</span><span class="p">),</span> <span class="nx">lenmem</span><span class="o">-</span><span class="nx">et</span><span class="p">.</span><span class="nx">size</span><span class="o">+</span><span class="nx">et</span><span class="p">.</span><span class="nx">ptrdata</span><span class="p">)</span>	
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 从old.array中迁移lenmem大小内存数据到p中
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">memmove</span><span class="p">(</span><span class="nx">p</span><span class="p">,</span> <span class="nx">old</span><span class="p">.</span><span class="nx">array</span><span class="p">,</span> <span class="nx">lenmem</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 注意：这里返回的是 old.len，因为此时还是之前的旧数据
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">return</span> <span class="nx">slice</span><span class="p">{</span><span class="nx">p</span><span class="p">,</span> <span class="nx">old</span><span class="p">.</span><span class="nx">len</span><span class="p">,</span> <span class="nx">newcap</span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// bulkBarrierPreWriteSrcOnly is like bulkBarrierPreWrite but
</span></span></span><span class="line"><span class="cl"><span class="c1">// does not execute write barriers for [dst, dst+size).
</span></span></span><span class="line"><span class="cl"><span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1">// In addition to the requirements of bulkBarrierPreWrite
</span></span></span><span class="line"><span class="cl"><span class="c1">// callers need to ensure [dst, dst+size) is zeroed.
</span></span></span><span class="line"><span class="cl"><span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1">// This is used for special cases where e.g. dst was just
</span></span></span><span class="line"><span class="cl"><span class="c1">// created and zeroed with malloc.
</span></span></span><span class="line"><span class="cl"><span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1">// The type of the space can be provided purely as an optimization,
</span></span></span><span class="line"><span class="cl"><span class="c1">// however it is not used with GOEXPERIMENT=noallocheaders.
</span></span></span><span class="line"><span class="cl"><span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1">//go:nosplit
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">bulkBarrierPreWriteSrcOnly</span><span class="p">(</span><span class="nx">dst</span><span class="p">,</span> <span class="nx">src</span><span class="p">,</span> <span class="nx">size</span> <span class="kt">uintptr</span><span class="p">,</span> <span class="nx">_</span> <span class="o">*</span><span class="nx">abi</span><span class="p">.</span><span class="nx">Type</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// GC并发标记阶段，这里需要处理混合写屏障相关事项，因为在拷贝指针数据
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="nx">dst</span><span class="p">|</span><span class="nx">src</span><span class="p">|</span><span class="nx">size</span><span class="p">)</span><span class="o">&amp;</span><span class="p">(</span><span class="nx">goarch</span><span class="p">.</span><span class="nx">PtrSize</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">throw</span><span class="p">(</span><span class="s">&#34;bulkBarrierPreWrite: unaligned arguments&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">!</span><span class="nx">writeBarrier</span><span class="p">.</span><span class="nx">enabled</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="c1">// 并发标记已结束
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nx">buf</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nf">getg</span><span class="p">().</span><span class="nx">m</span><span class="p">.</span><span class="nx">p</span><span class="p">.</span><span class="nf">ptr</span><span class="p">().</span><span class="nx">wbBuf</span> <span class="c1">// 写屏障缓冲区
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">h</span> <span class="o">:=</span> <span class="nf">heapBitsForAddr</span><span class="p">(</span><span class="nx">dst</span><span class="p">,</span> <span class="nx">size</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="kd">var</span> <span class="nx">addr</span> <span class="kt">uintptr</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="nx">h</span><span class="p">,</span> <span class="nx">addr</span> <span class="p">=</span> <span class="nx">h</span><span class="p">.</span><span class="nf">next</span><span class="p">();</span> <span class="nx">addr</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">break</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="nx">srcx</span> <span class="o">:=</span> <span class="p">(</span><span class="o">*</span><span class="kt">uintptr</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">addr</span> <span class="o">-</span> <span class="nx">dst</span> <span class="o">+</span> <span class="nx">src</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">        <span class="nx">p</span> <span class="o">:=</span> <span class="nx">buf</span><span class="p">.</span><span class="nf">get1</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">        <span class="nx">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">=</span> <span class="o">*</span><span class="nx">srcx</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>所有0字节分配的基地址。</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// base address for all 0-byte allocations
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">var</span> <span class="nx">zerobase</span> <span class="kt">uintptr</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="roundupsize"><code>roundupsize()</code><a hidden class="anchor" aria-hidden="true" href="#roundupsize">#</a></h3>
<ol>
<li>mallocgc返回将分配的内存块的大小，如果您要求该大小。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// Returns size of the memory block that mallocgc will allocate if you ask for the size.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">roundupsize</span><span class="p">(</span><span class="nx">size</span> <span class="kt">uintptr</span><span class="p">)</span> <span class="kt">uintptr</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// _MaxSmallSize = 32768
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nx">size</span> <span class="p">&lt;</span> <span class="nx">_MaxSmallSize</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// smallSizeMax = 1024
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="nx">size</span> <span class="o">&lt;=</span> <span class="nx">smallSizeMax</span><span class="o">-</span><span class="mi">8</span> <span class="p">{</span> <span class="c1">// 以最下8B倍数对齐
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// smallSizeDiv = 8，divRoundUp 等价于 ceil(size/8)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// size_to_class8和class_to_size 记录着 size 的映射关系
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="k">return</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">class_to_size</span><span class="p">[</span><span class="nx">size_to_class8</span><span class="p">[</span><span class="nf">divRoundUp</span><span class="p">(</span><span class="nx">size</span><span class="p">,</span> <span class="nx">smallSizeDiv</span><span class="p">)]])</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>    <span class="c1">// 以最小128B倍数对齐
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// largeSizeDiv = 128
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="k">return</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">class_to_size</span><span class="p">[</span><span class="nx">size_to_class128</span><span class="p">[</span><span class="nf">divRoundUp</span><span class="p">(</span><span class="nx">size</span><span class="o">-</span><span class="nx">smallSizeMax</span><span class="p">,</span> <span class="nx">largeSizeDiv</span><span class="p">)]])</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// _PageSize = 8192
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nx">size</span><span class="o">+</span><span class="nx">_PageSize</span> <span class="p">&lt;</span> <span class="nx">size</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="nx">size</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nf">alignUp</span><span class="p">(</span><span class="nx">size</span><span class="p">,</span> <span class="nx">_PageSize</span><span class="p">)</span> <span class="c1">// 对齐8KB
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="alignup"><code>alignUp()</code><a hidden class="anchor" aria-hidden="true" href="#alignup">#</a></h3>
<ol>
<li>alignUp将n取整为a的倍数。a必须是2的幂。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// alignUp rounds n up to a multiple of a. a must be a power of 2.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">alignUp</span><span class="p">(</span><span class="nx">n</span><span class="p">,</span> <span class="nx">a</span> <span class="kt">uintptr</span><span class="p">)</span> <span class="kt">uintptr</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="p">(</span><span class="nx">n</span> <span class="o">+</span> <span class="nx">a</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;^</span> <span class="p">(</span><span class="nx">a</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="muluintptr"><code>MulUintptr()</code><a hidden class="anchor" aria-hidden="true" href="#muluintptr">#</a></h3>
<ol>
<li><code>MulUintptr</code>返回<code>a * b</code>以及乘法运算是否溢出。</li>
<li>在受支持的平台上，这是由编译器降低的固有特性。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// MulUintptr returns a * b and whether the multiplication overflowed.
</span></span></span><span class="line"><span class="cl"><span class="c1">// On supported platforms this is an intrinsic lowered by the compiler.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">MulUintptr</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span> <span class="kt">uintptr</span><span class="p">)</span> <span class="p">(</span><span class="kt">uintptr</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// a|b &lt; 1&lt;&lt;16 || a|b &lt; 1&lt;&lt;32
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nx">a</span><span class="p">|</span><span class="nx">b</span> <span class="p">&lt;</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="mi">4</span><span class="o">*</span><span class="nx">goarch</span><span class="p">.</span><span class="nx">PtrSize</span><span class="p">)</span> <span class="o">||</span> <span class="nx">a</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="nx">a</span> <span class="o">*</span> <span class="nx">b</span><span class="p">,</span> <span class="kc">false</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// const MaxUintptr = ^uintptr(0)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">overflow</span> <span class="o">:=</span> <span class="nx">b</span> <span class="p">&gt;</span> <span class="nx">MaxUintptr</span><span class="o">/</span><span class="nx">a</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nx">a</span> <span class="o">*</span> <span class="nx">b</span><span class="p">,</span> <span class="nx">overflow</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div>

  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://heliu.site/tags/golang/">Golang</a></li>
      <li><a href="https://heliu.site/tags/%E5%88%87%E7%89%87/">切片</a></li>
    </ul>
<nav class="paginav">
  <a class="prev" href="https://heliu.site/posts/golang/slice/use/">
    <span class="title">« 上一页</span>
    <br>
    <span>Slice(使用)</span>
  </a>
  <a class="next" href="https://heliu.site/posts/golang/slice/check/">
    <span class="title">下一页 »</span>
    <br>
    <span>边界检查</span>
  </a>
</nav>

  </footer>
</article>
    </main>
    
<footer class="footer">
    
    <div class="busuanzi-footer">
    <span id="busuanzi_container_site_pv">
        本站总访问量<span id="busuanzi_value_site_pv"></span>次
    </span>
    <span id="busuanzi_container_site_uv">
        本站访客数<span id="busuanzi_value_site_uv"></span>人次
    </span>
    </div>
        <span>Copyright © 2020-2024 <a href="#">heliu's blog</a>. All rights reserved</span>  
    
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'Copy';

        function copyingDone() {
            copybutton.innerHTML = 'Done';
            setTimeout(() => {
                copybutton.innerHTML = 'Copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
