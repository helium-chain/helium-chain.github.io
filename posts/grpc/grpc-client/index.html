<!DOCTYPE html>
<html lang="zh" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>grpc.Client | Helium</title>
<meta name="keywords" content="grpc">
<meta name="description" content="grpc client 介绍。">
<meta name="author" content="helium">
<link rel="canonical" href="https://helium-chain.github.io/posts/grpc/grpc-client/">
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<meta name="referrer" content="no-referrer-when-downgrade">
<link crossorigin="anonymous" href="/assets/css/stylesheet.css" rel="preload stylesheet" as="style">
<link rel="icon" href="https://helium-chain.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://helium-chain.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://helium-chain.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://helium-chain.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://helium-chain.github.io/apple-touch-icon.png">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="zh" href="https://helium-chain.github.io/posts/grpc/grpc-client/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
<html>
<head>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/jetbrains-mono@1.0.6/css/jetbrains-mono-nl.min.css" />
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lxgw-wenkai-lite-webfont@1.1.0/style.css" />
    <link rel="stylesheet" href="https://cdn.staticfile.org/lxgw-wenkai-screen-webfont/1.6.0/style.css" />
    <style>
        body {
            font-family: "LXGW WenKai Lite", sans-serif;
            font-family: "LXGW WenKai Screen", sans-serif;
        }
    </style>
</head>
</html>

  

<meta property="og:title" content="grpc.Client" />
<meta property="og:description" content="grpc client 介绍。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://helium-chain.github.io/posts/grpc/grpc-client/" />
<meta property="og:image" content="https://helium-chain.github.io/favicon-32x32.png" />
<meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-09-17T00:00:00+00:00" />
<meta property="article:modified_time" content="2024-09-17T00:00:00+00:00" /><meta property="og:site_name" content="Helium" />

<meta name="twitter:card" content="summary_large_image" />
<meta name="twitter:image" content="https://helium-chain.github.io/favicon-32x32.png" />
<meta name="twitter:title" content="grpc.Client"/>
<meta name="twitter:description" content="grpc client 介绍。"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Article",
      "item": "https://helium-chain.github.io/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "gRPC",
      "item": "https://helium-chain.github.io/posts/grpc/"
    }, 
    {
      "@type": "ListItem",
      "position":  3 ,
      "name": "grpc.Client",
      "item": "https://helium-chain.github.io/posts/grpc/grpc-client/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "grpc.Client",
  "name": "grpc.Client",
  "description": "grpc client 介绍。",
  "keywords": [
    "grpc"
  ],
  "articleBody": "type ClientConn ClientConn表示到概念端点的虚拟连接，以执行rpc。 根据配置、负载等，ClientConn可以自由地拥有零个或多个到端点的实际连接。它还可以自由地确定要使用的实际端点，并可以在每个RPC中更改它，从而允许客户端负载平衡。 ClientConn封装了一系列功能，包括名称解析、TCP连接建立(带有重试和退出)和TLS握手。它还通过重新解析名称和重新连接来处理已建立连接上的错误。 type ClientConn struct { // contains filtered or unexported fields } NewClient(target, opts) NewClient为提供的目标URI创建一个新的gRPC “channel”。无I/O操作。对rpc使用ClientConn将自动使其连接。Connect可以用于手动创建连接，但对于大多数用户来说，这是不必要的。 目标名称语法在https://github.com/grpc/grpc/blob/master/doc/naming.md中定义。例如，要使用DNS解析器，应该对目标应用\" DNS:///“前缀。 WithBlock, WithTimeout, WithReturnConnectionError和FailOnNonTempDialError返回的DialOptions将被该函数忽略。 // NewClient creates a new gRPC \"channel\" for the target URI provided. No I/O // is performed. Use of the ClientConn for RPCs will automatically cause it to // connect. Connect may be used to manually create a connection, but for most // users this is unnecessary. // // The target name syntax is defined in // https://github.com/grpc/grpc/blob/master/doc/naming.md. e.g. to use dns // resolver, a \"dns:///\" prefix should be applied to the target. // // The DialOptions returned by WithBlock, WithTimeout, // WithReturnConnectionError, and FailOnNonTempDialError are ignored by this // function. func NewClient(target string, opts ...DialOption) (conn *ClientConn, err error) { cc := \u0026ClientConn{ target: target, conns: make(map[*addrConn]struct{}), dopts: defaultDialOptions(), } cc.retryThrottler.Store((*retryThrottler)(nil)) cc.safeConfigSelector.UpdateConfigSelector(\u0026defaultConfigSelector{nil}) cc.ctx, cc.cancel = context.WithCancel(context.Background()) // Apply dial options. disableGlobalOpts := false for _, opt := range opts { if _, ok := opt.(*disableGlobalDialOptions); ok { disableGlobalOpts = true break } } if !disableGlobalOpts { for _, opt := range globalDialOptions { opt.apply(\u0026cc.dopts) } } for _, opt := range opts { opt.apply(\u0026cc.dopts) } // Determine the resolver to use. if err := cc.initParsedTargetAndResolverBuilder(); err != nil { return nil, err } for _, opt := range globalPerTargetDialOptions { opt.DialOptionForTarget(cc.parsedTarget.URL).apply(\u0026cc.dopts) } chainUnaryClientInterceptors(cc) chainStreamClientInterceptors(cc) if err := cc.validateTransportCredentials(); err != nil { return nil, err } if cc.dopts.defaultServiceConfigRawJSON != nil { scpr := parseServiceConfig(*cc.dopts.defaultServiceConfigRawJSON, cc.dopts.maxCallAttempts) if scpr.Err != nil { return nil, fmt.Errorf(\"%s: %v\", invalidDefaultServiceConfigErrPrefix, scpr.Err) } cc.dopts.defaultServiceConfig, _ = scpr.Config.(*ServiceConfig) } cc.mkp = cc.dopts.copts.KeepaliveParams if err = cc.initAuthority(); err != nil { return nil, err } // Register ClientConn with channelz. Note that this is only done after // channel creation cannot fail. cc.channelzRegistration(target) channelz.Infof(logger, cc.channelz, \"parsed dial target is: %#v\", cc.parsedTarget) channelz.Infof(logger, cc.channelz, \"Channel authority set to %q\", cc.authority) cc.csMgr = newConnectivityStateManager(cc.ctx, cc.channelz) cc.pickerWrapper = newPickerWrapper(cc.dopts.copts.StatsHandlers) cc.metricsRecorderList = stats.NewMetricsRecorderList(cc.dopts.copts.StatsHandlers) cc.initIdleStateLocked() // Safe to call without the lock, since nothing else has a reference to cc. cc.idlenessMgr = idle.NewManager((*idler)(cc), cc.dopts.idleTimeout) return cc, nil } (cc) CanonicalTarget() CanonicalTarget返回ClientConn的规范目标字符串。 // CanonicalTarget returns the canonical target string of the ClientConn. func (cc *ClientConn) CanonicalTarget() string { return cc.parsedTarget.String() } 示例 func main() { // 配置ssl，\"*.heliu.site\"在实际开发中从浏览器中取获取，证书路径使用绝对路径 creds, _ := credentials.NewClientTLSFromFile( \"/root/workspace/learn-grpc/key/test.pem\", \"*.heliu.site\", ) var opts []grpc.DialOption // 不带TLS这里是grpc.WithTransportCredentials(insecure.NewCredentials()) opts = append(opts, grpc.WithTransportCredentials(creds)) opts = append(opts, grpc.WithPerRPCCredentials(\u0026ClientTokenAuth{})) // 添加客户端拦截器 opts = append(opts, grpc.WithUnaryInterceptor(interceptor.UnaryClientInterceptor())) // 添加流拦截器 opts = append(opts, grpc.WithStreamInterceptor(interceptor.StreamClientInterceptor())) // 连接server端，使用ssl加密通信 conn, err := grpc.NewClient(\"127.0.0.1:9090\", opts...) if err != nil { log.Fatalf(\"did not connect: %v\", err) } defer conn.Close() // ----------- CanonicalTarget: dns:///127.0.0.1:9090 ----------- log.Printf(\"CanonicalTarget: %s\\n\", conn.CanonicalTarget()) // ... } (cc) Close() Close关闭ClientConn和所有底层连接。 // Close tears down the ClientConn and all underlying connections. func (cc *ClientConn) Close() error { defer func() { cc.cancel() \u003c-cc.csMgr.pubSub.Done() }() // Prevent calls to enter/exit idle immediately, and ensure we are not // currently entering/exiting idle mode. cc.idlenessMgr.Close() cc.mu.Lock() if cc.conns == nil { cc.mu.Unlock() return ErrClientConnClosing } conns := cc.conns cc.conns = nil cc.csMgr.updateState(connectivity.Shutdown) // We can safely unlock and continue to access all fields now as // cc.conns==nil, preventing any further operations on cc. cc.mu.Unlock() cc.resolverWrapper.close() // The order of closing matters here since the balancer wrapper assumes the // picker is closed before it is closed. cc.pickerWrapper.close() cc.balancerWrapper.close() \u003c-cc.resolverWrapper.serializer.Done() \u003c-cc.balancerWrapper.serializer.Done() for ac := range conns { ac.tearDown(ErrClientConnClosing) } cc.addTraceEvent(\"deleted\") // TraceEvent needs to be called before RemoveEntry, as TraceEvent may add // trace reference to the entity being deleted, and thus prevent it from being // deleted right away. channelz.RemoveEntry(cc.channelz.ID) return nil } 示例 func main() { // 配置ssl，\"*.heliu.site\"在实际开发中从浏览器中取获取，证书路径使用绝对路径 creds, _ := credentials.NewClientTLSFromFile( \"/root/workspace/learn-grpc/key/test.pem\", \"*.heliu.site\", ) var opts []grpc.DialOption // 不带TLS这里是grpc.WithTransportCredentials(insecure.NewCredentials()) opts = append(opts, grpc.WithTransportCredentials(creds)) opts = append(opts, grpc.WithPerRPCCredentials(\u0026ClientTokenAuth{})) // 添加客户端拦截器 opts = append(opts, grpc.WithUnaryInterceptor(interceptor.UnaryClientInterceptor())) // 添加流拦截器 opts = append(opts, grpc.WithStreamInterceptor(interceptor.StreamClientInterceptor())) // 连接server端，使用ssl加密通信 conn, err := grpc.NewClient(\"127.0.0.1:9090\", opts...) if err != nil { log.Fatalf(\"did not connect: %v\", err) } // ----------- Close ----------- defer conn.Close() log.Printf(\"CanonicalTarget: %s\\n\", conn.CanonicalTarget()) // ... } (cc) Connect() 如果channel空闲，Connect将导致ClientConn中的所有子通道尝试连接。在返回之前不等待连接尝试开始。 注意:此API是实验性的，可能会在以后的版本中更改或删除。 // Connect causes all subchannels in the ClientConn to attempt to connect if // the channel is idle. Does not wait for the connection attempts to begin // before returning. // // # Experimental // // Notice: This API is EXPERIMENTAL and may be changed or removed in a later // release. func (cc *ClientConn) Connect() { if err := cc.idlenessMgr.ExitIdleMode(); err != nil { cc.addTraceEvent(err.Error()) return } // If the ClientConn was not in idle mode, we need to call ExitIdle on the // LB policy so that connections can be created. cc.mu.Lock() cc.balancerWrapper.exitIdle() cc.mu.Unlock() } 详解 它用于通知客户端连接的负载均衡器策略（LB policy）退出空闲模式，并尝试建立连接。这个函数通常在客户端连接空闲时调用，以便在必要时重新建立连接。 作用： 重新连接：当客户端连接处于空闲状态时，可以调用这个函数来尝试重新建立连接。 状态更新：通知负载均衡器策略客户端连接已准备好接受新的请求，并应该开始创建新的连接。 使用场景： 空闲连接管理：当客户端连接长时间没有活动时，可以通过调用这个函数来重新激活连接。 负载均衡策略：当客户端连接的负载均衡策略需要根据连接状态进行调整时，可以使用这个函数。 需要注意的是，Connect 函数是实验性的，可能会在未来的gRPC版本中更改或移除。因此，在生产环境中使用这个函数之前，应该仔细评估其稳定性和适用性。 package main import ( \"context\" \"fmt\" \"google.golang.org/grpc\" \"time\" ) func main() { ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second) defer cancel() conn, err := grpc.DialContext(ctx, \"localhost:50051\", grpc.WithBlock()) if err != nil { fmt.Printf(\"Failed to dial: %v\\n\", err) return } defer conn.Close() // 等待连接状态从DOWN变为READY if conn.WaitForStateChange(ctx, connectivity.StateDown) { fmt.Println(\"Connection state changed to READY\") } else { fmt.Println(\"Connection state change timeout\") } // 在需要时重新连接 conn.Connect() } 在这个例子中，我们创建了一个上下文，设置了5秒的超时时间。然后，我们尝试建立与服务器端口50051的gRPC连接。如果连接成功，我们使用WaitForStateChange函数等待连接状态从DOWN变为READY。如果连接状态在5秒内没有改变，我们将打印出超时的消息。随后，我们调用Connect函数通知客户端连接的负载均衡器策略退出空闲模式，并尝试建立新的连接。 (cc) GetMethodConfig(method) GetMethodConfig获取输入法的方法配置。如果有一个完全匹配的输入法(即/service/method)，我们返回相应的MethodConfig。如果输入法没有精确匹配，我们在服务(即/service/)下查找服务的默认配置，然后查找所有服务的默认配置(空字符串)。 如果服务有默认的MethodConfig，我们就返回它。否则，我们返回一个空的MethodConfig。 // GetMethodConfig gets the method config of the input method. // If there's an exact match for input method (i.e. /service/method), we return // the corresponding MethodConfig. // If there isn't an exact match for the input method, we look for the service's default // config under the service (i.e /service/) and then for the default for all services (empty string). // // If there is a default MethodConfig for the service, we return it. // Otherwise, we return an empty MethodConfig. func (cc *ClientConn) GetMethodConfig(method string) MethodConfig { // TODO: Avoid the locking here. cc.mu.RLock() defer cc.mu.RUnlock() return getMethodConfig(cc.sc, method) } (cc) GetState() GetState返回ClientConn的connectivity.State。 // GetState returns the connectivity.State of ClientConn. func (cc *ClientConn) GetState() connectivity.State { return cc.csMgr.getState() } 详解 它用于获取客户端连接当前的连接状态。这个函数在客户端需要了解其当前连接状态时非常有用，例如，当客户端需要根据连接状态调整其行为时。 作用： 状态监控：允许客户端检查其连接状态，以便根据需要进行相应的处理。 行为调整：客户端可以根据连接状态调整其行为，例如，当连接不可用时，可以暂停发送请求。 使用场景： 连接状态监控：在需要监控连接状态变化的应用场景中，如客户端需要根据连接状态调整其行为。 异常处理：在处理连接问题时，客户端可以检查连接状态来决定如何响应。 package main import ( \"context\" \"fmt\" \"google.golang.org/grpc\" \"time\" ) func main() { ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second) defer cancel() conn, err := grpc.DialContext(ctx, \"localhost:50051\", grpc.WithBlock()) if err != nil { fmt.Printf(\"Failed to dial: %v\\n\", err) return } defer conn.Close() // 获取连接状态 state := conn.GetState() fmt.Printf(\"Connection state: %s\\n\", state) // 假设在连接过程中遇到了短暂故障 if conn.WaitForStateChange(ctx, connectivity.StateIdle) { fmt.Println(\"Connection state changed to READY\") } else { fmt.Println(\"Connection state change timeout\") } } 在这个例子中，我们创建了一个上下文，设置了5秒的超时时间。然后，我们尝试建立与服务器端口50051的gRPC连接。如果连接成功，我们使用GetState函数获取连接状态，并打印出来。随后，我们假设遇到了网络故障，并调用WaitForStateChange函数等待连接状态从IDLE变为READY。如果在5秒内状态没有改变，我们将打印出超时的消息。 (cc) Invoke(ctx, method, args, reply, opts) Invoke通过网络发送RPC请求，并在收到响应后返回。这通常由生成的代码调用。 调用返回的所有错误都与状态包兼容。 // Invoke sends the RPC request on the wire and returns after response is // received. This is typically called by generated code. // // All errors returned by Invoke are compatible with the status package. func (cc *ClientConn) Invoke(ctx context.Context, method string, args, reply any, opts ...CallOption) error { // allow interceptor to see all applicable call options, which means those // configured as defaults from dial option as well as per-call options opts = combine(cc.dopts.callOptions, opts) if cc.dopts.unaryInt != nil { return cc.dopts.unaryInt(ctx, method, args, reply, cc, invoke, opts...) } return invoke(ctx, method, args, reply, cc, opts...) } 详解 它用于发送一个单向的RPC请求到服务器端，并等待接收响应。这个函数通常由gRPC代码生成器调用，用于客户端调用服务器端的单向RPC方法。 作用： 发送请求：允许客户端发送一个单向的RPC请求到服务器端。 接收响应：等待服务器端的响应，并将响应数据存储在 reply 参数中。 使用场景： 单向RPC调用：当客户端只需要发送请求而不需要接收响应时，可以使用这个函数。 服务调用：客户端可以通过这个函数调用服务器端的服务。 package main import ( \"context\" \"fmt\" \"google.golang.org/grpc\" \"time\" ) func main() { ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second) defer cancel() conn, err := grpc.DialContext(ctx, \"localhost:50051\", grpc.WithBlock()) if err != nil { fmt.Printf(\"Failed to dial: %v\\n\", err) return } defer conn.Close() // 调用服务器端的单向RPC方法 err = conn.Invoke(ctx, \"MyService.MyMethod\", nil, nil, grpc.FailOnNonTempDialError(true)) if err != nil { fmt.Printf(\"Failed to invoke RPC: %v\\n\", err) return } // 处理响应（如果有的话） // ... } 在这个例子中，我们创建了一个上下文，设置了5秒的超时时间。然后，我们尝试建立与服务器端口50051的gRPC连接。如果连接成功，我们使用Invoke函数调用服务器端的单向RPC方法。如果有响应，我们可以通过reply参数来处理。最后，我们关闭连接以释放资源。 (cc) NewStream(ctx, desc, method, opts) NewStream为客户端创建一个新的流。这通常由生成的代码调用。ctx用于流的生命周期。\n为了确保资源不会因为返回的流而泄露，必须执行以下操作之一:\n在ClientConn上调用Close。 取消提供的上下文。 调用RecvMsg，直到返回非nil错误。例如，protobuf生成的客户端流式RPC可能会使用辅助函数CloseAndRecv(请注意，CloseSend不Recv，因此不能保证释放所有资源)。 接收一个非nil，非io。报头或发送消息出错。 如果上述情况都没有发生，则会泄露一个程序和一个上下文，并且grpc将不会使用stats.End消息调用可选配置的stats处理程序。\n// NewStream creates a new Stream for the client side. This is typically // called by generated code. ctx is used for the lifetime of the stream. // // To ensure resources are not leaked due to the stream returned, one of the following // actions must be performed: // // 1. Call Close on the ClientConn. // 2. Cancel the context provided. // 3. Call RecvMsg until a non-nil error is returned. A protobuf-generated // client-streaming RPC, for instance, might use the helper function // CloseAndRecv (note that CloseSend does not Recv, therefore is not // guaranteed to release all resources). // 4. Receive a non-nil, non-io.EOF error from Header or SendMsg. // // If none of the above happen, a goroutine and a context will be leaked, and grpc // will not call the optionally-configured stats handler with a stats.End message. func (cc *ClientConn) NewStream(ctx context.Context, desc *StreamDesc, method string, opts ...CallOption) (ClientStream, error) { // allow interceptor to see all applicable call options, which means those // configured as defaults from dial option as well as per-call options opts = combine(cc.dopts.callOptions, opts) if cc.dopts.streamInt != nil { return cc.dopts.streamInt(ctx, desc, cc, method, newClientStream, opts...) } return newClientStream(ctx, desc, cc, method, opts...) } 详解 它用于创建一个新的客户端流（ClientStream）。这个函数通常由gRPC代码生成器调用，用于创建与服务器端服务的通信通道。 作用： 创建通信通道：允许客户端创建一个新的流，以便与服务器端服务进行通信。 行为配置：通过传递不同的CallOption参数，可以配置流的发送和接收行为。 使用场景： 服务调用：当客户端需要调用服务器端的服务时，可以使用这个函数创建一个新的流。 请求发送：客户端可以通过这个流发送请求消息给服务器端。 package main import ( \"context\" \"fmt\" \"google.golang.org/grpc\" \"time\" ) func main() { ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second) defer cancel() conn, err := grpc.DialContext(ctx, \"localhost:50051\", grpc.WithBlock()) if err != nil { fmt.Printf(\"Failed to dial: %v\\n\", err) return } defer conn.Close() // 创建一个新的流 stream, err := conn.NewStream(ctx, \u0026StreamDesc{ // 流描述 }, \"MyService.MyMethod\", grpc.FailOnNonTempDialError(true)) if err != nil { fmt.Printf(\"Failed to create stream: %v\\n\", err) return } // 发送请求消息 // ... // 接收响应消息 // ... // 关闭流 stream.CloseSend() } 在这个例子中，我们创建了一个上下文，设置了5秒的超时时间。然后，我们尝试建立与服务器端口50051的gRPC连接。如果连接成功，我们使用NewStream函数创建一个新的流，并指定要调用的RPC方法和一些流选项。接下来，我们可以通过这个流发送请求消息给服务器端，并接收响应消息。最后，我们关闭流以释放资源。 (cc) ResetConnectBackoff() ResetConnectBackoff唤醒所有暂时失败的子通道，并使它们立即尝试另一个连接。它还重置用于后续尝试的后退时间，而不管当前状态如何。 一般来说，不应该使用这个函数。在默认情况下，典型的服务或网络中断会导致合理的客户端重新连接策略。但是，如果先前不可用的网络变得可用，则可以使用此命令触发立即重新连接。 注意:此API是实验性的，可能会在以后的版本中更改或删除。 // ResetConnectBackoff wakes up all subchannels in transient failure and causes // them to attempt another connection immediately. It also resets the backoff // times used for subsequent attempts regardless of the current state. // // In general, this function should not be used. Typical service or network // outages result in a reasonable client reconnection strategy by default. // However, if a previously unavailable network becomes available, this may be // used to trigger an immediate reconnect. // // # Experimental // // Notice: This API is EXPERIMENTAL and may be changed or removed in a // later release. func (cc *ClientConn) ResetConnectBackoff() { cc.mu.Lock() conns := cc.conns cc.mu.Unlock() for ac := range conns { ac.resetConnectBackoff() } } 详解 它用于重置客户端连接的退避重试策略。这个函数在客户端遇到短暂故障并希望立即尝试重新连接时非常有用。 作用： 立即重试：当客户端遇到短暂故障（如网络问题）时，可以使用这个函数来立即重试连接，而不是等待预设的退避重试间隔。 状态重置：无论当前连接状态如何，这个函数都会重置后续尝试的退避时间。 使用场景： 网络恢复：当网络故障恢复时，客户端可以调用这个函数来立即尝试重新连接。 异常处理：在某些情况下，客户端可能需要绕过正常的退避重试策略，例如，当连接是由于客户端自身的问题（如客户端的代码错误）导致失败时。 需要注意的是，ResetConnectBackoff 函数是实验性的，可能会在未来的gRPC版本中更改或移除。因此，在生产环境中使用这个函数之前，应该仔细评估其稳定性和适用性。 package main import ( \"context\" \"fmt\" \"google.golang.org/grpc\" \"time\" ) func main() { ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second) defer cancel() conn, err := grpc.DialContext(ctx, \"localhost:50051\", grpc.WithBlock()) if err != nil { fmt.Printf(\"Failed to dial: %v\\n\", err) return } defer conn.Close() // 假设在连接过程中遇到了短暂故障 if conn.WaitForStateChange(ctx, connectivity.StateIdle) { fmt.Println(\"Connection state changed to READY\") } else { fmt.Println(\"Connection state change timeout\") } // 网络故障恢复，重置连接退避 conn.ResetConnectBackoff() // 再次尝试连接 if conn.WaitForStateChange(ctx, connectivity.StateIdle) { fmt.Println(\"Connection state changed to READY\") } else { fmt.Println(\"Connection state change timeout\") } } 在这个例子中，我们创建了一个上下文，设置了5秒的超时时间。然后，我们尝试建立与服务器端口50051的gRPC连接。如果连接成功，我们使用WaitForStateChange函数等待连接状态从IDLE变为READY。如果在5秒内状态没有改变，我们将打印出超时的消息。随后，我们假设遇到了网络故障，并调用ResetConnectBackoff函数重置连接退避。最后，我们再次尝试连接并等待状态变化。 (cc) Target() Target返回ClientConn的目标字符串。 // Target returns the target string of the ClientConn. func (cc *ClientConn) Target() string { return cc.target } 示例 func main() { // 配置ssl，\"*.heliu.site\"在实际开发中从浏览器中取获取，证书路径使用绝对路径 creds, _ := credentials.NewClientTLSFromFile( \"/root/workspace/learn-grpc/key/test.pem\", \"*.heliu.site\", ) var opts []grpc.DialOption // 不带TLS这里是grpc.WithTransportCredentials(insecure.NewCredentials()) opts = append(opts, grpc.WithTransportCredentials(creds)) opts = append(opts, grpc.WithPerRPCCredentials(\u0026ClientTokenAuth{})) // 添加客户端拦截器 opts = append(opts, grpc.WithUnaryInterceptor(interceptor.UnaryClientInterceptor())) // 添加流拦截器 opts = append(opts, grpc.WithStreamInterceptor(interceptor.StreamClientInterceptor())) // 连接server端，使用ssl加密通信 conn, err := grpc.NewClient(\"127.0.0.1:9090\", opts...) if err != nil { log.Fatalf(\"did not connect: %v\", err) } defer conn.Close() // Target(): 127.0.0.1:9090 log.Printf(\"Target(): %s\\n\", conn.Target()) // 建立连接 client := pb.NewSayHelloClient(conn) // ... } (cc) WaitForStateChange(ctx, sourceState) WaitForStateChange等待，直到ClientConn的connectivity.State从sourceState更改或ctx过期。 前一种情况返回真值，后一种情况返回假值。 // WaitForStateChange waits until the connectivity.State of ClientConn changes from sourceState or // ctx expires. A true value is returned in former case and false in latter. func (cc *ClientConn) WaitForStateChange(ctx context.Context, sourceState connectivity.State) bool { ch := cc.csMgr.getNotifyChan() if cc.csMgr.getState() != sourceState { return true } select { case \u003c-ctx.Done(): return false case \u003c-ch: return true } } 详解 它用于等待客户端连接的状态从指定的源状态（sourceState）改变。这个函数在客户端需要等待连接状态变化时非常有用，例如，当客户端需要检测到网络的恢复时。 作用： 状态监控：允许客户端在连接状态改变时进行响应，例如，当网络中断后恢复时。 错误处理：在等待状态变化的过程中，如果超时，客户端可以进行适当的错误处理。 使用场景： 网络恢复检测：当客户端连接的网络出现问题，可以使用这个函数来检测网络是否恢复。 连接状态监控：在需要监控连接状态变化的应用场景中，如客户端需要根据连接状态调整其行为。 package main import ( \"context\" \"fmt\" \"google.golang.org/grpc\" \"time\" ) func main() { ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second) defer cancel() conn, err := grpc.DialContext(ctx, \"localhost:50051\", grpc.WithBlock()) if err != nil { fmt.Printf(\"Failed to dial: %v\\n\", err) return } defer conn.Close() // 等待连接状态从DOWN变为READY if conn.WaitForStateChange(ctx, connectivity.StateDown) { fmt.Println(\"Connection state changed to READY\") } else { fmt.Println(\"Connection state change timeout\") } } 在这个例子中，我们创建了一个上下文，设置了5秒的超时时间。然后，我们尝试建立与服务器端口50051的gRPC连接。如果连接成功，我们使用WaitForStateChange函数等待连接状态从DOWN变为READY。如果在5秒内状态没有改变，我们将打印出超时的消息。 type DialOption DialOption配置我们如何设置连接。 type DialOption interface { apply(*dialOptions) } WithAuthority(a) WithAuthority返回一个DialOption，该DialOption指定要用作:authority伪头和身份验证握手中的服务器名称的值。 在HTTP/2协议中，:authority 是一个伪头部字段，用于携带请求的原始主机和端口信息。这个字段相当于HTTP/1.1中的Host头部字段，但在HTTP/2中，由于采用了新的头部压缩机制，:authority 被用作一个伪头部来区分实际的请求头部。 具体来说，:authority 字段通常包含以下内容： 主机名（例如 www.example.com） 端口号（如果使用了非标准端口，例如 :8080） // WithAuthority returns a DialOption that specifies the value to be used as the // :authority pseudo-header and as the server name in authentication handshake. func WithAuthority(a string) DialOption { return newFuncDialOption(func(o *dialOptions) { o.authority = a }) } 详情 用于指定在连接到gRPC服务器时使用的权威（authority）信息。这个权威信息通常包含服务器的域名或IP地址，并且是连接请求中的一个重要部分，因为它用于服务器身份验证和RPC方法的选择。 作用： 服务器识别：指定权威信息有助于服务器识别客户端的请求，并选择适当的RPC方法。 身份验证：在某些情况下，权威信息用于服务器端的认证过程。 使用场景： 客户端配置：在客户端代码中，可以通过传递WithAuthority选项来指定要连接的服务器的权威信息。 服务发现：在服务发现场景中，客户端可能需要根据服务注册表中的权威信息来连接到正确的服务器。 package main import ( \"context\" \"fmt\" \"google.golang.org/grpc\" \"time\" ) func main() { ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second) defer cancel() // 指定要连接的服务器的权威信息 opts := []grpc.DialOption{ grpc.WithAuthority(\"example.com:50051\"), } conn, err := grpc.DialContext(ctx, \"localhost:50051\", opts...) if err != nil { fmt.Printf(\"Failed to dial: %v\\n\", err) return } defer conn.Close() // 客户端可以继续使用这个连接进行RPC调用 // ... } 在这个例子中，我们创建了一个上下文，设置了5秒的超时时间。然后，我们使用WithAuthority选项指定要连接的服务器的权威信息。最后，我们使用这些选项来建立与服务器端口50051的gRPC连接。如果连接成功，客户端可以继续使用这个连接进行RPC调用。 WithChainStreamInterceptor(interceptors) WithChainStreamInterceptor返回一个DialOption，用于指定流rpc的链式拦截器。 第一个拦截器将是最外层的，而最后一个拦截器将是围绕实际调用的最内层的包装器。 此方法添加的所有拦截器都将被链接，并且由WithStreamInterceptor定义的拦截器将始终被添加到链中。 // WithChainStreamInterceptor returns a DialOption that specifies the chained // interceptor for streaming RPCs. The first interceptor will be the outer most, // while the last interceptor will be the inner most wrapper around the real call. // All interceptors added by this method will be chained, and the interceptor // defined by WithStreamInterceptor will always be prepended to the chain. func WithChainStreamInterceptor(interceptors ...StreamClientInterceptor) DialOption { return newFuncDialOption(func(o *dialOptions) { o.chainStreamInts = append(o.chainStreamInts, interceptors...) }) } 详情 用于为gRPC客户端的流式RPC（streaming RPC）添加一个拦截器链（interceptor chain）。这个拦截器链会在客户端发送流式RPC请求和接收响应时被调用。 作用： 拦截器逻辑：允许客户端在流式RPC的各个阶段添加自定义逻辑。 功能扩展：通过组合不同的拦截器，可以实现更复杂的客户端功能，例如请求和响应的修改、错误处理、日志记录等。 使用场景： 日志记录：在流式RPC的发送和接收过程中添加日志记录功能。 请求修改：在发送请求之前对请求进行修改。 响应修改：在接收响应之前对响应进行修改。 package main import ( \"context\" \"fmt\" \"google.golang.org/grpc\" \"time\" ) // 定义一个简单的StreamClientInterceptor func loggingInterceptor(ctx context.Context, desc *grpc.StreamDesc, cc *grpc.ClientConn, method string, opts ...grpc.CallOption) (grpc.ClientStream, error) { stream, err := cc.NewStream(ctx, desc, method, opts...) if err != nil { return nil, err } return \u0026loggingStream{stream}, nil } type loggingStream struct { grpc.ClientStream } func (s *loggingStream) SendMsg(m interface{}) error { fmt.Printf(\"Sending message: %v\\n\", m) return s.ClientStream.SendMsg(m) } func (s *loggingStream) RecvMsg(m interface{}) error { fmt.Printf(\"Received message: %v\\n\", m) return s.ClientStream.RecvMsg(m) } func (s *loggingStream) CloseSend() error { fmt.Println(\"Closing send side of the stream\") return s.ClientStream.CloseSend() } func (s *loggingStream) Context() context.Context { return s.ClientStream.Context() } func main() { ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second) defer cancel() // 创建一个包含拦截器的DialOption opts := []grpc.DialOption{ grpc.WithChainStreamInterceptor(loggingInterceptor), } conn, err := grpc.DialContext(ctx, \"localhost:50051\", opts...) if err != nil { fmt.Printf(\"Failed to dial: %v\\n\", err) return } defer conn.Close() // 客户端可以继续使用这个连接进行RPC调用 // ... } 在这个例子中，我们定义了一个简单的loggingInterceptor函数，它会在流式RPC的发送和接收过程中添加日志记录功能。然后，我们使用WithChainStreamInterceptor选项将这个拦截器添加到客户端的连接配置中。当客户端建立与服务器端口的连接并进行流式RPC调用时，loggingInterceptor将会被调用，并在发送和接收消息时打印日志。 WithChainUnaryInterceptor(interceptors) WithChainUnaryInterceptor返回一个DialOption，用于指定一元rpc的链式拦截器。 第一个拦截器将是最外层的，而最后一个拦截器将是围绕实际调用的最内层的包装器。 通过这个方法添加的所有拦截器都将被链接起来，并且由WithUnaryInterceptor定义的拦截器将始终被添加到链中。 // WithChainUnaryInterceptor returns a DialOption that specifies the chained // interceptor for unary RPCs. The first interceptor will be the outer most, // while the last interceptor will be the inner most wrapper around the real call. // All interceptors added by this method will be chained, and the interceptor // defined by WithUnaryInterceptor will always be prepended to the chain. func WithChainUnaryInterceptor(interceptors ...UnaryClientInterceptor) DialOption { return newFuncDialOption(func(o *dialOptions) { o.chainUnaryInts = append(o.chainUnaryInts, interceptors...) }) } 详情 用于为gRPC客户端的单向RPC（unary RPC）添加一个拦截器链（interceptor chain）。这个拦截器链会在客户端发送单向RPC请求和接收响应时被调用。 作用： 拦截器逻辑：允许客户端在单向RPC的各个阶段添加自定义逻辑。 功能扩展：通过组合不同的拦截器，可以实现更复杂的客户端功能，例如请求和响应的修改、错误处理、日志记录等。 使用场景： 日志记录：在单向RPC的发送和接收过程中添加日志记录功能。 请求修改：在发送请求之前对请求进行修改。 响应修改：在接收响应之前对响应进行修改。 package main import ( \"context\" \"fmt\" \"google.golang.org/grpc\" \"time\" ) // 定义一个简单的UnaryClientInterceptor func loggingInterceptor(ctx context.Context, method string, req, reply interface{}, cc *grpc.ClientConn, invoker grpc.UnaryInvoker, opts ...grpc.CallOption) error { fmt.Printf(\"Sending request: %v\\n\", req) err := invoker(ctx, method, req, reply, cc, opts...) if err != nil { return err } fmt.Printf(\"Received response: %v\\n\", reply) return nil } func main() { ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second) defer cancel() // 创建一个包含拦截器的DialOption opts := []grpc.DialOption{ grpc.WithChainUnaryInterceptor(loggingInterceptor), } conn, err := grpc.DialContext(ctx, \"localhost:50051\", opts...) if err != nil { fmt.Printf(\"Failed to dial: %v\\n\", err) return } defer conn.Close() // 客户端可以继续使用这个连接进行RPC调用 // ... } 在这个例子中，我们定义了一个简单的loggingInterceptor函数，它会在单向RPC的发送和接收过程中添加日志记录功能。然后，我们使用WithChainUnaryInterceptor选项将这个拦截器添加到客户端的连接配置中。当客户端建立与服务器端口的连接并进行单向RPC调用时，loggingInterceptor将会被调用，并在发送请求和接收响应时打印日志。 WithChannelzParentID(c) WithChannelzParentID返回一个DialOption，它指定当前ClientConn父节点的channelz ID。此函数用于嵌套通道创建(例如grpclb dial)。 注意:此API是实验性的，可能会在以后的版本中更改或删除。 // WithChannelzParentID returns a DialOption that specifies the channelz ID of // current ClientConn's parent. This function is used in nested channel creation // (e.g. grpclb dial). // // # Experimental // // Notice: This API is EXPERIMENTAL and may be changed or removed in a // later release. func WithChannelzParentID(c channelz.Identifier) DialOption { return newFuncDialOption(func(o *dialOptions) { o.channelzParent = c }) } 用于配置客户端连接选项，以指定当前客户端连接的父级通道ID。这个函数通常用于嵌套通道创建的情况，例如使用gRPC负载均衡器（grpclb）进行拨号时。 功能说明：WithChannelzParentID函数允许你为gRPC客户端连接指定一个父级通道ID。在gRPC中，通道（channel）是客户端和服务器之间通信的抽象，而通道ID是用于标识和管理这些通道的机制。通过指定一个父级通道ID，你可以跟踪和管理嵌套的通道，这在使用gRPC负载均衡器或其他类型的通道管理时非常有用。 参数说明：c：这是一个channelz.Identifier类型的值，用于标识当前客户端连接的父级通道。 package main import ( \"context\" \"log\" \"google.golang.org/grpc\" \"google.golang.org/grpc/channelz\" ) func main() { serverAddr := \"localhost:50051\" // 创建一个channelz标识符 parentID := channelz.Identifier{ ChannelType: channelz.CHANNEL_TYPE_GRPC_CLIENT, Address: \"localhost:50051\", } // 创建gRPC连接时应用WithChannelzParentID选项 conn, err := grpc.Dial(serverAddr, grpc.WithInsecure(), grpc.WithChannelzParentID(parentID), ) if err != nil { log.Fatalf(\"did not connect: %v\", err) } defer conn.Close() // ... 使用连接进行后续操作 ... } 在这个示例中，我们创建了一个channelz标识符，并使用了WithChannelzParentID选项来创建到服务器的连接。 注意事项： 这是一个实验性的API，可能会在未来版本中发生变化或被移除。 在实际应用中，你可能需要根据你的应用程序架构和通道管理需求来设置父级通道ID。 通过使用WithChannelzParentID，你可以根据应用程序的需求来跟踪和管理嵌套的gRPC通道，特别是在需要复杂的通道管理时。 WithConnectParams(p) WithConnectParams将ClientConn配置为使用提供的ConnectParams来创建和维护到服务器的连接。 作为ConnectParams的一部分指定的回退配置覆盖https://github.com/grpc/grpc/blob/master/doc/connection-backoff.md中指定的所有默认值。考虑使用后退。DefaultConfig作为基础，在您只想覆盖回退配置的子集的情况下。 // WithConnectParams configures the ClientConn to use the provided ConnectParams // for creating and maintaining connections to servers. // // The backoff configuration specified as part of the ConnectParams overrides // all defaults specified in // https://github.com/grpc/grpc/blob/master/doc/connection-backoff.md. Consider // using the backoff.DefaultConfig as a base, in cases where you want to // override only a subset of the backoff configuration. func WithConnectParams(p ConnectParams) DialOption { return newFuncDialOption(func(o *dialOptions) { o.bs = internalbackoff.Exponential{Config: p.Backoff} o.minConnectTimeout = func() time.Duration { return p.MinConnectTimeout } }) } 用于配置客户端连接选项，以使用提供的ConnectParams配置来创建和维护与服务器的连接。 功能说明：WithConnectParams函数允许你提供一个自定义的连接参数配置，这个配置将用于gRPC客户端在创建和维护与服务器的连接时使用。这个选项可以用来配置连接重试的策略，包括重试的间隔、最大尝试次数等。 参数说明：p：这是一个ConnectParams类型的值，包含了连接参数的配置。 package main import ( \"context\" \"log\" \"time\" \"google.golang.org/grpc\" ) type ConnectParams struct { Backoff BackoffConfig MinConnectTimeout time.Duration } func main() { serverAddr := \"localhost:50051\" // 设置连接参数 connectParams := ConnectParams{ Backoff: BackoffConfig{ InitialBackoff: 100 * time.Millisecond, MaxBackoff: 1 * time.Second, Multiplier: 1.5, }, MinConnectTimeout: 10 * time.Second, } // 创建gRPC连接时应用WithConnectParams选项 conn, err := grpc.Dial(serverAddr, grpc.WithInsecure(), grpc.WithConnectParams(connectParams), ) if err != nil { log.Fatalf(\"did not connect: %v\", err) } defer conn.Close() // ... 使用连接进行后续操作 ... } 在这个示例中，我们设置了一个连接参数配置，并使用了WithConnectParams选项来创建到服务器的连接。 注意事项： 连接参数配置中的Backoff字段可以覆盖gRPC默认的连接重试策略。 你可以使用这个选项来配置连接重试的策略，包括重试的间隔、最大尝试次数等。 通过使用WithConnectParams，你可以根据应用程序的需求来配置gRPC客户端的连接行为，特别是在需要自定义连接重试策略时。 WithContextDialer(f) WithContextDialer返回一个DialOption，它设置一个dialer来创建连接。如果FailOnNonTempDialError()设置为true，并且f返回一个错误，gRPC检查错误的Temporary()方法来决定是否应该尝试重新连接到网络地址。 注意:所有支持的Go版本(截至2023年12月)都覆盖了操作系统默认的TCP保持时间和间隔为15秒。要使TCP保持连接与操作系统默认的保持连接时间和间隔，请使用net。Dialer将KeepAlive字段设置为负值，并将SO_KEEPALIVE套接字选项从Control字段设置为true。有关如何做到这一点的具体示例，请参见internal.NetDialerWithTCPKeepalive()。 // WithContextDialer returns a DialOption that sets a dialer to create // connections. If FailOnNonTempDialError() is set to true, and an error is // returned by f, gRPC checks the error's Temporary() method to decide if it // should try to reconnect to the network address. // // Note: All supported releases of Go (as of December 2023) override the OS // defaults for TCP keepalive time and interval to 15s. To enable TCP keepalive // with OS defaults for keepalive time and interval, use a net.Dialer that sets // the KeepAlive field to a negative value, and sets the SO_KEEPALIVE socket // option to true from the Control field. For a concrete example of how to do // this, see internal.NetDialerWithTCPKeepalive(). // // For more information, please see [issue 23459] in the Go github repo. // // [issue 23459]: https://github.com/golang/go/issues/23459 func WithContextDialer(f func(context.Context, string) (net.Conn, error)) DialOption { return newFuncDialOption(func(o *dialOptions) { o.copts.Dialer = f }) } 用于配置客户端连接选项，以设置一个上下文特定的拨号器（dialer）来创建连接。 功能说明：WithContextDialer函数允许你提供一个自定义的拨号器，这个拨号器将在创建gRPC客户端连接时使用。你可以使用这个选项来配置网络连接的各个方面，比如超时设置、TCP保活参数等。 参数说明：f：这是一个函数类型，接受一个context.Context和一个string类型的地址，并返回一个net.Conn和一个可能的错误。这个函数将用于创建实际的网络连接。 package main import ( \"context\" \"log\" \"net\" \"time\" \"google.golang.org/grpc\" ) func main() { serverAddr := \"localhost:50051\" // 创建一个自定义的拨号器函数 dialer := func(ctx context.Context, addr string) (net.Conn, error) { d := net.Dialer{ Timeout: 10 * time.Second, KeepAlive: 15 * time.Second, } return d.DialContext(ctx, \"tcp\", addr) } // 创建gRPC连接时应用WithContextDialer选项 conn, err := grpc.Dial(serverAddr, grpc.WithInsecure(), grpc.WithContextDialer(dialer), ) if err != nil { log.Fatalf(\"did not connect: %v\", err) } defer conn.Close() // ... 使用连接进行后续操作 ... } 在这个示例中，我们创建了一个自定义的拨号器函数，它配置了拨号超时和TCP保活参数。然后，我们使用WithContextDialer选项来创建到服务器的连接。 注意事项： 由于Go 1.19及更高版本会覆盖TCP保活的时间和间隔为15秒，如果你需要使用操作系统的默认保活参数，你可以使用net.Dialer并设置KeepAlive为负值，以及设置SO_KEEPALIVE套接字选项为真。 这个选项是一个实验性的API，可能会在未来版本中发生变化或被移除。 你可以使用这个选项来配置网络连接的各个方面，比如超时设置、TCP保活参数等。 通过使用WithContextDialer，你可以根据应用程序的需求来配置gRPC客户端的连接行为，特别是在需要自定义网络连接参数时。 WithCredentialsBundle(b) WithCredentialsBundle返回一个DialOption来为ClientConn.WithCreds设置一个凭据包。它不应该与WithTransportCredentials一起使用。 注意:此API是实验性的，可能会在以后的版本中更改或删除。 // WithCredentialsBundle returns a DialOption to set a credentials bundle for // the ClientConn.WithCreds. This should not be used together with // WithTransportCredentials. // // # Experimental // // Notice: This API is EXPERIMENTAL and may be changed or removed in a // later release. func WithCredentialsBundle(b credentials.Bundle) DialOption { return newFuncDialOption(func(o *dialOptions) { o.copts.CredsBundle = b }) } 用于配置客户端连接选项，以设置一个凭证捆绑包（credentials bundle）用于客户端连接。 功能说明：WithCredentialsBundle函数允许你提供一个凭证捆绑包，这个捆绑包包含了用于认证和加密通信的凭证。这个选项通常用于需要客户端和服务端使用相同或兼容的凭证进行认证的情况。 参数说明：b：这是一个credentials.Bundle类型的值，包含了用于认证和加密通信的凭证。 package main import ( \"context\" \"log\" \"google.golang.org/grpc\" \"google.golang.org/grpc/credentials\" ) func main() { serverAddr := \"localhost:50051\" // 创建一个凭证捆绑包，包含TLS证书和客户端证书 bundle := credentials.NewBundle() bundle.Add(\"path/to/client_cert.pem\", \"path/to/client_key.pem\", \"path/to/ca_cert.pem\") // 创建gRPC连接时应用WithCredentialsBundle选项 conn, err := grpc.Dial(serverAddr, grpc.WithInsecure(), // 或者使用其他传输凭证选项 grpc.WithCredentialsBundle(bundle), ) if err != nil { log.Fatalf(\"did not connect: %v\", err) } defer conn.Close() // ... 使用连接进行后续操作 ... } 在这个示例中，我们创建了一个凭证捆绑包，并设置了客户端连接的传输凭证选项。然后，我们使用WithCredentialsBundle选项来创建到服务器的连接。 注意事项： 这是一个实验性的API，可能会在未来版本中发生变化或被移除。 不要与WithTransportCredentials一起使用。WithTransportCredentials用于设置传输级别的凭证，而WithCredentialsBundle用于设置客户端连接级别的凭证。 在实际应用中，你可能需要根据你的证书链和信任策略来设置凭证捆绑包。 通过使用WithCredentialsBundle，你可以根据应用程序的需求来配置gRPC客户端的认证方式，特别是在需要客户端和服务端使用相同或兼容的凭证进行认证时。 WithDefaultCallOptions(cos) WithDefaultCallOptions返回一个DialOption，它为连接上的调用设置默认的callooptions。 // WithDefaultCallOptions returns a DialOption which sets the default // CallOptions for calls over the connection. func WithDefaultCallOptions(cos ...CallOption) DialOption { return newFuncDialOption(func(o *dialOptions) { o.callOptions = append(o.callOptions, cos...) }) } 详解 用于为gRPC客户端的每个RPC调用设置默认的选项（CallOptions）。这些选项会被应用到所有通过该连接发起的RPC调用中，除非在调用时显式覆盖这些选项。 作用： 默认配置：允许客户端为通过连接发起的所有RPC调用设置默认的行为选项。 简化调用：通过设置默认选项，可以简化客户端代码，因为不需要在每个RPC调用中都显式指定这些选项。 使用场景： 性能优化：通过设置默认的超时时间、压缩选项等，可以优化客户端的整体性能。 错误处理：通过设置默认的重试策略，可以改善客户端在处理网络问题时的行为。 package main import ( \"context\" \"fmt\" \"google.golang.org/grpc\" \"time\" ) func main() { ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second) defer cancel() // 设置RPC调用的默认超时时间为5秒 opts := []grpc.DialOption{ grpc.WithDefaultCallOptions(grpc.MaxCallRecvMsgSize(1024 * 1024)), // 设置最大接收消息大小为1MB } conn, err := grpc.DialContext(ctx, \"localhost:50051\", opts...) if err != nil { fmt.Printf(\"Failed to dial: %v\\n\", err) return } defer conn.Close() // 客户端可以继续使用这个连接进行RPC调用 // ... } 在这个例子中，我们创建了一个上下文，设置了5秒的超时时间。然后，我们使用WithDefaultCallOptions选项为通过连接发起的所有RPC调用设置默认的超时时间。我们还将最大接收消息大小设置为1MB。最后，我们使用这些选项来建立与服务器端口50051的gRPC连接。如果连接成功，客户端可以继续使用这个连接进行RPC调用。 WithDefaultServiceConfig(s) 用于配置客户端连接选项，以提供一个默认的服务配置。 // WithDefaultServiceConfig returns a DialOption that configures the default // service config, which will be used in cases where: // // 1. WithDisableServiceConfig is also used, or // // 2. The name resolver does not provide a service config or provides an // invalid service config. // // The parameter s is the JSON representation of the default service config. // For more information about service configs, see: // https://github.com/grpc/grpc/blob/master/doc/service_config.md // For a simple example of usage, see: // examples/features/load_balancing/client/main.go func WithDefaultServiceConfig(s string) DialOption { return newFuncDialOption(func(o *dialOptions) { o.defaultServiceConfigRawJSON = \u0026s }) } 功能说明：WithDefaultServiceConfig函数允许你提供一个默认的服务配置，这个配置将在上述情况下被gRPC客户端使用。服务配置通常包含诸如负载均衡策略、重试策略、超时设置等配置信息。如果你不希望gRPC客户端依赖于解析器提供的服务配置，或者解析器提供的服务配置不符合你的需求，你可以使用这个选项来提供一个默认的服务配置。 参数说明：s：这是一个string类型的值，表示服务配置的JSON表示形式。这个配置将被gRPC客户端使用。 package main import ( \"context\" \"log\" \"google.golang.org/grpc\" ) func main() { serverAddr := \"localhost:50051\" // 设置默认服务配置的JSON表示形式 defaultServiceConfigJSON := `{ \"loadBalancingConfig\": { \"grpclb\": { \"childPolicy\": [ { \"round_robin\": {} } ] } } }` // 创建gRPC连接时应用WithDefaultServiceConfig选项 conn, err := grpc.Dial(serverAddr, grpc.WithInsecure(), grpc.WithDefaultServiceConfig(defaultServiceConfigJSON), ) if err != nil { log.Fatalf(\"did not connect: %v\", err) } defer conn.Close() // ... 使用连接进行后续操作 ... } 在这个示例中，我们设置了客户端连接的默认服务配置，并使用WithDefaultServiceConfig选项来创建到服务器的连接。 注意事项： 服务配置的JSON格式必须符合gRPC的服务配置规范。 如果同时使用了WithDisableServiceConfig和WithDefaultServiceConfig，gRPC客户端将使用WithDefaultServiceConfig提供的服务配置。 如果你不希望gRPC客户端使用任何服务配置，你可以只使用WithDisableServiceConfig选项。 通过使用WithDefaultServiceConfig，你可以根据应用程序的需求来配置gRPC客户端的行为，特别是在需要控制负载均衡策略和重试策略时。 WithDisableHealthCheck() 用于配置客户端连接选项，以禁用客户端连接对所有子连接的健康检查。 // WithDisableHealthCheck disables the LB channel health checking for all // SubConns of this ClientConn. // // # Experimental // // Notice: This API is EXPERIMENTAL and may be changed or removed in a // later release. func WithDisableHealthCheck() DialOption { return newFuncDialOption(func(o *dialOptions) { o.disableHealthCheck = true }) } 功能说明： WithDisableHealthCheck函数允许你禁用客户端连接对所有子连接的健康检查。在gRPC中，负载均衡器（LB）通道会定期对子连接进行检查，以确保它们仍然处于活动状态。如果一个子连接不再响应健康检查，负载均衡器会将其从可用连接列表中移除，并可能尝试建立一个新的子连接。 使用这个选项，你可以告诉gRPC不要进行健康检查，这意味着即使子连接不再响应，它们也不会被从可用连接列表中移除，也不会尝试建立新的子连接。 package main import ( \"context\" \"log\" \"google.golang.org/grpc\" ) func main() { serverAddr := \"localhost:50051\" // 创建gRPC连接时应用WithDisableHealthCheck选项 conn, err := grpc.Dial(serverAddr, grpc.WithInsecure(), grpc.WithDisableHealthCheck(), ) if err != nil { log.Fatalf(\"did not connect: %v\", err) } defer conn.Close() // ... 使用连接进行后续操作 ... } 在这个示例中，我们通过WithDisableHealthCheck选项来创建到服务器的连接，这会导致gRPC客户端不会对任何子连接进行健康检查。 注意事项： 这是一个实验性的API，可能会在未来版本中发生变化或被移除。 禁用健康检查可能会导致在子连接不再响应时，客户端不会自动尝试建立新的连接，这可能会影响到服务的可用性和可靠性。 在某些情况下，禁用健康检查可能是有用的，比如当你知道子连接可能会暂时不可用，但不需要gRPC自动重新建立连接时。 通过使用WithDisableHealthCheck，你可以更细粒度地控制gRPC客户端的健康检查行为，特别是在需要避免健康检查可能导致的问题时。 WithDisableRetry() 用于配置客户端连接选项，以禁用重试机制，即使服务配置启用了它们。 // WithDisableRetry returns a DialOption that disables retries, even if the // service config enables them. This does not impact transparent retries, which // will happen automatically if no data is written to the wire or if the RPC is // unprocessed by the remote server. func WithDisableRetry() DialOption { return newFuncDialOption(func(o *dialOptions) { o.disableRetry = true }) } 功能说明：WithDisableRetry函数允许你禁用gRPC客户端的重试机制。在gRPC中，重试机制允许客户端在遇到可重试的错误（如网络问题或服务端错误）时重新发起RPC调用。但是，有些情况下，你可能不希望客户端进行任何重试，即使服务配置中启用了重试。使用这个选项，你可以强制禁用重试。 package main import ( \"context\" \"log\" \"google.golang.org/grpc\" ) func main() { serverAddr := \"localhost:50051\" // 创建gRPC连接时应用WithDisableRetry选项 conn, err := grpc.Dial(serverAddr, grpc.WithInsecure(), grpc.WithDisableRetry(), ) if err != nil { log.Fatalf(\"did not connect: %v\", err) } defer conn.Close() // ... 使用连接进行后续操作 ... } 在这个示例中，我们通过WithDisableRetry选项来创建到服务器的连接，这会导致gRPC客户端不会进行任何重试，即使服务配置中启用了重试。 注意事项： 这个选项仅禁用显式的重试机制。透明的重试仍然会发生，如果满足以下条件：没有数据写入到网络，或者RPC在远程服务器上未被处理。 禁用重试可能会导致在遇到网络问题或服务端错误时，客户端不会尝试重新连接，这可能会影响到服务的可用性和可靠性。 在某些情况下，禁用重试可能是有用的，比如当你知道服务端可能无法处理重试请求，或者当你想要手动控制错误处理逻辑时。 通过使用WithDisableRetry，你可以更细粒度地控制gRPC客户端的重试行为，特别是在需要避免重试可能导致的问题时。 WithDisableServiceConfig() 用于配置客户端连接选项，以忽略通过解析器提供的任何服务配置，并给解析器一个提示，让它不要获取服务配置。 // WithDisableServiceConfig returns a DialOption that causes gRPC to ignore any // service config provided by the resolver and provides a hint to the resolver // to not fetch service configs. // // Note that this dial option only disables service config from resolver. If // default service config is provided, gRPC will use the default service config. func WithDisableServiceConfig() DialOption { return newFuncDialOption(func(o *dialOptions) { o.disableServiceConfig = true }) } 功能说明：WithDisableServiceConfig函数允许你禁用通过名称解析器传递给gRPC客户端的服务配置。服务配置通常包含诸如负载均衡策略、重试策略、超时设置等配置信息。使用这个选项，你可以告诉gRPC忽略这些配置，并且不会从解析器中获取它们。 package main import ( \"context\" \"log\" \"google.golang.org/grpc\" ) func main() { serverAddr := \"localhost:50051\" // 创建gRPC连接时应用WithDisableServiceConfig选项 conn, err := grpc.Dial(serverAddr, grpc.WithInsecure(), grpc.WithDisableServiceConfig(), ) if err != nil { log.Fatalf(\"did not connect: %v\", err) } defer conn.Close() // ... 使用连接进行后续操作 ... } 在这个示例中，我们通过WithDisableServiceConfig选项来创建到服务器的连接，这会导致gRPC忽略任何通过解析器提供的服务配置。 注意事项： 这个选项仅禁用通过解析器提供的服务配置。如果提供了默认的服务配置，gRPC仍然会使用这个默认配置。 禁用服务配置可能会导致gRPC客户端的行为与预期不同，特别是如果服务配置包含了重要的负载均衡或重试策略。 在某些情况下，禁用服务配置可能是有用的，比如当你想要手动控制所有配置或者当你知道解析器提供的服务配置不适用于你的应用程序时。 通过使用WithDisableServiceConfig，你可以更细粒度地控制gRPC客户端的行为，尤其是在需要避免解析器提供的配置对客户端造成不必要影响的情况下。 WithIdleTimeout(d) 用于配置客户端连接的空闲超时时间。 // WithIdleTimeout returns a DialOption that configures an idle timeout for the // channel. If the channel is idle for the configured timeout, i.e there are no // ongoing RPCs and no new RPCs are initiated, the channel will enter idle mode // and as a result the name resolver and load balancer will be shut down. The // channel will exit idle mode when the Connect() method is called or when an // RPC is initiated. // // A default timeout of 30 minutes will be used if this dial option is not set // at dial time and idleness can be disabled by passing a timeout of zero. // // # Experimental // // Notice: This API is EXPERIMENTAL and may be changed or removed in a // later release. func WithIdleTimeout(d time.Duration) DialOption { return newFuncDialOption(func(o *dialOptions) { o.idleTimeout = d }) } 功能说明：WithIdleTimeout函数允许你设置客户端连接在空闲状态下的超时时间。如果连接在指定的超时时间内没有任何活动（即没有正在进行的RPC调用，也没有新的RPC调用被发起），则连接将进入空闲模式，并关闭名称解析器和负载均衡器。连接将在调用Connect()方法或发起新的RPC调用时退出空闲模式。 参数说明：d：这是一个time.Duration类型的值，表示空闲超时时间。当连接空闲超过这个时间时，将触发空闲模式。 package main import ( \"context\" \"log\" \"time\" \"google.golang.org/grpc\" ) func main() { serverAddr := \"localhost:50051\" // 设置空闲超时时间为10分钟 idleTimeout := 10 * time.Minute conn, err := grpc.Dial(serverAddr, grpc.WithInsecure(), grpc.WithIdleTimeout(idleTimeout), ) if err != nil { log.Fatalf(\"did not connect: %v\", err) } defer conn.Close() // ... 使用连接进行后续操作 ... } 在这个示例中，我们设置了客户端连接的空闲超时时间为10分钟，并使用WithIdleTimeout选项来创建到服务器的连接。 注意事项： 如果在建立连接时没有设置此选项，默认的空闲超时时间为30分钟。 可以通过传递一个超时时间为0的值来禁用空闲超时功能。 这是一个实验性的API，可能会在未来版本中发生变化或被移除。 通过使用WithIdleTimeout，你可以根据应用程序的需求来管理客户端连接的生命周期，特别是在需要节省资源或减少不必要的网络活动时。例如，如果应用程序预期会有较长的空闲时间，则可以设置一个较短的空闲超时时间，以关闭不必要的连接并释放资源。 WithInitialConnWindowSize(s) 于配置客户端连接的初始连接窗口大小。 // WithInitialConnWindowSize returns a DialOption which sets the value for // initial window size on a connection. The lower bound for window size is 64K // and any value smaller than that will be ignored. func WithInitialConnWindowSize(s int32) DialOption { return newFuncDialOption(func(o *dialOptions) { o.copts.InitialConnWindowSize = s }) } 功能说明：WithInitialConnWindowSize函数允许你设置在客户端连接上用于流量控制的初始窗口大小。在gRPC中，流量控制是基于窗口大小的，用于限制发送方在没有得到接收方确认的情况下可以发送的数据量。与WithInitialWindowSize不同，WithInitialConnWindowSize影响的是整个连接的初始窗口大小，而不仅仅是单个流。 参数说明：s：这是一个int32类型的值，表示初始连接窗口大小（以字节为单位）。这个值用于控制客户端在连接建立时可以发送的数据量。 package main import ( \"context\" \"log\" \"google.golang.org/grpc\" ) func main() { serverAddr := \"localhost:50051\" // 设置初始连接窗口大小为2MB initialConnWindowSize := int32(2 \u003c\u003c 20) // 2MB in bytes conn, err := grpc.Dial(serverAddr, grpc.WithInsecure(), grpc.WithInitialConnWindowSize(initialConnWindowSize), ) if err != nil { log.Fatalf(\"did not connect: %v\", err) } defer conn.Close() // ... 使用连接进行后续操作 ... } 在这个示例中，我们设置了客户端连接的初始窗口大小为2MB，并使用WithInitialConnWindowSize选项来创建到服务器的连接。 注意事项： 初始连接窗口大小有一个下限，即64KB。如果传入的值小于64KB，则会被忽略，并使用默认值。 设置一个较大的初始连接窗口大小可以减少小数据包发送的频率，从而可能提高性能，特别是在发送大量数据时。 但是，设置过大的窗口大小可能会导致网络拥塞，特别是当网络带宽有限或接收方处理能力不足时。 通过使用WithInitialConnWindowSize，你可以根据网络条件和应用程序的需求来调整客户端的流量控制窗口大小，以优化数据传输效率。这对于管理连接级的数据传输特别有用，尤其是在需要发送大量初始数据或者需要处理多个并发流的情况下。 WithInitialWindowSize(s) 用于配置客户端连接的初始窗口大小。 // WithInitialWindowSize returns a DialOption which sets the value for initial // window size on a stream. The lower bound for window size is 64K and any value // smaller than that will be ignored. func WithInitialWindowSize(s int32) DialOption { return newFuncDialOption(func(o *dialOptions) { o.copts.InitialWindowSize = s }) } 功能说明：WithInitialWindowSize函数允许你设置在流上用于流量控制的初始窗口大小。在gRPC中，流量控制是基于窗口大小的，用于限制发送方在没有得到接收方确认的情况下可以发送的数据量。 参数说明：s：这是一个int32类型的值，表示初始窗口大小（以字节为单位）。这个值用于控制客户端在开始时可以发送的数据量。 package main import ( \"context\" \"log\" \"google.golang.org/grpc\" ) func main() { serverAddr := \"localhost:50051\" // 设置初始窗口大小为1MB initialWindowSize := int32(1 \u003c\u003c 20) // 1MB in bytes conn, err := grpc.Dial(serverAddr, grpc.WithInsecure(), grpc.WithInitialWindowSize(initialWindowSize), ) if err != nil { log.Fatalf(\"did not connect: %v\", err) } defer conn.Close() // ... 使用连接进行后续操作 ... } 在这个示例中，我们设置了客户端连接的初始窗口大小为1MB，并使用WithInitialWindowSize选项来创建到服务器的连接。 注意事项： 初始窗口大小有一个下限，即64KB。如果传入的值小于64KB，则会被忽略，并使用默认值。 设置一个较大的初始窗口大小可以减少小数据包发送的频率，从而可能提高性能，特别是在发送大量数据时。 但是，设置过大的窗口大小可能会导致网络拥塞，特别是当网络带宽有限或接收方处理能力不足时。 通过使用WithInitialWindowSize，你可以根据网络条件和应用程序的需求来调整客户端的流量控制窗口大小，以优化数据传输效率。 WithKeepaliveParams(kp) 用于配置客户端连接的保活（keepalive）参数。 // WithKeepaliveParams returns a DialOption that specifies keepalive parameters // for the client transport. func WithKeepaliveParams(kp keepalive.ClientParameters) DialOption { if kp.Time \u003c internal.KeepaliveMinPingTime { logger.Warningf(\"Adjusting keepalive ping interval to minimum period of %v\", internal.KeepaliveMinPingTime) kp.Time = internal.KeepaliveMinPingTime } return newFuncDialOption(func(o *dialOptions) { o.copts.KeepaliveParams = kp }) } 功能说明：WithKeepaliveParams函数允许你设置客户端传输层的保活参数。保活机制可以确保在长时间没有数据传输的情况下，客户端与服务器之间的连接仍然是活跃的。这对于维护连接的稳定性，特别是在存在网络设备（如NAT、防火墙）可能导致连接超时的情况下，是非常有用的。 参数说明：kp：这是一个keepalive.ClientParameters类型的结构体，包含了以下字段来配置保活参数： Time: 客户端发送保活ping的时间间隔。如果设置为0，则禁用保活ping。 Timeout: 等待服务器响应保活ping的超时时间。如果服务器在此时间内没有响应，连接将被关闭。 PermitWithoutStream: 即使没有活动流，也允许发送保活ping。 函数内部逻辑： 如果传入的kp.Time小于internal.KeepaliveMinPingTime（gRPC内部定义的最小保活ping时间间隔），则函数会调整kp.Time到最小值，并打印一条警告信息。 然后函数返回一个DialOption，该选项包含一个函数，该函数将kp赋值给dialOptions结构体的copts.KeepaliveParams字段。 package main import ( \"context\" \"log\" \"time\" \"google.golang.org/grpc\" \"google.golang.org/grpc/keepalive\" ) func main() { serverAddr := \"localhost:50051\" // 设置保活参数 keepaliveParams := keepalive.ClientParameters{ Time: 10 * time.Second, // 发送保活ping的时间间隔 Timeout: 5 * time.Second, // 等待服务器响应保活ping的超时时间 PermitWithoutStream: true, // 即使没有活动流也允许发送保活ping } conn, err := grpc.Dial(serverAddr, grpc.WithInsecure(), grpc.WithKeepaliveParams(keepaliveParams), ) if err != nil { log.Fatalf(\"did not connect: %v\", err) } defer conn.Close() // ... 使用连接进行后续操作 ... } 在这个示例中，我们设置了客户端的保活参数，并使用WithKeepaliveParams选项来创建到服务器的连接。 注意事项： 如果kp.Time设置得太低，可能会对服务器造成不必要的负担，因为服务器需要频繁地处理保活ping。 kp.Timeout应该小于或等于服务器配置的保活超时时间，以避免客户端过早地关闭连接。 PermitWithoutStream选项允许在没有活动流的情况下发送保活ping，这对于维护空闲连接非常有用。 通过使用WithKeepaliveParams，你可以根据应用程序的需求和网络环境来优化客户端的保活行为，从而确保连接的稳定性。 WithMaxCallAttempts(n) 用于配置客户端在发起调用时的最大尝试次数。 // WithMaxCallAttempts returns a DialOption that configures the maximum number // of attempts per call (including retries and hedging) using the channel. // Service owners may specify a higher value for these parameters, but higher // values will be treated as equal to the maximum value by the client // implementation. This mitigates security concerns related to the service // config being transferred to the client via DNS. // // A value of 5 will be used if this dial option is not set or n \u003c 2. func WithMaxCallAttempts(n int) DialOption { return newFuncDialOption(func(o *dialOptions) { if n \u003c 2 { n = defaultMaxCallAttempts } o.maxCallAttempts = n }) } 功能说明：WithMaxCallAttempts函数的作用是设置每个调用（包括重试和hedging）的最大尝试次数。以下是对其功能的详细解释： 重试次数：当客户端发起一个调用，并且遇到可重试的错误（例如网络问题）时，客户端会尝试重新发起调用，直到达到设定的最大尝试次数。 Hedging：Hedging是一种gRPC特有的机制，允许客户端在等待初始调用结果的同时，发送额外的请求。这些额外的请求会并行执行，目的是提高响应速度。如果其中一个调用成功，其他的调用将被取消。 参数说明： n：这是函数的参数，表示客户端应该尝试的最大次数。如果n小于2，函数将使用默认值defaultMaxCallAttempts（通常为5）。 package main import ( \"context\" \"log\" \"google.golang.org/grpc\" \"google.golang.org/grpc/credentials/insecure\" ) func main() { serverAddr := \"localhost:50051\" maxCallAttempts := 3 // 设置最大尝试次数为3 conn, err := grpc.Dial(serverAddr, grpc.WithTransportCredentials(insecure.NewCredentials()), grpc.WithMaxCallAttempts(maxCallAttempts), ) if err != nil { log.Fatalf(\"did not connect: %v\", err) } defer conn.Close() // ... 使用连接进行后续操作 ... } 在这个示例中，如果maxCallAttempts小于2，那么客户端将使用默认的最大尝试次数5。 注意事项： 当不设置WithMaxCallAttempts或设置小于2的值时，默认的最大尝试次数是5。 在实际应用中，应使用安全的凭据替换insecure.NewCredentials()。 WithMaxCallAttempts选项是在客户端发起连接时设置的，它影响所有通过该连接发出的调用。 通过使用WithMaxCallAttempts，你可以根据服务的不稳定性和性能需求，调整客户端的调用行为，以增强系统的健壮性。 WithMaxHeaderListSize(s) 该函数允许你设置客户端愿意接受的最大（未压缩）头部列表的大小。这在需要限制传入头部大小以防止潜在的资源耗尽攻击或处理过大的头部时非常有用。 // WithMaxHeaderListSize returns a DialOption that specifies the maximum // (uncompressed) size of header list that the client is prepared to accept. func WithMaxHeaderListSize(s uint32) DialOption { return MaxHeaderListSizeDialOption{ MaxHeaderListSize: s, } } package main import ( \"context\" \"log\" \"time\" \"google.golang.org/grpc\" \"google.golang.org/grpc/credentials/insecure\" ) func main() { // 服务地址 serverAddr := \"localhost:50051\" // 设置最大头部列表大小为1MB（以字节为单位） maxHeaderListSize := uint32(1 \u003c\u003c 20) // 1MB // 创建gRPC连接时应用WithMaxHeaderListSize选项 conn, err := grpc.Dial(serverAddr, grpc.WithTransportCredentials(insecure.NewCredentials()), grpc.WithMaxHeaderListSize(maxHeaderListSize), ) if err != nil { log.Fatalf(\"did not connect: %v\", err) } defer conn.Close() // 假设你有一个服务客户端，你可以使用conn创建客户端实例 // client := NewYourServiceClient(conn) // ... 使用client进行后续操作 ... // 这里只是一个示例，所以我们将等待一段时间后关闭连接 ctx, cancel := context.WithTimeout(context.Background(), time.Second*10) defer cancel() // 假设你调用了某个RPC方法 // response, err := client.YourRPCMethod(ctx, \u0026YourRequest{}) // if err != nil { // log.Fatalf(\"could not call: %v\", err) // } // log.Printf(\"Response: %v\", response) // 暂停一段时间后关闭连接 \u003c-ctx.Done() } 在这个示例中，我们首先导入了必要的包，然后设置了服务器的地址和想要设置的最大头部列表大小。接着，我们使用grpc.Dial函数创建了一个到服务器的连接，并通过grpc.WithMaxHeaderListSize传递了我们的配置选项。 WithNoProxy() 用于禁用代理（proxy）的使用。这个选项适用于客户端连接（ClientConn），当它被设置时，gRPC将不会通过代理与服务器进行通信。 // WithNoProxy returns a DialOption which disables the use of proxies for this // ClientConn. This is ignored if WithDialer or WithContextDialer are used. // // # Experimental // // Notice: This API is EXPERIMENTAL and may be changed or removed in a // later release. func WithNoProxy() DialOption { return newFuncDialOption(func(o *dialOptions) { o.copts.UseProxy = false }) } 作用： 代理禁用：允许客户端在建立与服务器的连接时禁用代理。 直接连接：通过禁用代理，客户端可以直接与服务器建立连接，绕过任何中间代理服务器。 使用场景： 代理限制：在客户端不能使用代理服务器或代理服务器不可靠的场景中，可以禁用代理。 安全性：在需要确保通信安全性的场景中，通过禁用代理来避免通过不可信的中间节点。 需要注意的是，WithNoProxy 函数是gRPC框架中的一个实验性API，可能会在未来的gRPC版本中更改或移除。因此，在生产环境中使用这个函数之前，应该仔细评估其稳定性和适用性。 WithPerRPCCredentials(creds) 用于为每个单向RPC（unary RPC）设置凭证（credentials）。这个选项允许客户端在每次RPC调用时传递特定的凭证，这通常是用于认证的凭证。 // WithPerRPCCredentials returns a DialOption which sets credentials and places // auth state on each outbound RPC. func WithPerRPCCredentials(creds credentials.PerRPCCredentials) DialOption { return newFuncDialOption(func(o *dialOptions) { o.copts.PerRPCCredentials = append(o.copts.PerRPCCredentials, creds) }) } 详解 作用： 认证：允许客户端在每次RPC调用时传递认证凭证，以验证客户端的身份。 安全通信：通过设置凭证，可以确保RPC调用是在安全的环境中进行。 使用场景： 客户端认证：在需要客户端认证的场景中，使用这个函数可以为每个RPC调用设置凭证。 安全性要求：在需要保证通信安全性的场景中，通过设置凭证来增强安全性。 package main import ( \"context\" \"fmt\" \"google.golang.org/grpc\" \"time\" ) // 定义一个简单的PerRPCCredentials实现 func customCredentials() (credentials.PerRPCCredentials, error) { // 实现凭证的获取逻辑 return nil, nil } func main() { ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second) defer cancel() // 创建一个包含凭证的DialOption opts := []grpc.DialOption{ grpc.WithPerRPCCredentials(customCredentials), } conn, err := grpc.DialContext(ctx, \"localhost:50051\", opts...) if err != nil { fmt.Printf(\"Failed to dial: %v\\n\", err) return } defer conn.Close() // 客户端可以继续使用这个连接进行RPC调用 // ... } 在这个例子中，我们创建了一个上下文，设置了5秒的超时时间。然后，我们使用WithPerRPCCredentials选项创建了一个包含自定义凭证的DialOption。这个凭证将被用于每次RPC调用。最后，我们使用这些选项来建立与服务器端口50051的gRPC连接。如果连接成功，客户端可以继续使用这个连接进行RPC调用。 WithReadBufferSize(s) 用于设置客户端连接（ClientConn）的读缓冲区（read buffer）的大小。这个缓冲区的大小决定了在一次系统调用中可以读取的最大数据量。 // WithReadBufferSize lets you set the size of read buffer, this determines how // much data can be read at most for each read syscall. // // The default value for this buffer is 32KB. Zero or negative values will // disable read buffer for a connection so data framer can access the // underlying conn directly. func WithReadBufferSize(s int) DialOption { return newFuncDialOption(func(o *dialOptions) { o.copts.ReadBufferSize = s }) } 详解 作用： 性能调优：适当调整读缓冲区的大小可以优化客户端接收数据的性能。 资源管理：通过设置合适的读缓冲区大小，可以有效地管理客户端端的内存使用。 默认值： 如果没有设置这个选项，gRPC客户端默认的读缓冲区大小是32KB。 使用场景： 网络条件优化：在网络条件变化时，调整读缓冲区大小可以帮助客户端更好地适应不同的网络条件。 接收性能优化：在需要优化接收性能的应用场景中，调整读缓冲区大小可以提高效率。 package main import ( \"context\" \"fmt\" \"google.golang.org/grpc\" \"time\" ) func main() { ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second) defer cancel() // 设置客户端连接的读缓冲区大小为100KB opts := []grpc.DialOption{ grpc.WithReadBufferSize(100 * 1024), } conn, err := grpc.DialContext(ctx, \"localhost:50051\", opts...) if err != nil { fmt.Printf(\"Failed to dial: %v\\n\", err) return } defer conn.Close() // 客户端可以继续使用这个连接进行RPC调用 // ... } 在这个例子中，我们创建了一个上下文，设置了5秒的超时时间。然后，我们使用WithReadBufferSize选项将客户端连接的读缓冲区大小设置为100KB。最后，我们使用这些选项来建立与服务器端口50051的gRPC连接。如果连接成功，客户端可以继续使用这个连接进行RPC调用。 WithResolvers(rs) 用于在客户端连接（ClientConn）上注册一系列解析器（resolver）实现，而不需要通过全局注册的方式。这些解析器将被用于解析客户端在当前Dial操作中使用的方案（scheme）。 // WithResolvers allows a list of resolver implementations to be registered // locally with the ClientConn without needing to be globally registered via // resolver.Register. They will be matched against the scheme used for the // current Dial only, and will take precedence over the global registry. // // # Experimental // // Notice: This API is EXPERIMENTAL and may be changed or removed in a // later release. func WithResolvers(rs ...resolver.Builder) DialOption { return newFuncDialOption(func(o *dialOptions) { o.resolvers = append(o.resolvers, rs...) }) } 详解 作用： 本地解析器注册：允许客户端在本地注册解析器，而不需要全局注册。 优先级：本地注册的解析器将优先于全局注册的解析器。 使用场景： 定制解析器：在需要使用自定义解析器或优先使用特定解析器的场景中，可以使用这个函数。 实验性特性：这个函数是一个实验性特性，可能会在未来的gRPC版本中更改或移除。 package main import ( \"context\" \"fmt\" \"google.golang.org/grpc\" \"time\" ) // 定义一个简单的解析器实现 func customResolver(ctx context.Context, s string) (addrs []resolver.Address, err error) { // 解析地址并返回解析结果 return []resolver.Address{}, nil } func main() { ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second) defer cancel() // 创建一个包含解析器的DialOption opts := []grpc.DialOption{ grpc.WithResolvers(customResolver), } conn, err := grpc.DialContext(ctx, \"localhost:50051\", opts...) if err != nil { fmt.Printf(\"Failed to dial: %v\\n\", err) return } defer conn.Close() // 客户端可以继续使用这个连接进行RPC调用 // ... } 在这个例子中，我们创建了一个上下文，设置了5秒的超时时间。然后，我们使用WithResolvers选项创建了一个包含自定义解析器的DialOption。这个解析器将用于解析地址。最后，我们使用这些选项来建立与服务器端口50051的gRPC连接。如果连接成功，客户端可以继续使用这个连接进行RPC调用。 WithSharedWriteBuffer(val) 用于设置客户端连接（ClientConn）的写缓冲区（write buffer）是否可以共享。这个选项影响客户端连接发送数据的缓冲机制。 // WithSharedWriteBuffer allows reusing per-connection transport write buffer. // If this option is set to true every connection will release the buffer after // flushing the data on the wire. // // # Experimental // // Notice: This API is EXPERIMENTAL and may be changed or removed in a // later release. func WithSharedWriteBuffer(val bool) DialOption { return newFuncDialOption(func(o *dialOptions) { o.copts.SharedWriteBuffer = val }) } 详解 作用： 缓冲机制控制：允许客户端控制写缓冲区的共享行为，这可以影响客户端发送数据的效率。 性能调优：通过调整写缓冲区的共享行为，可以优化客户端的性能。 默认值： 默认情况下，写缓冲区是独立的，每个连接都有自己的缓冲区。 使用场景： 性能优化：在需要优化发送性能的应用场景中，可以通过设置写缓冲区是否共享来优化效率。 资源管理：在需要管理客户端资源的场景中，通过设置写缓冲区是否共享来控制资源的使用。 package main import ( \"context\" \"fmt\" \"google.golang.org/grpc\" \"time\" ) func main() { ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second) defer cancel() // 设置写缓冲区可以共享 opts := []grpc.DialOption{ grpc.WithSharedWriteBuffer(true), } conn, err := grpc.DialContext(ctx, \"localhost:50051\", opts...) if err != nil { fmt.Printf(\"Failed to dial: %v\\n\", err) return } defer conn.Close() // 客户端可以继续使用这个连接进行RPC调用 // ... } 在这个例子中，我们创建了一个上下文，设置了5秒的超时时间。然后，我们使用WithSharedWriteBuffer选项将写缓冲区设置为可以共享。最后，我们使用这些选项来建立与服务器端口50051的gRPC连接。如果连接成功，客户端可以继续使用这个连接进行RPC调用。 WithStatsHandler(h) 用于为gRPC客户端连接指定统计（stats）处理程序。这个处理程序用于收集和报告关于客户端操作的统计信息，这些信息可以帮助开发者监控客户端性能、诊断问题，并进行性能调优。 // WithStatsHandler returns a DialOption that specifies the stats handler for // all the RPCs and underlying network connections in this ClientConn. func WithStatsHandler(h stats.Handler) DialOption { return newFuncDialOption(func(o *dialOptions) { if h == nil { logger.Error(\"ignoring nil parameter in grpc.WithStatsHandler ClientOption\") // Do not allow a nil stats handler, which would otherwise cause // panics. return } o.copts.StatsHandlers = append(o.copts.StatsHandlers, h) }) } 详解 作用： 性能监控：通过收集客户端操作的统计信息，可以监控客户端性能，及时发现性能瓶颈。 问题诊断：当客户端出现问题时，统计信息可以帮助诊断问题原因。 性能调优：根据统计数据，可以对客户端配置进行调整，以优化性能。 使用场景： 性能监控：在需要监控客户端性能的应用场景中，可以通过设置统计处理程序来收集统计信息。 问题诊断：在需要诊断客户端问题的应用场景中，可以通过设置统计处理程序来收集诊断信息。 性能调优：在需要优化客户端性能的应用场景中，可以通过设置统计处理程序来收集性能数据。 package main import ( \"context\" \"fmt\" \"google.golang.org/grpc\" \"time\" ) // 定义一个简单的统计处理程序 func loggingStatsHandler(s stats.RawClientStats) { // 处理统计信息，例如记录到日志 fmt.Printf(\"Received %d bytes on stream\", s.StreamBytesReceived) } func main() { ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second) defer cancel() // 创建一个包含统计处理程序的DialOption opts := []grpc.DialOption{ grpc.WithStatsHandler(loggingStatsHandler), } conn, err := grpc.DialContext(ctx, \"localhost:50051\", opts...) if err != nil { fmt.Printf(\"Failed to dial: %v\\n\", err) return } defer conn.Close() // 客户端可以继续使用这个连接进行RPC调用 // ... } 在这个例子中，我们创建了一个上下文，设置了5秒的超时时间。然后，我们使用WithStatsHandler选项创建了一个包含统计处理程序的DialOption。这个统计处理程序将记录每个流接收到的字节数。最后，我们使用这些选项来建立与服务器端口50051的gRPC连接。如果连接成功，客户端可以继续使用这个连接进行RPC调用。 WithStreamInterceptor(f) 用于为gRPC客户端的流式RPC（streaming RPC）添加一个拦截器（interceptor）。这个拦截器会在客户端发送流式RPC请求和接收响应时被调用。 // WithStreamInterceptor returns a DialOption that specifies the interceptor for // streaming RPCs. func WithStreamInterceptor(f StreamClientInterceptor) DialOption { return newFuncDialOption(func(o *dialOptions) { o.streamInt = f }) } 详解 作用： 拦截器逻辑：允许客户端在流式RPC的各个阶段添加自定义逻辑。 功能扩展：通过组合不同的拦截器，可以实现更复杂的客户端功能，例如请求和响应的修改、错误处理、日志记录等。 使用场景： 日志记录：在流式RPC的发送和接收过程中添加日志记录功能。 请求修改：在发送请求之前对请求进行修改。 响应修改：在接收响应之前对响应进行修改。 package main import ( \"context\" \"fmt\" \"google.golang.org/grpc\" \"time\" ) // 定义一个简单的StreamClientInterceptor func loggingInterceptor(ctx context.Context, desc *grpc.StreamDesc, cc *grpc.ClientConn, method string, opts ...grpc.CallOption) (grpc.ClientStream, error) { stream, err := cc.NewStream(ctx, desc, method, opts...) if err != nil { return nil, err } return \u0026loggingStream{stream}, nil } type loggingStream struct { grpc.ClientStream } func (s *loggingStream) SendMsg(m interface{}) error { fmt.Printf(\"Sending message: %v\\n\", m) return s.ClientStream.SendMsg(m) } func (s *loggingStream) RecvMsg(m interface{}) error { fmt.Printf(\"Received message: %v\\n\", m) return s.ClientStream.RecvMsg(m) } func (s *loggingStream) CloseSend() error { fmt.Println(\"Closing send side of the stream\") return s.ClientStream.CloseSend() } func (s *loggingStream) Context() context.Context { return s.ClientStream.Context() } func main() { ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second) defer cancel() // 创建一个包含拦截器的DialOption opts := []grpc.DialOption{ grpc.WithStreamInterceptor(loggingInterceptor), } conn, err := grpc.DialContext(ctx, \"localhost:50051\", opts...) if err != nil { fmt.Printf(\"Failed to dial: %v\\n\", err) return } defer conn.Close() // 客户端可以继续使用这个连接进行RPC调用 // ... } 在这个例子中，我们定义了一个简单的loggingInterceptor函数，它会在流式RPC的发送和接收过程中添加日志记录功能。然后，我们使用WithStreamInterceptor选项将这个拦截器添加到客户端的连接配置中。当客户端建立与服务器端口的连接并进行流式RPC调用时，loggingInterceptor将会被调用，并在发送和接收消息时打印日志。 WithTransportCredentials(creds) 用于配置客户端连接层面的安全凭证（例如TLS/SSL）。这个选项允许客户端在建立与服务器的连接时使用指定的传输级安全凭证。 // WithTransportCredentials returns a DialOption which configures a connection // level security credentials (e.g., TLS/SSL). This should not be used together // with WithCredentialsBundle. func WithTransportCredentials(creds credentials.TransportCredentials) DialOption { return newFuncDialOption(func(o *dialOptions) { o.copts.TransportCredentials = creds }) } 详解 作用： 安全连接：允许客户端在连接到服务器时使用TLS/SSL等安全协议，以加密传输的数据。 证书验证：客户端可以验证服务器的证书，确保连接到的是预期的服务器。 使用场景： 数据加密：在需要保护传输数据隐私和完整性的场景中，使用TLS/SSL等安全协议。 身份验证：在需要验证服务器身份的场景中，使用证书验证机制。 package main import ( \"context\" \"fmt\" \"google.golang.org/grpc\" \"time\" ) func main() { ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second) defer cancel() // 配置TLS/SSL传输级安全凭证 creds, err := credentials.NewClientTLSFromFile(\"server.crt\", \"\") if err != nil { fmt.Printf(\"Failed to load TLS credentials: %v\\n\", err) return } // 使用传输级安全凭证的DialOption opts := []grpc.DialOption{ grpc.WithTransportCredentials(creds), } conn, err := grpc.DialContext(ctx, \"localhost:50051\", opts...) if err != nil { fmt.Printf(\"Failed to dial: %v\\n\", err) return } defer conn.Close() // 客户端可以继续使用这个连接进行RPC调用 // ... } 在这个例子中，我们创建了一个上下文，设置了5秒的超时时间。然后，我们使用WithTransportCredentials选项配置了TLS/SSL传输级安全凭证。最后，我们使用这些选项来建立与服务器端口50051的gRPC连接。如果连接成功，客户端可以继续使用这个连接进行RPC调用。 WithUnaryInterceptor(f) 用于为gRPC客户端的单向RPC（unary RPC）添加一个拦截器（interceptor）。这个拦截器会在客户端发送单向RPC请求和接收响应时被调用。 // WithUnaryInterceptor returns a DialOption that specifies the interceptor for // unary RPCs. func WithUnaryInterceptor(f UnaryClientInterceptor) DialOption { return newFuncDialOption(func(o *dialOptions) { o.unaryInt = f }) } 详解 作用： 拦截器逻辑：允许客户端在单向RPC的各个阶段添加自定义逻辑。 功能扩展：通过组合不同的拦截器，可以实现更复杂的客户端功能，例如请求和响应的修改、错误处理、日志记录等。 使用场景： 日志记录：在单向RPC的发送和接收过程中添加日志记录功能。 请求修改：在发送请求之前对请求进行修改。 响应修改：在接收响应之前对响应进行修改。 package main import ( \"context\" \"fmt\" \"google.golang.org/grpc\" \"time\" ) // 定义一个简单的UnaryClientInterceptor func loggingInterceptor(ctx context.Context, method string, req, reply interface{}, cc *grpc.ClientConn, invoker grpc.UnaryInvoker, opts ...grpc.CallOption) error { fmt.Printf(\"Sending request: %v\\n\", req) err := invoker(ctx, method, req, reply, cc, opts...) if err != nil { return err } fmt.Printf(\"Received response: %v\\n\", reply) return nil } func main() { ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second) defer cancel() // 创建一个包含拦截器的DialOption opts := []grpc.DialOption{ grpc.WithUnaryInterceptor(loggingInterceptor), } conn, err := grpc.DialContext(ctx, \"localhost:50051\", opts...) if err != nil { fmt.Printf(\"Failed to dial: %v\\n\", err) return } defer conn.Close() // 客户端可以继续使用这个连接进行RPC调用 // ... } 在这个例子中，我们定义了一个简单的loggingInterceptor函数，它会在单向RPC的发送和接收过程中添加日志记录功能。然后，我们使用WithUnaryInterceptor选项将这个拦截器添加到客户端的连接配置中。当客户端建立与服务器端口的连接并进行单向RPC调用时，loggingInterceptor将会被调用，并在发送请求和接收响应时打印日志。 WithUserAgent(s) 设置 UserAgent。 // WithUserAgent returns a DialOption that specifies a user agent string for all // the RPCs. func WithUserAgent(s string) DialOption { return newFuncDialOption(func(o *dialOptions) { o.copts.UserAgent = s + \" \" + grpcUA }) } 详解 用于为所有通过该客户端连接发起的RPC设置用户代理（User Agent）字符串。用户代理字符串通常包含客户端软件的类型、版本、所用操作系统和其他环境信息，它被包含在RPC请求的User-Agent头信息中。 作用： 身份标识：允许客户端在RPC请求中包含用户代理信息，这有助于服务器识别客户端的类型和版本。 统计分析：服务器可以通过用户代理信息来分析客户端的使用情况。 使用场景： 服务监控：在需要监控客户端和服务器交互的场合，用户代理信息可以提供有用的上下文。 统计分析：在需要分析客户端和服务器交互的统计数据的场合，用户代理信息可以提供额外的信息。 package main import ( \"context\" \"fmt\" \"google.golang.org/grpc\" \"time\" ) func main() { ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second) defer cancel() // 设置RPC调用的用户代理为\"my-client/1.0\" opts := []grpc.DialOption{ grpc.WithUserAgent(\"my-client/1.0\"), } conn, err := grpc.DialContext(ctx, \"localhost:50051\", opts...) if err != nil { fmt.Printf(\"Failed to dial: %v\\n\", err) return } defer conn.Close() // 客户端可以继续使用这个连接进行RPC调用 // ... } 在这个例子中，我们创建了一个上下文，设置了5秒的超时时间。然后，我们使用WithUserAgent选项为通过连接发起的所有RPC设置用户代理为\"my-client/1.0”。最后，我们使用这些选项来建立与服务器端口50051的gRPC连接。如果连接成功，客户端可以继续使用这个连接进行RPC调用。 WithWriteBufferSize(s) 设置传输层写缓冲，默认值为32KB。可以设置为0或负数，禁止写缓冲 // WithWriteBufferSize determines how much data can be batched before doing a // write on the wire. The default value for this buffer is 32KB. // // Zero or negative values will disable the write buffer such that each write // will be on underlying connection. Note: A Send call may not directly // translate to a write. func WithWriteBufferSize(s int) DialOption { return newFuncDialOption(func(o *dialOptions) { o.copts.WriteBufferSize = s }) } 详解 作用： 性能调优：适当调整写缓冲区的大小可以优化客户端发送数据的性能。 资源管理：通过设置合适的写缓冲区大小，可以有效地管理客户端端的内存使用。 默认值： 如果没有设置这个选项，gRPC客户端默认的写缓冲区大小是32KB。 使用场景： 网络条件优化：在网络条件变化时，调整写缓冲区大小可以帮助客户端更好地适应不同的网络条件。 发送性能优化：在需要优化发送性能的应用场景中，调整写缓冲区大小可以提高效率。 用于设置客户端连接（ClientConn）的写缓冲区（write buffer）的大小。这个缓冲区的大小决定了在一次系统调用中可以发送的最大数据量。 package main import ( \"context\" \"fmt\" \"google.golang.org/grpc\" \"time\" ) func main() { ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second) defer cancel() // 设置客户端连接的写缓冲区大小为100KB opts := []grpc.DialOption{ grpc.WithWriteBufferSize(100 * 1024), } conn, err := grpc.DialContext(ctx, \"localhost:50051\", opts...) if err != nil { fmt.Printf(\"Failed to dial: %v\\n\", err) return } defer conn.Close() // 客户端可以继续使用这个连接进行RPC调用 // ... } 在这个例子中，我们创建了一个上下文，设置了5秒的超时时间。然后，我们使用WithWriteBufferSize选项将客户端连接的写缓冲区大小设置为100KB。最后，我们使用这些选项来建立与服务器端口50051的gRPC连接。如果连接成功，客户端可以继续使用这个连接进行RPC调用。 type CallOption callloption在调用启动前配置调用，或在调用完成后从调用中提取信息。 // CallOption configures a Call before it starts or extracts information from // a Call after it completes. type CallOption interface { // 在调用被发送到任何服务器之前被调用。 // 如果before返回一个非nil错误，RPC就会因为这个错误而失败。 before(*callInfo) error // After在呼叫完成后被调用。 // After不能返回错误，因此应该通过输出参数报告任何失败。 after(*callInfo, *csAttempt) } CallContentSubtype(contentSubtype) CallContentSubtype返回一个callloption，它将为调用设置内容子类型。例如，如果content-subtype是\"json\"，那么网络上的Content-Type将是\"application/grpc+json\"。在包含在Content-Type中之前，content-子类型被转换为小写。详细信息请参见https://github.com/grpc/grpc/blob/master/doc/PROTOCOL-HTTP2.md#requests上的内容类型。 如果没有使用ForceCodec, content-子类型将用于查找由RegisterCodec控制的注册表中使用的编解码器。有关注册的详细信息，请参阅RegisterCodec的文档。查找content-subtype不区分大小写。如果没有找到这样的编解码器，调用将导致code.internal错误。 如果还使用了ForceCodec，那么该编解码器将用于所有请求和响应消息，并将内容子类型设置为请求的给定contentSubtype。 // CallContentSubtype returns a CallOption that will set the content-subtype // for a call. For example, if content-subtype is \"json\", the Content-Type over // the wire will be \"application/grpc+json\". The content-subtype is converted // to lowercase before being included in Content-Type. See Content-Type on // https://github.com/grpc/grpc/blob/master/doc/PROTOCOL-HTTP2.md#requests for // more details. // // If ForceCodec is not also used, the content-subtype will be used to look up // the Codec to use in the registry controlled by RegisterCodec. See the // documentation on RegisterCodec for details on registration. The lookup of // content-subtype is case-insensitive. If no such Codec is found, the call // will result in an error with code codes.Internal. // // If ForceCodec is also used, that Codec will be used for all request and // response messages, with the content-subtype set to the given contentSubtype // here for requests. func CallContentSubtype(contentSubtype string) CallOption { return ContentSubtypeCallOption{ContentSubtype: strings.ToLower(contentSubtype)} } 详解 用于设置RPC调用内容的子类型（content-subtype）。这个子类型信息会被添加到通过HTTP/2协议传输的RPC请求的Content-Type头信息中。 作用： 内容类型定义：允许客户端定义RPC调用内容的子类型，这有助于客户端和服务器端根据内容类型选择合适的编解码器（Codec）。 定制内容传输：通过设置不同的内容子类型，可以实现不同的内容传输格式，例如JSON、Protobuf等。 使用场景： 协议兼容性：当客户端和服务器端使用不同的协议时，可以通过设置不同的内容子类型来保持兼容性。 内容格式调整：在需要调整RPC调用内容格式时，可以通过设置不同的内容子类型来实现。 package main import ( \"context\" \"fmt\" \"google.golang.org/grpc\" \"time\" ) func main() { ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second) defer cancel() // 设置RPC调用的内容子类型为\"json\" opts := []grpc.DialOption{ grpc.WithDefaultCallOptions(grpc.CallContentSubtype(\"json\")), } conn, err := grpc.DialContext(ctx, \"localhost:50051\", opts...) if err != nil { fmt.Printf(\"Failed to dial: %v\\n\", err) return } defer conn.Close() // 客户端可以继续使用这个连接进行RPC调用 // ... } 在这个例子中，我们创建了一个上下文，设置了5秒的超时时间。然后，我们使用WithDefaultCallOptions选项为通过连接发起的所有RPC调用设置默认的内容子类型为\"json\"。最后，我们使用这些选项来建立与服务器端口50051的gRPC连接。如果连接成功，客户端可以继续使用这个连接进行RPC调用。 ForceCodec(codec) 注意:此API是实验性的，可能会在以后的版本中更改或删除。 // ForceCodec returns a CallOption that will set codec to be used for all // request and response messages for a call. The result of calling Name() will // be used as the content-subtype after converting to lowercase, unless // CallContentSubtype is also used. // // See Content-Type on // https://github.com/grpc/grpc/blob/master/doc/PROTOCOL-HTTP2.md#requests for // more details. Also see the documentation on RegisterCodec and // CallContentSubtype for more details on the interaction between Codec and // content-subtype. // // This function is provided for advanced users; prefer to use only // CallContentSubtype to select a registered codec instead. // // # Experimental // // Notice: This API is EXPERIMENTAL and may be changed or removed in a // later release. func ForceCodec(codec encoding.Codec) CallOption { return ForceCodecCallOption{Codec: codec} } 详解 用于强制指定一个编解码器（Codec）用于RPC调用的所有请求和响应消息。这个编解码器会覆盖任何通过CallContentSubtype设置的内容子类型所选择的编解码器。 作用： 强制编解码器：允许客户端在RPC调用中强制使用指定的编解码器，而不受内容子类型的影响。 定制消息编码：当需要自定义消息的编码方式时，可以使用这个函数来指定编解码器。 使用场景： 协议兼容性：当客户端和服务器端使用不同的编解码器时，可以通过设置不同的编解码器来实现兼容性。 内容格式调整：在需要调整RPC调用内容格式时，可以通过设置不同的编解码器来实现。 package main import ( \"context\" \"fmt\" \"google.golang.org/grpc\" \"time\" ) func main() { ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second) defer cancel() // 设置RPC调用的编解码器为JSON opts := []grpc.DialOption{ grpc.WithDefaultCallOptions(grpc.ForceCodec(\u0026jsonpb.Marshaler{})), } conn, err := grpc.DialContext(ctx, \"localhost:50051\", opts...) if err != nil { fmt.Printf(\"Failed to dial: %v\\n\", err) return } defer conn.Close() // 客户端可以继续使用这个连接进行RPC调用 // ... } 在这个例子中，我们创建了一个上下文，设置了5秒的超时时间。然后，我们使用WithDefaultCallOptions选项为通过连接发起的所有RPC调用设置默认的编解码器为JSON。最后，我们使用这些选项来建立与服务器端口50051的gRPC连接。如果连接成功，客户端可以继续使用这个连接进行RPC调用。 ForceCodecV2(codec) 注意:此API是实验性的，可能会在以后的版本中更改或删除。 // ForceCodecV2 returns a CallOption that will set codec to be used for all // request and response messages for a call. The result of calling Name() will // be used as the content-subtype after converting to lowercase, unless // CallContentSubtype is also used. // // See Content-Type on // https://github.com/grpc/grpc/blob/master/doc/PROTOCOL-HTTP2.md#requests for // more details. Also see the documentation on RegisterCodec and // CallContentSubtype for more details on the interaction between Codec and // content-subtype. // // This function is provided for advanced users; prefer to use only // CallContentSubtype to select a registered codec instead. // // # Experimental // // Notice: This API is EXPERIMENTAL and may be changed or removed in a // later release. func ForceCodecV2(codec encoding.CodecV2) CallOption { return ForceCodecV2CallOption{CodecV2: codec} } 详解 用于在gRPC v2版本中强制指定一个编解码器（Codec）用于RPC调用的所有请求和响应消息。这个编解码器会覆盖任何通过CallContentSubtype设置的内容子类型所选择的编解码器。 作用： 强制编解码器：允许客户端在RPC调用中强制使用指定的编解码器，而不受内容子类型的影响。 定制消息编码：当需要自定义消息的编码方式时，可以使用这个函数来指定编解码器。 使用场景： 协议兼容性：当客户端和服务器端使用不同的编解码器时，可以通过设置不同的编解码器来实现兼容性。 内容格式调整：在需要调整RPC调用内容格式时，可以通过设置不同的编解码器来实现。 package main import ( \"context\" \"fmt\" \"google.golang.org/grpc\" \"time\" ) func main() { ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second) defer cancel() // 设置RPC调用的编解码器为JSON opts := []grpc.DialOption{ grpc.WithDefaultCallOptions(grpc.ForceCodecV2(\u0026jsonpb.Marshaler{})), } conn, err := grpc.DialContext(ctx, \"localhost:50051\", opts...) if err != nil { fmt.Printf(\"Failed to dial: %v\\n\", err) return } defer conn.Close() // 客户端可以继续使用这个连接进行RPC调用 // ... } 在这个例子中，我们创建了一个上下文，设置了5秒的超时时间。然后，我们使用WithDefaultCallOptions选项为通过连接发起的所有RPC调用设置默认的编解码器为JSON。最后，我们使用这些选项来建立与服务器端口50051的gRPC连接。如果连接成功，客户端可以继续使用这个连接进行RPC调用。 需要注意的是，ForceCodecV2 函数是gRPC v2版本中的一个实验性API，可能会在未来的gRPC版本中更改或移除。因此，在生产环境中使用这个函数之前，应该仔细评估其稳定性和适用性。 Header(md) Header返回一个calllooptions，用于检索一元RPC的Header元数据。 在 gRPC 中，grpc.Header 是一个 grpc.CallOption，它用于在客户端接收来自服务端的响应头部元数据。响应头部元数据通常包含有关响应的额外信息，如状态码、警告或其他自定义头部字段。 // Header returns a CallOptions that retrieves the header metadata // for a unary RPC. func Header(md *metadata.MD) CallOption { return HeaderCallOption{HeaderAddr: md} } 使用示例 首先，你需要创建一个 metadata.MD 类型的变量来存储响应的头部元数据。 var headerMD metadata.MD 当你发起 gRPC 调用时，将 grpc.Header 选项添加到调用选项列表中，并将你创建的 metadata.MD 容器传递给它。 import ( \"context\" \"google.golang.org/grpc\" \"google.golang.org/grpc/metadata\" ) func main() { // 假设 client 是一个 gRPC 客户端实例，req 是请求的结构体实例 // resp 是响应的结构体实例，ctx 是上下文 // 在这个例子中，SomeUnaryRPC 是一个一元 gRPC 调用方法，req 是请求消息，resp 是响应消息。 // grpc.Header(\u0026headerMD) 选项告诉 gRPC 客户端在调用完成时填充 headerMD 变量。 // 发起调用并使用 grpc.Header 选项 resp, err := client.SomeUnaryRPC(ctx, req, grpc.Header(\u0026headerMD)) if err != nil { // 处理错误 log.Fatalf(\"RPC failed: %v\", err) } // 检查头部元数据 if headerVal, ok := headerMD[\"header-key\"]; ok { // 使用 headerVal log.Printf(\"Header 'header-key': %v\", headerVal) } } 调用完成后，你可以检查 headerMD 变量来读取服务端发送的头部元数据。在上面的代码示例中，我们检查了是否存在一个名为 “header-key” 的头部，并打印了它的值。 请注意以下几点： grpc.Header 选项仅用于获取响应头部元数据，并不影响响应的正文。 在一元调用中，头部元数据通常在响应正文之前发送，所以你可以在读取响应正文之前检查头部元数据。 如果你想要在调用结束时获取尾部元数据，可以使用 grpc.Trailer 选项。 在流式调用（如服务器流或客户端流）中，头部元数据同样可以通过 grpc.Header 选项在首次读取消息之前获取。 使用 grpc.Header 可以帮助你在客户端处理服务端发送的额外信息，例如进行认证、日志记录或其他业务逻辑处理。 Header 和 Trailer 区别 在 gRPC 中，Header 和 Trailer 都用于传递元数据，但它们在 RPC 调用中的使用时机和目的有所不同： Header： 发送时机：Header 通常在 RPC 调用开始时发送，即在响应消息之前发送。 内容：它们通常包含与请求相关的元数据，比如请求的身份验证信息、内容类型、压缩算法等。 用途：Header 可以用来影响请求的处理，比如授权检查或者请求路由。 读取时机：在服务器端，Header 可以在处理请求的任何时间点读取；在客户端，通常在发送请求后立即读取响应的 Header。 Trailer： 发送时机：Trailer 在 RPC 调用结束时发送，即在所有响应消息发送完毕后发送。 内容：它们通常包含关于整个调用过程的状态信息，比如状态码、错误消息或者调用持续时间等。 用途：Trailer 用于提供关于整个调用结果的信息，特别是如果调用失败，它们可以提供额外的错误详情。 读取时机：在服务器端，Trailer 通常在响应发送完毕后设置；在客户端，通常在调用完成（成功或失败）后读取 Trailer。 主要区别： 发送时间点：Header 在调用开始时发送，而 Trailer 在调用结束时发送。 内容类型：Header 通常包含请求相关的元数据，Trailer 则包含响应相关的元数据。 读取时机：Header 在处理请求之前或期间读取，Trailer 在响应结束后读取。 在实际应用中，Header 和 Trailer 的使用取决于特定的需求和场景。例如，如果你需要在请求被完全处理之前就提供一些信息，那么使用 Header 是合适的；如果你需要在请求处理完毕后提供状态信息，那么使用 Trailer 是更好的选择。 MaxCallRecvMsgSize(bytes) MaxCallRecvMsgSize返回一个CallOption，它设置客户端可以接收的最大消息大小(以字节为单位)。如果没有设置，gRPC使用默认的4MB。 它允许你设置客户端接收消息的最大大小。这个选项可以用来覆盖 gRPC 默认的最大接收消息大小限制，这对于处理大型消息非常有用。 默认情况下，gRPC 限制了客户端和服务端可以发送和接收的消息大小，这个限制在 gRPC-Go 中默认设置为 4MB。如果你预期会接收到大于这个大小的消息，你可以使用 grpc.MaxCallRecvMsgSize 来增加这个限制。 // MaxCallRecvMsgSize returns a CallOption which sets the maximum message size // in bytes the client can receive. If this is not set, gRPC uses the default // 4MB. func MaxCallRecvMsgSize(bytes int) CallOption { return MaxRecvMsgSizeCallOption{MaxRecvMsgSize: bytes} } 使用示例 首先，你需要确定你希望的最大消息大小。这通常是一个整数值，表示字节数。 const maxRecvMsgSize = 10 * 1024 * 1024 // 10 MB 在你发起 gRPC 调用时，将 grpc.MaxCallRecvMsgSize 选项添加到调用选项列表中，并传递你设定的最大消息大小。 import ( \"context\" \"google.golang.org/grpc\" ) func main() { // 假设 client 是一个 gRPC 客户端实例，req 是请求的结构体实例 // resp 是响应的结构体实例，ctx 是上下文 // 在这个例子中，SomeUnaryRPC 是一个一元 gRPC 调用方法， // 我们通过 grpc.MaxCallRecvMsgSize(maxRecvMsgSize) 选项设置了最大接收消息大小。 // 发起调用并设置最大接收消息大小 err, resp := client.SomeUnaryRPC(ctx, req, grpc.MaxCallRecvMsgSize(maxRecvMsgSize)) if err != nil { // 处理错误 log.Fatalf(\"RPC failed: %v\", err) } // ... } 注意： 设置一个过大的 MaxCallRecvMsgSize 可能会增加客户端和服务端的内存使用，并可能导致性能问题。 如果你接收到一个超出设定大小的消息，gRPC 会返回一个错误，通常为 rpc error: code = ResourceExhausted desc = grpc: received message larger than max (X vs. Y)，其中 X 是接收到的消息大小，Y 是最大允许大小。 你也可以在创建客户端连接时全局设置最大接收消息大小，使用 grpc.WithDefaultCallOptions(grpc.MaxCallRecvMsgSize(maxRecvMsgSize)) 选项。 使用 grpc.MaxCallRecvMsgSize 可以确保你的客户端能够安全地处理大型消息，而不会因为默认大小限制而失败。 MaxCallSendMsgSize(bytes) MaxCallSendMsgSize返回一个CallOption，它设置客户端可以发送的最大消息大小(以字节为单位)。如果没有设置，gRPC使用默认的math.MaxInt32。 它允许你设置客户端发送消息的最大大小。这个选项可以用来覆盖 gRPC 默认的最大发送消息大小限制，这对于发送大型消息非常有用。 // MaxCallSendMsgSize returns a CallOption which sets the maximum message size // in bytes the client can send. If this is not set, gRPC uses the default // `math.MaxInt32`. func MaxCallSendMsgSize(bytes int) CallOption { return MaxSendMsgSizeCallOption{MaxSendMsgSize: bytes} } 使用示例 首先，你需要确定你希望的最大消息大小。这通常是一个整数值，表示字节数。 const maxSendMsgSize = 10 * 1024 * 1024 // 10 MB 在你发起 gRPC 调用时，将 grpc.MaxCallSendMsgSize 选项添加到调用选项列表中，并传递你设定的最大消息大小。 import ( \"context\" \"google.golang.org/grpc\" ) func main() { // 假设 client 是一个 gRPC 客户端实例，req 是请求的结构体实例 // resp 是响应的结构体实例，ctx 是上下文 // 在这个例子中，SomeUnaryRPC 是一个一元 gRPC 调用方法， // 我们通过 grpc.MaxCallSendMsgSize(maxSendMsgSize) 选项设置了最大发送消息大小。 // 发起调用并设置最大发送消息大小 resp, err := client.SomeUnaryRPC(ctx, req, grpc.MaxCallSendMsgSize(maxSendMsgSize)) if err != nil { // 处理错误 log.Fatalf(\"RPC failed: %v\", err) } // ... } 注意： 设置一个过大的 MaxCallSendMsgSize 可能会增加客户端和服务端的内存使用，并可能导致性能问题。 如果你发送的消息超出设定大小，gRPC 会返回一个错误，通常为 rpc error: code = ResourceExhausted desc = grpc: trying to send message larger than max (X vs. Y)，其中 X 是尝试发送的消息大小，Y 是最大允许大小。 你也可以在创建客户端连接时全局设置最大发送消息大小，使用 grpc.WithDefaultCallOptions(grpc.MaxCallSendMsgSize(maxSendMsgSize)) 选项。 使用 grpc.MaxCallSendMsgSize 可以确保你的客户端能够安全地发送大型消息，而不会因为默认大小限制而失败。 MaxRetryRPCBufferSize(bytes) MaxRetryRPCBufferSize返回一个CallOption，它限制了为重试目的缓冲RPC请求所使用的内容量。 注意:此API是实验性的，可能会在以后的版本中更改或删除。 // MaxRetryRPCBufferSize returns a CallOption that limits the amount of memory // used for buffering this RPC's requests for retry purposes. // // # Experimental // // Notice: This API is EXPERIMENTAL and may be changed or removed in a // later release. func MaxRetryRPCBufferSize(bytes int) CallOption { return MaxRetryRPCBufferSizeCallOption{bytes} } 详解 用于设置用于重试目的的RPC请求缓冲区的大小限制。这个选项用于控制内存的使用，特别是在需要多次重试RPC请求时。 作用： 内存控制：允许客户端控制用于重试目的的RPC请求缓冲区的大小，以防止内存耗尽。 性能优化：通过限制缓冲区大小，可以优化客户端在重试RPC请求时的性能。 使用场景： 高重试策略：在需要频繁重试RPC请求的场景中，可以通过设置缓冲区大小限制来避免内存问题。 资源管理：在处理大量重试请求时，通过设置合理的缓冲区大小，可以更好地管理客户端资源。 package main import ( \"context\" \"fmt\" \"google.golang.org/grpc\" \"time\" ) func main() { ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second) defer cancel() // 设置RPC调用的最大重试请求缓冲区大小为1MB opts := []grpc.DialOption{ grpc.WithDefaultCallOptions(grpc.MaxRetryRPCBufferSize(1024 * 1024)), } conn, err := grpc.DialContext(ctx, \"localhost:50051\", opts...) if err != nil { fmt.Printf(\"Failed to dial: %v\\n\", err) return } defer conn.Close() // 客户端可以继续使用这个连接进行RPC调用 // ... } 在这个例子中，我们创建了一个上下文，设置了5秒的超时时间。然后，我们使用WithDefaultCallOptions选项为通过连接发起的所有RPC调用设置默认的最大重试请求缓冲区大小为1MB。最后，我们使用这些选项来建立与服务器端口50051的gRPC连接。如果连接成功，客户端可以继续使用这个连接进行RPC调用。 需要注意的是，MaxRetryRPCBufferSize 函数是gRPC框架中的一个实验性API，可能会在未来的gRPC版本中更改或移除。因此，在生产环境中使用这个函数之前，应该仔细评估其稳定性和适用性。 OnFinish(onFinish) OnFinish返回一个callloption，它配置一个回调，当调用完成时调用。传递给回调的错误是RPC的状态，可能是nil。提供的onFinish回调只会被gRPC调用一次。这主要由流拦截器使用，当RPC完成时将收到通知以及有关RPC状态的信息。 注意:此API是实验性的，可能会在以后的版本中更改或删除。 // OnFinish returns a CallOption that configures a callback to be called when // the call completes. The error passed to the callback is the status of the // RPC, and may be nil. The onFinish callback provided will only be called once // by gRPC. This is mainly used to be used by streaming interceptors, to be // notified when the RPC completes along with information about the status of // the RPC. // // # Experimental // // Notice: This API is EXPERIMENTAL and may be changed or removed in a // later release. func OnFinish(onFinish func(err error)) CallOption { return OnFinishCallOption{ OnFinish: onFinish, } } 详解 用于配置一个回调函数，当RPC调用完成时（无论是成功还是失败）都会被调用。这个回调函数接收一个错误参数，该错误表示RPC调用的状态，如果RPC成功完成，则该错误为nil。 作用： 状态通知：允许客户端在RPC调用完成后收到通知，以便进行相应的处理，例如清理资源、记录日志等。 错误处理：当RPC调用失败时，客户端可以捕获错误并进行适当的错误处理。 使用场景： 资源管理：在RPC调用完成后，客户端可以释放资源或执行其他清理操作。 日志记录：记录RPC调用的完成状态，以便于后续分析和调试。 package main import ( \"context\" \"fmt\" \"google.golang.org/grpc\" \"time\" ) func main() { ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second) defer cancel() // 设置RPC调用的完成回调 opts := []grpc.DialOption{ grpc.WithDefaultCallOptions(grpc.OnFinish(func(err error) { if err != nil { fmt.Printf(\"RPC failed: %v\\n\", err) } else { fmt.Println(\"RPC completed successfully\") } })), } conn, err := grpc.DialContext(ctx, \"localhost:50051\", opts...) if err != nil { fmt.Printf(\"Failed to dial: %v\\n\", err) return } defer conn.Close() // 客户端可以继续使用这个连接进行RPC调用 // ... } 在这个例子中，我们创建了一个上下文，设置了5秒的超时时间。然后，我们使用WithDefaultCallOptions选项为通过连接发起的所有RPC调用设置默认的完成回调。当RPC调用完成后，无论成功还是失败，都会调用这个回调函数，并打印出相应的信息。最后，我们使用这些选项来建立与服务器端口50051的gRPC连接。如果连接成功，客户端可以继续使用这个连接进行RPC调用。 需要注意的是，OnFinish 函数是gRPC框架中的一个实验性API，可能会在未来的gRPC版本中更改或移除。因此，在生产环境中使用这个函数之前，应该仔细评估其稳定性和适用性。 Peer（p） Peer返回一个callloption，用于检索一元RPC的对等信息。在RPC完成后，peer字段将被填充。 // Peer returns a CallOption that retrieves peer information for a unary RPC. // The peer field will be populated *after* the RPC completes. func Peer(p *peer.Peer) CallOption { return PeerCallOption{PeerAddr: p} } 详解 用于获取与单向RPC（unary RPC）相关的对端（peer）信息。这个信息会在RPC调用完成后填充到p指向的peer.Peer结构体中。 作用： 对端信息获取：允许客户端在RPC调用完成后获取对端的信息，例如对端地址、端口、认证信息等。 安全性检查：通过获取对端信息，客户端可以进行安全性检查，例如验证对端的身份。 使用场景： 安全性验证：在需要验证对端身份或进行安全性检查的场景中，可以通过获取对端信息来验证。 性能监控：在需要监控RPC调用性能的场景中，可以通过获取对端信息来分析网络延迟和带宽使用情况。 package main import ( \"context\" \"fmt\" \"google.golang.org/grpc\" \"time\" ) func main() { ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second) defer cancel() // 设置RPC调用的对端信息收集 opts := []grpc.DialOption{ grpc.WithDefaultCallOptions(grpc.Peer(new(peer.Peer))), } conn, err := grpc.DialContext(ctx, \"localhost:50051\", opts...) if err != nil { fmt.Printf(\"Failed to dial: %v\\n\", err) return } defer conn.Close() // 客户端可以继续使用这个连接进行RPC调用 // ... } 在这个例子中，我们创建了一个上下文，设置了5秒的超时时间。然后，我们使用WithDefaultCallOptions选项为通过连接发起的所有RPC调用设置默认的对端信息收集。当RPC调用完成后，peer.Peer结构体中的信息将被填充。最后，我们使用这些选项来建立与服务器端口50051的gRPC连接。如果连接成功，客户端可以继续使用这个连接进行RPC调用。 需要注意的是，Peer 函数是gRPC框架中的一个实验性API，可能会在未来的gRPC版本中更改或移除。因此，在生产环境中使用这个函数之前，应该仔细评估其稳定性和适用性。 PerRPCCredentials(creds) PerRPCCredentials 返回为调用设置 credentials.PerRPCCredentials 的 CallOption。 该方法可以指定方法带上指定的认证，而不是使用全局的 grpc.WithPerRPCCredentials。 // PerRPCCredentials returns a CallOption that sets credentials.PerRPCCredentials // for a call. func PerRPCCredentials(creds credentials.PerRPCCredentials) CallOption { return PerRPCCredsCallOption{Creds: creds} } 使用示例 全局配置 PerRPCCredentials。 func main() { // 配置ssl，\"*.heliu.site\"在实际开发中从浏览器中取获取，证书路径使用绝对路径 creds, _ := credentials.NewClientTLSFromFile( \"/root/workspace/learn-grpc/key/test.pem\", \"*.heliu.site\", ) var opts []grpc.DialOption // 不带TLS这里是grpc.WithTransportCredentials(insecure.NewCredentials()) opts = append(opts, grpc.WithTransportCredentials(creds)) opts = append(opts, grpc.WithPerRPCCredentials(\u0026ClientTokenAuth{})) // 添加客户端拦截器 opts = append(opts, grpc.WithUnaryInterceptor(interceptor.UnaryClientInterceptor())) // 添加流拦截器 opts = append(opts, grpc.WithStreamInterceptor(interceptor.StreamClientInterceptor())) // 连接server端，使用ssl加密通信 conn, err := grpc.NewClient(\"127.0.0.1:9090\", opts...) if err != nil { log.Fatalf(\"did not connect: %v\", err) } defer conn.Close() // 建立连接 client := pb.NewSayHelloClient(conn) var header metadata.MD var tr metadata.MD var opts1 []grpc.CallOption = []grpc.CallOption{ grpc.WaitForReady(false), grpc.Header(\u0026header), grpc.Trailer(\u0026tr), } // 执行rpc调用(这个方法在服务器端来实现并返回结构) resp, err := client.SayHello(ctx, \u0026pb.HelloRequest{RequestName: \"gh\", Age: 12}, opts1...) if err != nil { fmt.Printf(\"%v\\n\", err) return } //... } 指定方法设置。 func main() { // 配置ssl，\"*.heliu.site\"在实际开发中从浏览器中取获取，证书路径使用绝对路径 creds, _ := credentials.NewClientTLSFromFile( \"/root/workspace/learn-grpc/key/test.pem\", \"*.heliu.site\", ) var opts []grpc.DialOption // 不带TLS这里是grpc.WithTransportCredentials(insecure.NewCredentials()) opts = append(opts, grpc.WithTransportCredentials(creds)) //opts = append(opts, grpc.WithPerRPCCredentials(\u0026ClientTokenAuth{})) // 添加客户端拦截器 opts = append(opts, grpc.WithUnaryInterceptor(interceptor.UnaryClientInterceptor())) // 添加流拦截器 opts = append(opts, grpc.WithStreamInterceptor(interceptor.StreamClientInterceptor())) // 连接server端，使用ssl加密通信 conn, err := grpc.NewClient(\"127.0.0.1:9090\", opts...) if err != nil { log.Fatalf(\"did not connect: %v\", err) } defer conn.Close() // 建立连接 client := pb.NewSayHelloClient(conn) var header metadata.MD var tr metadata.MD var opts1 []grpc.CallOption = []grpc.CallOption{ grpc.WaitForReady(false), grpc.Header(\u0026header), grpc.Trailer(\u0026tr), grpc.PerRPCCredentials(\u0026ClientTokenAuth{}), } // 执行rpc调用(这个方法在服务器端来实现并返回结构) resp, err := client.SayHello(ctx, \u0026pb.HelloRequest{RequestName: \"gh\", Age: 12}, opts1...) if err != nil { fmt.Printf(\"%v\\n\", err) return } //... } StaticMethod() StaticMethod返回一个callloption，它指定正在对静态方法进行调用，这意味着该方法在编译时是已知的，并且在运行时不会更改。这可以用作统计插件的信号，表明该方法可以安全地作为度量的关键。 // StaticMethod returns a CallOption which specifies that a call is being made // to a method that is static, which means the method is known at compile time // and doesn't change at runtime. This can be used as a signal to stats plugins // that this method is safe to include as a key to a measurement. func StaticMethod() CallOption { return StaticMethodCallOption{} } 详解 作用： 统计测量：允许客户端在RPC调用中指定方法是静态的，这样统计插件就可以安全地将这些方法作为统计测量（如响应时间）的键。 性能分析：在需要分析RPC调用性能的场景中，通过指定方法是静态的，可以更准确地进行性能分析。 使用场景： 性能监控：在需要监控RPC调用性能的场景中，通过指定方法是静态的，可以更准确地进行性能监控。 统计插件集成：在集成统计插件时，可以通过使用StaticMethod来确保统计的准确性。 用于指定一个RPC调用是静态方法调用。静态方法指的是在编译时已知且在运行时不会更改的方法。这个信息可以被统计插件（stats plugins）用来确定哪些方法可以安全地作为测量（measurement）的键。 package main import ( \"context\" \"fmt\" \"google.golang.org/grpc\" \"time\" ) func main() { ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second) defer cancel() // 设置RPC调用的静态方法标志 opts := []grpc.DialOption{ grpc.WithDefaultCallOptions(grpc.StaticMethod()), } conn, err := grpc.DialContext(ctx, \"localhost:50051\", opts...) if err != nil { fmt.Printf(\"Failed to dial: %v\\n\", err) return } defer conn.Close() // 客户端可以继续使用这个连接进行RPC调用 // ... } 在这个例子中，我们创建了一个上下文，设置了5秒的超时时间。然后，我们使用WithDefaultCallOptions选项为通过连接发起的所有RPC调用设置默认的静态方法标志。当RPC调用完成后，统计插件可以利用这个信息来更准确地进行性能分析。最后，我们使用这些选项来建立与服务器端口50051的gRPC连接。如果连接成功，客户端可以继续使用这个连接进行RPC调用。 需要注意的是，StaticMethod 函数是gRPC框架中的一个实验性API，可能会在未来的gRPC版本中更改或移除。因此，在生产环境中使用这个函数之前，应该仔细评估其稳定性和适用性。 Trailer(md) Trailer返回一个calllooptions，用于检索一元RPC的Trailer元数据。 // Trailer returns a CallOptions that retrieves the trailer metadata // for a unary RPC. func Trailer(md *metadata.MD) CallOption { return TrailerCallOption{TrailerAddr: md} } 详解 用于在单向RPC（unary RPC）调用完成后获取响应的尾随元数据（trailer metadata）。尾随元数据是RPC响应的元数据的一部分，它会在响应主体之后传输。 作用： 元数据获取：允许客户端在RPC调用完成后获取响应的尾随元数据，以便进行后续处理，例如日志记录、统计分析等。 使用场景： 日志记录：在需要记录RPC调用响应的尾随元数据以进行日志记录的场景中。 统计分析：在需要分析RPC调用响应的尾随元数据以进行统计分析的场景中。 package main import ( \"context\" \"fmt\" \"google.golang.org/grpc\" \"time\" ) func main() { ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second) defer cancel() // 设置RPC调用的尾随元数据获取 opts := []grpc.DialOption{ grpc.WithDefaultCallOptions(grpc.Trailer(\u0026metadata.MD{})), } conn, err := grpc.DialContext(ctx, \"localhost:50051\", opts...) if err != nil { fmt.Printf(\"Failed to dial: %v\\n\", err) return } defer conn.Close() // 客户端可以继续使用这个连接进行RPC调用 // ... } 在这个例子中，我们创建了一个上下文，设置了5秒的超时时间。然后，我们使用WithDefaultCallOptions选项为通过连接发起的所有RPC调用设置默认的尾随元数据获取。当RPC调用完成后，metadata.MD结构体中的元数据将被填充。最后，我们使用这些选项来建立与服务器端口50051的gRPC连接。如果连接成功，客户端可以继续使用这个连接进行RPC调用。 UseCompressor(name) UseCompressor返回一个CallOption，用来设置发送请求时使用的压缩器。如果也设置了WithCompressor，则UseCompressor具有更高的优先级。 注意：此API是实验性的，可能会在以后的版本中更改或删除。 // UseCompressor returns a CallOption which sets the compressor used when // sending the request. If WithCompressor is also set, UseCompressor has // higher priority. // // # Experimental // // Notice: This API is EXPERIMENTAL and may be changed or removed in a // later release. func UseCompressor(name string) CallOption { return CompressorCallOption{CompressorType: name} } 在 gRPC 中，UseCompressor 是一个客户端或服务器端的选项，它允许你指定在 gRPC 调用中使用的压缩算法。gRPC 支持多种压缩算法，例如 gzip、deflate、zlib 等。“google.golang.org/grpc/encoding/gzip”。 通常，gRPC 服务器和客户端之间的压缩是自动处理的，不需要手动干预。如果你需要使用非标准的压缩算法，你可能需要在 gRPC 的 encoding 包中实现自定义的编码器和解码器。 详解 用于指定在发送请求时使用的压缩器。这个选项允许客户端选择一个压缩器来压缩请求体，以减少网络传输的数据量。 作用： 压缩数据传输：允许客户端压缩发送到服务器的请求数据，以减少网络带宽的使用。 性能优化：通过压缩数据，可以优化客户端和服务器之间的数据传输性能。 使用场景： 带宽优化：在网络带宽有限或网络延迟较高的场景中，通过压缩数据可以优化性能。 性能调优：在需要优化RPC调用性能的场景中，可以通过设置压缩器来优化传输效率。 package main import ( \"context\" \"fmt\" \"google.golang.org/grpc\" \"time\" ) func main() { ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second) defer cancel() // 设置RPC调用的压缩器为GZIP opts := []grpc.DialOption{ grpc.WithDefaultCallOptions(grpc.UseCompressor(\"gzip\")), } conn, err := grpc.DialContext(ctx, \"localhost:50051\", opts...) if err != nil { fmt.Printf(\"Failed to dial: %v\\n\", err) return } defer conn.Close() // 客户端可以继续使用这个连接进行RPC调用 // ... } 在这个例子中，我们创建了一个上下文，设置了5秒的超时时间。然后，我们使用WithDefaultCallOptions选项为通过连接发起的所有RPC调用设置默认的压缩器为GZIP。最后，我们使用这些选项来建立与服务器端口50051的gRPC连接。如果连接成功，客户端可以继续使用这个连接进行RPC调用。 WaitForReady(waitForReady) WaitForReady在客户端处于TRANSIENT_FAILURE状态时配置RPC的行为，当所有地址连接失败时发生。 如果waitForReady为false, RPC将立即失败。否则，客户端将等待，直到连接可用或RPC的截止日期到达。 缺省情况下，rpc不等待准备好。 // WaitForReady configures the RPC's behavior when the client is in // TRANSIENT_FAILURE, which occurs when all addresses fail to connect. If // waitForReady is false, the RPC will fail immediately. Otherwise, the client // will wait until a connection becomes available or the RPC's deadline is // reached. // // By default, RPCs do not \"wait for ready\". func WaitForReady(waitForReady bool) CallOption { return FailFastCallOption{FailFast: !waitForReady} } 使用示例 在 gRPC 中，WaitForReady 是一个调用选项，它控制着 RPC 在尝试建立连接时应该如何处理网络不可用或服务不可达的情况。 默认情况下，如果没有立即建立连接，gRPC 调用会快速失败。但是，如果你设置了 WaitForReady 选项，那么 gRPC 将会等待连接准备好再发送 RPC 请求。这在服务端可能暂时不可用或者网络状况不佳的情况下非常有用。 package main import ( \"context\" \"log\" \"time\" \"google.golang.org/grpc\" \"google.golang.org/grpc/codes\" ) func main() { // 假设你有一个服务端的地址 serverAddr := \"localhost:50051\" // 连接到 gRPC 服务器 conn, err := grpc.Dial(serverAddr, grpc.WithInsecure(), grpc.WithBlock()) if err != nil { log.Fatalf(\"did not connect: %v\", err) } defer conn.Close() c := NewYourServiceClient(conn) // 设置 context，这里使用了 context.WithTimeout 来设置超时时间 ctx, cancel := context.WithTimeout(context.Background(), time.Second*10) defer cancel() // 使用 WaitForReady 选项 callOpts := []grpc.CallOption{grpc.WaitForReady(true)} // 假设有一个叫做 YourRPCMethod 的方法 _, err = c.YourRPCMethod(ctx, \u0026YourRequest{}, callOpts...) if err != nil { // 检查错误是否由于服务不可用 if grpc.Code(err) == codes.Unavailable { log.Printf(\"Server is unavailable, but we are waiting for it to be ready again\") } else { log.Fatalf(\"could not call: %v\", err) } } // 其他代码逻辑... } 在上面的代码中，YourServiceClient 和 YourRPCMethod 应该替换为你的具体服务客户端和方法。通过传递 grpc.WaitForReady(true) 到 YourRPCMethod，客户端会等待直到连接准备好，或者直到超时。 使用 WaitForReady 时需要谨慎，因为它可能会导致客户端在等待可用连接时挂起，如果服务端长时间不可用，这可能会导致客户端长时间等待。因此，通常建议与超时选项一起使用。 type Peer 包对等体定义了与rpc和相应的实用程序相关联的各种对等体信息。 NewContext(ctx, p) NewContext 创建一个附加对等信息的 context。 func NewContext(ctx context.Context, p *Peer) context.Context type Peer Peer包含RPC的对端信息，如地址、认证信息等。 type Peer struct { // Addr为对端地址。 Addr net.Addr // LocalAddr是本地地址。 LocalAddr net.Addr // AuthInfo是传输的认证信息。 // 如果没有使用传输安全性，则为nil。 AuthInfo credentials.AuthInfo } FromContext(ctx) 如果对等体存在，FromContext返回ctx形式的对等体信息。 func FromContext(ctx context.Context) (p *Peer, ok bool) (p) String() String确保Peer类型实现Stringer接口，以便有效地打印带有peerKey值的上下文。 func (p *Peer) String() string ",
  "wordCount" : "8408",
  "inLanguage": "zh",
  "image": "https://helium-chain.github.io/favicon-32x32.png","datePublished": "2024-09-17T00:00:00Z",
  "dateModified": "2024-09-17T00:00:00Z",
  "author":[{
    "@type": "Person",
    "name": "helium"
  }],
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://helium-chain.github.io/posts/grpc/grpc-client/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Helium",
    "logo": {
      "@type": "ImageObject",
      "url": "https://helium-chain.github.io/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://helium-chain.github.io/" accesskey="h" title="Blog (Alt + H)">
                <img src="https://helium-chain.github.io/helium.png" alt="" aria-label="logo"
                    height="35">Blog</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://helium-chain.github.io/" title="主页">
                    <span>Home</span>
                </a>
            </li>
            <li>
                <a href="https://helium-chain.github.io/posts" title="文章">
                    <span>Article</span>
                </a>
            </li>
            <li>
                <a href="https://helium-chain.github.io/archives" title="时间轴">
                    <span>Archive</span>
                </a>
            </li>
            <li>
                <a href="https://helium-chain.github.io/tags/" title="标签">
                    <span>Tag</span>
                </a>
            </li>
            <li>
                <a href="https://helium-chain.github.io/search/" title="搜索 (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
            <li>
                <a href="https://helium-chain.github.io/support" title="打赏">
                    <span>🫶Help</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">


<article class="post" autonumbering>
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://helium-chain.github.io/">主页</a>&nbsp;»&nbsp;<a href="https://helium-chain.github.io/posts/">Article</a>&nbsp;»&nbsp;<a href="https://helium-chain.github.io/posts/grpc/">gRPC</a></div>
    <h1 class="post-title entry-hint-parent">
      grpc.Client
    </h1>
    <div class="post-meta">










<span class="x-post-meta-item"><svg t="1720837714681" class="icon" viewBox="0 0 1084 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="7520" width="200" height="200"><path d="M123.47509 1023.984942a123.565437 123.565437 0 0 1-123.505206-123.32451V243.863302A123.565437 123.565437 0 0 1 123.47509 120.568908h171.630374V26.06529a26.050232 26.050232 0 0 1 52.070349 0v94.503618h377.592848V26.06529a26.050232 26.050232 0 0 1 52.100464 0v94.503618h183.797189A123.565437 123.565437 0 0 1 1084.171519 243.863302v656.79713A123.565437 123.565437 0 0 1 960.666314 1023.984942H123.47509z m-71.404741-123.32451A71.434857 71.434857 0 0 0 123.47509 971.974825h837.191224a71.434857 71.434857 0 0 0 71.404741-71.314393V442.326922l-946.361273-3.824716a25.598494 25.598494 0 0 1-5.84248-0.692665l-27.796953-6.444798v469.295689zM123.47509 172.579025a71.434857 71.434857 0 0 0-71.404741 71.284277v149.736133l27.796953-6.444797a26.080348 26.080348 0 0 1 5.902712-0.662549l946.301041 3.824716V243.863302a71.404741 71.404741 0 0 0-71.404741-71.284277h-180.183284l-6.173754 12.859479a26.200812 26.200812 0 0 1-23.490383 14.786895 26.261043 26.261043 0 0 1-23.520499-14.786895l-6.173754-12.859479H350.819834l-6.173754 12.859479a26.200812 26.200812 0 0 1-23.490383 14.786895 26.230928 26.230928 0 0 1-23.520499-14.786895l-6.173755-12.859479H123.47509z m156.150814 578.827128a26.050232 26.050232 0 0 1-26.050232-25.990001c0-14.335157 11.68496-26.020116 26.050232-26.020116h521.697312c14.365273 0 26.050232 11.68496 26.050233 26.020116a26.050232 26.050232 0 0 1-26.050233 25.990001H279.625904z" fill="#3D3F42" p-id="7521"></path></svg><span>2024-09-17</span></span>&nbsp;<span class="x-post-meta-item"><svg t="1720839329181" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="14106" width="200" height="200"><path d="M699.270662 190.485379c-0.411369 0-0.821715 0.011256-1.227967 0.032746H507.034407a23.041786 23.041786 0 0 0-1.221828-0.031723c-12.779048 0-23.140023 10.359952-23.140023 23.139 0 12.781094 10.360975 23.141046 23.140023 23.141046v0.032746h193.458083v-0.032746c12.780071 0 23.141046-10.359952 23.141047-23.141046 0-12.780071-10.360975-23.140023-23.141047-23.140023zM979.215516 724.005508c0-142.090159-115.186416-257.277598-257.277598-257.277598-72.245418 0-137.532353 29.777187-184.262654 77.725223l45.868677 31.474852c36.227086-33.873482 84.882226-54.617945 138.393977-54.617945 111.945605 0 202.696492 90.750887 202.696492 202.695468h-43.01263l70.331835 104.289228 70.331835-104.289228H979.215516z" fill="" p-id="14107"></path><path d="M748.885664 588.843132c0-14.881942-12.06785-26.945699-26.947746-26.945698-14.883989 0-26.947745 12.063757-26.947745 26.945698v135.164423c0 14.879895 12.063757 26.945699 26.947745 26.945699h107.786889c14.881942 0 26.945699-12.063757 26.945698-26.945699s-12.063757-26.945699-26.945698-26.945699h-80.839143V588.843132zM721.937918 926.702c-111.947651 0-202.696492-90.74884-202.696492-202.696492 0-0.144286 0.004093-0.285502 0.004094-0.429788h43.004443l-70.330812-104.289228-70.331835 104.289228h43.075051c0 0.144286-0.00307 0.285502-0.00307 0.429788 0 142.091182 115.187439 257.279644 257.278621 257.279645 72.241324 0 137.530306-29.77821 184.260607-77.727269l-45.86663-31.474852c-36.227086 33.873482-84.884272 54.618968-138.393977 54.618968zM694.633039 423.38066c-1.354857-11.487635-11.120268-20.400632-22.972201-20.400632H206.362486c-12.780071 0-23.140023 10.359952-23.140023 23.138999 0 12.781094 10.359952 23.141046 23.140023 23.141047H596.949252c30.209022-13.81668 63.104223-22.76754 97.683787-25.879414zM438.548616 623.143333H206.362486c-12.780071 0-23.140023 10.358929-23.140023 23.140023 0 12.780071 10.359952 23.140023 23.140023 23.140023h219.956598a298.463626 298.463626 0 0 1 12.229532-46.280046zM506.934123 513.062192H206.362486c-12.780071 0-23.140023 10.359952-23.140023 23.139 0 12.781094 10.359952 23.140023 23.140023 23.140023H469.936487a302.241672 302.241672 0 0 1 36.997636-46.279023z" fill="" p-id="14108"></path><path d="M442.765661 835.277778a298.531164 298.531164 0 0 1-14.365173-46.150087H146.542052v-0.065491c-33.036417 0-59.81941-26.78197-59.81941-59.819411V329.36031h704.907545v100.905154a298.561863 298.561863 0 0 1 46.150086 14.996552V194.619536h-0.162706c0-53.422723-43.307342-96.728018-96.730065-96.728018h-68.89409V84.418668c0-33.037441-26.782993-59.81941-59.81941-59.81941v-0.361227h-18.87079v0.032745c-33.038464 0-59.820434 26.78197-59.820433 59.819411 0 0.109494 0.008186 0.218988 0.008186 0.328481h-0.339738v13.47285H345.203648V84.418668c0-33.037441-26.782993-59.81941-59.819411-59.81941v-0.361227h-18.872836v0.032745c-33.036417 0-59.81941 26.78197-59.81941 59.819411 0 0.109494 0.007163 0.218988 0.008186 0.328481h-0.339737v13.47285h-69.189826c-53.4217 0-96.729042 43.306318-96.729041 96.728018 0 1.701758 0.045025 3.39226 0.132006 5.071505v533.785166a98.051153 98.051153 0 0 0-0.132006 5.071506c0 53.4217 43.307342 96.728018 96.729041 96.728018v0.001023h305.595047zM86.723665 204.056466c0-33.037441 26.782993-59.81941 59.819411-59.819411 0.044002 0 0.086981 0.00307 0.130983 0.00307v-0.068561h105.968473V94.874811h0.032746a22.807449 22.807449 0 0 1-0.032746-1.215688c0-12.779048 10.360975-23.140023 23.140023-23.140023s23.140023 10.360975 23.140023 23.140023c0 0.408299-0.010233 0.812505-0.031722 1.215688h0.031722v49.297776h280.508696V94.874811h0.032745a22.807449 22.807449 0 0 1-0.032745-1.215688c0-12.779048 10.361999-23.140023 23.140023-23.140023 12.780071 0 23.141046 10.360975 23.141046 23.140023 0 0.408299-0.011256 0.812505-0.032746 1.215688h0.032746v49.297776h106.10048v0.065492c33.035394 0 59.818387 26.780947 59.818387 59.81941h0.130983V283.080264H86.723665v-79.023798z" fill="" p-id="14109"></path></svg><span>2024-09-17</span></span>&nbsp;<span class="x-post-meta-item"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2" fill="none"
     stroke-linecap="round" stroke-linejoin="round" class="feather feather-file-text" style="user-select: text;">
    <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z" style="user-select: text;"></path>
    <polyline points="14 2 14 8 20 8" style="user-select: text;"></polyline>
    <line x1="16" y1="13" x2="8" y2="13" style="user-select: text;"></line>
    <line x1="16" y1="17" x2="8" y2="17" style="user-select: text;"></line>
    <polyline points="10 9 9 9 8 9" style="user-select: text;"></polyline>
</svg><span>8408字</span></span>&nbsp;<span class="x-post-meta-item"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2" fill="none"
     stroke-linecap="round" stroke-linejoin="round">
    <path stroke="none" d="M0 0h24v24H0z" fill="none"></path>
    <circle cx="12" cy="12" r="9"></circle>
    <polyline points="12 7 12 12 15 15"></polyline>
</svg><span>40分钟</span></span>&nbsp;<span class="x-post-meta-item"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2" fill="none"
     stroke-linecap="round" stroke-linejoin="round">
    <path stroke="none" d="M0 0h24v24H0z" fill="none"></path>
    <circle cx="12" cy="7" r="4"></circle>
    <path d="M6 21v-2a4 4 0 0 1 4 -4h4a4 4 0 0 1 4 4v2"></path>
</svg><span>helium</span></span>
      <span class="x-post-meta-item">
        &nbsp;<svg t="1720840393161" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="18680" width="200" height="200"><path d="M995.125144 559.61812l-415.998603-415.998602A52.986489 52.986489 0 0 0 541.413335 127.99957H338.847348c-3.166656-26.559911-9.286635-51.046495-17.999939-71.333094C299.734146 7.333309 271.154242 0 256.00096 0c-13.939953 0-40.439864 6.339979-61.259794 48.806503-10.473298 21.366595-17.946606 48.966502-21.573261 79.193067H53.334974a53.393154 53.393154 0 0 0-53.333154 53.333154v360.078791a52.986489 52.986489 0 0 0 15.619948 37.713206l415.998602 415.998603a53.333154 53.333154 0 0 0 75.426413 0l26.286579-26.293245 26.286578 26.293245a53.426487 53.426487 0 0 0 16.719944 11.333295 21.333262 21.333262 0 0 0 36.079879 11.293295l382.705381-382.705381a53.399821 53.399821 0 0 0 0-75.426413z m-762.070774-491.998347C241.494342 50.373164 250.667645 42.666523 256.00096 42.666523c5.99998 0 16.573278 9.639968 25.646581 30.806564 6.493312 15.159949 11.333295 33.999886 14.146619 54.526483H216.16776c3.206656-23.419921 9.013303-44.359851 16.88661-60.41313z m243.819181 897.330319a10.666631 10.666631 0 0 1-15.079949 0l-415.998603-415.998603A10.573298 10.573298 0 0 1 42.668343 541.411515V181.332724a10.666631 10.666631 0 0 1 10.666631-10.666631h245.332509c0 47.853173-10.373298 92.15969-27.066575 115.632945-5.926647 8.326639-16.566611 14.186619-22.306592 16.113279C204.041135 314.752276 170.667913 356.218803 170.667913 405.331972c0 58.813136 47.853173 106.666308 106.666309 106.666308s106.666308-47.853173 106.666308-106.666308c0-47.086508-30.666564-87.139707-73.079754-101.246327C330.060711 272.705751 341.334007 223.692582 341.334007 170.666093h72.079758a10.573298 10.573298 0 0 1 7.539974 3.126656l415.998603 415.998603a10.666631 10.666631 0 0 1 0 15.079949zM341.334007 405.331972a63.999785 63.999785 0 1 1-63.999785-63.999785 64.073118 64.073118 0 0 1 63.999785 63.999785z m263.539114 559.61812a10.666631 10.666631 0 0 1-15.079949 0L563.499927 938.663513l303.625647-303.61898a53.399821 53.399821 0 0 0 0-75.426413L478.16688 170.666093h63.246455a10.573298 10.573298 0 0 1 7.539974 3.126656l415.998603 415.998603c0.239999 0.239999 0.466665 0.486665 0.666664 0.746664l0.086667 0.106666a10.666631 10.666631 0 0 1 0 13.373289l-0.086667 0.106666c-0.213333 0.259999-0.439999 0.506665-0.666664 0.746664z" fill="#5C5C66" p-id="18681"></path></svg>
        <ul class="post-tags-meta" style="display: inline-block;font-size: 14px;">
            <a href="https://helium-chain.github.io/tags/grpc/" target="_blank" rel="noopener">Grpc</a>
        </ul>
      </span>
      
      <span id="busuanzi_container_page_pv" class="x-post-meta-item">
        &nbsp;<svg t="1720844685710" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="27237" width="200" height="200"><path d="M739.754667 574.08c-121.386667 45.610667-208.469333 169.813333-208.64 316.16 0 33.408 4.693333 65.493333 13.141333 95.914667H94.122667c-26.453333-43.52-41.685333-91.946667-41.685334-143.189334 0-185.173333 192.896-335.104 430.805334-335.104 96.256 0 184.832 24.746667 256.512 66.218667z m-280.490667-114.986667a214.869333 214.869333 0 0 1-214.869333-215.04A215.04 215.04 0 0 1 459.264 28.842667a215.04 215.04 0 0 1 215.04 215.210666 215.04 215.04 0 0 1-215.04 215.04zM974.506667 641.28c9.856 0 17.834667 7.466667 17.834666 16.64v59.989333c-0.341333 8.789333-7.850667 15.786667-17.28 16.085334-9.856 0.341333-18.176-6.826667-18.517333-16.085334v-20.053333l-99.114667 91.093333-0.256 0.256a18.474667 18.474667 0 0 1-14.848 4.352h-0.768a18.176 18.176 0 0 1-9.344-4.608l-0.938666-0.981333-85.930667-80.042667-123.562667 115.072a18.773333 18.773333 0 0 1-25.216 0 15.786667 15.786667 0 0 1 0-23.466666l136.149334-126.848 0.725333-0.597334a18.645333 18.645333 0 0 1 24.362667 0.512l87.253333 81.237334 86.058667-79.232h-21.248c-9.386667-0.298667-16.938667-7.338667-17.28-16.085334-0.341333-9.173333 7.381333-16.896 17.28-17.237333h64.64z m-367.146667 240h48.128c8.874667 0 16.042667 7.168 16.042667 16.042667v72.192a16.042667 16.042667 0 0 1-16.042667 16.042666h-48.128a16.042667 16.042667 0 0 1-16.042667-16.042666v-72.192c0-8.874667 7.210667-16.042667 16.042667-16.042667z m110.805333-106.666667h48.128c8.874667 0 16.042667 7.168 16.042667 16.042667v178.858667a16.042667 16.042667 0 0 1-16.042667 16.042666h-48.128a16.042667 16.042667 0 0 1-16.042666-16.042666v-178.858667c0-8.874667 7.168-16.042667 16.042666-16.042667z m106.538667 80h48.128c8.874667 0 16.042667 7.168 16.042667 16.042667v99.413333a16.042667 16.042667 0 0 1-16.042667 16.042667H824.746667a16.042667 16.042667 0 0 1-16.042667-16.042667v-99.413333c0-8.874667 7.168-16.042667 16.042667-16.042667z m110.165333-80h48.128c8.874667 0 16.042667 7.168 16.042667 16.042667v179.413333a16.042667 16.042667 0 0 1-16.042667 16.042667h-48.128a16.042667 16.042667 0 0 1-16.042666-16.042667v-179.413333c0-8.874667 7.210667-16.042667 16.042666-16.042667z" fill="#999999" p-id="27238"></path></svg>
        <span id="busuanzi_value_page_pv"></span>
      </span>

</div>
  </header> <aside id="toc-container" class="toc-container wide">
    <div class="toc">
        <details  open>
            <summary accesskey="c" title="(Alt + C)">
                <span class="details">目录</span>
            </summary>

            <div class="inner"><ul>
                    <li>
                        <a href="#type-clientconn" aria-label="type ClientConn">type ClientConn</a><ul>
                            
                    <li>
                        <a href="#newclienttarget-opts" aria-label="NewClient(target, opts)">NewClient(target, opts)</a></li>
                    <li>
                        <a href="#cc-canonicaltarget" aria-label="(cc) CanonicalTarget()">(cc) CanonicalTarget()</a><ul>
                            
                    <li>
                        <a href="#%e7%a4%ba%e4%be%8b" aria-label="示例">示例</a></li></ul>
                    </li>
                    <li>
                        <a href="#cc-close" aria-label="(cc) Close()">(cc) Close()</a><ul>
                            
                    <li>
                        <a href="#%e7%a4%ba%e4%be%8b-1" aria-label="示例">示例</a></li></ul>
                    </li>
                    <li>
                        <a href="#cc-connect" aria-label="(cc) Connect()">(cc) Connect()</a><ul>
                            
                    <li>
                        <a href="#%e8%af%a6%e8%a7%a3" aria-label="详解">详解</a></li></ul>
                    </li>
                    <li>
                        <a href="#cc-getmethodconfigmethod" aria-label="(cc) GetMethodConfig(method)">(cc) GetMethodConfig(method)</a></li>
                    <li>
                        <a href="#cc-getstate" aria-label="(cc) GetState()">(cc) GetState()</a><ul>
                            
                    <li>
                        <a href="#%e8%af%a6%e8%a7%a3-1" aria-label="详解">详解</a></li></ul>
                    </li>
                    <li>
                        <a href="#cc-invokectx-method-args-reply-opts" aria-label="(cc) Invoke(ctx, method, args, reply, opts)">(cc) Invoke(ctx, method, args, reply, opts)</a><ul>
                            
                    <li>
                        <a href="#%e8%af%a6%e8%a7%a3-2" aria-label="详解">详解</a></li></ul>
                    </li>
                    <li>
                        <a href="#cc-newstreamctx-desc-method-opts" aria-label="(cc) NewStream(ctx, desc, method, opts)">(cc) NewStream(ctx, desc, method, opts)</a><ul>
                            
                    <li>
                        <a href="#%e8%af%a6%e8%a7%a3-3" aria-label="详解">详解</a></li></ul>
                    </li>
                    <li>
                        <a href="#cc-resetconnectbackoff" aria-label="(cc) ResetConnectBackoff()">(cc) ResetConnectBackoff()</a><ul>
                            
                    <li>
                        <a href="#%e8%af%a6%e8%a7%a3-4" aria-label="详解">详解</a></li></ul>
                    </li>
                    <li>
                        <a href="#cc-target" aria-label="(cc) Target()">(cc) Target()</a><ul>
                            
                    <li>
                        <a href="#%e7%a4%ba%e4%be%8b-2" aria-label="示例">示例</a></li></ul>
                    </li>
                    <li>
                        <a href="#cc-waitforstatechangectx-sourcestate" aria-label="(cc) WaitForStateChange(ctx, sourceState)">(cc) WaitForStateChange(ctx, sourceState)</a><ul>
                            
                    <li>
                        <a href="#%e8%af%a6%e8%a7%a3-5" aria-label="详解">详解</a></li></ul>
                    </li></ul>
                    </li>
                    <li>
                        <a href="#type-dialoption" aria-label="type DialOption">type DialOption</a><ul>
                            
                    <li>
                        <a href="#withauthoritya" aria-label="WithAuthority(a)">WithAuthority(a)</a><ul>
                            
                    <li>
                        <a href="#%e8%af%a6%e6%83%85" aria-label="详情">详情</a></li></ul>
                    </li>
                    <li>
                        <a href="#withchainstreaminterceptorinterceptors" aria-label="WithChainStreamInterceptor(interceptors)">WithChainStreamInterceptor(interceptors)</a><ul>
                            
                    <li>
                        <a href="#%e8%af%a6%e6%83%85-1" aria-label="详情">详情</a></li></ul>
                    </li>
                    <li>
                        <a href="#withchainunaryinterceptorinterceptors" aria-label="WithChainUnaryInterceptor(interceptors)">WithChainUnaryInterceptor(interceptors)</a><ul>
                            
                    <li>
                        <a href="#%e8%af%a6%e6%83%85-2" aria-label="详情">详情</a></li></ul>
                    </li>
                    <li>
                        <a href="#withchannelzparentidc" aria-label="WithChannelzParentID(c)">WithChannelzParentID(c)</a></li>
                    <li>
                        <a href="#withconnectparamsp" aria-label="WithConnectParams(p)">WithConnectParams(p)</a></li>
                    <li>
                        <a href="#withcontextdialerf" aria-label="WithContextDialer(f)">WithContextDialer(f)</a></li>
                    <li>
                        <a href="#withcredentialsbundleb" aria-label="WithCredentialsBundle(b)">WithCredentialsBundle(b)</a></li>
                    <li>
                        <a href="#withdefaultcalloptionscos" aria-label="WithDefaultCallOptions(cos)">WithDefaultCallOptions(cos)</a><ul>
                            
                    <li>
                        <a href="#%e8%af%a6%e8%a7%a3-6" aria-label="详解">详解</a></li></ul>
                    </li>
                    <li>
                        <a href="#withdefaultserviceconfigs" aria-label="WithDefaultServiceConfig(s)">WithDefaultServiceConfig(s)</a></li>
                    <li>
                        <a href="#withdisablehealthcheck" aria-label="WithDisableHealthCheck()">WithDisableHealthCheck()</a></li>
                    <li>
                        <a href="#withdisableretry" aria-label="WithDisableRetry()">WithDisableRetry()</a></li>
                    <li>
                        <a href="#withdisableserviceconfig" aria-label="WithDisableServiceConfig()">WithDisableServiceConfig()</a></li>
                    <li>
                        <a href="#withidletimeoutd" aria-label="WithIdleTimeout(d)">WithIdleTimeout(d)</a></li>
                    <li>
                        <a href="#withinitialconnwindowsizes" aria-label="WithInitialConnWindowSize(s)">WithInitialConnWindowSize(s)</a></li>
                    <li>
                        <a href="#withinitialwindowsizes" aria-label="WithInitialWindowSize(s)">WithInitialWindowSize(s)</a></li>
                    <li>
                        <a href="#withkeepaliveparamskp" aria-label="WithKeepaliveParams(kp)">WithKeepaliveParams(kp)</a></li>
                    <li>
                        <a href="#withmaxcallattemptsn" aria-label="WithMaxCallAttempts(n)">WithMaxCallAttempts(n)</a></li>
                    <li>
                        <a href="#withmaxheaderlistsizes" aria-label="WithMaxHeaderListSize(s)">WithMaxHeaderListSize(s)</a></li>
                    <li>
                        <a href="#withnoproxy" aria-label="WithNoProxy()">WithNoProxy()</a></li>
                    <li>
                        <a href="#withperrpccredentialscreds" aria-label="WithPerRPCCredentials(creds)">WithPerRPCCredentials(creds)</a><ul>
                            
                    <li>
                        <a href="#%e8%af%a6%e8%a7%a3-7" aria-label="详解">详解</a></li></ul>
                    </li>
                    <li>
                        <a href="#withreadbuffersizes" aria-label="WithReadBufferSize(s)">WithReadBufferSize(s)</a><ul>
                            
                    <li>
                        <a href="#%e8%af%a6%e8%a7%a3-8" aria-label="详解">详解</a></li></ul>
                    </li>
                    <li>
                        <a href="#withresolversrs" aria-label="WithResolvers(rs)">WithResolvers(rs)</a><ul>
                            
                    <li>
                        <a href="#%e8%af%a6%e8%a7%a3-9" aria-label="详解">详解</a></li></ul>
                    </li>
                    <li>
                        <a href="#withsharedwritebufferval" aria-label="WithSharedWriteBuffer(val)">WithSharedWriteBuffer(val)</a><ul>
                            
                    <li>
                        <a href="#%e8%af%a6%e8%a7%a3-10" aria-label="详解">详解</a></li></ul>
                    </li>
                    <li>
                        <a href="#withstatshandlerh" aria-label="WithStatsHandler(h)">WithStatsHandler(h)</a><ul>
                            
                    <li>
                        <a href="#%e8%af%a6%e8%a7%a3-11" aria-label="详解">详解</a></li></ul>
                    </li>
                    <li>
                        <a href="#withstreaminterceptorf" aria-label="WithStreamInterceptor(f)">WithStreamInterceptor(f)</a><ul>
                            
                    <li>
                        <a href="#%e8%af%a6%e8%a7%a3-12" aria-label="详解">详解</a></li></ul>
                    </li>
                    <li>
                        <a href="#withtransportcredentialscreds" aria-label="WithTransportCredentials(creds)">WithTransportCredentials(creds)</a><ul>
                            
                    <li>
                        <a href="#%e8%af%a6%e8%a7%a3-13" aria-label="详解">详解</a></li></ul>
                    </li>
                    <li>
                        <a href="#withunaryinterceptorf" aria-label="WithUnaryInterceptor(f)">WithUnaryInterceptor(f)</a><ul>
                            
                    <li>
                        <a href="#%e8%af%a6%e8%a7%a3-14" aria-label="详解">详解</a></li></ul>
                    </li>
                    <li>
                        <a href="#withuseragents" aria-label="WithUserAgent(s)">WithUserAgent(s)</a><ul>
                            
                    <li>
                        <a href="#%e8%af%a6%e8%a7%a3-15" aria-label="详解">详解</a></li></ul>
                    </li>
                    <li>
                        <a href="#withwritebuffersizes" aria-label="WithWriteBufferSize(s)">WithWriteBufferSize(s)</a><ul>
                            
                    <li>
                        <a href="#%e8%af%a6%e8%a7%a3-16" aria-label="详解">详解</a></li></ul>
                    </li></ul>
                    </li>
                    <li>
                        <a href="#type-calloption" aria-label="type CallOption">type CallOption</a><ul>
                            
                    <li>
                        <a href="#callcontentsubtypecontentsubtype" aria-label="CallContentSubtype(contentSubtype)">CallContentSubtype(contentSubtype)</a><ul>
                            
                    <li>
                        <a href="#%e8%af%a6%e8%a7%a3-17" aria-label="详解">详解</a></li></ul>
                    </li>
                    <li>
                        <a href="#forcecodeccodec" aria-label="ForceCodec(codec)">ForceCodec(codec)</a><ul>
                            
                    <li>
                        <a href="#%e8%af%a6%e8%a7%a3-18" aria-label="详解">详解</a></li></ul>
                    </li>
                    <li>
                        <a href="#forcecodecv2codec" aria-label="ForceCodecV2(codec)">ForceCodecV2(codec)</a><ul>
                            
                    <li>
                        <a href="#%e8%af%a6%e8%a7%a3-19" aria-label="详解">详解</a></li></ul>
                    </li>
                    <li>
                        <a href="#headermd" aria-label="Header(md)">Header(md)</a><ul>
                            
                    <li>
                        <a href="#%e4%bd%bf%e7%94%a8%e7%a4%ba%e4%be%8b" aria-label="使用示例">使用示例</a></li>
                    <li>
                        <a href="#header-%e5%92%8c-trailer-%e5%8c%ba%e5%88%ab" aria-label="Header 和 Trailer 区别">Header 和 Trailer 区别</a></li></ul>
                    </li>
                    <li>
                        <a href="#maxcallrecvmsgsizebytes" aria-label="MaxCallRecvMsgSize(bytes)">MaxCallRecvMsgSize(bytes)</a><ul>
                            
                    <li>
                        <a href="#%e4%bd%bf%e7%94%a8%e7%a4%ba%e4%be%8b-1" aria-label="使用示例">使用示例</a></li></ul>
                    </li>
                    <li>
                        <a href="#maxcallsendmsgsizebytes" aria-label="MaxCallSendMsgSize(bytes)">MaxCallSendMsgSize(bytes)</a><ul>
                            
                    <li>
                        <a href="#%e4%bd%bf%e7%94%a8%e7%a4%ba%e4%be%8b-2" aria-label="使用示例">使用示例</a></li></ul>
                    </li>
                    <li>
                        <a href="#maxretryrpcbuffersizebytes" aria-label="MaxRetryRPCBufferSize(bytes)">MaxRetryRPCBufferSize(bytes)</a><ul>
                            
                    <li>
                        <a href="#%e8%af%a6%e8%a7%a3-20" aria-label="详解">详解</a></li></ul>
                    </li>
                    <li>
                        <a href="#onfinishonfinish" aria-label="OnFinish(onFinish)">OnFinish(onFinish)</a><ul>
                            
                    <li>
                        <a href="#%e8%af%a6%e8%a7%a3-21" aria-label="详解">详解</a></li></ul>
                    </li>
                    <li>
                        <a href="#peerp" aria-label="Peer（p）">Peer（p）</a><ul>
                            
                    <li>
                        <a href="#%e8%af%a6%e8%a7%a3-22" aria-label="详解">详解</a></li></ul>
                    </li>
                    <li>
                        <a href="#perrpccredentialscreds" aria-label="PerRPCCredentials(creds)">PerRPCCredentials(creds)</a><ul>
                            
                    <li>
                        <a href="#%e4%bd%bf%e7%94%a8%e7%a4%ba%e4%be%8b-3" aria-label="使用示例">使用示例</a></li></ul>
                    </li>
                    <li>
                        <a href="#staticmethod" aria-label="StaticMethod()">StaticMethod()</a><ul>
                            
                    <li>
                        <a href="#%e8%af%a6%e8%a7%a3-23" aria-label="详解">详解</a></li></ul>
                    </li>
                    <li>
                        <a href="#trailermd" aria-label="Trailer(md)">Trailer(md)</a><ul>
                            
                    <li>
                        <a href="#%e8%af%a6%e8%a7%a3-24" aria-label="详解">详解</a></li></ul>
                    </li>
                    <li>
                        <a href="#usecompressorname" aria-label="UseCompressor(name)">UseCompressor(name)</a><ul>
                            
                    <li>
                        <a href="#%e8%af%a6%e8%a7%a3-25" aria-label="详解">详解</a></li></ul>
                    </li>
                    <li>
                        <a href="#waitforreadywaitforready" aria-label="WaitForReady(waitForReady)">WaitForReady(waitForReady)</a><ul>
                            
                    <li>
                        <a href="#%e4%bd%bf%e7%94%a8%e7%a4%ba%e4%be%8b-4" aria-label="使用示例">使用示例</a></li></ul>
                    </li></ul>
                    </li>
                    <li>
                        <a href="#type-peer" aria-label="type Peer">type Peer</a><ul>
                            
                    <li>
                        <a href="#newcontextctx-p" aria-label="NewContext(ctx, p)">NewContext(ctx, p)</a></li>
                    <li>
                        <a href="#type-peer-1" aria-label="type Peer">type Peer</a><ul>
                            
                    <li>
                        <a href="#fromcontextctx" aria-label="FromContext(ctx)">FromContext(ctx)</a></li>
                    <li>
                        <a href="#p-string" aria-label="(p) String()">(p) String()</a>
                    </li>
                </ul>
                </li>
                </ul>
                </li>
                </ul>
            </div>
        </details>
    </div>
</aside>
<script>
    let activeElement;
    let elements;
    window.addEventListener('DOMContentLoaded', function (event) {
        checkTocPosition();

        elements = document.querySelectorAll('h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]');
         
         activeElement = elements[0];
         const id = encodeURI(activeElement.getAttribute('id')).toLowerCase();
         document.querySelector(`.inner ul li a[href="#${id}"]`).classList.add('active');
     }, false);

    window.addEventListener('resize', function(event) {
        checkTocPosition();
    }, false);

    window.addEventListener('scroll', () => {
        
        activeElement = Array.from(elements).find((element) => {
            if ((getOffsetTop(element) - window.pageYOffset) > 0 && 
                (getOffsetTop(element) - window.pageYOffset) < window.innerHeight/2) {
                return element;
            }
        }) || activeElement

        elements.forEach(element => {
             const id = encodeURI(element.getAttribute('id')).toLowerCase();
             if (element === activeElement){
                 document.querySelector(`.inner ul li a[href="#${id}"]`).classList.add('active');
             } else {
                 document.querySelector(`.inner ul li a[href="#${id}"]`).classList.remove('active');
             }
         })
     }, false);

    const main = parseInt(getComputedStyle(document.body).getPropertyValue('--article-width'), 10);
    const toc = parseInt(getComputedStyle(document.body).getPropertyValue('--toc-width'), 10);
    const gap = parseInt(getComputedStyle(document.body).getPropertyValue('--gap'), 10);

    function checkTocPosition() {
        const width = document.body.scrollWidth;

        if (width - main - (toc * 2) - (gap * 4) > 0) {
            document.getElementById("toc-container").classList.add("wide");
        } else {
            document.getElementById("toc-container").classList.remove("wide");
        }
    }

    function getOffsetTop(element) {
        if (!element.getClientRects().length) {
            return 0;
        }
        let rect = element.getBoundingClientRect();
        let win = element.ownerDocument.defaultView;
        return rect.top + win.pageYOffset;   
    }
</script>
  <div class="post-content"><h2 id="type-clientconn">type ClientConn<a hidden class="anchor" aria-hidden="true" href="#type-clientconn">#</a></h2>
<ol>
<li>ClientConn表示到概念端点的虚拟连接，以执行rpc。</li>
<li>根据配置、负载等，ClientConn可以自由地拥有零个或多个到端点的实际连接。它还可以自由地确定要使用的实际端点，并可以在每个RPC中更改它，从而允许客户端负载平衡。</li>
<li>ClientConn封装了一系列功能，包括名称解析、TCP连接建立(带有重试和退出)和TLS握手。它还通过重新解析名称和重新连接来处理已建立连接上的错误。</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">ClientConn</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// contains filtered or unexported fields
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></div><h3 id="newclienttarget-opts">NewClient(target, opts)<a hidden class="anchor" aria-hidden="true" href="#newclienttarget-opts">#</a></h3>
<ol>
<li>NewClient为提供的目标URI创建一个新的gRPC &ldquo;channel&rdquo;。无I/O操作。对rpc使用ClientConn将自动使其连接。Connect可以用于手动创建连接，但对于大多数用户来说，这是不必要的。</li>
<li>目标名称语法在https://github.com/grpc/grpc/blob/master/doc/naming.md中定义。例如，要使用DNS解析器，应该对目标应用&quot; DNS:///&ldquo;前缀。</li>
<li>WithBlock, WithTimeout, WithReturnConnectionError和FailOnNonTempDialError返回的DialOptions将被该函数忽略。</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// NewClient creates a new gRPC &#34;channel&#34; for the target URI provided.  No I/O
</span></span></span><span class="line"><span class="cl"><span class="c1">// is performed.  Use of the ClientConn for RPCs will automatically cause it to
</span></span></span><span class="line"><span class="cl"><span class="c1">// connect.  Connect may be used to manually create a connection, but for most
</span></span></span><span class="line"><span class="cl"><span class="c1">// users this is unnecessary.
</span></span></span><span class="line"><span class="cl"><span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1">// The target name syntax is defined in
</span></span></span><span class="line"><span class="cl"><span class="c1">// https://github.com/grpc/grpc/blob/master/doc/naming.md.  e.g. to use dns
</span></span></span><span class="line"><span class="cl"><span class="c1">// resolver, a &#34;dns:///&#34; prefix should be applied to the target.
</span></span></span><span class="line"><span class="cl"><span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1">// The DialOptions returned by WithBlock, WithTimeout,
</span></span></span><span class="line"><span class="cl"><span class="c1">// WithReturnConnectionError, and FailOnNonTempDialError are ignored by this
</span></span></span><span class="line"><span class="cl"><span class="c1">// function.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">NewClient</span><span class="p">(</span><span class="nx">target</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">opts</span> <span class="o">...</span><span class="nx">DialOption</span><span class="p">)</span> <span class="p">(</span><span class="nx">conn</span> <span class="o">*</span><span class="nx">ClientConn</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">cc</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">ClientConn</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">target</span><span class="p">:</span> <span class="nx">target</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">		<span class="nx">conns</span><span class="p">:</span>  <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="o">*</span><span class="nx">addrConn</span><span class="p">]</span><span class="kd">struct</span><span class="p">{}),</span>
</span></span><span class="line"><span class="cl">		<span class="nx">dopts</span><span class="p">:</span>  <span class="nf">defaultDialOptions</span><span class="p">(),</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">cc</span><span class="p">.</span><span class="nx">retryThrottler</span><span class="p">.</span><span class="nf">Store</span><span class="p">((</span><span class="o">*</span><span class="nx">retryThrottler</span><span class="p">)(</span><span class="kc">nil</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">	<span class="nx">cc</span><span class="p">.</span><span class="nx">safeConfigSelector</span><span class="p">.</span><span class="nf">UpdateConfigSelector</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">defaultConfigSelector</span><span class="p">{</span><span class="kc">nil</span><span class="p">})</span>
</span></span><span class="line"><span class="cl">	<span class="nx">cc</span><span class="p">.</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">cc</span><span class="p">.</span><span class="nx">cancel</span> <span class="p">=</span> <span class="nx">context</span><span class="p">.</span><span class="nf">WithCancel</span><span class="p">(</span><span class="nx">context</span><span class="p">.</span><span class="nf">Background</span><span class="p">())</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// Apply dial options.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">disableGlobalOpts</span> <span class="o">:=</span> <span class="kc">false</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">opt</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">opts</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">opt</span><span class="p">.(</span><span class="o">*</span><span class="nx">disableGlobalDialOptions</span><span class="p">);</span> <span class="nx">ok</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nx">disableGlobalOpts</span> <span class="p">=</span> <span class="kc">true</span>
</span></span><span class="line"><span class="cl">			<span class="k">break</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="p">!</span><span class="nx">disableGlobalOpts</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">opt</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">globalDialOptions</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nx">opt</span><span class="p">.</span><span class="nf">apply</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">cc</span><span class="p">.</span><span class="nx">dopts</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">opt</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">opts</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">opt</span><span class="p">.</span><span class="nf">apply</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">cc</span><span class="p">.</span><span class="nx">dopts</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// Determine the resolver to use.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">cc</span><span class="p">.</span><span class="nf">initParsedTargetAndResolverBuilder</span><span class="p">();</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">err</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">opt</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">globalPerTargetDialOptions</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">opt</span><span class="p">.</span><span class="nf">DialOptionForTarget</span><span class="p">(</span><span class="nx">cc</span><span class="p">.</span><span class="nx">parsedTarget</span><span class="p">.</span><span class="nx">URL</span><span class="p">).</span><span class="nf">apply</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">cc</span><span class="p">.</span><span class="nx">dopts</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nf">chainUnaryClientInterceptors</span><span class="p">(</span><span class="nx">cc</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nf">chainStreamClientInterceptors</span><span class="p">(</span><span class="nx">cc</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">cc</span><span class="p">.</span><span class="nf">validateTransportCredentials</span><span class="p">();</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">err</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">cc</span><span class="p">.</span><span class="nx">dopts</span><span class="p">.</span><span class="nx">defaultServiceConfigRawJSON</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">scpr</span> <span class="o">:=</span> <span class="nf">parseServiceConfig</span><span class="p">(</span><span class="o">*</span><span class="nx">cc</span><span class="p">.</span><span class="nx">dopts</span><span class="p">.</span><span class="nx">defaultServiceConfigRawJSON</span><span class="p">,</span> <span class="nx">cc</span><span class="p">.</span><span class="nx">dopts</span><span class="p">.</span><span class="nx">maxCallAttempts</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="nx">scpr</span><span class="p">.</span><span class="nx">Err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Errorf</span><span class="p">(</span><span class="s">&#34;%s: %v&#34;</span><span class="p">,</span> <span class="nx">invalidDefaultServiceConfigErrPrefix</span><span class="p">,</span> <span class="nx">scpr</span><span class="p">.</span><span class="nx">Err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="nx">cc</span><span class="p">.</span><span class="nx">dopts</span><span class="p">.</span><span class="nx">defaultServiceConfig</span><span class="p">,</span> <span class="nx">_</span> <span class="p">=</span> <span class="nx">scpr</span><span class="p">.</span><span class="nx">Config</span><span class="p">.(</span><span class="o">*</span><span class="nx">ServiceConfig</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">cc</span><span class="p">.</span><span class="nx">mkp</span> <span class="p">=</span> <span class="nx">cc</span><span class="p">.</span><span class="nx">dopts</span><span class="p">.</span><span class="nx">copts</span><span class="p">.</span><span class="nx">KeepaliveParams</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">cc</span><span class="p">.</span><span class="nf">initAuthority</span><span class="p">();</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">err</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// Register ClientConn with channelz. Note that this is only done after
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// channel creation cannot fail.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">cc</span><span class="p">.</span><span class="nf">channelzRegistration</span><span class="p">(</span><span class="nx">target</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">channelz</span><span class="p">.</span><span class="nf">Infof</span><span class="p">(</span><span class="nx">logger</span><span class="p">,</span> <span class="nx">cc</span><span class="p">.</span><span class="nx">channelz</span><span class="p">,</span> <span class="s">&#34;parsed dial target is: %#v&#34;</span><span class="p">,</span> <span class="nx">cc</span><span class="p">.</span><span class="nx">parsedTarget</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">channelz</span><span class="p">.</span><span class="nf">Infof</span><span class="p">(</span><span class="nx">logger</span><span class="p">,</span> <span class="nx">cc</span><span class="p">.</span><span class="nx">channelz</span><span class="p">,</span> <span class="s">&#34;Channel authority set to %q&#34;</span><span class="p">,</span> <span class="nx">cc</span><span class="p">.</span><span class="nx">authority</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">cc</span><span class="p">.</span><span class="nx">csMgr</span> <span class="p">=</span> <span class="nf">newConnectivityStateManager</span><span class="p">(</span><span class="nx">cc</span><span class="p">.</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">cc</span><span class="p">.</span><span class="nx">channelz</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">cc</span><span class="p">.</span><span class="nx">pickerWrapper</span> <span class="p">=</span> <span class="nf">newPickerWrapper</span><span class="p">(</span><span class="nx">cc</span><span class="p">.</span><span class="nx">dopts</span><span class="p">.</span><span class="nx">copts</span><span class="p">.</span><span class="nx">StatsHandlers</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">cc</span><span class="p">.</span><span class="nx">metricsRecorderList</span> <span class="p">=</span> <span class="nx">stats</span><span class="p">.</span><span class="nf">NewMetricsRecorderList</span><span class="p">(</span><span class="nx">cc</span><span class="p">.</span><span class="nx">dopts</span><span class="p">.</span><span class="nx">copts</span><span class="p">.</span><span class="nx">StatsHandlers</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">cc</span><span class="p">.</span><span class="nf">initIdleStateLocked</span><span class="p">()</span> <span class="c1">// Safe to call without the lock, since nothing else has a reference to cc.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">cc</span><span class="p">.</span><span class="nx">idlenessMgr</span> <span class="p">=</span> <span class="nx">idle</span><span class="p">.</span><span class="nf">NewManager</span><span class="p">((</span><span class="o">*</span><span class="nx">idler</span><span class="p">)(</span><span class="nx">cc</span><span class="p">),</span> <span class="nx">cc</span><span class="p">.</span><span class="nx">dopts</span><span class="p">.</span><span class="nx">idleTimeout</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nx">cc</span><span class="p">,</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h3 id="cc-canonicaltarget">(cc) CanonicalTarget()<a hidden class="anchor" aria-hidden="true" href="#cc-canonicaltarget">#</a></h3>
<ol>
<li>CanonicalTarget返回ClientConn的规范目标字符串。</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// CanonicalTarget returns the canonical target string of the ClientConn.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">cc</span> <span class="o">*</span><span class="nx">ClientConn</span><span class="p">)</span> <span class="nf">CanonicalTarget</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nx">cc</span><span class="p">.</span><span class="nx">parsedTarget</span><span class="p">.</span><span class="nf">String</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h4 id="示例">示例<a hidden class="anchor" aria-hidden="true" href="#示例">#</a></h4>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 配置ssl，&#34;*.heliu.site&#34;在实际开发中从浏览器中取获取，证书路径使用绝对路径
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">creds</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">credentials</span><span class="p">.</span><span class="nf">NewClientTLSFromFile</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">		<span class="s">&#34;/root/workspace/learn-grpc/key/test.pem&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">		<span class="s">&#34;*.heliu.site&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">	<span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="kd">var</span> <span class="nx">opts</span> <span class="p">[]</span><span class="nx">grpc</span><span class="p">.</span><span class="nx">DialOption</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 不带TLS这里是grpc.WithTransportCredentials(insecure.NewCredentials())
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">opts</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">opts</span><span class="p">,</span> <span class="nx">grpc</span><span class="p">.</span><span class="nf">WithTransportCredentials</span><span class="p">(</span><span class="nx">creds</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">	<span class="nx">opts</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">opts</span><span class="p">,</span> <span class="nx">grpc</span><span class="p">.</span><span class="nf">WithPerRPCCredentials</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">ClientTokenAuth</span><span class="p">{}))</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 添加客户端拦截器
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">opts</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">opts</span><span class="p">,</span> <span class="nx">grpc</span><span class="p">.</span><span class="nf">WithUnaryInterceptor</span><span class="p">(</span><span class="nx">interceptor</span><span class="p">.</span><span class="nf">UnaryClientInterceptor</span><span class="p">()))</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 添加流拦截器
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">opts</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">opts</span><span class="p">,</span> <span class="nx">grpc</span><span class="p">.</span><span class="nf">WithStreamInterceptor</span><span class="p">(</span><span class="nx">interceptor</span><span class="p">.</span><span class="nf">StreamClientInterceptor</span><span class="p">()))</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 连接server端，使用ssl加密通信
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">conn</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">grpc</span><span class="p">.</span><span class="nf">NewClient</span><span class="p">(</span><span class="s">&#34;127.0.0.1:9090&#34;</span><span class="p">,</span> <span class="nx">opts</span><span class="o">...</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">log</span><span class="p">.</span><span class="nf">Fatalf</span><span class="p">(</span><span class="s">&#34;did not connect: %v&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">defer</span> <span class="nx">conn</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// -----------  CanonicalTarget: dns:///127.0.0.1:9090  -----------
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">log</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;CanonicalTarget: %s\n&#34;</span><span class="p">,</span> <span class="nx">conn</span><span class="p">.</span><span class="nf">CanonicalTarget</span><span class="p">())</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></div><h3 id="cc-close">(cc) Close()<a hidden class="anchor" aria-hidden="true" href="#cc-close">#</a></h3>
<ol>
<li>Close关闭ClientConn和所有底层连接。</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// Close tears down the ClientConn and all underlying connections.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">cc</span> <span class="o">*</span><span class="nx">ClientConn</span><span class="p">)</span> <span class="nf">Close</span><span class="p">()</span> <span class="kt">error</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">defer</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">cc</span><span class="p">.</span><span class="nf">cancel</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">		<span class="o">&lt;-</span><span class="nx">cc</span><span class="p">.</span><span class="nx">csMgr</span><span class="p">.</span><span class="nx">pubSub</span><span class="p">.</span><span class="nf">Done</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="p">}()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// Prevent calls to enter/exit idle immediately, and ensure we are not
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// currently entering/exiting idle mode.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">cc</span><span class="p">.</span><span class="nx">idlenessMgr</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">cc</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">cc</span><span class="p">.</span><span class="nx">conns</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">cc</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="nx">ErrClientConnClosing</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">conns</span> <span class="o">:=</span> <span class="nx">cc</span><span class="p">.</span><span class="nx">conns</span>
</span></span><span class="line"><span class="cl">	<span class="nx">cc</span><span class="p">.</span><span class="nx">conns</span> <span class="p">=</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl">	<span class="nx">cc</span><span class="p">.</span><span class="nx">csMgr</span><span class="p">.</span><span class="nf">updateState</span><span class="p">(</span><span class="nx">connectivity</span><span class="p">.</span><span class="nx">Shutdown</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// We can safely unlock and continue to access all fields now as
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// cc.conns==nil, preventing any further operations on cc.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">cc</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">cc</span><span class="p">.</span><span class="nx">resolverWrapper</span><span class="p">.</span><span class="nb">close</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// The order of closing matters here since the balancer wrapper assumes the
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// picker is closed before it is closed.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">cc</span><span class="p">.</span><span class="nx">pickerWrapper</span><span class="p">.</span><span class="nb">close</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="nx">cc</span><span class="p">.</span><span class="nx">balancerWrapper</span><span class="p">.</span><span class="nb">close</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="o">&lt;-</span><span class="nx">cc</span><span class="p">.</span><span class="nx">resolverWrapper</span><span class="p">.</span><span class="nx">serializer</span><span class="p">.</span><span class="nf">Done</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="o">&lt;-</span><span class="nx">cc</span><span class="p">.</span><span class="nx">balancerWrapper</span><span class="p">.</span><span class="nx">serializer</span><span class="p">.</span><span class="nf">Done</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="nx">ac</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">conns</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">ac</span><span class="p">.</span><span class="nf">tearDown</span><span class="p">(</span><span class="nx">ErrClientConnClosing</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">cc</span><span class="p">.</span><span class="nf">addTraceEvent</span><span class="p">(</span><span class="s">&#34;deleted&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// TraceEvent needs to be called before RemoveEntry, as TraceEvent may add
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// trace reference to the entity being deleted, and thus prevent it from being
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// deleted right away.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">channelz</span><span class="p">.</span><span class="nf">RemoveEntry</span><span class="p">(</span><span class="nx">cc</span><span class="p">.</span><span class="nx">channelz</span><span class="p">.</span><span class="nx">ID</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h4 id="示例-1">示例<a hidden class="anchor" aria-hidden="true" href="#示例-1">#</a></h4>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 配置ssl，&#34;*.heliu.site&#34;在实际开发中从浏览器中取获取，证书路径使用绝对路径
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">creds</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">credentials</span><span class="p">.</span><span class="nf">NewClientTLSFromFile</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">		<span class="s">&#34;/root/workspace/learn-grpc/key/test.pem&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">		<span class="s">&#34;*.heliu.site&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">	<span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="kd">var</span> <span class="nx">opts</span> <span class="p">[]</span><span class="nx">grpc</span><span class="p">.</span><span class="nx">DialOption</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 不带TLS这里是grpc.WithTransportCredentials(insecure.NewCredentials())
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">opts</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">opts</span><span class="p">,</span> <span class="nx">grpc</span><span class="p">.</span><span class="nf">WithTransportCredentials</span><span class="p">(</span><span class="nx">creds</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">	<span class="nx">opts</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">opts</span><span class="p">,</span> <span class="nx">grpc</span><span class="p">.</span><span class="nf">WithPerRPCCredentials</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">ClientTokenAuth</span><span class="p">{}))</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 添加客户端拦截器
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">opts</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">opts</span><span class="p">,</span> <span class="nx">grpc</span><span class="p">.</span><span class="nf">WithUnaryInterceptor</span><span class="p">(</span><span class="nx">interceptor</span><span class="p">.</span><span class="nf">UnaryClientInterceptor</span><span class="p">()))</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 添加流拦截器
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">opts</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">opts</span><span class="p">,</span> <span class="nx">grpc</span><span class="p">.</span><span class="nf">WithStreamInterceptor</span><span class="p">(</span><span class="nx">interceptor</span><span class="p">.</span><span class="nf">StreamClientInterceptor</span><span class="p">()))</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 连接server端，使用ssl加密通信
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">conn</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">grpc</span><span class="p">.</span><span class="nf">NewClient</span><span class="p">(</span><span class="s">&#34;127.0.0.1:9090&#34;</span><span class="p">,</span> <span class="nx">opts</span><span class="o">...</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">log</span><span class="p">.</span><span class="nf">Fatalf</span><span class="p">(</span><span class="s">&#34;did not connect: %v&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// -----------  Close  -----------
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">defer</span> <span class="nx">conn</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">log</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;CanonicalTarget: %s\n&#34;</span><span class="p">,</span> <span class="nx">conn</span><span class="p">.</span><span class="nf">CanonicalTarget</span><span class="p">())</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></div><h3 id="cc-connect">(cc) Connect()<a hidden class="anchor" aria-hidden="true" href="#cc-connect">#</a></h3>
<ol>
<li>如果channel空闲，Connect将导致ClientConn中的所有子通道尝试连接。在返回之前不等待连接尝试开始。</li>
<li>注意:此API是实验性的，可能会在以后的版本中更改或删除。</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// Connect causes all subchannels in the ClientConn to attempt to connect if
</span></span></span><span class="line"><span class="cl"><span class="c1">// the channel is idle.  Does not wait for the connection attempts to begin
</span></span></span><span class="line"><span class="cl"><span class="c1">// before returning.
</span></span></span><span class="line"><span class="cl"><span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1">// # Experimental
</span></span></span><span class="line"><span class="cl"><span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1">// Notice: This API is EXPERIMENTAL and may be changed or removed in a later
</span></span></span><span class="line"><span class="cl"><span class="c1">// release.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">cc</span> <span class="o">*</span><span class="nx">ClientConn</span><span class="p">)</span> <span class="nf">Connect</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">cc</span><span class="p">.</span><span class="nx">idlenessMgr</span><span class="p">.</span><span class="nf">ExitIdleMode</span><span class="p">();</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">cc</span><span class="p">.</span><span class="nf">addTraceEvent</span><span class="p">(</span><span class="nx">err</span><span class="p">.</span><span class="nf">Error</span><span class="p">())</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// If the ClientConn was not in idle mode, we need to call ExitIdle on the
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// LB policy so that connections can be created.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">cc</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="nx">cc</span><span class="p">.</span><span class="nx">balancerWrapper</span><span class="p">.</span><span class="nf">exitIdle</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="nx">cc</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h4 id="详解">详解<a hidden class="anchor" aria-hidden="true" href="#详解">#</a></h4>
<ol>
<li>它用于通知客户端连接的负载均衡器策略（LB policy）退出空闲模式，并尝试建立连接。这个函数通常在客户端连接空闲时调用，以便在必要时重新建立连接。</li>
<li><strong>作用</strong>：
<ul>
<li><strong>重新连接</strong>：当客户端连接处于空闲状态时，可以调用这个函数来尝试重新建立连接。</li>
<li><strong>状态更新</strong>：通知负载均衡器策略客户端连接已准备好接受新的请求，并应该开始创建新的连接。</li>
</ul>
</li>
<li><strong>使用场景</strong>：
<ul>
<li><strong>空闲连接管理</strong>：当客户端连接长时间没有活动时，可以通过调用这个函数来重新激活连接。</li>
<li><strong>负载均衡策略</strong>：当客户端连接的负载均衡策略需要根据连接状态进行调整时，可以使用这个函数。</li>
</ul>
</li>
<li>需要注意的是，<code>Connect</code> 函数是实验性的，可能会在未来的gRPC版本中更改或移除。因此，在生产环境中使用这个函数之前，应该仔细评估其稳定性和适用性。</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kn">package</span> <span class="nx">main</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;context&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;fmt&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;google.golang.org/grpc&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;time&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">ctx</span><span class="p">,</span> <span class="nx">cancel</span> <span class="o">:=</span> <span class="nx">context</span><span class="p">.</span><span class="nf">WithTimeout</span><span class="p">(</span><span class="nx">context</span><span class="p">.</span><span class="nf">Background</span><span class="p">(),</span> <span class="mi">5</span><span class="o">*</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">defer</span> <span class="nf">cancel</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">conn</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">grpc</span><span class="p">.</span><span class="nf">DialContext</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="s">&#34;localhost:50051&#34;</span><span class="p">,</span> <span class="nx">grpc</span><span class="p">.</span><span class="nf">WithBlock</span><span class="p">())</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;Failed to dial: %v\n&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">defer</span> <span class="nx">conn</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 等待连接状态从DOWN变为READY
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">if</span> <span class="nx">conn</span><span class="p">.</span><span class="nf">WaitForStateChange</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">connectivity</span><span class="p">.</span><span class="nx">StateDown</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;Connection state changed to READY&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;Connection state change timeout&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 在需要时重新连接
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">conn</span><span class="p">.</span><span class="nf">Connect</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><ol start="5">
<li>在这个例子中，我们创建了一个上下文，设置了5秒的超时时间。然后，我们尝试建立与服务器端口50051的gRPC连接。如果连接成功，我们使用<code>WaitForStateChange</code>函数等待连接状态从<code>DOWN</code>变为<code>READY</code>。如果连接状态在5秒内没有改变，我们将打印出超时的消息。随后，我们调用<code>Connect</code>函数通知客户端连接的负载均衡器策略退出空闲模式，并尝试建立新的连接。</li>
</ol>
<h3 id="cc-getmethodconfigmethod">(cc) GetMethodConfig(method)<a hidden class="anchor" aria-hidden="true" href="#cc-getmethodconfigmethod">#</a></h3>
<ol>
<li>GetMethodConfig获取输入法的方法配置。如果有一个完全匹配的输入法(即/service/method)，我们返回相应的MethodConfig。如果输入法没有精确匹配，我们在服务(即/service/)下查找服务的默认配置，然后查找所有服务的默认配置(空字符串)。</li>
<li>如果服务有默认的MethodConfig，我们就返回它。否则，我们返回一个空的MethodConfig。</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// GetMethodConfig gets the method config of the input method.
</span></span></span><span class="line"><span class="cl"><span class="c1">// If there&#39;s an exact match for input method (i.e. /service/method), we return
</span></span></span><span class="line"><span class="cl"><span class="c1">// the corresponding MethodConfig.
</span></span></span><span class="line"><span class="cl"><span class="c1">// If there isn&#39;t an exact match for the input method, we look for the service&#39;s default
</span></span></span><span class="line"><span class="cl"><span class="c1">// config under the service (i.e /service/) and then for the default for all services (empty string).
</span></span></span><span class="line"><span class="cl"><span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1">// If there is a default MethodConfig for the service, we return it.
</span></span></span><span class="line"><span class="cl"><span class="c1">// Otherwise, we return an empty MethodConfig.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">cc</span> <span class="o">*</span><span class="nx">ClientConn</span><span class="p">)</span> <span class="nf">GetMethodConfig</span><span class="p">(</span><span class="nx">method</span> <span class="kt">string</span><span class="p">)</span> <span class="nx">MethodConfig</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// TODO: Avoid the locking here.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">cc</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">RLock</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="k">defer</span> <span class="nx">cc</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">RUnlock</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nf">getMethodConfig</span><span class="p">(</span><span class="nx">cc</span><span class="p">.</span><span class="nx">sc</span><span class="p">,</span> <span class="nx">method</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h3 id="cc-getstate">(cc) GetState()<a hidden class="anchor" aria-hidden="true" href="#cc-getstate">#</a></h3>
<ol>
<li>GetState返回ClientConn的connectivity.State。</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// GetState returns the connectivity.State of ClientConn.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">cc</span> <span class="o">*</span><span class="nx">ClientConn</span><span class="p">)</span> <span class="nf">GetState</span><span class="p">()</span> <span class="nx">connectivity</span><span class="p">.</span><span class="nx">State</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nx">cc</span><span class="p">.</span><span class="nx">csMgr</span><span class="p">.</span><span class="nf">getState</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h4 id="详解-1">详解<a hidden class="anchor" aria-hidden="true" href="#详解-1">#</a></h4>
<ol>
<li>它用于获取客户端连接当前的连接状态。这个函数在客户端需要了解其当前连接状态时非常有用，例如，当客户端需要根据连接状态调整其行为时。</li>
<li><strong>作用</strong>：
<ul>
<li><strong>状态监控</strong>：允许客户端检查其连接状态，以便根据需要进行相应的处理。</li>
<li><strong>行为调整</strong>：客户端可以根据连接状态调整其行为，例如，当连接不可用时，可以暂停发送请求。</li>
</ul>
</li>
<li><strong>使用场景</strong>：
<ul>
<li><strong>连接状态监控</strong>：在需要监控连接状态变化的应用场景中，如客户端需要根据连接状态调整其行为。</li>
<li><strong>异常处理</strong>：在处理连接问题时，客户端可以检查连接状态来决定如何响应。</li>
</ul>
</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kn">package</span> <span class="nx">main</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;context&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;fmt&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;google.golang.org/grpc&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;time&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">ctx</span><span class="p">,</span> <span class="nx">cancel</span> <span class="o">:=</span> <span class="nx">context</span><span class="p">.</span><span class="nf">WithTimeout</span><span class="p">(</span><span class="nx">context</span><span class="p">.</span><span class="nf">Background</span><span class="p">(),</span> <span class="mi">5</span><span class="o">*</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">defer</span> <span class="nf">cancel</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">conn</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">grpc</span><span class="p">.</span><span class="nf">DialContext</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="s">&#34;localhost:50051&#34;</span><span class="p">,</span> <span class="nx">grpc</span><span class="p">.</span><span class="nf">WithBlock</span><span class="p">())</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;Failed to dial: %v\n&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">defer</span> <span class="nx">conn</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 获取连接状态
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">state</span> <span class="o">:=</span> <span class="nx">conn</span><span class="p">.</span><span class="nf">GetState</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;Connection state: %s\n&#34;</span><span class="p">,</span> <span class="nx">state</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 假设在连接过程中遇到了短暂故障
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">if</span> <span class="nx">conn</span><span class="p">.</span><span class="nf">WaitForStateChange</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">connectivity</span><span class="p">.</span><span class="nx">StateIdle</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;Connection state changed to READY&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;Connection state change timeout&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><ol start="4">
<li>在这个例子中，我们创建了一个上下文，设置了5秒的超时时间。然后，我们尝试建立与服务器端口50051的gRPC连接。如果连接成功，我们使用<code>GetState</code>函数获取连接状态，并打印出来。随后，我们假设遇到了网络故障，并调用<code>WaitForStateChange</code>函数等待连接状态从<code>IDLE</code>变为<code>READY</code>。如果在5秒内状态没有改变，我们将打印出超时的消息。</li>
</ol>
<h3 id="cc-invokectx-method-args-reply-opts">(cc) Invoke(ctx, method, args, reply, opts)<a hidden class="anchor" aria-hidden="true" href="#cc-invokectx-method-args-reply-opts">#</a></h3>
<ol>
<li>Invoke通过网络发送RPC请求，并在收到响应后返回。这通常由生成的代码调用。</li>
<li>调用返回的所有错误都与状态包兼容。</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// Invoke sends the RPC request on the wire and returns after response is
</span></span></span><span class="line"><span class="cl"><span class="c1">// received.  This is typically called by generated code.
</span></span></span><span class="line"><span class="cl"><span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1">// All errors returned by Invoke are compatible with the status package.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">cc</span> <span class="o">*</span><span class="nx">ClientConn</span><span class="p">)</span> <span class="nf">Invoke</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">method</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">args</span><span class="p">,</span> <span class="nx">reply</span> <span class="nx">any</span><span class="p">,</span> <span class="nx">opts</span> <span class="o">...</span><span class="nx">CallOption</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// allow interceptor to see all applicable call options, which means those
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// configured as defaults from dial option as well as per-call options
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">opts</span> <span class="p">=</span> <span class="nf">combine</span><span class="p">(</span><span class="nx">cc</span><span class="p">.</span><span class="nx">dopts</span><span class="p">.</span><span class="nx">callOptions</span><span class="p">,</span> <span class="nx">opts</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">cc</span><span class="p">.</span><span class="nx">dopts</span><span class="p">.</span><span class="nx">unaryInt</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="nx">cc</span><span class="p">.</span><span class="nx">dopts</span><span class="p">.</span><span class="nf">unaryInt</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">method</span><span class="p">,</span> <span class="nx">args</span><span class="p">,</span> <span class="nx">reply</span><span class="p">,</span> <span class="nx">cc</span><span class="p">,</span> <span class="nx">invoke</span><span class="p">,</span> <span class="nx">opts</span><span class="o">...</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nf">invoke</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">method</span><span class="p">,</span> <span class="nx">args</span><span class="p">,</span> <span class="nx">reply</span><span class="p">,</span> <span class="nx">cc</span><span class="p">,</span> <span class="nx">opts</span><span class="o">...</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h4 id="详解-2">详解<a hidden class="anchor" aria-hidden="true" href="#详解-2">#</a></h4>
<ol>
<li>它用于发送一个单向的RPC请求到服务器端，并等待接收响应。这个函数通常由gRPC代码生成器调用，用于客户端调用服务器端的单向RPC方法。</li>
<li><strong>作用</strong>：
<ul>
<li><strong>发送请求</strong>：允许客户端发送一个单向的RPC请求到服务器端。</li>
<li><strong>接收响应</strong>：等待服务器端的响应，并将响应数据存储在 <code>reply</code> 参数中。</li>
</ul>
</li>
<li><strong>使用场景</strong>：
<ul>
<li><strong>单向RPC调用</strong>：当客户端只需要发送请求而不需要接收响应时，可以使用这个函数。</li>
<li><strong>服务调用</strong>：客户端可以通过这个函数调用服务器端的服务。</li>
</ul>
</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kn">package</span> <span class="nx">main</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;context&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;fmt&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;google.golang.org/grpc&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;time&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">ctx</span><span class="p">,</span> <span class="nx">cancel</span> <span class="o">:=</span> <span class="nx">context</span><span class="p">.</span><span class="nf">WithTimeout</span><span class="p">(</span><span class="nx">context</span><span class="p">.</span><span class="nf">Background</span><span class="p">(),</span> <span class="mi">5</span><span class="o">*</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">defer</span> <span class="nf">cancel</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">conn</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">grpc</span><span class="p">.</span><span class="nf">DialContext</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="s">&#34;localhost:50051&#34;</span><span class="p">,</span> <span class="nx">grpc</span><span class="p">.</span><span class="nf">WithBlock</span><span class="p">())</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;Failed to dial: %v\n&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">defer</span> <span class="nx">conn</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 调用服务器端的单向RPC方法
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">err</span> <span class="p">=</span> <span class="nx">conn</span><span class="p">.</span><span class="nf">Invoke</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="s">&#34;MyService.MyMethod&#34;</span><span class="p">,</span> <span class="kc">nil</span><span class="p">,</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">grpc</span><span class="p">.</span><span class="nf">FailOnNonTempDialError</span><span class="p">(</span><span class="kc">true</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;Failed to invoke RPC: %v\n&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 处理响应（如果有的话）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></div><ol start="4">
<li>在这个例子中，我们创建了一个上下文，设置了5秒的超时时间。然后，我们尝试建立与服务器端口50051的gRPC连接。如果连接成功，我们使用<code>Invoke</code>函数调用服务器端的单向RPC方法。如果有响应，我们可以通过<code>reply</code>参数来处理。最后，我们关闭连接以释放资源。</li>
</ol>
<h3 id="cc-newstreamctx-desc-method-opts">(cc) NewStream(ctx, desc, method, opts)<a hidden class="anchor" aria-hidden="true" href="#cc-newstreamctx-desc-method-opts">#</a></h3>
<ol>
<li>
<p>NewStream为客户端创建一个新的流。这通常由生成的代码调用。ctx用于流的生命周期。</p>
</li>
<li>
<p>为了确保资源不会因为返回的流而泄露，必须执行以下操作之一:</p>
<ul>
<li>在ClientConn上调用Close。</li>
<li>取消提供的上下文。</li>
<li>调用RecvMsg，直到返回非nil错误。例如，protobuf生成的客户端流式RPC可能会使用辅助函数CloseAndRecv(请注意，CloseSend不Recv，因此不能保证释放所有资源)。</li>
<li>接收一个非nil，非io。报头或发送消息出错。</li>
</ul>
</li>
<li>
<p>如果上述情况都没有发生，则会泄露一个程序和一个上下文，并且grpc将不会使用stats.End消息调用可选配置的stats处理程序。</p>
</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// NewStream creates a new Stream for the client side. This is typically
</span></span></span><span class="line"><span class="cl"><span class="c1">// called by generated code. ctx is used for the lifetime of the stream.
</span></span></span><span class="line"><span class="cl"><span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1">// To ensure resources are not leaked due to the stream returned, one of the following
</span></span></span><span class="line"><span class="cl"><span class="c1">// actions must be performed:
</span></span></span><span class="line"><span class="cl"><span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1">//  1. Call Close on the ClientConn.
</span></span></span><span class="line"><span class="cl"><span class="c1">//  2. Cancel the context provided.
</span></span></span><span class="line"><span class="cl"><span class="c1">//  3. Call RecvMsg until a non-nil error is returned. A protobuf-generated
</span></span></span><span class="line"><span class="cl"><span class="c1">//     client-streaming RPC, for instance, might use the helper function
</span></span></span><span class="line"><span class="cl"><span class="c1">//     CloseAndRecv (note that CloseSend does not Recv, therefore is not
</span></span></span><span class="line"><span class="cl"><span class="c1">//     guaranteed to release all resources).
</span></span></span><span class="line"><span class="cl"><span class="c1">//  4. Receive a non-nil, non-io.EOF error from Header or SendMsg.
</span></span></span><span class="line"><span class="cl"><span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1">// If none of the above happen, a goroutine and a context will be leaked, and grpc
</span></span></span><span class="line"><span class="cl"><span class="c1">// will not call the optionally-configured stats handler with a stats.End message.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">cc</span> <span class="o">*</span><span class="nx">ClientConn</span><span class="p">)</span> <span class="nf">NewStream</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">desc</span> <span class="o">*</span><span class="nx">StreamDesc</span><span class="p">,</span> <span class="nx">method</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">opts</span> <span class="o">...</span><span class="nx">CallOption</span><span class="p">)</span> <span class="p">(</span><span class="nx">ClientStream</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// allow interceptor to see all applicable call options, which means those
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// configured as defaults from dial option as well as per-call options
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">opts</span> <span class="p">=</span> <span class="nf">combine</span><span class="p">(</span><span class="nx">cc</span><span class="p">.</span><span class="nx">dopts</span><span class="p">.</span><span class="nx">callOptions</span><span class="p">,</span> <span class="nx">opts</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">cc</span><span class="p">.</span><span class="nx">dopts</span><span class="p">.</span><span class="nx">streamInt</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="nx">cc</span><span class="p">.</span><span class="nx">dopts</span><span class="p">.</span><span class="nf">streamInt</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">desc</span><span class="p">,</span> <span class="nx">cc</span><span class="p">,</span> <span class="nx">method</span><span class="p">,</span> <span class="nx">newClientStream</span><span class="p">,</span> <span class="nx">opts</span><span class="o">...</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nf">newClientStream</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">desc</span><span class="p">,</span> <span class="nx">cc</span><span class="p">,</span> <span class="nx">method</span><span class="p">,</span> <span class="nx">opts</span><span class="o">...</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h4 id="详解-3">详解<a hidden class="anchor" aria-hidden="true" href="#详解-3">#</a></h4>
<ol>
<li>它用于创建一个新的客户端流（<code>ClientStream</code>）。这个函数通常由gRPC代码生成器调用，用于创建与服务器端服务的通信通道。</li>
<li><strong>作用</strong>：
<ul>
<li><strong>创建通信通道</strong>：允许客户端创建一个新的流，以便与服务器端服务进行通信。</li>
<li><strong>行为配置</strong>：通过传递不同的<code>CallOption</code>参数，可以配置流的发送和接收行为。</li>
</ul>
</li>
<li><strong>使用场景</strong>：
<ul>
<li><strong>服务调用</strong>：当客户端需要调用服务器端的服务时，可以使用这个函数创建一个新的流。</li>
<li><strong>请求发送</strong>：客户端可以通过这个流发送请求消息给服务器端。</li>
</ul>
</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kn">package</span> <span class="nx">main</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;context&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;fmt&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;google.golang.org/grpc&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;time&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">ctx</span><span class="p">,</span> <span class="nx">cancel</span> <span class="o">:=</span> <span class="nx">context</span><span class="p">.</span><span class="nf">WithTimeout</span><span class="p">(</span><span class="nx">context</span><span class="p">.</span><span class="nf">Background</span><span class="p">(),</span> <span class="mi">5</span><span class="o">*</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">defer</span> <span class="nf">cancel</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">conn</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">grpc</span><span class="p">.</span><span class="nf">DialContext</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="s">&#34;localhost:50051&#34;</span><span class="p">,</span> <span class="nx">grpc</span><span class="p">.</span><span class="nf">WithBlock</span><span class="p">())</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;Failed to dial: %v\n&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">defer</span> <span class="nx">conn</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 创建一个新的流
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">stream</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">conn</span><span class="p">.</span><span class="nf">NewStream</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">StreamDesc</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// 流描述
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="p">},</span> <span class="s">&#34;MyService.MyMethod&#34;</span><span class="p">,</span> <span class="nx">grpc</span><span class="p">.</span><span class="nf">FailOnNonTempDialError</span><span class="p">(</span><span class="kc">true</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;Failed to create stream: %v\n&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 发送请求消息
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 接收响应消息
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 关闭流
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">stream</span><span class="p">.</span><span class="nf">CloseSend</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><ol start="4">
<li>在这个例子中，我们创建了一个上下文，设置了5秒的超时时间。然后，我们尝试建立与服务器端口50051的gRPC连接。如果连接成功，我们使用<code>NewStream</code>函数创建一个新的流，并指定要调用的RPC方法和一些流选项。接下来，我们可以通过这个流发送请求消息给服务器端，并接收响应消息。最后，我们关闭流以释放资源。</li>
</ol>
<h3 id="cc-resetconnectbackoff">(cc) ResetConnectBackoff()<a hidden class="anchor" aria-hidden="true" href="#cc-resetconnectbackoff">#</a></h3>
<ol>
<li>ResetConnectBackoff唤醒所有暂时失败的子通道，并使它们立即尝试另一个连接。它还重置用于后续尝试的后退时间，而不管当前状态如何。</li>
<li>一般来说，不应该使用这个函数。在默认情况下，典型的服务或网络中断会导致合理的客户端重新连接策略。但是，如果先前不可用的网络变得可用，则可以使用此命令触发立即重新连接。</li>
<li>注意:此API是实验性的，可能会在以后的版本中更改或删除。</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// ResetConnectBackoff wakes up all subchannels in transient failure and causes
</span></span></span><span class="line"><span class="cl"><span class="c1">// them to attempt another connection immediately.  It also resets the backoff
</span></span></span><span class="line"><span class="cl"><span class="c1">// times used for subsequent attempts regardless of the current state.
</span></span></span><span class="line"><span class="cl"><span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1">// In general, this function should not be used.  Typical service or network
</span></span></span><span class="line"><span class="cl"><span class="c1">// outages result in a reasonable client reconnection strategy by default.
</span></span></span><span class="line"><span class="cl"><span class="c1">// However, if a previously unavailable network becomes available, this may be
</span></span></span><span class="line"><span class="cl"><span class="c1">// used to trigger an immediate reconnect.
</span></span></span><span class="line"><span class="cl"><span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1">// # Experimental
</span></span></span><span class="line"><span class="cl"><span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1">// Notice: This API is EXPERIMENTAL and may be changed or removed in a
</span></span></span><span class="line"><span class="cl"><span class="c1">// later release.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">cc</span> <span class="o">*</span><span class="nx">ClientConn</span><span class="p">)</span> <span class="nf">ResetConnectBackoff</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">cc</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="nx">conns</span> <span class="o">:=</span> <span class="nx">cc</span><span class="p">.</span><span class="nx">conns</span>
</span></span><span class="line"><span class="cl">	<span class="nx">cc</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="nx">ac</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">conns</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">ac</span><span class="p">.</span><span class="nf">resetConnectBackoff</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h4 id="详解-4">详解<a hidden class="anchor" aria-hidden="true" href="#详解-4">#</a></h4>
<ol>
<li>它用于重置客户端连接的退避重试策略。这个函数在客户端遇到短暂故障并希望立即尝试重新连接时非常有用。</li>
<li><strong>作用</strong>：
<ul>
<li><strong>立即重试</strong>：当客户端遇到短暂故障（如网络问题）时，可以使用这个函数来立即重试连接，而不是等待预设的退避重试间隔。</li>
<li><strong>状态重置</strong>：无论当前连接状态如何，这个函数都会重置后续尝试的退避时间。</li>
</ul>
</li>
<li><strong>使用场景</strong>：
<ul>
<li><strong>网络恢复</strong>：当网络故障恢复时，客户端可以调用这个函数来立即尝试重新连接。</li>
<li><strong>异常处理</strong>：在某些情况下，客户端可能需要绕过正常的退避重试策略，例如，当连接是由于客户端自身的问题（如客户端的代码错误）导致失败时。</li>
</ul>
</li>
<li>需要注意的是，<code>ResetConnectBackoff</code> 函数是实验性的，可能会在未来的gRPC版本中更改或移除。因此，在生产环境中使用这个函数之前，应该仔细评估其稳定性和适用性。</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kn">package</span> <span class="nx">main</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;context&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;fmt&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;google.golang.org/grpc&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;time&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">ctx</span><span class="p">,</span> <span class="nx">cancel</span> <span class="o">:=</span> <span class="nx">context</span><span class="p">.</span><span class="nf">WithTimeout</span><span class="p">(</span><span class="nx">context</span><span class="p">.</span><span class="nf">Background</span><span class="p">(),</span> <span class="mi">5</span><span class="o">*</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">defer</span> <span class="nf">cancel</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">conn</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">grpc</span><span class="p">.</span><span class="nf">DialContext</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="s">&#34;localhost:50051&#34;</span><span class="p">,</span> <span class="nx">grpc</span><span class="p">.</span><span class="nf">WithBlock</span><span class="p">())</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;Failed to dial: %v\n&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">defer</span> <span class="nx">conn</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 假设在连接过程中遇到了短暂故障
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">if</span> <span class="nx">conn</span><span class="p">.</span><span class="nf">WaitForStateChange</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">connectivity</span><span class="p">.</span><span class="nx">StateIdle</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;Connection state changed to READY&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;Connection state change timeout&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 网络故障恢复，重置连接退避
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">conn</span><span class="p">.</span><span class="nf">ResetConnectBackoff</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 再次尝试连接
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">if</span> <span class="nx">conn</span><span class="p">.</span><span class="nf">WaitForStateChange</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">connectivity</span><span class="p">.</span><span class="nx">StateIdle</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;Connection state changed to READY&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;Connection state change timeout&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><ol start="5">
<li>在这个例子中，我们创建了一个上下文，设置了5秒的超时时间。然后，我们尝试建立与服务器端口50051的gRPC连接。如果连接成功，我们使用<code>WaitForStateChange</code>函数等待连接状态从<code>IDLE</code>变为<code>READY</code>。如果在5秒内状态没有改变，我们将打印出超时的消息。随后，我们假设遇到了网络故障，并调用<code>ResetConnectBackoff</code>函数重置连接退避。最后，我们再次尝试连接并等待状态变化。</li>
</ol>
<h3 id="cc-target">(cc) Target()<a hidden class="anchor" aria-hidden="true" href="#cc-target">#</a></h3>
<ol>
<li>Target返回ClientConn的目标字符串。</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// Target returns the target string of the ClientConn.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">cc</span> <span class="o">*</span><span class="nx">ClientConn</span><span class="p">)</span> <span class="nf">Target</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nx">cc</span><span class="p">.</span><span class="nx">target</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h4 id="示例-2">示例<a hidden class="anchor" aria-hidden="true" href="#示例-2">#</a></h4>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 配置ssl，&#34;*.heliu.site&#34;在实际开发中从浏览器中取获取，证书路径使用绝对路径
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">creds</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">credentials</span><span class="p">.</span><span class="nf">NewClientTLSFromFile</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">		<span class="s">&#34;/root/workspace/learn-grpc/key/test.pem&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">		<span class="s">&#34;*.heliu.site&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">	<span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="kd">var</span> <span class="nx">opts</span> <span class="p">[]</span><span class="nx">grpc</span><span class="p">.</span><span class="nx">DialOption</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 不带TLS这里是grpc.WithTransportCredentials(insecure.NewCredentials())
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">opts</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">opts</span><span class="p">,</span> <span class="nx">grpc</span><span class="p">.</span><span class="nf">WithTransportCredentials</span><span class="p">(</span><span class="nx">creds</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">	<span class="nx">opts</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">opts</span><span class="p">,</span> <span class="nx">grpc</span><span class="p">.</span><span class="nf">WithPerRPCCredentials</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">ClientTokenAuth</span><span class="p">{}))</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 添加客户端拦截器
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">opts</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">opts</span><span class="p">,</span> <span class="nx">grpc</span><span class="p">.</span><span class="nf">WithUnaryInterceptor</span><span class="p">(</span><span class="nx">interceptor</span><span class="p">.</span><span class="nf">UnaryClientInterceptor</span><span class="p">()))</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 添加流拦截器
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">opts</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">opts</span><span class="p">,</span> <span class="nx">grpc</span><span class="p">.</span><span class="nf">WithStreamInterceptor</span><span class="p">(</span><span class="nx">interceptor</span><span class="p">.</span><span class="nf">StreamClientInterceptor</span><span class="p">()))</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 连接server端，使用ssl加密通信
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">conn</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">grpc</span><span class="p">.</span><span class="nf">NewClient</span><span class="p">(</span><span class="s">&#34;127.0.0.1:9090&#34;</span><span class="p">,</span> <span class="nx">opts</span><span class="o">...</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">log</span><span class="p">.</span><span class="nf">Fatalf</span><span class="p">(</span><span class="s">&#34;did not connect: %v&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">defer</span> <span class="nx">conn</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// Target(): 127.0.0.1:9090
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">log</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;Target(): %s\n&#34;</span><span class="p">,</span> <span class="nx">conn</span><span class="p">.</span><span class="nf">Target</span><span class="p">())</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 建立连接
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">client</span> <span class="o">:=</span> <span class="nx">pb</span><span class="p">.</span><span class="nf">NewSayHelloClient</span><span class="p">(</span><span class="nx">conn</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></div><h3 id="cc-waitforstatechangectx-sourcestate">(cc) WaitForStateChange(ctx, sourceState)<a hidden class="anchor" aria-hidden="true" href="#cc-waitforstatechangectx-sourcestate">#</a></h3>
<ol>
<li>WaitForStateChange等待，直到ClientConn的connectivity.State从sourceState更改或ctx过期。</li>
<li>前一种情况返回真值，后一种情况返回假值。</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// WaitForStateChange waits until the connectivity.State of ClientConn changes from sourceState or
</span></span></span><span class="line"><span class="cl"><span class="c1">// ctx expires. A true value is returned in former case and false in latter.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">cc</span> <span class="o">*</span><span class="nx">ClientConn</span><span class="p">)</span> <span class="nf">WaitForStateChange</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">sourceState</span> <span class="nx">connectivity</span><span class="p">.</span><span class="nx">State</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">ch</span> <span class="o">:=</span> <span class="nx">cc</span><span class="p">.</span><span class="nx">csMgr</span><span class="p">.</span><span class="nf">getNotifyChan</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">cc</span><span class="p">.</span><span class="nx">csMgr</span><span class="p">.</span><span class="nf">getState</span><span class="p">()</span> <span class="o">!=</span> <span class="nx">sourceState</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="kc">true</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">select</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">case</span> <span class="o">&lt;-</span><span class="nx">ctx</span><span class="p">.</span><span class="nf">Done</span><span class="p">():</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="kc">false</span>
</span></span><span class="line"><span class="cl">	<span class="k">case</span> <span class="o">&lt;-</span><span class="nx">ch</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="kc">true</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h4 id="详解-5">详解<a hidden class="anchor" aria-hidden="true" href="#详解-5">#</a></h4>
<ol>
<li>它用于等待客户端连接的状态从指定的源状态（<code>sourceState</code>）改变。这个函数在客户端需要等待连接状态变化时非常有用，例如，当客户端需要检测到网络的恢复时。</li>
<li><strong>作用</strong>：
<ul>
<li><strong>状态监控</strong>：允许客户端在连接状态改变时进行响应，例如，当网络中断后恢复时。</li>
<li><strong>错误处理</strong>：在等待状态变化的过程中，如果超时，客户端可以进行适当的错误处理。</li>
</ul>
</li>
<li><strong>使用场景</strong>：
<ul>
<li><strong>网络恢复检测</strong>：当客户端连接的网络出现问题，可以使用这个函数来检测网络是否恢复。</li>
<li><strong>连接状态监控</strong>：在需要监控连接状态变化的应用场景中，如客户端需要根据连接状态调整其行为。</li>
</ul>
</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kn">package</span> <span class="nx">main</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;context&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;fmt&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;google.golang.org/grpc&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;time&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">ctx</span><span class="p">,</span> <span class="nx">cancel</span> <span class="o">:=</span> <span class="nx">context</span><span class="p">.</span><span class="nf">WithTimeout</span><span class="p">(</span><span class="nx">context</span><span class="p">.</span><span class="nf">Background</span><span class="p">(),</span> <span class="mi">5</span><span class="o">*</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">defer</span> <span class="nf">cancel</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">conn</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">grpc</span><span class="p">.</span><span class="nf">DialContext</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="s">&#34;localhost:50051&#34;</span><span class="p">,</span> <span class="nx">grpc</span><span class="p">.</span><span class="nf">WithBlock</span><span class="p">())</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;Failed to dial: %v\n&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">defer</span> <span class="nx">conn</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 等待连接状态从DOWN变为READY
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">if</span> <span class="nx">conn</span><span class="p">.</span><span class="nf">WaitForStateChange</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">connectivity</span><span class="p">.</span><span class="nx">StateDown</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;Connection state changed to READY&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;Connection state change timeout&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><ol start="4">
<li>在这个例子中，我们创建了一个上下文，设置了5秒的超时时间。然后，我们尝试建立与服务器端口50051的gRPC连接。如果连接成功，我们使用<code>WaitForStateChange</code>函数等待连接状态从<code>DOWN</code>变为<code>READY</code>。如果在5秒内状态没有改变，我们将打印出超时的消息。</li>
</ol>
<h2 id="type-dialoption">type DialOption<a hidden class="anchor" aria-hidden="true" href="#type-dialoption">#</a></h2>
<ol>
<li>DialOption配置我们如何设置连接。</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">DialOption</span> <span class="kd">interface</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nf">apply</span><span class="p">(</span><span class="o">*</span><span class="nx">dialOptions</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h3 id="withauthoritya">WithAuthority(a)<a hidden class="anchor" aria-hidden="true" href="#withauthoritya">#</a></h3>
<ol>
<li>WithAuthority返回一个DialOption，该DialOption指定要用作:authority伪头和身份验证握手中的服务器名称的值。</li>
<li>在HTTP/2协议中，:authority 是一个伪头部字段，用于携带请求的原始主机和端口信息。这个字段相当于HTTP/1.1中的Host头部字段，但在HTTP/2中，由于采用了新的头部压缩机制，:authority 被用作一个伪头部来区分实际的请求头部。</li>
<li>具体来说，:authority 字段通常包含以下内容：
<ul>
<li>主机名（例如 <a href="https://www.example.com" target="_blank" rel="noopener">www.example.com</a>）</li>
<li>端口号（如果使用了非标准端口，例如 :8080）</li>
</ul>
</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// WithAuthority returns a DialOption that specifies the value to be used as the
</span></span></span><span class="line"><span class="cl"><span class="c1">// :authority pseudo-header and as the server name in authentication handshake.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">WithAuthority</span><span class="p">(</span><span class="nx">a</span> <span class="kt">string</span><span class="p">)</span> <span class="nx">DialOption</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nf">newFuncDialOption</span><span class="p">(</span><span class="kd">func</span><span class="p">(</span><span class="nx">o</span> <span class="o">*</span><span class="nx">dialOptions</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">o</span><span class="p">.</span><span class="nx">authority</span> <span class="p">=</span> <span class="nx">a</span>
</span></span><span class="line"><span class="cl">    <span class="p">})</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h4 id="详情">详情<a hidden class="anchor" aria-hidden="true" href="#详情">#</a></h4>
<ol>
<li>用于指定在连接到gRPC服务器时使用的权威（authority）信息。这个权威信息通常包含服务器的域名或IP地址，并且是连接请求中的一个重要部分，因为它用于服务器身份验证和RPC方法的选择。</li>
<li><strong>作用</strong>：
<ul>
<li><strong>服务器识别</strong>：指定权威信息有助于服务器识别客户端的请求，并选择适当的RPC方法。</li>
<li><strong>身份验证</strong>：在某些情况下，权威信息用于服务器端的认证过程。</li>
</ul>
</li>
<li><strong>使用场景</strong>：
<ul>
<li><strong>客户端配置</strong>：在客户端代码中，可以通过传递<code>WithAuthority</code>选项来指定要连接的服务器的权威信息。</li>
<li><strong>服务发现</strong>：在服务发现场景中，客户端可能需要根据服务注册表中的权威信息来连接到正确的服务器。</li>
</ul>
</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kn">package</span> <span class="nx">main</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;context&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;fmt&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;google.golang.org/grpc&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;time&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">ctx</span><span class="p">,</span> <span class="nx">cancel</span> <span class="o">:=</span> <span class="nx">context</span><span class="p">.</span><span class="nf">WithTimeout</span><span class="p">(</span><span class="nx">context</span><span class="p">.</span><span class="nf">Background</span><span class="p">(),</span> <span class="mi">5</span><span class="o">*</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">defer</span> <span class="nf">cancel</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 指定要连接的服务器的权威信息
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">opts</span> <span class="o">:=</span> <span class="p">[]</span><span class="nx">grpc</span><span class="p">.</span><span class="nx">DialOption</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">grpc</span><span class="p">.</span><span class="nf">WithAuthority</span><span class="p">(</span><span class="s">&#34;example.com:50051&#34;</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">conn</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">grpc</span><span class="p">.</span><span class="nf">DialContext</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="s">&#34;localhost:50051&#34;</span><span class="p">,</span> <span class="nx">opts</span><span class="o">...</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;Failed to dial: %v\n&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">defer</span> <span class="nx">conn</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 客户端可以继续使用这个连接进行RPC调用
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></div><ol start="4">
<li>在这个例子中，我们创建了一个上下文，设置了5秒的超时时间。然后，我们使用<code>WithAuthority</code>选项指定要连接的服务器的权威信息。最后，我们使用这些选项来建立与服务器端口50051的gRPC连接。如果连接成功，客户端可以继续使用这个连接进行RPC调用。</li>
</ol>
<h3 id="withchainstreaminterceptorinterceptors">WithChainStreamInterceptor(interceptors)<a hidden class="anchor" aria-hidden="true" href="#withchainstreaminterceptorinterceptors">#</a></h3>
<ol>
<li>WithChainStreamInterceptor返回一个DialOption，用于指定流rpc的链式拦截器。</li>
<li>第一个拦截器将是最外层的，而最后一个拦截器将是围绕实际调用的最内层的包装器。</li>
<li>此方法添加的所有拦截器都将被链接，并且由WithStreamInterceptor定义的拦截器将始终被添加到链中。</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// WithChainStreamInterceptor returns a DialOption that specifies the chained
</span></span></span><span class="line"><span class="cl"><span class="c1">// interceptor for streaming RPCs. The first interceptor will be the outer most,
</span></span></span><span class="line"><span class="cl"><span class="c1">// while the last interceptor will be the inner most wrapper around the real call.
</span></span></span><span class="line"><span class="cl"><span class="c1">// All interceptors added by this method will be chained, and the interceptor
</span></span></span><span class="line"><span class="cl"><span class="c1">// defined by WithStreamInterceptor will always be prepended to the chain.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">WithChainStreamInterceptor</span><span class="p">(</span><span class="nx">interceptors</span> <span class="o">...</span><span class="nx">StreamClientInterceptor</span><span class="p">)</span> <span class="nx">DialOption</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nf">newFuncDialOption</span><span class="p">(</span><span class="kd">func</span><span class="p">(</span><span class="nx">o</span> <span class="o">*</span><span class="nx">dialOptions</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">o</span><span class="p">.</span><span class="nx">chainStreamInts</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">o</span><span class="p">.</span><span class="nx">chainStreamInts</span><span class="p">,</span> <span class="nx">interceptors</span><span class="o">...</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">})</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h4 id="详情-1">详情<a hidden class="anchor" aria-hidden="true" href="#详情-1">#</a></h4>
<ol>
<li>用于为gRPC客户端的流式RPC（streaming RPC）添加一个拦截器链（interceptor chain）。这个拦截器链会在客户端发送流式RPC请求和接收响应时被调用。</li>
<li><strong>作用</strong>：
<ul>
<li><strong>拦截器逻辑</strong>：允许客户端在流式RPC的各个阶段添加自定义逻辑。</li>
<li><strong>功能扩展</strong>：通过组合不同的拦截器，可以实现更复杂的客户端功能，例如请求和响应的修改、错误处理、日志记录等。</li>
</ul>
</li>
<li><strong>使用场景</strong>：
<ul>
<li><strong>日志记录</strong>：在流式RPC的发送和接收过程中添加日志记录功能。</li>
<li><strong>请求修改</strong>：在发送请求之前对请求进行修改。</li>
<li><strong>响应修改</strong>：在接收响应之前对响应进行修改。</li>
</ul>
</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kn">package</span> <span class="nx">main</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;context&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;fmt&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;google.golang.org/grpc&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;time&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 定义一个简单的StreamClientInterceptor
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">loggingInterceptor</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">desc</span> <span class="o">*</span><span class="nx">grpc</span><span class="p">.</span><span class="nx">StreamDesc</span><span class="p">,</span> <span class="nx">cc</span> <span class="o">*</span><span class="nx">grpc</span><span class="p">.</span><span class="nx">ClientConn</span><span class="p">,</span> <span class="nx">method</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">opts</span> <span class="o">...</span><span class="nx">grpc</span><span class="p">.</span><span class="nx">CallOption</span><span class="p">)</span> <span class="p">(</span><span class="nx">grpc</span><span class="p">.</span><span class="nx">ClientStream</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">stream</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">cc</span><span class="p">.</span><span class="nf">NewStream</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">desc</span><span class="p">,</span> <span class="nx">method</span><span class="p">,</span> <span class="nx">opts</span><span class="o">...</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">err</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="o">&amp;</span><span class="nx">loggingStream</span><span class="p">{</span><span class="nx">stream</span><span class="p">},</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">loggingStream</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">grpc</span><span class="p">.</span><span class="nx">ClientStream</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">loggingStream</span><span class="p">)</span> <span class="nf">SendMsg</span><span class="p">(</span><span class="nx">m</span> <span class="kd">interface</span><span class="p">{})</span> <span class="kt">error</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;Sending message: %v\n&#34;</span><span class="p">,</span> <span class="nx">m</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nx">s</span><span class="p">.</span><span class="nx">ClientStream</span><span class="p">.</span><span class="nf">SendMsg</span><span class="p">(</span><span class="nx">m</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">loggingStream</span><span class="p">)</span> <span class="nf">RecvMsg</span><span class="p">(</span><span class="nx">m</span> <span class="kd">interface</span><span class="p">{})</span> <span class="kt">error</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;Received message: %v\n&#34;</span><span class="p">,</span> <span class="nx">m</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nx">s</span><span class="p">.</span><span class="nx">ClientStream</span><span class="p">.</span><span class="nf">RecvMsg</span><span class="p">(</span><span class="nx">m</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">loggingStream</span><span class="p">)</span> <span class="nf">CloseSend</span><span class="p">()</span> <span class="kt">error</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;Closing send side of the stream&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nx">s</span><span class="p">.</span><span class="nx">ClientStream</span><span class="p">.</span><span class="nf">CloseSend</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">loggingStream</span><span class="p">)</span> <span class="nf">Context</span><span class="p">()</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nx">s</span><span class="p">.</span><span class="nx">ClientStream</span><span class="p">.</span><span class="nf">Context</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">ctx</span><span class="p">,</span> <span class="nx">cancel</span> <span class="o">:=</span> <span class="nx">context</span><span class="p">.</span><span class="nf">WithTimeout</span><span class="p">(</span><span class="nx">context</span><span class="p">.</span><span class="nf">Background</span><span class="p">(),</span> <span class="mi">5</span><span class="o">*</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">defer</span> <span class="nf">cancel</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 创建一个包含拦截器的DialOption
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">opts</span> <span class="o">:=</span> <span class="p">[]</span><span class="nx">grpc</span><span class="p">.</span><span class="nx">DialOption</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">grpc</span><span class="p">.</span><span class="nf">WithChainStreamInterceptor</span><span class="p">(</span><span class="nx">loggingInterceptor</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">conn</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">grpc</span><span class="p">.</span><span class="nf">DialContext</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="s">&#34;localhost:50051&#34;</span><span class="p">,</span> <span class="nx">opts</span><span class="o">...</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;Failed to dial: %v\n&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">defer</span> <span class="nx">conn</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 客户端可以继续使用这个连接进行RPC调用
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></div><ol start="4">
<li>在这个例子中，我们定义了一个简单的<code>loggingInterceptor</code>函数，它会在流式RPC的发送和接收过程中添加日志记录功能。然后，我们使用<code>WithChainStreamInterceptor</code>选项将这个拦截器添加到客户端的连接配置中。当客户端建立与服务器端口的连接并进行流式RPC调用时，<code>loggingInterceptor</code>将会被调用，并在发送和接收消息时打印日志。</li>
</ol>
<h3 id="withchainunaryinterceptorinterceptors">WithChainUnaryInterceptor(interceptors)<a hidden class="anchor" aria-hidden="true" href="#withchainunaryinterceptorinterceptors">#</a></h3>
<ol>
<li>WithChainUnaryInterceptor返回一个DialOption，用于指定一元rpc的链式拦截器。</li>
<li>第一个拦截器将是最外层的，而最后一个拦截器将是围绕实际调用的最内层的包装器。</li>
<li>通过这个方法添加的所有拦截器都将被链接起来，并且由WithUnaryInterceptor定义的拦截器将始终被添加到链中。</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// WithChainUnaryInterceptor returns a DialOption that specifies the chained
</span></span></span><span class="line"><span class="cl"><span class="c1">// interceptor for unary RPCs. The first interceptor will be the outer most,
</span></span></span><span class="line"><span class="cl"><span class="c1">// while the last interceptor will be the inner most wrapper around the real call.
</span></span></span><span class="line"><span class="cl"><span class="c1">// All interceptors added by this method will be chained, and the interceptor
</span></span></span><span class="line"><span class="cl"><span class="c1">// defined by WithUnaryInterceptor will always be prepended to the chain.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">WithChainUnaryInterceptor</span><span class="p">(</span><span class="nx">interceptors</span> <span class="o">...</span><span class="nx">UnaryClientInterceptor</span><span class="p">)</span> <span class="nx">DialOption</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nf">newFuncDialOption</span><span class="p">(</span><span class="kd">func</span><span class="p">(</span><span class="nx">o</span> <span class="o">*</span><span class="nx">dialOptions</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">o</span><span class="p">.</span><span class="nx">chainUnaryInts</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">o</span><span class="p">.</span><span class="nx">chainUnaryInts</span><span class="p">,</span> <span class="nx">interceptors</span><span class="o">...</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">})</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h4 id="详情-2">详情<a hidden class="anchor" aria-hidden="true" href="#详情-2">#</a></h4>
<ol>
<li>用于为gRPC客户端的单向RPC（unary RPC）添加一个拦截器链（interceptor chain）。这个拦截器链会在客户端发送单向RPC请求和接收响应时被调用。</li>
<li><strong>作用</strong>：
<ul>
<li><strong>拦截器逻辑</strong>：允许客户端在单向RPC的各个阶段添加自定义逻辑。</li>
<li><strong>功能扩展</strong>：通过组合不同的拦截器，可以实现更复杂的客户端功能，例如请求和响应的修改、错误处理、日志记录等。</li>
</ul>
</li>
<li><strong>使用场景</strong>：
<ul>
<li><strong>日志记录</strong>：在单向RPC的发送和接收过程中添加日志记录功能。</li>
<li><strong>请求修改</strong>：在发送请求之前对请求进行修改。</li>
<li><strong>响应修改</strong>：在接收响应之前对响应进行修改。</li>
</ul>
</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kn">package</span> <span class="nx">main</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;context&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;fmt&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;google.golang.org/grpc&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;time&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 定义一个简单的UnaryClientInterceptor
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">loggingInterceptor</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">method</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">req</span><span class="p">,</span> <span class="nx">reply</span> <span class="kd">interface</span><span class="p">{},</span> <span class="nx">cc</span> <span class="o">*</span><span class="nx">grpc</span><span class="p">.</span><span class="nx">ClientConn</span><span class="p">,</span> <span class="nx">invoker</span> <span class="nx">grpc</span><span class="p">.</span><span class="nx">UnaryInvoker</span><span class="p">,</span> <span class="nx">opts</span> <span class="o">...</span><span class="nx">grpc</span><span class="p">.</span><span class="nx">CallOption</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;Sending request: %v\n&#34;</span><span class="p">,</span> <span class="nx">req</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">err</span> <span class="o">:=</span> <span class="nf">invoker</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">method</span><span class="p">,</span> <span class="nx">req</span><span class="p">,</span> <span class="nx">reply</span><span class="p">,</span> <span class="nx">cc</span><span class="p">,</span> <span class="nx">opts</span><span class="o">...</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="nx">err</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;Received response: %v\n&#34;</span><span class="p">,</span> <span class="nx">reply</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">ctx</span><span class="p">,</span> <span class="nx">cancel</span> <span class="o">:=</span> <span class="nx">context</span><span class="p">.</span><span class="nf">WithTimeout</span><span class="p">(</span><span class="nx">context</span><span class="p">.</span><span class="nf">Background</span><span class="p">(),</span> <span class="mi">5</span><span class="o">*</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">defer</span> <span class="nf">cancel</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 创建一个包含拦截器的DialOption
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">opts</span> <span class="o">:=</span> <span class="p">[]</span><span class="nx">grpc</span><span class="p">.</span><span class="nx">DialOption</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">grpc</span><span class="p">.</span><span class="nf">WithChainUnaryInterceptor</span><span class="p">(</span><span class="nx">loggingInterceptor</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">conn</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">grpc</span><span class="p">.</span><span class="nf">DialContext</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="s">&#34;localhost:50051&#34;</span><span class="p">,</span> <span class="nx">opts</span><span class="o">...</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;Failed to dial: %v\n&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">defer</span> <span class="nx">conn</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 客户端可以继续使用这个连接进行RPC调用
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></div><ol start="4">
<li>在这个例子中，我们定义了一个简单的<code>loggingInterceptor</code>函数，它会在单向RPC的发送和接收过程中添加日志记录功能。然后，我们使用<code>WithChainUnaryInterceptor</code>选项将这个拦截器添加到客户端的连接配置中。当客户端建立与服务器端口的连接并进行单向RPC调用时，<code>loggingInterceptor</code>将会被调用，并在发送请求和接收响应时打印日志。</li>
</ol>
<h3 id="withchannelzparentidc">WithChannelzParentID(c)<a hidden class="anchor" aria-hidden="true" href="#withchannelzparentidc">#</a></h3>
<ol>
<li>WithChannelzParentID返回一个DialOption，它指定当前ClientConn父节点的channelz ID。此函数用于嵌套通道创建(例如grpclb dial)。</li>
<li>注意:此API是实验性的，可能会在以后的版本中更改或删除。</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// WithChannelzParentID returns a DialOption that specifies the channelz ID of
</span></span></span><span class="line"><span class="cl"><span class="c1">// current ClientConn&#39;s parent. This function is used in nested channel creation
</span></span></span><span class="line"><span class="cl"><span class="c1">// (e.g. grpclb dial).
</span></span></span><span class="line"><span class="cl"><span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1">// # Experimental
</span></span></span><span class="line"><span class="cl"><span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1">// Notice: This API is EXPERIMENTAL and may be changed or removed in a
</span></span></span><span class="line"><span class="cl"><span class="c1">// later release.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">WithChannelzParentID</span><span class="p">(</span><span class="nx">c</span> <span class="nx">channelz</span><span class="p">.</span><span class="nx">Identifier</span><span class="p">)</span> <span class="nx">DialOption</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nf">newFuncDialOption</span><span class="p">(</span><span class="kd">func</span><span class="p">(</span><span class="nx">o</span> <span class="o">*</span><span class="nx">dialOptions</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">o</span><span class="p">.</span><span class="nx">channelzParent</span> <span class="p">=</span> <span class="nx">c</span>
</span></span><span class="line"><span class="cl">    <span class="p">})</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><ol start="3">
<li>用于配置客户端连接选项，以指定当前客户端连接的父级通道ID。这个函数通常用于嵌套通道创建的情况，例如使用gRPC负载均衡器（grpclb）进行拨号时。</li>
<li>功能说明：<code>WithChannelzParentID</code>函数允许你为gRPC客户端连接指定一个父级通道ID。在gRPC中，通道（channel）是客户端和服务器之间通信的抽象，而通道ID是用于标识和管理这些通道的机制。通过指定一个父级通道ID，你可以跟踪和管理嵌套的通道，这在使用gRPC负载均衡器或其他类型的通道管理时非常有用。</li>
<li>参数说明：<strong>c</strong>：这是一个<code>channelz.Identifier</code>类型的值，用于标识当前客户端连接的父级通道。</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kn">package</span> <span class="nx">main</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;context&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;log&#34;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="s">&#34;google.golang.org/grpc&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;google.golang.org/grpc/channelz&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">serverAddr</span> <span class="o">:=</span> <span class="s">&#34;localhost:50051&#34;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 创建一个channelz标识符
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">parentID</span> <span class="o">:=</span> <span class="nx">channelz</span><span class="p">.</span><span class="nx">Identifier</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">ChannelType</span><span class="p">:</span> <span class="nx">channelz</span><span class="p">.</span><span class="nx">CHANNEL_TYPE_GRPC_CLIENT</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">		<span class="nx">Address</span><span class="p">:</span>     <span class="s">&#34;localhost:50051&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 创建gRPC连接时应用WithChannelzParentID选项
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">conn</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">grpc</span><span class="p">.</span><span class="nf">Dial</span><span class="p">(</span><span class="nx">serverAddr</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">		<span class="nx">grpc</span><span class="p">.</span><span class="nf">WithInsecure</span><span class="p">(),</span>
</span></span><span class="line"><span class="cl">		<span class="nx">grpc</span><span class="p">.</span><span class="nf">WithChannelzParentID</span><span class="p">(</span><span class="nx">parentID</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">	<span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">log</span><span class="p">.</span><span class="nf">Fatalf</span><span class="p">(</span><span class="s">&#34;did not connect: %v&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">defer</span> <span class="nx">conn</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// ... 使用连接进行后续操作 ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></div><ol start="6">
<li>在这个示例中，我们创建了一个channelz标识符，并使用了<code>WithChannelzParentID</code>选项来创建到服务器的连接。</li>
<li>注意事项：
<ul>
<li>这是一个实验性的API，可能会在未来版本中发生变化或被移除。</li>
<li>在实际应用中，你可能需要根据你的应用程序架构和通道管理需求来设置父级通道ID。</li>
</ul>
</li>
<li>通过使用<code>WithChannelzParentID</code>，你可以根据应用程序的需求来跟踪和管理嵌套的gRPC通道，特别是在需要复杂的通道管理时。</li>
</ol>
<h3 id="withconnectparamsp">WithConnectParams(p)<a hidden class="anchor" aria-hidden="true" href="#withconnectparamsp">#</a></h3>
<ol>
<li>WithConnectParams将ClientConn配置为使用提供的ConnectParams来创建和维护到服务器的连接。</li>
<li>作为ConnectParams的一部分指定的回退配置覆盖https://github.com/grpc/grpc/blob/master/doc/connection-backoff.md中指定的所有默认值。考虑使用后退。DefaultConfig作为基础，在您只想覆盖回退配置的子集的情况下。</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// WithConnectParams configures the ClientConn to use the provided ConnectParams
</span></span></span><span class="line"><span class="cl"><span class="c1">// for creating and maintaining connections to servers.
</span></span></span><span class="line"><span class="cl"><span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1">// The backoff configuration specified as part of the ConnectParams overrides
</span></span></span><span class="line"><span class="cl"><span class="c1">// all defaults specified in
</span></span></span><span class="line"><span class="cl"><span class="c1">// https://github.com/grpc/grpc/blob/master/doc/connection-backoff.md. Consider
</span></span></span><span class="line"><span class="cl"><span class="c1">// using the backoff.DefaultConfig as a base, in cases where you want to
</span></span></span><span class="line"><span class="cl"><span class="c1">// override only a subset of the backoff configuration.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">WithConnectParams</span><span class="p">(</span><span class="nx">p</span> <span class="nx">ConnectParams</span><span class="p">)</span> <span class="nx">DialOption</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nf">newFuncDialOption</span><span class="p">(</span><span class="kd">func</span><span class="p">(</span><span class="nx">o</span> <span class="o">*</span><span class="nx">dialOptions</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">o</span><span class="p">.</span><span class="nx">bs</span> <span class="p">=</span> <span class="nx">internalbackoff</span><span class="p">.</span><span class="nx">Exponential</span><span class="p">{</span><span class="nx">Config</span><span class="p">:</span> <span class="nx">p</span><span class="p">.</span><span class="nx">Backoff</span><span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="nx">o</span><span class="p">.</span><span class="nx">minConnectTimeout</span> <span class="p">=</span> <span class="kd">func</span><span class="p">()</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Duration</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="nx">p</span><span class="p">.</span><span class="nx">MinConnectTimeout</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">})</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><ol start="3">
<li>用于配置客户端连接选项，以使用提供的<code>ConnectParams</code>配置来创建和维护与服务器的连接。</li>
<li>功能说明：<code>WithConnectParams</code>函数允许你提供一个自定义的连接参数配置，这个配置将用于gRPC客户端在创建和维护与服务器的连接时使用。这个选项可以用来配置连接重试的策略，包括重试的间隔、最大尝试次数等。</li>
<li>参数说明：<strong>p</strong>：这是一个<code>ConnectParams</code>类型的值，包含了连接参数的配置。</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kn">package</span> <span class="nx">main</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;context&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;log&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;time&#34;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="s">&#34;google.golang.org/grpc&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">ConnectParams</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">Backoff</span> <span class="nx">BackoffConfig</span>
</span></span><span class="line"><span class="cl">	<span class="nx">MinConnectTimeout</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Duration</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">serverAddr</span> <span class="o">:=</span> <span class="s">&#34;localhost:50051&#34;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 设置连接参数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">connectParams</span> <span class="o">:=</span> <span class="nx">ConnectParams</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">Backoff</span><span class="p">:</span> <span class="nx">BackoffConfig</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nx">InitialBackoff</span><span class="p">:</span> <span class="mi">100</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Millisecond</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">			<span class="nx">MaxBackoff</span><span class="p">:</span>     <span class="mi">1</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">			<span class="nx">Multiplier</span><span class="p">:</span>     <span class="mf">1.5</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">		<span class="p">},</span>
</span></span><span class="line"><span class="cl">		<span class="nx">MinConnectTimeout</span><span class="p">:</span> <span class="mi">10</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 创建gRPC连接时应用WithConnectParams选项
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">conn</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">grpc</span><span class="p">.</span><span class="nf">Dial</span><span class="p">(</span><span class="nx">serverAddr</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">		<span class="nx">grpc</span><span class="p">.</span><span class="nf">WithInsecure</span><span class="p">(),</span>
</span></span><span class="line"><span class="cl">		<span class="nx">grpc</span><span class="p">.</span><span class="nf">WithConnectParams</span><span class="p">(</span><span class="nx">connectParams</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">	<span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">log</span><span class="p">.</span><span class="nf">Fatalf</span><span class="p">(</span><span class="s">&#34;did not connect: %v&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">defer</span> <span class="nx">conn</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// ... 使用连接进行后续操作 ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></div><ol start="6">
<li>在这个示例中，我们设置了一个连接参数配置，并使用了<code>WithConnectParams</code>选项来创建到服务器的连接。</li>
<li>注意事项：
<ul>
<li>连接参数配置中的<code>Backoff</code>字段可以覆盖gRPC默认的连接重试策略。</li>
<li>你可以使用这个选项来配置连接重试的策略，包括重试的间隔、最大尝试次数等。</li>
</ul>
</li>
<li>通过使用<code>WithConnectParams</code>，你可以根据应用程序的需求来配置gRPC客户端的连接行为，特别是在需要自定义连接重试策略时。</li>
</ol>
<h3 id="withcontextdialerf">WithContextDialer(f)<a hidden class="anchor" aria-hidden="true" href="#withcontextdialerf">#</a></h3>
<ol>
<li>WithContextDialer返回一个DialOption，它设置一个dialer来创建连接。如果FailOnNonTempDialError()设置为true，并且f返回一个错误，gRPC检查错误的Temporary()方法来决定是否应该尝试重新连接到网络地址。</li>
<li>注意:所有支持的Go版本(截至2023年12月)都覆盖了操作系统默认的TCP保持时间和间隔为15秒。要使TCP保持连接与操作系统默认的保持连接时间和间隔，请使用net。Dialer将KeepAlive字段设置为负值，并将SO_KEEPALIVE套接字选项从Control字段设置为true。有关如何做到这一点的具体示例，请参见internal.NetDialerWithTCPKeepalive()。</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// WithContextDialer returns a DialOption that sets a dialer to create
</span></span></span><span class="line"><span class="cl"><span class="c1">// connections. If FailOnNonTempDialError() is set to true, and an error is
</span></span></span><span class="line"><span class="cl"><span class="c1">// returned by f, gRPC checks the error&#39;s Temporary() method to decide if it
</span></span></span><span class="line"><span class="cl"><span class="c1">// should try to reconnect to the network address.
</span></span></span><span class="line"><span class="cl"><span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1">// Note: All supported releases of Go (as of December 2023) override the OS
</span></span></span><span class="line"><span class="cl"><span class="c1">// defaults for TCP keepalive time and interval to 15s. To enable TCP keepalive
</span></span></span><span class="line"><span class="cl"><span class="c1">// with OS defaults for keepalive time and interval, use a net.Dialer that sets
</span></span></span><span class="line"><span class="cl"><span class="c1">// the KeepAlive field to a negative value, and sets the SO_KEEPALIVE socket
</span></span></span><span class="line"><span class="cl"><span class="c1">// option to true from the Control field. For a concrete example of how to do
</span></span></span><span class="line"><span class="cl"><span class="c1">// this, see internal.NetDialerWithTCPKeepalive().
</span></span></span><span class="line"><span class="cl"><span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1">// For more information, please see [issue 23459] in the Go github repo.
</span></span></span><span class="line"><span class="cl"><span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1">// [issue 23459]: https://github.com/golang/go/issues/23459
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">WithContextDialer</span><span class="p">(</span><span class="nx">f</span> <span class="kd">func</span><span class="p">(</span><span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="nx">net</span><span class="p">.</span><span class="nx">Conn</span><span class="p">,</span> <span class="kt">error</span><span class="p">))</span> <span class="nx">DialOption</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nf">newFuncDialOption</span><span class="p">(</span><span class="kd">func</span><span class="p">(</span><span class="nx">o</span> <span class="o">*</span><span class="nx">dialOptions</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">o</span><span class="p">.</span><span class="nx">copts</span><span class="p">.</span><span class="nx">Dialer</span> <span class="p">=</span> <span class="nx">f</span>
</span></span><span class="line"><span class="cl">	<span class="p">})</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><ol start="3">
<li>用于配置客户端连接选项，以设置一个上下文特定的拨号器（dialer）来创建连接。</li>
<li>功能说明：<code>WithContextDialer</code>函数允许你提供一个自定义的拨号器，这个拨号器将在创建gRPC客户端连接时使用。你可以使用这个选项来配置网络连接的各个方面，比如超时设置、TCP保活参数等。</li>
<li>参数说明：<strong>f</strong>：这是一个函数类型，接受一个<code>context.Context</code>和一个<code>string</code>类型的地址，并返回一个<code>net.Conn</code>和一个可能的错误。这个函数将用于创建实际的网络连接。</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kn">package</span> <span class="nx">main</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;context&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;log&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;net&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;time&#34;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="s">&#34;google.golang.org/grpc&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">serverAddr</span> <span class="o">:=</span> <span class="s">&#34;localhost:50051&#34;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 创建一个自定义的拨号器函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">dialer</span> <span class="o">:=</span> <span class="kd">func</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">addr</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="nx">net</span><span class="p">.</span><span class="nx">Conn</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">d</span> <span class="o">:=</span> <span class="nx">net</span><span class="p">.</span><span class="nx">Dialer</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nx">Timeout</span><span class="p">:</span>   <span class="mi">10</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">			<span class="nx">KeepAlive</span><span class="p">:</span> <span class="mi">15</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="nx">d</span><span class="p">.</span><span class="nf">DialContext</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="s">&#34;tcp&#34;</span><span class="p">,</span> <span class="nx">addr</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 创建gRPC连接时应用WithContextDialer选项
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">conn</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">grpc</span><span class="p">.</span><span class="nf">Dial</span><span class="p">(</span><span class="nx">serverAddr</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">		<span class="nx">grpc</span><span class="p">.</span><span class="nf">WithInsecure</span><span class="p">(),</span>
</span></span><span class="line"><span class="cl">		<span class="nx">grpc</span><span class="p">.</span><span class="nf">WithContextDialer</span><span class="p">(</span><span class="nx">dialer</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">	<span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">log</span><span class="p">.</span><span class="nf">Fatalf</span><span class="p">(</span><span class="s">&#34;did not connect: %v&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">defer</span> <span class="nx">conn</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// ... 使用连接进行后续操作 ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></div><ol start="6">
<li>在这个示例中，我们创建了一个自定义的拨号器函数，它配置了拨号超时和TCP保活参数。然后，我们使用<code>WithContextDialer</code>选项来创建到服务器的连接。</li>
<li>注意事项：
<ul>
<li>由于Go 1.19及更高版本会覆盖TCP保活的时间和间隔为15秒，如果你需要使用操作系统的默认保活参数，你可以使用<code>net.Dialer</code>并设置<code>KeepAlive</code>为负值，以及设置<code>SO_KEEPALIVE</code>套接字选项为真。</li>
<li>这个选项是一个实验性的API，可能会在未来版本中发生变化或被移除。</li>
<li>你可以使用这个选项来配置网络连接的各个方面，比如超时设置、TCP保活参数等。</li>
</ul>
</li>
<li>通过使用<code>WithContextDialer</code>，你可以根据应用程序的需求来配置gRPC客户端的连接行为，特别是在需要自定义网络连接参数时。</li>
</ol>
<h3 id="withcredentialsbundleb">WithCredentialsBundle(b)<a hidden class="anchor" aria-hidden="true" href="#withcredentialsbundleb">#</a></h3>
<ol>
<li>WithCredentialsBundle返回一个DialOption来为ClientConn.WithCreds设置一个凭据包。它不应该与WithTransportCredentials一起使用。</li>
<li>注意:此API是实验性的，可能会在以后的版本中更改或删除。</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// WithCredentialsBundle returns a DialOption to set a credentials bundle for
</span></span></span><span class="line"><span class="cl"><span class="c1">// the ClientConn.WithCreds. This should not be used together with
</span></span></span><span class="line"><span class="cl"><span class="c1">// WithTransportCredentials.
</span></span></span><span class="line"><span class="cl"><span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1">// # Experimental
</span></span></span><span class="line"><span class="cl"><span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1">// Notice: This API is EXPERIMENTAL and may be changed or removed in a
</span></span></span><span class="line"><span class="cl"><span class="c1">// later release.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">WithCredentialsBundle</span><span class="p">(</span><span class="nx">b</span> <span class="nx">credentials</span><span class="p">.</span><span class="nx">Bundle</span><span class="p">)</span> <span class="nx">DialOption</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nf">newFuncDialOption</span><span class="p">(</span><span class="kd">func</span><span class="p">(</span><span class="nx">o</span> <span class="o">*</span><span class="nx">dialOptions</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">o</span><span class="p">.</span><span class="nx">copts</span><span class="p">.</span><span class="nx">CredsBundle</span> <span class="p">=</span> <span class="nx">b</span>
</span></span><span class="line"><span class="cl">    <span class="p">})</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><ol start="3">
<li>用于配置客户端连接选项，以设置一个凭证捆绑包（credentials bundle）用于客户端连接。</li>
<li>功能说明：<code>WithCredentialsBundle</code>函数允许你提供一个凭证捆绑包，这个捆绑包包含了用于认证和加密通信的凭证。这个选项通常用于需要客户端和服务端使用相同或兼容的凭证进行认证的情况。</li>
<li>参数说明：<strong>b</strong>：这是一个<code>credentials.Bundle</code>类型的值，包含了用于认证和加密通信的凭证。</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kn">package</span> <span class="nx">main</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;context&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;log&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;google.golang.org/grpc&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;google.golang.org/grpc/credentials&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">serverAddr</span> <span class="o">:=</span> <span class="s">&#34;localhost:50051&#34;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 创建一个凭证捆绑包，包含TLS证书和客户端证书
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">bundle</span> <span class="o">:=</span> <span class="nx">credentials</span><span class="p">.</span><span class="nf">NewBundle</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="nx">bundle</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="s">&#34;path/to/client_cert.pem&#34;</span><span class="p">,</span> <span class="s">&#34;path/to/client_key.pem&#34;</span><span class="p">,</span> <span class="s">&#34;path/to/ca_cert.pem&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 创建gRPC连接时应用WithCredentialsBundle选项
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">conn</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">grpc</span><span class="p">.</span><span class="nf">Dial</span><span class="p">(</span><span class="nx">serverAddr</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">		<span class="nx">grpc</span><span class="p">.</span><span class="nf">WithInsecure</span><span class="p">(),</span> <span class="c1">// 或者使用其他传输凭证选项
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nx">grpc</span><span class="p">.</span><span class="nf">WithCredentialsBundle</span><span class="p">(</span><span class="nx">bundle</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">	<span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">log</span><span class="p">.</span><span class="nf">Fatalf</span><span class="p">(</span><span class="s">&#34;did not connect: %v&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">defer</span> <span class="nx">conn</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// ... 使用连接进行后续操作 ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></div><ol start="6">
<li>在这个示例中，我们创建了一个凭证捆绑包，并设置了客户端连接的传输凭证选项。然后，我们使用<code>WithCredentialsBundle</code>选项来创建到服务器的连接。</li>
<li>注意事项：
<ul>
<li>这是一个实验性的API，可能会在未来版本中发生变化或被移除。</li>
<li>不要与<code>WithTransportCredentials</code>一起使用。<code>WithTransportCredentials</code>用于设置传输级别的凭证，而<code>WithCredentialsBundle</code>用于设置客户端连接级别的凭证。</li>
<li>在实际应用中，你可能需要根据你的证书链和信任策略来设置凭证捆绑包。</li>
</ul>
</li>
<li>通过使用<code>WithCredentialsBundle</code>，你可以根据应用程序的需求来配置gRPC客户端的认证方式，特别是在需要客户端和服务端使用相同或兼容的凭证进行认证时。</li>
</ol>
<h3 id="withdefaultcalloptionscos">WithDefaultCallOptions(cos)<a hidden class="anchor" aria-hidden="true" href="#withdefaultcalloptionscos">#</a></h3>
<ol>
<li>WithDefaultCallOptions返回一个DialOption，它为连接上的调用设置默认的callooptions。</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// WithDefaultCallOptions returns a DialOption which sets the default
</span></span></span><span class="line"><span class="cl"><span class="c1">// CallOptions for calls over the connection.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">WithDefaultCallOptions</span><span class="p">(</span><span class="nx">cos</span> <span class="o">...</span><span class="nx">CallOption</span><span class="p">)</span> <span class="nx">DialOption</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nf">newFuncDialOption</span><span class="p">(</span><span class="kd">func</span><span class="p">(</span><span class="nx">o</span> <span class="o">*</span><span class="nx">dialOptions</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">o</span><span class="p">.</span><span class="nx">callOptions</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">o</span><span class="p">.</span><span class="nx">callOptions</span><span class="p">,</span> <span class="nx">cos</span><span class="o">...</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">})</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h4 id="详解-6">详解<a hidden class="anchor" aria-hidden="true" href="#详解-6">#</a></h4>
<ol>
<li>用于为gRPC客户端的每个RPC调用设置默认的选项（CallOptions）。这些选项会被应用到所有通过该连接发起的RPC调用中，除非在调用时显式覆盖这些选项。</li>
<li><strong>作用</strong>：
<ul>
<li><strong>默认配置</strong>：允许客户端为通过连接发起的所有RPC调用设置默认的行为选项。</li>
<li><strong>简化调用</strong>：通过设置默认选项，可以简化客户端代码，因为不需要在每个RPC调用中都显式指定这些选项。</li>
</ul>
</li>
<li><strong>使用场景</strong>：
<ul>
<li><strong>性能优化</strong>：通过设置默认的超时时间、压缩选项等，可以优化客户端的整体性能。</li>
<li><strong>错误处理</strong>：通过设置默认的重试策略，可以改善客户端在处理网络问题时的行为。</li>
</ul>
</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kn">package</span> <span class="nx">main</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;context&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;fmt&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;google.golang.org/grpc&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;time&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">ctx</span><span class="p">,</span> <span class="nx">cancel</span> <span class="o">:=</span> <span class="nx">context</span><span class="p">.</span><span class="nf">WithTimeout</span><span class="p">(</span><span class="nx">context</span><span class="p">.</span><span class="nf">Background</span><span class="p">(),</span> <span class="mi">5</span><span class="o">*</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">defer</span> <span class="nf">cancel</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 设置RPC调用的默认超时时间为5秒
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">opts</span> <span class="o">:=</span> <span class="p">[]</span><span class="nx">grpc</span><span class="p">.</span><span class="nx">DialOption</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">grpc</span><span class="p">.</span><span class="nf">WithDefaultCallOptions</span><span class="p">(</span><span class="nx">grpc</span><span class="p">.</span><span class="nf">MaxCallRecvMsgSize</span><span class="p">(</span><span class="mi">1024</span> <span class="o">*</span> <span class="mi">1024</span><span class="p">)),</span> <span class="c1">// 设置最大接收消息大小为1MB
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">conn</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">grpc</span><span class="p">.</span><span class="nf">DialContext</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="s">&#34;localhost:50051&#34;</span><span class="p">,</span> <span class="nx">opts</span><span class="o">...</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;Failed to dial: %v\n&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">defer</span> <span class="nx">conn</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 客户端可以继续使用这个连接进行RPC调用
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></div><ol start="4">
<li>在这个例子中，我们创建了一个上下文，设置了5秒的超时时间。然后，我们使用<code>WithDefaultCallOptions</code>选项为通过连接发起的所有RPC调用设置默认的超时时间。我们还将最大接收消息大小设置为1MB。最后，我们使用这些选项来建立与服务器端口50051的gRPC连接。如果连接成功，客户端可以继续使用这个连接进行RPC调用。</li>
</ol>
<h3 id="withdefaultserviceconfigs">WithDefaultServiceConfig(s)<a hidden class="anchor" aria-hidden="true" href="#withdefaultserviceconfigs">#</a></h3>
<ol>
<li>用于配置客户端连接选项，以提供一个默认的服务配置。</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// WithDefaultServiceConfig returns a DialOption that configures the default
</span></span></span><span class="line"><span class="cl"><span class="c1">// service config, which will be used in cases where:
</span></span></span><span class="line"><span class="cl"><span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1">// 1. WithDisableServiceConfig is also used, or
</span></span></span><span class="line"><span class="cl"><span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1">// 2. The name resolver does not provide a service config or provides an
</span></span></span><span class="line"><span class="cl"><span class="c1">// invalid service config.
</span></span></span><span class="line"><span class="cl"><span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1">// The parameter s is the JSON representation of the default service config.
</span></span></span><span class="line"><span class="cl"><span class="c1">// For more information about service configs, see:
</span></span></span><span class="line"><span class="cl"><span class="c1">// https://github.com/grpc/grpc/blob/master/doc/service_config.md
</span></span></span><span class="line"><span class="cl"><span class="c1">// For a simple example of usage, see:
</span></span></span><span class="line"><span class="cl"><span class="c1">// examples/features/load_balancing/client/main.go
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">WithDefaultServiceConfig</span><span class="p">(</span><span class="nx">s</span> <span class="kt">string</span><span class="p">)</span> <span class="nx">DialOption</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nf">newFuncDialOption</span><span class="p">(</span><span class="kd">func</span><span class="p">(</span><span class="nx">o</span> <span class="o">*</span><span class="nx">dialOptions</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">o</span><span class="p">.</span><span class="nx">defaultServiceConfigRawJSON</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">s</span>
</span></span><span class="line"><span class="cl">	<span class="p">})</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><ol start="2">
<li>功能说明：<code>WithDefaultServiceConfig</code>函数允许你提供一个默认的服务配置，这个配置将在上述情况下被gRPC客户端使用。服务配置通常包含诸如负载均衡策略、重试策略、超时设置等配置信息。如果你不希望gRPC客户端依赖于解析器提供的服务配置，或者解析器提供的服务配置不符合你的需求，你可以使用这个选项来提供一个默认的服务配置。</li>
<li>参数说明：<strong>s</strong>：这是一个<code>string</code>类型的值，表示服务配置的JSON表示形式。这个配置将被gRPC客户端使用。</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kn">package</span> <span class="nx">main</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;context&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;log&#34;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="s">&#34;google.golang.org/grpc&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">serverAddr</span> <span class="o">:=</span> <span class="s">&#34;localhost:50051&#34;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 设置默认服务配置的JSON表示形式
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">defaultServiceConfigJSON</span> <span class="o">:=</span> <span class="s">`{
</span></span></span><span class="line"><span class="cl"><span class="s">		&#34;loadBalancingConfig&#34;: {
</span></span></span><span class="line"><span class="cl"><span class="s">			&#34;grpclb&#34;: {
</span></span></span><span class="line"><span class="cl"><span class="s">				&#34;childPolicy&#34;: [
</span></span></span><span class="line"><span class="cl"><span class="s">					{
</span></span></span><span class="line"><span class="cl"><span class="s">						&#34;round_robin&#34;: {}
</span></span></span><span class="line"><span class="cl"><span class="s">					}
</span></span></span><span class="line"><span class="cl"><span class="s">				]
</span></span></span><span class="line"><span class="cl"><span class="s">			}
</span></span></span><span class="line"><span class="cl"><span class="s">		}
</span></span></span><span class="line"><span class="cl"><span class="s">	}`</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 创建gRPC连接时应用WithDefaultServiceConfig选项
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">conn</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">grpc</span><span class="p">.</span><span class="nf">Dial</span><span class="p">(</span><span class="nx">serverAddr</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">		<span class="nx">grpc</span><span class="p">.</span><span class="nf">WithInsecure</span><span class="p">(),</span>
</span></span><span class="line"><span class="cl">		<span class="nx">grpc</span><span class="p">.</span><span class="nf">WithDefaultServiceConfig</span><span class="p">(</span><span class="nx">defaultServiceConfigJSON</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">	<span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">log</span><span class="p">.</span><span class="nf">Fatalf</span><span class="p">(</span><span class="s">&#34;did not connect: %v&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">defer</span> <span class="nx">conn</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// ... 使用连接进行后续操作 ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></div><ol start="4">
<li>在这个示例中，我们设置了客户端连接的默认服务配置，并使用<code>WithDefaultServiceConfig</code>选项来创建到服务器的连接。</li>
<li>注意事项：
<ul>
<li>服务配置的JSON格式必须符合gRPC的服务配置规范。</li>
<li>如果同时使用了<code>WithDisableServiceConfig</code>和<code>WithDefaultServiceConfig</code>，gRPC客户端将使用<code>WithDefaultServiceConfig</code>提供的服务配置。</li>
<li>如果你不希望gRPC客户端使用任何服务配置，你可以只使用<code>WithDisableServiceConfig</code>选项。</li>
</ul>
</li>
<li>通过使用<code>WithDefaultServiceConfig</code>，你可以根据应用程序的需求来配置gRPC客户端的行为，特别是在需要控制负载均衡策略和重试策略时。</li>
</ol>
<h3 id="withdisablehealthcheck">WithDisableHealthCheck()<a hidden class="anchor" aria-hidden="true" href="#withdisablehealthcheck">#</a></h3>
<ol>
<li>用于配置客户端连接选项，以禁用客户端连接对所有子连接的健康检查。</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// WithDisableHealthCheck disables the LB channel health checking for all
</span></span></span><span class="line"><span class="cl"><span class="c1">// SubConns of this ClientConn.
</span></span></span><span class="line"><span class="cl"><span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1">// # Experimental
</span></span></span><span class="line"><span class="cl"><span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1">// Notice: This API is EXPERIMENTAL and may be changed or removed in a
</span></span></span><span class="line"><span class="cl"><span class="c1">// later release.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">WithDisableHealthCheck</span><span class="p">()</span> <span class="nx">DialOption</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nf">newFuncDialOption</span><span class="p">(</span><span class="kd">func</span><span class="p">(</span><span class="nx">o</span> <span class="o">*</span><span class="nx">dialOptions</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">o</span><span class="p">.</span><span class="nx">disableHealthCheck</span> <span class="p">=</span> <span class="kc">true</span>
</span></span><span class="line"><span class="cl">	<span class="p">})</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><ol start="2">
<li>功能说明：
<ul>
<li><code>WithDisableHealthCheck</code>函数允许你禁用客户端连接对所有子连接的健康检查。在gRPC中，负载均衡器（LB）通道会定期对子连接进行检查，以确保它们仍然处于活动状态。如果一个子连接不再响应健康检查，负载均衡器会将其从可用连接列表中移除，并可能尝试建立一个新的子连接。</li>
<li>使用这个选项，你可以告诉gRPC不要进行健康检查，这意味着即使子连接不再响应，它们也不会被从可用连接列表中移除，也不会尝试建立新的子连接。</li>
</ul>
</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kn">package</span> <span class="nx">main</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;context&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;log&#34;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="s">&#34;google.golang.org/grpc&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">serverAddr</span> <span class="o">:=</span> <span class="s">&#34;localhost:50051&#34;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 创建gRPC连接时应用WithDisableHealthCheck选项
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">conn</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">grpc</span><span class="p">.</span><span class="nf">Dial</span><span class="p">(</span><span class="nx">serverAddr</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">		<span class="nx">grpc</span><span class="p">.</span><span class="nf">WithInsecure</span><span class="p">(),</span>
</span></span><span class="line"><span class="cl">		<span class="nx">grpc</span><span class="p">.</span><span class="nf">WithDisableHealthCheck</span><span class="p">(),</span>
</span></span><span class="line"><span class="cl">	<span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">log</span><span class="p">.</span><span class="nf">Fatalf</span><span class="p">(</span><span class="s">&#34;did not connect: %v&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">defer</span> <span class="nx">conn</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// ... 使用连接进行后续操作 ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></div><ol start="3">
<li>在这个示例中，我们通过<code>WithDisableHealthCheck</code>选项来创建到服务器的连接，这会导致gRPC客户端不会对任何子连接进行健康检查。</li>
<li>注意事项：
<ul>
<li>这是一个实验性的API，可能会在未来版本中发生变化或被移除。</li>
<li>禁用健康检查可能会导致在子连接不再响应时，客户端不会自动尝试建立新的连接，这可能会影响到服务的可用性和可靠性。</li>
<li>在某些情况下，禁用健康检查可能是有用的，比如当你知道子连接可能会暂时不可用，但不需要gRPC自动重新建立连接时。</li>
</ul>
</li>
<li>通过使用<code>WithDisableHealthCheck</code>，你可以更细粒度地控制gRPC客户端的健康检查行为，特别是在需要避免健康检查可能导致的问题时。</li>
</ol>
<h3 id="withdisableretry">WithDisableRetry()<a hidden class="anchor" aria-hidden="true" href="#withdisableretry">#</a></h3>
<ol>
<li>用于配置客户端连接选项，以禁用重试机制，即使服务配置启用了它们。</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// WithDisableRetry returns a DialOption that disables retries, even if the
</span></span></span><span class="line"><span class="cl"><span class="c1">// service config enables them.  This does not impact transparent retries, which
</span></span></span><span class="line"><span class="cl"><span class="c1">// will happen automatically if no data is written to the wire or if the RPC is
</span></span></span><span class="line"><span class="cl"><span class="c1">// unprocessed by the remote server.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">WithDisableRetry</span><span class="p">()</span> <span class="nx">DialOption</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nf">newFuncDialOption</span><span class="p">(</span><span class="kd">func</span><span class="p">(</span><span class="nx">o</span> <span class="o">*</span><span class="nx">dialOptions</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">o</span><span class="p">.</span><span class="nx">disableRetry</span> <span class="p">=</span> <span class="kc">true</span>
</span></span><span class="line"><span class="cl">	<span class="p">})</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><ol start="2">
<li>功能说明：<code>WithDisableRetry</code>函数允许你禁用gRPC客户端的重试机制。在gRPC中，重试机制允许客户端在遇到可重试的错误（如网络问题或服务端错误）时重新发起RPC调用。但是，有些情况下，你可能不希望客户端进行任何重试，即使服务配置中启用了重试。使用这个选项，你可以强制禁用重试。</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kn">package</span> <span class="nx">main</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;context&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;log&#34;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="s">&#34;google.golang.org/grpc&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">serverAddr</span> <span class="o">:=</span> <span class="s">&#34;localhost:50051&#34;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 创建gRPC连接时应用WithDisableRetry选项
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">conn</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">grpc</span><span class="p">.</span><span class="nf">Dial</span><span class="p">(</span><span class="nx">serverAddr</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">		<span class="nx">grpc</span><span class="p">.</span><span class="nf">WithInsecure</span><span class="p">(),</span>
</span></span><span class="line"><span class="cl">		<span class="nx">grpc</span><span class="p">.</span><span class="nf">WithDisableRetry</span><span class="p">(),</span>
</span></span><span class="line"><span class="cl">	<span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">log</span><span class="p">.</span><span class="nf">Fatalf</span><span class="p">(</span><span class="s">&#34;did not connect: %v&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">defer</span> <span class="nx">conn</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// ... 使用连接进行后续操作 ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></div><ol start="3">
<li>在这个示例中，我们通过<code>WithDisableRetry</code>选项来创建到服务器的连接，这会导致gRPC客户端不会进行任何重试，即使服务配置中启用了重试。</li>
<li>注意事项：
<ul>
<li>这个选项仅禁用显式的重试机制。透明的重试仍然会发生，如果满足以下条件：没有数据写入到网络，或者RPC在远程服务器上未被处理。</li>
<li>禁用重试可能会导致在遇到网络问题或服务端错误时，客户端不会尝试重新连接，这可能会影响到服务的可用性和可靠性。</li>
<li>在某些情况下，禁用重试可能是有用的，比如当你知道服务端可能无法处理重试请求，或者当你想要手动控制错误处理逻辑时。</li>
</ul>
</li>
<li>通过使用<code>WithDisableRetry</code>，你可以更细粒度地控制gRPC客户端的重试行为，特别是在需要避免重试可能导致的问题时。</li>
</ol>
<h3 id="withdisableserviceconfig">WithDisableServiceConfig()<a hidden class="anchor" aria-hidden="true" href="#withdisableserviceconfig">#</a></h3>
<ol>
<li>用于配置客户端连接选项，以忽略通过解析器提供的任何服务配置，并给解析器一个提示，让它不要获取服务配置。</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// WithDisableServiceConfig returns a DialOption that causes gRPC to ignore any
</span></span></span><span class="line"><span class="cl"><span class="c1">// service config provided by the resolver and provides a hint to the resolver
</span></span></span><span class="line"><span class="cl"><span class="c1">// to not fetch service configs.
</span></span></span><span class="line"><span class="cl"><span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1">// Note that this dial option only disables service config from resolver. If
</span></span></span><span class="line"><span class="cl"><span class="c1">// default service config is provided, gRPC will use the default service config.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">WithDisableServiceConfig</span><span class="p">()</span> <span class="nx">DialOption</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nf">newFuncDialOption</span><span class="p">(</span><span class="kd">func</span><span class="p">(</span><span class="nx">o</span> <span class="o">*</span><span class="nx">dialOptions</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">o</span><span class="p">.</span><span class="nx">disableServiceConfig</span> <span class="p">=</span> <span class="kc">true</span>
</span></span><span class="line"><span class="cl">	<span class="p">})</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><ol start="2">
<li>功能说明：<code>WithDisableServiceConfig</code>函数允许你禁用通过名称解析器传递给gRPC客户端的服务配置。服务配置通常包含诸如负载均衡策略、重试策略、超时设置等配置信息。使用这个选项，你可以告诉gRPC忽略这些配置，并且不会从解析器中获取它们。</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kn">package</span> <span class="nx">main</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;context&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;log&#34;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="s">&#34;google.golang.org/grpc&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">serverAddr</span> <span class="o">:=</span> <span class="s">&#34;localhost:50051&#34;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 创建gRPC连接时应用WithDisableServiceConfig选项
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">conn</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">grpc</span><span class="p">.</span><span class="nf">Dial</span><span class="p">(</span><span class="nx">serverAddr</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">		<span class="nx">grpc</span><span class="p">.</span><span class="nf">WithInsecure</span><span class="p">(),</span>
</span></span><span class="line"><span class="cl">		<span class="nx">grpc</span><span class="p">.</span><span class="nf">WithDisableServiceConfig</span><span class="p">(),</span>
</span></span><span class="line"><span class="cl">	<span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">log</span><span class="p">.</span><span class="nf">Fatalf</span><span class="p">(</span><span class="s">&#34;did not connect: %v&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">defer</span> <span class="nx">conn</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// ... 使用连接进行后续操作 ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></div><ol start="3">
<li>在这个示例中，我们通过<code>WithDisableServiceConfig</code>选项来创建到服务器的连接，这会导致gRPC忽略任何通过解析器提供的服务配置。</li>
<li>注意事项：
<ul>
<li>这个选项仅禁用通过解析器提供的服务配置。如果提供了默认的服务配置，gRPC仍然会使用这个默认配置。</li>
<li>禁用服务配置可能会导致gRPC客户端的行为与预期不同，特别是如果服务配置包含了重要的负载均衡或重试策略。</li>
<li>在某些情况下，禁用服务配置可能是有用的，比如当你想要手动控制所有配置或者当你知道解析器提供的服务配置不适用于你的应用程序时。</li>
</ul>
</li>
<li>通过使用<code>WithDisableServiceConfig</code>，你可以更细粒度地控制gRPC客户端的行为，尤其是在需要避免解析器提供的配置对客户端造成不必要影响的情况下。</li>
</ol>
<h3 id="withidletimeoutd">WithIdleTimeout(d)<a hidden class="anchor" aria-hidden="true" href="#withidletimeoutd">#</a></h3>
<ol>
<li>用于配置客户端连接的空闲超时时间。</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// WithIdleTimeout returns a DialOption that configures an idle timeout for the
</span></span></span><span class="line"><span class="cl"><span class="c1">// channel. If the channel is idle for the configured timeout, i.e there are no
</span></span></span><span class="line"><span class="cl"><span class="c1">// ongoing RPCs and no new RPCs are initiated, the channel will enter idle mode
</span></span></span><span class="line"><span class="cl"><span class="c1">// and as a result the name resolver and load balancer will be shut down. The
</span></span></span><span class="line"><span class="cl"><span class="c1">// channel will exit idle mode when the Connect() method is called or when an
</span></span></span><span class="line"><span class="cl"><span class="c1">// RPC is initiated.
</span></span></span><span class="line"><span class="cl"><span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1">// A default timeout of 30 minutes will be used if this dial option is not set
</span></span></span><span class="line"><span class="cl"><span class="c1">// at dial time and idleness can be disabled by passing a timeout of zero.
</span></span></span><span class="line"><span class="cl"><span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1">// # Experimental
</span></span></span><span class="line"><span class="cl"><span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1">// Notice: This API is EXPERIMENTAL and may be changed or removed in a
</span></span></span><span class="line"><span class="cl"><span class="c1">// later release.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">WithIdleTimeout</span><span class="p">(</span><span class="nx">d</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Duration</span><span class="p">)</span> <span class="nx">DialOption</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nf">newFuncDialOption</span><span class="p">(</span><span class="kd">func</span><span class="p">(</span><span class="nx">o</span> <span class="o">*</span><span class="nx">dialOptions</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">o</span><span class="p">.</span><span class="nx">idleTimeout</span> <span class="p">=</span> <span class="nx">d</span>
</span></span><span class="line"><span class="cl">	<span class="p">})</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><ol start="2">
<li>功能说明：<code>WithIdleTimeout</code>函数允许你设置客户端连接在空闲状态下的超时时间。如果连接在指定的超时时间内没有任何活动（即没有正在进行的RPC调用，也没有新的RPC调用被发起），则连接将进入空闲模式，并关闭名称解析器和负载均衡器。连接将在调用<code>Connect()</code>方法或发起新的RPC调用时退出空闲模式。</li>
<li>参数说明：<strong>d</strong>：这是一个<code>time.Duration</code>类型的值，表示空闲超时时间。当连接空闲超过这个时间时，将触发空闲模式。</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kn">package</span> <span class="nx">main</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;context&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;log&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;time&#34;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="s">&#34;google.golang.org/grpc&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">serverAddr</span> <span class="o">:=</span> <span class="s">&#34;localhost:50051&#34;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 设置空闲超时时间为10分钟
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">idleTimeout</span> <span class="o">:=</span> <span class="mi">10</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Minute</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">conn</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">grpc</span><span class="p">.</span><span class="nf">Dial</span><span class="p">(</span><span class="nx">serverAddr</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">		<span class="nx">grpc</span><span class="p">.</span><span class="nf">WithInsecure</span><span class="p">(),</span>
</span></span><span class="line"><span class="cl">		<span class="nx">grpc</span><span class="p">.</span><span class="nf">WithIdleTimeout</span><span class="p">(</span><span class="nx">idleTimeout</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">	<span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">log</span><span class="p">.</span><span class="nf">Fatalf</span><span class="p">(</span><span class="s">&#34;did not connect: %v&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">defer</span> <span class="nx">conn</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// ... 使用连接进行后续操作 ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></div><ol start="4">
<li>在这个示例中，我们设置了客户端连接的空闲超时时间为10分钟，并使用<code>WithIdleTimeout</code>选项来创建到服务器的连接。</li>
<li>注意事项：
<ul>
<li>如果在建立连接时没有设置此选项，默认的空闲超时时间为30分钟。</li>
<li>可以通过传递一个超时时间为0的值来禁用空闲超时功能。</li>
<li>这是一个实验性的API，可能会在未来版本中发生变化或被移除。</li>
</ul>
</li>
<li>通过使用<code>WithIdleTimeout</code>，你可以根据应用程序的需求来管理客户端连接的生命周期，特别是在需要节省资源或减少不必要的网络活动时。例如，如果应用程序预期会有较长的空闲时间，则可以设置一个较短的空闲超时时间，以关闭不必要的连接并释放资源。</li>
</ol>
<h3 id="withinitialconnwindowsizes">WithInitialConnWindowSize(s)<a hidden class="anchor" aria-hidden="true" href="#withinitialconnwindowsizes">#</a></h3>
<ol>
<li>于配置客户端连接的初始连接窗口大小。</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// WithInitialConnWindowSize returns a DialOption which sets the value for
</span></span></span><span class="line"><span class="cl"><span class="c1">// initial window size on a connection. The lower bound for window size is 64K
</span></span></span><span class="line"><span class="cl"><span class="c1">// and any value smaller than that will be ignored.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">WithInitialConnWindowSize</span><span class="p">(</span><span class="nx">s</span> <span class="kt">int32</span><span class="p">)</span> <span class="nx">DialOption</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nf">newFuncDialOption</span><span class="p">(</span><span class="kd">func</span><span class="p">(</span><span class="nx">o</span> <span class="o">*</span><span class="nx">dialOptions</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">o</span><span class="p">.</span><span class="nx">copts</span><span class="p">.</span><span class="nx">InitialConnWindowSize</span> <span class="p">=</span> <span class="nx">s</span>
</span></span><span class="line"><span class="cl">	<span class="p">})</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><ol start="2">
<li>功能说明：<code>WithInitialConnWindowSize</code>函数允许你设置在客户端连接上用于流量控制的初始窗口大小。在gRPC中，流量控制是基于窗口大小的，用于限制发送方在没有得到接收方确认的情况下可以发送的数据量。与<code>WithInitialWindowSize</code>不同，<code>WithInitialConnWindowSize</code>影响的是整个连接的初始窗口大小，而不仅仅是单个流。</li>
<li>参数说明：<strong>s</strong>：这是一个<code>int32</code>类型的值，表示初始连接窗口大小（以字节为单位）。这个值用于控制客户端在连接建立时可以发送的数据量。</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kn">package</span> <span class="nx">main</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;context&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;log&#34;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="s">&#34;google.golang.org/grpc&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">serverAddr</span> <span class="o">:=</span> <span class="s">&#34;localhost:50051&#34;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 设置初始连接窗口大小为2MB
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">initialConnWindowSize</span> <span class="o">:=</span> <span class="nb">int32</span><span class="p">(</span><span class="mi">2</span> <span class="o">&lt;&lt;</span> <span class="mi">20</span><span class="p">)</span> <span class="c1">// 2MB in bytes
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">	<span class="nx">conn</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">grpc</span><span class="p">.</span><span class="nf">Dial</span><span class="p">(</span><span class="nx">serverAddr</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">		<span class="nx">grpc</span><span class="p">.</span><span class="nf">WithInsecure</span><span class="p">(),</span>
</span></span><span class="line"><span class="cl">		<span class="nx">grpc</span><span class="p">.</span><span class="nf">WithInitialConnWindowSize</span><span class="p">(</span><span class="nx">initialConnWindowSize</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">	<span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">log</span><span class="p">.</span><span class="nf">Fatalf</span><span class="p">(</span><span class="s">&#34;did not connect: %v&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">defer</span> <span class="nx">conn</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// ... 使用连接进行后续操作 ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></div><ol start="4">
<li>在这个示例中，我们设置了客户端连接的初始窗口大小为2MB，并使用<code>WithInitialConnWindowSize</code>选项来创建到服务器的连接。</li>
<li>注意事项：
<ul>
<li>初始连接窗口大小有一个下限，即64KB。如果传入的值小于64KB，则会被忽略，并使用默认值。</li>
<li>设置一个较大的初始连接窗口大小可以减少小数据包发送的频率，从而可能提高性能，特别是在发送大量数据时。</li>
<li>但是，设置过大的窗口大小可能会导致网络拥塞，特别是当网络带宽有限或接收方处理能力不足时。</li>
</ul>
</li>
<li>通过使用<code>WithInitialConnWindowSize</code>，你可以根据网络条件和应用程序的需求来调整客户端的流量控制窗口大小，以优化数据传输效率。这对于管理连接级的数据传输特别有用，尤其是在需要发送大量初始数据或者需要处理多个并发流的情况下。</li>
</ol>
<h3 id="withinitialwindowsizes">WithInitialWindowSize(s)<a hidden class="anchor" aria-hidden="true" href="#withinitialwindowsizes">#</a></h3>
<ol>
<li>用于配置客户端连接的初始窗口大小。</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// WithInitialWindowSize returns a DialOption which sets the value for initial
</span></span></span><span class="line"><span class="cl"><span class="c1">// window size on a stream. The lower bound for window size is 64K and any value
</span></span></span><span class="line"><span class="cl"><span class="c1">// smaller than that will be ignored.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">WithInitialWindowSize</span><span class="p">(</span><span class="nx">s</span> <span class="kt">int32</span><span class="p">)</span> <span class="nx">DialOption</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nf">newFuncDialOption</span><span class="p">(</span><span class="kd">func</span><span class="p">(</span><span class="nx">o</span> <span class="o">*</span><span class="nx">dialOptions</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">o</span><span class="p">.</span><span class="nx">copts</span><span class="p">.</span><span class="nx">InitialWindowSize</span> <span class="p">=</span> <span class="nx">s</span>
</span></span><span class="line"><span class="cl">	<span class="p">})</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><ol start="2">
<li>功能说明：<code>WithInitialWindowSize</code>函数允许你设置在流上用于流量控制的初始窗口大小。在gRPC中，流量控制是基于窗口大小的，用于限制发送方在没有得到接收方确认的情况下可以发送的数据量。</li>
<li>参数说明：<strong>s</strong>：这是一个<code>int32</code>类型的值，表示初始窗口大小（以字节为单位）。这个值用于控制客户端在开始时可以发送的数据量。</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kn">package</span> <span class="nx">main</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;context&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;log&#34;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="s">&#34;google.golang.org/grpc&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">serverAddr</span> <span class="o">:=</span> <span class="s">&#34;localhost:50051&#34;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 设置初始窗口大小为1MB
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">initialWindowSize</span> <span class="o">:=</span> <span class="nb">int32</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">20</span><span class="p">)</span> <span class="c1">// 1MB in bytes
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">	<span class="nx">conn</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">grpc</span><span class="p">.</span><span class="nf">Dial</span><span class="p">(</span><span class="nx">serverAddr</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">		<span class="nx">grpc</span><span class="p">.</span><span class="nf">WithInsecure</span><span class="p">(),</span>
</span></span><span class="line"><span class="cl">		<span class="nx">grpc</span><span class="p">.</span><span class="nf">WithInitialWindowSize</span><span class="p">(</span><span class="nx">initialWindowSize</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">	<span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">log</span><span class="p">.</span><span class="nf">Fatalf</span><span class="p">(</span><span class="s">&#34;did not connect: %v&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">defer</span> <span class="nx">conn</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// ... 使用连接进行后续操作 ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></div><ol start="4">
<li>在这个示例中，我们设置了客户端连接的初始窗口大小为1MB，并使用<code>WithInitialWindowSize</code>选项来创建到服务器的连接。</li>
<li>注意事项：
<ul>
<li>初始窗口大小有一个下限，即64KB。如果传入的值小于64KB，则会被忽略，并使用默认值。</li>
<li>设置一个较大的初始窗口大小可以减少小数据包发送的频率，从而可能提高性能，特别是在发送大量数据时。</li>
<li>但是，设置过大的窗口大小可能会导致网络拥塞，特别是当网络带宽有限或接收方处理能力不足时。</li>
</ul>
</li>
<li>通过使用<code>WithInitialWindowSize</code>，你可以根据网络条件和应用程序的需求来调整客户端的流量控制窗口大小，以优化数据传输效率。</li>
</ol>
<h3 id="withkeepaliveparamskp">WithKeepaliveParams(kp)<a hidden class="anchor" aria-hidden="true" href="#withkeepaliveparamskp">#</a></h3>
<ol>
<li>用于配置客户端连接的保活（keepalive）参数。</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// WithKeepaliveParams returns a DialOption that specifies keepalive parameters
</span></span></span><span class="line"><span class="cl"><span class="c1">// for the client transport.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">WithKeepaliveParams</span><span class="p">(</span><span class="nx">kp</span> <span class="nx">keepalive</span><span class="p">.</span><span class="nx">ClientParameters</span><span class="p">)</span> <span class="nx">DialOption</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">kp</span><span class="p">.</span><span class="nx">Time</span> <span class="p">&lt;</span> <span class="nx">internal</span><span class="p">.</span><span class="nx">KeepaliveMinPingTime</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">logger</span><span class="p">.</span><span class="nf">Warningf</span><span class="p">(</span><span class="s">&#34;Adjusting keepalive ping interval to minimum period of %v&#34;</span><span class="p">,</span> <span class="nx">internal</span><span class="p">.</span><span class="nx">KeepaliveMinPingTime</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="nx">kp</span><span class="p">.</span><span class="nx">Time</span> <span class="p">=</span> <span class="nx">internal</span><span class="p">.</span><span class="nx">KeepaliveMinPingTime</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nf">newFuncDialOption</span><span class="p">(</span><span class="kd">func</span><span class="p">(</span><span class="nx">o</span> <span class="o">*</span><span class="nx">dialOptions</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">o</span><span class="p">.</span><span class="nx">copts</span><span class="p">.</span><span class="nx">KeepaliveParams</span> <span class="p">=</span> <span class="nx">kp</span>
</span></span><span class="line"><span class="cl">	<span class="p">})</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><ol start="2">
<li>功能说明：<code>WithKeepaliveParams</code>函数允许你设置客户端传输层的保活参数。保活机制可以确保在长时间没有数据传输的情况下，客户端与服务器之间的连接仍然是活跃的。这对于维护连接的稳定性，特别是在存在网络设备（如NAT、防火墙）可能导致连接超时的情况下，是非常有用的。</li>
<li>参数说明：<strong>kp</strong>：这是一个<code>keepalive.ClientParameters</code>类型的结构体，包含了以下字段来配置保活参数：
<ul>
<li><code>Time</code>: 客户端发送保活ping的时间间隔。如果设置为0，则禁用保活ping。</li>
<li><code>Timeout</code>: 等待服务器响应保活ping的超时时间。如果服务器在此时间内没有响应，连接将被关闭。</li>
<li><code>PermitWithoutStream</code>: 即使没有活动流，也允许发送保活ping。</li>
</ul>
</li>
<li>函数内部逻辑：
<ul>
<li>如果传入的<code>kp.Time</code>小于<code>internal.KeepaliveMinPingTime</code>（gRPC内部定义的最小保活ping时间间隔），则函数会调整<code>kp.Time</code>到最小值，并打印一条警告信息。</li>
<li>然后函数返回一个<code>DialOption</code>，该选项包含一个函数，该函数将<code>kp</code>赋值给<code>dialOptions</code>结构体的<code>copts.KeepaliveParams</code>字段。</li>
</ul>
</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kn">package</span> <span class="nx">main</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;context&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;log&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;time&#34;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="s">&#34;google.golang.org/grpc&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;google.golang.org/grpc/keepalive&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">serverAddr</span> <span class="o">:=</span> <span class="s">&#34;localhost:50051&#34;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 设置保活参数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">keepaliveParams</span> <span class="o">:=</span> <span class="nx">keepalive</span><span class="p">.</span><span class="nx">ClientParameters</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">Time</span><span class="p">:</span>                <span class="mi">10</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">,</span> <span class="c1">// 发送保活ping的时间间隔
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nx">Timeout</span><span class="p">:</span>             <span class="mi">5</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">,</span>  <span class="c1">// 等待服务器响应保活ping的超时时间
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nx">PermitWithoutStream</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>             <span class="c1">// 即使没有活动流也允许发送保活ping
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">conn</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">grpc</span><span class="p">.</span><span class="nf">Dial</span><span class="p">(</span><span class="nx">serverAddr</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">		<span class="nx">grpc</span><span class="p">.</span><span class="nf">WithInsecure</span><span class="p">(),</span>
</span></span><span class="line"><span class="cl">		<span class="nx">grpc</span><span class="p">.</span><span class="nf">WithKeepaliveParams</span><span class="p">(</span><span class="nx">keepaliveParams</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">	<span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">log</span><span class="p">.</span><span class="nf">Fatalf</span><span class="p">(</span><span class="s">&#34;did not connect: %v&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">defer</span> <span class="nx">conn</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// ... 使用连接进行后续操作 ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></div><ol start="5">
<li>在这个示例中，我们设置了客户端的保活参数，并使用<code>WithKeepaliveParams</code>选项来创建到服务器的连接。</li>
<li>注意事项：
<ul>
<li>如果<code>kp.Time</code>设置得太低，可能会对服务器造成不必要的负担，因为服务器需要频繁地处理保活ping。</li>
<li><code>kp.Timeout</code>应该小于或等于服务器配置的保活超时时间，以避免客户端过早地关闭连接。</li>
<li><code>PermitWithoutStream</code>选项允许在没有活动流的情况下发送保活ping，这对于维护空闲连接非常有用。</li>
</ul>
</li>
<li>通过使用<code>WithKeepaliveParams</code>，你可以根据应用程序的需求和网络环境来优化客户端的保活行为，从而确保连接的稳定性。</li>
</ol>
<h3 id="withmaxcallattemptsn">WithMaxCallAttempts(n)<a hidden class="anchor" aria-hidden="true" href="#withmaxcallattemptsn">#</a></h3>
<ol>
<li>用于配置客户端在发起调用时的最大尝试次数。</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// WithMaxCallAttempts returns a DialOption that configures the maximum number
</span></span></span><span class="line"><span class="cl"><span class="c1">// of attempts per call (including retries and hedging) using the channel.
</span></span></span><span class="line"><span class="cl"><span class="c1">// Service owners may specify a higher value for these parameters, but higher
</span></span></span><span class="line"><span class="cl"><span class="c1">// values will be treated as equal to the maximum value by the client
</span></span></span><span class="line"><span class="cl"><span class="c1">// implementation. This mitigates security concerns related to the service
</span></span></span><span class="line"><span class="cl"><span class="c1">// config being transferred to the client via DNS.
</span></span></span><span class="line"><span class="cl"><span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1">// A value of 5 will be used if this dial option is not set or n &lt; 2.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">WithMaxCallAttempts</span><span class="p">(</span><span class="nx">n</span> <span class="kt">int</span><span class="p">)</span> <span class="nx">DialOption</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nf">newFuncDialOption</span><span class="p">(</span><span class="kd">func</span><span class="p">(</span><span class="nx">o</span> <span class="o">*</span><span class="nx">dialOptions</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="nx">n</span> <span class="p">&lt;</span> <span class="mi">2</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nx">n</span> <span class="p">=</span> <span class="nx">defaultMaxCallAttempts</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="nx">o</span><span class="p">.</span><span class="nx">maxCallAttempts</span> <span class="p">=</span> <span class="nx">n</span>
</span></span><span class="line"><span class="cl">	<span class="p">})</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><ol start="2">
<li>功能说明：<code>WithMaxCallAttempts</code>函数的作用是设置每个调用（包括重试和hedging）的最大尝试次数。以下是对其功能的详细解释：
<ul>
<li><strong>重试次数</strong>：当客户端发起一个调用，并且遇到可重试的错误（例如网络问题）时，客户端会尝试重新发起调用，直到达到设定的最大尝试次数。</li>
<li><strong>Hedging</strong>：Hedging是一种gRPC特有的机制，允许客户端在等待初始调用结果的同时，发送额外的请求。这些额外的请求会并行执行，目的是提高响应速度。如果其中一个调用成功，其他的调用将被取消。</li>
</ul>
</li>
<li>参数说明：
<ul>
<li><strong>n</strong>：这是函数的参数，表示客户端应该尝试的最大次数。如果<code>n</code>小于2，函数将使用默认值<code>defaultMaxCallAttempts</code>（通常为5）。</li>
</ul>
</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kn">package</span> <span class="nx">main</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;context&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;log&#34;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="s">&#34;google.golang.org/grpc&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;google.golang.org/grpc/credentials/insecure&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">serverAddr</span> <span class="o">:=</span> <span class="s">&#34;localhost:50051&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="nx">maxCallAttempts</span> <span class="o">:=</span> <span class="mi">3</span> <span class="c1">// 设置最大尝试次数为3
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">	<span class="nx">conn</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">grpc</span><span class="p">.</span><span class="nf">Dial</span><span class="p">(</span><span class="nx">serverAddr</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">		<span class="nx">grpc</span><span class="p">.</span><span class="nf">WithTransportCredentials</span><span class="p">(</span><span class="nx">insecure</span><span class="p">.</span><span class="nf">NewCredentials</span><span class="p">()),</span>
</span></span><span class="line"><span class="cl">		<span class="nx">grpc</span><span class="p">.</span><span class="nf">WithMaxCallAttempts</span><span class="p">(</span><span class="nx">maxCallAttempts</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">	<span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">log</span><span class="p">.</span><span class="nf">Fatalf</span><span class="p">(</span><span class="s">&#34;did not connect: %v&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">defer</span> <span class="nx">conn</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// ... 使用连接进行后续操作 ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></div><ol start="4">
<li>在这个示例中，如果<code>maxCallAttempts</code>小于2，那么客户端将使用默认的最大尝试次数5。</li>
<li>注意事项：
<ul>
<li>当不设置<code>WithMaxCallAttempts</code>或设置小于2的值时，默认的最大尝试次数是5。</li>
<li>在实际应用中，应使用安全的凭据替换<code>insecure.NewCredentials()</code>。</li>
<li><code>WithMaxCallAttempts</code>选项是在客户端发起连接时设置的，它影响所有通过该连接发出的调用。</li>
</ul>
</li>
<li>通过使用<code>WithMaxCallAttempts</code>，你可以根据服务的不稳定性和性能需求，调整客户端的调用行为，以增强系统的健壮性。</li>
</ol>
<h3 id="withmaxheaderlistsizes">WithMaxHeaderListSize(s)<a hidden class="anchor" aria-hidden="true" href="#withmaxheaderlistsizes">#</a></h3>
<ol>
<li>该函数允许你设置客户端愿意接受的最大（未压缩）头部列表的大小。这在需要限制传入头部大小以防止潜在的资源耗尽攻击或处理过大的头部时非常有用。</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// WithMaxHeaderListSize returns a DialOption that specifies the maximum
</span></span></span><span class="line"><span class="cl"><span class="c1">// (uncompressed) size of header list that the client is prepared to accept.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">WithMaxHeaderListSize</span><span class="p">(</span><span class="nx">s</span> <span class="kt">uint32</span><span class="p">)</span> <span class="nx">DialOption</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nx">MaxHeaderListSizeDialOption</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">MaxHeaderListSize</span><span class="p">:</span> <span class="nx">s</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kn">package</span> <span class="nx">main</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;context&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;log&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;time&#34;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="s">&#34;google.golang.org/grpc&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;google.golang.org/grpc/credentials/insecure&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 服务地址
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">serverAddr</span> <span class="o">:=</span> <span class="s">&#34;localhost:50051&#34;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 设置最大头部列表大小为1MB（以字节为单位）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">maxHeaderListSize</span> <span class="o">:=</span> <span class="nb">uint32</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">20</span><span class="p">)</span> <span class="c1">// 1MB
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 创建gRPC连接时应用WithMaxHeaderListSize选项
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">conn</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">grpc</span><span class="p">.</span><span class="nf">Dial</span><span class="p">(</span><span class="nx">serverAddr</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">		<span class="nx">grpc</span><span class="p">.</span><span class="nf">WithTransportCredentials</span><span class="p">(</span><span class="nx">insecure</span><span class="p">.</span><span class="nf">NewCredentials</span><span class="p">()),</span>
</span></span><span class="line"><span class="cl">		<span class="nx">grpc</span><span class="p">.</span><span class="nf">WithMaxHeaderListSize</span><span class="p">(</span><span class="nx">maxHeaderListSize</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">	<span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">log</span><span class="p">.</span><span class="nf">Fatalf</span><span class="p">(</span><span class="s">&#34;did not connect: %v&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">defer</span> <span class="nx">conn</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 假设你有一个服务客户端，你可以使用conn创建客户端实例
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// client := NewYourServiceClient(conn)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">	<span class="c1">// ... 使用client进行后续操作 ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 这里只是一个示例，所以我们将等待一段时间后关闭连接
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">ctx</span><span class="p">,</span> <span class="nx">cancel</span> <span class="o">:=</span> <span class="nx">context</span><span class="p">.</span><span class="nf">WithTimeout</span><span class="p">(</span><span class="nx">context</span><span class="p">.</span><span class="nf">Background</span><span class="p">(),</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="o">*</span><span class="mi">10</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">defer</span> <span class="nf">cancel</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 假设你调用了某个RPC方法
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// response, err := client.YourRPCMethod(ctx, &amp;YourRequest{})
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// if err != nil {
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// 	log.Fatalf(&#34;could not call: %v&#34;, err)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// }
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// log.Printf(&#34;Response: %v&#34;, response)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 暂停一段时间后关闭连接
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="o">&lt;-</span><span class="nx">ctx</span><span class="p">.</span><span class="nf">Done</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><ol start="2">
<li>在这个示例中，我们首先导入了必要的包，然后设置了服务器的地址和想要设置的最大头部列表大小。接着，我们使用<code>grpc.Dial</code>函数创建了一个到服务器的连接，并通过<code>grpc.WithMaxHeaderListSize</code>传递了我们的配置选项。</li>
</ol>
<h3 id="withnoproxy">WithNoProxy()<a hidden class="anchor" aria-hidden="true" href="#withnoproxy">#</a></h3>
<ol>
<li>用于禁用代理（proxy）的使用。这个选项适用于客户端连接（<code>ClientConn</code>），当它被设置时，gRPC将不会通过代理与服务器进行通信。</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// WithNoProxy returns a DialOption which disables the use of proxies for this
</span></span></span><span class="line"><span class="cl"><span class="c1">// ClientConn. This is ignored if WithDialer or WithContextDialer are used.
</span></span></span><span class="line"><span class="cl"><span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1">// # Experimental
</span></span></span><span class="line"><span class="cl"><span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1">// Notice: This API is EXPERIMENTAL and may be changed or removed in a
</span></span></span><span class="line"><span class="cl"><span class="c1">// later release.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">WithNoProxy</span><span class="p">()</span> <span class="nx">DialOption</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nf">newFuncDialOption</span><span class="p">(</span><span class="kd">func</span><span class="p">(</span><span class="nx">o</span> <span class="o">*</span><span class="nx">dialOptions</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">o</span><span class="p">.</span><span class="nx">copts</span><span class="p">.</span><span class="nx">UseProxy</span> <span class="p">=</span> <span class="kc">false</span>
</span></span><span class="line"><span class="cl">	<span class="p">})</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><ol start="2">
<li><strong>作用</strong>：
<ul>
<li><strong>代理禁用</strong>：允许客户端在建立与服务器的连接时禁用代理。</li>
<li><strong>直接连接</strong>：通过禁用代理，客户端可以直接与服务器建立连接，绕过任何中间代理服务器。</li>
</ul>
</li>
<li><strong>使用场景</strong>：
<ul>
<li><strong>代理限制</strong>：在客户端不能使用代理服务器或代理服务器不可靠的场景中，可以禁用代理。</li>
<li><strong>安全性</strong>：在需要确保通信安全性的场景中，通过禁用代理来避免通过不可信的中间节点。</li>
</ul>
</li>
<li>需要注意的是，<code>WithNoProxy</code> 函数是gRPC框架中的一个实验性API，可能会在未来的gRPC版本中更改或移除。因此，在生产环境中使用这个函数之前，应该仔细评估其稳定性和适用性。</li>
</ol>
<h3 id="withperrpccredentialscreds">WithPerRPCCredentials(creds)<a hidden class="anchor" aria-hidden="true" href="#withperrpccredentialscreds">#</a></h3>
<ol>
<li>用于为每个单向RPC（unary RPC）设置凭证（credentials）。这个选项允许客户端在每次RPC调用时传递特定的凭证，这通常是用于认证的凭证。</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// WithPerRPCCredentials returns a DialOption which sets credentials and places
</span></span></span><span class="line"><span class="cl"><span class="c1">// auth state on each outbound RPC.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">WithPerRPCCredentials</span><span class="p">(</span><span class="nx">creds</span> <span class="nx">credentials</span><span class="p">.</span><span class="nx">PerRPCCredentials</span><span class="p">)</span> <span class="nx">DialOption</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nf">newFuncDialOption</span><span class="p">(</span><span class="kd">func</span><span class="p">(</span><span class="nx">o</span> <span class="o">*</span><span class="nx">dialOptions</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">o</span><span class="p">.</span><span class="nx">copts</span><span class="p">.</span><span class="nx">PerRPCCredentials</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">o</span><span class="p">.</span><span class="nx">copts</span><span class="p">.</span><span class="nx">PerRPCCredentials</span><span class="p">,</span> <span class="nx">creds</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">})</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h4 id="详解-7">详解<a hidden class="anchor" aria-hidden="true" href="#详解-7">#</a></h4>
<ol>
<li><strong>作用</strong>：
<ul>
<li><strong>认证</strong>：允许客户端在每次RPC调用时传递认证凭证，以验证客户端的身份。</li>
<li><strong>安全通信</strong>：通过设置凭证，可以确保RPC调用是在安全的环境中进行。</li>
</ul>
</li>
<li><strong>使用场景</strong>：
<ul>
<li><strong>客户端认证</strong>：在需要客户端认证的场景中，使用这个函数可以为每个RPC调用设置凭证。</li>
<li><strong>安全性要求</strong>：在需要保证通信安全性的场景中，通过设置凭证来增强安全性。</li>
</ul>
</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kn">package</span> <span class="nx">main</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;context&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;fmt&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;google.golang.org/grpc&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;time&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 定义一个简单的PerRPCCredentials实现
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">customCredentials</span><span class="p">()</span> <span class="p">(</span><span class="nx">credentials</span><span class="p">.</span><span class="nx">PerRPCCredentials</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 实现凭证的获取逻辑
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">ctx</span><span class="p">,</span> <span class="nx">cancel</span> <span class="o">:=</span> <span class="nx">context</span><span class="p">.</span><span class="nf">WithTimeout</span><span class="p">(</span><span class="nx">context</span><span class="p">.</span><span class="nf">Background</span><span class="p">(),</span> <span class="mi">5</span><span class="o">*</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">defer</span> <span class="nf">cancel</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 创建一个包含凭证的DialOption
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">opts</span> <span class="o">:=</span> <span class="p">[]</span><span class="nx">grpc</span><span class="p">.</span><span class="nx">DialOption</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">grpc</span><span class="p">.</span><span class="nf">WithPerRPCCredentials</span><span class="p">(</span><span class="nx">customCredentials</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">conn</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">grpc</span><span class="p">.</span><span class="nf">DialContext</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="s">&#34;localhost:50051&#34;</span><span class="p">,</span> <span class="nx">opts</span><span class="o">...</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;Failed to dial: %v\n&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">defer</span> <span class="nx">conn</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 客户端可以继续使用这个连接进行RPC调用
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></div><ol start="3">
<li>在这个例子中，我们创建了一个上下文，设置了5秒的超时时间。然后，我们使用<code>WithPerRPCCredentials</code>选项创建了一个包含自定义凭证的DialOption。这个凭证将被用于每次RPC调用。最后，我们使用这些选项来建立与服务器端口50051的gRPC连接。如果连接成功，客户端可以继续使用这个连接进行RPC调用。</li>
</ol>
<h3 id="withreadbuffersizes">WithReadBufferSize(s)<a hidden class="anchor" aria-hidden="true" href="#withreadbuffersizes">#</a></h3>
<ol>
<li>用于设置客户端连接（<code>ClientConn</code>）的读缓冲区（read buffer）的大小。这个缓冲区的大小决定了在一次系统调用中可以读取的最大数据量。</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// WithReadBufferSize lets you set the size of read buffer, this determines how
</span></span></span><span class="line"><span class="cl"><span class="c1">// much data can be read at most for each read syscall.
</span></span></span><span class="line"><span class="cl"><span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1">// The default value for this buffer is 32KB. Zero or negative values will
</span></span></span><span class="line"><span class="cl"><span class="c1">// disable read buffer for a connection so data framer can access the
</span></span></span><span class="line"><span class="cl"><span class="c1">// underlying conn directly.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">WithReadBufferSize</span><span class="p">(</span><span class="nx">s</span> <span class="kt">int</span><span class="p">)</span> <span class="nx">DialOption</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nf">newFuncDialOption</span><span class="p">(</span><span class="kd">func</span><span class="p">(</span><span class="nx">o</span> <span class="o">*</span><span class="nx">dialOptions</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">o</span><span class="p">.</span><span class="nx">copts</span><span class="p">.</span><span class="nx">ReadBufferSize</span> <span class="p">=</span> <span class="nx">s</span>
</span></span><span class="line"><span class="cl">	<span class="p">})</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h4 id="详解-8">详解<a hidden class="anchor" aria-hidden="true" href="#详解-8">#</a></h4>
<ol>
<li><strong>作用</strong>：
<ul>
<li><strong>性能调优</strong>：适当调整读缓冲区的大小可以优化客户端接收数据的性能。</li>
<li><strong>资源管理</strong>：通过设置合适的读缓冲区大小，可以有效地管理客户端端的内存使用。</li>
</ul>
</li>
<li><strong>默认值</strong>： 如果没有设置这个选项，gRPC客户端默认的读缓冲区大小是32KB。</li>
<li><strong>使用场景</strong>：
<ul>
<li><strong>网络条件优化</strong>：在网络条件变化时，调整读缓冲区大小可以帮助客户端更好地适应不同的网络条件。</li>
<li><strong>接收性能优化</strong>：在需要优化接收性能的应用场景中，调整读缓冲区大小可以提高效率。</li>
</ul>
</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kn">package</span> <span class="nx">main</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;context&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;fmt&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;google.golang.org/grpc&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;time&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">ctx</span><span class="p">,</span> <span class="nx">cancel</span> <span class="o">:=</span> <span class="nx">context</span><span class="p">.</span><span class="nf">WithTimeout</span><span class="p">(</span><span class="nx">context</span><span class="p">.</span><span class="nf">Background</span><span class="p">(),</span> <span class="mi">5</span><span class="o">*</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">defer</span> <span class="nf">cancel</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 设置客户端连接的读缓冲区大小为100KB
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">opts</span> <span class="o">:=</span> <span class="p">[]</span><span class="nx">grpc</span><span class="p">.</span><span class="nx">DialOption</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">grpc</span><span class="p">.</span><span class="nf">WithReadBufferSize</span><span class="p">(</span><span class="mi">100</span> <span class="o">*</span> <span class="mi">1024</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">conn</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">grpc</span><span class="p">.</span><span class="nf">DialContext</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="s">&#34;localhost:50051&#34;</span><span class="p">,</span> <span class="nx">opts</span><span class="o">...</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;Failed to dial: %v\n&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">defer</span> <span class="nx">conn</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 客户端可以继续使用这个连接进行RPC调用
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></div><ol start="4">
<li>在这个例子中，我们创建了一个上下文，设置了5秒的超时时间。然后，我们使用<code>WithReadBufferSize</code>选项将客户端连接的读缓冲区大小设置为100KB。最后，我们使用这些选项来建立与服务器端口50051的gRPC连接。如果连接成功，客户端可以继续使用这个连接进行RPC调用。</li>
</ol>
<h3 id="withresolversrs">WithResolvers(rs)<a hidden class="anchor" aria-hidden="true" href="#withresolversrs">#</a></h3>
<ol>
<li>用于在客户端连接（<code>ClientConn</code>）上注册一系列解析器（resolver）实现，而不需要通过全局注册的方式。这些解析器将被用于解析客户端在当前Dial操作中使用的方案（scheme）。</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// WithResolvers allows a list of resolver implementations to be registered
</span></span></span><span class="line"><span class="cl"><span class="c1">// locally with the ClientConn without needing to be globally registered via
</span></span></span><span class="line"><span class="cl"><span class="c1">// resolver.Register.  They will be matched against the scheme used for the
</span></span></span><span class="line"><span class="cl"><span class="c1">// current Dial only, and will take precedence over the global registry.
</span></span></span><span class="line"><span class="cl"><span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1">// # Experimental
</span></span></span><span class="line"><span class="cl"><span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1">// Notice: This API is EXPERIMENTAL and may be changed or removed in a
</span></span></span><span class="line"><span class="cl"><span class="c1">// later release.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">WithResolvers</span><span class="p">(</span><span class="nx">rs</span> <span class="o">...</span><span class="nx">resolver</span><span class="p">.</span><span class="nx">Builder</span><span class="p">)</span> <span class="nx">DialOption</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nf">newFuncDialOption</span><span class="p">(</span><span class="kd">func</span><span class="p">(</span><span class="nx">o</span> <span class="o">*</span><span class="nx">dialOptions</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">o</span><span class="p">.</span><span class="nx">resolvers</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">o</span><span class="p">.</span><span class="nx">resolvers</span><span class="p">,</span> <span class="nx">rs</span><span class="o">...</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">})</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h4 id="详解-9">详解<a hidden class="anchor" aria-hidden="true" href="#详解-9">#</a></h4>
<ol>
<li><strong>作用</strong>：
<ul>
<li><strong>本地解析器注册</strong>：允许客户端在本地注册解析器，而不需要全局注册。</li>
<li><strong>优先级</strong>：本地注册的解析器将优先于全局注册的解析器。</li>
</ul>
</li>
<li><strong>使用场景</strong>：
<ul>
<li><strong>定制解析器</strong>：在需要使用自定义解析器或优先使用特定解析器的场景中，可以使用这个函数。</li>
<li><strong>实验性特性</strong>：这个函数是一个实验性特性，可能会在未来的gRPC版本中更改或移除。</li>
</ul>
</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kn">package</span> <span class="nx">main</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;context&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;fmt&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;google.golang.org/grpc&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;time&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 定义一个简单的解析器实现
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">customResolver</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">s</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="nx">addrs</span> <span class="p">[]</span><span class="nx">resolver</span><span class="p">.</span><span class="nx">Address</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 解析地址并返回解析结果
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">return</span> <span class="p">[]</span><span class="nx">resolver</span><span class="p">.</span><span class="nx">Address</span><span class="p">{},</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">ctx</span><span class="p">,</span> <span class="nx">cancel</span> <span class="o">:=</span> <span class="nx">context</span><span class="p">.</span><span class="nf">WithTimeout</span><span class="p">(</span><span class="nx">context</span><span class="p">.</span><span class="nf">Background</span><span class="p">(),</span> <span class="mi">5</span><span class="o">*</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">defer</span> <span class="nf">cancel</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 创建一个包含解析器的DialOption
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">opts</span> <span class="o">:=</span> <span class="p">[]</span><span class="nx">grpc</span><span class="p">.</span><span class="nx">DialOption</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">grpc</span><span class="p">.</span><span class="nf">WithResolvers</span><span class="p">(</span><span class="nx">customResolver</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">conn</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">grpc</span><span class="p">.</span><span class="nf">DialContext</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="s">&#34;localhost:50051&#34;</span><span class="p">,</span> <span class="nx">opts</span><span class="o">...</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;Failed to dial: %v\n&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">defer</span> <span class="nx">conn</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 客户端可以继续使用这个连接进行RPC调用
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></div><ol start="3">
<li>在这个例子中，我们创建了一个上下文，设置了5秒的超时时间。然后，我们使用<code>WithResolvers</code>选项创建了一个包含自定义解析器的DialOption。这个解析器将用于解析地址。最后，我们使用这些选项来建立与服务器端口50051的gRPC连接。如果连接成功，客户端可以继续使用这个连接进行RPC调用。</li>
</ol>
<h3 id="withsharedwritebufferval">WithSharedWriteBuffer(val)<a hidden class="anchor" aria-hidden="true" href="#withsharedwritebufferval">#</a></h3>
<ol>
<li>用于设置客户端连接（<code>ClientConn</code>）的写缓冲区（write buffer）是否可以共享。这个选项影响客户端连接发送数据的缓冲机制。</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// WithSharedWriteBuffer allows reusing per-connection transport write buffer.
</span></span></span><span class="line"><span class="cl"><span class="c1">// If this option is set to true every connection will release the buffer after
</span></span></span><span class="line"><span class="cl"><span class="c1">// flushing the data on the wire.
</span></span></span><span class="line"><span class="cl"><span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1">// # Experimental
</span></span></span><span class="line"><span class="cl"><span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1">// Notice: This API is EXPERIMENTAL and may be changed or removed in a
</span></span></span><span class="line"><span class="cl"><span class="c1">// later release.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">WithSharedWriteBuffer</span><span class="p">(</span><span class="nx">val</span> <span class="kt">bool</span><span class="p">)</span> <span class="nx">DialOption</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nf">newFuncDialOption</span><span class="p">(</span><span class="kd">func</span><span class="p">(</span><span class="nx">o</span> <span class="o">*</span><span class="nx">dialOptions</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">o</span><span class="p">.</span><span class="nx">copts</span><span class="p">.</span><span class="nx">SharedWriteBuffer</span> <span class="p">=</span> <span class="nx">val</span>
</span></span><span class="line"><span class="cl">	<span class="p">})</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h4 id="详解-10">详解<a hidden class="anchor" aria-hidden="true" href="#详解-10">#</a></h4>
<ol>
<li><strong>作用</strong>：
<ul>
<li><strong>缓冲机制控制</strong>：允许客户端控制写缓冲区的共享行为，这可以影响客户端发送数据的效率。</li>
<li><strong>性能调优</strong>：通过调整写缓冲区的共享行为，可以优化客户端的性能。</li>
</ul>
</li>
<li><strong>默认值</strong>： 默认情况下，写缓冲区是独立的，每个连接都有自己的缓冲区。</li>
<li><strong>使用场景</strong>：
<ul>
<li><strong>性能优化</strong>：在需要优化发送性能的应用场景中，可以通过设置写缓冲区是否共享来优化效率。</li>
<li><strong>资源管理</strong>：在需要管理客户端资源的场景中，通过设置写缓冲区是否共享来控制资源的使用。</li>
</ul>
</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kn">package</span> <span class="nx">main</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;context&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;fmt&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;google.golang.org/grpc&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;time&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">ctx</span><span class="p">,</span> <span class="nx">cancel</span> <span class="o">:=</span> <span class="nx">context</span><span class="p">.</span><span class="nf">WithTimeout</span><span class="p">(</span><span class="nx">context</span><span class="p">.</span><span class="nf">Background</span><span class="p">(),</span> <span class="mi">5</span><span class="o">*</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">defer</span> <span class="nf">cancel</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 设置写缓冲区可以共享
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">opts</span> <span class="o">:=</span> <span class="p">[]</span><span class="nx">grpc</span><span class="p">.</span><span class="nx">DialOption</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">grpc</span><span class="p">.</span><span class="nf">WithSharedWriteBuffer</span><span class="p">(</span><span class="kc">true</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">conn</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">grpc</span><span class="p">.</span><span class="nf">DialContext</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="s">&#34;localhost:50051&#34;</span><span class="p">,</span> <span class="nx">opts</span><span class="o">...</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;Failed to dial: %v\n&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">defer</span> <span class="nx">conn</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 客户端可以继续使用这个连接进行RPC调用
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></div><ol start="4">
<li>在这个例子中，我们创建了一个上下文，设置了5秒的超时时间。然后，我们使用<code>WithSharedWriteBuffer</code>选项将写缓冲区设置为可以共享。最后，我们使用这些选项来建立与服务器端口50051的gRPC连接。如果连接成功，客户端可以继续使用这个连接进行RPC调用。</li>
</ol>
<h3 id="withstatshandlerh">WithStatsHandler(h)<a hidden class="anchor" aria-hidden="true" href="#withstatshandlerh">#</a></h3>
<ol>
<li>用于为gRPC客户端连接指定统计（stats）处理程序。这个处理程序用于收集和报告关于客户端操作的统计信息，这些信息可以帮助开发者监控客户端性能、诊断问题，并进行性能调优。</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// WithStatsHandler returns a DialOption that specifies the stats handler for
</span></span></span><span class="line"><span class="cl"><span class="c1">// all the RPCs and underlying network connections in this ClientConn.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">WithStatsHandler</span><span class="p">(</span><span class="nx">h</span> <span class="nx">stats</span><span class="p">.</span><span class="nx">Handler</span><span class="p">)</span> <span class="nx">DialOption</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nf">newFuncDialOption</span><span class="p">(</span><span class="kd">func</span><span class="p">(</span><span class="nx">o</span> <span class="o">*</span><span class="nx">dialOptions</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="nx">h</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nx">logger</span><span class="p">.</span><span class="nf">Error</span><span class="p">(</span><span class="s">&#34;ignoring nil parameter in grpc.WithStatsHandler ClientOption&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">			<span class="c1">// Do not allow a nil stats handler, which would otherwise cause
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="c1">// panics.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="k">return</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="nx">o</span><span class="p">.</span><span class="nx">copts</span><span class="p">.</span><span class="nx">StatsHandlers</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">o</span><span class="p">.</span><span class="nx">copts</span><span class="p">.</span><span class="nx">StatsHandlers</span><span class="p">,</span> <span class="nx">h</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">})</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h4 id="详解-11">详解<a hidden class="anchor" aria-hidden="true" href="#详解-11">#</a></h4>
<ol>
<li><strong>作用</strong>：
<ul>
<li><strong>性能监控</strong>：通过收集客户端操作的统计信息，可以监控客户端性能，及时发现性能瓶颈。</li>
<li><strong>问题诊断</strong>：当客户端出现问题时，统计信息可以帮助诊断问题原因。</li>
<li><strong>性能调优</strong>：根据统计数据，可以对客户端配置进行调整，以优化性能。</li>
</ul>
</li>
<li><strong>使用场景</strong>：
<ul>
<li><strong>性能监控</strong>：在需要监控客户端性能的应用场景中，可以通过设置统计处理程序来收集统计信息。</li>
<li><strong>问题诊断</strong>：在需要诊断客户端问题的应用场景中，可以通过设置统计处理程序来收集诊断信息。</li>
<li><strong>性能调优</strong>：在需要优化客户端性能的应用场景中，可以通过设置统计处理程序来收集性能数据。</li>
</ul>
</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kn">package</span> <span class="nx">main</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;context&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;fmt&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;google.golang.org/grpc&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;time&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 定义一个简单的统计处理程序
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">loggingStatsHandler</span><span class="p">(</span><span class="nx">s</span> <span class="nx">stats</span><span class="p">.</span><span class="nx">RawClientStats</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 处理统计信息，例如记录到日志
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;Received %d bytes on stream&#34;</span><span class="p">,</span> <span class="nx">s</span><span class="p">.</span><span class="nx">StreamBytesReceived</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">ctx</span><span class="p">,</span> <span class="nx">cancel</span> <span class="o">:=</span> <span class="nx">context</span><span class="p">.</span><span class="nf">WithTimeout</span><span class="p">(</span><span class="nx">context</span><span class="p">.</span><span class="nf">Background</span><span class="p">(),</span> <span class="mi">5</span><span class="o">*</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">defer</span> <span class="nf">cancel</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 创建一个包含统计处理程序的DialOption
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">opts</span> <span class="o">:=</span> <span class="p">[]</span><span class="nx">grpc</span><span class="p">.</span><span class="nx">DialOption</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">grpc</span><span class="p">.</span><span class="nf">WithStatsHandler</span><span class="p">(</span><span class="nx">loggingStatsHandler</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">conn</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">grpc</span><span class="p">.</span><span class="nf">DialContext</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="s">&#34;localhost:50051&#34;</span><span class="p">,</span> <span class="nx">opts</span><span class="o">...</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;Failed to dial: %v\n&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">defer</span> <span class="nx">conn</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 客户端可以继续使用这个连接进行RPC调用
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></div><ol start="3">
<li>在这个例子中，我们创建了一个上下文，设置了5秒的超时时间。然后，我们使用<code>WithStatsHandler</code>选项创建了一个包含统计处理程序的DialOption。这个统计处理程序将记录每个流接收到的字节数。最后，我们使用这些选项来建立与服务器端口50051的gRPC连接。如果连接成功，客户端可以继续使用这个连接进行RPC调用。</li>
</ol>
<h3 id="withstreaminterceptorf">WithStreamInterceptor(f)<a hidden class="anchor" aria-hidden="true" href="#withstreaminterceptorf">#</a></h3>
<ol>
<li>用于为gRPC客户端的流式RPC（streaming RPC）添加一个拦截器（interceptor）。这个拦截器会在客户端发送流式RPC请求和接收响应时被调用。</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// WithStreamInterceptor returns a DialOption that specifies the interceptor for
</span></span></span><span class="line"><span class="cl"><span class="c1">// streaming RPCs.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">WithStreamInterceptor</span><span class="p">(</span><span class="nx">f</span> <span class="nx">StreamClientInterceptor</span><span class="p">)</span> <span class="nx">DialOption</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nf">newFuncDialOption</span><span class="p">(</span><span class="kd">func</span><span class="p">(</span><span class="nx">o</span> <span class="o">*</span><span class="nx">dialOptions</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">o</span><span class="p">.</span><span class="nx">streamInt</span> <span class="p">=</span> <span class="nx">f</span>
</span></span><span class="line"><span class="cl">	<span class="p">})</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h4 id="详解-12">详解<a hidden class="anchor" aria-hidden="true" href="#详解-12">#</a></h4>
<ol>
<li><strong>作用</strong>：
<ul>
<li><strong>拦截器逻辑</strong>：允许客户端在流式RPC的各个阶段添加自定义逻辑。</li>
<li><strong>功能扩展</strong>：通过组合不同的拦截器，可以实现更复杂的客户端功能，例如请求和响应的修改、错误处理、日志记录等。</li>
</ul>
</li>
<li><strong>使用场景</strong>：
<ul>
<li><strong>日志记录</strong>：在流式RPC的发送和接收过程中添加日志记录功能。</li>
<li><strong>请求修改</strong>：在发送请求之前对请求进行修改。</li>
<li><strong>响应修改</strong>：在接收响应之前对响应进行修改。</li>
</ul>
</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kn">package</span> <span class="nx">main</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;context&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;fmt&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;google.golang.org/grpc&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;time&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 定义一个简单的StreamClientInterceptor
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">loggingInterceptor</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">desc</span> <span class="o">*</span><span class="nx">grpc</span><span class="p">.</span><span class="nx">StreamDesc</span><span class="p">,</span> <span class="nx">cc</span> <span class="o">*</span><span class="nx">grpc</span><span class="p">.</span><span class="nx">ClientConn</span><span class="p">,</span> <span class="nx">method</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">opts</span> <span class="o">...</span><span class="nx">grpc</span><span class="p">.</span><span class="nx">CallOption</span><span class="p">)</span> <span class="p">(</span><span class="nx">grpc</span><span class="p">.</span><span class="nx">ClientStream</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">stream</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">cc</span><span class="p">.</span><span class="nf">NewStream</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">desc</span><span class="p">,</span> <span class="nx">method</span><span class="p">,</span> <span class="nx">opts</span><span class="o">...</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">err</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="o">&amp;</span><span class="nx">loggingStream</span><span class="p">{</span><span class="nx">stream</span><span class="p">},</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">loggingStream</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">grpc</span><span class="p">.</span><span class="nx">ClientStream</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">loggingStream</span><span class="p">)</span> <span class="nf">SendMsg</span><span class="p">(</span><span class="nx">m</span> <span class="kd">interface</span><span class="p">{})</span> <span class="kt">error</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;Sending message: %v\n&#34;</span><span class="p">,</span> <span class="nx">m</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nx">s</span><span class="p">.</span><span class="nx">ClientStream</span><span class="p">.</span><span class="nf">SendMsg</span><span class="p">(</span><span class="nx">m</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">loggingStream</span><span class="p">)</span> <span class="nf">RecvMsg</span><span class="p">(</span><span class="nx">m</span> <span class="kd">interface</span><span class="p">{})</span> <span class="kt">error</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;Received message: %v\n&#34;</span><span class="p">,</span> <span class="nx">m</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nx">s</span><span class="p">.</span><span class="nx">ClientStream</span><span class="p">.</span><span class="nf">RecvMsg</span><span class="p">(</span><span class="nx">m</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">loggingStream</span><span class="p">)</span> <span class="nf">CloseSend</span><span class="p">()</span> <span class="kt">error</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;Closing send side of the stream&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nx">s</span><span class="p">.</span><span class="nx">ClientStream</span><span class="p">.</span><span class="nf">CloseSend</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">loggingStream</span><span class="p">)</span> <span class="nf">Context</span><span class="p">()</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nx">s</span><span class="p">.</span><span class="nx">ClientStream</span><span class="p">.</span><span class="nf">Context</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">ctx</span><span class="p">,</span> <span class="nx">cancel</span> <span class="o">:=</span> <span class="nx">context</span><span class="p">.</span><span class="nf">WithTimeout</span><span class="p">(</span><span class="nx">context</span><span class="p">.</span><span class="nf">Background</span><span class="p">(),</span> <span class="mi">5</span><span class="o">*</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">defer</span> <span class="nf">cancel</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 创建一个包含拦截器的DialOption
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">opts</span> <span class="o">:=</span> <span class="p">[]</span><span class="nx">grpc</span><span class="p">.</span><span class="nx">DialOption</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">grpc</span><span class="p">.</span><span class="nf">WithStreamInterceptor</span><span class="p">(</span><span class="nx">loggingInterceptor</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">conn</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">grpc</span><span class="p">.</span><span class="nf">DialContext</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="s">&#34;localhost:50051&#34;</span><span class="p">,</span> <span class="nx">opts</span><span class="o">...</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;Failed to dial: %v\n&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">defer</span> <span class="nx">conn</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 客户端可以继续使用这个连接进行RPC调用
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></div><ol start="3">
<li>在这个例子中，我们定义了一个简单的<code>loggingInterceptor</code>函数，它会在流式RPC的发送和接收过程中添加日志记录功能。然后，我们使用<code>WithStreamInterceptor</code>选项将这个拦截器添加到客户端的连接配置中。当客户端建立与服务器端口的连接并进行流式RPC调用时，<code>loggingInterceptor</code>将会被调用，并在发送和接收消息时打印日志。</li>
</ol>
<h3 id="withtransportcredentialscreds">WithTransportCredentials(creds)<a hidden class="anchor" aria-hidden="true" href="#withtransportcredentialscreds">#</a></h3>
<ol>
<li>用于配置客户端连接层面的安全凭证（例如TLS/SSL）。这个选项允许客户端在建立与服务器的连接时使用指定的传输级安全凭证。</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// WithTransportCredentials returns a DialOption which configures a connection
</span></span></span><span class="line"><span class="cl"><span class="c1">// level security credentials (e.g., TLS/SSL). This should not be used together
</span></span></span><span class="line"><span class="cl"><span class="c1">// with WithCredentialsBundle.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">WithTransportCredentials</span><span class="p">(</span><span class="nx">creds</span> <span class="nx">credentials</span><span class="p">.</span><span class="nx">TransportCredentials</span><span class="p">)</span> <span class="nx">DialOption</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nf">newFuncDialOption</span><span class="p">(</span><span class="kd">func</span><span class="p">(</span><span class="nx">o</span> <span class="o">*</span><span class="nx">dialOptions</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">o</span><span class="p">.</span><span class="nx">copts</span><span class="p">.</span><span class="nx">TransportCredentials</span> <span class="p">=</span> <span class="nx">creds</span>
</span></span><span class="line"><span class="cl">	<span class="p">})</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h4 id="详解-13">详解<a hidden class="anchor" aria-hidden="true" href="#详解-13">#</a></h4>
<ol>
<li><strong>作用</strong>：
<ul>
<li><strong>安全连接</strong>：允许客户端在连接到服务器时使用TLS/SSL等安全协议，以加密传输的数据。</li>
<li><strong>证书验证</strong>：客户端可以验证服务器的证书，确保连接到的是预期的服务器。</li>
</ul>
</li>
<li><strong>使用场景</strong>：
<ul>
<li><strong>数据加密</strong>：在需要保护传输数据隐私和完整性的场景中，使用TLS/SSL等安全协议。</li>
<li><strong>身份验证</strong>：在需要验证服务器身份的场景中，使用证书验证机制。</li>
</ul>
</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kn">package</span> <span class="nx">main</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;context&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;fmt&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;google.golang.org/grpc&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;time&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">ctx</span><span class="p">,</span> <span class="nx">cancel</span> <span class="o">:=</span> <span class="nx">context</span><span class="p">.</span><span class="nf">WithTimeout</span><span class="p">(</span><span class="nx">context</span><span class="p">.</span><span class="nf">Background</span><span class="p">(),</span> <span class="mi">5</span><span class="o">*</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">defer</span> <span class="nf">cancel</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 配置TLS/SSL传输级安全凭证
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">creds</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">credentials</span><span class="p">.</span><span class="nf">NewClientTLSFromFile</span><span class="p">(</span><span class="s">&#34;server.crt&#34;</span><span class="p">,</span> <span class="s">&#34;&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;Failed to load TLS credentials: %v\n&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 使用传输级安全凭证的DialOption
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">opts</span> <span class="o">:=</span> <span class="p">[]</span><span class="nx">grpc</span><span class="p">.</span><span class="nx">DialOption</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">grpc</span><span class="p">.</span><span class="nf">WithTransportCredentials</span><span class="p">(</span><span class="nx">creds</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">conn</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">grpc</span><span class="p">.</span><span class="nf">DialContext</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="s">&#34;localhost:50051&#34;</span><span class="p">,</span> <span class="nx">opts</span><span class="o">...</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;Failed to dial: %v\n&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">defer</span> <span class="nx">conn</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 客户端可以继续使用这个连接进行RPC调用
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></div><ol start="3">
<li>在这个例子中，我们创建了一个上下文，设置了5秒的超时时间。然后，我们使用<code>WithTransportCredentials</code>选项配置了TLS/SSL传输级安全凭证。最后，我们使用这些选项来建立与服务器端口50051的gRPC连接。如果连接成功，客户端可以继续使用这个连接进行RPC调用。</li>
</ol>
<h3 id="withunaryinterceptorf">WithUnaryInterceptor(f)<a hidden class="anchor" aria-hidden="true" href="#withunaryinterceptorf">#</a></h3>
<ol>
<li>用于为gRPC客户端的单向RPC（unary RPC）添加一个拦截器（interceptor）。这个拦截器会在客户端发送单向RPC请求和接收响应时被调用。</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// WithUnaryInterceptor returns a DialOption that specifies the interceptor for
</span></span></span><span class="line"><span class="cl"><span class="c1">// unary RPCs.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">WithUnaryInterceptor</span><span class="p">(</span><span class="nx">f</span> <span class="nx">UnaryClientInterceptor</span><span class="p">)</span> <span class="nx">DialOption</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nf">newFuncDialOption</span><span class="p">(</span><span class="kd">func</span><span class="p">(</span><span class="nx">o</span> <span class="o">*</span><span class="nx">dialOptions</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">o</span><span class="p">.</span><span class="nx">unaryInt</span> <span class="p">=</span> <span class="nx">f</span>
</span></span><span class="line"><span class="cl">	<span class="p">})</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h4 id="详解-14">详解<a hidden class="anchor" aria-hidden="true" href="#详解-14">#</a></h4>
<ol>
<li><strong>作用</strong>：
<ul>
<li><strong>拦截器逻辑</strong>：允许客户端在单向RPC的各个阶段添加自定义逻辑。</li>
<li><strong>功能扩展</strong>：通过组合不同的拦截器，可以实现更复杂的客户端功能，例如请求和响应的修改、错误处理、日志记录等。</li>
</ul>
</li>
<li><strong>使用场景</strong>：
<ul>
<li><strong>日志记录</strong>：在单向RPC的发送和接收过程中添加日志记录功能。</li>
<li><strong>请求修改</strong>：在发送请求之前对请求进行修改。</li>
<li><strong>响应修改</strong>：在接收响应之前对响应进行修改。</li>
</ul>
</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kn">package</span> <span class="nx">main</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;context&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;fmt&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;google.golang.org/grpc&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;time&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 定义一个简单的UnaryClientInterceptor
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">loggingInterceptor</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">method</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">req</span><span class="p">,</span> <span class="nx">reply</span> <span class="kd">interface</span><span class="p">{},</span> <span class="nx">cc</span> <span class="o">*</span><span class="nx">grpc</span><span class="p">.</span><span class="nx">ClientConn</span><span class="p">,</span> <span class="nx">invoker</span> <span class="nx">grpc</span><span class="p">.</span><span class="nx">UnaryInvoker</span><span class="p">,</span> <span class="nx">opts</span> <span class="o">...</span><span class="nx">grpc</span><span class="p">.</span><span class="nx">CallOption</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;Sending request: %v\n&#34;</span><span class="p">,</span> <span class="nx">req</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">err</span> <span class="o">:=</span> <span class="nf">invoker</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">method</span><span class="p">,</span> <span class="nx">req</span><span class="p">,</span> <span class="nx">reply</span><span class="p">,</span> <span class="nx">cc</span><span class="p">,</span> <span class="nx">opts</span><span class="o">...</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="nx">err</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;Received response: %v\n&#34;</span><span class="p">,</span> <span class="nx">reply</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">ctx</span><span class="p">,</span> <span class="nx">cancel</span> <span class="o">:=</span> <span class="nx">context</span><span class="p">.</span><span class="nf">WithTimeout</span><span class="p">(</span><span class="nx">context</span><span class="p">.</span><span class="nf">Background</span><span class="p">(),</span> <span class="mi">5</span><span class="o">*</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">defer</span> <span class="nf">cancel</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 创建一个包含拦截器的DialOption
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">opts</span> <span class="o">:=</span> <span class="p">[]</span><span class="nx">grpc</span><span class="p">.</span><span class="nx">DialOption</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">grpc</span><span class="p">.</span><span class="nf">WithUnaryInterceptor</span><span class="p">(</span><span class="nx">loggingInterceptor</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">conn</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">grpc</span><span class="p">.</span><span class="nf">DialContext</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="s">&#34;localhost:50051&#34;</span><span class="p">,</span> <span class="nx">opts</span><span class="o">...</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;Failed to dial: %v\n&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">defer</span> <span class="nx">conn</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 客户端可以继续使用这个连接进行RPC调用
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></div><ol start="3">
<li>在这个例子中，我们定义了一个简单的<code>loggingInterceptor</code>函数，它会在单向RPC的发送和接收过程中添加日志记录功能。然后，我们使用<code>WithUnaryInterceptor</code>选项将这个拦截器添加到客户端的连接配置中。当客户端建立与服务器端口的连接并进行单向RPC调用时，<code>loggingInterceptor</code>将会被调用，并在发送请求和接收响应时打印日志。</li>
</ol>
<h3 id="withuseragents">WithUserAgent(s)<a hidden class="anchor" aria-hidden="true" href="#withuseragents">#</a></h3>
<ol>
<li>设置 UserAgent。</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// WithUserAgent returns a DialOption that specifies a user agent string for all
</span></span></span><span class="line"><span class="cl"><span class="c1">// the RPCs.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">WithUserAgent</span><span class="p">(</span><span class="nx">s</span> <span class="kt">string</span><span class="p">)</span> <span class="nx">DialOption</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nf">newFuncDialOption</span><span class="p">(</span><span class="kd">func</span><span class="p">(</span><span class="nx">o</span> <span class="o">*</span><span class="nx">dialOptions</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">o</span><span class="p">.</span><span class="nx">copts</span><span class="p">.</span><span class="nx">UserAgent</span> <span class="p">=</span> <span class="nx">s</span> <span class="o">+</span> <span class="s">&#34; &#34;</span> <span class="o">+</span> <span class="nx">grpcUA</span>
</span></span><span class="line"><span class="cl">    <span class="p">})</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h4 id="详解-15">详解<a hidden class="anchor" aria-hidden="true" href="#详解-15">#</a></h4>
<ol>
<li>用于为所有通过该客户端连接发起的RPC设置用户代理（User Agent）字符串。用户代理字符串通常包含客户端软件的类型、版本、所用操作系统和其他环境信息，它被包含在RPC请求的<code>User-Agent</code>头信息中。</li>
<li><strong>作用</strong>：
<ul>
<li><strong>身份标识</strong>：允许客户端在RPC请求中包含用户代理信息，这有助于服务器识别客户端的类型和版本。</li>
<li><strong>统计分析</strong>：服务器可以通过用户代理信息来分析客户端的使用情况。</li>
</ul>
</li>
<li><strong>使用场景</strong>：
<ul>
<li><strong>服务监控</strong>：在需要监控客户端和服务器交互的场合，用户代理信息可以提供有用的上下文。</li>
<li><strong>统计分析</strong>：在需要分析客户端和服务器交互的统计数据的场合，用户代理信息可以提供额外的信息。</li>
</ul>
</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kn">package</span> <span class="nx">main</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;context&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;fmt&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;google.golang.org/grpc&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;time&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">ctx</span><span class="p">,</span> <span class="nx">cancel</span> <span class="o">:=</span> <span class="nx">context</span><span class="p">.</span><span class="nf">WithTimeout</span><span class="p">(</span><span class="nx">context</span><span class="p">.</span><span class="nf">Background</span><span class="p">(),</span> <span class="mi">5</span><span class="o">*</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">defer</span> <span class="nf">cancel</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 设置RPC调用的用户代理为&#34;my-client/1.0&#34;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">opts</span> <span class="o">:=</span> <span class="p">[]</span><span class="nx">grpc</span><span class="p">.</span><span class="nx">DialOption</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">grpc</span><span class="p">.</span><span class="nf">WithUserAgent</span><span class="p">(</span><span class="s">&#34;my-client/1.0&#34;</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">conn</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">grpc</span><span class="p">.</span><span class="nf">DialContext</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="s">&#34;localhost:50051&#34;</span><span class="p">,</span> <span class="nx">opts</span><span class="o">...</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;Failed to dial: %v\n&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">defer</span> <span class="nx">conn</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 客户端可以继续使用这个连接进行RPC调用
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></div><ol start="4">
<li>在这个例子中，我们创建了一个上下文，设置了5秒的超时时间。然后，我们使用<code>WithUserAgent</code>选项为通过连接发起的所有RPC设置用户代理为&quot;my-client/1.0&rdquo;。最后，我们使用这些选项来建立与服务器端口50051的gRPC连接。如果连接成功，客户端可以继续使用这个连接进行RPC调用。</li>
</ol>
<h3 id="withwritebuffersizes">WithWriteBufferSize(s)<a hidden class="anchor" aria-hidden="true" href="#withwritebuffersizes">#</a></h3>
<ol>
<li>设置传输层写缓冲，默认值为32KB。可以设置为0或负数，禁止写缓冲</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// WithWriteBufferSize determines how much data can be batched before doing a
</span></span></span><span class="line"><span class="cl"><span class="c1">// write on the wire. The default value for this buffer is 32KB.
</span></span></span><span class="line"><span class="cl"><span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1">// Zero or negative values will disable the write buffer such that each write
</span></span></span><span class="line"><span class="cl"><span class="c1">// will be on underlying connection. Note: A Send call may not directly
</span></span></span><span class="line"><span class="cl"><span class="c1">// translate to a write.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">WithWriteBufferSize</span><span class="p">(</span><span class="nx">s</span> <span class="kt">int</span><span class="p">)</span> <span class="nx">DialOption</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nf">newFuncDialOption</span><span class="p">(</span><span class="kd">func</span><span class="p">(</span><span class="nx">o</span> <span class="o">*</span><span class="nx">dialOptions</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">o</span><span class="p">.</span><span class="nx">copts</span><span class="p">.</span><span class="nx">WriteBufferSize</span> <span class="p">=</span> <span class="nx">s</span>
</span></span><span class="line"><span class="cl">    <span class="p">})</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h4 id="详解-16">详解<a hidden class="anchor" aria-hidden="true" href="#详解-16">#</a></h4>
<ol>
<li><strong>作用</strong>：
<ul>
<li><strong>性能调优</strong>：适当调整写缓冲区的大小可以优化客户端发送数据的性能。</li>
<li><strong>资源管理</strong>：通过设置合适的写缓冲区大小，可以有效地管理客户端端的内存使用。</li>
</ul>
</li>
<li><strong>默认值</strong>： 如果没有设置这个选项，gRPC客户端默认的写缓冲区大小是32KB。</li>
<li><strong>使用场景</strong>：
<ul>
<li><strong>网络条件优化</strong>：在网络条件变化时，调整写缓冲区大小可以帮助客户端更好地适应不同的网络条件。</li>
<li><strong>发送性能优化</strong>：在需要优化发送性能的应用场景中，调整写缓冲区大小可以提高效率。</li>
</ul>
</li>
<li>用于设置客户端连接（<code>ClientConn</code>）的写缓冲区（write buffer）的大小。这个缓冲区的大小决定了在一次系统调用中可以发送的最大数据量。</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kn">package</span> <span class="nx">main</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;context&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;fmt&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;google.golang.org/grpc&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;time&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">ctx</span><span class="p">,</span> <span class="nx">cancel</span> <span class="o">:=</span> <span class="nx">context</span><span class="p">.</span><span class="nf">WithTimeout</span><span class="p">(</span><span class="nx">context</span><span class="p">.</span><span class="nf">Background</span><span class="p">(),</span> <span class="mi">5</span><span class="o">*</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">defer</span> <span class="nf">cancel</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 设置客户端连接的写缓冲区大小为100KB
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">opts</span> <span class="o">:=</span> <span class="p">[]</span><span class="nx">grpc</span><span class="p">.</span><span class="nx">DialOption</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">grpc</span><span class="p">.</span><span class="nf">WithWriteBufferSize</span><span class="p">(</span><span class="mi">100</span> <span class="o">*</span> <span class="mi">1024</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">conn</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">grpc</span><span class="p">.</span><span class="nf">DialContext</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="s">&#34;localhost:50051&#34;</span><span class="p">,</span> <span class="nx">opts</span><span class="o">...</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;Failed to dial: %v\n&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">defer</span> <span class="nx">conn</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 客户端可以继续使用这个连接进行RPC调用
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></div><ol start="5">
<li>在这个例子中，我们创建了一个上下文，设置了5秒的超时时间。然后，我们使用<code>WithWriteBufferSize</code>选项将客户端连接的写缓冲区大小设置为100KB。最后，我们使用这些选项来建立与服务器端口50051的gRPC连接。如果连接成功，客户端可以继续使用这个连接进行RPC调用。</li>
</ol>
<h2 id="type-calloption">type CallOption<a hidden class="anchor" aria-hidden="true" href="#type-calloption">#</a></h2>
<ol>
<li>callloption在调用启动前配置调用，或在调用完成后从调用中提取信息。</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// CallOption configures a Call before it starts or extracts information from
</span></span></span><span class="line"><span class="cl"><span class="c1">// a Call after it completes.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">type</span> <span class="nx">CallOption</span> <span class="kd">interface</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 在调用被发送到任何服务器之前被调用。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 如果before返回一个非nil错误，RPC就会因为这个错误而失败。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">before</span><span class="p">(</span><span class="o">*</span><span class="nx">callInfo</span><span class="p">)</span> <span class="kt">error</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// After在呼叫完成后被调用。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// After不能返回错误，因此应该通过输出参数报告任何失败。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">after</span><span class="p">(</span><span class="o">*</span><span class="nx">callInfo</span><span class="p">,</span> <span class="o">*</span><span class="nx">csAttempt</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h3 id="callcontentsubtypecontentsubtype">CallContentSubtype(contentSubtype)<a hidden class="anchor" aria-hidden="true" href="#callcontentsubtypecontentsubtype">#</a></h3>
<ol>
<li>CallContentSubtype返回一个callloption，它将为调用设置内容子类型。例如，如果content-subtype是&quot;json&quot;，那么网络上的Content-Type将是&quot;application/grpc+json&quot;。在包含在Content-Type中之前，content-子类型被转换为小写。详细信息请参见https://github.com/grpc/grpc/blob/master/doc/PROTOCOL-HTTP2.md#requests上的内容类型。</li>
<li>如果没有使用ForceCodec, content-子类型将用于查找由RegisterCodec控制的注册表中使用的编解码器。有关注册的详细信息，请参阅RegisterCodec的文档。查找content-subtype不区分大小写。如果没有找到这样的编解码器，调用将导致code.internal错误。</li>
<li>如果还使用了ForceCodec，那么该编解码器将用于所有请求和响应消息，并将内容子类型设置为请求的给定contentSubtype。</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// CallContentSubtype returns a CallOption that will set the content-subtype
</span></span></span><span class="line"><span class="cl"><span class="c1">// for a call. For example, if content-subtype is &#34;json&#34;, the Content-Type over
</span></span></span><span class="line"><span class="cl"><span class="c1">// the wire will be &#34;application/grpc+json&#34;. The content-subtype is converted
</span></span></span><span class="line"><span class="cl"><span class="c1">// to lowercase before being included in Content-Type. See Content-Type on
</span></span></span><span class="line"><span class="cl"><span class="c1">// https://github.com/grpc/grpc/blob/master/doc/PROTOCOL-HTTP2.md#requests for
</span></span></span><span class="line"><span class="cl"><span class="c1">// more details.
</span></span></span><span class="line"><span class="cl"><span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1">// If ForceCodec is not also used, the content-subtype will be used to look up
</span></span></span><span class="line"><span class="cl"><span class="c1">// the Codec to use in the registry controlled by RegisterCodec. See the
</span></span></span><span class="line"><span class="cl"><span class="c1">// documentation on RegisterCodec for details on registration. The lookup of
</span></span></span><span class="line"><span class="cl"><span class="c1">// content-subtype is case-insensitive. If no such Codec is found, the call
</span></span></span><span class="line"><span class="cl"><span class="c1">// will result in an error with code codes.Internal.
</span></span></span><span class="line"><span class="cl"><span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1">// If ForceCodec is also used, that Codec will be used for all request and
</span></span></span><span class="line"><span class="cl"><span class="c1">// response messages, with the content-subtype set to the given contentSubtype
</span></span></span><span class="line"><span class="cl"><span class="c1">// here for requests.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">CallContentSubtype</span><span class="p">(</span><span class="nx">contentSubtype</span> <span class="kt">string</span><span class="p">)</span> <span class="nx">CallOption</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nx">ContentSubtypeCallOption</span><span class="p">{</span><span class="nx">ContentSubtype</span><span class="p">:</span> <span class="nx">strings</span><span class="p">.</span><span class="nf">ToLower</span><span class="p">(</span><span class="nx">contentSubtype</span><span class="p">)}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h4 id="详解-17">详解<a hidden class="anchor" aria-hidden="true" href="#详解-17">#</a></h4>
<ol>
<li>用于设置RPC调用内容的子类型（content-subtype）。这个子类型信息会被添加到通过HTTP/2协议传输的RPC请求的<code>Content-Type</code>头信息中。</li>
<li><strong>作用</strong>：
<ul>
<li><strong>内容类型定义</strong>：允许客户端定义RPC调用内容的子类型，这有助于客户端和服务器端根据内容类型选择合适的编解码器（Codec）。</li>
<li><strong>定制内容传输</strong>：通过设置不同的内容子类型，可以实现不同的内容传输格式，例如JSON、Protobuf等。</li>
</ul>
</li>
<li><strong>使用场景</strong>：
<ul>
<li><strong>协议兼容性</strong>：当客户端和服务器端使用不同的协议时，可以通过设置不同的内容子类型来保持兼容性。</li>
<li><strong>内容格式调整</strong>：在需要调整RPC调用内容格式时，可以通过设置不同的内容子类型来实现。</li>
</ul>
</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kn">package</span> <span class="nx">main</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;context&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;fmt&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;google.golang.org/grpc&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;time&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">ctx</span><span class="p">,</span> <span class="nx">cancel</span> <span class="o">:=</span> <span class="nx">context</span><span class="p">.</span><span class="nf">WithTimeout</span><span class="p">(</span><span class="nx">context</span><span class="p">.</span><span class="nf">Background</span><span class="p">(),</span> <span class="mi">5</span><span class="o">*</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">defer</span> <span class="nf">cancel</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 设置RPC调用的内容子类型为&#34;json&#34;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">opts</span> <span class="o">:=</span> <span class="p">[]</span><span class="nx">grpc</span><span class="p">.</span><span class="nx">DialOption</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">grpc</span><span class="p">.</span><span class="nf">WithDefaultCallOptions</span><span class="p">(</span><span class="nx">grpc</span><span class="p">.</span><span class="nf">CallContentSubtype</span><span class="p">(</span><span class="s">&#34;json&#34;</span><span class="p">)),</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">conn</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">grpc</span><span class="p">.</span><span class="nf">DialContext</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="s">&#34;localhost:50051&#34;</span><span class="p">,</span> <span class="nx">opts</span><span class="o">...</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;Failed to dial: %v\n&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">defer</span> <span class="nx">conn</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 客户端可以继续使用这个连接进行RPC调用
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></div><ol start="4">
<li>在这个例子中，我们创建了一个上下文，设置了5秒的超时时间。然后，我们使用<code>WithDefaultCallOptions</code>选项为通过连接发起的所有RPC调用设置默认的内容子类型为&quot;json&quot;。最后，我们使用这些选项来建立与服务器端口50051的gRPC连接。如果连接成功，客户端可以继续使用这个连接进行RPC调用。</li>
</ol>
<h3 id="forcecodeccodec">ForceCodec(codec)<a hidden class="anchor" aria-hidden="true" href="#forcecodeccodec">#</a></h3>
<ol>
<li>注意:此API是实验性的，可能会在以后的版本中更改或删除。</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// ForceCodec returns a CallOption that will set codec to be used for all
</span></span></span><span class="line"><span class="cl"><span class="c1">// request and response messages for a call. The result of calling Name() will
</span></span></span><span class="line"><span class="cl"><span class="c1">// be used as the content-subtype after converting to lowercase, unless
</span></span></span><span class="line"><span class="cl"><span class="c1">// CallContentSubtype is also used.
</span></span></span><span class="line"><span class="cl"><span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1">// See Content-Type on
</span></span></span><span class="line"><span class="cl"><span class="c1">// https://github.com/grpc/grpc/blob/master/doc/PROTOCOL-HTTP2.md#requests for
</span></span></span><span class="line"><span class="cl"><span class="c1">// more details. Also see the documentation on RegisterCodec and
</span></span></span><span class="line"><span class="cl"><span class="c1">// CallContentSubtype for more details on the interaction between Codec and
</span></span></span><span class="line"><span class="cl"><span class="c1">// content-subtype.
</span></span></span><span class="line"><span class="cl"><span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1">// This function is provided for advanced users; prefer to use only
</span></span></span><span class="line"><span class="cl"><span class="c1">// CallContentSubtype to select a registered codec instead.
</span></span></span><span class="line"><span class="cl"><span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1">// # Experimental
</span></span></span><span class="line"><span class="cl"><span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1">// Notice: This API is EXPERIMENTAL and may be changed or removed in a
</span></span></span><span class="line"><span class="cl"><span class="c1">// later release.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">ForceCodec</span><span class="p">(</span><span class="nx">codec</span> <span class="nx">encoding</span><span class="p">.</span><span class="nx">Codec</span><span class="p">)</span> <span class="nx">CallOption</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nx">ForceCodecCallOption</span><span class="p">{</span><span class="nx">Codec</span><span class="p">:</span> <span class="nx">codec</span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h4 id="详解-18">详解<a hidden class="anchor" aria-hidden="true" href="#详解-18">#</a></h4>
<ol>
<li>用于强制指定一个编解码器（Codec）用于RPC调用的所有请求和响应消息。这个编解码器会覆盖任何通过<code>CallContentSubtype</code>设置的内容子类型所选择的编解码器。</li>
<li><strong>作用</strong>：
<ul>
<li><strong>强制编解码器</strong>：允许客户端在RPC调用中强制使用指定的编解码器，而不受内容子类型的影响。</li>
<li><strong>定制消息编码</strong>：当需要自定义消息的编码方式时，可以使用这个函数来指定编解码器。</li>
</ul>
</li>
<li><strong>使用场景</strong>：
<ul>
<li><strong>协议兼容性</strong>：当客户端和服务器端使用不同的编解码器时，可以通过设置不同的编解码器来实现兼容性。</li>
<li><strong>内容格式调整</strong>：在需要调整RPC调用内容格式时，可以通过设置不同的编解码器来实现。</li>
</ul>
</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kn">package</span> <span class="nx">main</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;context&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;fmt&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;google.golang.org/grpc&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;time&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">ctx</span><span class="p">,</span> <span class="nx">cancel</span> <span class="o">:=</span> <span class="nx">context</span><span class="p">.</span><span class="nf">WithTimeout</span><span class="p">(</span><span class="nx">context</span><span class="p">.</span><span class="nf">Background</span><span class="p">(),</span> <span class="mi">5</span><span class="o">*</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">defer</span> <span class="nf">cancel</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 设置RPC调用的编解码器为JSON
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">opts</span> <span class="o">:=</span> <span class="p">[]</span><span class="nx">grpc</span><span class="p">.</span><span class="nx">DialOption</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">grpc</span><span class="p">.</span><span class="nf">WithDefaultCallOptions</span><span class="p">(</span><span class="nx">grpc</span><span class="p">.</span><span class="nf">ForceCodec</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">jsonpb</span><span class="p">.</span><span class="nx">Marshaler</span><span class="p">{})),</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">conn</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">grpc</span><span class="p">.</span><span class="nf">DialContext</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="s">&#34;localhost:50051&#34;</span><span class="p">,</span> <span class="nx">opts</span><span class="o">...</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;Failed to dial: %v\n&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">defer</span> <span class="nx">conn</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 客户端可以继续使用这个连接进行RPC调用
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></div><ol start="4">
<li>在这个例子中，我们创建了一个上下文，设置了5秒的超时时间。然后，我们使用<code>WithDefaultCallOptions</code>选项为通过连接发起的所有RPC调用设置默认的编解码器为JSON。最后，我们使用这些选项来建立与服务器端口50051的gRPC连接。如果连接成功，客户端可以继续使用这个连接进行RPC调用。</li>
</ol>
<h3 id="forcecodecv2codec">ForceCodecV2(codec)<a hidden class="anchor" aria-hidden="true" href="#forcecodecv2codec">#</a></h3>
<ol>
<li>注意:此API是实验性的，可能会在以后的版本中更改或删除。</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// ForceCodecV2 returns a CallOption that will set codec to be used for all
</span></span></span><span class="line"><span class="cl"><span class="c1">// request and response messages for a call. The result of calling Name() will
</span></span></span><span class="line"><span class="cl"><span class="c1">// be used as the content-subtype after converting to lowercase, unless
</span></span></span><span class="line"><span class="cl"><span class="c1">// CallContentSubtype is also used.
</span></span></span><span class="line"><span class="cl"><span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1">// See Content-Type on
</span></span></span><span class="line"><span class="cl"><span class="c1">// https://github.com/grpc/grpc/blob/master/doc/PROTOCOL-HTTP2.md#requests for
</span></span></span><span class="line"><span class="cl"><span class="c1">// more details. Also see the documentation on RegisterCodec and
</span></span></span><span class="line"><span class="cl"><span class="c1">// CallContentSubtype for more details on the interaction between Codec and
</span></span></span><span class="line"><span class="cl"><span class="c1">// content-subtype.
</span></span></span><span class="line"><span class="cl"><span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1">// This function is provided for advanced users; prefer to use only
</span></span></span><span class="line"><span class="cl"><span class="c1">// CallContentSubtype to select a registered codec instead.
</span></span></span><span class="line"><span class="cl"><span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1">// # Experimental
</span></span></span><span class="line"><span class="cl"><span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1">// Notice: This API is EXPERIMENTAL and may be changed or removed in a
</span></span></span><span class="line"><span class="cl"><span class="c1">// later release.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">ForceCodecV2</span><span class="p">(</span><span class="nx">codec</span> <span class="nx">encoding</span><span class="p">.</span><span class="nx">CodecV2</span><span class="p">)</span> <span class="nx">CallOption</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nx">ForceCodecV2CallOption</span><span class="p">{</span><span class="nx">CodecV2</span><span class="p">:</span> <span class="nx">codec</span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h4 id="详解-19">详解<a hidden class="anchor" aria-hidden="true" href="#详解-19">#</a></h4>
<ol>
<li>用于在gRPC v2版本中强制指定一个编解码器（Codec）用于RPC调用的所有请求和响应消息。这个编解码器会覆盖任何通过<code>CallContentSubtype</code>设置的内容子类型所选择的编解码器。</li>
<li><strong>作用</strong>：
<ul>
<li><strong>强制编解码器</strong>：允许客户端在RPC调用中强制使用指定的编解码器，而不受内容子类型的影响。</li>
<li><strong>定制消息编码</strong>：当需要自定义消息的编码方式时，可以使用这个函数来指定编解码器。</li>
</ul>
</li>
<li><strong>使用场景</strong>：
<ul>
<li><strong>协议兼容性</strong>：当客户端和服务器端使用不同的编解码器时，可以通过设置不同的编解码器来实现兼容性。</li>
<li><strong>内容格式调整</strong>：在需要调整RPC调用内容格式时，可以通过设置不同的编解码器来实现。</li>
</ul>
</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kn">package</span> <span class="nx">main</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;context&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;fmt&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;google.golang.org/grpc&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;time&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">ctx</span><span class="p">,</span> <span class="nx">cancel</span> <span class="o">:=</span> <span class="nx">context</span><span class="p">.</span><span class="nf">WithTimeout</span><span class="p">(</span><span class="nx">context</span><span class="p">.</span><span class="nf">Background</span><span class="p">(),</span> <span class="mi">5</span><span class="o">*</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">defer</span> <span class="nf">cancel</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 设置RPC调用的编解码器为JSON
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">opts</span> <span class="o">:=</span> <span class="p">[]</span><span class="nx">grpc</span><span class="p">.</span><span class="nx">DialOption</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">grpc</span><span class="p">.</span><span class="nf">WithDefaultCallOptions</span><span class="p">(</span><span class="nx">grpc</span><span class="p">.</span><span class="nf">ForceCodecV2</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">jsonpb</span><span class="p">.</span><span class="nx">Marshaler</span><span class="p">{})),</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">conn</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">grpc</span><span class="p">.</span><span class="nf">DialContext</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="s">&#34;localhost:50051&#34;</span><span class="p">,</span> <span class="nx">opts</span><span class="o">...</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;Failed to dial: %v\n&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">defer</span> <span class="nx">conn</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 客户端可以继续使用这个连接进行RPC调用
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></div><ol start="4">
<li>在这个例子中，我们创建了一个上下文，设置了5秒的超时时间。然后，我们使用<code>WithDefaultCallOptions</code>选项为通过连接发起的所有RPC调用设置默认的编解码器为JSON。最后，我们使用这些选项来建立与服务器端口50051的gRPC连接。如果连接成功，客户端可以继续使用这个连接进行RPC调用。</li>
<li>需要注意的是，<code>ForceCodecV2</code> 函数是gRPC v2版本中的一个实验性API，可能会在未来的gRPC版本中更改或移除。因此，在生产环境中使用这个函数之前，应该仔细评估其稳定性和适用性。</li>
</ol>
<h3 id="headermd">Header(md)<a hidden class="anchor" aria-hidden="true" href="#headermd">#</a></h3>
<ol>
<li>Header返回一个calllooptions，用于检索一元RPC的Header元数据。</li>
<li>在 gRPC 中，grpc.Header 是一个 grpc.CallOption，它用于在客户端接收来自服务端的响应头部元数据。响应头部元数据通常包含有关响应的额外信息，如状态码、警告或其他自定义头部字段。</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// Header returns a CallOptions that retrieves the header metadata
</span></span></span><span class="line"><span class="cl"><span class="c1">// for a unary RPC.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">Header</span><span class="p">(</span><span class="nx">md</span> <span class="o">*</span><span class="nx">metadata</span><span class="p">.</span><span class="nx">MD</span><span class="p">)</span> <span class="nx">CallOption</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nx">HeaderCallOption</span><span class="p">{</span><span class="nx">HeaderAddr</span><span class="p">:</span> <span class="nx">md</span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h4 id="使用示例">使用示例<a hidden class="anchor" aria-hidden="true" href="#使用示例">#</a></h4>
<ol>
<li>首先，你需要创建一个 metadata.MD 类型的变量来存储响应的头部元数据。</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">headerMD</span> <span class="nx">metadata</span><span class="p">.</span><span class="nx">MD</span>
</span></span></code></pre></div><ol start="2">
<li>当你发起 gRPC 调用时，将 grpc.Header 选项添加到调用选项列表中，并将你创建的 metadata.MD 容器传递给它。</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kn">import</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="s">&#34;context&#34;</span>
</span></span><span class="line"><span class="cl">    <span class="s">&#34;google.golang.org/grpc&#34;</span>
</span></span><span class="line"><span class="cl">    <span class="s">&#34;google.golang.org/grpc/metadata&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 假设 client 是一个 gRPC 客户端实例，req 是请求的结构体实例
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// resp 是响应的结构体实例，ctx 是上下文
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 在这个例子中，SomeUnaryRPC 是一个一元 gRPC 调用方法，req 是请求消息，resp 是响应消息。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// grpc.Header(&amp;headerMD) 选项告诉 gRPC 客户端在调用完成时填充 headerMD 变量。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 发起调用并使用 grpc.Header 选项
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">resp</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">client</span><span class="p">.</span><span class="nf">SomeUnaryRPC</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">req</span><span class="p">,</span> <span class="nx">grpc</span><span class="p">.</span><span class="nf">Header</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">headerMD</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 处理错误
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">log</span><span class="p">.</span><span class="nf">Fatalf</span><span class="p">(</span><span class="s">&#34;RPC failed: %v&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 检查头部元数据
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nx">headerVal</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">headerMD</span><span class="p">[</span><span class="s">&#34;header-key&#34;</span><span class="p">];</span> <span class="nx">ok</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 使用 headerVal
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">log</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;Header &#39;header-key&#39;: %v&#34;</span><span class="p">,</span> <span class="nx">headerVal</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><ol start="3">
<li>调用完成后，你可以检查 headerMD 变量来读取服务端发送的头部元数据。在上面的代码示例中，我们检查了是否存在一个名为 &ldquo;header-key&rdquo; 的头部，并打印了它的值。</li>
<li>请注意以下几点：
<ul>
<li>grpc.Header 选项仅用于获取响应头部元数据，并不影响响应的正文。</li>
<li>在一元调用中，头部元数据通常在响应正文之前发送，所以你可以在读取响应正文之前检查头部元数据。</li>
<li>如果你想要在调用结束时获取尾部元数据，可以使用 grpc.Trailer 选项。</li>
<li>在流式调用（如服务器流或客户端流）中，头部元数据同样可以通过 grpc.Header 选项在首次读取消息之前获取。</li>
</ul>
</li>
<li>使用 grpc.Header 可以帮助你在客户端处理服务端发送的额外信息，例如进行认证、日志记录或其他业务逻辑处理。</li>
</ol>
<h4 id="header-和-trailer-区别">Header 和 Trailer 区别<a hidden class="anchor" aria-hidden="true" href="#header-和-trailer-区别">#</a></h4>
<ol>
<li>在 gRPC 中，Header 和 Trailer 都用于传递元数据，但它们在 RPC 调用中的使用时机和目的有所不同：</li>
<li>Header：
<ul>
<li><strong>发送时机</strong>：Header 通常在 RPC 调用开始时发送，即在<strong>响应消息之前</strong>发送。</li>
<li><strong>内容</strong>：它们通常包含与请求相关的元数据，比如请求的身份验证信息、内容类型、压缩算法等。</li>
<li><strong>用途</strong>：Header 可以用来影响请求的处理，比如授权检查或者请求路由。</li>
<li><strong>读取时机</strong>：在服务器端，Header 可以在处理请求的任何时间点读取；在客户端，通常在发送请求后立即读取响应的 Header。</li>
</ul>
</li>
<li>Trailer：
<ul>
<li><strong>发送时机</strong>：Trailer 在 RPC 调用结束时发送，即在<strong>所有响应消息发送完毕后</strong>发送。</li>
<li><strong>内容</strong>：它们通常包含关于整个调用过程的状态信息，比如状态码、错误消息或者调用持续时间等。</li>
<li><strong>用途</strong>：Trailer 用于提供关于整个调用结果的信息，特别是如果调用失败，它们可以提供额外的错误详情。</li>
<li><strong>读取时机</strong>：在服务器端，Trailer 通常在响应发送完毕后设置；在客户端，通常在调用完成（成功或失败）后读取 Trailer。</li>
</ul>
</li>
<li>主要区别：
<ul>
<li><strong>发送时间点</strong>：Header 在调用开始时发送，而 Trailer 在调用结束时发送。</li>
<li><strong>内容类型</strong>：Header 通常包含请求相关的元数据，Trailer 则包含响应相关的元数据。</li>
<li><strong>读取时机</strong>：Header 在处理请求之前或期间读取，Trailer 在响应结束后读取。</li>
</ul>
</li>
<li>在实际应用中，Header 和 Trailer 的使用取决于特定的需求和场景。例如，如果你需要在请求被完全处理之前就提供一些信息，那么使用 Header 是合适的；如果你需要在请求处理完毕后提供状态信息，那么使用 Trailer 是更好的选择。</li>
</ol>
<h3 id="maxcallrecvmsgsizebytes">MaxCallRecvMsgSize(bytes)<a hidden class="anchor" aria-hidden="true" href="#maxcallrecvmsgsizebytes">#</a></h3>
<ol>
<li>MaxCallRecvMsgSize返回一个CallOption，它设置客户端可以接收的最大消息大小(以字节为单位)。如果没有设置，gRPC使用默认的4MB。</li>
<li>它允许你设置客户端接收消息的最大大小。这个选项可以用来覆盖 gRPC 默认的最大接收消息大小限制，这对于处理大型消息非常有用。</li>
<li>默认情况下，gRPC 限制了客户端和服务端可以发送和接收的消息大小，这个限制在 gRPC-Go 中默认设置为 4MB。如果你预期会接收到大于这个大小的消息，你可以使用 grpc.MaxCallRecvMsgSize 来增加这个限制。</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// MaxCallRecvMsgSize returns a CallOption which sets the maximum message size
</span></span></span><span class="line"><span class="cl"><span class="c1">// in bytes the client can receive. If this is not set, gRPC uses the default
</span></span></span><span class="line"><span class="cl"><span class="c1">// 4MB.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">MaxCallRecvMsgSize</span><span class="p">(</span><span class="nx">bytes</span> <span class="kt">int</span><span class="p">)</span> <span class="nx">CallOption</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nx">MaxRecvMsgSizeCallOption</span><span class="p">{</span><span class="nx">MaxRecvMsgSize</span><span class="p">:</span> <span class="nx">bytes</span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h4 id="使用示例-1">使用示例<a hidden class="anchor" aria-hidden="true" href="#使用示例-1">#</a></h4>
<ol>
<li>首先，你需要确定你希望的最大消息大小。这通常是一个整数值，表示字节数。</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">const</span> <span class="nx">maxRecvMsgSize</span> <span class="p">=</span> <span class="mi">10</span> <span class="o">*</span> <span class="mi">1024</span> <span class="o">*</span> <span class="mi">1024</span> <span class="c1">// 10 MB
</span></span></span></code></pre></div><ol start="2">
<li>在你发起 gRPC 调用时，将 grpc.MaxCallRecvMsgSize 选项添加到调用选项列表中，并传递你设定的最大消息大小。</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kn">import</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="s">&#34;context&#34;</span>
</span></span><span class="line"><span class="cl">    <span class="s">&#34;google.golang.org/grpc&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 假设 client 是一个 gRPC 客户端实例，req 是请求的结构体实例
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// resp 是响应的结构体实例，ctx 是上下文
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 在这个例子中，SomeUnaryRPC 是一个一元 gRPC 调用方法，
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 我们通过 grpc.MaxCallRecvMsgSize(maxRecvMsgSize) 选项设置了最大接收消息大小。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 发起调用并设置最大接收消息大小
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">err</span><span class="p">,</span> <span class="nx">resp</span> <span class="o">:=</span> <span class="nx">client</span><span class="p">.</span><span class="nf">SomeUnaryRPC</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">req</span><span class="p">,</span> <span class="nx">grpc</span><span class="p">.</span><span class="nf">MaxCallRecvMsgSize</span><span class="p">(</span><span class="nx">maxRecvMsgSize</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 处理错误
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">log</span><span class="p">.</span><span class="nf">Fatalf</span><span class="p">(</span><span class="s">&#34;RPC failed: %v&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></div><ol start="3">
<li>注意：
<ul>
<li>设置一个过大的 MaxCallRecvMsgSize 可能会增加客户端和服务端的内存使用，并可能导致性能问题。</li>
<li>如果你接收到一个超出设定大小的消息，gRPC 会返回一个错误，通常为 rpc error: code = ResourceExhausted desc = grpc: received message larger than max (X vs. Y)，其中 X 是接收到的消息大小，Y 是最大允许大小。</li>
<li>你也可以在创建客户端连接时全局设置最大接收消息大小，使用 grpc.WithDefaultCallOptions(grpc.MaxCallRecvMsgSize(maxRecvMsgSize)) 选项。</li>
</ul>
</li>
<li>使用 grpc.MaxCallRecvMsgSize 可以确保你的客户端能够安全地处理大型消息，而不会因为默认大小限制而失败。</li>
</ol>
<h3 id="maxcallsendmsgsizebytes">MaxCallSendMsgSize(bytes)<a hidden class="anchor" aria-hidden="true" href="#maxcallsendmsgsizebytes">#</a></h3>
<ol>
<li>MaxCallSendMsgSize返回一个CallOption，它设置客户端可以发送的最大消息大小(以字节为单位)。如果没有设置，gRPC使用默认的<code>math.MaxInt32</code>。</li>
<li>它允许你设置客户端发送消息的最大大小。这个选项可以用来覆盖 gRPC 默认的最大发送消息大小限制，这对于发送大型消息非常有用。</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// MaxCallSendMsgSize returns a CallOption which sets the maximum message size
</span></span></span><span class="line"><span class="cl"><span class="c1">// in bytes the client can send. If this is not set, gRPC uses the default
</span></span></span><span class="line"><span class="cl"><span class="c1">// `math.MaxInt32`.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">MaxCallSendMsgSize</span><span class="p">(</span><span class="nx">bytes</span> <span class="kt">int</span><span class="p">)</span> <span class="nx">CallOption</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nx">MaxSendMsgSizeCallOption</span><span class="p">{</span><span class="nx">MaxSendMsgSize</span><span class="p">:</span> <span class="nx">bytes</span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h4 id="使用示例-2">使用示例<a hidden class="anchor" aria-hidden="true" href="#使用示例-2">#</a></h4>
<ol>
<li>首先，你需要确定你希望的最大消息大小。这通常是一个整数值，表示字节数。</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">const</span> <span class="nx">maxSendMsgSize</span> <span class="p">=</span> <span class="mi">10</span> <span class="o">*</span> <span class="mi">1024</span> <span class="o">*</span> <span class="mi">1024</span> <span class="c1">// 10 MB
</span></span></span></code></pre></div><ol start="2">
<li>在你发起 gRPC 调用时，将 grpc.MaxCallSendMsgSize 选项添加到调用选项列表中，并传递你设定的最大消息大小。</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kn">import</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="s">&#34;context&#34;</span>
</span></span><span class="line"><span class="cl">    <span class="s">&#34;google.golang.org/grpc&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 假设 client 是一个 gRPC 客户端实例，req 是请求的结构体实例
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// resp 是响应的结构体实例，ctx 是上下文
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 在这个例子中，SomeUnaryRPC 是一个一元 gRPC 调用方法，
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 我们通过 grpc.MaxCallSendMsgSize(maxSendMsgSize) 选项设置了最大发送消息大小。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 发起调用并设置最大发送消息大小
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">resp</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">client</span><span class="p">.</span><span class="nf">SomeUnaryRPC</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">req</span><span class="p">,</span> <span class="nx">grpc</span><span class="p">.</span><span class="nf">MaxCallSendMsgSize</span><span class="p">(</span><span class="nx">maxSendMsgSize</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 处理错误
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">log</span><span class="p">.</span><span class="nf">Fatalf</span><span class="p">(</span><span class="s">&#34;RPC failed: %v&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></div><ol start="3">
<li>注意：
<ul>
<li>设置一个过大的 MaxCallSendMsgSize 可能会增加客户端和服务端的内存使用，并可能导致性能问题。</li>
<li>如果你发送的消息超出设定大小，gRPC 会返回一个错误，通常为 rpc error: code = ResourceExhausted desc = grpc: trying to send message larger than max (X vs. Y)，其中 X 是尝试发送的消息大小，Y 是最大允许大小。</li>
<li>你也可以在创建客户端连接时全局设置最大发送消息大小，使用 grpc.WithDefaultCallOptions(grpc.MaxCallSendMsgSize(maxSendMsgSize)) 选项。</li>
</ul>
</li>
<li>使用 grpc.MaxCallSendMsgSize 可以确保你的客户端能够安全地发送大型消息，而不会因为默认大小限制而失败。</li>
</ol>
<h3 id="maxretryrpcbuffersizebytes">MaxRetryRPCBufferSize(bytes)<a hidden class="anchor" aria-hidden="true" href="#maxretryrpcbuffersizebytes">#</a></h3>
<ol>
<li>MaxRetryRPCBufferSize返回一个CallOption，它限制了为重试目的缓冲RPC请求所使用的内容量。</li>
<li>注意:此API是实验性的，可能会在以后的版本中更改或删除。</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// MaxRetryRPCBufferSize returns a CallOption that limits the amount of memory
</span></span></span><span class="line"><span class="cl"><span class="c1">// used for buffering this RPC&#39;s requests for retry purposes.
</span></span></span><span class="line"><span class="cl"><span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1">// # Experimental
</span></span></span><span class="line"><span class="cl"><span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1">// Notice: This API is EXPERIMENTAL and may be changed or removed in a
</span></span></span><span class="line"><span class="cl"><span class="c1">// later release.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">MaxRetryRPCBufferSize</span><span class="p">(</span><span class="nx">bytes</span> <span class="kt">int</span><span class="p">)</span> <span class="nx">CallOption</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nx">MaxRetryRPCBufferSizeCallOption</span><span class="p">{</span><span class="nx">bytes</span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h4 id="详解-20">详解<a hidden class="anchor" aria-hidden="true" href="#详解-20">#</a></h4>
<ol>
<li>用于设置用于重试目的的RPC请求缓冲区的大小限制。这个选项用于控制内存的使用，特别是在需要多次重试RPC请求时。</li>
<li><strong>作用</strong>：
<ul>
<li><strong>内存控制</strong>：允许客户端控制用于重试目的的RPC请求缓冲区的大小，以防止内存耗尽。</li>
<li><strong>性能优化</strong>：通过限制缓冲区大小，可以优化客户端在重试RPC请求时的性能。</li>
</ul>
</li>
<li><strong>使用场景</strong>：
<ul>
<li><strong>高重试策略</strong>：在需要频繁重试RPC请求的场景中，可以通过设置缓冲区大小限制来避免内存问题。</li>
<li><strong>资源管理</strong>：在处理大量重试请求时，通过设置合理的缓冲区大小，可以更好地管理客户端资源。</li>
</ul>
</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kn">package</span> <span class="nx">main</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;context&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;fmt&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;google.golang.org/grpc&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;time&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">ctx</span><span class="p">,</span> <span class="nx">cancel</span> <span class="o">:=</span> <span class="nx">context</span><span class="p">.</span><span class="nf">WithTimeout</span><span class="p">(</span><span class="nx">context</span><span class="p">.</span><span class="nf">Background</span><span class="p">(),</span> <span class="mi">5</span><span class="o">*</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">defer</span> <span class="nf">cancel</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 设置RPC调用的最大重试请求缓冲区大小为1MB
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">opts</span> <span class="o">:=</span> <span class="p">[]</span><span class="nx">grpc</span><span class="p">.</span><span class="nx">DialOption</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">grpc</span><span class="p">.</span><span class="nf">WithDefaultCallOptions</span><span class="p">(</span><span class="nx">grpc</span><span class="p">.</span><span class="nf">MaxRetryRPCBufferSize</span><span class="p">(</span><span class="mi">1024</span> <span class="o">*</span> <span class="mi">1024</span><span class="p">)),</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">conn</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">grpc</span><span class="p">.</span><span class="nf">DialContext</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="s">&#34;localhost:50051&#34;</span><span class="p">,</span> <span class="nx">opts</span><span class="o">...</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;Failed to dial: %v\n&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">defer</span> <span class="nx">conn</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 客户端可以继续使用这个连接进行RPC调用
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></div><ol start="4">
<li>在这个例子中，我们创建了一个上下文，设置了5秒的超时时间。然后，我们使用<code>WithDefaultCallOptions</code>选项为通过连接发起的所有RPC调用设置默认的最大重试请求缓冲区大小为1MB。最后，我们使用这些选项来建立与服务器端口50051的gRPC连接。如果连接成功，客户端可以继续使用这个连接进行RPC调用。</li>
<li>需要注意的是，<code>MaxRetryRPCBufferSize</code> 函数是gRPC框架中的一个实验性API，可能会在未来的gRPC版本中更改或移除。因此，在生产环境中使用这个函数之前，应该仔细评估其稳定性和适用性。</li>
</ol>
<h3 id="onfinishonfinish">OnFinish(onFinish)<a hidden class="anchor" aria-hidden="true" href="#onfinishonfinish">#</a></h3>
<ol>
<li>OnFinish返回一个callloption，它配置一个回调，当调用完成时调用。传递给回调的错误是RPC的状态，可能是nil。提供的onFinish回调只会被gRPC调用一次。这主要由流拦截器使用，当RPC完成时将收到通知以及有关RPC状态的信息。</li>
<li>注意:此API是实验性的，可能会在以后的版本中更改或删除。</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// OnFinish returns a CallOption that configures a callback to be called when
</span></span></span><span class="line"><span class="cl"><span class="c1">// the call completes. The error passed to the callback is the status of the
</span></span></span><span class="line"><span class="cl"><span class="c1">// RPC, and may be nil. The onFinish callback provided will only be called once
</span></span></span><span class="line"><span class="cl"><span class="c1">// by gRPC. This is mainly used to be used by streaming interceptors, to be
</span></span></span><span class="line"><span class="cl"><span class="c1">// notified when the RPC completes along with information about the status of
</span></span></span><span class="line"><span class="cl"><span class="c1">// the RPC.
</span></span></span><span class="line"><span class="cl"><span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1">// # Experimental
</span></span></span><span class="line"><span class="cl"><span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1">// Notice: This API is EXPERIMENTAL and may be changed or removed in a
</span></span></span><span class="line"><span class="cl"><span class="c1">// later release.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">OnFinish</span><span class="p">(</span><span class="nx">onFinish</span> <span class="kd">func</span><span class="p">(</span><span class="nx">err</span> <span class="kt">error</span><span class="p">))</span> <span class="nx">CallOption</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nx">OnFinishCallOption</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">OnFinish</span><span class="p">:</span> <span class="nx">onFinish</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h4 id="详解-21">详解<a hidden class="anchor" aria-hidden="true" href="#详解-21">#</a></h4>
<ol>
<li>用于配置一个回调函数，当RPC调用完成时（无论是成功还是失败）都会被调用。这个回调函数接收一个错误参数，该错误表示RPC调用的状态，如果RPC成功完成，则该错误为nil。</li>
<li><strong>作用</strong>：
<ul>
<li><strong>状态通知</strong>：允许客户端在RPC调用完成后收到通知，以便进行相应的处理，例如清理资源、记录日志等。</li>
<li><strong>错误处理</strong>：当RPC调用失败时，客户端可以捕获错误并进行适当的错误处理。</li>
</ul>
</li>
<li><strong>使用场景</strong>：
<ul>
<li><strong>资源管理</strong>：在RPC调用完成后，客户端可以释放资源或执行其他清理操作。</li>
<li><strong>日志记录</strong>：记录RPC调用的完成状态，以便于后续分析和调试。</li>
</ul>
</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kn">package</span> <span class="nx">main</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;context&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;fmt&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;google.golang.org/grpc&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;time&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">ctx</span><span class="p">,</span> <span class="nx">cancel</span> <span class="o">:=</span> <span class="nx">context</span><span class="p">.</span><span class="nf">WithTimeout</span><span class="p">(</span><span class="nx">context</span><span class="p">.</span><span class="nf">Background</span><span class="p">(),</span> <span class="mi">5</span><span class="o">*</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">defer</span> <span class="nf">cancel</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 设置RPC调用的完成回调
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">opts</span> <span class="o">:=</span> <span class="p">[]</span><span class="nx">grpc</span><span class="p">.</span><span class="nx">DialOption</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">grpc</span><span class="p">.</span><span class="nf">WithDefaultCallOptions</span><span class="p">(</span><span class="nx">grpc</span><span class="p">.</span><span class="nf">OnFinish</span><span class="p">(</span><span class="kd">func</span><span class="p">(</span><span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;RPC failed: %v\n&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;RPC completed successfully&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="p">})),</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">conn</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">grpc</span><span class="p">.</span><span class="nf">DialContext</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="s">&#34;localhost:50051&#34;</span><span class="p">,</span> <span class="nx">opts</span><span class="o">...</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;Failed to dial: %v\n&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">defer</span> <span class="nx">conn</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 客户端可以继续使用这个连接进行RPC调用
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></div><ol start="4">
<li>在这个例子中，我们创建了一个上下文，设置了5秒的超时时间。然后，我们使用<code>WithDefaultCallOptions</code>选项为通过连接发起的所有RPC调用设置默认的完成回调。当RPC调用完成后，无论成功还是失败，都会调用这个回调函数，并打印出相应的信息。最后，我们使用这些选项来建立与服务器端口50051的gRPC连接。如果连接成功，客户端可以继续使用这个连接进行RPC调用。</li>
<li>需要注意的是，<code>OnFinish</code> 函数是gRPC框架中的一个实验性API，可能会在未来的gRPC版本中更改或移除。因此，在生产环境中使用这个函数之前，应该仔细评估其稳定性和适用性。</li>
</ol>
<h3 id="peerp">Peer（p）<a hidden class="anchor" aria-hidden="true" href="#peerp">#</a></h3>
<ol>
<li>Peer返回一个callloption，用于检索一元RPC的对等信息。在RPC完成后，peer字段将被填充。</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// Peer returns a CallOption that retrieves peer information for a unary RPC.
</span></span></span><span class="line"><span class="cl"><span class="c1">// The peer field will be populated *after* the RPC completes.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">Peer</span><span class="p">(</span><span class="nx">p</span> <span class="o">*</span><span class="nx">peer</span><span class="p">.</span><span class="nx">Peer</span><span class="p">)</span> <span class="nx">CallOption</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nx">PeerCallOption</span><span class="p">{</span><span class="nx">PeerAddr</span><span class="p">:</span> <span class="nx">p</span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h4 id="详解-22">详解<a hidden class="anchor" aria-hidden="true" href="#详解-22">#</a></h4>
<ol>
<li>用于获取与单向RPC（unary RPC）相关的对端（peer）信息。这个信息会在RPC调用完成后填充到<code>p</code>指向的<code>peer.Peer</code>结构体中。</li>
<li><strong>作用</strong>：
<ul>
<li><strong>对端信息获取</strong>：允许客户端在RPC调用完成后获取对端的信息，例如对端地址、端口、认证信息等。</li>
<li><strong>安全性检查</strong>：通过获取对端信息，客户端可以进行安全性检查，例如验证对端的身份。</li>
</ul>
</li>
<li><strong>使用场景</strong>：
<ul>
<li><strong>安全性验证</strong>：在需要验证对端身份或进行安全性检查的场景中，可以通过获取对端信息来验证。</li>
<li><strong>性能监控</strong>：在需要监控RPC调用性能的场景中，可以通过获取对端信息来分析网络延迟和带宽使用情况。</li>
</ul>
</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kn">package</span> <span class="nx">main</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;context&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;fmt&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;google.golang.org/grpc&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;time&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">ctx</span><span class="p">,</span> <span class="nx">cancel</span> <span class="o">:=</span> <span class="nx">context</span><span class="p">.</span><span class="nf">WithTimeout</span><span class="p">(</span><span class="nx">context</span><span class="p">.</span><span class="nf">Background</span><span class="p">(),</span> <span class="mi">5</span><span class="o">*</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">defer</span> <span class="nf">cancel</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 设置RPC调用的对端信息收集
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">opts</span> <span class="o">:=</span> <span class="p">[]</span><span class="nx">grpc</span><span class="p">.</span><span class="nx">DialOption</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">grpc</span><span class="p">.</span><span class="nf">WithDefaultCallOptions</span><span class="p">(</span><span class="nx">grpc</span><span class="p">.</span><span class="nf">Peer</span><span class="p">(</span><span class="nb">new</span><span class="p">(</span><span class="nx">peer</span><span class="p">.</span><span class="nx">Peer</span><span class="p">))),</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">conn</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">grpc</span><span class="p">.</span><span class="nf">DialContext</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="s">&#34;localhost:50051&#34;</span><span class="p">,</span> <span class="nx">opts</span><span class="o">...</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;Failed to dial: %v\n&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">defer</span> <span class="nx">conn</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 客户端可以继续使用这个连接进行RPC调用
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></div><ol start="4">
<li>在这个例子中，我们创建了一个上下文，设置了5秒的超时时间。然后，我们使用<code>WithDefaultCallOptions</code>选项为通过连接发起的所有RPC调用设置默认的对端信息收集。当RPC调用完成后，<code>peer.Peer</code>结构体中的信息将被填充。最后，我们使用这些选项来建立与服务器端口50051的gRPC连接。如果连接成功，客户端可以继续使用这个连接进行RPC调用。</li>
<li>需要注意的是，<code>Peer</code> 函数是gRPC框架中的一个实验性API，可能会在未来的gRPC版本中更改或移除。因此，在生产环境中使用这个函数之前，应该仔细评估其稳定性和适用性。</li>
</ol>
<h3 id="perrpccredentialscreds">PerRPCCredentials(creds)<a hidden class="anchor" aria-hidden="true" href="#perrpccredentialscreds">#</a></h3>
<ol>
<li>PerRPCCredentials 返回为调用设置 credentials.PerRPCCredentials 的 CallOption。</li>
<li>该方法可以指定方法带上指定的认证，而不是使用全局的 grpc.WithPerRPCCredentials。</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// PerRPCCredentials returns a CallOption that sets credentials.PerRPCCredentials
</span></span></span><span class="line"><span class="cl"><span class="c1">// for a call.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">PerRPCCredentials</span><span class="p">(</span><span class="nx">creds</span> <span class="nx">credentials</span><span class="p">.</span><span class="nx">PerRPCCredentials</span><span class="p">)</span> <span class="nx">CallOption</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nx">PerRPCCredsCallOption</span><span class="p">{</span><span class="nx">Creds</span><span class="p">:</span> <span class="nx">creds</span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h4 id="使用示例-3">使用示例<a hidden class="anchor" aria-hidden="true" href="#使用示例-3">#</a></h4>
<ol>
<li>全局配置 PerRPCCredentials。</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 配置ssl，&#34;*.heliu.site&#34;在实际开发中从浏览器中取获取，证书路径使用绝对路径
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">creds</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">credentials</span><span class="p">.</span><span class="nf">NewClientTLSFromFile</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">        <span class="s">&#34;/root/workspace/learn-grpc/key/test.pem&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="s">&#34;*.heliu.site&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">var</span> <span class="nx">opts</span> <span class="p">[]</span><span class="nx">grpc</span><span class="p">.</span><span class="nx">DialOption</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 不带TLS这里是grpc.WithTransportCredentials(insecure.NewCredentials())
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">opts</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">opts</span><span class="p">,</span> <span class="nx">grpc</span><span class="p">.</span><span class="nf">WithTransportCredentials</span><span class="p">(</span><span class="nx">creds</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">    <span class="nx">opts</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">opts</span><span class="p">,</span> <span class="nx">grpc</span><span class="p">.</span><span class="nf">WithPerRPCCredentials</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">ClientTokenAuth</span><span class="p">{}))</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 添加客户端拦截器
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">opts</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">opts</span><span class="p">,</span> <span class="nx">grpc</span><span class="p">.</span><span class="nf">WithUnaryInterceptor</span><span class="p">(</span><span class="nx">interceptor</span><span class="p">.</span><span class="nf">UnaryClientInterceptor</span><span class="p">()))</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 添加流拦截器
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">opts</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">opts</span><span class="p">,</span> <span class="nx">grpc</span><span class="p">.</span><span class="nf">WithStreamInterceptor</span><span class="p">(</span><span class="nx">interceptor</span><span class="p">.</span><span class="nf">StreamClientInterceptor</span><span class="p">()))</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 连接server端，使用ssl加密通信
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">conn</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">grpc</span><span class="p">.</span><span class="nf">NewClient</span><span class="p">(</span><span class="s">&#34;127.0.0.1:9090&#34;</span><span class="p">,</span> <span class="nx">opts</span><span class="o">...</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">log</span><span class="p">.</span><span class="nf">Fatalf</span><span class="p">(</span><span class="s">&#34;did not connect: %v&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">defer</span> <span class="nx">conn</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 建立连接
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">client</span> <span class="o">:=</span> <span class="nx">pb</span><span class="p">.</span><span class="nf">NewSayHelloClient</span><span class="p">(</span><span class="nx">conn</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">var</span> <span class="nx">header</span> <span class="nx">metadata</span><span class="p">.</span><span class="nx">MD</span>
</span></span><span class="line"><span class="cl">    <span class="kd">var</span> <span class="nx">tr</span> <span class="nx">metadata</span><span class="p">.</span><span class="nx">MD</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">var</span> <span class="nx">opts1</span> <span class="p">[]</span><span class="nx">grpc</span><span class="p">.</span><span class="nx">CallOption</span> <span class="p">=</span> <span class="p">[]</span><span class="nx">grpc</span><span class="p">.</span><span class="nx">CallOption</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">grpc</span><span class="p">.</span><span class="nf">WaitForReady</span><span class="p">(</span><span class="kc">false</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">        <span class="nx">grpc</span><span class="p">.</span><span class="nf">Header</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">header</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">        <span class="nx">grpc</span><span class="p">.</span><span class="nf">Trailer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">tr</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 执行rpc调用(这个方法在服务器端来实现并返回结构)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">resp</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">client</span><span class="p">.</span><span class="nf">SayHello</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">pb</span><span class="p">.</span><span class="nx">HelloRequest</span><span class="p">{</span><span class="nx">RequestName</span><span class="p">:</span> <span class="s">&#34;gh&#34;</span><span class="p">,</span> <span class="nx">Age</span><span class="p">:</span> <span class="mi">12</span><span class="p">},</span> <span class="nx">opts1</span><span class="o">...</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%v\n&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">//...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></div><ol start="2">
<li>指定方法设置。</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 配置ssl，&#34;*.heliu.site&#34;在实际开发中从浏览器中取获取，证书路径使用绝对路径
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">creds</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">credentials</span><span class="p">.</span><span class="nf">NewClientTLSFromFile</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">        <span class="s">&#34;/root/workspace/learn-grpc/key/test.pem&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="s">&#34;*.heliu.site&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">var</span> <span class="nx">opts</span> <span class="p">[]</span><span class="nx">grpc</span><span class="p">.</span><span class="nx">DialOption</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 不带TLS这里是grpc.WithTransportCredentials(insecure.NewCredentials())
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">opts</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">opts</span><span class="p">,</span> <span class="nx">grpc</span><span class="p">.</span><span class="nf">WithTransportCredentials</span><span class="p">(</span><span class="nx">creds</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//opts = append(opts, grpc.WithPerRPCCredentials(&amp;ClientTokenAuth{}))
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 添加客户端拦截器
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">opts</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">opts</span><span class="p">,</span> <span class="nx">grpc</span><span class="p">.</span><span class="nf">WithUnaryInterceptor</span><span class="p">(</span><span class="nx">interceptor</span><span class="p">.</span><span class="nf">UnaryClientInterceptor</span><span class="p">()))</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 添加流拦截器
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">opts</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">opts</span><span class="p">,</span> <span class="nx">grpc</span><span class="p">.</span><span class="nf">WithStreamInterceptor</span><span class="p">(</span><span class="nx">interceptor</span><span class="p">.</span><span class="nf">StreamClientInterceptor</span><span class="p">()))</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 连接server端，使用ssl加密通信
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">conn</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">grpc</span><span class="p">.</span><span class="nf">NewClient</span><span class="p">(</span><span class="s">&#34;127.0.0.1:9090&#34;</span><span class="p">,</span> <span class="nx">opts</span><span class="o">...</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">log</span><span class="p">.</span><span class="nf">Fatalf</span><span class="p">(</span><span class="s">&#34;did not connect: %v&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">defer</span> <span class="nx">conn</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 建立连接
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">client</span> <span class="o">:=</span> <span class="nx">pb</span><span class="p">.</span><span class="nf">NewSayHelloClient</span><span class="p">(</span><span class="nx">conn</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">var</span> <span class="nx">header</span> <span class="nx">metadata</span><span class="p">.</span><span class="nx">MD</span>
</span></span><span class="line"><span class="cl">    <span class="kd">var</span> <span class="nx">tr</span> <span class="nx">metadata</span><span class="p">.</span><span class="nx">MD</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">var</span> <span class="nx">opts1</span> <span class="p">[]</span><span class="nx">grpc</span><span class="p">.</span><span class="nx">CallOption</span> <span class="p">=</span> <span class="p">[]</span><span class="nx">grpc</span><span class="p">.</span><span class="nx">CallOption</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">grpc</span><span class="p">.</span><span class="nf">WaitForReady</span><span class="p">(</span><span class="kc">false</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">        <span class="nx">grpc</span><span class="p">.</span><span class="nf">Header</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">header</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">        <span class="nx">grpc</span><span class="p">.</span><span class="nf">Trailer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">tr</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">        <span class="nx">grpc</span><span class="p">.</span><span class="nf">PerRPCCredentials</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">ClientTokenAuth</span><span class="p">{}),</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 执行rpc调用(这个方法在服务器端来实现并返回结构)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">resp</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">client</span><span class="p">.</span><span class="nf">SayHello</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">pb</span><span class="p">.</span><span class="nx">HelloRequest</span><span class="p">{</span><span class="nx">RequestName</span><span class="p">:</span> <span class="s">&#34;gh&#34;</span><span class="p">,</span> <span class="nx">Age</span><span class="p">:</span> <span class="mi">12</span><span class="p">},</span> <span class="nx">opts1</span><span class="o">...</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%v\n&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">//...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></div><h3 id="staticmethod">StaticMethod()<a hidden class="anchor" aria-hidden="true" href="#staticmethod">#</a></h3>
<ol>
<li>StaticMethod返回一个callloption，它指定正在对静态方法进行调用，这意味着该方法在编译时是已知的，并且在运行时不会更改。这可以用作统计插件的信号，表明该方法可以安全地作为度量的关键。</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// StaticMethod returns a CallOption which specifies that a call is being made
</span></span></span><span class="line"><span class="cl"><span class="c1">// to a method that is static, which means the method is known at compile time
</span></span></span><span class="line"><span class="cl"><span class="c1">// and doesn&#39;t change at runtime. This can be used as a signal to stats plugins
</span></span></span><span class="line"><span class="cl"><span class="c1">// that this method is safe to include as a key to a measurement.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">StaticMethod</span><span class="p">()</span> <span class="nx">CallOption</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nx">StaticMethodCallOption</span><span class="p">{}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h4 id="详解-23">详解<a hidden class="anchor" aria-hidden="true" href="#详解-23">#</a></h4>
<ol>
<li><strong>作用</strong>：
<ul>
<li><strong>统计测量</strong>：允许客户端在RPC调用中指定方法是静态的，这样统计插件就可以安全地将这些方法作为统计测量（如响应时间）的键。</li>
<li><strong>性能分析</strong>：在需要分析RPC调用性能的场景中，通过指定方法是静态的，可以更准确地进行性能分析。</li>
</ul>
</li>
<li><strong>使用场景</strong>：
<ul>
<li><strong>性能监控</strong>：在需要监控RPC调用性能的场景中，通过指定方法是静态的，可以更准确地进行性能监控。</li>
<li><strong>统计插件集成</strong>：在集成统计插件时，可以通过使用<code>StaticMethod</code>来确保统计的准确性。</li>
</ul>
</li>
<li>用于指定一个RPC调用是静态方法调用。静态方法指的是在编译时已知且在运行时不会更改的方法。这个信息可以被统计插件（stats plugins）用来确定哪些方法可以安全地作为测量（measurement）的键。</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kn">package</span> <span class="nx">main</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;context&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;fmt&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;google.golang.org/grpc&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;time&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">ctx</span><span class="p">,</span> <span class="nx">cancel</span> <span class="o">:=</span> <span class="nx">context</span><span class="p">.</span><span class="nf">WithTimeout</span><span class="p">(</span><span class="nx">context</span><span class="p">.</span><span class="nf">Background</span><span class="p">(),</span> <span class="mi">5</span><span class="o">*</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">defer</span> <span class="nf">cancel</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 设置RPC调用的静态方法标志
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">opts</span> <span class="o">:=</span> <span class="p">[]</span><span class="nx">grpc</span><span class="p">.</span><span class="nx">DialOption</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">grpc</span><span class="p">.</span><span class="nf">WithDefaultCallOptions</span><span class="p">(</span><span class="nx">grpc</span><span class="p">.</span><span class="nf">StaticMethod</span><span class="p">()),</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">conn</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">grpc</span><span class="p">.</span><span class="nf">DialContext</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="s">&#34;localhost:50051&#34;</span><span class="p">,</span> <span class="nx">opts</span><span class="o">...</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;Failed to dial: %v\n&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">defer</span> <span class="nx">conn</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 客户端可以继续使用这个连接进行RPC调用
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></div><ol start="4">
<li>在这个例子中，我们创建了一个上下文，设置了5秒的超时时间。然后，我们使用<code>WithDefaultCallOptions</code>选项为通过连接发起的所有RPC调用设置默认的静态方法标志。当RPC调用完成后，统计插件可以利用这个信息来更准确地进行性能分析。最后，我们使用这些选项来建立与服务器端口50051的gRPC连接。如果连接成功，客户端可以继续使用这个连接进行RPC调用。</li>
<li>需要注意的是，<code>StaticMethod</code> 函数是gRPC框架中的一个实验性API，可能会在未来的gRPC版本中更改或移除。因此，在生产环境中使用这个函数之前，应该仔细评估其稳定性和适用性。</li>
</ol>
<h3 id="trailermd">Trailer(md)<a hidden class="anchor" aria-hidden="true" href="#trailermd">#</a></h3>
<ol>
<li>Trailer返回一个calllooptions，用于检索一元RPC的Trailer元数据。</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// Trailer returns a CallOptions that retrieves the trailer metadata
</span></span></span><span class="line"><span class="cl"><span class="c1">// for a unary RPC.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">Trailer</span><span class="p">(</span><span class="nx">md</span> <span class="o">*</span><span class="nx">metadata</span><span class="p">.</span><span class="nx">MD</span><span class="p">)</span> <span class="nx">CallOption</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nx">TrailerCallOption</span><span class="p">{</span><span class="nx">TrailerAddr</span><span class="p">:</span> <span class="nx">md</span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h4 id="详解-24">详解<a hidden class="anchor" aria-hidden="true" href="#详解-24">#</a></h4>
<ol>
<li>用于在单向RPC（unary RPC）调用完成后获取响应的尾随元数据（trailer metadata）。尾随元数据是RPC响应的元数据的一部分，它会在响应主体之后传输。</li>
<li><strong>作用</strong>：
<ul>
<li><strong>元数据获取</strong>：允许客户端在RPC调用完成后获取响应的尾随元数据，以便进行后续处理，例如日志记录、统计分析等。</li>
</ul>
</li>
<li><strong>使用场景</strong>：
<ul>
<li><strong>日志记录</strong>：在需要记录RPC调用响应的尾随元数据以进行日志记录的场景中。</li>
<li><strong>统计分析</strong>：在需要分析RPC调用响应的尾随元数据以进行统计分析的场景中。</li>
</ul>
</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kn">package</span> <span class="nx">main</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;context&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;fmt&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;google.golang.org/grpc&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;time&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">ctx</span><span class="p">,</span> <span class="nx">cancel</span> <span class="o">:=</span> <span class="nx">context</span><span class="p">.</span><span class="nf">WithTimeout</span><span class="p">(</span><span class="nx">context</span><span class="p">.</span><span class="nf">Background</span><span class="p">(),</span> <span class="mi">5</span><span class="o">*</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">defer</span> <span class="nf">cancel</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 设置RPC调用的尾随元数据获取
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">opts</span> <span class="o">:=</span> <span class="p">[]</span><span class="nx">grpc</span><span class="p">.</span><span class="nx">DialOption</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">grpc</span><span class="p">.</span><span class="nf">WithDefaultCallOptions</span><span class="p">(</span><span class="nx">grpc</span><span class="p">.</span><span class="nf">Trailer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">metadata</span><span class="p">.</span><span class="nx">MD</span><span class="p">{})),</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">conn</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">grpc</span><span class="p">.</span><span class="nf">DialContext</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="s">&#34;localhost:50051&#34;</span><span class="p">,</span> <span class="nx">opts</span><span class="o">...</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;Failed to dial: %v\n&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">defer</span> <span class="nx">conn</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 客户端可以继续使用这个连接进行RPC调用
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></div><ol start="4">
<li>在这个例子中，我们创建了一个上下文，设置了5秒的超时时间。然后，我们使用<code>WithDefaultCallOptions</code>选项为通过连接发起的所有RPC调用设置默认的尾随元数据获取。当RPC调用完成后，<code>metadata.MD</code>结构体中的元数据将被填充。最后，我们使用这些选项来建立与服务器端口50051的gRPC连接。如果连接成功，客户端可以继续使用这个连接进行RPC调用。</li>
</ol>
<h3 id="usecompressorname">UseCompressor(name)<a hidden class="anchor" aria-hidden="true" href="#usecompressorname">#</a></h3>
<ol>
<li>UseCompressor返回一个CallOption，用来设置发送请求时使用的压缩器。如果也设置了WithCompressor，则UseCompressor具有更高的优先级。</li>
<li><strong>注意</strong>：此API是实验性的，可能会在以后的版本中更改或删除。</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// UseCompressor returns a CallOption which sets the compressor used when
</span></span></span><span class="line"><span class="cl"><span class="c1">// sending the request.  If WithCompressor is also set, UseCompressor has
</span></span></span><span class="line"><span class="cl"><span class="c1">// higher priority.
</span></span></span><span class="line"><span class="cl"><span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1">// # Experimental
</span></span></span><span class="line"><span class="cl"><span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1">// Notice: This API is EXPERIMENTAL and may be changed or removed in a
</span></span></span><span class="line"><span class="cl"><span class="c1">// later release.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">UseCompressor</span><span class="p">(</span><span class="nx">name</span> <span class="kt">string</span><span class="p">)</span> <span class="nx">CallOption</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nx">CompressorCallOption</span><span class="p">{</span><span class="nx">CompressorType</span><span class="p">:</span> <span class="nx">name</span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><ol start="3">
<li>在 gRPC 中，UseCompressor 是一个客户端或服务器端的选项，它允许你指定在 gRPC 调用中使用的压缩算法。gRPC 支持多种压缩算法，例如 gzip、deflate、zlib 等。&ldquo;google.golang.org/grpc/encoding/gzip&rdquo;。</li>
<li>通常，gRPC 服务器和客户端之间的压缩是自动处理的，不需要手动干预。如果你需要使用非标准的压缩算法，你可能需要在 gRPC 的 encoding 包中实现自定义的编码器和解码器。</li>
</ol>
<h4 id="详解-25">详解<a hidden class="anchor" aria-hidden="true" href="#详解-25">#</a></h4>
<ol>
<li>用于指定在发送请求时使用的压缩器。这个选项允许客户端选择一个压缩器来压缩请求体，以减少网络传输的数据量。</li>
<li><strong>作用</strong>：
<ul>
<li><strong>压缩数据传输</strong>：允许客户端压缩发送到服务器的请求数据，以减少网络带宽的使用。</li>
<li><strong>性能优化</strong>：通过压缩数据，可以优化客户端和服务器之间的数据传输性能。</li>
</ul>
</li>
<li><strong>使用场景</strong>：
<ul>
<li><strong>带宽优化</strong>：在网络带宽有限或网络延迟较高的场景中，通过压缩数据可以优化性能。</li>
<li><strong>性能调优</strong>：在需要优化RPC调用性能的场景中，可以通过设置压缩器来优化传输效率。</li>
</ul>
</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kn">package</span> <span class="nx">main</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;context&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;fmt&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;google.golang.org/grpc&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;time&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">ctx</span><span class="p">,</span> <span class="nx">cancel</span> <span class="o">:=</span> <span class="nx">context</span><span class="p">.</span><span class="nf">WithTimeout</span><span class="p">(</span><span class="nx">context</span><span class="p">.</span><span class="nf">Background</span><span class="p">(),</span> <span class="mi">5</span><span class="o">*</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">defer</span> <span class="nf">cancel</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 设置RPC调用的压缩器为GZIP
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">opts</span> <span class="o">:=</span> <span class="p">[]</span><span class="nx">grpc</span><span class="p">.</span><span class="nx">DialOption</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">grpc</span><span class="p">.</span><span class="nf">WithDefaultCallOptions</span><span class="p">(</span><span class="nx">grpc</span><span class="p">.</span><span class="nf">UseCompressor</span><span class="p">(</span><span class="s">&#34;gzip&#34;</span><span class="p">)),</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">conn</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">grpc</span><span class="p">.</span><span class="nf">DialContext</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="s">&#34;localhost:50051&#34;</span><span class="p">,</span> <span class="nx">opts</span><span class="o">...</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;Failed to dial: %v\n&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">defer</span> <span class="nx">conn</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 客户端可以继续使用这个连接进行RPC调用
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></div><ol start="4">
<li>在这个例子中，我们创建了一个上下文，设置了5秒的超时时间。然后，我们使用<code>WithDefaultCallOptions</code>选项为通过连接发起的所有RPC调用设置默认的压缩器为GZIP。最后，我们使用这些选项来建立与服务器端口50051的gRPC连接。如果连接成功，客户端可以继续使用这个连接进行RPC调用。</li>
</ol>
<h3 id="waitforreadywaitforready">WaitForReady(waitForReady)<a hidden class="anchor" aria-hidden="true" href="#waitforreadywaitforready">#</a></h3>
<ol>
<li>WaitForReady在客户端处于TRANSIENT_FAILURE状态时配置RPC的行为，当所有地址连接失败时发生。</li>
<li>如果waitForReady为false, RPC将立即失败。否则，客户端将等待，直到连接可用或RPC的截止日期到达。</li>
<li>缺省情况下，rpc不等待准备好。</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// WaitForReady configures the RPC&#39;s behavior when the client is in
</span></span></span><span class="line"><span class="cl"><span class="c1">// TRANSIENT_FAILURE, which occurs when all addresses fail to connect.  If
</span></span></span><span class="line"><span class="cl"><span class="c1">// waitForReady is false, the RPC will fail immediately.  Otherwise, the client
</span></span></span><span class="line"><span class="cl"><span class="c1">// will wait until a connection becomes available or the RPC&#39;s deadline is
</span></span></span><span class="line"><span class="cl"><span class="c1">// reached.
</span></span></span><span class="line"><span class="cl"><span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1">// By default, RPCs do not &#34;wait for ready&#34;.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">WaitForReady</span><span class="p">(</span><span class="nx">waitForReady</span> <span class="kt">bool</span><span class="p">)</span> <span class="nx">CallOption</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nx">FailFastCallOption</span><span class="p">{</span><span class="nx">FailFast</span><span class="p">:</span> <span class="p">!</span><span class="nx">waitForReady</span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h4 id="使用示例-4">使用示例<a hidden class="anchor" aria-hidden="true" href="#使用示例-4">#</a></h4>
<ol>
<li>在 gRPC 中，WaitForReady 是一个调用选项，它控制着 RPC 在尝试建立连接时应该如何处理网络不可用或服务不可达的情况。</li>
<li>默认情况下，如果没有立即建立连接，gRPC 调用会快速失败。但是，如果你设置了 WaitForReady 选项，那么 gRPC 将会等待连接准备好再发送 RPC 请求。这在服务端可能暂时不可用或者网络状况不佳的情况下非常有用。</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kn">package</span> <span class="nx">main</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="s">&#34;context&#34;</span>
</span></span><span class="line"><span class="cl">    <span class="s">&#34;log&#34;</span>
</span></span><span class="line"><span class="cl">    <span class="s">&#34;time&#34;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="s">&#34;google.golang.org/grpc&#34;</span>
</span></span><span class="line"><span class="cl">    <span class="s">&#34;google.golang.org/grpc/codes&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 假设你有一个服务端的地址
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">serverAddr</span> <span class="o">:=</span> <span class="s">&#34;localhost:50051&#34;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 连接到 gRPC 服务器
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">conn</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">grpc</span><span class="p">.</span><span class="nf">Dial</span><span class="p">(</span><span class="nx">serverAddr</span><span class="p">,</span> <span class="nx">grpc</span><span class="p">.</span><span class="nf">WithInsecure</span><span class="p">(),</span> <span class="nx">grpc</span><span class="p">.</span><span class="nf">WithBlock</span><span class="p">())</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">log</span><span class="p">.</span><span class="nf">Fatalf</span><span class="p">(</span><span class="s">&#34;did not connect: %v&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">defer</span> <span class="nx">conn</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="nx">c</span> <span class="o">:=</span> <span class="nf">NewYourServiceClient</span><span class="p">(</span><span class="nx">conn</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 设置 context，这里使用了 context.WithTimeout 来设置超时时间
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">ctx</span><span class="p">,</span> <span class="nx">cancel</span> <span class="o">:=</span> <span class="nx">context</span><span class="p">.</span><span class="nf">WithTimeout</span><span class="p">(</span><span class="nx">context</span><span class="p">.</span><span class="nf">Background</span><span class="p">(),</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="o">*</span><span class="mi">10</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">defer</span> <span class="nf">cancel</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 使用 WaitForReady 选项
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">callOpts</span> <span class="o">:=</span> <span class="p">[]</span><span class="nx">grpc</span><span class="p">.</span><span class="nx">CallOption</span><span class="p">{</span><span class="nx">grpc</span><span class="p">.</span><span class="nf">WaitForReady</span><span class="p">(</span><span class="kc">true</span><span class="p">)}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 假设有一个叫做 YourRPCMethod 的方法
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">_</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">c</span><span class="p">.</span><span class="nf">YourRPCMethod</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">YourRequest</span><span class="p">{},</span> <span class="nx">callOpts</span><span class="o">...</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 检查错误是否由于服务不可用
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="nx">grpc</span><span class="p">.</span><span class="nf">Code</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span> <span class="o">==</span> <span class="nx">codes</span><span class="p">.</span><span class="nx">Unavailable</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nx">log</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;Server is unavailable, but we are waiting for it to be ready again&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nx">log</span><span class="p">.</span><span class="nf">Fatalf</span><span class="p">(</span><span class="s">&#34;could not call: %v&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 其他代码逻辑...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></div><ol start="3">
<li>在上面的代码中，YourServiceClient 和 YourRPCMethod 应该替换为你的具体服务客户端和方法。通过传递 grpc.WaitForReady(true) 到 YourRPCMethod，客户端会等待直到连接准备好，或者直到超时。</li>
<li>使用 WaitForReady 时需要<strong>谨慎</strong>，因为它可能会导致客户端在等待可用连接时挂起，如果服务端长时间不可用，这可能会导致客户端长时间等待。因此，通常建议与超时选项一起使用。</li>
</ol>
<h2 id="type-peer">type Peer<a hidden class="anchor" aria-hidden="true" href="#type-peer">#</a></h2>
<ol>
<li>包对等体定义了与rpc和相应的实用程序相关联的各种对等体信息。</li>
</ol>
<h3 id="newcontextctx-p">NewContext(ctx, p)<a hidden class="anchor" aria-hidden="true" href="#newcontextctx-p">#</a></h3>
<ol>
<li>NewContext 创建一个附加对等信息的 context。</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">NewContext</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">p</span> <span class="o">*</span><span class="nx">Peer</span><span class="p">)</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span>
</span></span></code></pre></div><h3 id="type-peer-1">type Peer<a hidden class="anchor" aria-hidden="true" href="#type-peer-1">#</a></h3>
<ol>
<li>Peer包含RPC的对端信息，如地址、认证信息等。</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">Peer</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Addr为对端地址。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">Addr</span> <span class="nx">net</span><span class="p">.</span><span class="nx">Addr</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// LocalAddr是本地地址。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">LocalAddr</span> <span class="nx">net</span><span class="p">.</span><span class="nx">Addr</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// AuthInfo是传输的认证信息。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 如果没有使用传输安全性，则为nil。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">AuthInfo</span> <span class="nx">credentials</span><span class="p">.</span><span class="nx">AuthInfo</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h4 id="fromcontextctx">FromContext(ctx)<a hidden class="anchor" aria-hidden="true" href="#fromcontextctx">#</a></h4>
<ol>
<li>如果对等体存在，FromContext返回ctx形式的对等体信息。</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">FromContext</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span> <span class="p">(</span><span class="nx">p</span> <span class="o">*</span><span class="nx">Peer</span><span class="p">,</span> <span class="nx">ok</span> <span class="kt">bool</span><span class="p">)</span>
</span></span></code></pre></div><h4 id="p-string">(p) String()<a hidden class="anchor" aria-hidden="true" href="#p-string">#</a></h4>
<ol>
<li>String确保Peer类型实现Stringer接口，以便有效地打印带有peerKey值的上下文。</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">p</span> <span class="o">*</span><span class="nx">Peer</span><span class="p">)</span> <span class="nf">String</span><span class="p">()</span> <span class="kt">string</span>
</span></span></code></pre></div>

  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://helium-chain.github.io/tags/grpc/">Grpc</a></li>
    </ul>
<nav class="paginav">
  <a class="prev" href="https://helium-chain.github.io/posts/grpc/grpc-server/">
    <span class="title">« 上一页</span>
    <br>
    <span>grpc.Server</span>
  </a>
  <a class="next" href="https://helium-chain.github.io/posts/tool/acme/">
    <span class="title">下一页 »</span>
    <br>
    <span>acme.sh</span>
  </a>
</nav>

  </footer>
</article>
    </main>
    
<footer class="footer">
    
    <div class="busuanzi-footer">
    <span id="busuanzi_container_site_pv">
        本站总访问量<span id="busuanzi_value_site_pv"></span>次
    </span>
    <span id="busuanzi_container_site_uv">
        本站访客数<span id="busuanzi_value_site_uv"></span>人次
    </span>
    </div>
        <span>Copyright © 2024 蜀ICP备2024091074号 <a href="#">heliu's blog</a>. All rights reserved</span>  
    
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'Copy';

        function copyingDone() {
            copybutton.innerHTML = 'Done';
            setTimeout(() => {
                copybutton.innerHTML = 'Copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
