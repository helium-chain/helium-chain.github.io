[{"content":" 本篇博客主要介绍 golang 中数组的定义及基本使用 有关数组的内存布局及元数据结构将在数组的第二篇中介绍 本片文章可能涉及到数组外的其他知识，不熟悉的请忽略，重点关注数组使用 本博客主要是作者的学习笔记，如遇到错误请指正 1. 数组的定义 🚀 数组是具有相同唯一类型的一组已编码且长度固定的数据项序列。 这是一种同构的数据结构，这种类型可以是任意的基础类型，如整型、字符串或自定义类型。 数组长度必须是一个常量表达式（编译期间能确定的值），并且是一个非负数。 数组的长度也是数组类型的一部分，[5]int和[10]int是属于不同类型。 如果想让数组元素，类型为任意类型，可以使用空接口interface{}作为类型，但使用时，必须先做一个类型判断。 访问越界，如果下标在数组合法范围之外，则触发访问越界，会panic。 数组是值类型，赋值和传参会复制整个数组，而不是指针。因此改变副本的值，不会改变本身的值。 只支持 \u0026ldquo;==\u0026quot;、\u0026rdquo;!=\u0026quot; 操作符。（不支持 \u0026ldquo;\u0026gt;\u0026quot;、\u0026quot;\u0026lt;\u0026quot;、\u0026quot;\u0026gt;=\u0026quot;、\u0026quot;\u0026lt;=\u0026quot;，原因是大于、小于对于数组来说没啥意义，我们也不会比较两个数组谁大谁小） 指针数组 [n]*T，数组指针 *[n]T。 1.1 数组元素为空接口 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;unsafe\u0026#34; ) func main() { // 数组 a 所占内存 16 * 5 = 80 字节 var a [5]interface{} = [5]interface{}{1, \u0026#34;hello\u0026#34;, false, 0.23, 2i} // 空接口的结构构造，type eface struct {typ *_type, data uintptr} fmt.Printf(\u0026#34;数组a占用内存的大小%d\\n\u0026#34;, unsafe.Sizeof(a))\t// 数组a占用内存的大小80 5*(8+8) // [5]interface {}{1, \u0026#34;hello\u0026#34;, false, 0.23, (0+2i)} fmt.Printf(\u0026#34;%#v\\n\u0026#34;, a) // 这里遍历可以改成遍历 \u0026amp;a，这样避免了大数组的复制 // 变量指针数组是Go的语法糖 for i, v := range a { // 【int, any】 fmt.Printf(\u0026#34;i:%d v:%#v t:%T\\n\u0026#34;, i , v, v) // 必须要做断言才能使用，空接口.(具体类型) if ii, ok := v.(int); ok { fmt.Println(ii + 10) } } // Output: // 数组a占用内存的大小80 // [5]interface {}{1, \u0026#34;hello\u0026#34;, false, 0.23, (0+2i)} // i:0 v:1 t:int // 11 // i:1 v:\u0026#34;hello\u0026#34; t:string // i:2 v:false t:bool // i:3 v:0.23 t:float64 // i:4 v:(0+2i) t:complex128 } 1.2 指针数组和数组指针 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 package main import \u0026#34;fmt\u0026#34; func main() { // 1. 指针数组，数组的元素是指针类型 var p1 [2]*int = [2]*int{} // [2]*int{nil, nil} fmt.Println(p1) var a int = 5 p1[1] = \u0026amp;a fmt.Println(p1) // Output: // [\u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt;] // [\u0026lt;nil\u0026gt; 0xc00000e0b8] // 2. 数组指针 var p2 *[2]int fmt.Println(p2) a1 := [2]int{1, 2} p2 = \u0026amp;a1 fmt.Printf(\u0026#34;%#v\u0026#34;, p2) // Output // \u0026lt;nil\u0026gt; // \u0026amp;[2]int{1, 2} } 1.3 数组和数组指针 在Go中数组和数组指针的用法基本一致，能遍历（range）、赋值、取值、求长度等，这是由于数组指针操作时存在语法糖支持。 切片(slice)则不允许这样操作，只有数组是特有的，为啥数组支持遍历数组地址，很大原因是大数据数组遍历的拷贝开销比较大，采用指针形式则不需要拷贝。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 { // *[5]int a1 := new([5]int) // 1) 语法糖： (*a1)[0] = 12 a1[0] = 12\t// 2) 语法糖： c := (*a1)[1] c := a1[1]\t// 3) 语法糖： l := len(*a1) l := len(a1)\t// 遍历a1，这是由于上面两个语法糖(2)(3)的支持 for i := range a1 { // 【int, int】 } } 2. 数组的声明与使用 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 // 1) 指定索引 var a = [5]string{3:\u0026#34;hello\u0026#34;, \u0026#34;world\u0026#34;} // [5]string{\u0026#34;\u0026#34;, \u0026#34;\u0026#34;, \u0026#34;\u0026#34;, \u0026#34;hello\u0026#34;, \u0026#34;world\u0026#34;} fmt.Printf(\u0026#34;%#v\\n\u0026#34;, a) // 2) ... 只能用在最外层数组 // ... 的用法 // 1. 用于数组声明的最外层数组，自动统计数组长度。 // 2. 用作函数的最后一个参数，...T 表示可变参数 []T 切片形式。 // 3. 用作切片后 []T... 表示解引用。【append([]int{1,2}, []int{3,4,5}...)】 // 4. 只有在【append([]byte(\u0026#34;hello \u0026#34;), \u0026#34;world\u0026#34;...)】时可以使用 【string...】 形式其他地方不被允许。 // slice = append(slice, elem1, elem2) // slice = append(slice, anotherSlice...) // slice = append([]byte(\u0026#34;hello \u0026#34;), \u0026#34;world\u0026#34;...) // ... 作为解引用时，只能用在Slice和string中 var b = [...]string{3:\u0026#34;hello\u0026#34;, \u0026#34;world\u0026#34;} // [5]string{\u0026#34;\u0026#34;, \u0026#34;\u0026#34;, \u0026#34;\u0026#34;, \u0026#34;hello\u0026#34;, \u0026#34;world\u0026#34;} fmt.Printf(\u0026#34;%#v\\n\u0026#34;, b) // 3) 默认值，注意不是空数组，数组不存在空数组概念，数组中一定是存在值的即使是默认值 var c [2]uint8\t// [2]uint8{0, 0} // Output: // [5]string{\u0026#34;\u0026#34;, \u0026#34;\u0026#34;, \u0026#34;\u0026#34;, \u0026#34;hello\u0026#34;, \u0026#34;world\u0026#34;} // [5]string{\u0026#34;\u0026#34;, \u0026#34;\u0026#34;, \u0026#34;\u0026#34;, \u0026#34;hello\u0026#34;, \u0026#34;world\u0026#34;} 2.1 一维数组或多维数组 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 package main import ( \u0026#34;fmt\u0026#34; ) func main() { // 1. 常用初始化 var arrAge = [5]int{15,16,15,18,17}\t// [5]int{15,16,15,18,17}\t// 2. 指定索引位置的初始化 var arrName = [5]string{3:\u0026#34;Chris\u0026#34;, 4:\u0026#34;Ron\u0026#34;}\t// [5]string{\u0026#34;\u0026#34;,\u0026#34;\u0026#34;,\u0026#34;\u0026#34;,\u0026#34;Chris\u0026#34;, \u0026#34;Ron\u0026#34;} var arrCount = [4]int{500, 2:100}\t// [4]int{500,0,100,0} // 3. 数组长度初始化根据元素多少决定 var arrLazy = [...]int{5,6,7,8,23}\t// [5]int{5,6,7,8,23}\tvar arrPack = [...]int{10,5:100}\t// [6]int{10,0,0,0,0,100} // 4. 不指定默认值 var arrRoom [20]int\t// [20]int{0,0,0,...} // 5. 使用new函数 var arrBed = new([20]int)\t// *[20]int{0,0,0,...} // 6. 数组类型是结构体 d := [...]struct{ name string\t// 占16字节 age uint8\t// 占1字节 内存对齐后 占8字节 }{ {\u0026#34;user1\u0026#34;, 10}, {\u0026#34;user2\u0026#34;, 20},\t// 别忘了最后一行的逗号，这是由于GO语法解析 } fmt.Println(unsafe.Sizeof(d))\t// 48 = (16+8) * 2 fmt.Printf(\u0026#34;arrAge:%#v arrAge:Type:%T\\n\u0026#34;, arrAge, arrAge) fmt.Printf(\u0026#34;arrName:%#v arrName:Type:%T\\n\u0026#34;, arrName, arrName) fmt.Printf(\u0026#34;arrCount:%#v arrCount:Type:%T\\n\u0026#34;, arrCount, arrCount) fmt.Printf(\u0026#34;arrLazy:%#v arrLazy:Type:%T\\n\u0026#34;, arrLazy, arrLazy) fmt.Printf(\u0026#34;arrPack:%#v arrPack:Type:%T\\n\u0026#34;, arrPack, arrPack) fmt.Printf(\u0026#34;arrRoom:%#v arrRoom:Type:%T\\n\u0026#34;, arrRoom, arrRoom) fmt.Printf(\u0026#34;arrBed:%#v arrBed:Type:%T\\n\u0026#34;, arrBed, arrBed) fmt.Printf(\u0026#34;d:%#v d:Type:%T\\n\u0026#34;, d, d) } /* * arrAge:[5]int{15, 16, 15, 18, 17} arrAge:Type:[5]int * arrName:[5]string{\u0026#34;\u0026#34;, \u0026#34;\u0026#34;, \u0026#34;\u0026#34;, \u0026#34;Chris\u0026#34;, \u0026#34;Ron\u0026#34;} arrName:Type:[5]string * arrCount:[4]int{500, 0, 100, 0} arrCount:Type:[4]int * arrLazy:[5]int{5, 6, 7, 8, 23} arrLazy:Type:[5]int * arrPack:[6]int{10, 0, 0, 0, 0, 100} arrPack:Type:[6]int * arrRoom:[20]int{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0} arrRoom:Type:[20]int * arrBed:\u0026amp;[20]int{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0} arrBed:Type:*[20]int * d: * [2]struct { name string; age uint8 } * { * struct { name string; age uint8 }{name:\u0026#34;user1\u0026#34;, age:0xa}, * struct { name string; age uint8 }{name:\u0026#34;user2\u0026#34;, age:0x14} * } * d:Type: * [2]struct { name string; age uint8 } */ Go语言中数组是一种值类型（不像C/C++中是指向首元素的指针），所以可以通过new()来创建。 // 申请 5 * 8 byte内存 var arr1 = new([5]int)\t// *[5]int 使用new([5]int)创建和var arr2 [5]int的区别，arr1的类型是 *[5]int，而arr2的类型是[5]int。 ","permalink":"http://localhost:1313/posts/golang/array/array/","summary":"数组的定义及基础使用。","title":"数组(一)"},{"content":"Golang 软件安装 首先需要下载Go语言安装包 下载地址为（中国大陆可能访问不到）：https://golang.org/dl/ 国内下载地址：https://golang.google.cn/dl/ 官方安装教程：https://golang.google.cn/doc/install，官方的安装教程已很详细（https://golang.google.cn/doc） 源码编译安装(Linux) UNIX/Linux/Mac OS和FreeBSD系统可以使用如下源码安装方法。以下示例Linux安装 Mac系统下可以使用以.pkg为扩展名的安装包直接双击来完成安装，安装目录在/usr/local/go/下。 Linux安装golang步骤 下载安装包 wget https://golang.google.cn/dl/go1.17.3.linux-amd64.tar.gz（替换你的版本） 32-bit Linux 下载安装包 https://golang.google.cn/dl/go1.17.3.linux-386.tar.gz 64-bit Linux 下载安装包 https://golang.google.cn/dl/go1.17.3.linux-amd64.tar.gz 删除老版本（如果存在则执行，不存在则忽略） rm -rf /usr/local/go 解压安装包 sudo tar -xzf go1.17.3.linux-amd64.tar.gz -C /usr/local 配置环境变量：使用go env -w命令一般只是本次生效 PATH 环境变量 export PATH=$PATH:/usr/local/go/bin GoLang工具位置，包含go、gofmt工具 GOROOT 变量 export GOROOT=/usr/local/go GoLang安装包位置 使用 go env -w GOROOT=/usr/local/go配置也是可以的 GOPATH 变量 export GOPATH=/var/local/go GoLang 1.11 版本前项目管理包位置 使用go env -w GOPATH=/var/local/go配置也是可以的 打印Go版本号 go version 如果上面(第4步)环境变量配置不成功，那么执行如下步骤配置： sudo vim ~/.bashrc命令打开文件 在文件最后添加： 1 2 3 4 5 6 7 export GOROOT=/usr/local/go export GOPATH=/var/local/go export PATH=$PATH:$GOROOT/bin:$GOPATH/bin export GOPROXY=\u0026#34;https://goproxy.cn,direct\u0026#34; # 在linux中设置临时目录，windows不用 export TMPDIR=/tmp 最后使配置生效 source ~/.bashrc Windows 安装 下载 https://golang.google.cn/dl/go1.17.3.windows-amd64.zip，直接解压到安装目录，如D:\\Go，然后把D:\\Go\\bin目录添加到PATH环境变量中。 设置GOPATH和GOROOT环境变量： GOPATH=D:\\goproject GOROOT=D:\\GO\\ 也可以选择https://golang.google.cn/dl/go1.17.3.windows-amd64.msi，双击运行程序，根据提示来操作安装。 GOROOT、GOPATH GOROOT GOROOT：Go软件的安装包绝对路径，默认是/usr/local/go GOPATH $GOPATH允许有多个目录，当有多个目录时，请注意分隔符，Windows中的分隔符是分号(;)。当有多个目录时默认将go get命令获取的包存放在第一个目录下，当在GOPATH模式下运行时是这样处理的 $GOPATH目录下约定有三个子目录： src目录：存放源代码（如.go，.c，.h，.s等文件）。按照Go默认约定，src目录是go run，go install等命令的当前工作路径（即在此路径下执行上述命令）。src也是用户代码存放的主要目录，所有的源代码都存放在这个目录下面，一般一个项目和一个目录对应。（当在GOPATH模式下运行时是这样处理的，但是Go官方在Go 1.11版本后不再推荐使用GOPATH模式编写Go代码，因此src目录无用处） pkg目录：存放编译时生成的中间文件（比如：.a） bin目录：存放编译后生成的可执行文件，比如后面安装的delve插件或多版本go软件就是在这个目录里 管理Go安装 安装多个Go版本 在同一台机器上安装多个Go版本。例如，我们可能希望在多个Go版本上测试代码。 注意：需要使用这种形式安装需要先安装git 多版本go安装步骤 要安装其他Go版本，运行go install命令，指定要安装的版本的下载位置。如下示例安装版本1.10.7： go install golang.org/dl/go1.10.7@latest 这里使用go install编译并安装指定的包来实现多版本go安裝，生成后的可执行文件在bin目录下（$GOPATH/bin） go1.10.7 download下载，需要切换到$GOPATH/bin下去执行，生成的安装路径在/root/sdk/go1.10.7 1 2 $ go install golang.org/dl/go1.10.7@latest # 安装并编译go1.10.7版本 $ go1.10.7 download 要使用新下载的版本运行命令，如下所示： 1 2 $ go1.10.7 version go version go1.10.7 linux/amd64 当你安装了多个版本时，可以使用如下命令查看每个版本的安装位置： 1 $ go1.10.7 env GOROOT 要卸载下载的版本时，只需要删除其由GOROOT环境变量和go.X.Y.Z二进制文件指定的安装目录即可 卸载Go 使用如下所描述的步骤从系统中删除Go Linux / macOS / FreeBSD 删除go目录：通常是/usr/local/go目录。 从PATH环境变量中删除Go bin目录。 在Linux和FreeBSD下，编辑/etc/profile或$HOME/.profile。 如果您使用macOS软件包安装了Go，请删除/etc/paths.d/go文件。 Windows 删除Go的最简单方法是通过Windows控制面板中的 Add/Remove 程序： 在控制面板中，双击 Add/Remove 程序。 在 Add/Remove 程序中，选择要卸载的软件，单击卸载，然后按照提示进行操作。 要使用工具删除Go，您还可以使用命令行： 通过运行以下命令使用命令行卸载：msiexec /x go{{version}}.windows-{{cpu-arch}}.msi /q 注意：对 Windows 使用此卸载过程将自动删除由原始安装创建的 Windows 环境变量。 ","permalink":"http://localhost:1313/posts/golang/install/install/","summary":"Go 软件安装。","title":"Install Golang"},{"content":"type Pool struct Pool 是一组可以单独保存和检索的临时对象。 储存在 Pool 中的任何物品都可以在任何时间自动移除，无需通知。如果在此发生时 Pool 持有唯一的引用，则可能会释放该元素。 Pool 可以被多个goroutines同时使用。 Pool's 的目的是缓存已分配但未使用的项，以便以后重用，减轻垃圾收集器的压力。也就是说，它使构建高效的、线程安全的空闲列表变得容易。但它并不适用于所有空闲链表。 Pool 的适当使用是管理一组在包的并发独立客户端之间共享和可能被重用的临时项。Pool 提供了一种在多个客户端之间摊销分配开销的方法。 一个良好使用 Pool 的例子是fmt包，它维护了一个动态大小的临时输出缓冲区存储。store在负载下扩展(当许多goroutines正在积极打印时)，在静默时收缩。 另一方面，作为生存期较短的对象的一部分维护的空闲列表不适合用于 Pool，因为在这种情况下开销不能很好地分摊。 在第一次使用后，不能复制池。 sync.Pool 是协程安全的，使用前，设置好对象的 New 函数，用在 Pool 里没有缓存的对象时，创建一个。之后在程序的任何地方、任何时候仅通过 Get() 和 Put() 方法就可以取和还对象了 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 // A Pool is a set of temporary objects that may be individually saved and // retrieved. // // Any item stored in the Pool may be removed automatically at any time without // notification. If the Pool holds the only reference when this happens, the // item might be deallocated. // // A Pool is safe for use by multiple goroutines simultaneously. // // Pool\u0026#39;s purpose is to cache allocated but unused items for later reuse, // relieving pressure on the garbage collector. That is, it makes it easy to // build efficient, thread-safe free lists. However, it is not suitable for all // free lists. // // An appropriate use of a Pool is to manage a group of temporary items // silently shared among and potentially reused by concurrent independent // clients of a package. Pool provides a way to amortize allocation overhead // across many clients. // // An example of good use of a Pool is in the fmt package, which maintains a // dynamically-sized store of temporary output buffers. The store scales under // load (when many goroutines are actively printing) and shrinks when // quiescent. // // On the other hand, a free list maintained as part of a short-lived object is // not a suitable use for a Pool, since the overhead does not amortize well in // that scenario. It is more efficient to have such objects implement their own // free list. // // A Pool must not be copied after first use. type Pool struct { // 使得内嵌了noCopy的对象在进行go vet静态检查的时候，可以检查出是否被复制 noCopy noCopy // 访问时根据P的id去访问对应下标的local[pid] // 通过这样的设计，多个goroutine使用同一个Pool时，减少了竞争，提升了性能 // local字段指向存储[P]poolloacl数组的指针，类型为[P]poolLocal // // local 是 [P]poolLocal 数组的首地址 // P 是当前P的数量，一般默认为CPU的核数 local unsafe.Pointer // local fixed-size per-P pool, actual type is [P]poolLocal // localSize 是上面 local 数组的大小 // 根据 localSize 判断是否初始化，pid为P的id改值是一个0的递增值 // 1. localSize 为0时，没有初始化 // 2. localSize \u0026lt;= pid 时，可能是没有初始化，也可能是P的数量发生了变化，变多了 localSize uintptr // size of the local array // victim 和 victimSize 作为次级缓存使用，GC时将对象放入其中，下一次GC来临之前如果有Get调用则会从p.victim中取，直到再一次GC来时回收 // 从 p.victim 中取出对象使用完毕之后并未返回 p.victim 中（而是放回p.local）中，在一定程度上也减小了下一次GC的开销 // 原来1次GC的开销被拉长到2次切会有一定程度的开销减小，这就是 p.victim 引入的意图 // victim 和 victimSize 会在一轮GC到来时，分别\u0026#34;接管\u0026#34; local 和 localSize // victim 的机制用于减少GC后冷启动导致的性能抖动，让分配对象更平滑 // sync.Pool 引入的意图在于降低GC压力的同时提高命中率 victim unsafe.Pointer // local from previous cycle 来自上一个周期的local victimSize uintptr // size of victims array\t来自上一个周期的local的大小 // New optionally specifies a function to generate // a value when Get would otherwise return nil. // It may not be changed concurrently with calls to Get. // // New可选地指定一个函数，用于在Get返回nil时生成一个值。 // 它不能在调用Get时同时改变。 New func() any\t// 我们指定的新建对象的方法 } // \u0026gt; ----------------------------------------------------------------------------------- type poolLocal struct { poolLocalInternal\t// 32 bytes // Prevents false sharing on widespread platforms with // 128 mod (cache line size) = 0 . // // 将poolLocal补齐至128字节（即两个cache line）的倍数，防止false sharing伪共享 // 仅占位用，防止在cache line上分配多个 poolLocalInternal // 确保CPU缓存机制不同，一般建议确保有128字节距离 pad [128 - unsafe.Sizeof(poolLocalInternal{})%128]byte\t// 使poolLocal总共占128字节 // CPU Cache // 现代cpu中，cache都划分成以cache line(cache block)为单位，在x86_64体系下一般都是64字节，cache line是操作的最小单元 // 程序即使只想读内存中的1个字节数据，也要同时把附近63节字加载到cache中，如果读取超个64字节，那么就要加载到多个cache line中 // 这样，访问后续63字节数据时就可以直接从cache line中读取，性能有很大提升 // false sharing // 伪共享的非标准定义为： // 缓存系统中是以缓存行（cache line）为单位存储的，当多线程修改互相独立的变量时，如果这些变量共享同一个缓存行， // 就会令整个 cache line 失效，无意中影响彼此的性能，这就是伪共享 // 如果没用pad字段时，那么当需要访问0号索引的poolLocal时，CPU同时会把0号和1号索引同时加载到cpu cache，在只修改0号索引的情况下， // 会让1号索引的poolLocal失效。这样，当其他线程想要读取1号索引时，发生cache miss，还得重新再加载，对性能有损， // 增加一个pad，补齐缓存行，让相关的字段能独立地加载到缓存行就不会出现false sharding了 } // \u0026gt; ----------------------------------------------------------------------------------- // Local per-P Pool appendix. type poolLocalInternal struct { // private只有当前P能用 private any // Can be used only by the respective P. // 其他P都可以用，当private没有时优先去当前P的local.shared中取，如果还没有就去其他P中的local.shared中窃取一个来用 shared poolChain // Local P can pushHead/popHead; any P can popTail. } Variables 全局变量 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 var ( allPoolsMu Mutex\t// 全局互斥锁 // allPools is the set of pools that have non-empty primary // caches. Protected by either 1) allPoolsMu and pinning or 2) // STW. // // allPools 是具有非空主键缓存的 pool 集合 // 受任何一方保护 1) allPoolsMu 和 pinning 2) STW // 在Get函数中，初始化时被保存在这里 allPools []*Pool\t// 保存来自用户创建的Pool实例，用户端可能创建多个Pool，比如fmt包创建的Pool也会保存在这里 // oldPools is the set of pools that may have non-empty victim // caches. Protected by STW. // // oldPools是一组可能具有非空victim caches的池。受STW保护。 // 在GC开始时，保存allPools中的值 oldPools []*Pool\t// oldPools只是保存了 allPools 的值，可见是防止被GC回收相关数据 ) type poolLocal struct 本地 Pool，对齐Cache line的倍数。 1 2 3 4 5 6 7 8 9 type poolLocal struct { poolLocalInternal // Prevents false sharing on widespread platforms with // 128 mod (cache line size) = 0 . // // 用 128 mod (cache line size) = 0 防止在广泛传播的平台上 false sharing。 pad [128 - unsafe.Sizeof(poolLocalInternal{})%128]byte } type poolLocalInternal struct 1 2 3 4 5 6 7 8 9 // Local per-P Pool appendix. type poolLocalInternal struct { // private 私有的，只能由相应的P使用。 private any // Can be used only by the respective P. // shared 共享的，local P 可以 pushHead/popHead; 任何P可以 popTail // 当当前P的private没有，那么优先从当前P的shared中取，还没有则从其他P的shared中取， // 还是没有如果New函数存在则使用该函数生成 shared poolChain // Local P can pushHead/popHead; any P can popTail. } type poolChain struct poolChain是poolDequeue的动态版本。 参看 poolqueue.go 文档。（第二篇中介绍） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // poolChain is a dynamically-sized version of poolDequeue. // // This is implemented as a doubly-linked list queue of poolDequeues // where each dequeue is double the size of the previous one. Once a // dequeue fills up, this allocates a new one and only ever pushes to // the latest dequeue. Pops happen from the other end of the list and // once a dequeue is exhausted, it gets removed from the list. type poolChain struct { // head is the poolDequeue to push to. This is only accessed // by the producer, so doesn\u0026#39;t need to be synchronized. head *poolChainElt // tail is the poolDequeue to popTail from. This is accessed // by consumers, so reads and writes must be atomic. tail *poolChainElt } Pool Methods Get() 优先从当前 P 的 local.private 中取，没有则从当前 P 的 local.shared 中取，还没有则去其他 P 中 local.shared 中窃取一个 调用者不应该认为Get的返回值和传递给Put值之间有任何关系 假如Get方法没有取得 item，如 p.New 非 nil，Get返回调用 p.New 的结果；否则返回nil 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 // Get selects an arbitrary item from the Pool, removes it from the // Pool, and returns it to the caller. // Get may choose to ignore the pool and treat it as empty. // Callers should not assume any relation between values passed to Put and // the values returned by Get. // // If Get would otherwise return nil and p.New is non-nil, Get returns // the result of calling p.New. func (p *Pool) Get() any { if race.Enabled { race.Disable() } l, pid := p.pin()\t// 返回当前工作线程所在的*poolLocal和pid x := l.private\t// 取当前private上数据 l.private = nil\t// 并清零private // 如果 local private 没有 if x == nil {\t// Try to pop the head of the local shard. We prefer // the head over the tail for temporal locality of // reuse. // // 尝试从local shard的head取出。对于重复使用一时的locality我们更喜欢head而不是tail x, _ = l.shared.popHead()\t// 尝试从shared的head弹出一个数据 if x == nil { x = p.getSlow(pid)\t// 如果上面还未空，则去其他P中偷取，或从victim cache去拿去 } } runtime_procUnpin()\t// 允许当前工作线程被抢占 if race.Enabled { race.Enable() if x != nil { race.Acquire(poolRaceAddr(x)) } } // 如果上面都没有拿到数据并且又定义了New方法调用该方法创建数据 if x == nil \u0026amp;\u0026amp; p.New != nil {\tx = p.New() } return x } pin() pin 将当前 goroutine 固定到 P，禁用抢占并为 P 和 P 的id返回 poolLocal池。 调用者在处理池时必须调用runtime_procUnpin()。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 // pin pins the current goroutine to P, disables preemption and // returns poolLocal pool for the P and the P\u0026#39;s id. // Caller must call runtime_procUnpin() when done with the pool. func (p *Pool) pin() (*poolLocal, int) { // 该函数主要作用是加锁M禁止当前M被抢占，然后返回M正绑定的P的id pid := runtime_procPin()\t// In pinSlow we store to local and then to localSize, here we load in opposite order. // Since we\u0026#39;ve disabled preemption, GC cannot happen in between. // Thus here we must observe local at least as large localSize. // We can observe a newer/larger local, it is fine (we must observe its zero-initialized-ness). // // 在pinSlow中，我们存储到local，然后存储到localSize，在这里我们按相反的顺序加载。 // 因为我们已经禁用了抢占，所以GC不能在这两者之间发生。 // 因此，这里我们必须注意local至少为large localSize。 // 我们可以观察到一个 更新/更大 的 local，这是没问题的(我们必须观察到它的零初始化)。 s := runtime_LoadAcquintptr(\u0026amp;p.localSize) // load-acquire;\t原子读取p.localSize值 l := p.local // load-consume;\t存储数据的数组地址 // uintptr(pid) \u0026gt;= s; 可能 1)没有初始化过 2)P的数量变多了 if uintptr(pid) \u0026lt; s { return indexLocal(l, pid), pid } return p.pinSlow()\t// 初始化去 } // \u0026gt; --------------------------------------------------------------------------------- // go1.19.3/src/runtime/proc.go //go:linkname sync_runtime_procPin sync.runtime_procPin //go:nosplit func sync_runtime_procPin() int { return procPin() } // \u0026gt; --------------------------------------------------------------------------------- // go1.19.3/src/runtime/proc.go //go:nosplit func procPin() int { _g_ := getg() mp := _g_.m mp.locks++ return int(mp.p.ptr().id) } // \u0026gt; --------------------------------------------------------------------------------- // go1.19.3/src/runtime/proc.go //go:linkname sync_runtime_procUnpin sync.runtime_procUnpin //go:nosplit func sync_runtime_procUnpin() { procUnpin() } // \u0026gt; --------------------------------------------------------------------------------- // go1.19.3/src/runtime/proc.go //go:nosplit func procUnpin() { _g_ := getg() _g_.m.locks-- } // \u0026gt; --------------------------------------------------------------------------------- // go1.19.3/src/sync/pool.go //go:linkname runtime_LoadAcquintptr runtime/internal/atomic.LoadAcquintptr func runtime_LoadAcquintptr(ptr *uintptr) uintptr // \u0026gt; --------------------------------------------------------------------------------- // go1.19.3/src/runtime/proc.go // l是p.local，i是pid func indexLocal(l unsafe.Pointer, i int) *poolLocal { // 获取到i下标的数据地址 lp := unsafe.Pointer(uintptr(l) + uintptr(i)*unsafe.Sizeof(poolLocal{})) return (*poolLocal)(lp) } pinSlow() pinSlow 主要是完成 pool.local 的初始化创建 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 func (p *Pool) pinSlow() (*poolLocal, int) { // Retry under the mutex. // Can not lock the mutex while pinned. runtime_procUnpin() allPoolsMu.Lock()\tdefer allPoolsMu.Unlock()\tpid := runtime_procPin()\t// poolCleanup won\u0026#39;t be called while we are pinned. s := p.localSize l := p.local // 再次检查的意义在于，可能出现此时Pool已经被初始化 if uintptr(pid) \u0026lt; s { return indexLocal(l, pid), pid } if p.local == nil { // 新初始化的Pool记录到allPools allPools = append(allPools, p)\t// allPools是存储[]*Pool切片 } // If GOMAXPROCS changes between GCs, we re-allocate the array and lose the old one. // 如果 GOMAXPROCS 在 GC 之间发生变化，我们将重新分配数组并丢失旧数组 // runtime.GOMAXPROCS 函数 参数是0或原大小值直接返回CPU中数量，其他则修改P的数量 size := runtime.GOMAXPROCS(0)\t// 返回P的总数量 local := make([]poolLocal, size)\t// 创建poolLocal类型切片，长度和容量都为size atomic.StorePointer(\u0026amp;p.local, unsafe.Pointer(\u0026amp;local[0])) // store-release runtime_StoreReluintptr(\u0026amp;p.localSize, uintptr(size)) // store-release return \u0026amp;local[pid], pid } // \u0026gt; --------------------------------------------------------------------------------- //go:linkname runtime_StoreReluintptr runtime/internal/atomic.StoreReluintptr func runtime_StoreReluintptr(ptr *uintptr, val uintptr) uintptr getSlow() 从其他 P 的 share 中去偷取元素 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 func (p *Pool) getSlow(pid int) any { // See the comment in pin regarding ordering of the loads. // 请参阅pin中关于负载排序的注释。 // 原子读取 p.localSize size := runtime_LoadAcquintptr(\u0026amp;p.localSize) // load-acquire locals := p.local // load-consume // Try to steal one element from other procs. // 尝试从其他进程中窃取一个元素。 for i := 0; i \u0026lt; int(size); i++ { // 偷取顺序从当前P的下一个P开始遍历一圈 l := indexLocal(locals, (pid+i+1)%int(size))\tif x, _ := l.shared.popTail(); x != nil { return x } } // Try the victim cache. We do this after attempting to steal // from all primary caches because we want objects in the // victim cache to age out if at all possible. // // 试试 victim cache。我们试图从所有primary caches中窃取数据后才这样做， // 因为我们希望victim cache中的对象尽可能的过期 size = atomic.LoadUintptr(\u0026amp;p.victimSize)\t// 原子读取victimSize if uintptr(pid) \u0026gt;= size { return nil } locals = p.victim l := indexLocal(locals, pid)\t// 取出pid对应Pool // 先从 private 中取 if x := l.private; x != nil { l.private = nil return x } // 从其他P的 share 中取 for i := 0; i \u0026lt; int(size); i++ { l := indexLocal(locals, (pid+i)%int(size)) if x, _ := l.shared.popTail(); x != nil { return x } } // Mark the victim cache as empty for future gets don\u0026#39;t bother // with it. // // 将 victim cache 标记为空，以便将来获取，不要费心处理它。 atomic.StoreUintptr(\u0026amp;p.victimSize, 0) return nil } indexLocal() 1 2 3 4 func indexLocal(l unsafe.Pointer, i int) *poolLocal { lp := unsafe.Pointer(uintptr(l) + uintptr(i)*unsafe.Sizeof(poolLocal{})) return (*poolLocal)(lp) } Put() Put方法将x放入 pool 中 把 x 放入池子中时，建议清除上面相关数据 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 // Put adds x to the pool. func (p *Pool) Put(x any) { if x == nil { return } if race.Enabled { if fastrandn(4) == 0 { // Randomly drop x on floor. return } race.ReleaseMerge(poolRaceAddr(x)) race.Disable() } // 获取 P 对应的 *poolLocal l, _ := p.pin() // 如果当前private为nil则把这个存储在这里，等待下次优先被使用 if l.private == nil { l.private = x x = nil } if x != nil {\t// 这种情况是private已经有数据了，则放入shared队列中 l.shared.pushHead(x) } runtime_procUnpin()\t// 允许当前工作线程被抢占，原因是pin函数里面加了锁的这里需要解锁 if race.Enabled { race.Enable() } } init() 注册 poolCleanup 函数，在GC开始时调用 对于 Pool 而言，并不能无限扩展，否则对象占用内存太多会引起内存溢出（几乎所有的池技术中都会在某个时刻清空或清除部分缓存对象。Go发生在GC时清除部分内存） 在 pool.go 文件的 init 函数里，注册GC发生时，如何清理 Pool 的函数 poolCleanup 1 2 3 4 5 6 7 8 9 10 11 12 func init() { runtime_registerPoolCleanup(poolCleanup) } // go1.19.3/src/runtime/mgc.go //go:linkname sync_runtime_registerPoolCleanup sync.runtime_registerPoolCleanup func sync_runtime_registerPoolCleanup(f func()) { poolcleanup = f } // go1.19.3/src/runtime/mgc.go var poolcleanup func() 使用示例 Pool：是一个可以分别存取的临时对象的集合 Pool：中保存的任何 item 都可能随时不做通告的释放掉 如果Pool持有该对象的唯一引用，这个 item 就可能被回收 Pool：可以安全的被多个线程同时使用 Pool：的目的是缓存申请但未使用 item 用于之后的重用，已减轻GC的压力 也就是说，让创建高效而线程安全的空闲列表更容易 但Pool并不适合用于多有空闲列表 Pool：的合理用法是用于管理一组静静的被多个独立并发线程共享并可能重用的临时 item Pool提供了让多个线程分摊内存申请消耗的方法 Pool：的一个好例子在fmt包里面 该Pool维护一个动态大小的临时输出缓存仓库 该创库会在过载（许多线程活跃的打印时）增大，在沉寂时缩小 另一方面，管理这短寿命对象的空闲列表不适合使用Pool 因为这种情况下内存申请消耗不能很好的分配 这时应该由这些对象自己实现空闲列表 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;sync\u0026#34; ) var pool *sync.Pool type Person struct { Name string } func initPool() { pool = \u0026amp;sync.Pool { New: func() interface{} { fmt.Println(\u0026#34;Creating a new Person\u0026#34;) return new(Person) }, } } func main() { initPool() // pool.Get() 返回interface{} // 然后断言 是否为 *Person p := pool.Get().(*Person) fmt.Println(\u0026#34;首次从 pool 里获取：\u0026#34;, p) p.Name = \u0026#34;first\u0026#34; fmt.Printf(\u0026#34;设置 p.Name = %s\\n\u0026#34;, p.Name) // 将p放回池中 pool.Put(p) fmt.Println(\u0026#34;Pool 里已有一个对象：\u0026amp;{first}，调用 Get：\u0026#34;, pool.Get().(*Person)) fmt.Println(\u0026#34;Pool 没有对象了，调用 Get：\u0026#34;, pool.Get().(*Person)) } Creating a new Person 首次从 pool 里获取： \u0026amp;{} 设置 p.Name = first Pool 里已有一个对象：\u0026amp;{first}，调用 Get： \u0026amp;{first} Creating a new Person Pool 没有对象了，调用 Get： \u0026amp;{} 首先，需要初始化 Pool，唯一需要的就是设置好New函数 当调用 Get 方法时，如果池子里缓存了对象，就直接返回缓存的对象 如果没有存货，则调用New函数创建一个新的对象 另外，我们发现Get方法取出来的对象和上次Put进去的对象实际上是同一个，Pool没有做任何“清空”的处理 但我们不应当对此有任何假设，因为在实际的并发使用场景中 无法保证这种顺序，最好的做法是在Put前，将对象清空 ","permalink":"http://localhost:1313/posts/golang/sync/pool/","summary":"Pool是一组可以单独保存和检索的临时对象。","title":"sync.Pool"},{"content":"type RWMutex struct 🚀 在runtime/rwmutex.go中有这个文件的修改过的副本。如果你在这里做了任何更改，看看是否应该在那里也做更改。 RWMutex 是一种 读/写 互斥锁。该锁可以由任意数量的读或单个写持有。 RWMutex 的零值是一个未锁定的互斥锁。RWMutex 在第一次使用后不能复制。 如果一个goroutine持有一个用于读取的RWMutex，而另一个goroutine可能会调用Lock， 那么任何goroutine都不应该期望能够获得一个读锁，直到初始的读锁被释放。 特别是，这禁止了递归读锁定。这是为了确保锁最终可用。被阻塞的锁调用会排除新的读取器获取锁。 RWMutex：读写互斥锁 1) 该锁可以被同时多个读取者持有或唯一写入者持有 2) RWMutex可以创建为其他结构体的字段 3) 零值为解锁状态 RWMutex 类型的锁也和线程无关，可以由不同的线程加读取锁/写入和解读取锁/写入锁 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 // There is a modified copy of this file in runtime/rwmutex.go. // If you make any changes here, see if you should make them there. // A RWMutex is a reader/writer mutual exclusion lock. // The lock can be held by an arbitrary number of readers or a single writer. // The zero value for a RWMutex is an unlocked mutex. // // A RWMutex must not be copied after first use. // // If a goroutine holds a RWMutex for reading and another goroutine might // call Lock, no goroutine should expect to be able to acquire a read lock // until the initial read lock is released. In particular, this prohibits // recursive read locking. This is to ensure that the lock eventually becomes // available; a blocked Lock call excludes new readers from acquiring the // lock. type RWMutex struct { // 1) 一把互斥锁，保护以下字段 // 所有写goroutine争抢sync.Mutex锁的goroutine都这这里排队等待 w Mutex // held if there are pending writers // 2) semaphore 读写等待池 // 获取到 sync.Mutex 锁gorutine，并等待正在运行 读goroutine 时，该写goroutine在这里等待 // 因此这里只可能是只有一个写goroutine在等待或者没有 writerSem uint32 // semaphore for writers to wait for completing readers // readerSem 记录着所有等待读的协程，当有写操作正在进行中，后面来的读操作全部排队等待在这里 // 等待正在进行中的读操作完成后释放writerSem中的写操作完成后，这里排队的读协程将被释放 readerSem uint32 // semaphore for readers to wait for completing writers // 3) 读等待数量 // readerCount 记录的所有的读goroutine数量（【正在执行的goroutine】+【等待在readerSem中的goroutine】）， // 调用RLock方法该值就会加一 // 当有写goroutine获取到sync.Mutex时，会将该值原子操作减去rwmutexMaxReaders变成负数， // 告知RLock方法有写操作在进行，goroutine去readerSem吧 readerCount int32 // number of pending readers // 在获取到Mutex后，记录当前【正在进行的读goroutine数量】，不包括存在readerSem排队的，这些读goroutine正在工作线程上运行 // 在当前写操作开始时等待正在运行全部读goroutine的数量，注意这里可以是负数 readerWait int32 // number of departing readers } const 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 // 2^30 = 1,073,741,824\t完全能满足读取的数量 const rwmutexMaxReaders = 1 \u0026lt;\u0026lt; 30\t// 最大读取数量 // Happens-before relationships are indicated to the race detector via: // - Unlock -\u0026gt; Lock: readerSem // - Unlock -\u0026gt; RLock: readerSem // - RUnlock -\u0026gt; Lock: writerSem // // The methods below temporarily disable handling of race synchronization // events in order to provide the more precise model above to the race // detector. // // For example, atomic.AddInt32 in RLock should not appear to provide // acquire-release semantics, which would incorrectly synchronize racing // readers, thus potentially missing races. // // Happens-before关系通过以下方式指示竞争检测器: // Unlock -\u0026gt; Lock: readerSem // Unlock -\u0026gt; RLock: readerSem // RUnlock -\u0026gt; Lock: writerSem // // 下面的方法暂时禁用了竞争同步事件的处理，以便为竞争检测器提供更精确的模型。 // 例如，RLock中的 atomic.AddInt32 看起来不应该提供 获取-释放语义，这将不正确地同步竞争的阅读器，从而可能错过竞争。 字段和方法描述 Lock()、Unlock() 写操作时调用的方法，如果锁已被reader或waiter持有，那么Lock方法会一直阻塞，直到能获取到锁 写操作时，如果锁被readers持有，那么将等待所有的reader解锁，返回写操作获得锁，这期间还有来的reader全部去排队等待，等待写操作解锁写操作解锁期间先把等待在排队的全部释放出来，然后再去解锁互斥锁。在互斥锁解锁小段时间来的读操作直接获取锁不需要去排队，互斥锁解锁后才允许排队的写操作或正在来的写操作去争抢互斥写锁 写操作时，如果锁已被waiter持有，那么当前写操作等待在RWRutex.w.seam信号量中，等待前面一个写锁完成，此时来的读操作全部阻塞起，已经在进行的读操作正常进行 Unlock方法是配对的释放锁的方法 RLock()、RUnlock() 读操作时调用的方法，如果锁已经被writer持有的话，RLock方法会一直阻塞，直到能获取到锁，否则就直接返回 读操作时没有waiter持有锁情况，直接记录readerCount加一，返回就返回，表示获取到锁 读操作时存在waiter持有锁情况，则当前读操作排队在readerSem，等待当前写完成 而RUnlock是reader释放锁的方法 RLocker() 这个方法的作用是为读操作返回一个Locker接口的对象，它的Lock方法会调用RWMutex的RLock方法，它的Unlock方法会调用RWMutex的RUnlock方法 Lock() Lock 锁定 rw 用于写入。 如果锁已经锁定用于读或写，那么锁将阻塞，直到锁可用为止。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 // Lock locks rw for writing. // If the lock is already locked for reading or writing, // Lock blocks until the lock is available. func (rw *RWMutex) Lock() { if race.Enabled { _ = rw.w.state race.Disable() } // 1) 尝试获取 sync.Mutex 锁 // First, resolve competition with other writers. // // 首先，解决与其他 writers 的竞争。 // 如果存在多个写gorutine的都在调用Lock竞争锁，这里需要先去竞争锁 rw.w.Lock()\t// sync.Mutex // 2) 原子修改readerCount值，告诉后面读goroutine调用Rlock函数需要去readerSem中挂起 // 由于刚获取到锁，因此此时只存在正在运行读goroutine和等待在writerSem中写goroutine，不存在等待在readerSem中的goroutine // 因此 readerCount 存储的是正在运行读goroutine，在下面这行原子操作执行前都认为读goroutine是不需要挂起的 // Announce to readers there is a pending writer. // // 通过把rw.readerCount设置成一个负数，来告知其他读goroutine当前有写的goroutine正在等待进入临界区 // atomic.AddInt32(\u0026amp;rw.readerCount, -rwmutexMaxReaders); 告诉后面来的读操作去排队等待，你们应该在本次写操作完后再去读取数据 // 由于当前刚获取到 Mutex,所以这里的 r 应该表示当前正在运行的读goroutine的数量，不包含被挂起的 goroutine r := atomic.AddInt32(\u0026amp;rw.readerCount, -rwmutexMaxReaders) + rwmutexMaxReaders\t// 原子操作表示当前有写的协程来了 // 在上面这行原子操作执行后，都有来的读goroutine在调用RLock方法时，都会被挂起在readerSem中 // 因此 r 是所有正在运行读goroutine的数量 // 上面的原子操作与RLock函数的原子操作形成一对临界区域互斥 // Wait for active readers. // // 1. r != 0：存在正在运行的读goroutine // 2. atomic.AddInt32(\u0026amp;rw.readerWait, r) != 0：继续判断这段时间呢这些读goroutine是否全部读取完， // 没有读取完这里需要把当前写goroutine挂起在writerSem // 这里的原子操作与RUlock函数的 \u0026#34;atomic.AddInt32(\u0026amp;rw.readerWait, -1) == 0\u0026#34; 形成临界区域互斥 if r != 0 \u0026amp;\u0026amp; atomic.AddInt32(\u0026amp;rw.readerWait, r) != 0 {\t// readerWait记录着正在运行中，还没有调用RUnlock的goroutine // 存在需要等待读的协程，把当前协程加入writerSem写信息池 // false：这里加入的是尾部，由于writerSem只可能存一个写goroutine runtime_SemacquireMutex(\u0026amp;rw.writerSem, false, 0)\t} if race.Enabled { race.Enable() race.Acquire(unsafe.Pointer(\u0026amp;rw.readerSem)) race.Acquire(unsafe.Pointer(\u0026amp;rw.writerSem)) } } Unlock() Unlock 方法解除rw的写入锁状态。 如果 rw 在进入解锁时没有锁定写入，这是一个运行时错误。 与 Mutexes 一样，一个被锁的 RWMutex 与一个特定的 goroutine 无关。 一个 goroutine 可以 RLock(锁定)一个 RWMutex，然后安排另一个 goroutine 运行 RUnlock(解锁)它。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 // Unlock unlocks rw for writing. It is a run-time error if rw is // not locked for writing on entry to Unlock. // // As with Mutexes, a locked RWMutex is not associated with a particular // goroutine. One goroutine may RLock (Lock) a RWMutex and then // arrange for another goroutine to RUnlock (Unlock) it. func (rw *RWMutex) Unlock() { if race.Enabled { _ = rw.w.state race.Release(unsafe.Pointer(\u0026amp;rw.readerSem)) race.Disable() } // 1) 当Unlock方法被调用，也就说明数据的相关写操作已经完成了，此时其他来读的goroutine可以正常读取新数据 // Announce to readers there is no active writer. // // 告诉所有RLock的协程，没有正在写的锁，此时来读的协程不必等待直接可以读取到数据 // 因为程序调用了Unlock方法代表我们前面以把数据更新了，此时在信号量中等待读的协程和此时后面来读的协程都可以安全读取数据了 // 这里与RLock函数的 \u0026#34;atomic.AddInt32(\u0026amp;rw.readerCount, 1) \u0026lt; 0\u0026#34; 形成临界区互斥 r := atomic.AddInt32(\u0026amp;rw.readerCount, rwmutexMaxReaders)\t// 这里的r全都是等待在信号量的数量 // 没有调用Lock方法，而是直接调用Unlock方法这里会报错 if r \u0026gt;= rwmutexMaxReaders { race.Enable() throw(\u0026#34;sync: Unlock of unlocked RWMutex\u0026#34;) } // Unblock blocked readers, if any. // // 释放掉等待在信号量的协程，注意这里是释放完了才把互斥锁解锁的才允许其他写操作进行 // 因为前面的数据已经更新了，所以这里需要把在信号量中的协程全部放在P本地队列或全局队列中等待调度器调度去来运行 // 这里也是为什么其他写goroutine获取到Mutex锁时，不存在等待在readerSem上的读goroutine的原因，因为Mutex解锁在后面一步 for i := 0; i \u0026lt; int(r); i++ { runtime_Semrelease(\u0026amp;rw.readerSem, false, 0)\t// 取出等待在readerSem的写goroutine } // Allow other writers to proceed. // // 允许其他 writers 继续 rw.w.Unlock()\t// sync.Mutex if race.Enabled { race.Enable() } } TryLock() TryLock 试图锁定 rw 进行写入，并报告是否成功。 请注意，虽然确实存在正确使用 TryLock 的情况，但很少，而且 TryLock 的使用通常表明互斥量的特定使用中存在更深层的问题。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 // TryLock tries to lock rw for writing and reports whether it succeeded. // // Note that while correct uses of TryLock do exist, they are rare, // and use of TryLock is often a sign of a deeper problem // in a particular use of mutexes. func (rw *RWMutex) TryLock() bool { if race.Enabled { _ = rw.w.state race.Disable() } // 尝试获取Mutex锁 if !rw.w.TryLock() { if race.Enabled { race.Enable() } return false } // 原子交换 readerCount 由 0 -\u0026gt; -rwmutexMaxReaders // 可见只有在没有读goroutine的时候，TryLock函数才会返回成功 if !atomic.CompareAndSwapInt32(\u0026amp;rw.readerCount, 0, -rwmutexMaxReaders) { // 存在其他正在读写协程 rw.w.Unlock()\t// 解锁互斥锁 if race.Enabled { race.Enable() } return false } if race.Enabled { race.Enable() race.Acquire(unsafe.Pointer(\u0026amp;rw.readerSem)) race.Acquire(unsafe.Pointer(\u0026amp;rw.writerSem)) } return true } RLock() RLock设置rw读锁。 它不应该用于递归的读锁定;被阻塞的锁调用会排除新的读取器获取锁。请参阅RWMutex类型的文档。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 // RLock locks rw for reading. // // It should not be used for recursive read locking; a blocked Lock // call excludes new readers from acquiring the lock. See the // documentation on the RWMutex type. func (rw *RWMutex) RLock() { if race.Enabled { _ = rw.w.state race.Disable() } // 把rw.readerCount加一，如果该值小于0，说明存在其他goroutine正在写操作，也就是前面的Lock方法 // 这里也表明了readerCount字段是记录所有写goroutine的数量 if atomic.AddInt32(\u0026amp;rw.readerCount, 1) \u0026lt; 0 { // A writer is pending, wait for it. // // 一个写锁正在继续，等待它完成 runtime_SemacquireMutex(\u0026amp;rw.readerSem, false, 0)\t// 将当前读goroutine挂在readerSem上 } if race.Enabled { race.Enable() race.Acquire(unsafe.Pointer(\u0026amp;rw.readerSem)) } } RUnlock() RUnlock 解除一个 RLock 调用。 它不会影响其他同时阅读的读者。 如果rw在进入RUnlock时没有锁定读取，则是一个运行时错误。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 // RUnlock undoes a single RLock call; // it does not affect other simultaneous readers. // It is a run-time error if rw is not locked for reading // on entry to RUnlock. func (rw *RWMutex) RUnlock() { if race.Enabled { _ = rw.w.state race.ReleaseMerge(unsafe.Pointer(\u0026amp;rw.writerSem)) race.Disable() } // 把前面读加锁减一，如果r小于0，说明正在进行写操作中 // 这里也有一种可能是没有存在写操作中又没有调用Rlock函数调用了RUnlock函数导致总有一个goroutine这里rw.readerCount=-1 if r := atomic.AddInt32(\u0026amp;rw.readerCount, -1); r \u0026lt; 0 { // Outlined slow-path to allow the fast-path to be inlined // // 有存在写在进行，因此需要判断当前是否需要取出该写goroutine // 原因是可能存在读goroutine在运行中，该写goroutine在writerSem中等待 rw.rUnlockSlow(r)\t} if race.Enabled { race.Enable() } } rUnlockSlow() 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 func (rw *RWMutex) rUnlockSlow(r int32) { // 判断没有调用RLock函数调用RUnlock函数报错 // 1. r+1 == -rwmutexMaxReaders =\u0026gt; r + rwmutexMaxReaders == 1 // 2. r+1 == 0，就是判断上面没有调用RLock函数调用RUnlock函数时情况 if r+1 == 0 || r+1 == -rwmutexMaxReaders { race.Enable() throw(\u0026#34;sync: RUnlock of unlocked RWMutex\u0026#34;) } // A writer is pending. // // rw.readerWait 记录着当前正在运行的goroutine没在信号池的数量，这里判断是否已经是最后一个 // 这里的原子操作和Lock函数中的 \u0026#34;atomic.AddInt32(\u0026amp;rw.readerWait, r) != 0\u0026#34; 形成临界区互斥 if atomic.AddInt32(\u0026amp;rw.readerWait, -1) == 0 {\t// 如果是最后一个，把等待写的goroutine取出 // The last reader unblocks the writer. runtime_Semrelease(\u0026amp;rw.writerSem, false, 1)\t// 从writerSem中取出等待在这里的读goroutine } } TryRLock() 尝试获取读锁，该方法只要不存在写协程都会获取读锁成功。 TryRLock 试图锁定 rw 以进行读取，并报告是否成功。 请注意，虽然确实存在对 TryRLock 的正确使用，但很少，而且 TryRLock 的使用通常表明互斥量的特定使用中存在更深层的问题。 该方法在没有写操作的情况下是一定能拿去到锁的。存在写操作时才会返回 false。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 // TryRLock tries to lock rw for reading and reports whether it succeeded. // // Note that while correct uses of TryRLock do exist, they are rare, // and use of TryRLock is often a sign of a deeper problem // in a particular use of mutexes. func (rw *RWMutex) TryRLock() bool { if race.Enabled { _ = rw.w.state race.Disable() } // TryRLock 函数获取到读锁只能发生在 readerCount \u0026gt;= 0 状态下 for { c := atomic.LoadInt32(\u0026amp;rw.readerCount)\t// 原子读取 readerCount if c \u0026lt; 0 { // 写操作在进行中或者在等待读完成。 if race.Enabled { race.Enable() } return false } // 尝试原子交换 readerCount 值 // 如果交换失败可能有其他读操作或写操作发生，再次循环。 if atomic.CompareAndSwapInt32(\u0026amp;rw.readerCount, c, c+1) { if race.Enabled { race.Enable() race.Acquire(unsafe.Pointer(\u0026amp;rw.readerSem)) } return true\t// 获取到锁后 } } } RLocker() RLocker 返回一个 Locker 接口，通过调用 rw 实现 Lock 和 Unlock 方法。RLock 和 rw.RUnlock。 意义在于返回接口Locker限制只能调用接口的，比如 sync.Cond 中需要的锁 1 2 3 4 5 // RLocker returns a Locker interface that implements // the Lock and Unlock methods by calling rw.RLock and rw.RUnlock. func (rw *RWMutex) RLocker() Locker { return (*rlocker)(rw) } type Locker interface Locker接口代表一个可以加锁和解锁的对象。 该接口定义在sync/mutex.go文件中。 1 2 3 4 type Locker interface { Lock() Unlock() } type rlocker RWMutex 1 type rlocker RWMutex\t// sync.RWMutex Lock() 1 2 3 4 5 6 func (r *rlocker) Lock() { // 因为 rlocker 和 RWMutex是两个类型，虽然底层一样 // 但是 rlocker 只支持 Lock() 和 Unlock() 方法 // 需要转换成 (*RWMutex) 才能调用 RLock() 方法。 (*RWMutex)(r).RLock() } Unlock() 1 2 3 func (r *rlocker) Unlock() { (*RWMutex)(r).RUnlock() } 使用示例 读写锁：是多读单写互斥锁，分别针对读操作和写操作进行锁定和解锁操作 经常用于读次数远远多于写次数的场合 在Go语言中，读写锁由结构体类型 sync.RWMutex 实现 基本遵守原则： 写锁定情况下，对读写锁定进行读锁定或写锁定，都将阻塞，而且读锁与写锁之间是互斥的 读锁定情况下，对读写锁进行写锁定，将阻塞 加读锁时不会阻塞，即可多读 对未被写锁定的读写锁进行写解锁，会引发运行时异常 对未被读读锁定的读写锁进行读解锁时也会引发运行时异常 写解锁在进行的同时会试图唤醒所有因进行读锁定而被阻塞的协程 读解锁在进行的时候则会试图唤醒一个因进行写锁定而被阻塞的协程 与互斥锁类型，sync.RWMutex 类型的零值就已经是立即可用的读写锁了 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;sync\u0026#34; \u0026#34;time\u0026#34; ) var m *sync.RWMutex func main() { wg := sync.WaitGroup{} wg.Add(20) var rwMutex sync.RWMutex Data := 0 for i := 0; i \u0026lt; 10; i++ { go func(t int) { rwMutex.RLock()\t// 读加锁 defer rwMutex.RUnlock()\t// 读解锁 fmt.Printf(\u0026#34;读数据：%v %d\\n\u0026#34;, Data, i) wg.Done() time.Sleep(1 * time.Second) // 这句代码第一次运行后，读解锁 // 循环到第二个时， 读锁定后，这个goroutine就没有阻塞，同时读成功 }(i) go func(t int) { rwMutex.Lock()\t// 写加锁 defer rwMutex.Unlock()\t// 写解锁 Data += 1 fmt.Printf(\u0026#34;写数据：%v %d\\n\u0026#34;, Data, t) wg.Done() // 对读写锁进行读锁定或者写锁定，都将阻塞 // 写锁定下是需要解锁后才能写的 time.Sleep(5 * time.Second) }(i) } wg.Wait() } 读数据：0 3 写数据：1 2 读数据：1 10 读数据：1 10 读数据：1 10 读数据：1 10 读数据：1 10 读数据：1 10 读数据：1 10 读数据：1 10 读数据：1 10 写数据：2 1 写数据：3 3 写数据：4 4 写数据：5 5 写数据：6 6 写数据：7 0 写数据：8 9 写数据：9 7 写数据：10 8 通过程序运行的输出可以看到，在写锁定情况下，对读写锁进行锁定或者写锁定，都将阻塞 把写数据中的Sleep设置更长时间，在第一次写锁定后，读数据也没有进行 再次写锁定是在 rwMutex.Unlock() 完成后，才能进行 rwMutex.lock() 而读数据时则可以多次读，不一定需要等 rwMutex.RUnlock() 完成 ","permalink":"http://localhost:1313/posts/golang/sync/rwmutex/","summary":"RWMutex是一种读写互斥锁。","title":"sync.RwMutex"},{"content":"type Once struct 🚀 Once是只执行一次动作的对象，应用场景，比如加载配置文件只需要加载一次。 首次使用Once后，不能复制Once。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 // Once is an object that will perform exactly one action. // // A Once must not be copied after first use. type Once struct { // done indicates whether the action has been performed. // It is first in the struct because it is used in the hot path. // The hot path is inlined at every call site. // Placing done first allows more compact instructions on some architectures (amd64/386), // and fewer instructions (to calculate offset) on other architectures. // // done 表示操作是否已经执行。 // 它在结构体中位于首位，因为它在 hot path 中使用。 // hot path 内联在每个调用点。 // 在某些体系结构上(amd64/386)，将done放在第一位可以让指令更紧凑，而在其他体系结构上可以让指令更少(用于计算偏移量)。 done uint32\t// 0.未被调用过 1.已被调用过 m Mutex\t// 互斥锁 } // 其中解释了为什么将 done 置为 Once 的第一个字段：done 在热路径中，done 放在第一个字段，能够减少 CPU 指令，也就是说，这样做能够提升性能。 // 1. 热路径(hot path)是程序非常频繁执行的一系列指令，sync.Once 绝大部分场景都会访问 o.done，在热路径上是比较好理解的， //\t如果 hot path 编译后的机器码指令更少，更直接，必然是能够提升性能的。 // 2. 为什么放在第一个字段就能够减少指令呢？因为结构体第一个字段的地址和结构体的指针是相同的，如果是第一个字段，直接对结构体的指针解引用即可。 // 如果是其他的字段，除了结构体指针外，还需要计算与第一个值的偏移(calculate offset)。在机器码中，偏移量是随指令传递的附加值， // CPU 需要做一次偏移值与指针的加法运算，才能获取要访问的值的地址。因为，访问第一个字段的机器代码更紧凑，速度更快。 Do() 当且仅当 Do 是第一次为 Once 实例调用函数 f 时，Do 才会调用函数 f。 换句话说，给定var once Once，如果 once.Do(f) 被多次调用，只有第一次调用会调用f，即使每次调用 f 的值不同。 每个函数执行时都需要一个 Once 的新实例。 Do 用于必须只运行一次的初始化。 由于 f 是 niladic，因此可能需要使用函数字面量来捕获Do调用的函数的参数:config.once.Do(func() { config.init(filename) }) niladic：被解释为不带参数的闭包函数。 因为只有在对 f 的调用返回之前，才会返回对 Do 的调用，如果 f 导致Do被调用，它就会死锁。（f函数内不能在调用外层的Do函数） 如果f发生panic，Do认为它回来了;Do的后续调用不需要调用f。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 // Do calls the function f if and only if Do is being called for the // first time for this instance of Once. In other words, given // var once Once // if once.Do(f) is called multiple times, only the first call will invoke f, // even if f has a different value in each invocation. A new instance of // Once is required for each function to execute. // // Do is intended for initialization that must be run exactly once. Since f // is niladic, it may be necessary to use a function literal to capture the // arguments to a function to be invoked by Do: // config.once.Do(func() { config.init(filename) }) // // Because no call to Do returns until the one call to f returns, if f causes // Do to be called, it will deadlock. // // If f panics, Do considers it to have returned; future calls of Do return // without calling f. func (o *Once) Do(f func()) { // Note: Here is an incorrect implementation of Do: // //\tif atomic.CompareAndSwapUint32(\u0026amp;o.done, 0, 1) { //\tf() //\t} // // Do guarantees that when it returns, f has finished. // This implementation would not implement that guarantee: // given two simultaneous calls, the winner of the cas would // call f, and the second would return immediately, without // waiting for the first\u0026#39;s call to f to complete. // This is why the slow path falls back to a mutex, and why // the atomic.StoreUint32 must be delayed until after f returns. // // 注意:下面是一个不正确的Do实现。 // 以下形式不能保证Do函数返回时f函数已执行完，因为我们是先标记后执行f的。 // if atomic.CompareAndSwapUint32(\u0026amp;o.done, 0, 1) { // f() // } // // Do 保证当它返回时，f 已经完成 // 这种实现不会实现这种保证:给定两个同时调用，cas的赢家将调用f，而第二个将立即返回，而无需等待第一个调用完成。 // 这就是慢路径回退到互斥量的原因，也是原子性的原因。StoreUint32必须延迟到f返回之后。 // 后续大部分情况会从这里判断失败 if atomic.LoadUint32(\u0026amp;o.done) == 0 { // Outlined slow-path to allow inlining of the fast-path. o.doSlow(f) } } doSlow() 1 2 3 4 5 6 7 8 9 10 11 12 func (o *Once) doSlow(f func()) { o.m.Lock() // 获取锁 defer o.m.Unlock() // 延迟释放锁 // 当出现并发时，这里会拦住等待着的协程 if o.done == 0 {\t// 在f()执行完后才会标记done为1。 defer atomic.StoreUint32(\u0026amp;o.done, 1) // 需要保证f函数不会发生panic // 如果发生panic，则o.done会被标记为1，后续不会在调用f函数 f() } } 使用场景 sync.Once 是 Go 标准库提供的使函数只执行一次的实现。 常应用于【单例模式】，例如【初始化配置】、【保持数据库连接】等。作用与 init 函数类似，但有区别。 init 函数是当所在的 package 首次被加载时执行，若迟迟未被使用，则既浪费了内存，又延长了程序加载时间。 sync.Once 可以在代码的任意位置初始化和调用，因此可以延迟到使用时再执行，并发场景下是线程安全的。 在多数情况下，sync.Once 被用于控制变量的初始化，这个变量的读写满足如下三个条件： 当且仅当第一次访问某个变量时，进行初始化（写）。 变量初始化过程中，所有读都被阻塞，直到初始化完成。 变量仅初始化一次，初始化完成后驻留在内存里。 sync.Once 仅提供了一个方法 Do，参数 f 是对象初始化函数。 func (o *Once) Do(f func())。 使用示例 简单的示例 考虑一个简单的场景，函数 ReadConfig 需要读取环境变量，并转换为对应的配置。 环境变量在程序执行前已经确定，执行过程中不会发生改变。 ReadConfig 可能会被多个协程并发调用，为了提升性能（减少执行时间和内存占用），使用 sync.Once 是一个比较好的方式。 在这个例子中，声明了 2 个全局变量，once 和 config。 config 是需要在 ReadConfig 函数中初始化的(将环境变量转换为 Config 结构体)，ReadConfig 可能会被并发调用。 如果 ReadConfig 每次都构造出一个新的 Config 结构体，既浪费内存，又浪费初始化时间。 如果 ReadConfig 中不加锁，初始化全局变量 config 就可能出现并发冲突。 这种情况下，使用 sync.Once 既能够保证全局变量初始化时是线程安全的，又能节省内存和初始化时间。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 type Config struct { Server string Port int64 } var ( once sync.Once config *Config ) func ReadConfig() *Config { once.Do(func() { var err error config = \u0026amp;Config{Server: os.Getenv(\u0026#34;TT_SERVER_URL\u0026#34;)} config.Port, err = strconv.ParseInt(os.Getenv(\u0026#34;TT_PORT\u0026#34;), 10, 0) if err != nil { config.Port = 8080 // default port } log.Println(\u0026#34;init config\u0026#34;) }) return config } func main() { for i := 0; i \u0026lt; 10; i++ { go func() { _ = ReadConfig() }() } time.Sleep(time.Second) } 标准库中的使用 比如 package html 中，对象 entity 只被初始化一次。 字典 entity 包含 2005 个键值对，若使用 init 在包加载时初始化，若不被使用，将会浪费大量内存。 html.UnescapeString(s) 函数是线程安全的，可能会被用户程序在并发场景下调用，因此对 entity 的初始化需要加锁，使用 sync.Once 能保证这一点。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 var populateMapsOnce sync.Once var entity map[string]rune func populateMaps() { entity = map[string]rune{ \u0026#34;AElig;\u0026#34;: \u0026#39;\\U000000C6\u0026#39;, \u0026#34;AMP;\u0026#34;: \u0026#39;\\U00000026\u0026#39;, \u0026#34;Aacute;\u0026#34;: \u0026#39;\\U000000C1\u0026#39;, \u0026#34;Abreve;\u0026#34;: \u0026#39;\\U00000102\u0026#39;, \u0026#34;Acirc;\u0026#34;: \u0026#39;\\U000000C2\u0026#39;, // 省略 2000 项 } } func UnescapeString(s string) string { populateMapsOnce.Do(populateMaps) i := strings.IndexByte(s, \u0026#39;\u0026amp;\u0026#39;) if i \u0026lt; 0 { return s } // 省略后续的实现 } 普通示例 对只需要运行一次的代码，如全局性的初始化操作，或者防止多次重复执行（比如重复提交等）都有很好的作用 无论 sync.Once.Do(f func()) 里面的f函数是否变化，只要 Once.Do() 运行一次就没有机会再次运行了 Once 是一个结构体，通过判断 done 值来确定是否执行下一步 当 done 为1时直接返回，否则锁定后执行f函数以及置done值为1 而对 done 的值得修改使用了 atomic.StoreUint32（原子级的操作） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;sync\u0026#34; \u0026#34;time\u0026#34; ) var once sync.Once func onces() { fmt.Println(\u0026#34;once\u0026#34;) } func onced() { fmt.Println(\u0026#34;onced\u0026#34;) } func main() { for i, v := range make([]string, 10){ once.Do(onces) fmt.Println(\u0026#34;v:\u0026#34;, v, \u0026#34;--i:\u0026#34;, i) } for i := 0; i \u0026lt; 10; i++ { go func(i int) { once.Do(onced) fmt.Println(i) }(i) } time.Sleep(3 * time.Second) } once v: --i: 0 v: --i: 1 v: --i: 2 v: --i: 3 v: --i: 4 v: --i: 5 v: --i: 6 v: --i: 7 v: --i: 8 v: --i: 9 0 1 3 4 2 6 5 7 8 9 ","permalink":"http://localhost:1313/posts/golang/sync/once/","summary":"Once是只执行一个动作的对象。","title":"sync.Once"},{"content":"type Mutex struct 🚀 包说明：\nsync 包提供了基本的同步原语，如互斥锁。 除了 Once 和 WaitGroup 类型之外，大多数都供底层库例程使用。 更高层次的同步最好通过 channels 和通信来完成。 包含在此包中定义的类型的值不应被复制。 1 2 3 4 5 6 7 // Package sync provides basic synchronization primitives such as mutual // exclusion locks. Other than the Once and WaitGroup types, most are intended // for use by low-level library routines. Higher-level synchronization is // better done via channels and communication. // // Values containing the types defined in this package should not be copied. package sync Mutex 是一把互斥锁。互斥锁的零值是未锁定的。 Mutex 在第一次使用后不能被复制。 在 Go 内存模型的术语中，第 n 次调用 Unlock，第 m 次调用 Lock 在同步完成以前 任何 n \u0026lt; m。 成功调用 TryLock 等同于调用 Lock。调用 TryLock 失败根本不会建立任何关系 在同步完成以前。 它是一把结合了【自旋锁】和【信号量】优化过的锁。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 // A Mutex is a mutual exclusion lock. // The zero value for a Mutex is an unlocked mutex. // // A Mutex must not be copied after first use. // // In the terminology of the Go memory model, // the n\u0026#39;th call to Unlock “synchronizes before” the m\u0026#39;th call to Lock // for any n \u0026lt; m. // A successful call to TryLock is equivalent to a call to Lock. // A failed call to TryLock does not establish any “synchronizes before” // relation at all. type Mutex struct { // Mutex 的状态信息 state int32\t// 初始时为 0 // semaphore 相关字段，该字段也是为什么 Mutex 不让拷贝的原因 sema uint32 // 初始时为 0 } Mutex 的内存布局： Mutex 是一个互斥锁，可以创建为其他结构体的字段，零值为解锁状态。 Mutex 类型的锁和线程无关，可以由不同的线程加锁和解锁。 Mutex 结构布局： state 记录 Mutex 的相关信息。 sema 在 Mutex 中没有任何作用，主要是在 semaphore 中，该字段是 Mutex 不能被拷贝的根本原因，在 semaphore 中主要标识有 wakeup 发生。 【正常模式】和【饥饿模式】： 正常模式：一个尝试加锁的 goroutine 会先自旋几次，尝试通过原子操作获得锁，若几次自旋之后仍不能获得锁，则通过信号量（semaphore）排队等待。所有的等待者会按照先入先出（FIFO）的顺序排队，但是当一个等待者被唤醒后并不会直接拥有锁，而是需要和后来者（处于自旋阶段，尚未排队等待的协程）竞争。这种情况下后来者更有优势，一方面原因是后来者正在CPU上运行，自然比刚唤醒的 goroutine 更有优势，另一方面处于自旋状态的 goroutine 可以有很多，而被唤醒的 goroutine 每次只有一个，所以被唤醒的 goroutine 有很大概率获取不到锁，这种情况下它会被重新插入队列的头部，而不是尾部。当一个 goroutine 本次加锁等待的时间超过了 1ms 后，它会把当前 Mutex 切换至饥饿状态。 饥饿模式：Mutex 的所有权从执行 Unlock 的 goroutine 直接传递给等待队列头部的 goroutine。后来者不会自旋，也不会尝试获得锁，它们会直接从队列的尾部排队等待，即使 Mutex 处于 Unlocked 状态。当一个等待者获得了锁之后，它会在以下两种情况时将 Mutex 由饥饿模式切换回正常模式：(1)它是最后一个等待者，即等待队列空了。(2)它的等待时间小于1ms，也就是它刚来不久，后面自然更没有饥饿的 goroutine 了。 正常模式下 Mutex 有更好的性能，但是饥饿模式对于防止尾端延长（队列尾端的 goroutine 迟迟抢不到锁）来讲特别重要。 const 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 const ( // 是否上锁标志位；0-未上锁，1-已上锁； mutexLocked = 1 \u0026lt;\u0026lt; iota\t// 001 // 是否有 goroutine 从阻塞中被唤醒；0-没有；1-有； // 当该标志位被设置时，Unlock 操作不会唤醒排队的 goroutine。 mutexWoken\t// 010 // 是否处于饥饿模式；0-非饥饿，1-饥饿； mutexStarving\t// 100 // 最低位存在3个bit位标识特俗信息，分别为上述的 mutexLocked、mutexWoken、mutexStarving mutexWaiterShift = iota\t// 3 // 互斥公平 // 互斥量可以有两种操作模式:正常(normal)和饥饿(starvation)。 // 在正常模式(normal mode)下：等待的waiters按FIFO(先进先出)顺序排队，但被唤醒的waiter不拥有互斥锁，并与新到达的goroutines竞争所有权。 // 新加入的goroutines有一个优势，它们已经在CPU上运行，并且可能有很多，所以唤醒的waiters很有可能会失败。 // 在这种情况下，它被重新安排在等待队列的前面。如果waiter超过1ms未能获取互斥锁，它将互斥锁切换到饥饿模式。 // 在饥饿模式(starvation mode)下：互斥锁的所有权直接从正在解锁的goroutine移交给队列前面的waiter。 // 新到达的goroutines不会尝试获取互斥锁，即使它看起来已经解锁，也不会尝试旋转。相反，它们把自己排在等待队列的尾部。 // 如果一个waiter收到互斥锁的所有权，并且发现 //\t1) 它是队列中最后一个waiter，或者 //\t2) 它等待的时间少于1毫秒，它会将互斥锁切换回正常工作模式。 // 普通模式(Normal mode)具有更好的性能，因为goroutine可以连续多次获取互斥量，即使有阻塞的等待。 // 饥饿模式(Starvation mode)对于预防有些g一值获取不到锁的尾延迟具有重要意义。(该模式防止有些始终拿不到锁的一直等待在信号池里面的goroutine) // 正常模式 \u0026lt;-\u0026gt; 饥饿模式 相互转换的时间阀门 // 饥饿模式，当前从semaphore中wakeup的goroutine的sleep时间超过1ms，再次获取锁失败时会被标记为饥饿模式 // 饥饿模式下：state 值的 mutexLocked和mutexWoken 位可能为0或1，被唤醒的goroutine mutexLocked和mutexWoken 位都为0 starvationThresholdNs = 1e6\t// sync.Mutex 进入饥饿模式的等待时间阈值1ms。 ) Lock() Lock 锁住 m。 如果锁已经被使用，调用 goroutine 会阻塞，直到 mutex 可用。 Lock 和 Unlock 是一对操作。 该方法主要通过 atomic 函数实现了Fast path，相应的Slow path被单独放在了lockSlow()方法中。 根据源码注释的说法，这样是为了便于编译器对 Fast path 进行内联优化。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 // Lock locks m. // If the lock is already in use, the calling goroutine // blocks until the mutex is available. func (m *Mutex) Lock() { // 1) 使用CAS尝试获取锁 // Fast path期望 Mutex 处于 Unlocked 状态，没有 goroutine 在排队，更不会饥饿。 // 理想状态下，一个CAS操作就可以获得锁。 // Fast path: grab unlocked mutex. // // 快速路径：获取解锁的互斥量。 // 原子操作比较 m.state 的旧值为 0 并交换成新值 1，成功则表示获取到锁。 // 这种情况发生在 state=0 时，没有等待的goroutine。 if atomic.CompareAndSwapInt32(\u0026amp;m.state, 0, mutexLocked) { if race.Enabled { race.Acquire(unsafe.Pointer(m)) } return } // 2) m.state != 0 时都会走 Slow path // CAS 操作没能获得锁，就需要进入 Slow path了。 // Slow path (outlined so that the fast path can be inlined) // // 如果上面快速方式拿取不到锁，则去和其他竞争。上面情况拿不到锁，可能： // 1. 存在有其他goroutine正在持有锁。 // 2. 不存在其他goroutine持有锁，存在被唤醒的goroutine或还有等待的goroutine。 // 当前可能处于【正常模式】或【饥饿模式】 m.lockSlow() } lockSlow() 如果调用者拿取不到锁，则下面操作流程是先自旋试图拿去锁，实在拿取不到锁则进入信号池去等待拿取锁。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 // 竞争获取锁 // 1. 先自旋等待其他goroutine解锁（满足自旋条件时） // 2. 尝试修改 state 值竞争锁 // 3. 竞争成功，获取锁退出 // 4. 竞争失败，sleep goroutine func (m *Mutex) lockSlow() { // 1. 当前goroutine首次进入semaphore池sleep的时间/纳秒，下次wakeup后用于判断 正常模式 \u0026lt;-\u0026gt; 饥饿模式 转换 // 2. queueLifo := waitStartTime != 0; 进入 semaphore 池的首或尾，false.尾 true.首 var waitStartTime int64\t// mutex模式 【false.正常模式】 【true.饥饿模式】 // 1. 正常模式下，新来获取锁的goroutine如果满足条件会进行自旋等待锁被释放，如果还拿取不到锁则去信号池最前面等待。 // 2. 饥饿模式下，新来获取锁的goroutine不会进行自旋，直接去信号池的末尾去等待。 starving := false\t// 是否有goroutine被唤醒 false.没有 // 有被唤醒的goroutine时，会试图去拿去锁，可能是跟当前正在获取锁的goroutine竞争 // 1. 在自旋情况下满足条件设置 awoke 为 true // 2. 非饥饿模式下被唤醒的goroutine awoke 会被设置为 true // 3. 在饥饿模式下 awoke 变量没有用 awoke := false\t// 用于原子设置 mutexWoken 位，通知 Unlock 函数有 woken 的goroutine了，不要去wakeup goroutine // 记录旋转的次数，当没有获取锁时，会尝试4次去自旋获取 iter := 0\t// 自旋计数器\t// 以下代码都是从 old -\u0026gt; new 的原子操作，去尝试修改 state 值 old := m.state\t// 旧值state // 该循环只有在获取到锁的时候才会退出，因此所有未获取到锁的goroutine都将在这里等待获取锁 for { // 1) 饥饿模式下不要自旋，因为所有权按照顺序传递，自旋没有意义。 // 正常模式下锁没有被释放满足自旋条件需要自旋。 // Don\u0026#39;t spin in starvation mode, ownership is handed off to waiters // so we won\u0026#39;t be able to acquire the mutex anyway. // // 不要在饥饿模式下旋转，所有权已移交给waiters，因此我们无论如何都无法获得互斥锁 // 1. old\u0026amp;(mutexLocked|mutexStarving) == mutexLocked; Mutex没有处于饥饿模式并且已被锁定。 // 2. runtime_canSpin(iter); 报告当前旋转要求条件。 //\t主动旋转条件： //\t旋转次数小于4次 并且 多核CPU运行 并且除了当前P还有其他P正在运行（不是空闲或自旋状态的P）并且 当前P没有其他g了 //\t这种情况需要去尝试自旋获取下锁，其他情况则不需要自旋去获取锁 // 以下自旋的意义，停留片刻等待其他goroutine让出锁，然后标记mutexWoken存在被唤醒的goroutine使自己获取锁优先级更高 if old\u0026amp;(mutexLocked|mutexStarving) == mutexLocked \u0026amp;\u0026amp; runtime_canSpin(iter) {\t// 自旋在这里 // Active spinning makes sense. // Try to set mutexWoken flag to inform Unlock // to not wake other blocked goroutines. // // 主动旋转是有道理的。 // 尝试设置 mutexflag 来通知 Unlock 不要唤醒其他被阻塞在信号池的goroutines。 // 以下逻辑是处于自旋，自旋的意义在于标记有正在被唤醒的goroutine，其他线程不要再次唤醒导致过多goroutine被唤醒 // // 1. !awoke; ：没有标记当前goroutine被唤醒 // 2. old\u0026amp;mutexWoken == 0; ：没有被唤醒的goroutine，包括其他g和当前g // 3. old\u0026gt;\u0026gt;mutexWaiterShift != 0; ：存在等待排队在信号池的goroutine // 4. atomic.CompareAndSwapInt32(\u0026amp;m.state, old, old|mutexWoken); //\t设置标志有goroutine被唤醒，这里设置成功那unlock则不会再去唤醒goroutine if !awoke \u0026amp;\u0026amp; old\u0026amp;mutexWoken == 0 \u0026amp;\u0026amp; old\u0026gt;\u0026gt;mutexWaiterShift != 0 \u0026amp;\u0026amp; atomic.CompareAndSwapInt32(\u0026amp;m.state, old, old|mutexWoken) { // 标记为唤醒状态，主要是告诉unlock不要再去唤醒goroutine了，这里有自旋的在等待 awoke = true } // 短暂延迟一段时间，主要是等待其他g解锁 // 如果此时Unlock了第一个if则不会再判断为true，直接去争抢锁了 runtime_doSpin()\titer++ old = m.state\t// 从新赋值给old continue } // 2) 锁可能已被释放尝试竞争获取，或锁还未解除去sleep。 // 代码执行到这里，只可能处于以下几种情况 // 1. 自旋次数以完，状态依然是 mutexLocked。 // 2. 状态是 mutexStarving 处于饥饿状态。 // 3. 状态是未加锁状态，锁已被解除。 // （处于饥饿模式） 或 （自旋次数超过4次） 或 （当前其他goroutine已Unlock）或 （不满足自旋条件） //\t如果锁已Unlock，那么尝试去获取锁；如果锁处于Lock，那么也尝试获取，否则加入到信号池中等待 // old 是本轮原子操作的 state 值 // new 是本轮需要争抢锁修改后的 state 值 // 正常模式下: // 1. 在old未持有锁情况下，谁先原子操作从 old 修改为 new 谁就先获取到锁 // 2. 在old持有锁情况下，当前goroutine需要sleep new := old // 2.1) 正常模式下需要争抢锁，因此需要设置mutexLocked状态 // Don\u0026#39;t try to acquire starving mutex, new arriving goroutines must queue. // // 不要尝试获取处于饥饿的Mutex，后来的goroutines必须排队。 // // 处于饥饿模式下，为什么不需要设置mutexLocked标志呢？ // 1. 处于饥饿模式下锁的持有权是手把手交给后面等待的goroutine，因此mutexLocked标志设置不设置不重要 // 2. 对于新来的goroutine，mutexLocked位可能为0或1，但是当前goroutine不会去挣抢锁直接sleep，因此mutexLocked位不重要 // 3. 对于从sleep中wakeup的goroutine，一定是来自Unlock函数而来自该函数mutexLocked位一定是0，已被解锁 if old\u0026amp;mutexStarving == 0 {\t// 处于正常模式 // new表示新值修改的状态 mutexLocked需要锁，不管当前是Lock或Unlock当前都需要设置mutexLocked表示需要去争抢锁 new |= mutexLocked\t} // 2.2) 锁还未被释放 或 处于饥饿模式下 这两种情况下都会去sleep，因此需要加一。 // 如果old锁没释放 或 处于饥饿状态，那么当前的goroutine则是需要被加入到信号池里面去的 if old\u0026amp;(mutexLocked|mutexStarving) != 0 {\t// 处于Lock或则饥饿模式当前g需要加入到信号池 new += 1 \u0026lt;\u0026lt; mutexWaiterShift\t// 数量增加1 } // 2.3) 当前 goroutine 将 mutex 切换至饥饿模式 // 如果 mutex 已经处于 unlocked 状态，就不要切换了， // 因为 Unlock() 函数认为处于饥饿模式的 mutex 等待队列不为空。 // The current goroutine switches mutex to starvation mode. // But if the mutex is currently unlocked, don\u0026#39;t do the switch. // Unlock expects that starving mutex has waiters, which will not // be true in this case. // // 当前的 goroutine 将互斥锁切换到饥饿模式，但如果互斥锁当前已解锁，就不要切换。 // Unlock期望处于饥饿状态的互斥锁有waiters，但在本例中并非如此。 // // starving=true 发生在：这个goroutine被加入到信号池后再度被唤醒去争抢锁时，发现等待时间已经超过1ms时 // old\u0026amp;mutexLocked != 0，表示这个被唤醒的goroutine再次争抢锁时锁没被其他gorutine释放，这次再争抢将失败则会标记成饥饿模式 if starving \u0026amp;\u0026amp; old\u0026amp;mutexLocked != 0 {\t// 这种情况下当前goroutine基本拿去不到锁 new |= mutexStarving // 标记成饥饿模式时，锁一定被其他持有；但是唤醒的g处于饥饿模式时，锁一定是Unlock状态 } // 2.4) 当前goroutine是被唤醒的，检查并清除标志位 // awoke=true 表示来自自旋或被唤醒的goroutine两种形式 // 1. 自旋状态下 awoke=true，state 中 mutexWoken 位已被设置为 1 // 2. 被唤醒的goroutine下 awoke=true 在本函数的唤醒后被设置，而 state 中 mutexWoken 位在Unlock函数中被设置 // 因此 awoke=true 就一定存在 state 中 mutexWoken 位为1，new\u0026amp;mutexWoken != 0成立 if awoke {\t// awoke有等待的goroutine被唤醒 // The goroutine has been woken from sleep, // so we need to reset the flag in either case. // // goroutine 已经从睡眠中唤醒，所以我们需要在任何一种情况下重置标志 if new\u0026amp;mutexWoken == 0 {\t// 不论来自自旋或被唤醒的goroutine这里都不能为0，正常状况下 throw(\u0026#34;sync: inconsistent mutex state\u0026#34;) } new \u0026amp;^= mutexWoken // 清除被唤醒标志位mutexWoken，因为下面即将去争抢锁，或者载入去信号池等待 } // 尝试使用原子修改state，所有的goroutine都会通过该条件，但是一轮只能成功一个 // 这里修改m.state成功了，并不代表一定获取到了锁，也有可能是当前g需要加入到信号池中去 if atomic.CompareAndSwapInt32(\u0026amp;m.state, old, new) {\t// 如果上一个拿去到锁的state是正常模式并没有锁，则这里直接退出，这里表示当前goroutine获取到了锁，正常模式都是从这里退出的 // 正常模式下获取到锁的情况，这里不会出现标记成饥饿模式但这里又判断为true退出了的情况，原因是标记成饥饿模式的前置条件是当前old是Lock if old\u0026amp;(mutexLocked|mutexStarving) == 0 {\t// 谁先拿到锁退出，接到执行goroutine后面代码 break // locked the mutex with CAS } // 后面处理逻辑是之前有锁，这个goroutine需要去排队情况，或当前模式处于饥饿模式，直接把该goroutine加入到尾部 // If we were already waiting before, queue at the front of the queue. // // 如果我们之前已经在等待，请在队列的前面排队 // waitStartTime如果不等于0说明先前入队过有被唤醒过，正常第一次入队这里是false // 被唤醒之后没有抢到锁，需要插入队列头部，而不是尾部。 queueLifo := waitStartTime != 0 // 首次进入信号池去等待时 if waitStartTime == 0 {\t// 这里表示这个goroutine从信号池中第一次被唤醒依然没有获取到锁，从新设置时间 waitStartTime = runtime_nanotime()\t// 注意：除第一次入队后后面每次缓存waitStartTime时间都不会被刷新 } // 这里存在被唤醒但是还是没拿到锁的情况会再次被入队 // runtime_SemacquireMutex的queueLifo参数为true则是插入的信号池头部，false插入到尾部 //\t首次进入信号池，则直接排在尾部 //\t从信号池中出来又争抢失败进入信号池排在头部 // 如我们取出gorutine则是从头部开始往后取，这也就是我们说的先进先出 // 因为第一次加入信号池的都是插入到尾部，当再被唤醒依然没有获取到锁时，则是被放回到头部 // 当前goroutine去排队，这里当前groutine被调离工作线程等待抢到锁后继续后面执行 runtime_SemacquireMutex(\u0026amp;m.sema, queueLifo, 1)\t// 被唤醒的g，接到从这里执行尝试去获取锁；可能当前处于饥饿模式或处于正常模式，唤醒g的相关代码位于Unlock函数 // 如果等待的时间大于1ms则标记成饥饿模式，以下逻辑是当前goroutine被唤醒后再次尝试获取锁 // 等待时间超过了1ms，等待时间太久需要被标记为饥饿状态 starving = starving || runtime_nanotime()-waitStartTime \u0026gt; starvationThresholdNs old = m.state\t// 获取当前的状态 // 如果处于饥饿模式，处于饥饿模式下唤醒的goroutine立即获取锁，因为正常来抢的goroutine都会被入队， // 然后一个个来获取 // 所有饥饿模式下获取锁的出口都在这里，该条件满足说明当前goroutine获取到锁持有权 if old\u0026amp;mutexStarving != 0 {\t// If this goroutine was woken and mutex is in starvation mode, // ownership was handed off to us but mutex is in somewhat // inconsistent state: mutexLocked is not set and we are still // accounted as waiter. Fix that. // // 当前代码位置的 goroutine 肯定是被唤醒的，而且 Mutex 处于饥饿模式 // 所有权被直接交给当前 goroutine // 但是这种情况下 mutex 的 state 会与实际情况不一致 // mutexLocked 标志位没有设置 // 而且等待者计数中也没有减去当前 goroutine。需要修复 state // 注意饥饿模式下传递 mutex 所有权不会设置 mutexWoken 标志，只有正常模式下唤醒才会 // // 饥饿模式下 old\u0026gt;\u0026gt;mutexWaiterShift != 0，当前一定不能是最后一个， // 因为下面 old\u0026gt;\u0026gt;mutexWaiterShift == 1 会退出饥饿模式 // old\u0026amp;(mutexLocked|mutexWoken) != 0 因为处于饥饿模式下，所有的goroutine都会去排队sleep， // 被wakeup的goroutine一定来自Unlock函数， // 此时mutexLocked一定解锁，mutexWoken一定是被清除的 if old\u0026amp;(mutexLocked|mutexWoken) != 0 || old\u0026gt;\u0026gt;mutexWaiterShift == 0 { // 饥饿模式下，mutexLocked和mutexWoken必定为0，参看上面代码。 throw(\u0026#34;sync: inconsistent mutex state\u0026#34;) } // +mutexLocked -1\u0026lt;\u0026lt;mutexWaiterShift delta := int32(mutexLocked - 1\u0026lt;\u0026lt;mutexWaiterShift)\t// 将等待的数量减一 // 等待时间小于1ms 或 当前goroutine是队列最后一个，则标记退出饥饿模式 if !starving || old\u0026gt;\u0026gt;mutexWaiterShift == 1 { // Exit starvation mode. // Critical to do it here and consider wait time. // Starvation mode is so inefficient, that two goroutines // can go lock-step infinitely once they switch mutex // to starvation mode. delta -= mutexStarving\t// 退出饥饿模式 } atomic.AddInt32(\u0026amp;m.state, delta) // 修改state，返回直接返回，应为该goroutine 获取到锁了 break\t// 饥饿模式从这里退出，因此饥饿模式下被唤醒的goroutine直接从这里退出 } // 正常模式下，设置为唤醒去争抢锁 awoke = true\t// state的mutexWoken位在Unlock函数中被设置 iter = 0\t// 自旋次数重置 } else { // 从old-\u0026gt;new 原子设置，如果设置失败从新再来 old = m.state } } if race.Enabled { race.Acquire(unsafe.Pointer(m)) } } sync_runtime_canSpin() sync.Mutex 主动旋转条件。 不主动旋转条件： 【旋转次数大于等于4次】或【单核CPU在运行】 或【除了当前P其他P都处于空闲或自旋状态】，不需要主动去旋转等待获取锁。 如果当前P的runq不为空，也没必要去自旋，因为里面的g还等着去执行，直接把当前g挂起。 主动旋转条件： 【旋转次数小于4次】并且【多核CPU运行】并且【除了当前P还有其他P正在运行】（不是空闲或自旋状态的P）并且 【当前P没有其他g了】。 这种情况需要去尝试自旋获取下锁，其他情况则不需要自旋去获取锁。 runtime/proc.go文件中。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 // Active spinning for sync.Mutex. //go:linkname sync_runtime_canSpin sync.runtime_canSpin //go:nosplit func sync_runtime_canSpin(i int) bool { // sync.Mutex is cooperative, so we are conservative with spinning. // Spin only few times and only if running on a multicore machine and // GOMAXPROCS\u0026gt;1 and there is at least one other running P and local runq is empty. // As opposed to runtime mutex we don\u0026#39;t do passive spinning here, // because there can be work on global runq or on other Ps. // // sync.Mutex是合作性的，所以我们对spinning是保守的。 // 只旋转几次，且仅当运行在多核计算机和GOMAXPROCS\u0026gt;1上，并且至少有一个其他运行P且本地runq为空时。 // 与运行时互斥锁相反，我们在这里不做被动旋转，因为可以在全局runq或其他P上进行工作。 // // 以下条件满足一项都不会再次自旋去获取锁 // 1. const active_spin = 4; 最多尝试4次自旋获取 // 2. var ncpu int32 \u0026lt;= 1; 如果是单核CPU // 3. gomaxprocs \u0026lt;= int32(sched.npidle+sched.nmspinning)+1; // 3.1 gomaxprocs：表示总的P // 3.2 sched.npidle空闲的P数量 // 3.3 sched.nmspinning正在自旋的M数量(这里面可能存在正在争抢锁，处在自旋都是只有一个g的情况) // 除了当前P其他的P都很闲，也不必要自旋了。 if i \u0026gt;= active_spin || ncpu \u0026lt;= 1 || gomaxprocs \u0026lt;= int32(sched.npidle+sched.nmspinning)+1 { return false } // 这里不像 runtime.mutex 那样进行消极自旋，因为全局 runq 或其他 P 上或许还有可运行的任务。 // 当前本地P不为空，也不需要自旋再出去尝试获取锁，其他goroutine还等起的。 if p := getg().m.p.ptr(); !runqempty(p) { return false } return true } sync_runtime_doSpin() 短暂的延迟。 runtime/proc.go 文件中。 1 2 3 4 5 6 //go:linkname sync_runtime_doSpin sync.runtime_doSpin //go:nosplit func sync_runtime_doSpin() { // 循环30次等待 procyield(active_spin_cnt)\t// active_spin_cnt=30 } procyield() 短暂的延迟。 1 2 3 4 5 6 7 8 # runtime/asm_amd.64.s TEXT runtime·procyield(SB),NOSPLIT,$0-0 MOVL\tcycles+0(FP), AX\t# AX=30 参数 again: PAUSE # 自旋降低CPU发热和性能优化。 SUBL\t$1, AX\t# AX -= 1 JNZ\tagain RET Unlock() Unlock解锁m。 如果m在进入解锁时没有被锁定，则是一个运行时错误。 一个锁定的互斥量与一个特定的goroutine无关。 允许一个goroutine锁定一个互斥量，然后安排另一个goroutine解锁它。 该方法主要通过 atomic 函数实现了 Fast path，相应的 Slow path被单独放在了 unlockSlow() 方法中。 根据源码注释的说法，这样是为了便于编译器对 Fast path 进行内联优化。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 // Unlock unlocks m. // It is a run-time error if m is not locked on entry to Unlock. // // A locked Mutex is not associated with a particular goroutine. // It is allowed for one goroutine to lock a Mutex and then // arrange for another goroutine to unlock it. func (m *Mutex) Unlock() { if race.Enabled { _ = m.state race.Release(unsafe.Pointer(m)) } // 1) 通过原子操作从 state 中减去 mutexLocked，也就是释放锁 // 然后根据 state 的新值(new)来判断是否需要执行 Slow path。 // Fast path: drop lock bit. // // Fast path: 直接把锁标志位放开 // 如果之前mutexLocked位为1则修改为0；如果之前mutexLocked位为0则修改为1； new := atomic.AddInt32(\u0026amp;m.state, -mutexLocked)\t// 如果删除了锁的bit位，state等于0说明没有等待抢锁的goroutine直接返回 // new为0，意味着没有其他 goroutine 在排队，所以不需要执行额外操作。 // new不为0，则可能需要唤醒某个 goroutine。 // Unlock 执行完后mutex.state!=0 则存在以下可能 // 正常模式下 // 1. 当前存在等待的goroutine去唤醒它 //\t2. 当前存在自旋等待的goroutine，则不唤醒其他等待的goroutine // 饥饿模式下 // 1. 直接将锁交给等待队列的第一个goroutine if new != 0 {\t// 还存在其他等待队列中的goroutine // Outlined slow path to allow inlining the fast path. // To hide unlockSlow during tracing we skip one extra frame when tracing GoUnblock. // // 概述了慢速路径以允许内联快速路径 // 为了在跟踪过程中隐藏 unlockSlow，我们在跟踪 GoUnblock 时会跳过一个额外的帧 m.unlockSlow(new) } } unlockSlow() 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 func (m *Mutex) unlockSlow(new int32) { // 判断未加锁的情况下不能多次调用unlock // 正常逻辑这里 new+mutexLocked 应该为1 if (new+mutexLocked)\u0026amp;mutexLocked == 0 {\t// 这种情况判断之前根本就没加过锁，则去解锁这会直接报错误 throw(\u0026#34;sync: unlock of unlocked mutex\u0026#34;) } // 正常模式下 if new\u0026amp;mutexStarving == 0 { // 从 old -\u0026gt; new 原子操作，主要是唤醒goroutine old := new for {\t// 以下代码是通过唤醒goroutine和其他正在运行的goroutine去争抢锁 // If there are no waiters or a goroutine has already // been woken or grabbed the lock, no need to wake anyone. // In starvation mode ownership is directly handed off from unlocking // goroutine to the next waiter. We are not part of this chain, // since we did not observe mutexStarving when we unlocked the mutex above. // So get off the way. // // 如果没有waiters，或goroutine已经被叫醒或抢了锁，没有必要叫醒任何人。 // 在饥饿模式下，所有权会从解锁goroutine直接移交给下一个waiter。 // 我们不是这个链的一部分，因为我们在上面解锁互斥锁时没有观察到mutexStarving。所以别挡道。 // // 没有等待的goroutine 或 (有其他的goroutine已近获得锁 或 有被唤醒的goroutine 或 当前处于饥饿模式下) if old\u0026gt;\u0026gt;mutexWaiterShift == 0 || old\u0026amp;(mutexLocked|mutexWoken|mutexStarving) != 0 { return\t// 直接返回，不需要再去后续处理 } // Grab the right to wake someone. // // 等在被唤醒的goroutine数量减一，设置有被唤醒标志 new = (old - 1\u0026lt;\u0026lt;mutexWaiterShift) | mutexWoken\t// 设置需要唤醒一个goroutine的新状态 if atomic.CompareAndSwapInt32(\u0026amp;m.state, old, new) {\t// 原子设置成功，说明没有其他正在争抢或当前争抢成功 runtime_Semrelease(\u0026amp;m.sema, false, 1)\t// 取出等待的goroutine放入本地P等待被调度，饭后返回 return } old = m.state\t// 没有获取成功，则直接替换旧state，再次尝试 } } else {\t// 饥饿模式下 // Starving mode: handoff mutex ownership to the next waiter, and yield // our time slice so that the next waiter can start to run immediately. // Note: mutexLocked is not set, the waiter will set it after wakeup. // But mutex is still considered locked if mutexStarving is set, // so new coming goroutines won\u0026#39;t acquire it. // // 饥饿模式：将mutex所有权移交给下一个waiter，并让出我们的时间片，以便下一个waiter可以立即开始运行 // 注意：mutexLocked 没有设置，waiter会在唤醒后设置 // 但是如果设置了 mutexStarving，mutex 仍然被认为是锁定的，所以新的 goroutines 不会获取它 // 处于饥饿模式下从这里唤醒的goroutine，state中mutexLocked位，一定为0 runtime_Semrelease(\u0026amp;m.sema, true, 1)\t// 饥饿模式下只从首部取出goroutine等待被调度即可 // 这里在饥饿模式下为甚不判断等待的goroutine数量？ // 原因是：处于饥饿模式下等待的goroutine数量一定是\u0026gt;=1的。 // 因为最后一个goroutine会把模式切换成正常模式，相关代码位于Lock函数 } } TryLock() TryLock试图锁定m并报告是否成功。 请注意，虽然确实存在正确使用TryLock的情况，但很少，而且TryLock的使用通常表明互斥量的特定使用中存在更深层的问题。 TryLock 可以用于在业务比较繁忙时去尝试获取锁，失败则提示相关文案等 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 // TryLock tries to lock m and reports whether it succeeded. // // Note that while correct uses of TryLock do exist, they are rare, // and use of TryLock is often a sign of a deeper problem // in a particular use of mutexes. func (m *Mutex) TryLock() bool { old := m.state // 当前锁存在 或 当前处于饥饿模式 if old\u0026amp;(mutexLocked|mutexStarving) != 0 { return false\t// 获取失败 } // There may be a goroutine waiting for the mutex, but we are // running now and can try to grab the mutex before that // goroutine wakes up. // // 可能有一个goroutine在等待互斥量，但我们现在正在运行，并且可以尝试在goroutine唤醒之前获取互斥量。 // // 尝试去争抢锁，这里的old一定是没加锁并处于正常模式下去尝试争抢 if !atomic.CompareAndSwapInt32(\u0026amp;m.state, old, old|mutexLocked) { return false\t// 争抢失败情况 } if race.Enabled { race.Acquire(unsafe.Pointer(m)) } return true\t// 争抢成功 } type Locker interface Locker接口代表一个可以加锁和解锁的对象 1 2 3 4 5 // A Locker represents an object that can be locked and unlocked. type Locker interface { Lock() Unlock() } 使用示例 sync.Mutex 互斥锁：是传统的并发程序对共享资源进行访问控制的主要手段，Go语言中推荐使用通道(channel)来实现资源共享和通信 互斥锁：由标准库 sync 包中分的 Mutex 结构体类型实现 只有两个公开方法： Lock() ：获得锁 Unlock() ：释放锁 同一个协程中同步调用使用Lock()加锁后，不能再对其加锁，否则会引发运行时异常，只能在 Unlock() 之后再次 Lock() 多个协程中异步调用Lock()没有问题，但每个协程只能调用一次Lock()，由于多个协程之间产生了锁竞争，因此不会有运行时异常 互斥锁：适用于只允许有一个读或者写的场景，所以该锁也叫全局锁 如果在使用 Unlock() 前未加锁，就会引起一个运行错误，已经锁定的 Mutex 并不与特定的协程相关，这样可以利用一个协程对其加锁，在利用其它协程对其解锁 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 // LockA() 中有 Lock() // LockB() 中也有 Lock() // LockB() 的 Lock() 运行时，锁还没有 Unlock()，程序发生 panic // 这是在同步调用互斥锁中常见的问题，一般在一对互斥锁中间不要调用其它函数，即使要用也尽量采用异步方式 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;sync\u0026#34; \u0026#34;time\u0026#34; ) var mutex sync.Mutex func main() { LockA() time.Sleep(10) } func LockA() { mutex.Lock()\t// 加锁 fmt.Println(\u0026#34;Lock in A\u0026#34;) LockB() time.Sleep(5) fmt.Println(\u0026#34;Wake up in A\u0026#34;) mutex.Unlock()\t// 解锁 fmt.Println(\u0026#34;Unlock in A\u0026#34;) } func LockB() { fmt.Println(\u0026#34;B\u0026#34;) mutex.Lock()\t// 加锁\tmain goroutine在这里被阻塞，导致deadlock fmt.Println(\u0026#34;Lock in B\u0026#34;) mutex.Unlock()\t// 解锁 fmt.Println(\u0026#34;Unlock in B\u0026#34;) } /* Lock in A B fatal error: all goroutines are asleep - deadlock! goroutine 1 [semacquire]: sync.runtime_SemacquireMutex(0x593b24, 0x0, 0x1) D:/True-False/Go/src/runtime/sema.go:71 +0x4e sync.(*Mutex).lockSlow(0x593b20) D:/True-False/Go/src/sync/mutex.go:138 +0x103 sync.(*Mutex).Lock(...) D:/True-False/Go/src/sync/mutex.go:81 main.LockB() D:/True-False/WWW/GoLang/src/xuexi/mutex.go:28 +0x194 main.LockA() D:/True-False/WWW/GoLang/src/xuexi/mutex.go:19 +0xa2 main.main() D:/True-False/WWW/GoLang/src/xuexi/mutex.go:12 +0x29 exit status 2 */ 把上面同步改为异步，把LockA()的LockB()改为go LockB() 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;sync\u0026#34; \u0026#34;time\u0026#34; ) var mutex sync.Mutex func main() { LockA() time.Sleep(10) } func LockA() { mutex.Lock()\t// 加锁 fmt.Println(\u0026#34;Lock in A\u0026#34;) go LockB() time.Sleep(5) fmt.Println(\u0026#34;Wake up in A\u0026#34;) mutex.Unlock()\t// 解锁 fmt.Println(\u0026#34;Unlock in A\u0026#34;) } func LockB() { fmt.Println(\u0026#34;B\u0026#34;) mutex.Lock()\t// 加锁\tlockB goroutine等待LockA解锁，先自旋再是被挂起 fmt.Println(\u0026#34;Lock in B\u0026#34;) mutex.Unlock()\t// 解锁 fmt.Println(\u0026#34;Unlock in B\u0026#34;) } /* Lock in A B Wake up in A Unlock in A Lock in B Unlock in B */ 建议：同一个互斥锁的成对锁定和解锁操作可以放在同一层次的代码块中 经典用法如下： 1 2 3 4 5 6 7 8 var lck sync.Mutex func foo() { lck.Lock()\t// 加锁 defer lck.Unlock()\t// 解锁 // ... ... } // lck.Lock() 会阻塞直到获取锁，然后利用defer语句在函数返回时自动释放锁 示例代码，通过三个协程来体现sync.Mutex对资源的访问控制特征 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;sync\u0026#34; \u0026#34;time\u0026#34; ) func main() { //var wg sync.WaitGroup wg := sync.WaitGroup{} var mutex sync.Mutex fmt.Println(\u0026#34;Locking (G0)\u0026#34;) mutex.Lock()\t// 加锁 fmt.Println(\u0026#34;locked (G0)\u0026#34;) wg.Add(3) for i := 1; i \u0026lt; 4; i++ { go func(i int) { fmt.Printf(\u0026#34;Locking (G%d)\\n\u0026#34;, i) mutex.Lock()\t// 加锁 fmt.Printf(\u0026#34;Locked (G%d)\\n\u0026#34;, i) time.Sleep(time.Second * 2)\t// 延迟2s mutex.Unlock()\t// 解锁 fmt.Printf(\u0026#34;unlocked (G%d)\\n\u0026#34;, i) wg.Done() }(i) } time.Sleep(time.Second * 5) fmt.Println(\u0026#34;ready unlock (G0)\u0026#34;) mutex.Unlock()\t// 解锁 fmt.Printf(\u0026#34;unlocked (G0)\u0026#34;) wg.Wait() } // 程序运行结果可以看出，当有锁释放时，才能进行加锁动作 // 运行结果如下 Locking (G0) locked (G0) Locking (G1) Locking (G2) Locking (G3) ready unlock (G0) unlocked (G0)Locked (G1) unlocked (G1) Locked (G2) unlocked (G2) Locked (G3) unlocked (G3) Mutex 也可以作为结构体的一部分，这样结构体在被多线程处理时数据安全才有保障 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;sync\u0026#34; \u0026#34;time\u0026#34; ) type Book struct { BookName string L *sync.Mutex } func (bk *Book) SetName(wg *sync.WaitGroup, name string) { defer func() { fmt.Println(\u0026#34;Unlock set name:\u0026#34;, name) bk.L.Unlock()\t// 解锁 wg.Done() }() bk.L.Lock()\t// 加锁 fmt.Println(\u0026#34;Lock set name:\u0026#34;, name) time.Sleep(1 * time.Second) bk.BookName = name } func main() { bk := Book{} //bk.L = \u0026amp;sync.Mutex{} bk.L = new(sync.Mutex) //wg := new(sync.WaitGroup) wg := \u0026amp;sync.WaitGroup{} books := []string{\u0026#34;\u0026lt;\u0026lt;三国演义\u0026gt;\u0026gt;\u0026#34;, \u0026#34;\u0026lt;\u0026lt;道德经\u0026gt;\u0026gt;\u0026#34;, \u0026#34;\u0026lt;\u0026lt;西游记\u0026gt;\u0026gt;\u0026#34;} for _, book := range books { wg.Add(1) go bk.SetName(wg, book) } wg.Wait() } Lock set name: \u0026lt;\u0026lt;西游记\u0026gt;\u0026gt; Unlock set name: \u0026lt;\u0026lt;西游记\u0026gt;\u0026gt; Lock set name: \u0026lt;\u0026lt;三国演义\u0026gt;\u0026gt; Unlock set name: \u0026lt;\u0026lt;三国演义\u0026gt;\u0026gt; Lock set name: \u0026lt;\u0026lt;道德经\u0026gt;\u0026gt; Unlock set name: \u0026lt;\u0026lt;道德经\u0026gt;\u0026gt; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;sync\u0026#34; \u0026#34;time\u0026#34; ) func main() { var m sync.Mutex go func() { m.Lock() defer m.Unlock() fmt.Println(\u0026#34;1\u0026#34;) m.Lock()\t// 这里当前goroutine将被永久保存到信号池中得不到运行机会 fmt.Println(\u0026#34;2\u0026#34;) defer m.Unlock() fmt.Println(\u0026#34;3\u0026#34;) }() time.Sleep(5 * time.Second) // Output: // 1 } 注意事项 Lock() 和 UnLock() 方法应该成对出现。 sync.Mutex 不允许被值拷贝，拷贝地址可以。 ","permalink":"http://localhost:1313/posts/golang/sync/mutex/","summary":"Mutex是一种互斥锁。","title":"sync.Mutex"},{"content":"type WaitGroup struct 🚀 WaitGroup 等待 goroutine 集合完成。 main goroutine 调用 Add 来设置要等待的 goroutine 的数量。然后每个 goroutine 运行并在完成时调用 Done。 同时，可以使用 Wait 来阻塞，直到所有 goroutine 完成。 WaitGroup 在第一次使用后不能被复制。 WaitGroup：用于等待一组线程的结束，父线程调用Add方法来设定应等待的线程的数量。 每个被等待的线程在结束时应调用Done方法，同时，主线程里可以调用Wait方法阻塞至所有线程结束。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 // A WaitGroup waits for a collection of goroutines to finish. // The main goroutine calls Add to set the number of // goroutines to wait for. Then each of the goroutines // runs and calls Done when finished. At the same time, // Wait can be used to block until all goroutines have finished. // // A WaitGroup must not be copied after first use. type WaitGroup struct { // WaitGroup 首次使用后不能被拷贝的原因【是 \u0026amp;state2 地址会发生变化】 // semaPhore 要求 \u0026amp;state2 地址是一个，不然从其中唤醒 goroutine 会找不到 noCopy noCopy\t// 编译器检查WaitGroup对象是否被拷贝过 // 64-bit value: high 32 bits are counter, low 32 bits are waiter count. // 64-bit atomic operations require 64-bit alignment, but 32-bit // compilers only guarantee that 64-bit fields are 32-bit aligned. // For this reason on 32 bit architectures we need to check in state() // if state1 is aligned or not, and dynamically \u0026#34;swap\u0026#34; the field order if // needed. // // 64位值: 高32位是 counter 计数，低32位是 waiter 计数。 // 64-bit = ( uint64(counter) \u0026lt;\u0026lt; 32 ) | uint32( waiter ) // 【64位原子操作需要64位对齐】，但是32位编译器只保证64位字段是32位对齐的。 // 因此，在32位架构上，我们需要检查在state()是否将state1对齐，并在需要时动态 “交换” 字段顺序。 // 意思是：在32位操作系统下使用64位原子操作时，被操作地址必须是64位对齐的，不然会宕机。 state1 uint64\t// (uint64(counter) \u0026lt;\u0026lt; 32) | uint32(waiter) state2 uint32 } type noCopy struct noCopy 可以嵌入到第一次使用后不得复制的结构中. sync/cond.go文件。 1 2 3 4 5 6 7 8 9 10 11 12 // noCopy may be embedded into structs which must not be copied // after the first use. // // See https://golang.org/issues/8005#issuecomment-190753527 // for details. type noCopy struct{} // Lock is a no-op used by -copylocks checker from `go vet`. // // Lock 是 `go vet` 的 -copylocks 检查器使用的无操作 func (*noCopy) Lock() {} func (*noCopy) Unlock() {} WaitGroup 结构布局 Semaphore：信号量用于挂起 Wait 函数的调用者的 goroutine。（需要一个 uint32 类型） Counter：等待的运行的 goroutine 数量，该值在 Add 和 Done 函数中被操作。 Waiter：等待在 Semaphore 中的 goroutine 数量。 为什么需要这么设计呢？因为 Waiter + Counter 是一个整体作为64位，被原子操作，而64位原子操作又要求必须是64位对齐的。（具体参看state()源码） 在1.22版本中，state1也就是Waiter和Counter使用atomic.Uint64替代了。以下图是1.18前版本的。 Sema、Counter、Waiter WaitGroup 结构设计目的是等待集合中的goroutine完成，因此 main goroutine 就是产生这个等待集合的，它等待集合中的所有goroutine完成再继续后续。 Counter 则是计数当前等待集合中的goroutine的数量，一个goroutine被创建放入集合时就应该计数Counter值，一个goroutine完成时也应该计数Counter。 因此goroutine被加入到等待集合中都是在main goroutine中操作包括Counter的计数，一个goroutine完成计数Counter应该在这goroutine完成时操作。 Semaphore 则是 main goroutine 在调用Wait()函数时，main goroutine需要等待等待集合goroutine完成而挂起在Semaphore池子里。 Waiter 则是记录Semaphore中等待的goroutine的数量。 Add() 和 Done() 函数是计数Counter的相关方法，在等待集合goroutine中最后一个goroutine完成时，如果有等待在Semaphore的goroutine应该全部唤醒。 Wait() 函数是等待等待集合goroutine完成，main goroutine主动挂起自己的相关逻辑。 state() State 返回指向存储在 wg.state* 中的 State 和 sema 字段的指针。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 // state returns pointers to the state and sema fields stored within wg.state*. func (wg *WaitGroup) state() (statep *uint64, semap *uint32) { // unsafe.Alignof(wg.state1) == 8：说明state1字段对齐为8字节，这种情况是64位平台 // uintptr(unsafe.Pointer(\u0026amp;wg.state1))%8 == 0：说明wg.state1的地址按照8字节对齐的，可能是64或32平台 if unsafe.Alignof(wg.state1) == 8 || uintptr(unsafe.Pointer(\u0026amp;wg.state1))%8 == 0 { // state1 is 64-bit aligned: nothing to do. // state1 是 64 位对齐的：无事可做 return \u0026amp;wg.state1, \u0026amp;wg.state2\t// state1是64位对齐，state1就是state，state2就是sema } else { // state1 is 32-bit aligned but not 64-bit aligned: this means that // (\u0026amp;state1)+4 is 64-bit aligned. // // State1是32位对齐，而不是64位对齐:这意味着 (\u0026amp;state1)+4 是64位对齐。 // 这种情况处理就是为了满足后续：64位原子操作需要64位对齐 state := (*[3]uint32)(unsafe.Pointer(\u0026amp;wg.state1))\treturn (*uint64)(unsafe.Pointer(\u0026amp;state[1])), \u0026amp;state[0] } } Add() Add 将 delta (可能是负数)添加到 WaitGroup counter。 如果 counter 变为0，所有在等待时被阻塞的 goroutine 都会被释放。如果 counter 变为负数，则会 painc。 请注意，当 counter 为0时，delta为正的调用必须发生在等待之前。 使用负的delta调用，或者从 counter 大于零开始使用正的delta调用，都可能在任何时候发生。 通常，这意味着对Add的调用应该在创建goroutine语句或其他要等待的事件之前执行。 如果重用一个 WaitGroup 来等待几个独立的事件集，那么新的Add调用必须在所有先前的wait调用都返回之后发生。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 // Add adds delta, which may be negative, to the WaitGroup counter. // If the counter becomes zero, all goroutines blocked on Wait are released. // If the counter goes negative, Add panics. // // Note that calls with a positive delta that occur when the counter is zero // must happen before a Wait. Calls with a negative delta, or calls with a // positive delta that start when the counter is greater than zero, may happen // at any time. // Typically this means the calls to Add should execute before the statement // creating the goroutine or other event to be waited for. // If a WaitGroup is reused to wait for several independent sets of events, // new Add calls must happen after all previous Wait calls have returned. // See the WaitGroup example. func (wg *WaitGroup) Add(delta int) { // 1) 原子操作 statep += delta // statep *uint64：【Waiter + Counter】 // semap *uint32：【semaphore】 // *statep = (uint64(counter) \u0026lt;\u0026lt; 32) | uint32(waiter) statep, semap := wg.state() if race.Enabled { _ = *statep // trigger nil deref early if delta \u0026lt; 0 { // Synchronize decrements with Wait. race.ReleaseMerge(unsafe.Pointer(wg)) } race.Disable() defer race.Enable() } // 原子操作 {counter += delta; state = counter;} delta 可能为负数 // 这里的64位原子操作也就是为什么需要 state 函数的原因 state := atomic.AddUint64(statep, uint64(delta)\u0026lt;\u0026lt;32) // counter += delta // 注意这里是 int32 类型，原因是 delta 是来自用户传入，可能最后导致 v \u0026lt; 0 情况发生 v := int32(state \u0026gt;\u0026gt; 32)\t// counter 高32位 w := uint32(state)\t// waiter 低32位 if race.Enabled \u0026amp;\u0026amp; delta \u0026gt; 0 \u0026amp;\u0026amp; v == int32(delta) { // The first increment must be synchronized with Wait. // Need to model this as a read, because there can be // several concurrent wg.counter transitions from 0. race.Read(unsafe.Pointer(semap)) } // 2) counter 不能为负数 // counter 不应该出现为负数情况 if v \u0026lt; 0 { panic(\u0026#34;sync: negative WaitGroup counter\u0026#34;) } // 3) Add(\u0026gt;0) 和 Wait 函数不能并发调用 // Add(\u0026gt;0) 和 Wait() 函数并发被调用 // 1. w != 0 存在等待的waiter // 2. delta \u0026gt; 0 本次调用是添加不是减少 // 3. v == int32(delta) 当前添加的数量就是总数量，之前为0 if w != 0 \u0026amp;\u0026amp; delta \u0026gt; 0 \u0026amp;\u0026amp; v == int32(delta) { panic(\u0026#34;sync: WaitGroup misuse: Add called concurrently with Wait\u0026#34;) } // 4) if ( v \u0026gt; 0 || (v == 0 \u0026amp;\u0026amp; w == 0) ) return // Counter计数数量大于零 或 没有等待的waiter直接返回 // 1. v \u0026gt; 0：代表不是最后一个，因此直接返回 // 2. v == 0 \u0026amp;\u0026amp; w == 0：也是直接返回 if v \u0026gt; 0 || w == 0 {\t// 这里的条件比较关键 return } // 5) v == 0 \u0026amp;\u0026amp; w \u0026gt; 0 // 这种情况需要去把 semap 上面挂起的 goroutine 全部唤醒 // This goroutine has set counter to 0 when waiters \u0026gt; 0. // Now there can\u0026#39;t be concurrent mutations of state: // - Adds must not happen concurrently with Wait, // - Wait does not increment waiters if it sees counter == 0. // Still do a cheap sanity check to detect WaitGroup misuse. // // 当 waiters \u0026gt; 0 时，此 goroutine 将 counter 设置为 0 // 现在不能有并发的 state 突变： // - Add 不能与 Wait 同时发生 // - 如果看到 counter == 0，Wait 不会增加 waiter // 仍然要做一个廉价的健全检查来检测WaitGroup的滥用。 // // WaitGroup误用:Add与Wait并发调用 // 这种情况发生在：最后一个goroutine运行完需要唤醒等待的waiter此时Add方法有被调用 if *statep != state { panic(\u0026#34;sync: WaitGroup misuse: Add called concurrently with Wait\u0026#34;) } // Reset waiters count to 0. *statep = 0\t// 重置 Counter = 0，Waiter = 0 for ; w != 0; w-- { // false正常模式 // 将等待在 semaphore 中的goroutine取出等待调度 runtime_Semrelease(semap, false, 0) } } Done() Done 将 WaitGroup counter 减1。 1 2 3 4 // Done decrements the WaitGroup counter by one. func (wg *WaitGroup) Done() { wg.Add(-1) } Wait() Wait 阻塞，直到 WaitGroup counter 为0。 Wait 函数的调用期间，可能处于多个goroutine在调用 Done 函数。 Wait() 函数允许被多个线程同时调用。Wait() 函数一定要所有的Counter都标记完毕后才调用该方法。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 // Wait blocks until the WaitGroup counter is zero. func (wg *WaitGroup) Wait() { // statep *uint64：【Waiter + Counter】 // semap *uint32：【semaphore】 // *statep = (uint64(counter) \u0026lt;\u0026lt; 32) | uint32(waiter) statep, semap := wg.state() if race.Enabled { _ = *statep // trigger nil deref early race.Disable() } for { state := atomic.LoadUint64(statep)\t// 原子读取 statep v := int32(state \u0026gt;\u0026gt; 32)\t// counter w := uint32(state)\t// waiter // 这种情况，比如在调用Wait函数时先调用sleep睡眠很长一段时间 // 也就是 Wait 函数还没开始执行 其他goroutine 已经执行完了，因此直接返回即可 if v == 0 {\t// Counter is 0, no need to wait. // // 计数器为 0，无需等待 if race.Enabled { race.Enable() race.Acquire(unsafe.Pointer(wg)) } return } // Increment waiters count. // // 增加waiter数量，正常逻辑下在这里等待的只有main goroutine一个 // 这里可能会失败，可能有很多goroutine正在调用Add或Done方法修改Counter导致这里原子操作失败 if atomic.CompareAndSwapUint64(statep, state, state+1) { if race.Enabled \u0026amp;\u0026amp; w == 0 { // Wait must be synchronized with the first Add. // Need to model this is as a write to race with the read in Add. // As a consequence, can do the write only for the first waiter, // otherwise concurrent Waits will race with each other. race.Write(unsafe.Pointer(semap)) } // 该方法最后会调用semacquire1，我们在sync.Mutex中已经讨论过 // 这里会把当前goroutine入队，注意这里入队的是main goroutine // runtime_Semacquire 将当前 goroutine 加入到 semaphore 的尾部 runtime_Semacquire(semap)\t// 主线程在这里被调离工作线程，下次恢复时从这里接到执行 // 当前goroutine被Done函数唤醒时，一定是 *statep == 0，不然流程有问题 if *statep != 0 { panic(\u0026#34;sync: WaitGroup is reused before previous Wait has returned\u0026#34;) } if race.Enabled { race.Enable() race.Acquire(unsafe.Pointer(wg)) } return\t// 直接返回到调用Wait方法位置处 } } } 使用示例 WaitGroup：用于线程总同步，它等待一组线程集合完成，才会继续向下执行。 主线程调用 Add() 方法来设置等待的协程数量： 然后每个协程运行，并在完成后调用 Done() 方法，Add(-1) 和 Done() 效果一致，都表示等到的协程数量减少一个。 同时，Wait() 方法用来阻塞主线程，直到所有协程完成才会向下执行。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;sync\u0026#34; ) func main() { var wg sync.WaitGroup wg.Add(10)\t// (\u0026amp;wg).Add(10) -\u0026gt; (*WaitGroup).Add(\u0026amp;wg, 10) for i := 0; i \u0026lt; 10; i++ { //wg.Add(1)\t// (\u0026amp;wg).Add(1)\t-\u0026gt; (*WaitGroup).Add(\u0026amp;wg, 1) go func(i int) { defer wg.Done()\t// (\u0026amp;wg).Done() -\u0026gt; (*WaitGroup).Done(\u0026amp;wg) fmt.Println(i) }(i) } fmt.Println(\u0026#34;我在循环外\u0026#34;) // 阻塞主线程，等所有协程完成 wg.Wait()\t// (\u0026amp;wg).Wait() -\u0026gt; (*WaitGroup).Wait(\u0026amp;wg) // Output: // 1 // 9 // 3 // 4 // 我在循环外 // 5 // 6 // 7 // 8 // 2 // 0 } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;net/http\u0026#34; \u0026#34;sync\u0026#34; ) func main() { var wg sync.WaitGroup var urls []string = []string{ \u0026#34;http://baidu.com/\u0026#34;, \u0026#34;https://wzapi.myzx.cn/\u0026#34;, } wg.Add(len(urls)) for _, url := range urls { // wg.Add(1) go func(url string) { defer wg.Done() response, err := http.Get(url) fmt.Println(response, err, url) }(url) } wg.Wait() fmt.Println(\u0026#34;over\u0026#34;) // Output: // \u0026amp;{200 OK 200 HTTP/1.1 1 1 map[Accept-Ranges:[bytes] Cache-Control:[max-age=86400] Connection:[Keep-Alive] Content-Length:[81] Content-Type:[text/html] Date:[Thu, 22 Apr 2021 03:19:50 GMT] Etag:[\u0026#34;51-47cf7e6ee8400\u0026#34;] Expires:[Fri, 23 A // pr 2021 03:19:50 GMT] Last-Modified:[Tue, 12 Jan 2010 13:48:00 GMT] Server:[Apache]] 0xc00003a140 81 [] false false map[] 0xc000044000 \u0026lt;nil\u0026gt;} \u0026lt;nil\u0026gt; http://baidu.com/ // \u0026amp;{200 OK 200 HTTP/1.1 1 1 map[Access-Control-Allow-Headers:[Origin, X-Requested-With, Content-Type, Acceptfecshop-uuid, fecshop-lang, fecshop-currency, access-token, x-token, authorization] Access-Control-Allow-Methods:[*] Access-Co // ntrol-Allow-Origin:[*] Cache-Control:[no-cache, private] Connection:[keep-alive] Content-Type:[text/html; charset=UTF-8] Date:[Thu, 22 Apr 2021 03:19:50 GMT] Etag:[W/\u0026#34;be34c7da7adc79dfee6c76195ba1dbdad7b5bc9b\u0026#34;] Server:[MYBWS/1.1] Set // -Cookie:[acw_tc=2760829816190615907855703e97def055d99950b742716bbf6b2d8e6e2288;path=/;HttpOnly;Max-Age=1800 XSRF-TOKEN=eyJpdiI6IjFPZm9TcTYzblc5c0JJMFdSSW5EZ0E9PSIsInZhbHVlIjoiTXhEbHNlbVRXelMwTnR4UE5nY1JsNTRDTEJ4SmUzaFFsQkZTak9nTEtib // m5rczF3VlF6bVE1YitjNU5EbzlXMms4bTZLV0RiRTk4WXZMSFBBMFoxQ0V0OUpuYWxwN1ppYmpydjFFUzRQWXVBbktaNW82dFNVXC9BXC9FOG9Qb094VSIsIm1hYyI6IjNmYTMyZDUyYzk0ZWY0ZjJkNzJjOGY3M2FiYWYzZDYwNTA4YjFmZTBiZTljMzI1ZTI1MzY1MGQyZDAxYjQwN2QifQ%3D%3D; expires // =Thu, 22-Apr-2021 05:19:50 GMT; Max-Age=7200; path=/ laravel_session=eyJpdiI6IlA2cXcxRHVWYVgxa3VZRnNFY09LbkE9PSIsInZhbHVlIjoiK1ptMGIwOTdZbGp5dlwvRlNMK2pWb3hLVVErV0wxOFBQSmp1dVRkWExcL1VZbm1zVFwvUmRGT0dZcXJlcTZSRmhoWk1hdkJxYU9kUUFrNjB // RK3o4cW5TanZVZXZSYjVEN29CNUU2bEVHdHVoUVVESkhJcG1ETDVCS3FSTmtwYkJTcDciLCJtYWMiOiIwMTM3NDg2NTJlNDJkMGFhN2Y0NDA2YzJhYzcyMTQ4MzY1NDU1YzlmMjYwOTUxNjM0ZDJkYjUzYWJmMmMxZTE1In0%3D; expires=Thu, 22-Apr-2021 05:19:50 GMT; Max-Age=7200; path=/ // ; httponly]] 0xc0001220a0 -1 [chunked] false true map[] 0xc00010a000 0xc00004e0b0} \u0026lt;nil\u0026gt; https://wzapi.myzx.cn/ // over } 总结 sync.WaitGroup 更多是 多个goroutine通知一个goroutine,更像是main goroutine等待集合的所有goroutine完成一项任务，多对一 sync.Cond 则更像多个goroutine等待main goroutine的工作完成，一对多，更像是广播形式 使用注意 以下使用方式是不正确的。 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;sync\u0026#34; ) func main() { var wg sync.WaitGroup // 【不能另外启动协程去执行Add()和Done()，因为main的Wait()不会阻塞等待】 go func() { for i := 0; i \u0026lt; 10; i++ { wg.Add(1)\t// (\u0026amp;wg).Add(1)\t-\u0026gt; (*WaitGroup).Add(\u0026amp;wg, 1) go func(i int) { defer wg.Done()\t// (\u0026amp;wg).Done() -\u0026gt; (*WaitGroup).Done(\u0026amp;wg) fmt.Println(i) }(i) } }() // 这里并不会阻塞等待，因为计数器为0 wg.Wait() // Output: } ","permalink":"http://localhost:1313/posts/golang/sync/waitgroup/","summary":"WaitGroup等待一组goroutine完成。","title":"sync.WaitGroup"},{"content":"基本数据类型 布尔类型 布尔型值只能是常量true或false。 1 2 3 4 5 // true 和 false 是两个无类型的布尔值 const ( true = 0 == 0 // 无类型布尔值 false = 0 != 0 // 无类型布尔值（默认值false） ) Go语言中不允许将整型强制转布尔型，也不允许将布尔型强制转整型。 如：b := (int)(false)，a := (bool)(1)这都是错误的。 布尔型无法参与数值运算，也无法与其他类型进行转换，布尔类型仅用在条件判断中。 通过指针运算(unsafe)可以实现0或1转布尔类型，反之亦然。 bool内存布局 布尔类型占一字节，也就是8bit，其在内存中存储的值是0或非0。8bit全是0表示false，其他情况表示true。 假设定义变量b，var b bool，默认值为false其内存存储为0； 给变量b赋值true，b = true，其内存设置为1。 给变量b赋值false，b = false，其内存设置为0。 布尔类型作为条件判断时，其内存值为0，则判断为true；非0则判断为false。 更多关于布尔类型的元结构类型，参看_type结构，记录着布尔型的相关参数。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 // 关于定义布尔类型示例 var b bool = false // 定义布尔类型变量b并设置其值为false var a bool // 定义布尔类型变量a并设置其值为false // --------------------------------------------------------------- // 1) 布尔值是以怎样的形式保存在内存中的 // ------------------------------------------------------- // false：在内存中存储的是0b0000_0000也就是整型0 // true： 在内存中存储的是0b0000_0001也就是整型1 // ------------------------------------------------------- // 示例中是 bool转int8类型，当然也能转其他类型 // ------------------------------------------------------- var b0 bool = false\t// 假设b0地址 0xc000014090 var b1 bool = true // *bool -\u0026gt; *int8 // i1 存储的是b0的地址0xc000014090 类型为*int8 // 注意区别：*(*int8)(unsafe.Pointer(\u0026amp;b0)) 存储的是b0的值 类型为int8 // 注意区别：(**int8)(unsafe.Pointer(\u0026amp;b0)) *bool -\u0026gt; **int8 i1 := (*int8)(unsafe.Pointer(\u0026amp;b0)) i2 := (*int8)(unsafe.Pointer(\u0026amp;b1)) fmt.Println(*i1, *i2)\t// 0 1 // --------------------------------------------------------------- // 2) 整数类型转换成布尔值是怎样个情况 // ------------------------------------------------------- // 0b0000_0000 转布尔是 false，其他全是 true // 0：转布尔是 false // 32768：(2^15)转布尔是 false // 1：转布尔是 true // 2：转布尔是 true // -1：转布尔是 true 注意转换时布尔值只需要1字节长度8bit // ------------------------------------------------------- var b0 int8 = 0 var b1 int8 = 1 i1 := (*bool)(unsafe.Pointer(\u0026amp;b0)) i2 := (*bool)(unsafe.Pointer(\u0026amp;b1)) fmt.Println(*i1, *i2)\t// false true // -------------------------------------------------------- // 3) 下面我们把其他类型转换成布尔值然后再转回之前的类型 // -------------------------------------------------------- // 以下代码说明使用unsafe转换仅仅是把第一个字节指向bool地址 // -------------------------------------------------------- // 3.1) int8 -\u0026gt; bool -\u0026gt; int8 var b0 int8 = 0 var b1 int8 = -125 // 1000 0011 i1 := (*bool)(unsafe.Pointer(\u0026amp;b0)) i2 := (*bool)(unsafe.Pointer(\u0026amp;b1)) fmt.Println(*i1, *i2)\t// false true i11 := (*int8)(unsafe.Pointer(i1)) i22 := (*int8)(unsafe.Pointer(i2)) fmt.Println(*i11, *i22)\t// 0 -125 // 3.2) int -\u0026gt; bool -\u0026gt; int var b0 int = 0 var b1 int = 55536 i1 := (*bool)(unsafe.Pointer(\u0026amp;b0)) i2 := (*bool)(unsafe.Pointer(\u0026amp;b1)) fmt.Println(*i1, *i2)\t// false true i11 := (*int)(unsafe.Pointer(i1)) i22 := (*int)(unsafe.Pointer(i2)) fmt.Println(*i11, *i22)\t// 0 55536 // 3.3) uint16 -\u0026gt; bool 修改 -\u0026gt; uint16 var b0 uint16 = 0 var b1 uint16 = 0b10000000_11111111 i1 := (*bool)(unsafe.Pointer(\u0026amp;b0)) i2 := (*bool)(unsafe.Pointer(\u0026amp;b1)) fmt.Println(*i1, *i2)\t// false true *i2 = false i11 := (*uint16)(unsafe.Pointer(i1)) i22 := (*uint16)(unsafe.Pointer(i2)) // 32768 -\u0026gt; 0b10000000_00000000 fmt.Println(*i11, *i22)\t// 0 32768 // 4) 上面发现将布尔类型赋值为false会将内存的8为bit全部设置为0，也就是85行代码处 // 那么将一个本就是布尔true类型赋值为true，内存中是否记录的大小为1？ var b1 int = 12 bb := (*bool)(unsafe.Pointer(\u0026amp;b1)) *bb = true fmt.Println(*(*int)(unsafe.Pointer(bb)))\t// 1 // 通过代码测试 布尔的赋值就是把内存中的数值false改为0 true改为1 总结： Go内存字段排序是，低字节在前高字节在后。（不同的硬件设备可能不同）。 比如33007二进制如10000000_11101111，在内存中是第一个字节11101111第二个字节10000000。 布尔类型占1字节（8bit），所有位都为0时表示false，否则表示true。 因此10000000_00000000这种形式转bool第一个字节是00000000返回false。 使用unsafe转换类型仅仅是把首字节转bool的地址。 也就是上面的33007（10000000_11101111）转bool，把11101111这个第一个字节地址给布尔值。 布尔类型在被赋值时，true会修改内存存储值为1，false会修改存储值为0。 整数类型 有符号整型 类型 长度(B/字节) 范围(科学计数) 范围 默认值 int8 1B (8bit) [-2^7, 2^7-1] [-128, 127] 0 int16 2B (16bit) [-2^15, 2^15-1] [-32768, 32767] 0 int32 4B (32bit) [-2^31, 2^31-1] [-2147483648, 2147483647] 0 int64 8B (64bit) [-2^63, 2^63-1] [-9223372036854775808, 9223372036854775807] 0 int 与系统有关，32位下4字节，64位下8字节 0 补码与源码 有符号负数类型转二进制，负数整型数值都是采用补码形式保存，当然正数的补码就是自己。 先是将对应的正整数转换成二进制后。 对二进制取反。 然后对结果再加一。 补码的运算：两个补码相加，算法与二进制加法相同，和仍然是补码（补码计算后可能存在溢出情况） 补码转源码。 正数：符号位为0时，即补码就是源码 负数：符号位为1时，即补码的补码就是源码 # -42存储形式：假设这里是int8类型 8位bit位 # 1. 42转二进制，00101010 # 2. 00101010 取反 11010101 # 3. 11010101加一，11010101 + 00000001 = 11010110\t补码 # 最终-42的二进制表示形式，11010110 # 11010110 补码转源码 # 1. 最高位为1表示负数 # 2. 11010110 取反 00101001 # 3. 00101001加一，00101001 + 00000001 = 00101010\t源码 # 总结：- 号的操作逻辑就是上面步骤2(取反)和步骤3(加一) # 最高位表示符号位 0.正数 1.负数 # 内存中都是采用补码形式存储的 1 2 3 4 5 6 7 // 验证 -42 是否是 11010110 var b0 int8 = -42 // i1 := uint8(b0) i1 := (*uint8)(unsafe.Pointer(\u0026amp;b0)) fmt.Printf(\u0026#34;%.8b\u0026#34;, *i1)\t// 11010110 例如：-1是11111111，127是01111111，最高位bit表示符号位，0表示正数(+)，1表示负数(-)。 # -1 转二进制 # 1 -\u0026gt; 00000001 # ~1 -\u0026gt; 11111110 取反 # +1\t-\u0026gt; 11111111 加一 # 127 转二进制 # 127\t-\u0026gt; 01111111 **-**号：操作在整型中的操作步骤(取反)然后(加一) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 // 在time.Duration中的String()方法中有这样一段代码 // d 为int64类型，这里正是利用了-(-42)=42, u=(-42) func (d Duration) String() string { // ... u := uint64(d) // 这里如果是负数，则转换后一定是个很大的数字 neg := d \u0026lt; 0 // neg为true表示是负数，为false表示是正数或0 if neg { u = -u // 这里再次按照负数存储形式，正数的二进制取反加1等到正数也就是(-d) } // ... } // 比如我们使用上面方法写一个abs取绝对值函数，并转换无符号类型为有符号类型 type i int64 func (i i) abs() uint64 { if i \u0026gt; 0 { return uint64(i) } return -uint64(i) } 无符号整型(unsigned) 类型 长度(B/字节) 范围 范围 默认值 uint8 1B (8bit) [0, 2^8-1] [0, 255] 0 uint16 2B (16bit) [0, 2^16-1] [0, 65535] 0 uint32 4B (32bit) [0, 2^32-1] [0, 4294967295] 0 uint64 8B (64bit) [0, 2^64-1] [0, 18446744073709551615] 0 uint 与系统有关，32位下4字节，64位下8字节 0 无符号转二进制 除二取余，然后倒序排列，高位补零 # 示例42转二进制，正整数转二进制 除二 求余 排序方向 十进制 42 || 2 | 42 .... 42/2 余 .... 0 ^ 0*2^0 = 0 |_______ + 2 | 21 .... 21/2 余 .... 1 | 1*2^1 = 2 |_______ + 2 | 10 .... 10/2 余 .... 0 | 0*2^2 = 0 |_______ + 2 | 5 .... 5/2 余 .... 1 | 1*2^3 = 8 |________ + 2 | 2 .... 2/2 余 .... 0 | 0*2^4 = 0 |________ + 1 .... 1/2 余 .... 1 | 1*2^5 = 32 # 42 对应二进制位 00101010 -\u0026gt; 0*2^0 + 1*2^1 + 0*2^2 + 1*2^3 + 0*2^4 + 1*2^5 = 42 其他整数类型 类型 等价于 长度/字节 备注 默认值 byte type byte = uint8 1B 存储一字节内容 0 rune type rune = int32 4B 存储一字符内容(Unciode编码) 0 uintptr uint 4B或8B 刚好能存储变量地址 0 1 2 3 4 5 6 7 // type byte = uint8 var b byte // 默认值 0 // type rune = int32 var r rune // 默认值 0 fmt.Printf(\u0026#34;b: %T\\n\u0026#34;, b)\t// b: uint8 fmt.Printf(\u0026#34;r: %T\\n\u0026#34;, r)\t// r: int32 浮点数类型 类型 描述 默认值 float32 IEEE-754 32位浮点型数4字节，大约存储小数位数7位（十进制科学计数法n.xxx*e+10情况下），这里的7位是x的位数 0.0 float64 IEEE-754 64位浮点型数8字节，大约存储小数位数16位（十进制科学计数法n.xxx*e+10情况下），这里的16位是x的位数 0.0 IEEE-754 浮点数在内存中如何存储 浮点数需要先转换成二进制才能存储在内存中，因此拆分成正数和小数： 对于正数部分： 按照有符号规则计算即可，比如42或-42是00101010，符号位后面单独处理 对于小数部分： 对小数点以后的数乘以2，取结果的整数部分(不是1就是0)，然后再用小数部分再乘以2，再取结果的整数部分 以此类推，直到小数部分为0或者位数已经够了就结束 然后把取的整数部分按先后次序排列，就构成了二进制小数部分的序列 # 如42.635648，处理小数部分就是0.635648 小数部位乘2 = 取正数位 排序方向 十进制 0.6328125 || 0.635648 * 2 = 1.271296 ... 取正数位 ... 1 | 2^-1 1/2 0.5 0.271296 * 2 = 0.542592 ... 取正数位 ... 0 | 0 + 0.542592 * 2 = 1.085184 ... 取正数位 ... 1 | 2^-3 1/2^3 0.125 0.085184 * 2 = 0.170368 ... 取正数位 ... 0 | 0 0.170368 * 2 = 0.340736 ... 取正数位 ... 0 | 0 + 0.340736 * 2 = 0.681472 ... 取正数位 ... 0 | 0 0.681472 * 2 = 1.362944 ... 取正数位 ... 1 v 2^-7 1/2^7 0.0078125 ... ... # 组成二进制 1010001... -\u0026gt; 2^5 + 2^3 + 2^1 + 2^-1 + 2^-3 + 2^-7 # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - # 如-0.1，处理小数部分就是0.1 小数部位乘2 = 取正数位 排序方向 十进制 0.099609375 || 0.1 * 2 = 0.2 ... 取正数位 ... 0 | 0 0.2 * 2 = 0.4 ... 取正数位 ... 0 | 0 0.4 * 2 = 0.8 ... 取正数位 ... 0 | 0 0.8 * 2 = 1.6 ... 取正数位 ... 1 | 1/2^4 0.0625 0.6 * 2 = 1.2 ... 取正数位 ... 1 | 1/2^5 0.03125 0.2 * 2 = 0.4 ... 取正数位 ... 0 | 0 + 0.4 * 2 = 0.8 ... 取正数位 ... 0 | 0 0.8 * 2 = 1.6 ... 取正数位 ... 1 | 1/2^8 0.00390625 0.6 * 2 = 1.2 ... 取正数位 ... 1 | 1/2^9 0.001953125 0.2 * 2 = 0.4 ... 取正数位 ... 0 v 0 ... ... # 组成二进制 0001100110... 然后把整数部分转二进制和小数部分转二进制加一起，如(101010.1010001...) 浮点数是如何存储在内存中 比如上面的101010.1010001...转换二进制科学计数法表示1.010101010001... * 2^5\n十进制 二进制 计算方式 二进制科学计数法表示 3.5 11.1 3.5 = 2^1 + 2^0 + 2^-1 11.1 = 1.11 * 2^1 10.625 1010.101 10.625 = 2^3 + 2^1 + 2^-1 + 2^-3 1010.101 = 1.010101 * 2^3 0.6 0.10011001.. 0.6 = 2^-1 + 2^-4 + 2^-5 + 2^-8 .. 0.100110011001.. = 1.00110011001.. * 2^-1 从上面可以观察到，对于任何数来说，表示成二进制科学计数法后，都可以转换成1.xxx * 2^n形式\n对于负数来说，则可以表示成-1.xxx * 2^n形式\n浮点数的存储形式可以分为三部分： 符号位（S） 尾数(xxx)（M） 指数(n)（E） 根据指数又分为三种类型：规格数(normal number)、非规格数(subnormal number)、特殊数(non-number)。 指数位 -\u0026gt; 全为0 不全为0且不全为1 全为1 对应的数 -\u0026gt; 非规格数(subnormal number) 规格数(normal number) 特殊数(non-number) 非规格数(subnormal number)：指数位全为0，用于表示0或非常接近0的数。 规格数(normal number)：指数位不全为0且不全为1，用于表示正常的数值。 特殊数(non-number)：指数位全为1，用于表示±infinity或NaN。 ","permalink":"http://localhost:1313/posts/golang/basic/type/","summary":"Golang 内置的基本类型介绍。","title":"内置类型"},{"content":" 🔥如果觉得我的文章对您有用，帮我买杯☕。您的支持将鼓励我继续创作。🎉🎉🎉\nwechat alipay ","permalink":"http://localhost:1313/support/","summary":" 🔥如果觉得我的文章对您有用，帮我买杯☕。您的支持将鼓励我继续创作。🎉🎉🎉\nwechat alipay ","title":"打赏"}]