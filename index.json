[{"content":"type Pool struct Pool æ˜¯ä¸€ç»„å¯ä»¥å•ç‹¬ä¿å­˜å’Œæ£€ç´¢çš„ä¸´æ—¶å¯¹è±¡ã€‚ å‚¨å­˜åœ¨ Pool ä¸­çš„ä»»ä½•ç‰©å“éƒ½å¯ä»¥åœ¨ä»»ä½•æ—¶é—´è‡ªåŠ¨ç§»é™¤ï¼Œæ— éœ€é€šçŸ¥ã€‚å¦‚æœåœ¨æ­¤å‘ç”Ÿæ—¶ Pool æŒæœ‰å”¯ä¸€çš„å¼•ç”¨ï¼Œåˆ™å¯èƒ½ä¼šé‡Šæ”¾è¯¥å…ƒç´ ã€‚ Pool å¯ä»¥è¢«å¤šä¸ªgoroutinesåŒæ—¶ä½¿ç”¨ã€‚ Pool's çš„ç›®çš„æ˜¯ç¼“å­˜å·²åˆ†é…ä½†æœªä½¿ç”¨çš„é¡¹ï¼Œä»¥ä¾¿ä»¥åé‡ç”¨ï¼Œå‡è½»åƒåœ¾æ”¶é›†å™¨çš„å‹åŠ›ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œå®ƒä½¿æ„å»ºé«˜æ•ˆçš„ã€çº¿ç¨‹å®‰å…¨çš„ç©ºé—²åˆ—è¡¨å˜å¾—å®¹æ˜“ã€‚ä½†å®ƒå¹¶ä¸é€‚ç”¨äºæ‰€æœ‰ç©ºé—²é“¾è¡¨ã€‚ Pool çš„é€‚å½“ä½¿ç”¨æ˜¯ç®¡ç†ä¸€ç»„åœ¨åŒ…çš„å¹¶å‘ç‹¬ç«‹å®¢æˆ·ç«¯ä¹‹é—´å…±äº«å’Œå¯èƒ½è¢«é‡ç”¨çš„ä¸´æ—¶é¡¹ã€‚Pool æä¾›äº†ä¸€ç§åœ¨å¤šä¸ªå®¢æˆ·ç«¯ä¹‹é—´æ‘Šé”€åˆ†é…å¼€é”€çš„æ–¹æ³•ã€‚ ä¸€ä¸ªè‰¯å¥½ä½¿ç”¨ Pool çš„ä¾‹å­æ˜¯fmtåŒ…ï¼Œå®ƒç»´æŠ¤äº†ä¸€ä¸ªåŠ¨æ€å¤§å°çš„ä¸´æ—¶è¾“å‡ºç¼“å†²åŒºå­˜å‚¨ã€‚storeåœ¨è´Ÿè½½ä¸‹æ‰©å±•(å½“è®¸å¤šgoroutinesæ­£åœ¨ç§¯ææ‰“å°æ—¶)ï¼Œåœ¨é™é»˜æ—¶æ”¶ç¼©ã€‚ å¦ä¸€æ–¹é¢ï¼Œä½œä¸ºç”Ÿå­˜æœŸè¾ƒçŸ­çš„å¯¹è±¡çš„ä¸€éƒ¨åˆ†ç»´æŠ¤çš„ç©ºé—²åˆ—è¡¨ä¸é€‚åˆç”¨äº Poolï¼Œå› ä¸ºåœ¨è¿™ç§æƒ…å†µä¸‹å¼€é”€ä¸èƒ½å¾ˆå¥½åœ°åˆ†æ‘Šã€‚ åœ¨ç¬¬ä¸€æ¬¡ä½¿ç”¨åï¼Œä¸èƒ½å¤åˆ¶æ± ã€‚ sync.Pool æ˜¯åç¨‹å®‰å…¨çš„ï¼Œä½¿ç”¨å‰ï¼Œè®¾ç½®å¥½å¯¹è±¡çš„ New å‡½æ•°ï¼Œç”¨åœ¨ Pool é‡Œæ²¡æœ‰ç¼“å­˜çš„å¯¹è±¡æ—¶ï¼Œåˆ›å»ºä¸€ä¸ªã€‚ä¹‹ååœ¨ç¨‹åºçš„ä»»ä½•åœ°æ–¹ã€ä»»ä½•æ—¶å€™ä»…é€šè¿‡ Get() å’Œ Put() æ–¹æ³•å°±å¯ä»¥å–å’Œè¿˜å¯¹è±¡äº† 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 // A Pool is a set of temporary objects that may be individually saved and // retrieved. // // Any item stored in the Pool may be removed automatically at any time without // notification. If the Pool holds the only reference when this happens, the // item might be deallocated. // // A Pool is safe for use by multiple goroutines simultaneously. // // Pool\u0026#39;s purpose is to cache allocated but unused items for later reuse, // relieving pressure on the garbage collector. That is, it makes it easy to // build efficient, thread-safe free lists. However, it is not suitable for all // free lists. // // An appropriate use of a Pool is to manage a group of temporary items // silently shared among and potentially reused by concurrent independent // clients of a package. Pool provides a way to amortize allocation overhead // across many clients. // // An example of good use of a Pool is in the fmt package, which maintains a // dynamically-sized store of temporary output buffers. The store scales under // load (when many goroutines are actively printing) and shrinks when // quiescent. // // On the other hand, a free list maintained as part of a short-lived object is // not a suitable use for a Pool, since the overhead does not amortize well in // that scenario. It is more efficient to have such objects implement their own // free list. // // A Pool must not be copied after first use. type Pool struct { // ä½¿å¾—å†…åµŒäº†noCopyçš„å¯¹è±¡åœ¨è¿›è¡Œgo veté™æ€æ£€æŸ¥çš„æ—¶å€™ï¼Œå¯ä»¥æ£€æŸ¥å‡ºæ˜¯å¦è¢«å¤åˆ¶ noCopy noCopy // è®¿é—®æ—¶æ ¹æ®Pçš„idå»è®¿é—®å¯¹åº”ä¸‹æ ‡çš„local[pid] // é€šè¿‡è¿™æ ·çš„è®¾è®¡ï¼Œå¤šä¸ªgoroutineä½¿ç”¨åŒä¸€ä¸ªPoolæ—¶ï¼Œå‡å°‘äº†ç«äº‰ï¼Œæå‡äº†æ€§èƒ½ // localå­—æ®µæŒ‡å‘å­˜å‚¨[P]poolloaclæ•°ç»„çš„æŒ‡é’ˆï¼Œç±»å‹ä¸º[P]poolLocal // // local æ˜¯ [P]poolLocal æ•°ç»„çš„é¦–åœ°å€ // P æ˜¯å½“å‰Pçš„æ•°é‡ï¼Œä¸€èˆ¬é»˜è®¤ä¸ºCPUçš„æ ¸æ•° local unsafe.Pointer // local fixed-size per-P pool, actual type is [P]poolLocal // localSize æ˜¯ä¸Šé¢ local æ•°ç»„çš„å¤§å° // æ ¹æ® localSize åˆ¤æ–­æ˜¯å¦åˆå§‹åŒ–ï¼Œpidä¸ºPçš„idæ”¹å€¼æ˜¯ä¸€ä¸ª0çš„é€’å¢å€¼ // 1. localSize ä¸º0æ—¶ï¼Œæ²¡æœ‰åˆå§‹åŒ– // 2. localSize \u0026lt;= pid æ—¶ï¼Œå¯èƒ½æ˜¯æ²¡æœ‰åˆå§‹åŒ–ï¼Œä¹Ÿå¯èƒ½æ˜¯Pçš„æ•°é‡å‘ç”Ÿäº†å˜åŒ–ï¼Œå˜å¤šäº† localSize uintptr // size of the local array // victim å’Œ victimSize ä½œä¸ºæ¬¡çº§ç¼“å­˜ä½¿ç”¨ï¼ŒGCæ—¶å°†å¯¹è±¡æ”¾å…¥å…¶ä¸­ï¼Œä¸‹ä¸€æ¬¡GCæ¥ä¸´ä¹‹å‰å¦‚æœæœ‰Getè°ƒç”¨åˆ™ä¼šä»p.victimä¸­å–ï¼Œç›´åˆ°å†ä¸€æ¬¡GCæ¥æ—¶å›æ”¶ // ä» p.victim ä¸­å–å‡ºå¯¹è±¡ä½¿ç”¨å®Œæ¯•ä¹‹åå¹¶æœªè¿”å› p.victim ä¸­ï¼ˆè€Œæ˜¯æ”¾å›p.localï¼‰ä¸­ï¼Œåœ¨ä¸€å®šç¨‹åº¦ä¸Šä¹Ÿå‡å°äº†ä¸‹ä¸€æ¬¡GCçš„å¼€é”€ // åŸæ¥1æ¬¡GCçš„å¼€é”€è¢«æ‹‰é•¿åˆ°2æ¬¡åˆ‡ä¼šæœ‰ä¸€å®šç¨‹åº¦çš„å¼€é”€å‡å°ï¼Œè¿™å°±æ˜¯ p.victim å¼•å…¥çš„æ„å›¾ // victim å’Œ victimSize ä¼šåœ¨ä¸€è½®GCåˆ°æ¥æ—¶ï¼Œåˆ†åˆ«\u0026#34;æ¥ç®¡\u0026#34; local å’Œ localSize // victim çš„æœºåˆ¶ç”¨äºå‡å°‘GCåå†·å¯åŠ¨å¯¼è‡´çš„æ€§èƒ½æŠ–åŠ¨ï¼Œè®©åˆ†é…å¯¹è±¡æ›´å¹³æ»‘ // sync.Pool å¼•å…¥çš„æ„å›¾åœ¨äºé™ä½GCå‹åŠ›çš„åŒæ—¶æé«˜å‘½ä¸­ç‡ victim unsafe.Pointer // local from previous cycle æ¥è‡ªä¸Šä¸€ä¸ªå‘¨æœŸçš„local victimSize uintptr // size of victims array\tæ¥è‡ªä¸Šä¸€ä¸ªå‘¨æœŸçš„localçš„å¤§å° // New optionally specifies a function to generate // a value when Get would otherwise return nil. // It may not be changed concurrently with calls to Get. // // Newå¯é€‰åœ°æŒ‡å®šä¸€ä¸ªå‡½æ•°ï¼Œç”¨äºåœ¨Getè¿”å›nilæ—¶ç”Ÿæˆä¸€ä¸ªå€¼ã€‚ // å®ƒä¸èƒ½åœ¨è°ƒç”¨Getæ—¶åŒæ—¶æ”¹å˜ã€‚ New func() any\t// æˆ‘ä»¬æŒ‡å®šçš„æ–°å»ºå¯¹è±¡çš„æ–¹æ³• } // \u0026gt; ----------------------------------------------------------------------------------- type poolLocal struct { poolLocalInternal\t// 32 bytes // Prevents false sharing on widespread platforms with // 128 mod (cache line size) = 0 . // // å°†poolLocalè¡¥é½è‡³128å­—èŠ‚ï¼ˆå³ä¸¤ä¸ªcache lineï¼‰çš„å€æ•°ï¼Œé˜²æ­¢false sharingä¼ªå…±äº« // ä»…å ä½ç”¨ï¼Œé˜²æ­¢åœ¨cache lineä¸Šåˆ†é…å¤šä¸ª poolLocalInternal // ç¡®ä¿CPUç¼“å­˜æœºåˆ¶ä¸åŒï¼Œä¸€èˆ¬å»ºè®®ç¡®ä¿æœ‰128å­—èŠ‚è·ç¦» pad [128 - unsafe.Sizeof(poolLocalInternal{})%128]byte\t// ä½¿poolLocalæ€»å…±å 128å­—èŠ‚ // CPU Cache // ç°ä»£cpuä¸­ï¼Œcacheéƒ½åˆ’åˆ†æˆä»¥cache line(cache block)ä¸ºå•ä½ï¼Œåœ¨x86_64ä½“ç³»ä¸‹ä¸€èˆ¬éƒ½æ˜¯64å­—èŠ‚ï¼Œcache lineæ˜¯æ“ä½œçš„æœ€å°å•å…ƒ // ç¨‹åºå³ä½¿åªæƒ³è¯»å†…å­˜ä¸­çš„1ä¸ªå­—èŠ‚æ•°æ®ï¼Œä¹Ÿè¦åŒæ—¶æŠŠé™„è¿‘63èŠ‚å­—åŠ è½½åˆ°cacheä¸­ï¼Œå¦‚æœè¯»å–è¶…ä¸ª64å­—èŠ‚ï¼Œé‚£ä¹ˆå°±è¦åŠ è½½åˆ°å¤šä¸ªcache lineä¸­ // è¿™æ ·ï¼Œè®¿é—®åç»­63å­—èŠ‚æ•°æ®æ—¶å°±å¯ä»¥ç›´æ¥ä»cache lineä¸­è¯»å–ï¼Œæ€§èƒ½æœ‰å¾ˆå¤§æå‡ // false sharing // ä¼ªå…±äº«çš„éæ ‡å‡†å®šä¹‰ä¸ºï¼š // ç¼“å­˜ç³»ç»Ÿä¸­æ˜¯ä»¥ç¼“å­˜è¡Œï¼ˆcache lineï¼‰ä¸ºå•ä½å­˜å‚¨çš„ï¼Œå½“å¤šçº¿ç¨‹ä¿®æ”¹äº’ç›¸ç‹¬ç«‹çš„å˜é‡æ—¶ï¼Œå¦‚æœè¿™äº›å˜é‡å…±äº«åŒä¸€ä¸ªç¼“å­˜è¡Œï¼Œ // å°±ä¼šä»¤æ•´ä¸ª cache line å¤±æ•ˆï¼Œæ— æ„ä¸­å½±å“å½¼æ­¤çš„æ€§èƒ½ï¼Œè¿™å°±æ˜¯ä¼ªå…±äº« // å¦‚æœæ²¡ç”¨padå­—æ®µæ—¶ï¼Œé‚£ä¹ˆå½“éœ€è¦è®¿é—®0å·ç´¢å¼•çš„poolLocalæ—¶ï¼ŒCPUåŒæ—¶ä¼šæŠŠ0å·å’Œ1å·ç´¢å¼•åŒæ—¶åŠ è½½åˆ°cpu cacheï¼Œåœ¨åªä¿®æ”¹0å·ç´¢å¼•çš„æƒ…å†µä¸‹ï¼Œ // ä¼šè®©1å·ç´¢å¼•çš„poolLocalå¤±æ•ˆã€‚è¿™æ ·ï¼Œå½“å…¶ä»–çº¿ç¨‹æƒ³è¦è¯»å–1å·ç´¢å¼•æ—¶ï¼Œå‘ç”Ÿcache missï¼Œè¿˜å¾—é‡æ–°å†åŠ è½½ï¼Œå¯¹æ€§èƒ½æœ‰æŸï¼Œ // å¢åŠ ä¸€ä¸ªpadï¼Œè¡¥é½ç¼“å­˜è¡Œï¼Œè®©ç›¸å…³çš„å­—æ®µèƒ½ç‹¬ç«‹åœ°åŠ è½½åˆ°ç¼“å­˜è¡Œå°±ä¸ä¼šå‡ºç°false shardingäº† } // \u0026gt; ----------------------------------------------------------------------------------- // Local per-P Pool appendix. type poolLocalInternal struct { // privateåªæœ‰å½“å‰Pèƒ½ç”¨ private any // Can be used only by the respective P. // å…¶ä»–Péƒ½å¯ä»¥ç”¨ï¼Œå½“privateæ²¡æœ‰æ—¶ä¼˜å…ˆå»å½“å‰Pçš„local.sharedä¸­å–ï¼Œå¦‚æœè¿˜æ²¡æœ‰å°±å»å…¶ä»–Pä¸­çš„local.sharedä¸­çªƒå–ä¸€ä¸ªæ¥ç”¨ shared poolChain // Local P can pushHead/popHead; any P can popTail. } Variables å…¨å±€å˜é‡ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 var ( allPoolsMu Mutex\t// å…¨å±€äº’æ–¥é” // allPools is the set of pools that have non-empty primary // caches. Protected by either 1) allPoolsMu and pinning or 2) // STW. // // allPools æ˜¯å…·æœ‰éç©ºä¸»é”®ç¼“å­˜çš„ pool é›†åˆ // å—ä»»ä½•ä¸€æ–¹ä¿æŠ¤ 1) allPoolsMu å’Œ pinning 2) STW // åœ¨Getå‡½æ•°ä¸­ï¼Œåˆå§‹åŒ–æ—¶è¢«ä¿å­˜åœ¨è¿™é‡Œ allPools []*Pool\t// ä¿å­˜æ¥è‡ªç”¨æˆ·åˆ›å»ºçš„Poolå®ä¾‹ï¼Œç”¨æˆ·ç«¯å¯èƒ½åˆ›å»ºå¤šä¸ªPoolï¼Œæ¯”å¦‚fmtåŒ…åˆ›å»ºçš„Poolä¹Ÿä¼šä¿å­˜åœ¨è¿™é‡Œ // oldPools is the set of pools that may have non-empty victim // caches. Protected by STW. // // oldPoolsæ˜¯ä¸€ç»„å¯èƒ½å…·æœ‰éç©ºvictim cachesçš„æ± ã€‚å—STWä¿æŠ¤ã€‚ // åœ¨GCå¼€å§‹æ—¶ï¼Œä¿å­˜allPoolsä¸­çš„å€¼ oldPools []*Pool\t// oldPoolsåªæ˜¯ä¿å­˜äº† allPools çš„å€¼ï¼Œå¯è§æ˜¯é˜²æ­¢è¢«GCå›æ”¶ç›¸å…³æ•°æ® ) type poolLocal struct æœ¬åœ° Poolï¼Œå¯¹é½Cache lineçš„å€æ•°ã€‚ 1 2 3 4 5 6 7 8 9 type poolLocal struct { poolLocalInternal // Prevents false sharing on widespread platforms with // 128 mod (cache line size) = 0 . // // ç”¨ 128 mod (cache line size) = 0 é˜²æ­¢åœ¨å¹¿æ³›ä¼ æ’­çš„å¹³å°ä¸Š false sharingã€‚ pad [128 - unsafe.Sizeof(poolLocalInternal{})%128]byte } type poolLocalInternal struct 1 2 3 4 5 6 7 8 9 // Local per-P Pool appendix. type poolLocalInternal struct { // private ç§æœ‰çš„ï¼Œåªèƒ½ç”±ç›¸åº”çš„Pä½¿ç”¨ã€‚ private any // Can be used only by the respective P. // shared å…±äº«çš„ï¼Œlocal P å¯ä»¥ pushHead/popHead; ä»»ä½•På¯ä»¥ popTail // å½“å½“å‰Pçš„privateæ²¡æœ‰ï¼Œé‚£ä¹ˆä¼˜å…ˆä»å½“å‰Pçš„sharedä¸­å–ï¼Œè¿˜æ²¡æœ‰åˆ™ä»å…¶ä»–Pçš„sharedä¸­å–ï¼Œ // è¿˜æ˜¯æ²¡æœ‰å¦‚æœNewå‡½æ•°å­˜åœ¨åˆ™ä½¿ç”¨è¯¥å‡½æ•°ç”Ÿæˆ shared poolChain // Local P can pushHead/popHead; any P can popTail. } type poolChain struct poolChainæ˜¯poolDequeueçš„åŠ¨æ€ç‰ˆæœ¬ã€‚ å‚çœ‹ poolqueue.go æ–‡æ¡£ã€‚ï¼ˆç¬¬äºŒç¯‡ä¸­ä»‹ç»ï¼‰ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // poolChain is a dynamically-sized version of poolDequeue. // // This is implemented as a doubly-linked list queue of poolDequeues // where each dequeue is double the size of the previous one. Once a // dequeue fills up, this allocates a new one and only ever pushes to // the latest dequeue. Pops happen from the other end of the list and // once a dequeue is exhausted, it gets removed from the list. type poolChain struct { // head is the poolDequeue to push to. This is only accessed // by the producer, so doesn\u0026#39;t need to be synchronized. head *poolChainElt // tail is the poolDequeue to popTail from. This is accessed // by consumers, so reads and writes must be atomic. tail *poolChainElt } Pool Methods Get() ä¼˜å…ˆä»å½“å‰ P çš„ local.private ä¸­å–ï¼Œæ²¡æœ‰åˆ™ä»å½“å‰ P çš„ local.shared ä¸­å–ï¼Œè¿˜æ²¡æœ‰åˆ™å»å…¶ä»– P ä¸­ local.shared ä¸­çªƒå–ä¸€ä¸ª è°ƒç”¨è€…ä¸åº”è¯¥è®¤ä¸ºGetçš„è¿”å›å€¼å’Œä¼ é€’ç»™Putå€¼ä¹‹é—´æœ‰ä»»ä½•å…³ç³» å‡å¦‚Getæ–¹æ³•æ²¡æœ‰å–å¾— itemï¼Œå¦‚ p.New é nilï¼ŒGetè¿”å›è°ƒç”¨ p.New çš„ç»“æœï¼›å¦åˆ™è¿”å›nil 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 // Get selects an arbitrary item from the Pool, removes it from the // Pool, and returns it to the caller. // Get may choose to ignore the pool and treat it as empty. // Callers should not assume any relation between values passed to Put and // the values returned by Get. // // If Get would otherwise return nil and p.New is non-nil, Get returns // the result of calling p.New. func (p *Pool) Get() any { if race.Enabled { race.Disable() } l, pid := p.pin()\t// è¿”å›å½“å‰å·¥ä½œçº¿ç¨‹æ‰€åœ¨çš„*poolLocalå’Œpid x := l.private\t// å–å½“å‰privateä¸Šæ•°æ® l.private = nil\t// å¹¶æ¸…é›¶private // å¦‚æœ local private æ²¡æœ‰ if x == nil {\t// Try to pop the head of the local shard. We prefer // the head over the tail for temporal locality of // reuse. // // å°è¯•ä»local shardçš„headå–å‡ºã€‚å¯¹äºé‡å¤ä½¿ç”¨ä¸€æ—¶çš„localityæˆ‘ä»¬æ›´å–œæ¬¢headè€Œä¸æ˜¯tail x, _ = l.shared.popHead()\t// å°è¯•ä»sharedçš„headå¼¹å‡ºä¸€ä¸ªæ•°æ® if x == nil { x = p.getSlow(pid)\t// å¦‚æœä¸Šé¢è¿˜æœªç©ºï¼Œåˆ™å»å…¶ä»–Pä¸­å·å–ï¼Œæˆ–ä»victim cacheå»æ‹¿å» } } runtime_procUnpin()\t// å…è®¸å½“å‰å·¥ä½œçº¿ç¨‹è¢«æŠ¢å  if race.Enabled { race.Enable() if x != nil { race.Acquire(poolRaceAddr(x)) } } // å¦‚æœä¸Šé¢éƒ½æ²¡æœ‰æ‹¿åˆ°æ•°æ®å¹¶ä¸”åˆå®šä¹‰äº†Newæ–¹æ³•è°ƒç”¨è¯¥æ–¹æ³•åˆ›å»ºæ•°æ® if x == nil \u0026amp;\u0026amp; p.New != nil {\tx = p.New() } return x } pin() pin å°†å½“å‰ goroutine å›ºå®šåˆ° Pï¼Œç¦ç”¨æŠ¢å å¹¶ä¸º P å’Œ P çš„idè¿”å› poolLocalæ± ã€‚ è°ƒç”¨è€…åœ¨å¤„ç†æ± æ—¶å¿…é¡»è°ƒç”¨runtime_procUnpin()ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 // pin pins the current goroutine to P, disables preemption and // returns poolLocal pool for the P and the P\u0026#39;s id. // Caller must call runtime_procUnpin() when done with the pool. func (p *Pool) pin() (*poolLocal, int) { // è¯¥å‡½æ•°ä¸»è¦ä½œç”¨æ˜¯åŠ é”Mç¦æ­¢å½“å‰Mè¢«æŠ¢å ï¼Œç„¶åè¿”å›Mæ­£ç»‘å®šçš„Pçš„id pid := runtime_procPin()\t// In pinSlow we store to local and then to localSize, here we load in opposite order. // Since we\u0026#39;ve disabled preemption, GC cannot happen in between. // Thus here we must observe local at least as large localSize. // We can observe a newer/larger local, it is fine (we must observe its zero-initialized-ness). // // åœ¨pinSlowä¸­ï¼Œæˆ‘ä»¬å­˜å‚¨åˆ°localï¼Œç„¶åå­˜å‚¨åˆ°localSizeï¼Œåœ¨è¿™é‡Œæˆ‘ä»¬æŒ‰ç›¸åçš„é¡ºåºåŠ è½½ã€‚ // å› ä¸ºæˆ‘ä»¬å·²ç»ç¦ç”¨äº†æŠ¢å ï¼Œæ‰€ä»¥GCä¸èƒ½åœ¨è¿™ä¸¤è€…ä¹‹é—´å‘ç”Ÿã€‚ // å› æ­¤ï¼Œè¿™é‡Œæˆ‘ä»¬å¿…é¡»æ³¨æ„localè‡³å°‘ä¸ºlarge localSizeã€‚ // æˆ‘ä»¬å¯ä»¥è§‚å¯Ÿåˆ°ä¸€ä¸ª æ›´æ–°/æ›´å¤§ çš„ localï¼Œè¿™æ˜¯æ²¡é—®é¢˜çš„(æˆ‘ä»¬å¿…é¡»è§‚å¯Ÿåˆ°å®ƒçš„é›¶åˆå§‹åŒ–)ã€‚ s := runtime_LoadAcquintptr(\u0026amp;p.localSize) // load-acquire;\tåŸå­è¯»å–p.localSizeå€¼ l := p.local // load-consume;\tå­˜å‚¨æ•°æ®çš„æ•°ç»„åœ°å€ // uintptr(pid) \u0026gt;= s; å¯èƒ½ 1)æ²¡æœ‰åˆå§‹åŒ–è¿‡ 2)Pçš„æ•°é‡å˜å¤šäº† if uintptr(pid) \u0026lt; s { return indexLocal(l, pid), pid } return p.pinSlow()\t// åˆå§‹åŒ–å» } // \u0026gt; --------------------------------------------------------------------------------- // go1.19.3/src/runtime/proc.go //go:linkname sync_runtime_procPin sync.runtime_procPin //go:nosplit func sync_runtime_procPin() int { return procPin() } // \u0026gt; --------------------------------------------------------------------------------- // go1.19.3/src/runtime/proc.go //go:nosplit func procPin() int { _g_ := getg() mp := _g_.m mp.locks++ return int(mp.p.ptr().id) } // \u0026gt; --------------------------------------------------------------------------------- // go1.19.3/src/runtime/proc.go //go:linkname sync_runtime_procUnpin sync.runtime_procUnpin //go:nosplit func sync_runtime_procUnpin() { procUnpin() } // \u0026gt; --------------------------------------------------------------------------------- // go1.19.3/src/runtime/proc.go //go:nosplit func procUnpin() { _g_ := getg() _g_.m.locks-- } // \u0026gt; --------------------------------------------------------------------------------- // go1.19.3/src/sync/pool.go //go:linkname runtime_LoadAcquintptr runtime/internal/atomic.LoadAcquintptr func runtime_LoadAcquintptr(ptr *uintptr) uintptr // \u0026gt; --------------------------------------------------------------------------------- // go1.19.3/src/runtime/proc.go // læ˜¯p.localï¼Œiæ˜¯pid func indexLocal(l unsafe.Pointer, i int) *poolLocal { // è·å–åˆ°iä¸‹æ ‡çš„æ•°æ®åœ°å€ lp := unsafe.Pointer(uintptr(l) + uintptr(i)*unsafe.Sizeof(poolLocal{})) return (*poolLocal)(lp) } pinSlow() pinSlow ä¸»è¦æ˜¯å®Œæˆ pool.local çš„åˆå§‹åŒ–åˆ›å»º 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 func (p *Pool) pinSlow() (*poolLocal, int) { // Retry under the mutex. // Can not lock the mutex while pinned. runtime_procUnpin() allPoolsMu.Lock()\tdefer allPoolsMu.Unlock()\tpid := runtime_procPin()\t// poolCleanup won\u0026#39;t be called while we are pinned. s := p.localSize l := p.local // å†æ¬¡æ£€æŸ¥çš„æ„ä¹‰åœ¨äºï¼Œå¯èƒ½å‡ºç°æ­¤æ—¶Poolå·²ç»è¢«åˆå§‹åŒ– if uintptr(pid) \u0026lt; s { return indexLocal(l, pid), pid } if p.local == nil { // æ–°åˆå§‹åŒ–çš„Poolè®°å½•åˆ°allPools allPools = append(allPools, p)\t// allPoolsæ˜¯å­˜å‚¨[]*Poolåˆ‡ç‰‡ } // If GOMAXPROCS changes between GCs, we re-allocate the array and lose the old one. // å¦‚æœ GOMAXPROCS åœ¨ GC ä¹‹é—´å‘ç”Ÿå˜åŒ–ï¼Œæˆ‘ä»¬å°†é‡æ–°åˆ†é…æ•°ç»„å¹¶ä¸¢å¤±æ—§æ•°ç»„ // runtime.GOMAXPROCS å‡½æ•° å‚æ•°æ˜¯0æˆ–åŸå¤§å°å€¼ç›´æ¥è¿”å›CPUä¸­æ•°é‡ï¼Œå…¶ä»–åˆ™ä¿®æ”¹Pçš„æ•°é‡ size := runtime.GOMAXPROCS(0)\t// è¿”å›Pçš„æ€»æ•°é‡ local := make([]poolLocal, size)\t// åˆ›å»ºpoolLocalç±»å‹åˆ‡ç‰‡ï¼Œé•¿åº¦å’Œå®¹é‡éƒ½ä¸ºsize atomic.StorePointer(\u0026amp;p.local, unsafe.Pointer(\u0026amp;local[0])) // store-release runtime_StoreReluintptr(\u0026amp;p.localSize, uintptr(size)) // store-release return \u0026amp;local[pid], pid } // \u0026gt; --------------------------------------------------------------------------------- //go:linkname runtime_StoreReluintptr runtime/internal/atomic.StoreReluintptr func runtime_StoreReluintptr(ptr *uintptr, val uintptr) uintptr getSlow() ä»å…¶ä»– P çš„ share ä¸­å»å·å–å…ƒç´  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 func (p *Pool) getSlow(pid int) any { // See the comment in pin regarding ordering of the loads. // è¯·å‚é˜…pinä¸­å…³äºè´Ÿè½½æ’åºçš„æ³¨é‡Šã€‚ // åŸå­è¯»å– p.localSize size := runtime_LoadAcquintptr(\u0026amp;p.localSize) // load-acquire locals := p.local // load-consume // Try to steal one element from other procs. // å°è¯•ä»å…¶ä»–è¿›ç¨‹ä¸­çªƒå–ä¸€ä¸ªå…ƒç´ ã€‚ for i := 0; i \u0026lt; int(size); i++ { // å·å–é¡ºåºä»å½“å‰Pçš„ä¸‹ä¸€ä¸ªPå¼€å§‹éå†ä¸€åœˆ l := indexLocal(locals, (pid+i+1)%int(size))\tif x, _ := l.shared.popTail(); x != nil { return x } } // Try the victim cache. We do this after attempting to steal // from all primary caches because we want objects in the // victim cache to age out if at all possible. // // è¯•è¯• victim cacheã€‚æˆ‘ä»¬è¯•å›¾ä»æ‰€æœ‰primary cachesä¸­çªƒå–æ•°æ®åæ‰è¿™æ ·åšï¼Œ // å› ä¸ºæˆ‘ä»¬å¸Œæœ›victim cacheä¸­çš„å¯¹è±¡å°½å¯èƒ½çš„è¿‡æœŸ size = atomic.LoadUintptr(\u0026amp;p.victimSize)\t// åŸå­è¯»å–victimSize if uintptr(pid) \u0026gt;= size { return nil } locals = p.victim l := indexLocal(locals, pid)\t// å–å‡ºpidå¯¹åº”Pool // å…ˆä» private ä¸­å– if x := l.private; x != nil { l.private = nil return x } // ä»å…¶ä»–Pçš„ share ä¸­å– for i := 0; i \u0026lt; int(size); i++ { l := indexLocal(locals, (pid+i)%int(size)) if x, _ := l.shared.popTail(); x != nil { return x } } // Mark the victim cache as empty for future gets don\u0026#39;t bother // with it. // // å°† victim cache æ ‡è®°ä¸ºç©ºï¼Œä»¥ä¾¿å°†æ¥è·å–ï¼Œä¸è¦è´¹å¿ƒå¤„ç†å®ƒã€‚ atomic.StoreUintptr(\u0026amp;p.victimSize, 0) return nil } indexLocal() 1 2 3 4 func indexLocal(l unsafe.Pointer, i int) *poolLocal { lp := unsafe.Pointer(uintptr(l) + uintptr(i)*unsafe.Sizeof(poolLocal{})) return (*poolLocal)(lp) } Put() Putæ–¹æ³•å°†xæ”¾å…¥ pool ä¸­ æŠŠ x æ”¾å…¥æ± å­ä¸­æ—¶ï¼Œå»ºè®®æ¸…é™¤ä¸Šé¢ç›¸å…³æ•°æ® 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 // Put adds x to the pool. func (p *Pool) Put(x any) { if x == nil { return } if race.Enabled { if fastrandn(4) == 0 { // Randomly drop x on floor. return } race.ReleaseMerge(poolRaceAddr(x)) race.Disable() } // è·å– P å¯¹åº”çš„ *poolLocal l, _ := p.pin() // å¦‚æœå½“å‰privateä¸ºnilåˆ™æŠŠè¿™ä¸ªå­˜å‚¨åœ¨è¿™é‡Œï¼Œç­‰å¾…ä¸‹æ¬¡ä¼˜å…ˆè¢«ä½¿ç”¨ if l.private == nil { l.private = x x = nil } if x != nil {\t// è¿™ç§æƒ…å†µæ˜¯privateå·²ç»æœ‰æ•°æ®äº†ï¼Œåˆ™æ”¾å…¥sharedé˜Ÿåˆ—ä¸­ l.shared.pushHead(x) } runtime_procUnpin()\t// å…è®¸å½“å‰å·¥ä½œçº¿ç¨‹è¢«æŠ¢å ï¼ŒåŸå› æ˜¯pinå‡½æ•°é‡Œé¢åŠ äº†é”çš„è¿™é‡Œéœ€è¦è§£é” if race.Enabled { race.Enable() } } init() æ³¨å†Œ poolCleanup å‡½æ•°ï¼Œåœ¨GCå¼€å§‹æ—¶è°ƒç”¨ å¯¹äº Pool è€Œè¨€ï¼Œå¹¶ä¸èƒ½æ— é™æ‰©å±•ï¼Œå¦åˆ™å¯¹è±¡å ç”¨å†…å­˜å¤ªå¤šä¼šå¼•èµ·å†…å­˜æº¢å‡ºï¼ˆå‡ ä¹æ‰€æœ‰çš„æ± æŠ€æœ¯ä¸­éƒ½ä¼šåœ¨æŸä¸ªæ—¶åˆ»æ¸…ç©ºæˆ–æ¸…é™¤éƒ¨åˆ†ç¼“å­˜å¯¹è±¡ã€‚Goå‘ç”Ÿåœ¨GCæ—¶æ¸…é™¤éƒ¨åˆ†å†…å­˜ï¼‰ åœ¨ pool.go æ–‡ä»¶çš„ init å‡½æ•°é‡Œï¼Œæ³¨å†ŒGCå‘ç”Ÿæ—¶ï¼Œå¦‚ä½•æ¸…ç† Pool çš„å‡½æ•° poolCleanup 1 2 3 4 5 6 7 8 9 10 11 12 func init() { runtime_registerPoolCleanup(poolCleanup) } // go1.19.3/src/runtime/mgc.go //go:linkname sync_runtime_registerPoolCleanup sync.runtime_registerPoolCleanup func sync_runtime_registerPoolCleanup(f func()) { poolcleanup = f } // go1.19.3/src/runtime/mgc.go var poolcleanup func() ä½¿ç”¨ç¤ºä¾‹ Poolï¼šæ˜¯ä¸€ä¸ªå¯ä»¥åˆ†åˆ«å­˜å–çš„ä¸´æ—¶å¯¹è±¡çš„é›†åˆ Poolï¼šä¸­ä¿å­˜çš„ä»»ä½• item éƒ½å¯èƒ½éšæ—¶ä¸åšé€šå‘Šçš„é‡Šæ”¾æ‰ å¦‚æœPoolæŒæœ‰è¯¥å¯¹è±¡çš„å”¯ä¸€å¼•ç”¨ï¼Œè¿™ä¸ª item å°±å¯èƒ½è¢«å›æ”¶ Poolï¼šå¯ä»¥å®‰å…¨çš„è¢«å¤šä¸ªçº¿ç¨‹åŒæ—¶ä½¿ç”¨ Poolï¼šçš„ç›®çš„æ˜¯ç¼“å­˜ç”³è¯·ä½†æœªä½¿ç”¨ item ç”¨äºä¹‹åçš„é‡ç”¨ï¼Œå·²å‡è½»GCçš„å‹åŠ› ä¹Ÿå°±æ˜¯è¯´ï¼Œè®©åˆ›å»ºé«˜æ•ˆè€Œçº¿ç¨‹å®‰å…¨çš„ç©ºé—²åˆ—è¡¨æ›´å®¹æ˜“ ä½†Poolå¹¶ä¸é€‚åˆç”¨äºå¤šæœ‰ç©ºé—²åˆ—è¡¨ Poolï¼šçš„åˆç†ç”¨æ³•æ˜¯ç”¨äºç®¡ç†ä¸€ç»„é™é™çš„è¢«å¤šä¸ªç‹¬ç«‹å¹¶å‘çº¿ç¨‹å…±äº«å¹¶å¯èƒ½é‡ç”¨çš„ä¸´æ—¶ item Poolæä¾›äº†è®©å¤šä¸ªçº¿ç¨‹åˆ†æ‘Šå†…å­˜ç”³è¯·æ¶ˆè€—çš„æ–¹æ³• Poolï¼šçš„ä¸€ä¸ªå¥½ä¾‹å­åœ¨fmtåŒ…é‡Œé¢ è¯¥Poolç»´æŠ¤ä¸€ä¸ªåŠ¨æ€å¤§å°çš„ä¸´æ—¶è¾“å‡ºç¼“å­˜ä»“åº“ è¯¥åˆ›åº“ä¼šåœ¨è¿‡è½½ï¼ˆè®¸å¤šçº¿ç¨‹æ´»è·ƒçš„æ‰“å°æ—¶ï¼‰å¢å¤§ï¼Œåœ¨æ²‰å¯‚æ—¶ç¼©å° å¦ä¸€æ–¹é¢ï¼Œç®¡ç†è¿™çŸ­å¯¿å‘½å¯¹è±¡çš„ç©ºé—²åˆ—è¡¨ä¸é€‚åˆä½¿ç”¨Pool å› ä¸ºè¿™ç§æƒ…å†µä¸‹å†…å­˜ç”³è¯·æ¶ˆè€—ä¸èƒ½å¾ˆå¥½çš„åˆ†é… è¿™æ—¶åº”è¯¥ç”±è¿™äº›å¯¹è±¡è‡ªå·±å®ç°ç©ºé—²åˆ—è¡¨ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;sync\u0026#34; ) var pool *sync.Pool type Person struct { Name string } func initPool() { pool = \u0026amp;sync.Pool { New: func() interface{} { fmt.Println(\u0026#34;Creating a new Person\u0026#34;) return new(Person) }, } } func main() { initPool() // pool.Get() è¿”å›interface{} // ç„¶åæ–­è¨€ æ˜¯å¦ä¸º *Person p := pool.Get().(*Person) fmt.Println(\u0026#34;é¦–æ¬¡ä» pool é‡Œè·å–ï¼š\u0026#34;, p) p.Name = \u0026#34;first\u0026#34; fmt.Printf(\u0026#34;è®¾ç½® p.Name = %s\\n\u0026#34;, p.Name) // å°†pæ”¾å›æ± ä¸­ pool.Put(p) fmt.Println(\u0026#34;Pool é‡Œå·²æœ‰ä¸€ä¸ªå¯¹è±¡ï¼š\u0026amp;{first}ï¼Œè°ƒç”¨ Getï¼š\u0026#34;, pool.Get().(*Person)) fmt.Println(\u0026#34;Pool æ²¡æœ‰å¯¹è±¡äº†ï¼Œè°ƒç”¨ Getï¼š\u0026#34;, pool.Get().(*Person)) } Creating a new Person é¦–æ¬¡ä» pool é‡Œè·å–ï¼š \u0026amp;{} è®¾ç½® p.Name = first Pool é‡Œå·²æœ‰ä¸€ä¸ªå¯¹è±¡ï¼š\u0026amp;{first}ï¼Œè°ƒç”¨ Getï¼š \u0026amp;{first} Creating a new Person Pool æ²¡æœ‰å¯¹è±¡äº†ï¼Œè°ƒç”¨ Getï¼š \u0026amp;{} é¦–å…ˆï¼Œéœ€è¦åˆå§‹åŒ– Poolï¼Œå”¯ä¸€éœ€è¦çš„å°±æ˜¯è®¾ç½®å¥½Newå‡½æ•° å½“è°ƒç”¨ Get æ–¹æ³•æ—¶ï¼Œå¦‚æœæ± å­é‡Œç¼“å­˜äº†å¯¹è±¡ï¼Œå°±ç›´æ¥è¿”å›ç¼“å­˜çš„å¯¹è±¡ å¦‚æœæ²¡æœ‰å­˜è´§ï¼Œåˆ™è°ƒç”¨Newå‡½æ•°åˆ›å»ºä¸€ä¸ªæ–°çš„å¯¹è±¡ å¦å¤–ï¼Œæˆ‘ä»¬å‘ç°Getæ–¹æ³•å–å‡ºæ¥çš„å¯¹è±¡å’Œä¸Šæ¬¡Putè¿›å»çš„å¯¹è±¡å®é™…ä¸Šæ˜¯åŒä¸€ä¸ªï¼ŒPoolæ²¡æœ‰åšä»»ä½•â€œæ¸…ç©ºâ€çš„å¤„ç† ä½†æˆ‘ä»¬ä¸åº”å½“å¯¹æ­¤æœ‰ä»»ä½•å‡è®¾ï¼Œå› ä¸ºåœ¨å®é™…çš„å¹¶å‘ä½¿ç”¨åœºæ™¯ä¸­ æ— æ³•ä¿è¯è¿™ç§é¡ºåºï¼Œæœ€å¥½çš„åšæ³•æ˜¯åœ¨Putå‰ï¼Œå°†å¯¹è±¡æ¸…ç©º ","permalink":"https://heliu.site/posts/golang/sync/pool/","summary":"Poolæ˜¯ä¸€ç»„å¯ä»¥å•ç‹¬ä¿å­˜å’Œæ£€ç´¢çš„ä¸´æ—¶å¯¹è±¡ã€‚","title":"sync.Pool"},{"content":"type RWMutex struct ğŸš€ åœ¨runtime/rwmutex.goä¸­æœ‰è¿™ä¸ªæ–‡ä»¶çš„ä¿®æ”¹è¿‡çš„å‰¯æœ¬ã€‚å¦‚æœä½ åœ¨è¿™é‡Œåšäº†ä»»ä½•æ›´æ”¹ï¼Œçœ‹çœ‹æ˜¯å¦åº”è¯¥åœ¨é‚£é‡Œä¹Ÿåšæ›´æ”¹ã€‚ RWMutex æ˜¯ä¸€ç§ è¯»/å†™ äº’æ–¥é”ã€‚è¯¥é”å¯ä»¥ç”±ä»»æ„æ•°é‡çš„è¯»æˆ–å•ä¸ªå†™æŒæœ‰ã€‚ RWMutex çš„é›¶å€¼æ˜¯ä¸€ä¸ªæœªé”å®šçš„äº’æ–¥é”ã€‚RWMutex åœ¨ç¬¬ä¸€æ¬¡ä½¿ç”¨åä¸èƒ½å¤åˆ¶ã€‚ å¦‚æœä¸€ä¸ªgoroutineæŒæœ‰ä¸€ä¸ªç”¨äºè¯»å–çš„RWMutexï¼Œè€Œå¦ä¸€ä¸ªgoroutineå¯èƒ½ä¼šè°ƒç”¨Lockï¼Œ é‚£ä¹ˆä»»ä½•goroutineéƒ½ä¸åº”è¯¥æœŸæœ›èƒ½å¤Ÿè·å¾—ä¸€ä¸ªè¯»é”ï¼Œç›´åˆ°åˆå§‹çš„è¯»é”è¢«é‡Šæ”¾ã€‚ ç‰¹åˆ«æ˜¯ï¼Œè¿™ç¦æ­¢äº†é€’å½’è¯»é”å®šã€‚è¿™æ˜¯ä¸ºäº†ç¡®ä¿é”æœ€ç»ˆå¯ç”¨ã€‚è¢«é˜»å¡çš„é”è°ƒç”¨ä¼šæ’é™¤æ–°çš„è¯»å–å™¨è·å–é”ã€‚ RWMutexï¼šè¯»å†™äº’æ–¥é” 1) è¯¥é”å¯ä»¥è¢«åŒæ—¶å¤šä¸ªè¯»å–è€…æŒæœ‰æˆ–å”¯ä¸€å†™å…¥è€…æŒæœ‰ 2) RWMutexå¯ä»¥åˆ›å»ºä¸ºå…¶ä»–ç»“æ„ä½“çš„å­—æ®µ 3) é›¶å€¼ä¸ºè§£é”çŠ¶æ€ RWMutex ç±»å‹çš„é”ä¹Ÿå’Œçº¿ç¨‹æ— å…³ï¼Œå¯ä»¥ç”±ä¸åŒçš„çº¿ç¨‹åŠ è¯»å–é”/å†™å…¥å’Œè§£è¯»å–é”/å†™å…¥é” 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 // There is a modified copy of this file in runtime/rwmutex.go. // If you make any changes here, see if you should make them there. // A RWMutex is a reader/writer mutual exclusion lock. // The lock can be held by an arbitrary number of readers or a single writer. // The zero value for a RWMutex is an unlocked mutex. // // A RWMutex must not be copied after first use. // // If a goroutine holds a RWMutex for reading and another goroutine might // call Lock, no goroutine should expect to be able to acquire a read lock // until the initial read lock is released. In particular, this prohibits // recursive read locking. This is to ensure that the lock eventually becomes // available; a blocked Lock call excludes new readers from acquiring the // lock. type RWMutex struct { // 1) ä¸€æŠŠäº’æ–¥é”ï¼Œä¿æŠ¤ä»¥ä¸‹å­—æ®µ // æ‰€æœ‰å†™goroutineäº‰æŠ¢sync.Mutexé”çš„goroutineéƒ½è¿™è¿™é‡Œæ’é˜Ÿç­‰å¾… w Mutex // held if there are pending writers // 2) semaphore è¯»å†™ç­‰å¾…æ±  // è·å–åˆ° sync.Mutex é”gorutineï¼Œå¹¶ç­‰å¾…æ­£åœ¨è¿è¡Œ è¯»goroutine æ—¶ï¼Œè¯¥å†™goroutineåœ¨è¿™é‡Œç­‰å¾… // å› æ­¤è¿™é‡Œåªå¯èƒ½æ˜¯åªæœ‰ä¸€ä¸ªå†™goroutineåœ¨ç­‰å¾…æˆ–è€…æ²¡æœ‰ writerSem uint32 // semaphore for writers to wait for completing readers // readerSem è®°å½•ç€æ‰€æœ‰ç­‰å¾…è¯»çš„åç¨‹ï¼Œå½“æœ‰å†™æ“ä½œæ­£åœ¨è¿›è¡Œä¸­ï¼Œåé¢æ¥çš„è¯»æ“ä½œå…¨éƒ¨æ’é˜Ÿç­‰å¾…åœ¨è¿™é‡Œ // ç­‰å¾…æ­£åœ¨è¿›è¡Œä¸­çš„è¯»æ“ä½œå®Œæˆåé‡Šæ”¾writerSemä¸­çš„å†™æ“ä½œå®Œæˆåï¼Œè¿™é‡Œæ’é˜Ÿçš„è¯»åç¨‹å°†è¢«é‡Šæ”¾ readerSem uint32 // semaphore for readers to wait for completing writers // 3) è¯»ç­‰å¾…æ•°é‡ // readerCount è®°å½•çš„æ‰€æœ‰çš„è¯»goroutineæ•°é‡ï¼ˆã€æ­£åœ¨æ‰§è¡Œçš„goroutineã€‘+ã€ç­‰å¾…åœ¨readerSemä¸­çš„goroutineã€‘ï¼‰ï¼Œ // è°ƒç”¨RLockæ–¹æ³•è¯¥å€¼å°±ä¼šåŠ ä¸€ // å½“æœ‰å†™goroutineè·å–åˆ°sync.Mutexæ—¶ï¼Œä¼šå°†è¯¥å€¼åŸå­æ“ä½œå‡å»rwmutexMaxReaderså˜æˆè´Ÿæ•°ï¼Œ // å‘ŠçŸ¥RLockæ–¹æ³•æœ‰å†™æ“ä½œåœ¨è¿›è¡Œï¼Œgoroutineå»readerSemå§ readerCount int32 // number of pending readers // åœ¨è·å–åˆ°Mutexåï¼Œè®°å½•å½“å‰ã€æ­£åœ¨è¿›è¡Œçš„è¯»goroutineæ•°é‡ã€‘ï¼Œä¸åŒ…æ‹¬å­˜åœ¨readerSemæ’é˜Ÿçš„ï¼Œè¿™äº›è¯»goroutineæ­£åœ¨å·¥ä½œçº¿ç¨‹ä¸Šè¿è¡Œ // åœ¨å½“å‰å†™æ“ä½œå¼€å§‹æ—¶ç­‰å¾…æ­£åœ¨è¿è¡Œå…¨éƒ¨è¯»goroutineçš„æ•°é‡ï¼Œæ³¨æ„è¿™é‡Œå¯ä»¥æ˜¯è´Ÿæ•° readerWait int32 // number of departing readers } const 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 // 2^30 = 1,073,741,824\tå®Œå…¨èƒ½æ»¡è¶³è¯»å–çš„æ•°é‡ const rwmutexMaxReaders = 1 \u0026lt;\u0026lt; 30\t// æœ€å¤§è¯»å–æ•°é‡ // Happens-before relationships are indicated to the race detector via: // - Unlock -\u0026gt; Lock: readerSem // - Unlock -\u0026gt; RLock: readerSem // - RUnlock -\u0026gt; Lock: writerSem // // The methods below temporarily disable handling of race synchronization // events in order to provide the more precise model above to the race // detector. // // For example, atomic.AddInt32 in RLock should not appear to provide // acquire-release semantics, which would incorrectly synchronize racing // readers, thus potentially missing races. // // Happens-beforeå…³ç³»é€šè¿‡ä»¥ä¸‹æ–¹å¼æŒ‡ç¤ºç«äº‰æ£€æµ‹å™¨: // Unlock -\u0026gt; Lock: readerSem // Unlock -\u0026gt; RLock: readerSem // RUnlock -\u0026gt; Lock: writerSem // // ä¸‹é¢çš„æ–¹æ³•æš‚æ—¶ç¦ç”¨äº†ç«äº‰åŒæ­¥äº‹ä»¶çš„å¤„ç†ï¼Œä»¥ä¾¿ä¸ºç«äº‰æ£€æµ‹å™¨æä¾›æ›´ç²¾ç¡®çš„æ¨¡å‹ã€‚ // ä¾‹å¦‚ï¼ŒRLockä¸­çš„ atomic.AddInt32 çœ‹èµ·æ¥ä¸åº”è¯¥æä¾› è·å–-é‡Šæ”¾è¯­ä¹‰ï¼Œè¿™å°†ä¸æ­£ç¡®åœ°åŒæ­¥ç«äº‰çš„é˜…è¯»å™¨ï¼Œä»è€Œå¯èƒ½é”™è¿‡ç«äº‰ã€‚ å­—æ®µå’Œæ–¹æ³•æè¿° Lock()ã€Unlock() å†™æ“ä½œæ—¶è°ƒç”¨çš„æ–¹æ³•ï¼Œå¦‚æœé”å·²è¢«readeræˆ–waiteræŒæœ‰ï¼Œé‚£ä¹ˆLockæ–¹æ³•ä¼šä¸€ç›´é˜»å¡ï¼Œç›´åˆ°èƒ½è·å–åˆ°é” å†™æ“ä½œæ—¶ï¼Œå¦‚æœé”è¢«readersæŒæœ‰ï¼Œé‚£ä¹ˆå°†ç­‰å¾…æ‰€æœ‰çš„readerè§£é”ï¼Œè¿”å›å†™æ“ä½œè·å¾—é”ï¼Œè¿™æœŸé—´è¿˜æœ‰æ¥çš„readerå…¨éƒ¨å»æ’é˜Ÿç­‰å¾…ï¼Œç­‰å¾…å†™æ“ä½œè§£é”å†™æ“ä½œè§£é”æœŸé—´å…ˆæŠŠç­‰å¾…åœ¨æ’é˜Ÿçš„å…¨éƒ¨é‡Šæ”¾å‡ºæ¥ï¼Œç„¶åå†å»è§£é”äº’æ–¥é”ã€‚åœ¨äº’æ–¥é”è§£é”å°æ®µæ—¶é—´æ¥çš„è¯»æ“ä½œç›´æ¥è·å–é”ä¸éœ€è¦å»æ’é˜Ÿï¼Œäº’æ–¥é”è§£é”åæ‰å…è®¸æ’é˜Ÿçš„å†™æ“ä½œæˆ–æ­£åœ¨æ¥çš„å†™æ“ä½œå»äº‰æŠ¢äº’æ–¥å†™é” å†™æ“ä½œæ—¶ï¼Œå¦‚æœé”å·²è¢«waiteræŒæœ‰ï¼Œé‚£ä¹ˆå½“å‰å†™æ“ä½œç­‰å¾…åœ¨RWRutex.w.seamä¿¡å·é‡ä¸­ï¼Œç­‰å¾…å‰é¢ä¸€ä¸ªå†™é”å®Œæˆï¼Œæ­¤æ—¶æ¥çš„è¯»æ“ä½œå…¨éƒ¨é˜»å¡èµ·ï¼Œå·²ç»åœ¨è¿›è¡Œçš„è¯»æ“ä½œæ­£å¸¸è¿›è¡Œ Unlockæ–¹æ³•æ˜¯é…å¯¹çš„é‡Šæ”¾é”çš„æ–¹æ³• RLock()ã€RUnlock() è¯»æ“ä½œæ—¶è°ƒç”¨çš„æ–¹æ³•ï¼Œå¦‚æœé”å·²ç»è¢«writeræŒæœ‰çš„è¯ï¼ŒRLockæ–¹æ³•ä¼šä¸€ç›´é˜»å¡ï¼Œç›´åˆ°èƒ½è·å–åˆ°é”ï¼Œå¦åˆ™å°±ç›´æ¥è¿”å› è¯»æ“ä½œæ—¶æ²¡æœ‰waiteræŒæœ‰é”æƒ…å†µï¼Œç›´æ¥è®°å½•readerCountåŠ ä¸€ï¼Œè¿”å›å°±è¿”å›ï¼Œè¡¨ç¤ºè·å–åˆ°é” è¯»æ“ä½œæ—¶å­˜åœ¨waiteræŒæœ‰é”æƒ…å†µï¼Œåˆ™å½“å‰è¯»æ“ä½œæ’é˜Ÿåœ¨readerSemï¼Œç­‰å¾…å½“å‰å†™å®Œæˆ è€ŒRUnlockæ˜¯readeré‡Šæ”¾é”çš„æ–¹æ³• RLocker() è¿™ä¸ªæ–¹æ³•çš„ä½œç”¨æ˜¯ä¸ºè¯»æ“ä½œè¿”å›ä¸€ä¸ªLockeræ¥å£çš„å¯¹è±¡ï¼Œå®ƒçš„Lockæ–¹æ³•ä¼šè°ƒç”¨RWMutexçš„RLockæ–¹æ³•ï¼Œå®ƒçš„Unlockæ–¹æ³•ä¼šè°ƒç”¨RWMutexçš„RUnlockæ–¹æ³• Lock() Lock é”å®š rw ç”¨äºå†™å…¥ã€‚ å¦‚æœé”å·²ç»é”å®šç”¨äºè¯»æˆ–å†™ï¼Œé‚£ä¹ˆé”å°†é˜»å¡ï¼Œç›´åˆ°é”å¯ç”¨ä¸ºæ­¢ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 // Lock locks rw for writing. // If the lock is already locked for reading or writing, // Lock blocks until the lock is available. func (rw *RWMutex) Lock() { if race.Enabled { _ = rw.w.state race.Disable() } // 1) å°è¯•è·å– sync.Mutex é” // First, resolve competition with other writers. // // é¦–å…ˆï¼Œè§£å†³ä¸å…¶ä»– writers çš„ç«äº‰ã€‚ // å¦‚æœå­˜åœ¨å¤šä¸ªå†™gorutineçš„éƒ½åœ¨è°ƒç”¨Lockç«äº‰é”ï¼Œè¿™é‡Œéœ€è¦å…ˆå»ç«äº‰é” rw.w.Lock()\t// sync.Mutex // 2) åŸå­ä¿®æ”¹readerCountå€¼ï¼Œå‘Šè¯‰åé¢è¯»goroutineè°ƒç”¨Rlockå‡½æ•°éœ€è¦å»readerSemä¸­æŒ‚èµ· // ç”±äºåˆšè·å–åˆ°é”ï¼Œå› æ­¤æ­¤æ—¶åªå­˜åœ¨æ­£åœ¨è¿è¡Œè¯»goroutineå’Œç­‰å¾…åœ¨writerSemä¸­å†™goroutineï¼Œä¸å­˜åœ¨ç­‰å¾…åœ¨readerSemä¸­çš„goroutine // å› æ­¤ readerCount å­˜å‚¨çš„æ˜¯æ­£åœ¨è¿è¡Œè¯»goroutineï¼Œåœ¨ä¸‹é¢è¿™è¡ŒåŸå­æ“ä½œæ‰§è¡Œå‰éƒ½è®¤ä¸ºè¯»goroutineæ˜¯ä¸éœ€è¦æŒ‚èµ·çš„ // Announce to readers there is a pending writer. // // é€šè¿‡æŠŠrw.readerCountè®¾ç½®æˆä¸€ä¸ªè´Ÿæ•°ï¼Œæ¥å‘ŠçŸ¥å…¶ä»–è¯»goroutineå½“å‰æœ‰å†™çš„goroutineæ­£åœ¨ç­‰å¾…è¿›å…¥ä¸´ç•ŒåŒº // atomic.AddInt32(\u0026amp;rw.readerCount, -rwmutexMaxReaders); å‘Šè¯‰åé¢æ¥çš„è¯»æ“ä½œå»æ’é˜Ÿç­‰å¾…ï¼Œä½ ä»¬åº”è¯¥åœ¨æœ¬æ¬¡å†™æ“ä½œå®Œåå†å»è¯»å–æ•°æ® // ç”±äºå½“å‰åˆšè·å–åˆ° Mutex,æ‰€ä»¥è¿™é‡Œçš„ r åº”è¯¥è¡¨ç¤ºå½“å‰æ­£åœ¨è¿è¡Œçš„è¯»goroutineçš„æ•°é‡ï¼Œä¸åŒ…å«è¢«æŒ‚èµ·çš„ goroutine r := atomic.AddInt32(\u0026amp;rw.readerCount, -rwmutexMaxReaders) + rwmutexMaxReaders\t// åŸå­æ“ä½œè¡¨ç¤ºå½“å‰æœ‰å†™çš„åç¨‹æ¥äº† // åœ¨ä¸Šé¢è¿™è¡ŒåŸå­æ“ä½œæ‰§è¡Œåï¼Œéƒ½æœ‰æ¥çš„è¯»goroutineåœ¨è°ƒç”¨RLockæ–¹æ³•æ—¶ï¼Œéƒ½ä¼šè¢«æŒ‚èµ·åœ¨readerSemä¸­ // å› æ­¤ r æ˜¯æ‰€æœ‰æ­£åœ¨è¿è¡Œè¯»goroutineçš„æ•°é‡ // ä¸Šé¢çš„åŸå­æ“ä½œä¸RLockå‡½æ•°çš„åŸå­æ“ä½œå½¢æˆä¸€å¯¹ä¸´ç•ŒåŒºåŸŸäº’æ–¥ // Wait for active readers. // // 1. r != 0ï¼šå­˜åœ¨æ­£åœ¨è¿è¡Œçš„è¯»goroutine // 2. atomic.AddInt32(\u0026amp;rw.readerWait, r) != 0ï¼šç»§ç»­åˆ¤æ–­è¿™æ®µæ—¶é—´å‘¢è¿™äº›è¯»goroutineæ˜¯å¦å…¨éƒ¨è¯»å–å®Œï¼Œ // æ²¡æœ‰è¯»å–å®Œè¿™é‡Œéœ€è¦æŠŠå½“å‰å†™goroutineæŒ‚èµ·åœ¨writerSem // è¿™é‡Œçš„åŸå­æ“ä½œä¸RUlockå‡½æ•°çš„ \u0026#34;atomic.AddInt32(\u0026amp;rw.readerWait, -1) == 0\u0026#34; å½¢æˆä¸´ç•ŒåŒºåŸŸäº’æ–¥ if r != 0 \u0026amp;\u0026amp; atomic.AddInt32(\u0026amp;rw.readerWait, r) != 0 {\t// readerWaitè®°å½•ç€æ­£åœ¨è¿è¡Œä¸­ï¼Œè¿˜æ²¡æœ‰è°ƒç”¨RUnlockçš„goroutine // å­˜åœ¨éœ€è¦ç­‰å¾…è¯»çš„åç¨‹ï¼ŒæŠŠå½“å‰åç¨‹åŠ å…¥writerSemå†™ä¿¡æ¯æ±  // falseï¼šè¿™é‡ŒåŠ å…¥çš„æ˜¯å°¾éƒ¨ï¼Œç”±äºwriterSemåªå¯èƒ½å­˜ä¸€ä¸ªå†™goroutine runtime_SemacquireMutex(\u0026amp;rw.writerSem, false, 0)\t} if race.Enabled { race.Enable() race.Acquire(unsafe.Pointer(\u0026amp;rw.readerSem)) race.Acquire(unsafe.Pointer(\u0026amp;rw.writerSem)) } } Unlock() Unlock æ–¹æ³•è§£é™¤rwçš„å†™å…¥é”çŠ¶æ€ã€‚ å¦‚æœ rw åœ¨è¿›å…¥è§£é”æ—¶æ²¡æœ‰é”å®šå†™å…¥ï¼Œè¿™æ˜¯ä¸€ä¸ªè¿è¡Œæ—¶é”™è¯¯ã€‚ ä¸ Mutexes ä¸€æ ·ï¼Œä¸€ä¸ªè¢«é”çš„ RWMutex ä¸ä¸€ä¸ªç‰¹å®šçš„ goroutine æ— å…³ã€‚ ä¸€ä¸ª goroutine å¯ä»¥ RLock(é”å®š)ä¸€ä¸ª RWMutexï¼Œç„¶åå®‰æ’å¦ä¸€ä¸ª goroutine è¿è¡Œ RUnlock(è§£é”)å®ƒã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 // Unlock unlocks rw for writing. It is a run-time error if rw is // not locked for writing on entry to Unlock. // // As with Mutexes, a locked RWMutex is not associated with a particular // goroutine. One goroutine may RLock (Lock) a RWMutex and then // arrange for another goroutine to RUnlock (Unlock) it. func (rw *RWMutex) Unlock() { if race.Enabled { _ = rw.w.state race.Release(unsafe.Pointer(\u0026amp;rw.readerSem)) race.Disable() } // 1) å½“Unlockæ–¹æ³•è¢«è°ƒç”¨ï¼Œä¹Ÿå°±è¯´æ˜æ•°æ®çš„ç›¸å…³å†™æ“ä½œå·²ç»å®Œæˆäº†ï¼Œæ­¤æ—¶å…¶ä»–æ¥è¯»çš„goroutineå¯ä»¥æ­£å¸¸è¯»å–æ–°æ•°æ® // Announce to readers there is no active writer. // // å‘Šè¯‰æ‰€æœ‰RLockçš„åç¨‹ï¼Œæ²¡æœ‰æ­£åœ¨å†™çš„é”ï¼Œæ­¤æ—¶æ¥è¯»çš„åç¨‹ä¸å¿…ç­‰å¾…ç›´æ¥å¯ä»¥è¯»å–åˆ°æ•°æ® // å› ä¸ºç¨‹åºè°ƒç”¨äº†Unlockæ–¹æ³•ä»£è¡¨æˆ‘ä»¬å‰é¢ä»¥æŠŠæ•°æ®æ›´æ–°äº†ï¼Œæ­¤æ—¶åœ¨ä¿¡å·é‡ä¸­ç­‰å¾…è¯»çš„åç¨‹å’Œæ­¤æ—¶åé¢æ¥è¯»çš„åç¨‹éƒ½å¯ä»¥å®‰å…¨è¯»å–æ•°æ®äº† // è¿™é‡Œä¸RLockå‡½æ•°çš„ \u0026#34;atomic.AddInt32(\u0026amp;rw.readerCount, 1) \u0026lt; 0\u0026#34; å½¢æˆä¸´ç•ŒåŒºäº’æ–¥ r := atomic.AddInt32(\u0026amp;rw.readerCount, rwmutexMaxReaders)\t// è¿™é‡Œçš„rå…¨éƒ½æ˜¯ç­‰å¾…åœ¨ä¿¡å·é‡çš„æ•°é‡ // æ²¡æœ‰è°ƒç”¨Lockæ–¹æ³•ï¼Œè€Œæ˜¯ç›´æ¥è°ƒç”¨Unlockæ–¹æ³•è¿™é‡Œä¼šæŠ¥é”™ if r \u0026gt;= rwmutexMaxReaders { race.Enable() throw(\u0026#34;sync: Unlock of unlocked RWMutex\u0026#34;) } // Unblock blocked readers, if any. // // é‡Šæ”¾æ‰ç­‰å¾…åœ¨ä¿¡å·é‡çš„åç¨‹ï¼Œæ³¨æ„è¿™é‡Œæ˜¯é‡Šæ”¾å®Œäº†æ‰æŠŠäº’æ–¥é”è§£é”çš„æ‰å…è®¸å…¶ä»–å†™æ“ä½œè¿›è¡Œ // å› ä¸ºå‰é¢çš„æ•°æ®å·²ç»æ›´æ–°äº†ï¼Œæ‰€ä»¥è¿™é‡Œéœ€è¦æŠŠåœ¨ä¿¡å·é‡ä¸­çš„åç¨‹å…¨éƒ¨æ”¾åœ¨Pæœ¬åœ°é˜Ÿåˆ—æˆ–å…¨å±€é˜Ÿåˆ—ä¸­ç­‰å¾…è°ƒåº¦å™¨è°ƒåº¦å»æ¥è¿è¡Œ // è¿™é‡Œä¹Ÿæ˜¯ä¸ºä»€ä¹ˆå…¶ä»–å†™goroutineè·å–åˆ°Mutexé”æ—¶ï¼Œä¸å­˜åœ¨ç­‰å¾…åœ¨readerSemä¸Šçš„è¯»goroutineçš„åŸå› ï¼Œå› ä¸ºMutexè§£é”åœ¨åé¢ä¸€æ­¥ for i := 0; i \u0026lt; int(r); i++ { runtime_Semrelease(\u0026amp;rw.readerSem, false, 0)\t// å–å‡ºç­‰å¾…åœ¨readerSemçš„å†™goroutine } // Allow other writers to proceed. // // å…è®¸å…¶ä»– writers ç»§ç»­ rw.w.Unlock()\t// sync.Mutex if race.Enabled { race.Enable() } } TryLock() TryLock è¯•å›¾é”å®š rw è¿›è¡Œå†™å…¥ï¼Œå¹¶æŠ¥å‘Šæ˜¯å¦æˆåŠŸã€‚ è¯·æ³¨æ„ï¼Œè™½ç„¶ç¡®å®å­˜åœ¨æ­£ç¡®ä½¿ç”¨ TryLock çš„æƒ…å†µï¼Œä½†å¾ˆå°‘ï¼Œè€Œä¸” TryLock çš„ä½¿ç”¨é€šå¸¸è¡¨æ˜äº’æ–¥é‡çš„ç‰¹å®šä½¿ç”¨ä¸­å­˜åœ¨æ›´æ·±å±‚çš„é—®é¢˜ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 // TryLock tries to lock rw for writing and reports whether it succeeded. // // Note that while correct uses of TryLock do exist, they are rare, // and use of TryLock is often a sign of a deeper problem // in a particular use of mutexes. func (rw *RWMutex) TryLock() bool { if race.Enabled { _ = rw.w.state race.Disable() } // å°è¯•è·å–Mutexé” if !rw.w.TryLock() { if race.Enabled { race.Enable() } return false } // åŸå­äº¤æ¢ readerCount ç”± 0 -\u0026gt; -rwmutexMaxReaders // å¯è§åªæœ‰åœ¨æ²¡æœ‰è¯»goroutineçš„æ—¶å€™ï¼ŒTryLockå‡½æ•°æ‰ä¼šè¿”å›æˆåŠŸ if !atomic.CompareAndSwapInt32(\u0026amp;rw.readerCount, 0, -rwmutexMaxReaders) { // å­˜åœ¨å…¶ä»–æ­£åœ¨è¯»å†™åç¨‹ rw.w.Unlock()\t// è§£é”äº’æ–¥é” if race.Enabled { race.Enable() } return false } if race.Enabled { race.Enable() race.Acquire(unsafe.Pointer(\u0026amp;rw.readerSem)) race.Acquire(unsafe.Pointer(\u0026amp;rw.writerSem)) } return true } RLock() RLockè®¾ç½®rwè¯»é”ã€‚ å®ƒä¸åº”è¯¥ç”¨äºé€’å½’çš„è¯»é”å®š;è¢«é˜»å¡çš„é”è°ƒç”¨ä¼šæ’é™¤æ–°çš„è¯»å–å™¨è·å–é”ã€‚è¯·å‚é˜…RWMutexç±»å‹çš„æ–‡æ¡£ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 // RLock locks rw for reading. // // It should not be used for recursive read locking; a blocked Lock // call excludes new readers from acquiring the lock. See the // documentation on the RWMutex type. func (rw *RWMutex) RLock() { if race.Enabled { _ = rw.w.state race.Disable() } // æŠŠrw.readerCountåŠ ä¸€ï¼Œå¦‚æœè¯¥å€¼å°äº0ï¼Œè¯´æ˜å­˜åœ¨å…¶ä»–goroutineæ­£åœ¨å†™æ“ä½œï¼Œä¹Ÿå°±æ˜¯å‰é¢çš„Lockæ–¹æ³• // è¿™é‡Œä¹Ÿè¡¨æ˜äº†readerCountå­—æ®µæ˜¯è®°å½•æ‰€æœ‰å†™goroutineçš„æ•°é‡ if atomic.AddInt32(\u0026amp;rw.readerCount, 1) \u0026lt; 0 { // A writer is pending, wait for it. // // ä¸€ä¸ªå†™é”æ­£åœ¨ç»§ç»­ï¼Œç­‰å¾…å®ƒå®Œæˆ runtime_SemacquireMutex(\u0026amp;rw.readerSem, false, 0)\t// å°†å½“å‰è¯»goroutineæŒ‚åœ¨readerSemä¸Š } if race.Enabled { race.Enable() race.Acquire(unsafe.Pointer(\u0026amp;rw.readerSem)) } } RUnlock() RUnlock è§£é™¤ä¸€ä¸ª RLock è°ƒç”¨ã€‚ å®ƒä¸ä¼šå½±å“å…¶ä»–åŒæ—¶é˜…è¯»çš„è¯»è€…ã€‚ å¦‚æœrwåœ¨è¿›å…¥RUnlockæ—¶æ²¡æœ‰é”å®šè¯»å–ï¼Œåˆ™æ˜¯ä¸€ä¸ªè¿è¡Œæ—¶é”™è¯¯ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 // RUnlock undoes a single RLock call; // it does not affect other simultaneous readers. // It is a run-time error if rw is not locked for reading // on entry to RUnlock. func (rw *RWMutex) RUnlock() { if race.Enabled { _ = rw.w.state race.ReleaseMerge(unsafe.Pointer(\u0026amp;rw.writerSem)) race.Disable() } // æŠŠå‰é¢è¯»åŠ é”å‡ä¸€ï¼Œå¦‚æœrå°äº0ï¼Œè¯´æ˜æ­£åœ¨è¿›è¡Œå†™æ“ä½œä¸­ // è¿™é‡Œä¹Ÿæœ‰ä¸€ç§å¯èƒ½æ˜¯æ²¡æœ‰å­˜åœ¨å†™æ“ä½œä¸­åˆæ²¡æœ‰è°ƒç”¨Rlockå‡½æ•°è°ƒç”¨äº†RUnlockå‡½æ•°å¯¼è‡´æ€»æœ‰ä¸€ä¸ªgoroutineè¿™é‡Œrw.readerCount=-1 if r := atomic.AddInt32(\u0026amp;rw.readerCount, -1); r \u0026lt; 0 { // Outlined slow-path to allow the fast-path to be inlined // // æœ‰å­˜åœ¨å†™åœ¨è¿›è¡Œï¼Œå› æ­¤éœ€è¦åˆ¤æ–­å½“å‰æ˜¯å¦éœ€è¦å–å‡ºè¯¥å†™goroutine // åŸå› æ˜¯å¯èƒ½å­˜åœ¨è¯»goroutineåœ¨è¿è¡Œä¸­ï¼Œè¯¥å†™goroutineåœ¨writerSemä¸­ç­‰å¾… rw.rUnlockSlow(r)\t} if race.Enabled { race.Enable() } } rUnlockSlow() 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 func (rw *RWMutex) rUnlockSlow(r int32) { // åˆ¤æ–­æ²¡æœ‰è°ƒç”¨RLockå‡½æ•°è°ƒç”¨RUnlockå‡½æ•°æŠ¥é”™ // 1. r+1 == -rwmutexMaxReaders =\u0026gt; r + rwmutexMaxReaders == 1 // 2. r+1 == 0ï¼Œå°±æ˜¯åˆ¤æ–­ä¸Šé¢æ²¡æœ‰è°ƒç”¨RLockå‡½æ•°è°ƒç”¨RUnlockå‡½æ•°æ—¶æƒ…å†µ if r+1 == 0 || r+1 == -rwmutexMaxReaders { race.Enable() throw(\u0026#34;sync: RUnlock of unlocked RWMutex\u0026#34;) } // A writer is pending. // // rw.readerWait è®°å½•ç€å½“å‰æ­£åœ¨è¿è¡Œçš„goroutineæ²¡åœ¨ä¿¡å·æ± çš„æ•°é‡ï¼Œè¿™é‡Œåˆ¤æ–­æ˜¯å¦å·²ç»æ˜¯æœ€åä¸€ä¸ª // è¿™é‡Œçš„åŸå­æ“ä½œå’ŒLockå‡½æ•°ä¸­çš„ \u0026#34;atomic.AddInt32(\u0026amp;rw.readerWait, r) != 0\u0026#34; å½¢æˆä¸´ç•ŒåŒºäº’æ–¥ if atomic.AddInt32(\u0026amp;rw.readerWait, -1) == 0 {\t// å¦‚æœæ˜¯æœ€åä¸€ä¸ªï¼ŒæŠŠç­‰å¾…å†™çš„goroutineå–å‡º // The last reader unblocks the writer. runtime_Semrelease(\u0026amp;rw.writerSem, false, 1)\t// ä»writerSemä¸­å–å‡ºç­‰å¾…åœ¨è¿™é‡Œçš„è¯»goroutine } } TryRLock() å°è¯•è·å–è¯»é”ï¼Œè¯¥æ–¹æ³•åªè¦ä¸å­˜åœ¨å†™åç¨‹éƒ½ä¼šè·å–è¯»é”æˆåŠŸã€‚ TryRLock è¯•å›¾é”å®š rw ä»¥è¿›è¡Œè¯»å–ï¼Œå¹¶æŠ¥å‘Šæ˜¯å¦æˆåŠŸã€‚ è¯·æ³¨æ„ï¼Œè™½ç„¶ç¡®å®å­˜åœ¨å¯¹ TryRLock çš„æ­£ç¡®ä½¿ç”¨ï¼Œä½†å¾ˆå°‘ï¼Œè€Œä¸” TryRLock çš„ä½¿ç”¨é€šå¸¸è¡¨æ˜äº’æ–¥é‡çš„ç‰¹å®šä½¿ç”¨ä¸­å­˜åœ¨æ›´æ·±å±‚çš„é—®é¢˜ã€‚ è¯¥æ–¹æ³•åœ¨æ²¡æœ‰å†™æ“ä½œçš„æƒ…å†µä¸‹æ˜¯ä¸€å®šèƒ½æ‹¿å»åˆ°é”çš„ã€‚å­˜åœ¨å†™æ“ä½œæ—¶æ‰ä¼šè¿”å› falseã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 // TryRLock tries to lock rw for reading and reports whether it succeeded. // // Note that while correct uses of TryRLock do exist, they are rare, // and use of TryRLock is often a sign of a deeper problem // in a particular use of mutexes. func (rw *RWMutex) TryRLock() bool { if race.Enabled { _ = rw.w.state race.Disable() } // TryRLock å‡½æ•°è·å–åˆ°è¯»é”åªèƒ½å‘ç”Ÿåœ¨ readerCount \u0026gt;= 0 çŠ¶æ€ä¸‹ for { c := atomic.LoadInt32(\u0026amp;rw.readerCount)\t// åŸå­è¯»å– readerCount if c \u0026lt; 0 { // å†™æ“ä½œåœ¨è¿›è¡Œä¸­æˆ–è€…åœ¨ç­‰å¾…è¯»å®Œæˆã€‚ if race.Enabled { race.Enable() } return false } // å°è¯•åŸå­äº¤æ¢ readerCount å€¼ // å¦‚æœäº¤æ¢å¤±è´¥å¯èƒ½æœ‰å…¶ä»–è¯»æ“ä½œæˆ–å†™æ“ä½œå‘ç”Ÿï¼Œå†æ¬¡å¾ªç¯ã€‚ if atomic.CompareAndSwapInt32(\u0026amp;rw.readerCount, c, c+1) { if race.Enabled { race.Enable() race.Acquire(unsafe.Pointer(\u0026amp;rw.readerSem)) } return true\t// è·å–åˆ°é”å } } } RLocker() RLocker è¿”å›ä¸€ä¸ª Locker æ¥å£ï¼Œé€šè¿‡è°ƒç”¨ rw å®ç° Lock å’Œ Unlock æ–¹æ³•ã€‚RLock å’Œ rw.RUnlockã€‚ æ„ä¹‰åœ¨äºè¿”å›æ¥å£Lockeré™åˆ¶åªèƒ½è°ƒç”¨æ¥å£çš„ï¼Œæ¯”å¦‚ sync.Cond ä¸­éœ€è¦çš„é” 1 2 3 4 5 // RLocker returns a Locker interface that implements // the Lock and Unlock methods by calling rw.RLock and rw.RUnlock. func (rw *RWMutex) RLocker() Locker { return (*rlocker)(rw) } type Locker interface Lockeræ¥å£ä»£è¡¨ä¸€ä¸ªå¯ä»¥åŠ é”å’Œè§£é”çš„å¯¹è±¡ã€‚ è¯¥æ¥å£å®šä¹‰åœ¨sync/mutex.goæ–‡ä»¶ä¸­ã€‚ 1 2 3 4 type Locker interface { Lock() Unlock() } type rlocker RWMutex 1 type rlocker RWMutex\t// sync.RWMutex Lock() 1 2 3 4 5 6 func (r *rlocker) Lock() { // å› ä¸º rlocker å’Œ RWMutexæ˜¯ä¸¤ä¸ªç±»å‹ï¼Œè™½ç„¶åº•å±‚ä¸€æ · // ä½†æ˜¯ rlocker åªæ”¯æŒ Lock() å’Œ Unlock() æ–¹æ³• // éœ€è¦è½¬æ¢æˆ (*RWMutex) æ‰èƒ½è°ƒç”¨ RLock() æ–¹æ³•ã€‚ (*RWMutex)(r).RLock() } Unlock() 1 2 3 func (r *rlocker) Unlock() { (*RWMutex)(r).RUnlock() } ä½¿ç”¨ç¤ºä¾‹ è¯»å†™é”ï¼šæ˜¯å¤šè¯»å•å†™äº’æ–¥é”ï¼Œåˆ†åˆ«é’ˆå¯¹è¯»æ“ä½œå’Œå†™æ“ä½œè¿›è¡Œé”å®šå’Œè§£é”æ“ä½œ ç»å¸¸ç”¨äºè¯»æ¬¡æ•°è¿œè¿œå¤šäºå†™æ¬¡æ•°çš„åœºåˆ åœ¨Goè¯­è¨€ä¸­ï¼Œè¯»å†™é”ç”±ç»“æ„ä½“ç±»å‹ sync.RWMutex å®ç° åŸºæœ¬éµå®ˆåŸåˆ™ï¼š å†™é”å®šæƒ…å†µä¸‹ï¼Œå¯¹è¯»å†™é”å®šè¿›è¡Œè¯»é”å®šæˆ–å†™é”å®šï¼Œéƒ½å°†é˜»å¡ï¼Œè€Œä¸”è¯»é”ä¸å†™é”ä¹‹é—´æ˜¯äº’æ–¥çš„ è¯»é”å®šæƒ…å†µä¸‹ï¼Œå¯¹è¯»å†™é”è¿›è¡Œå†™é”å®šï¼Œå°†é˜»å¡ åŠ è¯»é”æ—¶ä¸ä¼šé˜»å¡ï¼Œå³å¯å¤šè¯» å¯¹æœªè¢«å†™é”å®šçš„è¯»å†™é”è¿›è¡Œå†™è§£é”ï¼Œä¼šå¼•å‘è¿è¡Œæ—¶å¼‚å¸¸ å¯¹æœªè¢«è¯»è¯»é”å®šçš„è¯»å†™é”è¿›è¡Œè¯»è§£é”æ—¶ä¹Ÿä¼šå¼•å‘è¿è¡Œæ—¶å¼‚å¸¸ å†™è§£é”åœ¨è¿›è¡Œçš„åŒæ—¶ä¼šè¯•å›¾å”¤é†’æ‰€æœ‰å› è¿›è¡Œè¯»é”å®šè€Œè¢«é˜»å¡çš„åç¨‹ è¯»è§£é”åœ¨è¿›è¡Œçš„æ—¶å€™åˆ™ä¼šè¯•å›¾å”¤é†’ä¸€ä¸ªå› è¿›è¡Œå†™é”å®šè€Œè¢«é˜»å¡çš„åç¨‹ ä¸äº’æ–¥é”ç±»å‹ï¼Œsync.RWMutex ç±»å‹çš„é›¶å€¼å°±å·²ç»æ˜¯ç«‹å³å¯ç”¨çš„è¯»å†™é”äº† 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;sync\u0026#34; \u0026#34;time\u0026#34; ) var m *sync.RWMutex func main() { wg := sync.WaitGroup{} wg.Add(20) var rwMutex sync.RWMutex Data := 0 for i := 0; i \u0026lt; 10; i++ { go func(t int) { rwMutex.RLock()\t// è¯»åŠ é” defer rwMutex.RUnlock()\t// è¯»è§£é” fmt.Printf(\u0026#34;è¯»æ•°æ®ï¼š%v %d\\n\u0026#34;, Data, i) wg.Done() time.Sleep(1 * time.Second) // è¿™å¥ä»£ç ç¬¬ä¸€æ¬¡è¿è¡Œåï¼Œè¯»è§£é” // å¾ªç¯åˆ°ç¬¬äºŒä¸ªæ—¶ï¼Œ è¯»é”å®šåï¼Œè¿™ä¸ªgoroutineå°±æ²¡æœ‰é˜»å¡ï¼ŒåŒæ—¶è¯»æˆåŠŸ }(i) go func(t int) { rwMutex.Lock()\t// å†™åŠ é” defer rwMutex.Unlock()\t// å†™è§£é” Data += 1 fmt.Printf(\u0026#34;å†™æ•°æ®ï¼š%v %d\\n\u0026#34;, Data, t) wg.Done() // å¯¹è¯»å†™é”è¿›è¡Œè¯»é”å®šæˆ–è€…å†™é”å®šï¼Œéƒ½å°†é˜»å¡ // å†™é”å®šä¸‹æ˜¯éœ€è¦è§£é”åæ‰èƒ½å†™çš„ time.Sleep(5 * time.Second) }(i) } wg.Wait() } è¯»æ•°æ®ï¼š0 3 å†™æ•°æ®ï¼š1 2 è¯»æ•°æ®ï¼š1 10 è¯»æ•°æ®ï¼š1 10 è¯»æ•°æ®ï¼š1 10 è¯»æ•°æ®ï¼š1 10 è¯»æ•°æ®ï¼š1 10 è¯»æ•°æ®ï¼š1 10 è¯»æ•°æ®ï¼š1 10 è¯»æ•°æ®ï¼š1 10 è¯»æ•°æ®ï¼š1 10 å†™æ•°æ®ï¼š2 1 å†™æ•°æ®ï¼š3 3 å†™æ•°æ®ï¼š4 4 å†™æ•°æ®ï¼š5 5 å†™æ•°æ®ï¼š6 6 å†™æ•°æ®ï¼š7 0 å†™æ•°æ®ï¼š8 9 å†™æ•°æ®ï¼š9 7 å†™æ•°æ®ï¼š10 8 é€šè¿‡ç¨‹åºè¿è¡Œçš„è¾“å‡ºå¯ä»¥çœ‹åˆ°ï¼Œåœ¨å†™é”å®šæƒ…å†µä¸‹ï¼Œå¯¹è¯»å†™é”è¿›è¡Œé”å®šæˆ–è€…å†™é”å®šï¼Œéƒ½å°†é˜»å¡ æŠŠå†™æ•°æ®ä¸­çš„Sleepè®¾ç½®æ›´é•¿æ—¶é—´ï¼Œåœ¨ç¬¬ä¸€æ¬¡å†™é”å®šåï¼Œè¯»æ•°æ®ä¹Ÿæ²¡æœ‰è¿›è¡Œ å†æ¬¡å†™é”å®šæ˜¯åœ¨ rwMutex.Unlock() å®Œæˆåï¼Œæ‰èƒ½è¿›è¡Œ rwMutex.lock() è€Œè¯»æ•°æ®æ—¶åˆ™å¯ä»¥å¤šæ¬¡è¯»ï¼Œä¸ä¸€å®šéœ€è¦ç­‰ rwMutex.RUnlock() å®Œæˆ ","permalink":"https://heliu.site/posts/golang/sync/rwmutex/","summary":"RWMutexæ˜¯ä¸€ç§è¯»å†™äº’æ–¥é”ã€‚","title":"sync.RwMutex"},{"content":"type Once struct ğŸš€ Onceæ˜¯åªæ‰§è¡Œä¸€æ¬¡åŠ¨ä½œçš„å¯¹è±¡ï¼Œåº”ç”¨åœºæ™¯ï¼Œæ¯”å¦‚åŠ è½½é…ç½®æ–‡ä»¶åªéœ€è¦åŠ è½½ä¸€æ¬¡ã€‚ é¦–æ¬¡ä½¿ç”¨Onceåï¼Œä¸èƒ½å¤åˆ¶Onceã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 // Once is an object that will perform exactly one action. // // A Once must not be copied after first use. type Once struct { // done indicates whether the action has been performed. // It is first in the struct because it is used in the hot path. // The hot path is inlined at every call site. // Placing done first allows more compact instructions on some architectures (amd64/386), // and fewer instructions (to calculate offset) on other architectures. // // done è¡¨ç¤ºæ“ä½œæ˜¯å¦å·²ç»æ‰§è¡Œã€‚ // å®ƒåœ¨ç»“æ„ä½“ä¸­ä½äºé¦–ä½ï¼Œå› ä¸ºå®ƒåœ¨ hot path ä¸­ä½¿ç”¨ã€‚ // hot path å†…è”åœ¨æ¯ä¸ªè°ƒç”¨ç‚¹ã€‚ // åœ¨æŸäº›ä½“ç³»ç»“æ„ä¸Š(amd64/386)ï¼Œå°†doneæ”¾åœ¨ç¬¬ä¸€ä½å¯ä»¥è®©æŒ‡ä»¤æ›´ç´§å‡‘ï¼Œè€Œåœ¨å…¶ä»–ä½“ç³»ç»“æ„ä¸Šå¯ä»¥è®©æŒ‡ä»¤æ›´å°‘(ç”¨äºè®¡ç®—åç§»é‡)ã€‚ done uint32\t// 0.æœªè¢«è°ƒç”¨è¿‡ 1.å·²è¢«è°ƒç”¨è¿‡ m Mutex\t// äº’æ–¥é” } // å…¶ä¸­è§£é‡Šäº†ä¸ºä»€ä¹ˆå°† done ç½®ä¸º Once çš„ç¬¬ä¸€ä¸ªå­—æ®µï¼šdone åœ¨çƒ­è·¯å¾„ä¸­ï¼Œdone æ”¾åœ¨ç¬¬ä¸€ä¸ªå­—æ®µï¼Œèƒ½å¤Ÿå‡å°‘ CPU æŒ‡ä»¤ï¼Œä¹Ÿå°±æ˜¯è¯´ï¼Œè¿™æ ·åšèƒ½å¤Ÿæå‡æ€§èƒ½ã€‚ // 1. çƒ­è·¯å¾„(hot path)æ˜¯ç¨‹åºéå¸¸é¢‘ç¹æ‰§è¡Œçš„ä¸€ç³»åˆ—æŒ‡ä»¤ï¼Œsync.Once ç»å¤§éƒ¨åˆ†åœºæ™¯éƒ½ä¼šè®¿é—® o.doneï¼Œåœ¨çƒ­è·¯å¾„ä¸Šæ˜¯æ¯”è¾ƒå¥½ç†è§£çš„ï¼Œ //\tå¦‚æœ hot path ç¼–è¯‘åçš„æœºå™¨ç æŒ‡ä»¤æ›´å°‘ï¼Œæ›´ç›´æ¥ï¼Œå¿…ç„¶æ˜¯èƒ½å¤Ÿæå‡æ€§èƒ½çš„ã€‚ // 2. ä¸ºä»€ä¹ˆæ”¾åœ¨ç¬¬ä¸€ä¸ªå­—æ®µå°±èƒ½å¤Ÿå‡å°‘æŒ‡ä»¤å‘¢ï¼Ÿå› ä¸ºç»“æ„ä½“ç¬¬ä¸€ä¸ªå­—æ®µçš„åœ°å€å’Œç»“æ„ä½“çš„æŒ‡é’ˆæ˜¯ç›¸åŒçš„ï¼Œå¦‚æœæ˜¯ç¬¬ä¸€ä¸ªå­—æ®µï¼Œç›´æ¥å¯¹ç»“æ„ä½“çš„æŒ‡é’ˆè§£å¼•ç”¨å³å¯ã€‚ // å¦‚æœæ˜¯å…¶ä»–çš„å­—æ®µï¼Œé™¤äº†ç»“æ„ä½“æŒ‡é’ˆå¤–ï¼Œè¿˜éœ€è¦è®¡ç®—ä¸ç¬¬ä¸€ä¸ªå€¼çš„åç§»(calculate offset)ã€‚åœ¨æœºå™¨ç ä¸­ï¼Œåç§»é‡æ˜¯éšæŒ‡ä»¤ä¼ é€’çš„é™„åŠ å€¼ï¼Œ // CPU éœ€è¦åšä¸€æ¬¡åç§»å€¼ä¸æŒ‡é’ˆçš„åŠ æ³•è¿ç®—ï¼Œæ‰èƒ½è·å–è¦è®¿é—®çš„å€¼çš„åœ°å€ã€‚å› ä¸ºï¼Œè®¿é—®ç¬¬ä¸€ä¸ªå­—æ®µçš„æœºå™¨ä»£ç æ›´ç´§å‡‘ï¼Œé€Ÿåº¦æ›´å¿«ã€‚ Do() å½“ä¸”ä»…å½“ Do æ˜¯ç¬¬ä¸€æ¬¡ä¸º Once å®ä¾‹è°ƒç”¨å‡½æ•° f æ—¶ï¼ŒDo æ‰ä¼šè°ƒç”¨å‡½æ•° fã€‚ æ¢å¥è¯è¯´ï¼Œç»™å®švar once Onceï¼Œå¦‚æœ once.Do(f) è¢«å¤šæ¬¡è°ƒç”¨ï¼Œåªæœ‰ç¬¬ä¸€æ¬¡è°ƒç”¨ä¼šè°ƒç”¨fï¼Œå³ä½¿æ¯æ¬¡è°ƒç”¨ f çš„å€¼ä¸åŒã€‚ æ¯ä¸ªå‡½æ•°æ‰§è¡Œæ—¶éƒ½éœ€è¦ä¸€ä¸ª Once çš„æ–°å®ä¾‹ã€‚ Do ç”¨äºå¿…é¡»åªè¿è¡Œä¸€æ¬¡çš„åˆå§‹åŒ–ã€‚ ç”±äº f æ˜¯ niladicï¼Œå› æ­¤å¯èƒ½éœ€è¦ä½¿ç”¨å‡½æ•°å­—é¢é‡æ¥æ•è·Doè°ƒç”¨çš„å‡½æ•°çš„å‚æ•°:config.once.Do(func() { config.init(filename) }) niladicï¼šè¢«è§£é‡Šä¸ºä¸å¸¦å‚æ•°çš„é—­åŒ…å‡½æ•°ã€‚ å› ä¸ºåªæœ‰åœ¨å¯¹ f çš„è°ƒç”¨è¿”å›ä¹‹å‰ï¼Œæ‰ä¼šè¿”å›å¯¹ Do çš„è°ƒç”¨ï¼Œå¦‚æœ f å¯¼è‡´Doè¢«è°ƒç”¨ï¼Œå®ƒå°±ä¼šæ­»é”ã€‚ï¼ˆfå‡½æ•°å†…ä¸èƒ½åœ¨è°ƒç”¨å¤–å±‚çš„Doå‡½æ•°ï¼‰ å¦‚æœfå‘ç”Ÿpanicï¼ŒDoè®¤ä¸ºå®ƒå›æ¥äº†;Doçš„åç»­è°ƒç”¨ä¸éœ€è¦è°ƒç”¨fã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 // Do calls the function f if and only if Do is being called for the // first time for this instance of Once. In other words, given // var once Once // if once.Do(f) is called multiple times, only the first call will invoke f, // even if f has a different value in each invocation. A new instance of // Once is required for each function to execute. // // Do is intended for initialization that must be run exactly once. Since f // is niladic, it may be necessary to use a function literal to capture the // arguments to a function to be invoked by Do: // config.once.Do(func() { config.init(filename) }) // // Because no call to Do returns until the one call to f returns, if f causes // Do to be called, it will deadlock. // // If f panics, Do considers it to have returned; future calls of Do return // without calling f. func (o *Once) Do(f func()) { // Note: Here is an incorrect implementation of Do: // //\tif atomic.CompareAndSwapUint32(\u0026amp;o.done, 0, 1) { //\tf() //\t} // // Do guarantees that when it returns, f has finished. // This implementation would not implement that guarantee: // given two simultaneous calls, the winner of the cas would // call f, and the second would return immediately, without // waiting for the first\u0026#39;s call to f to complete. // This is why the slow path falls back to a mutex, and why // the atomic.StoreUint32 must be delayed until after f returns. // // æ³¨æ„:ä¸‹é¢æ˜¯ä¸€ä¸ªä¸æ­£ç¡®çš„Doå®ç°ã€‚ // ä»¥ä¸‹å½¢å¼ä¸èƒ½ä¿è¯Doå‡½æ•°è¿”å›æ—¶få‡½æ•°å·²æ‰§è¡Œå®Œï¼Œå› ä¸ºæˆ‘ä»¬æ˜¯å…ˆæ ‡è®°åæ‰§è¡Œfçš„ã€‚ // if atomic.CompareAndSwapUint32(\u0026amp;o.done, 0, 1) { // f() // } // // Do ä¿è¯å½“å®ƒè¿”å›æ—¶ï¼Œf å·²ç»å®Œæˆ // è¿™ç§å®ç°ä¸ä¼šå®ç°è¿™ç§ä¿è¯:ç»™å®šä¸¤ä¸ªåŒæ—¶è°ƒç”¨ï¼Œcasçš„èµ¢å®¶å°†è°ƒç”¨fï¼Œè€Œç¬¬äºŒä¸ªå°†ç«‹å³è¿”å›ï¼Œè€Œæ— éœ€ç­‰å¾…ç¬¬ä¸€ä¸ªè°ƒç”¨å®Œæˆã€‚ // è¿™å°±æ˜¯æ…¢è·¯å¾„å›é€€åˆ°äº’æ–¥é‡çš„åŸå› ï¼Œä¹Ÿæ˜¯åŸå­æ€§çš„åŸå› ã€‚StoreUint32å¿…é¡»å»¶è¿Ÿåˆ°fè¿”å›ä¹‹åã€‚ // åç»­å¤§éƒ¨åˆ†æƒ…å†µä¼šä»è¿™é‡Œåˆ¤æ–­å¤±è´¥ if atomic.LoadUint32(\u0026amp;o.done) == 0 { // Outlined slow-path to allow inlining of the fast-path. o.doSlow(f) } } doSlow() 1 2 3 4 5 6 7 8 9 10 11 12 func (o *Once) doSlow(f func()) { o.m.Lock() // è·å–é” defer o.m.Unlock() // å»¶è¿Ÿé‡Šæ”¾é” // å½“å‡ºç°å¹¶å‘æ—¶ï¼Œè¿™é‡Œä¼šæ‹¦ä½ç­‰å¾…ç€çš„åç¨‹ if o.done == 0 {\t// åœ¨f()æ‰§è¡Œå®Œåæ‰ä¼šæ ‡è®°doneä¸º1ã€‚ defer atomic.StoreUint32(\u0026amp;o.done, 1) // éœ€è¦ä¿è¯få‡½æ•°ä¸ä¼šå‘ç”Ÿpanic // å¦‚æœå‘ç”Ÿpanicï¼Œåˆ™o.doneä¼šè¢«æ ‡è®°ä¸º1ï¼Œåç»­ä¸ä¼šåœ¨è°ƒç”¨få‡½æ•° f() } } ä½¿ç”¨åœºæ™¯ sync.Once æ˜¯ Go æ ‡å‡†åº“æä¾›çš„ä½¿å‡½æ•°åªæ‰§è¡Œä¸€æ¬¡çš„å®ç°ã€‚ å¸¸åº”ç”¨äºã€å•ä¾‹æ¨¡å¼ã€‘ï¼Œä¾‹å¦‚ã€åˆå§‹åŒ–é…ç½®ã€‘ã€ã€ä¿æŒæ•°æ®åº“è¿æ¥ã€‘ç­‰ã€‚ä½œç”¨ä¸ init å‡½æ•°ç±»ä¼¼ï¼Œä½†æœ‰åŒºåˆ«ã€‚ init å‡½æ•°æ˜¯å½“æ‰€åœ¨çš„ package é¦–æ¬¡è¢«åŠ è½½æ—¶æ‰§è¡Œï¼Œè‹¥è¿Ÿè¿Ÿæœªè¢«ä½¿ç”¨ï¼Œåˆ™æ—¢æµªè´¹äº†å†…å­˜ï¼Œåˆå»¶é•¿äº†ç¨‹åºåŠ è½½æ—¶é—´ã€‚ sync.Once å¯ä»¥åœ¨ä»£ç çš„ä»»æ„ä½ç½®åˆå§‹åŒ–å’Œè°ƒç”¨ï¼Œå› æ­¤å¯ä»¥å»¶è¿Ÿåˆ°ä½¿ç”¨æ—¶å†æ‰§è¡Œï¼Œå¹¶å‘åœºæ™¯ä¸‹æ˜¯çº¿ç¨‹å®‰å…¨çš„ã€‚ åœ¨å¤šæ•°æƒ…å†µä¸‹ï¼Œsync.Once è¢«ç”¨äºæ§åˆ¶å˜é‡çš„åˆå§‹åŒ–ï¼Œè¿™ä¸ªå˜é‡çš„è¯»å†™æ»¡è¶³å¦‚ä¸‹ä¸‰ä¸ªæ¡ä»¶ï¼š å½“ä¸”ä»…å½“ç¬¬ä¸€æ¬¡è®¿é—®æŸä¸ªå˜é‡æ—¶ï¼Œè¿›è¡Œåˆå§‹åŒ–ï¼ˆå†™ï¼‰ã€‚ å˜é‡åˆå§‹åŒ–è¿‡ç¨‹ä¸­ï¼Œæ‰€æœ‰è¯»éƒ½è¢«é˜»å¡ï¼Œç›´åˆ°åˆå§‹åŒ–å®Œæˆã€‚ å˜é‡ä»…åˆå§‹åŒ–ä¸€æ¬¡ï¼Œåˆå§‹åŒ–å®Œæˆåé©»ç•™åœ¨å†…å­˜é‡Œã€‚ sync.Once ä»…æä¾›äº†ä¸€ä¸ªæ–¹æ³• Doï¼Œå‚æ•° f æ˜¯å¯¹è±¡åˆå§‹åŒ–å‡½æ•°ã€‚ func (o *Once) Do(f func())ã€‚ ä½¿ç”¨ç¤ºä¾‹ ç®€å•çš„ç¤ºä¾‹ è€ƒè™‘ä¸€ä¸ªç®€å•çš„åœºæ™¯ï¼Œå‡½æ•° ReadConfig éœ€è¦è¯»å–ç¯å¢ƒå˜é‡ï¼Œå¹¶è½¬æ¢ä¸ºå¯¹åº”çš„é…ç½®ã€‚ ç¯å¢ƒå˜é‡åœ¨ç¨‹åºæ‰§è¡Œå‰å·²ç»ç¡®å®šï¼Œæ‰§è¡Œè¿‡ç¨‹ä¸­ä¸ä¼šå‘ç”Ÿæ”¹å˜ã€‚ ReadConfig å¯èƒ½ä¼šè¢«å¤šä¸ªåç¨‹å¹¶å‘è°ƒç”¨ï¼Œä¸ºäº†æå‡æ€§èƒ½ï¼ˆå‡å°‘æ‰§è¡Œæ—¶é—´å’Œå†…å­˜å ç”¨ï¼‰ï¼Œä½¿ç”¨ sync.Once æ˜¯ä¸€ä¸ªæ¯”è¾ƒå¥½çš„æ–¹å¼ã€‚ åœ¨è¿™ä¸ªä¾‹å­ä¸­ï¼Œå£°æ˜äº† 2 ä¸ªå…¨å±€å˜é‡ï¼Œonce å’Œ configã€‚ config æ˜¯éœ€è¦åœ¨ ReadConfig å‡½æ•°ä¸­åˆå§‹åŒ–çš„(å°†ç¯å¢ƒå˜é‡è½¬æ¢ä¸º Config ç»“æ„ä½“)ï¼ŒReadConfig å¯èƒ½ä¼šè¢«å¹¶å‘è°ƒç”¨ã€‚ å¦‚æœ ReadConfig æ¯æ¬¡éƒ½æ„é€ å‡ºä¸€ä¸ªæ–°çš„ Config ç»“æ„ä½“ï¼Œæ—¢æµªè´¹å†…å­˜ï¼Œåˆæµªè´¹åˆå§‹åŒ–æ—¶é—´ã€‚ å¦‚æœ ReadConfig ä¸­ä¸åŠ é”ï¼Œåˆå§‹åŒ–å…¨å±€å˜é‡ config å°±å¯èƒ½å‡ºç°å¹¶å‘å†²çªã€‚ è¿™ç§æƒ…å†µä¸‹ï¼Œä½¿ç”¨ sync.Once æ—¢èƒ½å¤Ÿä¿è¯å…¨å±€å˜é‡åˆå§‹åŒ–æ—¶æ˜¯çº¿ç¨‹å®‰å…¨çš„ï¼Œåˆèƒ½èŠ‚çœå†…å­˜å’Œåˆå§‹åŒ–æ—¶é—´ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 type Config struct { Server string Port int64 } var ( once sync.Once config *Config ) func ReadConfig() *Config { once.Do(func() { var err error config = \u0026amp;Config{Server: os.Getenv(\u0026#34;TT_SERVER_URL\u0026#34;)} config.Port, err = strconv.ParseInt(os.Getenv(\u0026#34;TT_PORT\u0026#34;), 10, 0) if err != nil { config.Port = 8080 // default port } log.Println(\u0026#34;init config\u0026#34;) }) return config } func main() { for i := 0; i \u0026lt; 10; i++ { go func() { _ = ReadConfig() }() } time.Sleep(time.Second) } æ ‡å‡†åº“ä¸­çš„ä½¿ç”¨ æ¯”å¦‚ package html ä¸­ï¼Œå¯¹è±¡ entity åªè¢«åˆå§‹åŒ–ä¸€æ¬¡ã€‚ å­—å…¸ entity åŒ…å« 2005 ä¸ªé”®å€¼å¯¹ï¼Œè‹¥ä½¿ç”¨ init åœ¨åŒ…åŠ è½½æ—¶åˆå§‹åŒ–ï¼Œè‹¥ä¸è¢«ä½¿ç”¨ï¼Œå°†ä¼šæµªè´¹å¤§é‡å†…å­˜ã€‚ html.UnescapeString(s) å‡½æ•°æ˜¯çº¿ç¨‹å®‰å…¨çš„ï¼Œå¯èƒ½ä¼šè¢«ç”¨æˆ·ç¨‹åºåœ¨å¹¶å‘åœºæ™¯ä¸‹è°ƒç”¨ï¼Œå› æ­¤å¯¹ entity çš„åˆå§‹åŒ–éœ€è¦åŠ é”ï¼Œä½¿ç”¨ sync.Once èƒ½ä¿è¯è¿™ä¸€ç‚¹ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 var populateMapsOnce sync.Once var entity map[string]rune func populateMaps() { entity = map[string]rune{ \u0026#34;AElig;\u0026#34;: \u0026#39;\\U000000C6\u0026#39;, \u0026#34;AMP;\u0026#34;: \u0026#39;\\U00000026\u0026#39;, \u0026#34;Aacute;\u0026#34;: \u0026#39;\\U000000C1\u0026#39;, \u0026#34;Abreve;\u0026#34;: \u0026#39;\\U00000102\u0026#39;, \u0026#34;Acirc;\u0026#34;: \u0026#39;\\U000000C2\u0026#39;, // çœç•¥ 2000 é¡¹ } } func UnescapeString(s string) string { populateMapsOnce.Do(populateMaps) i := strings.IndexByte(s, \u0026#39;\u0026amp;\u0026#39;) if i \u0026lt; 0 { return s } // çœç•¥åç»­çš„å®ç° } æ™®é€šç¤ºä¾‹ å¯¹åªéœ€è¦è¿è¡Œä¸€æ¬¡çš„ä»£ç ï¼Œå¦‚å…¨å±€æ€§çš„åˆå§‹åŒ–æ“ä½œï¼Œæˆ–è€…é˜²æ­¢å¤šæ¬¡é‡å¤æ‰§è¡Œï¼ˆæ¯”å¦‚é‡å¤æäº¤ç­‰ï¼‰éƒ½æœ‰å¾ˆå¥½çš„ä½œç”¨ æ— è®º sync.Once.Do(f func()) é‡Œé¢çš„få‡½æ•°æ˜¯å¦å˜åŒ–ï¼Œåªè¦ Once.Do() è¿è¡Œä¸€æ¬¡å°±æ²¡æœ‰æœºä¼šå†æ¬¡è¿è¡Œäº† Once æ˜¯ä¸€ä¸ªç»“æ„ä½“ï¼Œé€šè¿‡åˆ¤æ–­ done å€¼æ¥ç¡®å®šæ˜¯å¦æ‰§è¡Œä¸‹ä¸€æ­¥ å½“ done ä¸º1æ—¶ç›´æ¥è¿”å›ï¼Œå¦åˆ™é”å®šåæ‰§è¡Œfå‡½æ•°ä»¥åŠç½®doneå€¼ä¸º1 è€Œå¯¹ done çš„å€¼å¾—ä¿®æ”¹ä½¿ç”¨äº† atomic.StoreUint32ï¼ˆåŸå­çº§çš„æ“ä½œï¼‰ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;sync\u0026#34; \u0026#34;time\u0026#34; ) var once sync.Once func onces() { fmt.Println(\u0026#34;once\u0026#34;) } func onced() { fmt.Println(\u0026#34;onced\u0026#34;) } func main() { for i, v := range make([]string, 10){ once.Do(onces) fmt.Println(\u0026#34;v:\u0026#34;, v, \u0026#34;--i:\u0026#34;, i) } for i := 0; i \u0026lt; 10; i++ { go func(i int) { once.Do(onced) fmt.Println(i) }(i) } time.Sleep(3 * time.Second) } once v: --i: 0 v: --i: 1 v: --i: 2 v: --i: 3 v: --i: 4 v: --i: 5 v: --i: 6 v: --i: 7 v: --i: 8 v: --i: 9 0 1 3 4 2 6 5 7 8 9 ","permalink":"https://heliu.site/posts/golang/sync/once/","summary":"Onceæ˜¯åªæ‰§è¡Œä¸€ä¸ªåŠ¨ä½œçš„å¯¹è±¡ã€‚","title":"sync.Once"},{"content":"type Mutex struct ğŸš€ åŒ…è¯´æ˜ï¼š\nsync åŒ…æä¾›äº†åŸºæœ¬çš„åŒæ­¥åŸè¯­ï¼Œå¦‚äº’æ–¥é”ã€‚ é™¤äº† Once å’Œ WaitGroup ç±»å‹ä¹‹å¤–ï¼Œå¤§å¤šæ•°éƒ½ä¾›åº•å±‚åº“ä¾‹ç¨‹ä½¿ç”¨ã€‚ æ›´é«˜å±‚æ¬¡çš„åŒæ­¥æœ€å¥½é€šè¿‡ channels å’Œé€šä¿¡æ¥å®Œæˆã€‚ åŒ…å«åœ¨æ­¤åŒ…ä¸­å®šä¹‰çš„ç±»å‹çš„å€¼ä¸åº”è¢«å¤åˆ¶ã€‚ 1 2 3 4 5 6 7 // Package sync provides basic synchronization primitives such as mutual // exclusion locks. Other than the Once and WaitGroup types, most are intended // for use by low-level library routines. Higher-level synchronization is // better done via channels and communication. // // Values containing the types defined in this package should not be copied. package sync Mutex æ˜¯ä¸€æŠŠäº’æ–¥é”ã€‚äº’æ–¥é”çš„é›¶å€¼æ˜¯æœªé”å®šçš„ã€‚ Mutex åœ¨ç¬¬ä¸€æ¬¡ä½¿ç”¨åä¸èƒ½è¢«å¤åˆ¶ã€‚ åœ¨ Go å†…å­˜æ¨¡å‹çš„æœ¯è¯­ä¸­ï¼Œç¬¬ n æ¬¡è°ƒç”¨ Unlockï¼Œç¬¬ m æ¬¡è°ƒç”¨ Lock åœ¨åŒæ­¥å®Œæˆä»¥å‰ ä»»ä½• n \u0026lt; mã€‚ æˆåŠŸè°ƒç”¨ TryLock ç­‰åŒäºè°ƒç”¨ Lockã€‚è°ƒç”¨ TryLock å¤±è´¥æ ¹æœ¬ä¸ä¼šå»ºç«‹ä»»ä½•å…³ç³» åœ¨åŒæ­¥å®Œæˆä»¥å‰ã€‚ å®ƒæ˜¯ä¸€æŠŠç»“åˆäº†ã€è‡ªæ—‹é”ã€‘å’Œã€ä¿¡å·é‡ã€‘ä¼˜åŒ–è¿‡çš„é”ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 // A Mutex is a mutual exclusion lock. // The zero value for a Mutex is an unlocked mutex. // // A Mutex must not be copied after first use. // // In the terminology of the Go memory model, // the n\u0026#39;th call to Unlock â€œsynchronizes beforeâ€ the m\u0026#39;th call to Lock // for any n \u0026lt; m. // A successful call to TryLock is equivalent to a call to Lock. // A failed call to TryLock does not establish any â€œsynchronizes beforeâ€ // relation at all. type Mutex struct { // Mutex çš„çŠ¶æ€ä¿¡æ¯ state int32\t// åˆå§‹æ—¶ä¸º 0 // semaphore ç›¸å…³å­—æ®µï¼Œè¯¥å­—æ®µä¹Ÿæ˜¯ä¸ºä»€ä¹ˆ Mutex ä¸è®©æ‹·è´çš„åŸå›  sema uint32 // åˆå§‹æ—¶ä¸º 0 } Mutex çš„å†…å­˜å¸ƒå±€ï¼š Mutex æ˜¯ä¸€ä¸ªäº’æ–¥é”ï¼Œå¯ä»¥åˆ›å»ºä¸ºå…¶ä»–ç»“æ„ä½“çš„å­—æ®µï¼Œé›¶å€¼ä¸ºè§£é”çŠ¶æ€ã€‚ Mutex ç±»å‹çš„é”å’Œçº¿ç¨‹æ— å…³ï¼Œå¯ä»¥ç”±ä¸åŒçš„çº¿ç¨‹åŠ é”å’Œè§£é”ã€‚ Mutex ç»“æ„å¸ƒå±€ï¼š state è®°å½• Mutex çš„ç›¸å…³ä¿¡æ¯ã€‚ sema åœ¨ Mutex ä¸­æ²¡æœ‰ä»»ä½•ä½œç”¨ï¼Œä¸»è¦æ˜¯åœ¨ semaphore ä¸­ï¼Œè¯¥å­—æ®µæ˜¯ Mutex ä¸èƒ½è¢«æ‹·è´çš„æ ¹æœ¬åŸå› ï¼Œåœ¨ semaphore ä¸­ä¸»è¦æ ‡è¯†æœ‰ wakeup å‘ç”Ÿã€‚ ã€æ­£å¸¸æ¨¡å¼ã€‘å’Œã€é¥¥é¥¿æ¨¡å¼ã€‘ï¼š æ­£å¸¸æ¨¡å¼ï¼šä¸€ä¸ªå°è¯•åŠ é”çš„ goroutine ä¼šå…ˆè‡ªæ—‹å‡ æ¬¡ï¼Œå°è¯•é€šè¿‡åŸå­æ“ä½œè·å¾—é”ï¼Œè‹¥å‡ æ¬¡è‡ªæ—‹ä¹‹åä»ä¸èƒ½è·å¾—é”ï¼Œåˆ™é€šè¿‡ä¿¡å·é‡ï¼ˆsemaphoreï¼‰æ’é˜Ÿç­‰å¾…ã€‚æ‰€æœ‰çš„ç­‰å¾…è€…ä¼šæŒ‰ç…§å…ˆå…¥å…ˆå‡ºï¼ˆFIFOï¼‰çš„é¡ºåºæ’é˜Ÿï¼Œä½†æ˜¯å½“ä¸€ä¸ªç­‰å¾…è€…è¢«å”¤é†’åå¹¶ä¸ä¼šç›´æ¥æ‹¥æœ‰é”ï¼Œè€Œæ˜¯éœ€è¦å’Œåæ¥è€…ï¼ˆå¤„äºè‡ªæ—‹é˜¶æ®µï¼Œå°šæœªæ’é˜Ÿç­‰å¾…çš„åç¨‹ï¼‰ç«äº‰ã€‚è¿™ç§æƒ…å†µä¸‹åæ¥è€…æ›´æœ‰ä¼˜åŠ¿ï¼Œä¸€æ–¹é¢åŸå› æ˜¯åæ¥è€…æ­£åœ¨CPUä¸Šè¿è¡Œï¼Œè‡ªç„¶æ¯”åˆšå”¤é†’çš„ goroutine æ›´æœ‰ä¼˜åŠ¿ï¼Œå¦ä¸€æ–¹é¢å¤„äºè‡ªæ—‹çŠ¶æ€çš„ goroutine å¯ä»¥æœ‰å¾ˆå¤šï¼Œè€Œè¢«å”¤é†’çš„ goroutine æ¯æ¬¡åªæœ‰ä¸€ä¸ªï¼Œæ‰€ä»¥è¢«å”¤é†’çš„ goroutine æœ‰å¾ˆå¤§æ¦‚ç‡è·å–ä¸åˆ°é”ï¼Œè¿™ç§æƒ…å†µä¸‹å®ƒä¼šè¢«é‡æ–°æ’å…¥é˜Ÿåˆ—çš„å¤´éƒ¨ï¼Œè€Œä¸æ˜¯å°¾éƒ¨ã€‚å½“ä¸€ä¸ª goroutine æœ¬æ¬¡åŠ é”ç­‰å¾…çš„æ—¶é—´è¶…è¿‡äº† 1ms åï¼Œå®ƒä¼šæŠŠå½“å‰ Mutex åˆ‡æ¢è‡³é¥¥é¥¿çŠ¶æ€ã€‚ é¥¥é¥¿æ¨¡å¼ï¼šMutex çš„æ‰€æœ‰æƒä»æ‰§è¡Œ Unlock çš„ goroutine ç›´æ¥ä¼ é€’ç»™ç­‰å¾…é˜Ÿåˆ—å¤´éƒ¨çš„ goroutineã€‚åæ¥è€…ä¸ä¼šè‡ªæ—‹ï¼Œä¹Ÿä¸ä¼šå°è¯•è·å¾—é”ï¼Œå®ƒä»¬ä¼šç›´æ¥ä»é˜Ÿåˆ—çš„å°¾éƒ¨æ’é˜Ÿç­‰å¾…ï¼Œå³ä½¿ Mutex å¤„äº Unlocked çŠ¶æ€ã€‚å½“ä¸€ä¸ªç­‰å¾…è€…è·å¾—äº†é”ä¹‹åï¼Œå®ƒä¼šåœ¨ä»¥ä¸‹ä¸¤ç§æƒ…å†µæ—¶å°† Mutex ç”±é¥¥é¥¿æ¨¡å¼åˆ‡æ¢å›æ­£å¸¸æ¨¡å¼ï¼š(1)å®ƒæ˜¯æœ€åä¸€ä¸ªç­‰å¾…è€…ï¼Œå³ç­‰å¾…é˜Ÿåˆ—ç©ºäº†ã€‚(2)å®ƒçš„ç­‰å¾…æ—¶é—´å°äº1msï¼Œä¹Ÿå°±æ˜¯å®ƒåˆšæ¥ä¸ä¹…ï¼Œåé¢è‡ªç„¶æ›´æ²¡æœ‰é¥¥é¥¿çš„ goroutine äº†ã€‚ æ­£å¸¸æ¨¡å¼ä¸‹ Mutex æœ‰æ›´å¥½çš„æ€§èƒ½ï¼Œä½†æ˜¯é¥¥é¥¿æ¨¡å¼å¯¹äºé˜²æ­¢å°¾ç«¯å»¶é•¿ï¼ˆé˜Ÿåˆ—å°¾ç«¯çš„ goroutine è¿Ÿè¿ŸæŠ¢ä¸åˆ°é”ï¼‰æ¥è®²ç‰¹åˆ«é‡è¦ã€‚ const 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 const ( // æ˜¯å¦ä¸Šé”æ ‡å¿—ä½ï¼›0-æœªä¸Šé”ï¼Œ1-å·²ä¸Šé”ï¼› mutexLocked = 1 \u0026lt;\u0026lt; iota\t// 001 // æ˜¯å¦æœ‰ goroutine ä»é˜»å¡ä¸­è¢«å”¤é†’ï¼›0-æ²¡æœ‰ï¼›1-æœ‰ï¼› // å½“è¯¥æ ‡å¿—ä½è¢«è®¾ç½®æ—¶ï¼ŒUnlock æ“ä½œä¸ä¼šå”¤é†’æ’é˜Ÿçš„ goroutineã€‚ mutexWoken\t// 010 // æ˜¯å¦å¤„äºé¥¥é¥¿æ¨¡å¼ï¼›0-éé¥¥é¥¿ï¼Œ1-é¥¥é¥¿ï¼› mutexStarving\t// 100 // æœ€ä½ä½å­˜åœ¨3ä¸ªbitä½æ ‡è¯†ç‰¹ä¿—ä¿¡æ¯ï¼Œåˆ†åˆ«ä¸ºä¸Šè¿°çš„ mutexLockedã€mutexWokenã€mutexStarving mutexWaiterShift = iota\t// 3 // äº’æ–¥å…¬å¹³ // äº’æ–¥é‡å¯ä»¥æœ‰ä¸¤ç§æ“ä½œæ¨¡å¼:æ­£å¸¸(normal)å’Œé¥¥é¥¿(starvation)ã€‚ // åœ¨æ­£å¸¸æ¨¡å¼(normal mode)ä¸‹ï¼šç­‰å¾…çš„waitersæŒ‰FIFO(å…ˆè¿›å…ˆå‡º)é¡ºåºæ’é˜Ÿï¼Œä½†è¢«å”¤é†’çš„waiterä¸æ‹¥æœ‰äº’æ–¥é”ï¼Œå¹¶ä¸æ–°åˆ°è¾¾çš„goroutinesç«äº‰æ‰€æœ‰æƒã€‚ // æ–°åŠ å…¥çš„goroutinesæœ‰ä¸€ä¸ªä¼˜åŠ¿ï¼Œå®ƒä»¬å·²ç»åœ¨CPUä¸Šè¿è¡Œï¼Œå¹¶ä¸”å¯èƒ½æœ‰å¾ˆå¤šï¼Œæ‰€ä»¥å”¤é†’çš„waiterså¾ˆæœ‰å¯èƒ½ä¼šå¤±è´¥ã€‚ // åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œå®ƒè¢«é‡æ–°å®‰æ’åœ¨ç­‰å¾…é˜Ÿåˆ—çš„å‰é¢ã€‚å¦‚æœwaiterè¶…è¿‡1msæœªèƒ½è·å–äº’æ–¥é”ï¼Œå®ƒå°†äº’æ–¥é”åˆ‡æ¢åˆ°é¥¥é¥¿æ¨¡å¼ã€‚ // åœ¨é¥¥é¥¿æ¨¡å¼(starvation mode)ä¸‹ï¼šäº’æ–¥é”çš„æ‰€æœ‰æƒç›´æ¥ä»æ­£åœ¨è§£é”çš„goroutineç§»äº¤ç»™é˜Ÿåˆ—å‰é¢çš„waiterã€‚ // æ–°åˆ°è¾¾çš„goroutinesä¸ä¼šå°è¯•è·å–äº’æ–¥é”ï¼Œå³ä½¿å®ƒçœ‹èµ·æ¥å·²ç»è§£é”ï¼Œä¹Ÿä¸ä¼šå°è¯•æ—‹è½¬ã€‚ç›¸åï¼Œå®ƒä»¬æŠŠè‡ªå·±æ’åœ¨ç­‰å¾…é˜Ÿåˆ—çš„å°¾éƒ¨ã€‚ // å¦‚æœä¸€ä¸ªwaiteræ”¶åˆ°äº’æ–¥é”çš„æ‰€æœ‰æƒï¼Œå¹¶ä¸”å‘ç° //\t1) å®ƒæ˜¯é˜Ÿåˆ—ä¸­æœ€åä¸€ä¸ªwaiterï¼Œæˆ–è€… //\t2) å®ƒç­‰å¾…çš„æ—¶é—´å°‘äº1æ¯«ç§’ï¼Œå®ƒä¼šå°†äº’æ–¥é”åˆ‡æ¢å›æ­£å¸¸å·¥ä½œæ¨¡å¼ã€‚ // æ™®é€šæ¨¡å¼(Normal mode)å…·æœ‰æ›´å¥½çš„æ€§èƒ½ï¼Œå› ä¸ºgoroutineå¯ä»¥è¿ç»­å¤šæ¬¡è·å–äº’æ–¥é‡ï¼Œå³ä½¿æœ‰é˜»å¡çš„ç­‰å¾…ã€‚ // é¥¥é¥¿æ¨¡å¼(Starvation mode)å¯¹äºé¢„é˜²æœ‰äº›gä¸€å€¼è·å–ä¸åˆ°é”çš„å°¾å»¶è¿Ÿå…·æœ‰é‡è¦æ„ä¹‰ã€‚(è¯¥æ¨¡å¼é˜²æ­¢æœ‰äº›å§‹ç»ˆæ‹¿ä¸åˆ°é”çš„ä¸€ç›´ç­‰å¾…åœ¨ä¿¡å·æ± é‡Œé¢çš„goroutine) // æ­£å¸¸æ¨¡å¼ \u0026lt;-\u0026gt; é¥¥é¥¿æ¨¡å¼ ç›¸äº’è½¬æ¢çš„æ—¶é—´é˜€é—¨ // é¥¥é¥¿æ¨¡å¼ï¼Œå½“å‰ä»semaphoreä¸­wakeupçš„goroutineçš„sleepæ—¶é—´è¶…è¿‡1msï¼Œå†æ¬¡è·å–é”å¤±è´¥æ—¶ä¼šè¢«æ ‡è®°ä¸ºé¥¥é¥¿æ¨¡å¼ // é¥¥é¥¿æ¨¡å¼ä¸‹ï¼šstate å€¼çš„ mutexLockedå’ŒmutexWoken ä½å¯èƒ½ä¸º0æˆ–1ï¼Œè¢«å”¤é†’çš„goroutine mutexLockedå’ŒmutexWoken ä½éƒ½ä¸º0 starvationThresholdNs = 1e6\t// sync.Mutex è¿›å…¥é¥¥é¥¿æ¨¡å¼çš„ç­‰å¾…æ—¶é—´é˜ˆå€¼1msã€‚ ) Lock() Lock é”ä½ mã€‚ å¦‚æœé”å·²ç»è¢«ä½¿ç”¨ï¼Œè°ƒç”¨ goroutine ä¼šé˜»å¡ï¼Œç›´åˆ° mutex å¯ç”¨ã€‚ Lock å’Œ Unlock æ˜¯ä¸€å¯¹æ“ä½œã€‚ è¯¥æ–¹æ³•ä¸»è¦é€šè¿‡ atomic å‡½æ•°å®ç°äº†Fast pathï¼Œç›¸åº”çš„Slow pathè¢«å•ç‹¬æ”¾åœ¨äº†lockSlow()æ–¹æ³•ä¸­ã€‚ æ ¹æ®æºç æ³¨é‡Šçš„è¯´æ³•ï¼Œè¿™æ ·æ˜¯ä¸ºäº†ä¾¿äºç¼–è¯‘å™¨å¯¹ Fast path è¿›è¡Œå†…è”ä¼˜åŒ–ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 // Lock locks m. // If the lock is already in use, the calling goroutine // blocks until the mutex is available. func (m *Mutex) Lock() { // 1) ä½¿ç”¨CASå°è¯•è·å–é” // Fast pathæœŸæœ› Mutex å¤„äº Unlocked çŠ¶æ€ï¼Œæ²¡æœ‰ goroutine åœ¨æ’é˜Ÿï¼Œæ›´ä¸ä¼šé¥¥é¥¿ã€‚ // ç†æƒ³çŠ¶æ€ä¸‹ï¼Œä¸€ä¸ªCASæ“ä½œå°±å¯ä»¥è·å¾—é”ã€‚ // Fast path: grab unlocked mutex. // // å¿«é€Ÿè·¯å¾„ï¼šè·å–è§£é”çš„äº’æ–¥é‡ã€‚ // åŸå­æ“ä½œæ¯”è¾ƒ m.state çš„æ—§å€¼ä¸º 0 å¹¶äº¤æ¢æˆæ–°å€¼ 1ï¼ŒæˆåŠŸåˆ™è¡¨ç¤ºè·å–åˆ°é”ã€‚ // è¿™ç§æƒ…å†µå‘ç”Ÿåœ¨ state=0 æ—¶ï¼Œæ²¡æœ‰ç­‰å¾…çš„goroutineã€‚ if atomic.CompareAndSwapInt32(\u0026amp;m.state, 0, mutexLocked) { if race.Enabled { race.Acquire(unsafe.Pointer(m)) } return } // 2) m.state != 0 æ—¶éƒ½ä¼šèµ° Slow path // CAS æ“ä½œæ²¡èƒ½è·å¾—é”ï¼Œå°±éœ€è¦è¿›å…¥ Slow pathäº†ã€‚ // Slow path (outlined so that the fast path can be inlined) // // å¦‚æœä¸Šé¢å¿«é€Ÿæ–¹å¼æ‹¿å–ä¸åˆ°é”ï¼Œåˆ™å»å’Œå…¶ä»–ç«äº‰ã€‚ä¸Šé¢æƒ…å†µæ‹¿ä¸åˆ°é”ï¼Œå¯èƒ½ï¼š // 1. å­˜åœ¨æœ‰å…¶ä»–goroutineæ­£åœ¨æŒæœ‰é”ã€‚ // 2. ä¸å­˜åœ¨å…¶ä»–goroutineæŒæœ‰é”ï¼Œå­˜åœ¨è¢«å”¤é†’çš„goroutineæˆ–è¿˜æœ‰ç­‰å¾…çš„goroutineã€‚ // å½“å‰å¯èƒ½å¤„äºã€æ­£å¸¸æ¨¡å¼ã€‘æˆ–ã€é¥¥é¥¿æ¨¡å¼ã€‘ m.lockSlow() } lockSlow() å¦‚æœè°ƒç”¨è€…æ‹¿å–ä¸åˆ°é”ï¼Œåˆ™ä¸‹é¢æ“ä½œæµç¨‹æ˜¯å…ˆè‡ªæ—‹è¯•å›¾æ‹¿å»é”ï¼Œå®åœ¨æ‹¿å–ä¸åˆ°é”åˆ™è¿›å…¥ä¿¡å·æ± å»ç­‰å¾…æ‹¿å–é”ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 // ç«äº‰è·å–é” // 1. å…ˆè‡ªæ—‹ç­‰å¾…å…¶ä»–goroutineè§£é”ï¼ˆæ»¡è¶³è‡ªæ—‹æ¡ä»¶æ—¶ï¼‰ // 2. å°è¯•ä¿®æ”¹ state å€¼ç«äº‰é” // 3. ç«äº‰æˆåŠŸï¼Œè·å–é”é€€å‡º // 4. ç«äº‰å¤±è´¥ï¼Œsleep goroutine func (m *Mutex) lockSlow() { // 1. å½“å‰goroutineé¦–æ¬¡è¿›å…¥semaphoreæ± sleepçš„æ—¶é—´/çº³ç§’ï¼Œä¸‹æ¬¡wakeupåç”¨äºåˆ¤æ–­ æ­£å¸¸æ¨¡å¼ \u0026lt;-\u0026gt; é¥¥é¥¿æ¨¡å¼ è½¬æ¢ // 2. queueLifo := waitStartTime != 0; è¿›å…¥ semaphore æ± çš„é¦–æˆ–å°¾ï¼Œfalse.å°¾ true.é¦– var waitStartTime int64\t// mutexæ¨¡å¼ ã€false.æ­£å¸¸æ¨¡å¼ã€‘ ã€true.é¥¥é¥¿æ¨¡å¼ã€‘ // 1. æ­£å¸¸æ¨¡å¼ä¸‹ï¼Œæ–°æ¥è·å–é”çš„goroutineå¦‚æœæ»¡è¶³æ¡ä»¶ä¼šè¿›è¡Œè‡ªæ—‹ç­‰å¾…é”è¢«é‡Šæ”¾ï¼Œå¦‚æœè¿˜æ‹¿å–ä¸åˆ°é”åˆ™å»ä¿¡å·æ± æœ€å‰é¢ç­‰å¾…ã€‚ // 2. é¥¥é¥¿æ¨¡å¼ä¸‹ï¼Œæ–°æ¥è·å–é”çš„goroutineä¸ä¼šè¿›è¡Œè‡ªæ—‹ï¼Œç›´æ¥å»ä¿¡å·æ± çš„æœ«å°¾å»ç­‰å¾…ã€‚ starving := false\t// æ˜¯å¦æœ‰goroutineè¢«å”¤é†’ false.æ²¡æœ‰ // æœ‰è¢«å”¤é†’çš„goroutineæ—¶ï¼Œä¼šè¯•å›¾å»æ‹¿å»é”ï¼Œå¯èƒ½æ˜¯è·Ÿå½“å‰æ­£åœ¨è·å–é”çš„goroutineç«äº‰ // 1. åœ¨è‡ªæ—‹æƒ…å†µä¸‹æ»¡è¶³æ¡ä»¶è®¾ç½® awoke ä¸º true // 2. éé¥¥é¥¿æ¨¡å¼ä¸‹è¢«å”¤é†’çš„goroutine awoke ä¼šè¢«è®¾ç½®ä¸º true // 3. åœ¨é¥¥é¥¿æ¨¡å¼ä¸‹ awoke å˜é‡æ²¡æœ‰ç”¨ awoke := false\t// ç”¨äºåŸå­è®¾ç½® mutexWoken ä½ï¼Œé€šçŸ¥ Unlock å‡½æ•°æœ‰ woken çš„goroutineäº†ï¼Œä¸è¦å»wakeup goroutine // è®°å½•æ—‹è½¬çš„æ¬¡æ•°ï¼Œå½“æ²¡æœ‰è·å–é”æ—¶ï¼Œä¼šå°è¯•4æ¬¡å»è‡ªæ—‹è·å– iter := 0\t// è‡ªæ—‹è®¡æ•°å™¨\t// ä»¥ä¸‹ä»£ç éƒ½æ˜¯ä» old -\u0026gt; new çš„åŸå­æ“ä½œï¼Œå»å°è¯•ä¿®æ”¹ state å€¼ old := m.state\t// æ—§å€¼state // è¯¥å¾ªç¯åªæœ‰åœ¨è·å–åˆ°é”çš„æ—¶å€™æ‰ä¼šé€€å‡ºï¼Œå› æ­¤æ‰€æœ‰æœªè·å–åˆ°é”çš„goroutineéƒ½å°†åœ¨è¿™é‡Œç­‰å¾…è·å–é” for { // 1) é¥¥é¥¿æ¨¡å¼ä¸‹ä¸è¦è‡ªæ—‹ï¼Œå› ä¸ºæ‰€æœ‰æƒæŒ‰ç…§é¡ºåºä¼ é€’ï¼Œè‡ªæ—‹æ²¡æœ‰æ„ä¹‰ã€‚ // æ­£å¸¸æ¨¡å¼ä¸‹é”æ²¡æœ‰è¢«é‡Šæ”¾æ»¡è¶³è‡ªæ—‹æ¡ä»¶éœ€è¦è‡ªæ—‹ã€‚ // Don\u0026#39;t spin in starvation mode, ownership is handed off to waiters // so we won\u0026#39;t be able to acquire the mutex anyway. // // ä¸è¦åœ¨é¥¥é¥¿æ¨¡å¼ä¸‹æ—‹è½¬ï¼Œæ‰€æœ‰æƒå·²ç§»äº¤ç»™waitersï¼Œå› æ­¤æˆ‘ä»¬æ— è®ºå¦‚ä½•éƒ½æ— æ³•è·å¾—äº’æ–¥é” // 1. old\u0026amp;(mutexLocked|mutexStarving) == mutexLocked; Mutexæ²¡æœ‰å¤„äºé¥¥é¥¿æ¨¡å¼å¹¶ä¸”å·²è¢«é”å®šã€‚ // 2. runtime_canSpin(iter); æŠ¥å‘Šå½“å‰æ—‹è½¬è¦æ±‚æ¡ä»¶ã€‚ //\tä¸»åŠ¨æ—‹è½¬æ¡ä»¶ï¼š //\tæ—‹è½¬æ¬¡æ•°å°äº4æ¬¡ å¹¶ä¸” å¤šæ ¸CPUè¿è¡Œ å¹¶ä¸”é™¤äº†å½“å‰Pè¿˜æœ‰å…¶ä»–Pæ­£åœ¨è¿è¡Œï¼ˆä¸æ˜¯ç©ºé—²æˆ–è‡ªæ—‹çŠ¶æ€çš„Pï¼‰å¹¶ä¸” å½“å‰Pæ²¡æœ‰å…¶ä»–gäº† //\tè¿™ç§æƒ…å†µéœ€è¦å»å°è¯•è‡ªæ—‹è·å–ä¸‹é”ï¼Œå…¶ä»–æƒ…å†µåˆ™ä¸éœ€è¦è‡ªæ—‹å»è·å–é” // ä»¥ä¸‹è‡ªæ—‹çš„æ„ä¹‰ï¼Œåœç•™ç‰‡åˆ»ç­‰å¾…å…¶ä»–goroutineè®©å‡ºé”ï¼Œç„¶åæ ‡è®°mutexWokenå­˜åœ¨è¢«å”¤é†’çš„goroutineä½¿è‡ªå·±è·å–é”ä¼˜å…ˆçº§æ›´é«˜ if old\u0026amp;(mutexLocked|mutexStarving) == mutexLocked \u0026amp;\u0026amp; runtime_canSpin(iter) {\t// è‡ªæ—‹åœ¨è¿™é‡Œ // Active spinning makes sense. // Try to set mutexWoken flag to inform Unlock // to not wake other blocked goroutines. // // ä¸»åŠ¨æ—‹è½¬æ˜¯æœ‰é“ç†çš„ã€‚ // å°è¯•è®¾ç½® mutexflag æ¥é€šçŸ¥ Unlock ä¸è¦å”¤é†’å…¶ä»–è¢«é˜»å¡åœ¨ä¿¡å·æ± çš„goroutinesã€‚ // ä»¥ä¸‹é€»è¾‘æ˜¯å¤„äºè‡ªæ—‹ï¼Œè‡ªæ—‹çš„æ„ä¹‰åœ¨äºæ ‡è®°æœ‰æ­£åœ¨è¢«å”¤é†’çš„goroutineï¼Œå…¶ä»–çº¿ç¨‹ä¸è¦å†æ¬¡å”¤é†’å¯¼è‡´è¿‡å¤šgoroutineè¢«å”¤é†’ // // 1. !awoke; ï¼šæ²¡æœ‰æ ‡è®°å½“å‰goroutineè¢«å”¤é†’ // 2. old\u0026amp;mutexWoken == 0; ï¼šæ²¡æœ‰è¢«å”¤é†’çš„goroutineï¼ŒåŒ…æ‹¬å…¶ä»–gå’Œå½“å‰g // 3. old\u0026gt;\u0026gt;mutexWaiterShift != 0; ï¼šå­˜åœ¨ç­‰å¾…æ’é˜Ÿåœ¨ä¿¡å·æ± çš„goroutine // 4. atomic.CompareAndSwapInt32(\u0026amp;m.state, old, old|mutexWoken); //\tè®¾ç½®æ ‡å¿—æœ‰goroutineè¢«å”¤é†’ï¼Œè¿™é‡Œè®¾ç½®æˆåŠŸé‚£unlockåˆ™ä¸ä¼šå†å»å”¤é†’goroutine if !awoke \u0026amp;\u0026amp; old\u0026amp;mutexWoken == 0 \u0026amp;\u0026amp; old\u0026gt;\u0026gt;mutexWaiterShift != 0 \u0026amp;\u0026amp; atomic.CompareAndSwapInt32(\u0026amp;m.state, old, old|mutexWoken) { // æ ‡è®°ä¸ºå”¤é†’çŠ¶æ€ï¼Œä¸»è¦æ˜¯å‘Šè¯‰unlockä¸è¦å†å»å”¤é†’goroutineäº†ï¼Œè¿™é‡Œæœ‰è‡ªæ—‹çš„åœ¨ç­‰å¾… awoke = true } // çŸ­æš‚å»¶è¿Ÿä¸€æ®µæ—¶é—´ï¼Œä¸»è¦æ˜¯ç­‰å¾…å…¶ä»–gè§£é” // å¦‚æœæ­¤æ—¶Unlockäº†ç¬¬ä¸€ä¸ªifåˆ™ä¸ä¼šå†åˆ¤æ–­ä¸ºtrueï¼Œç›´æ¥å»äº‰æŠ¢é”äº† runtime_doSpin()\titer++ old = m.state\t// ä»æ–°èµ‹å€¼ç»™old continue } // 2) é”å¯èƒ½å·²è¢«é‡Šæ”¾å°è¯•ç«äº‰è·å–ï¼Œæˆ–é”è¿˜æœªè§£é™¤å»sleepã€‚ // ä»£ç æ‰§è¡Œåˆ°è¿™é‡Œï¼Œåªå¯èƒ½å¤„äºä»¥ä¸‹å‡ ç§æƒ…å†µ // 1. è‡ªæ—‹æ¬¡æ•°ä»¥å®Œï¼ŒçŠ¶æ€ä¾ç„¶æ˜¯ mutexLockedã€‚ // 2. çŠ¶æ€æ˜¯ mutexStarving å¤„äºé¥¥é¥¿çŠ¶æ€ã€‚ // 3. çŠ¶æ€æ˜¯æœªåŠ é”çŠ¶æ€ï¼Œé”å·²è¢«è§£é™¤ã€‚ // ï¼ˆå¤„äºé¥¥é¥¿æ¨¡å¼ï¼‰ æˆ– ï¼ˆè‡ªæ—‹æ¬¡æ•°è¶…è¿‡4æ¬¡ï¼‰ æˆ– ï¼ˆå½“å‰å…¶ä»–goroutineå·²Unlockï¼‰æˆ– ï¼ˆä¸æ»¡è¶³è‡ªæ—‹æ¡ä»¶ï¼‰ //\tå¦‚æœé”å·²Unlockï¼Œé‚£ä¹ˆå°è¯•å»è·å–é”ï¼›å¦‚æœé”å¤„äºLockï¼Œé‚£ä¹ˆä¹Ÿå°è¯•è·å–ï¼Œå¦åˆ™åŠ å…¥åˆ°ä¿¡å·æ± ä¸­ç­‰å¾… // old æ˜¯æœ¬è½®åŸå­æ“ä½œçš„ state å€¼ // new æ˜¯æœ¬è½®éœ€è¦äº‰æŠ¢é”ä¿®æ”¹åçš„ state å€¼ // æ­£å¸¸æ¨¡å¼ä¸‹: // 1. åœ¨oldæœªæŒæœ‰é”æƒ…å†µä¸‹ï¼Œè°å…ˆåŸå­æ“ä½œä» old ä¿®æ”¹ä¸º new è°å°±å…ˆè·å–åˆ°é” // 2. åœ¨oldæŒæœ‰é”æƒ…å†µä¸‹ï¼Œå½“å‰goroutineéœ€è¦sleep new := old // 2.1) æ­£å¸¸æ¨¡å¼ä¸‹éœ€è¦äº‰æŠ¢é”ï¼Œå› æ­¤éœ€è¦è®¾ç½®mutexLockedçŠ¶æ€ // Don\u0026#39;t try to acquire starving mutex, new arriving goroutines must queue. // // ä¸è¦å°è¯•è·å–å¤„äºé¥¥é¥¿çš„Mutexï¼Œåæ¥çš„goroutineså¿…é¡»æ’é˜Ÿã€‚ // // å¤„äºé¥¥é¥¿æ¨¡å¼ä¸‹ï¼Œä¸ºä»€ä¹ˆä¸éœ€è¦è®¾ç½®mutexLockedæ ‡å¿—å‘¢ï¼Ÿ // 1. å¤„äºé¥¥é¥¿æ¨¡å¼ä¸‹é”çš„æŒæœ‰æƒæ˜¯æ‰‹æŠŠæ‰‹äº¤ç»™åé¢ç­‰å¾…çš„goroutineï¼Œå› æ­¤mutexLockedæ ‡å¿—è®¾ç½®ä¸è®¾ç½®ä¸é‡è¦ // 2. å¯¹äºæ–°æ¥çš„goroutineï¼ŒmutexLockedä½å¯èƒ½ä¸º0æˆ–1ï¼Œä½†æ˜¯å½“å‰goroutineä¸ä¼šå»æŒ£æŠ¢é”ç›´æ¥sleepï¼Œå› æ­¤mutexLockedä½ä¸é‡è¦ // 3. å¯¹äºä»sleepä¸­wakeupçš„goroutineï¼Œä¸€å®šæ˜¯æ¥è‡ªUnlockå‡½æ•°è€Œæ¥è‡ªè¯¥å‡½æ•°mutexLockedä½ä¸€å®šæ˜¯0ï¼Œå·²è¢«è§£é” if old\u0026amp;mutexStarving == 0 {\t// å¤„äºæ­£å¸¸æ¨¡å¼ // newè¡¨ç¤ºæ–°å€¼ä¿®æ”¹çš„çŠ¶æ€ mutexLockedéœ€è¦é”ï¼Œä¸ç®¡å½“å‰æ˜¯Lockæˆ–Unlockå½“å‰éƒ½éœ€è¦è®¾ç½®mutexLockedè¡¨ç¤ºéœ€è¦å»äº‰æŠ¢é” new |= mutexLocked\t} // 2.2) é”è¿˜æœªè¢«é‡Šæ”¾ æˆ– å¤„äºé¥¥é¥¿æ¨¡å¼ä¸‹ è¿™ä¸¤ç§æƒ…å†µä¸‹éƒ½ä¼šå»sleepï¼Œå› æ­¤éœ€è¦åŠ ä¸€ã€‚ // å¦‚æœoldé”æ²¡é‡Šæ”¾ æˆ– å¤„äºé¥¥é¥¿çŠ¶æ€ï¼Œé‚£ä¹ˆå½“å‰çš„goroutineåˆ™æ˜¯éœ€è¦è¢«åŠ å…¥åˆ°ä¿¡å·æ± é‡Œé¢å»çš„ if old\u0026amp;(mutexLocked|mutexStarving) != 0 {\t// å¤„äºLockæˆ–åˆ™é¥¥é¥¿æ¨¡å¼å½“å‰géœ€è¦åŠ å…¥åˆ°ä¿¡å·æ±  new += 1 \u0026lt;\u0026lt; mutexWaiterShift\t// æ•°é‡å¢åŠ 1 } // 2.3) å½“å‰ goroutine å°† mutex åˆ‡æ¢è‡³é¥¥é¥¿æ¨¡å¼ // å¦‚æœ mutex å·²ç»å¤„äº unlocked çŠ¶æ€ï¼Œå°±ä¸è¦åˆ‡æ¢äº†ï¼Œ // å› ä¸º Unlock() å‡½æ•°è®¤ä¸ºå¤„äºé¥¥é¥¿æ¨¡å¼çš„ mutex ç­‰å¾…é˜Ÿåˆ—ä¸ä¸ºç©ºã€‚ // The current goroutine switches mutex to starvation mode. // But if the mutex is currently unlocked, don\u0026#39;t do the switch. // Unlock expects that starving mutex has waiters, which will not // be true in this case. // // å½“å‰çš„ goroutine å°†äº’æ–¥é”åˆ‡æ¢åˆ°é¥¥é¥¿æ¨¡å¼ï¼Œä½†å¦‚æœäº’æ–¥é”å½“å‰å·²è§£é”ï¼Œå°±ä¸è¦åˆ‡æ¢ã€‚ // UnlockæœŸæœ›å¤„äºé¥¥é¥¿çŠ¶æ€çš„äº’æ–¥é”æœ‰waitersï¼Œä½†åœ¨æœ¬ä¾‹ä¸­å¹¶éå¦‚æ­¤ã€‚ // // starving=true å‘ç”Ÿåœ¨ï¼šè¿™ä¸ªgoroutineè¢«åŠ å…¥åˆ°ä¿¡å·æ± åå†åº¦è¢«å”¤é†’å»äº‰æŠ¢é”æ—¶ï¼Œå‘ç°ç­‰å¾…æ—¶é—´å·²ç»è¶…è¿‡1msæ—¶ // old\u0026amp;mutexLocked != 0ï¼Œè¡¨ç¤ºè¿™ä¸ªè¢«å”¤é†’çš„goroutineå†æ¬¡äº‰æŠ¢é”æ—¶é”æ²¡è¢«å…¶ä»–gorutineé‡Šæ”¾ï¼Œè¿™æ¬¡å†äº‰æŠ¢å°†å¤±è´¥åˆ™ä¼šæ ‡è®°æˆé¥¥é¥¿æ¨¡å¼ if starving \u0026amp;\u0026amp; old\u0026amp;mutexLocked != 0 {\t// è¿™ç§æƒ…å†µä¸‹å½“å‰goroutineåŸºæœ¬æ‹¿å»ä¸åˆ°é” new |= mutexStarving // æ ‡è®°æˆé¥¥é¥¿æ¨¡å¼æ—¶ï¼Œé”ä¸€å®šè¢«å…¶ä»–æŒæœ‰ï¼›ä½†æ˜¯å”¤é†’çš„gå¤„äºé¥¥é¥¿æ¨¡å¼æ—¶ï¼Œé”ä¸€å®šæ˜¯UnlockçŠ¶æ€ } // 2.4) å½“å‰goroutineæ˜¯è¢«å”¤é†’çš„ï¼Œæ£€æŸ¥å¹¶æ¸…é™¤æ ‡å¿—ä½ // awoke=true è¡¨ç¤ºæ¥è‡ªè‡ªæ—‹æˆ–è¢«å”¤é†’çš„goroutineä¸¤ç§å½¢å¼ // 1. è‡ªæ—‹çŠ¶æ€ä¸‹ awoke=trueï¼Œstate ä¸­ mutexWoken ä½å·²è¢«è®¾ç½®ä¸º 1 // 2. è¢«å”¤é†’çš„goroutineä¸‹ awoke=true åœ¨æœ¬å‡½æ•°çš„å”¤é†’åè¢«è®¾ç½®ï¼Œè€Œ state ä¸­ mutexWoken ä½åœ¨Unlockå‡½æ•°ä¸­è¢«è®¾ç½® // å› æ­¤ awoke=true å°±ä¸€å®šå­˜åœ¨ state ä¸­ mutexWoken ä½ä¸º1ï¼Œnew\u0026amp;mutexWoken != 0æˆç«‹ if awoke {\t// awokeæœ‰ç­‰å¾…çš„goroutineè¢«å”¤é†’ // The goroutine has been woken from sleep, // so we need to reset the flag in either case. // // goroutine å·²ç»ä»ç¡çœ ä¸­å”¤é†’ï¼Œæ‰€ä»¥æˆ‘ä»¬éœ€è¦åœ¨ä»»ä½•ä¸€ç§æƒ…å†µä¸‹é‡ç½®æ ‡å¿— if new\u0026amp;mutexWoken == 0 {\t// ä¸è®ºæ¥è‡ªè‡ªæ—‹æˆ–è¢«å”¤é†’çš„goroutineè¿™é‡Œéƒ½ä¸èƒ½ä¸º0ï¼Œæ­£å¸¸çŠ¶å†µä¸‹ throw(\u0026#34;sync: inconsistent mutex state\u0026#34;) } new \u0026amp;^= mutexWoken // æ¸…é™¤è¢«å”¤é†’æ ‡å¿—ä½mutexWokenï¼Œå› ä¸ºä¸‹é¢å³å°†å»äº‰æŠ¢é”ï¼Œæˆ–è€…è½½å…¥å»ä¿¡å·æ± ç­‰å¾… } // å°è¯•ä½¿ç”¨åŸå­ä¿®æ”¹stateï¼Œæ‰€æœ‰çš„goroutineéƒ½ä¼šé€šè¿‡è¯¥æ¡ä»¶ï¼Œä½†æ˜¯ä¸€è½®åªèƒ½æˆåŠŸä¸€ä¸ª // è¿™é‡Œä¿®æ”¹m.stateæˆåŠŸäº†ï¼Œå¹¶ä¸ä»£è¡¨ä¸€å®šè·å–åˆ°äº†é”ï¼Œä¹Ÿæœ‰å¯èƒ½æ˜¯å½“å‰géœ€è¦åŠ å…¥åˆ°ä¿¡å·æ± ä¸­å» if atomic.CompareAndSwapInt32(\u0026amp;m.state, old, new) {\t// å¦‚æœä¸Šä¸€ä¸ªæ‹¿å»åˆ°é”çš„stateæ˜¯æ­£å¸¸æ¨¡å¼å¹¶æ²¡æœ‰é”ï¼Œåˆ™è¿™é‡Œç›´æ¥é€€å‡ºï¼Œè¿™é‡Œè¡¨ç¤ºå½“å‰goroutineè·å–åˆ°äº†é”ï¼Œæ­£å¸¸æ¨¡å¼éƒ½æ˜¯ä»è¿™é‡Œé€€å‡ºçš„ // æ­£å¸¸æ¨¡å¼ä¸‹è·å–åˆ°é”çš„æƒ…å†µï¼Œè¿™é‡Œä¸ä¼šå‡ºç°æ ‡è®°æˆé¥¥é¥¿æ¨¡å¼ä½†è¿™é‡Œåˆåˆ¤æ–­ä¸ºtrueé€€å‡ºäº†çš„æƒ…å†µï¼ŒåŸå› æ˜¯æ ‡è®°æˆé¥¥é¥¿æ¨¡å¼çš„å‰ç½®æ¡ä»¶æ˜¯å½“å‰oldæ˜¯Lock if old\u0026amp;(mutexLocked|mutexStarving) == 0 {\t// è°å…ˆæ‹¿åˆ°é”é€€å‡ºï¼Œæ¥åˆ°æ‰§è¡Œgoroutineåé¢ä»£ç  break // locked the mutex with CAS } // åé¢å¤„ç†é€»è¾‘æ˜¯ä¹‹å‰æœ‰é”ï¼Œè¿™ä¸ªgoroutineéœ€è¦å»æ’é˜Ÿæƒ…å†µï¼Œæˆ–å½“å‰æ¨¡å¼å¤„äºé¥¥é¥¿æ¨¡å¼ï¼Œç›´æ¥æŠŠè¯¥goroutineåŠ å…¥åˆ°å°¾éƒ¨ // If we were already waiting before, queue at the front of the queue. // // å¦‚æœæˆ‘ä»¬ä¹‹å‰å·²ç»åœ¨ç­‰å¾…ï¼Œè¯·åœ¨é˜Ÿåˆ—çš„å‰é¢æ’é˜Ÿ // waitStartTimeå¦‚æœä¸ç­‰äº0è¯´æ˜å…ˆå‰å…¥é˜Ÿè¿‡æœ‰è¢«å”¤é†’è¿‡ï¼Œæ­£å¸¸ç¬¬ä¸€æ¬¡å…¥é˜Ÿè¿™é‡Œæ˜¯false // è¢«å”¤é†’ä¹‹åæ²¡æœ‰æŠ¢åˆ°é”ï¼Œéœ€è¦æ’å…¥é˜Ÿåˆ—å¤´éƒ¨ï¼Œè€Œä¸æ˜¯å°¾éƒ¨ã€‚ queueLifo := waitStartTime != 0 // é¦–æ¬¡è¿›å…¥ä¿¡å·æ± å»ç­‰å¾…æ—¶ if waitStartTime == 0 {\t// è¿™é‡Œè¡¨ç¤ºè¿™ä¸ªgoroutineä»ä¿¡å·æ± ä¸­ç¬¬ä¸€æ¬¡è¢«å”¤é†’ä¾ç„¶æ²¡æœ‰è·å–åˆ°é”ï¼Œä»æ–°è®¾ç½®æ—¶é—´ waitStartTime = runtime_nanotime()\t// æ³¨æ„ï¼šé™¤ç¬¬ä¸€æ¬¡å…¥é˜Ÿååé¢æ¯æ¬¡ç¼“å­˜waitStartTimeæ—¶é—´éƒ½ä¸ä¼šè¢«åˆ·æ–° } // è¿™é‡Œå­˜åœ¨è¢«å”¤é†’ä½†æ˜¯è¿˜æ˜¯æ²¡æ‹¿åˆ°é”çš„æƒ…å†µä¼šå†æ¬¡è¢«å…¥é˜Ÿ // runtime_SemacquireMutexçš„queueLifoå‚æ•°ä¸ºtrueåˆ™æ˜¯æ’å…¥çš„ä¿¡å·æ± å¤´éƒ¨ï¼Œfalseæ’å…¥åˆ°å°¾éƒ¨ //\té¦–æ¬¡è¿›å…¥ä¿¡å·æ± ï¼Œåˆ™ç›´æ¥æ’åœ¨å°¾éƒ¨ //\tä»ä¿¡å·æ± ä¸­å‡ºæ¥åˆäº‰æŠ¢å¤±è´¥è¿›å…¥ä¿¡å·æ± æ’åœ¨å¤´éƒ¨ // å¦‚æˆ‘ä»¬å–å‡ºgorutineåˆ™æ˜¯ä»å¤´éƒ¨å¼€å§‹å¾€åå–ï¼Œè¿™ä¹Ÿå°±æ˜¯æˆ‘ä»¬è¯´çš„å…ˆè¿›å…ˆå‡º // å› ä¸ºç¬¬ä¸€æ¬¡åŠ å…¥ä¿¡å·æ± çš„éƒ½æ˜¯æ’å…¥åˆ°å°¾éƒ¨ï¼Œå½“å†è¢«å”¤é†’ä¾ç„¶æ²¡æœ‰è·å–åˆ°é”æ—¶ï¼Œåˆ™æ˜¯è¢«æ”¾å›åˆ°å¤´éƒ¨ // å½“å‰goroutineå»æ’é˜Ÿï¼Œè¿™é‡Œå½“å‰groutineè¢«è°ƒç¦»å·¥ä½œçº¿ç¨‹ç­‰å¾…æŠ¢åˆ°é”åç»§ç»­åé¢æ‰§è¡Œ runtime_SemacquireMutex(\u0026amp;m.sema, queueLifo, 1)\t// è¢«å”¤é†’çš„gï¼Œæ¥åˆ°ä»è¿™é‡Œæ‰§è¡Œå°è¯•å»è·å–é”ï¼›å¯èƒ½å½“å‰å¤„äºé¥¥é¥¿æ¨¡å¼æˆ–å¤„äºæ­£å¸¸æ¨¡å¼ï¼Œå”¤é†’gçš„ç›¸å…³ä»£ç ä½äºUnlockå‡½æ•° // å¦‚æœç­‰å¾…çš„æ—¶é—´å¤§äº1msåˆ™æ ‡è®°æˆé¥¥é¥¿æ¨¡å¼ï¼Œä»¥ä¸‹é€»è¾‘æ˜¯å½“å‰goroutineè¢«å”¤é†’åå†æ¬¡å°è¯•è·å–é” // ç­‰å¾…æ—¶é—´è¶…è¿‡äº†1msï¼Œç­‰å¾…æ—¶é—´å¤ªä¹…éœ€è¦è¢«æ ‡è®°ä¸ºé¥¥é¥¿çŠ¶æ€ starving = starving || runtime_nanotime()-waitStartTime \u0026gt; starvationThresholdNs old = m.state\t// è·å–å½“å‰çš„çŠ¶æ€ // å¦‚æœå¤„äºé¥¥é¥¿æ¨¡å¼ï¼Œå¤„äºé¥¥é¥¿æ¨¡å¼ä¸‹å”¤é†’çš„goroutineç«‹å³è·å–é”ï¼Œå› ä¸ºæ­£å¸¸æ¥æŠ¢çš„goroutineéƒ½ä¼šè¢«å…¥é˜Ÿï¼Œ // ç„¶åä¸€ä¸ªä¸ªæ¥è·å– // æ‰€æœ‰é¥¥é¥¿æ¨¡å¼ä¸‹è·å–é”çš„å‡ºå£éƒ½åœ¨è¿™é‡Œï¼Œè¯¥æ¡ä»¶æ»¡è¶³è¯´æ˜å½“å‰goroutineè·å–åˆ°é”æŒæœ‰æƒ if old\u0026amp;mutexStarving != 0 {\t// If this goroutine was woken and mutex is in starvation mode, // ownership was handed off to us but mutex is in somewhat // inconsistent state: mutexLocked is not set and we are still // accounted as waiter. Fix that. // // å½“å‰ä»£ç ä½ç½®çš„ goroutine è‚¯å®šæ˜¯è¢«å”¤é†’çš„ï¼Œè€Œä¸” Mutex å¤„äºé¥¥é¥¿æ¨¡å¼ // æ‰€æœ‰æƒè¢«ç›´æ¥äº¤ç»™å½“å‰ goroutine // ä½†æ˜¯è¿™ç§æƒ…å†µä¸‹ mutex çš„ state ä¼šä¸å®é™…æƒ…å†µä¸ä¸€è‡´ // mutexLocked æ ‡å¿—ä½æ²¡æœ‰è®¾ç½® // è€Œä¸”ç­‰å¾…è€…è®¡æ•°ä¸­ä¹Ÿæ²¡æœ‰å‡å»å½“å‰ goroutineã€‚éœ€è¦ä¿®å¤ state // æ³¨æ„é¥¥é¥¿æ¨¡å¼ä¸‹ä¼ é€’ mutex æ‰€æœ‰æƒä¸ä¼šè®¾ç½® mutexWoken æ ‡å¿—ï¼Œåªæœ‰æ­£å¸¸æ¨¡å¼ä¸‹å”¤é†’æ‰ä¼š // // é¥¥é¥¿æ¨¡å¼ä¸‹ old\u0026gt;\u0026gt;mutexWaiterShift != 0ï¼Œå½“å‰ä¸€å®šä¸èƒ½æ˜¯æœ€åä¸€ä¸ªï¼Œ // å› ä¸ºä¸‹é¢ old\u0026gt;\u0026gt;mutexWaiterShift == 1 ä¼šé€€å‡ºé¥¥é¥¿æ¨¡å¼ // old\u0026amp;(mutexLocked|mutexWoken) != 0 å› ä¸ºå¤„äºé¥¥é¥¿æ¨¡å¼ä¸‹ï¼Œæ‰€æœ‰çš„goroutineéƒ½ä¼šå»æ’é˜Ÿsleepï¼Œ // è¢«wakeupçš„goroutineä¸€å®šæ¥è‡ªUnlockå‡½æ•°ï¼Œ // æ­¤æ—¶mutexLockedä¸€å®šè§£é”ï¼ŒmutexWokenä¸€å®šæ˜¯è¢«æ¸…é™¤çš„ if old\u0026amp;(mutexLocked|mutexWoken) != 0 || old\u0026gt;\u0026gt;mutexWaiterShift == 0 { // é¥¥é¥¿æ¨¡å¼ä¸‹ï¼ŒmutexLockedå’ŒmutexWokenå¿…å®šä¸º0ï¼Œå‚çœ‹ä¸Šé¢ä»£ç ã€‚ throw(\u0026#34;sync: inconsistent mutex state\u0026#34;) } // +mutexLocked -1\u0026lt;\u0026lt;mutexWaiterShift delta := int32(mutexLocked - 1\u0026lt;\u0026lt;mutexWaiterShift)\t// å°†ç­‰å¾…çš„æ•°é‡å‡ä¸€ // ç­‰å¾…æ—¶é—´å°äº1ms æˆ– å½“å‰goroutineæ˜¯é˜Ÿåˆ—æœ€åä¸€ä¸ªï¼Œåˆ™æ ‡è®°é€€å‡ºé¥¥é¥¿æ¨¡å¼ if !starving || old\u0026gt;\u0026gt;mutexWaiterShift == 1 { // Exit starvation mode. // Critical to do it here and consider wait time. // Starvation mode is so inefficient, that two goroutines // can go lock-step infinitely once they switch mutex // to starvation mode. delta -= mutexStarving\t// é€€å‡ºé¥¥é¥¿æ¨¡å¼ } atomic.AddInt32(\u0026amp;m.state, delta) // ä¿®æ”¹stateï¼Œè¿”å›ç›´æ¥è¿”å›ï¼Œåº”ä¸ºè¯¥goroutine è·å–åˆ°é”äº† break\t// é¥¥é¥¿æ¨¡å¼ä»è¿™é‡Œé€€å‡ºï¼Œå› æ­¤é¥¥é¥¿æ¨¡å¼ä¸‹è¢«å”¤é†’çš„goroutineç›´æ¥ä»è¿™é‡Œé€€å‡º } // æ­£å¸¸æ¨¡å¼ä¸‹ï¼Œè®¾ç½®ä¸ºå”¤é†’å»äº‰æŠ¢é” awoke = true\t// stateçš„mutexWokenä½åœ¨Unlockå‡½æ•°ä¸­è¢«è®¾ç½® iter = 0\t// è‡ªæ—‹æ¬¡æ•°é‡ç½® } else { // ä»old-\u0026gt;new åŸå­è®¾ç½®ï¼Œå¦‚æœè®¾ç½®å¤±è´¥ä»æ–°å†æ¥ old = m.state } } if race.Enabled { race.Acquire(unsafe.Pointer(m)) } } sync_runtime_canSpin() sync.Mutex ä¸»åŠ¨æ—‹è½¬æ¡ä»¶ã€‚ ä¸ä¸»åŠ¨æ—‹è½¬æ¡ä»¶ï¼š ã€æ—‹è½¬æ¬¡æ•°å¤§äºç­‰äº4æ¬¡ã€‘æˆ–ã€å•æ ¸CPUåœ¨è¿è¡Œã€‘ æˆ–ã€é™¤äº†å½“å‰På…¶ä»–Péƒ½å¤„äºç©ºé—²æˆ–è‡ªæ—‹çŠ¶æ€ã€‘ï¼Œä¸éœ€è¦ä¸»åŠ¨å»æ—‹è½¬ç­‰å¾…è·å–é”ã€‚ å¦‚æœå½“å‰Pçš„runqä¸ä¸ºç©ºï¼Œä¹Ÿæ²¡å¿…è¦å»è‡ªæ—‹ï¼Œå› ä¸ºé‡Œé¢çš„gè¿˜ç­‰ç€å»æ‰§è¡Œï¼Œç›´æ¥æŠŠå½“å‰gæŒ‚èµ·ã€‚ ä¸»åŠ¨æ—‹è½¬æ¡ä»¶ï¼š ã€æ—‹è½¬æ¬¡æ•°å°äº4æ¬¡ã€‘å¹¶ä¸”ã€å¤šæ ¸CPUè¿è¡Œã€‘å¹¶ä¸”ã€é™¤äº†å½“å‰Pè¿˜æœ‰å…¶ä»–Pæ­£åœ¨è¿è¡Œã€‘ï¼ˆä¸æ˜¯ç©ºé—²æˆ–è‡ªæ—‹çŠ¶æ€çš„Pï¼‰å¹¶ä¸” ã€å½“å‰Pæ²¡æœ‰å…¶ä»–gäº†ã€‘ã€‚ è¿™ç§æƒ…å†µéœ€è¦å»å°è¯•è‡ªæ—‹è·å–ä¸‹é”ï¼Œå…¶ä»–æƒ…å†µåˆ™ä¸éœ€è¦è‡ªæ—‹å»è·å–é”ã€‚ runtime/proc.goæ–‡ä»¶ä¸­ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 // Active spinning for sync.Mutex. //go:linkname sync_runtime_canSpin sync.runtime_canSpin //go:nosplit func sync_runtime_canSpin(i int) bool { // sync.Mutex is cooperative, so we are conservative with spinning. // Spin only few times and only if running on a multicore machine and // GOMAXPROCS\u0026gt;1 and there is at least one other running P and local runq is empty. // As opposed to runtime mutex we don\u0026#39;t do passive spinning here, // because there can be work on global runq or on other Ps. // // sync.Mutexæ˜¯åˆä½œæ€§çš„ï¼Œæ‰€ä»¥æˆ‘ä»¬å¯¹spinningæ˜¯ä¿å®ˆçš„ã€‚ // åªæ—‹è½¬å‡ æ¬¡ï¼Œä¸”ä»…å½“è¿è¡Œåœ¨å¤šæ ¸è®¡ç®—æœºå’ŒGOMAXPROCS\u0026gt;1ä¸Šï¼Œå¹¶ä¸”è‡³å°‘æœ‰ä¸€ä¸ªå…¶ä»–è¿è¡ŒPä¸”æœ¬åœ°runqä¸ºç©ºæ—¶ã€‚ // ä¸è¿è¡Œæ—¶äº’æ–¥é”ç›¸åï¼Œæˆ‘ä»¬åœ¨è¿™é‡Œä¸åšè¢«åŠ¨æ—‹è½¬ï¼Œå› ä¸ºå¯ä»¥åœ¨å…¨å±€runqæˆ–å…¶ä»–Pä¸Šè¿›è¡Œå·¥ä½œã€‚ // // ä»¥ä¸‹æ¡ä»¶æ»¡è¶³ä¸€é¡¹éƒ½ä¸ä¼šå†æ¬¡è‡ªæ—‹å»è·å–é” // 1. const active_spin = 4; æœ€å¤šå°è¯•4æ¬¡è‡ªæ—‹è·å– // 2. var ncpu int32 \u0026lt;= 1; å¦‚æœæ˜¯å•æ ¸CPU // 3. gomaxprocs \u0026lt;= int32(sched.npidle+sched.nmspinning)+1; // 3.1 gomaxprocsï¼šè¡¨ç¤ºæ€»çš„P // 3.2 sched.npidleç©ºé—²çš„Pæ•°é‡ // 3.3 sched.nmspinningæ­£åœ¨è‡ªæ—‹çš„Mæ•°é‡(è¿™é‡Œé¢å¯èƒ½å­˜åœ¨æ­£åœ¨äº‰æŠ¢é”ï¼Œå¤„åœ¨è‡ªæ—‹éƒ½æ˜¯åªæœ‰ä¸€ä¸ªgçš„æƒ…å†µ) // é™¤äº†å½“å‰På…¶ä»–çš„Péƒ½å¾ˆé—²ï¼Œä¹Ÿä¸å¿…è¦è‡ªæ—‹äº†ã€‚ if i \u0026gt;= active_spin || ncpu \u0026lt;= 1 || gomaxprocs \u0026lt;= int32(sched.npidle+sched.nmspinning)+1 { return false } // è¿™é‡Œä¸åƒ runtime.mutex é‚£æ ·è¿›è¡Œæ¶ˆæè‡ªæ—‹ï¼Œå› ä¸ºå…¨å±€ runq æˆ–å…¶ä»– P ä¸Šæˆ–è®¸è¿˜æœ‰å¯è¿è¡Œçš„ä»»åŠ¡ã€‚ // å½“å‰æœ¬åœ°Pä¸ä¸ºç©ºï¼Œä¹Ÿä¸éœ€è¦è‡ªæ—‹å†å‡ºå»å°è¯•è·å–é”ï¼Œå…¶ä»–goroutineè¿˜ç­‰èµ·çš„ã€‚ if p := getg().m.p.ptr(); !runqempty(p) { return false } return true } sync_runtime_doSpin() çŸ­æš‚çš„å»¶è¿Ÿã€‚ runtime/proc.go æ–‡ä»¶ä¸­ã€‚ 1 2 3 4 5 6 //go:linkname sync_runtime_doSpin sync.runtime_doSpin //go:nosplit func sync_runtime_doSpin() { // å¾ªç¯30æ¬¡ç­‰å¾… procyield(active_spin_cnt)\t// active_spin_cnt=30 } procyield() çŸ­æš‚çš„å»¶è¿Ÿã€‚ 1 2 3 4 5 6 7 8 # runtime/asm_amd.64.s TEXT runtimeÂ·procyield(SB),NOSPLIT,$0-0 MOVL\tcycles+0(FP), AX\t# AX=30 å‚æ•° again: PAUSE # è‡ªæ—‹é™ä½CPUå‘çƒ­å’Œæ€§èƒ½ä¼˜åŒ–ã€‚ SUBL\t$1, AX\t# AX -= 1 JNZ\tagain RET Unlock() Unlockè§£é”mã€‚ å¦‚æœmåœ¨è¿›å…¥è§£é”æ—¶æ²¡æœ‰è¢«é”å®šï¼Œåˆ™æ˜¯ä¸€ä¸ªè¿è¡Œæ—¶é”™è¯¯ã€‚ ä¸€ä¸ªé”å®šçš„äº’æ–¥é‡ä¸ä¸€ä¸ªç‰¹å®šçš„goroutineæ— å…³ã€‚ å…è®¸ä¸€ä¸ªgoroutineé”å®šä¸€ä¸ªäº’æ–¥é‡ï¼Œç„¶åå®‰æ’å¦ä¸€ä¸ªgoroutineè§£é”å®ƒã€‚ è¯¥æ–¹æ³•ä¸»è¦é€šè¿‡ atomic å‡½æ•°å®ç°äº† Fast pathï¼Œç›¸åº”çš„ Slow pathè¢«å•ç‹¬æ”¾åœ¨äº† unlockSlow() æ–¹æ³•ä¸­ã€‚ æ ¹æ®æºç æ³¨é‡Šçš„è¯´æ³•ï¼Œè¿™æ ·æ˜¯ä¸ºäº†ä¾¿äºç¼–è¯‘å™¨å¯¹ Fast path è¿›è¡Œå†…è”ä¼˜åŒ–ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 // Unlock unlocks m. // It is a run-time error if m is not locked on entry to Unlock. // // A locked Mutex is not associated with a particular goroutine. // It is allowed for one goroutine to lock a Mutex and then // arrange for another goroutine to unlock it. func (m *Mutex) Unlock() { if race.Enabled { _ = m.state race.Release(unsafe.Pointer(m)) } // 1) é€šè¿‡åŸå­æ“ä½œä» state ä¸­å‡å» mutexLockedï¼Œä¹Ÿå°±æ˜¯é‡Šæ”¾é” // ç„¶åæ ¹æ® state çš„æ–°å€¼(new)æ¥åˆ¤æ–­æ˜¯å¦éœ€è¦æ‰§è¡Œ Slow pathã€‚ // Fast path: drop lock bit. // // Fast path: ç›´æ¥æŠŠé”æ ‡å¿—ä½æ”¾å¼€ // å¦‚æœä¹‹å‰mutexLockedä½ä¸º1åˆ™ä¿®æ”¹ä¸º0ï¼›å¦‚æœä¹‹å‰mutexLockedä½ä¸º0åˆ™ä¿®æ”¹ä¸º1ï¼› new := atomic.AddInt32(\u0026amp;m.state, -mutexLocked)\t// å¦‚æœåˆ é™¤äº†é”çš„bitä½ï¼Œstateç­‰äº0è¯´æ˜æ²¡æœ‰ç­‰å¾…æŠ¢é”çš„goroutineç›´æ¥è¿”å› // newä¸º0ï¼Œæ„å‘³ç€æ²¡æœ‰å…¶ä»– goroutine åœ¨æ’é˜Ÿï¼Œæ‰€ä»¥ä¸éœ€è¦æ‰§è¡Œé¢å¤–æ“ä½œã€‚ // newä¸ä¸º0ï¼Œåˆ™å¯èƒ½éœ€è¦å”¤é†’æŸä¸ª goroutineã€‚ // Unlock æ‰§è¡Œå®Œåmutex.state!=0 åˆ™å­˜åœ¨ä»¥ä¸‹å¯èƒ½ // æ­£å¸¸æ¨¡å¼ä¸‹ // 1. å½“å‰å­˜åœ¨ç­‰å¾…çš„goroutineå»å”¤é†’å®ƒ //\t2. å½“å‰å­˜åœ¨è‡ªæ—‹ç­‰å¾…çš„goroutineï¼Œåˆ™ä¸å”¤é†’å…¶ä»–ç­‰å¾…çš„goroutine // é¥¥é¥¿æ¨¡å¼ä¸‹ // 1. ç›´æ¥å°†é”äº¤ç»™ç­‰å¾…é˜Ÿåˆ—çš„ç¬¬ä¸€ä¸ªgoroutine if new != 0 {\t// è¿˜å­˜åœ¨å…¶ä»–ç­‰å¾…é˜Ÿåˆ—ä¸­çš„goroutine // Outlined slow path to allow inlining the fast path. // To hide unlockSlow during tracing we skip one extra frame when tracing GoUnblock. // // æ¦‚è¿°äº†æ…¢é€Ÿè·¯å¾„ä»¥å…è®¸å†…è”å¿«é€Ÿè·¯å¾„ // ä¸ºäº†åœ¨è·Ÿè¸ªè¿‡ç¨‹ä¸­éšè— unlockSlowï¼Œæˆ‘ä»¬åœ¨è·Ÿè¸ª GoUnblock æ—¶ä¼šè·³è¿‡ä¸€ä¸ªé¢å¤–çš„å¸§ m.unlockSlow(new) } } unlockSlow() 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 func (m *Mutex) unlockSlow(new int32) { // åˆ¤æ–­æœªåŠ é”çš„æƒ…å†µä¸‹ä¸èƒ½å¤šæ¬¡è°ƒç”¨unlock // æ­£å¸¸é€»è¾‘è¿™é‡Œ new+mutexLocked åº”è¯¥ä¸º1 if (new+mutexLocked)\u0026amp;mutexLocked == 0 {\t// è¿™ç§æƒ…å†µåˆ¤æ–­ä¹‹å‰æ ¹æœ¬å°±æ²¡åŠ è¿‡é”ï¼Œåˆ™å»è§£é”è¿™ä¼šç›´æ¥æŠ¥é”™è¯¯ throw(\u0026#34;sync: unlock of unlocked mutex\u0026#34;) } // æ­£å¸¸æ¨¡å¼ä¸‹ if new\u0026amp;mutexStarving == 0 { // ä» old -\u0026gt; new åŸå­æ“ä½œï¼Œä¸»è¦æ˜¯å”¤é†’goroutine old := new for {\t// ä»¥ä¸‹ä»£ç æ˜¯é€šè¿‡å”¤é†’goroutineå’Œå…¶ä»–æ­£åœ¨è¿è¡Œçš„goroutineå»äº‰æŠ¢é” // If there are no waiters or a goroutine has already // been woken or grabbed the lock, no need to wake anyone. // In starvation mode ownership is directly handed off from unlocking // goroutine to the next waiter. We are not part of this chain, // since we did not observe mutexStarving when we unlocked the mutex above. // So get off the way. // // å¦‚æœæ²¡æœ‰waitersï¼Œæˆ–goroutineå·²ç»è¢«å«é†’æˆ–æŠ¢äº†é”ï¼Œæ²¡æœ‰å¿…è¦å«é†’ä»»ä½•äººã€‚ // åœ¨é¥¥é¥¿æ¨¡å¼ä¸‹ï¼Œæ‰€æœ‰æƒä¼šä»è§£é”goroutineç›´æ¥ç§»äº¤ç»™ä¸‹ä¸€ä¸ªwaiterã€‚ // æˆ‘ä»¬ä¸æ˜¯è¿™ä¸ªé“¾çš„ä¸€éƒ¨åˆ†ï¼Œå› ä¸ºæˆ‘ä»¬åœ¨ä¸Šé¢è§£é”äº’æ–¥é”æ—¶æ²¡æœ‰è§‚å¯Ÿåˆ°mutexStarvingã€‚æ‰€ä»¥åˆ«æŒ¡é“ã€‚ // // æ²¡æœ‰ç­‰å¾…çš„goroutine æˆ– (æœ‰å…¶ä»–çš„goroutineå·²è¿‘è·å¾—é” æˆ– æœ‰è¢«å”¤é†’çš„goroutine æˆ– å½“å‰å¤„äºé¥¥é¥¿æ¨¡å¼ä¸‹) if old\u0026gt;\u0026gt;mutexWaiterShift == 0 || old\u0026amp;(mutexLocked|mutexWoken|mutexStarving) != 0 { return\t// ç›´æ¥è¿”å›ï¼Œä¸éœ€è¦å†å»åç»­å¤„ç† } // Grab the right to wake someone. // // ç­‰åœ¨è¢«å”¤é†’çš„goroutineæ•°é‡å‡ä¸€ï¼Œè®¾ç½®æœ‰è¢«å”¤é†’æ ‡å¿— new = (old - 1\u0026lt;\u0026lt;mutexWaiterShift) | mutexWoken\t// è®¾ç½®éœ€è¦å”¤é†’ä¸€ä¸ªgoroutineçš„æ–°çŠ¶æ€ if atomic.CompareAndSwapInt32(\u0026amp;m.state, old, new) {\t// åŸå­è®¾ç½®æˆåŠŸï¼Œè¯´æ˜æ²¡æœ‰å…¶ä»–æ­£åœ¨äº‰æŠ¢æˆ–å½“å‰äº‰æŠ¢æˆåŠŸ runtime_Semrelease(\u0026amp;m.sema, false, 1)\t// å–å‡ºç­‰å¾…çš„goroutineæ”¾å…¥æœ¬åœ°Pç­‰å¾…è¢«è°ƒåº¦ï¼Œé¥­åè¿”å› return } old = m.state\t// æ²¡æœ‰è·å–æˆåŠŸï¼Œåˆ™ç›´æ¥æ›¿æ¢æ—§stateï¼Œå†æ¬¡å°è¯• } } else {\t// é¥¥é¥¿æ¨¡å¼ä¸‹ // Starving mode: handoff mutex ownership to the next waiter, and yield // our time slice so that the next waiter can start to run immediately. // Note: mutexLocked is not set, the waiter will set it after wakeup. // But mutex is still considered locked if mutexStarving is set, // so new coming goroutines won\u0026#39;t acquire it. // // é¥¥é¥¿æ¨¡å¼ï¼šå°†mutexæ‰€æœ‰æƒç§»äº¤ç»™ä¸‹ä¸€ä¸ªwaiterï¼Œå¹¶è®©å‡ºæˆ‘ä»¬çš„æ—¶é—´ç‰‡ï¼Œä»¥ä¾¿ä¸‹ä¸€ä¸ªwaiterå¯ä»¥ç«‹å³å¼€å§‹è¿è¡Œ // æ³¨æ„ï¼šmutexLocked æ²¡æœ‰è®¾ç½®ï¼Œwaiterä¼šåœ¨å”¤é†’åè®¾ç½® // ä½†æ˜¯å¦‚æœè®¾ç½®äº† mutexStarvingï¼Œmutex ä»ç„¶è¢«è®¤ä¸ºæ˜¯é”å®šçš„ï¼Œæ‰€ä»¥æ–°çš„ goroutines ä¸ä¼šè·å–å®ƒ // å¤„äºé¥¥é¥¿æ¨¡å¼ä¸‹ä»è¿™é‡Œå”¤é†’çš„goroutineï¼Œstateä¸­mutexLockedä½ï¼Œä¸€å®šä¸º0 runtime_Semrelease(\u0026amp;m.sema, true, 1)\t// é¥¥é¥¿æ¨¡å¼ä¸‹åªä»é¦–éƒ¨å–å‡ºgoroutineç­‰å¾…è¢«è°ƒåº¦å³å¯ // è¿™é‡Œåœ¨é¥¥é¥¿æ¨¡å¼ä¸‹ä¸ºç”šä¸åˆ¤æ–­ç­‰å¾…çš„goroutineæ•°é‡ï¼Ÿ // åŸå› æ˜¯ï¼šå¤„äºé¥¥é¥¿æ¨¡å¼ä¸‹ç­‰å¾…çš„goroutineæ•°é‡ä¸€å®šæ˜¯\u0026gt;=1çš„ã€‚ // å› ä¸ºæœ€åä¸€ä¸ªgoroutineä¼šæŠŠæ¨¡å¼åˆ‡æ¢æˆæ­£å¸¸æ¨¡å¼ï¼Œç›¸å…³ä»£ç ä½äºLockå‡½æ•° } } TryLock() TryLockè¯•å›¾é”å®šmå¹¶æŠ¥å‘Šæ˜¯å¦æˆåŠŸã€‚ è¯·æ³¨æ„ï¼Œè™½ç„¶ç¡®å®å­˜åœ¨æ­£ç¡®ä½¿ç”¨TryLockçš„æƒ…å†µï¼Œä½†å¾ˆå°‘ï¼Œè€Œä¸”TryLockçš„ä½¿ç”¨é€šå¸¸è¡¨æ˜äº’æ–¥é‡çš„ç‰¹å®šä½¿ç”¨ä¸­å­˜åœ¨æ›´æ·±å±‚çš„é—®é¢˜ã€‚ TryLock å¯ä»¥ç”¨äºåœ¨ä¸šåŠ¡æ¯”è¾ƒç¹å¿™æ—¶å»å°è¯•è·å–é”ï¼Œå¤±è´¥åˆ™æç¤ºç›¸å…³æ–‡æ¡ˆç­‰ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 // TryLock tries to lock m and reports whether it succeeded. // // Note that while correct uses of TryLock do exist, they are rare, // and use of TryLock is often a sign of a deeper problem // in a particular use of mutexes. func (m *Mutex) TryLock() bool { old := m.state // å½“å‰é”å­˜åœ¨ æˆ– å½“å‰å¤„äºé¥¥é¥¿æ¨¡å¼ if old\u0026amp;(mutexLocked|mutexStarving) != 0 { return false\t// è·å–å¤±è´¥ } // There may be a goroutine waiting for the mutex, but we are // running now and can try to grab the mutex before that // goroutine wakes up. // // å¯èƒ½æœ‰ä¸€ä¸ªgoroutineåœ¨ç­‰å¾…äº’æ–¥é‡ï¼Œä½†æˆ‘ä»¬ç°åœ¨æ­£åœ¨è¿è¡Œï¼Œå¹¶ä¸”å¯ä»¥å°è¯•åœ¨goroutineå”¤é†’ä¹‹å‰è·å–äº’æ–¥é‡ã€‚ // // å°è¯•å»äº‰æŠ¢é”ï¼Œè¿™é‡Œçš„oldä¸€å®šæ˜¯æ²¡åŠ é”å¹¶å¤„äºæ­£å¸¸æ¨¡å¼ä¸‹å»å°è¯•äº‰æŠ¢ if !atomic.CompareAndSwapInt32(\u0026amp;m.state, old, old|mutexLocked) { return false\t// äº‰æŠ¢å¤±è´¥æƒ…å†µ } if race.Enabled { race.Acquire(unsafe.Pointer(m)) } return true\t// äº‰æŠ¢æˆåŠŸ } type Locker interface Lockeræ¥å£ä»£è¡¨ä¸€ä¸ªå¯ä»¥åŠ é”å’Œè§£é”çš„å¯¹è±¡ 1 2 3 4 5 // A Locker represents an object that can be locked and unlocked. type Locker interface { Lock() Unlock() } ä½¿ç”¨ç¤ºä¾‹ sync.Mutex äº’æ–¥é”ï¼šæ˜¯ä¼ ç»Ÿçš„å¹¶å‘ç¨‹åºå¯¹å…±äº«èµ„æºè¿›è¡Œè®¿é—®æ§åˆ¶çš„ä¸»è¦æ‰‹æ®µï¼ŒGoè¯­è¨€ä¸­æ¨èä½¿ç”¨é€šé“(channel)æ¥å®ç°èµ„æºå…±äº«å’Œé€šä¿¡ äº’æ–¥é”ï¼šç”±æ ‡å‡†åº“ sync åŒ…ä¸­åˆ†çš„ Mutex ç»“æ„ä½“ç±»å‹å®ç° åªæœ‰ä¸¤ä¸ªå…¬å¼€æ–¹æ³•ï¼š Lock() ï¼šè·å¾—é” Unlock() ï¼šé‡Šæ”¾é” åŒä¸€ä¸ªåç¨‹ä¸­åŒæ­¥è°ƒç”¨ä½¿ç”¨Lock()åŠ é”åï¼Œä¸èƒ½å†å¯¹å…¶åŠ é”ï¼Œå¦åˆ™ä¼šå¼•å‘è¿è¡Œæ—¶å¼‚å¸¸ï¼Œåªèƒ½åœ¨ Unlock() ä¹‹åå†æ¬¡ Lock() å¤šä¸ªåç¨‹ä¸­å¼‚æ­¥è°ƒç”¨Lock()æ²¡æœ‰é—®é¢˜ï¼Œä½†æ¯ä¸ªåç¨‹åªèƒ½è°ƒç”¨ä¸€æ¬¡Lock()ï¼Œç”±äºå¤šä¸ªåç¨‹ä¹‹é—´äº§ç”Ÿäº†é”ç«äº‰ï¼Œå› æ­¤ä¸ä¼šæœ‰è¿è¡Œæ—¶å¼‚å¸¸ äº’æ–¥é”ï¼šé€‚ç”¨äºåªå…è®¸æœ‰ä¸€ä¸ªè¯»æˆ–è€…å†™çš„åœºæ™¯ï¼Œæ‰€ä»¥è¯¥é”ä¹Ÿå«å…¨å±€é” å¦‚æœåœ¨ä½¿ç”¨ Unlock() å‰æœªåŠ é”ï¼Œå°±ä¼šå¼•èµ·ä¸€ä¸ªè¿è¡Œé”™è¯¯ï¼Œå·²ç»é”å®šçš„ Mutex å¹¶ä¸ä¸ç‰¹å®šçš„åç¨‹ç›¸å…³ï¼Œè¿™æ ·å¯ä»¥åˆ©ç”¨ä¸€ä¸ªåç¨‹å¯¹å…¶åŠ é”ï¼Œåœ¨åˆ©ç”¨å…¶å®ƒåç¨‹å¯¹å…¶è§£é” 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 // LockA() ä¸­æœ‰ Lock() // LockB() ä¸­ä¹Ÿæœ‰ Lock() // LockB() çš„ Lock() è¿è¡Œæ—¶ï¼Œé”è¿˜æ²¡æœ‰ Unlock()ï¼Œç¨‹åºå‘ç”Ÿ panic // è¿™æ˜¯åœ¨åŒæ­¥è°ƒç”¨äº’æ–¥é”ä¸­å¸¸è§çš„é—®é¢˜ï¼Œä¸€èˆ¬åœ¨ä¸€å¯¹äº’æ–¥é”ä¸­é—´ä¸è¦è°ƒç”¨å…¶å®ƒå‡½æ•°ï¼Œå³ä½¿è¦ç”¨ä¹Ÿå°½é‡é‡‡ç”¨å¼‚æ­¥æ–¹å¼ package main import ( \u0026#34;fmt\u0026#34; \u0026#34;sync\u0026#34; \u0026#34;time\u0026#34; ) var mutex sync.Mutex func main() { LockA() time.Sleep(10) } func LockA() { mutex.Lock()\t// åŠ é” fmt.Println(\u0026#34;Lock in A\u0026#34;) LockB() time.Sleep(5) fmt.Println(\u0026#34;Wake up in A\u0026#34;) mutex.Unlock()\t// è§£é” fmt.Println(\u0026#34;Unlock in A\u0026#34;) } func LockB() { fmt.Println(\u0026#34;B\u0026#34;) mutex.Lock()\t// åŠ é”\tmain goroutineåœ¨è¿™é‡Œè¢«é˜»å¡ï¼Œå¯¼è‡´deadlock fmt.Println(\u0026#34;Lock in B\u0026#34;) mutex.Unlock()\t// è§£é” fmt.Println(\u0026#34;Unlock in B\u0026#34;) } /* Lock in A B fatal error: all goroutines are asleep - deadlock! goroutine 1 [semacquire]: sync.runtime_SemacquireMutex(0x593b24, 0x0, 0x1) D:/True-False/Go/src/runtime/sema.go:71 +0x4e sync.(*Mutex).lockSlow(0x593b20) D:/True-False/Go/src/sync/mutex.go:138 +0x103 sync.(*Mutex).Lock(...) D:/True-False/Go/src/sync/mutex.go:81 main.LockB() D:/True-False/WWW/GoLang/src/xuexi/mutex.go:28 +0x194 main.LockA() D:/True-False/WWW/GoLang/src/xuexi/mutex.go:19 +0xa2 main.main() D:/True-False/WWW/GoLang/src/xuexi/mutex.go:12 +0x29 exit status 2 */ æŠŠä¸Šé¢åŒæ­¥æ”¹ä¸ºå¼‚æ­¥ï¼ŒæŠŠLockA()çš„LockB()æ”¹ä¸ºgo LockB() 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;sync\u0026#34; \u0026#34;time\u0026#34; ) var mutex sync.Mutex func main() { LockA() time.Sleep(10) } func LockA() { mutex.Lock()\t// åŠ é” fmt.Println(\u0026#34;Lock in A\u0026#34;) go LockB() time.Sleep(5) fmt.Println(\u0026#34;Wake up in A\u0026#34;) mutex.Unlock()\t// è§£é” fmt.Println(\u0026#34;Unlock in A\u0026#34;) } func LockB() { fmt.Println(\u0026#34;B\u0026#34;) mutex.Lock()\t// åŠ é”\tlockB goroutineç­‰å¾…LockAè§£é”ï¼Œå…ˆè‡ªæ—‹å†æ˜¯è¢«æŒ‚èµ· fmt.Println(\u0026#34;Lock in B\u0026#34;) mutex.Unlock()\t// è§£é” fmt.Println(\u0026#34;Unlock in B\u0026#34;) } /* Lock in A B Wake up in A Unlock in A Lock in B Unlock in B */ å»ºè®®ï¼šåŒä¸€ä¸ªäº’æ–¥é”çš„æˆå¯¹é”å®šå’Œè§£é”æ“ä½œå¯ä»¥æ”¾åœ¨åŒä¸€å±‚æ¬¡çš„ä»£ç å—ä¸­ ç»å…¸ç”¨æ³•å¦‚ä¸‹ï¼š 1 2 3 4 5 6 7 8 var lck sync.Mutex func foo() { lck.Lock()\t// åŠ é” defer lck.Unlock()\t// è§£é” // ... ... } // lck.Lock() ä¼šé˜»å¡ç›´åˆ°è·å–é”ï¼Œç„¶ååˆ©ç”¨deferè¯­å¥åœ¨å‡½æ•°è¿”å›æ—¶è‡ªåŠ¨é‡Šæ”¾é” ç¤ºä¾‹ä»£ç ï¼Œé€šè¿‡ä¸‰ä¸ªåç¨‹æ¥ä½“ç°sync.Mutexå¯¹èµ„æºçš„è®¿é—®æ§åˆ¶ç‰¹å¾ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;sync\u0026#34; \u0026#34;time\u0026#34; ) func main() { //var wg sync.WaitGroup wg := sync.WaitGroup{} var mutex sync.Mutex fmt.Println(\u0026#34;Locking (G0)\u0026#34;) mutex.Lock()\t// åŠ é” fmt.Println(\u0026#34;locked (G0)\u0026#34;) wg.Add(3) for i := 1; i \u0026lt; 4; i++ { go func(i int) { fmt.Printf(\u0026#34;Locking (G%d)\\n\u0026#34;, i) mutex.Lock()\t// åŠ é” fmt.Printf(\u0026#34;Locked (G%d)\\n\u0026#34;, i) time.Sleep(time.Second * 2)\t// å»¶è¿Ÿ2s mutex.Unlock()\t// è§£é” fmt.Printf(\u0026#34;unlocked (G%d)\\n\u0026#34;, i) wg.Done() }(i) } time.Sleep(time.Second * 5) fmt.Println(\u0026#34;ready unlock (G0)\u0026#34;) mutex.Unlock()\t// è§£é” fmt.Printf(\u0026#34;unlocked (G0)\u0026#34;) wg.Wait() } // ç¨‹åºè¿è¡Œç»“æœå¯ä»¥çœ‹å‡ºï¼Œå½“æœ‰é”é‡Šæ”¾æ—¶ï¼Œæ‰èƒ½è¿›è¡ŒåŠ é”åŠ¨ä½œ // è¿è¡Œç»“æœå¦‚ä¸‹ Locking (G0) locked (G0) Locking (G1) Locking (G2) Locking (G3) ready unlock (G0) unlocked (G0)Locked (G1) unlocked (G1) Locked (G2) unlocked (G2) Locked (G3) unlocked (G3) Mutex ä¹Ÿå¯ä»¥ä½œä¸ºç»“æ„ä½“çš„ä¸€éƒ¨åˆ†ï¼Œè¿™æ ·ç»“æ„ä½“åœ¨è¢«å¤šçº¿ç¨‹å¤„ç†æ—¶æ•°æ®å®‰å…¨æ‰æœ‰ä¿éšœ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;sync\u0026#34; \u0026#34;time\u0026#34; ) type Book struct { BookName string L *sync.Mutex } func (bk *Book) SetName(wg *sync.WaitGroup, name string) { defer func() { fmt.Println(\u0026#34;Unlock set name:\u0026#34;, name) bk.L.Unlock()\t// è§£é” wg.Done() }() bk.L.Lock()\t// åŠ é” fmt.Println(\u0026#34;Lock set name:\u0026#34;, name) time.Sleep(1 * time.Second) bk.BookName = name } func main() { bk := Book{} //bk.L = \u0026amp;sync.Mutex{} bk.L = new(sync.Mutex) //wg := new(sync.WaitGroup) wg := \u0026amp;sync.WaitGroup{} books := []string{\u0026#34;\u0026lt;\u0026lt;ä¸‰å›½æ¼”ä¹‰\u0026gt;\u0026gt;\u0026#34;, \u0026#34;\u0026lt;\u0026lt;é“å¾·ç»\u0026gt;\u0026gt;\u0026#34;, \u0026#34;\u0026lt;\u0026lt;è¥¿æ¸¸è®°\u0026gt;\u0026gt;\u0026#34;} for _, book := range books { wg.Add(1) go bk.SetName(wg, book) } wg.Wait() } Lock set name: \u0026lt;\u0026lt;è¥¿æ¸¸è®°\u0026gt;\u0026gt; Unlock set name: \u0026lt;\u0026lt;è¥¿æ¸¸è®°\u0026gt;\u0026gt; Lock set name: \u0026lt;\u0026lt;ä¸‰å›½æ¼”ä¹‰\u0026gt;\u0026gt; Unlock set name: \u0026lt;\u0026lt;ä¸‰å›½æ¼”ä¹‰\u0026gt;\u0026gt; Lock set name: \u0026lt;\u0026lt;é“å¾·ç»\u0026gt;\u0026gt; Unlock set name: \u0026lt;\u0026lt;é“å¾·ç»\u0026gt;\u0026gt; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;sync\u0026#34; \u0026#34;time\u0026#34; ) func main() { var m sync.Mutex go func() { m.Lock() defer m.Unlock() fmt.Println(\u0026#34;1\u0026#34;) m.Lock()\t// è¿™é‡Œå½“å‰goroutineå°†è¢«æ°¸ä¹…ä¿å­˜åˆ°ä¿¡å·æ± ä¸­å¾—ä¸åˆ°è¿è¡Œæœºä¼š fmt.Println(\u0026#34;2\u0026#34;) defer m.Unlock() fmt.Println(\u0026#34;3\u0026#34;) }() time.Sleep(5 * time.Second) // Output: // 1 } æ³¨æ„äº‹é¡¹ Lock() å’Œ UnLock() æ–¹æ³•åº”è¯¥æˆå¯¹å‡ºç°ã€‚ sync.Mutex ä¸å…è®¸è¢«å€¼æ‹·è´ï¼Œæ‹·è´åœ°å€å¯ä»¥ã€‚ ","permalink":"https://heliu.site/posts/golang/sync/mutex/","summary":"Mutexæ˜¯ä¸€ç§äº’æ–¥é”ã€‚","title":"sync.Mutex"},{"content":" å®šä¹‰ç»“æ„ä½“ã€æ¥å£ã€ç±»å‹åˆ«åç­‰ã€‚ å®šä¹‰è‡ªå®šä¹‰ç±»å‹ï¼š è‡ªå®šä¹‰ç±»å‹ç”±ä¸€ç»„å€¼ä»¥åŠä½œç”¨äºè¿™äº›å€¼çš„æ–¹æ³•ç»„æˆã€‚ ç±»å‹ä¸€èˆ¬æœ‰ç±»å‹åˆ«åï¼Œå¾€å¾€ä»ç°æœ‰ç±»å‹ç»„åˆé€šè¿‡typeå…³é”®å­—æ„é€ å‡ºä¸€ä¸ªæ–°çš„ç±»å‹ã€‚ è‡ªå®šä¹‰ç±»å‹ GoåŸºç¡€æ•°æ®ç±»å‹ï¼š boolã€complex64ã€complex128ã€float32ã€float64ã€‚ intã€int8ã€int16ã€int32ã€int64ã€runeã€stringã€‚ uintã€uint8ã€uint16ã€uint32ã€uint64ã€byteã€uintptrã€‚ ä½¿ç”¨typeå…³é”®å­—å¯ä»¥å®šä¹‰è‡ªå·±çš„ç±»å‹ï¼Œå¯ä»¥ä½¿ç”¨typeå®šä¹‰ä¸€ä¸ªæ–°çš„ç»“æ„ä½“ã€‚ ä¹Ÿå¯ä»¥æŠŠä¸€ä¸ªå·²ç»å­˜åœ¨çš„ç±»å‹ä½œä¸ºåŸºç¡€ç±»å‹è€Œå®šä¹‰æ–°ç±»å‹ï¼Œç„¶ååœ¨ä»£ç ä¸­ä½¿ç”¨æ–°çš„ç±»å‹åå­—ã€‚ 1 type IZ int IZæ˜¯ä¸€ç§æ–°ç±»å‹ï¼Œç„¶åå¯ä»¥ä½¿ç”¨ä¸‹é¢æ–¹å¼å£°æ˜å˜é‡ã€‚ 1 var a IZ = 5 å¯ä»¥çœ‹åˆ°intæ˜¯å˜é‡açš„åº•å±‚ç±»å‹ï¼Œè¿™ä¹Ÿä½¿å¾—ä»–ä»¬ä¹‹é—´æˆä¸ºç›¸äº’è½¬åŒ–çš„å¯èƒ½ã€‚ å®šä¹‰å¤šä¸ªç±»å‹å¦‚ä¸‹ï¼š 1 2 3 4 5 type ( IZ int FZ float64 STR string ) åœ¨type IZ intä¸­ï¼ŒIZå°±æ˜¯åœ¨intç±»å‹åŸºç¡€ä¸Šæ„å»ºçš„æ–°åç§°ï¼Œè¿™ç§°ä¸ºè‡ªå®šä¹‰ç±»å‹ï¼Œä½¿ç”¨IZæ¥æ“ä½œintç±»å‹çš„æ•°æ®ã€‚ è¿™ç§æ–¹æ³•å®šä¹‰ä¹‹åçš„ç±»å‹å¯ä»¥æ‹¥æœ‰æ›´å¤šçš„ç‰¹æ€§ï¼Œä½†æ˜¯åœ¨ç±»å‹è½¬æ¢æ—¶å¿…é¡»æ˜¾ç¤ºè½¬æ¢ã€‚ æ¯ä¸ªå€¼éƒ½å¿…é¡»åœ¨ç»è¿‡ç¼–è¯‘åå±äºæŸä¸ªç±»å‹ï¼ˆç¼–è¾‘å™¨å¿…é¡»èƒ½å¤Ÿæ¨æ–­å‡ºæ‰€æœ‰å€¼å¾—ç±»å‹ï¼‰å› ä¸ºGoæ˜¯ä¸€ç§é™æ€ç±»å‹è¯­è¨€ã€‚ åœ¨å¿…è¦ä»¥åŠå¯è¡Œçš„æƒ…å†µä¸‹ï¼Œä¸€ç§ç±»å‹çš„å€¼å¯ä»¥è¢«è½¬æ¢æˆå¦å¤–ä¸€ç§ç±»å‹çš„å€¼ã€‚ Goè¯­è¨€ä¸å­˜åœ¨éšå¼è½¬æ¢ï¼Œå› æ­¤æ‰€æœ‰çš„è½¬æ¢éƒ½å¿…é¡»æ˜¾å¼è¯´æ˜ï¼Œå°±åƒè°ƒç”¨ä¸€ä¸ªå‡½æ•°ä¸€æ ·ï¼ˆç±»å‹åœ¨è¿™é‡Œçš„ä½œç”¨å¯ä»¥çœ‹ä½œæ˜¯ä¸€ç§å‡½æ•°ï¼‰ã€‚ 1 valueOfTypeB = typeB(valueOfTypeA) ç±»å‹Bçš„å€¼ = ç±»å‹B(ç±»å‹Açš„å€¼)ã€‚ type TZ intä¸­ï¼Œæ–°ç±»å‹TZä¸ä¼šæ‹¥æœ‰åŸåŸºç¡€ç±»å‹æ‰€é™„å¸¦çš„æ–¹æ³•ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 package main import ( \u0026#34;fmt\u0026#34; ) type A struct { Face int } func (a A) f () { fmt.Println(\u0026#34;hi \u0026#34;, a.Face) } // è‡ªå®šä¹‰æ–°ç±»å‹Aaã€‚æ²¡æœ‰åŸºç¡€ç±»å‹Açš„æ–¹æ³• type Aa A func main() { var s A = A{Face:9} s.f() // hi 9 var sa Aa = Aa{Face:90} //sa.f() // æ–¹æ³•ä¸å­˜åœ¨ fmt.Println(sa) // {90} } é€šè¿‡typeå…³é”®å­—åœ¨åŸæœ‰ç±»å‹åŸºç¡€ä¸Šæ„é€ å‡ºä¸€ä¸ªæ–°ç±»å‹ï¼Œéœ€è¦é’ˆå¯¹æ–°ç±»å‹æ¥é‡æ–°åˆ›å»ºæ–°æ–¹æ³•ã€‚ ç±»å‹åˆ«å ç±»å‹åˆ«ååœ¨Go1.9ç‰ˆæœ¬ä¸­å®ç°ï¼Œå°†åˆ«åç±»å‹å’ŒåŸç±»å‹è¿™ä¸¤ä¸ªç±»å‹è§†ä¸ºå®Œå…¨ä¸€è‡´ã€‚ 1 type IZ = int ä¸type IZ intä¸åŒï¼Œtype IZ = intåªæ˜¯ä¸ºintå–äº†ä¸ªåˆ«åï¼Œè€Œtype IZ intå´æ˜¯å®šä¹‰äº†æ–°ç±»å‹ã€‚ è‡ªå®šä¹‰ç±»å‹ä¸ä¼šæ‹¥æœ‰åŸç±»å‹é™„å¸¦çš„æ–¹æ³•ï¼Œè€Œåˆ«åæ‹¥æœ‰åŸç±»å‹é™„å¸¦çš„æ–¹æ³•ï¼Œç±»å‹åˆ«åæ‹¥æœ‰åŸç±»å‹å…¨éƒ¨çš„æ–¹æ³•ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 package main import ( \u0026#34;fmt\u0026#34; ) type A struct { Face int } func (a A) f () { fmt.Println(\u0026#34;hi \u0026#34;, a.Face) } // è‡ªå®šä¹‰æ–°ç±»å‹Aaã€‚æ²¡æœ‰åŸºç¡€ç±»å‹Açš„æ–¹æ³• type Aa = A func main() { var s A = A{Face:9} s.f() // hi 9 var sa Aa = Aa{Face:90} sa.f() // hi 90 fmt.Println(sa) // {90} } Goè¯­è¨€ä¸å­˜åœ¨ç±»å‹ç»§æ‰¿ã€‚ å‡½æ•°ä¹Ÿæ˜¯ä¸€ä¸ªç¡®å®šçš„ç±»å‹ï¼Œå°±æ˜¯ä»¥å‡½æ•°ç­¾åä½œä¸ºç±»å‹ï¼Œå‡½æ•°ç­¾åï¼šå‡½æ•°çš„å‚æ•°å’Œè¿”å›å€¼ã€‚ 1 type typeFunc func(int, int) int å¯ä»¥åœ¨å‡½æ•°ä½“ä¸­çš„æŸå¤„è¿”å›ä½¿ç”¨ç±»å‹ä¸ºtypeFuncçš„å˜é‡varfuncã€‚ 1 return varfunc è‡ªå®šä¹‰ç±»å‹ä¸ä¼šç»§æ‰¿åŸæœ‰ç±»å‹çš„æ–¹æ³•ï¼Œä½†æ¥å£æ–¹æ³•æˆ–ç»„åˆç±»å‹çš„å†…åµŒå…ƒç´ åˆ™ä¿ç•™åŸæœ‰çš„æ–¹æ³•ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 package main import ( \u0026#34;fmt\u0026#34; ) // Mutex ç”¨ä¸¤ç§æ–¹æ³•ï¼ŒLockå’ŒUnlock type Mutex struct{} func (m *Mutex) Lock() {} func (m *Mutex) Unlock() {} //NewMutex å’Œ Mutex çš„æ•°æ®ç»“æ„ä¸€æ ·ï¼Œä½†æ˜¯å…¶æ–¹æ³•æ˜¯ç©ºçš„ type NewMutex Mutex // PtrMutex çš„æ–¹æ³•ä¹Ÿæ˜¯ç©ºçš„ type PtrMutex Mutex // PrintableMutex æ‹¥æœ‰Lockå’ŒUnlockæ–¹æ³• type PrintableMutex struct { Mutex\t// ç»„åˆ } func main() {} ","permalink":"https://heliu.site/posts/golang/type/typ/","summary":"Golang typeå…³é”®å­—ç”¨æ³•ä»‹ç»ã€‚","title":"type"},{"content":"Golang è½¯ä»¶å®‰è£… é¦–å…ˆéœ€è¦ä¸‹è½½Goè¯­è¨€å®‰è£…åŒ…ã€‚ ä¸‹è½½åœ°å€ï¼šhttps://golang.org/dl/ã€‚ï¼ˆä¸­å›½å¤§é™†å¯èƒ½è®¿é—®ä¸åˆ°ï¼‰ å›½å†…ä¸‹è½½åœ°å€ï¼šhttps://golang.google.cn/dl/ã€‚ å®˜æ–¹å®‰è£…æ•™ç¨‹ï¼šhttps://golang.google.cn/doc/installã€‚ å®˜æ–¹çš„æ•™ç¨‹å¾ˆè¯¦ç»†ï¼ˆhttps://golang.google.cn/docï¼‰ã€‚ Linux UNIX / Linux / Mac OSå’ŒFreeBSDç³»ç»Ÿå¯ä»¥ä½¿ç”¨å¦‚ä¸‹æºç å®‰è£…æ–¹æ³•ã€‚ Macç³»ç»Ÿä¸‹å¯ä»¥ä½¿ç”¨ä»¥.pkgä¸ºæ‰©å±•åçš„å®‰è£…åŒ…ç›´æ¥åŒå‡»æ¥å®Œæˆå®‰è£…ï¼Œå®‰è£…ç›®å½•åœ¨/usr/local/go/ä¸‹ã€‚ Linuxä¸‹å®‰è£…golangæ­¥éª¤ ä¸‹è½½å®‰è£…åŒ…wget https://golang.google.cn/dl/go1.17.3.linux-amd64.tar.gzã€‚ 32-bit Linuxä¸‹è½½å®‰è£…åŒ… https://golang.google.cn/dl/go1.17.3.linux-386.tar.gzã€‚ 64-bit Linuxä¸‹è½½å®‰è£…åŒ… https://golang.google.cn/dl/go1.17.3.linux-amd64.tar.gzã€‚ åˆ é™¤è€ç‰ˆæœ¬ï¼ˆå¦‚æœå­˜åœ¨åˆ™æ‰§è¡Œï¼Œä¸å­˜åœ¨åˆ™å¿½ç•¥ï¼‰rm -rf /usr/local/goã€‚ è§£å‹å®‰è£…åŒ…sudo tar -xzf go1.17.3.linux-amd64.tar.gz -C /usr/localã€‚ é…ç½®ç¯å¢ƒå˜é‡ï¼šä½¿ç”¨go env -wå‘½ä»¤ä¸€èˆ¬åªæ˜¯æœ¬æ¬¡ç”Ÿæ•ˆã€‚ PATHç¯å¢ƒå˜é‡export PATH=$PATH:/usr/local/go/binGoLangå·¥å…·ä½ç½®ï¼ŒåŒ…å«gofmtå·¥å…·ã€‚ GOROOTå˜é‡export GOROOT=/usr/local/goGoLangå®‰è£…åŒ…ä½ç½®ã€‚ ä½¿ç”¨go env -w GOROOT=/usr/local/goé…ç½®ä¹Ÿæ˜¯å¯ä»¥çš„ã€‚ GOPATHå˜é‡export GOPATH=/var/local/goGoLang 1.11ç‰ˆæœ¬å‰é¡¹ç›®ç®¡ç†åŒ…ä½ç½®ã€‚ ä½¿ç”¨go env -w GOPATH=/var/local/goé…ç½®ä¹Ÿæ˜¯å¯ä»¥çš„ã€‚ æ‰“å°Goç‰ˆæœ¬å·go versionã€‚ å¦‚æœä¸Šé¢(ç¬¬4æ­¥)ç¯å¢ƒå˜é‡é…ç½®ä¸æˆåŠŸï¼Œé‚£ä¹ˆæ‰§è¡Œå¦‚ä¸‹æ­¥éª¤é…ç½®ï¼š sudo vim ~/.bashrcå‘½ä»¤æ‰“å¼€æ–‡ä»¶ã€‚ åœ¨æ–‡ä»¶æœ€åæ·»åŠ ï¼š 1 2 3 4 5 6 7 export GOROOT=/usr/local/go export GOPATH=/var/local/go export PATH=$PATH:$GOROOT/bin:$GOPATH/bin export GOPROXY=\u0026#34;https://goproxy.cn,direct\u0026#34; # åœ¨linuxä¸­è®¾ç½®ä¸´æ—¶ç›®å½•ï¼Œwindowsä¸ç”¨ export TMPDIR=/tmp æœ€åä½¿é…ç½®ç”Ÿæ•ˆ source ~/.bashrcã€‚ Windows ä¸‹è½½ https://golang.google.cn/dl/go1.17.3.windows-amd64.zipï¼Œç›´æ¥è§£å‹åˆ°å®‰è£…ç›®å½•ã€‚ å¦‚D:\\Goï¼Œç„¶åæŠŠD:\\Go\\binç›®å½•æ·»åŠ åˆ°PATHç¯å¢ƒå˜é‡ä¸­ã€‚ è®¾ç½®GOPATHå’ŒGOROOTç¯å¢ƒå˜é‡ï¼š GOPATH=D:\\goprojectã€‚ GOROOT=D:\\GO\\ã€‚ ä¹Ÿå¯ä»¥é€‰æ‹© https://golang.google.cn/dl/go1.17.3.windows-amd64.msiï¼ŒåŒå‡»è¿è¡Œç¨‹åºï¼Œæ ¹æ®æç¤ºæ¥æ“ä½œå®‰è£…ã€‚ GOROOTã€GOPATH GOROOT Goè½¯ä»¶çš„å®‰è£…åŒ…ç»å¯¹è·¯å¾„ï¼Œé»˜è®¤æ˜¯/usr/local/goã€‚ GOPATH $GOPATHå…è®¸æœ‰å¤šä¸ªç›®å½•ï¼Œå½“æœ‰å¤šä¸ªç›®å½•æ—¶ï¼Œè¯·æ³¨æ„åˆ†éš”ç¬¦ï¼ŒWindowsä¸­çš„åˆ†éš”ç¬¦æ˜¯åˆ†å·(;)ã€‚ å½“æœ‰å¤šä¸ªç›®å½•æ—¶é»˜è®¤å°†go getå‘½ä»¤è·å–çš„åŒ…å­˜æ”¾åœ¨ç¬¬ä¸€ä¸ªç›®å½•ä¸‹ï¼Œå½“åœ¨GOPATHæ¨¡å¼ä¸‹è¿è¡Œæ—¶æ˜¯è¿™æ ·å¤„ç†çš„ã€‚ $GOPATHç›®å½•ä¸‹çº¦å®šæœ‰ä¸‰ä¸ªå­ç›®å½•ï¼š srcç›®å½•ï¼šå­˜æ”¾æºä»£ç ï¼ˆå¦‚.goï¼Œ.cï¼Œ.hï¼Œ.sç­‰æ–‡ä»¶ï¼‰ã€‚ æŒ‰ç…§Goé»˜è®¤çº¦å®šï¼Œsrcç›®å½•æ˜¯go runï¼Œgo installç­‰å‘½ä»¤çš„å½“å‰å·¥ä½œè·¯å¾„ï¼ˆå³åœ¨æ­¤è·¯å¾„ä¸‹æ‰§è¡Œä¸Šè¿°å‘½ä»¤ï¼‰ã€‚ srcä¹Ÿæ˜¯ç”¨æˆ·ä»£ç å­˜æ”¾çš„ä¸»è¦ç›®å½•ï¼Œæ‰€æœ‰çš„æºä»£ç éƒ½å­˜æ”¾åœ¨è¿™ä¸ªç›®å½•ä¸‹é¢ï¼Œä¸€èˆ¬ä¸€ä¸ªé¡¹ç›®å’Œä¸€ä¸ªç›®å½•å¯¹åº”ã€‚ å½“åœ¨GOPATHæ¨¡å¼ä¸‹è¿è¡Œæ—¶æ˜¯è¿™æ ·å¤„ç†çš„ï¼Œä½†æ˜¯Goå®˜æ–¹åœ¨Go 1.11ç‰ˆæœ¬åä¸å†æ¨èä½¿ç”¨GOPATHæ¨¡å¼ç¼–å†™Goä»£ç ï¼Œå› æ­¤srcç›®å½•æ— ç”¨å¤„ã€‚ pkgç›®å½•ï¼šå­˜æ”¾ç¼–è¯‘æ—¶ç”Ÿæˆçš„ä¸­é—´æ–‡ä»¶ï¼ˆæ¯”å¦‚ï¼š.aï¼‰ã€‚ binç›®å½•ï¼šå­˜æ”¾ç¼–è¯‘åç”Ÿæˆçš„å¯æ‰§è¡Œæ–‡ä»¶ï¼Œæ¯”å¦‚åé¢å®‰è£…çš„delveæ’ä»¶æˆ–å¤šç‰ˆæœ¬goè½¯ä»¶å°±æ˜¯åœ¨è¿™ä¸ªç›®å½•é‡Œã€‚ ç®¡ç†Goå®‰è£… å®‰è£…å¤šä¸ªGoç‰ˆæœ¬ åœ¨åŒä¸€å°æœºå™¨ä¸Šå®‰è£…å¤šä¸ªGoç‰ˆæœ¬ã€‚ä¾‹å¦‚ï¼Œæˆ‘ä»¬å¯èƒ½å¸Œæœ›åœ¨å¤šä¸ªGoç‰ˆæœ¬ä¸Šæµ‹è¯•ä»£ç ã€‚ æ³¨æ„ï¼šéœ€è¦ä½¿ç”¨è¿™ç§å½¢å¼å®‰è£…éœ€è¦å…ˆå®‰è£…gitã€‚ å¤šç‰ˆæœ¬goå®‰è£…æ­¥éª¤ è¦å®‰è£…å…¶ä»–Goç‰ˆæœ¬ï¼Œè¿è¡Œgo installå‘½ä»¤ï¼ŒæŒ‡å®šè¦å®‰è£…çš„ç‰ˆæœ¬çš„ä¸‹è½½ä½ç½®ã€‚å¦‚ä¸‹ç¤ºä¾‹å®‰è£…ç‰ˆæœ¬1.10.7ï¼š go install golang.org/dl/go1.10.7@latestè¿™é‡Œä½¿ç”¨go installç¼–è¯‘å¹¶å®‰è£…æŒ‡å®šçš„åŒ…æ¥å®ç°å¤šç‰ˆæœ¬goå®‰è£ï¼Œç”Ÿæˆåçš„å¯æ‰§è¡Œæ–‡ä»¶åœ¨binç›®å½•ä¸‹ï¼ˆ$GOPATH/binï¼‰ã€‚ go1.10.7 downloadä¸‹è½½ï¼Œéœ€è¦åˆ‡æ¢åˆ°$GOPATH/binä¸‹å»æ‰§è¡Œï¼Œç”Ÿæˆçš„å®‰è£…è·¯å¾„åœ¨/root/sdk/go1.10.7ã€‚ 1 2 $ go install golang.org/dl/go1.10.7@latest # å®‰è£…å¹¶ç¼–è¯‘go1.10.7ç‰ˆæœ¬ $ go1.10.7 download è¦ä½¿ç”¨æ–°ä¸‹è½½çš„ç‰ˆæœ¬è¿è¡Œå‘½ä»¤ï¼Œå¦‚ä¸‹æ‰€ç¤ºï¼š 1 2 $ go1.10.7 version go version go1.10.7 linux/amd64 å½“ä½ å®‰è£…äº†å¤šä¸ªç‰ˆæœ¬æ—¶ï¼Œå¯ä»¥ä½¿ç”¨å¦‚ä¸‹å‘½ä»¤æŸ¥çœ‹æ¯ä¸ªç‰ˆæœ¬çš„å®‰è£…ä½ç½®ï¼š 1 $ go1.10.7 env GOROOT è¦å¸è½½ä¸‹è½½çš„ç‰ˆæœ¬æ—¶ï¼Œåªéœ€è¦åˆ é™¤å…¶ç”±GOROOTç¯å¢ƒå˜é‡å’Œgo.X.Y.ZäºŒè¿›åˆ¶æ–‡ä»¶æŒ‡å®šçš„å®‰è£…ç›®å½•å³å¯ã€‚ å¸è½½Go ä½¿ç”¨å¦‚ä¸‹æ‰€æè¿°çš„æ­¥éª¤ä»ç³»ç»Ÿä¸­åˆ é™¤Goã€‚ Linux / macOS / FreeBSD åˆ é™¤goç›®å½•ï¼šé€šå¸¸æ˜¯/usr/local/goç›®å½•ã€‚ ä»PATHç¯å¢ƒå˜é‡ä¸­åˆ é™¤Go binç›®å½•ã€‚ åœ¨Linuxå’ŒFreeBSDä¸‹ï¼Œç¼–è¾‘/etc/profileæˆ–$HOME/.profileã€‚ å¦‚æœæ‚¨ä½¿ç”¨macOSè½¯ä»¶åŒ…å®‰è£…äº†Goï¼Œè¯·åˆ é™¤/etc/paths.d/goæ–‡ä»¶ã€‚ Windows åˆ é™¤Goçš„æœ€ç®€å•æ–¹æ³•æ˜¯é€šè¿‡Windowsæ§åˆ¶é¢æ¿ä¸­çš„ Add/Remove ç¨‹åºï¼š åœ¨æ§åˆ¶é¢æ¿ä¸­ï¼ŒåŒå‡»Add/Removeç¨‹åºã€‚ åœ¨Add/Removeç¨‹åºä¸­ï¼Œé€‰æ‹©è¦å¸è½½çš„è½¯ä»¶ï¼Œå•å‡»å¸è½½ï¼Œç„¶åæŒ‰ç…§æç¤ºè¿›è¡Œæ“ä½œã€‚ è¦ä½¿ç”¨å·¥å…·åˆ é™¤Goï¼Œæ‚¨è¿˜å¯ä»¥ä½¿ç”¨å‘½ä»¤è¡Œï¼š é€šè¿‡è¿è¡Œä»¥ä¸‹å‘½ä»¤ä½¿ç”¨å‘½ä»¤è¡Œå¸è½½ï¼šmsiexec /x go{{version}}.windows-{{cpu-arch}}.msi /q æ³¨æ„ï¼šå¯¹ Windows ä½¿ç”¨æ­¤å¸è½½è¿‡ç¨‹å°†è‡ªåŠ¨åˆ é™¤ç”±åŸå§‹å®‰è£…åˆ›å»ºçš„ Windows ç¯å¢ƒå˜é‡ã€‚ ","permalink":"https://heliu.site/posts/golang/install/install/","summary":"Go è½¯ä»¶å®‰è£…ã€‚","title":"Install Golang"},{"content":"type WaitGroup struct ğŸš€ WaitGroup ç­‰å¾… goroutine é›†åˆå®Œæˆã€‚ main goroutine è°ƒç”¨ Add æ¥è®¾ç½®è¦ç­‰å¾…çš„ goroutine çš„æ•°é‡ã€‚ç„¶åæ¯ä¸ª goroutine è¿è¡Œå¹¶åœ¨å®Œæˆæ—¶è°ƒç”¨ Doneã€‚ åŒæ—¶ï¼Œå¯ä»¥ä½¿ç”¨ Wait æ¥é˜»å¡ï¼Œç›´åˆ°æ‰€æœ‰ goroutine å®Œæˆã€‚ WaitGroup åœ¨ç¬¬ä¸€æ¬¡ä½¿ç”¨åä¸èƒ½è¢«å¤åˆ¶ã€‚ WaitGroupï¼šç”¨äºç­‰å¾…ä¸€ç»„çº¿ç¨‹çš„ç»“æŸï¼Œçˆ¶çº¿ç¨‹è°ƒç”¨Addæ–¹æ³•æ¥è®¾å®šåº”ç­‰å¾…çš„çº¿ç¨‹çš„æ•°é‡ã€‚ æ¯ä¸ªè¢«ç­‰å¾…çš„çº¿ç¨‹åœ¨ç»“æŸæ—¶åº”è°ƒç”¨Doneæ–¹æ³•ï¼ŒåŒæ—¶ï¼Œä¸»çº¿ç¨‹é‡Œå¯ä»¥è°ƒç”¨Waitæ–¹æ³•é˜»å¡è‡³æ‰€æœ‰çº¿ç¨‹ç»“æŸã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 // A WaitGroup waits for a collection of goroutines to finish. // The main goroutine calls Add to set the number of // goroutines to wait for. Then each of the goroutines // runs and calls Done when finished. At the same time, // Wait can be used to block until all goroutines have finished. // // A WaitGroup must not be copied after first use. type WaitGroup struct { // WaitGroup é¦–æ¬¡ä½¿ç”¨åä¸èƒ½è¢«æ‹·è´çš„åŸå› ã€æ˜¯ \u0026amp;state2 åœ°å€ä¼šå‘ç”Ÿå˜åŒ–ã€‘ // semaPhore è¦æ±‚ \u0026amp;state2 åœ°å€æ˜¯ä¸€ä¸ªï¼Œä¸ç„¶ä»å…¶ä¸­å”¤é†’ goroutine ä¼šæ‰¾ä¸åˆ° noCopy noCopy\t// ç¼–è¯‘å™¨æ£€æŸ¥WaitGroupå¯¹è±¡æ˜¯å¦è¢«æ‹·è´è¿‡ // 64-bit value: high 32 bits are counter, low 32 bits are waiter count. // 64-bit atomic operations require 64-bit alignment, but 32-bit // compilers only guarantee that 64-bit fields are 32-bit aligned. // For this reason on 32 bit architectures we need to check in state() // if state1 is aligned or not, and dynamically \u0026#34;swap\u0026#34; the field order if // needed. // // 64ä½å€¼: é«˜32ä½æ˜¯ counter è®¡æ•°ï¼Œä½32ä½æ˜¯ waiter è®¡æ•°ã€‚ // 64-bit = ( uint64(counter) \u0026lt;\u0026lt; 32 ) | uint32( waiter ) // ã€64ä½åŸå­æ“ä½œéœ€è¦64ä½å¯¹é½ã€‘ï¼Œä½†æ˜¯32ä½ç¼–è¯‘å™¨åªä¿è¯64ä½å­—æ®µæ˜¯32ä½å¯¹é½çš„ã€‚ // å› æ­¤ï¼Œåœ¨32ä½æ¶æ„ä¸Šï¼Œæˆ‘ä»¬éœ€è¦æ£€æŸ¥åœ¨state()æ˜¯å¦å°†state1å¯¹é½ï¼Œå¹¶åœ¨éœ€è¦æ—¶åŠ¨æ€ â€œäº¤æ¢â€ å­—æ®µé¡ºåºã€‚ // æ„æ€æ˜¯ï¼šåœ¨32ä½æ“ä½œç³»ç»Ÿä¸‹ä½¿ç”¨64ä½åŸå­æ“ä½œæ—¶ï¼Œè¢«æ“ä½œåœ°å€å¿…é¡»æ˜¯64ä½å¯¹é½çš„ï¼Œä¸ç„¶ä¼šå®•æœºã€‚ state1 uint64\t// (uint64(counter) \u0026lt;\u0026lt; 32) | uint32(waiter) state2 uint32 } type noCopy struct noCopy å¯ä»¥åµŒå…¥åˆ°ç¬¬ä¸€æ¬¡ä½¿ç”¨åä¸å¾—å¤åˆ¶çš„ç»“æ„ä¸­. sync/cond.goæ–‡ä»¶ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 // noCopy may be embedded into structs which must not be copied // after the first use. // // See https://golang.org/issues/8005#issuecomment-190753527 // for details. type noCopy struct{} // Lock is a no-op used by -copylocks checker from `go vet`. // // Lock æ˜¯ `go vet` çš„ -copylocks æ£€æŸ¥å™¨ä½¿ç”¨çš„æ— æ“ä½œ func (*noCopy) Lock() {} func (*noCopy) Unlock() {} WaitGroup ç»“æ„å¸ƒå±€ Semaphoreï¼šä¿¡å·é‡ç”¨äºæŒ‚èµ· Wait å‡½æ•°çš„è°ƒç”¨è€…çš„ goroutineã€‚ï¼ˆéœ€è¦ä¸€ä¸ª uint32 ç±»å‹ï¼‰ Counterï¼šç­‰å¾…çš„è¿è¡Œçš„ goroutine æ•°é‡ï¼Œè¯¥å€¼åœ¨ Add å’Œ Done å‡½æ•°ä¸­è¢«æ“ä½œã€‚ Waiterï¼šç­‰å¾…åœ¨ Semaphore ä¸­çš„ goroutine æ•°é‡ã€‚ ä¸ºä»€ä¹ˆéœ€è¦è¿™ä¹ˆè®¾è®¡å‘¢ï¼Ÿå› ä¸º Waiter + Counter æ˜¯ä¸€ä¸ªæ•´ä½“ä½œä¸º64ä½ï¼Œè¢«åŸå­æ“ä½œï¼Œè€Œ64ä½åŸå­æ“ä½œåˆè¦æ±‚å¿…é¡»æ˜¯64ä½å¯¹é½çš„ã€‚ï¼ˆå…·ä½“å‚çœ‹state()æºç ï¼‰ åœ¨1.22ç‰ˆæœ¬ä¸­ï¼Œstate1ä¹Ÿå°±æ˜¯Waiterå’ŒCounterä½¿ç”¨atomic.Uint64æ›¿ä»£äº†ã€‚ä»¥ä¸‹å›¾æ˜¯1.18å‰ç‰ˆæœ¬çš„ã€‚ Semaã€Counterã€Waiter WaitGroup ç»“æ„è®¾è®¡ç›®çš„æ˜¯ç­‰å¾…é›†åˆä¸­çš„goroutineå®Œæˆï¼Œå› æ­¤ main goroutine å°±æ˜¯äº§ç”Ÿè¿™ä¸ªç­‰å¾…é›†åˆçš„ï¼Œå®ƒç­‰å¾…é›†åˆä¸­çš„æ‰€æœ‰goroutineå®Œæˆå†ç»§ç»­åç»­ã€‚ Counter åˆ™æ˜¯è®¡æ•°å½“å‰ç­‰å¾…é›†åˆä¸­çš„goroutineçš„æ•°é‡ï¼Œä¸€ä¸ªgoroutineè¢«åˆ›å»ºæ”¾å…¥é›†åˆæ—¶å°±åº”è¯¥è®¡æ•°Counterå€¼ï¼Œä¸€ä¸ªgoroutineå®Œæˆæ—¶ä¹Ÿåº”è¯¥è®¡æ•°Counterã€‚ å› æ­¤goroutineè¢«åŠ å…¥åˆ°ç­‰å¾…é›†åˆä¸­éƒ½æ˜¯åœ¨main goroutineä¸­æ“ä½œåŒ…æ‹¬Counterçš„è®¡æ•°ï¼Œä¸€ä¸ªgoroutineå®Œæˆè®¡æ•°Counteråº”è¯¥åœ¨è¿™goroutineå®Œæˆæ—¶æ“ä½œã€‚ Semaphore åˆ™æ˜¯ main goroutine åœ¨è°ƒç”¨Wait()å‡½æ•°æ—¶ï¼Œmain goroutineéœ€è¦ç­‰å¾…ç­‰å¾…é›†åˆgoroutineå®Œæˆè€ŒæŒ‚èµ·åœ¨Semaphoreæ± å­é‡Œã€‚ Waiter åˆ™æ˜¯è®°å½•Semaphoreä¸­ç­‰å¾…çš„goroutineçš„æ•°é‡ã€‚ Add() å’Œ Done() å‡½æ•°æ˜¯è®¡æ•°Counterçš„ç›¸å…³æ–¹æ³•ï¼Œåœ¨ç­‰å¾…é›†åˆgoroutineä¸­æœ€åä¸€ä¸ªgoroutineå®Œæˆæ—¶ï¼Œå¦‚æœæœ‰ç­‰å¾…åœ¨Semaphoreçš„goroutineåº”è¯¥å…¨éƒ¨å”¤é†’ã€‚ Wait() å‡½æ•°æ˜¯ç­‰å¾…ç­‰å¾…é›†åˆgoroutineå®Œæˆï¼Œmain goroutineä¸»åŠ¨æŒ‚èµ·è‡ªå·±çš„ç›¸å…³é€»è¾‘ã€‚ state() State è¿”å›æŒ‡å‘å­˜å‚¨åœ¨ wg.state* ä¸­çš„ State å’Œ sema å­—æ®µçš„æŒ‡é’ˆã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 // state returns pointers to the state and sema fields stored within wg.state*. func (wg *WaitGroup) state() (statep *uint64, semap *uint32) { // unsafe.Alignof(wg.state1) == 8ï¼šè¯´æ˜state1å­—æ®µå¯¹é½ä¸º8å­—èŠ‚ï¼Œè¿™ç§æƒ…å†µæ˜¯64ä½å¹³å° // uintptr(unsafe.Pointer(\u0026amp;wg.state1))%8 == 0ï¼šè¯´æ˜wg.state1çš„åœ°å€æŒ‰ç…§8å­—èŠ‚å¯¹é½çš„ï¼Œå¯èƒ½æ˜¯64æˆ–32å¹³å° if unsafe.Alignof(wg.state1) == 8 || uintptr(unsafe.Pointer(\u0026amp;wg.state1))%8 == 0 { // state1 is 64-bit aligned: nothing to do. // state1 æ˜¯ 64 ä½å¯¹é½çš„ï¼šæ— äº‹å¯åš return \u0026amp;wg.state1, \u0026amp;wg.state2\t// state1æ˜¯64ä½å¯¹é½ï¼Œstate1å°±æ˜¯stateï¼Œstate2å°±æ˜¯sema } else { // state1 is 32-bit aligned but not 64-bit aligned: this means that // (\u0026amp;state1)+4 is 64-bit aligned. // // State1æ˜¯32ä½å¯¹é½ï¼Œè€Œä¸æ˜¯64ä½å¯¹é½:è¿™æ„å‘³ç€ (\u0026amp;state1)+4 æ˜¯64ä½å¯¹é½ã€‚ // è¿™ç§æƒ…å†µå¤„ç†å°±æ˜¯ä¸ºäº†æ»¡è¶³åç»­ï¼š64ä½åŸå­æ“ä½œéœ€è¦64ä½å¯¹é½ state := (*[3]uint32)(unsafe.Pointer(\u0026amp;wg.state1))\treturn (*uint64)(unsafe.Pointer(\u0026amp;state[1])), \u0026amp;state[0] } } Add() Add å°† delta (å¯èƒ½æ˜¯è´Ÿæ•°)æ·»åŠ åˆ° WaitGroup counterã€‚ å¦‚æœ counter å˜ä¸º0ï¼Œæ‰€æœ‰åœ¨ç­‰å¾…æ—¶è¢«é˜»å¡çš„ goroutine éƒ½ä¼šè¢«é‡Šæ”¾ã€‚å¦‚æœ counter å˜ä¸ºè´Ÿæ•°ï¼Œåˆ™ä¼š paincã€‚ è¯·æ³¨æ„ï¼Œå½“ counter ä¸º0æ—¶ï¼Œdeltaä¸ºæ­£çš„è°ƒç”¨å¿…é¡»å‘ç”Ÿåœ¨ç­‰å¾…ä¹‹å‰ã€‚ ä½¿ç”¨è´Ÿçš„deltaè°ƒç”¨ï¼Œæˆ–è€…ä» counter å¤§äºé›¶å¼€å§‹ä½¿ç”¨æ­£çš„deltaè°ƒç”¨ï¼Œéƒ½å¯èƒ½åœ¨ä»»ä½•æ—¶å€™å‘ç”Ÿã€‚ é€šå¸¸ï¼Œè¿™æ„å‘³ç€å¯¹Addçš„è°ƒç”¨åº”è¯¥åœ¨åˆ›å»ºgoroutineè¯­å¥æˆ–å…¶ä»–è¦ç­‰å¾…çš„äº‹ä»¶ä¹‹å‰æ‰§è¡Œã€‚ å¦‚æœé‡ç”¨ä¸€ä¸ª WaitGroup æ¥ç­‰å¾…å‡ ä¸ªç‹¬ç«‹çš„äº‹ä»¶é›†ï¼Œé‚£ä¹ˆæ–°çš„Addè°ƒç”¨å¿…é¡»åœ¨æ‰€æœ‰å…ˆå‰çš„waitè°ƒç”¨éƒ½è¿”å›ä¹‹åå‘ç”Ÿã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 // Add adds delta, which may be negative, to the WaitGroup counter. // If the counter becomes zero, all goroutines blocked on Wait are released. // If the counter goes negative, Add panics. // // Note that calls with a positive delta that occur when the counter is zero // must happen before a Wait. Calls with a negative delta, or calls with a // positive delta that start when the counter is greater than zero, may happen // at any time. // Typically this means the calls to Add should execute before the statement // creating the goroutine or other event to be waited for. // If a WaitGroup is reused to wait for several independent sets of events, // new Add calls must happen after all previous Wait calls have returned. // See the WaitGroup example. func (wg *WaitGroup) Add(delta int) { // 1) åŸå­æ“ä½œ statep += delta // statep *uint64ï¼šã€Waiter + Counterã€‘ // semap *uint32ï¼šã€semaphoreã€‘ // *statep = (uint64(counter) \u0026lt;\u0026lt; 32) | uint32(waiter) statep, semap := wg.state() if race.Enabled { _ = *statep // trigger nil deref early if delta \u0026lt; 0 { // Synchronize decrements with Wait. race.ReleaseMerge(unsafe.Pointer(wg)) } race.Disable() defer race.Enable() } // åŸå­æ“ä½œ {counter += delta; state = counter;} delta å¯èƒ½ä¸ºè´Ÿæ•° // è¿™é‡Œçš„64ä½åŸå­æ“ä½œä¹Ÿå°±æ˜¯ä¸ºä»€ä¹ˆéœ€è¦ state å‡½æ•°çš„åŸå›  state := atomic.AddUint64(statep, uint64(delta)\u0026lt;\u0026lt;32) // counter += delta // æ³¨æ„è¿™é‡Œæ˜¯ int32 ç±»å‹ï¼ŒåŸå› æ˜¯ delta æ˜¯æ¥è‡ªç”¨æˆ·ä¼ å…¥ï¼Œå¯èƒ½æœ€åå¯¼è‡´ v \u0026lt; 0 æƒ…å†µå‘ç”Ÿ v := int32(state \u0026gt;\u0026gt; 32)\t// counter é«˜32ä½ w := uint32(state)\t// waiter ä½32ä½ if race.Enabled \u0026amp;\u0026amp; delta \u0026gt; 0 \u0026amp;\u0026amp; v == int32(delta) { // The first increment must be synchronized with Wait. // Need to model this as a read, because there can be // several concurrent wg.counter transitions from 0. race.Read(unsafe.Pointer(semap)) } // 2) counter ä¸èƒ½ä¸ºè´Ÿæ•° // counter ä¸åº”è¯¥å‡ºç°ä¸ºè´Ÿæ•°æƒ…å†µ if v \u0026lt; 0 { panic(\u0026#34;sync: negative WaitGroup counter\u0026#34;) } // 3) Add(\u0026gt;0) å’Œ Wait å‡½æ•°ä¸èƒ½å¹¶å‘è°ƒç”¨ // Add(\u0026gt;0) å’Œ Wait() å‡½æ•°å¹¶å‘è¢«è°ƒç”¨ // 1. w != 0 å­˜åœ¨ç­‰å¾…çš„waiter // 2. delta \u0026gt; 0 æœ¬æ¬¡è°ƒç”¨æ˜¯æ·»åŠ ä¸æ˜¯å‡å°‘ // 3. v == int32(delta) å½“å‰æ·»åŠ çš„æ•°é‡å°±æ˜¯æ€»æ•°é‡ï¼Œä¹‹å‰ä¸º0 if w != 0 \u0026amp;\u0026amp; delta \u0026gt; 0 \u0026amp;\u0026amp; v == int32(delta) { panic(\u0026#34;sync: WaitGroup misuse: Add called concurrently with Wait\u0026#34;) } // 4) if ( v \u0026gt; 0 || (v == 0 \u0026amp;\u0026amp; w == 0) ) return // Counterè®¡æ•°æ•°é‡å¤§äºé›¶ æˆ– æ²¡æœ‰ç­‰å¾…çš„waiterç›´æ¥è¿”å› // 1. v \u0026gt; 0ï¼šä»£è¡¨ä¸æ˜¯æœ€åä¸€ä¸ªï¼Œå› æ­¤ç›´æ¥è¿”å› // 2. v == 0 \u0026amp;\u0026amp; w == 0ï¼šä¹Ÿæ˜¯ç›´æ¥è¿”å› if v \u0026gt; 0 || w == 0 {\t// è¿™é‡Œçš„æ¡ä»¶æ¯”è¾ƒå…³é”® return } // 5) v == 0 \u0026amp;\u0026amp; w \u0026gt; 0 // è¿™ç§æƒ…å†µéœ€è¦å»æŠŠ semap ä¸Šé¢æŒ‚èµ·çš„ goroutine å…¨éƒ¨å”¤é†’ // This goroutine has set counter to 0 when waiters \u0026gt; 0. // Now there can\u0026#39;t be concurrent mutations of state: // - Adds must not happen concurrently with Wait, // - Wait does not increment waiters if it sees counter == 0. // Still do a cheap sanity check to detect WaitGroup misuse. // // å½“ waiters \u0026gt; 0 æ—¶ï¼Œæ­¤ goroutine å°† counter è®¾ç½®ä¸º 0 // ç°åœ¨ä¸èƒ½æœ‰å¹¶å‘çš„ state çªå˜ï¼š // - Add ä¸èƒ½ä¸ Wait åŒæ—¶å‘ç”Ÿ // - å¦‚æœçœ‹åˆ° counter == 0ï¼ŒWait ä¸ä¼šå¢åŠ  waiter // ä»ç„¶è¦åšä¸€ä¸ªå»‰ä»·çš„å¥å…¨æ£€æŸ¥æ¥æ£€æµ‹WaitGroupçš„æ»¥ç”¨ã€‚ // // WaitGroupè¯¯ç”¨:Addä¸Waitå¹¶å‘è°ƒç”¨ // è¿™ç§æƒ…å†µå‘ç”Ÿåœ¨ï¼šæœ€åä¸€ä¸ªgoroutineè¿è¡Œå®Œéœ€è¦å”¤é†’ç­‰å¾…çš„waiteræ­¤æ—¶Addæ–¹æ³•æœ‰è¢«è°ƒç”¨ if *statep != state { panic(\u0026#34;sync: WaitGroup misuse: Add called concurrently with Wait\u0026#34;) } // Reset waiters count to 0. *statep = 0\t// é‡ç½® Counter = 0ï¼ŒWaiter = 0 for ; w != 0; w-- { // falseæ­£å¸¸æ¨¡å¼ // å°†ç­‰å¾…åœ¨ semaphore ä¸­çš„goroutineå–å‡ºç­‰å¾…è°ƒåº¦ runtime_Semrelease(semap, false, 0) } } Done() Done å°† WaitGroup counter å‡1ã€‚ 1 2 3 4 // Done decrements the WaitGroup counter by one. func (wg *WaitGroup) Done() { wg.Add(-1) } Wait() Wait é˜»å¡ï¼Œç›´åˆ° WaitGroup counter ä¸º0ã€‚ Wait å‡½æ•°çš„è°ƒç”¨æœŸé—´ï¼Œå¯èƒ½å¤„äºå¤šä¸ªgoroutineåœ¨è°ƒç”¨ Done å‡½æ•°ã€‚ Wait() å‡½æ•°å…è®¸è¢«å¤šä¸ªçº¿ç¨‹åŒæ—¶è°ƒç”¨ã€‚Wait() å‡½æ•°ä¸€å®šè¦æ‰€æœ‰çš„Counteréƒ½æ ‡è®°å®Œæ¯•åæ‰è°ƒç”¨è¯¥æ–¹æ³•ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 // Wait blocks until the WaitGroup counter is zero. func (wg *WaitGroup) Wait() { // statep *uint64ï¼šã€Waiter + Counterã€‘ // semap *uint32ï¼šã€semaphoreã€‘ // *statep = (uint64(counter) \u0026lt;\u0026lt; 32) | uint32(waiter) statep, semap := wg.state() if race.Enabled { _ = *statep // trigger nil deref early race.Disable() } for { state := atomic.LoadUint64(statep)\t// åŸå­è¯»å– statep v := int32(state \u0026gt;\u0026gt; 32)\t// counter w := uint32(state)\t// waiter // è¿™ç§æƒ…å†µï¼Œæ¯”å¦‚åœ¨è°ƒç”¨Waitå‡½æ•°æ—¶å…ˆè°ƒç”¨sleepç¡çœ å¾ˆé•¿ä¸€æ®µæ—¶é—´ // ä¹Ÿå°±æ˜¯ Wait å‡½æ•°è¿˜æ²¡å¼€å§‹æ‰§è¡Œ å…¶ä»–goroutine å·²ç»æ‰§è¡Œå®Œäº†ï¼Œå› æ­¤ç›´æ¥è¿”å›å³å¯ if v == 0 {\t// Counter is 0, no need to wait. // // è®¡æ•°å™¨ä¸º 0ï¼Œæ— éœ€ç­‰å¾… if race.Enabled { race.Enable() race.Acquire(unsafe.Pointer(wg)) } return } // Increment waiters count. // // å¢åŠ waiteræ•°é‡ï¼Œæ­£å¸¸é€»è¾‘ä¸‹åœ¨è¿™é‡Œç­‰å¾…çš„åªæœ‰main goroutineä¸€ä¸ª // è¿™é‡Œå¯èƒ½ä¼šå¤±è´¥ï¼Œå¯èƒ½æœ‰å¾ˆå¤šgoroutineæ­£åœ¨è°ƒç”¨Addæˆ–Doneæ–¹æ³•ä¿®æ”¹Counterå¯¼è‡´è¿™é‡ŒåŸå­æ“ä½œå¤±è´¥ if atomic.CompareAndSwapUint64(statep, state, state+1) { if race.Enabled \u0026amp;\u0026amp; w == 0 { // Wait must be synchronized with the first Add. // Need to model this is as a write to race with the read in Add. // As a consequence, can do the write only for the first waiter, // otherwise concurrent Waits will race with each other. race.Write(unsafe.Pointer(semap)) } // è¯¥æ–¹æ³•æœ€åä¼šè°ƒç”¨semacquire1ï¼Œæˆ‘ä»¬åœ¨sync.Mutexä¸­å·²ç»è®¨è®ºè¿‡ // è¿™é‡Œä¼šæŠŠå½“å‰goroutineå…¥é˜Ÿï¼Œæ³¨æ„è¿™é‡Œå…¥é˜Ÿçš„æ˜¯main goroutine // runtime_Semacquire å°†å½“å‰ goroutine åŠ å…¥åˆ° semaphore çš„å°¾éƒ¨ runtime_Semacquire(semap)\t// ä¸»çº¿ç¨‹åœ¨è¿™é‡Œè¢«è°ƒç¦»å·¥ä½œçº¿ç¨‹ï¼Œä¸‹æ¬¡æ¢å¤æ—¶ä»è¿™é‡Œæ¥åˆ°æ‰§è¡Œ // å½“å‰goroutineè¢«Doneå‡½æ•°å”¤é†’æ—¶ï¼Œä¸€å®šæ˜¯ *statep == 0ï¼Œä¸ç„¶æµç¨‹æœ‰é—®é¢˜ if *statep != 0 { panic(\u0026#34;sync: WaitGroup is reused before previous Wait has returned\u0026#34;) } if race.Enabled { race.Enable() race.Acquire(unsafe.Pointer(wg)) } return\t// ç›´æ¥è¿”å›åˆ°è°ƒç”¨Waitæ–¹æ³•ä½ç½®å¤„ } } } ä½¿ç”¨ç¤ºä¾‹ WaitGroupï¼šç”¨äºçº¿ç¨‹æ€»åŒæ­¥ï¼Œå®ƒç­‰å¾…ä¸€ç»„çº¿ç¨‹é›†åˆå®Œæˆï¼Œæ‰ä¼šç»§ç»­å‘ä¸‹æ‰§è¡Œã€‚ ä¸»çº¿ç¨‹è°ƒç”¨ Add() æ–¹æ³•æ¥è®¾ç½®ç­‰å¾…çš„åç¨‹æ•°é‡ï¼š ç„¶åæ¯ä¸ªåç¨‹è¿è¡Œï¼Œå¹¶åœ¨å®Œæˆåè°ƒç”¨ Done() æ–¹æ³•ï¼ŒAdd(-1) å’Œ Done() æ•ˆæœä¸€è‡´ï¼Œéƒ½è¡¨ç¤ºç­‰åˆ°çš„åç¨‹æ•°é‡å‡å°‘ä¸€ä¸ªã€‚ åŒæ—¶ï¼ŒWait() æ–¹æ³•ç”¨æ¥é˜»å¡ä¸»çº¿ç¨‹ï¼Œç›´åˆ°æ‰€æœ‰åç¨‹å®Œæˆæ‰ä¼šå‘ä¸‹æ‰§è¡Œã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;sync\u0026#34; ) func main() { var wg sync.WaitGroup wg.Add(10)\t// (\u0026amp;wg).Add(10) -\u0026gt; (*WaitGroup).Add(\u0026amp;wg, 10) for i := 0; i \u0026lt; 10; i++ { //wg.Add(1)\t// (\u0026amp;wg).Add(1)\t-\u0026gt; (*WaitGroup).Add(\u0026amp;wg, 1) go func(i int) { defer wg.Done()\t// (\u0026amp;wg).Done() -\u0026gt; (*WaitGroup).Done(\u0026amp;wg) fmt.Println(i) }(i) } fmt.Println(\u0026#34;æˆ‘åœ¨å¾ªç¯å¤–\u0026#34;) // é˜»å¡ä¸»çº¿ç¨‹ï¼Œç­‰æ‰€æœ‰åç¨‹å®Œæˆ wg.Wait()\t// (\u0026amp;wg).Wait() -\u0026gt; (*WaitGroup).Wait(\u0026amp;wg) // Output: // 1 // 9 // 3 // 4 // æˆ‘åœ¨å¾ªç¯å¤– // 5 // 6 // 7 // 8 // 2 // 0 } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;net/http\u0026#34; \u0026#34;sync\u0026#34; ) func main() { var wg sync.WaitGroup var urls []string = []string{ \u0026#34;http://baidu.com/\u0026#34;, \u0026#34;https://wzapi.myzx.cn/\u0026#34;, } wg.Add(len(urls)) for _, url := range urls { // wg.Add(1) go func(url string) { defer wg.Done() response, err := http.Get(url) fmt.Println(response, err, url) }(url) } wg.Wait() fmt.Println(\u0026#34;over\u0026#34;) // Output: // \u0026amp;{200 OK 200 HTTP/1.1 1 1 map[Accept-Ranges:[bytes] Cache-Control:[max-age=86400] Connection:[Keep-Alive] Content-Length:[81] Content-Type:[text/html] Date:[Thu, 22 Apr 2021 03:19:50 GMT] Etag:[\u0026#34;51-47cf7e6ee8400\u0026#34;] Expires:[Fri, 23 A // pr 2021 03:19:50 GMT] Last-Modified:[Tue, 12 Jan 2010 13:48:00 GMT] Server:[Apache]] 0xc00003a140 81 [] false false map[] 0xc000044000 \u0026lt;nil\u0026gt;} \u0026lt;nil\u0026gt; http://baidu.com/ // \u0026amp;{200 OK 200 HTTP/1.1 1 1 map[Access-Control-Allow-Headers:[Origin, X-Requested-With, Content-Type, Acceptfecshop-uuid, fecshop-lang, fecshop-currency, access-token, x-token, authorization] Access-Control-Allow-Methods:[*] Access-Co // ntrol-Allow-Origin:[*] Cache-Control:[no-cache, private] Connection:[keep-alive] Content-Type:[text/html; charset=UTF-8] Date:[Thu, 22 Apr 2021 03:19:50 GMT] Etag:[W/\u0026#34;be34c7da7adc79dfee6c76195ba1dbdad7b5bc9b\u0026#34;] Server:[MYBWS/1.1] Set // -Cookie:[acw_tc=2760829816190615907855703e97def055d99950b742716bbf6b2d8e6e2288;path=/;HttpOnly;Max-Age=1800 XSRF-TOKEN=eyJpdiI6IjFPZm9TcTYzblc5c0JJMFdSSW5EZ0E9PSIsInZhbHVlIjoiTXhEbHNlbVRXelMwTnR4UE5nY1JsNTRDTEJ4SmUzaFFsQkZTak9nTEtib // m5rczF3VlF6bVE1YitjNU5EbzlXMms4bTZLV0RiRTk4WXZMSFBBMFoxQ0V0OUpuYWxwN1ppYmpydjFFUzRQWXVBbktaNW82dFNVXC9BXC9FOG9Qb094VSIsIm1hYyI6IjNmYTMyZDUyYzk0ZWY0ZjJkNzJjOGY3M2FiYWYzZDYwNTA4YjFmZTBiZTljMzI1ZTI1MzY1MGQyZDAxYjQwN2QifQ%3D%3D; expires // =Thu, 22-Apr-2021 05:19:50 GMT; Max-Age=7200; path=/ laravel_session=eyJpdiI6IlA2cXcxRHVWYVgxa3VZRnNFY09LbkE9PSIsInZhbHVlIjoiK1ptMGIwOTdZbGp5dlwvRlNMK2pWb3hLVVErV0wxOFBQSmp1dVRkWExcL1VZbm1zVFwvUmRGT0dZcXJlcTZSRmhoWk1hdkJxYU9kUUFrNjB // RK3o4cW5TanZVZXZSYjVEN29CNUU2bEVHdHVoUVVESkhJcG1ETDVCS3FSTmtwYkJTcDciLCJtYWMiOiIwMTM3NDg2NTJlNDJkMGFhN2Y0NDA2YzJhYzcyMTQ4MzY1NDU1YzlmMjYwOTUxNjM0ZDJkYjUzYWJmMmMxZTE1In0%3D; expires=Thu, 22-Apr-2021 05:19:50 GMT; Max-Age=7200; path=/ // ; httponly]] 0xc0001220a0 -1 [chunked] false true map[] 0xc00010a000 0xc00004e0b0} \u0026lt;nil\u0026gt; https://wzapi.myzx.cn/ // over } æ€»ç»“ sync.WaitGroup æ›´å¤šæ˜¯ å¤šä¸ªgoroutineé€šçŸ¥ä¸€ä¸ªgoroutine,æ›´åƒæ˜¯main goroutineç­‰å¾…é›†åˆçš„æ‰€æœ‰goroutineå®Œæˆä¸€é¡¹ä»»åŠ¡ï¼Œå¤šå¯¹ä¸€ sync.Cond åˆ™æ›´åƒå¤šä¸ªgoroutineç­‰å¾…main goroutineçš„å·¥ä½œå®Œæˆï¼Œä¸€å¯¹å¤šï¼Œæ›´åƒæ˜¯å¹¿æ’­å½¢å¼ ä½¿ç”¨æ³¨æ„ ä»¥ä¸‹ä½¿ç”¨æ–¹å¼æ˜¯ä¸æ­£ç¡®çš„ã€‚ package main import ( \u0026#34;fmt\u0026#34; \u0026#34;sync\u0026#34; ) func main() { var wg sync.WaitGroup // ã€ä¸èƒ½å¦å¤–å¯åŠ¨åç¨‹å»æ‰§è¡ŒAdd()å’ŒDone()ï¼Œå› ä¸ºmainçš„Wait()ä¸ä¼šé˜»å¡ç­‰å¾…ã€‘ go func() { for i := 0; i \u0026lt; 10; i++ { wg.Add(1)\t// (\u0026amp;wg).Add(1)\t-\u0026gt; (*WaitGroup).Add(\u0026amp;wg, 1) go func(i int) { defer wg.Done()\t// (\u0026amp;wg).Done() -\u0026gt; (*WaitGroup).Done(\u0026amp;wg) fmt.Println(i) }(i) } }() // è¿™é‡Œå¹¶ä¸ä¼šé˜»å¡ç­‰å¾…ï¼Œå› ä¸ºè®¡æ•°å™¨ä¸º0 wg.Wait() // Output: } ","permalink":"https://heliu.site/posts/golang/sync/waitgroup/","summary":"WaitGroupç­‰å¾…ä¸€ç»„goroutineå®Œæˆã€‚","title":"sync.WaitGroup"},{"content":"åŸºæœ¬æ•°æ®ç±»å‹ å¸ƒå°”ç±»å‹ å¸ƒå°”å‹å€¼åªèƒ½æ˜¯å¸¸é‡trueæˆ–falseã€‚ 1 2 3 4 5 // true å’Œ false æ˜¯ä¸¤ä¸ªæ— ç±»å‹çš„å¸ƒå°”å€¼ const ( true = 0 == 0 // æ— ç±»å‹å¸ƒå°”å€¼ false = 0 != 0 // æ— ç±»å‹å¸ƒå°”å€¼ï¼ˆé»˜è®¤å€¼falseï¼‰ ) Goè¯­è¨€ä¸­ä¸å…è®¸å°†æ•´å‹å¼ºåˆ¶è½¬å¸ƒå°”å‹ï¼Œä¹Ÿä¸å…è®¸å°†å¸ƒå°”å‹å¼ºåˆ¶è½¬æ•´å‹ã€‚ å¦‚ï¼šb := (int)(false)ï¼Œa := (bool)(1)è¿™éƒ½æ˜¯é”™è¯¯çš„ã€‚ å¸ƒå°”å‹æ— æ³•å‚ä¸æ•°å€¼è¿ç®—ï¼Œä¹Ÿæ— æ³•ä¸å…¶ä»–ç±»å‹è¿›è¡Œè½¬æ¢ï¼Œå¸ƒå°”ç±»å‹ä»…ç”¨åœ¨æ¡ä»¶åˆ¤æ–­ä¸­ã€‚ é€šè¿‡æŒ‡é’ˆè¿ç®—(unsafe)å¯ä»¥å®ç°0æˆ–1è½¬å¸ƒå°”ç±»å‹ã€‚ boolean å†…å­˜å¸ƒå±€ å¸ƒå°”ç±»å‹å ä¸€å­—èŠ‚ï¼Œä¹Ÿå°±æ˜¯8bitï¼Œå…¶åœ¨å†…å­˜ä¸­å­˜å‚¨çš„å€¼æ˜¯0æˆ–é0ã€‚8bitå…¨æ˜¯0è¡¨ç¤ºfalseï¼Œå…¶ä»–æƒ…å†µè¡¨ç¤ºtrueã€‚ å‡è®¾å®šä¹‰å˜é‡bï¼Œvar b boolï¼Œé»˜è®¤å€¼ä¸ºfalseå…¶å†…å­˜å­˜å‚¨ä¸º0ï¼› ç»™å˜é‡bèµ‹å€¼trueï¼Œb = trueï¼Œå…¶å†…å­˜è®¾ç½®ä¸º1ã€‚ ç»™å˜é‡bèµ‹å€¼falseï¼Œb = falseï¼Œå…¶å†…å­˜è®¾ç½®ä¸º0ã€‚ å¸ƒå°”ç±»å‹ä½œä¸ºæ¡ä»¶åˆ¤æ–­æ—¶ï¼Œå…¶å†…å­˜å€¼ä¸º0ï¼Œåˆ™åˆ¤æ–­ä¸ºtrueï¼›é0åˆ™åˆ¤æ–­ä¸ºfalseã€‚ æ›´å¤šå…³äºå¸ƒå°”ç±»å‹çš„å…ƒç»“æ„ç±»å‹ï¼Œå‚çœ‹_typeç»“æ„ï¼Œè®°å½•ç€å¸ƒå°”å‹çš„ç›¸å…³å‚æ•°ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 // å…³äºå®šä¹‰å¸ƒå°”ç±»å‹ç¤ºä¾‹ var b bool = false // å®šä¹‰å¸ƒå°”ç±»å‹å˜é‡bå¹¶è®¾ç½®å…¶å€¼ä¸ºfalse var a bool // å®šä¹‰å¸ƒå°”ç±»å‹å˜é‡aå¹¶è®¾ç½®å…¶å€¼ä¸ºfalse // --------------------------------------------------------------- // 1) å¸ƒå°”å€¼æ˜¯ä»¥æ€æ ·çš„å½¢å¼ä¿å­˜åœ¨å†…å­˜ä¸­çš„ // ------------------------------------------------------- // falseï¼šåœ¨å†…å­˜ä¸­å­˜å‚¨çš„æ˜¯0b0000_0000ä¹Ÿå°±æ˜¯æ•´å‹0 // trueï¼š åœ¨å†…å­˜ä¸­å­˜å‚¨çš„æ˜¯0b0000_0001ä¹Ÿå°±æ˜¯æ•´å‹1 // ------------------------------------------------------- // ç¤ºä¾‹ä¸­æ˜¯ boolè½¬int8ç±»å‹ï¼Œå½“ç„¶ä¹Ÿèƒ½è½¬å…¶ä»–ç±»å‹ // ------------------------------------------------------- var b0 bool = false // å‡è®¾b0åœ°å€ 0xc000014090 var b1 bool = true // *bool -\u0026gt; *int8 // i1 å­˜å‚¨çš„æ˜¯b0çš„åœ°å€0xc000014090 ç±»å‹ä¸º*int8 // æ³¨æ„åŒºåˆ«ï¼š*(*int8)(unsafe.Pointer(\u0026amp;b0)) å­˜å‚¨çš„æ˜¯b0çš„å€¼ ç±»å‹ä¸ºint8 // æ³¨æ„åŒºåˆ«ï¼š(**int8)(unsafe.Pointer(\u0026amp;b0)) *bool -\u0026gt; **int8 i1 := (*int8)(unsafe.Pointer(\u0026amp;b0)) i2 := (*int8)(unsafe.Pointer(\u0026amp;b1)) fmt.Println(*i1, *i2) // 0 1 // --------------------------------------------------------------- // 2) æ•´æ•°ç±»å‹è½¬æ¢æˆå¸ƒå°”å€¼æ˜¯æ€æ ·ä¸ªæƒ…å†µ // ------------------------------------------------------- // 0b0000_0000 è½¬å¸ƒå°”æ˜¯ falseï¼Œå…¶ä»–å…¨æ˜¯ true // 0ï¼šè½¬å¸ƒå°”æ˜¯ false // 32768ï¼š(2^15)è½¬å¸ƒå°”æ˜¯ false // 1ï¼šè½¬å¸ƒå°”æ˜¯ true // 2ï¼šè½¬å¸ƒå°”æ˜¯ true // -1ï¼šè½¬å¸ƒå°”æ˜¯ true æ³¨æ„è½¬æ¢æ—¶å¸ƒå°”å€¼åªéœ€è¦1å­—èŠ‚é•¿åº¦8bit // ------------------------------------------------------- var b0 int8 = 0 var b1 int8 = 1 i1 := (*bool)(unsafe.Pointer(\u0026amp;b0)) i2 := (*bool)(unsafe.Pointer(\u0026amp;b1)) fmt.Println(*i1, *i2) // false true // -------------------------------------------------------- // 3) ä¸‹é¢æˆ‘ä»¬æŠŠå…¶ä»–ç±»å‹è½¬æ¢æˆå¸ƒå°”å€¼ç„¶åå†è½¬å›ä¹‹å‰çš„ç±»å‹ // -------------------------------------------------------- // ä»¥ä¸‹ä»£ç è¯´æ˜ä½¿ç”¨unsafeè½¬æ¢ä»…ä»…æ˜¯æŠŠç¬¬ä¸€ä¸ªå­—èŠ‚æŒ‡å‘boolåœ°å€ // -------------------------------------------------------- // 3.1) int8 -\u0026gt; bool -\u0026gt; int8 var b0 int8 = 0 var b1 int8 = -125 // 1000 0011 i1 := (*bool)(unsafe.Pointer(\u0026amp;b0)) i2 := (*bool)(unsafe.Pointer(\u0026amp;b1)) fmt.Println(*i1, *i2) // false true i11 := (*int8)(unsafe.Pointer(i1)) i22 := (*int8)(unsafe.Pointer(i2)) fmt.Println(*i11, *i22) // 0 -125 // 3.2) int -\u0026gt; bool -\u0026gt; int var b0 int = 0 var b1 int = 55536 i1 := (*bool)(unsafe.Pointer(\u0026amp;b0)) i2 := (*bool)(unsafe.Pointer(\u0026amp;b1)) fmt.Println(*i1, *i2) // false true i11 := (*int)(unsafe.Pointer(i1)) i22 := (*int)(unsafe.Pointer(i2)) fmt.Println(*i11, *i22) // 0 55536 // 3.3) uint16 -\u0026gt; bool ä¿®æ”¹ -\u0026gt; uint16 var b0 uint16 = 0 var b1 uint16 = 0b10000000_11111111 i1 := (*bool)(unsafe.Pointer(\u0026amp;b0)) i2 := (*bool)(unsafe.Pointer(\u0026amp;b1)) fmt.Println(*i1, *i2) // false true *i2 = false i11 := (*uint16)(unsafe.Pointer(i1)) i22 := (*uint16)(unsafe.Pointer(i2)) // 32768 -\u0026gt; 0b10000000_00000000 fmt.Println(*i11, *i22) // 0 32768 // 4) ä¸Šé¢å‘ç°å°†å¸ƒå°”ç±»å‹èµ‹å€¼ä¸ºfalseä¼šå°†å†…å­˜çš„8ä¸ºbitå…¨éƒ¨è®¾ç½®ä¸º0ï¼Œä¹Ÿå°±æ˜¯85è¡Œä»£ç å¤„ // é‚£ä¹ˆå°†ä¸€ä¸ªæœ¬å°±æ˜¯å¸ƒå°”trueç±»å‹èµ‹å€¼ä¸ºtrueï¼Œå†…å­˜ä¸­æ˜¯å¦è®°å½•çš„å¤§å°ä¸º1ï¼Ÿ var b1 int = 12 bb := (*bool)(unsafe.Pointer(\u0026amp;b1)) *bb = true fmt.Println(*(*int)(unsafe.Pointer(bb))) // 1 // é€šè¿‡ä»£ç æµ‹è¯• å¸ƒå°”çš„èµ‹å€¼å°±æ˜¯æŠŠå†…å­˜ä¸­çš„æ•°å€¼falseæ”¹ä¸º0 trueæ”¹ä¸º1 æ€»ç»“ï¼š Goå†…å­˜å­—æ®µæ’åºæ˜¯ï¼Œä½å­—èŠ‚åœ¨å‰é«˜å­—èŠ‚åœ¨åã€‚ï¼ˆä¸åŒçš„ç¡¬ä»¶è®¾å¤‡å¯èƒ½ä¸åŒï¼‰ã€‚ æ¯”å¦‚33007äºŒè¿›åˆ¶å¦‚10000000_11101111ï¼Œåœ¨å†…å­˜ä¸­æ˜¯ç¬¬ä¸€ä¸ªå­—èŠ‚11101111ç¬¬äºŒä¸ªå­—èŠ‚10000000ã€‚ å¸ƒå°”ç±»å‹å 1å­—èŠ‚ï¼ˆ8bitï¼‰ï¼Œæ‰€æœ‰ä½éƒ½ä¸º0æ—¶è¡¨ç¤ºfalseï¼Œå¦åˆ™è¡¨ç¤ºtrueã€‚ å› æ­¤10000000_00000000è¿™ç§å½¢å¼è½¬boolç¬¬ä¸€ä¸ªå­—èŠ‚æ˜¯00000000è¿”å›falseã€‚ ä½¿ç”¨unsafeè½¬æ¢ç±»å‹ä»…ä»…æ˜¯æŠŠé¦–å­—èŠ‚è½¬boolçš„åœ°å€ã€‚ ä¹Ÿå°±æ˜¯ä¸Šé¢çš„33007ï¼ˆ10000000_11101111ï¼‰è½¬boolï¼ŒæŠŠ11101111è¿™ä¸ªç¬¬ä¸€ä¸ªå­—èŠ‚åœ°å€ç»™å¸ƒå°”å€¼ã€‚ å¸ƒå°”ç±»å‹åœ¨è¢«èµ‹å€¼æ—¶ï¼Œtrueä¼šä¿®æ”¹å†…å­˜å­˜å‚¨å€¼ä¸º1ï¼Œfalseä¼šä¿®æ”¹å­˜å‚¨å€¼ä¸º0ã€‚ æ•´æ•°ç±»å‹ æœ‰ç¬¦å·æ•´å‹ ç±»å‹ é•¿åº¦(B/å­—èŠ‚) èŒƒå›´(ç§‘å­¦è®¡æ•°) èŒƒå›´ é»˜è®¤å€¼ int8 1B (8bit) [-2^7, 2^7-1] [-128, 127] 0 int16 2B (16bit) [-2^15, 2^15-1] [-32768, 32767] 0 int32 4B (32bit) [-2^31, 2^31-1] [-2147483648, 2147483647] 0 int64 8B (64bit) [-2^63, 2^63-1] [-9223372036854775808, 9223372036854775807] 0 int ä¸ç³»ç»Ÿæœ‰å…³ï¼Œ32ä½ä¸‹4å­—èŠ‚ï¼Œ64ä½ä¸‹8å­—èŠ‚ 0 è¡¥ç ä¸æºç  æœ‰ç¬¦å·è´Ÿæ•°ç±»å‹è½¬äºŒè¿›åˆ¶ï¼Œè´Ÿæ•°æ•´å‹æ•°å€¼éƒ½æ˜¯é‡‡ç”¨è¡¥ç å½¢å¼ä¿å­˜ï¼Œå½“ç„¶æ­£æ•°çš„è¡¥ç å°±æ˜¯è‡ªå·±ã€‚ å…ˆæ˜¯å°†å¯¹åº”çš„æ­£æ•´æ•°è½¬æ¢æˆäºŒè¿›åˆ¶åã€‚ å¯¹äºŒè¿›åˆ¶å–åã€‚ ç„¶åå¯¹ç»“æœå†åŠ ä¸€ã€‚ è¡¥ç çš„è¿ç®—ï¼šä¸¤ä¸ªè¡¥ç ç›¸åŠ ï¼Œä¸äºŒè¿›åˆ¶åŠ æ³•ç›¸åŒï¼Œå’Œä»ç„¶æ˜¯è¡¥ç ï¼ˆè¡¥ç è®¡ç®—åå¯èƒ½å­˜åœ¨æº¢å‡ºæƒ…å†µï¼‰ è¡¥ç è½¬æºç ã€‚ æ­£æ•°ï¼šç¬¦å·ä½ä¸º0æ—¶ï¼Œå³è¡¥ç å°±æ˜¯æºç  è´Ÿæ•°ï¼šç¬¦å·ä½ä¸º1æ—¶ï¼Œå³è¡¥ç çš„è¡¥ç å°±æ˜¯æºç  # -42å­˜å‚¨å½¢å¼ï¼šå‡è®¾è¿™é‡Œæ˜¯int8ç±»å‹ 8ä½bitä½ # 1. 42è½¬äºŒè¿›åˆ¶ï¼Œ00101010 # 2. 00101010 å–å 11010101 # 3. 11010101åŠ ä¸€ï¼Œ11010101 + 00000001 = 11010110\tè¡¥ç  # æœ€ç»ˆ-42çš„äºŒè¿›åˆ¶è¡¨ç¤ºå½¢å¼ï¼Œ11010110 # 11010110 è¡¥ç è½¬æºç  # 1. æœ€é«˜ä½ä¸º1è¡¨ç¤ºè´Ÿæ•° # 2. 11010110 å–å 00101001 # 3. 00101001åŠ ä¸€ï¼Œ00101001 + 00000001 = 00101010\tæºç  # æ€»ç»“ï¼š- å·çš„æ“ä½œé€»è¾‘å°±æ˜¯ä¸Šé¢æ­¥éª¤2(å–å)å’Œæ­¥éª¤3(åŠ ä¸€) # æœ€é«˜ä½è¡¨ç¤ºç¬¦å·ä½ 0.æ­£æ•° 1.è´Ÿæ•° # å†…å­˜ä¸­éƒ½æ˜¯é‡‡ç”¨è¡¥ç å½¢å¼å­˜å‚¨çš„ 1 2 3 4 5 6 7 // éªŒè¯ -42 æ˜¯å¦æ˜¯ 11010110 var b0 int8 = -42 // i1 := uint8(b0) i1 := (*uint8)(unsafe.Pointer(\u0026amp;b0)) fmt.Printf(\u0026#34;%.8b\u0026#34;, *i1)\t// 11010110 ä¾‹å¦‚ï¼š-1æ˜¯11111111ï¼Œ127æ˜¯01111111ï¼Œæœ€é«˜ä½bitè¡¨ç¤ºç¬¦å·ä½ï¼Œ0è¡¨ç¤ºæ­£æ•°(+)ï¼Œ1è¡¨ç¤ºè´Ÿæ•°(-)ã€‚ # -1 è½¬äºŒè¿›åˆ¶ # 1 -\u0026gt; 00000001 # ~1 -\u0026gt; 11111110 å–å # +1\t-\u0026gt; 11111111 åŠ ä¸€ # 127 è½¬äºŒè¿›åˆ¶ # 127\t-\u0026gt; 01111111 -å·ï¼šæ“ä½œåœ¨æ•´å‹ä¸­çš„æ“ä½œæ­¥éª¤(å–å)ç„¶å(åŠ ä¸€)ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 // åœ¨time.Durationä¸­çš„String()æ–¹æ³•ä¸­æœ‰è¿™æ ·ä¸€æ®µä»£ç  // d ä¸ºint64ç±»å‹ï¼Œè¿™é‡Œæ­£æ˜¯åˆ©ç”¨äº†-(-42)=42, u=(-42) func (d Duration) String() string { // ... u := uint64(d) // è¿™é‡Œå¦‚æœæ˜¯è´Ÿæ•°ï¼Œåˆ™è½¬æ¢åä¸€å®šæ˜¯ä¸ªå¾ˆå¤§çš„æ•°å­— neg := d \u0026lt; 0 // negä¸ºtrueè¡¨ç¤ºæ˜¯è´Ÿæ•°ï¼Œä¸ºfalseè¡¨ç¤ºæ˜¯æ­£æ•°æˆ–0 if neg { u = -u // è¿™é‡Œå†æ¬¡æŒ‰ç…§è´Ÿæ•°å­˜å‚¨å½¢å¼ï¼Œæ­£æ•°çš„äºŒè¿›åˆ¶å–ååŠ 1ç­‰åˆ°æ­£æ•°ä¹Ÿå°±æ˜¯(-d) } // ... } // æ¯”å¦‚æˆ‘ä»¬ä½¿ç”¨ä¸Šé¢æ–¹æ³•å†™ä¸€ä¸ªabså–ç»å¯¹å€¼å‡½æ•°ï¼Œå¹¶è½¬æ¢æ— ç¬¦å·ç±»å‹ä¸ºæœ‰ç¬¦å·ç±»å‹ type i int64 func (i i) abs() uint64 { if i \u0026gt; 0 { return uint64(i) } return -uint64(i) } æ— ç¬¦å·æ•´å‹(unsigned) ç±»å‹ é•¿åº¦(B/å­—èŠ‚) èŒƒå›´ èŒƒå›´ é»˜è®¤å€¼ uint8 1B (8bit) [0, 2^8-1] [0, 255] 0 uint16 2B (16bit) [0, 2^16-1] [0, 65535] 0 uint32 4B (32bit) [0, 2^32-1] [0, 4294967295] 0 uint64 8B (64bit) [0, 2^64-1] [0, 18446744073709551615] 0 uint ä¸ç³»ç»Ÿæœ‰å…³ï¼Œ32ä½ä¸‹4å­—èŠ‚ï¼Œ64ä½ä¸‹8å­—èŠ‚ 0 æ— ç¬¦å·è½¬äºŒè¿›åˆ¶ é™¤äºŒå–ä½™ï¼Œç„¶åå€’åºæ’åˆ—ï¼Œé«˜ä½è¡¥é›¶ # ç¤ºä¾‹42è½¬äºŒè¿›åˆ¶ï¼Œæ­£æ•´æ•°è½¬äºŒè¿›åˆ¶ é™¤äºŒ æ±‚ä½™ æ’åºæ–¹å‘ åè¿›åˆ¶ 42 || 2 | 42 .... 42/2 ä½™ .... 0 ^ 0*2^0 = 0 |_______ + 2 | 21 .... 21/2 ä½™ .... 1 | 1*2^1 = 2 |_______ + 2 | 10 .... 10/2 ä½™ .... 0 | 0*2^2 = 0 |_______ + 2 | 5 .... 5/2 ä½™ .... 1 | 1*2^3 = 8 |________ + 2 | 2 .... 2/2 ä½™ .... 0 | 0*2^4 = 0 |________ + 1 .... 1/2 ä½™ .... 1 | 1*2^5 = 32 # 42 å¯¹åº”äºŒè¿›åˆ¶ä½ 00101010 -\u0026gt; 0*2^0 + 1*2^1 + 0*2^2 + 1*2^3 + 0*2^4 + 1*2^5 = 42 å…¶ä»–æ•´æ•°ç±»å‹ ç±»å‹ ç­‰ä»·äº é•¿åº¦(B/å­—èŠ‚) å¤‡æ³¨ é»˜è®¤å€¼ byte type byte = uint8 1B å­˜å‚¨ä¸€å­—èŠ‚å†…å®¹ 0 rune type rune = int32 4B å­˜å‚¨ä¸€å­—ç¬¦å†…å®¹(Unciodeç¼–ç ) 0 uintptr uint 4Bæˆ–8B åˆšå¥½èƒ½å­˜å‚¨å˜é‡åœ°å€ 0 1 2 3 4 5 6 7 // type byte = uint8 var b byte // é»˜è®¤å€¼ 0 // type rune = int32 var r rune // é»˜è®¤å€¼ 0 fmt.Printf(\u0026#34;b: %T\\n\u0026#34;, b)\t// b: uint8 fmt.Printf(\u0026#34;r: %T\\n\u0026#34;, r)\t// r: int32 æµ®ç‚¹æ•°ç±»å‹ ç±»å‹ æè¿° é»˜è®¤å€¼ float32 IEEE-754 32ä½æµ®ç‚¹å‹æ•°4å­—èŠ‚ï¼Œå¤§çº¦å­˜å‚¨å°æ•°ä½æ•°7ä½ï¼ˆåè¿›åˆ¶ç§‘å­¦è®¡æ•°æ³•n.xxx*e+10æƒ…å†µä¸‹ï¼‰ï¼Œè¿™é‡Œçš„7ä½æ˜¯xçš„ä½æ•° 0.0 float64 IEEE-754 64ä½æµ®ç‚¹å‹æ•°8å­—èŠ‚ï¼Œå¤§çº¦å­˜å‚¨å°æ•°ä½æ•°16ä½ï¼ˆåè¿›åˆ¶ç§‘å­¦è®¡æ•°æ³•n.xxx*e+10æƒ…å†µä¸‹ï¼‰ï¼Œè¿™é‡Œçš„16ä½æ˜¯xçš„ä½æ•° 0.0 IEEE-754 æµ®ç‚¹æ•°åœ¨å†…å­˜ä¸­å¦‚ä½•å­˜å‚¨ æµ®ç‚¹æ•°éœ€è¦å…ˆè½¬æ¢æˆäºŒè¿›åˆ¶æ‰èƒ½å­˜å‚¨åœ¨å†…å­˜ä¸­ï¼Œå› æ­¤æ‹†åˆ†æˆæ­£æ•°å’Œå°æ•°ï¼š å¯¹äºæ­£æ•°éƒ¨åˆ†ï¼š æŒ‰ç…§æœ‰ç¬¦å·è§„åˆ™è®¡ç®—å³å¯ï¼Œæ¯”å¦‚42æˆ–-42æ˜¯00101010ï¼Œç¬¦å·ä½åé¢å•ç‹¬å¤„ç†ã€‚ å¯¹äºå°æ•°éƒ¨åˆ†ï¼š å¯¹å°æ•°ç‚¹ä»¥åçš„æ•°ä¹˜ä»¥2ï¼Œå–ç»“æœçš„æ•´æ•°éƒ¨åˆ†(ä¸æ˜¯1å°±æ˜¯0)ï¼Œç„¶åå†ç”¨å°æ•°éƒ¨åˆ†å†ä¹˜ä»¥2ï¼Œå†å–ç»“æœçš„æ•´æ•°éƒ¨åˆ†ã€‚ ä»¥æ­¤ç±»æ¨ï¼Œç›´åˆ°å°æ•°éƒ¨åˆ†ä¸º0æˆ–è€…ä½æ•°å·²ç»å¤Ÿäº†å°±ç»“æŸã€‚ ç„¶åæŠŠå–çš„æ•´æ•°éƒ¨åˆ†æŒ‰å…ˆåæ¬¡åºæ’åˆ—ï¼Œå°±æ„æˆäº†äºŒè¿›åˆ¶å°æ•°éƒ¨åˆ†çš„åºåˆ—ã€‚ # å¦‚42.635648ï¼Œå¤„ç†å°æ•°éƒ¨åˆ†å°±æ˜¯0.635648 å°æ•°éƒ¨ä½ä¹˜2 = å–æ­£æ•°ä½ æ’åºæ–¹å‘ åè¿›åˆ¶ 0.6328125 || 0.635648 * 2 = 1.271296 ... å–æ­£æ•°ä½ ... 1 | 2^-1 1/2 0.5 0.271296 * 2 = 0.542592 ... å–æ­£æ•°ä½ ... 0 | 0 + 0.542592 * 2 = 1.085184 ... å–æ­£æ•°ä½ ... 1 | 2^-3 1/2^3 0.125 0.085184 * 2 = 0.170368 ... å–æ­£æ•°ä½ ... 0 | 0 0.170368 * 2 = 0.340736 ... å–æ­£æ•°ä½ ... 0 | 0 + 0.340736 * 2 = 0.681472 ... å–æ­£æ•°ä½ ... 0 | 0 0.681472 * 2 = 1.362944 ... å–æ­£æ•°ä½ ... 1 v 2^-7 1/2^7 0.0078125 ... ... # ç»„æˆäºŒè¿›åˆ¶ 1010001... -\u0026gt; 2^5 + 2^3 + 2^1 + 2^-1 + 2^-3 + 2^-7 # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - # å¦‚-0.1ï¼Œå¤„ç†å°æ•°éƒ¨åˆ†å°±æ˜¯0.1 å°æ•°éƒ¨ä½ä¹˜2 = å–æ­£æ•°ä½ æ’åºæ–¹å‘ åè¿›åˆ¶ 0.099609375 || 0.1 * 2 = 0.2 ... å–æ­£æ•°ä½ ... 0 | 0 0.2 * 2 = 0.4 ... å–æ­£æ•°ä½ ... 0 | 0 0.4 * 2 = 0.8 ... å–æ­£æ•°ä½ ... 0 | 0 0.8 * 2 = 1.6 ... å–æ­£æ•°ä½ ... 1 | 1/2^4 0.0625 0.6 * 2 = 1.2 ... å–æ­£æ•°ä½ ... 1 | 1/2^5 0.03125 0.2 * 2 = 0.4 ... å–æ­£æ•°ä½ ... 0 | 0 + 0.4 * 2 = 0.8 ... å–æ­£æ•°ä½ ... 0 | 0 0.8 * 2 = 1.6 ... å–æ­£æ•°ä½ ... 1 | 1/2^8 0.00390625 0.6 * 2 = 1.2 ... å–æ­£æ•°ä½ ... 1 | 1/2^9 0.001953125 0.2 * 2 = 0.4 ... å–æ­£æ•°ä½ ... 0 v 0 ... ... # ç»„æˆäºŒè¿›åˆ¶ 0001100110... ç„¶åæŠŠæ•´æ•°éƒ¨åˆ†è½¬äºŒè¿›åˆ¶å’Œå°æ•°éƒ¨åˆ†è½¬äºŒè¿›åˆ¶åŠ ä¸€èµ·ï¼Œå¦‚(101010.1010001...)ã€‚ æµ®ç‚¹æ•°æ˜¯å¦‚ä½•å­˜å‚¨åœ¨å†…å­˜ä¸­ æ¯”å¦‚ä¸Šé¢çš„101010.1010001...è½¬æ¢äºŒè¿›åˆ¶ç§‘å­¦è®¡æ•°æ³•è¡¨ç¤º1.010101010001... * 2^5ã€‚ åè¿›åˆ¶ äºŒè¿›åˆ¶ è®¡ç®—æ–¹å¼ äºŒè¿›åˆ¶ç§‘å­¦è®¡æ•°æ³•è¡¨ç¤º 3.5 11.1 3.5 = 2^1 + 2^0 + 2^-1 11.1 = 1.11 * 2^1 10.625 1010.101 10.625 = 2^3 + 2^1 + 2^-1 + 2^-3 1010.101 = 1.010101 * 2^3 0.6 0.10011001.. 0.6 = 2^-1 + 2^-4 + 2^-5 + 2^-8 .. 0.100110011001.. = 1.00110011001.. * 2^-1 ä»ä¸Šé¢å¯ä»¥è§‚å¯Ÿåˆ°ï¼Œå¯¹äºä»»ä½•æ•°æ¥è¯´ï¼Œè¡¨ç¤ºæˆäºŒè¿›åˆ¶ç§‘å­¦è®¡æ•°æ³•åï¼Œéƒ½å¯ä»¥è½¬æ¢æˆ1.xxx * 2^nå½¢å¼ã€‚ å¯¹äºè´Ÿæ•°æ¥è¯´ï¼Œåˆ™å¯ä»¥è¡¨ç¤ºæˆ-1.xxx * 2^nå½¢å¼ã€‚ æµ®ç‚¹æ•°çš„å­˜å‚¨å½¢å¼å¯ä»¥åˆ†ä¸ºä¸‰éƒ¨åˆ†ï¼š ç¬¦å·ä½ï¼ˆSï¼‰ å°¾æ•°(xxx)ï¼ˆMï¼‰ æŒ‡æ•°(n)ï¼ˆEï¼‰ æ ¹æ®æŒ‡æ•°åˆåˆ†ä¸ºä¸‰ç§ç±»å‹ï¼šè§„æ ¼æ•°(normal number)ã€éè§„æ ¼æ•°(subnormal number)ã€ç‰¹æ®Šæ•°(non-number)ã€‚ æŒ‡æ•°ä½ -\u0026gt; å…¨ä¸º0 ä¸å…¨ä¸º0ä¸”ä¸å…¨ä¸º1 å…¨ä¸º1 å¯¹åº”çš„æ•° -\u0026gt; éè§„æ ¼æ•°(subnormal number) è§„æ ¼æ•°(normal number) ç‰¹æ®Šæ•°(non-number) éè§„æ ¼æ•°(subnormal number)ï¼šæŒ‡æ•°ä½å…¨ä¸º0ï¼Œç”¨äºè¡¨ç¤º0æˆ–éå¸¸æ¥è¿‘0çš„æ•°ã€‚ è§„æ ¼æ•°(normal number)ï¼šæŒ‡æ•°ä½ä¸å…¨ä¸º0ä¸”ä¸å…¨ä¸º1ï¼Œç”¨äºè¡¨ç¤ºæ­£å¸¸çš„æ•°å€¼ã€‚ ç‰¹æ®Šæ•°(non-number)ï¼šæŒ‡æ•°ä½å…¨ä¸º1ï¼Œç”¨äºè¡¨ç¤ºÂ±infinityæˆ–NaNã€‚ åç§»é‡ï¼š\n4å­—èŠ‚æµ®ç‚¹æ•°çš„åç§»é‡ä¸º+127ï¼Œfloat32å­—èŠ‚çš„æŒ‡æ•°ä½æ˜¯å 8bitï¼Œæœ€å¤§å€¼255ã€‚ 8å­—èŠ‚æµ®ç‚¹æ•°çš„åç§»é‡ä¸º+1023ï¼Œfloat64å­—èŠ‚çš„æŒ‡æ•°ä½æ˜¯å 11bitï¼Œæœ€å¤§å€¼2047ã€‚ ä¸ºä½•åç§»é‡éƒ½å–ä¸€åŠä½œä¸ºä½¿ç”¨ï¼ŸåŸå› æ˜¯ä½œä¸ºæŒ‡æ•°nå­˜åœ¨è´Ÿæ•°æˆ–æ­£æ•°æƒ…å†µï¼ŒEæ˜¯åœ¨æ­¤åŸºç¡€ä¸ŠåšåŠ æ³•ã€‚ 7 è¡¨ç¤ºä¸º 00000111 0ä¸ºç¬¦å·ä½ï¼Œä»£è¡¨å®ƒæ˜¯ä¸€ä¸ªæ­£æ•°ã€‚ å¦‚æœæŠŠ 7 å’Œ +7 ç»Ÿä¸€åŠ ä¸Šåç§»é‡ 127ï¼Œé‚£ä¹ˆ 7 å°±å˜æˆ 134 ï¼ŒäºŒè¿›åˆ¶è¡¨ç¤ºä¸º 10000110ã€‚ -7å˜æˆ 120 ï¼ŒäºŒè¿›åˆ¶è¡¨ç¤ºä¸º 01111000ã€‚ ä¸¤è€…è¿›è¡Œæ¯”è¾ƒå¤§å°çš„æ—¶å€™ï¼Œè®¡ç®—æœºä¾¿æ— éœ€æ¯”è¾ƒä¸¤è€…çš„ç¬¦å·ä½ã€‚ å°¾æ•°ä½çš„å››ç§èˆå…¥æ–¹å¼ï¼šå› ä¸ºæµ®ç‚¹æ•°å¹¶ä¸èƒ½è¡¨ç¤ºæ‰€æœ‰çš„å®æ•°ï¼Œå› æ­¤ä¸ºäº†å°½é‡çš„é€¼è¿‘çœŸå®æ•°å­—æœ‰å¦‚ä¸‹èˆå…¥æ–¹å¼ã€‚\nå‘å¶èˆå…¥ï¼šè¿™æ˜¯æœ€å¸¸ç”¨çš„èˆå…¥æ–¹å¼ï¼Œä¹Ÿç§°ä¸ºâ€œå››èˆå…­å…¥äº”æˆåŒâ€ã€‚ å‘é›¶èˆå…¥ï¼šå³æœç€æ•°è½´é›¶ç‚¹æ–¹å‘èˆå…¥ï¼Œå³ç›´æ¥æˆªå°¾ã€‚ å‘ä¸Šèˆå…¥ï¼šå‘ç€æ•°è½´è¶Šå¤§çš„æ•°èˆå…¥ã€‚ å‘ä¸‹èˆå…¥ï¼šå‘ç€æ•°è½´è¶Šå°çš„æ•°èˆå…¥ã€‚ ä¸‹é¢ä»¥åè¿›åˆ¶ä¸ºä¾‹ï¼Œåˆ†æå‘å¶èˆå…¥ï¼š 1.40å°¾æ•°\u0026lt;=0.4ï¼Œç›´æ¥èˆå¼ƒï¼Œå€¼ä¸º1ã€‚ 1.60å°¾æ•°\u0026gt;=0.6ï¼Œå…¥ä½ï¼Œå€¼ä¸º2ã€‚ 1.5å°¾æ•°ä¸º0.5ï¼Œå‘å¶èˆå…¥ä¸º2ã€‚ 2.50å°¾æ•°ä¸º0.5ï¼Œå‘å¶èˆå…¥ä¸º2ã€‚ -1.50å°¾æ•°ä¸º0.5ï¼Œå‘å¶èˆå…¥ä¸º-2ã€‚ æ–¹å¼ 1.40 1.60 1.50 2.50 -1.50 å‘å¶èˆå…¥ 1 2 2 2 -2 å‘é›¶èˆå…¥ 1 1 1 2 -1 å‘ä¸‹èˆå…¥ 1 1 1 2 -2 å‘ä¸Šèˆå…¥ 2 2 2 3 -1 ç”¨RR\u0026hellip;RDD\u0026hellip;Dæ¥è¡¨ç¤ºä¸€ä¸ªäºŒè¿›åˆ¶å°æ•°ï¼ŒRè¡¨ç¤ºä¿ç•™ä½ï¼ŒDè¡¨ç¤ºèˆå»ä½ï¼Œé‚£ä¹ˆæœ‰ä»¥ä¸‹è§„åˆ™ï¼š DD\u0026hellip;D \u0026lt; 10\u0026hellip;0 -\u0026gt; ç›´æ¥èˆå» DD\u0026hellip;D \u0026gt; 10\u0026hellip;0 -\u0026gt; å‘ä¸Šèˆå…¥ DD\u0026hellip;D = 10\u0026hellip;0 -\u0026gt; å‘å¶æ•°èˆå…¥ï¼Œç»†åˆ™ï¼š RR\u0026hellip;R = XX\u0026hellip;0ï¼Œç›´æ¥èˆå» RR\u0026hellip;R = XX\u0026hellip;1ï¼Œå‘ä¸Šèˆå…¥ var f float64 = -0.1 è½¬æ¢æˆ 1.100110011001.. * 2^-4ï¼Œå°¾æ•°ä»¥1001é‡å¤ï¼Œå› æ­¤è¿›å…¥åŠ ä¸€ã€‚ æœ€åçš„å°¾æ•°ä¸º1001åŠ ä¸€ä¸º1010 var f float64 = -0.1 è½¬æ¢æˆ 1.100110011001.. * 2^-4ï¼Œå°¾æ•°ä»¥1001é‡å¤ï¼Œå› æ­¤è¿›å…¥åŠ ä¸€ã€‚ æœ€åçš„å°¾æ•°ä¸º1001åŠ ä¸€ä¸º1010 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // éªŒè¯ float32 å­˜å‚¨ 0.6 var b0 float32 = 0.6 i1 := (*uint32)(unsafe.Pointer(\u0026amp;b0)) fmt.Printf(\u0026#34;%b\u0026#34;, *i1)\t// 00111111 00011001 10011001 10011010 // float32æƒ…å†µä¸‹ï¼Œæœ€åä½“ç°äº† 11001 -\u0026gt; 11010 0èˆ1å…¥ // 0.6 -\u0026gt; 00111111000110011001100110011010 //-0.6 -\u0026gt; 10111111000110011001100110011010 // éªŒè¯ float64 å­˜å‚¨ -0.1 var b0 float64 = -0.1 i1 := (*uint64)(unsafe.Pointer(\u0026amp;b0)) // 10111111 10111001 10011001 10011001 10011001 10011001 10011001 10011010 fmt.Printf(\u0026#34;%b\u0026#34;, *i1)\t1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 // math/const.go æ–‡ä»¶ // Floating-point limit values. // Max is the largest finite value representable by the type. // SmallestNonzero is the smallest positive, non-zero value representable by the type. const ( // 2**127 * (2**24 - 1) / 2**23 == 2^128 - 2^104 == (2^127+...+2^0+1) - (2^103+...2^0+1) // 2^127 + 2^126 + ... + 2^104 == 1.11111111_11111111_1111111*2^127\tå®é™…å­˜å‚¨å­˜å‚¨ // 32bitå…¨éƒ¨å­˜å‚¨å¦‚ 0_11111110_11111111111111111111111 // 32ä¸ºè§„èŒƒæ•°çš„æŒ‡æ•°èŒƒå›´åœ¨[-126,127]ï¼Œå› ä¸ºæŒ‡æ•°å…¨é›¶ä¸ºå…¨å£¹è¡¨ç¤ºå…¶ä»–æ•°ï¼Œåç§»é‡127ï¼ŒæŒ‡æ•°æ–¹ä½[1,254] MaxFloat32 = 3.40282346638528859811704183484516925440e+38 // 2**127 * (2**24 - 1) / 2**23 // 1 / 2**(127 - 1 + 23) == 1.0 * 2^-149 == 0.00000000_00000000_0000010 * 2^-127 // 32bitå…¨éƒ¨å­˜å‚¨å¦‚ 0_00000000_00000000000000000000001\tè¿™é‡Œæ˜¯å› ä¸º0.çš„0ä¹Ÿè¢«å­˜å‚¨åˆ°å†…å­˜ä¸­äº†ï¼Œè¿™å°±æ˜¯å½“æŒ‡æ•°ä¸º0æ—¶æ˜¯ä¸€ç§ç‰¹æ®Šæƒ…å†µ // 2^-127 --\u0026gt; 0_00000000_1000000_00000000_00000000 // 2^-128 --\u0026gt; 0_00000000_0100000_00000000_00000000 // 2^-129 --\u0026gt; 0_00000000_0010000_00000000_00000000 // 2^-149 --\u0026gt; 0_00000000_0000000_00000000_00000001\tå½“æŒ‡æ•°å…¨ä¸º0æ—¶ï¼Œç³»æ•°ä»¥ 0. å¼€å¤´ SmallestNonzeroFloat32 = 1.401298464324817070923729583289916131280e-45 // 1 / 2**(127 - 1 + 23) MaxFloat64 = 1.797693134862315708145274237317043567981e+308 // 2**1023 * (2**53 - 1) / 2**52 SmallestNonzeroFloat64 = 4.940656458412465441765687928682213723651e-324 // 1 / 2**(1023 - 1 + 52) ) å¤æ•°ç±»å‹ å¤æ•°æ˜¯åœ¨æµ®ç‚¹æ•°çš„åŸºç¡€ä¸Šè¿›è¡Œå­˜å‚¨çš„ï¼Œé‚£ä¹ˆä¹Ÿå°±å¾ˆå¥½ç†è§£æµ®ç‚¹æ•°çš„å­˜å‚¨å½¢å¼ã€‚ complex64æ˜¯ç”±ä¸¤ä¸ªfloat32æ ¼å¼å½¢å¼ä¿å­˜çš„ï¼Œå› æ­¤å®éƒ¨å’Œè™šéƒ¨éƒ½æ˜¯float32å½¢å¼ä¿å­˜ï¼Œå…±å 8å­—èŠ‚ã€‚ complex128æ˜¯ç”±ä¸¤ä¸ªfloat64æ ¼å¼å½¢å¼ä¿å­˜çš„ï¼Œå› æ­¤å®éƒ¨å’Œè™šéƒ¨éƒ½æ˜¯float64å½¢å¼ä¿å­˜ï¼Œå…±å 16å­—èŠ‚ã€‚ ç±»å‹ é•¿åº¦ å†…å­˜å¯¹é½ complex64 32ä½æµ®ç‚¹æ•°æ„é€ å¤æ•° å 8å­—èŠ‚ 4B complex128 64ä½æµ®ç‚¹æ•°æ„é€ å¤æ•° å 16å­—èŠ‚ 8B 1 2 3 4 5 6 7 8 9 10 11 // complex64 ç­‰ä»·äº type clx64 struct { real float32 // å®æ•° 4Byte imag float32 // è™šæ•° 4Byte } // complex128 ç­‰ä»·äº type clx128 struct { real float64 // å®æ•° 8Byte imag float64 // è™šæ•° 8Byte } å£°æ˜å¤æ•°ï¼Œä»¥åŠreal()å’Œimag()å‡½æ•°ä½¿ç”¨ã€‚ 1 2 3 4 5 6 7 8 9 var c complex128 = 1.0 + 1i // %v ä»¥åŸå½¢å¼è¾“å‡º fmt.Printf(\u0026#34;value %v\u0026#34;, c) // value (1+1i) // complex()å‡½æ•°åˆ›å»º complex128ç±»å‹ cc := complex(2, -3) fmt.Printf(\u0026#34;value %v\u0026#34;, cc) // value (2-3i) // real()è·å–å¤æ•°å®éƒ¨ imag()å‡½æ•°è·å–å¤æ•°è™šéƒ¨ fmt.Println(real(cc), imag(cc))\t// 2 -3 éªŒè¯å¤æ•°çš„å†…å­˜å­˜å‚¨ç»“æ„ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 // complex64 ç±»å‹éªŒè¯ï¼Œæˆ‘ä»¬å‰é¢éªŒè¯è¿‡float32ç±»å‹çš„0.6æ ¼å¼è¿™é‡Œä¹Ÿä½¿ç”¨0.6 var b0 complex64 = 0.6 + 0.6i i1 := (*uint64)(unsafe.Pointer(\u0026amp;b0)) // 11111100011001100110011001101000111111000110011001100110011010 fmt.Printf(\u0026#34;%b\\n\u0026#34;, *i1)\t// 00111111000110011001100110011010 -\u0026gt; 0.6 å®éƒ¨ // 00111111000110011001100110011010 -\u0026gt; 0.6 è™šéƒ¨ // \u0026gt; ------------------------------------------------------------------ // complex128æ˜¯å 16å­—èŠ‚ var b0 complex128 = 0.6 - 0.6i i1 := (*float64)(unsafe.Pointer(\u0026amp;b0)) fmt.Println(*i1) // 0.6 i11 := (*uint64)(unsafe.Pointer(\u0026amp;b0)) // 0011111111100011001100110011001100110011001100110011001100110011 -\u0026gt; 0.6 å®éƒ¨ fmt.Printf(\u0026#34;%64b\\n\u0026#34;, *i11)\ti2 := (*float64)(unsafe.Pointer(uintptr(unsafe.Pointer(\u0026amp;b0)) + unsafe.Sizeof(uint64(0)))) fmt.Println(*i2) // -0.6 i22 := (*uint64)(unsafe.Pointer(uintptr(unsafe.Pointer(\u0026amp;b0)) + unsafe.Sizeof(uint64(0)))) // 1011111111100011001100110011001100110011001100110011001100110011 -\u0026gt; -0.6 è™šéƒ¨ fmt.Printf(\u0026#34;%64b\\n\u0026#34;, *i22)\tå­—ç¬¦ä¸²ç±»å‹ å­—ç¬¦ä¸²æ˜¯ä¸€ä¸²å›ºå®šé•¿åº¦çš„å­—ç¬¦è¿æ¥èµ·æ¥çš„å­—ç¬¦åºåˆ—ï¼Œå­—ç¬¦ä¸²æ˜¯ç”±å•ä¸ªå­—èŠ‚è¿æ¥èµ·æ¥çš„ï¼Œå­—èŠ‚ä½¿ç”¨UTF-8ç¼–ç æ ‡è¯†çš„Unicodeæ–‡æœ¬ã€‚ ç¼–è¯‘é˜¶æ®µå­—ç¬¦ä¸²å­˜å‚¨åœ¨åªè¯»æ•°æ®æ®µï¼Œæ‰€ä»¥å­—ç¬¦ä¸²åœ¨ç¡¬ä»¶åº•å±‚é˜»æ­¢è¢«ä¿®æ”¹ã€‚ ä½†æ˜¯åœ¨è¿è¡Œé˜¶æ®µå­—ç¬¦ä¸²åˆ™æ˜¯è¢«åˆ†é…åœ¨å †ä¸Šä½†æ˜¯ä¹Ÿä¸å…è®¸è¢«ä¿®æ”¹ï¼ŒåŸå› æ˜¯åœ¨è¯­è¨€å±‚é¢è¢«é˜»æ­¢çš„ï¼Œä½†æ˜¯æˆ‘ä»¬å¯ä»¥ä½¿ç”¨unsafeç»•è¿‡è¯­è¨€å±‚é¢è¿›è¡Œä¿®æ”¹ã€‚ é¦–å…ˆå­—ç¬¦ä¸²æ˜¯UTF-8ç¼–ç æ ‡è¯†çš„Unicodeæ–‡æœ¬ï¼Œéœ€è¦å…ˆäº†è§£Unicodeç¼–ç çš„å¤„ç†ï¼Œå†çœ‹Unicodeè½¬UTF-8ã€‚ éœ€è¦è®°ä½å­—ç¬¦çš„å­˜å‚¨å½¢å¼ã€‚ 1 2 3 4 5 6 type StringStruct struct { // å­˜å‚¨è”ç³»å†…å­˜çš„é¦–åœ°å€ï¼Œè¿™é‡Œä¹Ÿå°±æ˜¯[...]byteç±»å‹çš„æ•°ç»„ï¼Œè¿ç»­çš„å­—èŠ‚æ˜¯utf8ç¼–ç çš„æ•°æ® Data unsafe.Pointer // å­—ç¬¦ä¸²é•¿åº¦ Len uintptr } æ›´å¤šå…³äºå­—ç¬¦è®¨è®ºå‚çœ‹åé¢å­—ç¬¦ä¸²æ–‡æ¡£ã€‚ å¤åˆç±»å‹ æŒ‡é’ˆç±»å‹ï¼ˆpointerï¼‰ï¼Œä¹Ÿå°±æ˜¯å¦‚ *intã€*stringç­‰ç±»å‹ï¼Œå­˜å‚¨çš„æ˜¯åŸºç¡€ç±»å‹çš„å¼•ç”¨åœ°å€ã€‚ æ•°ç»„ç±»å‹ï¼ˆarrayï¼‰ï¼Œè¿ç»­å†…å­˜åˆ†å¸ƒå­˜å‚¨çš„ï¼Œå…¶æ•°ç»„é•¿åº¦ä¿å­˜åœ¨ç±»å‹ç»“æ„ä¸­ï¼Œè¿™ä¹Ÿå°±æ˜¯å¯¼è‡´ä¸åŒé•¿åº¦çš„ç›¸åŒç±»å‹çš„æ•°ç»„å±äºä¸åŒç±»å‹çš„åŸå› (ç±»å‹hashä¸åŒ)ã€‚ ç»“æ„ä½“ï¼ˆstructï¼‰ï¼Œè¿ç»­å†…å­˜åˆ†å¸ƒå­˜å‚¨çš„ã€‚ é€šé“ç±»å‹ï¼ˆchanï¼‰ï¼Œhchanç»“æ„ä½“çš„å¼•ç”¨åœ°å€ã€‚ å‡½æ•°ç±»å‹ï¼ˆfunctionï¼‰ï¼Œfuncvalç»“æ„ä½“çš„å¼•ç”¨åœ°å€ã€‚ åˆ‡ç‰‡ç±»å‹ï¼ˆsliceï¼‰ï¼Œç»“æ„ä¸å­—ç¬¦ä¸²çš„ç»“æ„å¤§ä½“ç›¸åŒåªå¤šäº†ä¸ªCapå­—æ®µå­˜å‚¨å®¹é‡ï¼Œå­˜å‚¨å½¢å¼å¤§ä½“ç›¸å½“ã€‚ æ¥å£ç±»å‹ï¼ˆinterfaceï¼‰ï¼Œefaceå’Œifaceç»“æ„ä½“çš„ ï¼Œå­˜å‚¨ç±»å‹å…ƒç´ æ•°æ®ã€åŠ¨æ€ç±»å‹ç›¸å…³ä¿¡æ¯ã€‚ å­—å…¸ç±»å‹ï¼ˆmapï¼‰ï¼Œhmapç»“æ„ä½“çš„å¼•ç”¨åœ°å€ã€‚ é”™è¯¯ç±»å‹ Goè¯­è¨€é¢„å®šä¹‰ç±»å‹ï¼Œä¹Ÿå°±æ˜¯ifaceç»“æ„ä½“ï¼Œéç©ºæ¥å£ç±»å‹ã€‚ é”™è¯¯ç±»å‹æ˜¯æ¥å£ï¼Œnilå€¼è¡¨ç¤ºæ— é”™è¯¯ã€‚ åªè¦å®ç°æ¥å£çš„æ–¹æ³•åŠç»§æ‰¿äº†è¯¥æ¥å£ã€‚ 1 2 3 4 // Erroræ¥å£ type error interface { Error() string } æ€»ç»“ æ•°ç»„(array)å’Œç»“æ„ä½“(struct)éƒ½æ˜¯èšåˆç±»å‹ï¼Œé•¿åº¦å›ºå®šã€‚ åˆ‡ç‰‡(slice)å’Œå­—å…¸(map)éƒ½æ˜¯åŠ¨æ€æ•°æ®ç»“æ„ï¼Œé•¿åº¦å¯å˜ã€‚ å‚è€ƒ æµ®ç‚¹æ•°å­˜å‚¨ ","permalink":"https://heliu.site/posts/golang/basic/type/","summary":"Golang å†…ç½®çš„åŸºæœ¬ç±»å‹ä»‹ç»ã€‚","title":"å†…ç½®ç±»å‹"},{"content":" å˜é‡åè®©ä½ èƒ½å¤ŸæŠŠç¨‹åºä¸­å‡†å¤‡ä½¿ç”¨çš„æ¯ä¸€æ®µæ•°æ®éƒ½èµ‹å€¼ç»™ä¸€ä¸ªç®€çŸ­ã€æ˜“äºè®°å¿†çš„åå­—ã€‚ å˜é‡å£°æ˜åŠä½¿ç”¨ å˜é‡çš„å®šä¹‰ 1 2 // å…³é”®å­— æ ‡è¯†ç¬¦ [ç±»å‹] = å€¼ var identifier [type] = value æ˜¾ç¤ºå£°æ˜å˜é‡ï¼šåœ¨å£°æ˜å˜é‡æ—¶æŒ‡å®šå˜é‡çš„ç±»å‹ã€‚ éšå¼å£°æ˜å˜é‡ï¼šåœ¨å£°æ˜å˜é‡æ—¶å¹¶æœªæŒ‡å®šå˜é‡çš„ç±»å‹ï¼Œè€Œæ˜¯åœ¨ç¼–è¯‘é˜¶æ®µç¼–è¯‘å™¨æ ¹æ®å˜é‡å€¼è‡ªåŠ¨åˆ¤æ–­ç±»å‹ã€‚ æ•´æ•°ç±»å‹(æ­£æ•°æˆ–è´Ÿæ•°ï¼Œåè¿›åˆ¶ã€åå…­è¿›åˆ¶ã€å…«è¿›åˆ¶ã€äºŒè¿›åˆ¶)ï¼šç¼–è¯‘å™¨ä¼šå…¨éƒ¨è¯†åˆ«ä¸ºintç±»å‹ï¼Œå¦‚ï¼švar a = 123ã€‚ å­—ç¬¦ä¸²ï¼šç¼–è¯‘å™¨è¯†åˆ«ä¸ºstringç±»å‹ï¼Œå¦‚ï¼švar b = \u0026quot;a1\u0026quot;ã€‚ æµ®ç‚¹æ•°ï¼šç¼–è¯‘å™¨è¯†åˆ«ä¸ºfloat64ç±»å‹ï¼Œå¦‚ï¼švar c = -1.0ã€‚ å¤æ•°ï¼šç¼–è¯‘å™¨è¯†åˆ«ä¸ºcomplecx128ç±»å‹ï¼Œå¦‚ï¼švar d = 1iã€‚ å­—ç¬¦ç±»å‹ï¼šç¼–è¯‘å™¨è¯†åˆ«ä¸ºrune (int32) ç±»å‹ï¼Œå¦‚ï¼švar e = 'a'ã€‚ å…¶ä»–ç±»å‹æ ¹æ®æƒ…å†µåˆ¤æ–­ï¼Œå¦‚ï¼švar f = map[string]int{}è¿™ä¸€å®šæ˜¯mapï¼Œå…¶ä»–ç±»ä¼¼ã€‚ 1 2 3 4 5 6 7 8 9 10 11 // æ˜¾å¼å£°æ˜ è®¾ç½®å€¼ // ç»“æ„ data=\u0026#34;hello world!\u0026#34; len=12 var name string = \u0026#34;hello world!\u0026#34;\tvar sex uint8 sex = 1 // æ˜¾å¼å£°æ˜ æœªè®¾ç½®å€¼ é»˜è®¤å–å€¼ \u0026#34;\u0026#34; var name string\t// éšå¼å£°æ˜ ç¼–è¾‘å™¨ä¼šè‡ªåŠ¨æ¨æ–­å˜é‡ç±»å‹ï¼Œè€Œå¸¸é‡åˆ™æ˜¯åœ¨ä¸Šä¸‹æ–‡ä¸­è½¬æ¢ var name = \u0026#34;hello\u0026#34;\t// ç³»ç»Ÿé»˜è®¤æ¨å¯¼ä¸ºstringç±»å‹ ç®€å•å£°æ˜ ç®€å•ç”³æ˜ä½¿ç”¨:=ï¼Œå½“å£°æ˜ä¸€ä¸ªå˜é‡æ—¶å½“å‰å˜é‡åœ¨å½“å‰ä½œç”¨åŸŸå†…æœªè¢«å£°æ˜è¿‡æ—¶ã€‚(åªèƒ½ç”¨äºå‡½æ•°å†…) 1 name := \u0026#34;hello\u0026#34; // ç³»ç»Ÿé»˜è®¤æ¨å¯¼string å¤šå˜é‡èµ‹å€¼ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // 1. ä¸åŒæ•°æ®ç±»å‹ // nameå’Œsexå˜é‡ï¼Œç¼–è¾‘å™¨é»˜è®¤æ¨å¯¼ä¸ºstringç±»å‹ // ageå˜é‡ï¼Œç¼–è¾‘å™¨é»˜è®¤æ¨æ–­ä¸ºintç±»å‹ var name, sex, age = \u0026#34;hello\u0026#34;, \u0026#34;ç”·\u0026#34;, 1 // 2. ç›¸åŒæ•°æ®ç±»å‹ï¼Œaã€bã€cå˜é‡éƒ½ä¸ºboolç±»å‹ var a, b, c bool a, b, c = false, true, false // 3. ä¸€èµ·å£°æ˜ var ( aa uint // æ•°å€¼ç±»å‹ é»˜è®¤å€¼ 0 bb string // å­—ç¬¦ä¸²ç±»å‹ é»˜è®¤å€¼ \u0026#34;\u0026#34; cc [3]int // æ•°ç»„ç±»å‹ é»˜è®¤å€¼ [0,0,0] ) // 4. æˆ–è€…åœ¨å‡½æ•°å†… // è¿™ç§å½¢å¼æ¯”è¾ƒç‰¹æ®Šï¼Œå½“å‰nameæˆ–sexæˆ–ageä¸­åªè¦æœ‰ä¸€ä¸ªå˜é‡åœ¨ã€å½“å‰ä½œç”¨åŸŸã€‘ä¸­æœªè¢«å£°æ˜è¿‡æ—¶æ‰èƒ½ä½¿ç”¨ // å…¶ä½™çš„å…¨éƒ¨é€€è¿˜ä¸ºèµ‹å€¼æ“ä½œï¼Œæ¯”è¾ƒå¸¸ç”¨çš„æ˜¯f, err := os.Open(\u0026#34;./t.txt\u0026#34;)è¿™é‡Œçš„errè¢«å¤šæ¬¡ä½¿ç”¨é€€åŒ–ä¸ºèµ‹å€¼æ“ä½œ name, sex, age := \u0026#34;hello\u0026#34;, \u0026#34;ç”·\u0026#34;, 1 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 // åœ¨ifçš„ä½œç”¨åŸŸä¸­æ—¶ï¼ˆè¿™é‡Œçš„bbå’Œerråœ¨è¯¥ä½œç”¨åŸŸä¸­éƒ½æ²¡æœ‰å£°æ˜è¿‡ï¼Œå› æ­¤é»˜è®¤ä¸ºå†…éƒ¨å˜é‡ï¼‰ if bb, err := tt(); err != nil { // bb declared and not used log.Println(err, bb) } // ç­‰ä»·äº { // ifçš„ä½œç”¨åŸŸå†…ï¼Œå£°æ˜bbå’Œerrã€å±€éƒ¨ã€‘å˜é‡ bb, err := tt() if err != nil { log.Println(err, bb) } } // \u0026gt; --------------------------------------------------------------- var bb byte = \u0026#39;a\u0026#39; // ä½œç”¨åŸŸå¤–çš„ bb å˜é‡ // è¿™é‡Œbbåœ¨ifå¤–ï¼Œè€Œerråœ¨ifå†…ä½œç”¨åŸŸï¼Œå› æ­¤ifå†…çš„bbä¼šç”Ÿæˆifå†…çš„å˜é‡è¦†ç›–å¤–å±‚bbå˜é‡ if bb, err := tt(); err != nil { // bb declared and not used log.Println(err, bb) // ä½œç”¨åŸŸå†…çš„ bb å˜é‡ } // ç­‰ä»·äº var bb byte = \u0026#39;a\u0026#39; { // ifçš„ä½œç”¨åŸŸå†…ï¼Œå£°æ˜bbå’Œerrã€å±€éƒ¨ã€‘å˜é‡ï¼Œå› ä¸ºåœ¨è¯¥ä½œç”¨åŸŸå†…éƒ½æ²¡æœ‰bbå’Œerrå˜é‡ bb, err := tt() if err != nil { log.Println(err, bb) } } æ€»ç»“ï¼Œ:=ä¼šåœ¨å½“å‰ä½œç”¨åŸŸå¯»æ‰¾å˜é‡ï¼Œå¦‚æœæ‰¾åˆ°åˆ™ä½¿ç”¨å®ƒï¼Œå¦‚æœæœªæ‰¾åˆ°åˆ™å£°æ˜ä¸€ä¸ªæ–°å˜é‡ã€‚ æ³¨æ„ï¼Œ:=å¿…é¡»è¦æ±‚å·¦è¾¹å­˜åœ¨è‡³å°‘ä¸€ä¸ªæœªå®šä¹‰çš„å˜é‡ã€‚:=åªèƒ½åœ¨å‡½æ•°å†…ä½¿ç”¨ã€‚ å˜é‡äº¤æ¢ 1 2 3 4 5 6 7 8 9 10 var a, b string = \u0026#34;world\u0026#34;, \u0026#34;hello\u0026#34; fmt.Println(a, b) // world hello // 1. äº¤æ¢å˜é‡å€¼ a, b = b, a fmt.Println(a, b) // hello world // 2. å˜é‡äº¤æ¢ç­‰ä»·äº temp := a a = b b = temp æ ‡è¯†ç¬¦ ç”±å­—æ¯ã€æ•°å­—ã€ä¸‹åˆ’çº¿ï¼ˆ_ï¼‰ç»„æˆï¼Œå…¶ä¸­é¦–å­—ç¬¦ä¸èƒ½ä¸ºæ•°å­—ï¼ŒåŒºåˆ†å¤§å°å†™ï¼ˆåŒä¸€å­—æ¯çš„å¤§å°å†™ä»£è¡¨ä¸åŒçš„æ ‡è¯†ï¼‰ã€‚ Goè¯­è¨€è§„èŒƒï¼š æ ‡è¯†ç¬¦ï¼šå‘½åç¨‹åºå®ä½“ï¼Œå¦‚å˜é‡åå’Œç±»å‹åã€‚ æ ‡è¯†ç¬¦æ˜¯ä¸€ä¸ªæˆ–å¤šä¸ªUnicodeå­—æ¯å’Œæ•°å­—çš„åºåˆ—ã€‚ æ ‡è¯†ç¬¦ä¸­çš„ä¸€ä¸ªå­—ç¬¦å¿…é¡»æ˜¯Unicodeå­—æ¯ï¼ˆä¸‹åˆ’çº¿_ä¹Ÿè¢«è®¤ä¸ºæ˜¯å­—æ¯ï¼‰ã€‚ identifiter = letter {letter | unicode_digit} letter = unicode_letter | _ï¼šletter åŒ…å«å­—æ¯ï¼ˆåŒ…æ‹¬é™¤è‹±æ–‡å­—æ¯ä»¥å¤–çš„å­—æ¯ï¼‰å’Œä¸‹åˆ’çº¿ã€‚ unicode_digit = 0 1 2 3 4 5 6 7 8 9ï¼šæ•°å­—ï¼ˆè¿™é‡Œä¹ŸåŒ…æ‹¬é™¤é˜¿æ‹‰ä¼¯æ•°å­—ä»¥å¤–çš„æ•°å­—ï¼‰ã€‚ åœ¨Goè¯­è¨€ä¸­ï¼Œå‘½åæ ‡è¯†ç¬¦æ—¶ï¼Œé€šå¸¸é€‰æ‹©è‹±æ–‡çš„52ä¸ªå¤§å°å†™å­—æ¯ä»¥åŠæ•°å­—0~9å’Œä¸‹åˆ’çº¿æ¥ç»„åˆæˆåˆé€‚çš„æ ‡è¯†ç¬¦ã€‚ 1 2 3 4 5 6 7 8 9 10 // Goè¯­è¨€å˜é‡å£°æ˜ä½¿ç”¨å…³é”®å­— var // ä¸‹é¢è¿™ç§å½¢å¼ å¤šç”¨äºå®šä¹‰å…¨å±€å˜é‡ï¼Œé€šå¸¸åœ¨å‡½æ•°å¤–è¢«å®šä¹‰ var ( a int b bool str string æµ®ç‚¹ float32\t// ä¸­æ–‡ä¹Ÿå¯ä»¥ä½œä¸ºå˜é‡æ ‡è¯†ç¬¦ï¼Œåœ¨Unicodeé‡Œçš„å­—ç¬¦éƒ½èƒ½ ) var a, b int å…³é”®å­— Goè¯­è¨€ä¸­å…³é”®å­—æ˜¯ä¿ç•™å­—ï¼Œä¸èƒ½ä½œä¸ºå˜é‡æ ‡è¯†ç¬¦ï¼Œå…³é”®å­—ä¸€å…±æœ‰25ä¸ªã€‚ Go å…³é”®å­— breakï¼šç”¨äºè·³å‡ºforå¾ªç¯ï¼Œè·³å‡ºswitchå’Œselectå—ã€‚ switchå’Œselectéƒ½é»˜è®¤è‡ªå¸¦breakï¼ˆå¦‚æœå†™äº†breaké»˜è®¤è·³å‡ºå½“å‰å—ï¼‰ã€‚ continueï¼šç”¨äºforå¾ªç¯ï¼Œè¡¨ç¤ºç»“æŸæœ¬æ¬¡å¾ªç¯ç»§ç»­ä¸‹æ¬¡å¾ªç¯ã€‚ defaultï¼šç”¨äºswitchå’Œselectç»“æ„çš„é»˜è®¤åˆ†æ”¯ï¼Œå½“æ‰€æœ‰caseéƒ½ä¸æ»¡è¶³æ—¶æ‰§è¡Œdefaultåˆ†æ”¯ã€‚ funcï¼šç”¨äºå®šä¹‰å‡½æ•°æˆ–æ–¹æ³•æˆ–å‡½æ•°ç±»å‹å˜é‡ã€‚ interfaceï¼šç”¨äºå®šä¹‰æ¥å£ç±»å‹ã€‚ selectï¼šé€‰æ‹©ç»“æ„ï¼Œä¸»è¦ç”¨äºchanç±»å‹åœ¨ï¼Œæ³¨æ„åœ¨selectä¸­ä¸èƒ½ä½¿ç”¨å…³é”®å­—fallthroughã€‚ caseï¼šç”¨äºselectå’Œswitchå…³é”®å­—ä¸­ï¼Œè¡¨ç¤ºä¸€ä¸ªåˆ†æ”¯å—ã€‚ deferï¼šä¸»è¦ç”¨äºfuncå…³é”®å­—å®šä¹‰çš„å‡½æ•°å’Œæ–¹æ³•ä½“ä¸­ï¼Œè¡¨ç¤ºå½“å‰è¯­å¥åœ¨å‡½æ•°é€€å‡ºæ—¶æ‰§è¡Œã€‚ goï¼šä¸»è¦ç”¨äºåˆ›å»ºä¸€ä¸ªgoroutineæ”¾å…¥Pä¸­ç­‰å¾…è¢«çº¿ç¨‹è°ƒç”¨ï¼Œè¿™ä¹Ÿæ˜¯åˆ›å»ºåç¨‹çš„å…³é”®ã€‚ mapï¼šç”¨äºå®šä¹‰å­—å…¸ç±»å‹ã€‚ structï¼šç”¨äºå®šä¹‰ç»“æ„ä½“ç±»å‹ã€‚ chanï¼šç”¨äºå®šä¹‰é€šé“ç±»å‹ï¼Œchançš„ä¸»è¦ä½œç”¨æ˜¯åœ¨å„ä¸ªgoroutineé—´é€šä¿¡çš„é€šé“ã€‚ elseï¼šä¸ifå…³é”®å­—é…åˆä½¿ç”¨ï¼Œå½“ä¸Šé¢æ‰€æœ‰æ¡ä»¶éƒ½ä¸æ»¡è¶³æ—¶é»˜è®¤æ‰§è¡Œelseåˆ†æ”¯çš„ä»£ç å—ã€‚ gotoï¼šè·³è½¬è¯­å¥ï¼Œé…åˆæ ‡ç­¾èƒ½ä»»æ„è·³è½¬åˆ°æŒ‡å®šä»£ç å¤„ï¼Œå¤šåœ¨å‡½æ•°å†…ä½¿ç”¨ã€‚ packageï¼šç”¨äº.goæ–‡ä»¶çš„åŒ…å£°æ˜ï¼Œå¤šç”¨äº.goæ–‡ä»¶çš„ç¬¬ä¸€è¡Œä»£ç ã€‚ switchï¼šé€‰æ‹©åˆ†æ”¯ç»“æ„ï¼Œå¸¸ä¸caseã€defaultã€fallthroughä¸€èµ·ä½¿ç”¨ã€‚ constï¼šç”¨äºå®šä¹‰å¸¸é‡ã€‚ fallthroughï¼šç”¨äºswitchçš„caseå—ä¸­ï¼Œè¡¨ç¤ºç»§ç»­è¿è¡Œä¸‹ä¸€ä¸ªcaseå—ä»£ç è€Œä¸æ£€æŸ¥æ˜¯å¦æ»¡è¶³æ¡ä»¶ã€‚ è¯¥å…³é”®å­—å¤šç”¨äºè¿ç§»å…¶ä»–è¯­è¨€ä»£ç å…¼ç”¨ä½¿ç”¨ï¼Œæ­£å¸¸å¼€å‘ä¸­ä¸å»ºè®®ä½¿ç”¨ã€‚ ifï¼šåˆ†æ”¯é€‰æ‹©ç»“æ„å¤šä¸elseæˆ–else ifä¸€èµ·ä½¿ç”¨ã€‚ rangeï¼šä¸forå…³é”®å­—ä¸€èµ·ä½¿ç”¨ï¼Œä»sliceã€mapã€stringã€arrayã€chanç­‰ä¸­è¿­ä»£å…ƒç´ ã€‚ æ³¨æ„rangeä¼šæ‹·è´sliceã€arrayéœ€è¦è¿­ä»£çš„é›†åˆå‰¯æœ¬ï¼Œä»¥ä¾¿äºåŸé›†åˆåŒºåˆ†ã€‚ typeï¼šå¤šç”¨äºå®šä¹‰ç±»å‹å…³é”®å­—ã€‚ forï¼šç”¨äºå¼€å§‹ä¸€ä¸ªå¾ªç¯ã€‚ importï¼šå¯¼å…¥å…¶ä»–åŒ…æ–‡ä»¶å…³é”®å­—ã€‚ returnï¼šç”¨äºå‡½æ•°æˆ–æ–¹æ³•ä¸­ï¼Œè¡¨ç¤ºç»“æŸå½“å‰å‡½æ•°å¹¶è¿”å›ç»™å®šå€¼ã€‚ åœ¨æ²¡æœ‰è¿”å›å€¼çš„å‡½æ•°ä¸­ä¹Ÿå¯ä»¥ä½¿ç”¨returnæ¥è¿”å›å‡½æ•°ã€‚ varï¼šç”¨äºå®šä¹‰å˜é‡çš„å…³é”®å­—ã€‚ æ³¨æ„äº‹é¡¹ å˜é‡å¿…é¡»å…ˆå®šä¹‰æ‰èƒ½ä½¿ç”¨ï¼Œå˜é‡çš„ç±»å‹å’Œèµ‹å€¼çš„ç±»å‹å¿…é¡»ä¸€è‡´ã€‚ å˜é‡åä¸èƒ½å†²çªï¼ˆåŒä¸€ä¸ªä½œç”¨åŸŸå†…ä¸èƒ½å†²çªï¼‰ã€‚ ç®€çŸ­å®šä¹‰æ–¹å¼ï¼Œåªèƒ½åœ¨å‡½æ•°å†…è¢«å®šä¹‰ã€‚ åŒä¸€ä¸ªä½œç”¨åŸŸä¸­ï¼Œå·²å­˜åœ¨åŒåçš„å˜é‡ï¼Œåˆ™ä¹‹åçš„å£°æ˜åˆå§‹åŒ–ï¼Œåˆ™é€€åŒ–ä¸ºèµ‹å€¼æ“ä½œã€‚ å‰ææ˜¯ï¼Œæœ€å°‘è¦æœ‰ä¸€ä¸ªæ–°çš„å˜é‡è¢«å®šä¹‰ï¼Œä¸”åœ¨åŒä¸€ä½œç”¨åŸŸã€‚ å˜é‡å®šä¹‰äº†å¦‚ä¸ä½¿ç”¨ç¼–è¯‘é€šä¸è¿‡ã€‚ 1 2 3 4 5 6 x := 12 // å®šä¹‰å˜é‡xé»˜è®¤æ¨å¯¼ä¸ºintç±»å‹ x, y = 1, \u0026#34;hello\u0026#34; // å˜é‡xé‡æ–°èµ‹å€¼ä¸º1ï¼Œ å®šä¹‰å˜é‡yé»˜è®¤æ¨å¯¼ä¸ºstringç±»å‹ // è¿™ç§æƒ…å†µç»å¸¸å‡ºç°åœ¨æ¥æ”¶é”™è¯¯æƒ…å†µä¸‹ï¼Œç¬¬äºŒä¸ªerrå˜é‡é€€åŒ–ä¸ºèµ‹å€¼æ“ä½œ file1, err := os.Open(\u0026#34;a.txt\u0026#34;) // åœ¨å½“å‰ä½œç”¨åŸŸå£°æ˜file1å’Œerrå˜é‡ file2, err := os.Open(\u0026#34;b.txt\u0026#34;) // å½“å‰ä½œç”¨åŸŸå·²æœ‰errå˜é‡ç›´æ¥ä½¿ç”¨ï¼Œå£°æ˜file2å˜é‡ ä½œç”¨åŸŸ åœ¨é¡¶å±‚å£°æ˜çš„å¸¸é‡ï¼ˆå¦‚const a int = 1ï¼‰ï¼Œç±»å‹ï¼ˆå¦‚type a intï¼‰ï¼Œå˜é‡ï¼ˆå¦‚var a = 1ï¼‰å‡½æ•°çš„æ ‡è¯†ç¬¦ï¼ˆå¦‚func name() intï¼‰çš„èŒƒå›´æ˜¯åŒ…å—ã€‚ å¯¼å…¥åŒ…åç§°èŒƒå›´æ˜¯åŒ…å«å¯¼å…¥å£°æ˜çš„æ–‡ä»¶çš„æ–‡ä»¶å—ã€‚ å¯¼å…¥åŒ…åç§°èŒƒå›´æ˜¯åŒ…å«å¯¼å…¥å£°æ˜çš„æ–‡ä»¶çš„æ–‡ä»¶å—ã€‚ åœ¨å‡½æ•°å†…å£°æ˜çš„å¸¸é‡æˆ–å˜é‡æ ‡è¯†ç¬¦çš„èŒƒå›´ä»å£°æ˜è¯­å¥çš„æœ«å°¾å¼€å§‹ï¼Œåˆ°æœ€å†…å±‚åŒ…å«å—çš„æœ«å°¾ç»“æŸã€‚ åœ¨å‡½æ•°å†…å£°æ˜çš„ç±»å‹æ ‡è¯†ç¬¦çš„èŒƒå›´ä»æ ‡è¯†ç¬¦å¼€å§‹ï¼Œåˆ°æœ€å†…å±‚åŒ…å«å—çš„æœ«å°¾ç»“æŸã€‚ å—ä¸­å£°æ˜çš„æ ‡è¯†ç¬¦å¯ä»¥åœ¨å†…éƒ¨å—ä¸­é‡æ–°å£°æ˜ã€‚ ä½œç”¨åŸŸå°±ç±»ä¼¼ä¸€æ£µæ ‘ç»“æ„ï¼Œè€Œæ¯ä¸ªæ ‘æç›¸å½“äºå—ï¼Œåœ¨æ ‘å¹²å®šä¹‰çš„å˜é‡èƒ½è¢«è¿™ä¸ªæ ‘å¹²åˆ†æˆå‡ºçš„æ ‘ææˆ–æ ‘æçš„æ ‘æä½¿ç”¨ï¼Œè€Œåœ¨æ ‘æä¸­é‡å¤å®šä¹‰æ ‘å¹²çš„å˜é‡åˆ™ä¼šå±è”½è°ƒæ ‘å¹²å®šä¹‰çš„å˜é‡ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 package main import ( \u0026#34;fmt\u0026#34; ) // å…¨å±€å˜é‡ var x int = 10 // ---------- å‡è®¾å…¨å±€ä½œç”¨åŸŸå°±æ˜¯æ ‘å¹²ç¼–å·SU01 func main() { fmt.Println(x) // 10\t// å±€éƒ¨å˜é‡ x := 1 // ---------- è€Œåœ¨mainå‡½æ•°ä¸­çš„å±€éƒ¨å˜é‡å°±SU01çš„æ ‘æSZ01 fmt.Println(x) // 1 // å±€éƒ¨å— { fmt.Println(x) // 1 // å±€éƒ¨å˜é‡ x := 2 // ---------- è€Œåœ¨SZ01å®šä¹‰çš„å—åŠæ˜¯SZ01çš„æ ‘æSZ02 fmt.Println(x) // 2 } fmt.Println(x) // 1 // Output: // 10 // 1 // 1 // 2 // 1 } æœªä½¿ç”¨çš„å˜é‡ æœªä½¿ç”¨çš„å…¨å±€å˜é‡ç¼–è¯‘ä¸ä¼šæŠ¥é”™ã€‚ å‡½æ•°å†…æœªä½¿ç”¨å®šä¹‰çš„å˜é‡ç¼–è¯‘ä¼šæŠ¥é”™ï¼Œimportå¯¼å…¥çš„åŒ…ï¼Œæœªä½¿ç”¨ç¼–è¯‘ä¼šæŠ¥é”™ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 package main import ( //\u0026#34;fmt\u0026#34; // 1. æœªä½¿ç”¨çš„importåŒ…ï¼Œç¼–è¯‘ä¼šæŠ¥é”™ ) var x int = 10 // æœªä½¿ç”¨çš„å…¨å±€å˜é‡ç¼–è¯‘ä¸ä¼šæŠ¥é”™ func main() { // 2. å‡½æ•°å†…æœªä½¿ç”¨çš„å˜é‡ç¼–è¯‘ä¼šæŠ¥é”™ x := 1\t// 10:2: x declared and not used } ä¸‹åˆ’çº¿ _ ï¼šæ˜¯ç‰¹æ®Šæ ‡è¯†ç¬¦ï¼Œç”¨æ¥å¿½ç•¥ç»“æœã€‚è¯¥å˜é‡æ˜¯åªå†™ï¼Œå¹¶ä¸”æ˜¯ç³»ç»Ÿå®šä¹‰å¥½çš„å˜é‡ï¼Œå¯ä»¥éšæ„ä½¿ç”¨ä¸åˆ†ä½œç”¨åŸŸã€‚ ä¸‹åˆ’çº¿åœ¨importä¸­ importï¼šå¯¼å…¥å…¶ä»–packageåŒ…æ–‡ä»¶ã€‚ å½“å‰ _ ç”¨äº import ä¸­ï¼Œä»…ä»…æ˜¯ä¸ºäº†è°ƒç”¨ init() å‡½æ•°ï¼Œæ‰€ä»¥æ— æ³•é€šè¿‡åŒ…åæ¥è°ƒç”¨åŒ…ä¸­çš„å…¶ä»–å‡½æ•°å’Œå…¨å±€å˜é‡ã€‚ é¡¹ç›®ç›®å½•ç»“æ„å¦‚ä¸‹ï¼š srcç›®å½• | +--- main.go | +--- helloç›®å½• | +--- hello.go 1 2 3 4 5 6 7 8 9 10 11 // ./src/main.go æ–‡ä»¶ package main import _ \u0026#34;./hello\u0026#34; // è¿™é‡Œå¯¼å…¥ä½¿ç”¨ä¸‹åˆ’çº¿ func main() { // hello.Print() // ç¼–è¯‘æŠ¥é”™ï¼š./main.go:6:5: undefined: hello // Output: // imp-init() come here. } 1 2 3 4 5 6 7 8 9 10 11 12 // ./src/hello/hello.go æ–‡ä»¶ package hello import \u0026#34;fmt\u0026#34; func init() { fmt.Println(\u0026#34;imp-init() come here.\u0026#34;) } func Print() { fmt.Println(\u0026#34;Hello!\u0026#34;) } å…¶ä»–ç¤ºä¾‹ 1 2 3 4 5 6 7 import \u0026#34;database/sql\u0026#34; import _ \u0026#34;github.com/go-sql-driver/mysql\u0026#34; // ç¬¬äºŒä¸ªimportå°±æ˜¯ä¸ç›´æ¥ä½¿ç”¨mysqlåŒ… // 1. åªæ˜¯æ‰§è¡Œä¸€ä¸‹è¿™ä¸ªåŒ…çš„initå‡½æ•° // 2. æŠŠmysqlçš„é©±åŠ¨æ³¨å†Œåˆ°sqlåŒ…é‡Œ // 3. ç„¶åç¨‹åºé‡Œå°±å¯ä»¥ä½¿ç”¨sqlåŒ…æ¥è®¿é—®mysqlæ•°æ®åº“äº† ä¸‹åˆ’çº¿å½“åšå˜é‡ä½¿ç”¨ _ ï¼šå½“åšå˜é‡ä½¿ç”¨ï¼Œè¡¨ç¤ºä¸¢å¼ƒï¼Œæ˜¯åªå†™å˜é‡ï¼Œä¸èƒ½è¯»å–ã€‚ ä¸‹åˆ’çº¿ç”¨ä½œåˆ¤æ–­åˆ‡ç‰‡ä¸‹æ ‡æ˜¯å¦è¶Šç•Œæ—¶ï¼Œ_ = a[3]ï¼Œæœ‰åŠ©äºå¸®åŠ©ç¼–è¯‘å™¨è¿›è¡Œè¾¹ç•Œè¶Šç•Œæ£€æŸ¥ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 package main import ( \u0026#34;os\u0026#34; ) func main() { buf := make([]byte, 1024) // os.Open æ‰“å¼€æ–‡ä»¶ è¿”å›æ–‡ä»¶å¥æŸ„ *os.File å’Œé”™è¯¯ç±»å‹ error f, _ := os.Open(\u0026#34;/Users/***/Desktop/text.txt\u0026#34;) // _è¡¨ç¤ºæŠ›å¼ƒå‡½æ•°è¿”å›çš„err defer f.Close() for { n, _ := f.Read(buf) if n == 0 { break } os.Stdout.Write(buf[:n]) } } ä¸‹åˆ’çº¿åœ¨ç¼–è¯‘åŸç†ä¸­ åœ¨ç¼–è¯‘åŸç†ä¸­è¯­æ³•åˆ†æä¸­ï¼Œåˆ†æconst ()å…³é”®å­—åŒºåˆ†ç»„æ—¶å­˜åœ¨è¿™æ ·ç»“æ„ã€‚ 1 2 3 4 // å–åœ°å€ è¡¨ç¤ºä¸€ç±»åˆ†ç»„åœ°å€ type Group struct { _ int } æ€»ç»“ ä¸‹åˆ’çº¿ç”¨åœ¨importä¸­ï¼Œä»…ä»…æ˜¯æ‰§è¡Œå¯¼å…¥åŒ…çš„æ‰€æœ‰init()å‡½æ•°ã€‚ ä¸‹åˆ’çº¿åœ¨å˜é‡ä¸­ï¼Œè¡¨ç¤ºæŠ›å¼ƒè¯¥å€¼ï¼š ä¸å ç”¨å‘½åç©ºé—´ï¼Œä¸ä¼šåˆ†é…å†…å­˜ã€‚ å¤šæ¬¡ä½¿ç”¨ä¸å­˜åœ¨é‡å¤å£°æ˜é—®é¢˜ã€‚ å¾ˆå¤šæ—¶å€™_ç”¨äºå ä½ï¼Œè¡¨ç¤ºå¿½ç•¥å€¼ã€‚ æˆ‘ä»¬å¯ä»¥æŠŠ_å½“åšæ˜¯ä¸€ä¸ªç³»ç»Ÿå·²ç»å£°æ˜çš„å…¨å±€åªå†™å˜é‡ï¼Œç›´æ¥ä½¿ç”¨å³å¯ï¼Œä¸éœ€è¦åƒ_ := aè¿™ç§å½¢å¼ å‚è€ƒ ä¸ºä»€ä¹ˆæŒ‡é’ˆè¢«èª‰ä¸º C è¯­è¨€çµé­‚ï¼Ÿï¼Œå…³äºæŒ‡é’ˆã€‚ ","permalink":"https://heliu.site/posts/golang/basic/variable/","summary":"Golang å˜é‡çš„å£°æ˜åŠä½¿ç”¨ã€‚","title":"å˜é‡"},{"content":"å¸¸é‡çš„å®šä¹‰åŠä½¿ç”¨ å¸¸é‡æ˜¯ä¸€ä¸ªç®€å•çš„æ ‡è¯†ç¬¦ï¼Œè¿è¡Œæ—¶ä¸ä¼šè¢«ä¿®æ”¹ï¼Œæ²¡ä½¿ç”¨çš„å¸¸é‡åœ¨ç¼–è¯‘æ—¶å€™ä¸ä¼šæŠ¥é”™ï¼ˆå…¨å±€å˜é‡æœªä½¿ç”¨ä¹Ÿä¸ä¼šæŠ¥é”™ï¼‰ã€‚ å¸¸é‡åœ¨å…¶ä»–è¯­è¨€ä¸€èˆ¬å»ºè®®ä½¿ç”¨å…¨å¤§å†™å­—æ¯ï¼Œä½†æ˜¯åœ¨ Go ä¸­å¤§å†™å­—æ¯å¼€å¤´çš„è¡¨ç¤ºå¯å¯¼å‡ºã€‚ å¸¸é‡ä¸­çš„æ•°æ®ç±»å‹åªå¯ä»¥æ˜¯å¸ƒå°”å‹(bool)ã€æ•°å€¼å‹ï¼ˆæ•´æ•°å‹ã€æµ®ç‚¹å‹ã€å¤æ•°ï¼‰å’Œå­—ç¬¦ä¸²å‹(string)ï¼Œä¸èƒ½æ˜¯å¤åˆç±»å‹ã€‚ ä¸èƒ½è·å–å¸¸é‡çš„åœ°å€ï¼ˆä¹Ÿæ²¡å¿…è¦ï¼‰ï¼Œå¦‚ \u0026amp;aï¼Œaä¸ºå¸¸é‡ï¼Œå¸¸é‡é€šå¸¸æ˜¯ä¸ä»£ç ä¸€èµ·è¢«ä¿å­˜åœ¨ä»£ç æ®µã€‚ å­—ç¬¦ä¸²å•ä¸ªå­—ç¬¦ä¹Ÿä¸èƒ½å–åœ°å€å¦‚\u0026amp;s[0](sä¸ºstringç±»å‹)ï¼Œå­—ç¬¦ä¸²æ˜¯åªè¯»ç±»å‹ï¼Œåœ¨è¯­è¨€å±‚é¢é˜»æ­¢ã€‚ æ³¨æ„å­—ç¬¦ä¸²\u0026amp;så’Œ\u0026amp;s[0]ä»£è¡¨çš„ä¸æ˜¯åŒä¸€ä¸ªåœ°å€çš„åŒºåˆ«ã€‚ å­—å…¸çš„å•ä¸ªkeyä¹Ÿä¸èƒ½å–åœ°å€\u0026amp;m[\u0026quot;o\u0026quot;](mä¸ºmapç±»å‹)ï¼Œå­—å…¸ä½¿ç”¨å“ˆå¸Œæ¡¶å½¢å¼å­˜å‚¨ï¼Œä¸€ä¸ªæ¡¶å­˜8ä¸ªkey-valueã€‚ å¸¸é‡çš„å®šä¹‰ const identifier [type] = value constï¼šå®šä¹‰å¸¸é‡å…³é”®å­—ã€‚ identifierï¼šå¸¸é‡åç§°æ ‡è¯†ç¬¦ã€‚ [type]ï¼šç±»å‹ï¼Œå¯é€‰ã€‚ valueï¼šå¸¸é‡å€¼ã€‚ 1 2 // å…³é”®å­— æ ‡è¯†ç¬¦ [ç±»å‹] = å€¼ const identifier [type] = value 1 2 3 4 5 // æŒ‡å®šç±»å‹å¸¸é‡ const IDENTIFIER bool = false // æ˜¾å¼ç±»å‹å®šä¹‰ // æ— ç±»å‹å¸¸é‡ï¼Œæ¨æ–­ç±»å‹è¡Œä¸ºbool const IDENTIFIER = true // éšå¼ç±»å‹å®šä¹‰ å®šä¹‰å¤šä¸ªå¸¸é‡ 1 2 // 1. æ¨æ–­ç±»å‹ Aä¸ºbool Bä¸ºint Cä¸ºstring const A, B, C = true, 52, \u0026#34;golang\u0026#34;\t// å¤šé‡èµ‹å€¼ 1 2 3 4 5 6 // 2. const ( UNKNOWN = 0 // æ¨æ–­ä¸ºintç±»å‹ FEMALE = 1 // æ¨æ–­ä¸ºintç±»å‹ MALE = 2 // æ¨æ–­ä¸ºintç±»å‹ ) 1 2 3 4 5 6 7 // åŒæ—¶å£°æ˜å¤šä¸ªå¸¸é‡æ—¶ï¼Œå¦‚æœçœç•¥äº†å€¼åˆ™è¡¨ç¤ºå’Œä¸Šé¢ä¸€è¡Œçš„å€¼ç›¸åŒ const ( A uint16 = 255 // 255 B // 255 C = \u0026#34;hello\u0026#34; // hello D // hello ) æ— ç±»å‹å¸¸é‡ æ²¡æœ‰æŒ‡æ˜å¸¸é‡ç±»å‹çš„å¸¸é‡ã€‚const PI = 3.14159 æ— ç±»å‹å¸¸é‡å…·æœ‰é»˜è®¤ç±»å‹ï¼Œè¯¥ç±»å‹åœ¨éœ€è¦ç±»å‹åŒ–å€¼å¾—ä¸Šä¸‹æ–‡ä¸­éšå¼è½¬æ¢å¸¸é‡çš„ç±»å‹ï¼š åœ¨ç®€å¼å£°æ˜ä¸­ï¼ši := 0 æ²¡æœ‰æ˜¾ç¤ºç±»å‹ï¼Œè¿™ä¸å˜é‡çš„æ— ç±»å‹å£°æ˜ä¸åŒã€‚ æ— ç±»å‹å¸¸é‡çš„é»˜è®¤ç±»å‹åˆ†åˆ«æ˜¯ boolã€runeã€intã€float64ã€comolex128æˆ–stringã€‚ å…·ä½“å†³å®šäºå®ƒæ˜¯å¸ƒå°”å€¼ã€å­—ç¬¦ã€æ•´æ•°ã€æµ®ç‚¹æ•°ã€å¤æ•°è¿˜æ˜¯å­—ç¬¦ä¸²ã€‚ å¸¸é‡çš„å€¼å¿…é¡»æ˜¯åœ¨ç¼–è¯‘æ—¶å°±èƒ½ç¡®å®šçš„ã€‚ å¯ä»¥åœ¨èµ‹å€¼è¡¨è¾¾å¼ä¸­æ¶‰åŠè®¡ç®—è¿‡ç¨‹ï¼Œä½†æ˜¯æ‰€æœ‰ç”¨äºè®¡ç®—çš„å€¼å¿…é¡»åœ¨ç¼–è¯‘æœŸé—´å°±èƒ½è·å¾—ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 package main import ( \u0026#34;fmt\u0026#34; ) func main() { const a = 5 // æ— ç±»å‹å¸¸é‡åœ¨ä½¿ç”¨æ—¶æ ¹æ®ä¸Šä¸‹æ–‡è¯­å¢ƒè½¬æ¢ var intVar int = a var int32Var int32 = a var float64Var float64 = a var complex64Var complex64 = a fmt.Println(intVar, int32Var, float64Var, complex64Var) // 5 5 5 (5+0i) const aa = 5.0 var intVV int = aa // æµ®ç‚¹æ•°ä¸èƒ½é»˜è®¤è½¬intç±»å‹ fmt.Println(intVV) // 5 //const aaa = 5.1 //var intVVV int = aaa // constant 5.1 truncated to integer //fmt.Println(intVVV) } iota ç‰¹æ®Šå¸¸é‡ï¼Œå¯ä»¥è¢«ç¼–è¯‘å™¨ä¿®æ”¹çš„å¸¸é‡ã€‚ æ¯é‡åˆ°constå…³é”®å­—ï¼Œiotaå°†è¢«é‡ç½®ä¸º0ã€‚ æ¯å½“ iota åœ¨æ–°çš„ä¸€è¡Œè¢«ä½¿ç”¨æ—¶ï¼Œiotaä¼šè‡ªåŠ¨åŠ ä¸€ï¼Œiota++ã€‚å…¶å®å¹¶ä¸æ˜¯iotaåœ¨æ–°çš„ä¸€è¡Œä¸­å‡ºç°å°±ä¼šåŠ ä¸€ï¼Œä¸å‡ºç°ä¹Ÿä¼šè‡ªå¢ã€‚ ã€iotaçš„å‡†ç¡®å®šä¹‰æ˜¯ã€‘ï¼šiotaè¡¨ç¤ºconstå£°æ˜å—çš„è¡Œç´¢å¼•ï¼ˆä¸‹æ ‡ä»0å¼€å§‹ï¼‰ï¼Œè§£é‡Šå°±æ˜¯iotaè¡¨ç¤ºå½“å‰constçš„è¡Œå·ï¼Œä¸ç®¡ä½¿ç”¨æ²¡ä½¿ç”¨iotaã€‚ ã€constè¿˜æœ‰ä¸€ä¸ªé‡è¦çš„ç‰¹ç‚¹æ˜¯ã€‘ï¼šç¬¬ä¸€ä¸ªå¸¸é‡å¿…é¡»æŒ‡å®šä¸€ä¸ªè¡¨è¾¾å¼ï¼Œåç»­çš„å¸¸é‡å¦‚æœæ²¡æœ‰è¡¨è¾¾å¼ï¼Œåˆ™ç»§æ‰¿ä¸Šé¢çš„è¡¨è¾¾å¼ã€‚ iotaä½¿ç”¨ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 const ( A = iota // 0 (iota == 0)\tB = iota // 1 (iota == 1) C = iota // 2 (iota == 2) ) const ( AA = iota // 0 (iota == 0) BB // 1 (iota == 1) ç­‰æ•ˆäº BB = iota CC // 2 (iota == 2) ç­‰æ•ˆäº CC = iota ) // ä¸ç®¡contsä¸­æ˜¯å¦æœ‰ä½¿ç”¨iotaï¼Œéƒ½æ˜¯æŒ‰ç…§è¡Œå·é€’å¢çš„ const ( one = 3 // 3 (iota == 0) two = iota // 1 (iota == 1) three = iota // 2 (iota == 2) four // 3 (iota == 3) five // 4 (iota == 4) ) type CAPACITY uint const ( B CAPACITY = 1 \u0026lt;\u0026lt; (iota * 10)// 1 == 2^0 (iota == 0) // ç­‰æ•ˆäº KB CAPACITY = 1 \u0026lt;\u0026lt; (iota * 10) KB // 1024 == 2^10 (iota == 1) // ç­‰æ•ˆäº MB CAPACITY = 1 \u0026lt;\u0026lt; (iota * 10) MB // 1024 * 1024 = 2^20 (iota == 2) ) const ( D1 = iota // 0 (iota == 0) D2 // 1 (iota == 1) ç­‰æ•ˆäº D2 = iota D3 // 2 (iota == 2) ç­‰æ•ˆäº D3 = iota D4 // 3 (iota == 3) ç­‰æ•ˆäº D4 = iota D5 = \u0026#34;HELLO\u0026#34; // HELLO (iota == 4) D6 // HELLO (iota == 5) ç­‰æ•ˆäº D6 = \u0026#34;HELLO\u0026#34; D7 = 23 // 23 (iota == 6)\tD8 // 23 (iota == 7) ç­‰æ•ˆäº D7 = 23 D9 = iota // 8 (iota == 8) D10 // 9 (iota == 9) ç­‰æ•ˆäº D10 = iota ) const ( D1, D2 = 1 \u0026lt;\u0026lt; iota, 1 \u0026lt;\u0026lt; iota - 1 // 1 0 iota == 0\t00000001 \u0026lt;\u0026lt; 0 == 0 , 00000001 \u0026lt;\u0026lt; 0 - 1 == 0 // ç­‰æ•ˆäº D3, D4 = 1 \u0026lt;\u0026lt; iota, 1 \u0026lt;\u0026lt; iota - 1 D3, D4 // 2 1 iota == 1\t00000001 \u0026lt;\u0026lt; 1 == 2 , 00000001 \u0026lt;\u0026lt; 1 - 1 == 1 // ç­‰æ•ˆäº D5, D6 = 1 \u0026lt;\u0026lt; iota, 1 \u0026lt;\u0026lt; iota - 1 D5, D6 // 4 3 iota == 2\t00000001 \u0026lt;\u0026lt; 2 == 4 , 00000001 \u0026lt;\u0026lt; 2 - 1 == 3 ) å‚è€ƒ Goé«˜é˜¶æŒ‡å—05ï¼Œiota å®ç°åŸç† ","permalink":"https://heliu.site/posts/golang/basic/const/","summary":"Golang å¸¸é‡çš„å®šä¹‰åŠä½¿ç”¨ã€‚","title":"å¸¸é‡"},{"content":"åŸºæœ¬è¿ç®—ç¬¦ ç®—æ•°è¿ç®—ç¬¦ é€‚ç”¨äºæ•°å€¼ç±»å‹ï¼Œè¿ç®—ç»“æœç±»å‹ä¸é™¤æ•°ç±»å‹ä¸€è‡´ã€‚ï¼ˆé™¤æ•°æ˜¯æµ®ç‚¹æ•°ç»“æœä¸ºæµ®ç‚¹æ•°ï¼Œé™¤æ•°ä¸ºæ•´æ•°ç»“æœä¸ºæ•´æ•°ï¼‰ æ±‚ä½™ï¼ˆ%ï¼‰è¿ç®—ç»“æœç¬¦å·ä¸é™¤æ•°ç¬¦å·ä¸€è‡´ï¼ˆé™¤æ•°æ˜¯è´Ÿæ•°ç»“æœç¬¦å·ä¸ºè´Ÿæ•°ï¼‰ã€‚ è¿ç®—ç¬¦ æè¿° é€‚ç”¨èŒƒå›´ ç¤ºä¾‹ + åŠ æ³•è¿ç®—ç¬¦æˆ–å­—ç¬¦ä¸²æ‹¼æ¥ç¬¦ é€‚ç”¨äºæ•´æ•°ã€æµ®ç‚¹æ•°ã€å¤æ•°ã€å­—ç¬¦ä¸² 5 + 3 = 8 - å‡æ³•è¿ç®—ç¬¦ é€‚ç”¨äºæ•´æ•°ã€æµ®ç‚¹æ•°ã€å¤æ•° 5 - 3 = 2 * ä¹˜æ³•è¿ç®—ç¬¦ é€‚ç”¨äºæ•´æ•°ã€æµ®ç‚¹æ•°ã€å¤æ•° 5 * 3 = 15 / é™¤æ³•è¿ç®—ç¬¦ é€‚ç”¨äºæ•´æ•°ã€æµ®ç‚¹æ•°ã€å¤æ•° 5 / 2 = 2 % æ±‚ä½™è¿ç®— é€‚ç”¨äºæ•´æ•°ï¼ˆæœ‰ç¬¦å·ã€æ— ç¬¦å·ï¼‰ -5 % 2 = -1ï¼Œ-5 % -2 = -1ï¼Œ5 % 2 = 1 ++ è‡ªå¢ é€‚ç”¨äºæ•´æ•°ï¼ˆæœ‰ç¬¦å·ã€æ— ç¬¦å·ï¼‰ a++ -- è‡ªå‡ é€‚ç”¨äºæ•´æ•°ï¼ˆæœ‰ç¬¦å·ã€æ— ç¬¦å·ï¼‰ a-- å˜é‡ å˜é‡ å•† å–ä½™ x y x/y x%y 5 3 1 2 -5 3 -1 -2 5 -3 -1 2 -5 -3 1 -2 å…³ç³»è¿ç®—ç¬¦ åŒç›®è¿ç®—ç¬¦ä½œæ¯”è¾ƒï¼Œç»“æœä¸ºå¸ƒå°”å€¼ã€‚ è¿ç®—ç¬¦ å«ä¹‰ ç¤ºä¾‹ï¼ˆA å°äº Bï¼‰ == ç­‰äº A == B false != ä¸ç­‰äº A != B true \u0026gt; å¤§äº A \u0026gt; B false \u0026lt; å°äº A \u0026lt; B true \u0026gt;= å¤§äºç­‰äº A \u0026gt;= B false \u0026lt;= å°äºç­‰äº A \u0026lt;= B true é€»è¾‘è¿ç®—ç¬¦ åŒç›®è¿ç®—ç¬¦ï¼Œå¤„ç†å·¦å³å¸ƒå°”å€¼ã€‚ è¿ç®—ç¬¦ æè¿° ç¤ºä¾‹ \u0026amp;\u0026amp; é€»è¾‘ä¸è¿ç®—ç¬¦ï¼ˆå·¦å³ä¸¤è¾¹éƒ½ä¸ºtrueè¿”å›trueï¼Œå¦åˆ™è¿”å›falseï¼‰ (true \u0026amp;\u0026amp; false) == false || é€»è¾‘æˆ–è¿ç®—ç¬¦ï¼ˆå·¦å³ä¸¤è¾¹éƒ½ä¸ºfalseè¿”å›falseï¼Œå¦åˆ™è¿”å›trueï¼‰ (false || false) == false ! é€»è¾‘éè¿ç®—ç¬¦ï¼ˆä¸€ä½è¿ç®—ç¬¦trueå–åä¸ºfalseï¼Œfalseå–åä¸ºtrueï¼‰ !true == false ä½è¿ç®—ç¬¦ æ“ä½œäºŒè¿›åˆ¶æ•°ã€‚ è¿ç®—ç¬¦ å«ä¹‰ \u0026amp; æŒ‰ä¸ºä¸ï¼ŒåŒç›®è¿ç®—ç¬¦ã€‚å‚ä¸è¿ç®—çš„ä¸¤æ•°å„å¯¹åº”çš„ä½ç›¸ä¸ï¼ˆåŒ1å¾—1ï¼‰ | æŒ‰ä¸ºæˆ–ï¼ŒåŒç›®è¿ç®—ç¬¦ã€‚å‚ä¸è¿ç®—çš„ä¸¤æ•°å„å¯¹åº”çš„ä½ç›¸æˆ–ï¼ˆæœ‰1å¾—1ï¼‰ ^ æŒ‰ä¸ºå¼‚æˆ–ï¼ŒåŒç›®è¿ç®—ç¬¦ã€‚å‚ä¸è¿ç®—çš„ä¸¤æ•°å„å¯¹åº”çš„ä½å¼‚æˆ–ï¼ˆç›¸åŒå¾—0ï¼‰æˆ– ^ä½œä¸ºä¸€å…ƒè¿ç®—ç¬¦æ˜¯æŒ‰ä½å–å \u0026laquo; å·¦ç§»è¿ç®—ç¬¦ï¼ŒåŒç›®è¿ç®—ç¬¦ã€‚æŠŠå·¦è¾¹çš„è¿ç®—æ•°çš„å„ä½å…¨éƒ¨å·¦ç§»è‹¥å¹²ä½ï¼Œé«˜ä½ä¸¢å¼ƒï¼Œä½ä½è¡¥0 \u0026raquo; å³ç§»è¿ç®—ç¬¦ï¼ŒåŒç›®è¿ç®—ç¬¦ã€‚æŠŠå³è¾¹çš„è¿ç®—æ•°çš„å„ä½å…¨éƒ¨å·¦ç§»è‹¥å¹²ä½ å˜é‡1 å˜é‡2 ä¸è¿ç®— æˆ–è¿ç®— å¼‚æˆ–è¿ç®— p q p\u0026amp;q p|q p^q 0 0 0 0 0 0 1 0 1 1 1 1 1 1 0 1 0 0 1 1 å˜é‡1 å˜é‡2 å·¦ç§»è¿ç®— å³ç§»è¿ç®— p q p\u0026lt;\u0026lt;q p\u0026gt;\u0026gt;q 00001101 3 01101000 00000001 èµ‹å€¼è¿ç®—ç¬¦ è¿ç®—ç¬¦ å«ä¹‰ ç¤ºä¾‹ = èµ‹å€¼è¿ç®—ç¬¦ += ç›¸åŠ åå†èµ‹å€¼ C += A ç­‰äº C = C + A -= ç›¸å‡åå†èµ‹å€¼ C -= A ç­‰äº C = C - A *= ç›¸ä¹˜åå†èµ‹å€¼ C *= A ç­‰äº C = C * A /= ç›¸é™¤åå†èµ‹å€¼ C /= A ç­‰äº C = C / A %= æ±‚ä½™åå†èµ‹å€¼ C %= A ç­‰äº C = C % A \u0026lt;\u0026lt;= å·¦ç§»åå†èµ‹å€¼ C \u0026lt;\u0026lt;= 2 ç­‰äº C = C \u0026lt;\u0026lt; 2 \u0026gt;\u0026gt;= å³ç§»åå†èµ‹å€¼ C \u0026gt;\u0026gt;= 2 ç­‰äº C = C \u0026gt;\u0026gt; 2 \u0026amp;= æŒ‰ä½ä¸åèµ‹å€¼ C \u0026amp;= 2 ç­‰äº C = C \u0026amp; 2 ^= æŒ‰ä½å¼‚æˆ–åèµ‹å€¼ C ^= 2 ç­‰äº C = C ^ 2 |= æŒ‰ä½æˆ–åèµ‹å€¼ C |= 2 ç­‰äº C = C | 2 æŒ‡é’ˆè¿ç®—ç¬¦ è¿ç®—ç¬¦ å«ä¹‰ å®ä¾‹ \u0026amp; è¿”å›å˜é‡å­˜å‚¨åœ°å€ \u0026amp;a å°†è¾“å‡ºå˜é‡çš„å®é™…åœ°å€ * æŒ‡é’ˆå˜é‡ *a æ˜¯ä¸€ä¸ªæŒ‡é’ˆå˜é‡ Goè¯­è¨€è¿ç®—ç¬¦æ±‡æ€» è¿ç®—ç¬¦ è¿ç®—ç¬¦ è¿ç®—ç¬¦ è¿ç®—ç¬¦ è¿ç®—ç¬¦ + \u0026amp; += \u0026amp;= \u0026amp;\u0026amp; - | -= |= || * ^ *= ^= \u0026lt;- / \u0026laquo; /= \u0026laquo;= ++ % \u0026raquo; || \u0026raquo;= \u0026ndash; == \u0026lt; \u0026gt; = ! != \u0026lt;= \u0026gt;= := \u0026hellip; ( [ { , . ) ] } ; : \u0026amp;^ \u0026amp;^= è¿ç®—ç¬¦ä¼˜å…ˆçº§ ä¸€å…ƒè¿ç®—ç¬¦å…·æœ‰æœ€é«˜ä¼˜å…ˆçº§ã€‚ï¼ˆ++å’Œ--è¿ç®—ç¬¦æ˜¯å½¢æˆè¯­å¥è€Œä¸æ˜¯è¡¨è¾¾å¼ï¼Œæ‰€ä»¥ä»–ä»¬ä¸å±äºè¿ç®—ç¬¦å±‚æ¬¡ç»“æ„ï¼Œè¯­å¥*p++ä¸(*p)++ç›¸åŒï¼‰ äºŒå…ƒè¿ç®—ç¬¦æœ‰äº”ä¸ªå±‚æ¬¡ç»“æ„ï¼Œå¦‚ä¸‹ä¼˜å…ˆçº§æ•°å­—è¶Šå¤§è¡¨ç¤ºä¼˜å…ˆçº§è¶Šé«˜ã€‚ å¯ä»¥ä½¿ç”¨()æ¥ä¸´æ—¶æé«˜ä¼˜å…ˆçº§ã€‚ ä¼˜å…ˆçº§ è¿ç®—ç¬¦ 5 * / % \u0026lt;\u0026lt; \u0026gt;\u0026gt; \u0026amp; \u0026amp;^ 4 + - | ^ 3 == != \u0026lt; \u0026lt;= \u0026gt; \u0026gt;= 2 \u0026amp;\u0026amp; 1 || ç‰¹æ®Šè¿ç®—ç¬¦ ä½æ¸…é™¤ \u0026amp;^ å°†æŒ‡å®šä½ç½®ä¸Šçš„å€¼è®¾ç½®ä¸º0ã€‚å°†è¿ç®—ç¬¦å·¦è¾¹æ•°æ®ç›¸å¼‚çš„ä½ä¿ç•™ï¼Œç›¸åŒä½æ¸…é›¶ã€‚ å¦‚æœYæŸä½ä¸Šçš„æ•°æ˜¯0ï¼Œåˆ™å–Xä¸Šå¯¹åº”ä½ç½®çš„å€¼ã€‚å¦‚æœYæŸä½ä¸Šä¸º1ï¼Œåˆ™ç»“æœä½ä¸Šå–0ã€‚ å¦‚æœå³ä¾§æ˜¯0ï¼Œåˆ™å·¦ä¾§æ•°ä¿æŒä¸å˜ã€‚ å¦‚æœå³ä¾§æ˜¯1ï¼Œåˆ™å·¦ä¾§æ•°ä¸€å®šæ¸…é›¶ã€‚ åŠŸèƒ½ä¸a\u0026amp;(^b)ç›¸åŒã€‚ X = 0b0000_0010 // 0000 0010 Y = 0b0000_0100 // 0000 0100 X \u0026amp;^ Y == X \u0026amp; (^Y) // 0000 0010 1 2 3 4 5 6 7 8 // ç›¸å¼‚çš„ä¿ç•™ï¼Œç›¸åŒä½æ¸…é›¶ // a \u0026amp;^ b // å¦‚æœå³ä¾§(a)ä½æ˜¯0ï¼Œåˆ™å·¦ä¾§æ•°ä¿æŒä¸å˜ // å¦‚æœå³ä¾§(a)ä¸ºæ˜¯1ï¼Œåˆ™å·¦ä¾§æ•°ä¸€å®šæ¸…é›¶ { // æ¸…é™¤açš„ç¬¬7ä½ a \u0026amp;^ (1\u0026lt;\u0026lt;7) // 10000000 128 } ^ å¼‚æˆ–ï¼ˆXORï¼‰ åœ¨Goè¯­è¨€ä¸­XORæ˜¯ä½œä¸ºäºŒå…ƒè¿ç®—ç¬¦å­˜åœ¨ã€‚å¦‚æœä½œä¸ºä¸€å…ƒè¿ç®—ç¬¦å‡ºç°ï¼Œæ„æ€æ˜¯æŒ‰ä½å–åã€‚ ä½œä¸ºäºŒå…ƒè¿ç®—ç¬¦ï¼ŒXORæ˜¯ä¸è¿›ä½åŠ æ³•è®¡ç®—ï¼Œä¹Ÿå°±æ˜¯å¼‚æˆ–è¿ç®—ã€‚ è®¾ç½®ç¬¬nä½ä¸º1 1 2 3 4 5 { var a uint8 a = a | (1 \u0026lt;\u0026lt; 7) // 10000000 } è®¾ç½®ç¬¬nä½ä¸º0 \u0026amp;^ï¼šæ¸…é›¶æŸä½ã€‚ 1 2 3 4 5 { var a uint8 = 0b0010_0001 a = a \u0026amp;^ (1 \u0026lt;\u0026lt; 5) // 1 } ","permalink":"https://heliu.site/posts/golang/basic/operator/","summary":"Golang ç›¸å…³çš„è¿ç®—ç¬¦ä»‹ç»ã€‚","title":"è¿ç®—ç¬¦"},{"content":" å­—é¢é‡æ˜¯æŒ‡ç”±å­—æ¯ã€æ•°å­—ç­‰æ„æˆçš„å­—ç¬¦ä¸²æˆ–æ•°å€¼ï¼Œå®ƒåªèƒ½ä½œä¸ºå³å€¼å‡ºç°ã€‚ æ•´æ•°å­—é¢é‡ è¡¨ç¤ºæ•´æ•°å¸¸é‡çš„æ•°å­—åºåˆ—ã€‚ 42 // åè¿›åˆ¶ 0600 // å…«è¿›åˆ¶ 6*8^2 + 0*8^1 + 0*8^0 oxBadFace // åå…­è¿›åˆ¶ 11*16^6 + 10*16^5 + ... ob11110000 // äºŒè¿›åˆ¶ ob1111_0000 // äºŒè¿›åˆ¶ 1 2 3 4 5 6 7 8 func Example() { var o int = 067 // 6*8+7 var ox int = 0xBa77 // 11*16^3 + 10*16^2 + 7*16 + 7 fmt.Println(o, ox) // Output: // 55 47735 } æµ®ç‚¹æ•°å­—é¢é‡ æµ®ç‚¹å¸¸é‡çš„åè¿›åˆ¶è¡¨ç¤ºã€‚ ç§‘å­¦è®¡æ•°æ³•ï¼šä¸€ä¸ªæ•´æ•°éƒ¨åˆ†ã€ä¸€ä¸ªå°æ•°ç‚¹ã€ä¸€ä¸ªå°æ•°éƒ¨åˆ†å’Œä¸€ä¸ªæŒ‡æ•°éƒ¨åˆ†ã€‚ 0. // 0 72.40 // 72.4 072.40 // 72.4 2.712 1.e+0 6.654e-11 // ç§‘å­¦è®¡æ•°æ³• 6.654 * 10^-11 1E6\t.25 // 0.25 .12345E+5 // 0.12345E+5 1 2 3 4 5 6 7 func Example() { a, b, c, d := 0., 072.40, 1.e+0, .1254E+5 fmt.Println(a, b, c, d) // Output: // 0 72.4 1 12540 } è™šæ•°å­—é¢é‡ è™šæ•°å­—é¢é‡æ˜¯å¤æ•°å¸¸æ•°çš„è™šæ•°çš„åè¿›åˆ¶è¡¨ç¤ºã€‚ 0i 011i // 11i 0.1 2.2454i 1.e+0i 6.67e-11i 1E6i .25i 1 2 3 4 5 6 7 func Example() { a, b, c, d := 0i, 011i, 0.1, 6.67e-11i fmt.Println(a, b, c, d) // Output: // (0+0i) (0+11i) 0.1 (0+6.67e-11i) } Runeå­—é¢é‡ Rune åˆ«å é•¿åº¦ èŒƒå›´ rune int32 4B -2147483648 ~ 2147483647 Runeå­—é¢é‡æ˜¯æ ‡è¯†Unicodeä»£ç ç‚¹çš„æ•´æ•°å€¼ã€‚ï¼ˆUnicodeæ˜¯å®šé•¿ä¸¤ä¸ªå­—èŠ‚ï¼‰ Runeå­—é¢é‡è¡¨ç¤ºç”¨å•å¼•å·æ‹¬èµ·æ¥çš„ä¸€ä¸ªæˆ–å¤šä¸ªå­—ç¬¦ã€‚'x'æˆ–'\\n'ã€‚ å•å¼•å·å­—ç¬¦è¡¨ç¤ºå­—ç¬¦æœ¬èº«çš„Unicodeå€¼ã€‚è€Œä»¥åæ–œæ å¼€å¤´çš„å­—ç¬¦åºåˆ—è¡¨ç¤ºå„ç§æ ¼å¼ç¼–ç å€¼ã€‚ Goæºç æ˜¯ä»¥UTF-8ç¼–ç çš„Unicodeå­—ç¬¦ï¼Œå› æ­¤å¤šä¸ªUTF-8ç¼–ç çš„å­—èŠ‚å¯ä»¥è¡¨ç¤ºå•ä¸ªæ•´æ•°å€¼ã€‚ 'a'è¡¨ç¤ºæ˜¯açš„å•ä¸ªå­—èŠ‚ï¼ŒUnicode U+0061ï¼Œå€¼ä¸º0x61ã€‚ \u0026ldquo;å¥½\u0026rdquo; ç¼–ç 0x597dåŒ…å«ä¸¤ä¸ªå­—èŠ‚ ï¼ŒU+00E4å€¼ä¸º0xe4ã€‚ å°†æ•´æ•°å€¼è¡¨ç¤ºä¸ºæ•°å­—å¸¸é‡ã€‚ \\xåè·Ÿæ°å¥½ä¸¤ä¸ªåå…­è¿›åˆ¶æ•°å­—\\x00 ~ \\xff (0 ~ 255) 1B (2^8)\t1å­—èŠ‚ã€‚ \\uåè·Ÿæ°å¥½å››ä¸ªåå…­è¿›åˆ¶æ•°å­—\\u0000 ~ \\uffff (0 ~ 65535) 2B (2^16) 2å­—èŠ‚ã€‚ \\Uåè·Ÿæ°å¥½å…«ä¸ªåå…­è¿›åˆ¶æ•°å­—\\U00000000 ~ \\Uffffffff (0 ~ 4294967295) 4B 4å­—èŠ‚ã€‚ \\ åè·Ÿæ°å¥½ä¸‰ä¸ªå…«è¿›åˆ¶æ•°å­—\\000 ~ \\777 (0 ~ 511)ã€‚ Unicode æœ€å¤§å€¼ 0x10FFF 69631ã€‚ \u0026#39;a\u0026#39; \u0026#39;ç¬¨\u0026#39; \u0026#39;\\t\u0026#39; \u0026#39;\\000\u0026#39; \u0026#39;\\007\u0026#39; \u0026#39;\\xff\u0026#39; \u0026#39;\\u12e4\u0026#39; \u0026#39;\\U00101234\u0026#39; \u0026#39;aa\u0026#39; // éæ³• å¤šä¸ªå­—ç¬¦ \u0026#39;\\xa\u0026#39; // éæ³• åå…­è¿›åˆ¶æ•°å­—å¤ªå°‘ \u0026#39;\\0\u0026#39; // éæ³•å…«è¿›åˆ¶æ•°å­—ä¸æ­£ç¡® \u0026#39;\\U001000000\u0026#39; // éæ³• æ— æ•ˆçš„Unicodeä»£ç ç‚¹ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 func Example() { // rune = int32 // byte = uint8 var a rune = \u0026#39;\\n\u0026#39; var b rune = \u0026#39;å¥½\u0026#39; var c byte = \u0026#39;\\007\u0026#39; var d rune = \u0026#39;\\xff\u0026#39; var e rune = \u0026#39;\\u12e4\u0026#39; fmt.Println(a, b, c, d, e) fmt.Printf(\u0026#34;%c %c %c %c %c\u0026#34;, a, b, c, d, e) // Output: // 10 22909 7 255 4836 // // å¥½ Ã¿ á‹¤ } å­—ç¬¦ä¸²å­—é¢é‡ åŸå§‹å­—ç¬¦ä¸²å­—é¢é‡ï¼šåå¼•å·ä¹‹é—´çš„å­—ç¬¦åºåˆ—ã€‚ è§£é‡Šçš„å­—ç¬¦ä¸²ï¼šåŒå¼•å·ä¹‹é—´çš„å­—ç¬¦åºåˆ—ã€‚ åœ¨åŒå¼•å·å†…ï¼Œé™¤äº†æ¢è¡Œç¬¦å’Œæœªè½¬ä¹‰çš„åŒå¼•å·å¤–ï¼Œä»»ä½•å­—ç¬¦éƒ½å¯ä»¥å‡ºç°ã€‚ å¼•å·ä¹‹é—´çš„æ–‡æœ¬å½¢æˆæ–‡å­—çš„runeå€¼ï¼Œåæ–œæ è½¬ä¹‰ç¬¦è¢«è§£é‡Šä¸ºç¬¦æ–‡(rune)ã€‚ `abc` // \u0026#34;abc\u0026#34; `\\n \\n` // \u0026#34;\\\\n\\n\\\\n\u0026#34; \u0026#34;\\n\u0026#34;\t\u0026#34;\\\u0026#34;\u0026#34; // `\u0026#34;` \u0026#34;Hello,World!\\n\u0026#34; \u0026#34;æ´’æ°´\u0026#34; \u0026#34;\\u65e5 æœ¬\\U00008a9e\u0026#34; \u0026#34;\\xff\\u00FF\u0026#34; ","permalink":"https://heliu.site/posts/golang/basic/literal/","summary":"Golang ç›¸å…³å­—é¢é‡ä»‹ç»ã€‚","title":"å­—é¢é‡"},{"content":"Go å†…ç½®ç±»å‹çš„é›¶å€¼ å½“ä¸€ä¸ªå˜é‡è¢«varå£°æ˜ä¹‹åï¼Œå¦‚æœæ²¡æœ‰ä¸ºå…¶æ˜ç¡®æŒ‡æ˜åˆå§‹å€¼ï¼ŒGoè¯­è¨€ä¼šè‡ªåŠ¨åˆå§‹åŒ–å…¶å€¼ä¸ºæ­¤ç±»å‹å¯¹åº”çš„é›¶å€¼ã€‚ ç±»å‹ é›¶å€¼ integer æ•´æ•°ç±»å‹ï¼ŒåŒ…æ‹¬çš„byteå’Œrune 0 uintptr æ•´æ•°ç±»å‹ 0 float æµ®ç‚¹æ•°ç±»å‹ 0.0 bool å¸ƒå°”å€¼ç±»å‹ false string å­—ç¬¦ä¸²ç±»å‹ ç©ºå­—ç¬¦ä¸²\u0026quot;\u0026quot; complex å¤æ•°ç±»å‹ 0+0i *T æŒ‡é’ˆç±»å‹ nil interfaceã€errorã€functionã€mapã€sliceã€channel nil uintptrçš„é»˜è®¤å€¼ uintptræ˜¯æ•´æ•°ç±»å‹ä¸æ˜¯æŒ‡é’ˆï¼Œè¯¥ç±»å‹åªæ˜¯ç”¨äºæŒ‡é’ˆåœ°å€åšåç§»è¿ç®—ã€‚ 1 2 3 4 5 6 7 8 9 10 11 package main func main() { var s uintptr // 0 if s == 0 { print(123) } // Output: // 123 } nilé›¶å€¼ 1 2 3 4 5 6 7 8 9 10 11 12 package main import ( //\u0026#34;fmt\u0026#34; ) func main() { // æ­¤å¤„ç¼–è¯‘ä¸é€šè¿‡ï¼Œnilèµ‹å€¼ç»™xï¼Œç¼–è¯‘å™¨åˆ¤æ–­ä¸å‡ºå…·ä½“ç±»å‹ var x = nil\t// use of untyped nil _ = x } åœ¨ä¸€ä¸ªnilçš„åˆ‡ç‰‡ä¸­æ·»åŠ å…ƒç´ æ˜¯æ²¡æœ‰é—®é¢˜çš„ã€‚ å› ä¸ºnilçš„åˆ‡ç‰‡å¹¶æ²¡ç”¨åˆ†é…å†…å­˜ï¼Œä½†æ˜¯æ·»åŠ å…ƒç´ å¿…é¡»ä½¿ç”¨appendå‡½æ•°ï¼Œè¯¥å‡½æ•°ä¼šåˆå§‹åŒ–nilçš„åˆ‡ç‰‡ã€‚ï¼ˆåŸå› æ˜¯ä¼šå¯¼è‡´æ‰©å®¹ä»æ–°åˆ†é…å†…å­˜ï¼‰ ä½†æ˜¯å¯¹ä¸€ä¸ªå­—å…¸åšåŒæ ·çš„äº‹å°†å‘ç”Ÿå¼‚å¸¸ã€‚ nilçš„mapå¹¶æ²¡æœ‰åˆ†é…å†…å­˜ï¼Œmapæ·»åŠ å…ƒç´ æ˜¯ç›´æ¥map[x] = xå½¢å¼ï¼Œæ‰€ä»¥ä¼šæŠ¥é”™è¯¯ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 package main import ( \u0026#34;fmt\u0026#34; ) func main() { // type sliceStruct struct {pointer, len, cap} // data=nil len=0 cap=0 var a []string // nil // æ³¨æ„ ä¸ a := []string{} çš„åŒºåˆ«ï¼Œè¿™ç§æ˜¯å·²ç»åˆå§‹åŒ–è¿‡çš„ä¹Ÿå°±æ˜¯ç³»ç»Ÿé»˜è®¤è°ƒç”¨è¿‡makeæ–¹æ³•å…¶é›¶å€¼ä¸ä¸ºnil // æ›´å¤š var a []string å’Œ a := []string{} å½¢å¼å°†åœ¨åˆ‡ç‰‡ä¸€èŠ‚ä¸­è®¨è®º // append ä¼šåˆå§‹åŒ–a a1 := append(a, \u0026#34;s\u0026#34;) fmt.Println(a, a1) // [] [s] //var m map[string]int //m[\u0026#34;one\u0026#34;] = 1 // panic: assignment to entry in nil map // data len // makeä¼šåˆå§‹åŒ– var m1 map[string]int = make(map[string]int, 2) m1[\u0026#34;one\u0026#34;] = 1 fmt.Println(m1)\t// map[one:1] var ss *string = new(string) *ss = \u0026#34;abc\u0026#34; fmt.Println(ss, *ss) // 0xc000088260 abc // panic: runtime error: invalid memory address or nil pointer dereference //var s *int // æ­¤æ—¶sçš„é»˜è®¤å€¼ä¸ºnilï¼Œ*så¹¶æ²¡æœ‰åˆ†é…å†…å­˜ //*s = 10 // æŠ¥é”™ s å¹¶æ²¡æœ‰åˆ†é…å†…å­˜ç©ºé—´ } æ³¨æ„nilç”¨äºçš„ç±»å‹ï¼š nilæ˜¯ä¸€ä¸ªé¢„å…ˆå£°æ˜çš„æ ‡è¯†ç¬¦ï¼Œè¡¨ç¤ºaçš„é›¶å€¼ pointer, channel, func, interface, map, or slice typeã€‚ ç±»å‹å¿…é¡»æ˜¯ pointer, channel, func, interface, map, or slice type. 1 2 var s string = \u0026#34;hello,world\u0026#34; c := s[0] // cçš„ç±»å‹ä¸º byte ä¹Ÿå°±æ˜¯ uint8 ","permalink":"https://heliu.site/posts/golang/basic/zero/","summary":"Golang ç±»å‹çš„é»˜è®¤é›¶å€¼ã€‚","title":"ç±»å‹é›¶å€¼"},{"content":"å±€éƒ¨å˜é‡ä¸å…¨å±€å˜é‡ å±€éƒ¨å˜é‡ï¼šå‡½æ•°ä½“å†…ã€ä»£ç å—å†…ã€å‚æ•°(å‡½æ•°å‚æ•°å’Œæ¥æ”¶å™¨å‚æ•°)å’Œè¿”å›å€¼å˜é‡ã€‚ åœ¨å‡½æ•°ä½“æˆ–ä»£ç å—å†…å£°æ˜çš„å˜é‡ç§°ä¸ºå±€éƒ¨å˜é‡ï¼Œå®ƒä»¬çš„ä½œç”¨åŸŸåªåœ¨ä»£ç å—å†…ã€‚ å‚æ•°å’Œè¿”å›å€¼å˜é‡ä¹Ÿæ˜¯å±€éƒ¨å˜é‡(æ¥æ”¶å™¨å‚æ•°ä¹Ÿæ˜¯å±€éƒ¨å˜é‡)ã€‚ å…¨å±€å˜é‡ï¼šå‡½æ•°ä½“å¤–å£°æ˜çš„å˜é‡ã€‚ åœ¨å‡½æ•°ä½“å¤–å£°æ˜çš„å˜é‡ç§°ä¸ºå…¨å±€å˜é‡ï¼Œå®ƒä»¬çš„ä½œç”¨åŸŸæ˜¯å…¨å±€çš„ã€‚ï¼ˆåœ¨æœ¬åŒ…èŒƒå›´å†…ï¼‰ å…¨å±€å˜é‡å¯ä»¥åœ¨æ•´ä¸ªåŒ…ç”šè‡³å¤–éƒ¨åŒ…ï¼ˆè¢«å¯¼å‡ºåï¼‰ä½¿ç”¨ï¼Œå…¨å±€å˜é‡å¯ä»¥åœ¨ä»»ä½•å‡½æ•°ä¸­ä½¿ç”¨ã€‚ ç®€å¼å˜é‡ï¼š ä½¿ç”¨ := å£°æ˜çš„å˜é‡ï¼Œä¸€èˆ¬ä¹Ÿæ˜¯å±€éƒ¨å˜é‡ã€‚ï¼ˆå˜é‡å¯èƒ½é€ƒé€¸åˆ°å †é‡Œé¢ï¼‰ å¦‚æœæ–°å±€éƒ¨å˜é‡Gaä¸åŒåå·²å®šä¹‰å˜é‡ï¼ˆå…¨å±€å˜é‡Gaï¼‰ä¸åœ¨åŒä¸€ä¸ªä½œç”¨åŸŸä¸­ï¼ŒGoè¯­è¨€ä¼šåœ¨æ­¤ä½œç”¨åŸŸæ–°å®šä¹‰å±€éƒ¨å˜é‡Gaï¼Œé®ä½å…¨å±€å˜é‡Gaï¼Œå› æ­¤å°½é‡å…¨å±€å˜é‡ä¸å±€éƒ¨å˜é‡ä¸åŒåã€‚ æ˜¾å¼ä¸éšå¼ä»£ç å— Goè¯­è¨€ä¸­çš„æ ‡è¯†ç¬¦ä½œç”¨åŸŸæ˜¯åŸºäºä»£ç å—çš„ï¼Œä»£ç å—æ˜¯åŒ…è£¹åœ¨ä¸€å¯¹èŠ±æ‹¬å·{}å†…éƒ¨çš„å£°æ˜å’Œè¯­å¥ï¼Œå¹¶ä¸”æ˜¯å¯åµŒå¥—çš„ã€‚ ä»£ç å—å¦‚ï¼šå‡½æ•°çš„å‡½æ•°ä½“ã€forå¾ªç¯çš„å¾ªç¯ä½“ç­‰ã€‚ è¿˜æœ‰éšå¼çš„ï¼ˆimplicitï¼‰ä»£ç å—ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 // ä½¿ç”¨æœ€å¤šçš„ifè¯­å¥ç±»å‹åªæœ‰ifè€Œæ²¡æœ‰elseåˆ†æ”¯ if simplestms; expression { ... ... } // åœ¨è¿™ç§ç±»å‹çš„ifè¯­å¥ä¸­ï¼Œæœ‰ä¸¤ä¸ªä»£ç å—ï¼šä¸€ä¸ªéšå¼çš„ä»£ç å—å’Œä¸€ä¸ªæ˜¾ç¤ºçš„ä»£ç å— // ä¸Šé¢ä»£ç ç­‰ä»·äº { // éšå¼çš„ä»£ç å— simplestms if expression { // æ˜¾å¼ä»£ç å— ... ... } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 package main import \u0026#34;fmt\u0026#34; func main() { // è¿™é‡Œéœ€è¦æ³¨æ„å˜é‡å£°æ˜çš„å…ˆåé¡ºåº if a := 1; false { fmt.Println(11) } else if b := 2; false { fmt.Println(22) } else if c := 3; false { fmt.Println(33) } else { fmt.Println(a, b, c) } // ä¸Šé¢ä»£ç  ç­‰ä»·äºå¦‚ä¸‹ä»£ç  å› æ­¤ä¸åŒä½ç½®å®šä¹‰çš„å˜é‡ä½œç”¨åŸŸä¸åŒ { aa := 1 if false { fmt.Println(11) } else { bb := 2 if false { fmt.Println(22) } else { cc := 3 if false { fmt.Println(33) } else { fmt.Println(aa, bb, cc) } } } } // Output: // 1 2 3 // 1 2 3 } å˜é‡è¢«é®ç›– ç›¸åŒåå­—çš„æ ‡è¯†ç¬¦ä¼šé®ä½å‰é¢çš„æ ‡è¯†ç¬¦ï¼Œè¿™ç§æƒ…å†µåªèƒ½æ˜¯åœ¨ä¸åŒçš„å—ä¸­ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;math/rand\u0026#34; ) // Ga å…¨å±€å˜é‡ var ( Ga int = 99 ) // v å…¨å±€å¸¸é‡ const ( v int = 199 ) func main() { // è¦†ç›–å¤–éƒ¨å£°æ˜å˜é‡Ga Ga := \u0026#34;string\u0026#34; fmt.Println(\u0026#34;mainå‡½æ•°ä¸­:\u0026#34;, Ga) // mainå‡½æ•°ä¸­: string b := GetGa() fmt.Println(\u0026#34;mainå‡½æ•°ä¸­ï¼š\u0026#34;, b(), b(), b(), b()) printGVariable() fmt.Println(v) // æ³¨æ„è¿™é‡Œå±è”½äº†å…¨å±€å¸¸é‡v v := 1 { v := 2 fmt.Println(v) { v := 3 fmt.Println(v) } } fmt.Println(v) // Output: // mainå‡½æ•°ä¸­: string // GetGa ifä¸­ï¼š 55 // GetGa å¾ªç¯ä¸­ï¼š 2 // GetGaå‡½æ•°ä¸­: 99 // mainå‡½æ•°ä¸­ï¼š 100 101 102 103 // 103 // 199 // 2 // 3 // 1 } // GetGa è¿”å›å€¼ä¸ºå‡½æ•° func() int func GetGa() func() int { rand1 := rand.Intn(10) // è¿”å›éšæœºæ•° [0,10] ä¹‹é—´ // å±€éƒ¨å˜é‡ Ga if Ga := 55; Ga + rand1 \u0026lt; 60 { fmt.Println(\u0026#34;GetGa ifä¸­ï¼š\u0026#34;, Ga) } // å±€éƒ¨å˜é‡ Ga for Ga := 2; ; { fmt.Println(\u0026#34;GetGa å¾ªç¯ä¸­ï¼š\u0026#34;, Ga) break } // å…¨å±€å˜é‡ Ga fmt.Println(\u0026#34;GetGaå‡½æ•°ä¸­:\u0026#34;, Ga) // å…³äºé—­åŒ…çš„æƒ…å†µå‚çœ‹å‡½æ•°ç« èŠ‚ return func() int { // æ­¤å¤„Gaçš„ä½œç”¨åŸŸè®¤å®šä¸Šä¸‹æ–‡æ˜¯99 Ga += 1 // å…¨å±€å˜é‡Ga return Ga } } func printGVariable() { // å…¨å±€å˜é‡Ga fmt.Println(Ga) } æ€»ç»“ æœ‰èŠ±æ‹¬å·ä¸€èˆ¬éƒ½å­˜åœ¨ä½œç”¨åŸŸã€‚ :=æ ‡è¯†æ–°å£°æ˜ä¸€ä¸ªå˜é‡ï¼Œåœ¨ä¸åŒçš„å—ä¸­å¯èƒ½ä¼šå±è”½æ‰€æœ‰ä¸Šå±‚ä»£ç å—ä¸­çš„ç›¸åŒåç§°çš„å˜é‡ï¼ˆå¸¸é‡ï¼‰ã€‚ åœ¨ifç­‰è¯­å¥ä¸­å­˜åœ¨éšå¼ä»£ç å—ï¼Œéœ€è¦æ³¨æ„ã€‚ é—­åŒ…å‡½æ•°å¯ä»¥ç†è§£ä¸ºä¸€ä¸ªä»£ç å—ï¼Œå¹¶ä¸”å¯ä»¥ä½¿ç”¨åŒ…å«å®ƒçš„å‡½æ•°å†…çš„å˜é‡ã€‚ ç®€å•å£°æ˜(:=)å˜é‡åªèƒ½åœ¨å‡½æ•°å†…éƒ¨å‡ºç°ï¼Œå®ƒä¼šè¦†ç›–å‡½æ•°å¤–çš„åŒåå˜é‡ã€‚ ç®€å•å£°æ˜(:=)å·¦ä¾§åªæœ‰ä¸€ä¸ªå˜é‡çš„æƒ…å†µä¸‹ä¸èƒ½é‡å¤å£°æ˜ä¸€ä¸ªå˜é‡ï¼Œæœ‰å¤šä¸ªå˜é‡æ—¶å…è®¸çš„ï¼Œä½†è¿™äº›å˜é‡ä¸­è‡³å°‘è¦æœ‰ä¸€ä¸ªæ–°çš„å˜é‡ï¼Œç»å¸¸æ˜¯æƒ…å†µæ˜¯file, err := os.Open(\u0026quot;txt.txt\u0026quot;)è¿™é‡Œçš„errå˜é‡æ¥æ”¶é”™è¯¯åœ¨ç›¸åŒå—çš„å¤šä¸ªåœ°æ–¹è¢«ä½¿ç”¨ã€‚ çº¦å®šå’Œæƒ¯ä¾‹ å¯è§æ€§è§„åˆ™ï¼š Goè¯­è¨€ä¸­æ ‡è¯†ç¬¦å¿…é¡»ä»¥ä¸€ä¸ªå¤§å†™å­—æ¯å¼€å¤´ï¼ˆå‚çœ‹Unicodeç¼–ç é›†å®šä¹‰çš„å¤§å†™å­—æ¯é›†ï¼‰ï¼Œæ‰èƒ½è¢«å¤–éƒ¨åŒ…çš„ä»£ç ä½¿ç”¨ï¼Œè¿™ç§°ä¸ºå¯¼å‡ºã€‚ æ ‡è¯†ç¬¦å¦‚æœä»¥å°å†™å­—æ¯å¼€å¤´ï¼Œåˆ™å¯¹åŒ…å¤–æ˜¯ä¸å¯è§çš„ï¼Œä½†æ˜¯ä»–ä»¬åœ¨æ•´ä¸ªåŒ…çš„å†…éƒ¨æ˜¯å¯è§å¹¶ä¸”å¯ç”¨çš„ã€‚ å‘½åè§„èŒƒä»¥åŠè¯­æ³•æƒ¯ä¾‹ï¼š å½“æŸä¸ªå‡½æ•°éœ€è¦è¢«å¤–éƒ¨åŒ…è°ƒç”¨çš„æ—¶å€™éœ€è¦ä»¥å¤§å†™å­—æ¯å¼€å¤´ï¼Œå¹¶éµå®ˆPascalå‘½åæ³•ã€‚ï¼ˆå¤§é©¼å³°å‘½åæ³•ï¼‰ å¦åˆ™å°±éµå®ˆï¼ˆå°é©¼å³°å‘½åæ³•ï¼‰ï¼Œå³ç¬¬ä¸€ä¸ªå•è¯çš„é¦–å­—æ¯å°å†™ï¼Œå…¶ä½™å•è¯çš„é¦–å­—æ¯å¤§å†™ã€‚ å•è¯ä¹‹é—´ä¸ä»¥ç©ºæ ¼æ–­å¼€æˆ–è¿æ¥å·ï¼ˆ-ï¼‰ã€ä¸‹åˆ’çº¿ï¼ˆ_ï¼‰è¿æ¥ï¼Œç¬¬ä¸€ä¸ªå•è¯é¦–å­—æ¯é‡‡ç”¨å¤§å†™å­—æ¯ï¼Œåç»­å•è¯çš„é¦–å­—æ¯ä¹Ÿç”¨å¤§å†™å­—æ¯ï¼ˆFirstNameã€LastNameï¼‰ã€‚ å·¦èŠ±æ‹¬å·{ä¸èƒ½ç‹¬å ä¸€è¡Œï¼Œè¿™æ˜¯ç¼–è¾‘å™¨çš„å¼ºåˆ¶è§„å®šï¼Œå³èŠ±æ‹¬å·}éœ€è¦ç‹¬å ä¸€è¡Œã€‚(è¿™ä¸Goæ²¡æœ‰;ç›¸å…³ï¼Œç¼–è¯‘å™¨ä¼šåŠ ä¸Šé»˜è®¤çš„;) åœ¨å®šä¹‰æ¥å£åæ—¶ä¹Ÿæœ‰æƒ¯ä¾‹ï¼Œä¸€ä¸ªå•æ–¹æ³•æ¥å£ç”±æ–¹æ³•åç§°åŠ ä¸Š-eråç¼€æˆ–è€…-ableåç¼€æ¥å‘½åæˆ–è€…Iå¼€å¤´ã€‚ æ³¨é‡Š è¡Œæ³¨é‡Šï¼š// æ³¨é‡Šã€‚ å—æ³¨é‡Šï¼š/* æ³¨é‡Š */ã€‚ ","permalink":"https://heliu.site/posts/golang/basic/scope/","summary":"Golang ç›¸å…³ä½œç”¨åŸŸä»‹ç»ã€‚","title":"ä½œç”¨åŸŸ"},{"content":" Goè¯­è¨€ä¸­çš„æŒ‡é’ˆä¸èƒ½è¿›è¡Œåç§»å’Œè¿ç®—ï¼Œæ˜¯å®‰å…¨æŒ‡é’ˆã€‚ æŒ‡é’ˆåœ°å€ã€æŒ‡é’ˆç±»å‹å’ŒæŒ‡é’ˆå–å€¼ã€‚ Goè¯­è¨€ä¸­çš„å‡½æ•°ä¼ å‚éƒ½æ˜¯å€¼æ‹·è´ï¼Œå½“æˆ‘ä»¬æƒ³è¦ä¿®æ”¹æŸä¸ªå˜é‡çš„æ—¶å€™ï¼Œæˆ‘ä»¬å¯ä»¥åˆ›å»ºä¸€ä¸ªæŒ‡å‘è¯¥å˜é‡åœ°å€çš„æŒ‡é’ˆå˜é‡ã€‚ ä¼ é€’æ•°æ®ä½¿ç”¨æŒ‡é’ˆï¼Œè€Œæ— é¡»æ‹·è´æ•°æ®ã€‚ ç±»å‹æŒ‡é’ˆä¸èƒ½è¿›è¡Œåç§»å’Œè¿ç®—ã€‚ Goè¯­è¨€ä¸­çš„æŒ‡é’ˆæ“ä½œéå¸¸ç®€å•ï¼Œåªéœ€è¦è®°ä½ä¸¤ä¸ªç¬¦å·ï¼š \u0026amp;ï¼ˆå–åœ°å€ï¼‰ã€*ï¼ˆæ ¹æ®åœ°å€å–å€¼ï¼‰ã€‚ æŒ‡é’ˆåœ°å€ä¸æŒ‡é’ˆç±»å‹ æ¯ä¸ªå˜é‡åœ¨è¿è¡Œæ—¶éƒ½æ‹¥æœ‰ä¸€ä¸ªåœ°å€ï¼Œè¿™ä¸ªåœ°å€ä»£è¡¨å˜é‡åœ¨å†…å­˜ä¸­çš„ä½ç½®ï¼ŒGoè¯­è¨€ä¸­ä½¿ç”¨\u0026amp;å­—ç¬¦æ”¾åœ¨å˜é‡å‰é¢å¯¹å˜é‡è¿›è¡Œ**â€œå–åœ°å€â€**æ“ä½œã€‚ Goè¯­è¨€ä¸­çš„å€¼ç±»å‹ï¼ˆintã€floatã€boolã€stringã€arrayã€structï¼‰ï¼Œå¯¹åº”çš„æŒ‡é’ˆ *intã€*int64ã€*stringç­‰ã€‚ 1 2 3 4 5 6 // å–å˜é‡æŒ‡é’ˆåœ°å€è¯­æ³• ptr := \u0026amp;v // vçš„ç±»å‹ä¸ºT // v: ä»£è¡¨è¢«å–åœ°å€çš„å˜é‡ï¼Œç±»å‹ä¸ºT // ptrï¼šç”¨äºæ¥æ”¶åœ°å€çš„å˜é‡ï¼Œptrçš„ç±»å‹å°±ä¸º*Tï¼Œç§°åšTçš„æŒ‡é’ˆç±»å‹ // * ä»£è¡¨æŒ‡é’ˆ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 package main import \u0026#34;fmt\u0026#34; func main() { a := 10\t// intç±»å‹ b := \u0026amp;a\t// *intç±»å‹ // a:10 ptr:0xc00001a078 type:int fmt.Printf(\u0026#34;a:%d ptr:%p type:%T\\n\u0026#34;, a, \u0026amp;a, a) // b:0xc00001a078 type:*int fmt.Printf(\u0026#34;b:%p type:%T\\n\u0026#34;, b, b) // 0xc00000e018 fmt.Println(\u0026amp;b) } æŒ‡é’ˆå–å€¼ åœ¨å¯¹æ™®é€šå˜é‡ä½¿ç”¨\u0026amp;æ“ä½œç¬¦å–åœ°å€åä¼šè·å¾—è¿™ä¸ªå˜é‡çš„æŒ‡é’ˆï¼Œç„¶åå¯ä»¥å¯¹æŒ‡é’ˆä½¿ç”¨*æ“ä½œï¼Œä¹Ÿå°±æ˜¯æŒ‡é’ˆå–å€¼ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 package main import \u0026#34;fmt\u0026#34; func main() { a := 10 // intç±»å‹ // å–å˜é‡açš„åœ°å€ï¼Œå°†æŒ‡é’ˆä¿å­˜åˆ°bä¸­ b := \u0026amp;a // *intç±»å‹ fmt.Printf(\u0026#34;type of b:%T\\n\u0026#34;, b) // type of b:*int // æŒ‡é’ˆå–å€¼ï¼ˆæ ¹æ®æŒ‡é’ˆå»å†…å­˜å–å€¼ï¼‰ c := *b fmt.Printf(\u0026#34;type of c:%T\\n\u0026#34;, c) // type of c:int fmt.Printf(\u0026#34;value of c:%v\\n\u0026#34;, c)// value of c:10 *b = 11 fmt.Println(a, *b, c) // 11 11 10 } ç©ºæŒ‡é’ˆ å½“ä¸€ä¸ªæŒ‡é’ˆè¢«å®šä¹‰åæ²¡æœ‰åˆ†é…åˆ°ä»»ä½•å˜é‡æ—¶ï¼Œå®ƒçš„å€¼ä¸º nilã€‚ ç©ºæŒ‡é’ˆçš„åˆ¤æ–­ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 package main import \u0026#34;fmt\u0026#34; func main() { var p *string fmt.Println(p) // \u0026lt;nil\u0026gt; fmt.Printf(\u0026#34;pçš„å€¼æ˜¯%v\\n\u0026#34;, p) // pçš„å€¼æ˜¯\u0026lt;nil\u0026gt; if p != nil { fmt.Println(\u0026#34;éç©º\u0026#34;) } else { fmt.Println(\u0026#34;ç©ºå€¼\u0026#34;) // ç©ºå€¼ } } ç±»å‹è½¬æ¢ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 { var ff float64 = 12.23 ii := *(*uint64)(unsafe.Pointer(\u0026amp;ff)) // uint64 ç±»å‹ fmt.Printf(\u0026#34;%064b \\n\u0026#34;, ii) ff1 := *(*float64)(unsafe.Pointer(\u0026amp;ii)) fmt.Println(ff1) // Output: // 0100000000101000011101011100001010001111010111000010100011110110 // 12.23 } æŒ‡é’ˆç»ƒä¹  ç¨‹åºå®šä¹‰ä¸€ä¸ªintå˜é‡numçš„åœ°å€å¹¶æ‰“å°ã€‚ å°†numçš„åœ°å€èµ‹ç»™æŒ‡é’ˆptrï¼Œå¹¶é€šè¿‡ptrå»ä¿®æ”¹numçš„å€¼ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 package main import \u0026#34;fmt\u0026#34; func main() { var a int fmt.Println(\u0026amp;a) var p *int p = \u0026amp;a *p = 20 fmt.Println(a) } ä½¿ç”¨æ³¨æ„ ã€å¸¸é‡ã€‘ä¸èƒ½ä½¿ç”¨\u0026amp;å–åœ°å€ï¼Œå¸¸é‡æ˜¯åªè¯»ç±»å‹å› æ­¤å–åœ°å€æ²¡å•¥æ„ä¹‰ã€‚ ã€å­—ç¬¦ä¸²å…ƒç´ ã€‘ï¼Œæ¯”å¦‚\u0026amp;string[0]ä¸èƒ½å–åœ°å€ï¼Œå­—ç¬¦ä¸²ä¹Ÿæ˜¯åªè¯»ç±»å‹å¯¹å­—ç¬¦ä¸²ä¸­çš„ç¬¦å·å–åœ°å€æ„ä¹‰ä¹Ÿä¸å¤§ã€‚ ã€å­—å…¸å…ƒç´ ã€‘ï¼Œæ¯”å¦‚\u0026amp;map[â€˜keyâ€™]ä¸èƒ½å–åœ°å€ï¼Œå­—å…¸çš„å­˜å‚¨ä½ç½®æ˜¯ç»å¸¸å˜åŒ–çš„ï¼Œå› æ­¤å¯¹å­—å…¸ä¸­å…ƒç´ å–åœ°å€æ„ä¹‰ä¸å¤§ã€‚ æ€»ç»“ å–åœ°å€æ“ä½œç¬¦\u0026amp;å’Œå–å€¼æ“ä½œç¬¦*æ˜¯ä¸€å¯¹äº’è¡¥æ“ä½œç¬¦ã€‚ \u0026amp;ï¼šå–å‡ºåœ°å€ï¼›*ï¼šæ ¹æ®åœ°å€å–å‡ºåœ°å€æŒ‡å‘çš„å€¼ã€‚ å˜é‡ã€æŒ‡é’ˆåœ°å€ã€æŒ‡é’ˆå˜é‡ã€å–åœ°å€ã€å–å€¼çš„ç›¸äº’å…³ç³»å’Œç‰¹æ€§å¦‚ä¸‹ï¼š å¯¹å˜é‡è¿›è¡Œå–åœ°å€ï¼ˆ\u0026amp;ï¼‰æ“ä½œï¼Œå¯ä»¥è·å¾—è¿™ä¸ªå˜é‡çš„å­˜å‚¨åœ°å€ã€‚ æŒ‡é’ˆå˜é‡çš„å€¼æ˜¯æŒ‡é’ˆåœ°å€ã€‚ å¯¹æŒ‡é’ˆå˜é‡è¿›è¡Œå–å€¼ï¼ˆ*ï¼‰æ“ä½œï¼Œå¯ä»¥è·å¾—æŒ‡é’ˆå˜é‡æŒ‡å‘çš„åŸå˜é‡çš„å€¼ã€‚ æŒ‡é’ˆä¼ å€¼ä¾‹å­ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 package main import \u0026#34;fmt\u0026#34; func main() { a := 10 modify1(a) fmt.Println(a) // 10 modify2(\u0026amp;a) fmt.Println(a) // 100 } func modify1(x int) { x = 100 } func modify2(x *int) { *x = 100 } ","permalink":"https://heliu.site/posts/golang/basic/pointer/","summary":"Golang æŒ‡é’ˆä»‹ç»ã€‚","title":"æŒ‡é’ˆ"},{"content":" ä½¿ç”¨åå¼•å·(``)æˆ–åŒå¼•å·(\u0026quot;\u0026quot;)æ¥å®šä¹‰å­—ç¬¦ä¸²ï¼Œåå¼•å·è¡¨ç¤ºåŸç”Ÿçš„å­—ç¬¦ä¸²ï¼Œå³ä¸è¿›è¡Œè½¬ä¹‰ã€‚ åŒå¼•å· å­—ç¬¦ä¸²ä½¿ç”¨åŒå¼•å·æ‹¬èµ·æ¥ï¼Œå…¶ä¸­ç›¸å…³çš„è½¬ä¹‰å­—ç¬¦å°†è¢«æ›¿æ¢ã€‚ 1 str := \u0026#34;hello world! \\n Hello \\n\u0026#34; // \\n è¡¨ç¤ºæ¢è¡Œ 1 2 3 4 5 6 7 8 9 func Example() { str := \u0026#34;hello world! \\n Hello \\n\u0026#34; fmt.Printf(\u0026#34;%s\u0026#34;, str) // Output: // hello world! // Hello // } åå¼•å· å­—ç¬¦ä¸²ä½¿ç”¨åå¼•å·æ‹¬èµ·æ¥ï¼Œå…¶ä¸­ç›¸å…³çš„è½¬ä¹‰å­—ç¬¦ä¸ä¼šè¢«æ›¿æ¢ã€‚ 1 str := `hello world! \\n Hello \\n`\t// \\n è¡¨ç¤ºæ¢è¡Œ 1 2 3 4 5 6 7 func Example() { str := `hello world! \\n Hello \\n` fmt.Printf(\u0026#34;%s\u0026#34;, str) // Output: // hello world! \\n Hello \\n } åŒå¼•å·å’Œåå¼•å·å­˜å‚¨çš„åŒºåˆ«ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 package main import \u0026#34;fmt\u0026#34; func main() { // éªŒè¯ä¸¤ç§å½¢å¼å­—ç¬¦ä¸²çš„åŒºåˆ« s1 := \u0026#34;hello,\\nworld\u0026#34; // 12 s2 := `hello,\\nworld` // 13 // å¯è§(åŒå¼•å·ä¸­ï¼Œ\\nå½“ä½œè½¬ä¹‰å­—ç¬¦åœ¨å¤„ç†)ï¼Œå½“ä½œä¸€ä¸ªå­—èŠ‚ // (åå¼•å·ä¸­ï¼Œ\\nå½“ä½œä¸¤ä¸ªå­—ç¬¦å¤„ç†)å½“ä½œä¸¤ä¸ªå­—èŠ‚ fmt.Println(len(s1), len(s2)) // Output: // 12 13 } å­—ç¬¦ä¸² Goè¯­è¨€ä¸­çš„stringç±»å‹æ˜¯ä¸€ç§å€¼ç±»å‹ï¼Œå­˜å‚¨çš„å­—ç¬¦ä¸²æ˜¯ä¸å¯å˜çš„ã€‚ å¦‚æœéœ€è¦ä¿®æ”¹stringçš„å†…å®¹ï¼Œéœ€è¦å°†stringè½¬æ¢ä¸º[]byteæˆ–[]runeï¼Œå¹¶ä¸”ä¿®æ”¹åçš„stringå†…å®¹æ˜¯é‡æ–°ç”Ÿæˆçš„ã€‚ Goé»˜è®¤ä½¿ç”¨UTF-8ç¼–ç ï¼Œå¯¹Unicodeçš„æ”¯æŒéå¸¸å¥½ã€‚ å­—ç¬¦ä¸²å­˜å‚¨ç»“æ„ï¼š 1 2 3 4 5 6 type StringStruct struct { // æŒ‡å‘å­—ç¬¦ä¸²çš„åº•å±‚æ•°ç»„çš„é¦–å­—èŠ‚åœ°å€ï¼Œå°±æ˜¯ä¸€ä¸ªæŒ‡é’ˆåœ°å€ Data unsafe.Pointer // ä¿å­˜å­—ç¬¦ä¸²çš„é•¿åº¦ï¼Œå…¶å®å°±æ˜¯intç±»å‹å¤§å° Len uintptr } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 type stringStruct struct { str unsafe.Pointer len uintptr } { var aa1 [32]byte var ll1 uintptr = 6 // å­—ç¬¦ä¸²ä¸€æ ·è¢«åˆ†é…åœ¨åªè¯»å†…å­˜ä¸Šï¼Œ // åªæ˜¯è¯¥åº•å±‚æ•°ç»„ä¸èƒ½æ“ä½œä½†æ˜¯èƒ½æ›¿æ¢stringStruct.strå­˜å‚¨çš„å€¼ var sss string = \u0026#34;b\u0026#34; // æ›¿æ¢æ‰åŸå…ˆæŒ‡å‘çš„åªè¯»å†…å­˜ä½ç½®åˆ°aa1æ ˆä¸Šçš„æ•°æ®ï¼Œ // ä»¥ä¸‹ä»£ç æ˜¯ä½¿sssåº•å±‚æ•°ç»„å’Œaa1ç›¸å…³è”èµ·æ¥ï¼Œæ“ä½œaa1ä¹Ÿå°±æ˜¯æ“ä½œsss s2s1 := (*stringStruct)(unsafe.Pointer(\u0026amp;sss)) s2s1.str = unsafe.Pointer(\u0026amp;aa1)\t// æ›¿æ¢è¯¥å€¼ s2s1.len = ll1 bbb1 := aa1[:ll1] bbb1[1] = \u0026#39;a\u0026#39; // [0 97 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0] // a // [0 97 0 0 0 0] fmt.Println(aa1, sss, bbb1) } byte å’Œ rune è¿™ä¸¤ä¸ªç±»å‹æ˜¯å¤„ç†å­—ç¬¦ç›¸å…³ã€‚ type byte = uint8ã€type rune = int32ã€‚ 1 2 3 4 5 6 7 // byte å’Œ rune type byte = uint8 // é•¿åº¦ 1B type rune = int32 // é•¿åº¦ 4B // ç±»å‹stringç±»å‹çš„é›¶å€¼æ˜¯é•¿åº¦ä¸ºé›¶çš„å­—ç¬¦ä¸²ï¼Œå³ç©ºå­—ç¬¦ä¸² \u0026#34;\u0026#34; var b byte = \u0026#39;a\u0026#39; // ASCIIç ç›¸å¯¹åº”æ•°å€¼ var r rune = \u0026#39;å¥½\u0026#39; // Unicodeç›¸å¯¹åº”ç¼–ç  Unicode è½¬ UTF-8 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;unicode/utf8\u0026#34; ) func main() { var s string = \u0026#34;hello Goè¯­è¨€\u0026#34;\t// 8 + 2*3 = 14 fmt.Println(len(s)) // 14 å­—èŠ‚ fmt.Println(utf8.RuneCountInString(s)) // 10 å­—ç¬¦ // æŠŠå­—ç¬¦ä¸²sæ˜¾ç¤ºè½¬æ¢ä¸º[]byteç±»å‹ï¼Œæ­¤æ—¶ä¼šåˆ†é…æ–°çš„åº•å±‚æ•°ç»„ç©ºé—´è€Œä¸æ˜¯å…±ç”¨ä¹‹å‰ slice1 := []byte(s) // utf-8ç¼–ç  è½¬ unicode // | Unicodeç¬¦å·èŒƒå›´ | UTF-8ç¼–ç æ–¹å¼ï¼Œç¼–ç æ¨¡æ¿ // n | åå…­è¿›åˆ¶ | äºŒè¿›åˆ¶ // --+-----------------------+-------------------------------------------------------- // 1 | 0000 0000 - 0000 007F | 0xxxxxxx // 2 | 0000 0080 - 0000 07FF | 110xxxxx 10xxxxxx // 3 | 0000 0800 - 0000 FFFF | 1110xxxx 10xxxxxx 10xxxxxx // 4 | 0001 0000 - 0010 FFFF | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx utf8æœ€å¤§4å­—èŠ‚ // 5 | 0020 0000 - 03FF FFFF | 111110xx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx // 6 | 0400 0000 - 7FFF FFFF | 1111110x 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx // --+-----------------------+-------------------------------------------------------- // 232 175 173\t=utf8è½¬äºŒè¿›åˆ¶=\u0026gt; 11101000 10101111 10101101 =è½¬unicode=\u0026gt; 10001011 11101101 =\u0026gt; 35821 è¯­ // 232 168 128\t=utf8è½¬äºŒè¿›åˆ¶=\u0026gt; 11101000 10101000 10000000 =è½¬unicode=\u0026gt; 10001010 00000000 =\u0026gt; 35328 è¨€ fmt.Println(slice1) // [104 101 108 108 111 32 71 111 232 175 173 232 168 128] // æŠŠå­—ç¬¦ä¸²sæ˜¾ç¤ºè½¬æ¢ä¸º[]runeç±»å‹ slice2 := []rune(s) fmt.Println(slice2) // [104 101 108 108 111 32 71 111 35821 35328] for i, v := range s { // int, rune fmt.Printf(\u0026#34;i:%d %#U %d \\n\u0026#34;, i, v, v) } /* * i:0 U+0068 \u0026#39;h\u0026#39; 104 * i:1 U+0065 \u0026#39;e\u0026#39; 101 * i:2 U+006C \u0026#39;l\u0026#39; 108 * i:3 U+006C \u0026#39;l\u0026#39; 108 * i:4 U+006F \u0026#39;o\u0026#39; 111 * i:5 U+0020 \u0026#39; \u0026#39; 32 * i:6 U+0047 \u0026#39;G\u0026#39; 71 * i:7 U+006F \u0026#39;o\u0026#39; 111 * i:8 U+8BED \u0026#39;è¯­\u0026#39; 35821 * i:11 U+8A00 \u0026#39;è¨€\u0026#39; 35328 */ // 232 175 173\t=\u0026gt; 35821 // E8 AF AD =\u0026gt; 8BED // å­—ç¬¦ä¸²çš„å•ä¸ªå­—ç¬¦æ˜¯byteä¹Ÿå°±æ˜¯uint8ç±»å‹ fmt.Printf(\u0026#34;%T\\n\u0026#34;, s[0]) // uint8 // å­—ç¬¦ä¸²ä½¿ç”¨åˆ‡ç‰‡åä¾ç„¶æ˜¯å­—ç¬¦ä¸²ç±»å‹ fmt.Printf(\u0026#34;%T\\n\u0026#34;, s[:]) // string } å­—ç¬¦ä¸²æ¯”è¾ƒ ä¸€èˆ¬çš„æ¯”è¾ƒè¿ç®—ç¬¦ï¼ˆ==ã€!=ã€\u0026lt;ã€\u0026lt;=ã€\u0026gt;=ã€\u0026gt;ï¼‰é€šè¿‡åœ¨å†…å­˜ä¸­æ¥å­—èŠ‚æ¯”è¾ƒæ¥å®ç°å­—ç¬¦ä¸²çš„å¯¹æ¯”ã€‚ æ¯”è¾ƒæºç å‡½æ•°ï¼š 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 //go:linkname runtime_cmpstring runtime.cmpstring func runtime_cmpstring(a, b string) int { l := len(a) // lè®°å½•aå’Œbæœ€å°çš„ä¸€ä¸ªé•¿åº¦ if len(b) \u0026lt; l {\tl = len(b) } for i := 0; i \u0026lt; l; i++ { // éå† c1, c2 := a[i], b[i] if c1 \u0026lt; c2 { // a \u0026lt; b è¿”å› -1 return -1 } if c1 \u0026gt; c2 { // a \u0026gt; b è¿”å› +1 return +1 } } // è¿™é‡Œè¯´æ˜å‰é¢å­—ä¸²éƒ½ä¸€æ ·ï¼Œç°åœ¨æ¯”è¾ƒè°é•¿ // ç”±äºä¸Šé¢éå†çš„æœ€çŸ­é•¿åº¦çš„æ‰€ä»¥éœ€è¦å†æ¬¡åˆ¤æ–­é•¿åº¦æ¯”è¾ƒ if len(a) \u0026lt; len(b) {\treturn -1 } if len(a) \u0026gt; len(b) { return +1 } // a == b è¿”å› 0 return 0 } å­—ç¬¦ä¸²é•¿åº¦ len()å‡½æ•°è·å–å­—ç¬¦ä¸²æ‰€å çš„å­—èŠ‚é•¿åº¦ï¼Œç”±å­—ç¬¦ä¸²çš„ç»“æ„å¯çŸ¥å­—ç¬¦ä¸²çš„é•¿åº¦ä¿å­˜åœ¨å­—ç¬¦ä¸²çš„ç¬¬äºŒä¸ªå­—æ®µä¸­ã€‚ 1 2 // ASCIIä¸­ a-\u0026gt;97 A-\u0026gt;65 fmt.Println(\u0026#39;a\u0026#39; \u0026gt; \u0026#39;A\u0026#39;) // true å†…ç½®çš„len()å‡½æ•°è·å–çš„æ˜¯å­—èŠ‚çš„é•¿åº¦å’Œï¼Œè€Œä¸æ˜¯å­—ç¬¦æ•°é‡ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;unicode/utf8\u0026#34; ) func main() { s := \u0026#34;å…¶å®å°±æ˜¯rune\u0026#34; fmt.Println(len(s)) // 16 å­—èŠ‚ 4*3 + 4 fmt.Println(utf8.RuneCountInString(s)) // 8 å­—ç¬¦ } å­—ç¬¦ä¸²çš„å†…å®¹(çº¯å­—èŠ‚)å¯ä»¥é€šè¿‡æ ‡å‡†ç´¢å¼•æ¥è·å–ï¼Œåœ¨ä¸­æ‹¬å·[]å†…å†™å…¥ç´¢å¼•ï¼Œç´¢å¼•ä»0å¼€å§‹ã€‚ å­—ç¬¦ä¸²strçš„ç¬¬ä¸€ä¸ªå­—èŠ‚ str[0]ã€‚ ç¬¬ i å­—èŠ‚ str[i - 1]ã€‚ æœ€å1ä¸ªå­—èŠ‚ str[len(str) - 1]ã€‚ 1 2 3 4 5 6 7 s1 := \u0026#34;hello, world!\u0026#34; fmt.Printf(\u0026#34;%c\\n\u0026#34;, s1[0]) // h fmt.Printf(\u0026#34;%c\\n\u0026#34;, s1[7]) // w // ä¸èƒ½ä½¿ç”¨\u0026amp;s1[0]è¿™ç§å½¢å¼å–åœ°å€ï¼Œå› ä¸ºå­—ç¬¦ä¸²æ˜¯ä¸å¯å˜ç±»å‹è¿™ç§å½¢å¼çš„å–åœ°å€æ²¡æœ‰ä»»ä½•æ„ä¹‰ // ä½†æ˜¯è·å–åˆ°s1[0]çš„åœ°å€ä¹Ÿæ˜¯æœ‰åŠæ³•çš„ï¼Œé€šè¿‡unsafe å¦‚æœå­—ç¬¦ä¸²å«æœ‰ä¸­æ–‡ç­‰å­—ç¬¦ï¼Œå¯ä»¥çœ‹åˆ°æ¯ä¸ªä¸­æ–‡å­—ç¬¦çš„ç´¢å¼•å€¼ç›¸å·®3ã€‚ Goçš„rangeå¾ªç¯åœ¨å¤„ç†å­—ç¬¦ä¸²çš„æ—¶å€™ï¼Œä¼šè‡ªåŠ¨éšå¼è§£ç UTF-8å­—ç¬¦ä¸²ï¼Œå…³äºå¾ªç¯çš„å¤„ç†å‚çœ‹forç›¸å…³æ–‡æ¡£ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 package main import ( \u0026#34;fmt\u0026#34; ) func main() { s := \u0026#34;å…¶å®å°±æ˜¯rune\u0026#34; // v å…¶å®å°±æ˜¯runeç±»å‹å€¼ for k, v := range s{ // ã€int, runeã€‘ fmt.Printf(\u0026#34;K: %d, V: %c === %d\\n\u0026#34;, k, v, v) } // Output: // K: 0, V: å…¶ === 20854 // K: 3, V: å® === 23454 // K: 6, V: å°± === 23601 // K: 9, V: æ˜¯ === 26159 // K: 12, V: r === 114 // K: 13, V: u === 117 // K: 14, V: n === 110 // K: 15, V: e === 101 } å­—ç¬¦ä¸²æ‹¼æ¥ å°†å¤šä¸ªå­—ç¬¦ä¸²æ‹¼æ¥æˆä¸€ä¸ªå­—ç¬¦ä¸²ã€‚ + æ‹¼æ¥ ä¸‹é¢çš„ç¤ºä¾‹ï¼Œå­—ç¬¦ä¸²éƒ½æ˜¯ä¸å¯å˜çš„ï¼Œæ¯æ¬¡è¿ç®—éƒ½ä¼šäº§ç”Ÿä¸€ä¸ªæ–°çš„å­—ç¬¦ä¸²ï¼Œæ‰€ä»¥ä¼šäº§ç”Ÿå¾ˆå¤šä¸´æ—¶çš„å­—ç¬¦ä¸²ã€‚ ä¸ä»…æ²¡ç”¨è¿˜ä¼šç»™åƒåœ¾å›æ”¶å¸¦æ¥é¢å¤–è´Ÿæ‹…ï¼Œæ‰€ä»¥æ€§èƒ½æ¯”è¾ƒå·®ã€‚ æ•°é‡è¾ƒå°‘çš„ + è¿˜è¡Œï¼Œæ¯”å¦‚ 5 ä¸ªæˆ–ä»¥ä¸‹ã€‚ 1 2 3 4 5 6 7 // è¿™ç§ç”±äºç¼–è¾‘å™¨ä¼šåœ¨ä»£ç è¡Œå°¾è‡ªåŠ¨è¡¥å…¨åˆ†å·çš„ç¼˜ç”±ï¼ŒåŠ å·å¿…é¡»æ”¾åœ¨ç¬¬ä¸€è¡Œ str := \u0026#34;hello\u0026#34; + \u0026#34;,world\u0026#34; // += å½¢å¼æ‹¼æ¥å­—ç¬¦ä¸² s := \u0026#34;hello\u0026#34; + \u0026#34;,world\u0026#34; s += \u0026#34;!\u0026#34; fmt.Sprintf() å†…éƒ¨ä½¿ç”¨[]byteå®ç°ï¼Œä¸åƒç›´æ¥ä½¿ç”¨+æ‹¼æ¥äº§ç”Ÿä¸´æ—¶çš„å­—ç¬¦ä¸²ã€‚ ä½†æ˜¯å†…éƒ¨é€»è¾‘æ¯”è¾ƒå¤æ‚ï¼Œå¾ˆå¤šé¢å¤–çš„åˆ¤æ–­ï¼Œç”¨åˆ°äº†æ¥å£ï¼Œæ‰€ä»¥æ€§èƒ½ä¸€èˆ¬ã€‚ 1 fmt.Sprintf(\u0026#34;%d:%s\u0026#34;, 2021, \u0026#34;Golang\u0026#34;) // 2021:Golang strings.Join() Joinä¼šå…ˆæ ¹æ®å­—ç¬¦ä¸²æ•°ç»„çš„å†…å®¹ï¼Œè®¡ç®—ä¸€ä¸ªæ‹¼æ¥ä¹‹åçš„é•¿åº¦ã€‚ ç„¶åç”³è¯·å¯¹åº”å¤§å°çš„å†…å­˜ï¼Œä¸€ä¸ªä¸€ä¸ªå­—ç¬¦ä¸²å¡«å…¥ã€‚ åœ¨å·²æœ‰ä¸€ä¸ªæ•°ç»„çš„æƒ…å†µä¸‹æ•ˆç‡å¾ˆé«˜ï¼Œä½†æ˜¯æ„é€ ä¸€ä¸ªæœ¬æ¥æ²¡æœ‰çš„æ•°æ®ä»£ä»·ä¹Ÿä¸å°ã€‚ 1 strings.Join([]string{\u0026#34;hello,\u0026#34;, \u0026#34;world\u0026#34;, \u0026#34;Golang\u0026#34;}, \u0026#34;!!!\u0026#34;) // hello,!!!world!!!Golang bytes.Buffer æ¯”è¾ƒç†æƒ³ï¼Œå¯ä»¥å½“æˆå¯å˜å­—ç¬¦ä½¿ç”¨ï¼Œå¯¹å†…å­˜çš„å¢é•¿ä¹Ÿæœ‰ä¼˜åŒ–ã€‚ å¦‚æœèƒ½é¢„ä¼°å­—ç¬¦ä¸²çš„é•¿åº¦ï¼Œå¯ä»¥ä½¿ç”¨buffer.Grow()æ¥å£æ¥è®¾ç½®capacityï¼Œå°±æ˜¯è®¾ç½®åˆ‡ç‰‡å®¹é‡ï¼Œé¿å…ç¿»å€æ‰©å®¹é€ æˆæ€§èƒ½ä¸‹é™ã€‚ 1 2 3 4 5 var buffer bytes.Buffer buffer.WriteString(\u0026#34;hello\u0026#34;) buffer.WriteString(\u0026#34;,\u0026#34;) buffer.WriteString(\u0026#34;world!\u0026#34;) fmt.Print(buffer.String()) strings.Builder å†…éƒ¨é€šè¿‡åˆ‡ç‰‡æ¥ä¿å­˜å’Œç®¡ç†å†…å®¹ã€‚ åˆ‡ç‰‡å†…éƒ¨åˆ™æ˜¯é€šè¿‡ä¸€ä¸ªæŒ‡é’ˆæŒ‡å‘å®é™…ä¿å­˜å†…å®¹çš„æ•°ç»„ã€‚ strings.BuilderåŒæ ·ä¹Ÿæä¾›äº†Grow()æ¥æ”¯æŒé¢„å®šäºå®¹é‡ï¼Œå°±æ˜¯è®¾ç½®åˆ‡ç‰‡å®¹é‡ï¼Œé¿å…ç¿»å€æ‰©å®¹é€ æˆæ€§èƒ½ä¸‹é™ã€‚ å½“å¯ä»¥é¢„å®šä¹‰éœ€è¦ä½¿ç”¨çš„å®¹é‡æ—¶ï¼Œstrings.Builderå°±èƒ½é¿å…å› æ‰©å®¹äº§ç”Ÿæ–°çš„åˆ‡ç‰‡ã€‚ strings.Builderæ˜¯éçº¿ç¨‹å®‰å…¨çš„ï¼Œæ€§èƒ½å’Œbytes.Bufferç›¸å·®æ— å‡ ã€‚ 1 2 3 4 var b1 string.Builder b1.WriteString(\u0026#34;hello,\u0026#34;) b1.WriteString(\u0026#34;world!\u0026#34;) fmt.Print(b1.String()) å­—ç¬¦ä¸²å¤„ç† æ ‡å‡†åº“å››ä¸ªå¯¹å­—ç¬¦ä¸²å¤„ç†åŒ…ï¼šbytesã€stringsã€strconvã€unicodeã€‚ åŒ… æè¿° strings æä¾›äº†è®¸å¤šå¦‚å­—ç¬¦ä¸²çš„æŸ¥è¯¢ã€æ›¿æ¢ã€æ¯”è¾ƒã€æˆªæ–­ã€æ‹†åˆ†å’Œåˆå¹¶ç­‰åŠŸèƒ½ bytes è¯¥åŒ…ä¹Ÿæä¾›äº†ç±»ä¼¼stringsåŠŸèƒ½çš„å‡½æ•°ï¼Œä½†æ˜¯é’ˆå¯¹å’Œå­—ç¬¦ä¸²æœ‰ç€ç›¸åŒç»“æ„çš„[]byteç±»å‹ï¼Œå› ä¸ºå­—ç¬¦ä¸²åªæ˜¯åªè¯»ï¼Œå› æ­¤é€æ­¥æ„å»ºå­—ç¬¦ä¸²ä¼šå¯¼è‡´å¾ˆå¤šåˆ†é…å’Œå¤åˆ¶ã€‚åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œä½¿ç”¨bytes.Bufferç±»å‹å°†æ›´æœ‰æ•ˆ strconv æä¾›äº†å¸ƒå°”å‹ã€æ•´å‹æ•°ã€æµ®ç‚¹æ•°å’Œå¯¹åº”å­—ç¬¦ä¸²çš„ç›¸äº’è½¬æ¢ï¼Œè¿˜æä¾›äº†åŒå¼•å·è½¬ä¹‰ç›¸å…³çš„è½¬æ¢ unicode æä¾›äº†IsDigitã€IsLetterã€IsUpperå’ŒIsLowerç­‰ç±»ä¼¼åŠŸèƒ½ï¼Œç”¨äºç»™å®šå­—ç¬¦åˆ†ç±» åˆ¤æ–­ä»¥æŸå­—ç¬¦ä¸²å¼€å¤´æˆ–ç»“å°¾ strings.HasPrefix(s, prefix string) bool åˆ¤æ–­æ˜¯å¦ä»¥æŸä¸ªå­—ç¬¦ä¸²å¼€å¤´ã€‚ strings.HasSuffix(s, suffix string) bool åˆ¤æ–­æ˜¯å¦ä»¥æŸä¸ªå­—ç¬¦ä¸²ç»“å°¾ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;strings\u0026#34; ) func main() { s := `å¿«æ¨‚ \\n Ak` fmt.Println(strings.HasPrefix(s, \u0026#34;å¿«æ¨‚\u0026#34;)) // true fmt.Println(strings.HasPrefix(s, \u0026#34;A\u0026#34;)) // false // Output: // true // false } å­—ç¬¦ä¸²åˆ†å‰² strings.Split(s, sep string) []string ä½¿ç”¨sepå­—ç¬¦ä¸²åˆ†éš”så­—ç¬¦ä¸²ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;strings\u0026#34; ) func main() { s := `A,B,C,D,E,F,G,H` fmt.Println(strings.Split(s, \u0026#34;,\u0026#34;)) // [A B C D E F G H] // Output: // [A B C D E F G H] } è¿”å›å­ä¸²ç´¢å¼• strings.Index(s, substr string) int è¿”å›ç¬¬ä¸€æ¬¡åŒ¹é…åˆ°çš„ç´¢å¼•ã€‚ strings.LastIndex(a, substr string) int è¿”å›æœ€åä¸€ä¸ªåŒ¹é…åˆ°çš„ç´¢å¼•ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;strings\u0026#34; ) func main() { s := `A,B,C,D,E,F,G,H` fmt.Println(strings.Index(s, \u0026#34;,\u0026#34;)) // 1 fmt.Println(strings.LastIndex(s, \u0026#34;,\u0026#34;)) // 13 fmt.Println(strings.Index(s, \u0026#34;D\u0026#34;)) // 6 fmt.Println(strings.LastIndex(s, \u0026#34;D\u0026#34;)) // 6 fmt.Println(strings.Index(s, \u0026#34;M\u0026#34;)) // -1 fmt.Println(strings.LastIndex(s, \u0026#34;M\u0026#34;)) // -1 } å­—ç¬¦ä¸²è¿æ¥ strings.Join(a []string, sep string) string ä½¿ç”¨sepå­—ç¬¦ä¸²æ‹¼æ¥aå­—ç¬¦ä¸²åˆ‡ç‰‡ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;strings\u0026#34; ) func main() { s := []string{\u0026#34;A\u0026#34;,\u0026#34;D\u0026#34;,\u0026#34;G\u0026#34;,\u0026#34;R\u0026#34;,\u0026#34;G\u0026#34;,\u0026#34;S\u0026#34;,\u0026#34;F\u0026#34;} // æ³¨æ„è¿™é‡Œçš„så¿…é¡»æ˜¯åˆ‡ç‰‡[]stringç±»å‹ fmt.Println(strings.Join(s, \u0026#34;,\u0026#34;)) // A,D,G,R,G,S,F // Output: // A,D,G,R,G,S,F } å­—ç¬¦ä¸²æ›¿æ¢ strings.Replace(s, old, new string, n int) string åœ¨så­—ç¬¦ä¸²ä¸­æœç´¢oldå­—ç¬¦ä¸²å¹¶æ›¿æ¢æˆnewå­—ç¬¦ä¸²ï¼Œnæ›¿æ¢ä¸ªæ•°ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;strings\u0026#34; ) func main() { s := \u0026#34;A,D,G,R,G,S,F,D,G,f,d,D,,FW,A,D\u0026#34; old := \u0026#34;,D\u0026#34; new := \u0026#34;-A-\u0026#34; // strings.Replace(s, old, new string, n int) // s åŸå­—ç¬¦ä¸² // old éœ€è¦è¢«æ›¿æ¢æ—§çš„å­—ç¬¦ä¸² // new éœ€è¦è¢«æ›¿æ¢æ–°çš„å­—ç¬¦ä¸² // æ›¿æ¢ä¸ªæ•° n\u0026lt;0 é»˜è®¤æ›¿æ¢å…¨éƒ¨ | n=0 ä¸æ›¿æ¢ | n=1 é»˜è®¤æ›¿æ¢ä¸€ä¸ª fmt.Println(strings.Replace(s, old, new, -1)) // A-A-,G,R,G,S,F-A-,G,f,d-A-,,FW,A-A- fmt.Println(strings.Replace(s, old, new, 0)) // A,D,G,R,G,S,F,D,G,f,d,D,,FW,A,D fmt.Println(strings.Replace(s, old, new, 1)) // A-A-,G,R,G,S,F,D,G,f,d,D,,FW,A,D fmt.Println(strings.Replace(s, old, new, 3)) // A-A-,G,R,G,S,F-A-,G,f,d-A-,,FW,A,D fmt.Println(strings.Replace(s, old, new, 30)) // A-A-,G,R,G,S,F-A-,G,f,d-A-,,FW,A-A- } ç»Ÿè®¡å­—ç¬¦åœ¨å­—ç¬¦ä¸²ä¸­çš„æ¬¡æ•° strings.Count(s, substr string) int ç»Ÿè®¡substrå­—ç¬¦ä¸²åœ¨så­—ç¬¦ä¸²ä¸­å‡ºç°çš„æ¬¡æ•°ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;strings\u0026#34; ) func main() { s := \u0026#34;A,D,G,R,G,S,F,D,G,f,d,D,,FW,A,D\u0026#34; fmt.Println(strings.Count(s, \u0026#34;,\u0026#34;)) // 15 fmt.Println(strings.Count(s, \u0026#34;D\u0026#34;)) // 4 // Output: // 15 // 4 } åˆ¤æ–­å­—ç¬¦ä¸²çš„åŒ…å«å…³ç³» strings.Contains(s, substr string) bool åˆ¤æ–­så­—ç¬¦ä¸²æ˜¯å¦åŒ…å«substrå­—ç¬¦ä¸²ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;strings\u0026#34; ) func main() { s := \u0026#34;A,D,G,R,G,S,F,D,G,f,d,D,,FW,A,D\u0026#34; fmt.Println(strings.Contains(s, \u0026#34;,D\u0026#34;)) // true fmt.Println(strings.Contains(s, \u0026#34;DD\u0026#34;)) // false // Output: // true // false } å­—ç¬¦ä¸²è½¬ä¹‰ç¬¦ Go è¯­è¨€çš„å­—ç¬¦ä¸²å¸¸è§è½¬ä¹‰ç¬¦åŒ…å«å›è½¦ã€æ¢è¡Œã€å•åŒå¼•å·ã€åˆ¶è¡¨ç¬¦ç­‰ï¼Œå¦‚ä¸‹è¡¨æ‰€ç¤ºã€‚ è½¬ä¹‰ å«ä¹‰ \\r å›è½¦ç¬¦ï¼ˆè¿”å›è¡Œé¦–ï¼‰ \\n æ¢è¡Œç¬¦ï¼ˆç›´æ¥è·³åˆ°ä¸‹ä¸€è¡Œçš„åŒåˆ—ä½ç½®ï¼‰ \\t åˆ¶è¡¨ç¬¦ \\' å•å¼•å· \\\u0026quot; åŒå¼•å· \\ åæ–œæ  1 2 3 4 5 6 7 8 9 10 11 12 package main import ( \u0026#34;fmt\u0026#34; ) func main() { fmt.Println(\u0026#34;str := \\\u0026#34;c:\\\\pprof\\\\main.exe\\\u0026#34;\u0026#34;) // Output: // str := \u0026#34;c:\\pprof\\main.exe\u0026#34; } byteå’Œruneç±»å‹ ç»„æˆæ¯ä¸ªå­—ç¬¦ä¸²çš„å…ƒç´ å«åšå­—ç¬¦ã€‚ å¯ä»¥é€šè¿‡éå†æˆ–è€…å•ä¸ªè·å–å­—ç¬¦ä¸²å…ƒç´ è·å¾—å­—ç¬¦ã€‚ å­—ç¬¦ç”¨è‹±æ–‡å•å¼•å·ï¼ˆ'ï¼‰åŒ…è£¹èµ·æ¥ã€‚ 1 2 3 4 5 // ä»¥ä¸‹å­—ç¬¦ç±»å‹éƒ½é»˜è®¤ runeç±»å‹ var a := \u0026#39;ä¸­\u0026#39; // rune var b := \u0026#39;x\u0026#39; // rune fmt.Printf(\u0026#34;b:%T\\n\u0026#34;, b) // b:int32 fmt.Printf(\u0026#34;a:%T\\n\u0026#34;, a) // a:int32 Go è¯­è¨€çš„å­—ç¬¦æœ‰ä»¥ä¸‹ä¸¤ç§ï¼š uint8ç±»å‹ï¼Œæˆ–è€…å«byteå‹ï¼Œä»£è¡¨äº†ASCIIç çš„ä¸€ä¸ªå­—ç¬¦ã€‚ runeç±»å‹ï¼Œä»£è¡¨ä¸€ä¸ªUnicodeå­—ç¬¦ã€‚ å½“éœ€è¦å¤„ç†ä¸­æ–‡ã€æ—¥æ–‡æˆ–è€…å…¶ä»–å¤åˆå­—ç¬¦æ—¶ï¼Œåˆ™éœ€è¦ç”¨åˆ°runeç±»å‹ã€‚ runeç±»å‹å®é™…æ˜¯ä¸€ä¸ªint32ã€‚ Go ä½¿ç”¨äº†ç‰¹æ®Šçš„ rune ç±»å‹æ¥å¤„ç† Unicodeï¼Œè®©åŸºäºUnicodeçš„æ–‡æœ¬å¤„ç†æ›´ä¸ºæ–¹ä¾¿ã€‚ ä¹Ÿå¯ä»¥ä½¿ç”¨ byte å‹è¿›è¡Œé»˜è®¤å­—ç¬¦ä¸²å¤„ç†ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // éå†å­—ç¬¦ä¸² func traversalString() { s := \u0026#34;pprof.cnåšå®¢\u0026#34; for i := 0; i \u0026lt; len(s); i++ { // ã€int, byteã€‘ fmt.Printf(\u0026#34;%v(%c) \u0026#34;, s[i], s[i]) } fmt.Println() for _, r := range s { // ã€int, runeã€‘ fmt.Printf(\u0026#34;%v(%c) \u0026#34;, r, r) } fmt.Println() } ä¿®æ”¹å­—ç¬¦ä¸² è¦ä¿®æ”¹å­—ç¬¦ä¸²ï¼Œéœ€è¦å…ˆå°†å…¶è½¬æ¢æˆ[]rune æˆ– []byteï¼Œå®Œæˆåå†è½¬æ¢ä¸ºstringã€‚ æ— è®ºå“ªç§è½¬æ¢ï¼Œéƒ½ä¼šé‡æ–°åˆ†é…å†…å­˜ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 func changeString() { s1 := \u0026#34;hello\u0026#34; // å¼ºåˆ¶ç±»å‹è½¬æ¢ byteS1 := []byte(s1) byteS1[0] = \u0026#39;H\u0026#39; fmt.Println(string(byteS1)) s2 := \u0026#34;åšå®¢\u0026#34; runeS2 := []rune(s2) runeS2[0] = \u0026#39;ç‹—\u0026#39; fmt.Println(string(runeS2)) } // ç±»å‹è½¬åŒ–ï¼Œä¸‹é¢å¯è§ç±»å‹è½¬æ¢éƒ½æ˜¯æ–°åˆ†é…å†…å­˜åœ°å€ // å†…å­˜åˆ†å¸ƒæ˜¯ä½å­—èŠ‚åœ¨å‰é«˜å­—èŠ‚åœ¨åæ’åºçš„ï¼Œä¸åŒçš„å¹³å°ä¸åŒ var u1 uint16 = 0b00000111_00000011 u2 := (uint8)(u1) fmt.Println(u2, \u0026amp;u1, \u0026amp;u2) // Output: // 3 0xc0000140b0 0xc0000140b2 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 type StringStruct struct { Data uintptr Len uintptr } type SliceStruct struct { Data uintptr Len uintptr Cap uintptr } func str() { s1 := \u0026#34;hello\u0026#34; fmt.Println(\u0026amp;s1) // 0xc0000102d0 fmt.Printf(\u0026#34;%#x\\n\u0026#34;, *(*uintptr)(unsafe.Pointer(\u0026amp;s1))) // 0x4a116b // çœ‹ä¸€ä¸‹s1çš„å­˜å‚¨çš„ç»“æ„ s := *(*StringStruct)(unsafe.Pointer(\u0026amp;s1)) fmt.Printf(\u0026#34;%#v\\n\u0026#34;, s) // main.StringStruct{Data:0x4a116b, Len:0x5} byteS1 := []byte(s1) // çœ‹çœ‹byteS1å­˜å‚¨çš„ç»“æ„ï¼Œä¸‹é¢ç»“æœå¯è§æ˜¯ä»æ–°åˆ†é…çš„å†…å­˜ ss := *(*SliceStruct)(unsafe.Pointer(\u0026amp;byteS1)) fmt.Printf(\u0026#34;%#v\\n\u0026#34;, ss) // main.SliceStruct{Data:0xc000074e28, Len:0x5, Cap:0x20} // è¿™é‡Œä¸ºä»€ä¹ˆå®¹é‡æ˜¯32ï¼Œæ¯”5å¤§é‚£ä¹ˆå¤šï¼Œå…·ä½“å‚çœ‹ []byte(s1) è½¬æ¢çš„æºç  fmt.Println(cap(byteS1)) // 32 // Output: // 0xc0000102d0 // 0x4a116b // main.StringStruct{Data:0x4a116b, Len:0x5} // main.SliceStruct{Data:0xc000074e28, Len:0x5, Cap:0x20} // 32 } ç±»å‹è½¬æ¢ Goè¯­è¨€ä¸­åªæœ‰æ˜¾ç¤ºç±»å‹è½¬æ¢ï¼Œæ²¡æœ‰éšå¼ç±»å‹è½¬æ¢ï¼Œè¯¥è¯­æ³•åªèƒ½åœ¨ä¸¤ä¸ªç±»å‹ä¹‹é—´æ”¯æŒç›¸äº’è½¬æ¢çš„æ—¶å€™ä½¿ç”¨ã€‚ å¼ºåˆ¶ç±»å‹è½¬æ¢çš„åŸºæœ¬è¯­æ³•å¦‚ä¸‹ï¼š T(è¡¨è¾¾å¼)ï¼šæ³¨æ„åŒºåˆ†å‡½æ•°è°ƒç”¨æƒ…å†µã€‚å› ä¸ºå‡½æ•°è°ƒç”¨ä¸æ˜¾ç¤ºè½¬æ¢ç±»å‹å½¢å¼ç›¸ä¼¼ã€‚ Tè¡¨ç¤ºè¦è½¬æ¢çš„ç±»å‹ã€‚ å¦‚è®¡ç®—ç›´è§’ä¸‰è§’å½¢çš„æ–œè¾¹é•¿æ—¶ä½¿ç”¨mathåŒ…çš„Sqrt()å‡½æ•°ã€‚ è¯¥å‡½æ•°æ¥æ”¶çš„æ˜¯float64ç±»å‹çš„å‚æ•°ï¼Œè€Œå˜é‡aå’Œbéƒ½æ˜¯intç±»å‹çš„ï¼Œè¿™ä¸ªæ—¶å€™å°±éœ€è¦å°†aå’Œbå¼ºåˆ¶ç±»å‹è½¬æ¢ä¸ºfloat64ç±»å‹ã€‚ 1 2 3 4 5 6 7 8 func sqrtDemo() { var a, b = 3, 4 var c int // math.Sqrt()æ¥æ”¶çš„å‚æ•°æ˜¯float64ç±»å‹ï¼Œéœ€è¦å¼ºåˆ¶è½¬æ¢ c = int(math.Sqrt(float64(a*a + b*b))) fmt.Println(c) } æ€»ç»“ å­—ç¬¦ä¸²è¢«è®¾è®¡æˆåªè¯»æ•°æ®ï¼Œè¿™æ ·åœ¨å¤šçº¿ç¨‹æ—¶æ“ä½œå­—ç¬¦ä¸²æ—¶ä¸éœ€è¦åŠ é”é¿å…å¹¶å‘ã€‚ ","permalink":"https://heliu.site/posts/golang/basic/string/","summary":"Golang å­—ç¬¦ä¸²ä½¿ç”¨ä»‹ç»ã€‚","title":"å­—ç¬¦ä¸²"},{"content":"å†…å­˜ç»“æ„ å­—ç¬¦ä¸²ç»“æ„ 1 2 3 4 5 6 type stringStruct struct { // æŒ‡å‘åº•å±‚æ•°ç»„ï¼Œè¿ç»­åˆ†é…çš„å­—èŠ‚ Data unsafe.Pointer // è®°å½•ç€å­—ç¬¦ä¸²çš„å­—èŠ‚é•¿åº¦ Len int } å­—ç¬¦ä¸²å†…å­˜åˆ†å¸ƒ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;unsafe\u0026#34; ) func main() { // å¦‚ä¸Šï¼šstrçš„åœ°å€ä¸º0x01f050å­˜å‚¨çš„å€¼æ˜¯0x4a1160ï¼Œ0x4a1160åˆ™æ˜¯å­—ç¬¦hçš„é¦–åœ°å€å­˜å‚¨çš„å€¼æ˜¯0x68(å­—ç¬¦h) var str string = \u0026#34;hello world!\u0026#34; // æŠŠå˜é‡strå½“æˆStringStructç»“æ„çœ‹å¾… // å­—ç¬¦ä¸²çš„å†…å­˜å¤§å°å­˜åœ¨_type.sizeä¸­ï¼Œæ›´å¤šå‚è€ƒruntime/type.goæ–‡ä»¶ sizeOf := unsafe.Sizeof(str) // å­—ç¬¦ä¸²å ç”¨å†…å­˜å¤§å°(B):16 fmt.Printf(\u0026#34;å­—ç¬¦ä¸²å ç”¨å†…å­˜å¤§å°(B):%d\\n\u0026#34;, sizeOf) // \u0026amp;str:0x01f050 // è¿™é‡Œéœ€è¦æ˜ç™½çš„æ˜¯ç»“æ„ä½“å­˜å‚¨çš„æ˜¯ç¬¬ä¸€ä¸ªå­—æ®µçš„åœ°å€ fmt.Printf(\u0026#34;\u0026amp;str:%#x\\n\u0026#34;, \u0026amp;str) // \u0026amp;StringStruct.data // \u0026amp;StringStruct.Len l := (*int)(unsafe.Pointer(uintptr(unsafe.Pointer(\u0026amp;str)) + unsafe.Sizeof(int(0)))) // å­—ç¬¦ä¸²é•¿åº¦:12 (0x0c) fmt.Printf(\u0026#34;å­—ç¬¦ä¸²é•¿åº¦:%d\\n\u0026#34;, *l) data := *(*int)(unsafe.Pointer(\u0026amp;str)) // æ•°æ®å­˜å‚¨åœ°å€ï¼š0x4a1160 fmt.Printf(\u0026#34;æ•°æ®å­˜å‚¨åœ°å€ï¼š%#x\\n\u0026#34;, data) // è·å–æŒ‡å®šæ•°æ®ï¼Œä¸æ¨èåˆ†å¼€æ“ä½œæŒ‡é’ˆæ¯”å¦‚è¿™é‡Œçš„dataå†™æˆä¸¤ä¸ªè¡¨è¾¾å¼ // uintptr(unsafe.Pointer(nil)) =\u0026gt; 0 //b0 := *(*byte)(unsafe.Pointer(uintptr(unsafe.Pointer(nil)) // + uintptr(data))) b0 := **(**byte)(unsafe.Pointer(\u0026amp;s1))\t// h // str[0]:h fmt.Printf(\u0026#34;str[0]:%c\\n\u0026#34;, b0) // ä¸å»ºè®®è¿™æ ·åˆ†å¼€å†™æˆä¸¤æ®µï¼Œå–str[8]çš„å€¼ //b8 := *(*byte)(unsafe.Pointer(uintptr(unsafe.Pointer(nil)) + // uintptr(data) + 8*unsafe.Sizeof(byte(\u0026#39;0\u0026#39;)))) b8 := (**(**[9]byte)(unsafe.Pointer(\u0026amp;str)))[8] // str[8]:r fmt.Printf(\u0026#34;str[8]:%c\\n\u0026#34;, b8) // Output: // å­—ç¬¦ä¸²å ç”¨å†…å­˜å¤§å°(B):16 // \u0026amp;str:0xc000088230 // å­—ç¬¦ä¸²é•¿åº¦:12 // æ•°æ®å­˜å‚¨åœ°å€ï¼š0x103fb6b // str[0]:h // str[8]:r } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;unsafe\u0026#34; ) // stringHeader å­—ç¬¦ä¸²ç»“æ„ type stringHeader struct { Data uintptr Len uintptr } func main() { var s0 string = \u0026#34;hello\u0026#34; // è·å–å­—ç¬¦ä¸²é•¿åº¦ l := (*stringHeader)(unsafe.Pointer(\u0026amp;s0)).Len fmt.Printf(\u0026#34;å­—ç¬¦ä¸²é•¿åº¦ï¼š%d\\n\u0026#34;, l) // s0[0] s00 := **(**byte)(unsafe.Pointer(\u0026amp;s0)) fmt.Printf(\u0026#34;s[0]ï¼š%c\\n\u0026#34;, s00) // s0[4] // *(*uintptr)(unsafe.Pointer(\u0026amp;s0)) s04 := *(*byte)(unsafe.Pointer(uintptr(unsafe.Pointer(nil)) + *(*uintptr)(unsafe.Pointer(\u0026amp;s0)) + 4*unsafe.Sizeof(byte(\u0026#39;0\u0026#39;)))) fmt.Printf(\u0026#34;s[4]ï¼š%c\\n\u0026#34;, s04) // ------------------------------------------------------------------------------------------------------- // è·å–å­—ç¬¦æ¯ä¸ªå­—ç¬¦ s1 := \u0026#34;helxo\u0026#34; fmt.Printf(\u0026#34;%c\\n\u0026#34;, **(**byte)(unsafe.Pointer(\u0026amp;s1))) // h fmt.Printf(\u0026#34;%c\\n\u0026#34;, **(**uint16)(unsafe.Pointer(\u0026amp;s1)) \u0026gt;\u0026gt; 8) // e fmt.Printf(\u0026#34;%c\\n\u0026#34;, **(**uint32)(unsafe.Pointer(\u0026amp;s1)) \u0026gt;\u0026gt; 16 \u0026amp; 0b00000000_11111111) // l fmt.Printf(\u0026#34;%c\\n\u0026#34;, **(**uint32)(unsafe.Pointer(\u0026amp;s1)) \u0026gt;\u0026gt; 24) // x fmt.Printf(\u0026#34;%c\\n\u0026#34;, **(**uint64)(unsafe.Pointer(\u0026amp;s1)) \u0026gt;\u0026gt; 32 \u0026amp; 0b00000000_00000000_00000000_11111111)\t// o a := **(**[5]byte)(unsafe.Pointer(\u0026amp;s1)) fmt.Println(a) // å­—ç¬¦ä¸å…è®¸è¢«ä¿®æ”¹ï¼Œæ‰€ä»¥è¿™é‡Œéœ€è¦å¤„ç†ä¸€ä¸‹ str1 := \u0026#34;hello world!\u0026#34; // ç¼–è¯‘æ—¶ä¼šè¢«åˆ†é…åˆ°åªè¯»ä»£ç æ®µ str1 = str1 + \u0026#34; ds\u0026#34; // è¿è¡Œæ—¶ä¼šåˆ†é…åˆ°å†…å­˜ä¸­ï¼Œè¯­è¨€å±‚é¢ä¸Šé™åˆ¶äº†åªè¯» // ab1 æ˜¯ [12]byte ç±»å‹ ab1 := **(**[12]byte)(unsafe.Pointer(\u0026amp;str1))\t// å¯¹æ¯”ä¸‹é¢çš„åŒºåˆ« ab1[0] = 101 fmt.Println(ab1, str1) // [101 101 108 108 111 32 119 111 114 108 100 33] hello world! ds // ab æ˜¯ *[12]byte ç±»å‹ ab := *(**[12]byte)(unsafe.Pointer(\u0026amp;str1)) (*ab)[0] = 101 fmt.Println(*ab, str1) // [101 101 108 108 111 32 119 111 114 108 100 33] eello world! ds // æŒ‡é’ˆæ•°ç»„å¯¹æ¯”ä¸Šé¢ ac := new([12]byte) // *[12]byte (*ac)[0] = 96 fmt.Println(*ac) // [96 0 0 0 0 0 0 0 0 0 0 0] } å­—ç¬¦ä¸²æŒ‰å€¼ä¼ å‚ ä»¥ä¸‹æˆ‘ä»¬å¯ä»¥çœ‹å‡ºï¼Œå­—ç¬¦ä¸²åœ¨å‡½æ•°é—´ä¼ é€’ä¼ é€’çš„æ˜¯stringStructç»“æ„ä½“ã€‚ æŒ‰å€¼ä¼ å‚ä¹Ÿæ˜¯ç›´æ¥æ–°åˆ›å»ºä¸ªå˜é‡åœ°å€ä¿å­˜stringStructç»“æ„ä½“ï¼Œå…¶å­—ç¬¦ä¸²æŒ‡å‘çš„åº•å±‚æ•°ç»„æ˜¯æ²¡æœ‰å‘ç”Ÿå˜åŒ–çš„ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;unsafe\u0026#34; ) func main() { var str string = \u0026#34;hello world!\u0026#34; fmt.Printf(\u0026#34;\u0026amp;str:%#x\\n\u0026#34;, \u0026amp;str) // ä»¥ä¸‹åŒºåˆ«ï¼š // uintptr(unsafe.Pointer(\u0026amp;str)) å¾—åˆ°uintptrç±»å‹å°±æ˜¯\u0026amp;stråœ°å€ï¼Œè¿™æ˜¯ä¸€ä¸ªç‰¹ä¾‹å…¶ä»–ç±»å‹ä¸å…è®¸è¿™æ ·è½¬æ¢ // (*uintptr)(unsafe.Pointer(\u0026amp;str)) å¾—åˆ°*uintptrç±»å‹ä¹Ÿæ˜¯\u0026amp;stråœ°å€ï¼Œä¸å»ºè®®ä½¿ç”¨ // *(*uintptr)(unsafe.Pointer(\u0026amp;str)) å¾—åˆ°uintptrç±»å‹æ˜¯strå­˜å‚¨é¦–uintptré•¿åº¦å­—èŠ‚çš„å€¼ l := (*int)(unsafe.Pointer(uintptr(unsafe.Pointer(\u0026amp;str)) + unsafe.Sizeof(int(0)))) // å­—ç¬¦ä¸²é•¿åº¦:12 fmt.Printf(\u0026#34;å­—ç¬¦ä¸²é•¿åº¦:%d\\n\u0026#34;, *l) data := *(*int)(unsafe.Pointer(\u0026amp;str)) // æ•°æ®å­˜å‚¨åœ°å€ï¼š0x103fb6b fmt.Printf(\u0026#34;æ•°æ®å­˜å‚¨åœ°å€ï¼š%#x\\n\u0026#34;, data) ts(str) // Output: // \u0026amp;str:0xc000036240 // å­—ç¬¦ä¸²é•¿åº¦:12 // æ•°æ®å­˜å‚¨åœ°å€ï¼š0x9dfb6b // \u0026amp;s:0xc000036250 // å­—ç¬¦ä¸²é•¿åº¦:12 // æ•°æ®å­˜å‚¨åœ°å€ï¼š0x9dfb6b } func ts(s string) { fmt.Printf(\u0026#34;\u0026amp;s:%#x\\n\u0026#34;, \u0026amp;s) l := (*int)(unsafe.Pointer(uintptr(unsafe.Pointer(\u0026amp;s)) + unsafe.Sizeof(int(0)))) // å­—ç¬¦ä¸²é•¿åº¦:12 fmt.Printf(\u0026#34;å­—ç¬¦ä¸²é•¿åº¦:%d\\n\u0026#34;, *l) data := *(*int)(unsafe.Pointer(\u0026amp;s)) // æ•°æ®å­˜å‚¨åœ°å€ï¼š0x103fb6b fmt.Printf(\u0026#34;æ•°æ®å­˜å‚¨åœ°å€ï¼š%#x\\n\u0026#34;, data) } 1 2 3 4 5 6 7 8 9 10 11 func ts() { // 0xc00000a028 -\u0026gt; 0xc00001c0a8 -\u0026gt; 1 str1 := 1 // int str := \u0026amp;str1 // *int fmt.Printf(\u0026#34;%p\\n\u0026#34;, \u0026amp;str) // 0xc00000a028 fmt.Printf(\u0026#34;%p\\n\u0026#34;, str) // 0xc00001c0a8 fmt.Printf(\u0026#34;%#v\\n\u0026#34;, uintptr(unsafe.Pointer(\u0026amp;str))) // 0xc00000a028 fmt.Printf(\u0026#34;%#v\\n\u0026#34;, (*uintptr)(unsafe.Pointer(\u0026amp;str))) // (*uintptr)(0xc00000a028) fmt.Printf(\u0026#34;%#v\\n\u0026#34;, *(*uintptr)(unsafe.Pointer(\u0026amp;str))) // 0xc00001c0a8 } []byteä¸string []byteå’Œstringéƒ½å¯ä»¥è¡¨ç¤ºå­—ç¬¦ä¸²ï¼Œå®ƒä»¬æ•°æ®ç»“æ„ä¸åŒï¼Œå…¶è¡ç”Ÿå‡ºæ¥çš„æ–¹æ³•ä¹Ÿä¸åŒã€‚ stringæ“…é•¿çš„åœºæ™¯ï¼š éœ€è¦å­—ç¬¦ä¸²æ¯”è¾ƒã€ä¸éœ€è¦nilå­—ç¬¦ä¸²ã€‚ []byteæ“…é•¿çš„åœºæ™¯ï¼š ä¿®æ”¹å­—ç¬¦ä¸²çš„æ—¶å€™ã€å‡½æ•°è¿”å›å€¼ï¼Œéœ€è¦ä½¿ç”¨nilæ¥è¡¨ç¤ºå«ä¹‰ã€éœ€è¦åˆ‡ç‰‡æ“ä½œã€‚ str2 := str1 å­—ç¬¦ä¸²é—´èµ‹å€¼ä¼šå…±ç”¨åŒä¸€ä¸ªåº•å±‚æ•°ç»„ï¼Ÿ å­—ç¬¦ä¸²é—´èµ‹å€¼ï¼Œã€ä¼šã€‘å…±ç”¨åŒä¸€ä¸ªåº•å±‚æ•°ç»„ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 { var str1 = \u0026#34;hello\u0026#34; str2 := str1 // åŒç”¨äº†ä¸€ä¸ªåº•å±‚æ•°ç»„ // å› ä¸ºå­—ç¬¦ä¸²æ—¶åªè¯»ç±»å‹ï¼Œå› æ­¤èµ‹å€¼å…±ç”¨åŒä¸€ä¸ªåº•å±‚ä¹Ÿæ²¡æœ‰é—®é¢˜ã€‚ fmt.Println(*(*stringStruct)(unsafe.Pointer(\u0026amp;str1))) // {15567553 5} fmt.Println(*(*stringStruct)(unsafe.Pointer(\u0026amp;str2))) // {15567553 5} }\ttype stringStruct struct { str uintptr len uintptr } s := []byte(str) å­—ç¬¦ä¸²å¼ºåˆ¶è½¬æˆ[]byteæ˜¯å¦å…±ç”¨åŒä¸€ä¸ªåº•å±‚æ•°ç»„ï¼Ÿ ã€ä¸ä¼šã€‘åŒç”¨ä¸€ä¸ªåº•å±‚æ•°ç»„ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;unsafe\u0026#34; ) func main() { str := \u0026#34;hello\u0026#34; s := []byte(str) s[0] = \u0026#39;e\u0026#39; fmt.Println(str, s) // æ¢ç©¶å­—ç¬¦ä¸²å¼ºåˆ¶è½¬æ¢æˆåˆ‡ç‰‡åº•å±‚æ•°ç»„æ˜¯å¦å‘ç”Ÿå˜åŒ– fmt.Printf(\u0026#34;å­—ç¬¦ä¸²æŒ‡å‘åº•å±‚æ•°ç»„ï¼š%x\\n\u0026#34;, *(*uintptr)(unsafe.Pointer(\u0026amp;str))) fmt.Printf(\u0026#34;str[0]:%c\\n\u0026#34;, *(*byte)(unsafe.Pointer(uintptr(unsafe.Pointer(nil)) + *(*uintptr)(unsafe.Pointer(\u0026amp;str))))) fmt.Printf(\u0026#34;åˆ‡ç‰‡æŒ‡å‘çš„åº•å±‚æ•°ç»„ï¼š%x\\n\u0026#34;, *(*uintptr)(unsafe.Pointer(\u0026amp;s))) fmt.Printf(\u0026#34;åˆ‡ç‰‡s[0]åœ°å€ï¼š%p\\n\u0026#34;, \u0026amp;s[0]) // Output: // hello [101 101 108 108 111] // å­—ç¬¦ä¸²æŒ‡å‘åº•å±‚æ•°ç»„ï¼š12e9c2 // str[0]:h // åˆ‡ç‰‡æŒ‡å‘çš„åº•å±‚æ•°ç»„ï¼šc00000e0b0 // åˆ‡ç‰‡s[0]åœ°å€ï¼š0xc00000e0b0 } string è½¬ []byte 1 2 3 4 5 6 7 8 9 10 11 12 package main import \u0026#34;fmt\u0026#34; func main() { s := \u0026#34;hello Goè¯­è¨€\u0026#34; // ä¸‹é¢ä»£ç å¯ä»¥çœ‹å‡ºï¼Œså’Œbå¹¶ã€æ²¡æœ‰ã€‘å…±ç”¨åŒä¸€ä¸ªåº•å±‚æ•°ç»„ b := []byte(s) // è¿™é‡Œä¼šè°ƒç”¨ runtime.stringtoslicebyte å‡½æ•° fmt.Println(b) } stringtoslicebyte() stringè½¬slice byteï¼Œstring -\u0026gt; []byteã€‚ å‚æ•°ï¼š buf *tmpBufï¼štype tmpBuf [32]byteï¼Œ[32]byteæ•°ç»„ç”¨äºè½¬æ¢å¤§å°åœ¨32å­—èŠ‚çš„ä¸´æ—¶å­˜å‚¨è½¬æ¢å®¹å™¨ã€‚ä¸Šä¸€ç« çš„\u0026quot;ä¿®æ”¹å­—ç¬¦ä¸²\u0026quot;èŠ‚stringè½¬[]byteåcapå€¼ä¸º32å°±æ˜¯è¿™ä¸ªå‚æ•°çš„åŸå› ã€‚ s stringï¼šè½¬æ¢å­—ç¬¦ä¸²ã€‚ è¿”å›å€¼ï¼š []byteï¼šè½¬æ¢åçš„slice byteã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 func stringtoslicebyte(buf *tmpBuf, s string) []byte { var b []byte // nil // tmpBuf å®¹é‡å¤Ÿ s çš„æœ¬æ¬¡è½¬æ¢ if buf != nil \u0026amp;\u0026amp; len(s) \u0026lt;= len(buf) { // è¿™é‡Œä¹Ÿå°±æ˜¯ []byte(string) æ²¡ç”¨å…±ç”¨ä¸€ä¸ªåº•å±‚æ•°ç»„çš„åŸå› æ‰€åœ¨ *buf = tmpBuf{} // æ¸…ç©º å¹¶ åˆå§‹åŒ–æ–°çš„å®¹é‡ {0xxxx, 0, 32} b = buf[:len(s)]\t} else { // å®¹å™¨å¤§å°ä¸å¤Ÿï¼Œéœ€è¦é‡æ–°ç”³è¯·å¤§å° b = rawbyteslice(len(s)) } // copy([]byte, string) int copy(b, s) // æ‹·è´å­—ç¬¦ä¸²ä¸­çš„æ•°æ® return b } rawbyteslice() rawbytesliceåˆ†é…ä¸€ä¸ªæ–°çš„byte sliceã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // rawbyteslice allocates a new byte slice. The byte slice is not zeroed. func rawbyteslice(size int) (b []byte) { // å› ä¸ºæ˜¯ byte æ‰€ä»¥ç›´æ¥ä¼  size å¤§å°å³å¯ï¼ŒåŒ¹é…æœ€è¿‘æ¥çš„å†…å­˜å—è§„æ ¼å¤§å° cap := roundupsize(uintptr(size)) // è°ƒæ•´sizeå¤§å° // è¿™é‡Œæ˜¯ []byte(string) æ²¡ç”¨å…±ç”¨ä¸€ä¸ªåº•å±‚æ•°ç»„çš„åŸå› æ‰€åœ¨ p := mallocgc(cap, nil, false) // ç”³è¯·capå¤§å°å†…å­˜ï¼Œpæ˜¯ç”³è¯·åçš„å†…å­˜åœ°å€ if cap != uintptr(size) { // æ¸…é›¶å¤šä½™çš„è¿™éƒ¨åˆ†å†…å­˜å— memclrNoHeapPointers(add(p, uintptr(size)), cap-uintptr(size)) } // å°†ç”³è¯·çš„å¤§å°èµ‹å€¼ä¸ªè¿”å›å€¼b *(*slice)(unsafe.Pointer(\u0026amp;b)) = slice{p, size, int(cap)} return } []byte è½¬ string 1 2 3 4 5 6 7 8 9 10 11 12 package main import \u0026#34;fmt\u0026#34; func main() { b := []byte{\u0026#39;h\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;l\u0026#39;, \u0026#39;l\u0026#39;, \u0026#39;o\u0026#39;} // ä¸‹é¢æºç å¯ä»¥çœ‹å‡ºï¼Œbå’Œså¹¶ã€æ²¡æœ‰ã€‘å…±ç”¨åŒä¸€ä¸ªåº•å±‚æ•°ç»„ s := string(b) // è¿™é‡Œä¼šè°ƒç”¨ runtime.slicebytetostring å‡½æ•° fmt.Println(s) } slicebytetostring() slicebytetostringå°†å­—èŠ‚åˆ‡ç‰‡è½¬æ¢ä¸ºå­—ç¬¦ä¸²ï¼Œstring([]byte)ã€‚ å®ƒç”±ç¼–è¯‘å™¨æ’å…¥åˆ°ç”Ÿæˆçš„ä»£ç ä¸­ã€‚ ptræ˜¯ä¸€ä¸ªæŒ‡é’ˆï¼ŒæŒ‡å‘åˆ‡ç‰‡çš„ç¬¬ä¸€ä¸ªå…ƒç´ ; næ˜¯åˆ‡ç‰‡çš„é•¿åº¦ã€‚ bufæ˜¯ä¸€ä¸ªå›ºå®šå¤§å°çš„ç¼“å†²åŒºï¼Œå¦‚æœç»“æœæ²¡æœ‰escapeè½¬ä¹‰å­—ç¬¦ï¼Œå®ƒå°±ä¸æ˜¯nilã€‚ å‚æ•°ï¼š buf *tmpBufï¼štype tmpBuf [32]byteï¼Œ[32]byteæ•°ç»„ ç”¨äºè½¬æ¢å¤§å°åœ¨32å­—èŠ‚çš„ä¸´æ—¶å­˜å‚¨è½¬æ¢å®¹å™¨ã€‚ ptr *byteï¼š[]byteåˆ‡ç‰‡çš„åº•å±‚æ•°ç»„åœ°å€ï¼Œä¹Ÿå°±æ˜¯slice.dataçš„å€¼ã€‚ n intï¼šåˆ‡ç‰‡çš„é•¿åº¦ï¼Œä¹Ÿå°±æ˜¯slice.lençš„å€¼ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 // slicebytetostring converts a byte slice to a string. // It is inserted by the compiler into generated code. // ptr is a pointer to the first element of the slice; // n is the length of the slice. // Buf is a fixed-size buffer for the result, // it is not nil if the result does not escape. func slicebytetostring(buf *tmpBuf, ptr *byte, n int) (str string) { // æ²¡æœ‰éœ€è¦è½¬æ¢çš„ if n == 0 { // Turns out to be a relatively common case. // Consider that you want to parse out data between parens in \u0026#34;foo()bar\u0026#34;, // you find the indices and convert the subslice to string. return \u0026#34;\u0026#34; } if raceenabled { racereadrangepc(unsafe.Pointer(ptr), uintptr(n), getcallerpc(), abi.FuncPCABIInternal(slicebytetostring)) } if msanenabled { msanread(unsafe.Pointer(ptr), uintptr(n)) } if asanenabled { asanread(unsafe.Pointer(ptr), uintptr(n)) } // å½“[]byte åªæœ‰ä¸€ä¸ªå­—ç¬¦æ—¶ if n == 1 {\t// staticuint64sæ˜¯ä¸€ä¸ª[256]uint64çš„æ•°ç»„ï¼Œä¹Ÿå°±æ˜¯ASCIIçš„æ•°ç»„æ•°ç»„ // è¿™é‡Œå¯ä»¥çœ‹å‡ºå¹¶ä¸æ˜¯ç”¨çš„åŒä¸€ä¸ªåº•å±‚æ•°ç»„ã€‚ p := unsafe.Pointer(\u0026amp;staticuint64s[*ptr])\tif goarch.BigEndian {\t// æŸäº›å¹³å°éœ€è¦å­—èŠ‚å¯¹é½ p = add(p, 7) } stringStructOf(\u0026amp;str).str = p // èµ‹å€¼ç»™å­—ç¬¦ä¸²çš„str stringStructOf(\u0026amp;str).len = 1 // èµ‹å€¼ç»™å­—ç¬¦ä¸²çš„len return } var p unsafe.Pointer if buf != nil \u0026amp;\u0026amp; n \u0026lt;= len(buf) { // å½“é•¿åº¦åœ¨32èŒƒå›´å†…æ—¶ p = unsafe.Pointer(buf)\t// ç›´æ¥ä½¿ç”¨bufçš„å®¹é‡å½“åšåœ°å€ } else { p = mallocgc(uintptr(n), nil, false) // ç”³è¯·nå¤§å°çš„å†…å­˜åœ°å€å¤‡ç”¨ } stringStructOf(\u0026amp;str).str = p stringStructOf(\u0026amp;str).len = n memmove(p, unsafe.Pointer(ptr), uintptr(n)) // å°†ptråœ°å€é•¿åº¦ä¸ºnå­—èŠ‚çš„å†…å®¹ç§»åŠ¨åˆ°pä¸­ return } 1 2 3 4 5 6 7 8 type stringStruct struct { str unsafe.Pointer len int } func stringStructOf(sp *string) *stringStruct { return (*stringStruct)(unsafe.Pointer(sp)) } string è½¬ []rune 1 2 3 4 5 6 7 8 9 10 11 12 package main import \u0026#34;fmt\u0026#34; func main() { s := \u0026#34;hello Goè¯­è¨€\u0026#34; // ä¸‹é¢ä»£ç å¯ä»¥çœ‹å‡ºï¼Œså’Œbå¹¶ã€æ²¡æœ‰ã€‘å…±ç”¨åŒä¸€ä¸ªåº•å±‚æ•°ç»„ b := []rune(s) // è¿™é‡Œä¼šè°ƒç”¨ runtime.stringtoslicerune å‡½æ•° fmt.Println(b) } stringtoslicerune() stringè½¬slice runeï¼Œ[]rune(string)ã€‚ å‚æ•°ï¼š buf *[tmpStringBufSize]runeï¼š*[32]rune 32ä½ç¼“å­˜runeã€‚ s stringï¼šç›®æ ‡å­—ç¬¦ä¸²ã€‚ è¿”å›å€¼ï¼š []runeï¼šè½¬æ¢åçš„åˆ‡ç‰‡ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 // string to slice rune func stringtoslicerune(buf *[tmpStringBufSize]rune, s string) []rune { // two passes. // unlike slicerunetostring, no race because strings are immutable. n := 0 for range s { // éå†sç»Ÿè®¡runeçš„æ€»é‡ n++ } var a []rune if buf != nil \u0026amp;\u0026amp; n \u0026lt;= len(buf) { // æ»¡è¶³32å­—èŠ‚ *buf = [tmpStringBufSize]rune{} a = buf[:n] } else { a = rawruneslice(n) // å‘ç³»ç»Ÿç”³è¯·nå¤§å°çš„å†…å­˜ } n = 0 for _, r := range s { // é€šè¿‡éå†å°†så­˜å‚¨åˆ°aä¸­ a[n] = r n++ } return a } rawruneslice() 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 // rawruneslice allocates a new rune slice. The rune slice is not zeroed. func rawruneslice(size int) (b []rune) { if uintptr(size) \u0026gt; maxAlloc/4 { // å†…å­˜æº¢å‡ºæƒ…æ™¯ throw(\u0026#34;out of memory\u0026#34;) } // rune = int32 å 4å­—èŠ‚ï¼ŒåŒ¹é…æœ€æ¥è¿‘çš„å†…å­˜å— mem := roundupsize(uintptr(size) * 4) // è¿™é‡Œæ˜¯æ²¡æœ‰ä½¿ç”¨åŒä¸€ä¸ªåœ°å€çš„åŸå›  // å‘ç³»ç»Ÿç”³è¯·å†…å­˜çš„å¤§å°æ˜¯ç›´æ¥ï¼Œè€Œsizeè¡¨ç¤ºçš„å­—ç¬¦çš„ä¸ªæ•°ï¼Œæ‰€ä»¥è¿™é‡Œæ˜¯éœ€è¦ä¹˜ä»¥4çš„ p := mallocgc(mem, nil, false)\tif mem != uintptr(size)*4 { memclrNoHeapPointers(add(p, uintptr(size)*4), mem-uintptr(size)*4) // æ¸…é›¶æœªä½¿ç”¨çš„é‚£éƒ¨åˆ†å†…å­˜å— } *(*slice)(unsafe.Pointer(\u0026amp;b)) = slice{p, size, int(mem / 4)} // ç”³è¯·åçš„èµ‹å€¼è¿”å› return } []rune è½¬ string 1 2 3 4 5 6 7 8 9 10 11 12 package main import \u0026#34;fmt\u0026#34; func main() { b := []rune{104, 101, 108, 108, 111, 32, 71, 111, 35821, 35328} // ä¸‹é¢æºç å¯ä»¥çœ‹å‡ºï¼Œbå’Œså¹¶ã€æ²¡æœ‰ã€‘å…±ç”¨åŒä¸€ä¸ªåº•å±‚æ•°ç»„ s := string(b) // è¿™é‡Œä¼šè°ƒç”¨ runtime.slicerunetostring å‡½æ•° fmt.Println(s) } slicerunetostring() slice rune è½¬ stringï¼Œstring([]rune)ã€‚ å‚æ•°ï¼š buf *tmpBufï¼štype tmpBuf [32]byteï¼Œ[32]byteæ•°ç»„ç”¨äºè½¬æ¢å¤§å°åœ¨32å­—èŠ‚çš„ä¸´æ—¶å­˜å‚¨è½¬æ¢å®¹å™¨ã€‚ a []runeï¼šè½¬æ¢çš„åˆ‡ç‰‡ã€‚ è¿”å›å€¼ï¼š stringï¼šè½¬æ¢åçš„å­—ç¬¦ä¸²ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 // slice rune to string func slicerunetostring(buf *tmpBuf, a []rune) string { if raceenabled \u0026amp;\u0026amp; len(a) \u0026gt; 0 { racereadrangepc(unsafe.Pointer(\u0026amp;a[0]), uintptr(len(a))*unsafe.Sizeof(a[0]), getcallerpc(), abi.FuncPCABIInternal(slicerunetostring)) } if msanenabled \u0026amp;\u0026amp; len(a) \u0026gt; 0 { msanread(unsafe.Pointer(\u0026amp;a[0]), uintptr(len(a))*unsafe.Sizeof(a[0])) } if asanenabled \u0026amp;\u0026amp; len(a) \u0026gt; 0 { asanread(unsafe.Pointer(\u0026amp;a[0]), uintptr(len(a))*unsafe.Sizeof(a[0])) } var dum [4]byte // ä¸´æ—¶å®¹å™¨ // è®°å½•[]runeåˆ‡ç‰‡è½¬stringéœ€è¦çš„æ€»å­—èŠ‚æ•°é‡ byte size1 := 0\tfor _, r := range a { // ã€int runeã€‘ // encoderune å‡½æ•°è§£ç rå¹¶æŠŠå€¼å­˜å…¥ç¬¬ä¸€ä¸ªå‚æ•°ä¸­ï¼Œè¿”å›è§£ç çš„å­—èŠ‚æ•°é‡ size1 += encoderune(dum[:], r)\t} // è¿”å›ä¸€ä¸ªså’Œbåº•å±‚æ•°ç»„ç›¸å…³è”çš„ï¼Œè¿™é‡Œsize1+3æ˜¯ä¸ºäº†å…¼å®¹æœ€åä¸€ä¸ªæ˜¯ASCIIæƒ…å†µ s, b := rawstringtmp(buf, size1+3)\tsize2 := 0\t// ç»Ÿè®¡æ•°é‡ for _, r := range a { // check for race // å¯èƒ½å­˜åœ¨ []rune ä¸­ \u0026#39;\u0026#39; è¿™ç§æ•°æ® if size2 \u0026gt;= size1 { break } // ä¹Ÿå°±æ˜¯è¿™é‡Œå®ç°äº†å°†æ•°æ®å†™å…¥å­—ç¬¦ä¸²åœ°å€ä¸­ï¼Œå› ä¸ºåˆ‡ç‰‡å’Œå­—ç¬¦ä¸²å…±ç”¨åŒä¸€ä¸ªåº•å±‚æ•°ç»„ // encoderuneè¯¥å‡½æ•°çš„ä½œç”¨æ˜¯å°†rè§£ç å¹¶å­˜å…¥ç¬¬ä¸€ä¸ªå‚æ•°ä½ç½®ï¼Œå¹¶è¿”å›rçš„ç¼–ç å­—èŠ‚é•¿åº¦ size2 += encoderune(b[size2:], r)\t} return s[:size2] // åˆ‡å‰²å­—ç¬¦ä¸²så¾—åˆ°çš„ä¾ç„¶æ˜¯å­—ç¬¦ä¸²ç±»å‹ } rawstringtmp() 1 2 3 4 5 6 7 8 9 10 // è¿”å›ä¸€ä¸ªså’Œbå…±ç”¨åŒä¸€ä¸ªåº•å±‚æ•°ç»„ func rawstringtmp(buf *tmpBuf, l int) (s string, b []byte) { if buf != nil \u0026amp;\u0026amp; l \u0026lt;= len(buf) { // å¦‚æœæ»¡è¶³32å­—èŠ‚å†… b = buf[:l] s = slicebytetostringtmp(\u0026amp;b[0], len(b)) // å¤„ç†så’Œbçš„å…³è”å…³ç³» } else { s, b = rawstring(l) // ä»æ–°ç”³è¯·ä¸€å—å†…å­˜ å…³è”så’Œbçš„åº•å±‚æ•°ç»„å…³è”å…³ç³» } return } slicebytetostringtmp() 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 // slicebytetostringtmp returns a \u0026#34;string\u0026#34; referring to the actual []byte bytes. // // Callers need to ensure that the returned string will not be used after // the calling goroutine modifies the original slice or synchronizes with // another goroutine. // // The function is only called when instrumenting // and otherwise intrinsified by the compiler. // // Some internal compiler optimizations use this function. // - Used for m[T1{... Tn{..., string(k), ...} ...}] and m[string(k)] // where k is []byte, T1 to Tn is a nesting of struct and array literals. // - Used for \u0026#34;\u0026lt;\u0026#34;+string(b)+\u0026#34;\u0026gt;\u0026#34; concatenation where b is []byte. // - Used for string(b)==\u0026#34;foo\u0026#34; comparison where b is []byte. func slicebytetostringtmp(ptr *byte, n int) (str string) { if raceenabled \u0026amp;\u0026amp; n \u0026gt; 0 { racereadrangepc(unsafe.Pointer(ptr), uintptr(n), getcallerpc(), abi.FuncPCABIInternal(slicebytetostringtmp)) } if msanenabled \u0026amp;\u0026amp; n \u0026gt; 0 { msanread(unsafe.Pointer(ptr), uintptr(n)) } if asanenabled \u0026amp;\u0026amp; n \u0026gt; 0 { asanread(unsafe.Pointer(ptr), uintptr(n)) } // é€šè¿‡å‚æ•°è¿”å›ä¸€ä¸ªptrå’Œè¿”å›strç›¸å…³è”çš„åº•å±‚æ•°ç»„ stringStructOf(\u0026amp;str).str = unsafe.Pointer(ptr)\tstringStructOf(\u0026amp;str).len = n return } rawstring() 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // rawstring allocates storage for a new string. The returned // string and byte slice both refer to the same storage. // The storage is not zeroed. Callers should use // b to set the string contents and then drop b. func rawstring(size int) (s string, b []byte) { // å‘ç³»ç»Ÿç”³è¯·å†…å­˜ p := mallocgc(uintptr(size), nil, false) stringStructOf(\u0026amp;s).str = p stringStructOf(\u0026amp;s).len = size *(*slice)(unsafe.Pointer(\u0026amp;b)) = slice{p, size, size} return } string -\u0026gt; string[:] è¿™ç§æƒ…å†µä¸‹æ²¡æœ‰æ–°ç”³è¯·å†…å­˜ï¼Œè€Œæ˜¯ã€å…±ç”¨ã€‘çš„ä¹‹å‰çš„å†…å­˜ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 package main import \u0026#34;fmt\u0026#34; func main() { s := \u0026#34;hello Goè¯­è¨€\u0026#34; // å­—ç¬¦ä¸²ä½¿ç”¨åˆ‡ç‰‡ç”Ÿæˆçš„ä¾ç„¶æ˜¯å­—ç¬¦ä¸²ç±»å‹ï¼ŒåŒç”¨ä¸€ä¸ªåº•å±‚æ•°æ®ã€‚ // ä¸‹é¢æˆ‘ä»¬æ¥åˆ†æä¸‹main.mainçš„æ±‡ç¼–ç  çœ‹çœ‹è¿™ä¸€è¡Œæ˜¯å¦‚ä½•æ“ä½œçš„ s1 := s[:] fmt.Println(s1) // s1çš„ç±»å‹ä¸ºstring } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 # s1 := s[:] æƒ…å†µ # æ¯”è¾ƒæ ˆæ˜¯å¦æº¢å‡º r14å­˜å‚¨çš„å½“å‰groutine string.go:5\t0x496680 493b6610 cmp rsp, qword ptr [r14+0x10]\tstring.go:5\t0x496684 0f86b9000000 jbe 0x496743 # ç»™main.mainå‡½æ•°æ ˆé¢„åˆ†é…0x78å¤§å° string.go:5\t0x49668a 4883ec78 sub rsp, 0x78\t# å°†runtime.mainå‡½æ•°çš„æ ˆåŸºå€rspå…¥æ ˆï¼Œä»¥ä¾¿main.mainæ‰§è¡Œå®Œå¥½æ¢å¤ string.go:5\t0x49668e 48896c2470 mov qword ptr [rsp+0x70], rbp\t# å°†rbpæŒ‡å‘main.mainçš„æ–°æ ˆåŸºä½ç½®ï¼Œè¡¨ç¤ºmain.mainçš„æ ˆä¿¡æ¯èŒƒå›´ string.go:5\t0x496693 488d6c2470 lea rbp, ptr [rsp+0x70]\t# è¯¥æ“ä½œç­‰äºå°†å­—ç¬¦ä¸²sçš„åº•å±‚æ•°ç»„åœ°å€æ”¾å…¥rcx string.go:6\t0x496698 488d0de87c0100 lea rcx, ptr [rip+0x17ce8]\t# åˆ™éƒ¨æ“ä½œä¸ºç»™s.strèµ‹å€¼ã€‚s.data=rip+0x17ce8 string.go:6\t0x49669f 48894c2438 mov qword ptr [rsp+0x38], rcx # è¯¥æ“ä½œä¸ºç»™s.lenèµ‹å€¼ï¼Œæ ‡æ˜å­—ç¬¦ä¸²é•¿åº¦å¤§å°ã€‚s.len=14 string.go:6\t0x4966a4 48c74424400e000000 mov qword ptr [rsp+0x40], 0xe\t# ä»¥ä¸‹ä¸¤è¡Œæ˜¯ç¬¬9è¡Œä»£ç  s1 := s[:]\t# å¯ä»¥çœ‹è§æ˜¯å…¬å…±ç”¨çš„åŒä¸€ä¸ªåº•å±‚æ•°ç»„ã€‚ string.go:9\t0x4966ad 48894c2428 mov qword ptr [rsp+0x28], rcx\tstring.go:9\t0x4966b2 48c74424300e000000 mov qword ptr [rsp+0x30], 0xe ä¿®æ”¹ç¬¬10è¡Œs1 := s[:]ä¸ºs1 := s[:5]ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 # s1 := s[:5] æƒ…å†µ string.go:5\t0x496680 493b6610 cmp rsp, qword ptr [r14+0x10] string.go:5\t0x496684 0f86c6000000 jbe 0x496750 string.go:5\t0x49668a 4883ec78 sub rsp, 0x78 string.go:5\t0x49668e 48896c2470 mov qword ptr [rsp+0x70], rbp string.go:5\t0x496693 488d6c2470 lea rbp, ptr [rsp+0x70] # è¿™é‡Œå‡ è¡Œç»™sèµ‹å€¼ string.go:6\t0x496698 488d0de87c0100 lea rcx, ptr [rip+0x17ce8]\tstring.go:6\t0x49669f 48894c2438 mov qword ptr [rsp+0x38], rcx string.go:6\t0x4966a4 48c74424400e000000 mov qword ptr [rsp+0x40], 0xe string.go:9\t0x4966ad eb00 jmp 0x4966af string.go:9\t0x4966af eb00 jmp 0x4966b1 # è¿™å‡ è¡Œs[:5]ï¼Œä¸ºä»€ä¹ˆè¿™é‡Œçš„rip+0x17ccfå’Œä¸Šé¢çš„rip+0x17ce8ä¸ä¸€è‡´ï¼Ÿ # åŸå› æ˜¯Goé‡‡ç”¨çš„åœ°å€åŠ åç§»é‡çš„å½¢å¼ï¼Œè¿™é‡Œä¸å‰é¢çš„å·®é‡æ‰€ä»¥åç§»é‡æœ‰æ‰€å˜åŒ– # è¿˜æœ‰ä¸ªåŸå› æ˜¯ç¼–è¯‘é˜¶æ®µçš„å­—ç¬¦ä¸²æ˜¯è¢«å­˜å‚¨åœ¨ä»£ç æ®µçš„ï¼Œæ‰€ä»¥é€šè¿‡è¿™ç§å½¢å¼ï¼Œ # å¦‚æœæ˜¯è¢«å­˜å‚¨åœ¨æ ˆæˆ–å †ä¸Šå‘¢ï¼Œæ ˆåˆ™æ˜¯rsp+åç§»é‡çš„å½¢å¼ string.go:9\t0x4966b1 488d0dcf7c0100 lea rcx, ptr [rip+0x17ccf]\tstring.go:9\t0x4966b8 48894c2428 mov qword ptr [rsp+0x28], rcx string.go:9\t0x4966bd 48c744243005000000 mov qword ptr [rsp+0x30], 0x5 # æ›´å¤šs1 := s[2:5]åŸºæœ¬å’Œä¸Šé¢æƒ…å†µå·®ä¸å¤š æ³¨æ„ ä¸è¦å‘½åæ ‡è¯†ç¬¦å’ŒåŒ…åç§°ä¸€æ ·ï¼Œè¿™æ ·ä¼šå¯¼è‡´å¼•ç”¨åŒ…åç§°æ—¶éœ€è¦æ·»åŠ ç‰¹æ®Šåˆ«åç§°ï¼Œæ¯”å¦‚å‘½åå‡½æ•°åç§°bytes()å’ŒbytesåŒ…ä¸€è‡´ï¼Œå¯¼è‡´bytesåŒ…éœ€è¦åˆ«åç§°bytes2 \u0026quot;bytes\u0026quot;ã€‚ å‚è€ƒ å­—ç¬¦ä¸²å†…å­˜å¸ƒå±€ å­—ç¬¦ä¸²å†…å­˜å¸ƒå±€ å­—ç¬¦ä¸²å†…å­˜ unicodeã€utf8ã€utf16ã€utf32 ","permalink":"https://heliu.site/posts/golang/basic/string-memory/","summary":"Golang ä»‹ç»å­—ç¬¦ä¸²çš„å†…å­˜ç»“æ„ã€‚","title":"å­—ç¬¦ä¸²(å†…å­˜å¸ƒå±€)"},{"content":"+å­—ç¬¦ä¸²æ‹¼æ¥ golangä¸­ä½¿ç”¨+æ‹¼æ¥å­—ç¬¦ä¸²ä¼šè°ƒç”¨concatstringX()ç›¸å…³å‡½æ•°ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 // a0 + a1 func concatstring2(buf *tmpBuf, a0, a1 string) string { return concatstrings(buf, []string{a0, a1}) } // a0 + a1 + a2 func concatstring3(buf *tmpBuf, a0, a1, a2 string) string { return concatstrings(buf, []string{a0, a1, a2}) } // a0 + a1 + a2 + a3 func concatstring4(buf *tmpBuf, a0, a1, a2, a3 string) string { return concatstrings(buf, []string{a0, a1, a2, a3}) } // a0 + a1 + a2 + a3 + a4 func concatstring5(buf *tmpBuf, a0, a1, a2, a3, a4 string) string { return concatstrings(buf, []string{a0, a1, a2, a3, a4}) } const 1 2 3 4 5 6 // The constant is known to the compiler. // There is no fundamental theory behind this number. // // è¯¥å¸¸é‡æ˜¯ç¼–è¯‘å™¨å·²çŸ¥çš„ // è¿™ä¸ªæ•°å­—èƒŒåæ²¡æœ‰åŸºæœ¬ç†è®º const tmpStringBufSize = 32 type 1 2 // å½“è¦æ‹¼æ¥çš„å­—ç¬¦ä¸²é•¿åº¦å°äºç­‰äº32å­—èŠ‚å¤§å°ï¼Œä½¿ç”¨è¯¥ä¸´æ—¶ç¼“å­˜å®¹å™¨ï¼Œå¦åˆ™é‡æ–°ç”Ÿæˆä¸€ä¸ªå†…å­˜ç©ºé—´ä½¿ç”¨ type tmpBuf [tmpStringBufSize]byte\t// tmpBufåªæ˜¯ç”¨äºå®šä¹‰ä¸€ä¸ª*[32]byteçš„ç¼“å†² concatstrings() 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 // concatstrings implements a Go string concatenation x+y+z+... // The operands are passed in the slice a. // If buf != nil, the compiler has determined that the result does not // escape the calling function, so the string data can be stored in buf // if small enough. // // concatstrings å®ç°äº†ä¸€ä¸ª Go å­—ç¬¦ä¸²è¿æ¥ x+y+z+... æ“ä½œæ•°åœ¨åˆ‡ç‰‡ a ä¸­ä¼ é€’ // å¦‚æœ buf != nilï¼Œç¼–è¯‘å™¨å·²ç»ç¡®å®šç»“æœä¸ä¼šè½¬ä¹‰è°ƒç”¨å‡½æ•°ï¼Œæ‰€ä»¥å¦‚æœè¶³å¤Ÿå°ï¼Œå­—ç¬¦ä¸²æ•°æ®å¯ä»¥å­˜å‚¨åœ¨ buf ä¸­ func concatstrings(buf *tmpBuf, a []string) string { idx := 0 // è®°å½•aä¸­æœ€åä¸€ä¸ªä¸ä¸ºç©ºçš„ä¸‹æ ‡ç´¢å¼•å€¼ l := 0 // ç»Ÿè®¡aåˆ‡ç‰‡ä¸­æ‰€æœ‰å­—ç¬¦ä¸²å…ƒç´ çš„å­—èŠ‚æ•°é‡ï¼Œè¯¥å€¼ä¸»è¦ç”¨äºç»Ÿè®¡æ‹¼æ¥æ€»å¤§å°ç”¨äºç¡®å®šå†…å­˜ count := 0 // ç»Ÿè®¡aåˆ‡ç‰‡ä¸­æœ‰æ•ˆçš„å…ƒç´ æ•°é‡ï¼Œä¸ä¸ºç©ºçš„å­—ç¬¦ä¸² for i, x := range a { n := len(x) // è·å–å­—ç¬¦ä¸²é•¿åº¦å­—èŠ‚ if n == 0 { continue } // è¯¥æƒ…å†µå‘ç”Ÿåœ¨å­—ç¬¦ä¸²æ•°é‡å¤ªé•¿å¯¼è‡´intç±»å‹æº¢å‡ºæƒ…å†µ if l+n \u0026lt; l {\tthrow(\u0026#34;string concatenation too long\u0026#34;) } l += n // åŠ ä¸Šå½“å‰å­—ç¬¦ä¸²çš„é•¿åº¦ï¼Œè®°å½•çš„æ˜¯æ‰€æœ‰çš„å­—èŠ‚Bæ•°é‡ count++ // åˆ‡ç‰‡aä¸­æ‰€æœ‰æœ‰æ•ˆçš„çš„å­—ç¬¦ä¸²ï¼Œä¹Ÿå°±æ˜¯ä¸æ˜¯ç©ºä¸²çš„å­—ç¬¦ä¸²æ•°é‡ idx = i // è®°å½•æœ€æœ‰ä¸€ä¸ªæœ‰æ•ˆçš„å­—ç¬¦ä¸²çš„ç´¢å¼•ä¸‹æ ‡æ•° } if count == 0 { return \u0026#34;\u0026#34; } // If there is just one string and either it is not on the stack // or our result does not escape the calling frame (buf != nil), // then we can return that string directly. // // å¦‚æœåªæœ‰ä¸€ä¸ªå­—ç¬¦ä¸²å¹¶ä¸”å®ƒä¸åœ¨å †æ ˆä¸Šï¼Œæˆ–è€…æˆ‘ä»¬çš„ç»“æœæ²¡æœ‰è½¬ä¹‰è°ƒç”¨å¸§ï¼ˆbufï¼= nilï¼‰ï¼Œé‚£ä¹ˆæˆ‘ä»¬å¯ä»¥ç›´æ¥è¿”å›è¯¥å­—ç¬¦ä¸² // !stringDataOnStack(a[idx]) å¦‚æœä¸ºtrueè¡¨ç¤ºå½“å‰a[idx]ä¸åœ¨å½“å‰goroutineçš„è¿è¡Œæ ˆä¸­ï¼Œé‚£ä¹ˆè¡¨ç¤ºå¯ä»¥è¿”å› // å› ä¸ºgoroutineçš„æ ˆä¼šåœ¨gè¢«è¿è¡Œå®Œé”€æ¯ï¼Œæ‰€ä»¥ä¸é€‚åˆç›´æ¥è¿”å› // a[idx]åœ¨goroutineæ ˆä¸Šæ—¶ï¼Œç»§ç»­å»ä¸‹é¢ rawstringtmp if count == 1 \u0026amp;\u0026amp; (buf != nil || !stringDataOnStack(a[idx])) { return a[idx] // å¦‚æœcountä¸º1é‚£ä¹ˆ idxå­˜å‚¨çš„å°±æ˜¯è¿™ä¸ªå”¯ä¸€çš„æœ‰æ•ˆçš„å­—ç¬¦ä¸²ç´¢å¼•å€¼ } // sä¸bæ˜¯é•¿åº¦ä¸ºlçš„åº•å±‚æ•°ç»„ç›¸äº’å…³è”çš„ï¼Œè¿™æ‰€ä»¥è¿™æ ·æ˜¯å­—ç¬¦ä¸²æ˜¯ä¸å¯å˜ç±»å‹æˆ‘ä»¬éœ€è¦é€šè¿‡åˆ‡ç‰‡å¤„ç† s, b := rawstringtmp(buf, l)\t// æŠŠæ¥è‡ªaçš„å­—ç¬¦ä¸²æ‹·è´åˆ°bä¸­ï¼Œä¹Ÿå°±æ˜¯æ‹·è´åˆ°sä¸­ for _, x := range a { // æ‹·è´xåˆ°b\t// int copy([]byte, string) // è¿™ä¸€æ­¥æ“ä½œæ˜¯å› ä¸ºcopyå‡½æ•°çš„æ‹·è´æœºåˆ¶ copy(b, x)\tb = b[len(x):]\t} return s // såˆ™æ˜¯æ‹¼æ¥åçš„å­—ç¬¦ä¸² } stringDataOnStack() 1 2 3 4 5 6 7 8 9 // stringDataOnStack reports whether the string\u0026#39;s data is // stored on the current goroutine\u0026#39;s stack. // // stringDataOnStack æŠ¥å‘Šå­—ç¬¦ä¸²çš„æ•°æ®æ˜¯å¦å­˜å‚¨åœ¨å½“å‰ goroutine çš„å †æ ˆä¸­ func stringDataOnStack(s string) bool { ptr := uintptr(stringStructOf(\u0026amp;s).str) // ptrè·å–æ˜¯å­—ç¬¦ä¸²çš„åº•å±‚å€¼ stk := getg().stack\t// stkæ˜¯å½“å‰æ­£åœ¨è¿è¡Œçš„goroutineçš„æ ˆé¡¶å’Œæ ˆåº•èŒƒå›´ return stk.lo \u0026lt;= ptr \u0026amp;\u0026amp; ptr \u0026lt; stk.hi // åˆ¤æ–­å½“å‰å­—ç¬¦ä¸²æ˜¯å¦åœ¨è¿™ä¸ªèŒƒå›´å†… } stringStructOf() 1 2 3 4 5 6 7 8 9 func stringStructOf(sp *string) *stringStruct { /* type stringStruct struct { str unsafe.Pointer len int } */ return (*stringStruct)(unsafe.Pointer(sp)) } rawstringtmp() 1 2 3 4 5 6 7 8 9 10 11 // så’Œbéƒ½åˆ†åˆ«æŒ‡å‘bufï¼Œå¹¶ä¸”é•¿åº¦ä¸ºl func rawstringtmp(buf *tmpBuf, l int) (s string, b []byte) { // å½“å‰è¦å¤„ç†çš„é•¿åº¦låœ¨bufçš„èŒƒå›´å†… if buf != nil \u0026amp;\u0026amp; l \u0026lt;= len(buf) { b = buf[:l] // bufæ˜¯æ•°å­—æŒ‡é’ˆï¼Œå› æ­¤bæ˜¯åˆ‡ç‰‡å¼•ç”¨buf s = slicebytetostringtmp(\u0026amp;b[0], len(b)) // å°†bufä¸så…³è”èµ·æ¥ } else { s, b = rawstring(l) // é‡æ–°åˆ†é…å†…å­˜ï¼ŒæŠŠså’Œbå…³è”èµ·æ¥ } return } slicebytetostringtmp() 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 // slicebytetostringtmp returns a \u0026#34;string\u0026#34; referring to the actual []byte bytes. // // Callers need to ensure that the returned string will not be used after // the calling goroutine modifies the original slice or synchronizes with // another goroutine. // // The function is only called when instrumenting // and otherwise intrinsified by the compiler. // // Some internal compiler optimizations use this function. // - Used for m[T1{... Tn{..., string(k), ...} ...}] and m[string(k)] // where k is []byte, T1 to Tn is a nesting of struct and array literals. // - Used for \u0026#34;\u0026lt;\u0026#34;+string(b)+\u0026#34;\u0026gt;\u0026#34; concatenation where b is []byte. // - Used for string(b)==\u0026#34;foo\u0026#34; comparison where b is []byte. func slicebytetostringtmp(ptr *byte, n int) (str string) { if raceenabled \u0026amp;\u0026amp; n \u0026gt; 0 { racereadrangepc(unsafe.Pointer(ptr), uintptr(n), getcallerpc(), abi.FuncPCABIInternal(slicebytetostringtmp)) } if msanenabled \u0026amp;\u0026amp; n \u0026gt; 0 { msanread(unsafe.Pointer(ptr), uintptr(n)) } if asanenabled \u0026amp;\u0026amp; n \u0026gt; 0 { asanread(unsafe.Pointer(ptr), uintptr(n)) } // ä½¿stræŒ‡å‘ptrï¼Œé•¿åº¦ä¸ºn stringStructOf(\u0026amp;str).str = unsafe.Pointer(ptr) stringStructOf(\u0026amp;str).len = n return } rawstring() 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // rawstring allocates storage for a new string. The returned // string and byte slice both refer to the same storage. // The storage is not zeroed. Callers should use // b to set the string contents and then drop b. func rawstring(size int) (s string, b []byte) { p := mallocgc(uintptr(size), nil, false)\t// é‡æ–°ç”³è¯·å†…å­˜ // å…³è”så’Œb stringStructOf(\u0026amp;s).str = p stringStructOf(\u0026amp;s).len = size *(*slice)(unsafe.Pointer(\u0026amp;b)) = slice{p, size, size} return } ","permalink":"https://heliu.site/posts/golang/basic/string-splice/","summary":"Golang +æ‹¼æ¥ä»‹ç»ã€‚","title":"å­—ç¬¦ä¸²(+æ‹¼æ¥)"},{"content":"æ•°æ®ç»“æ„åŠç±»å‹ç»“æ„ æ•°æ®ç»“æ„åŠç±»å‹ç»“æ„ç»„æˆå›¾ï¼šï¼ˆå…³äºç±»å‹æ„æˆè¯¦ç»†åé¢æ–‡ç« ä»‹ç»ï¼‰ æ•°æ®ç»“æ„ æ•°æ®ç»“æ„è®°å½•å­—ç¬¦ä¸²è®°å½•çš„å†…å­˜æ•°æ®ç›¸å…³ä¿¡æ¯ã€‚æ¯”å¦‚ã€å­—ç¬¦ä¸²çš„å†…å®¹ã€‘ä»¥åŠã€å­—ç¬¦ä¸²çš„é•¿åº¦ã€‘ã€‚ String.dataï¼šæ˜¯ä¸€ä¸ªæŒ‡é’ˆï¼ŒæŒ‡å‘ä¸€ä¸ªbyteç±»å‹æ•°ç»„çš„é¦–åœ°å€ã€‚ String.lenï¼šè®°å½•å½“å‰å­—ç¬¦ä¸²çš„é•¿åº¦ï¼Œä»¥å­—èŠ‚ä¸ºå•ä½ã€‚ 1 2 3 4 type String struct { data unsafe.Pointer len int } ç±»å‹ç»“æ„ ç±»å‹ç»“æ„è®°å½•å­—ç¬¦ä¸²ç±»å‹ç›¸å…³ä¿¡æ¯ã€‚æ¯”å¦‚å­—ç¬¦ä¸²ã€å ç”¨å†…å­˜å¤§å°ã€‘ã€åŒ…å«æŒ‡é’ˆæ•°é‡ã€‘ã€å­—æ®µå¯¹é½ã€‘ç­‰ä¿¡æ¯ã€‚ _typeï¼šè®°å½•ç±»å‹åŸæ•°æ®ç»“æ„ï¼Œç”¨äºè¡¨ç¤ºæ‰€æœ‰ç±»å‹å…±æœ‰çš„å±æ€§ç»“æ„ã€‚ å…³äº_typeçš„å…·ä½“å«ä¹‰åœ¨ç›¸å…³ç« èŠ‚åˆ—å‡ºã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 type u struct { _type } type _type struct { size uintptr ptrdata uintptr hash uint32 tflag tflag align uint8 fieldAlign uint8 kind uint8 equal func(unsafe.Pointer, unsafe.Pointer) bool gcdata *byte str nameOff ptrToThis typeOff } ","permalink":"https://heliu.site/posts/golang/basic/string-type/","summary":"Golang å­—ç¬¦ä¸²çš„ç±»å‹ç»“æ„ä»‹ç»ã€‚","title":"å­—ç¬¦ä¸²(ç±»å‹ç»“æ„)"},{"content":"ifè¯­å¥ ifè¯­å¥åç´§è·Ÿä¸€ä¸ªæˆ–å¤šä¸ªè¯­å¥ç»„æˆï¼Œæ³¨æ„å¸ƒå°”è¡¨è¾¾å¼ä¸èƒ½ç”¨0æˆ–1ã€‚ å¦‚æœè¡¨è¾¾å¼æ±‚å€¼ä¸ºtrueï¼Œåˆ™æ‰§è¡Œ\u0026quot;if\u0026quot;åˆ†æ”¯ï¼Œå¦åˆ™æ‰§è¡Œ\u0026quot;else\u0026quot;åˆ†æ”¯ã€‚ GoLangä¸æ”¯æŒä¸‰ç›®è¿ç®— a \u0026gt; b ? a : bï¼Œå®˜æ–¹çš„è§£é‡Šæ˜¯ä¸‰ç›®è¿ç®—ä¼šå¯¼è‡´å¤æ‚çš„è¡¨è¾¾å¼ã€‚ 1 2 3 4 5 6 7 8 // 1) if expr { } //\tOR // 2) if Init; expr { } if å¸ƒå°”è¡¨è¾¾å¼ {\t// å¸ƒå°”è¡¨è¾¾å¼ä¸ºtrueæ—¶æ‰§è¡Œ } else { // å¸ƒå°”è¡¨è¾¾å¼ä¸ºfalseæ—¶æ‰§è¡Œ } ç”±äºifå’Œswitchéƒ½æ¥å—åˆå§‹åŒ–è¯­å¥ï¼Œå› æ­¤é€šå¸¸ä¼šçœ‹åˆ°ç”¨äºè®¾ç½®å±€éƒ¨å˜é‡çš„è¯­å¥ã€‚ è¯¥è¯­å¥åœ¨è®¡ç®—è¡¨è¾¾å¼ä¹‹å‰æ‰§è¡Œã€‚ ifå’Œelse ifåéƒ½å¯ä»¥è·Ÿã€Init; exprã€‘è¯­å¥ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 package main import ( \u0026#34;fmt\u0026#34; ) func main() { // è¿™é‡Œæ³¨æ„ï¼Œè¿™é‡Œä½¿ç”¨çš„æ˜¯ ; ä¸æ˜¯ , // 1. ;åˆ†å·ï¼šç”¨äºåˆ†éš”è¯­å¥ // 2. ,é€—å·ï¼šå¸¸ç”¨è¯­åˆ†éš”å˜é‡å¤šè¿”å›èµ‹å€¼å½¢å¼ if x := 1; x \u0026lt; 10 { fmt.Println(\u0026#34;12345\u0026#34;) } else if x \u0026gt; 0 { // else if x = 2; x \u0026gt; 0 {} fmt.Println(\u0026#34;6789\u0026#34;) } else { fmt.Println(\u0026#34;147258369\u0026#34;) } // be equivalent to // æ³¨æ„ï¼šxx çš„ä½œç”¨åŸŸï¼Œå½“å‰åˆ†æ”¯ä»¥åéƒ½é€‚ç”¨ { xx := 1 if xx \u0026lt; 10 { fmt.Println(\u0026#34;12345\u0026#34;) } else { if xx \u0026gt; 0 { fmt.Println(\u0026#34;6789\u0026#34;) } else { fmt.Println(\u0026#34;147258369\u0026#34;) } } } // else if å…¨éƒ¨éƒ½å¯ä»¥è½¬æ¢æˆif elseå½¢å¼ï¼Œè¿™é‡Œæ˜¯ä¸ºäº†æ›´å¥½çš„ç†è§£åˆå§‹åŒ–è¯­å¥æ‰€åœ¨å—ä½ç½® // Output: // 12345 // 12345 } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 func Ts() { rand.Seed(time.Now().UnixNano()) n := rand.Intn(100) // 1. éªŒè¯ if Init; expr {} è¯­å¥ // 2. éªŒè¯ else if Init; expr {} è¯­å¥ if x := 2; x+n \u0026gt; 5 { print(x) // 2 } else if x = 1; x-n \u0026gt; 2 { print(x) // 1 } else if n == 2 { print(x) // 1 } else { print(x) // 1 } } å½“ifè¯­å¥æ²¡æœ‰è¿›å…¥ä¸‹ä¸€ä¸ªè¯­å¥ï¼Œå³æ­£æ–‡ä»¥breakã€continueã€gotoæˆ–returnç»“å°¾æ—¶ï¼Œçœç•¥ä¸å¿…è¦çš„elseã€‚ 1 2 3 4 f, err := os.Open(name) if err != nil { return err } breakè¯­å¥ ä¸€ä¸ªbreakçš„ä½œç”¨èŒƒå›´ä¸ºè¯¥è¯­å¥å‡ºç°çš„æœ€å†…éƒ¨çš„ç»“æ„ï¼Œå®ƒå¯ä»¥ç”¨äºä»»ä½•å½¢å¼çš„forå¾ªç¯ã€‚ åœ¨switchæˆ–selectè¯­å¥ä¸­ï¼Œbreakè¯­å¥çš„ä½œç”¨æ˜¯è·³è¿‡æ•´ä¸ªä»£ç å—ï¼Œç»§ç»­æ‰§è¡Œswitchæˆ–selectå¤–åç»­çš„ä»£ç ã€‚ è¯­å¥ä¸­å¦‚æœæœ‰æ ‡ç­¾ï¼Œåˆ™å¿…é¡»æ˜¯åŒ…å«forã€switchæˆ–selectè¯­å¥çš„æ ‡ç­¾ã€‚å¹¶ä¸”è¯¥æ ‡ç­¾æ˜¯å¯ä»¥æ‰§è¡Œç»ˆæ­¢çš„ã€‚ breakä¸¤ä¸ªä½œç”¨ï¼š é’ˆå¯¹forå…³é”®å­—ç»“æŸå¾ªç¯ã€‚ é’ˆå¯¹switchã€selectå…³é”®å­—è·³å‡ºæ•´ä¸ªä»£ç å—ã€‚ä½†switchå’Œselectçš„caseåæ˜¯é»˜è®¤è‡ªå¸¦breakï¼Œå¦‚æœæ˜¾ç¤ºå†™ä¸Šä¹Ÿåªæ˜¯è·³å‡ºswitchå’Œselectå—ã€‚ breakåœ¨switchä¸­å¯ä»¥ä½œä¸ºifåˆ†æ”¯ç»“æŸæ¡ä»¶ã€‚ 1 2 3 4 5 6 7 switch { case true: if true { break\t// æ¯”å¦‚è¿™é‡Œï¼Œé€€å‡ºcaseåˆ†æ”¯ } // å…¶ä»–ä»£ç  ... } å› æ­¤åœ¨switchæˆ–selectå—ä¸­ä½¿ç”¨breakå…³é”®å­—åªèƒ½è·³å‡ºã€å½“å‰ã€‘switchæˆ–selectå—ã€‚å¦‚æœæƒ³è·³å‡ºå¤–å±‚forå¾ªç¯åˆ™éœ€è¦break LabelåŠ ä¸Šæ ‡ç­¾åç§°ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 package main import ( \u0026#34;fmt\u0026#34; ) func main() { fmt.Println(\u0026#34;start\u0026#34;) OuterLoop:\t// å®šä¹‰æ ‡ç­¾ for i := 0; i \u0026lt; 3; i++ { fmt.Println(\u0026#34;i å¾ªç¯ï¼š\u0026#34;, i) for j := 0; j \u0026lt; 3; j++ { fmt.Println(\u0026#34;j å¾ªç¯ï¼š\u0026#34;, j) // switchå’Œselecté»˜è®¤æ˜¯è‡ªå¸¦breakçš„ switch j { case 0: fmt.Println(\u0026#34;break\u0026#34;) break // break åªæ˜¯è·³å‡ºswitchè¯­å¥å—ï¼Œä¸ä¼šè·³å‡ºåˆ°forå— case 2: fmt.Println(\u0026#34;2 OuterLoop\u0026#34;) // switché»˜è®¤å¸¦æœ‰breakè¯­å¥ï¼Œè¿™é‡ŒæŒ‡æ˜breakè¯­å¥è¦è·³å‡ºçš„æ ‡ç­¾ä½ç½® break OuterLoop // ç›´æ¥è·³å‡ºæ•´ä¸ªå¾ªç¯ } fmt.Println(\u0026#34;switch:\u0026#34;, j) } } fmt.Println(\u0026#34;end\u0026#34;) // Output: // start // i å¾ªç¯ï¼š 0 // j å¾ªç¯ï¼š 0 // break // switch: 0 // j å¾ªç¯ï¼š 1 // switch: 1 // j å¾ªç¯ï¼š 2 // 2 OuterLoop // end } æ³¨æ„break label; label(æ ‡ç­¾)åªèƒ½æ˜¯ä¹‹å‰å‡ºç°çš„ï¼Œcontinueå…³é”®å­—ä¹Ÿæ˜¯ã€‚ä½†æ˜¯gotoå…³é”®å­—å´å¯ä»¥è·³è½¬åˆ°åé¢çš„æ ‡ç­¾å¤„ã€‚ continueè¯­å¥ å…³é”®å­—continueç”¨åœ¨å…³é”®å­—forï¼ˆç»“æŸæœ¬æ¬¡å¾ªç¯ï¼Œç»§ç»­ä¸‹æ¬¡å¾ªç¯ï¼‰ï¼Œä½†ä¸æ˜¯æ— æ¡ä»¶æ‰§è¡Œä¸‹ä¸€æ¬¡å¾ªç¯ï¼Œæ‰§è¡Œä¹‹å‰ä¾æ—§éœ€è¦æ»¡è¶³å¾ªç¯çš„åˆ¤æ–­æ¡ä»¶ã€‚ å¦‚æœæœ‰ä¸€ä¸ªæ ‡ç­¾ï¼Œé‚£ä¹ˆå®ƒå¿…é¡»æ˜¯ä¸€ä¸ªå°é—­çš„forè¯­å¥ï¼Œå¹¶ä¸”æ˜¯å½“å‰æ‰§è¡Œè¿›ç¨‹çš„æ ‡ç­¾ã€‚ 1 2 3 4 5 6 7 8 9 RowLoop: for y, row := range rows { for x, data := range row { if data == endOfRow { continue RowLoop } row[x] = data + bias(x, y) } } ä½¿ç”¨ç¤ºä¾‹ï¼š 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 func main() { rows := []string{\u0026#34;hello\u0026#34;, \u0026#34;world\u0026#34;} rowLoop: for _, row := range rows { for _, data := range row { if data == \u0026#39;l\u0026#39; { // continue ç”¨äºç»“æŸæœ¬æ¬¡å¾ªç¯ï¼Œè¿›è¡Œä¸‹ä¸€æ¬¡å¾ªç¯ continue rowLoop } fmt.Printf(\u0026#34;%c\\n\u0026#34;, data) } } // Output: // h // e // w // o // r } æ ‡ç­¾ forã€switchã€selectè¯­å¥éƒ½å¯ä»¥é…åˆæ ‡ç­¾ï¼ˆlabelï¼‰å½¢å¼çš„æ ‡è¯†ç¬¦ä½¿ç”¨ã€‚æ ‡ç­¾å¯ä»¥åœ¨ä»£ç çš„ä»»ä½•åœ°æ–¹ï¼ˆå‡½æ•°ä½“å†…ï¼‰ã€‚ å³æŸä¸€è¡Œç¬¬ä¸€ä¸ªå¯ä»¥å†’å·ï¼ˆ:ï¼‰ç»“å°¾çš„å•è¯ï¼ˆGofmt ä¼šå°†åç»­ä»£ç è‡ªåŠ¨ç§»è‡³ä¸‹ä¸€è¡Œï¼‰ æ ‡ç­¾çš„åç§°æ˜¯å¤§å°å†™æ•æ„Ÿçš„ï¼Œä¸ºäº†æå‡å¯è¯»æ€§ï¼ˆå¯ä»¥é¦–å­—æ¯å¤§å°ï¼Œå¯è¯»æ€§æ¯”è¾ƒé«˜å°±è¡Œï¼‰ã€‚ 1 2 ERROR: // Error or err log.Panic(\u0026#34;error\u0026#34;)\t// æ ‡ç­¾åçš„ä»£ç  æ ‡ç­¾ç”¨äºbreakã€continueã€gotoè¯­å¥ï¼Œå®šä¹‰ä»æœªä½¿ç”¨çš„æ ‡ç­¾æ˜¯éæ³•çš„ï¼Œä¸èƒ½ç¼–è¯‘æˆåŠŸã€‚ï¼ˆå®šä¹‰äº†æ ‡ç­¾ä¸€å®šè¦ä½¿ç”¨ï¼‰ gotoè¯­å¥ gotoè¯­å¥æ˜¯è·³è½¬åˆ°å…·ä½“æœ‰ç›¸åŒå‡½æ•°å†…ç›¸åº”æ ‡ç­¾çš„è¯­å¥ã€‚ï¼ˆç»“åˆæ ‡ç­¾ä½¿ç”¨ï¼Œé€šå¸¸ç”¨åœ¨ä¸€äº›å…¬å…±ä»£ç éƒ¨åˆ†æˆ–å¾ªç¯é€»è¾‘å¤„ï¼‰ 1 goto ERROR Goè¯­è¨€ä¸é¼“åŠ±å¤šå±‚åµŒå¥—ä½¿ç”¨æ ‡ç­¾å’Œgotoè¯­å¥ï¼Œå› ä¸ºå®ƒä»¬ä¼šå¯¼è‡´éå¸¸ç³Ÿç³•çš„ç¨‹åºè®¾è®¡ï¼Œè€Œä¸”æ€»æœ‰æ›´åŠ å¯è¯»çš„æ›¿ä»£æ–¹æ¡ˆæ¥å®ç°ç›¸åŒå¾—éœ€æ±‚ã€‚ å—å¤–çš„gotoè¯­å¥ä¸èƒ½è·³è½¬åˆ°è¯¥å—å†…çš„æ ‡ç­¾ã€‚ï¼ˆåªèƒ½å¹³çº§è·³æˆ–è·³å‡ºåˆ°å¤–å±‚å—ï¼‰ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // ä»¥ä¸‹ä»£ç ä¸èƒ½é€šè¿‡ç¼–è¯‘ package main import \u0026#34;fmt\u0026#34; var x int = 10 func main() { if x % 2 == 1 { goto L1 // L1æ ‡ç­¾åœ¨å—å†… } for x \u0026lt; 10 { x-- fmt.Println(x) L1: // åœ¨forå†…éƒ¨ x-- fmt.Println(x) } } gotoè¯­å¥æ˜¯å¯ä»¥è·³è½¬åˆ°åé¢å‡ºç°çš„æ ‡ç­¾çš„ï¼Œå‰ææ˜¯æ»¡è¶³å—å¤–çš„gotoè¯­å¥ä¸èƒ½è·³è½¬åˆ°å—å†…çš„æ ‡ç­¾ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 package main import ( \u0026#34;fmt\u0026#34; ) var x = 10 func main() { goto TL // å‘åè·³è½¬åˆ°TLå¤„ï¼Œè¿™ç§æ¯”è¾ƒå°‘ç”¨ï¼Œå› ä¸ºæ¥ä¸‹é¢çš„ä»£ç æ°¸ä¹…ä¸ä¼šæ‰§è¡Œ fmt.Println(x) // è¿™è¡Œä»£ç ä¸ä¼šæ‰§è¡Œ TL: fmt.Println(\u0026#34;TL\u0026#34;) // Output: // TL } gotoå¤šç”¨äºè·³è½¬åˆ°å‰é¢ä»£ç çš„æ ‡ç­¾å¤„ï¼Œè¿™æ ·å°±å½¢æˆäº†å¾ªç¯ã€‚ æ€»ç»“ gotoã€breakã€continueï¼šä¸‰ä¸ªè¯­å¥éƒ½å¯ä»¥é…åˆæ ‡ç­¾(label)ä½¿ç”¨ã€‚ æ ‡ç­¾ååŒºåˆ†å¤§å°å†™ï¼Œå®šä¹‰åè‹¥ä¸ä½¿ç”¨ä¼šé€ æˆç¼–è¯‘é”™è¯¯ã€‚ continueã€breaké…åˆæ ‡ç­¾(label)å¯ç”¨äºå¤šå±‚å¾ªç¯è·³å‡ºã€‚ gotoæ˜¯è°ƒæ•´æ‰§è¡Œä½ç½®ï¼Œä¸continueã€breaké…åˆæ ‡ç­¾(label)çš„ç»“æœå¹¶ä¸ç›¸åŒã€‚ ","permalink":"https://heliu.site/posts/golang/process/if/","summary":"Golang ifã€breakã€contineã€gotoä»‹ç»ã€‚","title":"æµç¨‹æ§åˆ¶(æ¡ä»¶è¯­å¥)"},{"content":"forè®¡æ•°å™¨è¿­ä»£ 1 for åˆå§‹åŒ–è¯­å¥; æ¡ä»¶è¯­å¥; ä¿®é¥°è¯­å¥ {} ç”±ä¸‰éƒ¨åˆ†ç»„æˆå¾ªç¯çš„å¤´éƒ¨ï¼Œç›¸äº’ä¹‹é—´ä½¿ç”¨è‹±æ–‡åˆ†å·ï¼ˆ;ï¼‰éš”å¼€ï¼Œä½†å¹¶ä¸éœ€è¦æ‹¬å·å°†å®ƒä»¬æ‹¬èµ·æ¥ã€‚ åŒºåˆ«å…¶ä»–è¯­è¨€å½¢å¼å¦‚ã€for (åˆå§‹åŒ–è¯­å¥; æ¡ä»¶è¯­å¥; ä¿®é¥°è¯­å¥) {} ã€‘å…¶å®ä½¿ç”¨æ‹¬å·åŒ…èµ·æ¥ä¹Ÿå¯ä»¥ã€‚ åŒæ—¶ä½¿ç”¨å¤šä¸ªè®¡æ•°å™¨ è¿™å¾—ç›ŠäºGoè¯­è¨€å…·æœ‰å¹³è¡Œèµ‹å€¼çš„ç‰¹æ€§ã€‚ åŒºåˆ«æ€»ç»“ï¼š forå…³é”®å­—åé¢ä¸éœ€è¦æ‹¬å·ã€‚ åˆå§‹åŒ–è¯­å¥å’Œä¿®é¥°è¯­å¥å¯ä»¥ä½¿ç”¨å¹³è¡Œèµ‹å€¼çš„ç‰¹æ€§ã€‚ 1 2 3 4 // æ³¨æ„è¿™é‡Œçš„ ã€åˆå§‹åŒ–è¯­å¥ã€‘ å’Œ ã€ä¿®é¥°è¯­å¥ã€‘ // åˆå§‹åŒ–è¯­å¥ï¼ši, j := 0, N // ä¿®é¥°è¯­å¥ï¼ši, j = i+1, j-1 for i, j := 0, N; i \u0026lt; j; i, j = i+1, j-1 {} for{} å¯ä»¥è®¤ä¸ºè¿™æ˜¯æ²¡æœ‰ã€åˆå§‹åŒ–è¯­å¥ã€‘å’Œã€ä¿®é¥°è¯­å¥ã€‘çš„forç»“æ„ï¼Œå› æ­¤;;ä¾¿æ˜¯å¤šä½™çš„äº†ã€‚ å³ä½¿æ˜¯æ¡ä»¶è¯­å¥ä¹Ÿå¯ä»¥çœç•¥ï¼Œå¦‚ã€i: = 0; ;i++ã€‘æˆ–ã€for {} æˆ– for ;; {}ã€‘å¤šä½™çš„;;ä¼šåœ¨ä½¿ç”¨æ—¶ç§»é™¤ï¼Œè¿™äº›å¾ªç¯çš„æœ¬è´¨å°±æ˜¯æ— é™å¾ªç¯ã€‚ ä¹Ÿå¯ä»¥å†™æˆã€for true {}ã€‘ä¸€èˆ¬éƒ½æ˜¯ç›´æ¥å†™æˆã€for {}ã€‘ã€‚ å¦‚æœforå¾ªç¯çš„å¤´éƒ¨æ²¡æœ‰æ¡ä»¶è¯­å¥ï¼Œé»˜è®¤ä¸ºtrueå’Œswitchæ²¡æœ‰è¡¨è¾¾å¼ç±»ä¼¼é»˜è®¤ä¸ºtrueã€‚ ä¸€èˆ¬Goå¤„ç†ç±»ä¼¼æƒ…å†µçš„å¸¸ç”¨æ³•åˆ™ï¼Œå› æ­¤å¾ªç¯ä½“å†…å¿…é¡»æœ‰ç›¸å…³çš„æ¡ä»¶åˆ¤æ–­ä»¥ç¡®ä¿ä¼šåœ¨æŸä¸ªæ—¶åˆ»é€€å‡ºå¾ªç¯ã€‚ åŒºåˆ«æ€»ç»“ï¼š ã€for {}ã€‘æˆ‘ä»¬å¯ä»¥ç†è§£ä¸ºã€for æ¡ä»¶è¯­å¥ {}ã€‘è¿™ç§å½¢å¼ï¼Œçœç•¥äº†åˆå§‹åŒ–è¯­å¥å’Œä¿®é¥°è¯­å¥ï¼Œä¸å…¶ä»–è¯­è¨€ã€while (true) {}ã€‘ç”¨æ³•ç±»ä¼¼ã€‚ 1 for {} // ç­‰ä»·äº for true {} ä½¿ç”¨ç¤ºä¾‹ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 package main import ( \u0026#34;fmt\u0026#34; ) func main() { // åˆ›å»º[]intåˆ‡ç‰‡ a := []int{1,2,3,4,5,6} // äº¤æ¢åˆ‡ç‰‡é¦–å°¾æ•°æ® for i,j := 0,len(a)-1; i \u0026lt; j; i,j = i+1,j-1 { a[i], a[j] = a[j], a[i] } fmt.Println(a) // [6 5 4 3 2 1] // å¤šé‡å¾ªç¯æ»¡è¶³æ¡ä»¶é€€å‡º for j := 0; j \u0026lt; 5; j++ { for i := 0; i \u0026lt; 10; i++ { if i \u0026gt; 5 { break } fmt.Printf(\u0026#34;%d \u0026#34;, i) } fmt.Println() } // Output: // [6 5 4 3 2 1] // 0 1 2 3 4 5 // 0 1 2 3 4 5 // 0 1 2 3 4 5 // 0 1 2 3 4 5 // 0 1 2 3 4 5 } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 s := \u0026#34;abc\u0026#34; // 1) å¸¸è§çš„ for å¾ªç¯ï¼Œæ”¯æŒåˆå§‹åŒ–è¯­å¥ for i,n := 0,len(s); i \u0026lt; n; i++ { fmt.Printf(\u0026#34;%c\\n\u0026#34;, s[i]) } // Output: // a // b // c n := len(s) // 2) æ›¿ä»£ while (n \u0026gt; 0) {} for n \u0026gt; 0 { fmt.Println(s[n-1]) n-- } // Output: // 99 // 98 // 97 // 3) æ›¿æ¢ while (true) {} æˆ– for (;;) {} for { fmt.Println(s) } // Output: // abc // ... 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 package main import \u0026#34;fmt\u0026#34; func main() { var b int = 15 var a int // [1, 2, 3, 5, 0, 0] numbers := [6]int{1, 2, 3, 5} // 1) for å¾ªç¯ for a := 0; a \u0026lt; 10; a++ { fmt.Printf(\u0026#34;a çš„å€¼ä¸ºï¼š%d\\n\u0026#34;, a) } // 2) for true for a \u0026lt; b { a++ fmt.Printf(\u0026#34;a çš„å€¼ä¸ºï¼š%d\\n\u0026#34;, a) } // 3) for range for i, x := range numbers { fmt.Printf(\u0026#34;ç¬¬ %d ä½ x çš„å€¼ = %d\\n\u0026#34;, i, x) } // Output: // a çš„å€¼ä¸ºï¼š0 // a çš„å€¼ä¸ºï¼š1 // a çš„å€¼ä¸ºï¼š2 // a çš„å€¼ä¸ºï¼š3 // a çš„å€¼ä¸ºï¼š4 // a çš„å€¼ä¸ºï¼š5 // a çš„å€¼ä¸ºï¼š6 // a çš„å€¼ä¸ºï¼š7 // a çš„å€¼ä¸ºï¼š8 // a çš„å€¼ä¸ºï¼š9 // a çš„å€¼ä¸ºï¼š1 // a çš„å€¼ä¸ºï¼š2 // a çš„å€¼ä¸ºï¼š3 // a çš„å€¼ä¸ºï¼š4 // a çš„å€¼ä¸ºï¼š5 // a çš„å€¼ä¸ºï¼š6 // a çš„å€¼ä¸ºï¼š7 // a çš„å€¼ä¸ºï¼š8 // a çš„å€¼ä¸ºï¼š9 // a çš„å€¼ä¸ºï¼š10 // a çš„å€¼ä¸ºï¼š11 // a çš„å€¼ä¸ºï¼š12 // a çš„å€¼ä¸ºï¼š13 // a çš„å€¼ä¸ºï¼š14 // a çš„å€¼ä¸ºï¼š15 // ç¬¬ 0 ä½ x çš„å€¼ = 1 // ç¬¬ 1 ä½ x çš„å€¼ = 2 // ç¬¬ 2 ä½ x çš„å€¼ = 3 // ç¬¬ 3 ä½ x çš„å€¼ = 5 // ç¬¬ 4 ä½ x çš„å€¼ = 0 // ç¬¬ 5 ä½ x çš„å€¼ = 0 } åˆ¤æ–­ä¸€ä¸ªæ•°æ˜¯å¦æ˜¯è´¨æ•° 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;math\u0026#34; ) func main() { for i := uint64(2) ; i \u0026lt; 100; i++ { if isPrime(i) { fmt.Printf(\u0026#34;%d æ˜¯ç´ æ•°\\n\u0026#34;, i) } } } // isPrime åˆ¤æ–­numæ˜¯å¦æ˜¯ç´ æ•°(è´¨æ•°) ç´ æ•°åªèƒ½è¢«1å’Œæœ¬èº«æ•´é™¤ func isPrime(num uint64) bool { // å‡è®¾Aæ˜¯æ¡ä»¶ï¼ŒBæ˜¯ç»“è®º // ç”±Aå¯ä»¥æ¨å‡ºBï¼Œç”±Bå¯ä»¥æ¨å‡ºAï¼Œåˆ™Aæ˜¯Bçš„ (å……è¦æ¡ä»¶) // ç”±Aå¯ä»¥æ¨å‡ºBï¼Œç”±Bä¸å¯ä»¥æ¨å‡ºAï¼Œåˆ™Aæ˜¯Bçš„ (å……åˆ†ä¸å¿…è¦æ¡ä»¶) // ç”±Aä¸å¯ä»¥æ¨å‡ºBï¼Œç”±Bå¯ä»¥æ¨å‡ºAï¼Œåˆ™Aæ˜¯Bçš„ (å¿…è¦ä¸å……åˆ†æ¡ä»¶) // ç”±Aä¸å¯ä»¥æ¨å‡ºBï¼Œç”±Bä¸å¯ä»¥æ¨å‡ºAï¼Œåˆ™Aæ˜¯Bçš„ (æ—¢ä¸å……åˆ†ä¹Ÿä¸å¿…è¦æ¡ä»¶) // å¤§äºç­‰äº5çš„è´¨æ•°ä¸€å®šå’Œ6çš„å€æ•°ç›¸é‚» (å……åˆ†ä¸å¿…è¦æ¡ä»¶) // ä¸6çš„å€æ•°ç›¸é‚»çš„æ•°ä¸ä¸€å®šæ˜¯å¤§äºç­‰äº5çš„è´¨æ•° // è¯æ˜ï¼š(n \u0026gt;= 1, nå±äºè‡ªç„¶æ•°) // 6n + 0\t=\u0026gt; 2*3*n\t=\u0026gt; åˆæ•° // 6n + 1 -----\u0026gt; å¯èƒ½æ˜¯ç´ æ•°(7)ï¼Œä¹Ÿå¯èƒ½æ˜¯åˆæ•°(25) // 6n + 2\t=\u0026gt; 2*(3n+1)\t=\u0026gt; åˆæ•° // 6n + 3\t=\u0026gt; 3*(2n+1)\t=\u0026gt; åˆæ•° // 6n + 4\t=\u0026gt; 2*(3n+2)\t=\u0026gt; åˆæ•° // 6n + 5 -----\u0026gt; å¯èƒ½æ˜¯ç´ æ•°(11)ï¼Œä¹Ÿå¯èƒ½æ˜¯åˆæ•°(35) // ä¸Šé¢çš„åˆ—è¡¨èƒ½è¡¨ç¤ºæ‰€æœ‰\u0026gt;=5çš„è‡ªç„¶æ•°ï¼Œå› æ­¤å¤§äºç­‰äº5çš„è´¨æ•°ä¸€å®šå’Œ6çš„å€æ•°ç›¸é‚» // 5ä»¥ä¸‹çš„è´¨æ•°åˆ†åˆ«ä¸º 2å’Œ3 if num == 2 || num == 3 { return true } // å¤§äºç­‰äº5çš„è´¨æ•°ä¸€å®šå’Œ6çš„å€æ•°ç›¸é‚»ï¼Œç›¸åä¸åœ¨6çš„å€æ•°ä¸¤ä¾§çš„ä¸€å®šæ˜¯åˆæ•° // è¿™é‡Œæ’é™¤äº†æ‰€æœ‰è¢«2å’Œ3æ•´é™¤çš„åˆæ•°ï¼Œå› æ­¤åé¢çš„forå¾ªç¯åªéœ€éªŒè¯æ˜¯å¦èƒ½è¢«å…¶ä»–è´¨æ•°æ•´é™¤å³å¯ if num % 6 != 1 \u0026amp;\u0026amp; num % 6 != 5 { return false } // ä¸€ä¸ªæ•°èƒ½è¿›è¡Œå› å¼åˆ†è§£ï¼Œé‚£ä¹ˆåˆ†è§£æ—¶å¾—åˆ°çš„ä¸¤ä¸ªæ•° // ä¸€å®šæ˜¯ä¸€ä¸ªå°äºç­‰äº sqrt(n) å’Œ ä¸€ä¸ªå¤§äºç­‰äº sqrt(n) // æ•…éå†å¾ªç¯çš„æ¬¡æ•°å°±æ˜¯sqrt(n)å‘ä¸Šå–æ•´æ¬¡æ•° tmp := uint64(math.Ceil(math.Sqrt(float64(num)))) // ä¸6çš„å€æ•°ç›¸é‚»çš„æ•°ä¸ä¸€å®šæ˜¯å¤§äºç­‰äº5çš„è´¨æ•°(è´¨æ•°) var i uint64 = 5 // è¿™é‡Œiè¡¨ç¤ºç¬¬ä¸€ä¸ªç´ æ•°5 // è¿™é‡Œçš„i += 6åŒ…å«æ‰€æœ‰å½“å‰numå› å¼åˆ†è§£çš„æ‰€æœ‰å…¬å› å¼ï¼Œä¹Ÿå°±æ˜¯æ‰€æœ‰çš„ç´ æ•° for ; i \u0026lt;= tmp; i += 6 { // i å’Œ i + 2 æ˜¯6çš„å€æ•°å‰åä¸¤ä¸ªæ•°å­— // åˆ¤æ–­numæ˜¯å¦èƒ½å› å¼åˆ†è§£ï¼Œèƒ½è¿›è¡Œå› å¼åˆ†è§£åˆ™æ˜¯åˆæ•°ï¼Œå¦åˆ™æ˜¯ç´ æ•° if num % i == 0 || num % (i + 2) == 0 { return false } } return true } /* Output: 2 æ˜¯ç´ æ•° 3 æ˜¯ç´ æ•° 5 æ˜¯ç´ æ•° 7 æ˜¯ç´ æ•° 11 æ˜¯ç´ æ•° 13 æ˜¯ç´ æ•° 17 æ˜¯ç´ æ•° 19 æ˜¯ç´ æ•° 23 æ˜¯ç´ æ•° 29 æ˜¯ç´ æ•° 31 æ˜¯ç´ æ•° 37 æ˜¯ç´ æ•° 41 æ˜¯ç´ æ•° 43 æ˜¯ç´ æ•° 47 æ˜¯ç´ æ•° 53 æ˜¯ç´ æ•° 59 æ˜¯ç´ æ•° 61 æ˜¯ç´ æ•° 67 æ˜¯ç´ æ•° 71 æ˜¯ç´ æ•° 73 æ˜¯ç´ æ•° 79 æ˜¯ç´ æ•° 83 æ˜¯ç´ æ•° 89 æ˜¯ç´ æ•° 97 æ˜¯ç´ æ•° */ for-range ã€for - rangeã€‘ç»“æ„æ˜¯Goè¯­è¨€ç‰¹æœ‰çš„ä¸€ç§è¿­ä»£ç»“æ„ï¼Œå®ƒåœ¨è®¸å¤šæƒ…å†µä¸‹éƒ½éå¸¸æœ‰ç”¨ã€‚ å¯ä»¥è¿­ä»£ä»»ä½•ä¸€ä¸ªé›†åˆï¼Œä¹ŸåŒ…æ‹¬æ•°ç»„(array)å’Œå­—å…¸(map)å’Œå­—ç¬¦ä¸²(string)å’Œé€šé“(channel)å’Œåˆ‡ç‰‡(slice)ï¼ŒåŒæ—¶å¯ä»¥è·å¾—æ¯æ¬¡è¿­ä»£æ‰€å¯¹åº”çš„ç´¢å¼•å’Œå€¼ã€‚ 1 2 // ixï¼šç´¢å¼• valï¼šå€¼ for ix, val := range coll {} å¦‚æœåªéœ€è¦rangeé‡Œçš„ç´¢å¼•å€¼ï¼Œå¯ä»¥åªå†™keyçœç•¥valueã€‚ 1 for key := range coll {} valå€¼å§‹ç»ˆä¸ºé›†åˆä¸­å¯¹åº”ç´¢å¼•çš„å‰¯æœ¬ï¼Œå› æ­¤å®ƒä¸€èˆ¬åªå…·æœ‰åªè¯»æ€§è´¨ã€‚ å¯¹å®ƒæ‰€æœ‰çš„ä»»ä½•ä¿®æ”¹éƒ½ä¸ä¼šå½±å“åˆ°é›†åˆä¸­åŸæœ‰çš„å€¼ã€‚ å¦‚æœvalä¸ºæŒ‡é’ˆï¼Œåˆ™ä¼šäº§ç”ŸæŒ‡é’ˆçš„å‰¯æœ¬ï¼Œä¾æ—§å¯ä»¥ä¿®æ”¹é›†åˆä¸­çš„åŸå€¼ã€‚ rangeéå†çš„ä¹Ÿæ˜¯å‰¯æœ¬ã€‚ forå¾ªç¯çš„rangeæ ¼å¼å¯ä»¥å¯¹sliceã€mapã€arrayã€stringã€chanç­‰è¿›è¡Œè¿­ä»£å¾ªç¯ã€‚ Golangçš„rangeç±»ä¼¼è¿­ä»£å™¨æ“ä½œï¼Œè¿”å›ã€(ç´¢å¼•, å€¼) ã€‘æˆ–ã€(é”®, å€¼)ã€‘ã€‚ ç±»å‹ key value æè¿° string index æ˜¯ int ç±»å‹ s[index] æ˜¯ rune ç±»å‹ å­—ç¬¦ä¸² array/slice index æ˜¯ int ç±»å‹ s[index] æ˜¯å­˜å‚¨çš„å…ƒç´ ç±»å‹ æ•°ç»„/åˆ‡ç‰‡ map key m[key] æ˜¯mapå­˜å‚¨ç±»å‹ å­—å…¸ï¼Œéå†é¡ºåºæ˜¯éšæœºçš„ channel element æ˜¯chanå­˜å‚¨ç±»å‹ é€šé“ å¯ä»¥å¿½ç•¥ä¸æƒ³è¦çš„è¿”å›å€¼ï¼Œæˆ–ä½¿ç”¨_è¿™ä¸ªç‰¹æ®Šå˜é‡ã€‚æ³¨æ„_æ˜¯å†…ç½®å·²ç»å£°æ˜çš„ï¼Œå› æ­¤ä¸èƒ½ä½¿ç”¨è¿™ç§å½¢å¼_:=1ï¼Œä¸èƒ½ä½¿ç”¨:=åº”è¯¥ä½¿ç”¨=ã€‚ ä½¿ç”¨ç¤ºä¾‹ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 package main import \u0026#34;fmt\u0026#34; func main() { s := \u0026#34;abc\u0026#34; // range å˜é‡å­—ç¬¦ä¸²æ˜¯æŒ‰ç…§Unicodeéå†çš„ // 1) å¿½ç•¥ç¬¬äºŒä¸ªå‚æ•°, æ”¯æŒ string/array/slice/map for i := range s { // ã€int, runeã€‘ fmt.Printf(\u0026#34;%d %c\\n\u0026#34;, i, s[i]) } // Output: // 0 a // 1 b // 2 c // 2) å¿½ç•¥ ç¬¬ä¸€ä¸ªå‚æ•° for _, c := range s { // ã€int, runeã€‘ fmt.Println(c) } // Output: // 97 // 98 // 99 // 3) å¿½ç•¥å…¨éƒ¨è¿”å›å€¼ï¼Œä»…è¿­ä»£ n := 0 // sä¸ºå­—ç¬¦ä¸²æ—¶ï¼Œç»Ÿè®¡runeå­—ç¬¦æ•°é‡ for range s { // ã€int, runeã€‘ n++ } fmt.Println(n) m := map[string]int{\u0026#34;a\u0026#34;:1, \u0026#34;b\u0026#34;:2} // è¿”å› (key, value) // éå†mapï¼Œé¡ºåºæ˜¯éšæœºçš„ for k, v := range m { // ã€string, intã€‘ fmt.Println(k, v) } // Output: // b 2 // a 1 } for-rangeä¼šæ‹·è´éå†å¯¹è±¡ æ³¨æ„ä¸‹é¢çš„ä»£ç rangeå¤åˆ¶äº†aå¯¹è±¡æ•°æ®æ‰€ä»¥è¾“å‡ºç»“æœå’Œé¢„æœŸçš„ä¸åŒã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;unsafe\u0026#34; ) func main() { // æ•°ç»„å¸ƒå±€ å†…å­˜ä¸­è¿ç»­åˆ†é… // åœ°å€ 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25\tå­—èŠ‚B // |\u0026lt;---a[0]----\u0026gt;| |\u0026lt;-------a[1]------\u0026gt;| |\u0026lt;--------a[2]------\u0026gt;| a := [3]int{0, 1, 2} // æŸ¥çœ‹açš„å†…å­˜å ç”¨å¤§å° int åœ¨64ä½ç³»ç»Ÿä¸‹å 8å­—èŠ‚ 3*8 = 24å­—èŠ‚ fmt.Println(unsafe.Sizeof(a)) // 24 // indexã€value éƒ½æ˜¯ä»å¤åˆ¶å“ä¸­å–å‡º for i, v := range a { // ã€int, intã€‘ // åœ¨ä¿®æ”¹å‰ï¼Œæˆ‘ä»¬å…ˆä¿®æ”¹åŸæ•°ç»„ if i == 0 { a[1], a[2] = 999, 999 // ç¡®è®¤ä¿®æ”¹æœ‰æ•ˆï¼Œè¾“å‡º[0, 999, 999] fmt.Println(a) // [0 999 999] } // ä½¿ç”¨å¤åˆ¶å“ä¸­å–å‡ºçš„ value ä¿®æ”¹åŸæ•°ç»„ a[i] = v + 100 } // æ³¨æ„è¿™é‡Œçš„è¾“å‡º fmt.Println(a) // [100 101 102] // Output: // 24 // [0 999 999] // [100 101 102] } for-rangeéå†åˆ‡ç‰‡ æ”¹ç”¨å¼•ç”¨ç±»å‹ï¼Œå…¶åº•å±‚æ•°æ®ä¸ä¼šè¢«å¤åˆ¶ï¼Œæ³¨æ„ä¸‹é¢ä»£ç ã€‚ å¦å¤–ä¸¤ç§å¼•ç”¨ç±»å‹mapã€channelæ˜¯æŒ‡é’ˆåŒ…è£…ï¼Œè€Œä¸åƒsliceæ˜¯structã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 package main import \u0026#34;fmt\u0026#34; func main() { // å¸ƒå±€ type slice struct { pointer, len, cap } // slice pointer len cap // | 5 5 // v // array 0 1 2 3 4 5 ... // å‡è®¾ä»¥ä¸‹åˆ‡ç‰‡çš„ç»“æ„å¦‚ä¸‹struct {0x01f00, 5, 5} s := []int{1, 2, 3, 4, 5} // rangeéå†åˆ‡ç‰‡ï¼Œå¤åˆ¶ç»“æ„ä½“struct {0x01f00, 5, 5}ç”¨äºéå† // éå†æ—¶æŒ‡å‘pointeræŒ‡é’ˆç§»åŠ¨è·å–æ•°æ® for i, v := range s { // ã€int, intã€‘ if i == 0 { // ä¿®æ”¹sçš„åˆ‡ç‰‡ç»“æ„ä¸ºstruct {0x01f00, 3, 5}ï¼Œè€Œå¤åˆ¶çš„å‰¯æœ¬ä¸å˜struct {0x01f00, 5, 5} s = s[:3] // [low:high:max] len=high-lowã€cap=max-low // ä¿®æ”¹[0x01f00+2*8,0x01f00+3*8)åœ°å€ä½ç½®ä»3ä¿®æ”¹ä¸º100 s[2] = 100 } fmt.Println(i, v) } fmt.Println(s) // Output: // 0 1 // 1 2 // 2 100 // 3 4 // 4 5 // [1 2 100] } for-rangeéå†å­—ç¬¦ä¸² å­—ç¬¦ä¸²æ˜¯Unicodeç¼–ç çš„å­—ç¬¦é›†åˆä½¿ç”¨for-rangeç»“æ„è¿­ä»£å­—ç¬¦ä¸²ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 package main import ( \u0026#34;fmt\u0026#34; ) func main() { for pos, char := range \u0026#34;è¯­è¨€\\x80é›¨\u0026#34; { // ã€int, runeã€‘ fmt.Printf(\u0026#34;%d character %#U starts at byte position %d\\n\u0026#34;, char, char, pos) } // Output: // 35821 character U+8BED \u0026#39;è¯­\u0026#39; starts at byte position 0 // 35328 character U+8A00 \u0026#39;è¨€\u0026#39; starts at byte position 3 // 65533 character U+FFFD \u0026#39;ï¿½\u0026#39; starts at byte position 6 // 38632 character U+96E8 \u0026#39;é›¨\u0026#39; starts at byte position 7 } æ³¨æ„ éå†åˆ‡ç‰‡ï¼šä¸‹é¢ç¨‹åºä¸Šæœ‰æ²¡æœ‰å¯ä¼˜åŒ–çš„ç©ºé—´ï¼Ÿ 1 2 3 4 5 func rangeTest(slice []int) { for index, value := range slice { _, _ = index, value } } è§£æï¼šä½¿ç”¨ range éå†ï¼Œæ¯æ¬¡è¿­ä»£ä¼šå¯¹ index,value è¿›è¡Œèµ‹å€¼ï¼Œè‹¥æ•°æ®å¾ˆå¤§æˆ– value ç±»å‹ä¸º string æ—¶ï¼Œå¯¹ value çš„èµ‹å€¼æ“ä½œå¯ä»¥è¿›è¡Œä¼˜åŒ–ï¼Œå³å¿½ç•¥ value å€¼ï¼Œä½¿ç”¨ slice[index] æ¥è·å– value çš„å€¼ã€‚ è§£æï¼šä½¿ç”¨ range éå†ï¼Œæ¯æ¬¡è¿­ä»£ä¼šå¯¹ index,value è¿›è¡Œèµ‹å€¼ï¼Œè‹¥æ•°æ®å¾ˆå¤§æˆ– value ç±»å‹ä¸º string æ—¶ï¼Œå¯¹ value çš„èµ‹å€¼æ“ä½œå¯ä»¥è¿›è¡Œä¼˜åŒ–ï¼Œå³å¿½ç•¥ value å€¼ï¼Œä½¿ç”¨ slice[index] æ¥è·å– value çš„å€¼ã€‚ 1 2 3 4 5 func rangeTest(slice []int) { for index, _ := range slice { _, _ = index, slice[index] } } åŠ¨æ€éå†ï¼šä¸‹é¢ç¨‹åºä¸Šèƒ½å¦æ­£å¸¸ç»“æŸï¼Ÿ 1 2 3 4 5 6 7 8 9 func main() { v := []int{1,2,3} // æˆ‘ä»¬çŸ¥é“rangeéå†çš„æ˜¯vçš„å‰¯æœ¬ï¼Œä¹Ÿå°±æ˜¯ v1 := v éå†çš„æ˜¯v1 æ‰€ä»¥ä¸‹é¢åªä¼šå¾ªç¯3æ¬¡ for i := range v { v = append(v, i) } fmt.Println(v) // [1 2 3 0 1 2] // æœ€åå˜é‡å®Œ v = []int{1,2,3,0,1,2} } è§£æï¼šä¼šæ­£å¸¸ç»“æŸã€‚å¾ªç¯å†…å†æ”¹å˜åˆ‡ç‰‡çš„é•¿åº¦ï¼Œä¸å½±å“å¾ªç¯æ¬¡æ•°ï¼Œå¾ªç¯æ¬¡æ•°åœ¨å¾ªç¯å¼€å§‹å‰å°±å·²ç»æ˜¯ç¡®å®šäº†çš„ã€‚ éå†Mapï¼šä¸‹é¢ç¨‹åºä¸Šæœ‰æ²¡æœ‰å¯ä¼˜åŒ–çš„ç©ºé—´ï¼Ÿ 1 2 3 4 5 func rangeTest(mapTest map[int]string) { for key, _ := range mapTest { _, _ = key, mapTest[key] } } è§£æï¼šä½¿ç”¨ range éå†ï¼Œæ ¹æ®ç¬¬ä¸€é¢˜ç»éªŒï¼Œæˆ‘ä»¬æ ¹æ® key å€¼æ¥è·å–value çš„å€¼ï¼Œçœ‹ä¼¼å‡å°‘äº†ä¸€æ¬¡èµ‹å€¼ï¼Œä½†ä½¿ç”¨ mapTest[key] æ¥è·å– value å€¼çš„æ€§èƒ½æ¶ˆè€—å¯èƒ½é«˜äºèµ‹å€¼æ¶ˆè€—ã€‚èƒ½å¦ä¼˜åŒ–å–å†³äº map æ‰€å­˜å‚¨æ•°æ®ç»“æ„ç‰¹å¾ï¼Œåº”ç»“åˆå®é™…æƒ…å†µè¿›è¡Œã€‚ æˆ‘ä»¬çŸ¥é“mapTest[key]çš„å–å€¼æ˜¯ä¸€ä¸ªéå¸¸å¤æ‚çš„å‡½æ•°è°ƒç”¨ï¼ŒmapTest[key]çš„ä½¿ç”¨åè€Œä¼šå¢åŠ è´Ÿæ‹…ã€‚ å‚è€ƒ range å®ç°åŸç† ","permalink":"https://heliu.site/posts/golang/process/for/","summary":"Golang forå¾ªç¯ä»‹ç»ã€‚","title":"æµç¨‹æ§åˆ¶(å¾ªç¯è¯­å¥)"},{"content":"è¿­ä»£string rangeè¿­ä»£stringï¼Œkeyä¸ºintç±»å‹ï¼Œvalueä¸ºruneç±»å‹ã€‚ 1 2 3 4 5 str := \u0026#34;hello world! Gopher\u0026#34; for i, v := range str { // ã€int, runeã€‘ fmt.Println(i, v) // original body } ä¸Šé¢è¿­ä»£å­—ç¬¦ä¸²ä»£ç ç­‰æ•ˆäºä¸‹é¢ä»£ç ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 // 1) è·å–å­—ç¬¦ä¸²é•¿åº¦ // å­—ç¬¦ä¸²æ€»é•¿åº¦ï¼Œè¯¥é•¿åº¦æ˜¯å­—èŠ‚æ•°é‡ç”¨äºéå†å­—ç¬¦ä¸²çš„æ€»é•¿åº¦ lenTemp := len(str) // ä¸‹ä¸€æ¬¡éå†çš„ä¸‹æ ‡ä½ç½®ï¼Œè¿™æ˜¯ç”±äºutf8æ˜¯ä¸å®šé•¿ç¼–ç éœ€è¦è®°å½•ä¸Šä¸€æ¬¡å¤„ç†åçš„ä½ç½® var nextIndexTemp int\t// 2) key/value // æ³¨æ„ï¼šè¿™é‡Œçš„keyå’Œvalueï¼Œå®šä¹‰åœ¨forå¤–ï¼Œä¹Ÿæ˜¯\u0026amp;iå’Œ\u0026amp;væ˜¯å›ºå®šçš„åŸå›  var i int // éå†ç”¨åˆ°çš„ç´¢å¼•ï¼Œä¹Ÿå°±æ˜¯index var v rune // éå†å‡ºæ¥å­˜å‚¨çš„å€¼ï¼Œä¹Ÿå°±æ˜¯value // éå†å­—ç¬¦ä¸² for indexTemp := 0; indexTemp \u0026lt; lenTemp; indexTemp = nextIndexTemp { // è·å–å¼€å¤´8bitçš„å¤§å°ï¼Œå› ä¸ºè¯¥8bitèƒ½åŒºåˆ†å­˜å‚¨çš„æ˜¯ASCII 1bitè¿˜æ˜¯å¤šä¸ªä½¿ç”¨utf8ç¼–ç çš„å­—èŠ‚ valueTemp := rune(str[indexTemp])\t// utf8.RuneSelf = 0x80 = 128 å•å­—ç¬¦æœ€å¤§å€¼ // ASCIIç å­—ç¬¦å 1å­—èŠ‚ï¼Œè¯¥æ¡ä»¶æ»¡è¶³è¯´æ˜ï¼Œå­˜å‚¨çš„æ˜¯ASCIIç å ç”¨ä¸€ä¸ªå­—èŠ‚ if valueTemp \u0026lt; utf8.RuneSelf {\tnextIndexTemp = indexTemp + 1 } else { // è¯¥æ¡ä»¶æ»¡è¶³è¯´æ˜æ˜¯ä½¿ç”¨utf8ç¼–ç çš„å¤šä¸ªå­—èŠ‚å ç”¨ï¼Œ // ä½¿ç”¨decoderuneè·å–è¯¥Unicodeå€¼å’Œåœ¨Utf8ä¸­ç¼–ç å ç”¨çš„å­—èŠ‚å¤§å°æ•°ç›® // decoderuneè§£ç å­—ç¬¦ä¸²strä»indexTempä½ç½®å¼€å§‹ï¼Œå…·ä½“æ–¹æ³•åœ¨runtime/utf8.goæ–‡ä»¶ä¸­ // è¯¥å‡½æ•°ä¸utf8ç¼–ç ç›¸å…³ // valueTempè§£æçš„runeï¼ŒnextIndexTempå½“å‰çš„indexTemp+è§£æçš„runeçš„é•¿åº¦ valueTemp, nextIndexTemp = decoderune(str, indexTemp)\t} // 3) æ‹·è´èµ‹å€¼ // æ³¨æ„ï¼šè¿™é‡Œå°±æ˜¯ä¸ºä»€ä¹ˆfor rangeä¸­å–\u0026amp;iå’Œ\u0026amp;våœ°å€æ˜¯å›ºå®šçš„åŸå›  i = indexTemp // å½“å‰è·å–åˆ°çš„ç´¢å¼• v = valueTemp // å½“å‰è·å–åˆ°çš„å­—ç¬¦ fmt.Println(i, v) // original body } decoderune()ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 // runtime/utf8.go æ–‡ä»¶ä¸­decoderuneæ–¹æ³• // decoderune returns the non-ASCII rune at the start of // s[k:] and the index after the rune in s. // // decoderune assumes that caller has checked that // the to be decoded rune is a non-ASCII rune. // // If the string appears to be incomplete or decoding problems // are encountered (runeerror, k + 1) is returned to ensure // progress when decoderune is used to iterate over a string. func decoderune(s string, k int) (r rune, pos int) { pos = k // è§£æå¼€å§‹ä½ç½® if k \u0026gt;= len(s) { // å·²ç»åˆ°å­—ç¬¦ä¸²çš„æœ€å¤§é•¿åº¦äº† return runeError, k + 1 } s = s[k:] // ä»kä½ç½®åˆ†å‰²å­—ç¬¦ä¸² switch { // [t2, t3) --\u0026gt; [11000000, 11100000) case t2 \u0026lt;= s[0] \u0026amp;\u0026amp; s[0] \u0026lt; t3: // è¯¥å­—æ®µ2å­—èŠ‚ç¼–ç  // 0080-07FF two byte sequence // [locb, hicb] æ˜¯ç¬¬äºŒä¸ªå­—èŠ‚çš„èŒƒå›´å¤§å° [10000000, 10111111] if len(s) \u0026gt; 1 \u0026amp;\u0026amp; (locb \u0026lt;= s[1] \u0026amp;\u0026amp; s[1] \u0026lt;= hicb) { // ä»ç¼–ç ä¸­å–å‡ºç¼–ç çš„æ•°æ®ç»„æˆrune // mask2 = 00011111ï¼Œmaskx = 00111111 r = rune(s[0]\u0026amp;mask2)\u0026lt;\u0026lt;6 | rune(s[1]\u0026amp;maskx) pos += 2 if rune1Max \u0026lt; r { return } } // [t3, t4) --\u0026gt; [11100000, 11110000) case t3 \u0026lt;= s[0] \u0026amp;\u0026amp; s[0] \u0026lt; t4: // è¯¥å­—æ®µ3å­—èŠ‚ç¼–ç  // 0800-FFFF three byte sequence if len(s) \u0026gt; 2 \u0026amp;\u0026amp; (locb \u0026lt;= s[1] \u0026amp;\u0026amp; s[1] \u0026lt;= hicb) \u0026amp;\u0026amp; (locb \u0026lt;= s[2] \u0026amp;\u0026amp; s[2] \u0026lt;= hicb) { r = rune(s[0]\u0026amp;mask3)\u0026lt;\u0026lt;12 | rune(s[1]\u0026amp;maskx)\u0026lt;\u0026lt;6 | rune(s[2]\u0026amp;maskx) pos += 3 if rune2Max \u0026lt; r \u0026amp;\u0026amp; !(surrogateMin \u0026lt;= r \u0026amp;\u0026amp; r \u0026lt;= surrogateMax) { return } } // [t4, t5) --\u0026gt; [11110000, 11111000) case t4 \u0026lt;= s[0] \u0026amp;\u0026amp; s[0] \u0026lt; t5: // è¯¥å­—æ®µ4å­—èŠ‚ç¼–ç  // 10000-1FFFFF four byte sequence if len(s) \u0026gt; 3 \u0026amp;\u0026amp; (locb \u0026lt;= s[1] \u0026amp;\u0026amp; s[1] \u0026lt;= hicb) \u0026amp;\u0026amp; (locb \u0026lt;= s[2] \u0026amp;\u0026amp; s[2] \u0026lt;= hicb) \u0026amp;\u0026amp; (locb \u0026lt;= s[3] \u0026amp;\u0026amp; s[3] \u0026lt;= hicb) { r = rune(s[0]\u0026amp;mask4)\u0026lt;\u0026lt;18 | rune(s[1]\u0026amp;maskx)\u0026lt;\u0026lt;12 | rune(s[2]\u0026amp;maskx)\u0026lt;\u0026lt;6 | rune(s[3]\u0026amp;maskx) pos += 4 if rune3Max \u0026lt; r \u0026amp;\u0026amp; r \u0026lt;= maxRune { return } } } return runeError, k + 1 } for-rangeä¸èƒ½éå†*stringç±»å‹ã€‚ for-rangeå¯¹äºå­—ç¬¦ä¸²å¹¶æ²¡æœ‰å¤åˆ¶ä¸€ä»½å­—ç¬¦ä¸²è¿›è¡Œç¼–ç ï¼Œå…¶å®ä¹Ÿä¸å¿…è¦å› ä¸ºå­—ç¬¦ä¸²çš„è¯­ä¹‰æœ¬æ¥å°±æ˜¯ä¸å¯å˜æ•°æ®ã€‚ è¿­ä»£array rangeè¿­ä»£arrayï¼Œkeyä¸ºintç±»å‹ï¼Œvalueä¸ºæ•°ç»„çš„å…ƒç´ ç±»å‹ã€‚ 1 2 3 4 5 arr := [5]int{0,1,2,3,4} for i, v := range arr { // ã€int, intã€‘ fmt.Println(i, v) // original body } ä¸Šé¢è¿­ä»£æ•°ç»„ä»£ç ç­‰æ•ˆäºä¸‹é¢ä»£ç ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 // 1) è·å–æ•°ç»„é•¿åº¦ // æ³¨æ„ï¼šè¿™é‡Œæ”¯æŒæŒ‡é’ˆæ•°ç»„ï¼Œæ¯”å¦‚len(*[2]int) == 2 lenTemp := len(arr) // 2) æ‹·è´æ•°ç»„ // æ³¨æ„ï¼šè¿™é‡Œæ”¯æŒæŒ‡é’ˆæ•°ç»„ï¼Œæ¯”å¦‚arræ˜¯*[2]int // è¿™é‡Œä¹Ÿå°±æ˜¯ä¸ºä»€ä¹ˆä½¿ç”¨æ•°ç»„æŒ‡é’ˆå’Œæ•°ç»„æœ¬èº«çš„æ€§èƒ½å·®å¼‚ï¼Œ // ä½¿ç”¨æ•°ç»„æŒ‡é’ˆè¿™é‡Œçš„èµ‹å€¼æ˜¯æŒ‡é’ˆèµ‹å€¼ï¼Œè€Œä½¿ç”¨æ•°ç»„è¿™é‡Œæ˜¯å€¼å¤åˆ¶å½“æ•°æ®é‡å¤§æ—¶æ€§èƒ½å·®åˆ«è¿˜æ˜¯æ¯”è¾ƒæ˜æ˜¾ rangeArr := arr // å¤åˆ¶ä¸€ä»½éœ€è¦éå†çš„æ•°ç»„ï¼Œæ³¨æ„è¿™é‡Œçš„å‰¯æœ¬æ˜¯ä¸åŸæ•°ç»„æ²¡æœ‰ä»»ä½•è”ç³» // 3) key/value // æ³¨æ„ï¼šè¿™é‡Œçš„keyå’Œvalueï¼Œå®šä¹‰åœ¨forå¤–ï¼Œä¹Ÿæ˜¯\u0026amp;iå’Œ\u0026amp;væ˜¯å›ºå®šçš„åŸå›  var i, v int // å®šä¹‰éå†éœ€è¦æ¥æ”¶çš„keyå’Œvalueå˜é‡ // for rangeçš„ç¼–è¯‘ç­‰åŒä»£ç  for indexTemp := 0; indexTemp \u0026lt; lenTemp; indexTemp++ { // æ³¨æ„ï¼šè¿™é‡Œæ”¯æŒæŒ‡é’ˆæ•°ç»„èµ‹å€¼ valueTemp := rangeArr[indexTemp] // æ•°ç»„æ”¯æŒè¯­æ³•ç³– // 4) æ‹·è´èµ‹å€¼ // æ³¨æ„ï¼šè¿™é‡Œå°±æ˜¯ä¸ºä»€ä¹ˆfor rangeä¸­å–\u0026amp;iå’Œ\u0026amp;våœ°å€æ˜¯å›ºå®šçš„åŸå›  i = indexTemp // æ‹·è´èµ‹å€¼ v = valueTemp // æ‹·è´èµ‹å€¼ fmt.Println(i, v) // original body } æ•°ç»„éå†å’Œåˆ‡ç‰‡éå†æœ€ä¸»è¦çš„åŒºåˆ«å°±æ˜¯éå†å‰¯æœ¬ï¼Œæ•°ç»„çš„å‰¯æœ¬ä¸åŸæ•°ç»„æ²¡æœ‰ä»»ä½•å…³è”åªæ˜¯å€¼å…¨éƒ¨ç›¸åŒè€Œå·²ï¼Œè€Œåˆ‡ç‰‡åˆ™æ˜¯å‰¯æœ¬å’ŒåŸåˆ‡ç‰‡æ•°å…±ç”¨åŒä¸€ä¸ªåº•å±‚æ•°ç»„ã€‚ rangeèƒ½éå†ã€æ•°ç»„æŒ‡é’ˆã€‘è€Œã€ä¸èƒ½ã€‘éå†åˆ‡ç‰‡æŒ‡é’ˆï¼Œè¿™å¾—ç›Šäºæ•°å€¼æŒ‡é’ˆåœ¨èµ‹å€¼å’Œlen()å‡½æ•°ä¸ŠGoæ”¯æŒçš„ã€è¯­æ³•ç³–ã€‘è½¬æ¢ä½¿å¾—rangeå¯¹æ•°ç»„æŒ‡é’ˆåŒæ ·é€‚ç”¨ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 // rangeéå†æŒ‡é’ˆæ•°ç»„æ—¶ï¼Œä¼šè§£å¼•ç”¨æ•°ç»„æŒ‡é’ˆæ‹·è´å‰¯æœ¬éå† package main import \u0026#34;fmt\u0026#34; func main() { var aa *[2]string = new([2]string) // 1) è¯­æ³•ç³–1ï¼šèµ‹å€¼ //(*aa)[0] = \u0026#34;a\u0026#34; aa[0] = \u0026#34;a\u0026#34; // è¯­æ³•ç³– //(*aa)[1] = \u0026#34;bb\u0026#34; aa[1] = \u0026#34;bb\u0026#34;// è¯­æ³•ç³– // 2) è¯­æ³•ç³–2ï¼šå–å€¼ // c := (*aa)[1] c := aa[1] // è¯­æ³•ç³– // 3) è¯­æ³•ç³–3ï¼šæ±‚é•¿åº¦ // l := len(aa) // len(*aa) // åœ¨Goä¸­æ”¯æŒæ•°ç»„çš„æŒ‡é’ˆç›¸å…³çš„è¯­æ³•ç³–ï¼Œæ‰€ä»¥å¯¼è‡´ä½¿ç”¨æ•°ç»„å’Œæ•°ç»„æŒ‡é’ˆå¥½åƒå¹¶æ²¡æœ‰å¤šå¤§çš„åŒºåˆ« // æ¯”å¦‚æ•°ç»„æŒ‡é’ˆaaèƒ½ä½¿ç”¨aa[0] = \u0026#34;a\u0026#34;è¿™ç§å½¢å¼èµ‹å€¼ï¼Œä¹Ÿèƒ½ä½¿ç”¨len(aa)è¿™ç§å½¢å¼æ±‚é•¿åº¦ï¼Œ // å…¶ä»–ç±»å‹çš„æŒ‡é’ˆåˆ™ä¸æ”¯æŒ // è¿™äº›è¯­æ³•ç³–ä¹Ÿå¯¼è‡´äº†èƒ½ä½¿ç”¨rangeéå†æ•°ç»„æŒ‡é’ˆ // range æ‹·è´ *aa å‰¯æœ¬éå† for i, s := range aa { // å½“æ•°ç»„å¾ˆå¤§æ—¶ï¼Œéå†æ•°ç»„æŒ‡é’ˆæ˜¯ä¸€ä¸ªä¸é”™çš„é€‰æ‹© if i == 0 { aa[1] = \u0026#34;cc\u0026#34; } fmt.Println(i, s) } fmt.Println(aa) // Output: // 0 a // 1 cc // \u0026amp;[a cc] } éªŒè¯æ•°ç»„éå†æ˜¯å€¼æ‹·è´ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 {\tslice1 := [4]int{0,1,2,3} // è¿™é‡Œæ‹·è´çš„æ˜¯æ•°ç»„çš„å‰¯æœ¬ï¼Œå› æ­¤ifæ¡ä»¶æˆç«‹ä¸ä¼šå½±å“å€¼ for i, v := range slice1 { // [4]int if i == 1 { slice1[3] += 10 } fmt.Println(i, v) } fmt.Println(slice1) // Output: // 0 0 // 1 1 // 2 2 // 3 3 // [0 1 2 13] } { slice1 := [4]int{0,1,2,3} // è¿™é‡Œæ‹·è´çš„æ˜¯æ•°ç»„çš„æŒ‡é’ˆï¼Œå› æ­¤ifæ¡ä»¶æˆç«‹ä¼šå½±å“å€¼ for i, v := range \u0026amp;slice1 { // *[4]int if i == 1 { slice1[3] += 10 } fmt.Println(i, v) } // Output: // 0 0 // 1 1 // 2 2 // 3 13 } è¿­ä»£slice éå†sliceå‰ä¼šå…ˆè·å–sliceçš„é•¿åº¦lenTempæ¥ä½œä¸ºå¾ªç¯æ¬¡æ•°ï¼Œå¾ªç¯ä½“ä¸­ï¼Œæ¯æ¬¡å¾ªç¯ä¼šå…ˆè·å–å…ƒç´ å€¼ã€‚ å¦‚æœfor-rangeä¸­æ¥æ”¶indexå’Œvalueçš„è¯ï¼Œåˆ™ä¼šå¯¹indexå’Œvalueè¿›è¡Œä¸€æ¬¡èµ‹å€¼ã€‚ æ•°ç»„ä¸æ•°ç»„æŒ‡é’ˆçš„éå†è¿‡ç¨‹ä¸sliceåŸºæœ¬ä¸€è‡´ï¼Œä½†æ˜¯ä¹Ÿæœ‰åŒºåˆ«ï¼ŒåŒºåˆ«åœ¨äºå‰¯æœ¬å¤åˆ¶çš„æ˜¯ä¸åŸæ•°ç»„æ˜¯ä¸€ä¸ªå®Œå…¨ä¸ç›¸å¹²çš„æ•°ç»„ã€‚ for-rangeè¿­ä»£sliceï¼Œkeyä¸ºintï¼Œvalueä¸ºå­˜å‚¨çš„å…ƒç´ ç±»å‹ã€‚ 1 2 3 4 5 slice1 := []int{0,1,2,3} for i, v := range slice1 { // ã€int, intã€‘ fmt.Println(i, v) // original body } ä¸Šé¢è¿­ä»£åˆ‡ç‰‡ä»£ç ç­‰æ•ˆäºä¸‹é¢ä»£ç ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 // 1) æ‹·è´åˆ‡ç‰‡ // æ³¨æ„ï¼šæ‹·è´çš„åˆ‡ç‰‡ä¸åŸåˆ‡ç‰‡å…±ç”¨äº†åŒä¸€ä¸ªåº•å±‚æ•°ç»„ // ä¹Ÿéœ€è¦æ³¨æ„ï¼Œlenå’Œcapä¹Ÿæ‹·è´å…ƒåˆ‡ç‰‡çš„å€¼ï¼Œå› æ­¤for rangeä¿®æ”¹ä¸èµ·ä½œç”¨ï¼Œ rangeSlice := slice1 // 2) è·å–åˆ‡ç‰‡é•¿åº¦ï¼Œä¹Ÿæ˜¯éå†çš„æ¬¡æ•° // éå†çš„æ­¤æ—¶åˆ‡ç‰‡é•¿åº¦æ˜¯å›ºå®šçš„ lenTemp := len(rangeSlice) // æ‹¿åˆ°éœ€è¦éå†çš„åˆ‡ç‰‡æ€»é•¿åº¦ // 3) key/value // æ³¨æ„ï¼šè¿™é‡Œçš„keyå’Œvalueï¼Œå®šä¹‰åœ¨forå¤–ï¼Œä¹Ÿæ˜¯\u0026amp;iå’Œ\u0026amp;væ˜¯å›ºå®šçš„åŸå›  var i, v int // å®šä¹‰éå†éœ€è¦çš„keyå’Œvalueå˜é‡ // for rangeçš„ç¼–è¯‘ç­‰åŒä»£ç  for indexTemp := 0; indexTemp \u0026lt; lenTemp; indexTemp++ { valueTemp := rangeSlice[indexTemp] // 4) æ‹·è´èµ‹å€¼ // æ³¨æ„ï¼šè¿™é‡Œå°±æ˜¯ä¸ºä»€ä¹ˆfor rangeä¸­å–\u0026amp;iå’Œ\u0026amp;våœ°å€æ˜¯å›ºå®šçš„åŸå›  i = indexTemp v = valueTemp fmt.Println(i, v) // original body } ç”±äºå¾ªç¯å¼€å§‹å‰å¾ªç¯æ¬¡æ•°å°±å·²ç»ç¡®å®šäº†ï¼Œæ‰€ä»¥å¾ªç¯è¿‡ç¨‹ä¸­æ–°æ·»åŠ çš„å…ƒç´ æ˜¯æ— æ³•éå†åˆ°çš„ã€‚ ä½†æ˜¯å¾ªç¯è¿‡ç¨‹ä¸­ä¿®æ”¹åé¢è¿˜æœªå¾ªç¯çš„å€¼ï¼Œåˆ™ä¼šå½±å“ï¼Œè¿™æ˜¯ç”±äºåœ¨rangeå¾ªç¯å‰èµ‹å€¼çš„å‰¯æœ¬ä¸åŸåˆ‡ç‰‡å…±ç”¨äº†ä¸€ä¸ªåº•å±‚æ•°ç»„å¯¼è‡´çš„ï¼Œæ‰€ä»¥èƒ½ç›¸äº’å½±å“ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 { slice1 := []int{0,1,2,3} for i, v := range slice1 { // ã€int, intã€‘ if i == 1 { slice1[3] += 10 } fmt.Println(i, v) } // Output: // 0 0 // 1 1 // 2 2 // 3 13 } è¿­ä»£channel channeléå†æ˜¯ä¾æ¬¡ä»channelä¸­è¯»å–æ•°æ®ï¼Œè¯»å–å‰æ˜¯ä¸çŸ¥é“é‡Œé¢æœ‰å¤šå°‘ä¸ªå…ƒç´ çš„ã€‚ å¦‚æœchannelä¸­æ²¡æœ‰å…ƒç´ ï¼Œåˆ™ä¼šé˜»å¡ç­‰å¾…ï¼Œå¦‚æœchannelå·²è¢«å…³é—­ï¼Œåˆ™ä¼šè§£é™¤é˜»å¡å¹¶é€€å‡ºå¾ªç¯ã€‚ for-rangeè¿­ä»£channelï¼Œåªèƒ½è·å–ä¸€ä¸ªå€¼ï¼Œkeyä¸ºchannelå­˜å‚¨çš„å…ƒç´ ç±»å‹ã€‚ 1 2 3 4 5 6 c := make(chan int) // rangeéå†chan for v := range c { // ã€intã€‘ fmt.Println(v) // original body } ä¸Šé¢è¿­ä»£channelä»£ç ç­‰æ•ˆäºä¸‹é¢ä»£ç ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // è¿™é‡Œæ˜¯\u0026amp;vä¸ºä»€ä¹ˆéƒ½æ˜¯åŒä¸€ä¸ªåœ°å€çš„åŸå›  var v int // vå…¶å®å°±æ˜¯å›ºå®šçš„ä¸€ä¸ªå˜é‡ for { // æ³¨æ„å¦‚æœä¸å…³é—­channelè¿™é‡Œä¼šä¸€ç›´é˜»å¡ // æˆ‘ä»¬çŸ¥é“ \u0026lt;- ç¬¦å·ä¼šè°ƒç”¨ç›¸å…³çš„å‡½æ•°ï¼Œå¦‚æœchanå…³é—­äº†ä¼šè¿”å›falseé€€å‡ºå¾ªç¯ value_temp, ok := \u0026lt;- c\t// æœ‰æ•°æ®åˆ™ä¼šç›´æ¥è¿”å›æ•°æ®ï¼Œæ²¡æœ‰æ•°æ®åˆ™ä¼šé˜»å¡ï¼Œé€šè¿‡chançš„å­¦ä¹ çŸ¥é“é˜»å¡æ„å‘³ç€ // å½“å‰goroutineè¢«è°ƒç¦»è°ƒåº¦å¾ªç¯ç­‰å¾…æ•°æ®åˆ°æ¥è¢«é‡æ–°è°ƒèµ· // ok = falseï¼Œé€šé“å·²ç»å…³é—­ã€‚ if !ok { break } // 2) æ‹·è´å€¼ v = value_temp fmt.Println(v) // original body } ç¼–è¯‘åçš„ä¼ªä»£ç ï¼Œä¸ä¸Šé¢ç­‰ä»·ã€‚å…³äºchanrecv2()åœ¨channelä¸­ä»‹ç»ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 var v int for { ok := chanrecv2(c, \u0026amp;value_temp) if !ok { break } v = index_temp fmt.Println(v) // original body } æ³¨æ„ï¼š ä½¿ç”¨for-rangeéå†channelæ—¶åªèƒ½è·å–ä¸€ä¸ªè¿”å›å€¼ã€‚ ã€for-range \u0026lt;-chã€‘æƒ…å†µï¼Œè¯¥æƒ…å†µå¯ä»¥ç”¨åœ¨ ã€channel mapã€channel array|*arrayã€channel sliceã€channel stringã€‘ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 func chanTs2() { ch := make(chan map[int]int) // æ³¨æ„ï¼šè¿™é‡Œæ˜¯ \u0026lt;-chï¼Œå‰é¢çš„æ˜¯ ch for k, v := range \u0026lt;-ch { println(k, v) } // --------------------------- // as ç­‰ä»·äºä¸‹é¢ä»£ç  // --------------------------- // æ³¨æ„ï¼šè¿™é‡Œåªä¼šæ‰§è¡Œä¸€æ¬¡ a := \u0026lt;-ch for k, v := range a { println(k, v) } } è¿­ä»£map for-rangeè¿­ä»£mapï¼Œkeyä¸ºmapçš„é”®ï¼Œvalueä¸ºmapçš„å€¼ã€‚ 1 2 3 4 5 map1 := map[string]string{\u0026#34;one\u0026#34;:\u0026#34;1\u0026#34;, \u0026#34;tow\u0026#34;:\u0026#34;2\u0026#34;} for i, v := range map1 { // ã€string, stringã€‘ fmt.Println(i, v) // original body } ä¸Šé¢è¿­ä»£mapä»£ç ç­‰æ•ˆäºä¸‹é¢ä»£ç ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 // 1) key/value // è¿™é‡Œä¹Ÿæ˜¯ä¸ºä»€ä¹ˆ\u0026amp;iå’Œ\u0026amp;væ˜¯ä¸€ä¸ªå›ºå®šçš„åœ°å€çš„åŸå›  // å®šä¹‰éå†æ‰€éœ€è¦çš„keyå’Œvalueå˜é‡ var i, v string // 2) map_iteration_struct // map_iteration_structæ˜¯ä¸€ä¸ªhiterç»“æ„ä½“ï¼Œå­˜å‚¨ç€mapçš„éå†ç›¸å…³ä¿¡æ¯ var hiter map_iteration_struct\t// mapiterinit åˆå§‹åŒ–mapå‚çœ‹runtime/map.goæ–‡ä»¶ // hiteræ˜¯ä¸€ä¸ªå“ˆå¸Œè¿­ä»£ç»“æ„ï¼Œmapiternextè¿­ä»£ä¸‹ä¸€ä¸ªå“ˆå¸Œ for mapiterinit(type, range, \u0026amp;hiter); hiter.key != nil; mapiternext(\u0026amp;hiter) { index_temp := *hiter.key value_temp := *hiter.val // 3) æ‹·è´æ•°æ® i = index_temp v = value_temp fmt.Println(i, v) // original body } éå†mapæ—¶æ²¡æœ‰æŒ‡å®šå¾ªç¯æ¬¡æ•°ï¼Œå¾ªç¯ä½“ä¸éå†sliceç±»ä¼¼ã€‚ç”±äºmapåº•å±‚å®ç°ä¸sliceä¸åŒï¼Œmapåº•å±‚ä½¿ç”¨ hashè¡¨å®ç°çš„ã€‚ æ’å…¥æ•°æ®ä½ç½®æ˜¯éšæœºçš„ï¼Œæ‰€ä»¥éå†è¿‡ç¨‹ä¸­æ–°æ’å…¥çš„æ•°æ®ä¸èƒ½ä¿è¯éå†åˆ°ã€‚ ä»¥ä¸‹ç›¸å…³çš„å‡½æ•°åœ¨mapç¯‡ä¸­è¿˜ä¼šè¯¦ç»†çš„è®¨è®ºã€‚ type hiter structã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 // A hash iteration structure. // If you modify hiter, also change cmd/compile/internal/reflectdata/reflect.go // and reflect/value.go to match the layout of this structure. type hiter struct { // å½“å‰éå†çš„keyåœ°å€ key unsafe.Pointer // Must be in first position. Write nil to indicate iteration end (see cmd/compile/internal/walk/range.go). // å½“å‰éå†çš„elemåœ°å€ elem unsafe.Pointer // Must be in second position (see cmd/compile/internal/walk/range.go). // å½“å‰mapçš„ç±»å‹ç»“æ„ t *maptype // å½“å‰mapçš„å†…å­˜ç»“æ„ h *hmap\t// å½“å‰mapçš„å¸¸è§„æ¡¶åœ°å€ buckets unsafe.Pointer // bucket ptr at hash_iter initialization time // å½“å‰æ­£åœ¨éå†çš„æ¡¶ bptr *bmap // current bucket å½“å‰å­˜å‚¨æ¡¶ // h.extra.overflow overflow *[]*bmap // keeps overflow buckets of hmap.buckets alive\t// h.extra.oldoverflow oldoverflow *[]*bmap // keeps overflow buckets of hmap.oldbuckets alive // å¼€å§‹éå†çš„æ¡¶å·ï¼Œéšæœºçš„ï¼Œç”¨äºå¼€å§‹éå†çš„èµ·ç‚¹ä»¥åŠç»“æŸéå†çš„ç»ˆç‚¹ startBucket uintptr // bucket iteration started at // tophashåç§»å€¼ï¼Œåœ¨[0,7]ä¸­éšæœºç”Ÿæˆçš„å€¼ï¼Œç”¨äºåç»­ i + offset \u0026amp; 7 ç”¨ä½œåç§»é‡ offset uint8 // intra-bucket offset to start from during iteration (should be big enough to hold bucketCnt-1) // å½“å‰éå†å·²è¿‡æœ€å¤§æ¡¶(1 \u0026lt;\u0026lt; B)æ—¶è¢«è®¾ç½®ä¸ºtrue wrapped bool // already wrapped around from end of bucket array to beginning // åˆå§‹åŒ–æ—¶æ¡¶çš„æ•°é‡ 1 \u0026lt;\u0026lt; B B uint8 // å½“å‰æ¡¶éå†çš„ç´¢å¼•ï¼Œé»˜è®¤å€¼ä»0å¼€å§‹ï¼Œè¯¥å€¼é…åˆoffsetéå†tophashï¼Œi + offset \u0026amp; 7 i uint8 // åˆå§‹åŒ–æ—¶æ˜¯startBucketçš„å€¼ // 1. bptr == nilæ—¶bucketå­˜å‚¨éœ€è¦éå†çš„æ¡¶å· // 2. bptr != nilæ—¶bucketä¸‹ä¸ªæ¡¶çš„æ¡¶å· bucket uintptr // å­˜å‚¨çš„æ˜¯å½“å‰è¿­ä»£å™¨çš„æ¡¶å· // noCheck.ä¸éœ€è¦æ£€æŸ¥ï¼Œæ•°æ®åœ¨bptræ¡¶é‡Œé¢ // å…¶ä»–éœ€è¦æ£€æŸ¥ checkBucket uintptr // éœ€è¦æ£€æŸ¥çš„æ¡¶å· } mapiterinit()ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 // mapiterinit initializes the hiter struct used for ranging over maps. // The hiter struct pointed to by \u0026#39;it\u0026#39; is allocated on the stack // by the compilers order pass or on the heap by reflect_mapiterinit. // Both need to have zeroed hiter since the struct contains pointers. // mapiterinit åˆå§‹åŒ–ç”¨äºåœ¨mapä¸Šçš„ hiter ç»“æ„ // \u0026#39;it\u0026#39; æŒ‡å‘çš„ hiter ç»“æ„ç”±ç¼–è¯‘å™¨é¡ºåºä¼ é€’åœ¨å †æ ˆä¸Šåˆ†é…ï¼Œæˆ–è€…ç”± reflect_mapiterinit åœ¨å †ä¸Šåˆ†é…ã€‚ // ç”±äºç»“æ„åŒ…å«æŒ‡é’ˆï¼Œå› æ­¤ä¸¤è€…éƒ½éœ€è¦å°† hiter å½’é›¶ã€‚ // // è¿­ä»£åˆå§‹åŒ– // t *maptypeï¼šå½“å‰mapçš„å…ƒç´ ç±»å‹ // h *hmapï¼šå½“å‰mapçš„å†…å­˜ç»“æ„ // it *hiterï¼šè¿­ä»£å™¨ç»“æ„ func mapiterinit(t *maptype, h *hmap, it *hiter) { if raceenabled \u0026amp;\u0026amp; h != nil { callerpc := getcallerpc() racereadpc(unsafe.Pointer(h), callerpc, abi.FuncPCABIInternal(mapiterinit)) } it.t = t // å­˜å‚¨å½“å‰mapçš„ç±»å‹ç»“æ„åœ°å€ if h == nil || h.count == 0 { // å¦‚æœå½“å‰mapä¸ºç©ºç›´æ¥è¿”å› return } if unsafe.Sizeof(hiter{})/goarch.PtrSize != 12 { // åˆ¤æ–­hiterç»“æ„æ˜¯å¦æ­£ç¡® throw(\u0026#34;hash_iter size incorrect\u0026#34;) // see cmd/compile/internal/reflectdata/reflect.go } it.h = h // å­˜å‚¨å½“å‰mapçš„å†…å­˜ç»“æ„åœ°å€ // grab snapshot of bucket state it.B = h.B // è®°å½•å½“å‰mapçš„æ¡¶æ•°é‡ it.buckets = h.buckets // è®°å½•å½“å‰mapçš„å¸¸è§„æ¡¶åœ°å€ if t.bucket.ptrdata == 0 { // åˆ¤æ–­å½“å‰æ¡¶ç±»å‹çš„ptrdataå­—æ®µï¼Œè¯¥å­—æ®µä¸º0è¯´æ˜å­˜å‚¨çš„éƒ½æ˜¯æ ‡é‡æ•°æ® // åˆ†é…å½“å‰åˆ‡ç‰‡å¹¶è®°ä½æŒ‡å‘å½“å‰åˆ‡ç‰‡å’Œæ—§åˆ‡ç‰‡çš„æŒ‡é’ˆã€‚ // å³ä½¿è¡¨å¢é•¿ and/or åœ¨æˆ‘ä»¬è¿­ä»£æ—¶å°†æº¢å‡ºæ¡¶æ·»åŠ åˆ°è¡¨ä¸­ï¼Œè¿™ä¹Ÿä¼šä¿ç•™æ‰€æœ‰ç›¸å…³çš„æº¢å‡ºæ¡¶ã€‚ h.createOverflow() // åˆ›å»ºæº¢å‡ºæ¡¶ it.overflow = h.extra.overflow it.oldoverflow = h.extra.oldoverflow } // decide where to start // å†³å®šä»å“ªé‡Œå¼€å§‹ r := uintptr(fastrand()) // ç”Ÿæˆéšæœºæ•°å†³å®šä»å“ªé‡Œå¼€å§‹ // bucketCntBits = 3 if h.B \u0026gt; 31-bucketCntBits { // å¦‚æœå½“å‰çš„æ¡¶æ•° \u0026gt; 31 - 3 r += uintptr(fastrand()) \u0026lt;\u0026lt; 31 } it.startBucket = r \u0026amp; bucketMask(h.B) // ç¡®å®šå¼€å§‹çš„æ¡¶å·ï¼Œè¿™é‡Œä¹Ÿæ˜¯for rangeéšæœºçš„åŸå›  it.offset = uint8(r \u0026gt;\u0026gt; h.B \u0026amp; (bucketCnt - 1)) // å¼€å§‹çš„tophashä½ç½®å¤„ // iterator state it.bucket = it.startBucket // è®°ä½æˆ‘ä»¬æœ‰ä¸€ä¸ªè¿­ä»£å™¨ã€‚ // å¯ä»¥ä¸å¦ä¸€ä¸ª mapiterinit() å¹¶å‘è¿è¡Œã€‚\t// iterator = 1 å­˜åœ¨æ¡¶æ­£åœ¨åœ¨ä½¿ç”¨è¿­ä»£å™¨æ ‡å¿— // oldIterator = 2 å­˜åœ¨æ—§æ¡¶æ­£åœ¨ä½¿ç”¨è¿­ä»£å™¨æ ‡å¿— // è®¾ç½®æ­£åœ¨è¿­ä»£çš„æ ‡å¿—ä½ if old := h.flags; old\u0026amp;(iterator|oldIterator) != iterator|oldIterator { atomic.Or8(\u0026amp;h.flags, iterator|oldIterator) // åŸå­é”è®¾ç½®hmapçš„flagså‚æ•°æ ‡å¿—æ­£åœ¨ä½¿ç”¨è¿­ä»£å™¨ } mapiternext(it) } mapiternext()ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 // å‘ä¸‹å¯»æ‰¾ä¸‹ä¸€ä¸ªkey func mapiternext(it *hiter) { h := it.h // è·å–å½“å‰hmapå†…å­˜ç»“æ„ if raceenabled { callerpc := getcallerpc() racereadpc(unsafe.Pointer(h), callerpc, abi.FuncPCABIInternal(mapiternext)) } // å½“å‰æœ‰hashWritingæ“ä½œæ—¶ï¼Œæ¯”å¦‚m[k]=væˆ–deleteå‡½æ•°æ—¶éƒ½ä¼šæŠ¥é”™ if h.flags\u0026amp;hashWriting != 0 { throw(\u0026#34;concurrent map iteration and map write\u0026#34;) } t := it.t // è·å–mapçš„ç»“æ„ // æœ¬æ¬¡éœ€è¦éå†çš„æ¡¶å· bucket := it.bucket // å½“å‰çš„æ¡¶å· // æœ¬æ¬¡éœ€è¦éå†çš„æ¡¶ï¼Œå¦‚æœä¸ºnilè¯´æ˜éœ€è¦å»bucketå¯»æ‰¾ b := it.bptr // å½“å‰å­˜å‚¨æ¡¶ // æœ¬æ¬¡åº”è¯¥éå†çš„ç´¢å¼• i := it.i // éå†ç´¢å¼•é»˜è®¤0 checkBucket := it.checkBucket // éå†ä¸€éå½“å‰æ¡¶åŠå…¶æº¢å‡ºæ¡¶ç›´åˆ°b=nil next: // å½“å‰æ¡¶éå†å®Œæ—¶ï¼Œåˆ‡æ¢åˆ°ä¸‹ä¸€ä¸ªæ¡¶å»éå† if b == nil { // å½“å‰éå†çš„æ¡¶å’Œå¼€å§‹çš„æ¡¶ç›¸ç­‰ å¹¶ä¸” å·²ç»éå†è¿‡äº†æœ€å¤§æ¡¶æ•°ï¼Œè¯´æ˜éå†äº†ä¸€åœˆäº† if bucket == it.startBucket \u0026amp;\u0026amp; it.wrapped { // ç»“æŸéå†çš„æ¡ä»¶ // end of iteration it.key = nil it.elem = nil return } // h.growing() å½“å‰æ­£åœ¨æ‰©å®¹ä¸­ if h.growing() \u0026amp;\u0026amp; it.B == h.B { // h.growing()å½“å‰mapæ­£å¤„äºæ‰©å®¹çŠ¶æ€ // è¿­ä»£å™¨æ˜¯åœ¨å¢é•¿è¿‡ç¨‹ä¸­å¯åŠ¨çš„ï¼Œä½†å¢é•¿å°šæœªå®Œæˆã€‚ // å¦‚æœæˆ‘ä»¬æŸ¥çœ‹çš„bucketå°šæœªå¡«å……ï¼ˆå³ï¼Œæ—§bucketæœªè¢«æ¸…ç©ºï¼‰ï¼Œé‚£ä¹ˆæˆ‘ä»¬éœ€è¦éå†æ—§bucketsï¼Œåªè¿”å›å°†è¿ç§»åˆ°æ­¤bucketçš„bucketsã€‚ oldbucket := bucket \u0026amp; it.h.oldbucketmask() // æ—§æ¡¶çš„æ¡¶å· b = (*bmap)(add(h.oldbuckets, oldbucket*uintptr(t.bucketsize)))\t// è·å–æ¡¶ä½ç½® // å½“å‰æ¡¶çš„tophash[0]ä¸æ˜¯2|3|4æ—¶ï¼Œè¯´æ˜æ•°æ®æ²¡æœ‰è¢«è¿ç§» if !evacuated(b) {\tcheckBucket = bucket // éœ€è¦æ£€æŸ¥çš„æ¡¶å· } else { // è¯´æ˜æ•°æ®åœ¨æ–°æ¡¶é‡Œé¢ï¼Œæ•°æ®å·²è¢«è¿ç§» b = (*bmap)(add(it.buckets, bucket*uintptr(t.bucketsize)))\tcheckBucket = noCheck } } else { // 1.æ²¡æœ‰æ‰©å®¹ 2.æ‰©å®¹äº†ä½†æ˜¯it.B != h.B b = (*bmap)(add(it.buckets, bucket*uintptr(t.bucketsize))) // æ–°æ¡¶ checkBucket = noCheck } bucket++ // æ¡¶å·åŠ ä¸€ // å½“å‰æ¡¶å·ç­‰äºæœ€å¤§æ¡¶å· if bucket == bucketShift(it.B) { // bucketShift(it.B) ç­‰äº 1 \u0026gt;\u0026gt; B bucket = 0 // æ ‡è®°ä»0å·æ¡¶å¼€å§‹ it.wrapped = true // æ ‡è®°å·²ç»è¿‡äº†æœ€å¤§æ¡¶äº† } i = 0 // æ–°æ¡¶é‡ç½®ç´¢å¼•ä¸º0 } // éå†å½“å‰æ¡¶çš„æ‰€æœ‰å…ƒç´ \tbucketCnt = 8 // ä»å½“å‰æ¡¶éå†æ•°æ® for ; i \u0026lt; bucketCnt; i++ { offi := (i + it.offset) \u0026amp; (bucketCnt - 1) // æ ¹æ®it.offsetåç§»é‡å¼€å§‹éšæœºéå†å…ƒç´ [0,7] // b.tophash[offi] \u0026lt;= 1 æˆ– evacuatedEmpty = 4 è¡¨ç¤ºæ¡¶æ•°æ®ä¸ºç©º if isEmpty(b.tophash[offi]) || b.tophash[offi] == evacuatedEmpty { // å¦‚æœå½“å‰ä½ç½®ä¸º0æˆ–1æˆ–4è¡¨ç¤ºæ¡¶ä¸ºç©º continue } k := add(unsafe.Pointer(b), dataOffset+uintptr(offi)*uintptr(t.keysize)) // åç§»åˆ°å½“å‰keyä½ç½® if t.indirectkey() { // åˆ¤æ–­å½“å‰keyå­˜å‚¨æ˜¯å¦æ˜¯å·²æŒ‡é’ˆå­˜å‚¨è€Œä¸æ˜¯å­˜å‚¨çš„keyæœ¬èº« k = *((*unsafe.Pointer)(k)) } // åç§»åˆ°å½“å‰elemä½ç½® e := add(unsafe.Pointer(b), dataOffset+bucketCnt*uintptr(t.keysize)+uintptr(offi)*uintptr(t.elemsize)) // checkBucket != noCheck æ•°æ®åœ¨æ—§æ¡¶ å¹¶ä¸” !h.sameSizeGrow() ç¿»å€æ‰©å®¹ // éœ€è¦éªŒè¯æ¡¶æ—¶ï¼Œæ—§æ¡¶å­˜åœ¨æ•°æ® if checkBucket != noCheck \u0026amp;\u0026amp; !h.sameSizeGrow() { // å­˜åœ¨æ²¡æœ‰è¿ç§»å®Œçš„æ—§æ¡¶æ—¶ï¼Œå»æ£€æŸ¥æ—§æ¡¶ // t.reflexivekey() ä¸ºtrueè¡¨ç¤º k == k å§‹ç»ˆæˆç«‹ // t.reflexivekey() || t.key.equal(k, k) -\u0026gt; k == k å§‹ç»ˆæˆç«‹æƒ…å†µ if t.reflexivekey() || t.key.equal(k, k) { // å¦‚æœoldbucketä¸­çš„é¡¹ä¸æ˜¯é’ˆå¯¹è¿­ä»£ä¸­çš„å½“å‰æ–°bucketï¼Œè¯·è·³è¿‡å®ƒ hash := t.hasher(k, uintptr(h.hash0)) if hash\u0026amp;bucketMask(it.B) != checkBucket { // éœ€è¦è·³è¿‡çš„æƒ…å†µ continue } } else { // k == k ä¸æ˜¯å§‹ç»ˆæˆç«‹ // b.tophash[offi]\u0026amp;1 çš„æœ€ä½ä½ å‚çœ‹æ•°æ®è¿ç§»éƒ¨åˆ†çš„å»å‘ if checkBucket\u0026gt;\u0026gt;(it.B-1) != uintptr(b.tophash[offi]\u0026amp;1) { continue } } } // å°†æ‰¾åˆ°çš„kå’Œeä¿å­˜åˆ°hiterä¸­ // evacuatedX = 2ã€evacuatedY = 3 // b.tophash[offi] != evacuatedX \u0026amp;\u0026amp; b.tophash[offi] != evacuatedY å­˜åœ¨æœ‰æ•ˆæ•°æ® // !(t.reflexivekey() || t.key.equal(k, k))\t-\u0026gt; x == x ä¸æ˜¯å§‹ç»ˆæˆç«‹ if (b.tophash[offi] != evacuatedX \u0026amp;\u0026amp; b.tophash[offi] != evacuatedY) || !(t.reflexivekey() || t.key.equal(k, k)) { // è¿™æ˜¯éœ€è¦çš„æ•°æ®ï¼Œæˆ‘ä»¬å¯ä»¥è¿”å›å®ƒ // æˆ– // key!=keyï¼Œå› æ­¤æ— æ³•åˆ é™¤æˆ–æ›´æ–°æ¡ç›®ï¼Œå› æ­¤æˆ‘ä»¬å¯ä»¥åªè¿”å›å®ƒ // è¿™å¯¹æˆ‘ä»¬æ¥è¯´å¾ˆå¹¸è¿ï¼Œå› ä¸ºå½“key!=keyå…³é”®æ˜¯æˆ‘ä»¬æ‰¾ä¸åˆ°å®ƒ it.key = k if t.indirectelem() { e = *((*unsafe.Pointer)(e)) } it.elem = e } else { // æ•°æ®è¢«è¿ç§»åˆ°å…¶ä»–åœ°æ–¹äº† // è‡ªä»è¿­ä»£å™¨å¯åŠ¨ä»¥æ¥ï¼Œå“ˆå¸Œè¡¨ä¸€ç›´åœ¨å¢é•¿ // è¿™ä¸ªkeyçš„æ•°æ®ç°åœ¨åœ¨å…¶ä»–åœ°æ–¹ // æ£€æŸ¥æ•°æ®çš„å½“å‰å“ˆå¸Œè¡¨ // æ­¤ä»£ç å¤„ç†ä»¥ä¸‹æƒ…å†µï¼š //\tå·²è¢«åˆ é™¤ã€æ›´æ–°æˆ–åˆ é™¤å¹¶é‡æ–°æ’å…¥ //\tæ³¨æ„ï¼šæˆ‘ä»¬éœ€è¦é‡æ–°æ ‡è®°å¯†é’¥ï¼Œå› ä¸ºå®ƒå¯èƒ½å·²æ›´æ–°ä¸ºequal()ï¼Œä½†ä¸æ˜¯ç›¸åŒçš„keyï¼ˆä¾‹å¦‚+0.0 vs-0.0ï¼‰ rk, re := mapaccessK(t, h, k) // æ ¹æ®keyå»å¯»æ‰¾ç›¸åº”çš„æ•°æ®ï¼Œå¯èƒ½æ˜¯æ–°æ¡¶ä¹Ÿå¯èƒ½æ˜¯æ—§æ¡¶ // æ¯å¯»æ‰¾åˆ°ï¼Œå¯èƒ½keyå·²è¢«åˆ é™¤ if rk == nil { continue // key has been deleted } it.key = rk it.elem = re } it.bucket = bucket // å›å†™æ¡¶å· // è®°å½•å½“å‰æ­£åœ¨éå†çš„æ¡¶ if it.bptr != b { // avoid unnecessary write barrier; see issue 14921 it.bptr = b\t// é¿å…ä¸å¿…è¦çš„å†™å…¥éšœç¢ } it.i = i + 1 // iåŠ ä¸€ it.checkBucket = checkBucket return } b = b.overflow(t) // å¦‚æœä¸Šé¢æ¡¶éå†å®Œæ¥åˆ°å»åé¢æ¡¶æ‰¾ i = 0 goto next } mapaccessK()ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 // returns both key and elem. Used by map iterator // æ ¹æ®keyæ‰¾åˆ°ç›¸åº”çš„å€¼ func mapaccessK(t *maptype, h *hmap, key unsafe.Pointer) (unsafe.Pointer, unsafe.Pointer) { if h == nil || h.count == 0 { return nil, nil } hash := t.hasher(key, uintptr(h.hash0)) // å½“å‰keyç”Ÿæˆçš„hashå€¼ m := bucketMask(h.B) // (1 \u0026lt;\u0026lt; B) - 1 b := (*bmap)(add(h.buckets, (hash\u0026amp;m)*uintptr(t.bucketsize))) // keyå­˜å‚¨çš„å½“å‰æ¡¶ // æ˜¯å¦åœ¨æ‰©å®¹ä¸­ if c := h.oldbuckets; c != nil { if !h.sameSizeGrow() {\t// ç¿»å€æ‰©å®¹ // There used to be half as many buckets; mask down one more power of two. m \u0026gt;\u0026gt;= 1 } // å»æ—§æ¡¶é‡Œé¢æŸ¥çœ‹æ•°æ®æ˜¯å¦è¢«è¿ç§»äº† oldb := (*bmap)(add(c, (hash\u0026amp;m)*uintptr(t.bucketsize)))\t// æ•°æ®æ²¡æœ‰è¢«è¿ç§» tophash[0] != [2,3,4] if !evacuated(oldb) { b = oldb } } top := tophash(hash) // tophash bucketloop: // éå†å½“å‰æ¡¶åŠæº¢å‡ºæ¡¶å¯»æ‰¾ key for ; b != nil; b = b.overflow(t) { for i := uintptr(0); i \u0026lt; bucketCnt; i++ { if b.tophash[i] != top { if b.tophash[i] == emptyRest { // emptyRest = 0 break bucketloop } continue } // æ‰¾åˆ°äº†key // 1. å¯èƒ½æ˜¯hashå†²çªåˆ™è¿˜éœ€è¦å‘åå»æŸ¥æ‰¾ // 2. ç¡®å®æ‰¾åˆ°äº†keyç›´æ¥è¿”å›å³å¯ k := add(unsafe.Pointer(b), dataOffset+i*uintptr(t.keysize)) if t.indirectkey() { k = *((*unsafe.Pointer)(k)) } // keyåŒ¹é…æˆåŠŸ if t.key.equal(key, k) { e := add(unsafe.Pointer(b), dataOffset+bucketCnt*uintptr(t.keysize)+i*uintptr(t.elemsize)) if t.indirectelem() { e = *((*unsafe.Pointer)(e)) } return k, e } } } return nil, nil } æ€»ç»“ for-rangeä¸æ”¯æŒã€å­—ç¬¦ä¸²æŒ‡é’ˆã€‘ã€ã€åˆ‡ç‰‡æŒ‡é’ˆã€‘ã€ã€mapæŒ‡é’ˆã€‘ã€ã€channelæŒ‡é’ˆã€‘ï¼Œä½†æ”¯æŒã€æ•°ç»„æŒ‡é’ˆã€‘éå†ã€‚ ","permalink":"https://heliu.site/posts/golang/process/range/","summary":"Golang for rangeè¿­ä»£stringã€channelã€arrayã€sliceã€mapè§£æã€‚","title":"æµç¨‹æ§åˆ¶(rangeè¿­ä»£)"},{"content":" è¡¨è¾¾å¼å‹switchï¼šåŒ…å«ä¸switchè¡¨è¾¾å¼çš„å€¼è¿›è¡Œæ¯”è¾ƒçš„è¡¨è¾¾å¼ã€‚ ç±»å‹å‹switchï¼šåŒ…å«ä¸switchè¡¨è¾¾å¼çš„ç±»å‹è¿›è¡Œæ¯”è¾ƒçš„ç±»å‹ã€‚ switch ä½¿ç”¨æ–¹å¼ switch var{} switch è¡¨è¾¾å¼å¯ä»¥æ‰§è¡Œä¸€ä¸ªç®€å•è¯­å¥å®Œæˆè¿ç®—ä»è€Œå¾—åˆ°è¡¨è¾¾å¼çš„å€¼ã€‚ 1 2 3 4 5 6 7 8 switch var { // switch ä¼šåˆ¤æ–­varçš„ç±»å‹ case val1: // case ä¼šåˆ¤æ–­val1çš„ç±»å‹ä»¥ä¾¿å’Œvarèƒ½æ¯”è¾ƒ // ... case val2: // ... default: // ... } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 package main import ( \u0026#34;fmt\u0026#34; ) const B1 = false func main() { switch B1 { case false: fmt.Println(\u0026#34;fallthrough è¯­å¥ æ¥åˆ°æ‰§è¡Œä¸‹ä¸€ä¸ªè¯­å¥\u0026#34;) fallthrough case true: fmt.Println(\u0026#34;true\u0026#34;) fallthrough case false: fmt.Println(123) fallthrough case true: fmt.Println(456789) default: fmt.Println(\u0026#34;default\u0026#34;) } fmt.Println(\u0026#34;default 1234\u0026#34;) // \u0026gt; ---------------------------------------------------- var i1 = 2 switch i1 { default: fmt.Println(\u0026#34;default\u0026#34;) case 0,1,2,3: fmt.Println(\u0026#34;123456789\u0026#34;) case 4,5,6,7: fmt.Println(\u0026#34;987654321\u0026#34;) } // \u0026gt; ---------------------------------------------------- switch i1 { default: fmt.Println(\u0026#34;default\u0026#34;) case 0: case 1: case 2: case 3: fmt.Println(\u0026#34;123456789\u0026#34;) case 4,5,6,7: fmt.Println(\u0026#34;987654321\u0026#34;) } // æ³¨æ„ case 0,1,2,3: å½¢å¼å’Œ case 0: case 1: case 2: è¿™ç§å½¢å¼çš„åŒºåˆ« // Output: // fallthrough è¯­å¥ æ¥åˆ°æ‰§è¡Œä¸‹ä¸€ä¸ªè¯­å¥ // true // 123 // 456789 // default 1234 // 123456789 } switch{} ä¸æä¾›ä»»ä½•è¢«åˆ¤æ–­çš„å€¼ï¼ˆå®é™…ä¸Šé»˜è®¤ä¸ºåˆ¤æ–­æ˜¯å¦ä¸ºtrueï¼‰ç„¶ååœ¨æ¯ä¸ªcaseåˆ†æ”¯ä¸­æ£€æµ‹ä¸åŒçš„æ¡ä»¶ï¼Œå½“ä»»ä¸€åˆ†æ”¯çš„æµ‹è¯•ç»“æœä¸ºtrueæ—¶ï¼Œè¯¥åˆ†æ”¯çš„ä»£ç ä¼šè¢«æ‰§è¡Œï¼Œæ­¤æ—¶è¯­å¥ç›¸å½“äºswitch trueã€‚ 1 2 3 4 5 6 7 8 switch { // é»˜è®¤æ¨å¯¼ä¸ºå¸ƒå°”ç±»å‹ true case condition1: // condition1æ¯”è¾ƒæ¡ä»¶ // ... case condition2: // ... default: // ... } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 package main import ( \u0026#34;fmt\u0026#34; ) func main() { var x, y, z = 2, 1, 3 // switch {} ç­‰ä»·äº switch true {} switch { case x \u0026lt; y: fmt.Printf(\u0026#34;x:%d,y:%d\\n\u0026#34;, x, y) case x \u0026lt; z: fmt.Printf(\u0026#34;x:%d,z:%d\\n\u0026#34;, x, z) case z == 3: fmt.Println(\u0026#34;z==4\\n\u0026#34;) } // Output: // x:2,z:3 } switch Init; var{} switchè¯­å¥ç¬¬ä¸‰ç§å½¢å¼ï¼ŒåŒ…å«ä¸€ä¸ªåˆå§‹åŒ–è¯­å¥ã€‚ 1 2 3 4 5 6 7 8 switch Init; var { case val1: // ... case val2: // ... default: // ... } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 package main import ( \u0026#34;fmt\u0026#34; ) func main() { // switch x, y, z := 2, 1, 3; {} ç­‰ä»·äº switch x, y, z := 2, 1, 3; true {} // ç­‰ä»·äº // { // x, y, z := 2, 1, 3; // switch true { // // ... ... // } // } switch x, y, z := 2, 1, 3; { case x \u0026lt; y: fmt.Printf(\u0026#34;x:%d,y:%d\\n\u0026#34;, x, y) case x \u0026lt; z: fmt.Printf(\u0026#34;x:%d,z:%d\\n\u0026#34;, x, z) case z == 3: fmt.Println(\u0026#34;z==4\\n\u0026#34;) } switch x, y, z := 2, 1, 3; false { case x \u0026lt; y: fmt.Printf(\u0026#34;x:%d,y:%d\\n\u0026#34;, x, y) case x \u0026lt; z: fmt.Printf(\u0026#34;x:%d,z:%d\\n\u0026#34;, x, z) case z == 3: fmt.Println(\u0026#34;z==4\\n\u0026#34;) } // Output: // x:2,z:3 // x:2,y:1 } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 package main import \u0026#34;fmt\u0026#34; func main() { var j = 0 switch j { case 0: // æ³¨æ„è¿™ç§å’Œcase 0, 1:å½¢å¼çš„åŒºåˆ« case 1: fmt.Println(\u0026#34;11\u0026#34;) case 2: fmt.Println(\u0026#34;22\u0026#34;) default: fmt.Println(\u0026#34;def def\u0026#34;) } var k = 0 switch k { case 0: fmt.Println(\u0026#34;fallthrough\u0026#34;) fallthrough case 1: fmt.Println(\u0026#34;111\u0026#34;) case 2: fmt.Println(\u0026#34;211\u0026#34;) default: fmt.Println(\u0026#34;def def def\u0026#34;) } var m = 0 switch m { case 0, 1: fmt.Println(\u0026#34;1111\u0026#34;) case 2: fmt.Println(\u0026#34;2111\u0026#34;) default: fmt.Println(\u0026#34;def def def def\u0026#34;) } var n = 0 switch { case n \u0026gt; 0 \u0026amp;\u0026amp; n \u0026lt; 10: fmt.Println(\u0026#34;i \u0026gt; 0 and i \u0026lt; 10\u0026#34;) case n \u0026gt; 10 \u0026amp;\u0026amp; n \u0026lt; 20: fmt.Println(\u0026#34;i \u0026gt; 10 and i \u0026lt; 20\u0026#34;) default: fmt.Println(\u0026#34;def def def def def\u0026#34;) } // Output: // fallthrough // 111 // 1111 // def def def def def } è¡¨è¾¾å¼å‹switch å¦‚æœswitchè¡¨è¾¾å¼æ±‚å€¼ä¸ºæ— ç±»å‹å¸¸é‡ï¼Œåˆ™é¦–å…ˆå°†å…¶è½¬æ¢ä¸ºé»˜è®¤ç±»å‹ï¼ˆæ•´å‹é»˜è®¤intï¼Œæµ®ç‚¹æ•°é»˜è®¤float64ï¼Œå­—ç¬¦ä¸²é»˜è®¤stringï¼Œå¤æ•°é»˜è®¤complex128ï¼‰ã€‚ å¦‚æœæ˜¯æ— ç±»å‹çš„å¸ƒå°”å€¼ï¼Œåˆ™é¦–å…ˆå°†å…¶è½¬æ¢ä¸ºboolç±»å‹ã€‚ é¢„å…ˆå£°æ˜çš„æ— ç±»å‹å€¼nilä¸èƒ½ç”¨ä½œå¼€å…³è¡¨è¾¾å¼ï¼ˆç”±äºswitchè½¬æ¢nilä¸ºé»˜è®¤ç±»å‹æŠ¥é”™ï¼‰ã€‚ å¦‚æœswitchè¡¨è¾¾å¼æ˜¯æ— ç±»å‹çš„ï¼Œåˆ™é¦–å…ˆå°†å…¶è½¬æ¢ä¸ºswitchè¡¨è¾¾å¼çš„ç±»å‹ã€‚ å¯¹äºæ¯ä¸ªï¼ˆå¯èƒ½å·²è½¬æ¢çš„ï¼‰switchè¡¨è¾¾å¼xå’Œswitchè¡¨è¾¾å¼çš„å€¼tï¼Œxå’Œtå¿…é¡»å¯ä»¥è¿›è¡Œæœ‰æ•ˆçš„æ¯”è¾ƒã€‚ åœ¨switchæˆ–defaultå­—å¥ä¸­ï¼Œæœ€åä¸€ä¸ªéç©ºè¯­å¥å¯ä»¥æ˜¯fallthroughè¯­å¥ã€‚ ä»¥æŒ‡ç¤ºåº”è¯¥ä»è¯¥å­—å¥çš„æœ«å°¾æµå‘ä¸‹ä¸€ä¸ªå­—å¥çš„ç¬¬ä¸€ä¸ªè¯­å¥ï¼Œæ— è®ºä¸‹ä¸€ä¸ªå­—å¥çš„æ¡ä»¶æ˜¯å¦æ»¡è¶³ã€‚ å‡ºç°fallthroughè¯­å¥åï¼Œå®ƒåé¢åªèƒ½æ¥ä¸‹ä¸€ä¸ªå­—å¥ã€‚ 1 2 3 4 5 6 7 8 switch expr { case v1: // pass case v2: // pass default: // pass } nilä¸èƒ½ä½œä¸ºswitchè¡¨è¾¾å¼ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 package main import \u0026#34;fmt\u0026#34; func main() { // è¿™é‡Œswitchå°†nilè½¬æ¢æˆé»˜è®¤ç±»å‹è¿›è¡Œä»¥ä¸‹æ¯”è¾ƒæ—¶æŠ¥é”™ // å’Œä¹‹å‰çš„ a := nil æˆ– var a = nil ä¸€æ ·æŠ¥é”™ä¸èƒ½åˆ¤æ–­å‡ºaçš„å…·ä½“ç±»å‹ // ç”±æ­¤å¯è§swicthéœ€è¦ç¡®å®šå˜é‡çš„å”¯ä¸€ç±»å‹ switch nil { // æŠ¥é”™ case nil: fmt.Println(\u0026#34;nil\u0026#34;) default: fmt.Println(\u0026#34;default\u0026#34;) } // .\\os.go:8:2: use of untyped nil // ä¸‹é¢è¿™ç§å´æ˜¯å¯ä»¥ var m map[string]string switch m { // è¿™é‡Œèƒ½ç¡®è®¤mæ˜¯mapç±»å‹ case nil: fmt.Println(\u0026#34;nil\u0026#34;) default: fmt.Println(\u0026#34;default\u0026#34;) } // Output: // nil } æ— ç±»å‹å¸¸é‡ç”¨ä½œswitch 1 2 3 4 5 6 7 8 9 10 11 12 13 14 package main import \u0026#34;fmt\u0026#34; const Sw = 12 func main() { switch Sw { // Swè¢«é»˜è®¤æ¨å¯¼ä¸ºintç±»å‹ // (untyped float constant) truncated to int // æŠ¥é”™ï¼Œ1.1è¢«é»˜è®¤æ¨å¯¼ä¸ºfloat64ç±»å‹æ— æ³•ä¸intç±»å‹æ¯”è¾ƒ case 1.1:\tfmt.Println() } } switchå¸¸ç”¨ç¤ºä¾‹ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 package main import \u0026#34;fmt\u0026#34; func main() { // å®šä¹‰å±€éƒ¨å˜é‡ var grade string = \u0026#34;B\u0026#34; var marks int = 90 switch marks { case 90: grade = \u0026#34;A\u0026#34; case 80: grade = \u0026#34;B\u0026#34; // è¿™é‡Œä¸å…¶ä»–è¯­è¨€å†™æ³•çš„æ ¹æœ¬åŸå› æ˜¯goé»˜è®¤ä¼šæ·»åŠ breakè¯­å¥ï¼Œè€Œå…¶ä»–è¯­è¨€æ²¡æœ‰è¿™ä¸€ç‰¹æ€§çš„åŸå›  case 50, 60, 70: // è¿™é‡ŒåŒºåˆ†å…¶ä»–è¯­è¨€ case 50: case 60: case 70: grade = \u0026#34;C\u0026#34; default: grade = \u0026#34;D\u0026#34; } // switch çœç•¥æ¡ä»¶ é»˜è®¤ä¸º switch true {} // å’Œfor {} ä¸€æ ·çœç•¥æ¡ä»¶é»˜è®¤ä¸º for true {} switch { case grade == \u0026#34;A\u0026#34;: fmt.Printf(\u0026#34;ä¼˜ç§€\\n\u0026#34;) case grade == \u0026#34;B\u0026#34;, grade == \u0026#34;C\u0026#34;: fmt.Printf(\u0026#34;è‰¯å¥½\\n\u0026#34;) case grade == \u0026#34;D\u0026#34;: fmt.Printf(\u0026#34;åŠæ ¼\\n\u0026#34;) case grade == \u0026#34;F\u0026#34;: fmt.Printf(\u0026#34;ä¸åŠæ ¼\\n\u0026#34;) default: fmt.Printf(\u0026#34;å·®\\n\u0026#34;) } fmt.Printf(\u0026#34;ä½ çš„ç­‰çº§æ˜¯ %s\\n\u0026#34;, grade) // Output: // ä¼˜ç§€ // ä½ çš„ç­‰çº§æ˜¯ A } fallthroughå…³é”®å­— 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 package main import ( \u0026#34;fmt\u0026#34; ) func main() { // fallthrough å…³é”®å­— ç»§ç»­æ‰§è¡Œä¸‹ä¸€ä¸ªcaseä¸åˆ¤æ–­caseå€¼ switch { case false: fmt.Println(\u0026#34;fallthrough è¯­å¥ æ¥åˆ°æ‰§è¡Œä¸‹ä¸€ä¸ªè¯­å¥\u0026#34;) fallthrough case true: fmt.Println(\u0026#34;true\u0026#34;) fallthrough case false: fmt.Println(123) fallthrough case true: fmt.Println(456789) // fallthroughå¼ºåˆ¶æ‰§è¡Œã€ç´§æŒ¨ç€ç›¸é‚»ã€‘çš„caseæˆ–defaultå—ï¼Œ // å¦‚æœåé¢æ²¡æœ‰ç´§æŒ¨ç€çš„åˆ™æŠ¥é”™ fallthrough default: fmt.Println(\u0026#34;default\u0026#34;) } // Output: // true // 123 // 456789 // default } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 package main import \u0026#34;fmt\u0026#34; func main() { var k = 2 switch k { case 0: fmt.Println(\u0026#34;fallthrough\u0026#34;) case 2: fmt.Println(\u0026#34;211\u0026#34;) fallthrough // å¯è§ï¼Œfallthrough åç´§æŒ¨ç€ default ä¹Ÿä¼šæ‰§è¡Œå®ƒã€‚ default: fmt.Println(\u0026#34;def def def\u0026#34;) case 1: fmt.Println(\u0026#34;111\u0026#34;) } // Output: // 211 // def def def } fallthroughå’Œdefaultä¸€èµ·ä½¿ç”¨ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 switch { default: // æ¯”å¦‚è¿™é‡Œå½“åŒ¹é…æ¡ä»¶éƒ½ä¸é€šè¿‡ï¼Œåˆ™åˆ°defaultè¿™é‡Œ fmt.Println(\u0026#34;1\u0026#34;) fallthrough // fallthroughåç»§ç»­æ‰§è¡Œåé¢çš„case case true: fmt.Println(\u0026#34;2\u0026#34;) } // Output: // 2 switch { default: // æ¯”å¦‚è¿™é‡Œå½“åŒ¹é…æ¡ä»¶éƒ½ä¸é€šè¿‡ï¼Œåˆ™åˆ°defaultè¿™é‡Œ fmt.Println(\u0026#34;1\u0026#34;) fallthrough // fallthroughåç»§ç»­æ‰§è¡Œåé¢çš„case case false: fmt.Println(\u0026#34;2\u0026#34;) } // Output: // 1 // 2 ç±»å‹å‹switch æ¯”è¾ƒçš„ç±»å‹è€Œä¸æ˜¯å€¼ï¼Œå®ƒåœ¨å…¶ä»–æ–¹é¢ç±»ä¼¼è¡¨è¾¾å¼å‹switchï¼Œåªä¸è¿‡åˆ†æ”¯é€‰æ‹©çš„æ˜¯ç±»å‹è€Œä¸æ˜¯å€¼ã€‚ å®ƒç”±ä¸€ä¸ªç‰¹æ®Šçš„switchè¡¨è¾¾å¼æ ‡è®°ï¼Œè¯¥è¡¨è¾¾å¼ä½¿ç”¨ç±»å‹æ–­è¨€çš„å½¢å¼æ¥è¿›è¡ŒåŠ¨æ€ç±»å‹åˆ¤æ–­ã€‚ x.(type) switch è¯­å¥è¿˜å¯ä»¥è¢«ç”¨äº type-switch æ¥åˆ¤æ–­æŸä¸ª interface å˜é‡ä¸­å®é™…å­˜å‚¨çš„å˜é‡ç±»å‹ã€‚ type switch è¯­å¥æ ¼å¼å¦‚ä¸‹ï¼š 1 2 3 4 5 6 7 8 switch x.(type) { case type: statement(s) case type: statement(s) default: statement(s) } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 package main import ( \u0026#34;fmt\u0026#34; ) func main() { // å®šä¹‰å˜é‡t æ¥å£ç±»å‹ interface{} å¯ä»¥æ˜¯ä»»ä½•å…¶ä»–ç±»å‹ var t interface{} t = functionOfSomeType() // switch t.(type) { ... } // t.(type) æ–­è¨€tçš„ç±»å‹ .(type)å½¢å¼å¿…é¡»é…åˆswitchä½¿ç”¨ switch t1 := t.(type) { default: fmt.Printf(\u0026#34;default Type %T\\n\u0026#34;, t1) case bool: fmt.Printf(\u0026#34;bool %t\\n\u0026#34;, t1) case int: fmt.Printf(\u0026#34;integer %d\\n\u0026#34;, t1) case *bool: fmt.Printf(\u0026#34;pointer bool %t\\n\u0026#34;, *t1) case *int: fmt.Printf(\u0026#34;pointer integer %d\\n\u0026#34;, *t1) } } //func functionOfSomeType () bool { // return false //} // bool false //func functionOfSomeType () uint { // return 123 //} // default Type uint //func functionOfSomeType () int { // return 123 //} // integer 123 //func functionOfSomeType () *int { // a := 123 // return \u0026amp;a //} // pointer integer 123 func functionOfSomeType () *bool { a := true return \u0026amp;a } // pointer bool true æ³¨æ„ val1å’Œval2å¯ä»¥æ˜¯åŒç±»å‹çš„ä»»æ„å€¼ï¼Œç±»å‹ä¸å±€é™äºå¸¸æ•°æˆ–æ•´æ•°ï¼Œä½†å¿…é¡»æ˜¯ç›¸åŒçš„ç±»å‹ï¼Œæˆ–æœ€ç»ˆç»“æœä¸ºç›¸åŒç±»å‹çš„è¡¨è¾¾å¼ã€‚ å‰èŠ±æ‹¬å·{å¿…é¡»å’Œswitchå…³é”®å­—åœ¨åŒä¸€è¡Œã€‚ å¯ä»¥åŒæ—¶æµ‹è¯•å¤šä¸ªå¯èƒ½ç¬¦åˆæ¡ä»¶çš„å€¼ï¼Œä½¿ç”¨é€—å·åˆ†å‰²å®ƒä»¬ã€‚ å¦‚case val1, val2, val3è€Œåœ¨å…¶ä»–è¯­è¨€ä¸­åˆ™æ˜¯case val1: case val2: case val3:è¿™ç§å½¢å¼ã€‚ ä¸€æ—¦æˆåŠŸåœ°åŒ¹é…åˆ°æŸä¸ªåˆ†æ”¯ï¼Œåœ¨æ‰§è¡Œå®Œç›¸åº”ä»£ç åå°±ä¼šé€€å‡ºæ•´ä¸ªswitchä»£ç å—ã€‚ ä¹Ÿå°±æ˜¯è¯´ï¼Œä¸éœ€è¦ç‰¹åˆ«ä½¿ç”¨breakè¯­å¥æ¥è¡¨ç¤ºç»“æŸï¼Œå¦‚æœä½¿ç”¨äº†ä»ç„¶æ˜¯åœ¨switchå—ä¸­ã€‚ å¦‚æœåœ¨æ‰§è¡Œå®Œæ¯ä¸ªåˆ†æ”¯çš„ä»£ç åï¼Œè¿˜æ˜¯å¸Œæœ›ç»§ç»­æ‰§è¡Œåç»­åˆ†æ”¯çš„ä»£ç ã€‚ å¯ä»¥ä½¿ç”¨fallthroughå…³é”®å­—æ¥è¾¾åˆ°ç›®çš„ï¼Œfallthroughå¼ºåˆ¶æ‰§è¡Œåé¢çš„(ç´§æŒ¨ç€çš„)ä¸‹ä¸€æ¡åˆ†æ”¯ä»£ç ï¼Œä¸ç®¡æ˜¯caseæˆ–defaultåˆ†æ”¯éƒ½ä¼šæ‰§è¡Œã€‚ fallthroughä¸ä¼šåˆ¤æ–­ä¸‹ä¸€æ¡åˆ†æ”¯çš„è¡¨è¾¾å¼ç»“æœæ˜¯å¦ä¸ºçœŸã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 package main import ( \u0026#34;fmt\u0026#34; ) func main() { switch a := 1; { case a == 1: fmt.Printf(\u0026#34;a == %d\\n\u0026#34;, a) fallthrough case a == 2: fmt.Println(\u0026#34;a == 2\u0026#34;) case a == 3: fmt.Println(\u0026#34;a == 3\u0026#34;) fallthrough case a == 5: fmt.Println(\u0026#34;a == 5\u0026#34;) fallthrough default: fmt.Println(\u0026#34;default\u0026#34;) case a == 4: fmt.Println(\u0026#34;a == 4\u0026#34;) } // Output: // a == 1 // a == 2 } ","permalink":"https://heliu.site/posts/golang/process/switch/","summary":"Golang ä»‹ç»switchçš„ç”¨æ³•ã€‚","title":"æµç¨‹æ§åˆ¶(switch)"},{"content":" selectæ˜¯Goä¸­çš„ä¸€ä¸ªæ§åˆ¶ç»“æ„ï¼Œç±»ä¼¼switchè¯­å¥ã€‚ ä¸»è¦ä½œç”¨æ˜¯å¤„ç†å¼‚æ­¥é€šé“æ“ä½œï¼Œæ‰€æœ‰æƒ…å†µéƒ½ä¼šæ¶‰åŠé€šä¿¡æ“ä½œï¼Œä¸»è¦ç”¨äºchannelæ“ä½œã€‚ å› æ­¤selectä¼šç›‘å¬åˆ†æ”¯è¯­å¥ä¸­é€šé“çš„è¯»å†™æ“ä½œï¼Œå½“åˆ†æ”¯ä¸­çš„é€šé“è¯»å†™æ“ä½œä¸ºéé˜»å¡çŠ¶æ€ï¼ˆå³èƒ½è¯»å†™ï¼‰æ—¶ï¼Œå°†ä¼šè§¦å‘ç›¸åº”çš„åŠ¨ä½œã€‚ selectè¯­å¥ä¼šé€‰æ‹©ä¸€ç»„å¯ä»¥å‘é€æˆ–æ¥æ”¶æ“ä½œä¸­çš„ä¸€ä¸ªåˆ†æ”¯ç»§ç»­æ‰§è¡Œï¼Œselectæ²¡æœ‰æ¡ä»¶è¡¨è¾¾å¼ï¼Œä¸€ç›´ç­‰å¾…caseè¿›å…¥å¯è¿è¡ŒçŠ¶æ€ã€‚ æ€»ç»“ï¼š selectä¸­çš„caseè¯­å¥å¿…é¡»æ˜¯å¯¹é€šé“çš„æ“ä½œã€‚ selectä¸­çš„defaultå­å¥æ€»æ˜¯å¯è¿è¡Œçš„ã€‚ å¦‚æœæœ‰å¤šä¸ªåˆ†æ”¯éƒ½å¯ä»¥è¿è¡Œï¼Œselectä¼šä¼ªéšæœºå…¬å¹³çš„é€‰å‡ºä¸€ä¸ªæ‰§è¡Œï¼Œå…¶ä»–åˆ†æ”¯ä¸ä¼šæ‰§è¡Œã€‚ å¦‚æœæ²¡æœ‰å¯è¿è¡Œçš„åˆ†æ”¯ï¼Œä¸”æœ‰defaultè¯­å¥ï¼Œé‚£ä¹ˆå°±ä¼šæ‰§è¡Œdefaultçš„åŠ¨ä½œã€‚ å¦‚æœæ²¡æœ‰å¯è¿è¡Œçš„åˆ†æ”¯ï¼Œä¸”æ²¡æœ‰defaultè¯­å¥ï¼Œselectå°†é˜»å¡ï¼Œç›´åˆ°æŸä¸ªåˆ†æ”¯å¯ä»¥è¿è¡Œã€‚ å…³äºselectå…³é”®å­—çš„è¿è¡ŒåŸç†åœ¨channelç¯‡ä»‹ç»ã€‚(å¦‚æœæ‚¨è¿˜ä¸ç†Ÿæ‚‰channelï¼Œå‚çœ‹channelåå†é˜…è¯»æœ¬ç¯‡æ–‡ç« ) select(åŸç†)ã€‚ è¯­æ³•æ ¼å¼ Goç¼–ç¨‹è¯­è¨€ä¸­selectè¯­å¥çš„è¯­æ³•å¦‚ä¸‹ï¼š 1 2 3 4 5 6 7 8 select { case communication clause: statement(s) case communication clause: statement(s) default: statement(s) } ä½¿ç”¨ç¤ºä¾‹ nil channelä½¿ç”¨select defaultç»“æ„ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 package main import \u0026#34;fmt\u0026#34; func main() { var c1, c2, c3 chan int // nil var i1, i2 int // ç”±äºselectgoå‡½æ•°çš„æºä»£ç å¯çŸ¥ï¼Œgoä¼šæŠŠæ‰€æœ‰énilçš„channelç»„æˆä¸€ä¸ªsend+recvé›† // ç„¶åall channel lock ä¼ªéšæœºçš„éå†caseé›†ã€‚ // ç”±äºè¿™é‡Œçš„channeléƒ½æ˜¯nilï¼Œåˆ™ä¸å­˜åœ¨caseé›†ï¼Œç›´æ¥èµ°default select { case i1 = \u0026lt;-c1: fmt.Printf(\u0026#34;received \u0026#34;, i1, \u0026#34; from c1\\n\u0026#34;) case c2 \u0026lt;- i2: fmt.Printf(\u0026#34;sent \u0026#34;, i2, \u0026#34; to c2\\n\u0026#34;) case i3, ok := \u0026lt;-c3: if ok {// ok ä¸º trueï¼Œè¡¨ç¤ºæ­£å¸¸è·å–åˆ°å€¼ i3 fmt.Printf(\u0026#34;received \u0026#34;, i3, \u0026#34; from c3\\n\u0026#34;) } else {// ok ä¸º falseï¼Œè¡¨ç¤ºchannelå› å…³é—­è€Œè§¦å‘ fmt.Printf(\u0026#34;c3 is closed\\n\u0026#34;) } default: // èµ°é»˜è®¤åˆ†æ”¯ fmt.Printf(\u0026#34;no communication\\n\u0026#34;) } // Output: // no communication } ä¸å­˜åœ¨defaultåˆ†æ”¯æ—¶ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;time\u0026#34; ) func main() { var c1, c2, c3 chan int // nil var i1, i2 int // ç”±äºselectgoå‡½æ•°çš„æºä»£ç å¯çŸ¥ï¼Œgoä¼šæŠŠæ‰€æœ‰énilçš„channelç»„æˆä¸€ä¸ªsend+recvé›† // ç„¶åall channel lock ä¼ªéšæœºçš„éå†caseé›†ã€‚ // ç”±äºè¿™é‡Œåªæœ‰Timer.Cè¿™ä¸ªchanåœ¨caseé›†ä¸­ï¼Œåˆ™è·å–lockç„¶åä»è¿™é‡Œè¯»å–æ•°æ®ï¼Œä¸èƒ½ç«‹åˆ»å®Œæˆåˆ™è¢«æŒ‚èµ·ç­‰å¾…ã€‚ select { case i1 = \u0026lt;-c1: fmt.Printf(\u0026#34;received \u0026#34;, i1, \u0026#34;from c1\\n\u0026#34;) case c2 \u0026lt;- i2: fmt.Printf(\u0026#34;sent \u0026#34;, i2, \u0026#34;to c2\\n\u0026#34;) case i3, ok := (\u0026lt;-c3): if ok { fmt.Printf(\u0026#34;received \u0026#34;, i3, \u0026#34;from c3\\n\u0026#34;) } else { fmt.Printf(\u0026#34;c3 is closed\\n\u0026#34;) } // func After(d Duration) \u0026lt;-chan Time // Afterä¼šåœ¨å¦ä¸€çº¿ç¨‹ç»è¿‡æ—¶é—´æ®µdåå‘è¿”å›å€¼å‘é€å½“æ—¶çš„æ—¶é—´ã€‚ç­‰ä»·äºNewTimer(d).C case \u0026lt;-time.After(time.Second * 3): // è¶…æ—¶é€€å‡º fmt.Println(\u0026#34;request time out\u0026#34;) } // Output: // request time out } å¸¸ç”¨ç”¨æ³• è¶…æ—¶åˆ¤æ–­ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;time\u0026#34; ) var resChan = make(chan int) func main() { test() // request time out // Output: // request time out } func test() { // 1. caseé›†æ˜¯send+recvçš„é›†åˆï¼Œä¸åŒ…å«default // 2. è·å–æ‰€æœ‰ all channel lock // 3. ä¼ªéšæœºéå†æ‰€æœ‰çš„caseé›†ï¼Œå¯»æ‰¾æ˜¯å¦æœ‰ç«‹åˆ»å®Œæˆchannelã€‚ // 4. å¦‚æœéƒ½æ²¡æœ‰åˆ™ä»¥sudogå½¢å¼å°è£…å½“å‰goroutineæŒ‚åœ¨æ‰€æœ‰çš„channelä¸Šï¼Œall channel unlock å†æ¬¡è°ƒåº¦å¾ªç¯ç­‰å¾…å”¤é†’ã€‚ // 5. å½“goroutineè¢«å”¤é†’ï¼Œå¤„ç†æ‰€æœ‰æŒ‚åœ¨channelä¸Šçš„sudogï¼Œç„¶åè¿”å›ï¼Œå› ä¸ºæ•°æ®äº¤æ¢å·²ç»åœ¨å”¤é†’å‰å¤„ç†äº†ã€‚ select { case data := \u0026lt;-resChan: // ç­‰å¾…ä»resChanä¸­è¯»å–æ•°æ® doData(data) case \u0026lt;-time.After(time.Second * 3): // 3ç§’åä¼šåƒtime.Cé€šé“ä¸­å†™å…¥å½“å‰æ—¶é—´ï¼Œè¿™é‡Œå¾—åˆ°é€‰ä¸­ fmt.Println(\u0026#34;request time out\u0026#34;) } } func doData(data int) { fmt.Println(\u0026#34;doDataï¼š\u0026#34;, data) } åˆ¤æ–­channelæ˜¯å¦é˜»å¡ã€‚ 1 2 3 4 5 6 7 8 9 10 11 // åœ¨æŸäº›æƒ…å†µä¸‹æ˜¯å­˜åœ¨ä¸å¸Œæœ›channelç¼“å­˜æ»¡äº†çš„éœ€æ±‚çš„ï¼Œå¯ä»¥ç”¨å¦‚ä¸‹æ–¹æ³•åˆ¤æ–­ ch := make (chan int, 5) // ... dataï¼š= 0 // tryLock å½¢å¼ï¼Œæ˜¯å¦èƒ½ç«‹å³å®Œæˆã€‚ select { case ch \u0026lt;- data: default: //åšç›¸åº”æ“ä½œï¼Œæ¯”å¦‚ä¸¢å¼ƒdataã€‚è§†éœ€æ±‚è€Œå®š } selectä½œç”¨åœ¨channel c\u0026lt;-v 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // compiler implements // // select { // case c \u0026lt;- v: // ... foo // default: // ... bar // } // // as // // if selectnbsend(c, v) { // ... foo // } else { // ... bar // } func selectnbsend(c *hchan, elem unsafe.Pointer) (selected bool) { // selectedè¿”å›å€¼ true.è¯¥åˆ†æ”¯è¢«é€‰ä¸­ false.è¯¥åˆ†æ”¯ä¸ä¼šè¢«é€‰ä¸­ return chansend(c, elem, false, getcallerpc()) } v\u0026lt;-c 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 // compiler implements // // select { // case v = \u0026lt;-c: // ... foo // default: // ... bar // } // // as // // if selectnbrecv(\u0026amp;v, c) { // ... foo // } else { // ... bar // } func selectnbrecv(elem unsafe.Pointer, c *hchan) (selected bool) { // chanrecvå‡½æ•°å­˜åœ¨ä¸¤ä¸ªè¿”å›å€¼ å¸ƒå°” // selected è¿”å›å€¼ true.è¯¥åˆ†æ”¯è¢«é€‰ä¸­ false.è¯¥åˆ†æ”¯ä¸ä¼šè¢«é€‰ä¸­ // ç¬¬äºŒä¸ªè¿”å›å€¼ï¼Œå½“å‰æ˜¯å¦è¯»å–æ•°æ®æˆåŠŸï¼Œ false.è¯»å–å¤±è´¥ true.è¯»å–æˆåŠŸ selected, _ = chanrecv(c, elem, false) return } v, ok = \u0026lt;-c 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 // compiler implements // // select { // case v, ok = \u0026lt;-c: // ... foo // default: // ... bar // } // // as // // if c != nil \u0026amp;\u0026amp; selectnbrecv2(\u0026amp;v, \u0026amp;ok, c) { // ... foo // } else { // ... bar // } func selectnbrecv2(elem unsafe.Pointer, received *bool, c *hchan) (selected bool) { // TODO(khr): just return 2 values from this function, now that it is in Go. // chanrecvå‡½æ•°å­˜åœ¨ä¸¤ä¸ªè¿”å›å€¼ å¸ƒå°”å€¼ // selected è¿”å›å€¼ true.è¯¥åˆ†æ”¯è¢«é€‰ä¸­ false.è¯¥åˆ†æ”¯ä¸ä¼šè¢«é€‰ä¸­ // ç¬¬äºŒä¸ªè¿”å›å€¼ï¼Œå½“å‰æ˜¯å¦è¯»å–æ•°æ®æˆåŠŸï¼Œ false.è¯»å–å¤±è´¥ true.è¯»å–æˆåŠŸ selected, *received = chanrecv(c, elem, false) return } ","permalink":"https://heliu.site/posts/golang/process/select/","summary":"Golang selectä»‹ç»ã€‚","title":"æµç¨‹æ§åˆ¶(select)"},{"content":"package åŒ…çš„æ¦‚å¿µ ä½¿ç”¨åŒ…æ¥ç»„ç»‡ç®¡ç†ä»£ç ï¼ŒåŒ…æ˜¯ç»“æ„åŒ–ä»£ç çš„ä¸€ç§æ–¹å¼ã€‚ æ¯ä¸ª.goæ–‡ä»¶éƒ½å¿…é¡»å½’å±äºæŸä¸€ä¸ªåŒ…ï¼Œæ¯ä¸ª.goæ–‡ä»¶éƒ½å¯èƒ½æœ‰init()å‡½æ•°ã€‚ åŒ…ååœ¨æºæ–‡ä»¶ä¸­ç¬¬ä¸€è¡Œé€šè¿‡å…³é”®å­—packageæŒ‡å®šï¼ŒåŒ…åè¦å°å†™ã€‚ 1 package fmt æ¯ä¸ªç›®å½•ä¸‹é¢å¯ä»¥æœ‰å¤šä¸ª.goæ–‡ä»¶ï¼Œè¿™äº›æ–‡ä»¶åªèƒ½å±äºåŒä¸€ä¸ªåŒ…ï¼Œå¦åˆ™ç¼–è¯‘æ—¶ä¼šæŠ¥é”™ã€‚ åŒä¸€ä¸ªåŒ…ä¸‹çš„ä¸åŒ.goæ–‡ä»¶ç›¸äº’ä¹‹é—´å¯ä»¥ç›´æ¥å¼•ç”¨å˜é‡å’Œå‡½æ•°ï¼Œæ‰€ä»¥è¿™äº›æ–‡ä»¶ä¸­å®šä¹‰çš„å…¨å±€å˜é‡å’Œå‡½æ•°ä¸èƒ½é‡åã€‚ Goè¯­è¨€çš„å¯æ‰§è¡Œåº”ç”¨ç¨‹åºå¿…é¡»æœ‰mainåŒ…ï¼Œè€Œä¸”åœ¨mainåŒ…ä¸­å¿…é¡»ä¸”åªèƒ½æœ‰ä¸€ä¸ªmain()å‡½æ•°ã€‚ mainå‡½æ•°æ˜¯åº”ç”¨ç¨‹åºè¿è¡Œå¼€å§‹çš„å…¥å£ï¼Œåœ¨mainåŒ…ä¸­å¯ä»¥ä½¿ç”¨init()å‡½æ•°ã€‚ Goè¯­è¨€ä¸å¼ºåˆ¶è¦æ±‚åŒ…çš„åç§°å’Œæ–‡ä»¶æ‰€åœ¨ç›®å½•åç§°ç›¸åŒï¼Œä½†æ˜¯è¿™ä¸¤è€…æœ€å¥½ä¿æŒç›¸åŒï¼Œå¦åˆ™å¾ˆå®¹æ˜“å¼•èµ·æ­§ä¹‰ã€‚ å› ä¸ºå¯¼å…¥åŒ…çš„æ—¶å€™ä¼šä½¿ç”¨ç›®å½•åä½œä¸ºåŒ…çš„è·¯å¾„ï¼Œè€Œä»£ç ä¸­ä½¿ç”¨æ—¶ï¼Œå´è¦ä½¿ç”¨åŒ…çš„åç§°ã€‚ åŒ…çš„åˆå§‹åŒ– å¯æ‰§è¡Œåº”ç”¨ç¨‹åºçš„åˆå§‹åŒ–å’Œæ‰§è¡Œéƒ½èµ·å§‹äºmainåŒ…ã€‚ å¦‚æœmainåŒ…çš„æºä»£ç ä¸­æ²¡æœ‰åŒ…å«main()å‡½æ•°ï¼Œåˆ™ä¼šå¼•å‘æ„å»ºç¨‹åºé”™è¯¯ undefined: main.mianã€‚ main()å‡½æ•°å³æ²¡æœ‰å‚æ•°ï¼Œä¹Ÿæ²¡æœ‰è¿”å›ç±»å‹ï¼Œinit()å‡½æ•°å’Œmain()å‡½æ•°åœ¨è¿™ä¸€ç‚¹ä¸Šä¸€æ ·ã€‚ å¦‚æœmainåŒ…è¿˜å¯¼å…¥äº†å…¶ä»–çš„åŒ…ï¼Œé‚£ä¹ˆåœ¨ç¼–è¯‘æ—¶ä¼šå°†å®ƒä»¬ä¾æ¬¡å¯¼å…¥ã€‚ æœ‰æ—¶ä¸€ä¸ªåŒ…ä¼šè¢«å¤šä¸ªåŒ…åŒæ—¶å¯¼å…¥ï¼Œé‚£ä¹ˆå®ƒåªä¼šè¢«å¯¼å…¥ä¸€æ¬¡ï¼ˆå¦‚å¾ˆå¤šåŒ…å¯èƒ½éƒ½ä¼šç”¨åˆ°fmtåŒ…ï¼Œä½†å®ƒåªä¼šè¢«å¯¼å…¥ä¸€æ¬¡ï¼Œå› ä¸ºæ²¡æœ‰å¿…è¦å¯¼å…¥å¤šæ¬¡ï¼‰ å½“æ‰€æœ‰è¢«å¯¼å…¥çš„åŒ…éƒ½åŠ è½½å®Œæ¯• å°±ä¼šå¯¹mainåŒ…ä¸­çš„åŒ…çº§å¸¸é‡å’Œå˜é‡è¿›è¡Œåˆå§‹åŒ– ç„¶åæ‰§è¡ŒmainåŒ…ä¸­çš„init()å‡½æ•°ï¼Œæœ€åæ‰§è¡Œmain()å‡½æ•° å¯¼å…¥åŒ…çš„é¡ºåºï¼šå¯¼å…¥åŒ…æ–‡ä»¶ï¼Œå¯¹(å…¨å±€)å¸¸é‡å’Œå˜é‡è¿›è¡Œåˆå§‹åŒ–ï¼Œç„¶åæ‰§è¡Œinit()å‡½æ•°ï¼ˆå¦‚æœå‡½æ•°å­˜åœ¨çš„æƒ…å†µä¸‹ï¼‰ Goè¯­è¨€ä¸­çš„init()å‡½æ•°å¸¸ç”¨äºåŒ…çš„åˆå§‹åŒ–ï¼Œè¯¥å‡½æ•°æ˜¯Goè¯­è¨€çš„ä¸€ä¸ªé‡è¦ç‰¹å¾ã€‚ initå‡½æ•°æ˜¯ç”¨äºç¨‹åºæ‰§è¡Œå‰è¿›è¡ŒåŒ…çš„åˆå§‹åŒ–çš„å‡½æ•°ï¼Œä¾‹å¦‚åˆå§‹åŒ–åŒ…é‡Œçš„å˜é‡ç­‰ã€‚ æ¯ä¸ªåŒ…å¯ä»¥æ‹¥æœ‰å¤šä¸ªinitå‡½æ•°ï¼Œï¼ˆåŒä¸€ä¸ªåŒ…ä¸‹ä¸åŒçš„.goæ–‡ä»¶ä¸­éƒ½å…è®¸å®šä¹‰init()å‡½æ•°ï¼‰ã€‚ åŒä¸€ä¸ªåŒ…ä¸­çš„å¤šä¸ªinit()å‡½æ•°çš„æ‰§è¡Œé¡ºåºæ˜¯éšæœºçš„ã€‚ ä¸åŒåŒ…çš„init()å‡½æ•°æŒ‰ç…§åŒ…å¯¼å…¥çš„ä¾èµ–å…³ç³»å†³å®šè¯¥å‡½æ•°çš„æ‰§è¡Œé¡ºåºã€‚ init()å‡½æ•°ä¸èƒ½è¢«å…¶ä»–å‡½æ•°è°ƒç”¨ï¼Œå…¶åœ¨mainå‡½æ•°æ‰§è¡Œä¹‹å‰ï¼Œè‡ªåŠ¨è¢«è°ƒç”¨ã€‚ åŒ…çš„å¯¼å…¥ Goè¯­è¨€ç¨‹åºé€šè¿‡å¯¼å…¥importå…³é”®å­—å°†ä¸€ç»„åŒ…é“¾æ¥åœ¨ä¸€èµ·é€šè¿‡å¯¼å…¥åŒ…ä¸ºç¨‹åºæ‰€ä½¿ç”¨ï¼Œç¨‹åºä¸­æœªä½¿ç”¨çš„åŒ…ï¼Œä¸èƒ½å¯¼å…¥è¿›æ¥ã€‚ å¯¼å…¥æ“ä½œä¼šä½¿ç”¨ç›®å½•åä½œä¸ºåŒ…çš„è·¯å¾„è€Œä¸æ˜¯åŒ…åï¼Œå®é™…åº”ç”¨ä¸­ä¸€èˆ¬ä¼šä¿æŒä¸¤è€…ä¸€è‡´ã€‚ ä¾‹å¦‚æ ‡å‡†åŒ…ä¸­å®šä¹‰çš„bigåŒ…ï¼špackage big;å¯¼å…¥æ—¶è¯­å¥ä¸ºimport \u0026quot;math/big\u0026quot;ã€‚ å¯¼å…¥æ—¶æºä»£ç åœ¨$GOROOTç›®å½•ä¸‹çš„src/math/bigç›®å½•ä¸­ã€‚ ç¨‹åºä»£ç ä½¿ç”¨big.Intæ—¶ï¼ŒbigæŒ‡çš„æ˜¯.goæ–‡ä»¶ä¸­å®šä¹‰çš„åŒ…åç§°ã€‚ å½“å¯¼å…¥å¤šä¸ªåŒ…æ—¶ï¼Œä¸€èˆ¬æŒ‰ç…§å­—æ¯é¡ºåºæ’åˆ—åŒ…åç§°ã€‚ ä¸ºé¿å…åç§°å†²çªï¼ŒåŒä¸€åŒ…ä¸­æ‰€æœ‰å¯¹è±¡çš„æ ‡è¯†ç¬¦å¿…é¡»å”¯ä¸€ï¼Œä½†æ˜¯ç›¸åŒçš„æ ‡è¯†ç¬¦å¯ä»¥åœ¨ä¸åŒçš„åŒ…ä¸­ä½¿ç”¨ï¼Œå› ä¸ºå¯ä»¥ä½¿ç”¨åŒ…åæ¥åŒºåˆ†å®ƒä»¬ã€‚ 1 2 3 package main import \u0026#34;context\u0026#34; // åŠ è½½contextåŒ… å¯¼å…¥å¤šä¸ªåŒ…çš„å¸¸è§çš„æ–¹å¼ã€‚ 1 2 3 4 import ( \u0026#34;fmt\u0026#34; \u0026#34;net/http\u0026#34; ) 1 2 // è°ƒç”¨å¯¼å…¥çš„åŒ…å‡½æ•°çš„ä¸€èˆ¬æ–¹å¼ fmt.Println(\u0026#34;hello world!\u0026#34;) ä¸‰ç§ç‰¹æ®Šçš„åŒ…å¯¼å…¥ import (. \u0026quot;fmt\u0026quot;) ç‚¹æ“ä½œå«ä¹‰æ˜¯åŒ…å¯¼å…¥ä¹‹åï¼Œåœ¨è°ƒç”¨è¿™ä¸ªåŒ…çš„å‡½æ•°æ—¶ï¼Œå¯ä»¥çœç•¥å‰ç¼€çš„åŒ…åã€‚ å¦‚fmt.Println(\u0026quot;hello world\u0026quot;)å¯ä»¥å†™æˆPrintln(\u0026quot;hello world\u0026quot;)ã€‚ import (f \u0026quot;fmt\u0026quot;) åˆ«åæ“ä½œå°±æ˜¯å¯ä»¥æŠŠåŒ…å‘½åæˆå¦å¤–ä¸€ä¸ªå®¹æ˜“è®°ä½çš„åå­—ã€‚ å¦‚fmt.Println(\u0026quot;hello world\u0026quot;)å¯ä»¥å†™æˆf.Println(\u0026quot;hello world\u0026quot;)ã€‚ import (_ \u0026quot;fmt\u0026quot;) _æ“ä½œæ˜¯å¼•å…¥æŸä¸ªåŒ…ï¼Œä½†ä¸ç›´æ¥ä½¿ç”¨åŒ…é‡Œçš„å‡½æ•°ï¼Œè€Œæ˜¯è°ƒç”¨è¯¥åŒ…é‡Œé¢çš„initå‡½æ•°ã€‚ æœ‰æ—¶åœ¨å¼€å‘ä¸­ç”±äºæŸç§åŸå› æŸä¸ªåŸæ¥å¯¼å…¥çš„åŒ…ç°åœ¨ä¸åœ¨ä½¿ç”¨ï¼Œä¹Ÿå¯ä»¥é‡‡ç”¨è¿™ç§æ–¹å¼å¤„ç†ã€‚ 1 2 3 4 import ( _ \u0026#34;fmt\u0026#34; _ \u0026#34;github.com/go-sql-driver/mysql\u0026#34; ) æ ‡å‡†åº“ åœ¨Goè¯­è¨€çš„å®‰è£…ç›®å½•é‡ŒåŒ…å«æ ‡å‡†åº“çš„å„ç§åŒ…ï¼Œåœ¨$GOROOT/srcä¸­å¯ä»¥çœ‹åˆ°æºç ï¼Œå¯ä»¥æ ¹æ®æƒ…å†µè‡ªè¡Œé‡æ–°ç¼–è¯‘ã€‚ è®¿é—®https://golang.google.cn/pkg/#stdlibäº†è§£æ›´å¤šè¯¦æƒ…ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 unsafe: åŒ…å«äº†ä¸€äº›æ‰“ç ´Gpè¯­è¨€â€œç±»å‹å®‰å…¨â€çš„å‘½ä»¤ï¼Œä¸€è¾¹çš„ç¨‹åºä¸­ä¸ä¼šè¢«è°ƒç”¨ï¼Œå¯ç”¨åœ¨C++ç¨‹åºçš„è°ƒè¯•ä¸­ syscall-os-os/exec: os: æä¾›ç»™æˆ‘ä»¬ä¸€ä¸ªå¹³å°æ— å…³æ€§çš„æ“ä½œç³»ç»ŸåŠŸèƒ½æ¥å£ï¼Œé‡‡ç”¨ç±»ä¼¼UNIXè®¾è®¡ï¼Œéšè—äº†ä¸åŒæ“ä½œç³»ç»Ÿé—´çš„å·®å¼‚ï¼Œè®©ä¸åŒçš„æ–‡ä»¶ç³»ç»Ÿå’Œæ“ä½œç³»ç»Ÿå¯¹è±¡è¡¨ç°ä¸€è‡´ os/exec: æä¾›è¿è¡Œå¤–éƒ¨æ“ä½œç³»ç»Ÿå‘½ä»¤å’Œç¨‹åºæ–¹å¼ syscall: åº•å±‚çš„å¤–éƒ¨åŒ…ï¼Œæä¾›äº†æ“ä½œç³»ç»Ÿåº•å±‚è°ƒç”¨çš„åŸºæœ¬æ¥å£ archive/tar å’Œ /zip-compress: å‹ç¼©(è§£å‹ç¼©)æ–‡ä»¶åŠŸèƒ½ fmt-io-bufio-path/filepath-flag: fmt: æä¾›æ ¼å¼åŒ–è¾“å…¥è¾“å‡ºçš„åŠŸèƒ½ io: æä¾›åŸºæœ¬è¾“å…¥è¾“å‡ºåŠŸèƒ½ï¼Œå¤§å¤šæ•°æ˜¯å›´ç»•ç³»ç»ŸåŠŸèƒ½çš„å°è£… bufio: ç¼“å†²è¾“å…¥è¾“å‡ºåŠŸèƒ½çš„å°è£… path/filepath: ç”¨æ¥æ“ä½œåœ¨å½“å‰ç³»ç»Ÿä¸­çš„ç›®æ ‡æ–‡ä»¶åè·¯å¾„ flag: å¯¹å‘½ä»¤è¡Œå‚æ•°çš„æ“ä½œ strings-strconv-unicode-regexp-bytes: strings: æä¾›å¯¹å­—ç¬¦çš„æ“ä½œ strconv: æä¾›å°†å­—ç¬¦ä¸²è½¬æ¢ä¸ºåŸºç¡€ç±»å‹çš„åŠŸèƒ½ unicode: ä¸ºunicodeå‹çš„å­—ç¬¦ä¸²æä¾›ç‰¹æ®Šçš„åŠŸèƒ½ regexp: æ­£åˆ™è¡¨è¾¾å¼åŠŸèƒ½ bytes: æä¾›å¯¹å­—ç¬¦å‹åˆ†ç‰‡çš„æ“ä½œ math-math/cmath-math/big-math/rand-sort: math: åŸºæœ¬çš„æ•°å­¦å‡½æ•° math/cmath: å¯¹å¤æ•°çš„æ“ä½œ math/rand: ä¼ªéšæœºæ•°ç”Ÿæˆ sort: ä¸ºæ•°ç»„æ’åºå’Œè‡ªå®šä¹‰é›†åˆ math/big: å¤§æ•°çš„å®ç°å’Œè®¡ç®— container-/list-ring-heap: å®ç°å¯¹é›†åˆçš„æ“ä½œ list: åŒé“¾è¡¨ ring: ç¯å½¢é“¾è¡¨ time-log: time: æ—¥æœŸå’Œæ—¶é—´çš„åŸºæœ¬æ“ä½œ log: è®°å½•ç¨‹åºè¿è¡Œæ—¶äº§ç”Ÿçš„æ—¥å¿— encoding/JSON-encoding/xml-text/template: encoding/json: è¯»å–å¹¶è§£ç å’Œå†™å…¥å¹¶ç¼–ç jsonæ•°æ® encoding/xml: ç®€å•çš„XML1.0è§£æå™¨ text/template: ç”ŸæˆåƒHTMLä¸€æ ·çš„æ•°æ®ä¸æ–‡æœ¬æ··åˆçš„æ•°æ®é©±åŠ¨æ¨¡æ¿ net-net/http-html: net: ç½‘ç»œæ•°æ®çš„åŸºæœ¬æ“ä½œ http: æä¾›äº†ä¸€ä¸ªå¯æ‰©å±•çš„HTTPæœåŠ¡å™¨å’Œå®¢æˆ·ç«¯ï¼Œè§£æHTTPè¯·æ±‚å’Œå›å¤ html: HTML5è§£æå™¨ runtime: Goç¨‹åºè¿è¡Œæ—¶çš„äº¤äº’æ“ä½œï¼Œä¾‹å¦‚åƒåœ¾å›æ”¶å’Œåç¨‹åˆ›å»º reflect: å®ç°é€šè¿‡ç¨‹åºè¿è¡Œæ—¶åå°„ï¼Œè®©ç¨‹åºæ“ä½œä»»æ„ç±»å‹çš„å˜é‡ ä»githubå®‰è£…åŒ… å¦‚æœæƒ³å®‰è£…githubä¸Šçš„é¡¹ç›®åˆ°æœ¬åœ°è®¡ç®—æœºï¼Œå¯æ‰“å¼€ç»ˆç«¯æ‰§è¡Œï¼šgo get -u github.com/ffhelicopter/tmmã€‚ ç°åœ¨è¿™å°è®¡ç®—æœºä¸Šçš„å…¶ä»–Goå¼•ç”¨ç¨‹åºä¹Ÿå¯ä»¥é€šè¿‡å¯¼å…¥è·¯å¾„github.com/ffhelicopter/tmmæ¥ä½¿ç”¨ã€‚ import \u0026quot;github.com/ffhelicopter/tmm\u0026quot; Goå¯¹åŒ…çš„ç‰ˆæœ¬ç®¡ç†ä¸æ˜¯å¾ˆå‹å¥½ï¼Œè‡³å°‘åœ¨go1.10å‰æ˜¯å¦‚æ­¤ï¼Œä¸è¿‡ç°åœ¨ç¬¬ä¸‰æ–¹é¡¹ç›®åšå¾—ä¸é”™. æœ‰å…´è¶£çš„è¯»è€…å¯ä»¥äº†è§£ä¸€ä¸‹ï¼ˆglideã€godepã€govendorï¼‰. Gomodulesæ˜¯1.11ç‰ˆæœ¬è§£å†³â€œåŒ…ä¾èµ–ç®¡ç†â€çš„å®éªŒæ€§æŠ€æœ¯æ–¹æ¡ˆï¼Œåé¢ç« èŠ‚å­¦ä¹ ã€‚ å¯¼å…¥å¤–éƒ¨å®‰è£…åŒ… å¦‚æœè¦åœ¨åº”ç”¨ä¸­ä½¿ç”¨ä¸€ä¸ªæˆ–å¤šä¸ªå¤–éƒ¨åŒ…ï¼Œå¯ä»¥ä½¿ç”¨go installåœ¨æœ¬åœ°è®¡ç®—æœºä¸Šå®‰è£…å®ƒä»¬ã€‚ go installæ˜¯è‡ªåŠ¨åŒ…å®‰è£…å·¥å…·ï¼Œå¦‚éœ€è¦å°†åŒ…å®‰è£…åˆ°æœ¬åœ°ï¼Œå®ƒä¼šä»è¿œç«¯ä»“åº“ä¸‹è½½åŒ…ï¼Œå®Œæˆæ£€å‡ºã€ç¼–è¯‘å’Œå®‰è£…ã€‚ åŒ…å®‰è£…çš„å…ˆå†³æ¡ä»¶æ˜¯è¦è‡ªåŠ¨å¤„ç†åŒ…è‡ªèº«ä¾èµ–å…³ç³»ï¼Œè¢«ä¾èµ–çš„åŒ…ä¹Ÿä¼šå®‰è£…åˆ°å­ç›®å½•ä¸‹ã€‚ å¦‚æœæƒ³ä½¿ç”¨https://github.com/gocolly/collyè¿™ç§æ‰˜ç®¡åœ¨Google Codeã€GitHubå’ŒLaunchpadç­‰ä»£ç ç½‘ç«™ä¸Šçš„åŒ…ã€‚ ä¹Ÿå¯ä»¥é€šè¿‡å¦‚ä¸‹å‘½ä»¤å®‰è£…ï¼šgo install github.com/gocolly/collyã€‚ å°†ä¸€ä¸ªåä¸ºgithub.com/gocolly/collyçš„åŒ…å®‰è£…åœ¨$GoPATH/pkg/ç›®å½•ä¸‹ã€‚ go install/buildç”¨æ¥ç¼–è¯‘åŒ…å’Œä¾èµ–çš„åŒ…ï¼ŒåŒºåˆ«å¦‚ä¸‹ï¼š go buildåªå¯¹mainåŒ…æœ‰æ•ˆï¼Œåœ¨å½“å‰ç›®å½•ç¼–è¯‘ç”Ÿæˆä¸€ä¸ªå¯æ‰§è¡Œçš„äºŒè¿›åˆ¶æ–‡ä»¶ï¼Œä¾èµ–åŒ…ç”Ÿæˆçš„é™æ€åº“æ–‡ä»¶æ”¾åœ¨$GOOATH/pkgã€‚ go installä¸€èˆ¬ç”Ÿæˆé™æ€æ–‡ä»¶ï¼Œæ”¾åœ¨$GOPATH/pkgç›®å½•ä¸‹ï¼Œæ–‡ä»¶æ‰©å±•åä¸ºaã€‚ å¦‚æœä¸ºmainåŒ…ï¼Œè¿è¡Œgo buildåˆ™ä¼šåœ¨$GOPATH/binç”Ÿæˆä¸€ä¸ªå¯æ‰§è¡Œçš„äºŒè¿›åˆ¶æ–‡ä»¶ã€‚ ä½¿ç”¨Godoc åœ¨ç¨‹åºä¸­ä¸€èˆ¬éƒ½ä¼šä½¿ç”¨æ³¨é‡Šï¼ŒæŒ‰ç…§ä¸€å®šè§„åˆ™ï¼ŒGodocå·¥å…·ä¼šæ”¶é›†è¿™äº›æ³¨é‡Šå¹¶äº§ç”Ÿä¸€ä¸ªæŠ€æœ¯æ–‡æ¡£ã€‚ Godocä¼šä¸ºæ¯ä¸ªæ–‡ä»¶ç”Ÿæˆä¸€ç³»åˆ—çš„ç½‘é¡µã€‚ è®¿é—®Godocæ–‡æ¡£çš„æ–¹æ³•æ˜¯ï¼š å‘½ä»¤è¡Œä¸‹è¿›å…¥ç›®å½•å¹¶è¾“å…¥å‘½ä»¤ï¼šgodoc -http=:6060 -goroot=\u0026quot;.\u0026quot;ã€‚ ç„¶ååœ¨æµè§ˆå™¨ä¸­æ‰“å¼€åœ°å€ï¼šhttp://localhost:6060ã€‚ æ­¤æ—¶ä¼šçœ‹åˆ°æœ¬åœ°çš„Godocé¡µé¢ï¼Œä»å·¦åˆ°å³ä¸€æ¬¡æ˜¾ç¤ºå‡ºç›®å½•ä¸­çš„åŒ…ã€‚ æˆ–è€…ç›´æ¥åœ¨æµè§ˆå™¨ä¸­æ‰“å¼€åœ°å€http://localhost:6060/pkg/go42/chapter-4/4.2/1/ã€‚ Goç¨‹åºçš„ç¼–è¯‘ åœ¨Goè¯­è¨€ä¸­ï¼Œå’Œç¼–è¯‘æœ‰å…³çš„å‘½ä»¤ä¸»è¦æ˜¯go runã€go buildã€go installè¿™ä¸‰ä¸ªå‘½ä»¤ã€‚ go runåªèƒ½ä½œç”¨äºmainåŒ…æ–‡ä»¶ã€‚ å…ˆè¿è¡Œcompileå‘½ä»¤ç”Ÿæˆ.aæ–‡ä»¶ã€‚ ç„¶åé“¾æ¥å‘½ä»¤ç”Ÿæˆæœ€ç»ˆå¯æ‰§è¡Œæ–‡ä»¶å¹¶è¿è¡Œç¨‹åºï¼Œæ­¤è¿‡ç¨‹ä¸­äº§ç”Ÿçš„æ˜¯ä¸´æ—¶æ–‡ä»¶ã€‚ åœ¨go runé€€å‡ºå‰ä¼šåˆ é™¤è¿™äº›ä¸´æ—¶æ–‡ä»¶ï¼ˆå«.aæ–‡ä»¶å’Œå¯æ‰§è¡Œæ–‡ä»¶ï¼‰ã€‚ æœ€åç›´æ¥åœ¨å‘½ä»¤è¡Œè¾“å‡ºç¨‹åºæ‰§è¡Œç»“æœã€‚ go runå‘½ä»¤åœ¨ç¬¬äºŒæ¬¡æ‰§è¡Œçš„æ—¶å€™ï¼Œå¦‚æœå‘ç°å¯¼å…¥çš„ä»£ç åŒ…æ²¡æœ‰å‘ç”Ÿå˜åŒ–ã€‚ åˆ™ä¸ä¼šå†æ¬¡ç¼–è¯‘è¿™ä¸ªå¯¼å…¥çš„ä»£ç åŒ…ï¼Œè€Œæ˜¯ç›´æ¥è¿›è¡Œé“¾æ¥ç”Ÿæˆæœ€ç»ˆå¯æ‰§è¡Œæ–‡ä»¶å¹¶è¿è¡Œç¨‹åºã€‚ go installç”¨äºç¼–è¯‘å¹¶å®‰è£…æŒ‡å®šçš„ä»£ç åŒ…åŠå®ƒä»¬çš„ä¾èµ–åŒ…ã€‚ å¹¶ä¸”å°†ç¼–è¯‘åç”Ÿæˆçš„å¯æ‰§è¡Œæ–‡ä»¶æ”¾åˆ°binç›®å½•ä¸‹ï¼ˆ$GOPATH/binï¼‰ã€‚ ç¼–è¯‘åçš„åŒ…æ–‡ä»¶æ”¾åˆ°å½“å‰å·¥ä½œåŒºçš„pkgçš„å¹³å°ç›¸å…³ç›®å½•ä¸‹ã€‚ go buildç”¨äºç¼–è¯‘æŒ‡å®šçš„ä»£ç åŒ…ä»¥åŠå®ƒä»¬çš„ä¾èµ–åŒ…ã€‚ å¦‚æœç”¨æ¥ç¼–è¯‘émainåŒ…çš„æºç ï¼Œåˆ™åªåšæ£€æŸ¥æ€§çš„ç¼–è¯‘ï¼Œè€Œä¸ä¼šè¾“å‡ºä»»ä½•ç»“æœæ–‡ä»¶ã€‚ å¦‚æœæ˜¯ä¸€ä¸ªå¯æ‰§è¡Œç¨‹åºçš„æºç ï¼ˆå³mainåŒ…ï¼‰ï¼Œè¿‡ç¨‹ä¸go runå¤§ä½“ç›¸åŒï¼Œåªæ˜¯ä¼šåœ¨å½“å‰ç›®å½•ç”Ÿæˆä¸€ä¸ªå¯æ‰§è¡Œæ–‡ä»¶ã€‚ ä½¿ç”¨go buildæ˜¯æœ‰ä¸€ä¸ªåœ°æ–¹æ³¨æ„ï¼š å¯¹å¤–å‘å¸ƒç¼–è¯‘æ–‡ä»¶æ—¶å¦‚æœä¸å¸Œæœ›è¢«äººçœ‹åˆ°æºä»£ç ï¼Œå¯ä½¿ç”¨go build -ldflagså‘½ä»¤ã€‚ è®¾ç½®å‚æ•°ã€-ldflags \u0026quot;-w -s\u0026quot;ã€‘å†ç¼–è¯‘å‘å¸ƒï¼Œè¿™æ ·ä½¿ç”¨gdbè°ƒè¯•æ—¶æ— æ³•çœ‹åˆ°æºä»£ç ã€‚ GO111MODULE Go 1.11æ–°å¢äº†å¯¹æ¨¡å—çš„æ”¯æŒï¼Œå¸Œæœ›å€Ÿæ­¤è§£å†³â€œåŒ…ä¾èµ–ç®¡ç†â€é—®é¢˜ã€‚ å¯ä»¥é€šè¿‡è®¾ç½®ç¯å¢ƒå˜é‡GO111MODULEæ¥å¼€å¯æˆ–å…³é—­æ¨¡å—æ”¯æŒï¼Œå®ƒæœ‰ä¸‰ä¸ªå¯é€‰å€¼ï¼šoffã€onã€autoï¼Œé»˜è®¤å€¼æ˜¯autoã€‚ GO111MODULE = off æ— æ¨¡å—æ”¯æŒï¼Œgoä¼šä»GOPATHå’Œvendoræ–‡ä»¶å¤¹å¯»æ‰¾åŒ…ã€‚ GO111MODEL = on æ¨¡å—æ”¯æŒï¼Œgoä¼šä»GOPATHå’Œvendoræ–‡ä»¶å¤¹ï¼Œå€¼æ ¹æ®go.modä¸‹è½½ä¾èµ–ã€‚ GO111MODEL = auto åœ¨$GOPATH/srcå¤–é¢ä¸”æ ¹ç›®å½•æœ‰go.modæ–‡ä»¶æ—¶ï¼Œå¼€å¯æ¨¡å—æ”¯æŒã€‚ ","permalink":"https://heliu.site/posts/golang/package/bag/","summary":"Golang åŒ…ä»‹ç»ã€‚","title":"package"},{"content":" ç”¨æ³•ï¼šgo mod \u0026lt;command\u0026gt; [arguments]ã€‚ commandæ”¯æŒå‘½ä»¤åˆ—è¡¨ï¼š å‘½ä»¤ go mod \u0026lt;command\u0026gt; ä½œç”¨ go mod init ç”Ÿæˆ go.mod æ–‡ä»¶ go mod download ä¸‹è½½ go.mod æ–‡ä»¶ä¸­æŒ‡æ˜çš„æ‰€æœ‰ä¾èµ– go mod tidy æ•´ç†ç°æœ‰çš„ä¾èµ– go mod graph æŸ¥çœ‹ç°æœ‰çš„ä¾èµ–ç»“æ„ go mod edit ç¼–è¾‘ go.mod æ–‡ä»¶ go mod vendor å¯¼å‡ºé¡¹ç›®æ‰€æœ‰çš„ä¾èµ–åˆ°vendorç›®å½• go mod verify æ ¡éªŒä¸€ä¸ªæ¨¡å—æ˜¯å¦è¢«ç¯¡æ”¹è¿‡ go mod why æŸ¥çœ‹ä¸ºä»€ä¹ˆéœ€è¦ä¾èµ–æŸæ¨¡å— go mod init ç”¨æ³•ï¼šgo mod init [module-path]ã€‚ ç¤ºä¾‹ï¼š # åˆå§‹åŒ–å½“å‰ç›®å½•å¹¶åˆ›å»ºä¸€ä¸ªgo.modæ–‡ä»¶ï¼Œæ¨¡å—è·¯å¾„æ ¹æ®å…¶ä»–æ¡ä»¶æ¨æ–­åˆ¤æ–­ $ go mod init # åˆå§‹åŒ–å½“å‰ç›®å½•å¹¶åˆ›å»ºä¸€ä¸ªgo.modæ–‡ä»¶ï¼Œæ¨¡å—è·¯å¾„ä¸ºexample.com/m $ go mod init example.com/m ä»‹ç»ï¼š go mod initå‘½ä»¤åœ¨å½“å‰ç›®å½•ä¸­åˆå§‹åŒ–å¹¶å†™å…¥ä¸€ä¸ªæ–°çš„go.modæ–‡ä»¶ï¼Œå®é™…ä¸Šåˆ›å»ºäº†ä¸€ä¸ªä»¥å½“å‰ç›®å½•ä¸ºæ ¹çš„æ–°æ¨¡å—ã€‚ go.modæ–‡ä»¶å¿…é¡»ä¸å­˜åœ¨æ—¶æ‰§è¡Œä¸Šé¢å‘½ä»¤ï¼Œå¦åˆ™ä¼šæç¤ºgo.modæ–‡ä»¶å·²å­˜åœ¨æç¤ºã€‚ å¦‚å½“å‰å­˜åœ¨ä¸€ä¸ªç©ºé¡¹ç›®demoï¼Œåœ¨demoç›®å½•ä¸‹æ‰§è¡Œgo mod init gitee.com/bms/demoï¼Œä¼šç”Ÿæˆå¦‚ä¸‹go.modæ–‡ä»¶ï¼Œå½“å‰goç‰ˆæœ¬æ˜¯go1.16.3ã€‚ module gitee.com/bms/demo go 1.16 initæ¥å—ä¸€ä¸ªå¯é€‰å‚æ•°ï¼Œå³æ–°æ¨¡å—çš„æ¨¡å—è·¯å¾„ï¼Œæœ‰å…³é€‰æ‹©æ¨¡å—è·¯å¾„çš„è¯´æ˜ï¼Œè¯·å‚é˜…æ¨¡å—è·¯å¾„ã€‚ å¦‚æœçœç•¥äº†æ¨¡å—è·¯å¾„å‚æ•°ï¼Œinitå°†å°è¯•ä½¿ç”¨.goæ–‡ä»¶ã€vendoringå·¥å…·é…ç½®æ–‡ä»¶å’Œå½“å‰ç›®å½•ï¼ˆå¦‚æœåœ¨GOPATHä¸­ï¼‰ä¸­çš„å¯¼å…¥æ³¨é‡Šæ¥æ¨æ–­æ¨¡å—è·¯å¾„ã€‚ å¦‚æœå­˜åœ¨vendoringå·¥å…·çš„é…ç½®æ–‡ä»¶ï¼Œinitå°†å°è¯•ä»ä¸­å¯¼å…¥æ¨¡å—éœ€æ±‚ã€‚ initæ”¯æŒä»¥ä¸‹é…ç½®æ–‡ä»¶ï¼š GLOCKFILE (Glock) Godeps/Godeps.json (Godeps) Gopkg.lock (dep) dependencies.tsv (godeps) glide.lock (glide) vendor.conf (trash) vendor.yml (govend) vendor/manifest (gvt) vendor/vendor.json (govendor) Vendoringå·¥å…·é…ç½®æ–‡ä»¶æ— æ³•å§‹ç»ˆä»¥å®Œç¾çš„ä¿çœŸåº¦è¿›è¡Œç¿»è¯‘ã€‚ ä¾‹å¦‚ï¼ŒåŒä¸€ä¸ªä»“åº“ä¸­çš„å¤šä¸ªåŒ…åœ¨ä¸åŒç‰ˆæœ¬ä¸­å¯¼å…¥ï¼Œè€Œä»“åº“ä¸­åªåŒ…å«ä¸€ä¸ªæ¨¡å—ï¼Œé‚£ä¹ˆå¯¼å…¥çš„go.modå°±åªèƒ½éœ€è¦ä¸€ä¸ªç‰ˆæœ¬çš„æ¨¡å—ã€‚ æ‚¨å¯èƒ½å¸Œæœ›è¿è¡Œgo list -m allä»¥æ£€æŸ¥æ„å»ºåˆ—è¡¨ä¸­çš„æ‰€æœ‰ç‰ˆæœ¬ï¼Œå¹¶è¿è¡Œgo mod tidyä»¥æ·»åŠ ç¼ºå°‘çš„éœ€æ±‚å¹¶åˆ é™¤æœªä½¿ç”¨çš„éœ€æ±‚ã€‚ go mod download å°†å‘½åçš„æ¨¡å—ä¸‹è½½åˆ°æ¨¡å—ç¼“å­˜ä¸­ï¼ˆæ¨¡å—ç¼“å­˜å‚è€ƒå®˜æ–¹æ¨¡å—å‚è€ƒæ–‡æ¡£ï¼‰ã€‚ å‚æ•°å¯ä»¥æ˜¯æ¨¡å—è·¯å¾„æˆ–æ¨¡å—æ¨¡å¼ï¼Œé€‰æ‹©ä¸»æ¨¡å—çš„ä¾èµ–é¡¹æˆ–è¡¨å•çš„ç‰ˆæœ¬æŸ¥è¯¢path@versionã€‚ ä¸å¸¦å‚æ•°ï¼Œdownloadé€‚ç”¨äºä¸»æ¨¡å—çš„æ‰€æœ‰ä¾èµ–é¡¹ã€‚ è¯¥goå‘½ä»¤å°†åœ¨æ­£å¸¸æ‰§è¡ŒæœŸé—´æ ¹æ®éœ€è¦è‡ªåŠ¨ä¸‹è½½æ¨¡å—ã€‚ go mod downloadå‘½ä»¤ä¸»è¦ç”¨äºé¢„å¡«å……æ¨¡å—ç¼“å­˜æˆ–åŠ è½½è¦ç”±æ¨¡å—ä»£ç†æœåŠ¡çš„æ•°æ®ã€‚ é»˜è®¤æƒ…å†µä¸‹ï¼Œdownloadä¸å‘æ ‡å‡†è¾“å‡ºå†™å…¥ä»»ä½•å†…å®¹ã€‚å®ƒå°†è¿›åº¦æ¶ˆæ¯å’Œé”™è¯¯æ‰“å°åˆ°æ ‡å‡†é”™è¯¯ã€‚ ç”¨æ³•ï¼šgo mod download [-json] [-x] [modules] -jsonï¼š -jsonï¼šdownloadå°†ä¸€ç³»åˆ—JSONå¯¹è±¡æ‰“å°åˆ°æ ‡å‡†è¾“å‡ºï¼Œæè¿°æ¯ä¸ªä¸‹è½½çš„æ¨¡å—ï¼ˆæˆ–å¤±è´¥ï¼‰ å¯¹åº”å¦‚ä¸‹ç»“æ„ï¼š type Module struct { Path string // æ¨¡å—è·¯å¾„ Version string // æ¨¡å—ç‰ˆæœ¬ Error string // é”™è¯¯æ¨¡æ¿æè¿° Info string // ç¼“å­˜çš„ .info æ–‡ä»¶çš„ç»å¯¹è·¯å¾„ GoMod string // ç¼“å­˜ .mod æ–‡ä»¶çš„ç»å¯¹è·¯å¾„ Zip string // ç¼“å­˜çš„ .zip æ–‡ä»¶çš„ç»å¯¹è·¯å¾„ Dir string // ç¼“å­˜æºæ ¹ç›®å½•çš„ç»å¯¹è·¯å¾„ Sum string // checksumè·¯å¾„ï¼Œç‰ˆæœ¬ï¼ˆæ¯”å¦‚åœ¨go.sumï¼‰ GoModSum string // go.modçš„checksumï¼ˆæ¯”å¦‚åœ¨go.sumï¼‰ -xï¼šdownloadæ‰“å°å‘½ä»¤downloadæ‰§è¡Œåˆ°æ ‡å‡†é”™è¯¯ ç¤ºä¾‹ï¼š $ go mod download -json -x gitee.com/phpbms/demo { \u0026#34;Path\u0026#34;: \u0026#34;gitee.com/phpbms/demo\u0026#34;, \u0026#34;Version\u0026#34;: \u0026#34;v0.0.0-20211021090521-71a745ffbccb\u0026#34;, \u0026#34;Info\u0026#34;: \u0026#34;/mnt/g/Go/worker/pkg/mod/cache/download/gitee.com/phpbms/demo/@v/v0.0.0-20211021090521-71a745ffbccb.info\u0026#34;, \u0026#34;GoMod\u0026#34;: \u0026#34;/mnt/g/Go/worker/pkg/mod/cache/download/gitee.com/phpbms/demo/@v/v0.0.0-20211021090521-71a745ffbccb.mod\u0026#34;, \u0026#34;Zip\u0026#34;: \u0026#34;/mnt/g/Go/worker/pkg/mod/cache/download/gitee.com/phpbms/demo/@v/v0.0.0-20211021090521-71a745ffbccb.zip\u0026#34;, \u0026#34;Dir\u0026#34;: \u0026#34;/mnt/g/Go/worker/pkg/mod/gitee.com/phpbms/demo@v0.0.0-20211021090521-71a745ffbccb\u0026#34;, \u0026#34;Sum\u0026#34;: \u0026#34;h1:JJlXgKY8MUQtOlnSHtbIsHtRU9DNbxx9NUgpsDt3pQA=\u0026#34;, \u0026#34;GoModSum\u0026#34;: \u0026#34;h1:6H8vzSoXg8Ey2gdfFaP7ToLmbOnfc04IAcuTFDKqSV8=\u0026#34; } go mod tidy go mod tidyç¡®ä¿go.modæ–‡ä»¶ä¸æ¨¡å—ä¸­çš„æºä»£ç åŒ¹é…ã€‚ å®ƒæ·»åŠ äº†æ„å»ºå½“å‰æ¨¡å—çš„åŒ…å’Œä¾èµ–é¡¹æ‰€éœ€çš„ä»»ä½•ç¼ºå¤±çš„æ¨¡å—è¦æ±‚ï¼Œå¹¶åˆ é™¤äº†å¯¹ä¸æä¾›ä»»ä½•ç›¸å…³åŒ…çš„æ¨¡å—çš„è¦æ±‚ã€‚ å®ƒè¿˜å‘go.sumæ·»åŠ ä»»ä½•ç¼ºå¤±çš„æ¡ç›®å¹¶åˆ é™¤ä¸å¿…è¦çš„æ¡ç›®ã€‚ go mod tidyé€šè¿‡é€’å½’åŠ è½½ä¸»æ¨¡å—ä¸­çš„æ‰€æœ‰åŒ…ä»¥åŠå®ƒä»¬å¯¼å…¥çš„æ‰€æœ‰åŒ…æ¥å·¥ä½œï¼Œè¿™åŒ…æ‹¬æµ‹è¯•å¯¼å…¥çš„åŒ…ï¼ˆåŒ…æ‹¬å…¶ä»–æ¨¡å—ä¸­çš„æµ‹è¯•ï¼‰ã€‚ go mod tidyå°±åƒå¯ç”¨äº†æ‰€æœ‰æ„å»ºæ ‡è®°ä¸€æ ·ï¼Œå› æ­¤å®ƒä¼šè€ƒè™‘ç‰¹å®šäºå¹³å°çš„æºæ–‡ä»¶å’Œéœ€è¦è‡ªå®šä¹‰æ„å»ºæ ‡è®°çš„æ–‡ä»¶ï¼Œå³ä½¿è¿™äº›æºæ–‡ä»¶é€šå¸¸ä¸ä¼šè¢«æ„å»ºã€‚ æœ‰ä¸€ä¸ªä¾‹å¤–ï¼šå¿½ç•¥æ„å»ºæ ‡è®°æœªå¯ç”¨ï¼Œå› æ­¤ä¸ä¼šè€ƒè™‘å…·æœ‰æ„å»ºçº¦æŸã€// +build ignoreã€‘çš„æ–‡ä»¶ã€‚ è¯·æ³¨æ„ï¼Œgo mod tidyä¸ä¼šè€ƒè™‘ä¸»æ¨¡å—ä¸­åä¸ºtestdataæˆ–åç§°ä»¥.æˆ–_é™¤éè¿™äº›åŒ…æ˜¯ç”±å…¶ä»–åŒ…æ˜¾å¼å¯¼å…¥çš„ã€‚ ä¸€æ—¦go mod tidyåŠ è½½äº†è¿™ç»„åŒ…ï¼Œå®ƒä¼šç¡®ä¿æä¾›ä¸€ä¸ªæˆ–å¤šä¸ªåŒ…çš„æ¯ä¸ªæ¨¡å—åœ¨ä¸»æ¨¡å—çš„go.modæ–‡ä»¶ä¸­éƒ½æœ‰ä¸€ä¸ªrequireæŒ‡ä»¤ï¼Œæˆ–è€…å¦‚æœä¸»æ¨¡å—åœ¨go 1.16æˆ–æ›´ä½ç‰ˆæœ¬ - æ˜¯å¿…éœ€çš„å¦ä¸€ä¸ªå¿…éœ€çš„æ¨¡å—ã€‚ go mod tidyå°†æ·»åŠ å¯¹æ¯ä¸ªç¼ºå¤±æ¨¡å—çš„æœ€æ–°ç‰ˆæœ¬çš„è¦æ±‚ï¼ˆæœ‰å…³æœ€æ–°ç‰ˆæœ¬çš„å®šä¹‰ï¼Œè¯·å‚é˜…ç‰ˆæœ¬æŸ¥è¯¢ï¼‰ï¼Œgo mod tidyå°†åˆ é™¤ä¸æä¾›ä¸Šè¿°é›†åˆä¸­ä»»ä½•åŒ…çš„æ¨¡å—çš„requireæŒ‡ä»¤ã€‚ go mod tidyè¿˜å¯ä»¥æ·»åŠ æˆ–åˆ é™¤require æŒ‡ä»¤çš„// indirectï¼Œ// indirecté—´æ¥æ³¨é‡Šè¡¨ç¤ºæ¨¡å—ä¸æä¾›ç”±ä¸»æ¨¡å—ä¸­çš„åŒ…å¯¼å…¥çš„åŒ…ã€‚ ç”¨æ³•ï¼šgo mod tidy [-e] [-v] [-go=version] [-compat=version]ã€‚ ä»‹ç»ï¼š -eï¼š(åœ¨Go 1.16ä¸­æ·»åŠ )åœ¨åŠ è½½åŒ…æ—¶é‡åˆ°é”™è¯¯æ—¶å°è¯•ç»§ç»­ã€‚ -vï¼šå°†æœ‰å…³å·²åˆ é™¤æ¨¡å—çš„ä¿¡æ¯æ‰“å°åˆ°æ ‡å‡†é”™è¯¯ã€‚ -go=ï¼šå°†goæŒ‡ä»¤æ›´æ–°ä¸ºæŒ‡å®šçš„ç‰ˆæœ¬ï¼Œæ ¹æ®è¯¥ç‰ˆæœ¬å¯ç”¨æˆ–ç¦ç”¨æ¨¡å—å›¾ä¿®å‰ªå’Œå»¶è¿Ÿæ¨¡å—åŠ è½½ï¼ˆå¹¶æ ¹æ®éœ€è¦æ·»åŠ æˆ–åˆ é™¤// indirecté—´æ¥æ³¨é‡Šï¼‰ã€‚ -compat=ï¼šå½“æ¨¡å—å›¾ç”±goæŒ‡ä»¤ä¸­æŒ‡ç¤ºçš„ç‰ˆæœ¬ä¹‹å‰çš„Goç‰ˆæœ¬åŠ è½½æ—¶ï¼Œgo mod tidyå°†æ£€æŸ¥æ‰€é€‰ç‰ˆæœ¬çš„æ¨¡å—æ˜¯å¦ä¸ä¼šæ›´æ”¹ã€‚è¿˜å¯ä»¥é€šè¿‡-compatæ ‡å¿—æ˜¾å¼æŒ‡å®šç‰ˆæœ¬æ£€æŸ¥çš„å…¼å®¹æ€§ã€‚ go mod graph ä»¥æ–‡æœ¬å½¢å¼æ‰“å°æ¨¡å—éœ€æ±‚å›¾ã€‚ ç”¨æ³•ï¼šgo mod graph [-go=version]ã€‚ ä»‹ç»ï¼š æ¨¡å—å›¾ä¸­çš„æ¯ä¸ªé¡¶ç‚¹ä»£è¡¨ä¸€ä¸ªæ¨¡å—çš„ç‰¹å®šç‰ˆæœ¬ï¼Œå›¾ä¸­çš„æ¯æ¡è¾¹ä»£è¡¨å¯¹ä¾èµ–é¡¹çš„æœ€ä½ç‰ˆæœ¬çš„è¦æ±‚ã€‚ go mod graphæ‰“å°å›¾å½¢çš„è¾¹ç¼˜ï¼Œæ¯è¡Œä¸€ä¸ªã€‚ æ¯è¡Œæœ‰ä¸¤ä¸ªç©ºæ ¼åˆ†éš”çš„å­—æ®µï¼šæ¨¡å—ç‰ˆæœ¬åŠå…¶ä¾èµ–é¡¹ä¹‹ä¸€ã€‚ æ¯ä¸ªæ¨¡å—ç‰ˆæœ¬éƒ½æ ‡è¯†ä¸ºpath@versionå½¢å¼çš„å­—ç¬¦ä¸²ã€‚ ä¸»æ¨¡å—æ²¡æœ‰@versionåç¼€ï¼Œå› ä¸ºå®ƒæ²¡æœ‰ç‰ˆæœ¬ã€‚ -go=ï¼šgo mod graphæŠ¥å‘Šç»™å®šGoç‰ˆæœ¬åŠ è½½çš„æ¨¡å—å›¾ï¼Œè€Œä¸æ˜¯go.modæ–‡ä»¶ä¸­çš„goæŒ‡ä»¤æŒ‡ç¤ºçš„ç‰ˆæœ¬ã€‚ æœ‰å…³å¦‚ä½•é€‰æ‹©ç‰ˆæœ¬çš„æ›´å¤šä¿¡æ¯ï¼Œè¯·å‚é˜…æœ€å°ç‰ˆæœ¬é€‰æ‹©(MVS)ã€‚ å¦è¯·å‚é˜…go list -mä»¥æ‰“å°é€‰å®šçš„ç‰ˆæœ¬ï¼Œå¹¶æŸ¥çœ‹go mod whyä»¥äº†è§£ä¸ºä»€ä¹ˆéœ€è¦æ¨¡å—ã€‚ example.com/main example.com/a@v1.1.0 example.com/main example.com/b@v1.2.0 example.com/a@v1.1.0 example.com/b@v1.1.1 example.com/a@v1.1.0 example.com/c@v1.3.0 example.com/b@v1.1.0 example.com/c@v1.1.0 example.com/b@v1.2.0 example.com/c@v1.2.0 go mod edit è¯¥å‘½ä»¤æä¾›äº†ä¸€ä¸ªç”¨äºç¼–è¾‘å’Œæ ¼å¼åŒ–go.modæ–‡ä»¶çš„å‘½ä»¤è¡Œç•Œé¢ï¼Œä¸»è¦ä¾›å·¥å…·å’Œè„šæœ¬ä½¿ç”¨ã€‚ go mod editåªè¯»å–ä¸€ä¸ªgo.modæ–‡ä»¶ï¼Œå®ƒä¸æŸ¥æ‰¾æœ‰å…³å…¶ä»–æ¨¡å—çš„ä¿¡æ¯ã€‚ é»˜è®¤æƒ…å†µä¸‹ï¼Œgo mod editè¯»å–å’Œå†™å…¥go.modä¸»æ¨¡å—çš„æ–‡ä»¶ï¼Œä½†å¯ä»¥åœ¨ç¼–è¾‘æ ‡å¿—åæŒ‡å®šä¸åŒçš„ç›®æ ‡æ–‡ä»¶ã€‚ ç”¨æ³•ï¼šgo mod edit [editing flags] [-fmt|-print|-json] [go.mod] editing flagsï¼šæŒ‡å®šç¼–è¾‘æ“ä½œé€‰é¡¹ï¼š(editing flagså¯ä»¥é‡å¤ä½¿ç”¨ï¼ŒæŒ‰ç»™å®šçš„é¡ºåº) -moduleï¼šæ›´æ”¹æ¨¡å—çš„è·¯å¾„(go.modæ–‡ä»¶çš„moduleè¡Œ)ï¼Œä¿®æ”¹moduleè¡Œæ¨¡å—åç§°ã€‚ -go=versionï¼šè®¾ç½®go.modæ–‡ä»¶çš„Goç‰ˆæœ¬ã€‚ -require=path@versionï¼šæ·»åŠ æŒ‡å®šçš„æ¨¡å—è·¯å¾„å’Œç‰ˆæœ¬ä¸Šçš„è¦æ±‚ï¼Œä¼šè¦†ç›–go.modä¸Šçš„ä»»ä½•ç°æœ‰è¦æ±‚pathã€‚ -droprequire=pathï¼šåˆ é™¤æŒ‡å®šçš„æ¨¡å—è·¯å¾„å’Œç‰ˆæœ¬ä¸Šçš„è¦æ±‚ã€‚ -exclude=path@versionï¼šå¢åŠ ç»™å®šçš„æ¨¡å—è·¯å¾„ï¼Œ-exclude=path@versionå¦‚æœè¯¥æ’é™¤å·²å­˜åœ¨ï¼Œ åˆ™ä¸ºç©ºæ“ä½œã€‚ -dropexclude=path@versionï¼šæ”¾å¼ƒå¯¹ç»™å®šçš„æ¨¡å—è·¯å¾„å’Œç‰ˆæœ¬çš„æ’é™¤ã€‚ -replace=old[@v]=new[@v]ï¼šæ·»åŠ äº†ç»™å®šæ¨¡å—è·¯å¾„å’Œç‰ˆæœ¬å¯¹çš„æ›¿æ¢ã€‚ å¦‚æœçœç•¥old@våˆ™æ·»åŠ å·¦ä¾§æ²¡æœ‰ç‰ˆæœ¬çš„æ›¿æ¢ï¼Œè¿™é€‚ç”¨äºæ—§æ¨¡å—è·¯å¾„çš„æ‰€æœ‰ç‰ˆæœ¬ã€‚ å¦‚æœçœç•¥new@våˆ™æ–°è·¯å¾„åº”è¯¥æ˜¯æœ¬åœ°æ¨¡å—æ ¹ç›®å½•ï¼Œè€Œä¸æ˜¯æ¨¡å—è·¯å¾„ã€‚ æ³¨æ„ï¼š-replaceè¦†ç›–çš„ä»»ä½•å†—ä½™æ›¿æ¢old[@v]ï¼Œå› æ­¤çœç•¥@vå°†åˆ é™¤ç‰¹å®šç‰ˆæœ¬çš„æ›¿æ¢ã€‚ -dropreplace=old[@v]ï¼šä¸¢å¼ƒç»™å®šæ¨¡å—è·¯å¾„å’Œç‰ˆæœ¬å¯¹çš„æ›¿æ¢ã€‚ å¦‚æœ@væä¾›äº†ï¼Œåˆ™åˆ é™¤ç»™å®šç‰ˆæœ¬çš„æ›¿æ¢,å·¦ä¾§æ²¡æœ‰ç‰ˆæœ¬çš„ç°æœ‰æ›¿ä»£å“ä»å¯æ›´æ¢æ¨¡å—ã€‚ å¦‚æœ@vçœç•¥ ï¼Œåˆ™åˆ é™¤æ²¡æœ‰ç‰ˆæœ¬çš„æ›¿æ¢ã€‚ -retract=versionï¼šæ·»åŠ å›æ”¶å¯¹äºç»™å®šçš„ç‰ˆæœ¬ï¼Œå…¶å¯ä»¥æ˜¯ä¸€ä¸ªå•ä¸€çš„ç‰ˆæœ¬ï¼ˆå¦‚v1.2.3ï¼‰æˆ–é—´éš”ï¼ˆç­‰[v1.1.0,v1.2.0]ï¼‰ã€‚ æ³¨æ„ï¼š-retractæ ‡å¿—ä¸èƒ½ä¸ºretractæŒ‡ä»¤æ·»åŠ åŸºæœ¬åŸç†æ³¨é‡Šã€‚ -dropretract=versionï¼šåˆ é™¤å›æ”¶å¯¹äºç»™å®šçš„ç‰ˆæœ¬ã€‚ -fmtã€-printã€-jsonï¼šé¢å¤–æ ‡å¿—æ¥æ§åˆ¶è¾“å‡ºã€‚ -fmtï¼šé‡æ–°æ ¼å¼åŒ–go.modæ–‡ä»¶è€Œä¸è¿›è¡Œå…¶ä»–æ›´æ”¹ã€‚ ä½¿ç”¨æˆ–é‡å†™go.modæ–‡ä»¶çš„ä»»ä½•å…¶ä»–ä¿®æ”¹ä¹Ÿæš—ç¤ºäº†è¿™ç§é‡æ–°æ ¼å¼åŒ–ã€‚ å”¯ä¸€éœ€è¦æ­¤æ ‡å¿—çš„æƒ…å†µæ˜¯æ²¡æœ‰æŒ‡å®šå…¶ä»–æ ‡å¿—ï¼Œå¦‚go mod edit -fmtã€‚ -printï¼šgo.modä»¥å…¶æ–‡æœ¬æ ¼å¼æ‰“å°final ï¼Œè€Œä¸æ˜¯å°†å…¶å†™å›ç£ç›˜ï¼ˆå°±æ˜¯æ‰“å°go.modæ–‡ä»¶å†…å®¹ï¼‰ã€‚ -jsonï¼šgo.modä»¥ JSON æ ¼å¼æ‰“å°æœ€ç»ˆç»“æœï¼Œè€Œä¸æ˜¯ä»¥æ–‡æœ¬æ ¼å¼å°†å…¶å†™å›ç£ç›˜go mod edit -jsonã€‚ // jsonæ‰“å°æ ¼å¼ { \u0026#34;Module\u0026#34;: { \u0026#34;Path\u0026#34;: \u0026#34;mymod\u0026#34; }, \u0026#34;Go\u0026#34;: \u0026#34;1.17\u0026#34;, \u0026#34;Require\u0026#34;: [ { \u0026#34;Path\u0026#34;: \u0026#34;gitee.com/phpbms/demo\u0026#34;, \u0026#34;Version\u0026#34;: \u0026#34;v0.0.0-20211021090521-71a745ffbccb\u0026#34;, \u0026#34;Indirect\u0026#34;: true } ], \u0026#34;Exclude\u0026#34;: null, \u0026#34;Replace\u0026#34;: null, \u0026#34;Retract\u0026#34;: null } // å¯¹åº”ç›¸å…³ç»“æ„ä½“ type Module struct { Path string Version string } type GoMod struct { Module Module Go string Require []Require Exclude []Module Replace []Replace } type Require struct { Path string Version string Indirect bool } type Replace struct { Old Module New Module } type Retract struct { Low string High string Rationale string } ç¤ºä¾‹ï¼š # æ·»åŠ æ›¿æ¢æŒ‡ä»¤ $ go mod edit -replace example.com/a@v1.0.0=./a # åˆ é™¤æ›¿æ¢æŒ‡ä»¤ $ go mod edit -dropreplace example.com/a@v1.0.0 # è®¾ç½®goç‰ˆæœ¬ï¼Œæ·»åŠ éœ€æ±‚ï¼Œæ‰“å°æ–‡ä»¶è€Œä¸æ˜¯å†™å…¥ç£ç›˜ $ go mod edit -go=1.14 -require=example.com/m@v1.0.0 -print # æ ¼å¼åŒ– go.mod æ–‡ä»¶ $ go mod edit -fmt # æ ¼å¼åŒ–å¹¶æ‰“å°ä¸åŒçš„ .mod æ–‡ä»¶ $ go mod edit -print tools.mod # æ‰“å° go.mod æ–‡ä»¶çš„ JSON è¡¨ç¤º $ go mod edit -json # æ‰€æœ‰å‘½ä»¤ä½¿ç”¨ $ go mod edit -module=mydemo1 -go=1.16 -require=gitee.com/phpbms/demo/v3@v3.0.0 -exclude=gitee.com/phpbms/demo/v3@v3.0.1 -replace=gitee.com/phpbms/demo/v2@v2.0.1=gitee.com/phpbms/demo/v2@v2.0.0 -retract=v1.1.1 -print ./go.mod # ä¿®æ”¹goç‰ˆæœ¬ï¼Œä»ä¹‹å‰çš„ go 1.20 ä¿®æ”¹ä¸º go 1.21rc2 $ go mod edit -go 1.21rc2 go mod vendor åœ¨ä¸»æ¨¡å—çš„æ ¹ç›®å½•ä¸­æ„é€ ä¸€ä¸ªåä¸ºvendorçš„ç›®å½•ï¼Œè¯¥ç›®å½•åŒ…å«æ”¯æŒä¸»æ¨¡å—ä¸­åŒ…çš„æ„å»ºå’Œæµ‹è¯•æ‰€éœ€çš„æ‰€æœ‰åŒ…çš„å‰¯æœ¬ã€‚ ä¸åŒ…æ‹¬ä»…é€šè¿‡ä¸»æ¨¡å—ä¹‹å¤–çš„åŒ…æµ‹è¯•å¯¼å…¥çš„åŒ…ã€‚ ä¸go mod tidyå’Œå…¶ä»–æ¨¡å—å‘½ä»¤ä¸€æ ·ï¼Œåœ¨æ„å»ºvendorç›®å½•æ—¶ä¸è€ƒè™‘é™¤äº†ignoreä¹‹å¤–çš„æ„å»ºçº¦æŸã€‚ å½“å¯ç”¨vendoringæ—¶ï¼Œgoå‘½ä»¤å°†ä»vendorç›®å½•åŠ è½½åŒ…ï¼Œè€Œä¸æ˜¯å°†æ¨¡å—ä»å…¶æºä¸‹è½½åˆ°æ¨¡å—ç¼“å­˜ä¸­ï¼Œå¹¶ä½¿ç”¨é‚£äº›ä¸‹è½½å‰¯æœ¬çš„åŒ…ã€‚ go mod vendorè¿˜ä¼šåˆ›å»ºæ–‡ä»¶vendor/modules.txtï¼Œå…¶ä¸­åŒ…å«vendoråŒ…çš„åˆ—è¡¨ä»¥åŠä»ä¸­å¤åˆ¶å®ƒä»¬çš„æ¨¡å—ç‰ˆæœ¬ã€‚ å½“å¯ç”¨vendoringæ—¶ï¼Œæ­¤æ¸…å•ç”¨ä½œæ¨¡å—ç‰ˆæœ¬ä¿¡æ¯çš„æ¥æºï¼Œå¦‚go list -må’Œgo version -mæ‰€æŠ¥å‘Šçš„ã€‚ å½“goå‘½ä»¤è¯»å–vendor/modules.txtæ—¶ï¼Œå®ƒä¼šæ£€æŸ¥æ¨¡å—ç‰ˆæœ¬æ˜¯å¦ä¸go.modä¸€è‡´ã€‚ å¦‚æœgo.modåœ¨vendor/modules.txtç”Ÿæˆåå‘ç”Ÿäº†å˜åŒ–ï¼Œåˆ™åº”å†æ¬¡è¿è¡Œgo mod vendorã€‚ è¯·æ³¨æ„ï¼Œgo mod vendorä¼šåœ¨é‡æ–°æ„å»ºä¹‹å‰åˆ é™¤vendorç›®å½•ï¼ˆå¦‚æœå®ƒå­˜åœ¨ï¼‰ã€‚ ä¸åº”å¯¹vendorçš„è½¯ä»¶åŒ…è¿›è¡Œæœ¬åœ°æ›´æ”¹ã€‚ goå‘½ä»¤ä¸ä¼šæ£€æŸ¥vendorç›®å½•ä¸­çš„åŒ…æ˜¯å¦æœªè¢«ä¿®æ”¹ï¼Œä½†æ˜¯å¯ä»¥é€šè¿‡è¿è¡Œgo mod vendorå¹¶æ£€æŸ¥æ²¡æœ‰è¿›è¡Œä»»ä½•æ›´æ”¹æ¥éªŒè¯vendorç›®å½•çš„å®Œæ•´æ€§ã€‚ ä½¿ç”¨ï¼šgo mod vendor [-e] [-v]ã€‚ -eï¼šï¼ˆåœ¨Go 1.16ä¸­æ·»åŠ ï¼‰åœ¨åŠ è½½åŒ…æ—¶é‡åˆ°é”™è¯¯æ—¶å°è¯•ç»§ç»­ã€‚ -vï¼šå°†vendoræ¨¡å—å’ŒåŒ…çš„åç§°æ‰“å°ä¸ºæ ‡å‡†é”™è¯¯ã€‚ go mod verify æ£€æŸ¥å­˜å‚¨åœ¨æ¨¡å—ç¼“å­˜ä¸­çš„ä¸»æ¨¡å—çš„ä¾èµ–é¡¹è‡ªä¸‹è½½ä»¥æ¥æ²¡æœ‰è¢«ä¿®æ”¹ã€‚ æ‰§è¡Œæ­¤æ£€æŸ¥ï¼Œå¯¹æ¯ä¸ªä¸‹è½½çš„module.zipæ–‡ä»¶å’Œæå–çš„ç›®å½•è¿›è¡Œæ•£åˆ—ç„¶åå°†è¿™äº›æ•£åˆ—ä¸é¦–æ¬¡ä¸‹è½½æ¨¡å—æ—¶è®°å½•çš„æ•£åˆ—è¿›è¡Œæ¯”è¾ƒã€‚ go mod verify æ£€æŸ¥æ„å»ºåˆ—è¡¨ä¸­çš„æ¯ä¸ªæ¨¡å—ï¼ˆå¯ä»¥ä½¿ç”¨go list -m allæ‰“å°æ‰€æœ‰æ¨¡å—ï¼‰ã€‚ å¦‚æœæ‰€æœ‰æ¨¡å—éƒ½æœªä¿®æ”¹ï¼Œåˆ™go mod verify æ‰“å°all modules verifiedå¦åˆ™ï¼Œå®ƒå°†æŠ¥å‘Šå“ªäº›æ¨¡å—å·²æ›´æ”¹å¹¶ä»¥éé›¶çŠ¶æ€é€€å‡ºã€‚ æ³¨æ„ï¼šæ‰€æœ‰æ¨¡å—æ„ŸçŸ¥å‘½ä»¤éƒ½ä¼šéªŒè¯ä¸»æ¨¡å—çš„go.sumæ–‡ä»¶ä¸­çš„å“ˆå¸Œå€¼æ˜¯å¦ä¸ä¸ºä¸‹è½½åˆ°æ¨¡å—ç¼“å­˜ä¸­çš„æ¨¡å—è®°å½•çš„å“ˆå¸Œå€¼åŒ¹é…ã€‚ å¦‚æœgo.sumä¸­ç¼ºå°‘å“ˆå¸Œï¼ˆä¾‹å¦‚ï¼Œå› ä¸ºæ¨¡å—æ˜¯ç¬¬ä¸€æ¬¡ä½¿ç”¨ï¼‰ï¼Œåˆ™goå‘½ä»¤ä½¿ç”¨æ ¡éªŒå’Œæ•°æ®åº“éªŒè¯å…¶å“ˆå¸Œã€‚ é™¤éæ¨¡å—è·¯å¾„ä¸GOPRIVATEæˆ–GONOSUMDBåŒ¹é…ã€‚ go mod verifyä¸ä¼šä¸ºä¸åœ¨ç¼“å­˜ä¸­çš„æ¨¡å—ä¸‹è½½å†…å®¹ï¼Œä¹Ÿä¸ä¼šä½¿ç”¨go.sumæ–‡ä»¶æ¥éªŒè¯æ¨¡å—å†…å®¹ã€‚ ä½†æ˜¯ï¼Œgo mod verifyå¯èƒ½ä¼šä¸‹è½½go.modæ–‡ä»¶ä»¥æ‰§è¡Œæœ€å°‘çš„ç‰ˆæœ¬é€‰æ‹©ã€‚ å®ƒå°†ä½¿ç”¨go.sumæ¥éªŒè¯è¿™äº›æ–‡ä»¶ï¼Œå¹¶ä¸”å¯èƒ½ä¼šä¸ºä¸¢å¤±çš„å“ˆå¸Œæ·»åŠ go.sumæ¡ç›®ã€‚ ç”¨æ³•ï¼šgo mod verifyã€‚ $ go mod verify all modules verified go mod why go mod whyåœ¨å¯¼å…¥å›¾ä¸­æ˜¾ç¤ºä»ä¸»æ¨¡å—åˆ°æ¯ä¸ªåˆ—å‡ºçš„åŒ…çš„æœ€çŸ­è·¯å¾„ã€‚ ç”¨æ³•ï¼šgo mod why [-m] [-vendor] packages...ã€‚ -mï¼šgo mod whyå°†å…¶å‚æ•°è§†ä¸ºæ¨¡å—åˆ—è¡¨ã€‚ go mod whyä¼šæ‰“å°æ¯ä¸ªæ¨¡å—ä¸­ä»»ä½•åŒ…çš„è·¯å¾„ã€‚ è¯·æ³¨æ„ï¼Œå³ä½¿ä½¿ç”¨-mï¼Œgo mod whyæŸ¥è¯¢åŒ…å›¾ï¼Œè€Œä¸æ˜¯go mod graphæ‰“å°çš„æ¨¡å—å›¾ã€‚ -vendorï¼šgo mod whyå¿½ç•¥ä¸»æ¨¡å—ä¹‹å¤–çš„åŒ…æµ‹è¯•ä¸­çš„å¯¼å…¥ï¼ˆå°±åƒgo mod vendoræ‰€åšçš„é‚£æ ·ï¼‰ã€‚ é»˜è®¤æƒ…å†µä¸‹ï¼Œ go mod whyä¼šè€ƒè™‘ä¸allæ¨¡å¼åŒ¹é…çš„åŒ…å›¾ã€‚ è¿™ä¸ªæ ‡å¿—åœ¨Go 1.16ä¹‹ååœ¨å£°æ˜go 1.16æˆ–æ›´é«˜ç‰ˆæœ¬çš„æ¨¡å—ä¸­æ— æ•ˆï¼ˆä½¿ç”¨go.modä¸­çš„goæŒ‡ä»¤ï¼‰ï¼Œå› ä¸ºallçš„å«ä¹‰å·²æ›´æ”¹ä»¥åŒ¹é…go modä¾›åº”å•†åŒ¹é…çš„åŒ…é›†ã€‚ ç¤ºä¾‹ï¼š è¾“å‡ºæ˜¯ä¸€ä¸ªèŠ‚åºåˆ—ï¼Œæ¯ä¸ªåœ¨å‘½ä»¤è¡Œä¸Šå‘½åçš„åŒ…æˆ–æ¨¡å—éƒ½æœ‰ä¸€ä¸ªèŠ‚ï¼Œç”¨ç©ºè¡Œåˆ†éš”ã€‚ æ¯èŠ‚ä»¥æ³¨é‡Šè¡Œå¼€å¤´ï¼Œä»¥#å¼€å¤´ï¼Œç»™å‡ºç›®æ ‡åŒ…æˆ–æ¨¡å—ã€‚ åç»­è¡Œç»™å‡ºäº†é€šè¿‡å¯¼å…¥å›¾çš„è·¯å¾„ï¼Œæ¯è¡Œä¸€ä¸ªåŒ…ã€‚ å¦‚æœåŒ…æˆ–æ¨¡å—ä¸æ˜¯ä»ä¸»æ¨¡å—å¼•ç”¨çš„ï¼Œåˆ™è¯¥èŠ‚å°†æ˜¾ç¤ºä¸€ä¸ªå¸¦æ‹¬å·çš„æ³¨é‡Šï¼Œè¡¨æ˜è¯¥äº‹å®ã€‚ $ go mod why golang.org/x/text/language golang.org/x/text/encoding # golang.org/x/text/language rsc.io/quote rsc.io/sampler golang.org/x/text/language # golang.org/x/text/encoding (main module does not need package golang.org/x/text/encoding) ","permalink":"https://heliu.site/posts/golang/package/module/","summary":"Golang go moduleså‘½ä»¤ä»‹ç»ã€‚","title":"go modules"},{"content":" ç”¨æ³•ï¼šgo work \u0026lt;command\u0026gt; [arguments] command åˆ—è¡¨ï¼š editï¼šä»å·¥å…·æˆ–è„šæœ¬ç¼–è¾‘ go.workã€‚ initï¼šåˆå§‹åŒ–å·¥ä½œåŒºæ–‡ä»¶ã€‚ syncï¼šå°†å·¥ä½œåŒºæ„å»ºåˆ—è¡¨åŒæ­¥åˆ°æ¨¡å—ã€‚ useï¼šå°†æ¨¡å—æ·»åŠ åˆ°å·¥ä½œåŒºæ–‡ä»¶ã€‚ go work init ç”¨æ³•ï¼šgo work init [moddirs]ã€‚ initåœ¨å½“å‰ç›®å½•ä¸­åˆå§‹åŒ–å¹¶å†™å…¥ä¸€ä¸ªæ–°çš„go.workæ–‡ä»¶ï¼Œå®é™…ä¸Šæ˜¯åœ¨å½“å‰ç›®å½•ä¸­åˆ›å»ºäº†ä¸€ä¸ªæ–°çš„å·¥ä½œç©ºé—´ã€‚ go work initå¯é€‰æ‹©æ¥å—å·¥ä½œåŒºæ¨¡å—çš„è·¯å¾„ä½œä¸ºå‚æ•°ã€‚å¦‚æœçœç•¥è¯¥å‚æ•°ï¼Œå°†åˆ›å»ºä¸€ä¸ªæ²¡æœ‰æ¨¡å—çš„ç©ºå·¥ä½œåŒºã€‚ æ¯ä¸ªå‚æ•°è·¯å¾„éƒ½æ·»åŠ åˆ°go.workæ–‡ä»¶ä¸­çš„useæŒ‡ä»¤ä¸­ã€‚ å½“å‰çš„goç‰ˆæœ¬ä¹Ÿå°†åˆ—åœ¨go.workæ–‡ä»¶ä¸­ã€‚ ç¤ºä¾‹ï¼š 1 2 # åˆå§‹åŒ–ä¸€ä¸ªæ–°çš„å·¥ä½œåŒºï¼Œåé¢å‚æ•°å°±æ˜¯å…·ä½“çš„å­æ¨¡å— $ go work init ./queue ./hello 1 2 3 4 5 6 7 8 9 // é¡¹ç›®ç›®å½•æ„æˆ workspace |-- queue # å­æ¨¡å— | |-- go.mod | |-- queue.go |-- hello # å­æ¨¡å— | |-- go.mod | |-- main.go\t|-- go.work # å·¥ä½œåŒº é€šå¸¸go.workæ–‡ä»¶ä¸è¦æäº¤åˆ°gitä¸Šï¼Œå› ä¸ºå®ƒä¸»è¦ç”¨äºæœ¬åœ°ä»£ç å¼€å‘ã€‚ go work edit ç”¨æ³•ï¼šgo work edit [editing flags] [go.work]ã€‚ç”¨äºç¼–è¾‘go.workæ–‡ä»¶ã€‚ go work editå‘½ä»¤æä¾›äº†ä¸€ä¸ªç”¨äºç¼–è¾‘go.workçš„å‘½ä»¤è¡Œç•Œé¢ï¼Œä¸»è¦ä¾›å·¥å…·æˆ–è„šæœ¬ä½¿ç”¨ã€‚ å®ƒåªè¯»å–go.work;å®ƒä¸æŸ¥æ‰¾æœ‰å…³æ‰€æ¶‰åŠæ¨¡å—çš„ä¿¡æ¯ã€‚å¦‚æœæ²¡æœ‰æŒ‡å®šæ–‡ä»¶ï¼Œeditåœ¨å½“å‰ç›®å½•åŠå…¶çˆ¶ç›®å½•ä¸­æŸ¥æ‰¾go.workæ–‡ä»¶ã€‚ editing flags fmtï¼šé‡æ–°æ ¼å¼åŒ–go.workæ–‡ä»¶è€Œä¸è¿›è¡Œå…¶ä»–æ›´æ”¹ã€‚ä½¿ç”¨æˆ–é‡å†™go.workæ–‡ä»¶çš„ä»»ä½•å…¶ä»–ä¿®æ”¹ä¹Ÿæš—ç¤ºäº†è¿™ç§é‡æ–°æ ¼å¼åŒ–ã€‚å”¯ä¸€éœ€è¦æ­¤æ ‡å¿—çš„æƒ…å†µæ˜¯æ²¡æœ‰æŒ‡å®šå…¶ä»–æ ‡å¿—ã€‚ ç¤ºä¾‹ï¼šgo work edit -fmtã€‚ç”¨äºæ ¼å¼åŒ–go.workæ–‡ä»¶ã€‚ $ go work edit -fmt -use=pathï¼šä»go.workæ–‡ä»¶çš„æ¨¡å—ç›®å½•é›†ä¸­æ·»åŠ useæŒ‡ä»¤ã€‚å»ºè®®ä½¿ç”¨go work useæŒ‡ä»¤ã€‚ ç¤ºä¾‹ï¼šgo work edit -use=./queueã€‚æ·»åŠ å­æ¨¡å—ã€‚ $ go work edit -use ./ququq -dropuse=pathï¼šä»go.workæ–‡ä»¶çš„æ¨¡å—ç›®å½•é›†ä¸­åˆ é™¤useæŒ‡ä»¤ã€‚ ç¤ºä¾‹ï¼šgo work edit -dropuse=./queueã€‚åˆ é™¤å­æ¨¡å—queueã€‚ $ go work edit -dropuse ./queue -replace=old[@v]=new[@v]ï¼šæ·»åŠ äº†ç»™å®šæ¨¡å—è·¯å¾„å’Œç‰ˆæœ¬å¯¹çš„æ›¿æ¢ã€‚ å¦‚æœold@vä¸­çš„@vè¢«çœç•¥ï¼Œåˆ™æ·»åŠ å·¦ä¾§æ²¡æœ‰ç‰ˆæœ¬çš„æ›¿æ¢ï¼Œé€‚ç”¨äºæ—§æ¨¡å—è·¯å¾„çš„æ‰€æœ‰ç‰ˆæœ¬ã€‚ å¦‚æœçœç•¥new@vä¸­çš„@vï¼Œåˆ™æ–°è·¯å¾„åº”è¯¥æ˜¯æœ¬åœ°æ¨¡å—æ ¹ç›®å½•ï¼Œè€Œä¸æ˜¯æ¨¡å—è·¯å¾„ã€‚ è¯·æ³¨æ„ï¼Œ-replaceä¼šè¦†ç›–old[@v]çš„ä»»ä½•å†—ä½™æ›¿æ¢ï¼Œå› æ­¤çœç•¥@vå°†åˆ é™¤ç‰¹å®šç‰ˆæœ¬çš„ç°æœ‰æ›¿æ¢ã€‚ ç¤ºä¾‹ï¼šgo work edit -replace myzx.cn/helium/queue=./queueã€‚ $ go work edit -replace myzx.cn/helium/queue=./queue -dropreplace=old[@v]ï¼šåˆ é™¤ç»™å®šæ¨¡å—è·¯å¾„å’Œç‰ˆæœ¬å¯¹çš„æ›¿æ¢ã€‚å¦‚æœçœç•¥äº†@vï¼Œåˆ™ä¼šåˆ é™¤å·¦ä¾§æ²¡æœ‰ç‰ˆæœ¬çš„æ›¿æ¢ã€‚ ç¤ºä¾‹ï¼šgo work edit -dropreplace myzx.cn/helium/queueã€‚ $ go work edit -dropreplace myzx.cn/helium/queue -go=versionï¼šè®¾ç½®é¢„æœŸçš„Goè¯­è¨€ç‰ˆæœ¬ã€‚ ç¤ºä¾‹ï¼šgo work edit -go 1.19ã€‚ $ go work edit -go 1.19 è¿™äº›editing flagså¯ä»¥é‡å¤ä½¿ç”¨ã€‚ æ›´æ”¹æŒ‰ç»™å®šçš„é¡ºåºåº”ç”¨ã€‚ go work editæœ‰é¢å¤–çš„æ ‡å¿—æ¥æ§åˆ¶å®ƒçš„è¾“å‡º -printï¼šä»¥æ–‡æœ¬æ ¼å¼æ‰“å°æœ€ç»ˆçš„go.workï¼Œè€Œä¸æ˜¯å°†å…¶å†™å›go.modã€‚ $ go work edit -print -jsonï¼šä»¥JSONæ ¼å¼æ‰“å°æœ€ç»ˆçš„go.workæ–‡ä»¶ï¼Œè€Œä¸æ˜¯å°†å…¶å†™å›go.modã€‚ $ go work edit -json JSONè¾“å‡ºå¯¹åº”äºä»¥ä¸‹Goç±»å‹ï¼š 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 type Module struct { Path string Version string } type GoWork struct { Go string Directory []Directory Replace []Replace } type Use struct { Path string ModulePath string } type Replace struct { Old Module New Module } go work use ç”¨æ³•ï¼šgo work use [-r] [moddirs]ã€‚useæŒ‡å®šä½¿ç”¨çš„æ¨¡å—ç›®å½•ã€‚ go work useå‘½ä»¤æä¾›äº†ä¸€ä¸ªå‘½ä»¤è¡Œç•Œé¢ï¼Œç”¨äºå°†ç›®å½•ï¼ˆå¯é€‰åœ°ä»¥é€’å½’æ–¹å¼ï¼‰æ·»åŠ åˆ°go.workæ–‡ä»¶ä¸­ã€‚ useæŒ‡ä»¤å°†è¢«æ·»åŠ åˆ°å‘½ä»¤è¡Œgo.workæ–‡ä»¶ä¸­åˆ—å‡ºçš„æ¯ä¸ªå‚æ•°ç›®å½•çš„go.workæ–‡ä»¶ï¼ˆå¦‚æœå®ƒå­˜åœ¨äºç£ç›˜ä¸Šï¼‰ï¼Œæˆ–è€…ä»go.workæ–‡ä»¶ä¸­åˆ é™¤ï¼ˆå¦‚æœå®ƒä¸å­˜åœ¨äºç£ç›˜ä¸Šï¼‰ã€‚ åˆ é™¤åŠŸèƒ½ä½¿ç”¨ï¼šgo work edit -dropuse ./queueå‘½ä»¤ã€‚ -rï¼šé€’å½’æœç´¢å‚æ•°ç›®å½•ä¸­çš„æ¨¡å—ï¼Œå¹¶ä¸”ä½¿ç”¨å‘½ä»¤å°±åƒæ¯ä¸ªç›®å½•éƒ½è¢«æŒ‡å®šä¸ºå‚æ•°ä¸€æ ·æ“ä½œï¼šå³ï¼Œå°†ä¸ºå­˜åœ¨çš„ç›®å½•æ·»åŠ ä½¿ç”¨æŒ‡ä»¤ï¼Œä¸ºä¸å­˜åœ¨çš„ç›®å½•åˆ é™¤ä½¿ç”¨æŒ‡ä»¤ã€‚ é€’å½’çš„æ·»åŠ å­æ¨¡å—åˆ°å½“å‰å·¥ä½œåŒºï¼Œè¿™å¯¹äºå­æ¨¡å—å¼•ç”¨äº†å¾ˆå¤šæ¨¡å—å¾ˆç”¨ç”¨å¤„ã€‚ ç¤ºä¾‹ï¼šgo work use ./queueï¼Œæ·»åŠ queueå­æ¨¡å—ã€‚ $ go work use ./queue go work sync ç”¨æ³•ï¼šgo work syncã€‚æ²¡æœ‰å‚æ•°ã€‚ go work syncå‘½ä»¤å°†å·¥ä½œåŒºçš„æ„å»ºåˆ—è¡¨åŒæ­¥å›å·¥ä½œåŒºçš„æ¨¡å—ã€‚è¯¥å‘½ä»¤ä¼šä¿®æ”¹go.workæ–‡ä»¶ã€‚ å·¥ä½œåŒºçš„æ„å»ºåˆ—è¡¨æ˜¯ç”¨äºåœ¨å·¥ä½œåŒºä¸­è¿›è¡Œæ„å»ºçš„æ‰€æœ‰ï¼ˆä¼ é€’ï¼‰ä¾èµ–æ¨¡å—çš„ç‰ˆæœ¬é›†ã€‚go work syncä½¿ç”¨æœ€å°ç‰ˆæœ¬é€‰æ‹©(MVS)ç®—æ³•ç”Ÿæˆè¯¥æ„å»ºåˆ—è¡¨ï¼Œç„¶åå°†è¿™äº›ç‰ˆæœ¬åŒæ­¥å›å·¥ä½œåŒºä¸­æŒ‡å®šçš„æ¯ä¸ªæ¨¡å—ï¼ˆä½¿ç”¨useæŒ‡ä»¤ï¼‰ã€‚ ä¸€æ—¦è®¡ç®—äº†å·¥ä½œåŒºæ„å»ºåˆ—è¡¨ï¼Œå·¥ä½œåŒºä¸­æ¯ä¸ªæ¨¡å—çš„go.modæ–‡ä»¶éƒ½ä¼šè¢«é‡å†™ï¼Œå¹¶ä½¿ç”¨ä¸è¯¥æ¨¡å—ç›¸å…³çš„ä¾èµ–é¡¹è¿›è¡Œå‡çº§ä»¥åŒ¹é…å·¥ä½œåŒºæ„å»ºåˆ—è¡¨ã€‚è¯·æ³¨æ„ï¼Œæœ€å°ç‰ˆæœ¬é€‰æ‹©ä¿è¯æ¯ä¸ªæ¨¡å—çš„æ„å»ºåˆ—è¡¨ç‰ˆæœ¬å§‹ç»ˆä¸æ¯ä¸ªå·¥ä½œåŒºæ¨¡å—ä¸­çš„ç›¸åŒæˆ–æ›´é«˜ã€‚ $ go work sync go env GOWORK æŸ¥çœ‹ç¯å¢ƒå˜é‡ï¼ŒæŸ¥çœ‹å½“å‰å·¥ä½œåŒºæ–‡ä»¶è·¯å¾„ã€‚å¯ä»¥æ’æŸ¥å·¥ä½œåŒºæ–‡ä»¶æ˜¯å¦è®¾ç½®æ­£ç¡®ã€‚go.workè·¯å¾„æ‰¾ä¸åˆ°å¯ä»¥ä½¿ç”¨GOWORKæŒ‡å®šã€‚ ç¤ºä¾‹ï¼š $ go env GOWORK G:\\workspace\\go.work ç¦ç”¨å·¥ä½œåŒºï¼Œç›´æ¥æŠŠGOWORKè®¾ç½®ä¸ºoffå³å¯ã€‚ ","permalink":"https://heliu.site/posts/golang/package/work/","summary":"Golang go work å‘½ä»¤ä»‹ç»ã€‚","title":"go work"},{"content":"GO111MODULE Goè¯­è¨€æä¾›äº†GO111MODULEè¿™ä¸ªç¯å¢ƒå˜é‡æ¥ä½œä¸ºGo modulesçš„å¼€å…³ï¼Œå…¶å…è®¸è®¾ç½®ä»¥ä¸‹å‚æ•°ï¼š autoï¼šåªè¦é¡¹ç›®åŒ…å«äº†go.modæ–‡ä»¶(åœ¨$GOPATH/srcå¤–é¢ä¸”æ ¹ç›®å½•æœ‰go.modæ–‡ä»¶æ—¶)çš„è¯å¯ç”¨Go modulesã€‚ onï¼šå¯ç”¨Go modulesï¼Œæ¨èè®¾ç½®ï¼Œä¼šå¿½ç•¥GOPATHå’Œvendoræ–‡ä»¶å¤¹ï¼Œåªæ ¹æ®go.modä¸‹è½½ä¾èµ–ã€‚ offï¼šç¦ç”¨Go modulesï¼Œä¸æ¨èè®¾ç½®ï¼Œä¼šä»GOPATHå’Œvendoræ–‡ä»¶å¤¹å¯»æ‰¾åŒ…ã€‚ GO111MODULEç›¸å…³è§£é‡Šï¼š GO111MODULEè¿™ä¸ªå‘½åä»£è¡¨ç€Goè¯­è¨€åœ¨1.11ç‰ˆæœ¬æ·»åŠ çš„ï¼Œé’ˆå¯¹Moduleçš„å˜é‡ã€‚ åƒæ˜¯åœ¨Go1.5ç‰ˆæœ¬çš„æ—¶å€™ï¼Œä¹Ÿå‘å¸ƒäº†ä¸€ä¸ªç³»ç»Ÿç¯å¢ƒå˜é‡GO15VENDOREXPERIMENTã€‚ ä½œç”¨æ˜¯ç”¨äºå¼€å¯vendorç›®å½•çš„æ”¯æŒï¼Œå½“æ—¶å…¶é»˜è®¤å€¼ä¹Ÿä¸æ˜¯å¼€å¯ï¼Œä»…ä»…ä½œä¸ºexperimentalã€‚ å…¶éšååœ¨Go1.6ç‰ˆæœ¬æ—¶ä¹Ÿå°†é»˜è®¤å€¼æ”¹ä¸ºäº†å¼€å¯ï¼Œå¹¶ä¸”æœ€åä½œä¸ºäº†officialï¼ŒGO15VENDOREXPERIMENTç³»ç»Ÿå˜é‡å°±é€€å‡ºäº†å†å²èˆå°ã€‚ è€Œæœªæ¥GO111MODULEè¿™ä¸€ä¸ªç³»ç»Ÿç¯å¢ƒå˜é‡ä¹Ÿä¼šé¢ä¸´è¿™ä¸ªé—®é¢˜ï¼Œä¸å»é™¤æ˜¯ä¸ºäº†å…¼å®¹è€ç‰ˆæœ¬ã€‚ $ go env -w GO111MODULE=auto GOPROXY è¿™ä¸ªç¯å¢ƒå˜é‡ä¸»è¦æ˜¯ç”¨äºè®¾ç½®Goæ¨¡å—ä»£ç†ï¼Œç›´æ¥é€šè¿‡é•œåƒç«™ç‚¹æ¥å¿«é€Ÿæ‹‰å–ã€‚ GOPROXYçš„é»˜è®¤å€¼æ˜¯ï¼šhttps://proxy.golang.org,directï¼Œè¿™æœ‰ä¸€ä¸ªå¾ˆä¸¥é‡çš„é—®é¢˜ï¼Œå°±æ˜¯https://proxy.golang.orgåœ¨å›½å†…æ˜¯æ— æ³•è®¿é—®çš„ã€‚ åœ¨è¯¥é…ç½®ä¸‹ï¼Œgoå‘½ä»¤é¦–å…ˆå»Googleè¿è¡Œçš„Goæ¨¡å—é•œåƒï¼Œå¦‚æœé•œåƒæ²¡æœ‰æ¨¡å—ï¼Œåˆ™å›é€€åˆ°ç›´æ¥è¿æ¥ã€‚ å¯ä»¥è®¾ç½®GOPRIVATEå’ŒGONOPROXYç¯å¢ƒå˜é‡ä»¥é˜²æ­¢ä½¿ç”¨ä»£ç†ä¸‹è½½ç‰¹å®šæ¨¡å—ã€‚ ä¸­å›½å¤§é™†æ¨èä½¿ç”¨ go env -w GOPROXY=https://goproxy.cn,directã€‚ å…¶ä»–æºåœ°å€åˆ—è¡¨ï¼šhttps://goproxy.cnã€https://goproxy.ioã€https://goproxy.baidu.com/ã€‚ GOPROXYçš„å€¼æ˜¯ä¸€ä¸ªä»¥è‹±æ–‡é€—å·(,)æˆ–ç«–çº¿(|)åˆ†å‰²çš„Goæ¨¡å—ä»£ç†åˆ—è¡¨ï¼Œå…è®¸è®¾ç½®å¤šä¸ªæ¨¡å—ä»£ç†ã€‚ å‡è®¾ä½ ä¸æƒ³ä½¿ç”¨ï¼Œä¹Ÿå¯ä»¥å°†å…¶è®¾ç½®ä¸ºâ€œoffâ€ ï¼Œè¿™å°†ä¼šç¦æ­¢Goåœ¨åç»­æ“ä½œä¸­ä½¿ç”¨ä»»ä½•Goæ¨¡å—ä»£ç†ã€‚ä¹Ÿå°±æ˜¯go env -w GOPROXY=offã€‚ direct æ˜¯ä»€ä¹ˆ? æ˜¯ä¸€ä¸ªç‰¹æ®ŠæŒ‡ç¤ºç¬¦ï¼Œç”¨äºæŒ‡ç¤ºGoå›æºåˆ°æ¨¡å—ç‰ˆæœ¬çš„æºåœ°å€å»æŠ“å–ï¼ˆæ¯”å¦‚GitHubç­‰ï¼‰ã€‚ å½“å€¼åˆ—è¡¨ä¸­ä¸Šä¸€ä¸ªGoæ¨¡å—ä»£ç†è¿”å›404æˆ–410é”™è¯¯æ—¶ï¼ŒGoè‡ªåŠ¨å°è¯•åˆ—è¡¨ä¸­çš„ä¸‹ä¸€ä¸ªã€‚ é‡è§â€œdirectâ€æ—¶å›æºï¼Œä¹Ÿå°±æ˜¯å›åˆ°æºåœ°å€å»æŠ“å–ï¼Œè€Œé‡è§EOFæ—¶ç»ˆæ­¢å¹¶æŠ›å‡ºç±»ä¼¼â€œinvalid version: unknown revision...â€çš„é”™è¯¯ã€‚ æ¨¡å—ä»£ç†URLåˆ—è¡¨ï¼Œä»¥é€—å· (,) æˆ–ç«–çº¿ (|) åˆ†éš”ï¼š å½“goå‘½ä»¤æŸ¥æ‰¾æŸä¸ªæ¨¡å—çš„ä¿¡æ¯æ—¶ï¼Œå®ƒä¼šä¾æ¬¡è”ç³»åˆ—è¡¨ä¸­çš„æ¯ä¸ªä»£ç†ï¼Œç›´åˆ°æ”¶åˆ°æˆåŠŸå“åº”æˆ–ç»ˆç«¯é”™è¯¯ä¸ºæ­¢ã€‚ ä»£ç†å¯èƒ½ä¼šä»¥404ï¼ˆæœªæ‰¾åˆ°ï¼‰æˆ–410ï¼ˆå·²æ¶ˆå¤±ï¼‰çŠ¶æ€å“åº”ï¼Œä»¥æŒ‡ç¤ºè¯¥æ¨¡å—åœ¨è¯¥æœåŠ¡å™¨ä¸Šä¸å¯ç”¨ã€‚ goå‘½ä»¤çš„é”™è¯¯å›é€€è¡Œä¸ºç”±URLä¹‹é—´çš„åˆ†éš”ç¬¦å†³å®šï¼š ,ï¼šgoå‘½ä»¤ä¼šåœ¨404æˆ–410é”™è¯¯åå›é€€åˆ°ä¸‹ä¸€ä¸ªURLï¼Œæ‰€æœ‰å…¶ä»–é”™è¯¯éƒ½è¢«è§†ä¸ºç»ˆç«¯é”™è¯¯ã€‚ |ï¼šgoå‘½ä»¤åœ¨å‡ºç°ä»»ä½•é”™è¯¯ï¼ˆåŒ…æ‹¬è¶…æ—¶ç­‰éHTTPé”™è¯¯ï¼‰åå›é€€åˆ°ä¸‹ä¸€ä¸ªæºã€‚ GOPROXYçš„URLå¯èƒ½å…·æœ‰httpsã€httpæˆ–fileæ–¹æ¡ˆï¼Œå¦‚æœURLæ²¡æœ‰æ–¹æ¡ˆï¼Œåˆ™å‡å®šä¸ºhttpsã€‚ æ¨¡å—ç¼“å­˜å¯ä»¥ç›´æ¥ç”¨ä½œæ–‡ä»¶ä»£ç†ï¼šgo env -w GOPROXY=file://$(go env GOMODCACHE)/cache/downloadã€‚ å¯ä»¥ä½¿ç”¨ä¸¤ä¸ªå…³é”®å­—ä»£æ›¿ä»£ç†URLï¼š offï¼šç¦æ­¢ä»ä»»ä½•æ¥æºä¸‹è½½æ¨¡å—ã€‚ directï¼šç›´æ¥ä»ç‰ˆæœ¬æ§åˆ¶å­˜å‚¨åº“ä¸‹è½½ï¼Œè€Œä¸æ˜¯ä½¿ç”¨æ¨¡å—ä»£ç†ã€‚ $ go env -w GOPROXY=https://goproxy.cn,direct GOSUMDB ç”¨äºåœ¨æ‹‰å–æ¨¡å—ç‰ˆæœ¬æ—¶ï¼ˆæ— è®ºæ˜¯ä»æºç«™æ‹‰å–è¿˜æ˜¯é€šè¿‡Go module proxyæ‹‰å–ï¼‰ä¿è¯æ‹‰å–åˆ°çš„æ¨¡å—ç‰ˆæœ¬æ•°æ®æœªç»è¿‡ç¯¡æ”¹ã€‚è‹¥å‘ç°ä¸ä¸€è‡´ï¼Œä¹Ÿå°±æ˜¯å¯èƒ½å­˜åœ¨ç¯¡æ”¹ï¼Œå°†ä¼šç«‹å³ä¸­æ­¢ã€‚ GOSUMDBçš„é»˜è®¤å€¼ä¸ºï¼šsum.golang.orgï¼Œåœ¨å›½å†…ä¹Ÿæ˜¯æ— æ³•è®¿é—®çš„ï¼Œä½†æ˜¯GOSUMDBå¯ä»¥è¢«Goæ¨¡å—ä»£ç†æ‰€ä»£ç†ã€‚ å› æ­¤æˆ‘ä»¬å¯ä»¥é€šè¿‡è®¾ç½®GOPROXYæ¥è§£å†³ï¼Œè€Œå…ˆå‰æˆ‘ä»¬æ‰€è®¾ç½®çš„æ¨¡å—ä»£ç†goproxy.cnå°±èƒ½æ”¯æŒä»£ç†sum.golang.orgã€‚ æ‰€ä»¥è¿™ä¸€ä¸ªé—®é¢˜åœ¨è®¾ç½®GOPROXYåï¼Œä½ å¯ä»¥ä¸éœ€è¦è¿‡åº¦å…³å¿ƒã€‚ å¦å¤–è‹¥å¯¹GOSUMDBçš„å€¼æœ‰è‡ªå®šä¹‰éœ€æ±‚ï¼Œå…¶æ”¯æŒå¦‚ä¸‹æ ¼å¼ï¼š æ ¼å¼ 1ï¼š\u0026lt;SUMDB_NAME\u0026gt;+\u0026lt;PUBLIC_KEY\u0026gt;ã€‚ æ ¼å¼ 2ï¼š\u0026lt;SUMDB_NAME\u0026gt;+\u0026lt;PUBLIC_KEY\u0026gt; \u0026lt;SUMDB_URL\u0026gt;ã€‚ ä¹Ÿå¯ä»¥å°†å…¶è®¾ç½®ä¸ºâ€œoffâ€ï¼Œä¹Ÿå°±æ˜¯ç¦æ­¢Goåœ¨åç»­æ“ä½œä¸­æ ¡éªŒæ¨¡å—ç‰ˆæœ¬ï¼Œä¹Ÿå°±æ˜¯go env -w GOSUMDB=offã€‚ å¦‚æœGOSUMDBè®¾ç½®ä¸ºoffæˆ–è€…ä½¿ç”¨go getè®¾ç½®-insecureæ ‡å¿—åˆ™ä¸ä¼šæŸ¥è¯¢æ ¡éªŒå’Œæ•°æ®åº“ï¼Œå¹¶æ¥å—æ‰€æœ‰æ— æ³•è¯†åˆ«çš„æ¨¡å—ã€‚ ä»£ä»·æ˜¯æ”¾å¼ƒå¯¹æ‰€æœ‰æ¨¡å—è¿›è¡Œå·²éªŒè¯çš„å¯é‡å¤ä¸‹è½½çš„å®‰å…¨ä¿è¯ã€‚ ç»•è¿‡ç‰¹å®šæ¨¡å—çš„æ ¡éªŒå’Œæ•°æ®åº“çš„æ›´å¥½æ–¹æ³•æ˜¯ä½¿ç”¨GOPRIVATEæˆ–GONOSUMDBç¯å¢ƒå˜é‡ã€‚ ç›¸å…³å‚è€ƒæ–‡æ¡£ï¼šhttps://goproxy.io/zh/docs/GOSUMDB-env.htmlã€‚ GOPRIVATE ç”¨äºå½“å‰é¡¹ç›®ä¾èµ–äº†ç§æœ‰æ¨¡å—ï¼Œå¦‚ä½ å…¬å¸çš„ç§æœ‰gitä»“åº“ï¼Œåˆæˆ–æ˜¯githubä¸­çš„ç§æœ‰åº“ï¼Œéƒ½æ˜¯å±äºç§æœ‰æ¨¡å—ï¼Œéƒ½æ˜¯è¦è¿›è¡Œè®¾ç½®çš„ï¼Œå¦åˆ™ä¼šæ‹‰å–å¤±è´¥ã€‚ å°±æ˜¯ä¾èµ–äº†ç”±GOPROXYæŒ‡å®šçš„Goæ¨¡å—ä»£ç†æˆ–ç”±GOSUMDBæŒ‡å®šGo checksum databaseéƒ½æ— æ³•è®¿é—®åˆ°çš„æ¨¡å—æ—¶çš„åœºæ™¯ã€‚ ä»¥è‹±æ–‡é€—å·â€œ,â€åˆ†å‰²çš„æ¨¡å—è·¯å¾„å‰ç¼€ï¼Œä¹Ÿå°±æ˜¯å¯ä»¥è®¾ç½®å¤šä¸ªï¼Œä¾‹å¦‚ï¼š go env -w GOPRIVATE=\u0026quot;git.example.com,github.com/helium/bms\u0026quot;ã€‚ è®¾ç½®åï¼Œå‰ç¼€ä¸ºgit.xxx.comå’Œgithub.com/helium/bmsçš„æ¨¡å—éƒ½ä¼šè¢«è®¤ä¸ºæ˜¯ç§æœ‰æ¨¡å—ã€‚ å¦‚æœä¸æƒ³æ¯æ¬¡éƒ½é‡æ–°è®¾ç½®ï¼Œæˆ‘ä»¬ä¹Ÿå¯ä»¥åˆ©ç”¨é€šé…ç¬¦ï¼Œä¾‹å¦‚ï¼š go env -w GOPRIVATE=\u0026quot;*.example.com\u0026quot;ã€‚ è¿™æ ·å­è®¾ç½®çš„è¯ï¼Œæ‰€æœ‰æ¨¡å—è·¯å¾„ä¸ºexample.comçš„å­åŸŸå(ä¾‹å¦‚ï¼šgit.example.com)éƒ½å°†ä¸ç»è¿‡Go module proxyå’ŒGo checksum databaseã€‚ éœ€è¦æ³¨æ„çš„æ˜¯ä¸åŒ…æ‹¬example.comæœ¬èº«ã€‚ ç›¸å…³å‚è€ƒæ–‡æ¡£ï¼šhttps://goproxy.io/zh/docs/GOPRIVATE-env.htmlã€‚ GONOPROXY ç”¨äºæŒ‡å®šä¸ä½¿ç”¨æ¨¡å—ä»£ç†ï¼ˆå¦‚proxy.golang.orgï¼‰ä¸‹è½½æ¨¡å—çš„æ¨¡å—è·¯å¾„å‰ç¼€åˆ—è¡¨ã€‚ æ¨¡å—ä»£ç†æ˜¯Go 1.13åŠä»¥ä¸Šç‰ˆæœ¬æ¨å‡ºçš„åŠŸèƒ½ï¼Œç”¨äºç¼“å­˜å…¬å…±æ¨¡å—ï¼Œä»¥åŠ å¿«æ¨¡å—ä¸‹è½½é€Ÿåº¦å’Œæé«˜æ¨¡å—ä¸‹è½½çš„å¯é æ€§ã€‚ è¯¥å˜é‡åŒ…å«ä¸€ä¸ªç”±é€—å·åˆ†éš”çš„æ¨¡å—è·¯å¾„å‰ç¼€åˆ—è¡¨ã€‚ å¦‚æœä½ æœ‰ä¸€ä¸ªç§æœ‰æ¨¡å—å­˜å‚¨åœ¨ git.example.comï¼Œå¹¶å¸Œæœ›Goå‘½ä»¤ç›´æ¥ä»è¯¥ä»“åº“ä¸‹è½½æ¨¡å—è€Œä¸æ˜¯é€šè¿‡æ¨¡å—ä»£ç†ï¼Œä½ å¯ä»¥è®¾ç½®GONOPROXY=git.example.comã€‚ GONOSUMDB ç”¨äºæŒ‡å®šä¸æ£€æŸ¥å…¶æ ¡éªŒå’Œçš„æ¨¡å—è·¯å¾„å‰ç¼€åˆ—è¡¨ã€‚ Go modulesä½¿ç”¨æ ¡éªŒå’Œæ•°æ®åº“ï¼ˆå¦‚sum.golang.orgï¼‰æ¥ç¡®ä¿ä¸‹è½½çš„æ¨¡å—ç‰ˆæœ¬æ²¡æœ‰è¢«ç¯¡æ”¹ã€‚ ä¸GONOPROXYç±»ä¼¼ï¼Œè¯¥å˜é‡ä¹ŸåŒ…å«ä¸€ä¸ªç”±é€—å·åˆ†éš”çš„æ¨¡å—è·¯å¾„å‰ç¼€åˆ—è¡¨ã€‚ å‡è®¾ä½ æœ‰ç§æœ‰æ¨¡å—å¹¶ä¸”ä¸å¸Œæœ›Goå‘½ä»¤å°è¯•éªŒè¯è¿™äº›æ¨¡å—çš„æ ¡éªŒå’Œï¼Œä½ å¯ä»¥è®¾ç½®GONOSUMDB=git.example.comã€‚ GOVCS æ§åˆ¶goå‘½ä»¤å¯ä»¥ç”¨æ¥ä¸‹è½½å…¬å…±å’Œç§æœ‰æ¨¡å—ï¼Œï¼ˆç”±å®ƒä»¬çš„è·¯å¾„æ˜¯å¦ä¸GOPRIVATEä¸­çš„æ¨¡å¼åŒ¹é…ï¼‰æˆ–å…¶ä»–ä¸globæ¨¡å¼åŒ¹é…çš„æ¨¡å—çš„ç‰ˆæœ¬æ§åˆ¶å·¥å…·é›†ã€‚ å¦‚æœæœªè®¾ç½®GOVCSï¼Œæˆ–è€…æ¨¡å—ä¸GOVCSä¸­çš„ä»»ä½•æ¨¡å¼éƒ½ä¸åŒ¹é…ï¼Œåˆ™goå‘½ä»¤å¯èƒ½å¯¹å…¬å…±æ¨¡å—ä½¿ç”¨gitå’Œhgï¼Œæˆ–å¯¹ç§æœ‰æ¨¡å—ä½¿ç”¨ä»»ä½•å·²çŸ¥çš„ç‰ˆæœ¬æ§åˆ¶å·¥å…·ã€‚ å…·ä½“æ¥è¯´ï¼Œgoå‘½ä»¤å°±åƒGOVCSè¢«è®¾ç½®ä¸ºï¼ˆé»˜è®¤æ¨¡å¼ï¼‰ï¼špublic:git|hg,private:allã€‚ ","permalink":"https://heliu.site/posts/golang/package/env/","summary":"Golang ç¯å¢ƒå˜é‡ä»‹ç»ã€‚","title":"æ¨¡å—ç›¸å…³ç¯å¢ƒå˜é‡"},{"content":" å·¥ä½œåŒºæ˜¯ç£ç›˜ä¸Šæ¨¡å—çš„é›†åˆï¼Œåœ¨è¿è¡Œæœ€å°ç‰ˆæœ¬é€‰æ‹©(MVS)æ—¶ç”¨ä½œæ ¹æ¨¡å—ã€‚ å·¥ä½œç©ºé—´å¯ä»¥åœ¨go.workæ–‡ä»¶ä¸­å£°æ˜ï¼Œè¯¥æ–‡ä»¶æŒ‡å®šå·¥ä½œç©ºé—´ä¸­æ¯ä¸ªæ¨¡å—çš„æ¨¡å—ç›®å½•çš„ç›¸å¯¹è·¯å¾„ã€‚ å½“ä¸å­˜åœ¨go.workæ–‡ä»¶æ—¶ï¼Œå·¥ä½œåŒºç”±åŒ…å«å½“å‰ç›®å½•çš„å•ä¸ªæ¨¡å—ç»„æˆã€‚ å¤§å¤šæ•°ä¸æ¨¡å—ä¸€èµ·ä½¿ç”¨çš„goå­å‘½ä»¤åœ¨ç”±å½“å‰å·¥ä½œç©ºé—´ç¡®å®šçš„æ¨¡å—é›†ä¸Šè¿è¡Œã€‚ go mod initã€go mod whyã€go mod editã€go mod tidyã€go mod vendorå’Œgo getå§‹ç»ˆåœ¨å•ä¸ªä¸»æ¨¡å—ä¸Šè¿è¡Œã€‚ å‘½ä»¤é¦–å…ˆæ£€æŸ¥-workfileæ ‡å¿—æ¥ç¡®å®šå®ƒæ˜¯å¦åœ¨å·¥ä½œåŒºä¸Šä¸‹æ–‡ä¸­ã€‚å¦‚æœ-workfileè®¾ç½®ä¸ºoffï¼Œåˆ™è¯¥å‘½ä»¤å°†ä½äºå•æ¨¡å—ä¸Šä¸‹æ–‡ä¸­ã€‚ å¦‚æœå®ƒä¸ºç©ºæˆ–æœªæä¾›ï¼Œè¯¥å‘½ä»¤å°†æœç´¢å½“å‰å·¥ä½œç›®å½•ï¼Œç„¶åæ˜¯åç»­çˆ¶ç›®å½•ï¼Œä»¥æŸ¥æ‰¾æ–‡ä»¶go.workã€‚å¦‚æœæ‰¾åˆ°ä¸€ä¸ªæ–‡ä»¶ï¼Œè¯¥å‘½ä»¤å°†åœ¨å®ƒå®šä¹‰çš„å·¥ä½œç©ºé—´ä¸­è¿è¡Œï¼› å¦åˆ™ï¼Œå·¥ä½œåŒºå°†ä»…åŒ…å«åŒ…å«å·¥ä½œç›®å½•çš„æ¨¡å—ã€‚å¦‚æœ-workfileå‘½åä»¥.workç»“å°¾çš„ç°æœ‰æ–‡ä»¶çš„è·¯å¾„ï¼Œåˆ™å°†å¯ç”¨å·¥ä½œåŒºæ¨¡å¼ã€‚ä»»ä½•å…¶ä»–å€¼éƒ½æ˜¯é”™è¯¯ã€‚ go.workæ–‡ä»¶ä¸€èˆ¬ä¸ä¼ åˆ°gitä¸Šï¼Œåªæ˜¯æœ¬åœ°ä¸€ä¸ªå…¬å…±åŒºæ–‡ä»¶ã€‚ go.workæ–‡ä»¶ å·¥ä½œç©ºé—´ç”±åä¸ºgo.workï¼ŒUTF-8ç¼–ç æ–‡æœ¬æ–‡ä»¶å®šä¹‰ã€‚ go.workæ–‡ä»¶æ˜¯é¢å‘è¡Œçš„ã€‚æ¯è¡ŒåŒ…å«ä¸€ä¸ªæŒ‡ä»¤ï¼Œç”±å…³é”®å­—å’Œå‚æ•°ç»„æˆã€‚ ä¾‹å¦‚ï¼š go 1.18 use ./my/first/thing use ./my/second/thing replace example.com/bad/thing v1.4.5 =\u0026gt; example.com/good/thing v1.4.5 ä¸go.modæ–‡ä»¶ä¸€æ ·ï¼Œå¯ä»¥ä»ç›¸é‚»è¡Œä¸­åˆ†è§£å‡ºå‰å¯¼å…³é”®å­—æ¥åˆ›å»ºå—ã€‚ use ( ./my/first/thing ./my/second/thing ) goå‘½ä»¤æä¾›äº†å‡ ä¸ªç”¨äºæ“ä½œgo.workæ–‡ä»¶çš„å­å‘½ä»¤ã€‚ go work initï¼šåˆ›å»ºæ–°çš„go.workæ–‡ä»¶ã€‚ go work useï¼šå°†æ¨¡å—ç›®å½•æ·»åŠ åˆ°go.workæ–‡ä»¶ä¸­ã€‚ go work editï¼šæ‰§è¡Œä½çº§ç¼–è¾‘ã€‚ go work syncï¼šå°†å·¥ä½œåŒºæ„å»ºåˆ—è¡¨åŒæ­¥åˆ°æ¨¡å—ã€‚ Goç¨‹åºå¯ä»¥ä½¿ç”¨golang.org/x/mod/modfileåŒ…ä»¥ç¼–ç¨‹æ–¹å¼è¿›è¡Œç›¸åŒçš„æ›´æ”¹ã€‚ è¯æ±‡å…ƒç´  go.workæ–‡ä»¶ä¸­çš„è¯æ³•å…ƒç´ çš„å®šä¹‰æ–¹å¼ä¸go.modæ–‡ä»¶å®Œå…¨ç›¸åŒã€‚ è¯­æ³• go.workè¯­æ³•åœ¨ä¸‹é¢ä½¿ç”¨æ‰©å±•å·´ç§‘æ–¯-ç‘™å°”å½¢å¼(EBNF)æŒ‡å®šã€‚æœ‰å…³EBNFè¯­æ³•çš„è¯¦ç»†ä¿¡æ¯ï¼Œè¯·å‚é˜…Goè¯­è¨€è§„èŒƒä¸­çš„ç¬¦å·éƒ¨åˆ†ã€‚ 1 2 3 4 GoWork = { Directive } . Directive = GoDirective | UseDirective | ReplaceDirective . æ¢è¡Œç¬¦(newline)ã€æ ‡è¯†ç¬¦(ident)å’Œå­—ç¬¦ä¸²(string)åˆ†åˆ«è¡¨ç¤ºã€‚ æ¨¡å—è·¯å¾„å’Œç‰ˆæœ¬ç”¨ModulePathå’ŒVersionè¡¨ç¤ºã€‚æ¨¡å—è·¯å¾„å’Œç‰ˆæœ¬çš„æŒ‡å®šæ–¹å¼ä¸go.modæ–‡ä»¶å®Œå…¨ç›¸åŒã€‚ 1 2 ModulePath = ident | string . /* see restrictions above */ Version = ident | string . /* see restrictions above */ goæŒ‡ä»¤ æœ‰æ•ˆçš„go.workæ–‡ä»¶ä¸­éœ€è¦goæŒ‡ä»¤ã€‚ç‰ˆæœ¬å¿…é¡»æ˜¯æœ‰æ•ˆçš„Goå‘è¡Œç‰ˆæœ¬ï¼šä¸€ä¸ªæ­£æ•´æ•°ï¼Œåè·Ÿä¸€ä¸ªç‚¹å’Œä¸€ä¸ªéè´Ÿæ•´æ•°ï¼ˆä¾‹å¦‚ï¼Œ1.18ã€1.19ï¼‰ã€‚ goæŒ‡ä»¤æŒ‡ç¤ºgo.workæ–‡ä»¶æ‰“ç®—ä½¿ç”¨çš„goå·¥å…·é“¾ç‰ˆæœ¬ã€‚å¦‚æœå¯¹go.workæ–‡ä»¶æ ¼å¼è¿›è¡Œäº†æ›´æ”¹ï¼Œå·¥å…·é“¾çš„æœªæ¥ç‰ˆæœ¬å°†æ ¹æ®å…¶æŒ‡ç¤ºçš„ç‰ˆæœ¬è§£é‡Šæ–‡ä»¶ã€‚ ä¸€ä¸ªgo.workæ–‡ä»¶æœ€å¤šå¯ä»¥åŒ…å«ä¸€ä¸ªgoæŒ‡ä»¤ã€‚ 1 2 GoDirective = \u0026#34;go\u0026#34; GoVersion newline . GoVersion = string | ident . /* valid release version; see above */ ç¤ºä¾‹ï¼š go 1.18 useæŒ‡ä»¤ ç”¨æˆ·å°†ç£ç›˜ä¸Šçš„æ¨¡å—æ·»åŠ åˆ°å·¥ä½œç©ºé—´ä¸­çš„ä¸»è¦æ¨¡å—é›†ã€‚å®ƒçš„å‚æ•°æ˜¯åŒ…å«æ¨¡å—çš„go.modæ–‡ä»¶çš„ç›®å½•çš„ç›¸å¯¹è·¯å¾„ã€‚ ä½¿ç”¨useæŒ‡ä»¤ä¸ä¼šæ·»åŠ åŒ…å«åœ¨å…¶å‚æ•°ç›®å½•çš„å­ç›®å½•ä¸­çš„æ¨¡å—ã€‚ è¿™äº›æ¨¡å—å¯ä»¥é€šè¿‡åŒ…å«å…¶go.modæ–‡ä»¶çš„ç›®å½•æ·»åŠ åˆ°å•ç‹¬çš„ä½¿ç”¨æŒ‡ä»¤ä¸­ã€‚ 1 2 3 UseDirective = \u0026#34;use\u0026#34; ( UseSpec | \u0026#34;(\u0026#34; newline { UseSpec } \u0026#34;)\u0026#34; newline ) . UseSpec = FilePath newline . FilePath = /* platform-specific relative or absolute file path */ ç¤ºä¾‹ï¼š use ./mymod // example.com/mymod use ( ../othermod ./subdir/thirdmod ) replaceæŒ‡ä»¤ ä¸go.modæ–‡ä»¶ä¸­çš„replaceæŒ‡ä»¤ç±»ä¼¼ï¼Œgo.workæ–‡ä»¶ä¸­çš„replaceæŒ‡ä»¤å°†æ¨¡å—çš„ç‰¹å®šç‰ˆæœ¬æˆ–æ¨¡å—çš„æ‰€æœ‰ç‰ˆæœ¬çš„å†…å®¹æ›¿æ¢ä¸ºå…¶ä»–åœ°æ–¹çš„å†…å®¹ã€‚ go.workä¸­çš„é€šé…ç¬¦æ›¿æ¢ä¼šè¦†ç›–go.modæ–‡ä»¶ä¸­ç‰¹å®šäºç‰ˆæœ¬çš„æ›¿æ¢ã€‚ go.workæ–‡ä»¶ä¸­çš„replaceæŒ‡ä»¤ä¼šè¦†ç›–å·¥ä½œåŒºæ¨¡å—ä¸­ç›¸åŒæ¨¡å—æˆ–æ¨¡å—ç‰ˆæœ¬çš„ä»»ä½•æ›¿æ¢ã€‚ 1 2 3 4 ReplaceDirective = \u0026#34;replace\u0026#34; ( ReplaceSpec | \u0026#34;(\u0026#34; newline { ReplaceSpec } \u0026#34;)\u0026#34; newline ) . ReplaceSpec = ModulePath [ Version ] \u0026#34;=\u0026gt;\u0026#34; FilePath newline | ModulePath [ Version ] \u0026#34;=\u0026gt;\u0026#34; ModulePath Version newline . FilePath = /* platform-specific relative or absolute file path */ ç¤ºä¾‹ï¼š replace golang.org/x/net v1.2.3 =\u0026gt; example.com/fork/net v1.4.5 replace ( golang.org/x/net v1.2.3 =\u0026gt; example.com/fork/net v1.4.5 golang.org/x/net =\u0026gt; example.com/fork/net v1.4.5 golang.org/x/net v1.2.3 =\u0026gt; ./fork/net golang.org/x/net =\u0026gt; ./fork/net ) é”™è¯¯çš„go.work åŒæ—¶åœ¨useå’ŒreplaceæŒ‡å®šç›¸åŒçš„æœ¬åœ°è·¯å¾„ã€‚åŒæ—¶æŒ‡å®š./exampleã€‚ go 1.18 use ( ./hello ./example ) replace ( github.com/link1st/example =\u0026gt; ./example ) ","permalink":"https://heliu.site/posts/golang/package/go-work/","summary":"Golang go.workæ–‡ä»¶å†…å®¹ä»‹ç»ã€‚","title":"go.work æ–‡ä»¶"},{"content":" æ¨¡å—ç”±å…¶æ ¹ç›®å½•ä¸­åä¸ºgo.modï¼ŒUTF-8ç¼–ç æ–‡æœ¬æ–‡ä»¶å®šä¹‰ã€‚ go.modæ–‡ä»¶æ˜¯é¢å‘è¡Œçš„ã€‚æ¯è¡ŒåŒ…å«ä¸€ä¸ªæŒ‡ä»¤ï¼Œç”±å…³é”®å­—åè·Ÿå‚æ•°ç»„æˆã€‚ä¾‹å¦‚ï¼š 1 2 3 4 5 6 7 8 9 module example.com/my/thing go 1.12 require example.com/other/thing v1.0.2 require example.com/new/thing/v2 v2.3.4 exclude example.com/old/thing v1.2.3 replace example.com/bad/thing v1.4.5 =\u0026gt; example.com/good/thing v1.4.5 retract [v1.9.0, v1.9.5] å‰å¯¼å…³é”®å­—å¯ä»¥ä»ç›¸é‚»è¡Œä¸­åˆ†è§£å‡ºæ¥ä»¥åˆ›å»ºä¸€ä¸ªå—ï¼Œå°±åƒåœ¨Go importä¸­ä¸€æ ·ã€‚ 1 2 3 4 require ( example.com/new/thing/v2 v2.3.4 example.com/old/thing v1.2.3 ) go.modæ–‡ä»¶è¢«è®¾è®¡ä¸ºäººç±»å¯è¯»å’Œæœºå™¨å¯å†™ã€‚goå‘½ä»¤æä¾›äº†å‡ ä¸ªæ›´æ”¹go.modæ–‡ä»¶çš„å­å‘½ä»¤ã€‚ä¾‹å¦‚ï¼š go getå¯ä»¥å‡çº§æˆ–é™çº§ç‰¹å®šçš„ä¾èµ–é¡¹ã€‚ åŠ è½½æ¨¡å—å›¾çš„å‘½ä»¤å°†åœ¨éœ€è¦æ—¶è‡ªåŠ¨æ›´æ–°go.modã€‚ go mod editå¯ä»¥æ‰§è¡Œä½çº§ç¼–è¾‘ã€‚ ä¸»æ¨¡å—ä»¥åŠä½¿ç”¨æœ¬åœ°æ–‡ä»¶è·¯å¾„æŒ‡å®šçš„ä»»ä½•æ›¿æ¢æŒ‡ä»¤æ›¿æ¢éƒ½éœ€è¦ä¸€ä¸ªgo.modæ–‡ä»¶ã€‚ä½†æ˜¯ï¼Œç¼ºå°‘æ˜ç¡®çš„go.modæ–‡ä»¶çš„æ¨¡å—å¯èƒ½ä»ç„¶éœ€è¦ä½œä¸ºä¾èµ–é¡¹ï¼Œæˆ–è€…ç”¨ä½œä½¿ç”¨æ¨¡å—ã€‚ è¯æ±‡å…ƒç´  å¯¹ä¸€ä¸ªgo.modæ–‡ä»¶è¿›è¡Œåˆ†æï¼Œå…¶å†…å®¹è¢«åˆ†æˆæ ‡è®°å½¢å¼ã€‚ æœ‰å‡ ç§æ ‡è®°ï¼šç©ºæ ¼ã€æ³¨é‡Šã€æ ‡ç‚¹ç¬¦å·ã€å…³é”®å­—ã€æ ‡è¯†ç¬¦å’Œå­—ç¬¦ä¸²ã€‚ ç©ºç™½ï¼šç”±ç©ºæ ¼(U+0020)ã€åˆ¶è¡¨ç¬¦(U+0009)ã€å›è½¦(U+000D)å’Œæ¢è¡Œç¬¦(U+000A)ç»„æˆã€‚ é™¤äº†æ¢è¡Œç¬¦ä¹‹å¤–çš„ç©ºç™½å­—ç¬¦æ²¡æœ‰ä»»ä½•ä½œç”¨ï¼Œé™¤éåˆ†éš”æœ¬æ¥ä¸å…¶ä»–ç»„åˆçš„æ ‡è®°ã€‚ æ¢è¡Œç¬¦æ˜¯é‡è¦çš„æ ‡è®°ã€‚ æ³¨é‡Šï¼šä»¥//å¼€å§‹åˆ°è¡Œå°¾ã€‚/**/æ³¨é‡Šä¸å…è®¸æ·»åŠ æ³¨é‡Šæ–‡æ¡ˆã€‚ æ ‡ç‚¹ç¬¦å·ï¼šåŒ…æ‹¬ï¼ˆ,ï¼‰å’Œ=\u0026gt;ã€‚ å…³é”®å­—ï¼šæ˜¯åŒºåˆ†go.modæ–‡ä»¶ä¸­ä¸åŒç§ç±»çš„æŒ‡ä»¤ã€‚ å…è®¸çš„å…³é”®å­—moduleï¼Œgoï¼Œrequireï¼Œreplaceï¼Œexcludeï¼Œretractã€‚ æ ‡è¯†ç¬¦ï¼šéç©ºç™½å­—ç¬¦çš„åºåˆ—ï¼Œä¾‹å¦‚æ¨¡å—è·¯å¾„æˆ–è¯­ä¹‰ç‰ˆæœ¬ã€‚ å­—ç¬¦ä¸²ï¼šå¸¦å¼•å·çš„å­—ç¬¦åºåˆ—ï¼Œæœ‰ä¸¤ç§å­—ç¬¦ä¸²ï¼š ä»¥å¼•å·(\u0026quot;,U+0022)å¼€å¤´å’Œç»“å°¾çš„è§£é‡Šå­—ç¬¦ä¸²ã€‚ è§£é‡Šçš„å­—ç¬¦ä¸²å¯èƒ½åŒ…å«ç”±åæ–œæ (\\,U+005C)åè·Ÿå¦ä¸€ä¸ªå­—ç¬¦ç»„æˆçš„è½¬ä¹‰åºåˆ—ã€‚ è½¬ä¹‰å¼•å·(\\\u0026quot;)ä¸ä¼šç»ˆæ­¢å·²è§£é‡Šçš„å­—ç¬¦ä¸²ã€‚ è§£é‡Šå­—ç¬¦ä¸²çš„ä¸å¸¦å¼•å·çš„å€¼æ˜¯å¼•å·ä¹‹é—´çš„å­—ç¬¦åºåˆ—ï¼Œæ¯ä¸ªè½¬ä¹‰åºåˆ—éƒ½è¢«åæ–œæ åé¢çš„å­—ç¬¦\\\u0026ldquo;æ›¿æ¢ï¼ˆä¾‹å¦‚ï¼Œè¢«æ›¿æ¢ä¸º\u0026rdquo;ï¼Œ\\nè¢«æ›¿æ¢ä¸ºnï¼‰ã€‚ ä»¥é‡éŸ³ç¬¦ (`,U+0060)å¼€å¤´å’Œç»“å°¾çš„åŸå§‹å­—ç¬¦ä¸²ã€‚ ç›¸æ¯”ä¹‹ä¸‹ï¼ŒåŸå§‹å­—ç¬¦ä¸²çš„ä¸å¸¦å¼•å·çš„å€¼åªæ˜¯é‡éŸ³ç¬¦ä¹‹é—´çš„å­—ç¬¦åºåˆ—ï¼Œåæ–œæ åœ¨åŸå§‹å­—ç¬¦ä¸²ä¸­æ²¡æœ‰ç‰¹æ®Šå«ä¹‰ã€‚ æ ‡è¯†ç¬¦å’Œå­—ç¬¦ä¸²åœ¨go.modè¯­æ³•ä¸­æ˜¯å¯ä»¥äº’æ¢çš„ã€‚ æ¨¡å—è·¯å¾„å’Œç‰ˆæœ¬ go.modæ–‡ä»¶ä¸­çš„å¤§å¤šæ•°æ ‡è¯†ç¬¦å’Œå­—ç¬¦ä¸²è¦ä¹ˆæ˜¯æ¨¡å—è·¯å¾„ï¼Œè¦ä¹ˆæ˜¯ç‰ˆæœ¬ã€‚ æ¨¡å—è·¯å¾„å¿…é¡»æ»¡è¶³ä»¥ä¸‹è¦æ±‚ï¼š è·¯å¾„å¿…é¡»ç”±ä¸€ä¸ªæˆ–å¤šä¸ªä»¥æ–œçº¿(/,U+002F)åˆ†éš”çš„è·¯å¾„å…ƒç´ ç»„æˆï¼Œå®ƒä¸èƒ½ä»¥æ–œçº¿å¼€å¤´æˆ–ç»“å°¾ã€‚ æ¯ä¸ªè·¯å¾„æ˜¯ç”±å¤šä¸ªASCIIå­—æ¯ï¼ŒASCIIæ•°å­—æˆ–éç©ºå­—ç¬¦ä¸²ï¼Œå’Œæœ‰é™çš„ASCIIæ ‡ç‚¹ç¬¦å·ï¼ˆ-ã€.ã€_ã€~ï¼‰ã€‚ è·¯å¾„å…ƒç´ ä¸èƒ½ä»¥ç‚¹(., U+002E)å¼€å§‹æˆ–ç»“æŸã€‚ ç›´åˆ°ç¬¬ä¸€ä¸ªç‚¹çš„å…ƒç´ å‰ç¼€ä¸èƒ½æ˜¯Windowsä¸Šçš„ä¿ç•™æ–‡ä»¶åï¼Œæ— è®ºå¤§å°å†™ï¼ˆCONã€com1ã€NuLç­‰ï¼‰ï¼Œä¸èƒ½ä»¥con.æˆ–com1.æˆ–Nul.ç­‰å¼€å¤´ã€‚ ç¬¬ä¸€ä¸ªç‚¹ä¹‹å‰çš„å…ƒç´ å‰ç¼€ä¸å¾—ä»¥æ³¢æµªå·(~)åè·Ÿä¸€ä¸ªæˆ–å¤šä¸ªæ•°å­—ï¼ˆå¦‚EXAMPL~1.COMï¼‰ç»“å°¾ã€‚ å¦‚æœæ¨¡å—è·¯å¾„å‡ºç°åœ¨requireæŒ‡ä»¤ä¸­å¹¶ä¸”æ²¡æœ‰è¢«æ›¿æ¢ï¼Œæˆ–è€…æ¨¡å—è·¯å¾„å‡ºç°åœ¨replaceæŒ‡ä»¤çš„å³ä¾§ï¼Œåˆ™è¯¥goå‘½ä»¤å¯èƒ½éœ€è¦ä¸‹è½½å…·æœ‰è¯¥è·¯å¾„çš„æ¨¡å—ï¼Œå¹¶ä¸”å¿…é¡»æ»¡è¶³ä¸€äº›é™„åŠ è¦æ±‚ã€‚ å‰å¯¼è·¯å¾„å…ƒç´ ï¼ˆç›´åˆ°ç¬¬ä¸€ä¸ªæ–œæ ï¼Œå¦‚æœæœ‰çš„è¯ï¼‰ï¼ŒæŒ‰ç…§çº¦å®šï¼ŒåŸŸåå¿…é¡»åªåŒ…å«å°å†™ASCIIå­—æ¯ã€ASCIIæ•°å­—ã€ç‚¹ï¼ˆ.,U+002Eï¼‰å’Œç ´æŠ˜å·ï¼ˆ-,U+002Dï¼‰å®ƒå¿…é¡»è‡³å°‘åŒ…å«ä¸€ä¸ªç‚¹ï¼Œå¹¶ä¸”ä¸èƒ½ä»¥ç ´æŠ˜å·å¼€å¤´ã€‚ å¯¹äºå½¢å¼çš„æœ€ç»ˆè·¯å¾„å…ƒç´ /vNåœ¨é‚£é‡ŒNæ˜¯æ•°å­—ï¼ˆASCIIæ•°å­—å’Œç‚¹ï¼‰ï¼ŒNä¸å¾—å¸¦å‰å¯¼é›¶çš„å¼€å§‹ï¼Œä¸€å®šä¸èƒ½/v1ï¼Œä¸€å®šä¸èƒ½åŒ…å«ä»»ä½•åœ†ç‚¹ã€‚ å¯¹äºä»¥gopkg.in/å¼€å¤´çš„è·¯å¾„ï¼Œæ­¤è¦æ±‚å°†æ›¿æ¢ä¸ºè·¯å¾„éµå¾ªgopkg.inæœåŠ¡çº¦å®šçš„è¦æ±‚ã€‚ go.modæ–‡ä»¶ä¸­çš„ç‰ˆæœ¬å¯èƒ½æ˜¯è§„èŒƒçš„æˆ–éè§„èŒƒçš„ï¼Œè§„èŒƒç‰ˆæœ¬ä»¥å­—æ¯vå¼€å¤´ï¼Œåè·Ÿç¬¦åˆè¯­ä¹‰ç‰ˆæœ¬æ§åˆ¶2.0.0è§„èŒƒçš„è¯­ä¹‰ç‰ˆæœ¬ã€‚ éè§„èŒƒç‰ˆæœ¬åªå…è®¸åœ¨ä¸»æ¨¡å—çš„go.modæ–‡ä»¶ä¸­ï¼Œè¯¥goå‘½ä»¤å°†å°è¯•æ—¶ï¼Œå®ƒä¼šè‡ªåŠ¨ç”¨ç­‰æ•ˆçš„è§„èŒƒç‰ˆæœ¬æ›¿æ¢æ¯ä¸ªéè§„èŒƒç‰ˆæœ¬æ›´æ–°çš„go.modæ–‡ä»¶ã€‚ åœ¨ä¸€ä¸ªæ¨¡å—è·¯å¾„ä¸ç‰ˆæœ¬ç›¸å…³çš„åœ°æ–¹ï¼ˆå¦‚requireï¼Œreplaceå’ŒexcludeæŒ‡ä»¤ï¼‰ï¼Œæœ€åçš„è·¯å¾„å…ƒç´ å¿…é¡»ä¸ç‰ˆæœ¬æ˜¯ä¸€è‡´çš„ï¼Œè¯·å‚é˜…ä¸»è¦ç‰ˆæœ¬åç¼€ã€‚ è¯­æ³• go.modä¸‹é¢ä½¿ç”¨æ‰©å±•å·´ç§‘æ–¯-è¯ºå°”å½¢å¼(EBNF)æŒ‡å®šè¯­æ³•ã€‚æœ‰å…³EBNFè¯­æ³•çš„è¯¦ç»†ä¿¡æ¯ï¼Œè¯·å‚é˜…Goè¯­è¨€è§„èŒƒä¸­çš„ç¬¦å·éƒ¨åˆ†ã€‚ 1 2 3 4 5 6 7 GoMod = { Directive } . Directive = ModuleDirective | GoDirective | RequireDirective | ExcludeDirective | ReplaceDirective | RetractDirective . æ¢è¡Œï¼Œæ ‡è¯†ç¬¦å’Œå­—ç¬¦ä¸²åˆ†åˆ«æ ‡æ³¨newlineï¼Œidentå’Œ stringã€‚ æ¨¡å—è·¯å¾„å’Œç‰ˆæœ¬ç”¨ModulePathå’Œè¡¨ç¤ºVersionã€‚ 1 2 ModulePath = ident | string . /* see restrictions above */ Version = ident | string . /* see restrictions above */ moduleæ¨¡å—æŒ‡ä»¤ ä¸€ä¸ªmoduleæŒ‡ä»¤å®šä¹‰äº†ä¸»æ¨¡å—çš„è·¯å¾„ã€‚ä¸€ä¸ªgo.modæ–‡ä»¶å¿…é¡»åªåŒ…å«ä¸€ä¸ªmoduleæŒ‡ä»¤ã€‚ moduleæŒ‡ä»¤å®šä¹‰äº†æ¨¡å—åç§°ï¼š ModuleDirective = \u0026quot;module\u0026quot; ( ModulePath | \u0026quot;(\u0026quot; newline ModulePath newline \u0026quot;)\u0026quot; ) newline . ç¤ºä¾‹ï¼š module golang.org/x/net Deprecatedï¼šå¼ƒç”¨æ ‡å¿— å¯ä»¥åœ¨Deprecated:æ®µè½å¼€å¤´åŒ…å«å­—ç¬¦ä¸²ï¼ˆåŒºåˆ†å¤§å°å†™ï¼‰çš„æ³¨é‡Šå—ä¸­å°†æ¨¡å—æ ‡è®°ä¸ºå·²å¼ƒç”¨ã€‚ å¼ƒç”¨æ¶ˆæ¯åœ¨å†’å·ä¹‹åå¼€å§‹å¹¶è¿è¡Œåˆ°æ®µè½çš„æœ«å°¾ã€‚æ³¨é‡Šå¯èƒ½å‡ºç°åœ¨moduleæŒ‡ä»¤ä¹‹å‰æˆ–ä¹‹åå‡ºç°åœ¨åŒä¸€è¡Œã€‚ ç¤ºä¾‹ï¼š // Deprecated: æ”¹ç”¨ example.com/mod/v2 module example.com/mod ä»Go 1.17å¼€å§‹ï¼Œgo list -m -uæ£€æŸ¥æ„å»ºåˆ—è¡¨ä¸­æ‰€æœ‰å¼ƒç”¨æ¨¡å—çš„ä¿¡æ¯ã€‚go getæ£€æŸ¥æ„å»ºåœ¨å‘½ä»¤è¡Œä¸Šå‘½åçš„åŒ…æ‰€éœ€çš„ä¸æ¨èä½¿ç”¨çš„æ¨¡å—ã€‚ å½“è¯¥goå‘½ä»¤æ£€ç´¢æ¨¡å—çš„å¼ƒç”¨ä¿¡æ¯æ—¶ï¼Œå®ƒä¼šä»ä¸@latestç‰ˆæœ¬æŸ¥è¯¢åŒ¹é…çš„ç‰ˆæœ¬åŠ è½½go.modæ–‡ä»¶ï¼Œè€Œä¸è€ƒè™‘æ’¤å›çš„æˆ–æ’é™¤çš„ã€‚goå‘½ä»¤ä»åŒä¸€ä¸ªgo.modæ–‡ä»¶åŠ è½½æ’¤å›ã€‚ è¦å¼ƒç”¨æ¨¡å—ï¼Œä½œè€…å¯ä»¥æ·»åŠ // Deprecated:è¯„è®ºå¹¶æ ‡è®°æ–°ç‰ˆæœ¬ã€‚ä½œè€…å¯èƒ½ä¼šåœ¨æ›´é«˜ç‰ˆæœ¬ä¸­æ›´æ”¹æˆ–åˆ é™¤å¼ƒç”¨æ¶ˆæ¯ã€‚ å¼ƒç”¨é€‚ç”¨äºæ¨¡å—çš„æ‰€æœ‰æ¬¡è¦ç‰ˆæœ¬ã€‚ä»¥v2ä¸ºä¾‹ï¼Œä¸»ç‰ˆæœ¬é«˜äºè¢«è®¤ä¸ºæ˜¯å•ç‹¬çš„æ¨¡å—ï¼Œå› ä¸ºå®ƒä»¬çš„ä¸»ç‰ˆæœ¬åç¼€ä¸ºå®ƒä»¬æä¾›äº†ä¸åŒçš„æ¨¡å—è·¯å¾„ã€‚ å¼ƒç”¨æ¶ˆæ¯æ—¨åœ¨é€šçŸ¥ç”¨æˆ·è¯¥æ¨¡å—ä¸å†å—æ”¯æŒå¹¶æä¾›è¿ç§»è¯´æ˜ï¼Œä¾‹å¦‚è¿ç§»åˆ°æœ€æ–°çš„ä¸»è¦ç‰ˆæœ¬ã€‚ä¸èƒ½å¼ƒç”¨å•ä¸ªæ¬¡è¦ç‰ˆæœ¬å’Œè¡¥ä¸ç‰ˆæœ¬ï¼Œretractå¯èƒ½æ›´é€‚åˆå•ä¸ªç‰ˆæœ¬ã€‚ go ç‰ˆæœ¬æŒ‡ä»¤ ä¸€ä¸ªgoæŒ‡ä»¤è¡¨æ˜ä¸€ä¸ªæ¨¡å—æ˜¯åœ¨å‡è®¾Goçš„ç»™å®šç‰ˆæœ¬çš„è¯­ä¹‰çš„æƒ…å†µä¸‹ç¼–å†™çš„ã€‚ ç‰ˆæœ¬å¿…é¡»æ˜¯æœ‰æ•ˆçš„Goå‘å¸ƒç‰ˆæœ¬ï¼šä¸€ä¸ªæ­£æ•´æ•°ï¼Œåè·Ÿä¸€ä¸ªç‚¹å’Œä¸€ä¸ªéè´Ÿæ•´æ•°ï¼ˆä¾‹å¦‚ï¼Œ1.9,1.14ï¼‰ã€‚ç¤ºä¾‹ï¼šgo 1.14ã€‚ goæŒ‡ä»¤æœ€åˆæ—¨åœ¨æ”¯æŒGoè¯­è¨€çš„å‘åä¸å…¼å®¹æ›´æ”¹ï¼ˆè¯·å‚é˜…Go 2 transitionï¼‰ã€‚ è‡ªå¼•å…¥æ¨¡å—ä»¥æ¥ï¼Œæ²¡æœ‰å‘ç”Ÿä¸å…¼å®¹çš„è¯­è¨€æ›´æ”¹ï¼Œä½†è¯¥goæŒ‡ä»¤ä»ç„¶å½±å“æ–°è¯­è¨€åŠŸèƒ½çš„ä½¿ç”¨ï¼š å¯¹äºæ¨¡å—å†…çš„åŒ…ï¼Œç¼–è¯‘å™¨æ‹’ç»ä½¿ç”¨åœ¨goæŒ‡ä»¤æŒ‡å®šçš„ç‰ˆæœ¬ä¹‹åå¼•å…¥çš„è¯­è¨€åŠŸèƒ½ã€‚ä¾‹å¦‚ï¼Œå¦‚æœä¸€ä¸ªæ¨¡å—æœ‰æŒ‡ä»¤go 1.12ï¼Œå®ƒçš„åŒ…å¯èƒ½ä¸ä¼šä½¿ç”¨åƒ1_000_000 Go 1.13ä¸­å¼•å…¥çš„æ•°å­—æ–‡å­—ã€‚ å¦‚æœè¾ƒæ—§çš„Goç‰ˆæœ¬æ„å»ºæ¨¡å—çš„åŒ…ä¹‹ä¸€å¹¶é‡åˆ°ç¼–è¯‘é”™è¯¯ï¼Œåˆ™è¯¥é”™è¯¯ä¼šæŒ‡å‡ºè¯¥æ¨¡å—æ˜¯ä¸ºè¾ƒæ–°çš„Goç‰ˆæœ¬ç¼–å†™çš„ã€‚å‡è®¾ä¸€ä¸ªæ¨¡å—æœ‰go 1.13ä¸€ä¸ªåŒ…ä½¿ç”¨æ•°å­—æ–‡å­—1_000_000ã€‚å¦‚æœè¯¥åŒ…æ˜¯ç”¨Go 1.12æ„å»ºçš„ï¼Œç¼–è¯‘å™¨ä¼šæ³¨æ„åˆ°ä»£ç æ˜¯ä¸ºGo 1.13ç¼–å†™çš„ã€‚ åœ¨go 1.17æˆ–æ›´é«˜ç‰ˆæœ¬ï¼š go.modæ–‡ä»¶ä¸ºæ¯ä¸ªæ¨¡å—åŒ…å«ä¸€ä¸ªæ˜¾å¼çš„requireæŒ‡ä»¤ï¼Œè¯¥æŒ‡ä»¤æä¾›ç”±ä¸»æ¨¡å—ä¸­çš„åŒ…æˆ–æµ‹è¯•ä¼ é€’å¯¼å…¥çš„ä»»ä½•åŒ…ã€‚ï¼ˆåœ¨go 1.16åŠæ›´ä½ç‰ˆæœ¬ä¸­ï¼Œä»…å½“æœ€å°ç‰ˆæœ¬é€‰æ‹©ä¼šé€‰æ‹©ä¸åŒç‰ˆæœ¬æ—¶æ‰åŒ…å«é—´æ¥ä¾èµ–é¡¹ã€‚ï¼‰æ­¤é¢å¤–ä¿¡æ¯å¯ç”¨æ¨¡å—å›¾ä¿®å‰ªå’Œå»¶è¿Ÿæ¨¡å—åŠ è½½ã€‚ ç”±äºå¯èƒ½å­˜åœ¨// indirectæ¯”ä»¥å‰goç‰ˆæœ¬æ›´å¤šçš„ä¾èµ–é¡¹ ï¼Œå› æ­¤é—´æ¥ä¾èµ–é¡¹è®°å½•åœ¨go.modæ–‡ä»¶ä¸­çš„å•ç‹¬å—ä¸­ã€‚ go mod vendorçœç•¥äº†vendorä¾èµ–çš„go.modå’Œgo.sumæ–‡ä»¶ã€‚ï¼ˆè¿™å…è®¸åœ¨vendorçš„å­ç›®å½•ä¸­è°ƒç”¨goå‘½ä»¤æ¥è¯†åˆ«æ­£ç¡®çš„ä¸»æ¨¡å—ã€‚ï¼‰ go mod vendorå°†goæ¯ä¸ªä¾èµ–é¡¹go.modæ–‡ä»¶çš„ç‰ˆæœ¬è®°å½•åœ¨vendor/modules.txtã€‚ ä¸€ä¸ªgo.modæ–‡ä»¶æœ€å¤šå¯ä»¥åŒ…å«ä¸€ä¸ªgoæŒ‡ä»¤ã€‚å¦‚æœå½“å‰Goç‰ˆæœ¬ä¸å­˜åœ¨ï¼Œå¤§å¤šæ•°å‘½ä»¤ä¼šæ·»åŠ ä¸€ä¸ªgoæŒ‡ä»¤ã€‚ 1 2 GoDirective = \u0026#34;go\u0026#34; GoVersion newline . GoVersion = string | ident . /* valid release version; see above */ require éœ€æ±‚æŒ‡ä»¤ ä¸€ä¸ªrequireæŒ‡ä»¤å£°æ˜ä¸€ä¸ªç»™å®šçš„æ¨¡å—ä¾èµ–çš„æœ€ä½ç‰ˆæœ¬ã€‚å¯¹äºæ¯ä¸ªæ‰€éœ€çš„æ¨¡å—ç‰ˆæœ¬ï¼Œgoå‘½ä»¤åŠ è½½è¯¥ç‰ˆæœ¬çš„go.modæ–‡ä»¶å¹¶åˆå¹¶æ¥è‡ªè¯¥æ–‡ä»¶çš„requireã€‚åŠ è½½æ‰€æœ‰requireåï¼Œgoå‘½ä»¤å°†ä½¿ç”¨æœ€å°ç‰ˆæœ¬é€‰æ‹© (MVS)è§£å†³å®ƒä»¬ä»¥ç”Ÿæˆæ„å»ºåˆ—è¡¨ã€‚ goå‘½ä»¤ä¼šè‡ªåŠ¨ä¸ºæŸäº›requireæ·»åŠ // indirecté—´æ¥ä¾èµ–æ³¨é‡Šã€‚// indirectè¡¨ç¤ºä¸»æ¨¡å—ä¸­çš„ä»»ä½•åŒ…éƒ½ä¸ä¼šç›´æ¥å¯¼å…¥æ‰€éœ€æ¨¡å—ä¸­çš„åŒ…ã€‚ å¦‚æœgoæŒ‡ä»¤æŒ‡å®šgo 1.16æˆ–æ›´ä½ç‰ˆæœ¬ï¼Œåˆ™å½“æ‰€é€‰æ¨¡å—çš„ç‰ˆæœ¬é«˜äºä¸»æ¨¡å—çš„å…¶ä»–ä¾èµ–é¡¹å·²ç»æš—ç¤ºï¼ˆä¼ é€’ï¼‰çš„ç‰ˆæœ¬æ—¶ï¼Œgoå‘½ä»¤ä¼šæ·»åŠ ä¸€ä¸ªindirectã€‚è¿™å¯èƒ½æ˜¯ç”±äºæ˜¾å¼å‡çº§ï¼ˆgo get -u ./...ï¼‰ã€åˆ é™¤äº†å…ˆå‰å¼ºåŠ è¦æ±‚çš„å…¶ä»–ä¾èµ–é¡¹ï¼ˆgo mod tidyï¼‰ï¼Œæˆ–è€…å¯¼å…¥äº†ä¸€ä¸ªåŒ…è€Œæ²¡æœ‰ç›¸åº”è¦æ±‚çš„ä¾èµ–é¡¹go.modæ–‡ä»¶ï¼ˆä¾‹å¦‚å®Œå…¨ç¼ºå°‘go.modæ–‡ä»¶çš„ä¾èµ–é¡¹ï¼‰ åœ¨go 1.17åŠæ›´é«˜ç‰ˆæœ¬ä¸­ï¼Œgoå‘½ä»¤ä¸ºæ¯ä¸ªæ¨¡å—æ·»åŠ äº†ä¸€ä¸ªindirectï¼Œè¯¥æ¨¡å—æä¾›ç”±ä¸»æ¨¡å—ä¸­çš„åŒ…æˆ–æµ‹è¯•å¯¼å…¥ï¼ˆç”šè‡³indirectï¼‰çš„ä»»ä½•åŒ…ï¼Œæˆ–ä½œä¸ºå‚æ•°ä¼ é€’ç»™go getã€‚ è¿™äº›æ›´å…¨é¢çš„è¦æ±‚æ”¯æŒæ¨¡å—å›¾ä¿®å‰ªå’Œå»¶è¿Ÿæ¨¡å—åŠ è½½ã€‚ 1 2 RequireDirective = \u0026#34;require\u0026#34; ( RequireSpec | \u0026#34;(\u0026#34; newline { RequireSpec } \u0026#34;)\u0026#34; newline ) . RequireSpec = ModulePath Version newline . ç¤ºä¾‹ï¼š 1 2 3 4 5 6 require golang.org/x/net v1.2.3 require ( golang.org/x/crypto v1.4.5 // indirect golang.org/x/text v1.6.7 ) exclude æ’é™¤æŒ‡ä»¤ excludeæŒ‡ä»¤é˜²æ­¢æ¨¡å—ç‰ˆæœ¬è¢«goå‘½ä»¤åŠ è½½ã€‚(æ’é™¤æŒ‡å®šçš„æ¨¡å—ç‰ˆæœ¬) ä»Go 1.16å¼€å§‹ï¼Œå¦‚æœä»»ä½•go.modæ–‡ä»¶ä¸­çš„requireæŒ‡ä»¤å¼•ç”¨çš„ç‰ˆæœ¬è¢«ä¸»æ¨¡å—çš„go.modæ–‡ä»¶ä¸­çš„excludeæŒ‡ä»¤æ’é™¤ï¼Œåˆ™è¯¥requireå°†è¢«å¿½ç•¥ã€‚ è¿™å¯èƒ½ä¼šå¯¼è‡´åƒgo getå’Œgo mod tidyè¿™æ ·çš„å‘½ä»¤å°†æ›´é«˜ç‰ˆæœ¬çš„æ–°è¦æ±‚æ·»åŠ åˆ°go.modï¼Œå¦‚æœåˆé€‚ï¼Œå¸¦æœ‰// indirectã€‚ åœ¨Go 1.16ä¹‹å‰ï¼Œå¦‚æœä¸€ä¸ªæ’é™¤çš„ç‰ˆæœ¬è¢«requireæŒ‡ä»¤å¼•ç”¨ï¼Œgoå‘½ä»¤ä¼šåˆ—å‡ºæ¨¡å—çš„å¯ç”¨ç‰ˆæœ¬ï¼ˆå¦‚go list -m -versionsæ‰€ç¤ºï¼‰å¹¶åŠ è½½ä¸‹ä¸€ä¸ªæ›´é«˜çš„éæ’é™¤ç‰ˆæœ¬ã€‚è¿™å¯èƒ½å¯¼è‡´ä¸ç¡®å®šçš„ç‰ˆæœ¬é€‰æ‹©ï¼Œå› ä¸ºä¸‹ä¸€ä¸ªæ›´é«˜çš„ç‰ˆæœ¬å¯èƒ½ä¼šéšç€æ—¶é—´çš„æ¨ç§»è€Œæ”¹å˜ã€‚ä¸ºæ­¤ç›®çš„ï¼Œå‘è¡Œç‰ˆå’Œé¢„å‘è¡Œç‰ˆéƒ½è¢«è€ƒè™‘åœ¨å†…ï¼Œä½†ä¼ªç‰ˆæœ¬åˆ™ä¸ç„¶ã€‚å¦‚æœæ²¡æœ‰æ›´é«˜ç‰ˆæœ¬ï¼Œgoå‘½ä»¤æŠ¥é”™ã€‚ excludeæŒ‡ä»¤ä»…é€‚ç”¨äºä¸»æ¨¡å—çš„go.modæ–‡ä»¶ï¼Œåœ¨å…¶ä»–æ¨¡å—ä¸­è¢«å¿½ç•¥ã€‚æœ‰å…³è¯¦ç»†ä¿¡æ¯ï¼Œè¯·å‚é˜…æœ€å°ç‰ˆæœ¬é€‰æ‹©ã€‚ 1 2 ExcludeDirective = \u0026#34;exclude\u0026#34; ( ExcludeSpec | \u0026#34;(\u0026#34; newline { ExcludeSpec } \u0026#34;)\u0026#34; newline ) . ExcludeSpec = ModulePath Version newline . ç¤ºä¾‹ï¼š 1 2 3 4 5 6 exclude golang.org/x/net v1.2.3 exclude ( golang.org/x/crypto v1.4.5 golang.org/x/text v1.6.7 ) replace æ›¿æ¢æŒ‡ä»¤ replaceæŒ‡ä»¤ç”¨åœ¨åˆ«å¤„æ‰¾åˆ°çš„å†…å®¹æ›¿æ¢æ¨¡å—çš„ç‰¹å®šç‰ˆæœ¬æˆ–æ¨¡å—çš„æ‰€æœ‰ç‰ˆæœ¬çš„å†…å®¹ã€‚ä»¥ä½¿ç”¨å¦ä¸€ä¸ªæ¨¡å—è·¯å¾„å’Œç‰ˆæœ¬æˆ–ç‰¹å®šäºå¹³å°çš„æ–‡ä»¶è·¯å¾„æ¥æŒ‡å®šæ›¿æ¢ã€‚ å¦‚æœç®­å¤´å·¦ä¾§(=\u0026gt;)å­˜åœ¨æŸä¸ªç‰ˆæœ¬ï¼Œåˆ™ä»…æ›¿æ¢è¯¥æ¨¡å—çš„ç‰¹å®šç‰ˆæœ¬ã€‚å…¶ä»–ç‰ˆæœ¬å°†æ­£å¸¸è®¿é—®ã€‚å¦‚æœçœç•¥å·¦ç‰ˆæœ¬ï¼Œåˆ™æ›¿æ¢æ¨¡å—çš„æ‰€æœ‰ç‰ˆæœ¬ã€‚ å¦‚æœç®­å¤´å³ä¾§çš„è·¯å¾„æ˜¯ç»å¯¹æˆ–ç›¸å¯¹è·¯å¾„ï¼ˆä»¥./æˆ–../å¼€å¤´ï¼‰ï¼Œåˆ™è§£é‡Šä¸ºæ›¿æ¢æ¨¡å—æ ¹ç›®å½•çš„æœ¬åœ°æ–‡ä»¶è·¯å¾„ï¼Œå¿…é¡»åŒ…å«ä¸€ä¸ªgo.modæ–‡ä»¶ã€‚åœ¨è¿™ç§æƒ…å†µä¸‹å¿…é¡»çœç•¥æ›¿æ¢ç‰ˆæœ¬ã€‚ å¦‚æœå³ä¾§çš„è·¯å¾„ä¸æ˜¯æœ¬åœ°è·¯å¾„ï¼Œåˆ™å¿…é¡»æ˜¯æœ‰æ•ˆçš„æ¨¡å—è·¯å¾„ã€‚åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œéœ€è¦ä¸€ä¸ªç‰ˆæœ¬ã€‚ç›¸åŒçš„æ¨¡å—ç‰ˆæœ¬ä¸å¾—å‡ºç°åœ¨æ„å»ºåˆ—è¡¨ä¸­ã€‚ ä¸ç®¡æ›¿æ¢æ˜¯ç”¨æœ¬åœ°è·¯å¾„è¿˜æ˜¯æ¨¡å—è·¯å¾„æŒ‡å®šçš„ï¼Œå¦‚æœæ›¿æ¢æ¨¡å—æœ‰go.modæ–‡ä»¶ï¼Œå®ƒçš„moduleæŒ‡ä»¤å¿…é¡»åŒ¹é…å®ƒæ›¿æ¢çš„æ¨¡å—è·¯å¾„ã€‚ replaceæŒ‡ä»¤ä»…é€‚ç”¨äºä¸»æ¨¡å—çš„go.modæ–‡ä»¶ï¼Œåœ¨å…¶ä»–æ¨¡å—ä¸­è¢«å¿½ç•¥ã€‚æœ‰å…³è¯¦ç»†ä¿¡æ¯ï¼Œè¯·å‚é˜…æœ€å°ç‰ˆæœ¬é€‰æ‹©ã€‚ å¦‚æœæœ‰å¤šä¸ªä¸»æ¨¡å—ï¼Œåˆ™åº”ç”¨æ‰€æœ‰ä¸»æ¨¡å—çš„ go.mod æ–‡ä»¶ã€‚ ä¸å…è®¸è·¨ä¸»æ¨¡å—å†²çªçš„æ›¿æ¢æŒ‡ä»¤ï¼Œå¹¶ä¸”å¿…é¡»åœ¨ go.work æ–‡ä»¶çš„æ›¿æ¢ä¸­åˆ é™¤æˆ–è¦†ç›–ã€‚ è¯·æ³¨æ„ï¼Œå•ç‹¬çš„replaceæŒ‡ä»¤ä¸ä¼šå°†æ¨¡å—æ·»åŠ åˆ°æ¨¡å—å›¾ä¸­ã€‚åœ¨ä¸»æ¨¡å—çš„go.modæ–‡ä»¶æˆ–ä¾èµ–é¡¹çš„go.modæ–‡ä»¶ä¸­ï¼Œè¿˜éœ€è¦å¼•ç”¨æ›¿æ¢æ¨¡å—ç‰ˆæœ¬çš„requireæŒ‡ä»¤ã€‚å¦‚æœä¸éœ€è¦å·¦ä¾§çš„æ¨¡å—ç‰ˆæœ¬ï¼Œåˆ™æ›¿æ¢æŒ‡ä»¤æ— æ•ˆã€‚ 1 2 3 4 ReplaceDirective = \u0026#34;replace\u0026#34; ( ReplaceSpec | \u0026#34;(\u0026#34; newline { ReplaceSpec } \u0026#34;)\u0026#34; newline ) . ReplaceSpec = ModulePath [ Version ] \u0026#34;=\u0026gt;\u0026#34; FilePath newline | ModulePath [ Version ] \u0026#34;=\u0026gt;\u0026#34; ModulePath Version newline . FilePath = /* platform-specific relative or absolute file path */ ç¤ºä¾‹ï¼š 1 2 3 4 5 6 7 8 replace golang.org/x/net v1.2.3 =\u0026gt; example.com/fork/net v1.4.5 replace ( golang.org/x/net v1.2.3 =\u0026gt; example.com/fork/net v1.4.5 golang.org/x/net =\u0026gt; example.com/fork/net v1.4.5 golang.org/x/net v1.2.3 =\u0026gt; ./fork/net golang.org/x/net =\u0026gt; ./fork/net ) retract æ’¤å›æŒ‡ä»¤ retractæŒ‡ä»¤æŒ‡ç¤ºä¸åº”ä¾èµ–ç”±go.modå®šä¹‰çš„æ¨¡å—çš„ç‰ˆæœ¬æˆ–ç‰ˆæœ¬èŒƒå›´ã€‚å½“ç‰ˆæœ¬è¿‡æ—©å‘å¸ƒæˆ–ç‰ˆæœ¬å‘å¸ƒåå‘ç°ä¸¥é‡é—®é¢˜æ—¶ï¼Œæ’¤å›æŒ‡ä»¤å¾ˆæœ‰ç”¨ã€‚æ’¤å›çš„ç‰ˆæœ¬åº”è¯¥åœ¨ç‰ˆæœ¬æ§åˆ¶å­˜å‚¨åº“å’Œæ¨¡å—ä»£ç†ä¸­ä¿æŒå¯ç”¨ï¼Œä»¥ç¡®ä¿ä¾èµ–äºå®ƒä»¬çš„æ„å»ºä¸ä¼šè¢«ç ´åã€‚æ’¤å›è¿™ä¸ªè¯æ˜¯ä»å­¦æœ¯æ–‡çŒ®ä¸­å€Ÿæ¥çš„ï¼šè¢«æ’¤å›çš„ç ”ç©¶è®ºæ–‡ä»ç„¶å¯ç”¨ï¼Œä½†å®ƒæœ‰é—®é¢˜ï¼Œä¸åº”ä½œä¸ºæœªæ¥å·¥ä½œçš„åŸºç¡€ã€‚ å½“æ¨¡å—ç‰ˆæœ¬è¢«æ’¤å›æ—¶ï¼Œç”¨æˆ·ä¸ä¼šä½¿ç”¨go getã€go mod tidyæˆ–å…¶ä»–å‘½ä»¤è‡ªåŠ¨å‡çº§åˆ°å®ƒã€‚ä¾èµ–äºæ’¤å›ç‰ˆæœ¬çš„æ„å»ºåº”è¯¥ç»§ç»­å·¥ä½œï¼Œä½†æ˜¯å½“ç”¨æˆ·ä½¿ç”¨go list -m -uæ£€æŸ¥æ›´æ–°æˆ–ä½¿ç”¨go getæ›´æ–°ç›¸å…³æ¨¡å—æ—¶ï¼Œä¼šæ”¶åˆ°æ’¤å›é€šçŸ¥ã€‚ è¦æ’¤å›ä¸€ä¸ªç‰ˆæœ¬ï¼Œæ¨¡å—ä½œè€…åº”è¯¥å‘go.modæ·»åŠ ä¸€ä¸ªæ’¤å›æŒ‡ä»¤ï¼Œç„¶åå‘å¸ƒä¸€ä¸ªåŒ…å«è¯¥æŒ‡ä»¤çš„æ–°ç‰ˆæœ¬ã€‚æ–°ç‰ˆæœ¬å¿…é¡»é«˜äºå…¶ä»–å‘å¸ƒæˆ–é¢„å‘å¸ƒç‰ˆæœ¬ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œåœ¨è€ƒè™‘æ’¤å›ä¹‹å‰ï¼Œ@latestç‰ˆæœ¬æŸ¥è¯¢åº”è¯¥è§£æä¸ºæ–°ç‰ˆæœ¬ã€‚goå‘½ä»¤ä»go list -m -retracted $modpath@latestï¼ˆå…¶ä¸­$modpathæ˜¯æ¨¡å—è·¯å¾„ï¼‰æ˜¾ç¤ºçš„ç‰ˆæœ¬åŠ è½½å¹¶åº”ç”¨æ’¤å›ã€‚ é™¤éä½¿ç”¨-retractedæ ‡å¿—ï¼Œå¦åˆ™ä»go list -m -versionsæ‰“å°çš„ç‰ˆæœ¬åˆ—è¡¨ä¸­éšè—å·²æ’¤å›çš„ç‰ˆæœ¬ã€‚è§£æ@\u0026gt;=v1.2.3æˆ–@latestä¹‹ç±»çš„ç‰ˆæœ¬æŸ¥è¯¢æ—¶ï¼Œå°†æ’é™¤æ’¤å›çš„ç‰ˆæœ¬ã€‚ åŒ…å«æ’¤å›çš„ç‰ˆæœ¬å¯èƒ½ä¼šæ’¤å›è‡ªå·±ã€‚å¦‚æœæ¨¡å—çš„æœ€é«˜å‘è¡Œç‰ˆæˆ–é¢„å‘è¡Œç‰ˆè‡ªè¡Œæ”¶å›ï¼Œåˆ™åœ¨æ’é™¤æ”¶å›çš„ç‰ˆæœ¬åï¼Œ@latestæŸ¥è¯¢å°†è§£æä¸ºè¾ƒä½ç‰ˆæœ¬ã€‚ ä¾‹å¦‚ï¼Œè€ƒè™‘æ¨¡å—example.com/mçš„ä½œè€…æ„å¤–å‘å¸ƒç‰ˆæœ¬v1.0.0çš„æƒ…å†µã€‚ä¸ºäº†é˜²æ­¢ç”¨æˆ·å‡çº§åˆ°v1.0.0ï¼Œä½œè€…å¯ä»¥åœ¨go.modä¸­æ·»åŠ ä¸¤ä¸ªæ’¤æ¶ˆæŒ‡ä»¤ï¼Œç„¶åå°†æ’¤å›æ ‡è®°ä¸ºv1.0.1ã€‚ 1 2 3 4 retract ( v1.0.0 // æ„å¤–å‘å¸ƒ v1.0.1 // ä»…åŒ…å«æ’¤å› ) å½“ç”¨æˆ·è¿è¡Œgo get example.com/m@latestæ—¶ï¼Œgoå‘½ä»¤ä»v1.0.1è¯»å–æ’¤å›ï¼Œç°åœ¨æ˜¯æœ€é«˜ç‰ˆæœ¬ã€‚v1.0.0å’Œv1.0.1éƒ½å·²æ’¤å›ï¼Œå› æ­¤goå‘½ä»¤å°†å‡çº§ï¼ˆæˆ–é™çº§ï¼ï¼‰åˆ°ä¸‹ä¸€ä¸ªæœ€é«˜ç‰ˆæœ¬ï¼Œå¯èƒ½æ˜¯v0.9.5ã€‚ æ’¤å›æŒ‡ä»¤å¯ä»¥ä½¿ç”¨å•ä¸ªç‰ˆæœ¬ï¼ˆå¦‚v1.0.0ï¼‰æˆ–å…·æœ‰ä¸Šä¸‹é™çš„å°é—­åŒºé—´ç‰ˆæœ¬ç¼–å†™ï¼Œç”±[å’Œ]åˆ†éš”ï¼ˆå¦‚[v1.1.0, v1.2.0]ï¼‰ã€‚å•ä¸ªç‰ˆæœ¬ç›¸å½“äºä¸Šä¸‹é™ç›¸åŒçš„åŒºé—´ã€‚åƒå…¶ä»–æŒ‡ä»¤ä¸€æ ·ï¼Œå¤šä¸ªæ’¤å›æŒ‡ä»¤å¯ä»¥ç»„åˆåœ¨ä¸€ä¸ªå—ä¸­ï¼Œç”±ï¼ˆåœ¨ä¸€è¡Œçš„æœ«å°¾å’Œï¼‰åœ¨å®ƒè‡ªå·±çš„è¡Œä¸Šåˆ†éš”ã€‚ æ¯ä¸ªæ’¤å›æŒ‡ä»¤éƒ½åº”è¯¥æœ‰ä¸€ä¸ªæ³¨é‡Šæ¥è§£é‡Šæ’¤å›çš„ç†ç”±ï¼Œå°½ç®¡è¿™ä¸æ˜¯å¼ºåˆ¶æ€§çš„ã€‚goå‘½ä»¤å¯èƒ½ä¼šåœ¨æœ‰å…³æ’¤å›ç‰ˆæœ¬çš„è­¦å‘Šå’Œgoåˆ—è¡¨è¾“å‡ºä¸­æ˜¾ç¤ºæ’¤å›æ³¨é‡Šã€‚æ’¤å›æ³¨é‡Šå¯ä»¥å†™åœ¨æ’¤å›æŒ‡ä»¤çš„æ­£ä¸Šæ–¹ï¼ˆä¸­é—´æ²¡æœ‰ç©ºè¡Œï¼‰ï¼Œä¹Ÿå¯ä»¥å†™åœ¨åŒä¸€è¡Œä¹‹åã€‚å¦‚æœæ³¨é‡Šå‡ºç°åœ¨å—ä¸Šæ–¹ï¼Œåˆ™å®ƒé€‚ç”¨äºå—å†…æ²¡æœ‰è‡ªå·±æ³¨é‡Šçš„æ‰€æœ‰æ’¤å›æŒ‡ä»¤ã€‚æ’¤å›æ³¨é‡Šå¯èƒ½è·¨è¶Šå¤šè¡Œã€‚ 1 2 RetractDirective = \u0026#34;retract\u0026#34; ( RetractSpec | \u0026#34;(\u0026#34; newline { RetractSpec } \u0026#34;)\u0026#34; newline ) . RetractSpec = ( Version | \u0026#34;[\u0026#34; Version \u0026#34;,\u0026#34; Version \u0026#34;]\u0026#34; ) newline . ç¤ºä¾‹ï¼š 1 2 3 4 5 6 retract v1.0.0 retract [v1.0.0, v1.9.9] retract ( v1.0.0 [v1.0.0, v1.9.9] ) RetractæŒ‡ä»¤æ˜¯åœ¨Go 1.16ä¸­æ·»åŠ çš„ã€‚å¦‚æœåœ¨ä¸»æ¨¡å—çš„go.modæ–‡ä»¶ä¸­å†™å…¥äº†æ’¤å›æŒ‡ä»¤ï¼Œåˆ™Go 1.15åŠæ›´ä½ç‰ˆæœ¬å°†æŠ¥å‘Šé”™è¯¯ï¼Œå¹¶ä¸”å°†å¿½ç•¥ä¾èµ–é¡¹çš„go.modæ–‡ä»¶ä¸­çš„æ’¤å›æŒ‡ä»¤ã€‚ è‡ªåŠ¨æ›´æ–° å¦‚æœgo.modç¼ºå°‘ä¿¡æ¯æˆ–ä¸èƒ½å‡†ç¡®åæ˜ ç°å®ï¼Œå¤§å¤šæ•°å‘½ä»¤éƒ½ä¼šæŠ¥å‘Šé”™è¯¯ã€‚go getå’Œgo mod tidyå‘½ä»¤å¯ç”¨äºè§£å†³å¤§å¤šæ•°è¿™äº›é—®é¢˜ã€‚ æ­¤å¤–ï¼Œ-mod=modæ ‡å¿—å¯ä»¥ä¸å¤§å¤šæ•°æ¨¡å—æ„ŸçŸ¥å‘½ä»¤ï¼ˆgo buildã€go testç­‰ï¼‰ä¸€èµ·ä½¿ç”¨ï¼Œä»¥æŒ‡ç¤ºgoå‘½ä»¤è‡ªåŠ¨ä¿®å¤go.modå’Œgo.sumä¸­çš„é—®é¢˜ã€‚ ä¾‹å¦‚ï¼Œè€ƒè™‘è¿™ä¸ªgo.modæ–‡ä»¶ï¼š 1 2 3 4 5 6 7 8 9 10 11 12 13 module example.com/M go 1.16 require ( example.com/A v1 example.com/B v1.0.0 example.com/C v1.0.0 example.com/D v1.2.3 example.com/E dev ) exclude example.com/D v1.2.3 ä½¿ç”¨-mod=modè§¦å‘çš„æ›´æ–°å°†éè§„èŒƒç‰ˆæœ¬æ ‡è¯†ç¬¦é‡å†™ä¸ºè§„èŒƒsemverå½¢å¼ï¼Œå› æ­¤example.com/Açš„v1å˜ä¸ºv1.0.0ï¼Œexample.com/Eçš„devæˆä¸ºdevä¸Šæœ€æ–°æäº¤çš„ä¼ªç‰ˆæœ¬åˆ†æ”¯ï¼Œå¯èƒ½æ˜¯v0.0.0-20180523231146-b3f5c0f6e5f1ã€‚ è¯¥æ›´æ–°ä¿®æ”¹äº†è¦æ±‚ä»¥éµå®ˆæ’é™¤è§„åˆ™ï¼Œå› æ­¤å¯¹æ’é™¤çš„example.com/D v1.2.3çš„requireæ›´æ–°ä¸ºä½¿ç”¨example.com/Dçš„ä¸‹ä¸€ä¸ªå¯ç”¨ç‰ˆæœ¬ï¼Œå¯èƒ½æ˜¯v1.2.4æˆ–v1.3.0ã€‚ æ­¤æ›´æ–°åˆ é™¤äº†å¤šä½™æˆ–è¯¯å¯¼æ€§çš„è¦æ±‚ã€‚ä¾‹å¦‚ï¼Œå¦‚æœexample.com/A v1.0.0æœ¬èº«éœ€è¦example.com/B v1.2.0å’Œexample.com/C v1.0.0ï¼Œé‚£ä¹ˆ go.modå¯¹example.com/B v1.0.0çš„è¦æ±‚å…·æœ‰è¯¯å¯¼æ€§ï¼ˆå·²å–ä»£é€šè¿‡example.com/Aéœ€è¦v1.2.0ï¼‰ï¼Œå¹¶ä¸”å®ƒå¯¹example.com/C v1.0.0çš„è¦æ±‚æ˜¯å¤šä½™çš„ï¼ˆæš—ç¤ºexample.com/Aéœ€è¦ç›¸åŒç‰ˆæœ¬ï¼‰ï¼Œå› æ­¤ä¸¤è€…éƒ½å°†è¢«åˆ é™¤ã€‚å¦‚æœä¸»æ¨¡å—åŒ…å«ç›´æ¥ä»example.com/Bæˆ–example.com/Cå¯¼å…¥åŒ…çš„åŒ…ï¼Œé‚£ä¹ˆéœ€æ±‚å°†è¢«ä¿ç•™ä½†æ›´æ–°åˆ°æ­£åœ¨ä½¿ç”¨çš„å®é™…ç‰ˆæœ¬ã€‚ æœ€åï¼Œæ›´æ–°ä»¥è§„èŒƒæ ¼å¼é‡æ–°æ ¼å¼åŒ–go.modï¼Œä»¥ä¾¿æœªæ¥çš„æœºæ¢°æ›´æ”¹å°†å¯¼è‡´æœ€å°å·®å¼‚ã€‚ å¦‚æœåªéœ€è¦æ›´æ”¹æ ¼å¼ï¼Œgoå‘½ä»¤å°†ä¸ä¼šæ›´æ–°go.modã€‚ å› ä¸ºæ¨¡å—å›¾å®šä¹‰äº†importè¯­å¥çš„å«ä¹‰ï¼Œæ‰€ä»¥ä»»ä½•åŠ è½½åŒ…çš„å‘½ä»¤ä¹Ÿä½¿ç”¨go.modï¼Œå› æ­¤å¯ä»¥æ›´æ–°å®ƒï¼ŒåŒ…æ‹¬go buildã€go getã€go installã€go listã€go testã€go mod tidyã€‚ åœ¨Go 1.15åŠæ›´ä½ç‰ˆæœ¬ä¸­ï¼Œé»˜è®¤å¯ç”¨-mod=modæ ‡å¿—ï¼Œå› æ­¤ä¼šè‡ªåŠ¨æ‰§è¡Œæ›´æ–°ã€‚ä»Go 1.16å¼€å§‹ï¼Œgoå‘½ä»¤çš„è¡Œä¸ºå°±åƒè®¾ç½®äº†-mod=readonlyä¸€æ ·ï¼Œå¦‚æœéœ€è¦å¯¹go.modè¿›è¡Œä»»ä½•æ›´æ”¹ï¼Œåˆ™goå‘½ä»¤ä¼šæŠ¥å‘Šé”™è¯¯å¹¶å»ºè®®ä¿®å¤ã€‚ ","permalink":"https://heliu.site/posts/golang/package/go-mod/","summary":"Golang go.modæ–‡ä»¶å†…å®¹ä»‹ç»ã€‚","title":"go.mod æ–‡ä»¶"},{"content":" æœ¬æ•™ç¨‹ä»‹ç»Goä¸­å¤šæ¨¡å—å·¥ä½œåŒºçš„åŸºç¡€çŸ¥è¯†ã€‚ä½¿ç”¨å¤šæ¨¡å—å·¥ä½œåŒºï¼Œæ‚¨å¯ä»¥å‘Šè¯‰Goå‘½ä»¤æ‚¨æ­£åœ¨åŒæ—¶åœ¨å¤šä¸ªæ¨¡å—ä¸­ç¼–å†™ä»£ç ï¼Œå¹¶è½»æ¾åœ°åœ¨è¿™äº›æ¨¡å—ä¸­æ„å»ºå’Œè¿è¡Œä»£ç ã€‚ åœ¨æœ¬æ•™ç¨‹ä¸­ï¼Œæ‚¨å°†åœ¨å…±äº«çš„å¤šæ¨¡å—å·¥ä½œåŒºä¸­åˆ›å»ºä¸¤ä¸ªæ¨¡å—ï¼Œå¯¹è¿™äº›æ¨¡å—è¿›è¡Œæ›´æ”¹ï¼Œå¹¶åœ¨æ„å»ºä¸­æŸ¥çœ‹è¿™äº›æ›´æ”¹çš„ç»“æœã€‚ å¿…é¡»æ¡ä»¶ï¼š Go 1.18æˆ–æ›´é«˜ç‰ˆæœ¬çš„å®‰è£…ã€‚ ç”¨äºç¼–è¾‘ä»£ç çš„å·¥å…·ã€‚ æ‚¨æ‹¥æœ‰çš„ä»»ä½•æ–‡æœ¬ç¼–è¾‘å™¨éƒ½å¯ä»¥æ­£å¸¸å·¥ä½œã€‚ ä¸€ä¸ªå‘½ä»¤ç»ˆç«¯ã€‚Goåœ¨Linuxå’ŒMacä¸Šçš„ä»»ä½•ç»ˆç«¯ä»¥åŠWindowsä¸­çš„PowerShellæˆ–cmdä¸Šéƒ½èƒ½å¾ˆå¥½åœ°å·¥ä½œã€‚ æœ¬æ•™ç¨‹éœ€è¦go1.18æˆ–æ›´é«˜ç‰ˆæœ¬ã€‚ ä½¿ç”¨go.dev/dlä¸­çš„é“¾æ¥ï¼Œç¡®ä¿æ‚¨å·²åœ¨Go 1.18æˆ–æ›´é«˜ç‰ˆæœ¬ä¸­å®‰è£…äº†Goã€‚ åˆ›å»ºä¸€ä¸ªæ¨¡å— é¦–å…ˆï¼Œä¸ºæ‚¨è¦ç¼–å†™çš„ä»£ç åˆ›å»ºä¸€ä¸ªæ¨¡å—ã€‚ æ‰“å¼€å‘½ä»¤æç¤ºç¬¦å¹¶åˆ‡æ¢åˆ°æ‚¨çš„ä¸»ç›®å½•ã€‚ åœ¨Linuxæˆ–Macä¸Šï¼šcdã€‚ åœ¨Windowsä¸Šï¼šC:\\\u0026gt; cd %HOMEPATH%ã€‚ æœ¬æ•™ç¨‹çš„å…¶ä½™éƒ¨åˆ†å°†æ˜¾ç¤º$ä½œä¸ºæç¤ºã€‚æ‚¨ä½¿ç”¨çš„å‘½ä»¤ä¹Ÿå¯ä»¥åœ¨Windowsä¸Šè¿è¡Œã€‚ åœ¨å‘½ä»¤æç¤ºç¬¦ä¸‹ï¼Œä¸ºæ‚¨çš„ä»£ç åˆ›å»ºä¸€ä¸ªåä¸ºå·¥ä½œåŒºçš„ç›®å½•ã€‚ 1 2 $ mkdir workspace $ cd workspace åˆå§‹åŒ–æ¨¡å— æˆ‘ä»¬çš„ç¤ºä¾‹å°†åˆ›å»ºä¸€ä¸ªhelloä¾èµ–äºgolang.org/x/exampleæ¨¡å—çš„æ–°æ¨¡å—ã€‚ åˆ›å»ºhelloæ¨¡å—ï¼š 1 2 3 4 $ mkdir hello $ cd hello $ go mod init example.com/hello go: creating new go.mod: module example.com/hello ä½¿ç”¨go getæ·»åŠ å¯¹golang.org/x/exampleæ¨¡å—çš„ä¾èµ–ï¼ˆå¦‚æœæœ‰éœ€è¦ï¼‰ã€‚ 1 2 3 $ go get golang.org/x/example go: downloading golang.org/x/example v0.0.0-20220304235025-ad95e7f791d8 go get: added golang.org/x/example v0.0.0-20220304235025-ad95e7f791d8 åœ¨helloç›®å½•ä¸‹åˆ›å»ºhello.goï¼Œå†…å®¹å¦‚ä¸‹ï¼š 1 2 3 4 5 6 7 8 9 10 11 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;golang.org/x/example/stringutil\u0026#34; ) func main() { fmt.Println(stringutil.Reverse(\u0026#34;Hello\u0026#34;)) } ç°åœ¨ï¼Œè¿è¡Œhelloç¨‹åºï¼š 1 2 3 $ go mod tidy $ go run . olleH ç›®å½•ç»“æ„ä¸ºï¼š 1 2 3 4 |--workspace |----hello |------hello.go |------go.mod åˆ›å»ºå·¥ä½œåŒº åœ¨è¿™ä¸€æ­¥ä¸­ï¼Œæˆ‘ä»¬å°†åˆ›å»ºä¸€ä¸ªgo.workæ–‡ä»¶æ¥æŒ‡å®šæ¨¡å—çš„å·¥ä½œåŒºã€‚ åˆå§‹åŒ–å·¥ä½œåŒº åœ¨workspaceç›®å½•ä¸­ï¼Œè¿è¡Œï¼š 1 2 3 # go1.18beta2.exe work init ./hello ## æœ¬åœ°ç”¨çš„go1.18beta2ç‰ˆæœ¬ # å½“å‰ç›®å½•æ˜¯ hello çš„ä¸Šçº§ç›®å½•ä¸‹ï¼Œæ‰§è¡Œå®Œgo work initåä¼šç”Ÿæˆä¸€ä¸ªgo.workæ–‡ä»¶ $ go work init ./hello go work initå‘½ä»¤å‘Šè¯‰goä¸ºåŒ…å«./helloç›®å½•ä¸­çš„æ¨¡å—çš„å·¥ä½œç©ºé—´åˆ›å»ºä¸€ä¸ªgo.workæ–‡ä»¶ã€‚ goå‘½ä»¤ç”Ÿæˆä¸€ä¸ªå¦‚ä¸‹æ‰€ç¤ºçš„go.workæ–‡ä»¶ï¼š go 1.18 use ./hello go.workæ–‡ä»¶çš„è¯­æ³•ä¸go.modç›¸ä¼¼ã€‚ goæŒ‡ä»¤å‘Šè¯‰Goåº”è¯¥ä½¿ç”¨å“ªä¸ªç‰ˆæœ¬çš„Goæ¥è§£é‡Šæ–‡ä»¶ã€‚å®ƒç±»ä¼¼äºgo.modæ–‡ä»¶ä¸­çš„goæŒ‡ä»¤ã€‚ useæŒ‡ä»¤å‘Šè¯‰Goåœ¨æ„å»ºæ—¶helloç›®å½•ä¸­çš„æ¨¡å—åº”è¯¥æ˜¯ä¸»æ¨¡å—ã€‚ å› æ­¤ï¼Œåœ¨å·¥ä½œåŒºçš„ä»»ä½•å­ç›®å½•ä¸­ï¼Œè¯¥æ¨¡å—éƒ½å°†å¤„äºæ´»åŠ¨çŠ¶æ€ã€‚ ç›®å½•ç»“æ„ä¸ºï¼š 1 2 3 4 5 |--workspace |----hello |------hello.go |------go.mod |----go.work è¿è¡Œå·¥ä½œåŒºä¸‹çš„ç›®å½• åœ¨workspaceç›®å½•ä¸­ï¼Œè¿è¡Œï¼š 1 2 3 # go1.18beta2.exe run example.com/hello $ go run example.com/hello olleH Goå‘½ä»¤åŒ…æ‹¬å·¥ä½œåŒºä¸­çš„æ‰€æœ‰æ¨¡å—ä½œä¸ºä¸»æ¨¡å—ã€‚è¿™å…è®¸æˆ‘ä»¬åœ¨æ¨¡å—ä¸­å¼•ç”¨ä¸€ä¸ªåŒ…ï¼Œç”šè‡³åœ¨æ¨¡å—ä¹‹å¤–ã€‚ åœ¨æ¨¡å—æˆ–å·¥ä½œåŒºä¹‹å¤–è¿è¡Œgo runå‘½ä»¤ä¼šå¯¼è‡´é”™è¯¯ï¼Œå› ä¸ºgoå‘½ä»¤ä¸çŸ¥é“è¦ä½¿ç”¨å“ªäº›æ¨¡å—ã€‚ æ¥ä¸‹æ¥ï¼Œæˆ‘ä»¬å°†golang.org/x/exampleæ¨¡å—çš„æœ¬åœ°å‰¯æœ¬æ·»åŠ åˆ°å·¥ä½œåŒºã€‚ç„¶åï¼Œæˆ‘ä»¬å°†å‘stringutilåŒ…æ·»åŠ ä¸€ä¸ªæ–°å‡½æ•°ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨å®ƒæ¥ä»£æ›¿Reverseã€‚ ä¸‹è½½å’Œä¿®æ”¹golang.org/x/exampleæ¨¡å— åœ¨è¿™ä¸€æ­¥ä¸­ï¼Œæˆ‘ä»¬å°†ä¸‹è½½åŒ…å«golang.org/x/exampleæ¨¡å—çš„Gitå­˜å‚¨åº“çš„å‰¯æœ¬ï¼Œå°†å…¶æ·»åŠ åˆ°å·¥ä½œåŒºï¼Œç„¶åå‘å…¶ä¸­æ·»åŠ ä¸€ä¸ªæˆ‘ä»¬å°†ä»helloç¨‹åºä¸­ä½¿ç”¨çš„æ–°å‡½æ•°ã€‚ å…‹éš†å­˜å‚¨åº“ï¼Œåœ¨workspaceç›®å½•ä¸­ï¼Œè¿è¡Œgitå‘½ä»¤æ¥å…‹éš†å­˜å‚¨åº“ï¼š 1 2 3 4 5 6 7 8 $ git clone https://github.com/golang/example Cloning into \u0026#39;example\u0026#39;... remote: Enumerating objects: 182, done. remote: Counting objects: 100% (30/30), done. remote: Compressing objects: 100% (20/20), done. remote: Total 182 (delta 6), reused 16 (delta 4), pack-reused 152R Receiving objects: 100% (182/182), 138.39 KiB | 1.05 MiB/s, done. Resolving deltas: 100% (74/74), done. å°†æ¨¡å—æ·»åŠ åˆ°å·¥ä½œåŒºã€‚ 1 2 # go1.18beta2.exe work use ./example $ go work use ./example go work useå‘½ä»¤å°†ä¸€ä¸ªæ–°æ¨¡å—æ·»åŠ åˆ°go.workæ–‡ä»¶ä¸­ã€‚å®ƒç°åœ¨çœ‹èµ·æ¥åƒè¿™æ ·ï¼š go 1.18 use ( ./hello ./example ) ç›®å½•ç»“æ„ï¼š 1 2 3 4 5 6 7 8 |--workspace |----hello |------hello.go |------go.mod |----example |------stringutil |--------reverse.go |----go.work è¯¥æ¨¡å—ç°åœ¨åŒ…æ‹¬example.com/helloæ¨¡å—å’Œgolang.org/x/exampleæ¨¡å—ã€‚ è¿™å°†å…è®¸æˆ‘ä»¬ä½¿ç”¨æˆ‘ä»¬å°†åœ¨stringutilæ¨¡å—çš„å‰¯æœ¬ä¸­ç¼–å†™çš„æ–°ä»£ç ï¼Œè€Œä¸æ˜¯ä½¿ç”¨go getå‘½ä»¤ä¸‹è½½çš„æ¨¡å—ç¼“å­˜ä¸­çš„æ¨¡å—ç‰ˆæœ¬ã€‚ æ·»åŠ æ–°åŠŸèƒ½ï¼š æˆ‘ä»¬å°†åœ¨golang.org/x/example/stringutilåŒ…ä¸­æ·»åŠ ä¸€ä¸ªå°†å­—ç¬¦ä¸²å¤§å†™çš„æ–°å‡½æ•°ã€‚ å°†æ–°æ–‡ä»¶å¤¹æ·»åŠ åˆ°åŒ…å«ä»¥ä¸‹å†…å®¹çš„workspace/example/stringutilç›®å½•ï¼šå¹¶å‘½ä»¤ä¸ºupper.goæ–‡ä»¶ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 package stringutil import \u0026#34;unicode\u0026#34; // ToUpper uppercases all the runes in its argument string. func ToUpper(s string) string { r := []rune(s) for i := range r { r[i] = unicode.ToUpper(r[i]) } return string(r) } ä¿®æ”¹helloç¨‹åºä»¥ä½¿ç”¨è¯¥åŠŸèƒ½ï¼Œä¿®æ”¹workspace/hello/hello.goçš„å†…å®¹ï¼ŒåŒ…å«ä»¥ä¸‹å†…å®¹ï¼š 1 2 3 4 5 6 7 8 9 10 11 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;golang.org/x/example/stringutil\u0026#34; ) func main() { fmt.Println(stringutil.ToUpper(\u0026#34;Hello\u0026#34;)) } è¿è¡Œworkspaceç›®å½•ä¸‹ä»£ç  ä»workspaceç›®å½•ï¼Œè¿è¡Œï¼š 1 2 # go1.18beta2.exe run example.com/hello $ go run example.com/hello Goå‘½ä»¤åœ¨go.workæ–‡ä»¶æŒ‡å®šçš„helloç›®å½•ä¸­æŸ¥æ‰¾å‘½ä»¤è¡Œä¸­æŒ‡å®šçš„example.com/helloæ¨¡å—ï¼ŒåŒæ ·ä½¿ç”¨go.workæ–‡ä»¶è§£ægolang.org/x/exampleå¯¼å…¥ã€‚ å¯ä»¥ä½¿ç”¨go.workè€Œä¸æ˜¯æ·»åŠ æ›¿æ¢æŒ‡ä»¤æ¥è·¨å¤šä¸ªæ¨¡å—å·¥ä½œã€‚ ç”±äºè¿™ä¸¤ä¸ªæ¨¡å—ä½äºåŒä¸€ä¸ªå·¥ä½œåŒºä¸­ï¼Œå› æ­¤å¾ˆå®¹æ˜“åœ¨ä¸€ä¸ªæ¨¡å—ä¸­è¿›è¡Œæ›´æ”¹å¹¶åœ¨å¦ä¸€ä¸ªæ¨¡å—ä¸­ä½¿ç”¨å®ƒã€‚ ","permalink":"https://heliu.site/posts/golang/package/use-work/","summary":"Golang workä½¿ç”¨ä»‹ç»ã€‚","title":"å·¥ä½œåŒºä½¿ç”¨"},{"content":" åœ¨æœ¬æ•™ç¨‹ä¸­ï¼Œæ‚¨å°†åˆ›å»ºä¸¤ä¸ªæ¨¡å—ã€‚ç¬¬ä¸€ä¸ªæ˜¯æ—¨åœ¨ç”±å…¶ä»–åº“æˆ–åº”ç”¨ç¨‹åºå¯¼å…¥çš„åº“ã€‚ç¬¬äºŒä¸ªæ˜¯è°ƒç”¨è€…åº”ç”¨ç¨‹åºï¼Œå®ƒå°†ä½¿ç”¨ç¬¬ä¸€ä¸ªã€‚ æœ¬æ•™ç¨‹çš„åºåˆ—åŒ…æ‹¬ä¸ƒä¸ªç®€çŸ­çš„ä¸»é¢˜ï¼Œæ¯ä¸ªä¸»é¢˜éƒ½è¯´æ˜äº†è¯­è¨€çš„ä¸åŒéƒ¨åˆ†ï¼š åˆ›å»ºä¸€ä¸ªæ¨¡å— â€”â€” ç¼–å†™ä¸€ä¸ªå°æ¨¡å—ï¼Œå…¶ä¸­åŒ…å«å¯ä»¥ä»å¦ä¸€ä¸ªæ¨¡å—è°ƒç”¨çš„å‡½æ•°ã€‚ ä»å¦ä¸€ä¸ªæ¨¡å—è°ƒç”¨æ‚¨çš„ä»£ç  â€”â€” å¯¼å…¥å¹¶ä½¿ç”¨æ‚¨çš„æ–°æ¨¡å—ã€‚ è¿”å›å¹¶å¤„ç†é”™è¯¯ â€”â€” æ·»åŠ ç®€å•çš„é”™è¯¯å¤„ç†ã€‚ è¿”å›ä¸€ä¸ªéšæœºçš„é—®å€™ â€”â€” åœ¨åˆ‡ç‰‡ä¸­å¤„ç†æ•°æ®ï¼ˆGo çš„åŠ¨æ€å¤§å°çš„æ•°ç»„ï¼‰ã€‚ è¿”å›å¤šäººçš„é—®å€™ â€”â€” åœ¨ map ä¸­å­˜å‚¨ é”®/å€¼ å¯¹ã€‚ æ·»åŠ æµ‹è¯• â€”â€” ä½¿ç”¨ Go çš„å†…ç½®å•å…ƒæµ‹è¯•åŠŸèƒ½æ¥æµ‹è¯•ä½ çš„ä»£ç ã€‚ ç¼–è¯‘å’Œå®‰è£…åº”ç”¨ç¨‹åº â€”â€” åœ¨æœ¬åœ°ç¼–è¯‘å’Œå®‰è£…ä½ çš„ä»£ç ã€‚ å¯åŠ¨ä¸€ä¸ªå…¶ä»–äººå¯ä»¥ä½¿ç”¨çš„æ¨¡å— é¦–å…ˆåˆ›å»ºä¸€ä¸ªGoæ¨¡å—ã€‚åœ¨ä¸€ä¸ªæ¨¡å—ä¸­ï¼Œæ‚¨ä¸ºä¸€ç»„ç¦»æ•£ä¸”æœ‰ç”¨çš„åŠŸèƒ½æ”¶é›†ä¸€ä¸ªæˆ–å¤šä¸ªç›¸å…³åŒ…ã€‚ä¾‹å¦‚ï¼Œæ‚¨å¯èƒ½ä¼šåˆ›å»ºä¸€ä¸ªåŒ…å«å…·æœ‰è´¢åŠ¡åˆ†æåŠŸèƒ½çš„åŒ…çš„æ¨¡å—ï¼Œä»¥ä¾¿å…¶ä»–ç¼–å†™è´¢åŠ¡åº”ç”¨ç¨‹åºçš„äººå¯ä»¥ä½¿ç”¨æ‚¨çš„å·¥ä½œã€‚æœ‰å…³å¼€å‘æ¨¡å—çš„æ›´å¤šä¿¡æ¯ï¼Œè¯·å‚é˜… å¼€å‘å’Œå‘å¸ƒæ¨¡å—ã€‚ Goä»£ç è¢«åˆ†ç»„åˆ°åŒ…ä¸­ï¼ŒåŒ…è¢«åˆ†ç»„åˆ°æ¨¡å—ä¸­ã€‚æ‚¨çš„æ¨¡å—æŒ‡å®šäº†è¿è¡Œä»£ç æ‰€éœ€çš„ä¾èµ–é¡¹ï¼ŒåŒ…æ‹¬ Go ç‰ˆæœ¬å’Œå®ƒæ‰€éœ€çš„ä¸€ç»„å…¶ä»–æ¨¡å—ã€‚ å½“æ‚¨åœ¨æ¨¡å—ä¸­æ·»åŠ æˆ–æ”¹è¿›åŠŸèƒ½æ—¶ï¼Œæ‚¨ä¼šå‘å¸ƒæ¨¡å—çš„æ–°ç‰ˆæœ¬ã€‚ç¼–å†™è°ƒç”¨æ¨¡å—ä¸­å‡½æ•°çš„ä»£ç çš„å¼€å‘äººå‘˜å¯ä»¥å¯¼å…¥æ¨¡å—çš„æ›´æ–°åŒ…å¹¶ä½¿ç”¨æ–°ç‰ˆæœ¬è¿›è¡Œæµ‹è¯•ï¼Œç„¶åå†å°†å…¶æŠ•å…¥ç”Ÿäº§ä½¿ç”¨ã€‚ æ‰“å¼€å‘½ä»¤æç¤ºç¬¦å¹¶cdåˆ°æ‚¨çš„ä¸»ç›®å½•ï¼š åœ¨ Linux æˆ– Mac ä¸Šï¼šcdã€‚ åœ¨ Windows ä¸Šï¼šcd %HOMEPATH%ã€‚ ä¸ºæ‚¨çš„Goæ¨¡å—æºä»£ç  åˆ›å»ºä¸€ä¸ªdemoç›®å½•ã€‚ ä¾‹å¦‚ï¼Œä»æ‚¨çš„ä¸»ç›®å½•ä½¿ç”¨ä»¥ä¸‹å‘½ä»¤ï¼š mkdir greetings1 cd greetings1 ä½¿ç”¨go mod initå‘½ä»¤å¯åŠ¨æ‚¨çš„æ¨¡å—ã€‚è¿è¡Œgo mod initå‘½ä»¤ï¼Œç»™å®ƒä½ çš„æ¨¡å—è·¯å¾„ â€”â€” åœ¨è¿™é‡Œï¼Œä½¿ç”¨gitee.com/phpbms/greetingsã€‚ è¿è¡Œgo mod initå‘½ä»¤ï¼Œç»™å®ƒä½ çš„æ¨¡å—è·¯å¾„â€”â€”åœ¨è¿™é‡Œï¼Œä½¿ç”¨gitee.com/phpbms/greetingsã€‚å¦‚æœæ‚¨å‘å¸ƒä¸€ä¸ªæ¨¡å—ï¼Œè¿™å¿…é¡»æ˜¯Goå·¥å…·å¯ä»¥ä»ä¸­ä¸‹è½½æ‚¨çš„æ¨¡å—çš„è·¯å¾„ã€‚é‚£å°†æ˜¯æ‚¨çš„ä»£ç å­˜å‚¨åº“ã€‚æœ‰å…³ä½¿ç”¨æ¨¡å—è·¯å¾„å‘½åæ¨¡å—çš„æ›´å¤šä¿¡æ¯ï¼Œè¯·å‚é˜… ç®¡ç†ä¾èµ–é¡¹ã€‚ $ go mod init gitee.com/phpbms/greetings1 go: creating new go.mod: module gitee.com/phpbms/greetings1 ç›®å½•ç»“æ„ï¼š |--greetings1/ |----go.mod # gitee.com/phpbms/greetings1 è¯¥go mod initå‘½ä»¤ä¼šåˆ›å»ºä¸€ä¸ªgo.modæ–‡ä»¶æ¥è·Ÿè¸ªä»£ç çš„ä¾èµ–å…³ç³»ã€‚åˆ°ç›®å‰ä¸ºæ­¢ï¼Œè¯¥æ–‡ä»¶ä»…åŒ…å«æ¨¡å—çš„åç§°å’Œä»£ç æ”¯æŒçš„Goç‰ˆæœ¬ã€‚ä½†æ˜¯å½“æ‚¨æ·»åŠ ä¾èµ–é¡¹æ—¶ï¼Œgo.modæ–‡ä»¶å°†åˆ—å‡ºæ‚¨çš„ä»£ç æ‰€ä¾èµ–çš„ç‰ˆæœ¬ã€‚è¿™ä½¿æ„å»ºä¿æŒå¯é‡å¤æ€§ï¼Œå¹¶ä½¿æ‚¨å¯ä»¥ç›´æ¥æ§åˆ¶è¦ä½¿ç”¨çš„æ¨¡å—ç‰ˆæœ¬ã€‚ åœ¨æ‚¨çš„æ–‡æœ¬ç¼–è¾‘å™¨ä¸­ï¼Œåˆ›å»ºä¸€ä¸ªç”¨äºç¼–å†™ä»£ç çš„æ–‡ä»¶å¹¶å°†å…¶å‘½åä¸ºgreetings.goã€‚ å°†ä»¥ä¸‹ä»£ç ç²˜è´´åˆ°æ‚¨çš„greetings.goæ–‡ä»¶ä¸­å¹¶ä¿å­˜æ–‡ä»¶ package greetings1 import \u0026#34;fmt\u0026#34; // Hello returns a greeting for the named person. func Hello(name string) string { message := fmt.Sprintf(\u0026#34;Hi, %v. Welcome!\u0026#34;, name) return message } è¿™æ˜¯æ‚¨çš„æ¨¡å—çš„ç¬¬ä¸€ä¸ªä»£ç ã€‚å®ƒä¼šå‘ä»»ä½•è¯·æ±‚çš„å‘¼å«è€…è¿”å›é—®å€™è¯­ã€‚æ‚¨å°†åœ¨ä¸‹ä¸€æ­¥ç¼–å†™è°ƒç”¨æ­¤å‡½æ•°çš„ä»£ç ï¼Œåœ¨æ­¤ä»£ç ä¸­ï¼š å£°æ˜ä¸€ä¸ªgreetings1åŒ…æ¥æ”¶é›†ç›¸å…³åŠŸèƒ½ã€‚ å®ç°ä¸€ä¸ªHelloå‡½æ•°æ¥è¿”å›é—®å€™è¯­ã€‚ è¯¥å‡½æ•°æ¥å—ä¸€ä¸ªnameç±»å‹ä¸ºçš„å‚æ•°stringã€‚è¯¥å‡½æ•°è¿˜è¿”å›ä¸€ä¸ªstringã€‚åœ¨Goä¸­ï¼Œåç§°ä»¥å¤§å†™å­—æ¯å¼€å¤´çš„å‡½æ•°å¯ä»¥è¢«ä¸åœ¨åŒä¸€ä¸ªåŒ…ä¸­çš„å‡½æ•°è°ƒç”¨ã€‚è¿™åœ¨Goä¸­ç§°ä¸ºå¯¼å‡ºåç§°ã€‚æœ‰å…³å¯¼å‡ºåç§°çš„æ›´å¤šä¿¡æ¯ï¼Œè¯·å‚é˜…Go tourä¸­çš„å¯¼å‡ºåç§°ã€‚ å£°æ˜ä¸€ä¸ªmessageå˜é‡æ¥ä¿å­˜ä½ çš„é—®å€™ï¼Œåœ¨Goä¸­ï¼Œ:=è¿ç®—ç¬¦æ˜¯åœ¨ä¸€è¡Œä¸­å£°æ˜å’Œåˆå§‹åŒ–å˜é‡çš„å¿«æ·æ–¹å¼ï¼ˆGoä½¿ç”¨å³ä¾§çš„å€¼æ¥ç¡®å®šå˜é‡çš„ç±»å‹ï¼‰ã€‚ä»é•¿è¿œæ¥çœ‹ï¼Œæ‚¨å¯èƒ½å·²å°†å…¶å†™ä¸ºï¼š var message string message = fmt.Sprintf(\u0026#34;Hi, %v. Welcome!\u0026#34;, name) ç›®å½•ç»“æ„ï¼š |--greetings1/ |----go.mod\t# gitee.com/phpbms/greetings1 |----greetings.go\t# greetings1 ä»å¦ä¸€ä¸ªæ¨¡å—è°ƒç”¨æ‚¨çš„ä»£ç  åœ¨(1)ä¸­ï¼Œæ‚¨åˆ›å»ºäº†ä¸€ä¸ªgreetings1æ¨¡å—ã€‚åœ¨æœ¬èŠ‚ä¸­ï¼Œæ‚¨å°†ç¼–å†™ä»£ç æ¥è°ƒç”¨Helloæ‚¨åˆšåˆšç¼–å†™çš„æ¨¡å—ä¸­çš„å‡½æ•°ã€‚æ‚¨å°†ç¼–å†™å¯ä»¥ä½œä¸ºåº”ç”¨ç¨‹åºæ‰§è¡Œçš„ä»£ç ï¼Œå¹¶è°ƒç”¨greetings1æ¨¡å—ä¸­çš„ä»£ç ã€‚ helloä¸ºæ‚¨çš„Goæ¨¡å—æºä»£ç  åˆ›å»ºä¸€ä¸ªç›®å½•ã€‚è¿™æ˜¯ä½ å†™ä½ çš„è°ƒç”¨è€…çš„åœ°æ–¹ã€‚ åˆ›å»ºæ­¤ç›®å½•åï¼Œæ‚¨åº”è¯¥åœ¨å±‚æ¬¡ç»“æ„çš„åŒä¸€çº§åˆ«ä¸ŠåŒæ—¶æ‹¥æœ‰ä¸€ä¸ªhelloå’Œä¸€ä¸ªgreetingsç›®å½•ï¼Œå¦‚ä¸‹æ‰€ç¤ºï¼š \u0026lt;home\u0026gt;/ |-- greetings1/ |-- hello2/ ä¾‹å¦‚ï¼Œå¦‚æœæ‚¨çš„å‘½ä»¤æç¤ºç¬¦ä½äºgreetings1ç›®å½•ä¸­ï¼Œæ‚¨å¯ä»¥ä½¿ç”¨ä»¥ä¸‹å‘½ä»¤ï¼š cd .. mkdir hello2 cd hello2 ä¸ºæ‚¨è¦ç¼–å†™çš„ä»£ç å¯ç”¨ä¾èµ–é¡¹è·Ÿè¸ªï¼Œè¦ä¸ºæ‚¨çš„ä»£ç å¯ç”¨ä¾èµ–é¡¹è·Ÿè¸ªï¼Œè¯·è¿è¡Œgo mod init commandï¼Œå¹¶ä¸ºå…¶æä¾›æ‚¨çš„ä»£ç æ‰€åœ¨çš„æ¨¡å—çš„åç§°ã€‚ å‡ºäºæœ¬æ•™ç¨‹çš„ç›®çš„ï¼Œè¯·ä½¿ç”¨gitee.com/phpbms/hello2æ¨¡å—è·¯å¾„ã€‚ $ go mod init gitee.com/phpbms/hello2 go: creating new go.mod: module gitee.com/phpbms/hello2 åœ¨æ–‡æœ¬ç¼–è¾‘å™¨çš„hello2ç›®å½•ä¸­ï¼Œåˆ›å»ºä¸€ä¸ªç”¨äºç¼–å†™ä»£ç çš„æ–‡ä»¶å¹¶å°†å…¶å‘½åä¸ºhello.goã€‚ ç¼–å†™ä»£ç æ¥è°ƒç”¨Helloå‡½æ•°ï¼Œç„¶åæ‰“å°å‡½æ•°çš„è¿”å›å€¼ package main import ( \u0026#34;fmt\u0026#34; \u0026#34;gitee.com/phpbms/greetings1\u0026#34; ) func main() { message := greetings1.Hello(\u0026#34;Gol\u0026#34;) fmt.Println(message) } ç›®å½•ç»“æ„ï¼š |--greetings1/ |----go.mod # gitee.com/phpbms/greetings1 |----greetings.go # greetings1 |--hello2/ |----go.mod # gitee.com/phpbms/hello2 |----hello.go # main åœ¨æ­¤ä»£ç ä¸­ï¼š\nå£°æ˜ä¸€ä¸ªmainåŒ…ã€‚åœ¨Goä¸­ï¼Œä½œä¸ºåº”ç”¨ç¨‹åºæ‰§è¡Œçš„ä»£ç å¿…é¡»åœ¨mainåŒ…ä¸­ã€‚ å¯¼å…¥ä¸¤ä¸ªåŒ…ï¼šgitee.com/phpbms/greetings1å’ŒfmtåŒ…ã€‚è¿™ä½¿æ‚¨çš„ä»£ç å¯ä»¥è®¿é—®è¿™äº›åŒ…ä¸­çš„å‡½æ•°ã€‚å¯¼å…¥gitee.com/phpbms/greetings1ï¼ˆåŒ…å«åœ¨æ‚¨ä¹‹å‰åˆ›å»ºçš„æ¨¡å—ä¸­çš„åŒ…ï¼‰ä½¿æ‚¨å¯ä»¥è®¿é—®è¯¥HelloåŠŸèƒ½ã€‚æ‚¨è¿˜å¯import fmtï¼Œå…·æœ‰å¤„ç†è¾“å…¥å’Œè¾“å‡ºæ–‡æœ¬çš„åŠŸèƒ½ï¼ˆä¾‹å¦‚å°†æ–‡æœ¬æ‰“å°åˆ°æ§åˆ¶å°ï¼‰ greetingsé€šè¿‡è°ƒç”¨åŒ…çš„ Helloå‡½æ•° æ¥è·å¾—é—®å€™ã€‚ ç¼–è¾‘gitee.com/phpbms/greetings1æ¨¡å—ä»¥ä½¿ç”¨æ‚¨çš„æœ¬åœ°gitee.com/phpbms/greetings1æ¨¡å—ã€‚\nå¯¹äºç”Ÿäº§ç”¨é€”ï¼Œæ‚¨gitee.com/phpbms/greetings1å°†ä»å…¶å­˜å‚¨åº“å‘å¸ƒæ¨¡å—ï¼ˆä½¿ç”¨åæ˜ å…¶å‘å¸ƒä½ç½®çš„æ¨¡å—è·¯å¾„ï¼‰ï¼ŒGo å·¥å…·å¯ä»¥åœ¨å…¶ä¸­æ‰¾åˆ°å®ƒå¹¶ä¸‹è½½å®ƒã€‚ç›®å‰ï¼Œç”±äºæ‚¨å°šæœªå‘å¸ƒè¯¥æ¨¡å—ï¼Œæ‚¨éœ€è¦è°ƒæ•´è¯¥example.com/helloæ¨¡å—ï¼Œä»¥ä¾¿å®ƒå¯ä»¥ gitee.com/phpbms/greetings1åœ¨æ‚¨çš„æœ¬åœ°æ–‡ä»¶ç³»ç»Ÿä¸Šæ‰¾åˆ°ä»£ç ã€‚\nä¸ºæ­¤ï¼Œè¯·ä½¿ç”¨go mod editå‘½ä»¤ç¼–è¾‘example.com/helloæ¨¡å—ä»¥å°†Goå·¥å…·ä»å…¶æ¨¡å—è·¯å¾„ï¼ˆæ¨¡å—æ‰€åœ¨çš„ä½ç½®ï¼‰é‡å®šå‘åˆ°æœ¬åœ°ç›®å½•ï¼ˆæ¨¡å—æ‰€åœ¨çš„ä½ç½®ï¼‰ã€‚\nåœ¨helloç›®å½•ä¸­çš„å‘½ä»¤æç¤ºç¬¦ä¸‹ï¼Œè¿è¡Œä»¥ä¸‹å‘½ä»¤ï¼š ã€go mod edit -replace gitee.com/phpbms/greetings1=../greetings1ã€‘ã€‚ è¯¥å‘½ä»¤æŒ‡å®šgitee.com/phpbms/greetings1åº”æ›¿æ¢../greetings1ä¸ºä»¥å®šä½ä¾èµ–é¡¹ã€‚è¿è¡Œå‘½ä»¤åï¼Œ hello ç›®å½•ä¸­çš„ go.mod æ–‡ä»¶åº”è¯¥åŒ…å«ä¸€ä¸ªreplaceæŒ‡ä»¤ï¼š module gitee.com/phpbms/hello2 go 1.16 replace gitee.com/phpbms/greetings1 =\u0026gt; ../greetings1 åœ¨helloç›®å½•ä¸‹çš„å‘½ä»¤æç¤ºç¬¦ä¸‹ï¼Œè¿è¡Œã€go mod tidyã€‘å‘½ä»¤åŒæ­¥gitee.com/phpbms/hello2æ¨¡å—çš„ä¾èµ–ï¼Œæ·»åŠ ä»£ç éœ€è¦ä½†æ¨¡å—ä¸­å°šæœªè·Ÿè¸ªçš„ä¾èµ–ã€‚ $ go mod tidy -v go: found gitee.com/phpbms/greetings1 in gitee.com/phpbms/greetings1 v0.0.0-00010101000000-000000000000 å‘½ä»¤å®Œæˆåï¼Œgitee.com/phpbms/hello2æ¨¡å—çš„go.modæ–‡ä»¶åº”å¦‚ä¸‹æ‰€ç¤ºï¼š module gitee.com/phpbms/hello2 go 1.16 replace gitee.com/phpbms/greetings1 =\u0026gt; ../greetings1 require gitee.com/phpbms/greetings1 v0.0.0-00010101000000-000000000000 è¯¥å‘½ä»¤åœ¨greetings1ç›®å½•ä¸­æ‰¾åˆ°äº†æœ¬åœ°ä»£ç ï¼Œç„¶åæ·»åŠ äº†ä¸€ä¸ªrequireæŒ‡ä»¤æ¥æŒ‡å®šgitee.com/phpbms/hello2éœ€è¦gitee.com/phpbms/greetings1ã€‚å½“æ‚¨åœ¨hello.goä¸­å¯¼å…¥é—®å€™åŒ…æ—¶ï¼Œæ‚¨åˆ›å»ºäº†æ­¤ä¾èµ–é¡¹ã€‚\næ¨¡å—è·¯å¾„åé¢çš„æ•°å­—æ˜¯ä¸€ä¸ªä¼ªç‰ˆæœ¬å· â€”â€” ä¸€ä¸ªç”Ÿæˆçš„æ•°å­—ç”¨æ¥ä»£æ›¿è¯­ä¹‰ç‰ˆæœ¬å·ï¼ˆæ¨¡å—è¿˜æ²¡æœ‰ï¼‰ï¼Œè¦å¼•ç”¨å·²å‘å¸ƒçš„æ¨¡å—ï¼Œgo.modæ–‡ä»¶é€šå¸¸ä¼šçœç•¥replaceæŒ‡ä»¤å¹¶ä½¿ç”¨ requireæœ«å°¾å¸¦æœ‰æ ‡è®°ç‰ˆæœ¬å·çš„æŒ‡ä»¤ã€‚require gitee.com/phpbms/greetings1 v1.1.0ã€‚æœ‰å…³ç‰ˆæœ¬å·çš„æ›´å¤šä¿¡æ¯ï¼Œè¯·å‚é˜…æ¨¡å—ç‰ˆæœ¬ç¼–å·ã€‚\nåœ¨helloç›®å½•ä¸­çš„å‘½ä»¤æç¤ºç¬¦å¤„ï¼Œè¿è¡Œæ‚¨çš„ä»£ç ä»¥ç¡®è®¤å…¶å·¥ä½œã€‚\n$ go run . Hi, Gol. Welcome! è¿”å›å¹¶å¤„ç†é”™è¯¯ å¤„ç†é”™è¯¯æ˜¯å¯é ä»£ç çš„åŸºæœ¬ç‰¹å¾ã€‚åœ¨æœ¬èŠ‚ä¸­ï¼Œæ‚¨å°†æ·»åŠ ä¸€äº›ä»£ç æ¥ä»greetings1æ¨¡å—è¿”å›é”™è¯¯ï¼Œç„¶ååœ¨è°ƒç”¨è€…ä¸­å¤„ç†å®ƒã€‚ åœ¨greetings/greetings.goä¸­ï¼Œæ·»åŠ ä¸‹é¢çªå‡ºæ˜¾ç¤ºçš„ä»£ç ï¼Œå¦‚æœæ‚¨ä¸çŸ¥é“è¯¥å‘è°æ‰“æ‹›å‘¼ï¼Œåˆ™å‘é€é—®å€™æ˜¯æ²¡æœ‰æ„ä¹‰çš„ã€‚å¦‚æœåç§°ä¸ºç©ºï¼Œåˆ™å‘è°ƒç”¨è€…è¿”å›é”™è¯¯ã€‚å°†ä»¥ä¸‹ä»£ç å¤åˆ¶åˆ°greetings.goå¹¶ä¿å­˜æ–‡ä»¶ã€‚ package greetings1 import ( \u0026#34;errors\u0026#34; \u0026#34;fmt\u0026#34; ) // Hello returns a greeting for the named person. func Hello(name string) (string, error) { if name == \u0026#34;\u0026#34; { return \u0026#34;\u0026#34;, errors.New(\u0026#34;empty\u0026#34;) } message := fmt.Sprintf(\u0026#34;Hi, %v. Welcome!\u0026#34;, name) return message, nil } åœ¨æ­¤ä»£ç ä¸­ï¼š æ›´æ”¹å‡½æ•°ï¼Œä½¿å…¶è¿”å›ä¸¤ä¸ªå€¼ï¼ša stringå’Œan errorã€‚æ‚¨çš„è°ƒç”¨è€…å°†æ£€æŸ¥ç¬¬äºŒä¸ªå€¼ä»¥æŸ¥çœ‹æ˜¯å¦å‘ç”Ÿé”™è¯¯ã€‚ï¼ˆä»»ä½•Goå‡½æ•°éƒ½å¯ä»¥è¿”å›å¤šä¸ªå€¼ã€‚æœ‰å…³æ›´å¤šä¿¡æ¯ï¼Œè¯·å‚é˜…Effective Goã€‚ï¼‰ å¯¼å…¥Goæ ‡å‡†åº“errorsåŒ…ï¼Œä»¥ä¾¿æ‚¨å¯ä»¥ä½¿ç”¨å…¶errors.NewåŠŸèƒ½ã€‚ æ·»åŠ ifè¯­å¥ä»¥æ£€æŸ¥æ— æ•ˆè¯·æ±‚ï¼ˆåç§°åº”ä¸ºç©ºå­—ç¬¦ä¸²ï¼‰ï¼Œå¦‚æœè¯·æ±‚æ— æ•ˆåˆ™è¿”å›é”™è¯¯ã€‚è¯¥errors.Newå‡½æ•°è¿”å›ä¸€ä¸ª erroråŒ…å«æ‚¨çš„æ¶ˆæ¯ã€‚ æ·»åŠ nilï¼ˆæ„å‘³ç€æ²¡æœ‰é”™è¯¯ï¼‰ä½œä¸ºæˆåŠŸè¿”å›ä¸­çš„ç¬¬äºŒä¸ªå€¼ã€‚è¿™æ ·ï¼Œè°ƒç”¨è€…å°±å¯ä»¥çœ‹åˆ°å‡½æ•°æˆåŠŸäº†ã€‚ åœ¨hello2/hello.goæ–‡ä»¶ä¸­ï¼Œå¤„ç†Helloå‡½æ•°ç°åœ¨è¿”å›çš„é”™è¯¯ä»¥åŠéé”™è¯¯å€¼ã€‚å°†ä»¥ä¸‹ä»£ç ç²˜è´´åˆ°hello.goä¸­ã€‚ package main import ( \u0026#34;fmt\u0026#34; \u0026#34;gitee.com/phpbms/greetings1\u0026#34; \u0026#34;log\u0026#34; ) func main() { // Set properties of the predefined Logger, including // the log entry prefix and a flag to disable printing // the time, source file, and line number. log.SetPrefix(\u0026#34;greetings: \u0026#34;) log.SetFlags(0) // Request a greeting message. message, err := greetings1.Hello(\u0026#34;\u0026#34;) // If an error was returned, print it to the console and // exit the program. if err != nil { log.Fatal(err) } // If no error was returned, print the returned message // to the console. fmt.Println(message) } åœ¨æ­¤ä»£ç ä¸­ï¼š å°†logåŒ…é…ç½®ä¸ºåœ¨å…¶æ—¥å¿—æ¶ˆæ¯çš„å¼€å¤´æ‰“å°å‘½ä»¤åç§°ï¼ˆâ€œgreetings:â€ï¼‰ï¼Œä¸å¸¦æ—¶é—´æˆ³æˆ–æºæ–‡ä»¶ä¿¡æ¯ã€‚ å°†ä¸¤ä¸ªHelloè¿”å›å€¼ï¼ˆåŒ…æ‹¬ ï¼‰åˆ†é…errorç»™å˜é‡ã€‚ å°†Helloå‚æ•°ä»Gladysçš„åç§°æ›´æ”¹ä¸ºç©ºå­—ç¬¦ä¸²ï¼Œä»¥ä¾¿æ‚¨å¯ä»¥å°è¯•æ‚¨çš„é”™è¯¯å¤„ç†ä»£ç ã€‚ å¯»æ‰¾ä¸€ä¸ªéé›¶errorå€¼ã€‚åœ¨è¿™ç§æƒ…å†µä¸‹ç»§ç»­ä¸‹å»æ˜¯æ²¡æœ‰æ„ä¹‰çš„ã€‚ ä½¿ç”¨æ ‡å‡†åº“ä¸­çš„å‡½æ•°log packageè¾“å‡ºé”™è¯¯ä¿¡æ¯ã€‚å¦‚æœå‡ºç°é”™è¯¯ï¼Œåˆ™ä½¿ç”¨logåŒ…çš„Fatalå‡½æ•°æ‰“å°é”™è¯¯å¹¶åœæ­¢ç¨‹åºã€‚ åœ¨helloç›®å½•ä¸­çš„å‘½ä»¤è¡Œä¸­ï¼Œè¿è¡Œhello.goä»¥ç¡®è®¤ä»£ç æœ‰æ•ˆã€‚ç°åœ¨æ‚¨ä¼ å…¥ä¸€ä¸ªç©ºåç§°ï¼Œæ‚¨å°†æ”¶åˆ°é”™è¯¯æ¶ˆæ¯ã€‚ $ go run . greetings: empty name exit status 1 è¿”å›éšæœºé—®å€™è¯­å¥ åœ¨æœ¬èŠ‚ä¸­ï¼Œæ‚¨å°†æ›´æ”¹ä»£ç ï¼Œä»¥ä¾¿ä¸æ˜¯æ¯æ¬¡éƒ½è¿”å›ä¸€ä¸ªé—®å€™è¯­ï¼Œè€Œæ˜¯è¿”å›å¤šä¸ªé¢„å®šä¹‰çš„é—®å€™è¯­æ¶ˆæ¯ä¹‹ä¸€ã€‚ ä¸ºæ­¤ï¼Œæ‚¨å°†ä½¿ç”¨Goåˆ‡ç‰‡ã€‚åˆ‡ç‰‡ç±»ä¼¼äºæ•°ç»„ï¼Œä¸åŒä¹‹å¤„åœ¨äºå®ƒçš„å¤§å°ä¼šéšç€æ‚¨æ·»åŠ å’Œåˆ é™¤é¡¹ç›®è€ŒåŠ¨æ€å˜åŒ–ã€‚sliceæ˜¯Goæœ€æœ‰ç”¨çš„ç±»å‹ä¹‹ä¸€ã€‚ æ‚¨å°†æ·»åŠ ä¸€å°éƒ¨åˆ†æ¥åŒ…å«ä¸‰ä¸ªé—®å€™æ¶ˆæ¯ï¼Œç„¶åè®©æ‚¨çš„ä»£ç éšæœºè¿”å›å…¶ä¸­ä¸€ä¸ªæ¶ˆæ¯ã€‚æœ‰å…³åˆ‡ç‰‡çš„æ›´å¤šä¿¡æ¯ï¼Œè¯·å‚é˜…Goåšå®¢ä¸­çš„Goåˆ‡ç‰‡ã€‚ åœ¨greetings1/greetings.goä¸­ï¼Œæ›´æ”¹æ‚¨çš„ä»£ç ï¼Œä½¿å…¶çœ‹èµ·æ¥å¦‚ä¸‹æ‰€ç¤ºã€‚ package greetings1 import ( \u0026#34;errors\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;math/rand\u0026#34; \u0026#34;time\u0026#34; ) // Hello returns a greeting for the named person. func Hello(name string) (string, error) { if name == \u0026#34;\u0026#34; { return \u0026#34;\u0026#34;, errors.New(\u0026#34;empty\u0026#34;) } message := fmt.Sprintf(randomFormat(), name) return message, nil } // init sets initial values for variables used in the function. func init() { rand.Seed(time.Now().UnixNano()) } // randomFormat returns one of a set of greeting messages. The returned // message is selected at random. func randomFormat() string { // A slice of message formats. formats := []string{ \u0026#34;Hi, %v. Welcome!\u0026#34;, \u0026#34;Great to see you, %v!\u0026#34;, \u0026#34;Hail, %v! Well met!\u0026#34;, } return formats[rand.Intn(len(formats))] } åœ¨æ­¤ä»£ç ä¸­ï¼š æ·»åŠ ä¸€ä¸ªrandomFormatå‡½æ•°ï¼Œè¿”å›éšæœºé€‰æ‹©çš„é—®å€™æ¶ˆæ¯æ ¼å¼ã€‚è¯·æ³¨æ„ï¼Œ randomFormatä»¥å°å†™å­—æ¯å¼€å¤´ï¼Œä½¿å…¶åªèƒ½ç”±å…¶è‡ªå·±çš„åŒ…ä¸­çš„ä»£ç è®¿é—®ï¼ˆæ¢å¥è¯è¯´ï¼Œå®ƒä¸ä¼šè¢«å¯¼å‡ºï¼‰ã€‚ åœ¨ä¸­randomFormatï¼Œå£°æ˜ä¸€ä¸ªformatså…·æœ‰ä¸‰ç§æ¶ˆæ¯æ ¼å¼çš„åˆ‡ç‰‡ã€‚å½“å£°æ˜ä¸€ä¸ªåˆ‡ç‰‡ï¼Œä½ åœ¨æ‹¬å·å¿½ç•¥å®ƒçš„å¤§å°ï¼Œåƒè¿™æ ·ï¼š[]stringã€‚è¿™å‘Šè¯‰ Go åˆ‡ç‰‡åº•å±‚æ•°ç»„çš„å¤§å°å¯ä»¥åŠ¨æ€æ›´æ”¹ã€‚ ä½¿ç”¨math/rand åŒ…ç”Ÿæˆä¸€ä¸ªéšæœºæ•°ï¼Œç”¨äºä»åˆ‡ç‰‡ä¸­é€‰æ‹©ä¸€ä¸ªé¡¹ç›®ã€‚ æ·»åŠ ä¸€ä¸ªinitå‡½æ•°ä»¥randä½¿ç”¨å½“å‰æ—¶é—´ä¸ºåŒ…åšç§å­ã€‚Goinitåœ¨ç¨‹åºå¯åŠ¨æ—¶è‡ªåŠ¨æ‰§è¡Œå‡½æ•°ï¼Œåœ¨å…¨å±€å˜é‡åˆå§‹åŒ–åã€‚æœ‰å…³initå‡½æ•°çš„æ›´å¤šä¿¡æ¯ï¼Œè¯·å‚é˜… Effective Goã€‚ åœ¨ä¸­Helloï¼Œè°ƒç”¨è¯¥randomFormatå‡½æ•°ä»¥è·å–æ‚¨å°†è¿”å›çš„æ¶ˆæ¯çš„æ ¼å¼ï¼Œç„¶åä¸€èµ·ä½¿ç”¨è¯¥æ ¼å¼å’Œnameå€¼æ¥åˆ›å»ºè¯¥æ¶ˆæ¯ã€‚ åƒä»¥å‰ä¸€æ ·è¿”å›æ¶ˆæ¯ï¼ˆæˆ–é”™è¯¯ï¼‰ã€‚ åœ¨hello2/hello.goä¸­ï¼Œæ›´æ”¹æ‚¨çš„ä»£ç ï¼Œä½¿å…¶çœ‹èµ·æ¥å¦‚ä¸‹æ‰€ç¤ºã€‚æ‚¨åªæ˜¯å°†Gladysçš„åå­—ï¼ˆæˆ–ä¸åŒçš„åå­—ï¼Œå¦‚æœæ‚¨å–œæ¬¢ï¼‰ä½œä¸ºå‚æ•°æ·»åŠ åˆ°Hello hello.goä¸­çš„å‡½æ•°è°ƒç”¨ä¸­ã€‚ package main import ( \u0026#34;fmt\u0026#34; \u0026#34;gitee.com/phpbms/greetings1\u0026#34; \u0026#34;log\u0026#34; ) func main() { // Set properties of the predefined Logger, including // the log entry prefix and a flag to disable printing // the time, source file, and line number. log.SetPrefix(\u0026#34;greetings: \u0026#34;) log.SetFlags(0) // Request a greeting message. message, err := greetings1.Hello(\u0026#34;Gla\u0026#34;) // If an error was returned, print it to the console and // exit the program. if err != nil { log.Fatal(err) } // If no error was returned, print the returned message // to the console. fmt.Println(message) } åœ¨å‘½ä»¤è¡Œçš„helloç›®å½•ä¸­ï¼Œè¿è¡Œhello.goä»¥ç¡®è®¤ä»£ç æœ‰æ•ˆã€‚å¤šæ¬¡è¿è¡Œå®ƒï¼Œæ³¨æ„åˆ°é—®å€™è¯­å‘ç”Ÿäº†å˜åŒ–ã€‚ $ hello go run . Great to see you, Gla! $ hello go run . Great to see you, Gla! $ hello go run . Hi, Gla. Welcome! å›å¤å¤šäººé—®å€™ åœ¨æ‚¨å¯¹æ¨¡å—ä»£ç æ‰€åšçš„æœ€åæ›´æ”¹ä¸­ï¼Œæ‚¨å°†æ·»åŠ å¯¹åœ¨ä¸€ä¸ªè¯·æ±‚ä¸­ä¸ºå¤šäººè·å–é—®å€™çš„æ”¯æŒã€‚æ¢å¥è¯è¯´ï¼Œæ‚¨å°†å¤„ç†å¤šå€¼è¾“å…¥ï¼Œç„¶åå°†è¯¥è¾“å…¥ä¸­çš„å€¼ä¸å¤šå€¼è¾“å‡ºé…å¯¹ã€‚ä¸ºæ­¤ï¼Œæ‚¨éœ€è¦å°†ä¸€ç»„åç§°ä¼ é€’ç»™ä¸€ä¸ªå¯ä»¥ä¸ºæ¯ä¸ªåç§°è¿”å›é—®å€™è¯­çš„å‡½æ•°ã€‚ ä½†æœ‰ä¸€ä¸ªéšœç¢ã€‚å°†Helloå‡½æ•°çš„å‚æ•°ä»å•ä¸ªåç§°æ›´æ”¹ä¸ºä¸€ç»„åç§°ä¼šæ›´æ”¹å‡½æ•°çš„ç­¾åã€‚å¦‚æœæ‚¨å·²ç»å‘å¸ƒäº†example.com/greetings æ¨¡å—å¹¶ä¸”ç”¨æˆ·å·²ç»ç¼–å†™äº†è°ƒç”¨ çš„ä»£ç Helloï¼Œé‚£ä¹ˆè¿™ç§æ›´æ”¹ä¼šç ´åä»–ä»¬çš„ç¨‹åºã€‚ åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œæ›´å¥½çš„é€‰æ‹©æ˜¯ç¼–å†™ä¸€ä¸ªå…·æœ‰ä¸åŒåç§°çš„æ–°å‡½æ•°ã€‚æ–°å‡½æ•°å°†é‡‡ç”¨å¤šä¸ªå‚æ•°ã€‚è¿™ä¿ç•™äº†æ—§åŠŸèƒ½ä»¥å®ç°å‘åå…¼å®¹æ€§ã€‚ åœ¨greetings1/greetings.goä¸­ï¼Œæ›´æ”¹æ‚¨çš„ä»£ç ï¼Œä½¿å…¶çœ‹èµ·æ¥å¦‚ä¸‹æ‰€ç¤ºã€‚ package greetings1 import ( \u0026#34;errors\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;math/rand\u0026#34; \u0026#34;time\u0026#34; ) // Hello returns a greeting for the named person. func Hello(name string) (string, error) { if name == \u0026#34;\u0026#34; { return \u0026#34;\u0026#34;, errors.New(\u0026#34;empty\u0026#34;) } message := fmt.Sprintf(randomFormat(), name) return message, nil } // init sets initial values for variables used in the function. func init() { rand.Seed(time.Now().UnixNano()) } // randomFormat returns one of a set of greeting messages. The returned // message is selected at random. func randomFormat() string { // A slice of message formats. formats := []string{ \u0026#34;Hi, %v. Welcome!\u0026#34;, \u0026#34;Great to see you, %v!\u0026#34;, \u0026#34;Hail, %v! Well met!\u0026#34;, } return formats[rand.Intn(len(formats))] } // Hellos returns a map that associates each of the named people // with a greeting message. func Hellos(names []string) (map[string]string, error) { // A map to associate names with messages. messages := make(map[string]string, len(names)) // Loop through the received slice of names, calling // the Hello function to get a message for each name. for _, name := range names { message, err := Hello(name) if err != nil { return nil, err } // In the map, associate the retrieved message with // the name. messages[name] = message } return messages, nil } åœ¨æ­¤ä»£ç ä¸­ï¼š æ·»åŠ ä¸€ä¸ªHelloså‡½æ•°ï¼Œå…¶å‚æ•°æ˜¯ä¸€æ®µåç§°è€Œä¸æ˜¯å•ä¸ªåç§°ã€‚æ­¤å¤–ï¼Œæ‚¨å°†å…¶è¿”å›ç±»å‹ä¹‹ä¸€ä»aæ›´æ”¹stringä¸ºaï¼Œmapä»¥ä¾¿æ‚¨å¯ä»¥è¿”å›æ˜ å°„åˆ°é—®å€™æ¶ˆæ¯çš„åç§°ã€‚ è®©æ–°Helloså‡½æ•°è°ƒç”¨ç°æœ‰Helloå‡½æ•°ã€‚è¿™æœ‰åŠ©äºå‡å°‘é‡å¤ï¼ŒåŒæ—¶ä¿ç•™ä¸¤ä¸ªåŠŸèƒ½ã€‚ åˆ›å»ºmessagesæ˜ å°„ä»¥å°†æ¯ä¸ªæ¥æ”¶åˆ°çš„åç§°ï¼ˆä½œä¸ºé”®ï¼‰ä¸ç”Ÿæˆçš„æ¶ˆæ¯ï¼ˆä½œä¸ºå€¼ï¼‰ç›¸å…³è”ã€‚åœ¨Goä¸­ï¼Œæ‚¨ä½¿ç”¨ä»¥ä¸‹è¯­æ³•åˆå§‹åŒ–mapï¼šæ‚¨è®©å‡½æ•°å°†æ­¤æ˜ å°„è¿”å›ç»™è°ƒç”¨è€…ã€‚æœ‰å…³åœ°å›¾çš„æ›´å¤šä¿¡æ¯ï¼Œè¯·å‚é˜…Goåšå®¢ä¸Šçš„Go mapå®æˆ˜ã€‚make(map[*key-type*]*value-type*) å¾ªç¯éå†æ‚¨çš„å‡½æ•°æ”¶åˆ°çš„åç§°ï¼Œæ£€æŸ¥æ¯ä¸ªåç§°æ˜¯å¦å…·æœ‰éç©ºå€¼ï¼Œç„¶åå°†æ¶ˆæ¯ä¸æ¯ä¸ªåç§°å…³è”ã€‚åœ¨æ­¤ forå¾ªç¯ä¸­ï¼Œrangeè¿”å›ä¸¤ä¸ªå€¼ï¼šå¾ªç¯ä¸­å½“å‰é¡¹ç›®çš„ç´¢å¼•å’Œé¡¹ç›®å€¼çš„å‰¯æœ¬ã€‚æ‚¨ä¸éœ€è¦ç´¢å¼•ï¼Œå› æ­¤æ‚¨ä½¿ç”¨ Go ç©ºç™½æ ‡è¯†ç¬¦ï¼ˆä¸‹åˆ’çº¿ï¼‰æ¥å¿½ç•¥å®ƒã€‚æœ‰å…³æ›´å¤šä¿¡æ¯ï¼Œè¯·å‚é˜… Effective Go ä¸­çš„ç©ºç™½æ ‡è¯†ç¬¦ã€‚ åœ¨ä½ çš„hello2/hello.goè°ƒç”¨ä»£ç ä¸­ï¼Œä¼ é€’ä¸€æ®µåç§°ï¼Œç„¶åæ‰“å°ä½ è¿”å›çš„åç§°/æ¶ˆæ¯æ˜ å°„çš„å†…å®¹ã€‚åœ¨hello.goä¸­ï¼Œæ›´æ”¹æ‚¨çš„ä»£ç ï¼Œä½¿å…¶çœ‹èµ·æ¥å¦‚ä¸‹æ‰€ç¤ºã€‚ package main import ( \u0026#34;fmt\u0026#34; \u0026#34;gitee.com/phpbms/greetings1\u0026#34; \u0026#34;log\u0026#34; ) func main() { // Set properties of the predefined Logger, including // the log entry prefix and a flag to disable printing // the time, source file, and line number. log.SetPrefix(\u0026#34;greetings: \u0026#34;) log.SetFlags(0) names := []string{\u0026#34;Gladys\u0026#34;, \u0026#34;Samantha\u0026#34;, \u0026#34;Darrin\u0026#34;} // Request a greeting message. message, err := greetings1.Hellos(names) // If an error was returned, print it to the console and // exit the program. if err != nil { log.Fatal(err) } // If no error was returned, print the returned message // to the console. fmt.Println(message) } é€šè¿‡è¿™äº›æ›´æ”¹ï¼š åˆ›å»ºä¸€ä¸ªnameså˜é‡ä½œä¸ºåŒ…å«ä¸‰ä¸ªåç§°çš„åˆ‡ç‰‡ç±»å‹ã€‚ å°†nameså˜é‡ä½œä¸ºå‚æ•°ä¼ é€’ç»™ Helloså‡½æ•°ã€‚ åœ¨å‘½ä»¤è¡Œä¸­ï¼Œåˆ‡æ¢åˆ°åŒ…å«hello/hello.goçš„ç›®å½•ï¼Œç„¶åä½¿ç”¨go runæ¥ç¡®è®¤ä»£ç æ˜¯å¦æœ‰æ•ˆã€‚è¾“å‡ºåº”è¯¥æ˜¯å°†åç§°ä¸æ¶ˆæ¯ç›¸å…³è”çš„åœ°å›¾çš„å­—ç¬¦ä¸²è¡¨ç¤ºå½¢å¼ï¼Œå¦‚ä¸‹æ‰€ç¤ºï¼š $ go run . map[Darrin:Hail, Darrin! Well met! Gladys:Hail, Gladys! Well met! Samantha:Hail, Samantha! Well met!] æ·»åŠ æµ‹è¯• æ—¢ç„¶æ‚¨å·²ç»å°†ä»£ç æ”¾åˆ°äº†ä¸€ä¸ªç¨³å®šçš„ä½ç½®ï¼ˆé¡ºä¾¿è¯´ä¸€å¥ï¼Œåšå¾—å¾ˆå¥½ï¼‰ï¼Œè¯·æ·»åŠ ä¸€ä¸ªæµ‹è¯•ã€‚åœ¨å¼€å‘æœŸé—´æµ‹è¯•æ‚¨çš„ä»£ç å¯ä»¥æš´éœ²åœ¨æ‚¨è¿›è¡Œæ›´æ”¹æ—¶å‘ç°çš„é”™è¯¯ã€‚åœ¨æœ¬ä¸»é¢˜ä¸­ï¼Œæ‚¨å°†ä¸ºè¯¥Helloå‡½æ•°æ·»åŠ ä¸€ä¸ªæµ‹è¯• ã€‚ Go å¯¹å•å…ƒæµ‹è¯•çš„å†…ç½®æ”¯æŒä½¿æ‚¨å¯ä»¥æ›´è½»æ¾åœ°è¿›è¡Œæµ‹è¯•ã€‚å…·ä½“æ¥è¯´ï¼Œä½¿ç”¨å‘½åçº¦å®šã€Goçš„testingåŒ…å’Œgo testå‘½ä»¤ï¼Œæ‚¨å¯ä»¥å¿«é€Ÿç¼–å†™å’Œæ‰§è¡Œæµ‹è¯•ã€‚ åœ¨ greetings1 ç›®å½•ä¸­ï¼Œåˆ›å»ºä¸€ä¸ªåä¸ºgreetings_test.goçš„æ–‡ä»¶ã€‚ä»¥_test.goç»“å°¾çš„æ–‡ä»¶åå‘Šè¯‰go testå‘½ä»¤è¯¥æ–‡ä»¶åŒ…å«æµ‹è¯•å‡½æ•°ã€‚ åœ¨greetings_test.goä¸­ï¼Œç²˜è´´ä»¥ä¸‹ä»£ç å¹¶ä¿å­˜æ–‡ä»¶ã€‚ package greetings1 import ( \u0026#34;regexp\u0026#34; \u0026#34;testing\u0026#34; ) // TestHelloName calls greetings.Hello with a name, checking // for a valid return value. func TestHelloName(t *testing.T) { name := \u0026#34;Gladys\u0026#34; want := regexp.MustCompile(`\\b`+name+`\\b`) msg, err := Hello(\u0026#34;Gladys\u0026#34;) if !want.MatchString(msg) || err != nil { t.Fatalf(`Hello(\u0026#34;Gladys\u0026#34;) = %q, %v, want match for %#q, nil`, msg, err, want) } } // TestHelloEmpty calls greetings.Hello with an empty string, // checking for an error. func TestHelloEmpty(t *testing.T) { msg, err := Hello(\u0026#34;\u0026#34;) if msg != \u0026#34;\u0026#34; || err == nil { t.Fatalf(`Hello(\u0026#34;\u0026#34;) = %q, %v, want \u0026#34;\u0026#34;, error`, msg, err) } } åœ¨æ­¤ä»£ç ä¸­ï¼š åœ¨ä¸æ‚¨æ­£åœ¨æµ‹è¯•çš„ä»£ç ç›¸åŒçš„åŒ…ä¸­å®ç°æµ‹è¯•åŠŸèƒ½ã€‚ åˆ›å»ºä¸¤ä¸ªæµ‹è¯•å‡½æ•°æ¥æµ‹è¯•greetings.Hello å‡½æ•°ã€‚æµ‹è¯•å‡½æ•°åç§°çš„å½¢å¼ä¸ºTest*Name*ï¼Œå…¶ä¸­Nameè¡¨ç¤ºç‰¹å®šæµ‹è¯•çš„ä¸€äº›å†…å®¹ã€‚æ­¤å¤–ï¼Œæµ‹è¯•å‡½æ•°å°†æŒ‡å‘åŒ…testing.Tç±»å‹çš„æŒ‡é’ˆä½œä¸ºå‚æ•°ã€‚æ‚¨å¯ä»¥ä½¿ç”¨æ­¤å‚æ•°çš„æ–¹æ³•æ¥æŠ¥å‘Šå’Œè®°å½•æ‚¨çš„æµ‹è¯•ã€‚ å®ç°ä¸¤ä¸ªæµ‹è¯•ï¼š TestHelloNameè°ƒç”¨è¯¥Helloå‡½æ•°ï¼Œä¼ é€’ä¸€ä¸ªnameå€¼ï¼Œè¯¥å‡½æ•°åº”è¯¥èƒ½å¤Ÿä½¿ç”¨è¯¥å€¼è¿”å›æœ‰æ•ˆçš„å“åº”æ¶ˆæ¯ã€‚å¦‚æœè°ƒç”¨è¿”å›é”™è¯¯æˆ–æ„å¤–å“åº”æ¶ˆæ¯ï¼ˆä¸åŒ…å«æ‚¨ä¼ å…¥çš„åç§°çš„æ¶ˆæ¯ï¼‰ï¼Œåˆ™ä½¿ç”¨tå‚æ•°çš„Fatalfå°†æ¶ˆæ¯æ‰“å°åˆ°æ§åˆ¶å°å¹¶ç»“æŸæ‰§è¡Œã€‚ TestHelloEmpty``Helloç”¨ç©ºå­—ç¬¦ä¸²è°ƒç”¨å‡½æ•°ã€‚æ­¤æµ‹è¯•æ—¨åœ¨ç¡®è®¤æ‚¨çš„é”™è¯¯å¤„ç†å·¥ä½œæ­£å¸¸ã€‚å¦‚æœè°ƒç”¨è¿”å›éç©ºå­—ç¬¦ä¸²æˆ–æ²¡æœ‰é”™è¯¯ï¼Œåˆ™ä½¿ç”¨tå‚æ•°çš„Fatalfæ–¹æ³•å°†æ¶ˆæ¯æ‰“å°åˆ°æ§åˆ¶å°å¹¶ç»“æŸæ‰§è¡Œã€‚ åœ¨greetingsç›®å½•ä¸‹çš„å‘½ä»¤è¡Œï¼Œè¿è¡Œgo testå‘½ä»¤æ‰§è¡Œæµ‹è¯•ï¼Œè¯¥go testå‘½ä»¤æ‰§è¡Œæµ‹è¯•Testæ–‡ä»¶ï¼ˆåç§°ä»¥_test.goç»“å°¾ï¼‰ä¸­çš„æµ‹è¯•å‡½æ•°ï¼ˆåç§°ä»¥Test_å¼€å¤´ï¼‰ã€‚æ‚¨å¯ä»¥æ·»åŠ -væ ‡å¿—ä»¥è·å–åˆ—å‡ºæ‰€æœ‰æµ‹è¯•åŠå…¶ç»“æœçš„è¯¦ç»†è¾“å‡ºã€‚æµ‹è¯•åº”è¯¥é€šè¿‡ã€‚ $ go test PASS ok gitee.com/phpbms/greetings1 0.024s $ go test -v === RUN TestHelloName --- PASS: TestHelloName (0.00s) === RUN TestHelloEmpty --- PASS: TestHelloEmpty (0.00s) PASS ok gitee.com/phpbms/greetings1 0.025s ä¸­æ–­greetings.Helloå‡½æ•°ä»¥æŸ¥çœ‹å¤±è´¥çš„æµ‹è¯•ã€‚è¯¥TestHelloNameæµ‹è¯•åŠŸèƒ½æ£€æŸ¥æ‚¨æŒ‡å®šä¸ºåç§°çš„è¿”å›å€¼Helloå‡½æ•°çš„å‚æ•°ã€‚è¦æŸ¥çœ‹å¤±è´¥çš„æµ‹è¯•ç»“æœï¼Œè¯·æ›´æ”¹greetings.Helloå‡½æ•°ä½¿å…¶ä¸å†åŒ…å«åç§°ã€‚åœ¨greetings/greetings.goä¸­ï¼Œç²˜è´´ä»¥ä¸‹ä»£ç ä»£æ›¿ Helloå‡½æ•°ã€‚è¯·æ³¨æ„ï¼Œçªå‡ºæ˜¾ç¤ºçš„è¡Œä¼šæ›´æ”¹å‡½æ•°è¿”å›çš„å€¼ï¼Œå°±å¥½åƒnameå‚æ•°å·²è¢«æ„å¤–åˆ é™¤ä¸€æ ·ã€‚ // Hello returns a greeting for the named person. func Hello(name string) (string, error) { // If no name was given, return an error with a message. if name == \u0026#34;\u0026#34; { return name, errors.New(\u0026#34;empty name\u0026#34;) } // Create a message using a random format. // message := fmt.Sprintf(randomFormat(), name)\t// è¿™è¡Œæ›¿æ¢äº† message := fmt.Sprint(randomFormat()) return message, nil } åœ¨greetingsç›®å½•ä¸‹çš„å‘½ä»¤è¡Œï¼Œè¿è¡Œgo testæ‰§è¡Œæµ‹è¯•ã€‚è¿™ä¸€æ¬¡ï¼Œåœ¨go testæ²¡æœ‰-væ ‡å¿—çš„æƒ…å†µä¸‹è¿è¡Œã€‚è¾“å‡ºå°†ä»…åŒ…å«å¤±è´¥çš„æµ‹è¯•çš„ç»“æœï¼Œè¿™åœ¨æ‚¨è¿›è¡Œå¤§é‡æµ‹è¯•æ—¶éå¸¸æœ‰ç”¨ã€‚è¯¥TestHelloNameæµ‹è¯•å°†å¤±è´¥-TestHelloEmptyè¿˜é€šè¿‡ã€‚ $ go test -v === RUN TestHelloName greetings_test.go:15: Hello(\u0026#34;Gladys\u0026#34;) = \u0026#34;Hail, %v! Well met!\u0026#34;, \u0026lt;nil\u0026gt;, want match for `\\bGladys\\b`, nil --- FAIL: TestHelloName (0.00s) === RUN TestHelloEmpty --- PASS: TestHelloEmpty (0.00s) FAIL exit status 1 FAIL gitee.com/phpbms/greetings1 0.025s ç¼–è¯‘å¹¶å®‰è£…åº”ç”¨ç¨‹åº åœ¨æœ€åä¸€ä¸ªä¸»é¢˜ä¸­ï¼Œæ‚¨å°†å­¦ä¹ å‡ ä¸ªæ–°goå‘½ä»¤ã€‚è™½ç„¶è¯¥go runå‘½ä»¤æ˜¯åœ¨æ‚¨è¿›è¡Œé¢‘ç¹æ›´æ”¹æ—¶ç¼–è¯‘å’Œè¿è¡Œç¨‹åºçš„æœ‰ç”¨å¿«æ·æ–¹å¼ï¼Œä½†å®ƒä¸ä¼šç”ŸæˆäºŒè¿›åˆ¶å¯æ‰§è¡Œæ–‡ä»¶ã€‚ æœ¬ä¸»é¢˜ä»‹ç»äº†ä¸¤ä¸ªç”¨äºæ„å»ºä»£ç çš„é™„åŠ å‘½ä»¤ï¼š è¯¥go buildå‘½ä»¤ç¼–è¯‘åŒ…åŠå…¶ä¾èµ–é¡¹ï¼Œä½†ä¸å®‰è£…ç»“æœã€‚ è¯¥go installå‘½ä»¤ç¼–è¯‘å¹¶å®‰è£…è½¯ä»¶åŒ…ã€‚ æ­¥éª¤å¦‚ä¸‹ ä»hello2ç›®å½•ä¸­çš„å‘½ä»¤è¡Œï¼Œè¿è¡Œgo build å‘½ä»¤å°†ä»£ç ç¼–è¯‘ä¸ºå¯æ‰§è¡Œæ–‡ä»¶ã€‚ ä»hello2ç›®å½•ä¸­çš„å‘½ä»¤è¡Œï¼Œè¿è¡Œæ–°çš„hello å¯æ‰§è¡Œæ–‡ä»¶ä»¥ç¡®è®¤ä»£ç æœ‰æ•ˆã€‚è¯·æ³¨æ„ï¼Œæ ¹æ®æ‚¨åœ¨æµ‹è¯•åæ˜¯å¦æ›´æ”¹äº†greetings.goä»£ç ï¼Œæ‚¨çš„ç»“æœå¯èƒ½ä¼šæœ‰æ‰€ä¸åŒã€‚ åœ¨Linuxæˆ–Macä¸Šï¼š $ ./hello map[Darrin:Great to see you, Darrin! Gladys:Hail, Gladys! Well met! Samantha:Hail, Samantha! Well met!] åœ¨ Windows ä¸Šï¼š $ hello.exe map[Darrin:Great to see you, Darrin! Gladys:Hail, Gladys! Well met! Samantha:Hail, Samantha! Well met!] æ‚¨å·²å°†åº”ç”¨ç¨‹åºç¼–è¯‘ä¸ºå¯æ‰§è¡Œæ–‡ä»¶ï¼Œä»¥ä¾¿å¯ä»¥è¿è¡Œå®ƒã€‚ä½†æ˜¯è¦å½“å‰è¿è¡Œå®ƒï¼Œæ‚¨çš„æç¤ºéœ€è¦ä½äºå¯æ‰§è¡Œæ–‡ä»¶çš„ç›®å½•ä¸­ï¼Œæˆ–è€…æŒ‡å®šå¯æ‰§è¡Œæ–‡ä»¶çš„è·¯å¾„ã€‚æ¥ä¸‹æ¥ï¼Œæ‚¨å°†å®‰è£…å¯æ‰§è¡Œæ–‡ä»¶ï¼Œä»¥ä¾¿æ— éœ€æŒ‡å®šå…¶è·¯å¾„å³å¯è¿è¡Œå®ƒã€‚ å‘ç° Go å®‰è£…è·¯å¾„ï¼Œè¯¥goå‘½ä»¤å°†åœ¨å…¶ä¸­å®‰è£…å½“å‰åŒ…ã€‚æ‚¨å¯ä»¥é€šè¿‡è¿è¡Œå‘½ä»¤æ¥å‘ç°å®‰è£…è·¯å¾„ï¼Œ å¦‚ä¸‹ä¾‹æ‰€ç¤ºï¼š go list -f \u0026#39;{{.Target}}\u0026#39; ä¾‹å¦‚ï¼Œå‘½ä»¤çš„è¾“å‡ºå¯èƒ½æ˜¯/home/gopher/bin/helloï¼Œè¿™æ„å‘³ç€äºŒè¿›åˆ¶æ–‡ä»¶å®‰è£…åˆ°/home/gopher/binã€‚åœ¨ä¸‹ä¸€æ­¥ä¸­æ‚¨å°†éœ€è¦æ­¤å®‰è£…ç›®å½•ã€‚\nå°† Go å®‰è£…ç›®å½•æ·»åŠ åˆ°ç³»ç»Ÿçš„ shell è·¯å¾„ã€‚è¿™æ ·ï¼Œæ‚¨å°±å¯ä»¥è¿è¡Œç¨‹åºçš„å¯æ‰§è¡Œæ–‡ä»¶ï¼Œè€Œæ— éœ€æŒ‡å®šå¯æ‰§è¡Œæ–‡ä»¶çš„ä½ç½®ã€‚\nåœ¨Linuxæˆ–Macä¸Šï¼Œè¿è¡Œä»¥ä¸‹å‘½ä»¤ï¼š export PATH=$PATH:/path/to/your/install/directory åœ¨Windowsä¸Šï¼Œè¿è¡Œä»¥ä¸‹å‘½ä»¤ï¼š set PATH=%PATH%;C:\\path\\to\\your\\install\\directory ä½œä¸ºæ›¿ä»£æ–¹æ¡ˆï¼Œå¦‚æœæ‚¨$HOME/binåœ¨ shell è·¯å¾„ä¸­å·²ç»æœ‰ä¸€ä¸ªç›®å½• ï¼Œå¹¶ä¸”æ‚¨æƒ³åœ¨é‚£é‡Œå®‰è£… Go ç¨‹åºï¼Œæ‚¨å¯ä»¥é€šè¿‡GOBINä½¿ç”¨ä»¥ä¸‹å‘½ä»¤è®¾ç½®å˜é‡æ¥ æ›´æ”¹å®‰è£…ç›®æ ‡ï¼šgo env\ngo env -w GOBIN=/path/to/your/bin // or go env -w GOBIN=C:\\path\\to\\your\\bin æ›´æ–° shell è·¯å¾„åï¼Œè¿è¡Œgo installå‘½ä»¤æ¥ç¼–è¯‘å’Œå®‰è£…åŒ…ã€‚ go install åªéœ€é”®å…¥å…¶åç§°å³å¯è¿è¡Œæ‚¨çš„åº”ç”¨ç¨‹åºã€‚ä¸ºäº†ä½¿è¿™å˜å¾—æœ‰è¶£ï¼Œæ‰“å¼€ä¸€ä¸ªæ–°çš„å‘½ä»¤æç¤ºç¬¦å¹¶helloåœ¨å…¶ä»–ç›®å½•ä¸­è¿è¡Œå¯æ‰§è¡Œæ–‡ä»¶åç§°ã€‚ $ hello map[Darrin:Hail, Darrin! Well met! Gladys:Great to see you, Gladys! Samantha:Hail, Samantha! Well met!] ","permalink":"https://heliu.site/posts/golang/package/use-mod/","summary":"Golang åˆ›å»ºæ¨¡å—ä»‹ç»ã€‚","title":"åˆ›å»ºæ¨¡å—"},{"content":" æ‚¨å¯ä»¥å°†ç›¸å…³åŒ…æ”¶é›†åˆ°æ¨¡å—ä¸­ï¼Œç„¶åå‘å¸ƒæ¨¡å—ä¾›å…¶ä»–å¼€å‘äººå‘˜ä½¿ç”¨ã€‚æœ¬ä¸»é¢˜æ¦‚è¿°äº†å¼€å‘å’Œå‘å¸ƒæ¨¡å—ã€‚ ä¸ºäº†æ”¯æŒå¼€å‘ã€å‘å¸ƒå’Œä½¿ç”¨æ¨¡å—ï¼Œæ‚¨å¯ä»¥ä½¿ç”¨ï¼š æ‚¨å¼€å‘å’Œå‘å¸ƒæ¨¡å—çš„å·¥ä½œæµç¨‹ï¼Œéšç€æ—¶é—´çš„æ¨ç§»ä½¿ç”¨æ–°ç‰ˆæœ¬å¯¹å…¶è¿›è¡Œä¿®æ”¹ã€‚è¯·å‚é˜…ã€å¼€å‘å’Œå‘å¸ƒæ¨¡å—çš„å·¥ä½œæµç¨‹ã€‘ã€‚ å¸®åŠ©æ¨¡å—ç”¨æˆ·ç†è§£å¹¶ä»¥ç¨³å®šæ–¹å¼å‡çº§åˆ°æ–°ç‰ˆæœ¬çš„è®¾è®¡å®è·µã€‚è¯·å‚ã€é˜…è®¾è®¡å’Œå¼€å‘ã€‘ã€‚ ç”¨äºå‘å¸ƒæ¨¡å—å’Œæ£€ç´¢å…¶ä»£ç çš„å»ä¸­å¿ƒåŒ–ç³»ç»Ÿã€‚æ‚¨ä½¿æ‚¨çš„æ¨¡å—å¯ä¾›å…¶ä»–å¼€å‘äººå‘˜ä»æ‚¨è‡ªå·±çš„å­˜å‚¨åº“ä¸­ä½¿ç”¨å¹¶ä½¿ç”¨ç‰ˆæœ¬å·å‘å¸ƒã€‚è¯·å‚é˜… å»ä¸­å¿ƒåŒ–å‡ºç‰ˆã€‚ ä¸€ä¸ªåŒ…æœç´¢å¼•æ“å’Œæ–‡æ¡£æµè§ˆå™¨(pkg.go.dev)ï¼Œå¼€å‘äººå‘˜å¯ä»¥åœ¨å…¶ä¸­æ‰¾åˆ°æ‚¨çš„æ¨¡å—ã€‚è¯·å‚é˜…åŒ…å‘ç°ã€‚ ä¸€ç§æ¨¡å—ç‰ˆæœ¬ç¼–å·çº¦å®šï¼Œç”¨äºå‘ä½¿ç”¨æ‚¨çš„æ¨¡å—çš„å¼€å‘äººå‘˜ä¼ è¾¾å¯¹ç¨³å®šæ€§å’Œå‘åå…¼å®¹æ€§çš„æœŸæœ›ã€‚è¯·å‚é˜… ç‰ˆæœ¬æ§åˆ¶ã€‚ Go å·¥å…·ä½¿å…¶ä»–å¼€å‘äººå‘˜æ›´å®¹æ˜“ç®¡ç†ä¾èµ–é¡¹ï¼ŒåŒ…æ‹¬è·å–æ¨¡å—çš„æºä»£ç ã€å‡çº§ç­‰ã€‚è¯·å‚é˜…ç®¡ç†ä¾èµ–é¡¹ã€‚ ä¹Ÿå¯ä»¥çœ‹çœ‹ï¼š å¦‚æœæ‚¨åªæ˜¯å¯¹ä½¿ç”¨å…¶ä»–äººå¼€å‘çš„è½¯ä»¶åŒ…æ„Ÿå…´è¶£ï¼Œé‚£ä¹ˆè¿™ä¸æ˜¯æ‚¨çš„ä¸»é¢˜ã€‚ç›¸åï¼Œè¯·å‚é˜…ç®¡ç†ä¾èµ–é¡¹ã€‚ æœ‰å…³åŒ…å«ä¸€äº›æ¨¡å—å¼€å‘åŸºç¡€çŸ¥è¯†çš„æ•™ç¨‹ï¼Œè¯·å‚é˜…æ•™ç¨‹ï¼šåˆ›å»º Go æ¨¡å—ã€‚ å¼€å‘å’Œå‘å¸ƒæ¨¡å—çš„å·¥ä½œæµç¨‹ å½“æ‚¨æƒ³ä¸ºå…¶ä»–äººå‘å¸ƒæ‚¨çš„æ¨¡å—æ—¶ï¼Œæ‚¨å¯ä»¥é‡‡ç”¨ä¸€äº›çº¦å®šæ¥ç®€åŒ–è¿™äº›æ¨¡å—çš„ä½¿ç”¨ã€‚ æ¨¡å—å‘å¸ƒå’Œç‰ˆæœ¬æ§åˆ¶å·¥ä½œæµç¨‹ä¸­æ›´è¯¦ç»†åœ°æè¿°äº†ä»¥ä¸‹é«˜çº§æ­¥éª¤ã€‚ è®¾è®¡å’Œç¼–ç æ¨¡å—å°†åŒ…å«çš„åŒ…ã€‚ ä½¿ç”¨çº¦å®šå°†ä»£ç æäº¤åˆ°æ‚¨çš„å­˜å‚¨åº“ï¼Œä»¥ç¡®ä¿å…¶ä»–äººå¯ä»¥é€šè¿‡ Go å·¥å…·ä½¿ç”¨å®ƒã€‚ å‘å¸ƒæ¨¡å—ä»¥ä½¿å…¶å¯è¢«å¼€å‘äººå‘˜å‘ç°ã€‚ éšç€æ—¶é—´çš„æ¨ç§»ï¼Œä½¿ç”¨ä½¿ç”¨ç‰ˆæœ¬ç¼–å·çº¦å®šçš„ç‰ˆæœ¬æ¥ä¿®æ”¹æ¨¡å—ï¼Œä»¥è¡¨æ˜æ¯ä¸ªç‰ˆæœ¬çš„ç¨³å®šæ€§å’Œå‘åå…¼å®¹æ€§ã€‚ è®¾è®¡å’Œå¼€å‘ å¦‚æœæ¨¡å—ä¸­çš„åŠŸèƒ½å’ŒåŒ…å½¢æˆä¸€ä¸ªè¿è´¯çš„æ•´ä½“ï¼Œæ‚¨çš„æ¨¡å—å°†æ›´å®¹æ˜“è¢«å¼€å‘äººå‘˜æ‰¾åˆ°å’Œä½¿ç”¨ã€‚å½“ä½ è®¾è®¡ä¸€ä¸ªæ¨¡å—çš„å…¬å…± API æ—¶ï¼Œå°½é‡ä¿æŒå®ƒçš„åŠŸèƒ½é›†ä¸­å’Œç¦»æ•£ã€‚ æ­¤å¤–ï¼Œåœ¨è®¾è®¡å’Œå¼€å‘æ¨¡å—æ—¶è€ƒè™‘åˆ°å‘åå…¼å®¹æ€§å¯ä»¥å¸®åŠ©å…¶ç”¨æˆ·å‡çº§ï¼ŒåŒæ—¶æœ€å¤§é™åº¦åœ°å‡å°‘ä»–ä»¬è‡ªå·±çš„ä»£ç çš„æµå¤±ã€‚æ‚¨å¯ä»¥åœ¨ä»£ç ä¸­ä½¿ç”¨æŸäº›æŠ€æœ¯æ¥é¿å…å‘å¸ƒç ´åå‘åå…¼å®¹æ€§çš„ç‰ˆæœ¬ã€‚æœ‰å…³è¿™äº›æŠ€æœ¯çš„æ›´å¤šä¿¡æ¯ï¼Œè¯·å‚é˜…Goåšå®¢ä¸Šçš„ä¿æŒæ¨¡å—å…¼å®¹ã€‚ åœ¨å‘å¸ƒæ¨¡å—ä¹‹å‰ï¼Œæ‚¨å¯ä»¥ä½¿ç”¨replaceæŒ‡ä»¤åœ¨æœ¬åœ°æ–‡ä»¶ç³»ç»Ÿä¸Šå¼•ç”¨å®ƒã€‚è¿™ä½¿å¾—åœ¨æ¨¡å—ä»åœ¨å¼€å‘æ—¶ç¼–å†™è°ƒç”¨æ¨¡å—ä¸­çš„å‡½æ•°çš„å®¢æˆ·ç«¯ä»£ç å˜å¾—æ›´åŠ å®¹æ˜“ã€‚æœ‰å…³è¯¦ç»†ä¿¡æ¯ï¼Œè¯·å‚é˜…æ¨¡å—å‘å¸ƒå’Œç‰ˆæœ¬æ§åˆ¶å·¥ä½œæµç¨‹ä¸­çš„â€œé’ˆå¯¹æœªå‘å¸ƒçš„æ¨¡å—è¿›è¡Œç¼–ç â€ ã€‚ å»ä¸­å¿ƒåŒ–å‡ºç‰ˆ åœ¨Goä¸­ï¼Œæ‚¨é€šè¿‡åœ¨å­˜å‚¨åº“ä¸­æ ‡è®°å…¶ä»£ç æ¥å‘å¸ƒæ‚¨çš„æ¨¡å—ï¼Œä»¥ä½¿å…¶å¯ä¾›å…¶ä»–å¼€å‘äººå‘˜ä½¿ç”¨ã€‚ æ‚¨ä¸éœ€è¦å°†æ¨¡å—æ¨é€åˆ°é›†ä¸­å¼æœåŠ¡ï¼Œå› ä¸ºGoå·¥å…·å¯ä»¥ç›´æ¥ä»æ‚¨çš„å­˜å‚¨åº“ï¼ˆä½¿ç”¨æ¨¡å—çš„è·¯å¾„å®šä½ï¼Œè¿™æ˜¯ä¸€ä¸ªçœç•¥äº†è¯¥æ–¹æ¡ˆçš„URLï¼‰æˆ–ä»ä»£ç†æœåŠ¡å™¨ä¸‹è½½æ‚¨çš„æ¨¡å—ã€‚ åœ¨ä»–ä»¬çš„ä»£ç ä¸­å¯¼å…¥ä½ çš„åŒ…åï¼Œå¼€å‘äººå‘˜ä½¿ç”¨Goå·¥å…·ï¼ˆåŒ…æ‹¬go getå‘½ä»¤ï¼‰ä¸‹è½½ä½ çš„æ¨¡å—ä»£ç ä»¥è¿›è¡Œç¼–è¯‘ã€‚ä¸ºäº†æ”¯æŒæ­¤æ¨¡å‹ï¼Œæ‚¨éµå¾ªçº¦å®šå’Œæœ€ä½³å®è·µï¼Œä½¿Goå·¥å…·ï¼ˆä»£è¡¨å…¶ä»–å¼€å‘äººå‘˜ï¼‰å¯ä»¥ä»å­˜å‚¨åº“ä¸­æ£€ç´¢æ¨¡å—çš„æºä»£ç ã€‚ ä¾‹å¦‚ï¼ŒGoå·¥å…·ä½¿ç”¨ä½ æŒ‡å®šçš„æ¨¡å—çš„æ¨¡å—è·¯å¾„ï¼Œä»¥åŠä½ ç”¨æ¥æ ‡è®°æ¨¡å—ä»¥å‘å¸ƒçš„æ¨¡å—ç‰ˆæœ¬å·ï¼Œä¸ºå®ƒçš„ç”¨æˆ·å®šä½å’Œä¸‹è½½æ¨¡å—ã€‚ æœ‰å…³æºå’Œå‘å¸ƒçº¦å®šä»¥åŠæœ€ä½³å®è·µçš„æ›´å¤šä¿¡æ¯ï¼Œè¯·å‚é˜…ç®¡ç†æ¨¡å—æºã€‚ æœ‰å…³å‘å¸ƒæ¨¡å—çš„åˆ†æ­¥è¯´æ˜ï¼Œè¯·å‚é˜…å‘å¸ƒæ¨¡å—ã€‚ åŒ…å‘ç° åœ¨æ‚¨å‘å¸ƒäº†æ‚¨çš„æ¨¡å—å¹¶ä¸”æœ‰äººä½¿ç”¨Goå·¥å…·è·å–äº†å®ƒä¹‹åï¼Œå®ƒå°†åœ¨GoåŒ…å‘ç°ç«™ç‚¹pkg.go.devä¸Šå¯è§ã€‚åœ¨é‚£é‡Œï¼Œå¼€å‘äººå‘˜å¯ä»¥æœç´¢è¯¥ç«™ç‚¹ä»¥æ‰¾åˆ°å®ƒå¹¶é˜…è¯»å…¶æ–‡æ¡£ã€‚ è¦å¼€å§‹ä½¿ç”¨è¯¥æ¨¡å—ï¼Œå¼€å‘äººå‘˜ä»è¯¥æ¨¡å—å¯¼å…¥åŒ…ï¼Œç„¶åè¿è¡Œgo getå‘½ä»¤ä¸‹è½½å…¶æºä»£ç ä»¥è¿›è¡Œç¼–è¯‘ã€‚ æœ‰å…³å¼€å‘äººå‘˜å¦‚ä½•æŸ¥æ‰¾å’Œä½¿ç”¨æ¨¡å—çš„æ›´å¤šä¿¡æ¯ï¼Œè¯·å‚é˜…ç®¡ç†ä¾èµ–é¡¹ã€‚ ç‰ˆæœ¬æ§åˆ¶ å½“æ‚¨éšç€æ—¶é—´çš„æ¨ç§»ä¿®æ”¹å’Œæ”¹è¿›æ‚¨çš„æ¨¡å—æ—¶ï¼Œæ‚¨ä¼šåˆ†é…ç‰ˆæœ¬å·ï¼ˆåŸºäºè¯­ä¹‰ç‰ˆæœ¬æ§åˆ¶æ¨¡å‹ï¼‰ï¼Œæ—¨åœ¨è¡¨æ˜æ¯ä¸ªç‰ˆæœ¬çš„ç¨³å®šæ€§å’Œå‘åå…¼å®¹æ€§ã€‚è¿™æœ‰åŠ©äºä½¿ç”¨æ‚¨çš„æ¨¡å—çš„å¼€å‘äººå‘˜ç¡®å®šæ¨¡å—ä½•æ—¶ç¨³å®šä»¥åŠå‡çº§æ˜¯å¦å¯èƒ½åŒ…æ‹¬è¡Œä¸ºçš„é‡å¤§å˜åŒ–ã€‚æ‚¨å¯ä»¥é€šè¿‡åœ¨å­˜å‚¨åº“ä¸­æ ‡è®°æ¨¡å—çš„æºä»£ç æ¥æŒ‡ç¤ºæ¨¡å—çš„ç‰ˆæœ¬å·ã€‚ æœ‰å…³å¼€å‘ä¸»è¦ç‰ˆæœ¬æ›´æ–°çš„æ›´å¤šä¿¡æ¯ï¼Œè¯·å‚é˜…å¼€å‘ä¸»è¦ç‰ˆæœ¬æ›´æ–°ã€‚ æœ‰å…³å¦‚ä½•ä¸ºGoæ¨¡å—ä½¿ç”¨è¯­ä¹‰ç‰ˆæœ¬æ§åˆ¶æ¨¡å‹çš„æ›´å¤šä¿¡æ¯ï¼Œè¯·å‚é˜…æ¨¡å—ç‰ˆæœ¬ç¼–å·ã€‚ æ¨¡å—å‘å¸ƒå’Œç‰ˆæœ¬æ§åˆ¶å·¥ä½œæµç¨‹ å½“æ‚¨å¼€å‘ä¾›å…¶ä»–å¼€å‘äººå‘˜ä½¿ç”¨çš„æ¨¡å—æ—¶ï¼Œæ‚¨å¯ä»¥éµå¾ªæœ‰åŠ©äºç¡®ä¿ä½¿ç”¨è¯¥æ¨¡å—çš„å¼€å‘äººå‘˜è·å¾—å¯é ã€ä¸€è‡´çš„ä½“éªŒçš„å·¥ä½œæµç¨‹ã€‚ æœ¬ä¸»é¢˜æè¿°äº†è¯¥å·¥ä½œæµä¸­çš„é«˜çº§æ­¥éª¤ã€‚ æœ‰å…³æ¨¡å—å¼€å‘çš„æ¦‚è¿°ï¼Œè¯·å‚é˜…å¼€å‘å’Œå‘å¸ƒæ¨¡å—ã€‚ ä¹Ÿå¯ä»¥çœ‹çœ‹ å¦‚æœæ‚¨åªæƒ³åœ¨ä»£ç ä¸­ä½¿ç”¨å¤–éƒ¨åŒ…ï¼Œè¯·åŠ¡å¿…æŸ¥çœ‹ç®¡ç†ä¾èµ–é¡¹ã€‚ å¯¹äºæ¯ä¸ªæ–°ç‰ˆæœ¬ï¼Œæ‚¨éƒ½ç”¨å…¶ç‰ˆæœ¬å·è¡¨ç¤ºå¯¹æ¨¡å—çš„æ›´æ”¹ã€‚æœ‰å…³æ›´å¤šä¿¡æ¯ï¼Œè¯·å‚é˜…æ¨¡å—ç‰ˆæœ¬ç¼–å·ã€‚ å¸¸è§çš„å·¥ä½œæµç¨‹æ­¥éª¤ ä»¥ä¸‹åºåˆ—è¯´æ˜äº†ç¤ºä¾‹æ–°æ¨¡å—çš„å‘å¸ƒå’Œç‰ˆæœ¬æ§åˆ¶å·¥ä½œæµç¨‹æ­¥éª¤ã€‚æœ‰å…³æ¯ä¸ªæ­¥éª¤çš„æ›´å¤šä¿¡æ¯ï¼Œè¯·å‚é˜…æœ¬ä¸»é¢˜ä¸­çš„éƒ¨åˆ†ã€‚\nå¼€å§‹ä¸€ä¸ªæ¨¡å—å¹¶ç»„ç»‡å®ƒçš„æºä»£ç ï¼Œä½¿å¼€å‘äººå‘˜æ›´å®¹æ˜“ä½¿ç”¨å’Œç»´æŠ¤ã€‚å¦‚æœæ‚¨æ˜¯å¼€å‘æ¨¡å—çš„æ–°æ‰‹ï¼Œè¯·æŸ¥çœ‹æ•™ç¨‹ï¼šåˆ›å»ºGoæ¨¡å—ã€‚åœ¨ Go çš„å»ä¸­å¿ƒåŒ–æ¨¡å—å‘å¸ƒç³»ç»Ÿä¸­ï¼Œå¦‚ä½•ç»„ç»‡ä»£ç å¾ˆé‡è¦ã€‚æœ‰å…³æ›´å¤šä¿¡æ¯ï¼Œè¯·å‚é˜…ç®¡ç†æ¨¡å—æºã€‚ è®¾ç½®ä¸ºç¼–å†™è°ƒç”¨æœªå‘å¸ƒæ¨¡å—ä¸­çš„å‡½æ•°çš„æœ¬åœ°å®¢æˆ·ç«¯ä»£ç ã€‚åœ¨å‘å¸ƒæ¨¡å—ä¹‹å‰ï¼Œå¯¹äºä½¿ç”¨è¯¸å¦‚go getã€‚ åœ¨æ­¤é˜¶æ®µæµ‹è¯•æ¨¡å—ä»£ç çš„ä¸€ä¸ªå¥½æ–¹æ³•æ˜¯åœ¨å®ƒä½äºè°ƒç”¨ä»£ç çš„æœ¬åœ°ç›®å½•ä¸­æ—¶å°è¯•å®ƒã€‚æœ‰å…³æœ¬åœ°å¼€å‘çš„æ›´å¤šä¿¡æ¯ï¼Œè¯·å‚é˜…é’ˆå¯¹æœªå‘å¸ƒçš„æ¨¡å—è¿›è¡Œç¼–ç ã€‚ å½“æ¨¡å—çš„ä»£ç å‡†å¤‡å¥½ä¾›å…¶ä»–å¼€å‘äººå‘˜è¯•ç”¨æ—¶ï¼Œå¼€å§‹å‘å¸ƒv0é¢„å‘å¸ƒç‰ˆæœ¬ï¼Œä¾‹å¦‚alphaå’Œbetaã€‚æœ‰å…³æ›´å¤šä¿¡æ¯ï¼Œè¯·å‚é˜…å‘å¸ƒé¢„å‘å¸ƒç‰ˆæœ¬ã€‚ å‘å¸ƒä¸€ä¸ªä¸ä¿è¯ç¨³å®š**çš„v0ï¼Œä½†ç”¨æˆ·å¯ä»¥å°è¯•ã€‚**æœ‰å…³æ›´å¤šä¿¡æ¯ï¼Œè¯·å‚é˜…å‘å¸ƒç¬¬ä¸€ä¸ªï¼ˆä¸ç¨³å®šï¼‰ç‰ˆæœ¬ã€‚ åœ¨æ‚¨çš„ v0 ç‰ˆæœ¬å‘å¸ƒåï¼Œæ‚¨å¯ä»¥ï¼ˆå¹¶ä¸”åº”è¯¥ï¼ï¼‰ç»§ç»­ å‘å¸ƒå®ƒçš„æ–°ç‰ˆæœ¬ã€‚è¿™äº›æ–°ç‰ˆæœ¬å¯èƒ½åŒ…æ‹¬é”™è¯¯ä¿®å¤ï¼ˆè¡¥ä¸ç‰ˆæœ¬ï¼‰ã€å¯¹æ¨¡å—å…¬å…± API çš„æ·»åŠ ï¼ˆæ¬¡è¦ç‰ˆæœ¬ï¼‰ï¼Œç”šè‡³æ˜¯é‡å¤§æ›´æ”¹ã€‚ç”±äºv0ç‰ˆæœ¬ä¸ä¿è¯ç¨³å®šæ€§æˆ–å‘åå…¼å®¹æ€§ï¼Œå› æ­¤æ‚¨å¯ä»¥å¯¹å…¶ç‰ˆæœ¬è¿›è¡Œé‡å¤§æ›´æ”¹ã€‚æœ‰å…³æ›´å¤šä¿¡æ¯ï¼Œè¯·å‚é˜…å‘å¸ƒé”™è¯¯ä¿®å¤å’Œå‘å¸ƒéç ´åæ€§APIæ›´æ”¹ã€‚ å½“æ‚¨å‡†å¤‡å¥½å‘å¸ƒçš„ç¨³å®šç‰ˆæœ¬æ—¶ï¼Œæ‚¨å¯ä»¥å°†é¢„å‘å¸ƒç‰ˆæœ¬å‘å¸ƒä¸ºalphaså’Œbetasã€‚æœ‰å…³æ›´å¤šä¿¡æ¯ï¼Œè¯·å‚é˜…å‘å¸ƒé¢„å‘å¸ƒç‰ˆæœ¬ã€‚ å‘å¸ƒ v1 ä½œä¸ºç¬¬ä¸€ä¸ªç¨³å®šç‰ˆæœ¬ã€‚è¿™æ˜¯å¯¹æ¨¡å—ç¨³å®šæ€§åšå‡ºæ‰¿è¯ºçš„ç¬¬ä¸€ä¸ªç‰ˆæœ¬ã€‚æœ‰å…³æ›´å¤šä¿¡æ¯ï¼Œè¯·å‚é˜…å‘å¸ƒç¬¬ä¸€ä¸ªç¨³å®šç‰ˆæœ¬ã€‚ åœ¨ v1 ç‰ˆæœ¬ä¸­ï¼Œç»§ç»­ä¿®å¤é”™è¯¯ï¼Œå¹¶åœ¨å¿…è¦æ—¶å¯¹æ¨¡å—çš„å…¬å…± API è¿›è¡Œæ·»åŠ ã€‚æœ‰å…³æ›´å¤šä¿¡æ¯ï¼Œè¯·å‚é˜…å‘å¸ƒé”™è¯¯ä¿®å¤å’Œå‘å¸ƒéç ´åæ€§ API æ›´æ”¹ã€‚ å¦‚æœæ— æ³•é¿å…ï¼Œè¯·åœ¨æ–°çš„ä¸»è¦ç‰ˆæœ¬ä¸­å‘å¸ƒé‡å¤§æ›´æ”¹ã€‚ä¸»è¦ç‰ˆæœ¬æ›´æ–°â€”â€”ä¾‹å¦‚ä» v1.xx åˆ° v2.xxâ€”â€”å¯¹äºæ¨¡å—çš„ç”¨æˆ·æ¥è¯´å¯èƒ½æ˜¯ä¸€ä¸ªéå¸¸å…·æœ‰ç ´åæ€§çš„å‡çº§ã€‚è¿™åº”è¯¥æ˜¯æœ€åçš„æ‰‹æ®µã€‚æœ‰å…³æ›´å¤šä¿¡æ¯ï¼Œè¯·å‚é˜…å‘å¸ƒé‡å¤§ API æ›´æ”¹ã€‚ ","permalink":"https://heliu.site/posts/golang/package/publish-mod/","summary":"Golang å‘å¸ƒæ¨¡å—æµç¨‹ä»‹ç»ã€‚","title":"å¼€å‘å’Œå‘å¸ƒæ¨¡å—"},{"content":"æ•°ç»„çš„å®šä¹‰ ğŸš€ æ•°ç»„æ˜¯å…·æœ‰ç›¸åŒå”¯ä¸€ç±»å‹çš„ä¸€ç»„å·²ç¼–ç ä¸”é•¿åº¦å›ºå®šçš„æ•°æ®é¡¹åºåˆ—ã€‚ è¿™æ˜¯ä¸€ç§åŒæ„çš„æ•°æ®ç»“æ„ï¼Œè¿™ç§ç±»å‹å¯ä»¥æ˜¯ä»»æ„çš„åŸºç¡€ç±»å‹ï¼Œå¦‚æ•´å‹ã€å­—ç¬¦ä¸²æˆ–è‡ªå®šä¹‰ç±»å‹ã€‚ æ•°ç»„é•¿åº¦å¿…é¡»æ˜¯ä¸€ä¸ªå¸¸é‡è¡¨è¾¾å¼ï¼ˆç¼–è¯‘æœŸé—´èƒ½ç¡®å®šçš„å€¼ï¼‰ï¼Œå¹¶ä¸”æ˜¯ä¸€ä¸ªéè´Ÿæ•°ã€‚ æ•°ç»„çš„é•¿åº¦ä¹Ÿæ˜¯æ•°ç»„ç±»å‹çš„ä¸€éƒ¨åˆ†ï¼Œ[5]intå’Œ[10]intæ˜¯å±äºä¸åŒç±»å‹ã€‚ å¦‚æœæƒ³è®©æ•°ç»„å…ƒç´ ï¼Œç±»å‹ä¸ºä»»æ„ç±»å‹ï¼Œå¯ä»¥ä½¿ç”¨ç©ºæ¥å£interface{}ä½œä¸ºç±»å‹ï¼Œä½†ä½¿ç”¨æ—¶ï¼Œå¿…é¡»å…ˆåšä¸€ä¸ªç±»å‹åˆ¤æ–­ã€‚ è®¿é—®è¶Šç•Œï¼Œå¦‚æœä¸‹æ ‡åœ¨æ•°ç»„åˆæ³•èŒƒå›´ä¹‹å¤–ï¼Œåˆ™è§¦å‘è®¿é—®è¶Šç•Œï¼Œä¼španicã€‚ æ•°ç»„æ˜¯å€¼ç±»å‹ï¼Œèµ‹å€¼å’Œä¼ å‚ä¼šå¤åˆ¶æ•´ä¸ªæ•°ç»„ï¼Œè€Œä¸æ˜¯æŒ‡é’ˆã€‚å› æ­¤æ”¹å˜å‰¯æœ¬çš„å€¼ï¼Œä¸ä¼šæ”¹å˜æœ¬èº«çš„å€¼ã€‚ åªæ”¯æŒ \u0026ldquo;==\u0026quot;ã€\u0026rdquo;!=\u0026quot; æ“ä½œç¬¦ã€‚ï¼ˆä¸æ”¯æŒ \u0026ldquo;\u0026gt;\u0026quot;ã€\u0026quot;\u0026lt;\u0026quot;ã€\u0026quot;\u0026gt;=\u0026quot;ã€\u0026quot;\u0026lt;=\u0026quot;ï¼ŒåŸå› æ˜¯å¤§äºã€å°äºå¯¹äºæ•°ç»„æ¥è¯´æ²¡å•¥æ„ä¹‰ï¼Œæˆ‘ä»¬ä¹Ÿä¸ä¼šæ¯”è¾ƒä¸¤ä¸ªæ•°ç»„è°å¤§è°å°ï¼‰ æŒ‡é’ˆæ•°ç»„ [n]*Tï¼Œæ•°ç»„æŒ‡é’ˆ *[n]Tã€‚ æ•°ç»„å…ƒç´ ä¸ºç©ºæ¥å£ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;unsafe\u0026#34; ) func main() { // æ•°ç»„ a æ‰€å å†…å­˜ 16 * 5 = 80 å­—èŠ‚ var a [5]interface{} = [5]interface{}{1, \u0026#34;hello\u0026#34;, false, 0.23, 2i} // ç©ºæ¥å£çš„ç»“æ„æ„é€ ï¼Œtype eface struct {typ *_type, data uintptr} fmt.Printf(\u0026#34;æ•°ç»„aå ç”¨å†…å­˜çš„å¤§å°%d\\n\u0026#34;, unsafe.Sizeof(a))\t// æ•°ç»„aå ç”¨å†…å­˜çš„å¤§å°80 5*(8+8) // [5]interface {}{1, \u0026#34;hello\u0026#34;, false, 0.23, (0+2i)} fmt.Printf(\u0026#34;%#v\\n\u0026#34;, a) // è¿™é‡Œéå†å¯ä»¥æ”¹æˆéå† \u0026amp;aï¼Œè¿™æ ·é¿å…äº†å¤§æ•°ç»„çš„å¤åˆ¶ // å˜é‡æŒ‡é’ˆæ•°ç»„æ˜¯Goçš„è¯­æ³•ç³– for i, v := range a { // ã€int, anyã€‘ fmt.Printf(\u0026#34;i:%d v:%#v t:%T\\n\u0026#34;, i , v, v) // å¿…é¡»è¦åšæ–­è¨€æ‰èƒ½ä½¿ç”¨ï¼Œç©ºæ¥å£.(å…·ä½“ç±»å‹) if ii, ok := v.(int); ok { fmt.Println(ii + 10) } } // Output: // æ•°ç»„aå ç”¨å†…å­˜çš„å¤§å°80 // [5]interface {}{1, \u0026#34;hello\u0026#34;, false, 0.23, (0+2i)} // i:0 v:1 t:int // 11 // i:1 v:\u0026#34;hello\u0026#34; t:string // i:2 v:false t:bool // i:3 v:0.23 t:float64 // i:4 v:(0+2i) t:complex128 } æŒ‡é’ˆæ•°ç»„å’Œæ•°ç»„æŒ‡é’ˆ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 package main import \u0026#34;fmt\u0026#34; func main() { // 1. æŒ‡é’ˆæ•°ç»„ï¼Œæ•°ç»„çš„å…ƒç´ æ˜¯æŒ‡é’ˆç±»å‹ var p1 [2]*int = [2]*int{} // [2]*int{nil, nil} fmt.Println(p1) var a int = 5 p1[1] = \u0026amp;a fmt.Println(p1) // Output: // [\u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt;] // [\u0026lt;nil\u0026gt; 0xc00000e0b8] // 2. æ•°ç»„æŒ‡é’ˆ var p2 *[2]int fmt.Println(p2) a1 := [2]int{1, 2} p2 = \u0026amp;a1 fmt.Printf(\u0026#34;%#v\u0026#34;, p2) // Output // \u0026lt;nil\u0026gt; // \u0026amp;[2]int{1, 2} } æ•°ç»„å’Œæ•°ç»„æŒ‡é’ˆ åœ¨Goä¸­æ•°ç»„å’Œæ•°ç»„æŒ‡é’ˆçš„ç”¨æ³•åŸºæœ¬ä¸€è‡´ï¼Œèƒ½éå†ï¼ˆrangeï¼‰ã€èµ‹å€¼ã€å–å€¼ã€æ±‚é•¿åº¦ç­‰ï¼Œè¿™æ˜¯ç”±äºæ•°ç»„æŒ‡é’ˆæ“ä½œæ—¶å­˜åœ¨è¯­æ³•ç³–æ”¯æŒã€‚ åˆ‡ç‰‡(slice)åˆ™ä¸å…è®¸è¿™æ ·æ“ä½œï¼Œåªæœ‰æ•°ç»„æ˜¯ç‰¹æœ‰çš„ï¼Œä¸ºå•¥æ•°ç»„æ”¯æŒéå†æ•°ç»„åœ°å€ï¼Œå¾ˆå¤§åŸå› æ˜¯å¤§æ•°æ®æ•°ç»„éå†çš„æ‹·è´å¼€é”€æ¯”è¾ƒå¤§ï¼Œé‡‡ç”¨æŒ‡é’ˆå½¢å¼åˆ™ä¸éœ€è¦æ‹·è´ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 { // *[5]int a1 := new([5]int) // 1) è¯­æ³•ç³–ï¼š (*a1)[0] = 12 a1[0] = 12\t// 2) è¯­æ³•ç³–ï¼š c := (*a1)[1] c := a1[1]\t// 3) è¯­æ³•ç³–ï¼š l := len(*a1) l := len(a1)\t// éå†a1ï¼Œè¿™æ˜¯ç”±äºä¸Šé¢ä¸¤ä¸ªè¯­æ³•ç³–(2)(3)çš„æ”¯æŒ for i := range a1 { // ã€int, intã€‘ } } æ•°ç»„çš„å£°æ˜ä¸ä½¿ç”¨ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 // 1) æŒ‡å®šç´¢å¼• var a = [5]string{3:\u0026#34;hello\u0026#34;, \u0026#34;world\u0026#34;} // [5]string{\u0026#34;\u0026#34;, \u0026#34;\u0026#34;, \u0026#34;\u0026#34;, \u0026#34;hello\u0026#34;, \u0026#34;world\u0026#34;} fmt.Printf(\u0026#34;%#v\\n\u0026#34;, a) // 2) ... åªèƒ½ç”¨åœ¨æœ€å¤–å±‚æ•°ç»„ // ... çš„ç”¨æ³• // 1. ç”¨äºæ•°ç»„å£°æ˜çš„æœ€å¤–å±‚æ•°ç»„ï¼Œè‡ªåŠ¨ç»Ÿè®¡æ•°ç»„é•¿åº¦ã€‚ // 2. ç”¨ä½œå‡½æ•°çš„æœ€åä¸€ä¸ªå‚æ•°ï¼Œ...T è¡¨ç¤ºå¯å˜å‚æ•° []T åˆ‡ç‰‡å½¢å¼ã€‚ // 3. ç”¨ä½œåˆ‡ç‰‡å []T... è¡¨ç¤ºè§£å¼•ç”¨ã€‚ã€append([]int{1,2}, []int{3,4,5}...)ã€‘ // 4. åªæœ‰åœ¨ã€append([]byte(\u0026#34;hello \u0026#34;), \u0026#34;world\u0026#34;...)ã€‘æ—¶å¯ä»¥ä½¿ç”¨ ã€string...ã€‘ å½¢å¼å…¶ä»–åœ°æ–¹ä¸è¢«å…è®¸ã€‚ // slice = append(slice, elem1, elem2) // slice = append(slice, anotherSlice...) // slice = append([]byte(\u0026#34;hello \u0026#34;), \u0026#34;world\u0026#34;...) // ... ä½œä¸ºè§£å¼•ç”¨æ—¶ï¼Œåªèƒ½ç”¨åœ¨Sliceå’Œstringä¸­ var b = [...]string{3:\u0026#34;hello\u0026#34;, \u0026#34;world\u0026#34;} // [5]string{\u0026#34;\u0026#34;, \u0026#34;\u0026#34;, \u0026#34;\u0026#34;, \u0026#34;hello\u0026#34;, \u0026#34;world\u0026#34;} fmt.Printf(\u0026#34;%#v\\n\u0026#34;, b) // 3) é»˜è®¤å€¼ï¼Œæ³¨æ„ä¸æ˜¯ç©ºæ•°ç»„ï¼Œæ•°ç»„ä¸å­˜åœ¨ç©ºæ•°ç»„æ¦‚å¿µï¼Œæ•°ç»„ä¸­ä¸€å®šæ˜¯å­˜åœ¨å€¼çš„å³ä½¿æ˜¯é»˜è®¤å€¼ var c [2]uint8\t// [2]uint8{0, 0} // Output: // [5]string{\u0026#34;\u0026#34;, \u0026#34;\u0026#34;, \u0026#34;\u0026#34;, \u0026#34;hello\u0026#34;, \u0026#34;world\u0026#34;} // [5]string{\u0026#34;\u0026#34;, \u0026#34;\u0026#34;, \u0026#34;\u0026#34;, \u0026#34;hello\u0026#34;, \u0026#34;world\u0026#34;} ä¸€ç»´æ•°ç»„æˆ–å¤šç»´æ•°ç»„ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 package main import ( \u0026#34;fmt\u0026#34; ) func main() { // 1. å¸¸ç”¨åˆå§‹åŒ– var arrAge = [5]int{15,16,15,18,17}\t// [5]int{15,16,15,18,17}\t// 2. æŒ‡å®šç´¢å¼•ä½ç½®çš„åˆå§‹åŒ– var arrName = [5]string{3:\u0026#34;Chris\u0026#34;, 4:\u0026#34;Ron\u0026#34;}\t// [5]string{\u0026#34;\u0026#34;,\u0026#34;\u0026#34;,\u0026#34;\u0026#34;,\u0026#34;Chris\u0026#34;, \u0026#34;Ron\u0026#34;} var arrCount = [4]int{500, 2:100}\t// [4]int{500,0,100,0} // 3. æ•°ç»„é•¿åº¦åˆå§‹åŒ–æ ¹æ®å…ƒç´ å¤šå°‘å†³å®š var arrLazy = [...]int{5,6,7,8,23}\t// [5]int{5,6,7,8,23}\tvar arrPack = [...]int{10,5:100}\t// [6]int{10,0,0,0,0,100} // 4. ä¸æŒ‡å®šé»˜è®¤å€¼ var arrRoom [20]int\t// [20]int{0,0,0,...} // 5. ä½¿ç”¨newå‡½æ•° var arrBed = new([20]int)\t// *[20]int{0,0,0,...} // 6. æ•°ç»„ç±»å‹æ˜¯ç»“æ„ä½“ d := [...]struct{ name string\t// å 16å­—èŠ‚ age uint8\t// å 1å­—èŠ‚ å†…å­˜å¯¹é½å å 8å­—èŠ‚ }{ {\u0026#34;user1\u0026#34;, 10}, {\u0026#34;user2\u0026#34;, 20},\t// åˆ«å¿˜äº†æœ€åä¸€è¡Œçš„é€—å·ï¼Œè¿™æ˜¯ç”±äºGOè¯­æ³•è§£æ } fmt.Println(unsafe.Sizeof(d))\t// 48 = (16+8) * 2 fmt.Printf(\u0026#34;arrAge:%#v arrAge:Type:%T\\n\u0026#34;, arrAge, arrAge) fmt.Printf(\u0026#34;arrName:%#v arrName:Type:%T\\n\u0026#34;, arrName, arrName) fmt.Printf(\u0026#34;arrCount:%#v arrCount:Type:%T\\n\u0026#34;, arrCount, arrCount) fmt.Printf(\u0026#34;arrLazy:%#v arrLazy:Type:%T\\n\u0026#34;, arrLazy, arrLazy) fmt.Printf(\u0026#34;arrPack:%#v arrPack:Type:%T\\n\u0026#34;, arrPack, arrPack) fmt.Printf(\u0026#34;arrRoom:%#v arrRoom:Type:%T\\n\u0026#34;, arrRoom, arrRoom) fmt.Printf(\u0026#34;arrBed:%#v arrBed:Type:%T\\n\u0026#34;, arrBed, arrBed) fmt.Printf(\u0026#34;d:%#v d:Type:%T\\n\u0026#34;, d, d) } /* * arrAge:[5]int{15, 16, 15, 18, 17} arrAge:Type:[5]int * arrName:[5]string{\u0026#34;\u0026#34;, \u0026#34;\u0026#34;, \u0026#34;\u0026#34;, \u0026#34;Chris\u0026#34;, \u0026#34;Ron\u0026#34;} arrName:Type:[5]string * arrCount:[4]int{500, 0, 100, 0} arrCount:Type:[4]int * arrLazy:[5]int{5, 6, 7, 8, 23} arrLazy:Type:[5]int * arrPack:[6]int{10, 0, 0, 0, 0, 100} arrPack:Type:[6]int * arrRoom:[20]int{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0} arrRoom:Type:[20]int * arrBed:\u0026amp;[20]int{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0} arrBed:Type:*[20]int * d: * [2]struct { name string; age uint8 } * { * struct { name string; age uint8 }{name:\u0026#34;user1\u0026#34;, age:0xa}, * struct { name string; age uint8 }{name:\u0026#34;user2\u0026#34;, age:0x14} * } * d:Type: * [2]struct { name string; age uint8 } */ Goè¯­è¨€ä¸­æ•°ç»„æ˜¯ä¸€ç§å€¼ç±»å‹ï¼ˆä¸åƒC/C++ä¸­æ˜¯æŒ‡å‘é¦–å…ƒç´ çš„æŒ‡é’ˆï¼‰ï¼Œæ‰€ä»¥å¯ä»¥é€šè¿‡new()æ¥åˆ›å»ºã€‚ // ç”³è¯· 5 * 8 byteå†…å­˜ var arr1 = new([5]int)\t// *[5]int ä½¿ç”¨new([5]int)åˆ›å»ºå’Œvar arr2 [5]intçš„åŒºåˆ«ï¼Œarr1çš„ç±»å‹æ˜¯ *[5]intï¼Œè€Œarr2çš„ç±»å‹æ˜¯[5]intã€‚ æ•°ç»„é•¿åº¦ä¸åŒç®—ä½œä¸åŒç±»å‹ åœ¨Goè¯­è¨€ä¸­ï¼Œæ•°ç»„çš„é•¿åº¦éƒ½ç®—åœ¨ç±»å‹é‡Œï¼Œç”±äºåœ¨æ•°ç»„çš„ç±»å‹æè¿°ç»“æ„ä¸­è®°å½•ç€æ•°ç»„çš„é•¿åº¦ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 package main import ( \u0026#34;fmt\u0026#34; ) func main() { // 1) new([5]int) åˆ›å»ºçš„æ˜¯æ•°ç»„æŒ‡é’ˆ var arr1 = new([5]int) // *[5]int // æŠŠæ•°ç»„ [5]int çœ‹åšå¦‚ä¸‹æ„æˆï¼š // a: struct { // a1 int // a2 int // a3 int // a4 int // a5 int // } // åˆ™ arr1 = \u0026amp;a // arr1ç±»å‹:*[5]int, \u0026amp;arr1:0xc00000a028, arr1:0xc000012420, \u0026amp;arr1[0]:0xc000012420 fmt.Printf(\u0026#34;arr1ç±»å‹:%T, \u0026amp;arr1:%p, arr1:%p, \u0026amp;arr1[0]:%p\\n\u0026#34;, arr1, \u0026amp;arr1, arr1, \u0026amp;arr1[0]) // arr1:\u0026amp;[5]int{0, 0, 0, 0, 0} fmt.Printf(\u0026#34;arr1:%#v\\n\u0026#34;, arr1) // arrå’Œarr1æŒ‡å‘åŒä¸€åœ°å€ï¼Œå› è€Œä¿®æ”¹arr1å’ŒarråŒæ ·ä¹Ÿç”Ÿæ•ˆ arr := arr1 // arrç±»å‹:*[5]int, \u0026amp;arr:0xc00000a038, arr:0xc000012420, \u0026amp;arr[0]:0xc000012420 fmt.Printf(\u0026#34;arrç±»å‹:%T, \u0026amp;arr:%p, arr:%p, \u0026amp;arr[0]:%p\\n\u0026#34;, arr, \u0026amp;arr, arr, \u0026amp;arr[0]) // arr:\u0026amp;[5]int{0, 0, 0, 0, 0} fmt.Printf(\u0026#34;arr:%#v\\n\u0026#34;, arr) arr1[2] = 100 // (*arr1)[2] = 100 fmt.Println(arr1[2], arr[2]) // 100 100 // 2) éæŒ‡é’ˆå½¢å¼ [5]int var arr2 [5]int // newArræ˜¯arr2çš„å‰¯æœ¬ï¼Œå› æ­¤ä¿®æ”¹ä»»ä½•ä¸€ä¸ªå€¼éƒ½ä¸ä¼šæ”¹å˜å¦å¤–ä¸€ä¸ªå€¼ newArr := arr2 arr2[2] = 100 fmt.Println(arr2[2], newArr[2]) // 100 0 } å‡½æ•°æˆ–æ–¹æ³•æ—¶ï¼Œå¦‚æœå‚æ•°æ˜¯æ•°ç»„ï¼Œéœ€è¦æ³¨æ„å‚æ•°ä¸èƒ½è¿‡å¤§ã€‚ ç”±äºæŠŠä¸€ä¸ªå¤§æ•°ç»„ä¼ é€’ç»™å‡½æ•°ä¼šæ¶ˆè€—å¾ˆå¤šå†…å­˜ï¼ˆå€¼ä¼ é€’ï¼‰ï¼Œå¯ä»¥ä½¿ç”¨å…¶ä»–æ–¹å¼ä¼ é€’ã€‚ ä¼ é€’æ•°ç»„çš„æŒ‡é’ˆã€‚ ä½¿ç”¨åˆ‡ç‰‡ï¼ˆå¸¸ç”¨é€‰æ‹©ï¼‰ã€‚ å¤šç»´æ•°ç»„ 1 2 3 [...][5]int{ {10,20},{30,40} } // len() é•¿åº¦æ ¹æ®å®é™…åˆå§‹åŒ–æ—¶æ•°ç»„çš„é•¿åº¦æ¥å®šï¼Œè¿™é‡Œæ˜¯ 2 [3][2]int // len() é•¿åº¦è¿™é‡Œæ˜¯ 3 [2][2][2]float64 // å¯ä»¥è¿™æ ·ç†è§£[2]([2]([2]float64)) å®šä¹‰å¤šç»´æ•°ç»„æ˜¯ï¼Œä»…ç¬¬ä¸€ç»´å…è®¸ä½¿ç”¨ \u0026ldquo;...\u0026quot;ã€‚ å†…ç½®å‡½æ•°len()å’Œcap()éƒ½è¿”å›ç¬¬ä¸€ç»´åº¦é•¿åº¦ã€‚ len()è·å–çš„æ˜¯æ•°ç»„çš„é•¿åº¦ã€‚ cap()è·å–çš„æ˜¯æ•°ç»„çš„å®¹é‡ï¼Œè¿™é‡Œä¹Ÿå°±æ˜¯è¿”å›æ•°ç»„çš„é•¿åº¦ã€‚ å®šä¹‰æ•°ç»„æ—¶ \u0026ldquo;...\u0026rdquo; è¡¨ç¤ºé•¿åº¦ä¸å®šï¼Œåˆå§‹åŒ–æ—¶æ ¹æ®å®é™…é•¿åº¦æ¥ç¡®å®šæ•°ç»„çš„é•¿åº¦ã€‚ 1 2 b := [...][5]int{ {10,20},{30,40,50,60} } fmt.Println(b[1][3], len(b)) // 60 2 æ•°ç»„å…ƒç´ å¯ä»¥é€šè¿‡ç´¢å¼•ï¼ˆä¸‹æ ‡ï¼‰æ¥è¯»å–æˆ–è€…ä¿®æ”¹ï¼Œæ‰€ä»¥ä»0å¼€å§‹ã€‚ éå†æ•°ç»„çš„æ–¹æ³•å¯ä»¥ä½¿ç”¨foræˆ–è€…for-rangeã€‚è¿™ä¸¤ç§å¯¹äºåˆ‡ç‰‡ä¸€æ ·é€‚ç”¨ã€‚å¤šç»´æ•°ç»„çš„éå†éœ€è¦ä½¿ç”¨å¤šå±‚çš„åµŒå¥—ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 package main import ( \u0026#34;fmt\u0026#34; ) func main() { var arrAge = [5]int{18,20,15,22,16} for i := 0; i \u0026lt; len(arrAge) ; i++ { // ã€int, intã€‘ fmt.Println(arrAge[i]) } fmt.Println(\u0026#34;-------------------------\u0026#34;) for key, val := range arrAge { // ã€int, intã€‘ fmt.Println(key, val) } // Output: // 18 // 20 // 15 // 22 // 16 // ------------------------- // 0 18 // 1 20 // 2 15 // 3 22 // 4 16 } æ•°ç»„ä¹‹é—´æ¯”è¾ƒ æ•°ç»„å…ƒç´ ç±»å‹æ”¯æŒ == æˆ– != æ“ä½œç¬¦ï¼Œé‚£ä¹ˆæ•°ç»„ä¹Ÿæ”¯æŒæ­¤æ“ä½œã€‚ ä½†å¦‚æœæ•°ç»„ç±»å‹ä¸ä¸€æ ·åˆ™ä¸æ”¯æŒï¼ˆéœ€è¦æ•°ç»„é•¿åº¦å’Œæ•°ç»„ç±»å‹ä¸€è‡´ï¼Œå¦åˆ™ç¼–è¯‘ä¸é€šè¿‡ï¼‰ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 package main import ( \u0026#34;fmt\u0026#34; ) func main() { var arrRoom [20]int var arrBed [20]int fmt.Println(arrRoom == arrBed) // true var a [2]int = [2]int{0, 1} var b [2]int = [2]int{0, 1} var c [2]int = [2]int{0, 2} fmt.Println(a == b) // true fmt.Println(a == c) // false // Output: // true // true // false } æ•°ç»„æ¯”è¾ƒçš„æ ¸å¿ƒä»£ç ç¤ºä¾‹ï¼šä»¥ä¸‹ä»£ç æŠ„è‡ªsrc/reflect/type.goæ–‡ä»¶ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 // typè¡¨ç¤ºæ•°ç»„çš„å…ƒç±»å‹_typeï¼Œetypåˆ™æ˜¯æ•°ç»„å…ƒç´ çš„å…ƒç±»å‹_type // ä¸¾ä¾‹å¦‚ [5]string æ•°ç»„ï¼Œè¿™é‡Œçš„typå°±æ˜¯[5]stringæ•°ç»„ç±»å‹ï¼Œetypå°±æ˜¯stringç±»å‹ etyp := typ.common() // esizeè¡¨ç¤ºæ•°ç»„å…ƒç´ æ‰€åœ¨å†…å­˜å¤§å°ï¼Œè¿™é‡Œçš„esizeå°±æ˜¯stringç±»å‹çš„å¤§å°16å­—èŠ‚ esize := etyp.Size() // æ ‡è®°æ•°ç»„æ¯”è¾ƒå­—æ®µä¸ºnilï¼Œnilè¡¨ç¤ºå½“å‰ç±»å‹ä¸å¯æ¯”è¾ƒ array.equal = nil // è¿™é‡Œå…ˆæ ‡è®°é»˜è®¤å€¼ // åˆ¤æ–­etyp.equalä¹Ÿå°±æ˜¯æ•°ç»„çš„å…ƒç´ ç±»å‹(string)æ˜¯å¦å¯ä»¥æ¯”è¾ƒï¼Œå¦‚æœè¯¥ç±»å‹ä¸å¯æ¯”è¾ƒåˆ™å½“å‰æ•°ç»„ä¹Ÿä¸å¯æ¯”è¾ƒ if eequal := etyp.equal; eequal != nil { // æ•°ç»„å…ƒç´ å¯ä»¥æ¯”è¾ƒæ—¶ï¼Œåˆå§‹åŒ–æ•°ç»„çš„æ¯”è¾ƒå­—æ®µé—­åŒ…å½¢å¼ // på’Œqåˆ†è¡¨è¡¨ç¤ºéœ€è¦æ¯”è¾ƒçš„ä¸¤ä¸ªæ•°ç»„åœ°å€ array.equal = func(p, q unsafe.Pointer) bool { // array.equalæ•°ç»„çš„æ¯”è¾ƒæ–¹æ³• for i := 0; i \u0026lt; count; i++ { // éå†æ•°ç»„çš„æ‰€æœ‰å…ƒç´ ï¼Œcountè®°å½•æ•°ç»„å…ƒç´ çš„å¤§å° pi := arrayAt(p, i, esize, \u0026#34;i \u0026lt; count\u0026#34;) // arrayAtåç§»åˆ°pçš„æ¯ä¸ªå…ƒç´ ä½ç½®ï¼Œå¾—åˆ°æ•°ç»„å…ƒç´ å€¼ qi := arrayAt(q, i, esize, \u0026#34;i \u0026lt; count\u0026#34;) // arrayAtåç§»åˆ°qçš„æ¯ä¸ªå…ƒç´ ä½ç½®ï¼Œå¾—åˆ°æ•°ç»„å…ƒç´ å€¼ // eequalåˆ™æ˜¯æ•°ç»„å…ƒç´ ç±»å‹çš„æ¯”è¾ƒå‡½æ•°ï¼Œè¿™é‡Œä¸¾ä¾‹æ˜¯stringæ¯”è¾ƒå‡½æ•° if !eequal(pi, qi) { // eequalæ•°ç»„å…ƒç´ ç±»å‹çš„æ¯”è¾ƒæ–¹æ³•ï¼Œæ¯”è¾ƒpiå’Œqi return false // ä¸¤ä¸ªæ•°ç»„ä¸ç›¸ç­‰æ—¶ } } return true // ä¸¤ä¸ªæ•°ç»„ä¸€è‡´æ—¶ } } å€¼æ‹·è´è¡Œä¸ºä¼šé€ æˆæ€§èƒ½é—®é¢˜ï¼Œé€šå¸¸ä¼šå»ºè®®ä½¿ç”¨ sliceï¼Œæˆ–æ•°ç»„æŒ‡é’ˆã€‚ å¤šç»´æ•°ç»„éå† 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 package main import ( \u0026#34;fmt\u0026#34; ) func main() { // äºŒç»´æ•°ç»„ï¼Œ2X3 var f [2][3]int = [...][3]int{{1, 2, 3}, {7, 8, 9}} for k1, v1 := range f { // ã€int, [3]intã€‘ for k2, v2 := range v1 { // ã€int, intã€‘ fmt.Printf(\u0026#34;(%d,%d)=%d \u0026#34;, k1, k2, v2) } fmt.Println() } // Output: // (0,0)=1 (0,1)=2 (0,2)=3 // (1,0)=7 (1,1)=8 (1,2)=9 } æ•°ç»„æ‹·è´å’Œä¼ å‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 package main import \u0026#34;fmt\u0026#34; func printArr(arr *[5]int) { arr[0] = 10 // (*arr)[0] // for i, v := range *arr for i, v := range arr { // ã€int, intã€‘ fmt.Println(i, v) } } func main() { var arr1 [5]int printArr(\u0026amp;arr1) fmt.Println(arr1) arr2 := [...]int{2, 4, 6, 8, 10} printArr(\u0026amp;arr2) fmt.Println(arr2) } /* * 0 10 * 1 0 * 2 0 * 3 0 * 4 0 * [10 0 0 0 0] * 0 10 * 1 4 * 2 6 * 3 8 * 4 10 * [10 4 6 8 10] */ æ±‚æ•°ç»„æ‰€æœ‰å…ƒç´ ä¹‹å’Œ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;math/rand\u0026#34; \u0026#34;time\u0026#34; ) // æ±‚å…ƒç´ å’Œ func sumArr(a *[10]int) int { var sum int = 0 for i := 0; i \u0026lt; len(a); i++ { // è¯­æ³•ç³– len(*a) sum += a[i] // è¯­æ³•ç³– (*a)[i] } //for _, v := range a { //\tsum += v //} return sum } func main() { // è‹¥æƒ³åšä¸€ä¸ªçœŸæ­£çš„éšæœºæ•°ï¼Œä¸€èˆ¬ä½¿ç”¨æ—¶é—´çº³ç§’æ’­ç§éšæœºæ•° // seed()ç§å­é»˜è®¤æ˜¯1ï¼Œrand.Seed(1) rand.Seed(time.Now().UnixNano()) var b [10]int for i := 0; i \u0026lt; len(b); i++ { // äº§ç”Ÿä¸€ä¸ª0åˆ°1000éšæœºæ•° b[i] = rand.Intn(1000) } sum := sumArr(\u0026amp;b) fmt.Printf(\u0026#34;sum=%d\\n\u0026#34;, sum) // Output: // sum=3171 } æ‰¾å‡ºæ•°ç»„ä¸­å’Œä¸ºç»™å®šå€¼çš„ä¸¤ä¸ªå…ƒç´ çš„ä¸‹æ ‡ ä¾‹å¦‚æ•°ç»„[1,3,5,8,7]ï¼Œæ‰¾å‡ºä¸¤ä¸ªå…ƒç´ ä¹‹å’Œç­‰äº8çš„ä¸‹æ ‡åˆ†åˆ«æ˜¯(0, 4)å’Œ(1, 2)ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 package main import \u0026#34;fmt\u0026#34; // æ‰¾å‡ºæ•°ç»„ä¸­å’Œä¸ºç»™å®šå€¼çš„ä¸¤ä¸ªå…ƒç´ çš„ä¸‹æ ‡ï¼Œä¾‹å¦‚æ•°ç»„[1,3,5,8,7]ï¼Œ // æ‰¾å‡ºä¸¤ä¸ªå…ƒç´ ä¹‹å’Œç­‰äº8çš„ä¸‹æ ‡åˆ†åˆ«æ˜¯ï¼ˆ0ï¼Œ4ï¼‰å’Œï¼ˆ1ï¼Œ2ï¼‰ // æ±‚å…ƒç´ å’Œï¼Œæ˜¯ç»™å®šçš„å€¼ func myTest(a []int, target int) { for i := 0; i \u0026lt; len(a); i++ { other := target - a[i] for j := i + 1; j \u0026lt; len(a); j++ { if a[j] == other { fmt.Printf(\u0026#34;(%d,%d)\\n\u0026#34;, i, j) } } } } func main() { b := [5]int{1, 3, 5, 8, 7} // b[:] ä¼šå¼•ç”¨æ•°ç»„bçš„åœ°å€ï¼Œå¦‚æœmyTestå‡½æ•°ä¿®æ”¹å‚æ•°aåˆ™ä¼šå½±å“åˆ°bã€‚ myTest(b[:], 8) } éšæœºæ‰“ä¹±ä¸€ä¸ªæ•°ç»„ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;math/rand\u0026#34; \u0026#34;time\u0026#34; ) func main() { // éšæœºæ‰“ä¹±ä¸€ä¸ªæ•°ç»„ // 1) ç»™ [12]int èµ‹å€¼ var ar [12]int = [12]int{} for i := range \u0026amp;ar { ar[i] = i + 1 } fmt.Println(ar) rand.Seed(time.Now().UnixNano()) // 2) æ‰“ä¹± [12]int n := len(ar) // 12 for i := 1; i \u0026lt; n; i++ { // æ ¹æ®éšæœºæ•°æ‰“ä¹±ar j := rand.Int() % (i+1) ar[i], ar[j] = ar[j], ar[i] } fmt.Println(ar) } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;math/rand\u0026#34; \u0026#34;time\u0026#34; ) func shuffleArray(arr []int) { // è·å–éšæœºæ•°ç§å­ rand.Seed(time.Now().UnixNano()) // éå†æ•°ç»„ï¼Œéšæœºäº¤æ¢å…ƒç´  for i := len(arr) - 1; i \u0026gt; 0; i-- { j := rand.Intn(i + 1) arr[i], arr[j] = arr[j], arr[i] } } func main() { arr := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20} shuffleArray(arr) fmt.Println(arr) } ... çš„ä½¿ç”¨ ç”¨äºæ•°ç»„æ—¶ï¼Œ...åªèƒ½ç”¨åœ¨æœ€å¤–å±‚æ•°ç»„ã€‚ ç”¨äºæ•°ç»„ç”³æ˜çš„æœ€å¤–å±‚æ•°ç»„ï¼Œè‡ªåŠ¨ç»Ÿè®¡æ•°ç»„é•¿åº¦ã€‚ ç”¨ä½œå‡½æ•°çš„æœ€åä¸€ä¸ªå‚æ•°ï¼Œ...Tè¡¨ç¤ºå¯å˜å‚æ•°[]Tåˆ‡ç‰‡å½¢å¼ã€‚ ç”¨ä½œåˆ‡ç‰‡å[]T...è¡¨ç¤ºè§£å¼•ç”¨ã€‚ã€append([]int{1,2}, []int{3,4,5}\u0026hellip;)ã€‘ åªæœ‰åœ¨ã€append([]byte(\u0026ldquo;hello \u0026ldquo;), \u0026ldquo;world\u0026rdquo;\u0026hellip;)ã€‘æ—¶å¯ä»¥ä½¿ç”¨ã€string...ã€‘å½¢å¼å…¶ä»–åœ°æ–¹ä¸è¢«å…è®¸ã€‚ ...ä½œä¸ºè§£å¼•ç”¨æ—¶ï¼Œåªèƒ½ç”¨åœ¨Sliceå’Œstringä¸­ã€‚ append()ç›¸å…³ç”¨æ³•ã€‚ slice = append(slice, elem1, elem2) slice = append(slice, anotherSlice...) slice = append([]byte(\u0026quot;hello \u0026quot;), \u0026quot;world\u0026quot;...) æ³¨æ„ åœ¨Goè¯­è¨€ä¸­åªæœ‰æ•°ç»„å’Œæ•°ç»„æŒ‡é’ˆèƒ½ç›¸äº’æ··ç”¨ï¼Œå…¶ä»–ç±»å‹åˆ™ä¸èƒ½ï¼Œæ¯”å¦‚åˆ‡ç‰‡å’Œåˆ‡ç‰‡æŒ‡é’ˆç­‰ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 { sl := [4]int{1,2,3,4} str3 := \u0026amp;sl // str3[1]ã€range str3ã€len(str3) ç­‰æ“ä½œ _ = str3[1] // (*str3)[1] è¯­æ³•ç³– for range str3 {\t} _ = len(str3) // len(*str3) è¯­æ³•ç³– _ = cap(str3) // cap(*str3) è¯­æ³•ç³– } ","permalink":"https://heliu.site/posts/golang/array/use/","summary":"æ•°ç»„çš„å®šä¹‰åŠåŸºç¡€ä½¿ç”¨ã€‚","title":"æ•°ç»„ä½¿ç”¨"},{"content":" æ•°ç»„åœ¨å†…å­˜ä¸­æ˜¯è¿ç»­åˆ†é…çš„ï¼Œæ•°ç»„çš„å¤§å°ä¿å­˜åœ¨æ•°ç»„ç±»å‹å…ƒæ•°æ®ä¸­çš„ã€‚ [3]int çš„å†…å­˜å¸ƒå±€ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // ç¤ºä¾‹[3]int æ•°ç»„å¸ƒå±€ å†…å­˜ä¸­è¿ç»­åˆ†é… // åœ°å€ 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 // |\u0026lt;---a[0]----\u0026gt;| |\u0026lt;-------a[1]------\u0026gt;| |\u0026lt;--------a[2]------\u0026gt;| a := [3]int{0, 1, 2} // açš„åœ°å€\u0026amp;aä¹Ÿå°±æ˜¯å½“å‰ç¤ºä¾‹çš„0å³å†…å­˜çš„é¦–åœ°å€ // æŸ¥çœ‹açš„å†…å­˜å ç”¨å¤§å° int åœ¨64ä½ç³»ç»Ÿä¸‹å 8å­—èŠ‚ 3*8 = 24å­—èŠ‚ fmt.Println(unsafe.Sizeof(a)) // 24 // æ•°ç»„çš„é•¿åº¦ä¿å­˜åœ¨ç±»å‹å…ƒæ•°æ®ä¸­ type arrayType struct { _type // æ•°ç»„ç±»å‹ç»“æ„ elem *_type // æ•°ç»„å…ƒç´ ç±»å‹ç»“æ„ slice *_type // åˆ‡ç‰‡ç±»å‹ç»“æ„ len uintptr // æ•°ç»„é•¿åº¦ } [3]string çš„å†…å­˜å¸ƒå±€ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 // ç¤ºä¾‹[5]string å­—ç¬¦ä¸²æ•°ç»„å†…å­˜å¸ƒå±€ // å­—ç¬¦ä¸²ç»“æ„æˆ‘ä»¬æ˜¯å¦‚ä¸‹ 64ä½æ“ä½œç³»ç»Ÿä¸‹ // string struct // å­—æ®µ ç±»å‹ å¤§å° ç¤ºä¾‹ // data uintptr 8byte æŒ‡å‘åº•å±‚æ•°ç»„ å¦‚x[0] -\u0026gt; [\u0026#39;h\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;l\u0026#39;, \u0026#39;l\u0026#39;, \u0026#39;o\u0026#39;, \u0026#39;2\u0026#39;, \u0026#39;1\u0026#39;] // len int 8byte è®°å½•å­—ç¬¦çš„é•¿åº¦ å¦‚x[0] 7 // // | // 0 1 ... 6 7 8 9 ... 14 15 16 17 .. 22 23 24 25 ... 30 31 32 33 .. 39 40 41 42 ... å†…å­˜åœ°å€byte // | | | | | | | | | | ... // |x[0].data| | x[0].len | | x[1].data | | x[1].len | | x2[2].data | ... // | 8B | | 8B | | 8B | | 8B | | 8B | ... // // æ•°ç»„çš„é•¿åº¦è®°å½•åœ¨æ•°ç»„çš„ç±»å‹å…ƒæ•°æ®ä¸­ x := [5]string{\u0026#34;hello21\u0026#34;, \u0026#34;word\u0026#34;, \u0026#34;! 1\u0026#34;, \u0026#34;! 2\u0026#34;, \u0026#34;! 3\u0026#34;} // æ•°ç»„xå ç”¨å†…å­˜å¤§å°(å­—èŠ‚) 5*16 fmt.Println(unsafe.Sizeof(x))\t// 80 éªŒè¯[2]stringçš„å†…å­˜å¸ƒå±€ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;unsafe\u0026#34; ) // array2Str ç±» [2]string å†…å­˜ç»“æ„å¸ƒå±€ // å› æ­¤ æ•°ç»„ ç›´æ¥çœ‹æˆç›¸åº”çš„ç»“æ„ä½“ type array2Str struct { a0Data unsafe.Pointer a0Len int a1Data unsafe.Pointer a1Len int } func main() { a := [2]string{\u0026#34;hello\u0026#34;, \u0026#34;world!\u0026#34;} // 16 * 2 = 32 // æŠŠ a çœ‹æˆ array2Str ç»“æ„ä½“ s := **(**[5]byte)(unsafe.Pointer(\u0026amp;a)) // a[0]; array2Str.p1 fmt.Println(string(s[:]), unsafe.Sizeof(a)) // hello 32 // \u0026amp;array2Str.l1 // æŠŠ a çœ‹æˆ array2Str è¿™é‡Œæ¯”è¾ƒå¥½ç†è§£ a0l := (*int)(unsafe.Pointer(uintptr(unsafe.Pointer(\u0026amp;a)) + unsafe.Sizeof(uintptr(0)))) // len(a[0]) //a0l := (*(*[2]int)(unsafe.Pointer(\u0026amp;a)))[1] // 5 fmt.Println(*a0l) // 5 ss := (*array2Str)(unsafe.Pointer(\u0026amp;a)) fmt.Println(*ss) // {4807271 5 4807756 6} } æ•°ç»„çš„æŒ‰å€¼ä¼ å‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;unsafe\u0026#34; ) func main() { a := [2]int{10, 20} // æ•°ç»„aå ç”¨å†…å­˜å¤§å°ï¼š16 fmt.Printf(\u0026#34;æ•°ç»„aå ç”¨å†…å­˜å¤§å°ï¼š%d\\n\u0026#34;, unsafe.Sizeof(a)) fmt.Printf(\u0026#34;æ•°ç»„aåœ°å€ï¼š%p\\n\u0026#34;, \u0026amp;a) x(a) // Output: // æ•°ç»„aå ç”¨å†…å­˜å¤§å°ï¼š16 // æ•°ç»„aåœ°å€ï¼š0xc00000e0b0 // æ•°ç»„aå ç”¨å†…å­˜å¤§å°ï¼š16 // æ•°ç»„aåœ°å€ï¼š0xc00000e0d0 // ä»æ•°ç»„açš„åœ°å€å¯ä»¥çœ‹å‡ºï¼Œmainå‡½æ•°çš„æ ˆåˆ†é…æ˜¯ç»æŒ¨ç€çš„ } func x(a [2]int) { // æ•°ç»„aå ç”¨å†…å­˜å¤§å°ï¼š16 fmt.Printf(\u0026#34;æ•°ç»„aå ç”¨å†…å­˜å¤§å°ï¼š%d\\n\u0026#34;, unsafe.Sizeof(a)) fmt.Printf(\u0026#34;æ•°ç»„aåœ°å€ï¼š%p\u0026#34;, \u0026amp;a) } ","permalink":"https://heliu.site/posts/golang/array/memory/","summary":"Golang æ•°ç»„çš„å†…å­˜å¸ƒå±€ä»‹ç»ã€‚","title":"æ•°ç»„çš„å†…å­˜å¸ƒå±€"},{"content":" Golang çš„å…ƒç±»å‹åœ¨interfaceç« èŠ‚æ‰ä¼šä»‹ç»ï¼Œå¦‚æœä¸ç†Ÿæ‚‰ç•¥è¿‡ã€‚ æ•°ç»„å…ƒç±»å‹ç»“æ„ æ•°ç»„å…ƒç±»å‹ï¼šæ„æˆæ•°ç»„ç±»å‹çš„ç»“æ„ã€‚ï¼ˆæ•°ç»„ç±»å‹å’Œè‡ªå®šä¹‰æ•°ç»„ç±»å‹ï¼‰ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 // æ•°ç»„ç±»å‹ type arrayType struct { _type // æ•°ç»„å…ƒç±»å‹ï¼Œä¹Ÿå°±æ˜¯æ•°ç»„ç±»å‹ç›¸å…³ä¿¡æ¯ elem *_type // æ•°ç»„å…ƒç´ å…ƒç±»å‹ï¼Œæ¯”å¦‚[2]stringä¸­çš„stringç±»å‹ç›¸å…³ä¿¡æ¯ slice *_type // åˆ‡ç‰‡å…ƒç±»å‹ï¼Œä¸ºä»€ä¹ˆæ•°ç»„ç±»å‹ç»“æ„ä¸­æœ‰ä¸€ä¸ªåˆ‡ç‰‡çš„å…ƒç±»å‹ã€‚åœ¨åå°„çš„æ–¹æ³•ä¸­è¢«ç”¨åˆ°ç”¨äºå¿«é€Ÿæ‰¾åˆ°åˆ‡ç‰‡ len uintptr // æ•°ç»„é•¿åº¦ï¼Œæ•°ç»„çš„é•¿åº¦æ˜¯ä¿å­˜åœ¨å…ƒç±»å‹ä¸­çš„ } // è‡ªå®šä¹‰æ•°ç»„ç±»å‹ type u struct { arrayType u uncommonType } // uncommonType æ˜¯è‡ªå®šä¹‰æ–¹æ³•é›† type uncommonType struct { pkgPath int32 // 4B åç§»åˆ°åŒ…åç§°è·¯å¾„ mcount uint16 // 2B æ–¹æ³•æ€»æ•°é‡ xcount uint16 // 2B å¯å¯¼å‡ºæ–¹æ³•æ•°é‡ moff uint32 // 4B åç§»åˆ°é¦–æ–¹æ³•çš„åç§»é‡ï¼Œæ–¹æ³•æ˜¯æŒ‰ç…§æ–¹æ³•åæ­£åºæ’åºçš„ï¼Œå› æ­¤å¯¼å‡ºæ–¹æ³•åœ¨æœ€å‰é¢ _ uint32 // 4B å ä½å†…å­˜è¡¥é½ï¼Œè¡¥é½4Bï¼Œè¯¥uncommonTypeæ­£å¥½æ˜¯16Bæ— è®ºæ˜¯32ä½ä¸‹è¿˜æ˜¯64ä½ä¸‹éƒ½å…¼å®¹ } // æ–¹æ³•ç±»å‹ type method struct { name nameOff // åç§»é‡ æ–¹æ³•å mtyp typeOff // åç§»é‡ æ–¹æ³•ç±»å‹ ifn textOff // åç§»é‡ æ–¹æ³•åœ°å€ ç”¨äºæ¥å£ ç¼–è¯‘å™¨ç”Ÿæˆçš„åŒ…è£…æ–¹æ³• tfn textOff // åç§»é‡ æ–¹æ³•åœ°å€ } æŸ¥çœ‹æ•°ç»„çš„_typeä¿¡æ¯ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;unsafe\u0026#34; ) // sType ä¸è®ºåœ¨32ä½ä¸‹è¿˜æ˜¯64ä½ä¸‹åˆšå¥½æ˜¯8çš„å€æ•°éƒ½å…¼å®¹ type sType struct { size uintptr // å½“å‰ç±»å‹å ç”¨å­—èŠ‚å¤§å°ï¼Œå­—èŠ‚B ptrData uintptr // ç±»å‹ä¸­ä¹Ÿå¯åŒ…å«æŒ‡é’ˆçš„å­—èŠ‚æ•°Bï¼Œåœ¨å½“å‰å¤§å°èŒƒå›´åéƒ½æ˜¯æ ‡é‡æ•°æ® hash uint32 // ç±»å‹å”¯ä¸€å“ˆå¸Œå€¼ï¼Œç”¨äºå¿«é€ŸåŒºåˆ†å…ƒç´ ç±»å‹ tFlag uint8 // è®°å½•ç€å½“å‰ç±»å‹çš„é¢å¤–ä¿¡æ¯ï¼Œæ¯”å¦‚åç§°ã€æ–¹æ³•é›†ã€åç§°*å‰ç¼€ã€åŒ…è·¯å¾„ã€tagæ ‡ç­¾ç­‰ align uint8 // ç±»å‹çš„å¯¹é½é‡ fieldAlign uint8 // ç»“æ„ä½“å­—æ®µçš„å¯¹é½é‡ kind uint8 // ç±»å‹æšä¸¾ï¼Œä¹Ÿå°±æ˜¯å½“å‰ç±»å‹å€¼ equal func(uintptr, uintptr) // ç±»å‹æ¯”è¾ƒå‡½æ•°ï¼Œä¸ä¸ºnilè¡¨ç¤ºå¯æ¯”è¾ƒ gcData *byte // åƒåœ¾å›æ”¶ç›¸å…³ï¼Œè®°å½•å½“å‰ç±»å‹å¼•ç”¨çš„å›æ”¶çŠ¶æ€ç­‰ str int32 // å½“å‰ç±»å‹nameçš„åç§»é‡ï¼Œåˆ°å½“å‰ç±»å‹åç§°è·¯å¾„çš„åç§»é‡ï¼Œä¹Ÿå°±æ˜¯tFlagä¿¡æ¯å¯¹åº”çš„å†…å®¹å¤„ ptrToThis int32 // å½“å‰ç±»å‹çš„æŒ‡é’ˆç±»å‹çš„åç§»é‡ï¼Œä¹Ÿå°±æ˜¯[2]intåç§»åˆ°*[2]intçš„åç§»é‡ } //type AA [2]string func main() { var s = [2]string{\u0026#34;hello\u0026#34;, \u0026#34;world!\u0026#34;} //var s AA = [2]string{\u0026#34;hello\u0026#34;, \u0026#34;world!\u0026#34;} // type eface interface {typ *_type, data uintptr} var ss interface{} = s at := **(**sType)(unsafe.Pointer(\u0026amp;ss)) // main.sType{ // size:0x20, // 2 * 16 = 32 // ptrData:0x18, // 16 + 8 = 3 * 8 = 24ï¼Œåœ¨24å­—èŠ‚åå…¨éƒ¨éƒ½æ˜¯æ ‡é‡æ•°æ® // hash:0xe9e55850, // tFlag:0x2, // 0000 0010 // align:0x8, // fieldAlign:0x8, // kind:0x11, // 16 + 1 = 17 // equal:(func(uintptr, uintptr))(0x45dee0), // å¯æ¯”è¾ƒ // gcData:(*uint8)(0x49d780), // str:5888, // ptrToThis:0 // æ•°ç»„è¯¥å€¼éƒ½ä¸º0 // } fmt.Printf(\u0026#34;%#v\\n\u0026#34;, at) } æŸ¥çœ‹æ•°ç»„å…¨éƒ¨ä¿¡æ¯ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;unsafe\u0026#34; ) type sType struct { size uintptr // å½“å‰ç±»å‹å ç”¨å­—èŠ‚å¤§å° B ptrData uintptr // ç±»å‹ä¸­ä¹Ÿå¯åŒ…å«æŒ‡é’ˆçš„å­—èŠ‚æ•° B åœ¨å½“å‰å¤§å°èŒƒå›´åéƒ½æ˜¯æ ‡é‡æ•°æ® hash uint32 // ç±»å‹å”¯ä¸€å“ˆå¸Œå€¼ tFlag uint8 // è®°å½•ç€å½“å‰ç±»å‹çš„é¢å¤–ä¿¡æ¯ï¼Œæ¯”å¦‚åç§°ã€æ–¹æ³•é›†ã€åç§°*å‰ç¼€ã€åŒ…è·¯å¾„ã€tagæ ‡ç­¾ç­‰ align uint8 // ç±»å‹çš„å¯¹é½é‡ fieldAlign uint8 // ç»“æ„ä½“å­—æ®µçš„å¯¹é½é‡ kind uint8 // ç±»å‹æšä¸¾ equal func(uintptr, uintptr) // ç±»å‹æ¯”è¾ƒå‡½æ•° gcData *byte // åƒåœ¾å›æ”¶ç›¸å…³ str int32 // å½“å‰ç±»å‹nameçš„åç§»é‡ ptrToThis int32 // å½“å‰ç±»å‹çš„æŒ‡é’ˆç±»å‹çš„åç§»é‡ } type arrayType struct { sType elem *sType slice *sType len uintptr } func main() { var s = [2]string{\u0026#34;hello\u0026#34;, \u0026#34;world!\u0026#34;} // type eface interface {typ *_type, data uintptr} var ss interface{} = s at := **(**arrayType)(unsafe.Pointer(\u0026amp;ss)) // main.arrayType{ // sType:main.sType{ // size:0x20, // ptrData:0x18, // hash:0xe9e55850, // tFlag:0x2, // align:0x8, // fieldAlign:0x8, // kind:0x11, // equal:(func(uintptr, uintptr))(0x45dee0), // gcData:(*uint8)(0x49d880), // str:5896, // ptrToThis:0 // }, // elem:(*main.sType)(0x486fa0), // slice:(*main.sType)(0x486120), // len:0x2 // } fmt.Printf(\u0026#34;%#v\\n\u0026#34;, at) fmt.Println(*at.elem) // {16 8 3774831796 7 8 8 24 0x402d20 0x4b4268 3135 21952} fmt.Println(*at.slice) // {24 8 183740627 2 8 8 23 \u0026lt;nil\u0026gt; 0x4b4268 5068 0} } è‡ªå®šä¹‰æ•°ç»„ç±»å‹ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;unsafe\u0026#34; ) type sType struct { size uintptr // å½“å‰ç±»å‹å ç”¨å­—èŠ‚å¤§å° B ptrData uintptr // ç±»å‹ä¸­ä¹Ÿå¯åŒ…å«æŒ‡é’ˆçš„å­—èŠ‚æ•° B åœ¨å½“å‰å¤§å°èŒƒå›´åéƒ½æ˜¯æ ‡é‡æ•°æ® hash uint32 // ç±»å‹å”¯ä¸€å“ˆå¸Œå€¼ tFlag uint8 // è®°å½•ç€å½“å‰ç±»å‹çš„é¢å¤–ä¿¡æ¯ï¼Œæ¯”å¦‚åç§°ã€æ–¹æ³•é›†ã€åç§°*å‰ç¼€ã€åŒ…è·¯å¾„ã€tagæ ‡ç­¾ç­‰ align uint8 // ç±»å‹çš„å¯¹é½é‡ fieldAlign uint8 // ç»“æ„ä½“å­—æ®µçš„å¯¹é½é‡ kind uint8 // ç±»å‹æšä¸¾ equal func(uintptr, uintptr) // ç±»å‹æ¯”è¾ƒå‡½æ•° gcData *byte // åƒåœ¾å›æ”¶ç›¸å…³ str int32 // å½“å‰ç±»å‹nameçš„åç§»é‡ ptrToThis int32 // å½“å‰ç±»å‹çš„æŒ‡é’ˆç±»å‹çš„åç§»é‡ } // æ•°ç»„å…ƒç±»å‹ type arrayType struct { sType elem *sType slice *sType len uintptr } // è‡ªå®šä¹‰æ•°ç»„ç±»å‹ï¼ŒåŒ…å«è‡ªå®šä¹‰æ–¹æ³• type u struct { arrayType uncommonType } // è‡ªå®šä¹‰æ–¹æ³•é›† type uncommonType struct { pkgPath int32 // 4B åç§»åˆ°è¡¨åç§°è·¯å¾„ mCount uint16 // 2B æ€»æ–¹æ³•æ•°é‡ xCount uint16 // 2B å¯å¯¼å‡ºæ–¹æ³•æ•°é‡ mOff uint32 // 4B åç§»åˆ°é¦–æ–¹æ³•çš„åç§»é‡ï¼Œæ–¹æ³•æ˜¯æŒ‰ç…§æ–¹æ³•åæ­£åºæ’åºçš„ï¼Œå› æ­¤å¯¼å‡ºæ–¹æ³•åœ¨æœ€å‰é¢ _ uint32 // 4B å ä½å†…å­˜è¡¥é½ } // AA å®šä¹‰è‡ªå®šä¹‰ç±»å‹ type AA [2]uint8 func (a AA) String() string { return \u0026#34;å¯å¯¼å‡ºæ–¹æ³•\u0026#34; } func (a *AA) setName(i uint8) { a[0] = i // è¿™é‡Œæ˜¯è¯­æ³•ç³– (*a)[0] = 1 } // ptrType represents a pointer type. æŒ‡é’ˆç±»å‹ type ptrType struct { sType elem *sType // pointer element (pointed at) type } type up struct { ptrType uncommonType } func main() { // éªŒè¯è‡ªå®šä¹‰ç±»å‹ var a AA a.setName(12) // AAç±»å‹ var inter any = a // è¯¥ç±»å‹åªå®ç°äº†Stringæ–¹æ³• s := **(**u)(unsafe.Pointer(\u0026amp;inter)) fmt.Printf(\u0026#34;%#v\\n\u0026#34;, s) // *AAç±»å‹ æ˜¯æŒ‡é’ˆç±»å‹ var inter1 any = \u0026amp;a // è¯¥ç±»å‹åªå®ç°äº†setNameæ–¹æ³•,ä½†æ˜¯è¿˜æœ‰ç¼–è¯‘åŒ…è£…çš„*AA String()æ–¹æ³• s1 := **(**up)(unsafe.Pointer(\u0026amp;inter1)) fmt.Printf(\u0026#34;%#v\\n\u0026#34;, s1) } // kind: 0x11 æ˜¯ 17 arrayç±»å‹ // AAç±»å‹ // main.u{ // arrayType:main.arrayType{ // sType:main.sType{ // size:0x2, // ptrData:0x0, // hash:0xeb895ab, // tFlag:0xf, // align:0x1, // fieldAlign:0x1, // kind:0x11, // equal:(func(uintptr, uintptr))(0xb02c40), // gcData:(*uint8)(0xbc8010), // str:4503, // ptrToThis:45344 // }, // elem:(*main.sType)(0xb94e20), // slice:(*main.sType)(0xb93f20), // len:0x2 // }, // uncommonType:main.uncommonType{ // pkgPath:522, // mCount:0x1, // æ–¹æ³•æ€»æ•°1 // xCount:0x1, // mOff:0x10, // _:0x0 // } // } // kind: 0x36 æ˜¯ 54 = 32(ç±»å‹é—´æ¥å­˜åœ¨æ¥å£å€¼ä¸­) + 22(æŒ‡é’ˆç±»å‹) // *AAç±»å‹ // main.up{ // ptrType:main.ptrType{ // sType:main.sType{ // size:0x8, // ptrData:0x8, // hash:0xae85f2d0, // tFlag:0x9, // 1001 // align:0x8, // fieldAlign:0x8, // kind:0x36, // 0x36 = 54 = 32 + 22 // equal:(func(uintptr, uintptr))(0x9f2c80), // gcData:(*uint8)(0xab8330), // str:4512, // ptrToThis:0 // }, // elem:(*main.sType)(0xa88fc0) // }, // uncommonType:main.uncommonType{ // pkgPath:522, // mCount:0x2, // æ–¹æ³•æ€»æ•°2 // xCount:0x1, // mOff:0x10, // _:0x0 // } // } ","permalink":"https://heliu.site/posts/golang/array/meta/","summary":"Golang æ•°ç»„çš„å…ƒç±»å‹ä»‹ç»ã€‚","title":"æ•°ç»„çš„å…ƒç±»å‹"},{"content":" åˆ‡ç‰‡ï¼šå¯¹åº•å±‚æ•°ç»„çš„ä¸€ä¸ªè¿ç»­ç‰‡æ®µçš„å¼•ç”¨ï¼Œæ‰€ä»¥åˆ‡ç‰‡æ˜¯ä¸€ä¸ªå¼•ç”¨ç±»å‹ï¼ˆå’Œæ•°ç»„ä¸ä¸€æ ·ï¼‰è¯¥æ•°ç»„ç§°ä¸ºç›¸å…³æ•°ç»„ï¼Œé€šå¸¸æ˜¯åŒ¿åçš„ã€‚ åˆ‡ç‰‡æä¾›å¯¹è¯¥æ•°ç»„ä¸­ç¼–å·çš„å…ƒç´ åºåˆ—çš„è®¿é—®ã€‚ æœªåˆå§‹åŒ–åˆ‡ç‰‡çš„å€¼ä¸ºnilï¼ˆæ³¨æ„ï¼šnilåˆ‡ç‰‡å’Œç©ºåˆ‡ç‰‡[]çš„åŒºåˆ«ï¼‰ã€‚ ä¸æ•°ç»„ä¸€æ ·åˆ‡ç‰‡æ˜¯å¯ç´¢å¼•çš„å¹¶ä¸”å…·æœ‰é•¿åº¦ã€‚ åˆ‡ç‰‡sçš„é•¿åº¦å¯ä»¥é€šè¿‡å†…ç½®çš„len()å‡½æ•°è·å–ï¼Œä¸æ•°ç»„ä¸åŒåˆ‡ç‰‡çš„é•¿åº¦å¯èƒ½åœ¨æ‰§è¡ŒæœŸé—´å‘ç”Ÿå˜åŒ–ã€‚ å…ƒç´ å¯ä»¥é€šè¿‡æ•´æ•°ç´¢å¼•0åˆ°len(s)-1æ¥å¯»å€ï¼Œåˆ‡ç‰‡ç›¸å½“ä¸€ä¸ªé•¿åº¦å¯å˜çš„æ•°ç»„ã€‚ è®¡ç®—å®¹å™¨çš„å‡½æ•°cap()ã€‚å¯ä»¥è®¡ç®—åˆ‡ç‰‡æœ€å¤§é•¿åº¦ã€‚ åˆ‡ç‰‡çš„é•¿åº¦æ°¸è¿œä¸ä¼šè¶…è¿‡å®ƒçš„å®¹é‡ï¼Œæ‰€ä»¥å¯¹äºsåˆ‡ç‰‡æ¥è¯´ï¼Œ0 \u0026lt;= len(s) \u0026lt;= cap(s)ã€‚ ä¸€æ—¦åˆå§‹åŒ–ï¼Œåˆ‡ç‰‡å§‹ç»ˆä¸ä¿å­˜å…¶å…ƒç´ çš„åŸºç¡€æ•°æ®ç›¸å…³è”ã€‚ å› æ­¤ï¼Œåˆ‡ç‰‡ä¼šå’Œå…¶æ‹¥æœ‰åŒä¸€åŸºç¡€æ•°æ®çš„å…¶ä»–åˆ‡ç‰‡å…±äº«å­˜å‚¨ã€‚ ç›¸æ¯”ä¹‹ä¸‹ï¼Œä¸åŒçš„æ•°ç»„æ€»æ˜¯æ‹¥æœ‰ä¸åŒçš„å­˜å‚¨ã€‚ ä½¿ç”¨make()å‡½æ•°å¯ä»¥ç»™åˆ‡ç‰‡åˆå§‹åŒ–ï¼Œè¯¥å‡½æ•°æŒ‡å®šåˆ‡ç‰‡ç±»å‹ã€é•¿åº¦å’Œå¯é€‰å®¹é‡çš„å‚æ•°ã€‚ å› ä¸ºåˆ‡ç‰‡æ˜¯å¼•ç”¨ï¼Œæ‰€ä»¥ä»–ä»¬ä¸éœ€è¦ä½¿ç”¨é¢å¤–çš„å†…å­˜ï¼Œå¹¶ä¸”æ¯”æ•°ç»„æ›´é«˜æ•ˆï¼Œå› æ­¤åˆ‡ç‰‡æ¯”æ•°ç»„å¸¸ç”¨ã€‚ å£°æ˜åˆ‡ç‰‡ å£°æ˜åˆ‡ç‰‡æ ¼å¼ã€‚ä¸éœ€è¦æŒ‡å®šé•¿åº¦ï¼Œåˆ‡ç‰‡åœ¨æœªåˆå§‹åŒ–ä¹‹å‰é»˜è®¤ä¸ºnilï¼Œé•¿åº¦ä¸º0ã€‚ 1 var identifer []type åˆ‡ç‰‡åˆå§‹åŒ–æ ¼å¼ã€‚ slice1æ˜¯ç”±æ•°ç»„arr1ä»startç´¢å¼•åˆ°end-1ç´¢å¼•ä¹‹é—´çš„å…ƒç´ æ„æˆçš„å­é›†ã€‚ start:end ç§°ä¸ºsliceè¡¨è¾¾å¼ã€‚ 1 2 3 4 // [start,end) // len = end - start // cap = end - start var slice1 []type = arr1[strat:end] åˆ‡ç‰‡åˆå§‹åŒ–æ ¼å¼ã€‚ 1 var x = []int{2,3,5,7,11,13} // è¿™æ ·åˆ›å»ºä¸€ä¸ªé•¿åº¦å’Œå®¹é‡ä¸º6çš„åˆ‡ç‰‡ ä½¿ç”¨make()å‡½æ•°æ¥åˆ›å»ºä¸€ä¸ªåˆ‡ç‰‡ã€‚ 1 2 3 var slice1 []type = make([]type, len, cap) // ç®€å†™å½¢å¼å¦‚ä¸‹ slice1 := make([]type, len, cap) makeå‡½æ•°çš„lenæ˜¯æ•°ç»„çš„é•¿åº¦ä¹Ÿæ˜¯sliceçš„åˆå§‹é•¿åº¦ï¼Œcapæ˜¯å®¹é‡ï¼Œæ˜¯å¯é€‰å‚æ•°ã€‚ 1 2 3 // åˆ›å»ºä¸€ä¸ªæœ‰50ä¸ªintå€¼å¾—æ•°ç»„ï¼Œå¹¶ä¸”åˆ›å»ºé•¿åº¦ä¸º10ï¼Œå®¹é‡ä¸º50çš„åˆ‡ç‰‡ // è¯¥åˆ‡ç‰‡æŒ‡å‘æ•°ç»„çš„å‰10ä¸ªå…ƒç´  v := make([]int, 10 , 50) ä»æ•°ç»„æˆ–è€…åˆ‡ç‰‡ä¸­ç”Ÿæˆä¸€ä¸ªæ–°çš„åˆ‡ç‰‡ã€‚ 1 2 3 4 5 6 7 // cap = max - low çš„ç»“æœè¡¨ç¤ºå®¹é‡ // len = high - low çš„ç»“æœè¡¨ç¤ºé•¿åº¦ a[low:high:max] // highå’Œmaxä¸èƒ½å¤§äºa.capçš„å€¼ // lowçš„é»˜è®¤å€¼0 // highçš„é»˜è®¤å€¼ len(a) // maxçš„é»˜è®¤å€¼ cap(a) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 package main import ( \u0026#34;fmt\u0026#34; ) func main() { a := [5]int{1,2,3,4,5} // len = 3-1 = 2 // cap = 5-1 = 4 t := a[1:3:5] // å¯ä»¥çœ‹å‡ºæ­¤å¤„å˜é‡tå¼•ç”¨äº†å˜é‡açš„éƒ¨åˆ†æ•°æ® fmt.Println(a, t) // [1 2 3 4 5] [2 3] a[1] += 1 fmt.Println(a, t) // [1 3 3 4 5] [3 3] fmt.Println(t, len(t), cap(t)) // [3,3] 2 4 } åˆ‡ç‰‡å–å€¼æ—¶ç´¢å¼•å¤§äºé•¿åº¦ä¼šå¯¼è‡´å¼‚å¸¸å‘ç”Ÿï¼Œå³ä½¿å®¹é‡è¿œè¿œå¤§äºé•¿åº¦ä¹Ÿæ²¡æœ‰ç”¨ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 package main import ( \u0026#34;fmt\u0026#34; ) func main() { sli := make([]int, 5, 10) fmt.Printf(\u0026#34;åˆ‡ç‰‡slié•¿åº¦å’Œå®¹é‡ï¼š%d, %d\\n\u0026#34;, len(sli), cap(sli)) fmt.Println(sli) // len = 10, cap = 10 newSli := sli[:cap(sli)] // å¯ä»¥çœ‹å‡ºæ­¤å¤„å˜é‡newSliå¤ç”¨äº†sliçš„åº•å±‚æ•°ç»„ï¼Œå¯¼è‡´ä¿®æ”¹ä¸€ä¸ªå…¨éƒ¨éƒ½å˜ fmt.Println(sli, newSli) // [0 0 0 0 0] [0 0 0 0 0 0 0 0 0 0] newSli[0] += 10 fmt.Println(sli, newSli) // [10 0 0 0 0] [10 0 0 0 0 0 0 0 0 0] var x = []int{2,3,5,7,11} fmt.Printf(\u0026#34;åˆ‡ç‰‡xé•¿åº¦å’Œå®¹é‡ï¼š%d, %d\\n\u0026#34;, len(x), cap(x)) a := [5]int{1,2,3,4,5} // len = 2, cap = 4 t := a[1:3:5] // å¯ä»¥çœ‹å‡ºå˜é‡tå¤ç”¨äº†açš„æ•°æ®ï¼Œå¯¼è‡´ä¿®æ”¹ä¸€ä¸ªå…¨éƒ¨éƒ½å˜ fmt.Println(t, a) // [2 3] [1 2 3 4 5] t[0] += 10 fmt.Println(t, a) // [12 3] [1 12 3 4 5] fmt.Printf(\u0026#34;åˆ‡ç‰‡té•¿åº¦å’Œå®¹é‡ï¼š%d, %d\\n\u0026#34;, len(t), cap(t)) // fmt.Println(t[2]) // panic ç´¢å¼•ä¸èƒ½è¶…è¿‡åˆ‡ç‰‡çš„é•¿åº¦ } /** * åˆ‡ç‰‡slié•¿åº¦å’Œå®¹é‡ï¼š5, 10 * [0 0 0 0 0] * [0 0 0 0 0] [0 0 0 0 0 0 0 0 0 0] * [10 0 0 0 0] [10 0 0 0 0 0 0 0 0 0] * åˆ‡ç‰‡xé•¿åº¦å’Œå®¹é‡ï¼š5, 5 * [2 3] [1 2 3 4 5] * [12 3] [1 12 3 4 5] * åˆ‡ç‰‡té•¿åº¦å’Œå®¹é‡ï¼š2, 4 */ åˆ›å»ºåˆ‡ç‰‡æ±‡æ€»ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 package main import \u0026#34;fmt\u0026#34; func main() { // 1. å£°æ˜åˆ‡ç‰‡ï¼Œnilåˆ‡ç‰‡ï¼Œä¹Ÿå°±æ˜¯æ²¡æœ‰åˆ†é…åº•å±‚å…³è”æ•°ç»„çš„åˆ‡ç‰‡ var s1 []int // é»˜è®¤å€¼ä¸º nil æ ¼å¼å¦‚ type slice struct {nil, 0, 0} if s1 == nil { fmt.Println(\u0026#34;æ˜¯nil\u0026#34;) // æ˜¯nil } else { fmt.Println(\u0026#34;ä¸æ˜¯nil\u0026#34;) } // Output: // æ˜¯nil // 2. := []åˆ‡ç‰‡ï¼Œä¹Ÿå°±æ˜¯åˆå§‹åŒ–äº†åº•å±‚å…³è”æ•°ç»„çš„åˆ‡ç‰‡ s2 := []int{} // é»˜è®¤å€¼ä¸º struct {0xxxxxx, 0, 0} if s2 != nil { fmt.Println(\u0026#34;ä¸æ˜¯nil\u0026#34;) // ä¸æ˜¯nil } else { fmt.Println(\u0026#34;æ˜¯nil\u0026#34;) } // Output: // ä¸æ˜¯nil // 3. make() var s3 []int = make([]int, 0) // ç©ºåˆ‡ç‰‡ fmt.Printf(\u0026#34;s1:%#v s2:%#v s3:%#v\\n\u0026#34;, s1, s2, s3) // s1:[]int(nil) s2:[]int{} s3:[]int{} fmt.Println(s1, s2, s3)\t// [] [] [] // 4. åˆå§‹åŒ–èµ‹å€¼ var s4 []int = make([]int, 0, 0) // ç©ºåˆ‡ç‰‡ fmt.Printf(\u0026#34;s4:%#v\\n\u0026#34;, s4) // s4:[]int{} fmt.Println(s4) // [] s5 := []int{1, 2, 3} fmt.Println(s5) // [1 2 3] // 5. ä»æ•°ç»„åˆ‡ç‰‡ arr := [5]int{1, 2, 3, 4, 5} var s6 []int // [1,4)ï¼Œè¯¥è¯­æ³•çš„æ„æ€æ˜¯å¼•ç”¨æ•°ç»„åœ°å€ï¼Œæ³¨æ„è¿”å›çš„æ˜¯å¯¹åº”çš„åˆ‡ç‰‡ // len = 3, cap = 4 s6 = arr[1:4] // è¿™ç§æƒ…å†µä¼šå…±ç”¨æ•°ç»„çš„ä½œä¸ºåº•å±‚å…³è”æ•°ç»„ fmt.Println(s6, len(s6), cap(s6)) // [2 3 4] 3 4 } åˆ‡ç‰‡åˆå§‹åŒ– arrayã€stringã€slice ä½¿ç”¨ [:] æ•°ç»„ä½¿ç”¨[:]è¿”å›çš„æ˜¯å¯¹åº”çš„ã€åˆ‡ç‰‡ã€‘ç±»å‹ï¼Œæ•°ç»„ä½¿ç”¨ [low:high:max] æ—¶ï¼Œlowå’Œhighã€maxå¿…é¡»æ˜¯æ»¡è¶³[0, len(array)]èŒƒå›´ã€‚ å­—ç¬¦ä¸²ä½¿ç”¨[:]è¿”å›çš„è¿˜æ˜¯ã€å­—ç¬¦ä¸²ã€‘ç±»å‹ï¼Œå­—ç¬¦ä¸²ä½¿ç”¨ [low:high] æ—¶ï¼Œlowå’Œhighå¿…é¡»æ˜¯æ»¡è¶³[0, len(string)]èŒƒå›´ã€‚å­—ç¬¦ä¸²ä¸æ”¯æŒç¬¬ä¸‰ä¸ªå‚æ•°maxä¹Ÿæ²¡ä»»ä½•æ„ä¹‰ã€‚ åˆ‡ç‰‡ä½¿ç”¨[:]è¿”å›çš„è¿˜æ˜¯ã€åˆ‡ç‰‡ã€‘ç±»å‹ï¼Œåˆ‡ç‰‡ä½¿ç”¨ [low:high:max] æ—¶ï¼Œlowå’Œhighã€maxå¿…é¡»æ»¡è¶³[0, cap(slice)]èŒƒå›´ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;unsafe\u0026#34; ) // åˆ‡ç‰‡å†…å­˜ç»“æ„ type sliceStruct struct { data uintptr len int cap int } // å­—ç¬¦å†…å­˜ç»“æ„ type stringStruct1 struct { data uintptr len int } func main() { fmt.Println(\u0026#34;array -------\u0026#34;) // 1. æ•°ç»„ä½¿ç”¨[low:high:max]æƒ…å†µæ—¶ var a [3]int = [3]int{1, 2, 3} // \u0026amp;a:0xc000014138, \u0026amp;a[0]0xc000014138 fmt.Printf(\u0026#34;\u0026amp;a:%p, \u0026amp;a[0]%p\\n\u0026#34;, \u0026amp;a, \u0026amp;a[0])\t// len = 2-0 = 2 // cap = 3-0 = 3 a1 := a[:2:3] // è¿™ç§å½¢å¼ç¡®å®å…±ç”¨äº†åŒä¸€ä¸ªåº•å±‚å…³è”æ•°ç»„ u1 := *(**byte)(unsafe.Pointer(\u0026amp;a1)) u2 := *(*sliceStruct)(unsafe.Pointer(\u0026amp;a1)) // u1:0xc000014138, u2:main.sliceStruct{data:0xc000014138, len:2, cap:3} fmt.Printf(\u0026#34;u1:%p, u2:%#v\\n\u0026#34;, u1, u2)\tfmt.Printf(\u0026#34;a.Type: %T\\n\u0026#34;, a1) // a.Type: []int // \u0026gt; ----------------------------------------------------------------------- fmt.Println(\u0026#34;string -------\u0026#34;) // 2. å­—ç¬¦ä¸²ä½¿ç”¨[low:high]æƒ…å†µæ—¶ï¼Œæ„Ÿè§‰å­—ç¬¦ä¸²ä¸­maxå‚æ•°æ²¡ç”¨ var ss string = \u0026#34;hello,world!\u0026#34; // 12 // \u0026amp;ss[0]:0x436cf1 fmt.Printf(\u0026#34;\u0026amp;ss[0]:%p\\n\u0026#34;, *(**byte)(unsafe.Pointer(\u0026amp;ss)))\t// \u0026amp;ss-struct: main.stringStruct1{data:0x436cf1, len:12} fmt.Printf(\u0026#34;\u0026amp;ss-struct: %#v\\n\u0026#34;, *(*stringStruct1)(unsafe.Pointer(\u0026amp;ss)))\tss1 := ss[:10] // len = 10 // \u0026amp;ss1[0]:0x436cf1 fmt.Printf(\u0026#34;\u0026amp;ss1[0]:%p\\n\u0026#34;, *(**byte)(unsafe.Pointer(\u0026amp;ss1)))\t// \u0026amp;ss1-struct: main.stringStruct1{data:0x436cf1, len:10} fmt.Printf(\u0026#34;\u0026amp;ss1-struct: %#v\\n\u0026#34;, *(*stringStruct1)(unsafe.Pointer(\u0026amp;ss1)))\tfmt.Printf(\u0026#34;ss1.Type: %T\\n\u0026#34;, ss1)\t// ss1.Type: string // \u0026gt; ----------------------------------------------------------------------- // 3. åˆ‡ç‰‡ fmt.Println(\u0026#34;slice -------\u0026#34;) var sl []int = []int{1,2,3,4,5,6,7,8} // len=8,cap=8 // ä¸ºä»€ä¹ˆä¸‹é¢çš„åœ°å€æ²¡æœ‰æ›¿æ¢ç¿»å€æ‰©å®¹ï¼ŸåŸå› ä½¿slè¢«è¦†ç›–äº† // å¦‚æœåœ¨è¿™ä¸€è¡Œæ‰“å°slåœ°å€ï¼Œä¸ä¸‹é¢å‘å®šä¸åŒã€‚fmt.Printf(\u0026#34;\u0026amp;sl[0]:%p\\n\u0026#34;, \u0026amp;sl[0]) sl = append(sl, 9) // è¿™é‡Œç¿»å€æ‰©å®¹äº† // \u0026amp;sl[0]:0xc00000c340 fmt.Printf(\u0026#34;\u0026amp;sl[0]:%p\\n\u0026#34;, \u0026amp;sl[0])\t// \u0026amp;sl[0]:0xc00000c340 fmt.Printf(\u0026#34;\u0026amp;sl[0]:%p\\n\u0026#34;, *(**byte)(unsafe.Pointer(\u0026amp;sl)))\t// sl-struct:main.sliceStruct{data:0xc00000c340, len:9, cap:16} fmt.Printf(\u0026#34;sl-struct:%#v\\n\u0026#34;, *(*sliceStruct)(unsafe.Pointer(\u0026amp;sl)))\tsl1 := sl[:] // \u0026amp;sl1[0]:0xc00000c340 fmt.Printf(\u0026#34;\u0026amp;sl1[0]:%p\\n\u0026#34;, \u0026amp;sl1[0])\tsl2 := sl[:10:16] // æ­£æ˜¯ç”±äºå‰é¢slç¿»å€æ‰©å®¹äº†ï¼Œè¿™é‡Œèƒ½å–åˆ°16 // \u0026amp;sl1[0]:0xc00000c340 fmt.Printf(\u0026#34;\u0026amp;sl1[0]:%p\\n\u0026#34;, \u0026amp;sl2[0])\t} [:]åˆå§‹åŒ– 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 // å…¨å±€ï¼š var arr = [...]int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9} // len=10 // len=9,cap=10 var slice0 []int = arr[0:9] // [0,9) // len=9,cap=10 var slice1 []int = arr[:9] // [0,9) // len=10,cap=10 var slice2 []int = arr[0:] // [0,10] // len=10,cap=10 var slice3 []int = arr[:] // [0,10] // len=9,cap=10 // arr[:9] var slice4 = arr[:len(arr)-1] // å»æ‰åˆ‡ç‰‡çš„æœ€åä¸€ä¸ªå…ƒç´  // å±€éƒ¨ï¼š arr2 := [...]int{9, 8, 7, 6, 5, 4, 3, 2, 1, 0} slice5 := arr[0:9] slice6 := arr[:9] slice7 := arr[0:] slice8 := arr[:] slice9 := arr[:len(arr)-1] //å»æ‰åˆ‡ç‰‡çš„æœ€åä¸€ä¸ªå…ƒç´  æ“ä½œ å«ä¹‰ s[n] åˆ‡ç‰‡sä¸­ç´¢å¼•ä½ç½®ä¸ºnçš„é¡¹ s[:] ä»åˆ‡ç‰‡sçš„ç´¢å¼•ä½ç½®0åˆ°len(s)-1å¤„æ‰€è·å¾—çš„åˆ‡ç‰‡ s[low:] ä»åˆ‡ç‰‡sçš„ç´¢å¼•ä½ç½®lowåˆ°len(s)-1å¤„æ‰€è·å¾—çš„åˆ‡ç‰‡ s[:high] ä»åˆ‡ç‰‡sçš„ç´¢å¼•ä½ç½®0åˆ°highå¤„æ‰€è·å¾—çš„åˆ‡ç‰‡ï¼Œlen == high s[low:high] ä»åˆ‡ç‰‡sçš„ç´¢å¼•ä½ç½®lowåˆ°highå¤„æ‰€è·å¾—çš„åˆ‡ç‰‡ï¼Œlen == high-low s[low:high:max] ä»åˆ‡ç‰‡sçš„ç´¢å¼•ä½ç½®lowåˆ°highå¤„æ‰€è·å¾—çš„åˆ‡ç‰‡ï¼Œlen == high-lowï¼Œcap == max-low len(s) åˆ‡ç‰‡sçš„é•¿åº¦ï¼Œæ€»æ˜¯ \u0026lt;= cap(s) cap(s) åˆ‡ç‰‡sçš„å®¹é‡ï¼Œæ€»æ˜¯ \u0026gt;= len(s) s[low:high:max]ï¼š çœç•¥lowé»˜è®¤ä¸º0ã€‚ çœç•¥highé»˜è®¤ä¸ºlen(s)ã€‚ çœç•¥maxé»˜è®¤ä¸ºcap(s)ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 package main import ( \u0026#34;fmt\u0026#34; ) var arr = [...]int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9} // main.init // main.init.0 var slice0 []int = arr[2:8] var slice1 []int = arr[0:6] // å¯ä»¥ç®€å†™ä¸º var slice []int = arr[:end] var slice2 []int = arr[5:10] // å¯ä»¥ç®€å†™ä¸º var slice[]int = arr[start:] var slice3 []int = arr[0:len(arr)] // var slice []int = arr[:] var slice4 = arr[:len(arr)-1] // å»æ‰åˆ‡ç‰‡çš„æœ€åä¸€ä¸ªå…ƒç´  func main() { fmt.Printf(\u0026#34;å…¨å±€å˜é‡ï¼šarr %v\\n\u0026#34;, arr) fmt.Printf(\u0026#34;å…¨å±€å˜é‡ï¼šslice0 %v\\n\u0026#34;, slice0) fmt.Printf(\u0026#34;å…¨å±€å˜é‡ï¼šslice1 %v\\n\u0026#34;, slice1) fmt.Printf(\u0026#34;å…¨å±€å˜é‡ï¼šslice2 %v\\n\u0026#34;, slice2) fmt.Printf(\u0026#34;å…¨å±€å˜é‡ï¼šslice3 %v\\n\u0026#34;, slice3) fmt.Printf(\u0026#34;å…¨å±€å˜é‡ï¼šslice4 %v\\n\u0026#34;, slice4) fmt.Printf(\u0026#34;-----------------------------------\\n\u0026#34;) arr2 := [...]int{9, 8, 7, 6, 5, 4, 3, 2, 1, 0} slice5 := arr[2:8] slice6 := arr[0:6] //å¯ä»¥ç®€å†™ä¸º slice := arr[:end] slice7 := arr[5:10] //å¯ä»¥ç®€å†™ä¸º slice := arr[start:] slice8 := arr[0:len(arr)] //slice := arr[:] slice9 := arr[:len(arr)-1] //å»æ‰åˆ‡ç‰‡çš„æœ€åä¸€ä¸ªå…ƒç´  fmt.Printf(\u0026#34;å±€éƒ¨å˜é‡ï¼š arr2 %v\\n\u0026#34;, arr2) fmt.Printf(\u0026#34;å±€éƒ¨å˜é‡ï¼š slice5 %v\\n\u0026#34;, slice5) fmt.Printf(\u0026#34;å±€éƒ¨å˜é‡ï¼š slice6 %v\\n\u0026#34;, slice6) fmt.Printf(\u0026#34;å±€éƒ¨å˜é‡ï¼š slice7 %v\\n\u0026#34;, slice7) fmt.Printf(\u0026#34;å±€éƒ¨å˜é‡ï¼š slice8 %v\\n\u0026#34;, slice8) fmt.Printf(\u0026#34;å±€éƒ¨å˜é‡ï¼š slice9 %v\\n\u0026#34;, slice9) // Output: // å…¨å±€å˜é‡ï¼šarr [0 1 2 3 4 5 6 7 8 9] // å…¨å±€å˜é‡ï¼šslice0 [2 3 4 5 6 7] // å…¨å±€å˜é‡ï¼šslice1 [0 1 2 3 4 5] // å…¨å±€å˜é‡ï¼šslice2 [5 6 7 8 9] // å…¨å±€å˜é‡ï¼šslice3 [0 1 2 3 4 5 6 7 8 9] // å…¨å±€å˜é‡ï¼šslice4 [0 1 2 3 4 5 6 7 8] // ----------------------------------- // å±€éƒ¨å˜é‡ï¼š arr2 [9 8 7 6 5 4 3 2 1 0] // å±€éƒ¨å˜é‡ï¼š slice5 [2 3 4 5 6 7] // å±€éƒ¨å˜é‡ï¼š slice6 [0 1 2 3 4 5] // å±€éƒ¨å˜é‡ï¼š slice7 [5 6 7 8 9] // å±€éƒ¨å˜é‡ï¼š slice8 [0 1 2 3 4 5 6 7 8 9] // å±€éƒ¨å˜é‡ï¼š slice9 [0 1 2 3 4 5 6 7 8] } make()åˆ›å»ºåˆ‡ç‰‡ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 package main import ( \u0026#34;fmt\u0026#34; ) var slice0 []int = make([]int, 10) var slice1 = make([]int, 10) var slice2 = make([]int, 10, 10) func main() { fmt.Printf(\u0026#34;makeå…¨å±€slice0 ï¼š%v\\n\u0026#34;, slice0) fmt.Printf(\u0026#34;makeå…¨å±€slice1 ï¼š%v\\n\u0026#34;, slice1) fmt.Printf(\u0026#34;makeå…¨å±€slice2 ï¼š%v\\n\u0026#34;, slice2) fmt.Println(\u0026#34;--------------------------------------\u0026#34;) slice3 := make([]int, 10) slice4 := make([]int, 10) slice5 := make([]int, 10, 10) fmt.Printf(\u0026#34;makeå±€éƒ¨slice3 ï¼š%v\\n\u0026#34;, slice3) fmt.Printf(\u0026#34;makeå±€éƒ¨slice4 ï¼š%v\\n\u0026#34;, slice4) fmt.Printf(\u0026#34;makeå±€éƒ¨slice5 ï¼š%v\\n\u0026#34;, slice5) // Output: // makeå…¨å±€slice0 ï¼š[0 0 0 0 0 0 0 0 0 0] // makeå…¨å±€slice1 ï¼š[0 0 0 0 0 0 0 0 0 0] // makeå…¨å±€slice2 ï¼š[0 0 0 0 0 0 0 0 0 0] // -------------------------------------- // makeå±€éƒ¨slice3 ï¼š[0 0 0 0 0 0 0 0 0 0] // makeå±€éƒ¨slice4 ï¼š[0 0 0 0 0 0 0 0 0 0] // makeå±€éƒ¨slice5 ï¼š[0 0 0 0 0 0 0 0 0 0] } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 package main import ( \u0026#34;fmt\u0026#34; ) func main() { data := [...]int{0, 1, 2, 3, 4, 5} s := data[2:4] // åˆ‡å‰²æ•°ç»„æ˜¯å¼•ç”¨æ•°ç»„åœ°å€ s[0] += 100 s[1] += 200 fmt.Println(s) fmt.Println(data) // Output: // [102 203] // [0 1 102 203 4 5] } å¯ç›´æ¥åˆ›å»º slice å¯¹è±¡ï¼Œè‡ªåŠ¨åˆ†é…åº•å±‚æ•°ç»„ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 package main import \u0026#34;fmt\u0026#34; func main() { s1 := []int{0, 1, 2, 3, 8: 100} // é€šè¿‡åˆå§‹åŒ–è¡¨è¾¾å¼æ„é€ ï¼Œå¯ä½¿ç”¨ç´¢å¼•å·ã€‚ fmt.Println(s1, len(s1), cap(s1)) s2 := make([]int, 6, 8) // ä½¿ç”¨ make åˆ›å»ºï¼ŒæŒ‡å®š len å’Œ cap å€¼ã€‚ fmt.Println(s2, len(s2), cap(s2)) s3 := make([]int, 6) // çœç•¥ capï¼Œç›¸å½“äº cap = lenã€‚ fmt.Println(s3, len(s3), cap(s3)) // Output: // [0 1 2 3 0 0 0 0 100] 9 9 // [0 0 0 0 0 0] 6 8 // [0 0 0 0 0 0] 6 6 } ä½¿ç”¨ make åŠ¨æ€åˆ›å»ºsliceï¼Œé¿å…äº†æ•°ç»„å¿…é¡»ç”¨å¸¸é‡åšé•¿åº¦çš„éº»çƒ¦ã€‚ è¿˜å¯ç”¨æŒ‡é’ˆç›´æ¥è®¿é—®åº•å±‚æ•°ç»„ï¼Œé€€åŒ–æˆæ™®é€šæ•°ç»„æ“ä½œã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 package main import \u0026#34;fmt\u0026#34; func main() { s := []int{0, 1, 2, 3} p := \u0026amp;s[2] // *int, è·å–åº•å±‚æ•°ç»„å…ƒç´ æŒ‡é’ˆã€‚ *p += 100 fmt.Println(s) // [0 1 102 3] // Output: // [0 1 102 3] } äºŒç»´åˆ‡ç‰‡ è‡³äº [][]Tï¼Œæ˜¯æŒ‡å…ƒç´ ç±»å‹ä¸º []Tï¼Œè¯¥ç»“æ„ä¸ºäºŒç»´åˆ‡ç‰‡ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;unsafe\u0026#34; ) func main() { // makeå‡½æ•°åªèƒ½åˆå§‹åŒ–æœ€å¤–å±‚å†…å­˜ï¼Œä¹Ÿå°±æ˜¯24 * 16ï¼Œæœ€é‡Œå±‚ä¸èƒ½ // ä¼šåˆ›å»º24 * 16 å¤§å°å†…å­˜ï¼Œä¹Ÿå°±æ˜¯[]int * capä¼šåˆ†é…å†…å­˜ï¼Œä½†æ˜¯æœ€é‡Œä¸€å±‚å¹¶æ²¡æœ‰åˆå§‹åŒ–è¿™ç‚¹éœ€è¦æ³¨æ„ s := make([][]int, 8, 16)\t// [][]int{[]int(nil), []int(nil), []int(nil), []int(nil), []int(nil), []int(nil), []int(nil), []int(nil)} fmt.Printf(\u0026#34;%#v\\n\u0026#34;, s)\ts[0] = make([]int, 2, 4) // [][]int{[]int{0, 0}, []int(nil), []int(nil), []int(nil), []int(nil), []int(nil), []int(nil), []int(nil)} fmt.Printf(\u0026#34;%#v\\n\u0026#34;, s)\t// æ³¨æ„sè¿˜æ˜¯åˆ‡ç‰‡ç»“æ„ï¼Œå› æ­¤è¿™é‡Œä¾ç„¶å ç”¨24å­—èŠ‚å¤§å° fmt.Printf(\u0026#34;så ç”¨å†…å­˜å¤§å°%d\\n\u0026#34;, unsafe.Sizeof(s))\t} 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 package main import ( \u0026#34;fmt\u0026#34; ) func main() { data := [][]int{ []int{1, 2, 3}, []int{100, 200}, []int{11, 22, 33, 44}, } fmt.Println(data)\tfmt.Printf(\u0026#34;%#v\\n\u0026#34;, data)\t// Output: // [[1 2 3] [100 200] [11 22 33 44]] // [][]int{[]int{1, 2, 3}, []int{100, 200}, []int{11, 22, 33, 44}} } å¯ç›´æ¥ä¿®æ”¹ struct array/slice æˆå‘˜ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 package main import ( \u0026#34;fmt\u0026#34; ) func main() { d := [5]struct { x int }{} // ä½¿ç”¨d[:]æ•°ç»„dç§°ä¸ºsçš„åº•å±‚å…³è”æ•°ç»„ s := d[:] // ä¿®æ”¹dçš„æ•°æ®ç›¸å½“äºç›´æ¥ä¿®æ”¹sçš„åº•å±‚å…³è”æ•°ç»„ d[1].x = 10 // ä¿®æ”¹sçš„æ•°æ®ä¹Ÿç›¸å½“äºç›´æ¥ä¿®æ”¹sçš„åº•å±‚å…³è”æ•°ç»„dçš„æ•°æ® s[2].x = 20 fmt.Println(d) // [{0} {10} {20} {0} {0}] fmt.Println(s) // [{0} {10} {20} {0} {0}] // 0xc00000c3f0, 0xc00000c3f0, 0xc000004078, 0xc00000c3f0 fmt.Printf(\u0026#34;%p, %p, %p, %p\\n\u0026#34;, \u0026amp;d, \u0026amp;d[0], \u0026amp;s, \u0026amp;s[0]) } append()è¿½åŠ å…ƒç´  append(s S, x ...T) S å‘såˆ‡ç‰‡ä¸­è¿½åŠ æ•°æ®Tï¼ˆTçš„ç±»å‹ä¸ºsåˆ‡ç‰‡çš„å…ƒç´ ç±»å‹ï¼‰S = []Tã€‚è¿”å›è¿½åŠ åçš„åˆ‡ç‰‡Sã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 package main import ( \u0026#34;fmt\u0026#34; ) func main() { var a = []int{1, 2, 3} // len 3 cap 3 fmt.Printf(\u0026#34;slice a : %v\\n\u0026#34;, a) var b = []int{4, 5, 6} // len 3 cap 3 fmt.Printf(\u0026#34;slice b : %v\\n\u0026#34;, b) c := append(a, b...) // len 6 cap 6 fmt.Printf(\u0026#34;slice c : %v\\n\u0026#34;, c) d := append(c, 7) // len 7 cap 12 fmt.Printf(\u0026#34;slice d : %v\\n\u0026#34;, d) e := append(d, 8, 9, 10)// len 10 cap 12 fmt.Printf(\u0026#34;slice e : %v, %d, %d\\n\u0026#34;, e, len(e), cap(e)) // Output: // slice a : [1 2 3] // slice b : [4 5 6] // slice c : [1 2 3 4 5 6] // slice d : [1 2 3 4 5 6 7] // slice e : [1 2 3 4 5 6 7 8 9 10], 10, 12 } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 package main import \u0026#34;fmt\u0026#34; func main() { var c []byte = make([]byte, 0, 20) // slice = append([]byte(\u0026#34;hello \u0026#34;), \u0026#34;world\u0026#34;...) c = append(c, \u0026#34;Goè¯­è¨€001\u0026#34;...) fmt.Printf(\u0026#34;%#v\\n\u0026#34;, c) fmt.Println(string(c)) // Output: // []byte{0x47, 0x6f, 0xe8, 0xaf, 0xad, 0xe8, 0xa8, 0x80, 0x30, 0x30, 0x31} // Goè¯­è¨€001 } appendï¼šå‘sliceå°¾éƒ¨æ·»åŠ æ•°æ®ï¼Œè¿”å›æ–°çš„sliceå¯¹è±¡ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;unsafe\u0026#34; ) func main() { s1 := make([]int, 0, 5) // %p è¿™é‡Œæ˜¯ æ‰“å°s1ç¬¬ä¸€ä¸ªæŒ‡é’ˆåœ°å€ï¼Œæ‰€ä»¥è¿™é‡Œæ˜¾ç¤ºçš„æ˜¯ç¬¬ä¸€ä¸ª8Bå­˜å‚¨çš„å€¼ fmt.Printf(\u0026#34;s1å…³è”æ•°ç»„åœ°å€ï¼š%p\\n\u0026#34;, s1) s2 := append(s1, 2012, 5) fmt.Printf(\u0026#34;s2å…³è”æ•°ç»„åœ°å€ï¼š%p\\n\u0026#34;, s2) fmt.Println(s1, s2, len(s1), cap(s1), len(s2), cap(s2)) // [] [2012 5] 0 5 2 5 // Output: // s1å…³è”æ•°ç»„åœ°å€ï¼š0xc0000c2060 // s2å…³è”æ•°ç»„åœ°å€ï¼š0xc0000c2060 // [] [2012 5] 0 5 2 5 // åˆ‡ç‰‡ç»“æ„ slice struct { data pointer, len int, cap int } // a1æ‹¿åˆ°çš„æ˜¯ç»“æ„ä½“ä¸­dataçš„å€¼ä¹Ÿå°±æ˜¯åº•å±‚å…³è”æ•°ç»„çš„é¦–åœ°å€å€¼ a1 := *(*uintptr)(unsafe.Pointer(\u0026amp;s2)) fmt.Printf(\u0026#34;a1:type:%T a1å­˜å‚¨çš„å€¼:%#x\\n\u0026#34;, a1, a1) // a1:type:uintptr a1å­˜å‚¨çš„å€¼:0xc0000c2060 // s2[0]çš„å€¼ fmt.Println(*(*int)(unsafe.Pointer(uintptr(unsafe.Pointer(nil)) + *(*uintptr)(unsafe.Pointer(\u0026amp;s2))))) // s2[1]çš„å€¼ fmt.Println(*(*int)(unsafe.Pointer(uintptr(unsafe.Pointer(nil)) + *(*uintptr)(unsafe.Pointer(\u0026amp;s2)) + unsafe.Sizeof(int(0))))) // s2[2]çš„å€¼ ç›´æ¥è®¿é—®s2[2]ä¼šå‡ºç°ä¸‹æ ‡è¶Šç•Œ fmt.Println(*(*int)(unsafe.Pointer(uintptr(unsafe.Pointer(nil)) + *(*uintptr)(unsafe.Pointer(\u0026amp;s2)) + 2 * unsafe.Sizeof(int(0))))) // Output: // s1å…³è”æ•°ç»„åœ°å€ï¼š0xc0000c6060 // s2å…³è”æ•°ç»„åœ°å€ï¼š0xc0000c6060 // [] [2012 5] 0 5 2 5 // a1:type:uintptr a1å­˜å‚¨çš„å€¼:oxc0000c6060 // 2012 // 5 // 0 } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;unsafe\u0026#34; ) type SliceHeader struct { Data uintptr Len int Cap int } func main() { s1 := make([]int, 0, 5) fmt.Println(s1) // [] fmt.Printf(\u0026#34;%p\\n\u0026#34;, s1) // 0xc00001a0c0 // main.SliceHeader{Data:0xc00001a0c0, Len:0, Cap:5} fmt.Printf(\u0026#34;%#v\\n\u0026#34;, *(*SliceHeader)(unsafe.Pointer(\u0026amp;s1)))\ts2 := append(s1, 1, 2) fmt.Printf(\u0026#34;%p\\n\u0026#34;, s2) // 0xc00001a0c0 s3 := append(s2, 1, 2, 3, 4) fmt.Printf(\u0026#34;%p\\n\u0026#34;, s3) // 0xc0000c4000 } slice.cap é™åˆ¶ ä¼šé‡æ–°åˆ†é…åº•å±‚æ•°ç»„ï¼Œå³ä¾¿åŸæ•°ç»„å¹¶æœªå¡«æ»¡ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 package main import ( \u0026#34;fmt\u0026#34; ) func main() { data := [...]int{0, 1, 2, 3, 4, 10: 0} s := data[:2:3] s = append(s, 100, 200) // ä¸€æ¬¡ append ä¸¤ä¸ªå€¼ï¼Œè¶…å‡º s.cap é™åˆ¶ã€‚ fmt.Println(s, data) // é‡æ–°åˆ†é…åº•å±‚æ•°ç»„ï¼Œä¸åŸæ•°ç»„æ— å…³ã€‚ fmt.Println(\u0026amp;s[0], \u0026amp;data[0]) // æ¯”å¯¹åº•å±‚æ•°ç»„èµ·å§‹æŒ‡é’ˆã€‚ // Output: // [0 1 100 200] [0 1 2 3 4 0 0 0 0 0 0] // 0xc00000c3f0 0xc00005c060 } ä»è¾“å‡ºç»“æœå¯ä»¥çœ‹å‡ºï¼š append åçš„ s é‡æ–°åˆ†é…äº†åº•å±‚æ•°ç»„ï¼Œå¹¶å¤åˆ¶æ•°æ®ã€‚ å¦‚æœåªè¿½åŠ ä¸€ä¸ªå€¼ï¼Œåˆ™ä¸ä¼šè¶…è¿‡ s.cap é™åˆ¶ï¼Œä¹Ÿå°±ä¸ä¼šé‡æ–°åˆ†é…ã€‚ é€šå¸¸ä»¥ 2 å€å®¹é‡é‡æ–°åˆ†é…åº•å±‚æ•°ç»„ã€‚ åœ¨å¤§æ‰¹é‡æ·»åŠ æ•°æ®æ—¶ï¼Œå»ºè®®ä¸€æ¬¡æ€§åˆ†é…è¶³å¤Ÿå¤§çš„ç©ºé—´ï¼Œä»¥å‡å°‘å†…å­˜åˆ†é…å’Œæ•°æ®å¤åˆ¶å¼€é”€ã€‚ æˆ–åˆå§‹åŒ–è¶³å¤Ÿé•¿çš„ len å±æ€§ï¼Œæ”¹ç”¨ç´¢å¼•å·è¿›è¡Œæ“ä½œã€‚ åŠæ—¶é‡Šæ”¾ä¸å†ä½¿ç”¨çš„ slice å¯¹è±¡ï¼Œé¿å…æŒæœ‰è¿‡æœŸæ•°ç»„ï¼Œé€ æˆ GC æ— æ³•å›æ”¶ã€‚ copy() ä½¿ç”¨ copy(to, fm slice) int ä¸ copy(to []byte, fm string) intã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 package main import ( \u0026#34;fmt\u0026#34; ) func main() { s1 := []int{1, 2, 3, 4, 5} fmt.Printf(\u0026#34;slice s1 : %v\\n\u0026#34;, s1) // slice s1 : [1 2 3 4 5] s2 := make([]int, 10) fmt.Printf(\u0026#34;slice s2 : %v\\n\u0026#34;, s2) // slice s2 : [0 0 0 0 0 0 0 0 0 0] // copy(to, fm slice) int fm -\u0026gt; to copy(s2, s1) fmt.Printf(\u0026#34;copied slice s1 : %v\\n\u0026#34;, s1) // copied slice s1 : [1 2 3 4 5] fmt.Printf(\u0026#34;copied slice s2 : %v\\n\u0026#34;, s2) // copied slice s2 : [1 2 3 4 5 0 0 0 0 0] s3 := []int{1, 2, 3} fmt.Printf(\u0026#34;slice s3 : %v\\n\u0026#34;, s3) // slice s3 : [1 2 3] s3 = append(s3, s2...) fmt.Printf(\u0026#34;appended slice s3 : %v\\n\u0026#34;, s3) // appended slice s3 : [1 2 3 1 2 3 4 5 0 0 0 0 0] s3 = append(s3, 4, 5, 6) fmt.Printf(\u0026#34;last slice s3 : %v\\n\u0026#34;, s3) // last slice s3 : [1 2 3 1 2 3 4 5 0 0 0 0 0 4 5 6] } å‡½æ•°copyåœ¨ä¸¤ä¸ªsliceé—´å¤åˆ¶æ•°æ®ï¼Œå¤åˆ¶é•¿åº¦ä»¥ lenå°çš„ä¸ºå‡†ã€‚ ä¸¤ä¸ªsliceå¯æŒ‡å‘åŒä¸€åº•å±‚æ•°ç»„ï¼Œå…è®¸å…ƒç´ åŒºé—´é‡å ï¼ˆä¸¤ä¸ªåˆ‡ç‰‡éƒ½æŒ‡å‘åŒä¸€åº•å±‚æ•°ç»„æ—¶éœ€è¦æ³¨æ„è¦†ç›–é—®é¢˜ï¼‰ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 package main import ( \u0026#34;fmt\u0026#34; ) func main() { data := [...]int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9} fmt.Println(\u0026#34;array data : \u0026#34;, data) // array data : [0 1 2 3 4 5 6 7 8 9] s1 := data[8:] s2 := data[:5] fmt.Printf(\u0026#34;slice s1 : %v\\n\u0026#34;, s1) // slice s1 : [8 9] fmt.Printf(\u0026#34;slice s2 : %v\\n\u0026#34;, s2) // slice s2 : [0 1 2 3 4] // copy(to, fm slice) int copy(s2, s1) fmt.Printf(\u0026#34;copied slice s1 : %v\\n\u0026#34;, s1) // copied slice s1 : [8 9] fmt.Printf(\u0026#34;copied slice s2 : %v\\n\u0026#34;, s2) // copied slice s2 : [8 9 2 3 4] // æ³¨æ„è¿™é‡Œç´¢å¼•0 ç´¢å¼•1çš„å€¼ åœ¨copyå‡½æ•°æ—¶å‘ç”Ÿäº†å˜åŒ–ï¼Œå› ä¸ºéƒ½æ˜¯åŒä¸€ä¸ªåº•å±‚æ•°ç»„çš„åŸå›  fmt.Println(\u0026#34;last array data : \u0026#34;, data)\t// last array data : [8 9 2 3 4 5 6 7 8 9] } åº”åŠæ—¶å°†æ‰€éœ€æ•°æ®copyåˆ°è¾ƒå°çš„sliceï¼Œä»¥ä¾¿é‡Šæ”¾è¶…å¤§å·åº•å±‚æ•°ç»„å†…å­˜ã€‚ éå†åˆ‡ç‰‡ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 package main import ( \u0026#34;fmt\u0026#34; ) func main() { data := [...]int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9} slice := data[:] for index, value := range slice { fmt.Printf(\u0026#34;inde : %v , value : %v\\n\u0026#34;, index, value) } } /* * inde : 0 , value : 0 * inde : 1 , value : 1 * inde : 2 , value : 2 * inde : 3 , value : 3 * inde : 4 , value : 4 * inde : 5 , value : 5 * inde : 6 , value : 6 * inde : 7 , value : 7 * inde : 8 , value : 8 * inde : 9 , value : 9 */ å­—ç¬¦ä¸²å’Œåˆ‡ç‰‡ stringï¼šåº•å±‚å°±æ˜¯ä¸€ä¸ªçš„æ•°ç»„ï¼Œå› æ­¤ï¼Œä¹Ÿå¯ä»¥è¿›è¡Œåˆ‡ç‰‡æ“ä½œã€‚ stringæ•°æ®ç»“æ„ï¼štype string struct {data uintptr; len int}ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 package main import \u0026#34;fmt\u0026#34; func main() { str := \u0026#34;hello world\u0026#34; s1 := str[0:5] // string fmt.Println(s1) s2 := str[6:] // string fmt.Println(s2) // Output: // hello // world } stringæœ¬èº«æ˜¯ä¸å¯å˜çš„ï¼Œå› æ­¤è¦æ”¹å˜stringä¸­å­—ç¬¦ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 package main import \u0026#34;fmt\u0026#34; func main() { str := \u0026#34;Hello world\u0026#34; // []byte(str) ä¼šé‡æ–°åˆ†é…å†…å­˜å¹¶æ‹·è´stræ•°æ® s := []byte(str) // ä¸­æ–‡å­—ç¬¦éœ€è¦ç”¨[]rune(str) s[6] = \u0026#39;G\u0026#39; // å¯ä»¥çœ‹å‡ºä½¿ç”¨[]byteå¼ºåˆ¶è½¬æ¢ã€å¹¶æ²¡ã€‘ç”¨å…±ç”¨ä¸€ä¸ªåº•å±‚æ•°ç»„ fmt.Println(str, string(s)) // Hello world Hello Gorld s = s[:8] s = append(s, \u0026#39;!\u0026#39;) // string(s) ä¹Ÿä¼šé‡æ–°åˆ†é…ä¸€å—å†…å­˜ï¼Œç„¶åæ‹·è´sæ•°æ® // åŸå› æ˜¯sliceæ˜¯å¯å˜çš„ï¼Œè€Œstringæ˜¯ä¸å¯å˜çš„ str = string(s) // åˆ‡ç‰‡è½¬å­—ç¬¦ä¸² fmt.Println(str)// Hello Go! } nilåˆ‡ç‰‡å’Œç©ºåˆ‡ç‰‡åŒºåˆ« nilåˆ‡ç‰‡è¡¨ç¤ºåˆ‡ç‰‡æ²¡æœ‰åˆå§‹åŒ–ï¼Œä¹Ÿå°±æ˜¯æ²¡æœ‰åˆ†é…å­˜å‚¨åœ°å€ã€‚ ç©ºåˆ‡ç‰‡åˆ™æ˜¯åˆ‡ç‰‡å·²ç»åˆå§‹åŒ–ï¼Œå¹¶åˆ†é…äº†å­˜å‚¨åœ°å€ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 package main import ( \u0026#34;fmt\u0026#34; ) func main() { var sl []string // nilåˆ‡ç‰‡ slå¹¶æ²¡æœ‰åˆ†é…åº•å±‚å†…å­˜åœ°å€ if sl == nil { fmt.Println(\u0026#34;aaaa\u0026#34;) } } // çœ‹ä¸‹ç›¸å…³æ±‡ç¼– string.go:7 0x496680 493b6610 cmp rsp, qword ptr [r14+0x10] string.go:7 0x496684 767d jbe 0x496703 string.go:7 0x496686 4883ec68 sub rsp, 0x68 string.go:7 0x49668a 48896c2460 mov qword ptr [rsp+0x60], rbp string.go:7 0x49668f 488d6c2460 lea rbp, ptr [rsp+0x60] // è¿™æ˜¯è®¾ç½® slice.data = 0 å¯ä»¥çœ‹å‡ºå¹¶æ²¡æœ‰åˆ†é…å­˜å‚¨å†…å­˜ string.go:8 0x496694 48c744243000000000 mov qword ptr [rsp+0x30], 0x0 // è¿™é‡Œæ˜¯ slice.len = slice.cap = 0 è®¾ç½®äº†é•¿åº¦å’Œå®¹é‡ string.go:8 0x49669d 440f117c2438 movups xmmword ptr [rsp+0x38], xmm15 1 2 3 4 5 6 7 8 9 10 11 12 13 package main import ( \u0026#34;fmt\u0026#34; ) func main() { sl := []string{} // ç©ºåˆ‡ç‰‡ slæ­¤æ—¶å·²ç»åˆå§‹åŒ–è¿‡ï¼Œåˆ†é…äº†åº•å±‚å†…å­˜åœ°å€ if sl == nil { fmt.Println(\u0026#34;aaaa\u0026#34;) } } // çœ‹ä¸‹ç›¸å…³æ±‡ç¼– string.go:7\t0x46d240 4883ec30 sub rsp, 0x30 string.go:7\t0x46d244 48896c2428 mov qword ptr [rsp+0x28], rbp string.go:7\t0x46d249 488d6c2428 lea rbp, ptr [rsp+0x28] // []stringçš„åº•å±‚æ•°ç»„è¢«ç¼–è¯‘å™¨ç›´æ¥åˆ†é…åœ¨äº†æ ˆä¸Šï¼Œå› ä¸ºrspå­˜å‚¨çš„æ˜¯æ ˆä¸Šçš„å€¼ string.go:8\t0x46d24e 488d0424 lea rax, ptr [rsp] // rax = rsp å­˜å‚¨çš„å€¼ // [rsp+0x8] = rax è¿™é‡Œæ˜¯å­˜å‚¨çš„å˜é‡slçš„åœ°å€ç©ºé—´æŒ‡å‘slice.data string.go:8\t0x46d252 4889442408 mov qword ptr [rsp+0x8], rax string.go:8\t0x46d257 8400 test byte ptr [rax], al string.go:8\t0x46d259 eb00 jmp 0x46d25b // [rsp+0x10] = rax slice.data = rax å¯ä»¥çœ‹å‡ºæ˜¯åˆ†é…äº†åœ°å€ç©ºé—´ string.go:8\t0x46d25b 4889442410\tmov qword ptr [rsp+0x10], rax // è¿™é‡Œæ˜¯ slice.len = slice.cap = 0 è®¾ç½®äº†é•¿åº¦å’Œå®¹é‡ string.go:8\t0x46d260 440f117c2418 movups xmmword ptr [rsp+0x18], xmm15 string.go:10 0x46d266 eb00 jmp 0x46d268 string.go:13 0x46d268 488b6c2428 mov rbp, qword ptr [rsp+0x28] .:0 0x46d26d 4883c430 add rsp, 0x30 .:0 0x46d271 c3 ret åˆ‡ç‰‡é‡ç»„ é€šè¿‡æ”¹å˜åˆ‡ç‰‡é•¿åº¦å¾—åˆ°æ–°åˆ‡ç‰‡çš„è¿‡ç¨‹ç§°ä¸ºåˆ‡ç‰‡é‡ç»„ã€‚ å¦‚slice1 = slice1[0:end] å–å€¼èŒƒå›´len = end - 0; cap = cap - 0; å…¶ä¸­endæ˜¯æ–°çš„æœ«å°¾ç´¢å¼•ï¼ˆå³é•¿åº¦ï¼‰ã€‚ åœ¨ä¸€ä¸ªåˆ‡ç‰‡åŸºç¡€ä¸Šé‡æ–°åˆ’åˆ†ä¸€ä¸ªåˆ‡ç‰‡æ—¶ï¼Œæ–°çš„åˆ‡ç‰‡ä¼šç»§ç»­å¼•ç”¨åŸæœ‰åˆ‡ç‰‡çš„ç›¸å…³æ•°ç»„ã€‚ å¦‚æœå¿˜è®°è¿™ä¸ªè¡Œä¸ºï¼Œåœ¨ç¨‹åºå†…å­˜å†…åˆ†é…å ç”¨å¤§é‡çš„å†…å­˜çš„ä¸´æ—¶åˆ‡ç‰‡ã€‚ ç„¶ååœ¨è¿™ä¸ªä¸´æ—¶åˆ‡ç‰‡åŸºç¡€ä¸Šåˆ›å»ºåªå¼•ç”¨ä¸€å°éƒ¨åˆ†åŸæœ‰æ•°æ®çš„æ–°åˆ‡ç‰‡æ—¶ã€‚ ä¼šå¯¼è‡´éš¾ä»¥é¢„æœŸçš„å†…å­˜ä½¿ç”¨ç»“æœã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 package main import ( \u0026#34;fmt\u0026#34; ) func get() []byte { raw := make([]byte, 10000) fmt.Println(len(raw), cap(raw), \u0026amp;raw[0]) // 10000 10000 0xc000090000 // æ­¤å¤„è¿”å›å€¼å¼•ç”¨å˜é‡rawçš„åº•å±‚éƒ¨åˆ†æ•°ç»„æ•°æ®ï¼Œå¯¼è‡´è¿”å›æ—¶rawä»æ ˆé€ƒé€¸åˆ°å †é‡Œ // return raw[:3:3] // è¿™ç§ä¹Ÿä¼šé€ƒé€¸åˆ°å † // è¿”å›åˆ‡ç‰‡åº•å±‚æ•°ç»„å¼•ç”¨äº†rawå¯¼è‡´rawä¸ä¼šè¢«é‡Šæ”¾ï¼Œå ç”¨å¾ˆå¤šä¸å¿…è¦å†…å­˜ç©ºé—´ // len = 3, cap = 10000 return raw[:3] // rawå˜é‡é€ƒé€¸åˆ°å †äº† } func main() { data := get() fmt.Println(len(data), cap(data), \u0026amp;data[0]) // 3 10000 0xc000090000 // \u0026amp;raw[0] == $data[0] è¡¨æ˜åˆ‡ç‰‡è¢«å¼•ç”¨äº† } ä¸ºäº†é¿å…è¿™ä¸ªé™·é˜±ï¼Œéœ€è¦åœ¨ä¸´æ—¶çš„åˆ‡ç‰‡ä¸­ä½¿ç”¨å†…ç½®å‡½æ•°copy()ï¼Œå¤åˆ¶æ•°æ®ï¼ˆè€Œä¸æ˜¯é‡æ–°å¼•ç”¨åˆ’åˆ†åˆ‡ç‰‡ï¼‰åˆ°æ–°åˆ‡ç‰‡ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 package main import ( \u0026#34;fmt\u0026#34; ) func get() []byte { raw := make([]byte, 10000) fmt.Println(len(raw), cap(raw), \u0026amp;raw[0]) // 10000 10000 0xc000080000 // len = 3, cap = 3 res := make([]byte, 3) // åˆ©ç”¨copyå‡½æ•°å¤åˆ¶, rawå¯è¢«GCé‡Šæ”¾ // resä»rawå¤åˆ¶éƒ¨åˆ†æ•°æ® copy(to, fm slice) int // ä½¿ç”¨copyèƒ½æœ‰æ•ˆé˜²æ­¢å˜é‡é€ƒé€¸ copy(res, raw[:3]) return res } func main() { data := get() fmt.Println(len(data), cap(data), \u0026amp;data[0]) // 3 3 0xc00000a0c8 } éœ€è¦å‘åˆ‡ç‰‡æœ«å°¾è¿½åŠ æ•°æ®æ—¶ï¼Œå¯ä»¥ä½¿ç”¨å†…ç½®å‡½æ•°append()ã€‚ 1 func append(s S,x ...T) S // Tæ˜¯Så…ƒç´ ç±»å‹ S = []T appendå‡½æ•°å°†0ä¸ªæˆ–å¤šä¸ªå…·æœ‰ç›¸åŒç±»å‹Sçš„å…ƒç´ è¿½åŠ åˆ°åˆ‡ç‰‡såé¢å¹¶ä¸”è¿”å›æ–°çš„åˆ‡ç‰‡ã€‚ è¿½åŠ çš„å…ƒç´ å¿…é¡»å’ŒåŸåˆ‡ç‰‡çš„å…ƒç´ åŒç±»å‹ï¼Œå¦‚æœsçš„å®¹é‡ä¸è¶³ä»¥å­˜å‚¨æ–°å¢å…ƒç´ ï¼Œappendä¼šåˆ†é…æ–°çš„åˆ‡ç‰‡æ¥ä¿è¯å·²æœ‰åˆ‡ç‰‡å…ƒç´ å’Œæ–°å¢å…ƒç´ çš„å­˜å‚¨ã€‚ å› æ­¤appendå‡½æ•°è¿”å›çš„åˆ‡ç‰‡å¯èƒ½å·²ç»æŒ‡å‘ä¸€ä¸ªä¸åŒçš„ç›¸å…³æ•°ç»„äº†ï¼Œå³ä½¿ä¿®æ”¹äº†æ•°æ®ä¹Ÿä¸ä¼šåŒæ­¥ã€‚ append()å‡½æ•°æ€»æ˜¯è¿”å›æˆåŠŸï¼Œé™¤éç³»ç»Ÿå†…å­˜è€—å°½äº†ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 package main import ( \u0026#34;fmt\u0026#34; ) func main() { // åˆ‡ç‰‡å®¹é‡ä¸è¶³ append() è¿”å›çš„æ˜¯æ–°çš„åˆ‡ç‰‡ æŒ‡å‘ä¸åŒçš„å…³è”æ•°ç»„ s0 := []int{0,0} fmt.Println(s0, \u0026amp;s0[0], len(s0), cap(s0))// [0 0] 0xc00000a0b0 2 2 // ç”±äºs0çš„å®¹é‡åªæœ‰2ï¼Œæ­¤æ—¶æ·»åŠ å…ƒç´ å¯¼è‡´æ‰©å®¹ï¼Œä»æ–°åˆ†é…å†…å­˜ï¼Œå¹¶æŠŠä¹‹å‰æ•°æ®å¤åˆ¶è¿‡æ¥ s1 := append(s0,2) fmt.Println(s1, \u0026amp;s1[0], len(s1), cap(s1))// [0 0 2] 0xc00000e340 3 4 s1[0] += 1 fmt.Println(s0, s1) // [0 0] [1 0 2] // æ­¤æ—¶æ·»åŠ å…ƒç´  åˆä¼šå¯¼è‡´æ‰©å®¹ ä»æ–°åˆ†é…å†…å­˜ å¹¶æŠŠä¹‹å‰æ•°æ®å¤åˆ¶è¿‡æ¥ s2 := append(s1, 3, 5, 7) fmt.Println(s2, \u0026amp;s2[0], len(s2), cap(s2))// [1 0 2 3 5 7] 0xc00000c300 6 8 // æ­¤æ—¶åˆšå¥½è¾¾åˆ°æœ€å¤§å®¹é‡ï¼Œä¸ä¼šæ‰©å®¹ å˜é‡s3å¼•ç”¨å˜é‡s2åº•å±‚æ•°ç»„ï¼Œä¿®æ”¹å…¶ä¸­å…ƒç´ ä¼šå¼•èµ·å…¶ä»–ä¿®æ”¹ s3 := append(s2, s0...) fmt.Println(s3, len(s3), cap(s3)) // [1 0 2 3 5 7 0 0] 8 8 s2[1] += 1 fmt.Println(s2, s3) // [1 1 2 3 5 7] [1 1 2 3 5 7 0 0] // s3[3:6] len=3 cap=5 // s3[2:] len=6 cap=6 // å¯¼è‡´s4ä»æ–°åˆ†é…å†…å­˜å­˜å‚¨æ•°æ® s4 := append(s3[3:6], s3[2:]...) fmt.Println(s4) // [3 5 7 2 3 5 7 0 0] } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 package main import ( \u0026#34;fmt\u0026#34; ) func main() { // å¦‚æœåˆ‡ç‰‡å®¹é‡è¶³å¤Ÿ append()åä¸ä¼šç”Ÿæˆæ–°çš„åˆ‡ç‰‡ s0 := make([]int, 10, 20) fmt.Println(s0, \u0026amp;s0[0], len(s0), cap(s0)) // [0 0 0 0 0 0 0 0 0 0] 0xc00007c000 10 20 s1 := append(s0,2) fmt.Println(s1, \u0026amp;s1[0], len(s1), cap(s1)) // [0 0 0 0 0 0 0 0 0 0 2] 0xc00007c000 11 20 s2 := append(s1, 3, 5, 7) fmt.Println(s2, \u0026amp;s2[0], len(s2), cap(s2)) // [0 0 0 0 0 0 0 0 0 0 2 3 5 7] 0xc00007c000 14 20 // æ­¤æ—¶æ‰©å®¹ï¼Œä»æ–°å¼€è¾Ÿå†…å­˜ï¼Œå¤åˆ¶åŸæ¥æ•°æ® s3 := append(s2, s0...) fmt.Println(s3, len(s3), cap(s3)) // [0 0 0 0 0 0 0 0 0 0 2 3 5 7 0 0 0 0 0 0 0 0 0 0] 24 40 // è¿™é‡Œs4å®¹é‡ä¸º37 æ˜¯ç”±äºs3[3:6] è¿™é‡Œ40-3=37å®¹é‡ // æ­¤æ—¶å®¹é‡è¶³å¤Ÿï¼Œå¹¶æ²¡æœ‰æ‰©å®¹ s4 := append(s3[3:6], s3[2:]...) fmt.Println(s4, len(s4), cap(s4)) // [0 0 0 0 0 0 0 0 0 0 0 2 3 5 7 0 0 0 0 0 0 0 0 0 0] 25 37 fmt.Println(s0) // [0 0 0 0 0 0 0 0 0 0] fmt.Println(s1) // [0 0 0 0 0 0 0 0 0 0 2] fmt.Println(s2) // [0 0 0 0 0 0 0 0 0 0 2 3 5 7] fmt.Println(s3) // [0 0 0 0 0 0 0 0 0 0 0 0 0 0 2 3 5 7 0 0 0 0 0 0] fmt.Println(s4) // [0 0 0 0 0 0 0 0 0 0 0 2 3 5 7 0 0 0 0 0 0 0 0 0 0] s0[1] += 1 fmt.Println(s0) // [0 1 0 0 0 0 0 0 0 0] fmt.Println(s1) // [0 1 0 0 0 0 0 0 0 0 2] fmt.Println(s2) // [0 1 0 0 0 0 0 0 0 0 2 3 5 7] fmt.Println(s3) // [0 0 0 0 0 0 0 0 0 0 0 0 0 0 2 3 5 7 0 0 0 0 0 0] fmt.Println(s4) // [0 0 0 0 0 0 0 0 0 0 0 2 3 5 7 0 0 0 0 0 0 0 0 0 0] s4[0] += 1 fmt.Println(s3) // [0 0 0 1 0 0 0 0 0 0 0 0 0 0 2 3 5 7 0 0 0 0 0 0] fmt.Println(s4) // [1 0 0 0 0 0 0 0 0 0 0 2 3 5 7 0 0 0 0 0 0 0 0 0 0] } é™ˆæ—§çš„åˆ‡ç‰‡ å¤šä¸ªåˆ‡ç‰‡å¯ä»¥å¼•ç”¨åŒä¸€ä¸ªåº•å±‚ç›¸å…³æ•°ç»„ã€‚ æŸäº›æƒ…å†µä¸‹åœ¨ä¸€ä¸ªåˆ‡ç‰‡ä¸­æ·»åŠ æ–°çš„æ•°æ®ï¼Œåœ¨åŸæœ‰æ•°ç»„æ— æ³•ä¿æŒæ›´å¤šæ–°çš„æ•°æ®æ—¶ï¼Œå°†å¯¼è‡´åˆ†é…ä¸€ä¸ªæ–°çš„æ•°ç»„ã€‚ è€Œå…¶ä»–çš„åˆ‡ç‰‡è¿˜æŒ‡å‘è€çš„æ•°ç»„ï¼ˆå’Œè€çš„æ•°æ®ï¼‰ã€‚ append()å‡½æ•°æ“ä½œåï¼Œæœ‰æ²¡æœ‰ç”Ÿæˆæ–°çš„åˆ‡ç‰‡éœ€è¦çœ‹åŸæœ‰çš„åˆ‡ç‰‡çš„å®¹é‡æ˜¯å¦è¶³å¤Ÿã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 package main import ( \u0026#34;fmt\u0026#34; ) func main() { s1 := []int{1,2,3} fmt.Println(len(s1), cap(s1), s1) // 3 3 [1 2 3] // len = 3-1 = 2 // cap = 3-1 = 2 s2 := s1[1:] fmt.Println(len(s2), cap(s2), s2) // 2 2 [2 3] for i := range s2{ s2[i] += 20 } // s2çš„ä¿®æ”¹ä¼šéŸ³å“åˆ°æ•°ç»„æ•°æ®ï¼Œs1è¾“å‡ºæ–°æ•°æ® fmt.Println(s1) // [1 22 23] fmt.Println(s2) // [22 23] // append s2å®¹é‡ä¸º2 å¯¼è‡´slice s2æ‰©å®¹ï¼Œä¼šç”Ÿæˆæ–°çš„åº•å±‚æ•°ç»„ s2 = append(s2, 4) for i := range s2{ s2[i] += 10 } // s1æ•°æ®ç°åœ¨æ˜¯æ¥æ•°æ® s2æ‰©å®¹äº†ï¼Œå¤åˆ¶åˆ°æ–°æ•°ç»„ï¼Œä»–ä»¬åº•å±‚æ•°ç»„å·²ç»ä¸æ˜¯åŒä¸€ä¸ªæ•°ç»„äº† fmt.Println(len(s1), cap(s1), s1) // 3 3 [1 22 23] fmt.Println(len(s2), cap(s2), s2) // 3 4 [32 33 14] } ","permalink":"https://heliu.site/posts/golang/slice/use/","summary":"Golang sliceçš„ä½¿ç”¨ä»‹ç»ã€‚","title":"Slice(ä½¿ç”¨)"},{"content":" æœ¬ç¯‡æ–‡ç« éƒ½æ˜¯sliceçš„æºç èµ°è¯»ã€‚ æ³¨æ„ï¼šslice ä¸æ˜¯å¹¶å‘å®‰å…¨çš„æ•°æ®ç»“æ„ï¼Œå¤§å®¶åœ¨ä½¿ç”¨æ—¶è¯·åŠ¡å¿…æ³¨æ„å¹¶å‘å®‰å…¨é—®é¢˜ã€‚ type slice struct åˆ‡ç‰‡çš„å†…å­˜å¸ƒå±€ã€‚ arrayï¼šæŒ‡å‘ä¸€ä¸ª[cap]Tå¤§å°çš„æ•°ç»„åœ°å€ã€‚å°±æ˜¯æŒ‡å‘ä¸€ä¸ªcapå®¹é‡å¤§å°çš„æ•°ç»„é¦–åœ°å€ã€‚ lenï¼šè®°å½•åˆ‡ç‰‡å·²å­˜å‚¨å…ƒç´ çš„é•¿åº¦ï¼Œä¹Ÿæ˜¯å¯è®¿é—®çš„æœ€å¤§ä¸‹æ ‡len - 1ã€‚ capï¼šè®°å½•åˆ‡ç‰‡çš„å®¹é‡ï¼Œä¹Ÿå°±æ˜¯å½“å‰åˆ‡ç‰‡å­˜å‚¨çš„æœ€å¤§å…ƒç´ æ•°é‡ï¼ˆæœªæ‰©å®¹å‰ï¼‰ã€‚ type slice struct { array unsafe.Pointer len int cap int } type notInHeapSlice struct notInHeapSliceæ˜¯go:notinheapå†…å­˜æ”¯æŒçš„sliceã€‚ ä¹Ÿå°±æ˜¯è¯¥ç±»å‹çš„å¯¹è±¡ä¸æ˜¯åœ¨å †ä¸­åˆ›å»ºçš„ï¼Œä¹Ÿå°±æ˜¯GCä¸ä¼šæ‰«æï¼Œå¤šç”¨äºå†…å­˜ç®¡ç†æ¨¡å—ä¸­ã€‚ 1 2 3 4 5 6 // A notInHeapSlice is a slice backed by go:notinheap memory. type notInHeapSlice struct { array *notInHeap // æŒ‡å‘ä¸€ä¸ªèµ·å§‹åœ°å€ len int cap int } type notInHeap struct notInHeapæ˜¯ç”±sysAllocæˆ–persistentAllocç­‰åº•å±‚åˆ†é…å™¨åˆ†é…çš„å †å¤–å†…å­˜ã€‚ ä¸€èˆ¬æ¥è¯´ï¼Œæœ€å¥½ä½¿ç”¨æ ‡è®°ä¸ºgo:notinheapçš„çœŸå®ç±»å‹ï¼Œä½†åœ¨æ— æ³•è¿™æ ·åšçš„æƒ…å†µä¸‹(æ¯”å¦‚åœ¨åˆ†é…å™¨ä¸­)ï¼Œå®ƒç”¨ä½œé€šç”¨ç±»å‹ã€‚ TODOï¼šä½¿ç”¨å®ƒä½œä¸ºsysAlloc,persistentAllocç­‰çš„è¿”å›ç±»å‹? 1 2 3 4 5 6 7 8 9 10 11 // notInHeap is off-heap memory allocated by a lower-level allocator // like sysAlloc or persistentAlloc. // // In general, it\u0026#39;s better to use real types marked as go:notinheap, // but this serves as a generic type for situations where that isn\u0026#39;t // possible (like in the allocators). // // TODO: Use this as the return type of sysAlloc, persistentAlloc, etc? // //go:notinheap type notInHeap struct{} add() 1 2 3 4 func (p *notInHeap) add(bytes uintptr) *notInHeap { // p + bytes return (*notInHeap)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + bytes)) } make() makeå†…ç½®å‡½æ•°åˆ†é…å¹¶åˆå§‹åŒ–ä¸€ä¸ªç±»å‹ä¸ºsliceã€mapæˆ–chançš„å¯¹è±¡(only)ã€‚ å’Œnewä¸€æ ·ï¼Œç¬¬ä¸€ä¸ªå‚æ•°æ˜¯ç±»å‹ï¼Œè€Œä¸æ˜¯å€¼ã€‚ä¸newä¸åŒï¼Œmakeçš„è¿”å›å€¼ç±»å‹ä¸å…¶å‚æ•°çš„ç±»å‹ç›¸åŒï¼Œè€Œä¸æ˜¯æŒ‡å‘å‚æ•°çš„æŒ‡é’ˆã€‚ å…·ä½“çš„ç»“æœå–å†³äºç±»å‹ï¼š Sliceï¼š sizeæŒ‡å®šäº†é•¿åº¦ã€‚åˆ‡ç‰‡çš„å®¹é‡ç­‰äºå®ƒçš„é•¿åº¦ã€‚ ä»¥æä¾›ç¬¬äºŒä¸ªæ•´æ•°å‚æ•°æ¥æŒ‡å®šä¸åŒçš„å®¹é‡;å®ƒå¿…é¡»ä¸å°äºé•¿åº¦ã€‚ ä¾‹å¦‚ï¼Œmake([]int, 0, 10)ä¼šåˆ†é…ä¸€ä¸ªé•¿åº¦ä¸º10çš„åº•å±‚æ•°ç»„ï¼Œå¹¶è¿”å›ä¸€ä¸ªé•¿åº¦ä¸º0ã€å®¹é‡ä¸º10çš„åˆ‡ç‰‡ã€‚ Mapï¼šä¸€ä¸ªç©ºçš„mapåˆ†é…äº†è¶³å¤Ÿçš„ç©ºé—´æ¥ä¿å­˜æŒ‡å®šæ•°é‡çš„å…ƒç´ ã€‚åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œå¯ä»¥çœç•¥é•¿åº¦ï¼Œåˆ†é…ä¸€ä¸ªè¾ƒå°çš„èµ·å§‹é•¿åº¦ã€‚ Channelï¼šchannelç¼“å†²åŒºä½¿ç”¨æŒ‡å®šçš„ç¼“å†²åŒºå®¹é‡åˆå§‹åŒ–ã€‚å¦‚æœä¸º0ï¼Œæˆ–è€…sizeè¢«çœç•¥ï¼Œåˆ™channelæ˜¯æ— ç¼“å†²çš„ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 // The make built-in function allocates and initializes an object of type // slice, map, or chan (only). Like new, the first argument is a type, not a // value. Unlike new, make\u0026#39;s return type is the same as the type of its // argument, not a pointer to it. The specification of the result depends on // the type: //\tSlice: The size specifies the length. The capacity of the slice is //\tequal to its length. A second integer argument may be provided to //\tspecify a different capacity; it must be no smaller than the //\tlength. For example, make([]int, 0, 10) allocates an underlying array //\tof size 10 and returns a slice of length 0 and capacity 10 that is //\tbacked by this underlying array. //\tMap: An empty map is allocated with enough space to hold the //\tspecified number of elements. The size may be omitted, in which case //\ta small starting size is allocated. //\tChannel: The channel\u0026#39;s buffer is initialized with the specified //\tbuffer capacity. If zero, or the size is omitted, the channel is //\tunbuffered. func make(t Type, size ...IntegerType) Type makeslice() make([]T *_type, len, cap int) *_typeï¼šè®°å½•ç€åˆ‡ç‰‡å…ƒç´ ç±»å‹ï¼Œæ¯”å¦‚[]stringåˆ‡ç‰‡è¿™é‡Œæ˜¯stringçš„å…ƒç±»å‹ã€‚ lenï¼šåˆ‡ç‰‡çš„é•¿åº¦ï¼Œè¯¥å‚æ•°æ˜¯å¿…ä¼ ã€‚ capï¼šåˆ‡ç‰‡çš„å®¹é‡ï¼Œè¯¥å‚æ•°æ˜¯å¯ä¼ ï¼Œé»˜è®¤ä¼šä¼ lenå¤§å°ã€‚ makeslice()å‡½æ•°æ˜¯åˆ‡ç‰‡ç”³è¯·å†…å­˜çš„make()å‡½æ•°åŸå‹ï¼Œä¸»è¦è´Ÿè´£ç”³è¯·slice.arrayå­—æ®µæŒ‡å‘çš„å†…å­˜å¤§å°ã€‚ é‚£ä¹ˆåˆ‡ç‰‡çš„24å­—èŠ‚å¤§å°å†…å­˜æ˜¯åœ¨ä»€ä¹ˆæ—¶å€™åˆ†é…çš„ï¼Ÿï¼ˆ64ä½ç³»ç»Ÿä¸‹ä¸º24å­—èŠ‚å†…å­˜ï¼Œ32ç³»ç»Ÿä¸‹ä¸º12å­—èŠ‚å†…å­˜ï¼‰ å¯èƒ½åœ¨å‡½æ•°æ ˆä¸Šç›´æ¥åˆ†é…24å­—èŠ‚å¤§å°å†…å­˜ã€‚ ä¹Ÿå¯èƒ½åœ¨å †ä¸Šåˆ†é…24å­—èŠ‚å¤§å°å†…å­˜ã€‚ è°ƒç”¨äº†makeslice()å‡½æ•°ï¼Œå…¶slice.arrayæŒ‡å‘çš„å†…å­˜å—ä¸€å®šæ˜¯åœ¨å †ä¸Šã€‚æ²¡æœ‰è°ƒè¯¥å‡½æ•°æ—¶å¯èƒ½å†…å­˜åˆ†é…åœ¨æ ˆä¸Šã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 func makeslice(et *_type, len, cap int) unsafe.Pointer { // 1ï¼‰åˆ¤æ–­et.size * uintptr(cap)æ˜¯å¦é€ æˆå†…å­˜æº¢å‡º mem, overflow := math.MulUintptr(et.size, uintptr(cap)) // æŒ‰ç…§capè®¡ç®—çš„ // 1. ã€overflow == trueã€‘ï¼šæº¢å‡º // 2. ã€mem \u0026gt; maxAllocã€‘ï¼šè¶…è¿‡æ“ä½œç³»ç»Ÿæœ€å¤§å†…å­˜ // 3. ã€len \u0026lt; 0ã€‘ï¼šé”™è¯¯çš„lenå‚æ•° // 4. ã€len \u0026gt; capã€‘ï¼šé•¿åº¦å¤§äºå®¹é‡ if overflow || mem \u0026gt; maxAlloc || len \u0026lt; 0 || len \u0026gt; cap { // NOTE: Produce a \u0026#39;len out of range\u0026#39; error instead of a // \u0026#39;cap out of range\u0026#39; error when someone does make([]T, bignumber). // \u0026#39;cap out of range\u0026#39; is true too, but since the cap is only being // supplied implicitly, saying len is clearer. // See golang.org/issue/4085. // // å½“æœ‰äºº make([]T, bignumber) æ—¶ï¼Œäº§ç”Ÿä¸€ä¸ª \u0026#39;len out of range\u0026#39; é”™è¯¯è€Œä¸æ˜¯ \u0026#39;cap out of range\u0026#39; é”™è¯¯æç¤º // å½“ \u0026#39;cap out of range\u0026#39; ä¹Ÿæ˜¯å¤ªé•¿äº†ï¼Œç”±äºcapåªæ˜¯éšå¼åœ°æä¾›ï¼Œæ‰€ä»¥è¯´lenæ›´æ¸…æ¥šçš„æç¤ºã€‚ mem, overflow := math.MulUintptr(et.size, uintptr(len))\t// æ ¹æ®lenè®¡ç®— if overflow || mem \u0026gt; maxAlloc || len \u0026lt; 0 { panicmakeslicelen() // painc \u0026#39;len out of range\u0026#39; } panicmakeslicecap() // panic \u0026#39;cap out of range\u0026#39; } // 2ï¼‰å‘æ“ä½œç³»ç»Ÿç”³è¯·memå¤§å°çš„å†…å­˜å—ï¼Œè¿”å›ç”³è¯·åˆ°å†…å­˜å—çš„é¦–åœ°å€ return mallocgc(mem, et, true) } makeslice64() int64ç‰ˆæœ¬ï¼Œå¦‚æœå½“å‰æ˜¯åœ¨32ä½ç³»ç»Ÿä¸­æ—¶ï¼Œintå…¶å®æ˜¯int32å¤§å°ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 func makeslice64(et *_type, len64, cap64 int64) unsafe.Pointer { len := int(len64) // 32ä½ç³»ç»Ÿä¸‹è½¬æ¢ä¼šä¸¢å¤±éƒ¨åˆ†æ•°æ® if int64(len) != len64 { panicmakeslicelen() // painc \u0026#39;len out of range\u0026#39; } cap := int(cap64) if int64(cap) != cap64 { panicmakeslicecap() // panic \u0026#39;cap out of range\u0026#39; } return makeslice(et, len, cap) } len() ä»¥ä¸‹ä¼ªä»£ç è·å–åˆ‡ç‰‡çš„é•¿åº¦ã€‚ lenå‡½æ•°çš„åŸå‹ï¼šfunc len(array []T) intã€‚ 1 2 3 4 // ä¼ªä»£ç ç¤ºä¾‹ func len(array []T) int { return array.len } cap() ä»¥ä¸‹ä¼ªä»£ç è·å–åˆ‡ç‰‡çš„å®¹é‡ã€‚ capå‡½æ•°çš„åŸå‹ï¼šfunc cap(array []T) intã€‚ 1 2 3 4 // ä¼ªä»£ç ç¤ºä¾‹ func cap(array []T) int { return array.cap } copy() copyå†…ç½®å‡½æ•°å°†å…ƒç´ ä»æºç‰‡å¤åˆ¶åˆ°ç›®æ ‡ç‰‡ã€‚(ä½œä¸ºç‰¹æ®Šæƒ…å†µï¼Œå®ƒä¹Ÿä¼šå°†bytesä»stringå¤åˆ¶åˆ°byteåˆ‡ç‰‡ã€‚) æºå’Œç›®æ ‡å¯èƒ½é‡å ã€‚ copyè¿”å›å¤åˆ¶çš„å…ƒç´ æ•°é‡ï¼Œè¿™å°†æ˜¯len(src)å’Œlen(dst)çš„æœ€å°å€¼ã€‚src-\u0026gt;dstã€‚ 1 2 3 4 5 6 // The copy built-in function copies elements from a source slice into a // destination slice. (As a special case, it also will copy bytes from a // string to a slice of bytes.) The source and destination may overlap. Copy // returns the number of elements copied, which will be the minimum of // len(src) and len(dst). func copy(dst, src []Type) int slicecopy() slicecopyç”¨äºå°†pointerlesså…ƒç´ çš„å­—ç¬¦ä¸²æˆ–åˆ‡ç‰‡å¤åˆ¶åˆ°åˆ‡ç‰‡ä¸­ã€‚ æ³¨æ„ï¼šcopy()çš„å‡½æ•°åŸå‹ä¸­æ²¡æœ‰å¯å˜å‚æ•°ï¼ˆ... Tï¼‰çš„å½¢å¼å‚æ•°ã€‚ slicecopy é€‚ç”¨ä»¥ä¸‹ä¸¤ç§æƒ…å†µï¼šfm -\u0026gt; to ã€copy(to, fm []T) intã€‘ ã€copy(to []byte, fm string) intã€‘ æ³¨æ„ä»¥ä¸‹slicecopyå‡½æ•°å¯èƒ½åœ¨go1.18+ç‰ˆæœ¬ä¸­ä¸æ˜¯è¿™æ ·çš„ï¼Œè¿™ä¸€ç‰ˆé‡‡ç”¨çš„æ˜¯go1.22å·¦å³ç‰ˆæœ¬çš„æºç ï¼Œä½†æ˜¯åªæ˜¯å‘ç”Ÿäº†å˜åŒ–å…·ä½“é€»è¾‘æ²¡å˜ã€‚ å‚æ•°ï¼šfromPtr -\u0026gt; toPtr toPtr unsafe.Pointerï¼šç›®æ ‡åœ°å€ï¼Œä¹Ÿå°±æ˜¯ä¸Šé¢çš„to.arrayå€¼ã€‚ toLen intï¼šç›®æ ‡é•¿åº¦ï¼Œä¹Ÿå°±æ˜¯ä¸Šé¢çš„to.lenå€¼ã€‚ fromPtr unsafe.Pointerï¼šæ¥æºåœ°å€ï¼Œä¹Ÿå°±æ˜¯ä¸Šé¢çš„fm.arrayå€¼ã€‚ fromLen intï¼šæ¥æºé•¿åº¦ï¼Œä¹Ÿå°±æ˜¯ä¸Šé¢çš„fm.lenå€¼ã€‚ width uintptrï¼šåˆ‡ç‰‡ç±»å‹å ç”¨å†…å­˜å¤§å°ï¼Œä¹Ÿå°±æ˜¯[]Tçš„Tç±»å‹çš„å¤§å°ã€‚ è¿”å›å€¼ï¼š intï¼šæ‹·è´çš„å…ƒç´ æ•°é‡ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 // slicecopy is used to copy from a string or slice of pointerless elements into a slice. func slicecopy(toPtr unsafe.Pointer, toLen int, fromPtr unsafe.Pointer, fromLen int, width uintptr) int { // 1) æ‹·è´æˆ–è¢«æ‹·è´é•¿åº¦ä¸º0ç›´æ¥è¿”å› if fromLen == 0 || toLen == 0 { return 0 } // 2) æ‹·è´å…ƒç´ çš„ä¸ªæ•°å–å†³äºæ‹·è´æˆ–è¢«æ‹·è´çš„æœ€å°é•¿åº¦ n := fromLen if toLen \u0026lt; n { n = toLen } // 3) æ‹·è´çš„å…ƒç´ å¤§å°ä¸º0ï¼Œç›´æ¥è¿”å›n if width == 0 {\t// []struct{} return n } // 4) size éœ€è¦æ‹·è´çš„æ€»å†…å­˜å¤§å°/å­—èŠ‚ã€‚ size := uintptr(n) * width if raceenabled { callerpc := getcallerpc() pc := abi.FuncPCABIInternal(slicecopy) racereadrangepc(fromPtr, size, callerpc, pc) racewriterangepc(toPtr, size, callerpc, pc) } if msanenabled { msanread(fromPtr, size) msanwrite(toPtr, size) } if asanenabled { asanread(fromPtr, size) asanwrite(toPtr, size) } // ä¸€èˆ¬æƒ…å†µä¸‹ï¼Œè¿™é‡Œçš„å€¼å¤§çº¦æ˜¯2xï¼ˆåªæœ‰1å­—èŠ‚éœ€è¦æ‹·è´ï¼‰ // to := make([]byte, 1); copy(to, \u0026#34;hello\u0026#34;) // ã€[]byteã€‘ OR ã€[]uint8ã€‘ OR ã€[]int8ã€‘ OR ã€[]boolã€‘ if size == 1 { // common case worth about 2x to do here // TODO: is this still worth it with new memmove impl? // // TODO: ä½¿ç”¨æ–°çš„memmove implï¼Œè¿™ä»ç„¶å€¼å¾—å—? // å·²çŸ¥fromPtrå’ŒtoPtræ˜¯ byte æŒ‡é’ˆ *(*byte)(toPtr) = *(*byte)(fromPtr) // known to be a byte pointer } else { memmove(toPtr, fromPtr, size) // æ‹·è´æ•°æ® } return n } memmove() memmoveä»fromå¤åˆ¶nä¸ªå­—èŠ‚åˆ°toã€‚ memmoveç¡®ä¿ä»»ä½•ä½äºfromä¸­çš„æŒ‡é’ˆéƒ½ä»¥ä¸å¯åˆ†å‰²çš„å†™å…¥æ–¹å¼å†™å…¥åˆ°toä¸­ï¼Œå› æ­¤ï¼ŒåŠ¨æ€è¯»å–æ— æ³•è§‚å¯Ÿåˆ°ä¸€ä¸ªåªå†™äº†ä¸€åŠçš„æŒ‡é’ˆã€‚ è¿™æ˜¯å¿…è¦çš„ï¼Œä»¥é˜²æ­¢åƒåœ¾æ”¶é›†å™¨å‘ç°æ— æ•ˆæŒ‡é’ˆï¼Œè¿™ä¸éæ‰˜ç®¡è¯­è¨€ä¸­çš„memmoveä¸åŒã€‚ ä¸è¿‡ï¼Œåªæœ‰å½“fromå’Œtoå¯èƒ½åŒ…å«æŒ‡é’ˆæ—¶ï¼Œmemmove()æ‰éœ€è¦è¿™ä¹ˆåšï¼Œåªæœ‰å½“fromã€toå’Œnéƒ½æ˜¯ word-alignedæ—¶æ‰ä¼šè¿™æ ·åšã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 // memmove copies n bytes from \u0026#34;from\u0026#34; to \u0026#34;to\u0026#34;. // // memmove ensures that any pointer in \u0026#34;from\u0026#34; is written to \u0026#34;to\u0026#34; with // an indivisible write, so that racy reads cannot observe a // half-written pointer. This is necessary to prevent the garbage // collector from observing invalid pointers, and differs from memmove // in unmanaged languages. However, memmove is only required to do // this if \u0026#34;from\u0026#34; and \u0026#34;to\u0026#34; may contain pointers, which can only be the // case if \u0026#34;from\u0026#34;, \u0026#34;to\u0026#34;, and \u0026#34;n\u0026#34; are all be word-aligned. // // Implementations are in memmove_*.s. // //go:noescape func memmove(to, from unsafe.Pointer, n uintptr) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 TEXT runtimeÂ·memmove\u0026lt;ABIInternal\u0026gt;(SB), NOSPLIT, $0-24 // AX = to // BX = from // CX = n MOVQ AX, DI MOVQ BX, SI MOVQ CX, BX tail: // TESTæŒ‡ä»¤ç”¨äºå¯¹BXå¯„å­˜å™¨çš„å†…å®¹å’Œè‡ªèº«è¿›è¡ŒæŒ‰ä½ä¸æ“ä½œï¼Œä½†æ˜¯ä¸æ”¹å˜å¯„å­˜å™¨çš„å†…å®¹ã€‚ TESTQ BX, BX # æ£€æŸ¥BXæ˜¯å¦ä¸º0 // æ£€æŸ¥ä¸Šä¸€æ¡æŒ‡ä»¤ï¼ˆTESTï¼‰æ‰§è¡Œåæ˜¯å¦è®¾ç½®äº†é›¶æ ‡å¿—ï¼ˆZFï¼‰ JEQ move_0 # Jump if Equal // è¿™æ˜¯ä¸€ä¸ªæ¯”è¾ƒæŒ‡ä»¤ï¼Œç”¨äºæ¯”è¾ƒBXå¯„å­˜å™¨ä¸­çš„å€¼å’Œç«‹å³æ•°2ã€‚ // å…·ä½“æ¥è¯´ï¼Œå®ƒä¼šå°†BXå¯„å­˜å™¨çš„å€¼å’Œ2ç›¸å‡ï¼Œä½†ä¸æ”¹å˜ä»»ä½•å¯„å­˜å™¨çš„å€¼ï¼Œåªæ˜¯æ ¹æ®ç»“æœè®¾ç½®çŠ¶æ€æ ‡å¿—ã€‚ CMPQ BX, $2 // BX \u0026lt;= 2 æˆç«‹ JBE move_1or2 # Jump if Below or Equal CMPQ BX, $4 # \u0026lt;= 4 JB move_3 JBE move_4 CMPQ BX, $8 # \u0026lt;= 8 JB move_5through7 JE move_8 CMPQ BX, $16 JBE move_9through16 CMPQ BX, $32 JBE move_17through32 CMPQ BX, $64 JBE move_33through64 CMPQ BX, $128 JBE move_65through128 CMPQ BX, $256 JBE move_129through256 TESTB $1, runtimeÂ·useAVXmemmove(SB) JNZ avxUnaligned //... ... append() å†…ç½®å‡½æ•°append()å°†å…ƒç´ æ·»åŠ åˆ°åˆ‡ç‰‡çš„æœ«å°¾ã€‚ å¦‚æœå®ƒæœ‰è¶³å¤Ÿçš„å®¹é‡ï¼Œç›®çš„åœ°å°†è¢«é‡æ–°åˆ’åˆ†ä»¥å®¹çº³æ–°çš„å…ƒç´ ã€‚å¦‚æœæ²¡æœ‰ï¼Œå°†åˆ†é…ä¸€ä¸ªæ–°çš„åº•å±‚æ•°ç»„ã€‚ æ³¨æ„ï¼šappend()å‡½æ•°å­˜åœ¨å¯å˜å‚æ•°ï¼ˆ... Tï¼‰çš„å½¢å¼çš„å‚æ•°ã€‚ append()è¿”å›æ›´æ–°åçš„sliceã€‚å› æ­¤ï¼Œæœ‰å¿…è¦å°†append()çš„ç»“æœå­˜å‚¨åœ¨ä¿å­˜åˆ‡ç‰‡æœ¬èº«çš„å˜é‡ä¸­ï¼š ã€slice = append(slice, elem1, elem2)ã€‘ ã€slice = append(slice, anotherSlice...)ã€‘ ä½œä¸ºä¸€ç§ç‰¹æ®Šæƒ…å†µï¼Œå¯ä»¥å°†å­—ç¬¦ä¸²æ·»åŠ åˆ°å­—èŠ‚åˆ‡ç‰‡ä¸­ï¼Œå¦‚ä¸‹æ‰€ç¤ºï¼š ã€slice = append([]byte(\u0026quot;hello \u0026quot;), \u0026quot;world\u0026quot;...)ã€‘ 1 2 3 4 5 6 7 8 9 10 11 12 13 // The append built-in function appends elements to the end of a slice. If // it has sufficient capacity, the destination is resliced to accommodate the // new elements. If it does not, a new underlying array will be allocated. // Append returns the updated slice. It is therefore necessary to store the // result of append, often in the variable holding the slice itself: // //\tslice = append(slice, elem1, elem2) //\tslice = append(slice, anotherSlice...) // // As a special case, it is legal to append a string to a byte slice, like this: // //\tslice = append([]byte(\u0026#34;hello \u0026#34;), \u0026#34;world\u0026#34;...) func append(slice []Type, elems ...Type) []Type append æ‰§è¡Œæ­¥éª¤ï¼š å¦‚æœå½“å‰append()å‡½æ•°æ‰§è¡Œå®Œååˆ‡ç‰‡ä¸ä¼š\u0026ldquo;ç¿»å€æ‰©å®¹\u0026quot;é‚£ä¹ˆï¼Œç›´æ¥æ˜¯æŠŠappend()åè¿½åŠ çš„æ•°æ®æ‹·è´åˆ°åˆ‡ç‰‡çš„åç»­ç©ºé—´å³å¯ã€‚ å¦‚æœå½“å‰append()å‡½æ•°æ‰§è¡Œå®Œåéœ€è¦\u0026ldquo;ç¿»å€æ‰©å®¹\u0026rdquo;ï¼Œé‚£ä¹ˆå…ˆè°ƒç”¨runtime.growslice()æ‰©å®¹å‡½æ•°ï¼Œç„¶ååœ¨æ‹·è´æ•°æ®è¿½åŠ åˆ°æ–°çš„å†…å­˜ç©ºé—´ã€‚ growslice() growslice()åœ¨append()å‡½æ•°æœŸé—´å¤„ç†åˆ‡ç‰‡å¢é•¿ã€‚ å®ƒå°†sliceå…ƒç´ ç±»å‹ã€æ—§çš„sliceå’Œæ‰€éœ€çš„æ–°æœ€å°å®¹é‡ä¼ é€’ç»™å®ƒï¼Œç„¶åè¿”å›ä¸€ä¸ªè‡³å°‘å…·æœ‰è¯¥å®¹é‡çš„æ–°sliceï¼Œå¹¶å°†æ—§æ•°æ®å¤åˆ¶åˆ°å…¶ä¸­ã€‚ æ–°sliceçš„é•¿åº¦è¢«è®¾ç½®ä¸ºæ—§sliceçš„é•¿åº¦ï¼Œè€Œä¸æ˜¯æ–°è¯·æ±‚çš„å®¹é‡ã€‚ è¿™æ˜¯ä¸ºäº†æ–¹ä¾¿codegenã€‚æ—§ç‰‡çš„é•¿åº¦ç«‹å³ç”¨äºè®¡ç®—åœ¨è¿½åŠ æœŸé—´åœ¨ä½•å¤„å†™å…¥æ–°å€¼ã€‚ TODOï¼šå½“æ—§çš„åç«¯æ¶ˆå¤±æ—¶ï¼Œé‡æ–°è€ƒè™‘è¿™ä¸ªå†³å®šã€‚ SSAåç«¯å¯èƒ½æ›´å–œæ¬¢æ–°çš„é•¿åº¦ï¼Œæˆ–è€…åªè¿”å›ptr/capä»¥èŠ‚çœæ ˆç©ºé—´ã€‚ å‚æ•°ï¼š et *_typeï¼šåˆ‡ç‰‡å…ƒç´ çš„å…ƒç±»å‹ã€‚ old sliceï¼šæœªç¿»å€æ‰©å®¹å‰åˆ‡ç‰‡ã€‚ cap intï¼šappend()å‡½æ•°åéœ€è¦çš„é•¿åº¦ old.len + n = capã€‚ä¹Ÿå°±æ˜¯append(s S, x ...T) Så‡½æ•°ä¸­len(S) + len(x) = capåçš„é•¿åº¦ã€‚ è¿”å›å€¼ï¼šslice slice.dataï¼šæ–°ç”³è¯·çš„åœ°å€ã€‚ slice.lenï¼šold.lençš„å€¼ã€‚æ³¨æ„è¿™é‡Œæ˜¯æ—§åˆ‡ç‰‡çš„é•¿åº¦ã€‚ slice.capï¼šæ‰©å®¹åçš„å®¹é‡ã€‚ è¯¥å‡½æ•°åœ¨append()å‡½æ•°è°ƒç”¨æ—¶æ ¹æ®æ¡ä»¶è§¦å‘ã€‚å¦‚old = append(old, 1, 2, 1), len(old) + 3 \u0026gt; cap(old)æ—¶å°±éœ€è¦æ‰©å®¹äº†ã€‚ æ³¨æ„ï¼Œå…³äºsliceçš„æ‰©å®¹è§„åˆ™åœ¨go1.18å‰æ˜¯æ ¹æ®lençš„ä¸€å¥—è§„åˆ™ï¼Œè€Œåœ¨ä»¥åç‰ˆæœ¬åˆæ˜¯æ ¹æ®capçš„ä¸€å¥—è§„åˆ™ï¼Œæœ¬ç¯‡é‡‡ç”¨çš„æ˜¯go1.22å·¦å³ç‰ˆæœ¬çš„ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 // growslice handles slice growth during append. // It is passed the slice element type, the old slice, and the desired new minimum capacity, // and it returns a new slice with at least that capacity, with the old data // copied into it. // The new slice\u0026#39;s length is set to the old slice\u0026#39;s length, // NOT to the new requested capacity. // This is for codegen convenience. The old slice\u0026#39;s length is used immediately // to calculate where to write new values during an append. // TODO: When the old backend is gone, reconsider this decision. // The SSA backend might prefer the new length or to return only ptr/cap and save stack space. func growslice(et *_type, old slice, cap int) slice { if raceenabled { callerpc := getcallerpc() racereadrangepc(old.array, uintptr(old.len*int(et.size)), callerpc, abi.FuncPCABIInternal(growslice)) } if msanenabled { msanread(old.array, uintptr(old.len*int(et.size))) } if asanenabled { asanread(old.array, uintptr(old.len*int(et.size))) } // 1) åˆ‡ç‰‡é•¿åº¦æº¢å‡ºåˆ¤æ–­ if cap \u0026lt; old.cap { panic(errorString(\u0026#34;growslice: cap out of range\u0026#34;)) } // 2) åˆ‡ç‰‡å…ƒç´ ç±»å‹ å ç”¨å†…å­˜ä¸ºé›¶ æƒ…å†µ // è¿™ç§æƒ…å†µå‡ºç°åœ¨ï¼š // var s []struct{} // s = append(s, struct{}{}, struct{}{}) if et.size == 0 { // append should not create a slice with nil pointer but non-zero len. // We assume that append doesn\u0026#39;t need to preserve old.array in this case. // // Appendä¸åº”è¯¥åˆ›å»ºä¸€ä¸ªæŒ‡é’ˆä¸ºnilçš„åˆ‡ç‰‡ï¼Œè€Œæ˜¯ä¸€ä¸ªlenä¸ºnon-zeroçš„åˆ‡ç‰‡ã€‚ // åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œæˆ‘ä»¬å‡è®¾appendä¸éœ€è¦ä¿å­˜old.arrayã€‚ // èµ‹å€¼slice.arrayæŒ‡å®šåœ°å€ï¼Œä¸ºäº†ç¡®ä¿sliceä¸æ˜¯nil // sliceä¸ºnilçš„åˆ¤æ–­æ¡ä»¶æ˜¯ï¼Œåªè¦slice.array==0x00,ä¸ç®¡lenå’Œcapçš„å€¼ä¸ºå¤šå°‘éƒ½ä¸ºnil return slice{unsafe.Pointer(\u0026amp;zerobase), old.len, cap} } // 3) è¯„ä¼°æ‰©å®¹åçš„å®¹é‡ // ---+-------+----------------------------------------------------------------------------------- // é¢„ | if | oldCap * 2 \u0026lt; cap ------\u0026gt; newCap = cap ä½¿ç”¨capå€¼ // ä¼° |-------+----------------------------------------------------------------------------------- // è§„ | else | oldCap \u0026lt; 256 ------\u0026gt; newCap = oldCap * 2 ç¿»å€æ‰©å®¹ // åˆ™ | | oldCap \u0026gt;= 256 ------\u0026gt; newCap = oldCap * 5/4 + 256 * 3/4 åœ¨åŸå®¹é‡ä¸Šæ‰©å®¹1/4åœ¨æ‰©å®¹192 // ---+-------+----------------------------------------------------------------------------------- newcap := old.cap doublecap := newcap + newcap if cap \u0026gt; doublecap { // 2å€æ—§å®¹é‡ \u0026lt; capæ—¶ï¼Œåˆ™æŒ‰ç…§capç®—ã€‚ newcap = cap } else { const threshold = 256 if old.cap \u0026lt; threshold { newcap = doublecap } else { // Check 0 \u0026lt; newcap to detect overflow // and prevent an infinite loop. // // æ£€æŸ¥ 0 \u0026lt; newcap ä»¥æ£€æµ‹æº¢å‡ºå¹¶é˜²æ­¢æ— é™å¾ªç¯ã€‚ for 0 \u0026lt; newcap \u0026amp;\u0026amp; newcap \u0026lt; cap { // Transition from growing 2x for small slices // to growing 1.25x for large slices. This formula // gives a smooth-ish transition between the two. newcap += (newcap + 3*threshold) / 4 } // Set newcap to the requested cap when // the newcap calculation overflowed. if newcap \u0026lt;= 0 { newcap = cap } } } // 4) å†…å­˜è§„æ ¼åŒ¹é… // å†…å­˜æ˜¯å¦æº¢å‡º true.æº¢å‡º false.æ²¡æœ‰æº¢å‡º var overflow bool\t// lenmem æ—§åˆ‡ç‰‡å…ƒç´ å ç”¨çš„å†…å­˜å¤§å° // è¯¥å€¼ç”¨äºè¿ç§»æ—§æ•°æ®çš„ä¾æ®/å­—èŠ‚ // newlenmem ç¿»å€ååˆ‡ç‰‡å…ƒç´ å ç”¨çš„å†…å­˜å¤§å° // è¯¥å€¼æ˜¯å½“å‰æ‰©å®¹åå®é™…å ç”¨çš„å¤§å°/å­—èŠ‚ // å› æ­¤capmem-newlenmemè¿™éƒ¨åˆ†å†…å­˜æ˜¯å¤šä½™çš„ï¼Œä¸ä¼šè¢«ç”¨åˆ°ã€‚ // capmem ç¿»å€åæ–°å®¹é‡å ç”¨çš„å†…å­˜å¤§å°ï¼Œ // ç”¨äºå‘æ“ä½œç³»ç»Ÿç”³è¯·çš„å†…å­˜å¤§å°/å­—èŠ‚ // è¿™éƒ¨åˆ†å†…å­˜å¯èƒ½å¤§äºnewlenmemçš„å€¼ï¼Œå› ä¸ºGoçš„å†…å­˜ç”³è¯·æ˜¯æœ‰è§„æ ¼çš„ã€‚ var lenmem, newlenmem, capmem uintptr // Specialize for common values of et.size. // For 1 we don\u0026#39;t need any division/multiplication. // For goarch.PtrSize, compiler will optimize division/multiplication into a shift by a constant. // For powers of 2, use a variable shift. // // ä¸“é—¨ç”¨äº et.size çš„å…±åŒå€¼ã€‚ // å¯¹äº1ï¼Œæˆ‘ä»¬ä¸éœ€è¦ä»»ä½•é™¤æ³•/ä¹˜æ³• // å¯¹äº goarch.PtrSizeï¼Œç¼–è¯‘å™¨å°†é™¤æ³•/ä¹˜æ³• ä¼˜åŒ–ä¸ºä¸€ä¸ªå¸¸é‡çš„ä½ç§» // å¯¹äº2çš„å¹‚æ¬¡æ–¹ï¼Œä½¿ç”¨å¯å˜ä½ç§» switch { // å€˜è‹¥æ•°ç»„å…ƒç´ çš„å¤§å°ä¸º 1ï¼Œåˆ™æ–°å®¹é‡å¤§å°ä¸º 1 * newcap. // åŒæ—¶ä¼šé’ˆå¯¹ span class è¿›è¡Œå–æ•´ case et.size == 1: // 1å­—èŠ‚ lenmem = uintptr(old.len) newlenmem = uintptr(cap) capmem = roundupsize(uintptr(newcap)) // åŒ¹é…æœ€è¿‘æ¥çš„å†…å­˜å—è§„æ ¼ overflow = uintptr(newcap) \u0026gt; maxAlloc // æ˜¯å¦å†…å­˜æº¢å‡º newcap = int(capmem) // ä»æ–°è°ƒæ•´ç¿»å€åæ–°å®¹é‡ // å€˜è‹¥æ•°ç»„å…ƒç´ ä¸ºæŒ‡é’ˆç±»å‹ï¼Œåˆ™æ ¹æ®æŒ‡é’ˆå ç”¨ç©ºé—´ç»“åˆå…ƒç´ ä¸ªæ•°è®¡ç®—ç©ºé—´å¤§å° // å¹¶ä¼šé’ˆå¯¹ span class è¿›è¡Œå–æ•´ case et.size == goarch.PtrSize: // 4æˆ–8å­—èŠ‚ lenmem = uintptr(old.len) * goarch.PtrSize newlenmem = uintptr(cap) * goarch.PtrSize capmem = roundupsize(uintptr(newcap) * goarch.PtrSize) overflow = uintptr(newcap) \u0026gt; maxAlloc/goarch.PtrSize newcap = int(capmem / goarch.PtrSize) // å€˜è‹¥å…ƒç´ å¤§å°ä¸º 2 çš„æŒ‡æ•°ï¼Œåˆ™ç›´æ¥é€šè¿‡ä½è¿ç®—è¿›è¡Œç©ºé—´å¤§å°çš„è®¡ç®— case isPowerOfTwo(et.size): // 2çš„å¹‚æ¬¡æ–¹ var shift uintptr if goarch.PtrSize == 8 { // Mask shift for better code generation. // // æ©ç ç§»ä½ä»¥æ›´å¥½åœ°ç”Ÿæˆä»£ç ã€‚ // sys.Ctz64å‡½æ•°è®¡æ•°å°¾éƒ¨(ä½é˜¶)é›¶ï¼Œå¦‚æœå…¨éƒ¨ä¸ºé›¶ï¼Œåˆ™ä¸º64ã€‚ // æ¯”å¦‚ et.size æ˜¯2^8ä¹Ÿå°±æ˜¯ 1_0000_0000ï¼Œä¹Ÿå°±æ˜¯8ä¸ªé›¶ shift = uintptr(sys.Ctz64(uint64(et.size))) \u0026amp; 63 // 64ä½ } else { shift = uintptr(sys.Ctz32(uint32(et.size))) \u0026amp; 31 // 32ä½ } lenmem = uintptr(old.len) \u0026lt;\u0026lt; shift newlenmem = uintptr(cap) \u0026lt;\u0026lt; shift capmem = roundupsize(uintptr(newcap) \u0026lt;\u0026lt; shift) overflow = uintptr(newcap) \u0026gt; (maxAlloc \u0026gt;\u0026gt; shift) newcap = int(capmem \u0026gt;\u0026gt; shift) // å…œåº•åˆ†æ”¯ï¼šæ ¹æ®å…ƒç´ å¤§å°ä¹˜ä»¥å…ƒç´ ä¸ªæ•° // å†é’ˆå¯¹ span class è¿›è¡Œå–æ•´ default: lenmem = uintptr(old.len) * et.size newlenmem = uintptr(cap) * et.size // math.MulUintptr è¿”å› capmem = et.size * uintptr(newcap); overflow æ˜¯å¦æº¢å‡º capmem, overflow = math.MulUintptr(et.size, uintptr(newcap)) capmem = roundupsize(capmem) newcap = int(capmem / et.size) } // ä»¥ä¸Šä»£ç å› ä¸ºä¼šå»åŒ¹é…å†…å­˜è§„æ ¼ï¼Œæ‰€ä»¥ä¼šä»æ–°è®¡ç®—newcapè¿™ä¸ªç¿»å€åçš„å€¼ // The check of overflow in addition to capmem \u0026gt; maxAlloc is needed // to prevent an overflow which can be used to trigger a segfault // on 32bit architectures with this example program: // // é™¤äº†capmem \u0026gt; maxAllocä¹‹å¤–ï¼Œè¿˜éœ€è¦æ£€æŸ¥æº¢å‡ºï¼Œä»¥é˜²æ­¢æº¢å‡ºï¼Œ // è¯¥æº¢å‡ºå¯ç”¨äºåœ¨32ä½ä½“ç³»ç»“æ„ä¸Šè§¦å‘æ®µæ•…éšœï¼Œç¤ºä¾‹ç¨‹åºå¦‚ä¸‹: // // type T [1\u0026lt;\u0026lt;27 + 1]int64 // // var d T // var s []T // // func main() { // s = append(s, d, d, d, d)\t// print(len(s), \u0026#34;\\n\u0026#34;) // } // 4*(1\u0026lt;\u0026lt;27 + 1)*8 if overflow || capmem \u0026gt; maxAlloc { panic(errorString(\u0026#34;growslice: cap out of range\u0026#34;)) } // ç”³è¯·åˆ°çš„å†…å­˜é¦–åœ°å€ var p unsafe.Pointer if et.ptrdata == 0 { // åˆ‡ç‰‡å…ƒç´ ç±»å‹ä¸åŒ…å«æŒ‡é’ˆ // capmem ç”³è¯·çš„å†…å­˜; nil ç±»å‹å…ƒç±»å‹ç”¨äºåˆ¤æ–­æ˜¯å¦ä¸ºæŒ‡é’ˆç±»å‹; false æ˜¯å¦é‡ç½®å†…å­˜ä¸ºé›¶å€¼; p = mallocgc(capmem, nil, false) // å‘æ“ä½œç³»ç»Ÿç”³è¯·å†…å­˜å— // The append() that calls growslice is going to overwrite from // old.len to cap (which will be the new length). // Only clear the part that will not be overwritten. // // è°ƒç”¨ growslice çš„ append() æ–¹æ³•ä¼šå°† old.len è¦†ç›–åˆ° cap(è¿™å°†æ˜¯æ–°çš„é•¿åº¦)ã€‚ // åªæ¸…é™¤ä¸ä¼šè¢«è¦†ç›–çš„éƒ¨åˆ†ã€‚ // æ¸…é›¶capmem-newlenmemè¿™å—å†…å­˜ï¼Œè¿™å¿«å†…å­˜æ˜¯å¤šä½™çš„ï¼Œä¸ä¼šè¢«ç”¨åˆ°ã€‚ memclrNoHeapPointers(add(p, newlenmem), capmem-newlenmem)\t} else { // åˆ‡ç‰‡å…ƒç´ ç±»å‹åŒ…å«æŒ‡é’ˆ // Note: can\u0026#39;t use rawmem (which avoids zeroing of memory), // because then GC can scan uninitialized memory. // // Note: ä¸èƒ½ä½¿ç”¨rawmem(å®ƒå¯ä»¥é¿å…å†…å­˜å½’é›¶)ï¼Œå› ä¸ºè¿™æ ·GCä¼šæ‰«ææœªåˆå§‹åŒ–çš„å†…å­˜ã€‚ p = mallocgc(capmem, et, true) // å‘æ“ä½œç³»ç»Ÿç”³è¯·å†…å­˜å— if lenmem \u0026gt; 0 \u0026amp;\u0026amp; writeBarrier.enabled { // å¼€å¯äº†å†™å±éšœ // Only shade the pointers in old.array since we know the destination slice p // only contains nil pointers because it has been cleared during alloc. // // åœ¨ old.array ä¸­åªå¯¹æŒ‡é’ˆè¿›è¡Œ shade å¤„ç†ï¼Œå› ä¸ºæˆ‘ä»¬çŸ¥é“ç›®æ ‡åˆ‡ç‰‡ p åªåŒ…å«nilæŒ‡é’ˆï¼Œ // å› ä¸ºå®ƒåœ¨allocæœŸé—´å·²è¢«æ¸…é™¤ã€‚ // lenmem-et.size+et.ptrdata åˆšå¥½æ˜¯old.arrayå­˜åœ¨çš„éƒ½æ˜¯æŒ‡é’ˆ // -et.sizeï¼šå‡å»æœ€åä¸€ä¸ªå…ƒç´ çš„å†…å­˜ // +et.ptrdataï¼šå†åŠ ä¸Šæœ€åä¸€ä¸ªå…ƒç´ çš„æŒ‡é’ˆ // åˆšå¥½å¤„ç†å®Œæœ€åä¸€ä¸ªå…ƒç´ åé¢ä¸æ˜¯æŒ‡é’ˆçš„éƒ¨åˆ†å†…å­˜ã€‚ // [dst, dst+size] bulkBarrierPreWriteSrcOnly(uintptr(p), uintptr(old.array), lenmem-et.size+et.ptrdata)\t} } // ä»old.arrayä¸­è¿ç§»lenmemå¤§å°å†…å­˜æ•°æ®åˆ°pä¸­ memmove(p, old.array, lenmem) // æ³¨æ„ï¼šè¿™é‡Œè¿”å›çš„æ˜¯ old.lenï¼Œå› ä¸ºæ­¤æ—¶è¿˜æ˜¯ä¹‹å‰çš„æ—§æ•°æ® return slice{p, old.len, newcap} } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 // bulkBarrierPreWriteSrcOnly is like bulkBarrierPreWrite but // does not execute write barriers for [dst, dst+size). // // In addition to the requirements of bulkBarrierPreWrite // callers need to ensure [dst, dst+size) is zeroed. // // This is used for special cases where e.g. dst was just // created and zeroed with malloc. // // The type of the space can be provided purely as an optimization, // however it is not used with GOEXPERIMENT=noallocheaders. // //go:nosplit func bulkBarrierPreWriteSrcOnly(dst, src, size uintptr, _ *abi.Type) { // GCå¹¶å‘æ ‡è®°é˜¶æ®µï¼Œè¿™é‡Œéœ€è¦å¤„ç†æ··åˆå†™å±éšœç›¸å…³äº‹é¡¹ï¼Œå› ä¸ºåœ¨æ‹·è´æŒ‡é’ˆæ•°æ® if (dst|src|size)\u0026amp;(goarch.PtrSize-1) != 0 { throw(\u0026#34;bulkBarrierPreWrite: unaligned arguments\u0026#34;) } if !writeBarrier.enabled { return // å¹¶å‘æ ‡è®°å·²ç»“æŸ } buf := \u0026amp;getg().m.p.ptr().wbBuf // å†™å±éšœç¼“å†²åŒº h := heapBitsForAddr(dst, size) for { var addr uintptr if h, addr = h.next(); addr == 0 { break } srcx := (*uintptr)(unsafe.Pointer(addr - dst + src)) p := buf.get1() p[0] = *srcx } } æ‰€æœ‰0å­—èŠ‚åˆ†é…çš„åŸºåœ°å€ã€‚ 1 2 // base address for all 0-byte allocations var zerobase uintptr roundupsize() mallocgcè¿”å›å°†åˆ†é…çš„å†…å­˜å—çš„å¤§å°ï¼Œå¦‚æœæ‚¨è¦æ±‚è¯¥å¤§å°ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // Returns size of the memory block that mallocgc will allocate if you ask for the size. func roundupsize(size uintptr) uintptr { // _MaxSmallSize = 32768 if size \u0026lt; _MaxSmallSize { // smallSizeMax = 1024 if size \u0026lt;= smallSizeMax-8 { // ä»¥æœ€ä¸‹8Bå€æ•°å¯¹é½ // smallSizeDiv = 8ï¼ŒdivRoundUp ç­‰ä»·äº ceil(size/8) // size_to_class8å’Œclass_to_size è®°å½•ç€ size çš„æ˜ å°„å…³ç³» return uintptr(class_to_size[size_to_class8[divRoundUp(size, smallSizeDiv)]]) } else { // ä»¥æœ€å°128Bå€æ•°å¯¹é½ // largeSizeDiv = 128 return uintptr(class_to_size[size_to_class128[divRoundUp(size-smallSizeMax, largeSizeDiv)]]) } } // _PageSize = 8192 if size+_PageSize \u0026lt; size { return size } return alignUp(size, _PageSize) // å¯¹é½8KB } alignUp() alignUpå°†nå–æ•´ä¸ºaçš„å€æ•°ã€‚aå¿…é¡»æ˜¯2çš„å¹‚ã€‚ 1 2 3 4 // alignUp rounds n up to a multiple of a. a must be a power of 2. func alignUp(n, a uintptr) uintptr { return (n + a - 1) \u0026amp;^ (a - 1) } MulUintptr() MulUintptrè¿”å›a * bä»¥åŠä¹˜æ³•è¿ç®—æ˜¯å¦æº¢å‡ºã€‚ åœ¨å—æ”¯æŒçš„å¹³å°ä¸Šï¼Œè¿™æ˜¯ç”±ç¼–è¯‘å™¨é™ä½çš„å›ºæœ‰ç‰¹æ€§ã€‚ 1 2 3 4 5 6 7 8 9 10 11 // MulUintptr returns a * b and whether the multiplication overflowed. // On supported platforms this is an intrinsic lowered by the compiler. func MulUintptr(a, b uintptr) (uintptr, bool) { // a|b \u0026lt; 1\u0026lt;\u0026lt;16 || a|b \u0026lt; 1\u0026lt;\u0026lt;32 if a|b \u0026lt; 1\u0026lt;\u0026lt;(4*goarch.PtrSize) || a == 0 { return a * b, false } // const MaxUintptr = ^uintptr(0) overflow := b \u0026gt; MaxUintptr/a return a * b, overflow } ","permalink":"https://heliu.site/posts/golang/slice/theory/","summary":"sliceçš„å†…å­˜ç»“æ„ã€makeã€copyã€appendå‡½æ•°åŠæ‰©å®¹ä»‹ç»ã€‚","title":"Slice(åŸç†)"},{"content":"ä»€ä¹ˆæ˜¯è¾¹ç•Œæ£€æŸ¥ è¾¹ç•Œæ£€æŸ¥ï¼Œè‹±æ–‡åBounds Check Eliminationï¼Œç®€ç§°ä¸º BCEã€‚ å®ƒæ˜¯Goè¯­è¨€ä¸­é˜²æ­¢æ•°ç»„ã€åˆ‡ç‰‡è¶Šç•Œè€Œå¯¼è‡´å†…å­˜ä¸å®‰å…¨çš„æ£€æŸ¥æ‰‹æ®µã€‚å¦‚æœæ£€æŸ¥ä¸‹æ ‡å·²ç»è¶Šç•Œäº†ï¼Œå°±ä¼šäº§ç”ŸPanicã€‚ è¾¹ç•Œæ£€æŸ¥ä½¿å¾—æˆ‘ä»¬çš„ä»£ç èƒ½å¤Ÿå®‰å…¨åœ°è¿è¡Œï¼Œä½†æ˜¯å¦ä¸€æ–¹é¢ï¼Œä¹Ÿä½¿å¾—æˆ‘ä»¬çš„ä»£ç è¿è¡Œæ•ˆç‡ç•¥å¾®é™ä½ã€‚ æ¯”å¦‚ä¸‹é¢è¿™æ®µä»£ç ï¼Œä¼šè¿›è¡Œä¸‰æ¬¡çš„è¾¹ç•Œæ£€æŸ¥ã€‚ 1 2 3 4 5 6 7 8 9 package main func f(s []int) { _ = s[0] // æ£€æŸ¥ç¬¬ä¸€æ¬¡ _ = s[1] // æ£€æŸ¥ç¬¬äºŒæ¬¡ _ = s[2] // æ£€æŸ¥ç¬¬ä¸‰æ¬¡ } func main() {} ä½ å¯èƒ½ä¼šå¥½å¥‡äº†ï¼Œä¸‰æ¬¡ï¼Ÿæˆ‘æ˜¯æ€ä¹ˆçŸ¥é“å®ƒè¦æ£€æŸ¥ä¸‰æ¬¡çš„ã€‚ å®é™…ä¸Šï¼Œä½ åªè¦åœ¨ç¼–è¯‘çš„æ—¶å€™ï¼ŒåŠ ä¸Šå‚æ•°-gcflags=\u0026quot;-d=ssa/check_bce/debug=1\u0026quot;å³å¯ï¼Œå‘½ä»¤å¦‚ä¸‹ï¼š 1 2 3 4 5 $ go build -gcflags=\u0026#34;-d=ssa/check_bce/debug=1\u0026#34; main.go # command-line-arguments ./main.go:4:7: Found IsInBounds ./main.go:5:7: Found IsInBounds ./main.go:6:7: Found IsInBounds è¾¹ç•Œæ£€æŸ¥çš„æ¡ä»¶ å¹¶ä¸æ˜¯æ‰€æœ‰çš„å¯¹æ•°ç»„ã€åˆ‡ç‰‡è¿›è¡Œç´¢å¼•æ“ä½œéƒ½éœ€è¦è¾¹ç•Œæ£€æŸ¥ã€‚ æ¯”å¦‚ä¸‹é¢è¿™ä¸ªç¤ºä¾‹ï¼Œå°±ä¸éœ€è¦è¿›è¡Œè¾¹ç•Œæ£€æŸ¥ï¼Œå› ä¸ºç¼–è¯‘å™¨æ ¹æ®ä¸Šä¸‹æ–‡å·²ç»å¾—çŸ¥ï¼Œsè¿™ä¸ªåˆ‡ç‰‡çš„é•¿åº¦æ˜¯å¤šå°‘ï¼Œä½ çš„ç»ˆæ­¢ç´¢å¼•æ˜¯å¤šå°‘ï¼Œç«‹é©¬å°±èƒ½åˆ¤æ–­åˆ°åº•æœ‰æ²¡æœ‰è¶Šç•Œï¼Œå› æ­¤æ˜¯ä¸éœ€è¦å†è¿›è¡Œè¾¹ç•Œæ£€æŸ¥ï¼Œå› ä¸ºåœ¨ç¼–è¯‘çš„æ—¶å€™å°±å·²ç»çŸ¥é“è¿™ä¸ªåœ°æ–¹ä¼šä¸ä¼š panicã€‚ 1 2 3 4 5 6 7 8 9 package main func f() { s := []int{1,2,3,4} // panic: runtime error: slice bounds out of range [:9] with capacity 4 _ = s[:9] // ä¸éœ€è¦è¾¹ç•Œæ£€æŸ¥ } func main() {} å› æ­¤å¯ä»¥å¾—å‡ºç»“è®ºï¼Œå¯¹äºåœ¨ç¼–è¯‘é˜¶æ®µæ— æ³•åˆ¤æ–­æ˜¯å¦ä¼šè¶Šç•Œçš„ç´¢å¼•æ“ä½œæ‰ä¼šéœ€è¦è¾¹ç•Œæ£€æŸ¥ï¼Œæ¯”å¦‚è¿™æ ·å­ï¼š 1 2 3 4 5 6 7 package main func f(s []int) { _ = s[:9] // éœ€è¦è¾¹ç•Œæ£€æŸ¥ } func main() {} è¾¹ç•Œæ£€æŸ¥çš„ç‰¹æ®Šæ¡ˆä¾‹ æ¡ˆä¾‹ä¸€ åœ¨å¦‚ä¸‹ç¤ºä¾‹ä»£ç ä¸­ï¼Œç”±äºç´¢å¼•2åœ¨æœ€å‰é¢å·²ç»æ£€æŸ¥è¿‡ä¼šä¸ä¼šè¶Šç•Œï¼Œå› æ­¤èªæ˜çš„ç¼–è¯‘å™¨å¯ä»¥æ¨æ–­å‡ºåé¢çš„ç´¢å¼•0å’Œ1ä¸ç”¨å†æ£€æŸ¥ã€‚ 1 2 3 4 5 6 7 8 9 package main func f(s []int) { _ = s[2] // æ£€æŸ¥ä¸€æ¬¡ _ = s[1] // ä¸ä¼šæ£€æŸ¥ _ = s[0] // ä¸ä¼šæ£€æŸ¥ } func main() {} æ¡ˆä¾‹äºŒ åœ¨ä¸‹é¢è¿™ä¸ªç¤ºä¾‹ä¸­ï¼Œå¯ä»¥åœ¨é€»è¾‘ä¸Šä¿è¯ä¸ä¼šè¶Šç•Œçš„ä»£ç ï¼ŒåŒæ ·æ˜¯ä¸ä¼šè¿›è¡Œè¶Šç•Œæ£€æŸ¥çš„ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 package main // [low:high:max] // len = high - low // cap = max - low // s =\u0026gt; len = 10, cap = 20 func f(s []int) { for index, _ := range s { // ä»¥ä¸‹æ“ä½œéƒ½æ˜¯åœ¨æœ‰æ•ˆçš„ç´¢å¼•èŒƒå›´ _ = s[index] _ = s[:index+1] // index [0,9] _ = s[index:len(s)] // len(s) = 10 } } func main() {} æ¡ˆä¾‹ä¸‰ åœ¨å¦‚ä¸‹ç¤ºä¾‹ä»£ç ä¸­ï¼Œè™½ç„¶æ•°ç»„çš„é•¿åº¦å’Œå®¹é‡å¯ä»¥ç¡®å®šï¼Œä½†æ˜¯ç´¢å¼•æ˜¯é€šè¿‡rand.Intn()å‡½æ•°å–å¾—çš„éšæœºæ•°ï¼Œåœ¨ç¼–è¯‘å™¨çœ‹æ¥è¿™ä¸ªç´¢å¼•å€¼æ˜¯ä¸ç¡®å®šçš„ï¼Œå®ƒæœ‰å¯èƒ½å¤§äºæ•°ç»„çš„é•¿åº¦ï¼Œä¹Ÿæœ‰å¯èƒ½å°äºæ•°ç»„çš„é•¿åº¦ã€‚ å› æ­¤ç¬¬ä¸€æ¬¡æ˜¯éœ€è¦è¿›è¡Œæ£€æŸ¥çš„ï¼Œæœ‰äº†ç¬¬ä¸€æ¬¡æ£€æŸ¥åï¼Œç¬¬äºŒæ¬¡ç´¢å¼•ä»é€»è¾‘ä¸Šå°±èƒ½æ¨æ–­ï¼Œæ‰€ä»¥ä¸ä¼šå†è¿›è¡Œè¾¹ç•Œæ£€æŸ¥ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 package main import ( \u0026#34;math/rand\u0026#34; ) func f() { s := make([]int, 3, 5) index := rand.Intn(3) // [0,1,2,3] _ = s[:index] // ç¬¬ä¸€æ¬¡æ£€æŸ¥ _ = s[index:] // ç¬¬äºŒæ¬¡æ£€æŸ¥ } func main() {} æˆ‘ä»¬åªæœ‰å½“æ•°ç»„çš„é•¿åº¦å’Œå®¹é‡ç›¸ç­‰æ—¶ï¼Œ:indexæˆç«‹ï¼Œæ‰èƒ½ä¸€å®šèƒ½æ¨å‡ºindex:ä¹Ÿæˆç«‹ï¼Œè¿™æ ·çš„è¯ï¼Œåªè¦åšä¸€æ¬¡æ£€æŸ¥å³å¯ã€‚ ä¸€æ—¦æ•°ç»„çš„é•¿åº¦å’Œå®¹é‡ä¸ç›¸ç­‰ï¼Œé‚£ä¹ˆindexåœ¨ç¼–è¯‘å™¨çœ‹æ¥æ˜¯æœ‰å¯èƒ½å¤§äºæ•°ç»„é•¿åº¦çš„ï¼Œç”šè‡³å¤§äºæ•°ç»„çš„å®¹é‡ã€‚ æˆ‘ä»¬å‡è®¾indexå–å¾—çš„éšæœºæ•°ä¸º4ï¼Œé‚£ä¹ˆå®ƒå¤§äºæ•°ç»„é•¿åº¦ï¼Œæ­¤æ—¶s[:index]è™½ç„¶å¯ä»¥æˆåŠŸï¼Œä½†æ˜¯s[index:]æ˜¯è¦å¤±è´¥çš„ï¼Œå› æ­¤ç¬¬äºŒæ¬¡è¾¹ç•Œçš„æ£€æŸ¥æ˜¯æœ‰å¿…è¦çš„ã€‚ ä½ å¯èƒ½ä¼šè¯´ï¼Œindexä¸æ˜¯æœ€å¤§å€¼ä¸º3å—ï¼Ÿæ€ä¹ˆå¯èƒ½æ˜¯4å‘¢ï¼Ÿè¦çŸ¥é“ç¼–è¯‘å™¨åœ¨ç¼–è¯‘çš„æ—¶å€™ï¼Œå¹¶ä¸çŸ¥é“indexçš„æœ€å¤§å€¼æ˜¯3å‘¢ã€‚ æ€»ç»“ï¼š å½“æ•°ç»„çš„é•¿åº¦å’Œå®¹é‡ç›¸ç­‰æ—¶ï¼Œs[:index]æˆç«‹èƒ½å¤Ÿä¿è¯s[index:]ä¹Ÿæˆç«‹ï¼Œå› ä¸ºåªè¦æ£€æŸ¥ä¸€æ¬¡å³å¯ã€‚ å½“æ•°ç»„çš„é•¿åº¦å’Œå®¹é‡ä¸ç­‰æ—¶ï¼Œs[:index]æˆç«‹ä¸èƒ½ä¿è¯s[index:]ä¹Ÿæˆç«‹ï¼Œå› ä¸ºè¦æ£€æŸ¥ä¸¤æ¬¡æ‰å¯ä»¥ã€‚ æ¡ˆä¾‹å›› ç”±äºæ•°ç»„æ˜¯è°ƒç”¨è€…ä¼ å…¥çš„å‚æ•°ï¼Œæ‰€ä»¥ç¼–è¯‘å™¨ç¼–è¯‘çš„æ—¶å€™æ— æ³•å¾—çŸ¥æ•°ç»„çš„é•¿åº¦å’Œå®¹é‡æ˜¯å¦ç›¸ç­‰ï¼Œå› æ­¤åªèƒ½ä¿é™©ä¸€ç‚¹ï¼Œä¸¤ä¸ªéƒ½æ£€æŸ¥ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 package main import ( \u0026#34;math/rand\u0026#34; ) func f(s []int, index int) { _ = s[:index] // ç¬¬ä¸€æ¬¡æ£€æŸ¥ _ = s[index:] // ç¬¬äºŒæ¬¡æ£€æŸ¥ } func main() {} ä½†æ˜¯å¦‚æœæŠŠä¸¤ä¸ªè¡¨è¾¾å¼çš„é¡ºåºåè¿‡æ¥ï¼Œå°±åªè¦åšä¸€æ¬¡æ£€æŸ¥å°±è¡Œäº†ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 package main import ( \u0026#34;math/rand\u0026#34; ) func f(s []int, index int) { _ = s[index:] // ç¬¬ä¸€æ¬¡æ£€æŸ¥ _ = s[:index] // ä¸ç”¨æ£€æŸ¥ } func main() {} ä¸»åŠ¨æ¶ˆé™¤è¾¹ç•Œæ£€æŸ¥ è™½ç„¶ç¼–è¯‘å™¨å·²ç»éå¸¸åŠªåŠ›å»æ¶ˆé™¤ä¸€äº›åº”è¯¥æ¶ˆé™¤çš„è¾¹ç•Œæ£€æŸ¥ï¼Œä½†éš¾å…ä¼šæœ‰ä¸€äº›é—æ¼ã€‚ è¿™å°±éœ€è¦â€è­¦æ°‘åˆä½œâ€ï¼Œå¯¹äºé‚£äº›ç¼–è¯‘å™¨è¿˜æœªè€ƒè™‘åˆ°çš„åœºæ™¯ï¼Œä½†å¼€å‘è€…åˆæåŠ›è¿½æ±‚ç¨‹åºçš„è¿è¡Œæ•ˆç‡çš„ï¼Œå¯ä»¥ä½¿ç”¨ä¸€äº›å°æŠ€å·§ç»™å‡ºä¸€äº›æš—ç¤ºï¼Œå‘Šè¯‰ç¼–è¯‘å™¨å“ªäº›åœ°æ–¹å¯ä»¥ä¸ç”¨åšè¾¹ç•Œæ£€æŸ¥ã€‚ æ¯”å¦‚ä¸‹é¢è¿™ä¸ªç¤ºä¾‹ï¼Œä»ä»£ç çš„é€»è¾‘ä¸Šæ¥è¯´ï¼Œæ˜¯å®Œå…¨æ²¡æœ‰å¿…è¦åšè¾¹ç•Œæ£€æŸ¥çš„ï¼Œä½†æ˜¯ç¼–è¯‘å™¨å¹¶æ²¡æœ‰é‚£ä¹ˆæ™ºèƒ½ï¼Œå®é™…ä¸Šæ¯ä¸ªforå¾ªç¯ï¼Œå®ƒéƒ½è¦åšä¸€æ¬¡è¾¹ç•Œçš„æ£€æŸ¥ï¼Œéå¸¸çš„æµªè´¹æ€§èƒ½ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 package main func f0(is []int, bs []byte) { if len(is) \u0026gt;= 256 { //is=is[:256] for _, n := range bs { // æ¯ä¸ªå¾ªç¯éƒ½è¦è¾¹ç•Œæ£€æŸ¥ï¼Œ // å› ä¸ºç¼–è¯‘å™¨å¹¶ä¸çŸ¥é“is[n]è¿™é‡Œçš„isçš„é•¿åº¦æ˜¯å¦ä¼šè¶…è¿‡byteå¤§å° _ = is[n] } } } func main() {} 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 TEXT main.f0(SB) /mnt/hgfs/g/hello1/struct.go func f0(is []int, bs []byte) { 0x4552e0 4883ec50 SUBQ $0x50, SP 0x4552e4 48896c2448 MOVQ BP, 0x48(SP) 0x4552e9 488d6c2448 LEAQ 0x48(SP), BP 0x4552ee 4889442458 MOVQ AX, 0x58(SP) # is.data 0x4552f3 48895c2460 MOVQ BX, 0x60(SP) # is.len 0x4552f8 48894c2468 MOVQ CX, 0x68(SP) # is.cap 0x4552fd 48897c2470 MOVQ DI, 0x70(SP) # bs.data 0x455302 4889742478 MOVQ SI, 0x78(SP) # bs.len 0x455307 4c89842480000000 MOVQ R8, 0x80(SP) # bs.cap if len(is) \u0026gt;= 256 { 0x45530f 48895c2428 MOVQ BX, 0x28(SP) # BX=is.len 0x455314 4881fb00010000 CMPQ $0x100, BX # is.len ä¸ 256æ¯”è¾ƒ 0x45531b 7d02 JGE 0x45531f 0x45531d eb36 JMP 0x455355 for _, n := range bs { 0x45531f 488b542470 MOVQ 0x70(SP), DX # DX=bs.data 0x455324 488b5c2478 MOVQ 0x78(SP), BX # BX=bs.len 0x455329 488bb42480000000 MOVQ 0x80(SP), SI # SI=bs.cap 0x455331 4889542430 MOVQ DX, 0x30(SP) 0x455336 48895c2438 MOVQ BX, 0x38(SP) 0x45533b 4889742440 MOVQ SI, 0x40(SP) 0x455340 48c744242000000000 MOVQ $0x0, 0x20(SP) 0x455349 488b542438 MOVQ 0x38(SP), DX\t# DX=bs.len 0x45534e 4889542418 MOVQ DX, 0x18(SP) 0x455353 eb0c JMP 0x455361 } 0x455355 eb00 JMP 0x455357 0x455357 488b6c2448 MOVQ 0x48(SP), BP 0x45535c 4883c450 ADDQ $0x50, SP 0x455360 c3 RET for _, n := range bs { 0x455361 488b542420 MOVQ 0x20(SP), DX # DX=0 0x455366 4839542418 CMPQ DX, 0x18(SP) # DX ä¸ bs.len å¾ªç¯åˆ¤æ–­æ¡ä»¶ 0x45536b 7f02 JG 0x45536f 0x45536d eb2e JMP 0x45539d 0x45536f 488b542430 MOVQ 0x30(SP), DX 0x455374 4803542420 ADDQ 0x20(SP), DX 0x455379 0fb602 MOVZX 0(DX), AX 0x45537c 88442417 MOVB AL, 0x17(SP) _ = is[n] 0x455380 488b4c2460 MOVQ 0x60(SP), CX 0x455385 4839c1 CMPQ AX, CX # è¶Šç•Œåˆ¤æ–­ 0x455388 7702 JA 0x45538c 0x45538a eb13 JMP 0x45539f 0x45538c eb00 JMP 0x45538e for _, n := range bs { 0x45538e 488b542420 MOVQ 0x20(SP), DX 0x455393 48ffc2 INCQ DX 0x455396 4889542420 MOVQ DX, 0x20(SP) 0x45539b ebc4 JMP 0x455361 } 0x45539d ebb8 JMP 0x455357 _ = is[n] 0x45539f 90 NOPL 0x4553a0 e81bd3ffff CALL runtime.panicIndex(SB) 0x4553a5 90 NOPL å¯ä»¥è¯•ç€åœ¨forå¾ªç¯å‰åŠ ä¸Šè¿™ä¹ˆä¸€å¥is = is[:256]æ¥å‘Šè¯‰ç¼–è¯‘å™¨æ–°isçš„é•¿åº¦ä¸º256ï¼Œæœ€å¤§ç´¢å¼•å€¼ä¸º255ï¼Œä¸ä¼šè¶…è¿‡byteçš„æœ€å¤§å€¼ï¼Œå› ä¸ºis[n]ä»é€»è¾‘ä¸Šæ¥è¯´æ˜¯ä¸€å®šä¸ä¼šè¶Šç•Œçš„ã€‚ 1 2 3 4 5 6 7 8 9 10 11 package main func f00(is []int, bs []byte) { if len(is) \u0026gt;= 256 { is = is[:256] for _, n := range bs { _ = is[n] // ä¸éœ€è¦åšè¾¹ç•Œæ£€æŸ¥ } } } func main() {} 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 TEXT main.f00(SB) /mnt/hgfs/g/hello1/t1.go func f00(is []int, bs []byte) { 0x4552e0 4883ec50 SUBQ $0x50, SP 0x4552e4 48896c2448 MOVQ BP, 0x48(SP) 0x4552e9 488d6c2448 LEAQ 0x48(SP), BP 0x4552ee 4889442458 MOVQ AX, 0x58(SP) 0x4552f3 48895c2460 MOVQ BX, 0x60(SP) 0x4552f8 48894c2468 MOVQ CX, 0x68(SP) 0x4552fd 48897c2470 MOVQ DI, 0x70(SP) 0x455302 4889742478 MOVQ SI, 0x78(SP) 0x455307 4c89842480000000 MOVQ R8, 0x80(SP) if len(is) \u0026gt;= 256 { 0x45530f 48895c2428 MOVQ BX, 0x28(SP) 0x455314 4881fb00010000 CMPQ $0x100, BX # 256 ä¸ is.len æ¯”è¾ƒ 0x45531b 7d02 JGE 0x45531f 0x45531d eb54 JMP 0x455373 is = is[:256] // æ¶ˆé™¤è¾¹ç•Œæ£€æŸ¥ 0x45531f 488b542468 MOVQ 0x68(SP), DX # DX=is.cap 0x455324 4881fa00010000 CMPQ $0x100, DX # 256 ä¸ is.cap æ¯”è¾ƒ 0x45532b 7305 JAE 0x455332 0x45532d e993000000 JMP 0x4553c5 0x455332 eb00 JMP 0x455334 0x455334 48c744246000010000 MOVQ $0x100, 0x60(SP) # is.len=256 for _, n := range bs { 0x45533d 488b542470 MOVQ 0x70(SP), DX # DX=bs.data 0x455342 488b5c2478 MOVQ 0x78(SP), BX # BX=bs.len 0x455347 488bb42480000000 MOVQ 0x80(SP), SI # SI=bs.cap 0x45534f 4889542430 MOVQ DX, 0x30(SP) 0x455354 48895c2438 MOVQ BX, 0x38(SP) 0x455359 4889742440 MOVQ SI, 0x40(SP) 0x45535e 48c744242000000000 MOVQ $0x0, 0x20(SP) 0x455367 488b542438 MOVQ 0x38(SP), DX # DX=bs.len 0x45536c 4889542418 MOVQ DX, 0x18(SP) 0x455371 eb0c JMP 0x45537f } 0x455373 eb00 JMP 0x455375 0x455375 488b6c2448 MOVQ 0x48(SP), BP 0x45537a 4883c450 ADDQ $0x50, SP 0x45537e c3 RET for _, n := range bs { 0x45537f 488b542420 MOVQ 0x20(SP), DX # DX=0 0x455384 4839542418 CMPQ DX, 0x18(SP) # 0 ä¸ bs.len æ¯”è¾ƒ 0x455389 7f02 JG 0x45538d 0x45538b eb2e JMP 0x4553bb 0x45538d 488b542430 MOVQ 0x30(SP), DX # DX=bs.data 0x455392 4803542420 ADDQ 0x20(SP), DX # DX=0+DX 0x455397 0fb602 MOVZX 0(DX), AX # AX=*bs.data 0x45539a 88442417 MOVB AL, 0x17(SP) _ = is[n] 0x45539e 488b4c2460 MOVQ 0x60(SP), CX # CX=256 0x4553a3 4839c1 CMPQ AX, CX # è¶Šç•Œåˆ¤æ–­ 0x4553a6 7702 JA 0x4553aa 0x4553a8 eb13 JMP 0x4553bd 0x4553aa eb00 JMP 0x4553ac for _, n := range bs { 0x4553ac 488b542420 MOVQ 0x20(SP), DX 0x4553b1 48ffc2 INCQ DX 0x4553b4 4889542420 MOVQ DX, 0x20(SP) 0x4553b9 ebc4 JMP 0x45537f } 0x4553bb ebb8 JMP 0x455375 _ = is[n] 0x4553bd 0f1f00 NOPL 0(AX) 0x4553c0 e8fbd2ffff CALL runtime.panicIndex(SB) is = is[:256] // æ¶ˆé™¤è¾¹ç•Œæ£€æŸ¥ 0x4553c5 b900010000 MOVL $0x100, CX 0x4553ca e871d3ffff CALL runtime.panicSliceAcap(SB) 0x4553cf 90 NOPL ","permalink":"https://heliu.site/posts/golang/slice/check/","summary":"Golang sliceè¾¹ç•Œæ£€æŸ¥ã€‚","title":"è¾¹ç•Œæ£€æŸ¥"},{"content":" æœ¬ç¯‡æ–‡ç« ä¸­æ¶‰åŠåˆ°æ±‡ç¼–ï¼Œä¸ç†Ÿæ‚‰è¯·å¿½ç•¥ã€‚ ä½¿ç”¨ä»‹ç» append() å‡½æ•°ç”¨äºé™„åŠ è¿æ¥åˆ‡ç‰‡ã€‚ Tæ˜¯ç±»å‹Sçš„å…ƒç´ ç±»å‹ï¼Œæ¯”å¦‚S = []Tã€‚ append(s S, x ...T) S appendå‡½æ•°å°†0ä¸ªæˆ–å¤šä¸ªå…·æœ‰ç›¸åŒç±»å‹Sçš„å…ƒç´ è¿½åŠ åˆ°åˆ‡ç‰‡såé¢å¹¶ä¸”è¿”å›æ–°çš„åˆ‡ç‰‡ã€‚ è¿½åŠ çš„å…ƒç´ å¿…é¡»å’ŒåŸåˆ‡ç‰‡çš„å…ƒç´ åŒç±»å‹ã€‚ å®ƒçš„å¯å˜å‚æ•°å¿…é¡»æ˜¯åˆ‡ç‰‡çš„ç±»å‹ï¼Œå¹¶è¿”å›ç»“æœåˆ‡ç‰‡ï¼Œä¹Ÿå°±æ˜¯Sç±»å‹ã€‚ å€¼xä¼ é€’ç»™ç±»å‹ä¸º ... çš„å‚æ•°Tï¼Œå…¶ä¸­Tæ˜¯Sçš„å…ƒç´ ç±»å‹ã€‚ å¦‚æœsçš„å®¹é‡ä¸è¶³ä»¥å­˜å‚¨æ–°å¢å…ƒç´ ï¼Œappendä¼šåˆ†é…æ–°çš„åˆ‡ç‰‡æ¥ä¿è¯å·²æœ‰åˆ‡ç‰‡å…ƒç´ å’Œæ–°å¢å…ƒç´ çš„å­˜å‚¨ã€‚ å› æ­¤append()å‡½æ•°è¿”å›çš„åˆ‡ç‰‡å¯èƒ½å·²ç»æŒ‡å‘ä¸€ä¸ªä¸åŒçš„ç›¸å…³æ•°ç»„äº†ï¼Œå³ä½¿ä¿®æ”¹äº†æ•°æ®ä¹Ÿä¸ä¼šåŒæ­¥ï¼Œå…·ä½“éœ€è¦æ ¹æ®Sçš„å®¹é‡è¿›è¡Œåˆ¤æ–­ã€‚ append()å‡½æ•°æ€»æ˜¯è¿”å›æˆåŠŸï¼Œé™¤éç³»ç»Ÿå†…å­˜è€—å°½äº†ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 s0 := []int{0, 0} // len 2 cap 2 // append é™„åŠ è¿æ¥å•ä¸ªå…ƒç´  s1 == []int{0, 0, 2} len 3 cap 4 s1 := append(s0, 2) // append é™„åŠ è¿æ¥å¤šä¸ªå…ƒç´  s2 == []int{0, 0, 2, 3, 5, 7} len 6 cap 8 s2 := append(s1, 3, 5, 7) // append é™„åŠ è¿æ¥åˆ‡ç‰‡s0 s3 == []int{0, 0, 2, 3, 5, 7, 0, 0} len 8 cap 8 s3 := append(s2, s0...) // append é™„åŠ åˆ‡ç‰‡æŒ‡å®šå€¼ s4 == []int{3, 5, 7, 2, 3, 5, 7, 0, 0} len 9 cap 10 s4 := append(s3[3:6], s3[2:]...) fmt.Println(\u0026#34;s0\u0026#34;, len(s0), cap(s0)) fmt.Println(\u0026#34;s1\u0026#34;, len(s1), cap(s1)) fmt.Println(\u0026#34;s2\u0026#34;, len(s2), cap(s2)) fmt.Println(\u0026#34;s3\u0026#34;, len(s3), cap(s3)) fmt.Println(\u0026#34;s4\u0026#34;, len(s4), cap(s4)) // s0 len:2 cap:2 // s1 len:3 cap:4 ç¿»å€æ‰©å®¹ // s2 len:6 cap:8 ç¿»å€æ‰©å®¹ // s3 len:8 cap:8 // s4 len:9 cap:10 ç¿»å€æ‰©å®¹ è¿™é‡Œç¿»å€æ‰©å®¹åˆ°10åŸå› åœ¨äºs3[3:6]çš„å®¹é‡ä¸º5 åˆ‡ç‰‡çš„å…ƒç´ æ˜¯ç©ºæ¥å£ã€‚ 1 2 var t []interface{} t = append(t, 42, 3.1415, \u0026#34;foo\u0026#34;) // t == []interfase{}{42, 3.1415, \u0026#34;foo\u0026#34;} åˆ‡ç‰‡çš„å…ƒç´ æ˜¯å­—èŠ‚ã€‚ 1 2 var b []byte b = append(b, \u0026#34;bar\u0026#34;...) // appendé™„åŠ è¿æ¥å­—ç¬¦ä¸²å†…å®¹ b == []byte{\u0026#39;b\u0026#39;, \u0026#39;a\u0026#39;, \u0026#39;r\u0026#39;} append() ä½¿ç”¨ç¤ºä¾‹ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 func ExampleAppend() { // åˆ‡ç‰‡å®¹é‡ä¸è¶³ append() è¿”å›çš„æ˜¯æ–°çš„åˆ‡ç‰‡ æŒ‡å‘ä¸åŒçš„å…³è”æ•°ç»„ s0 := []int{0,0} // len 2 cap 2 fmt.Println(s0, \u0026amp;s0[0], len(s0), cap(s0))// [0 0] 0xc00000a0b0 2 2 // ç”±äºs0çš„å®¹é‡åªæœ‰2ï¼Œæ­¤æ—¶æ·»åŠ å…ƒç´ å¯¼è‡´æ‰©å®¹ï¼Œä»æ–°åˆ†é…å†…å­˜ï¼Œå¹¶æŠŠä¹‹å‰æ•°æ®å¤åˆ¶è¿‡æ¥ s1 := append(s0, 2) fmt.Println(s1, \u0026amp;s1[0], len(s1), cap(s1))// [0 0 2] 0xc00000e340 3 4 è¿™é‡Œæ˜¾ç¤ºæ‰©å®¹ååœ°å€å˜äº† s1[0] += 1 fmt.Println(s0, s1) // [0 0] [1 0 2] // æ­¤æ—¶æ·»åŠ å…ƒç´  åˆä¼šå¯¼è‡´æ‰©å®¹ ä»æ–°åˆ†é…å†…å­˜ å¹¶æŠŠä¹‹å‰æ•°æ®å¤åˆ¶è¿‡æ¥ s2 := append(s1, 3, 5, 7) fmt.Println(s2, \u0026amp;s2[0], len(s2), cap(s2))// [1 0 2 3 5 7] 0xc00000c300 6 8 è¿™é‡Œæ˜¾ç¤ºæ‰©å®¹ååœ°å€åˆå˜äº† // æ­¤æ—¶åˆšå¥½è¾¾åˆ°æœ€å¤§å®¹é‡ï¼Œä¸ä¼šæ‰©å®¹ å˜é‡s3å¼•ç”¨å˜é‡s2åº•å±‚æ•°ç»„ï¼Œä¿®æ”¹å…¶ä¸­å…ƒç´ ä¼šå¼•èµ·å…¶ä»–ä¿®æ”¹ s3 := append(s2, s0...) fmt.Println(s3, len(s3), cap(s3)) // [1 0 2 3 5 7 0 0] 8 8 s2[1] += 1 fmt.Println(s2, s3) // [1 1 2 3 5 7] [1 1 2 3 5 7 0 0] // s3[3:6] len=3 cap=5 // s3[2:] len=6 cap=6 // å¯¼è‡´s4ä»æ–°åˆ†é…å†…å­˜å­˜å‚¨æ•°æ®ï¼Œs4 è¿™é‡Œ len 9 cap 10 s4 := append(s3[3:6], s3[2:]...) fmt.Println(s4) // [3 5 7 2 3 5 7 0 0] // Output: // [0 0] 0xc00000a0b0 2 2 // [0 0 2] 0xc00000e340 3 4 // [0 0] [1 0 2] // [1 0 2 3 5 7] 0xc00000c300 6 8 // [1 0 2 3 5 7 0 0] 8 8 // [1 1 2 3 5 7] [1 1 2 3 5 7 0 0] // [3 5 7 2 3 5 7 0 0] } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 func ExampleAppend() { // å¦‚æœåˆ‡ç‰‡å®¹é‡è¶³å¤Ÿ append()åä¸ä¼šç”Ÿæˆæ–°çš„åˆ‡ç‰‡ s0 := make([]int, 10, 20) // len.10 cap.20 fmt.Println(s0, \u0026amp;s0[0], len(s0), cap(s0)) // [0 0 0 0 0 0 0 0 0 0] 0xc00007c000 10 20 s1 := append(s0,2) // len.11 cap.20 fmt.Println(s1, \u0026amp;s1[0], len(s1), cap(s1)) // [0 0 0 0 0 0 0 0 0 0 2] 0xc00007c000 11 20 s2 := append(s1, 3, 5, 7) // len.14 cap.20 fmt.Println(s2, \u0026amp;s2[0], len(s2), cap(s2)) // [0 0 0 0 0 0 0 0 0 0 2 3 5 7] 0xc00007c000 14 20 // æ­¤æ—¶æ‰©å®¹ï¼Œä»æ–°å¼€è¾Ÿå†…å­˜ï¼Œå¤åˆ¶åŸæ¥æ•°æ® s3 := append(s2, s0...) // len.24 cap.40 fmt.Println(s3, len(s3), cap(s3)) // [0 0 0 0 0 0 0 0 0 0 2 3 5 7 0 0 0 0 0 0 0 0 0 0] 24 40 // è¿™é‡Œs4å®¹é‡ä¸º37 æ˜¯ç”±äºs3[3:6] è¿™é‡Œ40-3=37å®¹é‡ // æ­¤æ—¶å®¹é‡è¶³å¤Ÿï¼Œå¹¶æ²¡æœ‰æ‰©å®¹ // s3[3:6] -\u0026gt; len = 6-3=3 cap = 40-3 = 37 // s3[2:] -\u0026gt; len = 24-2=22 cap = 40-2 = 38 s4 := append(s3[3:6], s3[2:]...) fmt.Println(s4, len(s4), cap(s4)) // [0 0 0 0 0 0 0 0 0 0 0 2 3 5 7 0 0 0 0 0 0 0 0 0 0] 25 37 fmt.Println(s0) // [0 0 0 0 0 0 0 0 0 0] fmt.Println(s1) // [0 0 0 0 0 0 0 0 0 0 2] fmt.Println(s2) // [0 0 0 0 0 0 0 0 0 0 2 3 5 7] fmt.Println(s3) // [0 0 0 0 0 0 0 0 0 0 0 0 0 0 2 3 5 7 0 0 0 0 0 0] fmt.Println(s4) // [0 0 0 0 0 0 0 0 0 0 0 2 3 5 7 0 0 0 0 0 0 0 0 0 0] s0[1] += 1 fmt.Println(s0) // [0 1 0 0 0 0 0 0 0 0] fmt.Println(s1) // [0 1 0 0 0 0 0 0 0 0 2] fmt.Println(s2) // [0 1 0 0 0 0 0 0 0 0 2 3 5 7] fmt.Println(s3) // [0 0 0 0 0 0 0 0 0 0 0 0 0 0 2 3 5 7 0 0 0 0 0 0] fmt.Println(s4) // [0 0 0 0 0 0 0 0 0 0 0 2 3 5 7 0 0 0 0 0 0 0 0 0 0] s4[0] += 1 fmt.Println(s3) // [0 0 0 1 0 0 0 0 0 0 0 0 0 0 2 3 5 7 0 0 0 0 0 0] fmt.Println(s4) // [1 0 0 0 0 0 0 0 0 0 0 2 3 5 7 0 0 0 0 0 0 0 0 0 0] } Goä¸­appendçš„æè¿° append å†…ç½®å‡½æ•°å°†å…ƒç´ é™„åŠ åˆ°åˆ‡ç‰‡çš„æœ«å°¾ã€‚å¦‚æœå®ƒæœ‰è¶³å¤Ÿçš„å®¹é‡ï¼Œç›®æ ‡å°†è¢«é‡æ–°åˆ‡ç‰‡ä»¥å®¹çº³æ–°å…ƒç´ ã€‚å¦‚æœæ²¡æœ‰ï¼Œå°†åˆ†é…ä¸€ä¸ªæ–°çš„åº•å±‚æ•°ç»„ã€‚ Append è¿”å›æ›´æ–°åçš„åˆ‡ç‰‡ã€‚å› æ­¤æœ‰å¿…è¦å°† append çš„ç»“æœå­˜å‚¨åœ¨ä¿å­˜åˆ‡ç‰‡æœ¬èº«çš„å˜é‡ä¸­ï¼š slice = append(slice, elem1, elem2)ï¼š elem1ï¼Œelem2 åˆ‡ç‰‡å…ƒç´ ã€‚ slice = append(slice, anotherSlice...)ï¼šanotherSlice å…¶ä»–åˆ‡ç‰‡ã€‚ ä½œä¸ºä¸€ç§ç‰¹æ®Šæƒ…å†µï¼Œå°†å­—ç¬¦ä¸²é™„åŠ åˆ°å­—èŠ‚åˆ‡ç‰‡æ˜¯åˆæ³•çš„ï¼Œå¦‚ä¸‹æ‰€ç¤ºï¼š slice = append([]byte(\u0026quot;hello \u0026quot;), \u0026quot;world\u0026quot;...) ã€append([]T, ...T) []Tã€‘ æˆ– ã€append([]byte, string...) []byteã€‘ 1 2 3 4 5 6 7 8 9 10 // The append built-in function appends elements to the end of a slice. If // it has sufficient capacity, the destination is resliced to accommodate the // new elements. If it does not, a new underlying array will be allocated. // Append returns the updated slice. It is therefore necessary to store the // result of append, often in the variable holding the slice itself: //\tslice = append(slice, elem1, elem2)\t//\tslice = append(slice, anotherSlice...)\t// As a special case, it is legal to append a string to a byte slice, like this: //\tslice = append([]byte(\u0026#34;hello \u0026#34;), \u0026#34;world\u0026#34;...) func append(slice []Type, elems ...Type) []Type append() ä¸æ‰©å®¹æ—¶ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 func main() { s := make([]int, 0, 8) // ä¸å­˜åœ¨æ‰©å®¹çš„æƒ…å†µ s = append(s, 1, 2) _ = s } /* TEXT main.main(SB) /mnt/hgfs/g/hello1/slice1.go func main() { 0x4551e0 4883ec60 SUBQ $0x60, SP 0x4551e4 48896c2458 MOVQ BP, 0x58(SP) 0x4551e9 488d6c2458 LEAQ 0x58(SP), BP s := make([]int, 0, 8) 0x4551ee 440f113c24 MOVUPS X15, 0(SP) 0x4551f3 440f117c2410 MOVUPS X15, 0x10(SP) 0x4551f9 440f117c2420 MOVUPS X15, 0x20(SP) 0x4551ff 440f117c2430 MOVUPS X15, 0x30(SP) 0x455205 488d0424 LEAQ 0(SP), AX # AX=0(SP) 0x455209 8400 TESTB AL, 0(AX) 0x45520b eb00 JMP 0x45520d 0x45520d eb00 JMP 0x45520f 0x45520f 4889442440 MOVQ AX, 0x40(SP) 0x455214 48c744244800000000 MOVQ $0x0, 0x48(SP) 0x45521d 48c744245008000000 MOVQ $0x8, 0x50(SP) s = append(s, 1, 2) 0x455226 eb00 JMP 0x455228 0x455228 48c7042401000000 MOVQ $0x1, 0(SP) 0x455230 48c744240802000000 MOVQ $0x2, 0x8(SP) 0x455239 4889442440 MOVQ AX, 0x40(SP) 0x45523e 48c744244802000000 MOVQ $0x2, 0x48(SP) 0x455247 48c744245008000000 MOVQ $0x8, 0x50(SP) } 0x455250 488b6c2458 MOVQ 0x58(SP), BP 0x455255 4883c460 ADDQ $0x60, SP 0x455259 c3 RET */ // +60 | address of runtime.main // ---------------------------------------- // +58 | BP of runtime.main // ---------------------------------------- BP // +50 | 8 s.cap // ---------------------------------------- // +48 | 2 s.len // ---------------------------------------- // +40 | 0(SP) s.data // ---------------------------------------- // +38 | 0 *s.data.7 // ---------------------------------------- // +30 | 0 *s.data.6 // ---------------------------------------- // +28 | 0 *s.data.5 // ---------------------------------------- // +20 | 0 *s.data.4 // ---------------------------------------- // +18 | 0 *s.data.3 // ---------------------------------------- // +10 | 0 *s.data.2 // ---------------------------------------- // +08 | 2 *s.data.1 // ---------------------------------------- // +00 | 1 *s.data.0 // ---------------------------------------- SP append() ç¿»å€æ‰©å®¹æ—¶ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 func main() { s := make([]int, 0, 1) // ç¿»å€æ‰©å®¹æƒ…å†µ s = append(s, 1, 2) _ = s } /* TEXT main.main(SB) /mnt/hgfs/g/hello1/slice1.go func main() { 0x4551e0 493b6610 CMPQ 0x10(R14), SP 0x4551e4 0f8681000000 JBE 0x45526b 0x4551ea 4883ec68 SUBQ $0x68, SP 0x4551ee 48896c2460 MOVQ BP, 0x60(SP) 0x4551f3 488d6c2460 LEAQ 0x60(SP), BP s := make([]int, 0, 1) 0x4551f8 48c744244000000000 MOVQ $0x0, 0x40(SP) 0x455201 488d5c2440 LEAQ 0x40(SP), BX # BX=0x40(SP) 0x455206 8403 TESTB AL, 0(BX) 0x455208 eb00 JMP 0x45520a 0x45520a eb00 JMP 0x45520c 0x45520c 48895c2448 MOVQ BX, 0x48(SP) 0x455211 48c744245000000000 MOVQ $0x0, 0x50(SP) 0x45521a 48c744245801000000 MOVQ $0x1, 0x58(SP) s = append(s, 1, 2) 0x455223 eb00 JMP 0x455225 0x455225 488d05f44a0000 LEAQ 0x4af4(IP), AX # AX=0x4af4(IP) \u0026amp;type.int 0x45522c 31c9 XORL CX, CX # CX=0 0x45522e bf01000000 MOVL $0x1, DI # DI=1 0x455233 be02000000 MOVL $0x2, SI # SI=2 ç¿»å€æ‰©å®¹å cap=2 # runtime.growslice -\u0026gt; func growslice(et *_type, old slice, cap int) slice æ‰©å®¹å‡½æ•° # è¿”å›å€¼ AX=r.data; BX=r.len; CX=r.cap 0x455238 e8c3b2feff CALL runtime.growslice(SB)\t# DX=r.len+2 åŸå› æ˜¯runtime.growsliceè¿”å›çš„r.lenæ˜¯old.len 0x45523d 488d5302 LEAQ 0x2(BX), DX\t0x455241 eb00 JMP 0x455243 0x455243 48c70001000000 MOVQ $0x1, 0(AX)\t0x45524a 48c7400802000000 MOVQ $0x2, 0x8(AX) 0x455252 4889442448 MOVQ AX, 0x48(SP) 0x455257 4889542450 MOVQ DX, 0x50(SP) 0x45525c 48894c2458 MOVQ CX, 0x58(SP) } 0x455261 488b6c2460 MOVQ 0x60(SP), BP 0x455266 4883c468 ADDQ $0x68, SP 0x45526a c3 RET func main() { 0x45526b e8f0ccffff CALL runtime.morestack_noctxt.abi0(SB) 0x455270 e96bffffff JMP main.main(SB) */ // +68 |\taddress of runtime.main // ------------------------------------ // +60 |\tBP of runtime.main // ------------------------------------ BP // +58 | 1 s.cap // ------------------------------------ // +50 | 0 s.len // ------------------------------------ // +48 | 0x40(SP) s.data // ------------------------------------ // +40 | 0 *s.data.0 // ------------------------------------ // +38 | // ------------------------------------ // +30 | // ------------------------------------ // +28 | // ------------------------------------ // +20 | // ------------------------------------ // +18 | // ------------------------------------ // +10 | // ------------------------------------ // +08 | // ------------------------------------ // +00 | // ------------------------------------ SP nilåˆ‡ç‰‡è°ƒç”¨appendå‡½æ•° 1 2 3 4 5 6 7 8 9 package main import \u0026#34;fmt\u0026#34; func main() { var s []int // {nil, 0, 0} s = append(s, 1, 2) fmt.Println(s) } TEXT main.main(SB) /mnt/hgfs/g/hello1/slice1.go func main() { 0x4551e0 493b6610 CMPQ 0x10(R14), SP 0x4551e4 7665 JBE 0x45524b 0x4551e6 4883ec60 SUBQ $0x60, SP 0x4551ea 48896c2458 MOVQ BP, 0x58(SP) 0x4551ef 488d6c2458 LEAQ 0x58(SP), BP var s []int // {nil, 0, 0} 0x4551f4 48c744244000000000 MOVQ $0x0, 0x40(SP) 0x4551fd 440f117c2448 MOVUPS X15, 0x48(SP) s = append(s, 1, 2) 0x455203 eb00 JMP 0x455205 0x455205 488d05144b0000 LEAQ 0x4b14(IP), AX # AX=0x4b14(IP) et=\u0026amp;type.int 0x45520c 31db XORL BX, BX # BX=0 old.data 0x45520e 31c9 XORL CX, CX # CX=0 old.len 0x455210 4889cf MOVQ CX, DI # DI=0 old.cap 0x455213 be02000000 MOVL $0x2, SI # SI=2 cap=2 # runtime.growslice -\u0026gt; func growslice(et *_type, old slice, cap int) slice æ‰©å®¹å‡½æ•° # è¿™é‡Œå°±æ˜¯nilåˆ‡ç‰‡èƒ½ä½¿ç”¨appendæ–°å¢å…ƒç´ çš„åŸå›  0x455218 e8e3b2feff CALL runtime.growslice(SB) 0x45521d 488d5302 LEAQ 0x2(BX), DX 0x455221 eb00 JMP 0x455223 0x455223 48c70001000000 MOVQ $0x1, 0(AX) 0x45522a 48c7400802000000 MOVQ $0x2, 0x8(AX) 0x455232 4889442440 MOVQ AX, 0x40(SP) 0x455237 4889542448 MOVQ DX, 0x48(SP) 0x45523c 48894c2450 MOVQ CX, 0x50(SP) } 0x455241 488b6c2458 MOVQ 0x58(SP), BP 0x455246 4883c460 ADDQ $0x60, SP 0x45524a c3 RET func main() { 0x45524b e810cdffff CALL runtime.morestack_noctxt.abi0(SB) 0x455250 eb8e JMP main.main(SB) // +60 | address of runtime.main // ----------------------------------- // +58 | BP of runtime.main // ----------------------------------- BP // +50 | 0 s.cap // ----------------------------------- // +48 | 0 s.len // ----------------------------------- // +40 | 0 s.data // ----------------------------------- // +38 | // ----------------------------------- // +30 | // ----------------------------------- // +28 | // ----------------------------------- // +20 | // ----------------------------------- // +18 | // ----------------------------------- // +10 | // ----------------------------------- // +08 | // ----------------------------------- // +00 | // ----------------------------------- SP append æ‰§è¡Œæ­¥éª¤ å¦‚æœå½“å‰append()å‡½æ•°æ‰§è¡Œå®Œååˆ‡ç‰‡ä¸ä¼š\u0026quot;ç¿»å€æ‰©å®¹\u0026quot;é‚£ä¹ˆï¼Œç›´æ¥æ˜¯æŠŠappendåè¿½åŠ çš„æ•°æ®æ‹·è´åˆ°åˆ‡ç‰‡çš„åç»­ç©ºé—´å³å¯ã€‚ å¦‚æœå½“å‰append()å‡½æ•°æ‰§è¡Œå®Œåéœ€è¦\u0026quot;ç¿»å€æ‰©å®¹\u0026quot;ï¼Œé‚£ä¹ˆå…ˆè°ƒç”¨runtime.growslice()æ‰©å®¹å‡½æ•°ï¼Œç„¶ååœ¨æ‹·è´æ•°æ®è¿½åŠ åˆ°æ–°çš„å†…å­˜ç©ºé—´ã€‚ append å‡½æ•°æ€»ç»“ append() å‡½æ•°åŸå‹ func append(slice []Type, elems ...Type) []Type æ”¯æŒä¸¤ç§å½¢å¼ã€‚ 1 2 3 4 // å½¢å¼ä¸€ slice = append(slice, elem1, elem2)\t// å½¢å¼äºŒ anotherSlice... è¿™ç§å½¢å¼åªæ”¯æŒanotherSliceæ˜¯åˆ‡ç‰‡ slice = append(slice, anotherSlice...)\t1 2 // å½¢å¼ä¸‰ åªæœ‰åœ¨è¿™ç§å½¢å¼ä¸‹å‡½æ•°å†…æ‰èƒ½ä½¿ç”¨ \u0026#34;world\u0026#34;... å½¢å¼è§£å¼•ç”¨å­—ç¬¦ä¸² slice = append([]byte(\u0026#34;hello \u0026#34;), \u0026#34;world\u0026#34;...) append() å‡½æ•°æ˜¯ç”±ç¼–è¯‘å™¨æ”¯æŒçš„æ²¡æœ‰å‡½æ•°åŸå‹åªå­˜åœ¨å‡½æ•°å£°æ˜ã€‚ func append(slice []Type, elems ...Type) []Type å¦‚æœæ·»åŠ è¿‡ç¨‹ä¸­éœ€è¦æ‰©å®¹ï¼Œç¼–è¯‘å™¨ä¼šè°ƒç”¨ runtime.growslice å‡½æ•°ï¼Œè¯¥å‡½æ•°åŸå‹ã€‚ 1 2 3 4 5 6 7 8 9 10 11 // å‡½æ•°å‚æ•° // et *_typeï¼šåˆ‡ç‰‡å…ƒç´ å…ƒç±»å‹ // old sliceï¼šæœªæ‰©å®¹å‰åˆ‡ç‰‡ // cap intï¼šæ·»åŠ å…ƒç´ åçš„å®¹é‡ old.len + n = cap // è¿”å›å€¼ slice // slice.dataï¼šæ–°åˆ†é…çš„å†…å­˜åœ°å€ // slice.lenï¼šold.len æ—§åˆ‡ç‰‡é•¿åº¦ // slice.capï¼šç¿»å€æ‰©å®¹åçš„å®¹é‡ func growslice(et *_type, old slice, cap int) slice ","permalink":"https://heliu.site/posts/golang/slice/append/","summary":"Golang append()å‡½æ•°ä»‹ç»ã€‚","title":"append()"},{"content":"copy(dst, src []Type) int copy å†…ç½®å‡½æ•°å°†å…ƒç´ ä» src æºåˆ‡ç‰‡å¤åˆ¶åˆ° dst ç›®æ ‡åˆ‡ç‰‡ã€‚(ä½œä¸ºä¸€ç§ç‰¹æ®Šæƒ…å†µï¼Œå®ƒè¿˜å°†å­—èŠ‚ä»ä¸€ä¸ª string å¤åˆ¶åˆ°ä¸€ä¸ª []byte) src å’Œ dst å¯èƒ½ä¼šé‡å ã€‚copy è¿”å›èµ‹å€¼çš„å…ƒç´ æ•°é‡ï¼Œå®ƒå°†æ˜¯ len(src) å’Œ len(dst) çš„æœ€å°å€¼ã€‚ å¸¸å¸¸å°†åˆ‡ç‰‡å…ƒç´ ä»æºsrcå¤åˆ¶åˆ°ç›®æ ‡dstï¼Œå¹¶è¿”å›å¤åˆ¶çš„å…ƒç´ æ•° ä¸¤ä¸ªå‚æ•°å¿…é¡»å…·æœ‰ç›¸åŒå¾—å…ƒç´ ç±»å‹Typeï¼Œå¹¶ä¸”å¯ä»¥åˆ†é…ç»™ç±»å‹ä¸º[]Typeçš„åˆ‡ç‰‡ srcå’Œdståˆ‡ç‰‡çš„åº•å±‚å…ƒç´ å¯èƒ½ä¼šé‡å  å¤åˆ¶çš„å…ƒç´ æ•°é‡æ˜¯len(src)å’Œlen(dst)çš„æœ€å°å€¼ 1 2 3 4 5 6 // The copy built-in function copies elements from a source slice into a // destination slice. (As a special case, it also will copy bytes from a // string to a slice of bytes.) The source and destination may overlap. Copy // returns the number of elements copied, which will be the minimum of // len(src) and len(dst). copy(dst, src []Type) int // src -\u0026gt; dst ä½¿ç”¨ç¤ºä¾‹ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 func ExampleCopy() { var a = [...]int{0,1,2,3,4,5,6,7} var s = make([]int, 6) n1 := copy(s, a[0:]) fmt.Println(n1, s) // 6 [0 1 2 3 4 5] // ä»sä¸­èµ‹å€¼æ•°æ®åˆ°sä¸­ n2 := copy(s, s[2:]) fmt.Println(n2, s) // 4 [2 3 4 5 4 5] fmt.Println(a) // [0 1 2 3 4 5 6 7] // Output: // 6 [0 1 2 3 4 5] // 4 [2 3 4 5 4 5] // [0 1 2 3 4 5 6 7] } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 func ExampleCopy() { var a = [...]int{0,1,2,3,4,5,6,7} var s = make([]int, 4) n1 := copy(s, a[0:]) fmt.Println(n1, s) // 4 [0 1 2 3] // ä»sä¸­èµ‹å€¼æ•°æ®åˆ°sä¸­ n2 := copy(s, s[2:]) fmt.Println(n2, s) // 2 [2 3 2 3] fmt.Println(a) // [0 1 2 3 4 5 6 7] // Output: // 4 [0 1 2 3] // 2 [2 3 2 3] // [0 1 2 3 4 5 6 7] } copy(to []byte, fm string) int copy(to []byte, fm string) int\t// fm -\u0026gt; to copy() å‡½æ•°è¿˜æ¥æ”¶å¯åˆ†é…ç»™[]byteç±»å‹çš„ç›®æ ‡å‚æ•°ï¼Œå…¶ä¸­fmå‚æ•°ä¸ºå­—ç¬¦ä¸²ç±»å‹ 1 2 3 4 5 6 7 8 9 10 func ExampleCopy() { var b = make([]byte, 5) n3 := copy(b, \u0026#34;Helloï¼ŒWorld!\u0026#34;) fmt.Println(n3, b) // 5 [72 101 108 108 111] // Output: // 5 [72 101 108 108 111] } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 func ExampleCopy() { var s string = \u0026#34;hello Goè¯­è¨€\u0026#34; // 8 + 2*3 = 14 var slice1 []byte // åˆ›å»ºåˆ‡ç‰‡ é»˜è®¤é•¿åº¦ä¸º0 num1 := copy(slice1, s) fmt.Println(num1, slice1) // 0 [] var slice2 []byte = []byte{0} // åˆ›å»ºåˆ‡ç‰‡ å¹¶åˆå§‹åŒ–ä¸€ä¸ªå®¹é‡ num2 := copy(slice2, s) fmt.Println(num2, slice2) // 1 [104] slice3 := make([]byte, 20) // åˆ›å»ºåˆ‡ç‰‡ åˆå§‹åŒ–é•¿åº¦ä¸º20 num3 := copy(slice3, s) fmt.Println(num3, slice3) // 14 [104 101 108 108 111 32 71 111 232 175 173 232 168 128 0 0 0 0 0 0] slice4 := make([]byte, 20, 40) // åˆ›å»ºåˆ‡ç‰‡ åˆå§‹åŒ–é•¿åº¦ä¸º20 å®¹é‡ä¸º40 num4 := copy(slice4, s) fmt.Println(num4, slice4) // 14 [104 101 108 108 111 32 71 111 232 175 173 232 168 128 0 0 0 0 0 0] // ç”±æ­¤å¯ä»¥çœ‹å‡º copy()å‡½æ•° å¤åˆ¶å¤šå°‘è·Ÿæ¥å—å˜é‡é•¿åº¦æœ‰å…³ // Output: // 0 [] // 1 [104] // 14 [104 101 108 108 111 32 71 111 232 175 173 232 168 128 0 0 0 0 0 0] // 14 [104 101 108 108 111 32 71 111 232 175 173 232 168 128 0 0 0 0 0 0] } 1 2 3 4 5 6 7 8 func ExampleCopy() { slice := make([]byte, 3) n := copy(slice, \u0026#34;append\u0026#34;) fmt.Println(n ,slice) // 3 [97 112 112] // Output: // 3 [97 112 112] } copy æºç  å‚è€ƒæœ¬ç« èŠ‚çš„åŸç†ç¯‡ã€‚ ","permalink":"https://heliu.site/posts/golang/slice/copy/","summary":"Golang copy()å‡½æ•°ä»‹ç»ã€‚","title":"copy()"},{"content":"map ä»‹ç» mapæ˜¯ä¸€ç§æ— åºçš„åŸºäºkey-valueçš„æ•°æ®ç»“æ„ï¼ŒGoè¯­è¨€ä¸­çš„mapæ˜¯å¼•ç”¨ç±»å‹ï¼Œå¿…é¡»åˆå§‹åŒ–æ‰èƒ½ä½¿ç”¨ã€‚ å­—å…¸(map)æ˜¯ä¸€ç§é”®-å€¼å¯¹(key-value)çš„æ— åºé›†åˆã€‚ ä¸€ç»„ç§°ä¸ºå€¼å…ƒç´  valueã€‚ å¦å¤–ä¸€ç»„ç§°ä¸ºå”¯ä¸€é”®ç´¢å¼•keyã€‚ æœªåˆå§‹åŒ–å­—å…¸çš„å€¼nilã€‚ å­—å…¸æ˜¯å¼•ç”¨ç±»å‹ï¼šå£°æ˜å¦‚ä¸‹ [keytype]å’Œvaluetypeä¹‹é—´å…è®¸æœ‰ç©ºæ ¼ï¼Œä½†æ˜¯Gofmtç§»é™¤äº†ç©ºæ ¼ã€‚ var map1 map[keytype]valuetype å£°æ˜çš„æ—¶å€™ä¸éœ€è¦çŸ¥é“å­—å…¸çš„é•¿åº¦ï¼Œå­—å…¸æ˜¯å¯ä»¥åŠ¨æ€å¢é•¿çš„ï¼Œä½†æœ€å¥½æŒ‡å®šå®¹é‡ã€‚ keyå¯ä»¥æ˜¯ä»»æ„èƒ½ä½¿ç”¨**==æˆ–è€…!=**æ“ä½œç¬¦æ¯”è¾ƒçš„ç±»å‹ï¼Œè¿™æ˜¯ç”±äºåœ¨ä½¿ç”¨mapä¸­å¾ˆå¤šéƒ½éœ€è¦æ¯”è¾ƒkeyæ˜¯å¦ç›¸ç­‰ï¼Œæ¯”å¦‚è·å–keyå­˜å‚¨çš„valueå€¼ï¼Œéœ€è¦æ¯”è¾ƒkeyæ˜¯å¦ä¸€è‡´ã€‚ å¦‚stringã€intã€floatã€‚ æ‰€ä»¥å­—å…¸ã€åˆ‡ç‰‡ã€å‡½æ•°ä¸èƒ½ä½œä¸ºkeyã€‚ å«æœ‰åˆ‡ç‰‡çš„ç»“æ„ä½“ä¸èƒ½ä½œä¸ºkeyï¼Œåªèƒ½åŒ…å«å†…å»ºç±»å‹çš„structæ˜¯å¯ä»¥ä½œä¸ºkeyçš„ã€‚ æŒ‡é’ˆå’Œæ¥å£ç±»å‹å¯ä»¥ï¼Œå°½é‡ä¸ä½¿ç”¨æ¥å£ï¼Œæ¥å£ä½œä¸ºkeyåœ¨hashæ—¶æœ‰å¯èƒ½ä¼španicï¼Œæ¥å£ä¸­å­˜åœ¨ä¸å¯æ¯”è¾ƒç±»å‹æ—¶ã€‚ valueå¯ä»¥æ˜¯ä»»æ„ç±»å‹ï¼Œé€šè¿‡ä½¿ç”¨ç©ºæ¥å£ç±»å‹ï¼Œå¯ä»¥å­˜å‚¨ä»»æ„å€¼ã€‚ä½†æ˜¯ä½¿ç”¨è¿™ç§ç±»å‹ä½œä¸ºå€¼æ—¶éœ€è¦å…ˆåšä¸€æ¬¡ç±»å‹æ–­è¨€ã€‚ å­—å…¸ä¼ é€’ç»™å‡½æ•°çš„ä»£ä»·å¾ˆå°ï¼Œè™½ç„¶é€šè¿‡keyåœ¨å­—å…¸ä¸­æŸ¥æ‰¾å€¼å¾ˆå¿«ã€‚ä½†æ˜¯ä»ç„¶æ¯”ä»æ•°ç»„å’Œåˆ‡ç‰‡çš„ç´¢å¼•ä¸­è¯»å–è¦æ…¢ï¼Œä¸€èˆ¬å»ºè®®ä½¿ç”¨åˆ‡ç‰‡ã€‚ å­—å…¸å¯ä»¥ç”¨{key1:val1, key2:val2}çš„æè¿°æ–¹å¼æ¥åˆå§‹åŒ–ï¼Œå°±åƒæ•°ç»„å’Œç»“æ„ä½“ä¸€æ ·ã€‚å­—å…¸æ˜¯å¼•ç”¨ç±»å‹çš„ï¼Œå†…å­˜ç”¨makeå‡½æ•°æ¥åˆ†é…ã€‚ var map1 = make(map[keytype]valtype) å’Œæ•°ç»„ä¸åŒï¼Œå­—å…¸å¯ä»¥æ ¹æ®æ–°å¢çš„é”®-å€¼(key-value)å¯¹åŠ¨æ€çš„ä¼¸ç¼©ï¼Œå› æ­¤å®ƒä¸å­˜åœ¨å›ºå®šé•¿åº¦æˆ–è€…æœ€å¤§é™åˆ¶ã€‚ ä¹Ÿå¯ä»¥é€‰æ‹©æ ‡æ˜mapçš„åˆå§‹å®¹é‡capacityï¼Œmake(map[keytype]valtype, cap)ã€‚ // cap è¡¨ç¤º map çš„å®¹é‡ï¼Œè¯¥å‚æ•°è™½ç„¶ä¸æ˜¯å¿…é¡»çš„ // åº”è¯¥åœ¨åˆå§‹åŒ–mapçš„æ—¶å€™å°±ä¸ºå…¶æŒ‡å®šä¸€ä¸ªåˆé€‚çš„å®¹é‡ make(map[keyType]ValueType, [cap]) map2 := make(map[string]float32, 100) // æ”¯æŒ100ä¸ªkey/elemä¸æ‰©å®¹ å½“å­—å…¸å¢é•¿åˆ°å®¹é‡ä¸Šé™çš„æ—¶å€™ï¼Œå¦‚æœåœ¨å¢åŠ æ–°çš„é”®-å€¼å¯¹ï¼Œå­—å…¸çš„å¤§å°ä¼šè‡ªåŠ¨åŠ 1ã€‚æ‰€ä»¥å¯¹äºå¤§çš„å­—å…¸æˆ–è€…ä¼šå¿«é€Ÿæ‰©å¼ çš„å­—å…¸ï¼Œå³ä½¿åªæ˜¯å¤§æ¦‚çŸ¥é“å®¹é‡ï¼Œä¹Ÿæœ€å¥½å…ˆæ ‡æ˜ã€‚ åœ¨ä¸€ä¸ªnilçš„åˆ‡ç‰‡ä¸­æ·»åŠ å…ƒç´ æ˜¯æ²¡æœ‰é—®é¢˜çš„ï¼Œä½†æ˜¯å¯¹äºä¸€ä¸ªå­—å…¸åšåŒæ ·çš„äº‹æƒ…å°†ä¼šç”Ÿæˆä¸€ä¸ªè¿è¡Œæ—¶å¼‚å¸¸ã€‚ç”±äºnilè¿˜æœªåˆ†é…å†…å­˜ï¼Œæ‰€ä»¥ä¸èƒ½ä½¿ç”¨ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 package main import ( \u0026#34;fmt\u0026#34; ) func main() { // å£°æ˜å˜é‡sï¼Œå¹¶æœªåˆ†é…å†…å­˜ é»˜è®¤å€¼ä¸º nil // sliceåˆ‡ç‰‡ç»“æ„ struct slice {data, len, cap} var s []int // appendå‡½æ•°ä¼šåˆå§‹åŒ–så˜é‡å¹¶åˆ†é…å†…å­˜ s = append(s, 1) fmt.Println(s) // [1] //var m map[string]int //m[\u0026#34;one\u0026#34;] = 1 // panic: assignment to entry in nil map //fmt.Println(m) // ä½†æ˜¯ä½¿ç”¨make()åˆ›å»ºçš„è€…ä¸ä¼šå‡ºç°ç±»ä¼¼æƒ…å†µ // makeå‡½æ•°ä¼šåˆå§‹åŒ–mapï¼Œå¹¶åˆ†é…å†…å­˜ m2 := make(map[string]int, 0) m2[\u0026#34;a\u0026#34;] = 12 fmt.Println(m2) // map[a:12] } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 package main import ( \u0026#34;fmt\u0026#34; ) var m3 = make(map[string]int, 8) var m4 map[string]float64 func main() { var m = make(map[string]int, 8) m[\u0026#34;a\u0026#34;] = 12 fmt.Println(m) // map[a:12] var m1 map[string]string m1[\u0026#34;a\u0026#34;] = \u0026#34;as\u0026#34; // panic: assignment to entry in nil map fmt.Println(m1) m2 := make(map[string]int, 8) m2[\u0026#34;a\u0026#34;] = 12 fmt.Println(m2) // map[a:12] m3[\u0026#34;a\u0026#34;] = 12 fmt.Println(m3) // map[a:12] m4[\u0026#34;a\u0026#34;] = 12.3 // panic: assignment to entry in nil map fmt.Println(m4) i, v := m3[\u0026#34;a\u0026#34;] fmt.Println(i, v) // 12 true } å¯ä»¥é€šè¿‡val1 = map1[key1]çš„æ–¹æ³•è·å–key1å¯¹åº”çš„å€¼val1ã€‚ value, ok = map[key] 1 2 3 if _, ok := x[\u0026#34;two\u0026#34;]; !ok { fmt.Println(\u0026#34;å€¼ä¸å­˜åœ¨\u0026#34;) } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 package main import \u0026#34;fmt\u0026#34; func main() { scoreMap := make(map[string]int) scoreMap[\u0026#34;one\u0026#34;] = 90 scoreMap[\u0026#34;two\u0026#34;] = 100 // å¦‚æœkeyå­˜åœ¨ okä¸ºtrueï¼Œvä¸ºå¯¹åº”çš„å€¼ // keyä¸å­˜åœ¨ okä¸ºfalseï¼Œvä¸ºå€¼ç±»å‹çš„é›¶å€¼ v, ok := scoreMap[\u0026#34;two\u0026#34;] if ok { fmt.Println(v) } else { fmt.Println(\u0026#34;ä¸å­˜åœ¨\u0026#34;) } } å®šä¹‰å­—å…¸çš„ä¾‹å­ã€‚ 1 2 3 4 5 6 7 8 9 10 // æŒ‡å®šå®¹é‡ map1 := make(map[string]string, 5) map2 := make(map[string]string) // åˆ›å»ºå¹¶åˆå§‹åŒ–ä¸€ä¸ªç©ºçš„å­—å…¸ï¼Œè¿™æ—¶æ²¡æœ‰ä»»ä½•å…ƒç´  map3 := map[string]string{} // å­—å…¸ä¸­æœ‰ä¸‰ä¸ªå€¼ map4 := map[string]string{\u0026#34;a\u0026#34;:\u0026#34;1\u0026#34;, \u0026#34;b\u0026#34;:\u0026#34;2\u0026#34;, \u0026#34;c\u0026#34;:\u0026#34;3\u0026#34;} ä»map1ä¸­åˆ é™¤key1ï¼Œç›´æ¥ä½¿ç”¨delete(map1, key1)å°±å¯ä»¥ã€‚ map1ï¼šè¡¨ç¤ºè¦åˆ é™¤é”®å€¼å¯¹çš„map key1ï¼šè¡¨ç¤ºè¦åˆ é™¤çš„é”®å€¼å¯¹çš„é”® å¦‚æœkey1ä¸å­˜åœ¨ï¼Œè¯¥æ“ä½œä¸ä¼šäº§ç”Ÿé”™è¯¯ // ä»å­—å…¸map4ä¸­åˆ é™¤é”®\u0026#34;a\u0026#34; delete(map4, \u0026#34;a\u0026#34;) 1 2 3 4 5 6 7 8 9 10 11 12 13 package main import \u0026#34;fmt\u0026#34; func main() { scoreMap := make(map[string]int) scoreMap[\u0026#34;one\u0026#34;] = 90 scoreMap[\u0026#34;two\u0026#34;] = 100 // ä»scoreMapä¸­åˆ é™¤é”®one delete(scoreMap, \u0026#34;one\u0026#34;) fmt.Println(scoreMap) // map[two:100] } å­—å…¸é»˜è®¤æ˜¯æ— åºçš„ï¼Œæ— è®ºæ˜¯æŒ‰ç…§keyè¿˜æ˜¯valueé»˜è®¤éƒ½ä¸æ’åºã€‚ å¦‚æœæƒ³ä¸ºå­—å…¸æ’åºï¼Œéœ€è¦å°†keyï¼ˆæˆ–è€…valueï¼‰å¤åˆ¶åˆ°ä¸€ä¸ªåˆ‡ç‰‡ï¼Œå†å¯¹åˆ‡ç‰‡æ’åºï¼ˆä½¿ç”¨sortåŒ…ï¼‰ã€‚ æŒ‰ç…§æŒ‡å®šé¡ºåºéå†map 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;math/rand\u0026#34; \u0026#34;sort\u0026#34; \u0026#34;strconv\u0026#34; \u0026#34;time\u0026#34; ) func main() { // åˆå§‹åŒ–éšæœºæ•°ç§å­ rand.Seed(time.Now().UnixNano()) var scoreMap = make(map[string]int, 200) // ç”Ÿæˆæ•°æ® for i := 0; i \u0026lt; 100; i++ { // ç”Ÿæˆ 0~99 çš„éšæœºæ•´æ•° key := \u0026#34;\u0026#34; if i \u0026lt; 10 { key = \u0026#34;0\u0026#34; + strconv.Itoa(i) } else { key = strconv.Itoa(i) } scoreMap[key] = rand.Intn(100) } // å–å‡ºmapä¸­çš„æ‰€æœ‰keyå­˜å…¥åˆ‡ç‰‡keys var keys = make([]string, 0, 200) for key := range scoreMap { // æŠŠmapçš„keyå­˜å…¥[]stringåˆ‡ç‰‡ keys = append(keys, key) } // å¯¹åˆ‡ç‰‡è¿›è¡Œæ’åº sort.Strings(keys) // æŒ‰ç…§æ’åºåçš„keyéå†map for _, key := range keys { fmt.Println(key, scoreMap[key]) } } å…ƒç´ ä¸ºmapç±»å‹çš„åˆ‡ç‰‡ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 package main import \u0026#34;fmt\u0026#34; func main() { var mapSlice = make([]map[string]string, 3) // å…ƒç´ mapä¸ºnilï¼Œéœ€è¦åˆå§‹åŒ– for index, value := range mapSlice { fmt.Printf(\u0026#34;index:%d value:%#v\\n\u0026#34;, index, value) } /* * index:0 value:map[string]string(nil) * index:1 value:map[string]string(nil) * index:2 value:map[string]string(nil) */ fmt.Println(\u0026#34;after init\u0026#34;) // å¯¹åˆ‡ç‰‡ä¸­çš„mapå…ƒç´ è¿›è¡Œåˆå§‹åŒ– å¹¶æŒ‡å®šå®¹é‡ä¸º10 mapSlice[0] = make(map[string]string, 10)\tfmt.Println(mapSlice, mapSlice[0]) // [map[] map[] map[]] map[] mapSlice[0][\u0026#34;name\u0026#34;] = \u0026#34;name\u0026#34; mapSlice[0][\u0026#34;password\u0026#34;] = \u0026#34;password\u0026#34; mapSlice[0][\u0026#34;address\u0026#34;] = \u0026#34;address\u0026#34; fmt.Println(mapSlice) // [map[address:address name:name password:password] map[] map[]] for index, value := range mapSlice { fmt.Printf(\u0026#34;index:%d value:%#v\\n\u0026#34;, index, value) } /* * index:0 value:map[address:address name:name password:password] * index:1 value:map[string]string(nil) * index:2 value:map[string]string(nil) */ } å€¼ä¸ºåˆ‡ç‰‡ç±»å‹çš„map 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 package main import \u0026#34;fmt\u0026#34; func main() { var sliceMap = make(map[string][]string, 3) fmt.Printf(\u0026#34;%#v\\n\u0026#34;, sliceMap) // map[string][]string{} fmt.Println(\u0026#34;after init\u0026#34;) // after init key := \u0026#34;ä¸­å›½\u0026#34; value, ok := sliceMap[key] fmt.Printf(\u0026#34;%#v, %#v\\n\u0026#34;, value, ok) // []string(nil), false if !ok { // åˆå§‹åŒ– åˆ‡ç‰‡[]string é•¿åº¦0 å®¹é‡2 value = make([]string, 0, 2) } // åˆ‡ç‰‡æ·»åŠ å…ƒç´  value = append(value, \u0026#34;åŒ—äº¬\u0026#34;, \u0026#34;ä¸Šæµ·\u0026#34;) sliceMap[key] = value fmt.Println(sliceMap) // map[ä¸­å›½:[åŒ—äº¬ ä¸Šæµ·]] } rangeè¯­å¥ä¸­çš„å€¼ åœ¨rangeè¯­å¥ä¸­ç”Ÿæˆçš„æ•°æ®çš„å€¼æ˜¯çœŸå®é›†åˆå…ƒç´ çš„å‰¯æœ¬ï¼Œä»–ä»¬ä¸æ˜¯åŸæœ‰å…ƒç´ çš„å¼•ç”¨ã€‚ æ„å‘³ç€æ›´æ–°è¿™äº›å€¼å°†ä¸ä¼šä¿®æ”¹åŸæ¥çš„æ•°æ®ï¼ŒåŒæ—¶ä¹Ÿæ„å‘³ç€ä½¿ç”¨è¿™äº›å€¼çš„åœ°å€å°†ä¸ä¼šå¾—åˆ°åŸæœ‰æ•°æ®çš„æŒ‡é’ˆã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 package main import ( \u0026#34;fmt\u0026#34; ) func main() { data := []int{1, 2, 3} for _, v := range data { v *= 10 } fmt.Println(\u0026#34;data:\u0026#34;, data) // data: [1 2 3] scoreMap := make(map[string]int) scoreMap[\u0026#34;one\u0026#34;] = 90 scoreMap[\u0026#34;two\u0026#34;] = 100 for k := range scoreMap { fmt.Println(k) } for k, v := range scoreMap { fmt.Println(k, v) } } /* data: [1 2 3] one two one 90 two 100 */ ä¿®æ”¹æ›´æ–°åŸæœ‰é›†åˆä¸­çš„æ•°æ®ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 package main import ( \u0026#34;fmt\u0026#34; ) func main() { data := []int{1, 2, 3} for i := range data { data[i] *= 10 } fmt.Println(\u0026#34;data:\u0026#34;, data) // data: [10 20 30] } ","permalink":"https://heliu.site/posts/golang/map/use/","summary":"Golang mapçš„ä½¿ç”¨ä»‹ç»ã€‚","title":"Map(ä½¿ç”¨)"},{"content":" æœ¬ç¯‡ä»‹ç»mapçš„golangæºç ï¼Œå…¨ç¯‡ä»£ç è¾ƒå¤šæ¯”è¾ƒæ¯ç‡¥ã€‚ map åŒ…è¯´æ˜ï¼š map åªæ˜¯ä¸€ä¸ª hash è¡¨ã€‚æ•°æ®è¢«å®‰æ’åœ¨æ¡¶æ•°ç»„ä¸­ã€‚æ¯ä¸ªæ¡¶æœ€å¤šåŒ…å«8ä¸ª key/elem å¯¹ã€‚ hash çš„low-order bits(hash\u0026amp;1\u0026lt;\u0026lt;B - 1)ç”¨äºé€‰æ‹©æ¡¶ã€‚æ¯ä¸ªæ¡¶åŒ…å« high-order bitsï¼ˆé«˜8ä½ï¼‰ç”¨äºåŒºåˆ†æ¯ä¸ªæ¡¶ä¸­çš„ entriesï¼ˆå°±æ˜¯tophashï¼‰ã€‚ å¦‚æœæœ‰è¶…è¿‡ 8 ä¸ª keysï¼Œhash åˆ°ä¸€ä¸ªæ¡¶ä¸­ï¼Œæˆ‘ä»¬å°†é¢å¤–çš„ extra æ¡¶é“¾æ¥èµ·æ¥ã€‚ å½“ hashtable å¢é•¿æ—¶ï¼Œæˆ‘ä»¬åˆ†é…ä¸€ä¸ªä¸¤å€å¤§å°çš„æ–°æ¡¶æ•°ç»„ã€‚æ¡¶ä¼šä»æ—§çš„æ¡¶æ•°ç»„æ¸è¿›å¼å¤åˆ¶åˆ°æ–°çš„æ¡¶æ•°ç»„ä¸­ã€‚ Map è¿­ä»£å™¨éå†æ¡¶æ•°ç»„ï¼Œå¹¶æŒ‰éå†é¡ºåºè¿”å›keysã€‚ï¼ˆå¸¸è§„æ¡¶åæ˜¯æŒ‰ç…§æº¢å‡ºæ¡¶çš„é¡ºåºè¿”å›æ¡¶ç´¢å¼•ï¼‰ ä¸ºäº†ç»´æŠ¤è¿­ä»£è¯­ä¹‰ï¼Œæˆ‘ä»¬ä»ä¸å°† keys ç§»åŠ¨åˆ°æ¡¶ä¸­(å¦‚æœç§»åŠ¨ï¼Œé”®å¯èƒ½ä¼šè¿”å›0æˆ–2æ¬¡)ã€‚ åœ¨å¢é•¿ table æ—¶ï¼Œè¿­ä»£å™¨ä»ç„¶åœ¨è¿­ä»£æ—§è¡¨ï¼Œå¹¶ä¸”å¿…é¡»æ£€æŸ¥æ–°è¡¨æ˜¯å¦å·²ç»ç§»åŠ¨(â€œevacuatedâ€)åˆ°æ–°è¡¨ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 // This file contains the implementation of Go\u0026#39;s map type. // // A map is just a hash table. The data is arranged // into an array of buckets. Each bucket contains up to // 8 key/elem pairs. The low-order bits of the hash are // used to select a bucket. Each bucket contains a few // high-order bits of each hash to distinguish the entries // within a single bucket. // // If more than 8 keys hash to a bucket, we chain on // extra buckets. // // When the hashtable grows, we allocate a new array // of buckets twice as big. Buckets are incrementally // copied from the old bucket array to the new bucket array. // // Map iterators walk through the array of buckets and // return the keys in walk order (bucket #, then overflow // chain order, then bucket index). To maintain iteration // semantics, we never move keys within their bucket (if // we did, keys might be returned 0 or 2 times). When // growing the table, iterators remain iterating through the // old table and must check the new table if the bucket // they are iterating through has been moved (\u0026#34;evacuated\u0026#34;) // to the new table. // Picking loadFactor: too large and we have lots of overflow // buckets, too small and we waste a lot of space. I wrote // a simple program to check some stats for different loads: // (64-bit, 8 byte keys and elems) // // Picking loadFactor: å¤ªå¤§ä¼šæœ‰å¾ˆå¤šæº¢å‡ºçš„æ¡¶ï¼Œå¤ªå°ä¼šæµªè´¹å¾ˆå¤šç©ºé—´ã€‚ // æˆ‘å†™äº†ä¸€ä¸ªç®€å•çš„ç¨‹åºæ¥æ£€æŸ¥ä¸åŒåŠ è½½çš„ä¸€äº›ç»Ÿè®¡ä¿¡æ¯:(64-bit, 8 byte keys and elems) // loadFactor %overflow bytes/entry hitprobe missprobe // 4.00 2.13 20.77 3.00 4.00 // 4.50 4.05 17.30 3.25 4.50 // 5.00 6.85 14.77 3.50 5.00 // 5.50 10.55 12.94 3.75 5.50 // 6.00 15.27 11.67 4.00 6.00 // 6.50 20.90 10.79 4.25 6.50 -- loadFactor = 13/2 // 7.00 27.14 10.15 4.50 7.00 // 7.50 34.03 9.73 4.75 7.50 // 8.00 41.10 9.40 5.00 8.00 // // %overflow = percentage of buckets which have an overflow bucket # æœ‰æº¢å‡ºæ¡¶çš„æ¡¶çš„ç™¾åˆ†æ¯” // bytes/entry = overhead bytes used per key/elem pair # æ¯ä¸ª key/elem å¯¹ä½¿ç”¨çš„å¼€é”€å­—èŠ‚æ•° // hitprobe = # of entries to check when looking up a present key # åœ¨æŸ¥æ‰¾å½“å‰é”®æ—¶è¦æ£€æŸ¥çš„æ¡ç›® // missprobe = # of entries to check when looking up an absent key # åœ¨æŸ¥æ‰¾ç¼ºå¤±é”®æ—¶è¦æ£€æŸ¥çš„æ¡ç›® // // Keep in mind this data is for maximally loaded tables, i.e. just // before the table grows. Typical tables will be somewhat less loaded. hmap ğŸš€ type hmap struct ç»“æ„è¯´æ˜ï¼šgoçš„mapä¸­å­˜å‚¨çš„æ˜¯hmapçš„æŒ‡é’ˆã€‚mapåˆ†é…çš„æ˜¯ä¸€å—è¿ç»­çš„å†…å­˜ï¼ŒåŒ…æ‹¬å¸¸è§„æ¡¶å’Œæº¢å‡ºæ¡¶çš„å†…å­˜ã€‚\ncountï¼šè®°å½•mapä¸­å­˜å‚¨çš„é”®å€¼å¯¹æ•°é‡ã€‚è¯¥å€¼ä¹Ÿæ˜¯len(map)è¿”å›å€¼ã€‚cap()å‡½æ•°å¯¹mapæ²¡æœ‰å®é™…ä½œç”¨ã€‚ flagsï¼šæ‰©å®¹ã€è¿­ä»£ç›¸å…³æ ‡å¿—ä½ã€‚ Bï¼šå¸¸è§„æ¡¶ä¸ªæ•°2^Bï¼Œæ­¤å¤„çš„Bæ˜¯å¹‚æ¬¡æ–¹ã€‚æ³¨æ„è¿™é‡Œå¹¶æ²¡æœ‰åŒ…æ‹¬æº¢å‡ºæ¡¶æ•°é‡ã€‚ noverflowï¼šå·²ä½¿ç”¨çš„æº¢å‡ºæ¡¶æ•°é‡ï¼Œè¯¥å€¼ç”¨äºç­‰é‡æ‰©å®¹çš„åˆ¤æ–­å€¼ã€‚ hash0ï¼šç”Ÿæˆçš„éšæœºå€¼ï¼Œæ‰©å®¹æ—¶å€™è¯¥å€¼ä¸ä¼šè¢«åˆ·æ–°ã€‚ä½†æ˜¯åœ¨åˆ é™¤æ—¶mapä¸ºç©ºæ—¶ä¼šåˆ·æ–°ã€‚ bucketsï¼šå¸¸è§„æ¡¶èµ·å§‹åœ°å€ã€‚ oldbucketsï¼šæ‰©å®¹æ—¶ç”¨äºå­˜å‚¨æ—§å¸¸è§„æ¡¶çš„èµ·å§‹åœ°å€ä¹Ÿå°±æ˜¯bucketsçš„å€¼ï¼Œå½“oldbuckets != nilæ—¶ä¹Ÿæ˜¯æ‰©å®¹æ­£åœ¨è¿›è¡Œçš„æ¡ä»¶ã€‚ nevacuateï¼šæ‰©å®¹æ­£åœ¨è¿›è¡Œä¸­ä¸‹ä¸€ä¸ªè¦è¢«è¿ç§»çš„æ—§æ¡¶ç¼–å·ã€‚ extraï¼šæº¢å‡ºæ¡¶ç›¸å…³ä¿¡æ¯ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 // A header for a Go map. type hmap struct { // Note: the format of the hmap is also encoded in cmd/compile/internal/gc/reflect.go. // Make sure this stays in sync with the compiler\u0026#39;s definition. // 1. å·²ç»å­˜å‚¨çš„é”®å€¼å¯¹ä¸ªæ•°ï¼Œlen(map) == count // 2. mapä¸èƒ½ä½¿ç”¨cap()å‡½æ•°ï¼Œcap()å‡½æ•°æ˜¯è®¡ç®—å®¹é‡ï¼Œå¯¹äºmapæ¥è¯´æ„ä¹‰ä¸å¤§ count int // # live cells == size of map. Must be first (used by len() builtin) flags uint8 // å½“å‰hmapçš„çŠ¶æ€ï¼Œæ¯”å¦‚æ­£å¤„äºå†™å…¥æ•°æ®ä¸­ç­‰ï¼Œå‚çœ‹ä¸‹é¢çš„å¸¸é‡ // ã€å¸¸è§„æ¡¶ã€‘ä¸ªæ•°ç­‰äº 2^Bï¼Œmake()åˆå§‹åŒ–æ—¶è¯¥å€¼ä¼šè¢«è®¾ç½®ï¼Œæ³¨æ„è¿™é‡Œå¹¶ã€æ²¡ç”¨ã€‘åŒ…å«æº¢å‡ºæ¡¶çš„æ•°é‡ B uint8 // log_2 of # of buckets (æœ€å¤šå¯ä»¥å®¹çº³ loadFactor * 2^B items) // å·²ä½¿ç”¨çš„æº¢å‡ºæ¡¶æ•°é‡ï¼Œç”¨äºæ˜¯å¦ç­‰é‡æ‰©å®¹åˆ¤æ–­ï¼Œåœ¨makeåˆå§‹åŒ–å’Œæ‰©å®¹åˆå§‹åŒ–æ—¶è¢«é‡ç½®ä¸º0 // å·²ä½¿ç”¨æº¢å‡ºæ¡¶çš„è®¡æ•°è§„åˆ™ï¼š // 1. å¸¸è§„æ¡¶ h.B \u0026lt;= 15 æ—¶ï¼Œæ¯ä½¿ç”¨äº†ä¸€ä¸ªæº¢å‡ºæ¡¶ h.noverflow++ // 2. å¸¸è§„æ¡¶ h.B \u0026gt; 16 æ—¶ï¼ŒæŒ‰ç…§ä¸€å®šæ¦‚ç‡å¢åŠ æº¢å‡ºæ¡¶ 1/((1 \u0026lt;\u0026lt; (h.B-15))-1) çš„æ¦‚ç‡ h.noverflow++ noverflow uint16 // approximate number of overflow buckets; see incrnoverflow for details // åœ¨makeåˆå§‹åŒ–æ—¶æ ¹æ®éšæœºæ•°ç”Ÿæˆ // hashéšæœºæ•°ï¼Œç”¨äºç”Ÿæˆkeyçš„hashå€¼ï¼Œmakeåˆå§‹åŒ–æ—¶è¯¥å€¼ä¼šè¢«è®¾ç½® hash0 uint32 // hash seed\t// å¸¸è§„æ¡¶èµ·å§‹åœ°å€ï¼Œmakeåˆå§‹åŒ–æ—¶è¯¥å€¼ä¼šè¢«è®¾ç½® // è¯¥å€¼ä¹Ÿè®¸ä¸ºnilï¼Œå½“count==0æ—¶ï¼Œåœ¨ã€[key] = elemã€‘æ—¶ä¼šåˆå§‹åŒ–åˆ†é…å†…å­˜ buckets unsafe.Pointer // array of 2^B Buckets. may be nil if count==0. // å½“å­˜åœ¨æ‰©å®¹æ—¶ä¼šæŠŠhmap.bucketså€¼æ‹·è´åˆ°hmap.oldbuckets // è¿™ä¹Ÿæ˜¯åˆ¤æ–­æ‰©å®¹çš„æ¡ä»¶ hmap.oldbuckets != nil oldbuckets unsafe.Pointer // previous bucket array of half the size, non-nil only when growing // è®°å½•ä¸‹ä¸€ä¸ªè¦è¢«è¿ç§»çš„æ—§æ¡¶ç¼–å·ï¼Œåœ¨æ‰©å®¹åˆå§‹åŒ–æ—¶è¢«é‡ç½®ä¸º0ï¼Œè¢«åˆ†æ‘Šåˆ°åˆ°æ¯æ¬¡mapæ“ä½œä¸­æ¸è¿›è¿ç§» nevacuate uintptr // progress counter for evacuation (buckets less than this have been evacuated) // makeåˆå§‹åŒ–æ—¶extra.nextOverflowæ”¹å€¼ä¼šè¢«è®¾ç½®ï¼Œè®°å½•æº¢å‡ºæ¡¶çš„é¦–åœ°å€ // æº¢å‡ºæ¡¶åˆ†é…è§„åˆ™å¸¸è§„æ¡¶ ã€h.B \u0026gt;= 4ã€‘ï¼Œå°±ä¼šé¢„åˆ†é… ã€h.B-4ã€‘ ä¸ªæº¢å‡ºæ¡¶å¤‡ç”¨ // extra ä¸»è¦æ˜¯è®°å½•åˆ†é…çš„å¤‡ç”¨ç©ºé—²æº¢å‡ºæ¡¶åœ°å€ extra.nextOverflowï¼Œä»¥åŠåˆ†é…è¿‡çš„æ— æŒ‡é’ˆæº¢å‡ºæ¡¶è®°å½•åœ¨extra.overflow extra *mapextra // optional fields\tæº¢å‡ºæ¡¶ä¿¡æ¯ ä»¥åŠ æ‰©å®¹ä¿¡æ¯ } createOverflow() åˆ›å»ºä¸€ä¸ª extra æˆ– extra.overflowã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 func (h *hmap) createOverflow() { if h.extra == nil {\th.extra = new(mapextra) } if h.extra.overflow == nil { // sliceå¤šé‡‡ç”¨make()åˆ›å»ºï¼Œè¿™é‡Œé‡‡ç”¨newåˆ›å»º // ä¹Ÿå°±æ˜¯åªæ˜¯åˆ›å»º24Bå¤§å°å†…å­˜ï¼Œ\u0026amp;slice{0,0,0} // åç»­overflowå­—æ®µä¼šé€šè¿‡append()å‡½æ•°æ·»åŠ å…ƒç´  // å½“bmapæ˜¯æŒ‡é’ˆç±»å‹æ—¶ï¼Œç”¨äºå­˜å‚¨æº¢å‡ºbmapï¼Œä»¥å…è¢«GCç»™å›æ”¶äº† h.extra.overflow = new([]*bmap) } } growing() åˆ¤æ–­å½“å‰mapæ˜¯å¦å¤„äºæ‰©å®¹çŠ¶æ€ï¼Œå¯èƒ½æ˜¯ç¿»å€æ‰©å®¹æˆ–ç­‰é‡æ‰©å®¹ã€‚ 1 2 3 4 // growing reports whether h is growing. The growth may be to the same size or bigger. func (h *hmap) growing() bool { return h.oldbuckets != nil // true.å¤„äºæ‰©å®¹çŠ¶æ€ } sameSizeGrow() sameSizeGrow è¡¨ç¤ºå½“å‰æ­£åœ¨å¤„äºç­‰é‡æ‰©å®¹çŠ¶æ€ã€‚ 1 2 3 4 // sameSizeGrow reports whether the current growth is to a map of the same size. func (h *hmap) sameSizeGrow() bool { return h.flags\u0026amp;sameSizeGrow != 0 // true.ç­‰é‡æ‰©å®¹ } noldbuckets() noldbuckets è®¡ç®—å½“å‰ map æ‰©å®¹ä¹‹å‰çš„å¸¸è§„æ¡¶æ•°ã€‚ 1 2 3 4 5 6 7 8 // noldbuckets calculates the number of buckets prior to the current map growth. func (h *hmap) noldbuckets() uintptr { oldB := h.B if !h.sameSizeGrow() { oldB-- } return bucketShift(oldB) // 1 \u0026lt;\u0026lt; B } oldbucketmask() å¸¸è§„æ¡¶æ‰©å®¹ä¹‹å‰çš„æ©ç æ•°ã€‚ 1 2 3 4 // oldbucketmask provides a mask that can be applied to calculate n % noldbuckets(). func (h *hmap) oldbucketmask() uintptr { return h.noldbuckets() - 1 // æ¡¶å¢é•¿ä¹‹å‰çš„æ©ç  } incrnoverflow() Incrnoverflow å¢åŠ  h.noverflowã€‚noverflow ç»Ÿè®¡æº¢å‡ºæ¡¶çš„æ•°é‡ã€‚ è¿™ç”¨äºè§¦å‘ç­‰é‡æ‰©å®¹å¤§å°çš„mapå¢é•¿ã€‚ç­‰é‡æ‰©å®¹æ¡ä»¶å‚çœ‹ tooManyOverflowBuckets æ–¹æ³•ã€‚ ä¸ºäº†ä¿æŒhmapè¾ƒå°ï¼Œnoverflowæ˜¯uint16ç±»å‹ã€‚ å½“æ¡¶å¾ˆå°‘æ—¶ï¼Œnoverflowæ˜¯ä¸€ä¸ªç²¾ç¡®çš„è®¡æ•°ã€‚å½“æœ‰å¾ˆå¤šæ¡¶æ—¶ï¼Œnoverflowæ˜¯ä¸€ä¸ªè¿‘ä¼¼çš„è®¡æ•°ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 // incrnoverflow increments h.noverflow. // noverflow counts the number of overflow buckets. // This is used to trigger same-size map growth. // See also tooManyOverflowBuckets. // To keep hmap small, noverflow is a uint16. // When there are few buckets, noverflow is an exact count. // When there are many buckets, noverflow is an approximate count. func (h *hmap) incrnoverflow() {\t// å¢åŠ ä½¿ç”¨çš„æº¢å‡ºæ¡¶è®¡æ•°å™¨ // We trigger same-size map growth if there are // as many overflow buckets as buckets. // We need to be able to count to 1\u0026lt;\u0026lt;h.B. // // å¦‚æœæº¢å‡ºæ¡¶å’Œå¸¸è§„æ¡¶ä¸€æ ·å¤šï¼Œæˆ‘ä»¬å°±ä¼šè§¦å‘ç­‰é‡æ‰©å®¹mapã€‚æˆ‘ä»¬éœ€è¦èƒ½å¤Ÿæ•°åˆ° 1\u0026lt;\u0026lt;h.Bã€‚ if h.B \u0026lt; 16 { // å½“æ¡¶çš„æ•°é‡ \u0026lt;= 2^15 æº¢å‡ºæ¡¶åŠ ä¸€ h.noverflow++ return } // Increment with probability 1/(1\u0026lt;\u0026lt;(h.B-15)). // When we reach 1\u0026lt;\u0026lt;15 - 1, we will have approximately // as many overflow buckets as buckets. // // ä»¥1/(1\u0026lt;\u0026lt;(h.B-15))æ¦‚ç‡é€’å¢åŠ ä¸€ mask := uint32(1)\u0026lt;\u0026lt;(h.B-15) - 1\t// Example: if h.B == 18, then mask == 7, // and fastrand \u0026amp; 7 == 0 with probability 1/8. if fastrand()\u0026amp;mask == 0 { h.noverflow++ } } newoverflow() åˆ†é…æ–°çš„æº¢å‡ºæ¡¶ï¼Œå¦‚æœå½“å‰æ¡¶æ»¡äº†åˆ™éœ€è¦åˆ†é…æº¢å‡ºæ¡¶è°ƒç”¨æ­¤æ–¹æ³•è¿”å›æº¢å‡ºæ¡¶ã€‚ è¯¥æ–¹æ³•æœ‰å¤‡ç”¨çš„æº¢å‡ºæ¡¶å·²ç”¨å®Œé‡æ–°åˆ†é…æº¢å‡ºæ¡¶æƒ…å†µã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 func (h *hmap) newoverflow(t *maptype, b *bmap) *bmap { var ovf *bmap // åˆ†é…çš„æº¢å‡ºæ¡¶ *bmap // å½“å‰æº¢å‡ºæ¡¶ä¿¡æ¯ä¸ä¸ºç©º å¹¶ä¸” ä¸‹ä¸€ä¸ªæº¢å‡ºæ¡¶ä¸ä¸ºç©º ç›´æ¥ä»åé¢è·å– if h.extra != nil \u0026amp;\u0026amp; h.extra.nextOverflow != nil {\t// We have preallocated overflow buckets available. // See makeBucketArray for more details. // // æˆ‘ä»¬æœ‰é¢„å…ˆåˆ†é…çš„æº¢å‡ºæ¡¶å¯ç”¨ã€‚æ›´å¤šç»†èŠ‚è¯·å‚è§makeBucketArrayæ–¹æ³•ã€‚ ovf = h.extra.nextOverflow // åˆ¤æ–­æº¢å‡ºæ¡¶çš„overflowå­—æ®µæ˜¯å¦ä¸ºnilï¼Œç”¨äºåˆ¤æ–­åˆ†é…çš„å¤‡ç”¨æº¢å‡ºæ¡¶ä½¿ç”¨å·²ç”¨å®Œ // å‚çœ‹makeBucketArrayæ–¹æ³•ä¸­æŠŠæœ€åä¸€ä¸ªæº¢å‡ºæ¡¶overflowæŒ‡å‘äº†ç¬¬ä¸€ä¸ªå¸¸è§„æ¡¶åœ°å€ if ovf.overflow(t) == nil { // We\u0026#39;re not at the end of the preallocated overflow buckets. Bump the pointer. // // æˆ‘ä»¬è¿˜æ²¡æœ‰åˆ°è¾¾é¢„åˆ†é…çš„æº¢å‡ºæ¡¶çš„æœ«å°¾ã€‚ç¢°ä¸€ä¸‹æŒ‡é’ˆã€‚ h.extra.nextOverflow = (*bmap)(add(unsafe.Pointer(ovf), uintptr(t.bucketsize)))\t// ä¸‹ä¸€ä¸ªç©ºé—²çš„æº¢å‡ºæ¡¶ } else { // å·²ç»æ˜¯æœ€åä¸€ä¸ªå¤‡ç”¨çš„æº¢å‡ºæ¡¶äº†ï¼ˆæœ€åä¸€ä¸ªæº¢å‡ºæ¡¶æŒ‡å‘äº†ç¬¬ä¸€ä¸ªå¸¸è§„æ¡¶ï¼Œå…¶ä»–æº¢å‡ºæ¡¶éƒ½åº”è¯¥æœªnilï¼‰ // This is the last preallocated overflow bucket. // Reset the overflow pointer on this bucket, // which was set to a non-nil sentinel value. // // è¿™æ˜¯æœ€åä¸€ä¸ªé¢„åˆ†é…çš„æº¢å‡ºæ¡¶ã€‚ // é‡ç½®æ­¤æ¡¶ä¸Šçš„æº¢å‡ºæŒ‡é’ˆï¼Œè¯¥æŒ‡é’ˆè¢«è®¾ç½®ä¸ºénilå“¨å…µå€¼ã€‚ ovf.setoverflow(t, nil) // ovf.overflow = nil h.extra.nextOverflow = nil } } else { // æº¢å‡ºæ¡¶ä»¥åˆ†é…å®Œäº† æˆ–è€… æ²¡æœ‰åˆ†é…æº¢å‡ºæ¡¶æ—¶ // æ³¨æ„ï¼šè¿™é‡Œç›´æ¥è°ƒç”¨new()å‡½æ•°åˆ†é…çš„ ovf = (*bmap)(newobject(t.bucket))\t} // å·²ä½¿ç”¨æº¢å‡ºæ¡¶è®¡æ•°å™¨ h.incrnoverflow()\t// æ¡¶ä¸åŒ…å«æŒ‡é’ˆ if t.bucket.ptrdata == 0 { h.createOverflow()\t// é˜²æ­¢ h.extra æˆ– h.extra.overflow æ²¡æœ‰åˆå§‹åŒ– // å°†åˆ†é…çš„æº¢å‡ºæ¡¶ä¿å­˜åœ¨h.extra.overflowä¸­ï¼Œä¸»è¦æ˜¯é˜²æ­¢è¿™éƒ¨åˆ†å†…å­˜ä¸è¯¥è¢«GCæ¸…ç†ï¼Œç»“æœè¢«æ¸…é™¤äº† *h.extra.overflow = append(*h.extra.overflow, ovf) } b.setoverflow(t, ovf) // b.overflow = ovf return ovf } type bmap struct bmap ç”¨æ¥è£… map çš„æ¡¶ã€‚ bmap å‰8å­—èŠ‚æ˜¯ tophash å€¼ï¼Œåé¢åˆ†åˆ«æ˜¯8ä¸ªè¿ç»­çš„ key å’Œ8ä¸ªè¿ç»­çš„ value ç„¶åæ˜¯ä¸€ä¸ªæº¢å‡ºæ¡¶æŒ‡é’ˆã€‚ ä¹‹æ‰€ä»¥æ¡¶æŒ‰ç…§è¿™ä¸ªç»“æ„è®¾è®¡æ˜¯ä¸ºäº†å†…å­˜ç´§å‡‘ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 // A bucket for a Go map. type bmap struct { // tophash generally contains the top byte of the hash value // for each key in this bucket. If tophash[0] \u0026lt; minTopHash, // tophash[0] is a bucket evacuation state instead. // // Tophashé€šå¸¸åŒ…å«è¯¥æ¡¶ä¸­æ¯ä¸ªé”®çš„æ•£åˆ—å€¼çš„é¡¶éƒ¨å­—èŠ‚ã€‚ // å¦‚æœtophash[0] \u0026lt; minTopHashï¼Œåˆ™tophash[0]ä¸ºæ¡¶ç–æ•£çŠ¶æ€ã€‚ // const minTopHash = 5 // const bucketCnt = 8; tophash [bucketCnt]uint8 // [8]uint8 // Followed by bucketCnt keys and then bucketCnt elems. // NOTE: packing all the keys together and then all the elems together makes the // code a bit more complicated than alternating key/elem/key/elem/... but it allows // us to eliminate padding which would be needed for, e.g., map[int64]int8. // Followed by an overflow pointer. // // æ¥ä¸‹æ¥æ˜¯bucketCntçš„keysï¼Œç„¶åæ˜¯bucketCntçš„elemsã€‚ // æ³¨æ„: å°†æ‰€æœ‰keyæ‰“åŒ…åœ¨ä¸€èµ·ï¼Œç„¶åå°†æ‰€æœ‰elemæ‰“åŒ…åœ¨ä¸€èµ· // è¿™æ¯”äº¤æ›¿ä½¿ç”¨key/elem/key/elem/â€¦ä½†å®ƒå…è®¸æˆ‘ä»¬æ¶ˆé™¤æ‰€éœ€çš„å†…è¾¹è·ï¼Œä¾‹å¦‚ map[int64]int8ã€‚ // åè·Ÿä¸€ä¸ªæº¢å‡ºæŒ‡é’ˆã€‚ } bmap ç»“æ„ï¼š h1 - h8ï¼š8ä¸ªhashå€¼åˆ†åˆ«æ˜¯keyçš„hashé«˜å…«ä½ï¼Œä¸»è¦ç”¨äºå¿«é€ŸæŸ¥æ‰¾keyå’Œbmapæ¡¶çš„ç›¸å…³è¿ç§»çŠ¶æ€æ ‡è®°ã€‚ k1 - k8ï¼š8ä¸ªkeyçš„å€¼ã€‚ v1 - v8ï¼š8ä¸ªvalueçš„å€¼ã€‚ overflowï¼šæŒ‡å‘åé¢æº¢å‡ºæ¡¶çš„æŒ‡é’ˆã€‚ evacuated() è¯¥ bmap æ¡¶æ˜¯å¦æ˜¯ç–æ•£çš„ï¼Œ1 \u0026lt; tophash[0] \u0026lt; 5ï¼Œè¡¨æ˜è¯¥ bmap æ¡¶æ•°æ®å·²è¢«è¿ç§»ã€‚ 1 2 3 4 5 6 7 8 func evacuated(b *bmap) bool { h := b.tophash[0] // å‚çœ‹åé¢ consts ä¸­ç›¸å…³å¸¸é‡å®šä¹‰ // const emptyOne = 1 // const minTopHash = 5 // return h IN (2,3,4) return h \u0026gt; emptyOne \u0026amp;\u0026amp; h \u0026lt; minTopHash } overflow() è¯¥ bmap æ¡¶çš„ overflow å­—æ®µæŒ‡å‘çš„æº¢å‡ºæ¡¶ *bmapã€‚ 1 2 3 4 func (b *bmap) overflow(t *maptype) *bmap { // b + bucketsize - goarch.PtrSize return *(**bmap)(add(unsafe.Pointer(b), uintptr(t.bucketsize)-goarch.PtrSize)) } setoverflow() è¯¥ bmap æ¡¶çš„ overflow å­—æ®µæŒ‡å‘ ovf *bmap è¿™ä¸ªæ¡¶ã€‚ ç­‰ä»·äº bmap.overflow = ovf ã€‚ 1 2 3 4 func (b *bmap) setoverflow(t *maptype, ovf *bmap) { // bmap.overflow = ovf *(**bmap)(add(unsafe.Pointer(b), uintptr(t.bucketsize)-goarch.PtrSize)) = ovf } keys() è¿”å›è¯¥ bmap æ¡¶çš„ key å¼€å§‹åœ°å€ã€‚ 1 2 3 4 5 func (b *bmap) keys() unsafe.Pointer { // dataOffset å‚çœ‹åé¢ consts ä¸­çš„å¸¸é‡å®šä¹‰ // dataOffset -\u0026gt; [8]uint8 return add(unsafe.Pointer(b), dataOffset) } type mapextra struct Mapextra æŒæœ‰ä¸€äº›åœ¨æ‰€æœ‰mapä¸­éƒ½ä¸å­˜åœ¨çš„å­—æ®µã€‚ä¸»è¦æ˜¯æº¢å‡ºæ¡¶ç›¸å…³ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 // mapextra holds fields that are not present on all maps. type mapextra struct { // If both key and elem do not contain pointers and are inline, then we mark bucket // type as containing no pointers. This avoids scanning such maps. // However, bmap.overflow is a pointer. In order to keep overflow buckets // alive, we store pointers to all overflow buckets in hmap.extra.overflow and hmap.extra.oldoverflow. // overflow and oldoverflow are only used if key and elem do not contain pointers. // overflow contains overflow buckets for hmap.buckets. // oldoverflow contains overflow buckets for hmap.oldbuckets. // The indirection allows to store a pointer to the slice in hiter. // // å¦‚æœ key å’Œ elem éƒ½ä¸åŒ…å«æŒ‡é’ˆå¹¶ä¸”æ˜¯å…è®¸å†…è”(inline)çš„ï¼Œé‚£ä¹ˆæˆ‘ä»¬å°†bucketç±»å‹æ ‡è®°ä¸ºã€ä¸åŒ…å«æŒ‡é’ˆã€‘ã€‚è¿™æ ·é¿å…äº†æ‰«æè¿™æ ·çš„mapã€‚ // ç„¶è€Œ bmap.overflow æ˜¯ä¸€ä¸ªæŒ‡é’ˆã€‚ // ä¸ºäº†ä¿æŒoverflowæ¡¶æ˜¯alive(æ´»è·ƒçš„ä¸è¢«GCå›æ”¶)ï¼Œæˆ‘ä»¬å°†æŒ‡å‘æ‰€æœ‰overflowæ¡¶çš„æŒ‡é’ˆå­˜å‚¨åœ¨hmap.extra.overflowå’Œhmap.extra.oldoverflowä¸­ // ã€ä»…å½“ key å’Œ elem ä¸åŒ…å«æŒ‡é’ˆæ—¶ï¼Œæ‰ä½¿ç”¨ overflow å’Œ oldoverflowã€‚ã€‘å› ä¸ºä¸åŒ…å«æŒ‡é’ˆæ‰å®¹æ˜“è¢«GCå›æ”¶ï¼Œå› æ­¤éœ€è¦ä¿å­˜ã€‚ // overflow åŒ…å«ç”¨äº hmap.buckets çš„overflowæ¡¶é›† // oldoverflow åŒ…å«ç”¨äº hmap.oldbuckets çš„overflowæ¡¶é›† // é—´æ¥å…è®¸åœ¨hiterä¸­å­˜å‚¨ä¸€ä¸ªæŒ‡å‘åˆ‡ç‰‡çš„æŒ‡é’ˆã€‚(hiteræ˜¯éå†ç›¸å…³ç»“æ„) overflow *[]*bmap // åœ¨ key å’Œ elem ä¸åŒ…å«æŒ‡é’ˆæ—¶ï¼ŒæŠŠå·²ç»ç”¨åˆ°çš„æº¢å‡ºæ¡¶å­˜å‚¨èµ·æ¥ï¼Œä¸»è¦æ˜¯ä¿å­˜ alive oldoverflow *[]*bmap // æ‰©å®¹æ­£åœ¨è¿›è¡Œæ—¶ï¼ŒæŠŠ overflow æ•°æ®æ‹·è´åˆ°è¿™é‡Œ // nextOverflow holds a pointer to a free overflow bucket. // // nextOverflowä¿å­˜äº†ä¸€ä¸ªæŒ‡å‘ç©ºé—²æº¢å‡ºæ¡¶çš„æŒ‡é’ˆã€‚ // ä¸‹ä¸€ä¸ªå°šæœªä½¿ç”¨çš„æº¢å‡ºæ¡¶ï¼Œè¿™é‡Œæ¡¶ä¹‹é—´æ˜¯ä¸€ä¸ªé“¾è¡¨é“¾æ¥æ‰€æœ‰çš„æº¢å‡ºæ¡¶ã€‚ // è¯¥å€¼åœ¨makeå‡½æ•°ä¸­è¢«è®¾ç½®æˆç”³è¯·çš„é¦–ä¸ªæº¢å‡ºæ¡¶ nextOverflow *bmap\t} constant 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 const ( // Maximum number of key/elem pairs a bucket can hold. // // ä¸€ä¸ªæ¡¶å¯ä»¥å®¹çº³çš„æœ€å¤§ key/elem å¯¹æ•°é‡ bucketCntBits = 3 bucketCnt = 1 \u0026lt;\u0026lt; bucketCntBits // 2^3 = 8 // Maximum average load of a bucket that triggers growth is 6.5. // Represent as loadFactorNum/loadFactorDen, to allow integer math. // // è§¦å‘å¢é•¿çš„æ¡¶çš„æœ€å¤§å¹³å‡è´Ÿè½½ä¸º13/2 = 6.5ã€‚ // è¡¨ç¤ºä¸º loadFactorNum/loadFactorDen ï¼Œå…è®¸è¿›è¡Œæ•´æ•°è¿ç®—ã€‚ loadFactorNum = 13 // loadFactorNum/loadFactorDen = 6.5 loadFactorDen = 2 // Maximum key or elem size to keep inline (instead of mallocing per element). // Must fit in a uint8. // Fast versions cannot handle big elems - the cutoff size for // fast versions in cmd/compile/internal/gc/walk.go must be at most this elem. // // ä¿å­˜inlineçš„æœ€å¤§ key æˆ– elem å¤§å°(è€Œä¸æ˜¯ä¸ºæ¯ä¸ªå…ƒç´ åˆ†é…å†…å­˜) // å¿…é¡»é€‚é…åœ¨uint8ä¸­ã€‚å¿«é€Ÿç‰ˆæœ¬ä¸èƒ½å¤„ç†å¤§å…ƒç´ -åœ¨cmd/compile/internal/gc/walkä¸­å¿«é€Ÿç‰ˆæœ¬çš„æˆªæ­¢å¤§å°ã€‚Goæœ€å¤šåªèƒ½æ˜¯è¿™ä¸ªelemã€‚ maxKeySize = 128 // mapé”®æœ€å¤§å†…å­˜å€¼ 128Bï¼Œè¶…è¿‡è¯¥å€¼åˆ™æ˜¯æ¡¶çš„keyæ˜¯é—´æ¥å­˜å‚¨çš„ï¼Œä¹Ÿå°±æ˜¯åªæ˜¯å­˜å‚¨çš„æ˜¯æŒ‡é’ˆ maxElemSize = 128 // mapå€¼æœ€å¤§å†…å­˜å€¼ 128Bï¼Œè¶…è¿‡è¯¥å€¼åˆ™æ˜¯æ¡¶çš„elemæ˜¯é—´æ¥å­˜å‚¨çš„ï¼Œä¹Ÿå°±æ˜¯åªæ˜¯å­˜å‚¨çš„æ˜¯æŒ‡é’ˆ // data offset should be the size of the bmap struct, but needs to be // aligned correctly. For amd64p32 this means 64-bit alignment // even though pointers are 32 bit. // // dataOffset æ˜¯bmapç»“æ„ä½“çš„é•¿åº¦ï¼Œä½†éœ€è¦æ­£ç¡®å¯¹é½ // å¯¹äºamd64p32ï¼Œè¿™æ„å‘³ç€å³ä½¿æŒ‡é’ˆæ˜¯32ä½ï¼Œä¹Ÿä¼šè¿›è¡Œ64ä½å¯¹é½ã€‚ dataOffset = unsafe.Offsetof(struct { b bmap // 8B v int64 // 8B }{}.v) // dataOffset = 8B bmapæ¡¶çš„ç¬¬ä¸€ä¸ªkeyåç§»é‡ // Possible tophash values. We reserve a few possibilities for special marks. // Each bucket (including its overflow buckets, if any) will have either all or none of its // entries in the evacuated* states (except during the evacuate() method, which only happens // during map writes and thus no one else can observe the map during that time). // // å¯èƒ½çš„ tophash å€¼ã€‚æˆ‘ä»¬ä¿ç•™ä¸€äº›ç‰¹æ®Šæ ‡è®°çš„å¯èƒ½æ€§ã€‚ // æ¯ä¸ªæ¡¶(åŒ…æ‹¬å®ƒçš„æº¢å‡ºæ¡¶ï¼Œå¦‚æœæœ‰çš„è¯)çš„æ‰€æœ‰æ¡ç›®éƒ½å°†å¤„äº evacuated* çŠ¶æ€(é™¤éåœ¨ä½¿ç”¨evacuate()æ–¹æ³•æ—¶ï¼Œè¿™ç§æƒ…å†µåªå‘ç”Ÿåœ¨mapå†™æ“ä½œæœŸé—´ï¼Œ // å› æ­¤ï¼Œåœ¨è¿™æ®µæ—¶é—´å†…ï¼Œæ²¡æœ‰å…¶ä»–äººå¯ä»¥è§‚å¯Ÿmap)ã€‚ // å½“å‰æ ¼ä¸ºç©ºçš„é»˜è®¤çŠ¶æ€ï¼Œåé¢æ ¼éƒ½ä¸ºç©ºä¸å­˜åœ¨å…¶ä»–æ•°æ® emptyRest = 0 // this cell is empty, and there are no more non-empty cells at higher indexes or overflows. // å½“å‰æ ¼ä¸ºç©ºï¼Œåé¢æ ¼è¿˜å­˜åœ¨å…¶ä»–æ•°æ®ã€‚åœ¨å½“å‰æ ¼è¢«åˆ é™¤æ—¶ä¼šè¢«æ ‡è®°ä¸º1 emptyOne = 1 // this cell is empty // key/elemæ˜¯æœ‰æ•ˆçš„ï¼Œentryå·²è¢«ç–æ•£åˆ°ç¿»å€åçš„æ–°æ¡¶é‡Œï¼ŒåŸæ¥çš„æ¡¶å·å¤„ evacuatedX = 2 // key/elem is valid. Entry has been evacuated to first half of larger table. // key/elemæ˜¯æœ‰æ•ˆçš„ï¼Œentryå·²è¢«ç–æ•£åˆ°ç¿»å€åçš„æ–°æ¡¶é‡Œï¼ŒåŸæ¥æ¡¶å·çš„2å€å¤„ evacuatedY = 3 // same as above, but evacuated to second half of larger table. // å•å…ƒæ ¼æ˜¯ç©ºçš„ã€‚åœ¨æ‰©å®¹è¿›è¡Œä¸­è¢«æ ‡è®°ä» 0æˆ–1æ ‡è®°ä¸º4 evacuatedEmpty = 4 // cell is empty, bucket is evacuated. // æ­£å¸¸å¡«å……å•å…ƒæ ¼çš„æœ€å°å€¼ï¼Œæ¯”å¦‚æŸä¸ªkeyè®¡ç®—åçš„hashå€¼ä¸º0åˆ™å¡«å……ä¸º5ã€‚ minTopHash = 5 // minimum tophash for a normal filled cell. // flags // å¯èƒ½æœ‰ä¸€ä¸ªä½¿ç”¨bucketsçš„è¿­ä»£å™¨ iterator = 1 // there may be an iterator using buckets // å¯èƒ½æœ‰ä¸€ä¸ªä½¿ç”¨oldbucketsçš„è¿­ä»£å™¨ oldIterator = 2 // there may be an iterator using oldbuckets // ä¸€ä¸ªgoroutineæ­£åœ¨å‘mapå†™å…¥æ•°æ®ï¼Œç”¨äºåˆ¤æ–­mapæ˜¯å¦åœ¨è¯»å†™åˆ é™¤å¹¶å‘æ“ä½œ // åœ¨m[key] = elemæ—¶è¢«è®¾ç½®æˆ–åœ¨deleteåˆ é™¤keyæ—¶è¢«è®¾ç½® hashWriting = 4 // a goroutine is writing to the map // ç­‰é‡æ‰©å®¹æ ‡å¿—ä½ sameSizeGrow = 8 // the current map growth is to a new map of the same size // sentinel bucket ID for iterator checks // è¿­ä»£å™¨æ£€æŸ¥çš„å“¨å…µæ¡¶IDï¼Œå¦‚æœæ¡¶å·ä¸ºè¯¥å€¼ä¸éœ€è¦æ£€æŸ¥ // è¿­ä»£å™¨ç›¸å…³ï¼Œåœ¨æ‰©å®¹è¿›è¡Œä¸­è¿­ä»£å™¨ç”¨äºæ£€æŸ¥çš„æ¡¶å· noCheck = 1\u0026lt;\u0026lt;(8*goarch.PtrSize) - 1\t) type maptype struct map å…ƒç±»å‹ï¼Œruntime/type.goã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 type maptype struct { typ _type // mapç±»å‹ key *_type // keyç±»å‹ elem *_type // elemç±»å‹ // æ¡¶çš„ç±»å‹ï¼Œæ¡¶åŒ…å«tophashsã€keysã€elemsã€overflowè¿™å››å— // ç”±äºkey/elemæ˜¯ä¸ç¡®å®šçš„ç±»å‹ï¼Œæ‰€ä»¥bucketä¹Ÿæ˜¯ä¸åŒçš„ç±»å‹ // bucketæ˜¯å¦åŒ…å«æŒ‡é’ˆç±»å‹ï¼Œæ˜¯å–å†³äºè¯¥ç»“æ„ä¸­æ˜¯å¦å­˜åœ¨æŒ‡é’ˆ //\t1. tophashs æ˜¯éæŒ‡é’ˆ // 2. keysã€elems æ˜¯æ ¹æ®å…·ä½“æƒ…å†µçš„ // 3. overflow æ˜¯ä¸ªæŒ‡é’ˆï¼Œé‚£ä¹ˆæ˜¯å¦æ„å‘³åˆ™bucketæ˜¯å¦åŒ…å«æŒ‡é’ˆç±»å‹? // å…¶å®bucketæ˜¯å¦åŒ…å«æŒ‡é’ˆç±»å‹æ˜¯æ ¹æ®keysã€elemså†³å®šçš„ï¼ŒåŸå› æ˜¯overflowæ˜¯ç”¨æˆ·æ“ä½œä¸åˆ°çš„ // å› æ­¤å¤„ç†è¿™ä¸ªç‰¹æ®Šæƒ…å†µæ—¶ï¼Œé‡‡ç”¨äº†éæŒ‡é’ˆå½¢å¼é‡‡ç”¨mapextraç»“æ„ä¿å­˜æº¢å‡ºæ¡¶æ•°æ®ï¼Œä»¥ä¾¿ä¸è¢«GCå›æ”¶ bucket *_type // internal type representing a hash bucket // function for hashing keys (ptr to key, seed) -\u0026gt; hash // hashå‡½æ•°ï¼Œç”¨äº(key, h.hash0) hasher func(unsafe.Pointer, uintptr) uintptr\t// size of key slot keysize uint8 // keyå€¼å¤§å° // size of elem slot elemsize uint8 // valueå€¼å¤§å° // size of bucket bucketsize uint16 // æ¡¶å¤§å° flags uint32 // mapçš„æ ‡å¿—ä½ } indirectkey() å½“ key å¤§äº128Bæ—¶keyå­˜çš„æ˜¯å®ƒçš„æŒ‡é’ˆï¼Œkey æ˜¯å¦æ˜¯é—´æ¥å­˜å‚¨çš„ã€‚é‡‡ç”¨è¿™ç§é—´æ¥å­˜å‚¨æ˜¯ä¸ºäº†æ»¡è¶³GCçš„ä½å›¾ã€‚ ä¸€ä¸ªæ¡¶æœ€å¤šæ”¯æŒ bucketSize*(1+maxKeySize+maxValSize)+ptrSize å­—èŠ‚ï¼Œå³2064å­—èŠ‚ï¼Œæˆ–258ä¸ªæŒ‡é’ˆå¤§å°çš„å­—ï¼Œæˆ–33å­—èŠ‚çš„æŒ‡é’ˆä½å›¾ã€‚ å› ä¸ºé”®å’Œå€¼éƒ½å°äº128å­—èŠ‚ï¼Œæ‰€ä»¥å¯ä»¥ä¿è¯å®ƒä»¬æœ‰ä½å›¾è€Œä¸æ˜¯GCç¨‹åºã€‚ 1 2 3 4 5 6 // Note: flag values must match those used in the TMAP case // in ../cmd/compile/internal/reflectdata/reflect.go:writeType. func (mt *maptype) indirectkey() bool { // store ptr to key instead of key itself // flags = 1ï¼škeyå ç”¨å†…å­˜å¤§äº 128B return mt.flags\u0026amp;1 != 0\t} indirectelem() å½“elemå¤§äº128Bæ—¶keyå­˜çš„æ˜¯å®ƒçš„æŒ‡é’ˆï¼Œelemæ˜¯å¦æ˜¯é—´æ¥å­˜å‚¨çš„ã€‚ 1 2 3 4 func (mt *maptype) indirectelem() bool { // store ptr to elem instead of elem itself // flags = 2ï¼šelemå ç”¨å†…å­˜å¤§äº 128B return mt.flags\u0026amp;2 != 0\t} reflexivekey() map keyæ˜¯NaNæ—¶ï¼Œåˆ¤æ–­ key æ»¡è¶³ x == x æˆç«‹? x != x æˆç«‹æƒ…å†µï¼š float32ã€float64ã€complex64ã€complex128ï¼ˆå½“ä¸ºNaNæ—¶ï¼‰ã€‚ anyï¼šå­˜å‚¨çš„æ˜¯ NaN æ—¶ã€‚ Array æ—¶åˆ¤æ–­æ•°ç»„çš„å…ƒç´ ç±»å‹ã€‚åˆ‡ç‰‡ä¸èƒ½ä½œä¸ºmapçš„keyå› æ­¤æ’é™¤ã€‚ String æ—¶ï¼Œåˆ¤æ–­å­—æ®µç±»å‹ã€‚ æ ¹æ® IEEE754 æ ‡å‡†ï¼Œå½“æµ®ç‚¹æ•°çš„æŒ‡æ•°ä½å…¨ä¸º1æ—¶ï¼Œè¯¥æ•°å¤„äºéæ­£å¸¸æ˜¯æ ‡å‡†å¤šç”¨äºè¡¨ç¤ºæ­£æ— ç©·å¤§æˆ–è´Ÿæ— ç©·å¤§åŠNaNï¼Œå› æ­¤å…¶ä»–ä½å¯èƒ½æ˜¯ä¸åŒçš„æ•°å€¼ã€‚ x != x æƒ…å†µæ˜¯ä¼šå½±å“hashï¼Œå› æ­¤NaNçš„ä½å€¼ä¸ä¸€å®šå…¨éƒ¨ç›¸ç­‰ã€‚ 1 2 3 4 func (mt *maptype) reflexivekey() bool { // true if k==k for all keys // flags = 4ï¼šè¯´æ˜ x == xå§‹ç»ˆæ˜¯æˆç«‹çš„ return mt.flags\u0026amp;4 != 0\t} needkeyupdate() map keyçš„å€¼éœ€è¦æ›´æ–°ï¼Œè¿™ç§æƒ…å†µå‡ºç°åœ¨ key == keyï¼Œä½†æ˜¯ key ç”Ÿæˆçš„ hash å¯èƒ½ä¸ç›¸åŒï¼Œè¿™ä¼šå½±å“åˆ° tophash å­˜å‚¨å€¼ã€‚ éœ€è¦æ›´æ–°çš„ç±»å‹ï¼š float32ã€float64ã€complex64ã€complex128ï¼ˆfloats and complex can be +0/-0ï¼‰ã€‚ æµ®ç‚¹æ•°å’Œå¤æ•°å¯ä»¥æ˜¯+0/-0ï¼Œæµ®ç‚¹æ•°ä¸­è¿™ä¸¤ä¸ªæ•°ä¿å­˜çš„ç¬¦å·ä½æ˜¯ä¸åŒå¾—ï¼Œä½†æ˜¯æ¯”è¾ƒè¿™ä¸¤ä¸ªæ•°ç¡®å®æ˜¯ç›¸ç­‰çš„ã€‚ any ç”±äº any èƒ½å­˜å‚¨ä»»ä½•ç±»å‹ï¼Œæ‰€æœ‰å¯ä»¥å­˜å‚¨æµ®ç‚¹æ•°ç­‰å› æ­¤ä¹Ÿéœ€è¦æ›´æ–°ã€‚ stringï¼šï¼ˆstrings might have smaller backing storesï¼‰ å­—ç¬¦ä¸²å¯èƒ½æœ‰è¾ƒå°çš„åå¤‡å­˜å‚¨å™¨ Array ç±»å‹æ—¶åˆ¤æ–­æ•°ç»„å…ƒç´ ï¼Œå¯èƒ½æ˜¯ä¸Šé¢ç±»å‹ã€‚ Struct æ—¶åˆ¤æ–­ç»“æ„ä½“çš„å…ƒç´ ï¼Œå¯èƒ½æ˜¯ä¸Šé¢ç±»å‹ã€‚ 1 2 3 4 func (mt *maptype) needkeyupdate() bool { // true if we need to update key on an overwrite // flags = 8ï¼šéœ€è¦æ›´æ–°slotçš„key return mt.flags\u0026amp;8 != 0\t} hashMightPanic() key ç”Ÿæˆ hash å¯èƒ½å‘ç”Ÿ panicï¼Œè¿™æ˜¯ç”±äºsliceã€mapã€functionä¸èƒ½ä½œä¸ºmap keyï¼Œè€Œanyå¯ä»¥å­˜å‚¨ä»»ä½•ç±»å‹ã€‚ å­˜åœ¨å¯èƒ½çš„ç±»å‹ï¼š anyã€sliceã€mapã€function; å½“anyå­˜å‚¨çš„sliceæˆ–mapæˆ–functionæ—¶å°±ä¼španicã€‚ Array ç±»å‹æ—¶åˆ¤æ–­æ•°ç»„çš„å…ƒç´ ï¼Œè¯¥å…ƒç´ æ—¶sliceæˆ–mapæˆ–åŒ…å«å®ƒä»¬éƒ½ä¼španicã€‚Slice ä¸èƒ½ä½œä¸ºkeyã€‚ Struct ç±»å‹æ—¶åˆ¤æ–­ç»“æ„ä½“çš„å…ƒç´ ï¼Œè¯¥å…ƒç´ æ—¶sliceæˆ–mapæˆ–åŒ…å«å®ƒä»¬éƒ½ä¼španicã€‚ ä½†æ˜¯å¦‚æœæ˜¯å®ƒä»¬ç±»å‹çš„æŒ‡é’ˆåˆ™ä¸ä¼šå‘ç”Ÿpanicã€‚ 1 2 3 4 func (mt *maptype) hashMightPanic() bool { // true if hash function might panic // flags = 16ï¼škeyç”Ÿæˆhashå¯èƒ½panicçš„ return mt.flags\u0026amp;16 != 0\t} make() ğŸš€ makemap() å®ç°ä¸º make(map[k]v, hint) åˆ›å»º Go mapã€‚ å¦‚æœç¼–è¯‘å™¨å·²ç»ç¡®å®šå¯ä»¥åœ¨æ ˆä¸Šåˆ›å»ºmapæˆ–ç¬¬ä¸€ä¸ªbucketï¼Œh and/or bucket å¯èƒ½æ˜¯ non-nilã€‚ å¦‚æœ h != nilï¼Œåˆ™å¯ä»¥ç›´æ¥åœ¨hä¸­åˆ›å»ºmapã€‚ å¦‚æœ h.buckets != nilï¼Œåˆ™æŒ‡å‘çš„æ¡¶å¯ä»¥ç”¨ä½œç¬¬ä¸€ä¸ªæ¡¶ã€‚ å‚æ•°ï¼š t *maptypeï¼šmap çš„å…ƒç±»å‹ã€‚ hint intï¼škey/elemå¯¹çš„æ•°é‡ï¼Œä¸æ˜¯æ¡¶çš„æ•°é‡ã€‚hintèƒ½ä¿è¯ä¸€å®šèƒ½å­˜å‚¨key/elemå¯¹æ•°æ®è€Œä¸æ‰©å®¹ã€‚ h *hmapï¼šmap æŒ‡é’ˆï¼Œå¯èƒ½æ˜¯ nil æˆ– non-nilã€‚ è¿”å›å€¼ï¼š *hmapï¼šç”Ÿæˆçš„ map çš„å€¼ï¼Œä¹Ÿå°±æ˜¯ *hmapã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 // makemap implements Go map creation for make(map[k]v, hint). // If the compiler has determined that the map or the first bucket // can be created on the stack, h and/or bucket may be non-nil. // If h != nil, the map can be created directly in h. // If h.buckets != nil, bucket pointed to can be used as the first bucket. func makemap(t *maptype, hint int, h *hmap) *hmap { // MulUintptr è¿”å› a * b ä»¥åŠä¹˜æ³•æ˜¯å¦æº¢å‡º // mem = uintptr(hint) * t.bucket.size // è¿™é‡Œä½¿ç”¨ key/elem å¯¹ä¹˜ä¸Š æ¡¶å¤§å° æ˜¾ç¤ºæ˜¯åœ¨æ‰©å¤§è®¡ç®—å†…å­˜ï¼Œå› ä¸º hint ä¸€å®šæ˜¯å¤§äº æ¡¶çš„æ•°é‡çš„ mem, overflow := math.MulUintptr(uintptr(hint), t.bucket.size) if overflow || mem \u0026gt; maxAlloc { hint = 0 } // initialize Hmap if h == nil { // åˆå§‹åŒ– hmap // æ³¨æ„è¿™é‡Œä½¿ç”¨äº†newå‡½æ•°åˆ›å»ºçš„ h = new(hmap)\t} // ç”Ÿæˆä¸€ä¸ªéšæœºæ•°ç”¨äºåç»­keyçš„hashï¼Œè¯¥å€¼åœ¨æ¡¶æ¯æ¬¡æ¸…ç©ºæ—¶è¯¥å€¼ä¼šä»æ–°ç”Ÿæˆéšæœºå€¼ h.hash0 = fastrand() // Find the size parameter B which will hold the requested # of elements. // For hint \u0026lt; 0 overLoadFactor returns false since hint \u0026lt; bucketCnt. // // æ‰¾åˆ°å‚æ•°Bçš„å¤§å°ï¼Œå®ƒå°†ä¿å­˜è¯·æ±‚çš„å…ƒç´  // å¯¹äº hint \u0026lt; 0 overLoadFactor è¿”å› falseï¼Œå› ä¸º hint \u0026lt; bucketCntã€‚ B := uint8(0) // è®¡ç®—ä¿å­˜hintä¸ªkey/elemå¯¹ä¸æ‰©å®¹æœ€å°éœ€è¦çš„Bçš„æ•°é‡ for overLoadFactor(hint, B) { B++ } h.B = B // allocate initial hash table // if B == 0, the buckets field is allocated lazily later (in mapassign) // If hint is large zeroing this memory could take a while. // // åˆ†é…åˆå§‹hashè¡¨ï¼Œå¦‚æœB == 0ï¼Œåˆ™ç¨å(åœ¨mapassignä¸­ï¼Œä¹Ÿå°±æ˜¯å­˜å‚¨æ•°æ®è¿‡ç¨‹ä¸­)å»¶è¿Ÿåˆ†é…bucketså­—æ®µï¼Œ // å¦‚æœhintå¾ˆå¤§ï¼Œåˆ™æ¸…ç©ºè¯¥å†…å­˜å¯èƒ½éœ€è¦ä¸€æ®µæ—¶é—´ã€‚ if h.B != 0 { var nextOverflow *bmap // ç”¨äºè®°å½• makeBucketArray æ˜¯å¦åˆ†é…äº†æº¢å‡ºæ¡¶ // makeBucketArray æ ¹æ®Båˆ†é…å¸¸è§„æ¡¶å’Œæº¢å‡ºæ¡¶ï¼Œå¦‚æœåˆ†é…äº†æº¢å‡ºæ¡¶åˆ™å°†æœ€åä¸€ä¸ªæº¢å‡ºæ¡¶åœ°å€æŒ‡å‘ç¬¬ä¸€ä¸ªå¸¸è§„æ¡¶åœ°å€ // æº¢å‡ºæ¡¶åˆ†é…è§„åˆ™ B \u0026gt;= 4 åˆ†é…æœ€å°‘ B-4 ä¸ªæº¢å‡ºæ¡¶å¤‡ç”¨ï¼Œæº¢å‡ºæ¡¶æ•°é‡ \u0026gt;= 1 \u0026lt;\u0026lt; (B-4) h.buckets, nextOverflow = makeBucketArray(t, h.B, nil) if nextOverflow != nil { h.extra = new(mapextra) // è®°å½•ä¸‹ä¸€ä¸ªå¯ä½¿ç”¨çš„æº¢å‡ºæ¡¶ h.extra.nextOverflow = nextOverflow } } return h } overLoadFactor() overLoadFactor æŠ¥å‘Šæ”¾ç½®åœ¨ 1\u0026laquo;B æ¡¶ä¸­çš„é¡¹ç›®æ•°é‡æ˜¯å¦è¶…è¿‡ loadFactorã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 // overLoadFactor reports whether count items placed in 1\u0026lt;\u0026lt;B buckets is over loadFactor. func overLoadFactor(count int, B uint8) bool { // const ( // bucketCnt = 8 // loadFactorNum = 13 // loadFactorDen = 2 // ) // bucketShift(B) == 1 \u0026lt;\u0026lt; B // uintptr(count)/bucketShift(B) \u0026lt; loadFactorNum/loadFactorDen // // return count \u0026gt; 8 \u0026amp;\u0026amp; count \u0026gt; 6.5 * (1 \u0026lt;\u0026lt; B) return count \u0026gt; bucketCnt \u0026amp;\u0026amp; uintptr(count) \u0026gt; loadFactorNum*(bucketShift(B)/loadFactorDen) } bucketShift() bucketShift è¿”å› 1\u0026lt;\u0026lt;bï¼Œä¸ºä»£ç ç”Ÿæˆåšäº†ä¼˜åŒ–ã€‚ 1 2 3 4 5 6 7 8 // bucketShift returns 1\u0026lt;\u0026lt;b, optimized for code generation. func bucketShift(b uint8) uintptr { // Masking the shift amount allows overflow checks to be elided. // // å±è”½ç§»ä½é‡å¯ä»¥çœç•¥æº¢å‡ºæ£€æŸ¥ã€‚ // goarch.PtrSize 64ä½ä¸‹ä¸º8ï¼Œ32ä½ä¸‹ä¸º4; goarch.PtrSize*8 - 1 æ©ç ä¸ºäº†é˜²æ­¢æº¢å‡º return uintptr(1) \u0026lt;\u0026lt; (b \u0026amp; (goarch.PtrSize*8 - 1)) // 1 \u0026lt;\u0026lt; b } makeBucketArray() makeBucketArray() ä¸º map æ¡¶åˆå§‹åŒ–ä¸€ä¸ªåå¤‡æ•°ç»„ã€‚ 1\u0026lt;\u0026lt;bæ˜¯è¦åˆ†é…çš„æœ€å°æ¡¶æ•°ã€‚ dirtyallocè¦ä¹ˆæ˜¯nilï¼Œè¦ä¹ˆæ˜¯makeBucketArrayä¹‹å‰åˆ†é…çš„å…·æœ‰ç›¸åŒtå’Œbå‚æ•°çš„æ¡¶æ•°ç»„ã€‚ å¦‚æœdirtyallocä¸ºnilï¼Œå°†åˆ†é…ä¸€ä¸ªæ–°çš„åå¤‡æ•°ç»„ï¼Œå¦åˆ™å°†æ¸…é™¤dirtyallocå¹¶ä½œä¸ºåå¤‡æ•°ç»„é‡ç”¨ã€‚ å‚æ•°ï¼š t *maptypeï¼šmapçš„ç±»å‹ç»“æ„ã€‚ b uint8ï¼šh.Bçš„å€¼ã€‚ dirtyalloc unsafe.Pointerï¼šnilæ—¶é‡æ–°ç”³è¯·å—å†…å­˜ï¼Œä¸æ˜¯nilæ—¶ï¼Œç»§ç»­ä½¿ç”¨dirtyalloc æŒ‡å‘çš„å†…å­˜åœ°å€ã€‚ è¿”å›å€¼ï¼š buckets unsafe.Pointerï¼šåˆ†é…çš„å¸¸è§„æ¡¶é¦–åœ°å€ã€‚ nextOverflow *bmapï¼šåˆ†é…çš„æº¢å‡ºæ¡¶é¦–åœ°å€ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 // makeBucketArray initializes a backing array for map buckets. // 1\u0026lt;\u0026lt;b is the minimum number of buckets to allocate. // dirtyalloc should either be nil or a bucket array previously // allocated by makeBucketArray with the same t and b parameters. // If dirtyalloc is nil a new backing array will be alloced and // otherwise dirtyalloc will be cleared and reused as backing array. func makeBucketArray(t *maptype, b uint8, dirtyalloc unsafe.Pointer) (buckets unsafe.Pointer, nextOverflow *bmap) { // base := 1 \u0026lt;\u0026lt; b base := bucketShift(b) // å¸¸è§„æ¡¶æ•°é‡ nbuckets := base // å­˜å‚¨(å¸¸è§„æ¡¶ + æº¢å‡ºæ¡¶)çš„æ€»æ•°é‡ // For small b, overflow buckets are unlikely. // Avoid the overhead of the calculation. // // å¯¹äºå°å€¼bæ¥è¯´ï¼Œæº¢å‡ºæ¡¶ä¸å¤ªå¯èƒ½å‡ºç°ã€‚é¿å…è®¡ç®—çš„å¼€é”€ã€‚ // æº¢å‡ºæ¡¶åˆ†é…è§„åˆ™ B \u0026gt;= 4 åˆ†é…æœ€å°‘ B-4 ä¸ªæº¢å‡ºæ¡¶å¤‡ç”¨ã€‚ if b \u0026gt;= 4 { // Add on the estimated number of overflow buckets // required to insert the median number of elements // used with this value of b. // // å†åŠ ä¸Šç”¨è¯¥å€¼bæ’å…¥å…ƒç´ çš„ä¸­ä½æ•°æ‰€éœ€çš„æº¢å‡ºæ¡¶çš„ä¼°è®¡æ•°é‡ã€‚ // nbuckets += 1 \u0026lt;\u0026lt; (b - 4) nbuckets += bucketShift(b - 4) // å¸¸è§„æ¡¶ + æº¢å‡ºæ¡¶ sz := t.bucket.size * nbuckets // è®¡ç®—å…¨éƒ¨æ¡¶(å¸¸è§„æ¡¶ + æº¢å‡ºæ¡¶)æ‰€éœ€å†…å­˜å¤§å° up := roundupsize(sz) // åŒ¹é…æœ€æ¥è¿‘szçš„å†…å­˜å¤§å°è§„æ ¼ if up != sz { // åŒ¹é…çš„å†…å­˜è§„æ ¼åå¤§\t// è°ƒæ•´ nbuckets æ•°é‡ï¼Œè¿™é‡Œåº”è¯¥æ˜¯åå¤§è®¾ç½® // å› ä¸ºä¸èƒ½èƒ½åŒ¹é…åå‡ºç°åå°çš„æƒ…å†µ nbuckets = up / t.bucket.size } } if dirtyalloc == nil { // æ²¡æœ‰å¯é‡æ–°åˆ©ç”¨çš„å†…å­˜å—ï¼Œé‡æ–°å‘å†…å­˜ç®¡ç†ç³»ç»Ÿç”³è¯·å†…å­˜ // buckets ç”³è¯·çš„æ¡¶é¦–åœ°å€ åŒ…å«å¸¸è§„æ¡¶å’Œæº¢å‡ºæ¡¶ï¼Œå› æ­¤å¸¸è§„æ¡¶å’Œæº¢å‡ºæ¡¶æ˜¯ä¸€æ•´å—è¿ç»­çš„å†…å­˜ buckets = newarray(t.bucket, int(nbuckets))\t} else { // dirtyalloc was previously generated by // the above newarray(t.bucket, int(nbuckets)) // but may not be empty. // // dirtyallocæ˜¯ç”±ä¸Šè¿° newarray(t.bucket, int(nbuckets)) ç”Ÿæˆçš„ï¼Œä½†ä¸èƒ½ä¸ºç©ºã€‚ buckets = dirtyalloc // æ¡¶å†…å­˜å—åœ°å€ size := t.bucket.size * nbuckets // å†…å­˜å—å¤§å° if t.bucket.ptrdata != 0 { // å½“å‰æ¡¶ä¸­å­˜åœ¨æŒ‡é’ˆæ•°æ®æ—¶ // é‡ç½®ä»bucketsåœ°å€å¼€å§‹é•¿åº¦ä¸ºsizeå¤§å°çš„å†…å­˜ memclrHasPointers(buckets, size) } else { // å½“å‰æ¡¶ä¸­ä¸å­˜åœ¨æŒ‡é’ˆæ•°æ®æ—¶ // é‡ç½®ä»bucketsåœ°å€å¼€å§‹é•¿åº¦ä¸ºsizeå¤§å°çš„å†…å­˜ memclrNoHeapPointers(buckets, size) } } // åˆ†é…äº†æº¢å‡ºæ¡¶ if base != nbuckets { // We preallocated some overflow buckets. // To keep the overhead of tracking these overflow buckets to a minimum, // we use the convention that if a preallocated overflow bucket\u0026#39;s overflow // pointer is nil, then there are more available by bumping the pointer. // We need a safe non-nil pointer for the last overflow bucket; just use buckets. // // æˆ‘ä»¬é¢„å…ˆåˆ†é…äº†ä¸€äº›æº¢å‡ºæ¡¶ã€‚ // ä¸ºäº†å°†è·Ÿè¸ªè¿™äº›æº¢å‡ºæ¡¶çš„å¼€é”€é™åˆ°æœ€ä½ï¼Œæˆ‘ä»¬ä½¿ç”¨çº¦å®š:å¦‚æœé¢„åˆ†é…çš„æº¢å‡ºæ¡¶çš„overflowæŒ‡é’ˆä¸ºnilï¼Œåˆ™é€šè¿‡ç¢°æ’æŒ‡é’ˆæ¥æä¾›æ›´å¤šå¯ç”¨çš„å†…å­˜ã€‚ // æˆ‘ä»¬éœ€è¦ä¸ºæœ€åä¸€ä¸ªæº¢å‡ºæ¡¶æä¾›ä¸€ä¸ªå®‰å…¨çš„ non-nil æŒ‡é’ˆ; å°±ç”¨å¸¸è§„æ¡¶å§ã€‚ç”¨äºåœ¨åˆ†é…æº¢å‡ºæ¡¶æ—¶åˆ¤æ–­æº¢å‡ºæ¡¶ä»¥åˆ†é…å®Œ nextOverflow = (*bmap)(add(buckets, base*uintptr(t.bucketsize))) // é¦–ä¸ªæº¢å‡ºæ¡¶ *bmap last := (*bmap)(add(buckets, (nbuckets-1)*uintptr(t.bucketsize)))// æœ€åä¸€ä¸ªæº¢å‡ºæ¡¶ *bmap // ä¹‹æ‰€ä»¥å°†æœ€åä¸€ä¸ªæº¢å‡ºæ¡¶overflowæŒ‡å‘ç¬¬ä¸€ä¸ªå¸¸è§„æ¡¶åœ°å€æ˜¯ç”¨äºåˆ†é…æº¢å‡ºæ¡¶æ˜¯åˆ¤æ–­æ˜¯å¦åˆ†é…å®Œå‚çœ‹(*hmap).newoverflow()æ–¹æ³• last.setoverflow(t, (*bmap)(buckets)) // æœ€åä¸€ä¸ªæº¢å‡ºæ¡¶æŒ‡é’ˆæŒ‡å‘é¦–ä¸ªå¸¸è§„æ¡¶ } return buckets, nextOverflow } newarray() newarray() åˆ†é…ä¸€ä¸ªåŒ…å« n ä¸ªç±»å‹ä¸º typ çš„å…ƒç´ çš„æ•°ç»„ã€‚ å‚æ•°ï¼š typ *_typeï¼šæ¡¶çš„ç±»å‹ç»“æ„ã€‚ n intï¼šæ¡¶çš„ä¸ªæ•°ï¼ˆå¸¸è§„æ¡¶ + æº¢å‡ºæ¡¶ï¼‰æ€»æ•°ã€‚ è¿”å›å€¼ï¼š unsafe.Pointerï¼šç”³è¯·åˆ°çš„å†…å­˜é¦–åœ°å€ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 // newarray allocates an array of n elements of type typ. func newarray(typ *_type, n int) unsafe.Pointer { if n == 1 { // åªæœ‰ä¸€ä¸ªæ¡¶ï¼Œç›´æ¥ç”³è¯· return mallocgc(typ.size, typ, true) } // æº¢å‡ºåˆ¤æ–­ï¼Œtyp.size * uintptr(n) ä¸ºæ¡¶æ€»å…±å ç”¨çš„å†…å­˜ mem, overflow := math.MulUintptr(typ.size, uintptr(n)) if overflow || mem \u0026gt; maxAlloc || n \u0026lt; 0 { panic(plainError(\u0026#34;runtime: allocation size out of range\u0026#34;)) } return mallocgc(mem, typ, true) } makemap_small() makemap_small() å®ç°äº† make(map[k]v) å’Œ make(map[k]v, hint) çš„Go mapåˆ›å»ºã€‚ å½“hint(\u0026lt;= 8)åœ¨ç¼–è¯‘æ—¶å·²çŸ¥æœ€å¤šä¸º bucketCnt (8)ï¼Œå¹¶ä¸”éœ€è¦åœ¨å †ä¸Šåˆ†é…mapæ—¶ã€‚ 1 2 3 4 5 6 7 8 9 10 // makemap_small implements Go map creation for make(map[k]v) and // make(map[k]v, hint) when hint is known to be at most bucketCnt // at compile time and the map needs to be allocated on the heap. func makemap_small() *hmap { // å½“ hint \u0026lt;= 8 æ—¶ // åˆå§‹åŒ– map h := new(hmap) h.hash0 = fastrand() return h } map Get ğŸš€ è·å– map ä¸­æŒ‡å®š key çš„å€¼ v := h[key] mapaccess1_fat() å¯ä»¥æŒ‡å®šé»˜è®¤å€¼ zeroï¼Œå½“åˆ†0å†…å­˜æ˜¯è¿”å›zeroå€¼ã€‚ è¯¥å‡½æ•°è¿”å›ä¸€ä¸ªåœ°å€ï¼Œåœ°å€æŒ‡å‘çš„å€¼å°±æ˜¯è¦å–å¾—vå€¼ã€‚ å‚æ•°ï¼š t *maptypeï¼šmapçš„ç±»å‹ç»“æ„ã€‚ h *hmapï¼šmapçš„å†…å­˜ç»“æ„ã€‚ key unsafe.Pointerï¼škeyçš„åœ°å€ã€‚ zero unsafe.Pointerï¼šé›¶å€¼åœ°å€ï¼Œç”¨äºè¿”å›å€¼ã€‚ è¿”å›å€¼ï¼š unsafe.Pointerï¼šè·å–åˆ°çš„elemåœ°å€ã€‚ 1 2 3 4 5 6 7 func mapaccess1_fat(t *maptype, h *hmap, key, zero unsafe.Pointer) unsafe.Pointer { e := mapaccess1(t, h, key) if e == unsafe.Pointer(\u0026amp;zeroVal[0]) { return zero } return e } mapaccess1() mapaccess1() è¿”å›ä¸€ä¸ªæŒ‡å‘h[key]çš„æŒ‡é’ˆã€‚ æ°¸è¿œä¸è¦è¿”å›nilï¼Œç›¸åï¼Œå¦‚æœkeyä¸åœ¨mapä¸­ï¼Œå®ƒä¼šè¿”å›ä¸€ä¸ªæŒ‡å‘elemç±»å‹çš„zeroå¯¹è±¡çš„å¼•ç”¨ã€‚ zeroå¯¹è±¡å°±æ˜¯å…¨å±€å˜é‡\u0026amp;zeroVal[0]åœ°å€å€¼ã€‚ æ³¨æ„ï¼šè¿”å›çš„æŒ‡é’ˆå¯èƒ½ä¼šä½¿æ•´ä¸ªmapä¿æŒæ´»åŠ¨çŠ¶æ€ï¼Œæ‰€ä»¥ä¸è¦å ç”¨å®ƒå¤ªé•¿æ—¶é—´ã€‚ go map æ˜¯ä¸æ”¯æŒå¤šçº¿ç¨‹çš„å†™ï¼Œä½†æ˜¯å¤šçº¿ç¨‹çš„è¯»æ˜¯æ²¡æœ‰é—®é¢˜çš„ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 // mapaccess1 returns a pointer to h[key]. Never returns nil, instead // it will return a reference to the zero object for the elem type if // the key is not in the map. // NOTE: The returned pointer may keep the whole map live, so don\u0026#39;t // hold onto it for very long. func mapaccess1(t *maptype, h *hmap, key unsafe.Pointer) unsafe.Pointer { if raceenabled \u0026amp;\u0026amp; h != nil { callerpc := getcallerpc() pc := abi.FuncPCABIInternal(mapaccess1) racereadpc(unsafe.Pointer(h), callerpc, pc) raceReadObjectPC(t.key, key, callerpc, pc) } if msanenabled \u0026amp;\u0026amp; h != nil { msanread(key, t.key.size) } if asanenabled \u0026amp;\u0026amp; h != nil { asanread(key, t.key.size) } // 1) mapæœªåˆå§‹åŒ– æˆ– æ²¡æœ‰key/elemå¯¹ if h == nil || h.count == 0 { // å½“keyä¸ºanyç±»å‹æ—¶ï¼Œåœ¨keyç»è¿‡hashæ—¶å¯èƒ½ä¼šå‘ç”Ÿpanic // t.hashMightPanic()åˆ¤æ–­å½“å‰hashå‡½æ•°æ˜¯å¦å¯èƒ½å‘ç”Ÿpanic // è¿™æ˜¯å› ä¸º any å­˜å‚¨çš„å€¼å¯èƒ½ä¸é€‚åˆä½œä¸º map çš„ key if t.hashMightPanic() { // å°è¯•hash panic t.hasher(key, 0) // see issue 23734 } // ç›´æ¥è¿”å› \u0026amp;zeroVal[0]ï¼Œè¿”å›é»˜è®¤å€¼ return unsafe.Pointer(\u0026amp;zeroVal[0]) } // 2) å½“å‰mapå­˜åœ¨å…¶ä»–goroutineæ­£åœ¨å†™æ“ä½œï¼Œç›´æ¥æŠ¥é”™ä¸æ”¯æŒå¹¶å‘ // hashWriting æ ‡å¿—åœ¨å†™mapæˆ–delete mapæ—¶è¢«è®¾ç½® if h.flags\u0026amp;hashWriting != 0 { fatal(\u0026#34;concurrent map read and map write\u0026#34;) // å¹¶å‘çš„mapè¯»å†™æ“ä½œ } // 3) keyæ ¹æ®h.hash0ç”Ÿæˆhashå€¼ï¼Œæ ¹æ®ä¸Šé¢keyä¸ºanyæ—¶è¿™é‡Œhashå¯èƒ½ä¼španic hash := t.hasher(key, uintptr(h.hash0)) m := bucketMask(h.B) // mapå¸¸è§„æ¡¶æ•°é‡; m = (1 \u0026lt;\u0026lt; B) - 1 // 4) åç§»åˆ°å½“å‰keyå¯¹åº”çš„å¸¸è§„æ¡¶å¤„ *bmap b := (*bmap)(add(h.buckets, (hash\u0026amp;m)*uintptr(t.bucketsize))) // 5) c != nil å½“å‰mapæ­£åœ¨æ‰©å®¹ä¸­ï¼Œéœ€è¦åˆ¤æ–­å½“å‰æ—§æ¡¶æ•°æ®æ˜¯å¦è¿ç§»ï¼Œæ²¡è¿ç§»æ•°æ®è¿˜åœ¨æ—§æ¡¶ä¸­ if c := h.oldbuckets; c != nil { // !h.sameSizeGrow() == true; // ç¿»å€æ‰©å®¹æ—¶ if !h.sameSizeGrow() { // There used to be half as many buckets; mask down one more power of two. // // è¿‡å»æ¡¶çš„æ•°é‡åªæœ‰ç°åœ¨çš„ä¸€åŠ;å†é™¤ä¸€ä¸ª2çš„å€æ•°ã€‚ m \u0026gt;\u0026gt;= 1 // éœ€è¦æŠŠmç¼©å°ä¸¤å€ } oldb := (*bmap)(add(c, (hash\u0026amp;m)*uintptr(t.bucketsize))) // åˆ¤æ–­æ—§æ¡¶æ˜¯å¦å·²ç»è¿ç§»äº†ï¼Œæ²¡æœ‰è¿ç§»åˆ™ä»æ—§æ¡¶é‡Œé¢å–æ•°æ® // ä¸æ˜¯2|3|4æ—¶è¡¨ç¤ºæ•°æ®è¿˜åœ¨æ—§æ¡¶é‡Œé¢ï¼Œtophash[0] NOT IN (2,3,4) if !evacuated(oldb) { b = oldb // æ›¿æ¢ä¸ºæ—§æ¡¶ *bmap } } // 6) top æ˜¯ hash çš„é«˜å…«ä½å€¼ï¼Œç”¨äºå¿«é€Ÿæ¯”å¯¹ key // hash \u0026gt;\u0026gt; (8*8 - 8) top := tophash(hash) // uint8 bucketloop: // 7) éå†å½“å‰æ¡¶ä»¥åŠåé¢çš„æº¢å‡ºæ¡¶ for ; b != nil; b = b.overflow(t) { // éå†å½“å‰æ¡¶; bucketCnt = 8 for i := uintptr(0); i \u0026lt; bucketCnt; i++ { // 7.1) å½“å‰ tophash ä¸ç›¸ç­‰ if b.tophash[i] != top { // const emptyRest = 0 // å½“å‰æ¡¶åŒ…æ‹¬æº¢å‡ºæ¡¶åé¢æ²¡æœ‰æ•°æ®äº† if b.tophash[i] == emptyRest { break bucketloop // ç»“æŸéå† } continue } // 7.2) b.tophash[i] == top; å¹¶ä¸ä»£è¡¨ä¸€å®šæ‰¾åˆ°keyï¼Œå¯èƒ½å‡ºç°tophashå†²çªæƒ…å†µ k := add(unsafe.Pointer(b), dataOffset+i*uintptr(t.keysize)) // æ‰¾åˆ°å½“å‰keyçš„åœ°å€ // keyçš„æ•°æ®æ˜¯é—´æ¥å­˜å‚¨çš„ï¼Œå…³äºå¸¸é‡maxKeySizeçš„ç›¸å…³æƒ…å†µ if t.indirectkey() { k = *((*unsafe.Pointer)(k)) // æ‹¿åˆ°keyåœ°å€ } // 7.3) è°ƒç”¨keyçš„æ¯”è¾ƒå‡½æ•°ï¼Œæ¯”è¾ƒkeyå’Œkæ˜¯å¦ç›¸ç­‰ã€‚ // è¿™é‡Œä¹Ÿæ˜¯keyå¿…é¡»æ˜¯å¯æ¯”è¾ƒç±»å‹çš„åŸå›  // ä¸å¯æ¯”è¾ƒçš„ç±»å‹ï¼š // 1. mapï¼Œä»¥åŠåŒ…å«mapçš„ç»“æ„ // 2. sliceï¼Œä»¥åŠåŒ…å«sliceçš„ç»“æ„ // è¿™é‡Œkeyå¦‚æœæ˜¯ NaN çš„è¯æ¯”å¯¹ä¸é€šè¿‡ã€‚ if t.key.equal(key, k) { // æ¯”å¯¹æˆåŠŸã€‚åç§»åˆ°elemå…ƒç´ åœ°å€å¤„ e := add(unsafe.Pointer(b), dataOffset+bucketCnt*uintptr(t.keysize)+i*uintptr(t.elemsize)) // elemçš„æ•°æ®æ˜¯é—´æ¥å­˜å‚¨çš„ï¼Œå…³äºå¸¸é‡maxElemSizeçš„ç›¸å…³æƒ…å†µ if t.indirectelem() { e = *((*unsafe.Pointer)(e)) // æ‹¿åˆ°elemåœ°å€ } return e // æˆåŠŸè¿”å›æ‰¾åˆ°çš„elemåœ°å€æŒ‡é’ˆ } // æœªåŒ¹é…æˆåŠŸå‡ºç°tophashã€å†²çªã€‘æƒ…å†µ } } // map ä¸­æ²¡æœ‰ keyï¼Œè¿”å›é»˜è®¤å€¼ return unsafe.Pointer(\u0026amp;zeroVal[0]) } bucketMask() bucketMask è¿”å›1\u0026lt;\u0026lt;b - 1ï¼Œä¸ºä»£ç ç”Ÿæˆåšäº†ä¼˜åŒ–ã€‚ 1 2 3 4 // bucketMask returns 1\u0026lt;\u0026lt;b - 1, optimized for code generation. func bucketMask(b uint8) uintptr { return bucketShift(b) - 1 // (1\u0026lt;\u0026lt;b) - 1 } tophash() tophash è®¡ç®— hash çš„ Tophash å€¼ã€‚ 1 2 3 4 5 6 7 8 9 10 11 // tophash calculates the tophash value for hash. func tophash(hash uintptr) uint8 { // hash \u0026gt;\u0026gt; (8*8 - 8) // hashé«˜å…«ä½ top := uint8(hash \u0026gt;\u0026gt; (goarch.PtrSize*8 - 8))\t// top \u0026lt; 5 if top \u0026lt; minTopHash { top += minTopHash } return top } evacuated() æ¡¶æ•°æ®æ˜¯å¦å·²è¿ç§»ã€‚ 1 2 3 4 5 func evacuated(b *bmap) bool { h := b.tophash[0] // b.tophash[0] IN (2,3,4) return h \u0026gt; emptyOne \u0026amp;\u0026amp; h \u0026lt; minTopHash } v, b := h[key] mapaccess2_fat() å¯ä»¥æŒ‡å®šé»˜è®¤å€¼ zeroã€‚å½“åˆ†0å†…å­˜æ˜¯è¿”å› zero å€¼ã€‚ 1 2 3 4 5 6 7 8 9 func mapaccess2_fat(t *maptype, h *hmap, key, zero unsafe.Pointer) (unsafe.Pointer, bool) { // æ²¡çœ‹é”™ï¼Œè¿™é‡Œä¾ç„¶æ˜¯è°ƒç”¨çš„ mapaccess1() å‡½æ•° // å› ä¸ºå¦‚æœæ²¡æ‰¾åˆ°keyä¼šè¿”å›\u0026amp;zeroVal[0]ï¼Œæ ¹æ®è¯¥å€¼èƒ½åˆ¤æ–­boolã€‚ e := mapaccess1(t, h, key) if e == unsafe.Pointer(\u0026amp;zeroVal[0]) { return zero, false } return e, true } mapaccess2() mapaccess2() å’Œ mapaccess1() ä»£ç åŸºæœ¬ä¸€æ ·ï¼Œåªå¤šè¿”å›ä¸ªè·å–æˆå¤±è´¥çš„å€¼ã€‚ è¯¥å‡½æ•°åœ¨åå°„ç›¸å…³ä¸­è¢«è°ƒç”¨ï¼Œæ­£å¸¸mapè¿™é‡Œä¸ä¼šè°ƒç”¨è¯¥å‡½æ•°ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 func mapaccess2(t *maptype, h *hmap, key unsafe.Pointer) (unsafe.Pointer, bool) { if raceenabled \u0026amp;\u0026amp; h != nil { callerpc := getcallerpc() pc := abi.FuncPCABIInternal(mapaccess2) racereadpc(unsafe.Pointer(h), callerpc, pc) raceReadObjectPC(t.key, key, callerpc, pc) } if msanenabled \u0026amp;\u0026amp; h != nil { msanread(key, t.key.size) } if asanenabled \u0026amp;\u0026amp; h != nil { asanread(key, t.key.size) } if h == nil || h.count == 0 { if t.hashMightPanic() { t.hasher(key, 0) // see issue 23734 } return unsafe.Pointer(\u0026amp;zeroVal[0]), false // è¿™é‡Œè·å–å¤±è´¥è¿”å› false } if h.flags\u0026amp;hashWriting != 0 { fatal(\u0026#34;concurrent map read and map write\u0026#34;) } hash := t.hasher(key, uintptr(h.hash0)) m := bucketMask(h.B) b := (*bmap)(add(h.buckets, (hash\u0026amp;m)*uintptr(t.bucketsize))) if c := h.oldbuckets; c != nil { if !h.sameSizeGrow() { // There used to be half as many buckets; mask down one more power of two. m \u0026gt;\u0026gt;= 1 } oldb := (*bmap)(add(c, (hash\u0026amp;m)*uintptr(t.bucketsize))) if !evacuated(oldb) { b = oldb } } top := tophash(hash) bucketloop: for ; b != nil; b = b.overflow(t) { for i := uintptr(0); i \u0026lt; bucketCnt; i++ { if b.tophash[i] != top { if b.tophash[i] == emptyRest { break bucketloop } continue } k := add(unsafe.Pointer(b), dataOffset+i*uintptr(t.keysize)) if t.indirectkey() { k = *((*unsafe.Pointer)(k)) } if t.key.equal(key, k) { e := add(unsafe.Pointer(b), dataOffset+bucketCnt*uintptr(t.keysize)+i*uintptr(t.elemsize)) if t.indirectelem() { e = *((*unsafe.Pointer)(e)) } return e, true // è¿™é‡Œè·å–æˆåŠŸè¿”å› true } } } return unsafe.Pointer(\u0026amp;zeroVal[0]), false // è¿™é‡Œè·å–å¤±è´¥è¿”å› false } map Set ğŸš€ h[k] = v reflect_mapassign() keyå’Œelemåˆ†åˆ«ä»£è¡¨çš„æ˜¯å„è‡ªçš„åœ°å€ã€‚ å½“ key != key æ—¶ï¼Œå­˜å…¥çš„æ•°æ®for rangeæƒ…å†µæ˜¯å–ä¸å‡ºæ¥çš„ã€‚ å‚æ•°ï¼š t *maptypeï¼šmapç±»å‹ç»“æ„ã€‚ h *hmapï¼šmapå†…å­˜ç»“æ„ã€‚ key unsafe.Pointerï¼šmapçš„keyåœ°å€ã€‚ elem unsafe.Pointerï¼šmapè¦å†™å…¥çš„våœ°å€ã€‚ 1 2 3 4 5 6 7 //go:linkname reflect_mapassign reflect.mapassign func reflect_mapassign(t *maptype, h *hmap, key unsafe.Pointer, elem unsafe.Pointer) { // ä»mapä¸­æ‰¾åˆ°elemåº”è¯¥æ”¾å…¥æ’æ§½çš„åœ°å€ p := mapassign(t, h, key)\t// æ‹·è´æ•°æ®ï¼Œä¹Ÿå°±å››æŠŠ\u0026amp;vå¤åˆ¶ç»™mapæ’æ§½ typedmemmove(t.elem, p, elem)\t} mapassign() ç±»ä¼¼äºmapaccessï¼Œä½†å¦‚æœkeyåœ¨mapä¸­ä¸å­˜åœ¨ï¼Œåˆ™ä¼šä¸ºé”®åˆ†é…ä¸€ä¸ªä½ç½®ã€‚ å­˜åœ¨ä¸¤ç§æƒ…å†µï¼š æ–°å¢ï¼šå¯èƒ½kæ˜¯ä»æ¥æ²¡å­˜åœ¨mapä¸­ã€‚ ä¿®æ”¹ï¼šå¯èƒ½kå·²ç»å­˜å‚¨åœ¨mapä¸­ã€‚ map æ˜¯å¹¶å‘ä¸å®‰å…¨çš„ã€‚ map å¿…é¡»è¦ç»è¿‡make()å‡½æ•°åˆå§‹åŒ–æ‰èƒ½ä½¿ç”¨ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 // Like mapaccess, but allocates a slot for the key if it is not present in the map. func mapassign(t *maptype, h *hmap, key unsafe.Pointer) unsafe.Pointer { // 1) æœªåˆå§‹åŒ–çš„mapä¸å…è®¸å†™æ“ä½œ // è¿™é‡Œå°±æ˜¯ä¸ºä»€ä¹ˆå‘nilçš„mapå†™å…¥æ•°æ®ä¼španicåŸå›  if h == nil { panic(plainError(\u0026#34;assignment to entry in nil map\u0026#34;)) } if raceenabled { callerpc := getcallerpc() pc := abi.FuncPCABIInternal(mapassign) racewritepc(unsafe.Pointer(h), callerpc, pc) raceReadObjectPC(t.key, key, callerpc, pc) } if msanenabled { msanread(key, t.key.size) } if asanenabled { asanread(key, t.key.size) } // 2) æ£€æŸ¥mapæ˜¯å¦å­˜åœ¨å¹¶å‘çš„å†™æ“ä½œï¼Œåˆ é™¤ä¹Ÿæ˜¯å†™æ“ä½œã€‚ if h.flags\u0026amp;hashWriting != 0 { fatal(\u0026#34;concurrent map writes\u0026#34;) } // 3) keyæ ¹æ®h.hash0ç”Ÿæˆhashå€¼ï¼Œæ ¹æ®ä¸Šé¢keyä¸ºanyæ—¶è¿™é‡Œhashå¯èƒ½ä¼španicã€‚ hash := t.hasher(key, uintptr(h.hash0)) // Set hashWriting after calling t.hasher, since t.hasher may panic, // in which case we have not actually done a write. // // åœ¨è°ƒç”¨t.hasherä¹‹åè®¾ç½®hashWritingï¼Œå› ä¸ºt.hasherå¯èƒ½ä¼šå‡ºé”™ï¼Œåœ¨è¿™ç§æƒ…å†µä¸‹æˆ‘ä»¬å®é™…ä¸Šå¹¶æ²¡æœ‰å†™å…¥ã€‚ // è¿™é‡Œä½¿ç”¨ ^= æœ‰ç‚¹å°çªé—¨ï¼Œå› ä¸ºåœ¨å¹¶å‘å†™çš„æƒ…å†µä¸‹å¯èƒ½å­˜åœ¨ä¸Šé¢çš„h.flags\u0026amp;hashWriting != 0æ£€æŸ¥æ—¶è¢«è·³è¿‡äº†ï¼Œ // æ‰€ä»¥è¿™ä¸ªå‡½æ•°æœ€åè¿˜éœ€è¦åˆ¤æ–­å¹¶æ˜¯å¦å·²ç»å‘ç”Ÿ ^ å¼‚æˆ– ç›¸åŒå¾—0ï¼Œä¸åŒå¾—1; hashWriting = 4 = 0b100 // æŒ‰ç…§æ­£å¸¸é€»è¾‘ h.flags çš„3bitä½åº”è¯¥æ˜¯0ï¼Œé‚£ä¹ˆ0^1=1ã€‚åœ¨å‡½æ•°çš„æœ€å h.flags\u0026amp;hashWriting == 0 åˆ¤æ–­æ—¶ 1\u0026amp;1=1ã€‚ // å¼‚å¸¸é€»è¾‘ h.flags çš„3bitä½æ˜¯1ï¼Œé‚£ä¹ˆ 1^1=0ã€‚åœ¨å‡½æ•°çš„æœ€å h.flags\u0026amp;hashWriting == 0 åˆ¤æ–­æ—¶ 0\u0026amp;1=0ã€‚å› æ­¤åˆ¤æ–­å¹¶å‘å‘ç”Ÿ h.flags ^= hashWriting // å†™çŠ¶æ€æ ‡è®° // 4) æ²¡æœ‰åˆ†é…å¸¸è§„æ¡¶ï¼Œè¿™ç§æƒ…å†µæ¥è‡ªmakemap_small()å‡½æ•°ï¼Œhint\u0026lt;=8 æ—¶ if h.buckets == nil { // ç”³è¯·ä¸€ä¸ªå¸¸è§„æ¡¶å†…å­˜å— h.buckets = newobject(t.bucket) // newarray(t.bucket, 1) } again: // 5) æ ¹æ® hash æ˜ å°„åˆ°æŒ‡å®šæ¡¶å· bucket := hash \u0026amp; bucketMask(h.B) // bucket = hash \u0026amp; ((1 \u0026lt;\u0026lt; B) - 1) // 6) æ˜¯å¦æ­£å¤„äºæ‰©å®¹ä¸­ï¼šã€ç­‰é‡æ‰©å®¹ã€‘ æˆ– ã€ç¿»å€æ‰©å®¹ã€‘ if h.growing() { // h.oldbuckets != nil // è¿ç§»å½“å‰keyå¯¹åº”çš„æ¡¶æ•°æ®åˆ°æ–°æ¡¶å®Œæˆéƒ¨åˆ†æ‰©å®¹ä»»åŠ¡ // è¿ç§»åä¼šæŠŠæ—§æ¡¶æ•°æ®è¿ç§»åˆ°æ–°æ¡¶ï¼Œå› æ­¤ä»¥ä¸‹ä»£ç å¤„ç†æ–°æ¡¶å³å¯ // growWork() å‡½æ•°åœ¨delete(map)å’Œmap[k]=væ—¶è¢«è°ƒç”¨ï¼Œæ¸è¿›å¼è¿ç§»æ•°æ® growWork(t, h, bucket)\t} // 7) å¯»æ‰¾å¯¹åº”çš„æ¡¶(*bmap)ï¼Œkeyå¯¹åº”çš„æ¡¶ *bmap b := (*bmap)(add(h.buckets, bucket*uintptr(t.bucketsize))) // top = uint8( hash \u0026amp; (1\u0026gt;\u0026gt;8*8-8) ) top := tophash(hash) // hash é«˜å…«ä½ï¼Œç”¨äºå¿«é€Ÿåˆ¤æ–­ key // inserti å¯¹åº”keyåº”è¯¥æ”¾å…¥tophashçš„slotä½ç½®åœ°å€ var inserti *uint8\t// insertk å¯¹åº”keyåº”è¯¥æ”¾å…¥keysçš„slotä½ç½®åœ°å€ var insertk unsafe.Pointer // elem å¯¹åº”keyåº”è¯¥æ”¾å…¥elemsçš„slotä½ç½®åœ°å€ var elem unsafe.Pointer\tbucketloop: // 8) éå†å¸¸è§„æ¡¶å’Œæº¢å‡ºæ¡¶ï¼Œå¯»æ‰¾slotä½ç½® // è¢«åˆ é™¤çš„slotä¼šè¢«ä¼˜å…ˆä½¿ç”¨æ¥å­˜å‚¨æ•°æ® for { // 8.1) éå†å•ä¸ªæ¡¶; const bucketCnt = 8 for i := uintptr(0); i \u0026lt; bucketCnt; i++ { // 8.1.1) tophash æ¯”å¯¹å¤±è´¥ if b.tophash[i] != top { // isEmpty(b.tophash[i]) --\u0026gt; b.tophash[i] \u0026lt;= 1 // inserti == nil; å¯»æ‰¾åˆ°slotåä¸ä¼šå†è¿›å…¥è¿™é‡Œ // è¿™é‡Œä¹Ÿæ˜¯åˆ¤æ–­å½“å‰å¯èƒ½æ˜¯æ–°å¢çš„æƒ…å†µï¼Œå½“å‰ä½å¯ä»¥æ’å…¥æ•°æ®å¦‚æœæ˜¯æ–°å¢çš„è¯ã€‚ if isEmpty(b.tophash[i]) \u0026amp;\u0026amp; inserti == nil { // è®°å½•å½“å‰æ’æ§½ä½ç½® inserti = \u0026amp;b.tophash[i] insertk = add(unsafe.Pointer(b), dataOffset+i*uintptr(t.keysize)) elem = add(unsafe.Pointer(b), dataOffset+bucketCnt*uintptr(t.keysize)+i*uintptr(t.elemsize)) } // b.tophash[i] == 0; åé¢æ²¡æœ‰æ•°æ®äº† if b.tophash[i] == emptyRest { break bucketloop } // b.tophash[i] == 1 // åé¢æœ‰æ•°æ®éœ€è¦ç»§ç»­éå†åˆ¤æ–­æ˜¯å¦å½“å‰keyå·²ç»å­˜åœ¨åœ¨mapä¸­äº† continue // continueçš„ä½œç”¨å°±æ˜¯ç»§ç»­éå†mapå¯»æ‰¾key } // tophashåŒ¹é…æˆåŠŸ // 1. å¯èƒ½æ˜¯hashå†²çªï¼Œç»§ç»­å‘åå¯»æ‰¾ // 2. å¯èƒ½æ˜¯åŒ¹é…åˆ°äº†keyï¼Œåˆ™æ˜¯æ›´æ–° // 8.1.2) å½“å‰keyçš„slotåœ°å€ k := add(unsafe.Pointer(b), dataOffset+i*uintptr(t.keysize)) if t.indirectkey() { // key é—´æ¥å­˜å‚¨ k = *((*unsafe.Pointer)(k)) } // 8.1.3) æ¯”è¾ƒkeyå’Œkæ˜¯å¦ç›¸ç­‰ï¼Œä¸ç›¸ç­‰è¯´æ˜ tophashå†²çªäº† // å¦‚æœå­˜å‚¨çš„ key æ˜¯ NaN è¿™é‡Œæ¯”å¯¹ä¸é€šè¿‡ã€‚ if !t.key.equal(key, k) { continue // key != k ç»§ç»­å‘åå¯»æ‰¾ } // key == k; åŒ¹é…æˆåŠŸåˆ™æœ¬æ¬¡æ˜¯æ›´æ–°æ“ä½œ // already have a mapping for key. Update it. // // å·²ç»æœ‰ä¸€ä¸ªkeyçš„æ˜ å°„ã€‚ã€æ›´æ–°å®ƒã€‘ã€‚ // key == keyæˆç«‹ï¼Œä½†æ˜¯å¯èƒ½ç”Ÿæˆçš„hashå€¼ä¸åŒï¼Œæ¯”å¦‚+0å’Œ-0 if t.needkeyupdate() { typedmemmove(t.key, k, key) // æŠŠkæ›´æ–°ä¸ºkey } // 8.1.4) æ‰¾åˆ°elemåœ°å€ elem = add(unsafe.Pointer(b), dataOffset+bucketCnt*uintptr(t.keysize)+i*uintptr(t.elemsize)) goto done } ovf := b.overflow(t) // båé¢é“¾æ¥çš„æº¢å‡ºæ¡¶ // æ²¡æœ‰æº¢å‡ºæ¡¶äº† if ovf == nil { break } b = ovf } // Did not find mapping for key. Allocate new cell \u0026amp; add entry. // // 9) æ²¡æœ‰æ‰¾åˆ°keyçš„æ˜ å°„ã€‚åˆ†é…æ–°çš„å•å…ƒæ ¼å¹¶æ·»åŠ entryã€‚æ–°å¢ key/elem // If we hit the max load factor or we have too many overflow buckets, // and we\u0026#39;re not already in the middle of growing, start growing. // // 10) å¦‚æœæˆ‘ä»¬è¾¾åˆ°äº†æœ€å¤§è´Ÿè½½ç³»æ•°ï¼Œæˆ–è€…æˆ‘ä»¬æœ‰å¤ªå¤šæº¢å‡ºæ¡¶ï¼Œè€Œæˆ‘ä»¬è¿˜æ²¡æœ‰è¾¾åˆ°å¢é•¿çš„ä¸€åŠï¼Œå°±å¼€å§‹å¢é•¿ã€‚ // h.growing() -\u0026gt; (h.oldbuckets != nil); æ˜¯å¦æ­£åœ¨æ‰©å®¹ä¸­ if !h.growing() \u0026amp;\u0026amp; (overLoadFactor(h.count+1, h.B) || tooManyOverflowBuckets(h.noverflow, h.B)) { hashGrow(t, h) // æ‰©å®¹åˆå§‹åŒ– // æ‰©å®¹hash tableä¼šä½¿ä¸Šé¢çš„æ‰€æœ‰æ“ä½œå¤±æ•ˆï¼Œæ‰€ä»¥å†è¯•ä¸€æ¬¡ goto again // Growing the table invalidates everything, so try again } // 11) å¸¸è§„æ¡¶å’Œæº¢å‡ºæ¡¶(å¦‚æœå­˜åœ¨)éƒ½æ²¡æ‰¾åˆ°slotï¼Œè¿™æ—¶å€™éœ€è¦åˆ†é…æ–°çš„æº¢å‡ºæ¡¶ if inserti == nil { // The current bucket and all the overflow buckets connected to it are full, allocate a new one. // // å½“å‰æ¡¶å’Œè¿æ¥åˆ°å®ƒçš„æ‰€æœ‰æº¢å‡ºæ¡¶å·²æ»¡ï¼Œåˆ†é…ä¸€ä¸ªæ–°çš„æ¡¶ã€‚ newb := h.newoverflow(t, b) // åˆ†é…ä¸€ä¸ªæº¢å‡ºæ¡¶ *bmap inserti = \u0026amp;newb.tophash[0] insertk = add(unsafe.Pointer(newb), dataOffset) elem = add(insertk, bucketCnt*uintptr(t.keysize)) } // store new key/elem at insert position // // 12) å°†æ–°çš„é”®/elemå­˜å‚¨åœ¨æ’å…¥ä½ç½® if t.indirectkey() { // key é—´æ¥å­˜å‚¨ kmem := newobject(t.key) *(*unsafe.Pointer)(insertk) = kmem insertk = kmem } if t.indirectelem() { // elem é—´æ¥å­˜å‚¨ vmem := newobject(t.elem) *(*unsafe.Pointer)(elem) = vmem // ç”±äºdoneåé¢æœ‰ t.indirectelem() åˆ¤æ–­æ‰€æœ‰è¿™é‡Œæ²¡æœ‰ elem = vmem è¿™è¡Œä»£ç  } // 13) æ‹·è´æ•°æ® typedmemmove(t.key, insertk, key) // ä¿å­˜keyçš„å€¼ *inserti = top // tophash ä¿å­˜ h.count++ // key/elem å¯¹åŠ ä¸€ done: // 14) å†æ¬¡åˆ¤æ–­æ˜¯å¦æœ‰å…¶ä»–goroutineæ­£åœ¨å¯¹mapè¿›è¡Œå†™æ“ä½œ if h.flags\u0026amp;hashWriting == 0 { fatal(\u0026#34;concurrent map writes\u0026#34;) } h.flags \u0026amp;^= hashWriting // æ¸…é™¤hashWritingæ ‡å¿—ä½ if t.indirectelem() { // elem é—´æ¥å­˜å‚¨ elem = *((*unsafe.Pointer)(elem)) } return elem // è¿”å›å½“å‰slotçš„åœ°å€ } isEmpty() isEmptyæŠ¥å‘Šç»™å®šçš„tophashæ•°ç»„é¡¹æ˜¯å¦è¡¨ç¤ºç©ºæ¡¶é¡¹ã€‚ 1 2 3 4 // isEmpty reports whether the given tophash array entry represents an empty bucket entry. func isEmpty(x uint8) bool { return x \u0026lt;= emptyOne // x \u0026lt;= 1 } overLoadFactor() ç¿»å€æ‰©å®¹åˆ¤æ–­æ¡ä»¶ã€‚ 1 2 3 4 5 // overLoadFactor reports whether count items placed in 1\u0026lt;\u0026lt;B buckets is over loadFactor. func overLoadFactor(count int, B uint8) bool { // count \u0026gt; 8 \u0026amp;\u0026amp; count \u0026gt; 13*((1\u0026lt;\u0026lt;B) / 2) return count \u0026gt; bucketCnt \u0026amp;\u0026amp; uintptr(count) \u0026gt; loadFactorNum*(bucketShift(B)/loadFactorDen) } tooManyOverflowBuckets() ç­‰é‡æ‰©å®¹åˆ¤æ–­æ¡ä»¶ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 // tooManyOverflowBuckets reports whether noverflow buckets is too many for a map with 1\u0026lt;\u0026lt;B buckets. // Note that most of these overflow buckets must be in sparse use; // if use was dense, then we\u0026#39;d have already triggered regular map growth. func tooManyOverflowBuckets(noverflow uint16, B uint8) bool { // If the threshold is too low, we do extraneous work. // If the threshold is too high, maps that grow and shrink can hold on to lots of unused memory. // \u0026#34;too many\u0026#34; means (approximately) as many overflow buckets as regular buckets. // See incrnoverflow for more details. if B \u0026gt; 15 { B = 15 } // The compiler doesn\u0026#39;t see here that B \u0026lt; 16; mask B to generate shorter shift code. return noverflow \u0026gt;= uint16(1)\u0026lt;\u0026lt;(B\u0026amp;15) } æ‰©å®¹ ğŸš€ ç¿»å€æ‰©å®¹æ¡ä»¶ h.oldbuckets == nil; æœªå¤„äºæ‰©å®¹è¿‡ç¨‹ä¸­ã€‚ å­˜å‚¨çš„key/elemå¯¹æ•°é‡å¤§äºå¸¸è§„æ¡¶æ•°é‡çš„ 6.5 å€ã€‚ key/elemå¯¹æ•°é‡å¤§äº8 1 2 3 // 1) h.oldbuckets != nil; å¤„äºæ‰©å®¹ä¸­ã€‚!h.growing()ï¼šæ²¡æœ‰å¤„äºæ‰©å®¹ä¸­ // 2) overLoadFactor(h.count+1, h.B)ï¼šæ–°å¢ä¸€ä¸ªå…ƒç´ æ˜¯å¦éœ€è¦æ‰©å®¹åˆ¤æ–­ if !h.growing() \u0026amp;\u0026amp; overLoadFactor(h.count+1, h.B) {} overLoadFactor() overLoadFactor æŠ¥å‘Šæ”¾ç½®åœ¨ 1\u0026lt;\u0026lt;B æ¡¶ä¸­çš„é¡¹ç›®æ•°é‡æ˜¯å¦è¶…è¿‡ loadFactorã€‚ 1 2 3 4 5 6 // overLoadFactor reports whether count items placed in 1\u0026lt;\u0026lt;B buckets is over loadFactor. func overLoadFactor(count int, B uint8) bool { // count \u0026gt; 8 \u0026amp;\u0026amp; count \u0026gt; 13*( (1\u0026lt;\u0026lt;B) / 2) // count \u0026gt; 8 \u0026amp;\u0026amp; count \u0026gt; 6.5 * (1\u0026lt;\u0026lt;B) return count \u0026gt; bucketCnt \u0026amp;\u0026amp; uintptr(count) \u0026gt; loadFactorNum*(bucketShift(B)/loadFactorDen) } ç­‰é‡æ‰©å®¹æ¡ä»¶ å½“å¸¸è§„æ¡¶(h.B)å°äºç­‰äº15æ—¶ï¼Œæº¢å‡ºæ¡¶æ•°é‡ å¤§äºç­‰äº å¸¸è§„æ¡¶æ•°é‡(1 \u0026lt;\u0026lt; h.B) å°±è¦æ‰©å®¹ã€‚ å½“å¸¸è§„æ¡¶(h.B)å¤§äº15æ—¶ï¼Œæº¢å‡ºæ¡¶æ•°é‡ å¤§äºç­‰äº (1 \u0026lt;\u0026lt; 15) å°±è¦æ‰©å®¹äº†ã€‚ æº¢å‡ºæ¡¶çš„åˆ†é…è§„åˆ™ï¼šå½“B\u0026gt;=4æ—¶åˆ™åˆ†é…(B-4)ä¸ªæº¢å‡ºæ¡¶å¤‡ç”¨ï¼Œå› æ­¤å¸¸è§„æ¡¶æ•°é‡å¤§äºæº¢å‡ºæ¡¶æ•°é‡ã€‚ç­‰é‡æ‰©å®¹æ—¶å¤‡ç”¨çš„æº¢å‡ºæ¡¶ä¸€å®šæ˜¯è¢«ç”¨å®Œäº†ã€‚ 1 2 3 // 1) !h.growing()ï¼šæ²¡æœ‰å¤„äºæ‰©å®¹ä¸­ // 2) tooManyOverflowBuckets(h.noverflow, h.B)ï¼šæ»¡è¶³ç­‰é‡æ‰©å®¹æ¡ä»¶ if !h.growing() \u0026amp;\u0026amp; tooManyOverflowBuckets(h.noverflow, h.B) {} tooManyOverflowBuckets() tooManyOverflowBuckets æŠ¥å‘Š noverflow æ¡¶å¯¹äºä¸€ä¸ªåŒ…å« 1\u0026lt;\u0026lt;B æ¡¶çš„ map æ¥è¯´æ˜¯å¦å¤ªå¤šã€‚ è¯·æ³¨æ„ï¼Œå¤§å¤šæ•°æº¢å‡ºæ¡¶å¿…é¡»ç¨€ç–ä½¿ç”¨; å¦‚æœä½¿ç”¨æ˜¯å¯†é›†çš„ï¼Œé‚£ä¹ˆæˆ‘ä»¬å°±å·²ç»è§¦å‘äº†å¸¸è§„çš„ map å¢é•¿ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 // tooManyOverflowBuckets reports whether noverflow buckets is too many for a map with 1\u0026lt;\u0026lt;B buckets. // Note that most of these overflow buckets must be in sparse use; // if use was dense, then we\u0026#39;d have already triggered regular map growth. func tooManyOverflowBuckets(noverflow uint16, B uint8) bool { // If the threshold is too low, we do extraneous work. // If the threshold is too high, maps that grow and shrink can hold on to lots of unused memory. // \u0026#34;too many\u0026#34; means (approximately) as many overflow buckets as regular buckets. // See incrnoverflow for more details. // // å¦‚æœé˜ˆå€¼å¤ªä½ï¼Œæˆ‘ä»¬åšå¤šä½™çš„å·¥ä½œã€‚ // å¦‚æœé˜ˆå€¼è¿‡é«˜ï¼Œåˆ™å¢å¤§å’Œç¼©å°çš„æ˜ å°„ä¼šå ç”¨å¤§é‡æœªä½¿ç”¨çš„å†…å­˜ã€‚ // \u0026#34;too many\u0026#34;æ˜¯æŒ‡æº¢å‡ºæ¡¶çš„æ•°é‡(å¤§çº¦)ä¸æ™®é€šæ¡¶ç›¸åŒã€‚æ›´å¤šç»†èŠ‚è¯·å‚è§h.incnoverflow()ã€‚ if B \u0026gt; 15 { B = 15 } // The compiler doesn\u0026#39;t see here that B \u0026lt; 16; mask B to generate shorter shift code. // // ç¼–è¯‘å™¨æ²¡æœ‰çœ‹åˆ°B \u0026lt; 16;æ©ç Bä»¥ç”Ÿæˆæ›´çŸ­çš„ç§»ä½ç ã€‚ // noverflowï¼šè¡¨ç¤ºå·²ä½¿ç”¨çš„æº¢å‡ºæ¡¶æ•°é‡ return noverflow \u0026gt;= uint16(1)\u0026lt;\u0026lt;(B\u0026amp;15) } æ‰©å®¹åˆå§‹åŒ– hashGrow() æ‰©å®¹åˆå§‹åŒ–å¼€å§‹ã€‚ å‚æ•°ï¼š t *maptypeï¼šå½“å‰ map çš„ç±»å‹ç»“æ„ã€‚ h *hmapï¼šå½“å‰ map çš„å†…å­˜ç»“æ„ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 func hashGrow(t *maptype, h *hmap) { // If we\u0026#39;ve hit the load factor, get bigger. // Otherwise, there are too many overflow buckets, // so keep the same number of buckets and \u0026#34;grow\u0026#34; laterally. // // 1) å¦‚æœæˆ‘ä»¬è¾¾åˆ°äº†æ»¡è½½ç³»æ•°ï¼Œå°±ä¼šå˜å¤§ã€‚å¦åˆ™ï¼Œæº¢å‡ºæ¡¶å¤ªå¤šï¼Œæ‰€ä»¥ä¿æŒç›¸åŒæ•°é‡çš„æ¡¶ï¼Œæ¨ªå‘â€œå¢é•¿â€ã€‚ bigger := uint8(1)\t// biggeræ˜¯ç¿»å€æ‰©å®¹è¿˜æ˜¯ç­‰é‡æ‰©å®¹ 1.ã€ç¿»å€æ‰©å®¹ã€‘ 0.ã€ç­‰é‡æ‰©å®¹ã€‘\tif !overLoadFactor(h.count+1, h.B) { bigger = 0 // æ ‡è®°ç­‰é‡æ‰©å®¹ h.flags |= sameSizeGrow\t// è®¾ç½®ç­‰é‡æ‰©å®¹æ ‡å¿—ä½ } oldbuckets := h.buckets // è®°å½•æ—§æ¡¶åœ°å€ // 2) ç”³è¯·ä¸€å—æ–°å†…å­˜ï¼Œå½“åšæ–°æ¡¶åœ°å€ newbuckets, nextOverflow := makeBucketArray(t, h.B+bigger, nil)\t// 3) æ¸…é™¤iterator å’Œ oldIteratoræ ‡å¿—çš„flags flags := h.flags \u0026amp;^ (iterator | oldIterator) // è¿­ä»£å™¨åœ¨æ‰©å®¹çš„å‰é¢æ—¶ if h.flags\u0026amp;iterator != 0 {\t// è¿­ä»£å™¨æ­£åœ¨è¿è¡Œ flags |= oldIterator // æ ‡è®°è¿­ä»£æ—§æ•°æ® } // 4) è®¾ç½® hmap ç›¸å…³å‚æ•° // commit the grow (atomic wrt gc) h.B += bigger // æ‰©å®¹åçš„B h.flags = flags // æœ€æ–°çš„flagsçŠ¶æ€ h.oldbuckets = oldbuckets // æ—§æ¡¶åœ°å€ h.buckets = newbuckets // æ–°æ¡¶åœ°å€ h.nevacuate = 0\t// ä¸‹ä¸€ä¸ªéœ€è¦è¿ç§»çš„æ—§æ¡¶å· h.noverflow = 0 // å·²ä½¿ç”¨çš„æº¢å‡ºæ¡¶ // h.extra.overflow å’Œ h.extra.oldoverflow // 5) æº¢å‡ºæ¡¶ç›¸å…³è®¾ç½®ï¼ˆä¸»è¦æ˜¯GCç›¸å…³ï¼‰ï¼Œä½œç”¨åœ¨å‰é¢å·²ç»ä»‹ç»äº† if h.extra != nil \u0026amp;\u0026amp; h.extra.overflow != nil { // Promote current overflow buckets to the old generation. if h.extra.oldoverflow != nil { throw(\u0026#34;oldoverflow is not nil\u0026#34;) } h.extra.oldoverflow = h.extra.overflow h.extra.overflow = nil } // 6) åˆ†é…äº†å¤‡ç”¨æº¢å‡ºæ¡¶ if nextOverflow != nil { if h.extra == nil { h.extra = new(mapextra) } h.extra.nextOverflow = nextOverflow } // the actual copying of the hash table data is done incrementally // by growWork() and evacuate(). // // å®é™…çš„å“ˆå¸Œè¡¨æ•°æ®å¤åˆ¶æ˜¯é€šè¿‡growWork()å’Œevacuate()å®Œæˆçš„ã€‚ // æ¸è¿›å¼æ‰©å®¹åˆ†é…åˆ°ã€å†™ã€‘å’Œã€åˆ é™¤ã€‘ä¸­è°ƒç”¨growWork()å’Œevacuate()å®Œæˆçš„ã€‚ // æ³¨æ„ï¼šè¯»æ“ä½œã€å¹¶æ²¡æœ‰ã€‘æ¸è¿›å¼è¿ç§»éƒ¨åˆ†æ•°æ®ã€‚ } æ¸è¿›å¼è¿ç§» growWork() æ¸è¿›å¼è¿ç§»æ¡¶æ•°æ®ã€‚å…ˆè¿ç§»å½“å‰ä¼ å…¥çš„æ¡¶å·ï¼Œå†å»è¿ç§»ä¸‹æ¬¡éœ€è¦è¿ç§»çš„æ¡¶å·ã€‚ å› ä¸ºå½“å‰ä¼ å…¥çš„æ¡¶å·ä¸€å®šæ˜¯å½“å‰æ­£åœ¨å†™æˆ–åˆ é™¤çš„keyå¯¹åº”çš„æ¡¶å·ï¼Œå› æ­¤å…ˆè¿ç§»è¯¥æ¡¶ï¼Œç„¶åè¿ç§»å›ºå®šå¢é•¿çš„æ¡¶å·ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 func growWork(t *maptype, h *hmap, bucket uintptr) { // make sure we evacuate the oldbucket corresponding // to the bucket we\u0026#39;re about to use // // ç¡®ä¿æˆ‘ä»¬æ¸…ç©ºäº†å°†è¦ä½¿ç”¨çš„æ¡¶å¯¹åº”çš„oldbucket evacuate(t, h, bucket\u0026amp;h.oldbucketmask()) // evacuate one more oldbucket to make progress on growing // // ç–æ•£æ›´å¤šçš„æ—§æ¡¶ï¼Œä»¥å–å¾—è¿›å±•çš„å¢é•¿ if h.growing() { evacuate(t, h, h.nevacuate)\t// æ³¨æ„è¿™é‡Œä¼ çš„æ¡¶å·æ˜¯h.nevacuate } } evacuate() æ‰§è¡Œä¸€æ¬¡æ¡¶è¿ç§»ï¼Œåœ¨ç–æ•£æ—§æ¡¶æ—¶åªä¿®æ”¹äº†topHashï¼Œå¹¶ä¸”åœ¨æ²¡æœ‰è¿­ä»£å™¨æƒ…å†µä¸‹æ‰æ¸…é™¤key/elemã€‚ å‚æ•°ï¼š t *maptypeï¼šmap ç±»å‹ç»“æ„ã€‚ h *hmapï¼šmap å†…å­˜ç»“æ„ã€‚ oldbucket uintptrï¼šå½“å‰éœ€è¦è¿ç§»æ¡¶çš„ç¼–å·ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 func evacuate(t *maptype, h *hmap, oldbucket uintptr) { // 1) oldbucket æ¡¶å·å¯¹åº”çš„ *bmap b := (*bmap)(add(h.oldbuckets, oldbucket*uintptr(t.bucketsize))) // *bmap newbit := h.noldbuckets() // æ—§æ¡¶æ•°é‡ï¼Œç­‰é‡æ‰©å®¹å°±æ˜¯ 1\u0026lt;\u0026lt;h.Bï¼Œç¿»å€æ‰©å®¹ä¸º 1\u0026lt;\u0026lt;(h.B-1) // 2) å½“å‰æ¡¶æ²¡æœ‰è¢«è¿ç§»ï¼Œtophash[0] not in (2,3,4) if !evacuated(b) { // TODO: reuse overflow buckets instead of using new ones, if there // is no iterator using the old buckets. (If !oldIterator.) // // TODO: å¦‚æœæ²¡æœ‰è¿­ä»£å™¨ä½¿ç”¨æ—§çš„æ¡¶ï¼Œåˆ™é‡ç”¨æº¢å‡ºçš„æ¡¶ï¼Œè€Œä¸æ˜¯ä½¿ç”¨æ–°çš„æ¡¶ã€‚(If !oldIterator) // xy contains the x and y (low and high) evacuation destinations. // // xyåŒ…å«xå’Œy(low and high)ç–æ•£ç›®çš„åœ°ã€‚ // 2.1) è®°å½•è¿ç§»åæ¡¶çš„å»å‘ï¼Œxä¸æ—§æ¡¶ï¼Œyåˆ™æ˜¯æ–°æ¡¶ var xy [2]evacDst\tx := \u0026amp;xy[0] // æµå‘æ—§æ¡¶æ—¶çš„æ¡¶ä¿¡æ¯ã€‚ x.b = (*bmap)(add(h.buckets, oldbucket*uintptr(t.bucketsize))) x.k = add(unsafe.Pointer(x.b), dataOffset) x.e = add(x.k, bucketCnt*uintptr(t.keysize)) // 2.2) ç¿»å€æ‰©å®¹ if !h.sameSizeGrow() {\t// Only calculate y pointers if we\u0026#39;re growing bigger. // Otherwise GC can see bad pointers. // // åªæœ‰å½“yæŒ‡é’ˆç¿»å€æ‰©å®¹æ—¶æ‰è®¡ç®—ã€‚å¦åˆ™GCä¼šçœ‹åˆ°åæŒ‡é’ˆã€‚ y := \u0026amp;xy[1] // æµå‘æ–°æ¡¶æ—¶çš„æ¡¶ä¿¡æ¯ã€‚ y.b = (*bmap)(add(h.buckets, (oldbucket+newbit)*uintptr(t.bucketsize))) y.k = add(unsafe.Pointer(y.b), dataOffset) y.e = add(y.k, bucketCnt*uintptr(t.keysize)) } // 2.3) éå†ã€å¸¸è§„æ¡¶ã€‘å’Œåé¢çš„ã€æº¢å‡ºæ¡¶ã€‘ for ; b != nil; b = b.overflow(t) { k := add(unsafe.Pointer(b), dataOffset) // keyå¼€å§‹é¦–åœ°å€ e := add(k, bucketCnt*uintptr(t.keysize)) // elemå¼€å§‹é¦–åœ°å€ // 2.4) éå†å½“å‰æ¡¶ iã€kã€e åˆ†åˆ«å¯¹åº”å½“å‰æ¡¶ indexã€keyã€elem // const bucketCnt = 8 for i := 0; i \u0026lt; bucketCnt; i, k, e = i+1, add(k, uintptr(t.keysize)), add(e, uintptr(t.elemsize)) { top := b.tophash[i] // 2.4.1) å½“å‰iå¤„ä¸ºç©ºï¼Œtop \u0026lt;= 1 if isEmpty(top) { // const evacuatedEmpty = 4 // 0æˆ–1 æ ‡è®°ä¸º 4 b.tophash[i] = evacuatedEmpty\tcontinue } // const minTopHash = 5 if top \u0026lt; minTopHash { throw(\u0026#34;bad map state\u0026#34;) } // 2.4.2) æœ‰æ•°æ®éœ€è¦è¿ç§» k2 := k\t// kæ˜¯å½“å‰éå†æ¡¶\u0026amp;key\tunsafe.Pointer if t.indirectkey() { // é—´æ¥å­˜å‚¨ k2 = *((*unsafe.Pointer)(k2)) } // ç”±äºè®°å½•æ¡¶çš„æµå‘ 0.æ—§æ¡¶ 1.æ–°æ¡¶ var useY uint8\tif !h.sameSizeGrow() { // ç¿»å€æ‰©å®¹ // Compute hash to make our evacuation decision (whether we need // to send this key/elem to bucket x or bucket y). // // è®¡ç®—å“ˆå¸Œå€¼ä»¥åšå‡ºç–æ•£å†³ç­–(æˆ‘ä»¬éœ€è¦å°†è¿™ä¸ªé”®/elemå‘é€åˆ°æ¡¶xè¿˜æ˜¯æ¡¶y)ã€‚ hash := t.hasher(k2, uintptr(h.hash0)) // !t.reflexivekey() == true è¯´æ˜ k2 != k2 æˆç«‹ï¼Œæ¯”å¦‚ NaN // h.flags\u0026amp;iterator != 0 è¿­ä»£å™¨åœ¨æ‰©å®¹å if h.flags\u0026amp;iterator != 0 \u0026amp;\u0026amp; !t.reflexivekey() \u0026amp;\u0026amp; !t.key.equal(k2, k2) { // If key != key (NaNs), then the hash could be (and probably // will be) entirely different from the old hash. Moreover, // it isn\u0026#39;t reproducible. Reproducibility is required in the // presence of iterators, as our evacuation decision must // match whatever decision the iterator made. // Fortunately, we have the freedom to send these keys either // way. Also, tophash is meaningless for these kinds of keys. // We let the low bit of tophash drive the evacuation decision. // We recompute a new random tophash for the next level so // these keys will get evenly distributed across all buckets // after multiple grows. // // å¦‚æœ key != key (NaNs)ï¼Œé‚£ä¹ˆè¿™ä¸ªhashå€¼å¯èƒ½(ä¹Ÿå¯èƒ½ä¼š)ä¸æ—§çš„hashå€¼å®Œå…¨ä¸åŒã€‚æ­¤å¤–ï¼Œå®ƒæ˜¯ä¸å¯å¤åˆ¶çš„ã€‚ // åœ¨è¿­ä»£å™¨å­˜åœ¨çš„æƒ…å†µä¸‹ï¼Œéœ€è¦é‡ç°æ€§ï¼Œå› ä¸ºæˆ‘ä»¬çš„ç–æ•£å†³ç­–å¿…é¡»åŒ¹é…è¿­ä»£å™¨æ‰€åšçš„ä»»ä½•å†³ç­–ã€‚ // å¹¸è¿çš„æ˜¯ï¼Œæˆ‘ä»¬å¯ä»¥è‡ªç”±åœ°ä»¥ä»»ä½•æ–¹å¼å‘é€è¿™äº›keysã€‚è€Œä¸”ï¼Œtophashå¯¹äºè¿™ç§ç±»å‹çš„é”®æ²¡æœ‰æ„ä¹‰ã€‚(å› ä¸ºæ— æ³•å–å‡ºæ¥) // æˆ‘ä»¬è®©ä½bitä½çš„tophashæ¥å†³å®šç–æ•£ã€‚ // æˆ‘ä»¬ä¸ºä¸‹ä¸€å±‚é‡æ–°è®¡ç®—ä¸€ä¸ªæ–°çš„éšæœºtophashå€¼ï¼Œè¿™æ ·è¿™äº›é”®åœ¨å¢é•¿å¤šæ¬¡åå°†å‡åŒ€åˆ†å¸ƒåˆ°æ‰€æœ‰æ¡¶ä¸­ã€‚ // æ³¨æ„è¿™é‡Œçš„topæ˜¯æ—§æ¡¶çš„tophashåœ¨è®¡ç®—ç–æ•£æ–¹å‘ useY = top \u0026amp; 1 // topçš„æœ€ä½ä½ç”¨æ¥éšæœºè®¡ç®—ï¼Œä»¥ä¾¿å‡åŒ€çš„åˆ†å¸ƒè¿™äº›keyåˆ°å­˜å‚¨æ¡¶ä¸­å» top = tophash(hash) // ä»æ–°è®¡ç®—tophashï¼Œè¯¥topå­˜å‚¨åœ¨æ–°æ¡¶ } else { // æ²¡æœ‰è¿­ä»£å™¨åœ¨è¿è¡Œ æˆ– k == kæˆç«‹ // æµå‘æ–°æ¡¶ï¼Œnewbitæ˜¯æ—§æ¡¶æ•°é‡ä¸º2çš„å¹‚æ¬¡æ–¹ if hash\u0026amp;newbit != 0 {\tuseY = 1 } } } // const evacuatedX = 2 // const evacuatedY = 3 if evacuatedX+1 != evacuatedY || evacuatedX^1 != evacuatedY { throw(\u0026#34;bad evacuatedN\u0026#34;) } // tophash = 2 æˆ– 3ï¼Œæ•°æ®æµå‘; // æ³¨æ„ä¸Šé¢çš„ useY = top \u0026amp; 1; // å³ä½¿è¿™é‡Œä¿®æ”¹äº†æ—§æ¡¶çš„topHashä¹Ÿèƒ½çŸ¥é“ç–æ•£æ–¹å‘ï¼Œå› ä¸º2å’Œ3ä»£è¡¨ç–æ•£æ–¹å‘ b.tophash[i] = evacuatedX + useY // evacuatedX + 1 == evacuatedY // dstç›®æ ‡æ¡¶ dst := \u0026amp;xy[useY] // evacuation destination // å½“å‰æ¡¶å·²ç»å­˜æ»¡äº† // const bucketCnt = 8 if dst.i == bucketCnt { dst.b = h.newoverflow(t, dst.b)\t// å…³è”æ¡¶å¹¶åˆ†é…æ–°çš„æº¢å‡ºæ¡¶ dst.i = 0 dst.k = add(unsafe.Pointer(dst.b), dataOffset) dst.e = add(dst.k, bucketCnt*uintptr(t.keysize)) } // tophash è¿ç§» dst.b.tophash[dst.i\u0026amp;(bucketCnt-1)] = top // mask dst.i as an optimization, to avoid a bounds check if t.indirectkey() { // é—´æ¥å­˜å‚¨ *(*unsafe.Pointer)(dst.k) = k2 // copy pointer } else { typedmemmove(t.key, dst.k, k) // copy elem } if t.indirectelem() { // é—´æ¥å­˜å‚¨ *(*unsafe.Pointer)(dst.e) = *(*unsafe.Pointer)(e) } else { typedmemmove(t.elem, dst.e, e) } dst.i++ // These updates might push these pointers past the end of the // key or elem arrays. That\u0026#39;s ok, as we have the overflow pointer // at the end of the bucket to protect against pointing past the // end of the bucket. dst.k = add(dst.k, uintptr(t.keysize)) dst.e = add(dst.e, uintptr(t.elemsize)) } } // Unlink the overflow buckets \u0026amp; clear key/elem to help GC. // // å½“å‰æ¡¶åŠæº¢å‡ºæ¡¶éƒ½è¢«ç–æ•£å®Œæˆåï¼›æ–­å¼€æº¢å‡ºæ¡¶ å¹¶ æ¸…é™¤key/elemä»¥å¸®åŠ©GC // h.flags\u0026amp;oldIterator == 0ï¼šéå†å™¨æ²¡æœ‰åœ¨éå†æ—§æ•°æ® // t.bucket.ptrdata != 0ï¼šæ¡¶ç±»å‹ä¸­å­˜åœ¨æŒ‡é’ˆï¼Œä¹Ÿå°±æ˜¯ key/elem ç±»å‹ä¸­å­˜åœ¨æŒ‡é’ˆ if h.flags\u0026amp;oldIterator == 0 \u0026amp;\u0026amp; t.bucket.ptrdata != 0 { // å½“å‰æ¸…é™¤æ—§æ¡¶æ‰€åœ¨æ¡¶åœ°å€ b := add(h.oldbuckets, oldbucket*uintptr(t.bucketsize)) // Preserve b.tophash because the evacuation // state is maintained there. // // ä¿ç•™b.tophashï¼Œå› ä¸ºç–æ•£çŠ¶æ€åœ¨é‚£é‡Œä¿æŒã€‚ ptr := add(b, dataOffset) // keyå¼€å§‹åœ°å€ n := uintptr(t.bucketsize) - dataOffset // éœ€è¦æ¸…é™¤çš„å­—èŠ‚é•¿åº¦ // æ¸…é™¤keysã€elemsã€overflowå¸®åŠ©GC memclrHasPointers(ptr, n) } } // growWorkæ–¹æ³•åœ¨è¿ç§»äº†æœ¬æ¬¡æ¡¶åä¼šå†è¿ç§»ä¸€æ¬¡h.nevacuateï¼Œå› æ­¤è¿™é‡Œå¾—åˆ°æ‰§è¡Œ if oldbucket == h.nevacuate { advanceEvacuationMark(h, t, newbit) } } evacuated() åˆ¤æ–­å½“å‰æ¡¶æ˜¯å¦å·²è¢«è¿ç§»ã€‚ 1 2 3 4 5 6 7 func evacuated(b *bmap) bool { h := b.tophash[0] // const emptyOne = 1 // const minTopHash = 5 // b.tophash[0] IN (2,3,4) return h \u0026gt; emptyOne \u0026amp;\u0026amp; h \u0026lt; minTopHash } type evacDst struct evacDst æ˜¯æ¡¶æ•°æ®è¿ç§»æµè½¬çš„ä¸€ä¸ªå­˜å‚¨å™¨ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // evacDst is an evacuation destination. type evacDst struct { // å½“å‰æµè½¬çš„ç›®åœ°æ¡¶ *bmap // ä¹Ÿå°±æ˜¯è¿ç§»åçš„æ–°æ¡¶çš„æ¡¶åœ°å€ï¼Œæ¯”å¦‚ä»Aæ¡¶è¿ç§»åˆ°Bæ¡¶ï¼Œè¿™é‡Œå°±æ˜¯Bæ¡¶çš„æ¡¶åœ°å€ã€‚ b *bmap // current destination bucket // key/elem ç´¢å¼•åˆ°b // è¯¥å€¼é»˜è®¤ä¸º0ï¼Œè¡¨ç¤ºç¬¬ä¸€ä¸ªç´¢å¼•ä¸‹æ ‡ i int // key/elem index into b // æŒ‡å‘å½“å‰keyå­˜å‚¨çš„æŒ‡é’ˆ // è¯¥å€¼é»˜è®¤æŒ‡å‘ç¬¬ä¸€ä¸ªkeyçš„åœ°å€ k unsafe.Pointer // pointer to current key storage // æŒ‡å‘å½“å‰elemå­˜å‚¨çš„æŒ‡é’ˆ // è¯¥å€¼é»˜è®¤æŒ‡å‘ç¬¬ä¸€ä¸ªelemçš„åœ°å€ e unsafe.Pointer // pointer to current elem storage } isEmpty() åˆ¤æ–­å½“å‰ slot å¤„æ˜¯å¦ä¸ºç©ºã€‚ 1 2 3 4 5 // isEmpty reports whether the given tophash array entry represents an empty bucket entry. func isEmpty(x uint8) bool { // const emptyOne = 1 return x \u0026lt;= emptyOne } advanceEvacuationMark() h.nevacuate æ¡¶å·å¾—åˆ°è¿ç§»åç›¸å…³åˆ¤æ–­è¿ç§»å®Œæ¯•ä»£ç ã€‚ å‚æ•°ï¼š h *hmapï¼šmap çš„å†…å­˜ç»“æ„ã€‚ t *maptypeï¼šmap çš„ç±»å‹ç»“æ„ã€‚ newbit uintptrï¼šæ‰©å®¹åçš„æ€»æ•°é‡ï¼Œç¿»å€æ‰©å®¹æ˜¯ä¹‹å‰å®¹é‡çš„ä¸¤å€ï¼Œç­‰é‡æ‰©å®¹å°±æ˜¯ä¹‹å‰çš„å®¹é‡ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 func advanceEvacuationMark(h *hmap, t *maptype, newbit uintptr) {\th.nevacuate++ // ä¸‹ä¸€ä¸ªéœ€è¦è¿ç§»çš„æ¡¶å· // Experiments suggest that 1024 is overkill by at least an order of magnitude. // Put it in there as a safeguard anyway, to ensure O(1) behavior. // // å®éªŒè¡¨æ˜ï¼Œ1024æ˜¯å¤šä½™çš„ï¼Œè‡³å°‘æ˜¯ä¸€ä¸ªæ•°é‡çº§ã€‚æŠŠå®ƒæ”¾åœ¨é‚£é‡Œä½œä¸ºä¸€ç§ä¿æŠ¤æªæ–½ï¼Œä»¥ç¡®ä¿O(1)è¡Œä¸ºã€‚ stop := h.nevacuate + 1024 // stopæ˜¯ä¸€ä¸ªå¾ªç¯æ¬¡æ•°æœ€å¤§1024æ¬¡ // newbit æœªæ‰©å®¹å‰æ¡¶æ•°é‡ï¼Œstop \u0026gt; newbit å‰©ä½™æ‰©å®¹æ•°é‡åœ¨[0,1024]é—´ if stop \u0026gt; newbit { stop = newbit } // å¾ªç¯ä¸€å®šçš„æ¬¡æ•°ï¼Œåˆ¤æ–­åé¢çš„æ¡¶æ˜¯å¦å·²ç»è¿ç§»äº† for h.nevacuate != stop \u0026amp;\u0026amp; bucketEvacuated(t, h, h.nevacuate) { h.nevacuate++ } // æ¡¶å·²ç»è¿ç§»å®Œ if h.nevacuate == newbit { // newbit == # of oldbuckets // Growing is all done. Free old main bucket array. h.oldbuckets = nil // é‡Šæ”¾oldbuckets // Can discard old overflow buckets as well. // If they are still referenced by an iterator, // then the iterator holds a pointers to the slice. // // å¯ä»¥ä¸¢å¼ƒæ—§çš„æº¢å‡ºæ¡¶ã€‚å¦‚æœå®ƒä»¬ä»ç„¶è¢«è¿­ä»£å™¨å¼•ç”¨ï¼Œåˆ™è¿­ä»£å™¨ä¿å­˜ä¸€ä¸ªæŒ‡å‘ç‰‡çš„æŒ‡é’ˆã€‚ if h.extra != nil { h.extra.oldoverflow = nil } h.flags \u0026amp;^= sameSizeGrow // æ¸…é™¤sameSizeGrowæ ‡å¿—ä½ï¼Œå¦‚æœè®¾ç½®äº†çš„è¯ } } bucketEvacuated() åˆ¤æ–­ bucket æ¡¶æ˜¯å¦å·²ç»è¿ç§»äº†ã€‚ 1 2 3 4 func bucketEvacuated(t *maptype, h *hmap, bucket uintptr) bool { b := (*bmap)(add(h.oldbuckets, bucket*uintptr(t.bucketsize))) return evacuated(b) } åˆ é™¤ ğŸš€ delete() å†…ç½®å‡½æ•°delete()å°†æŒ‡å®šé”®å€¼(m[key])çš„å…ƒç´ ä»mapä¸­åˆ é™¤ã€‚ å¦‚æœmä¸ºnilæˆ–ä¸å­˜åœ¨è¿™æ ·çš„å…ƒç´ ï¼Œåˆ™delete()ä¸ºç©ºæ“ä½œã€‚ 1 2 3 4 // The delete built-in function deletes the element with the specified key // (m[key]) from the map. If m is nil or there is no such element, delete // is a no-op. func delete(m map[Type]Type1, key Type) mapdelete() deleteåˆ é™¤mapã€‚ å¦‚æœåˆ é™¤çš„æ˜¯ä¸­é—´æ•°æ®ç›´æ¥æ ‡è®°å¹¶æ¸…é™¤keyå’Œelemå³å¯ã€‚ å¦‚æœåˆ é™¤çš„æ˜¯æœ€åä¸€ä¸ªåˆ™éœ€è¦å‘å‰åˆ¤æ–­å‰é¢æ˜¯å¦å·²è¢«åˆ é™¤ä¾æ¬¡æ ‡è®°tophashä¸º0ã€‚ å‚æ•°ï¼š t *maptypeï¼šmapç±»å‹ç»“æ„ã€‚ h *hmapï¼šmapå†…å­˜ç»“æ„ã€‚ key unsafe.Pointerï¼šéœ€è¦åˆ é™¤çš„keyåœ°å€ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 func mapdelete(t *maptype, h *hmap, key unsafe.Pointer) { if raceenabled \u0026amp;\u0026amp; h != nil { callerpc := getcallerpc() pc := abi.FuncPCABIInternal(mapdelete) racewritepc(unsafe.Pointer(h), callerpc, pc) raceReadObjectPC(t.key, key, callerpc, pc) } if msanenabled \u0026amp;\u0026amp; h != nil { msanread(key, t.key.size) } if asanenabled \u0026amp;\u0026amp; h != nil { asanread(key, t.key.size) } // 1) æœªåˆå§‹çš„map æˆ– mapæ²¡æœ‰key/elemå¯¹ if h == nil || h.count == 0 { // å½“keyä¸ºanyç±»å‹æ—¶ï¼Œåœ¨keyç»è¿‡hashæ—¶å¯èƒ½ä¼šå‘ç”Ÿpanic // t.hashMightPanic()åˆ¤æ–­å½“å‰hashå‡½æ•°æ˜¯å¦å¯èƒ½å‘ç”Ÿpanic if t.hashMightPanic() { // å°è¯•hash panic t.hasher(key, 0) // see issue 23734 } return } // 2) å½“å‰mapæ­£åœ¨å¹¶å‘å†™æ“ä½œ if h.flags\u0026amp;hashWriting != 0 { fatal(\u0026#34;concurrent map writes\u0026#34;) } // 3) keyæ ¹æ®h.hash0ç”Ÿæˆhashå€¼ï¼Œæ ¹æ®ä¸Šé¢keyä¸ºanyæ—¶è¿™é‡Œhashå¯èƒ½ä¼španic hash := t.hasher(key, uintptr(h.hash0)) // Set hashWriting after calling t.hasher, since t.hasher may panic, // in which case we have not actually done a write (delete). // // åœ¨è°ƒç”¨t.hasherä¹‹åè®¾ç½®hashWritingï¼Œå› ä¸ºt.hasherå¯èƒ½ä¼šå‘ç”Ÿé”™è¯¯ï¼Œ // åœ¨è¿™ç§æƒ…å†µä¸‹æˆ‘ä»¬å®é™…ä¸Šå¹¶æ²¡æœ‰æ‰§è¡Œå†™å…¥(delete)æ“ä½œã€‚ h.flags ^= hashWriting bucket := hash \u0026amp; bucketMask(h.B) // å½“å‰keyå¯¹åº”æ¡¶å· // 4) æ­£åœ¨æ‰©å®¹è¿›è¡Œä¸­ï¼Œå»è¿ç§»è¯¥æ¡¶çš„æ•°æ® if h.growing() { growWork(t, h, bucket) } b := (*bmap)(add(h.buckets, bucket*uintptr(t.bucketsize))) // *bmap bOrig := b\t// å½“å‰å˜é‡å¼€å§‹æ¡¶ï¼Œç”¨äºå‘å‰éå†æ—¶åˆ¤æ–­ç»“æŸç‚¹ top := tophash(hash) search: // 5) å˜é‡å½“å‰å¸¸è§„æ¡¶ä»¥åŠåé¢æº¢å‡ºæ¡¶(å¦‚æœå­˜åœ¨) for ; b != nil; b = b.overflow(t) { // éå†å½“å‰æ¡¶ // const bucketCnt = 8 for i := uintptr(0); i \u0026lt; bucketCnt; i++ { // tophashæ¯”å¯¹å¤±è´¥ if b.tophash[i] != top { // const emptyRest = 0 // åé¢slotéƒ½æ²¡æœ‰æ•°æ® if b.tophash[i] == emptyRest { break search } continue } // tophashæ¯”å¯¹æˆåŠŸ; // å¯èƒ½æ˜¯ã€tophashå†²çªã€‘ æˆ– ã€åŒ¹é…åˆ°äº†keyã€‘ k := add(unsafe.Pointer(b), dataOffset+i*uintptr(t.keysize)) // key k2 := k if t.indirectkey() {\t// é—´æ¥å­˜å‚¨ k2 = *((*unsafe.Pointer)(k2)) } // æ¯”å¯¹å¤±è´¥ tophashå†²çª // NaN çš„ key æ— æ³•è¢«åˆ é™¤ if !t.key.equal(key, k2) {\tcontinue } // key æ¯”å¯¹æˆåŠŸ // Only clear key if there are pointers in it. // // åªæœ‰åœ¨ key ä¸­æœ‰æŒ‡é’ˆæ—¶æ‰æ¸…é™¤ keyã€‚ if t.indirectkey() { // é—´æ¥å­˜å‚¨æ—¶ *(*unsafe.Pointer)(k) = nil // æ¸…ç©ºkey } else if t.key.ptrdata != 0 { // key ä¸­å­˜åœ¨æŒ‡é’ˆç±»å‹æ•°æ®æ—¶ memclrHasPointers(k, t.key.size) // æ¸…ç©ºkey } e := add(unsafe.Pointer(b), dataOffset+bucketCnt*uintptr(t.keysize)+i*uintptr(t.elemsize)) // elem if t.indirectelem() { // ç®€ä»‹å­˜å‚¨æ—¶ *(*unsafe.Pointer)(e) = nil // æ¸…ç©ºelem } else if t.elem.ptrdata != 0 { // elem ä¸­å­˜åœ¨æŒ‡é’ˆç±»å‹æ•°æ®æ—¶ memclrHasPointers(e, t.elem.size) // æ¸…ç©ºelem } else { // elem ä¸­ä¸å­˜åœ¨æŒ‡é’ˆç±»å‹æ•°æ®æ—¶ memclrNoHeapPointers(e, t.elem.size) // æ¸…ç©ºelem } // æ ‡è®° tophash ä½ä¸º 1 b.tophash[i] = emptyOne // emptyOne == 1 // If the bucket now ends in a bunch of emptyOne states, // change those to emptyRest states. // It would be nice to make this a separate function, but // for loops are not currently inlineable. // // å½“å‰æ¡¶æœ€åä¸€ä¸ª key if i == bucketCnt-1 { if b.overflow(t) != nil \u0026amp;\u0026amp; b.overflow(t).tophash[0] != emptyRest { // å­˜åœ¨æº¢å‡ºæ¡¶å¹¶ä¸”åé¢è¿˜æœ‰æ•°æ®ï¼Œå¤„ç†åç»­åç›´æ¥è¿”å›ã€‚ // å› ä¸ºåé¢æœ‰æ•°æ®ä¸éœ€è¦æ¸…æ¥šå·²è¢«åˆ é™¤çš„å…¶ä»–slotã€‚ goto notLast } } else { // åé¢ä¸€ä¸ªtophash != 0; åé¢è¿˜æœ‰æ•°æ® // const emptyRest = 0 if b.tophash[i+1] != emptyRest { goto notLast } } // åé¢æ²¡æœ‰æ•°æ®äº†ï¼Œéœ€è¦å‘å‰éå†å¤„ç†å·²ç»åˆ é™¤çš„slot for { // const emptyRest = 0 // æ ‡è®°å½“å‰tophashä¸º0 b.tophash[i] = emptyRest\t// å½“å‰æ¡¶çš„ç¬¬ä¸€ä¸ªslot if i == 0 { if b == bOrig { // å·²ç»åˆ°æœ€å‰çš„å¸¸è§„æ¡¶äº† break // beginning of initial bucket, we\u0026#39;re done. } // Find previous bucket, continue at its last entry. c := b for b = bOrig; b.overflow(t) != c; b = b.overflow(t) { } i = bucketCnt - 1 } else { // å‘å‰å›æº¯ i-- } // const emptyOne = 1 // å› ä¸ºåˆ é™¤çš„ç©ºæ ¼å…¨éƒ¨æ ‡è®°ä¸ºäº†1ï¼Œå› æ­¤!=1è¯´æ˜å­˜åœ¨æ•°æ®äº†ç›´æ¥é€€å‡º if b.tophash[i] != emptyOne { break } } notLast: // key/elemå¯¹æ•°é‡å‡ä¸€ h.count--\t// Reset the hash seed to make it more difficult for attackers to // repeatedly trigger hash collisions. See issue 25237. // // é‡ç½®hashå€¼ï¼Œä½¿æ”»å‡»è€…æ›´éš¾è§¦å‘hashç¢°æ’ã€‚ if h.count == 0 { h.hash0 = fastrand() // é‡ç½®hash0 } break search } } // å¹¶å‘åˆ¤æ–­ if h.flags\u0026amp;hashWriting == 0 {\tfatal(\u0026#34;concurrent map writes\u0026#34;) } h.flags \u0026amp;^= hashWriting // æ¸…é™¤hashWritingæ ‡å¿—ä½ } len() ğŸš€ reflect_maplen() len() å‡½æ•°å®ç°ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 //go:linkname reflect_maplen reflect.maplen func reflect_maplen(h *hmap) int { if h == nil { return 0 } if raceenabled { callerpc := getcallerpc() racereadpc(unsafe.Pointer(h), callerpc, abi.FuncPCABIInternal(reflect_maplen)) } // ç›´æ¥å–å€¼ hmap.count return h.count } è¿­ä»£å™¨ ğŸš€ type hiter struct hash è¿­ä»£å™¨ã€‚ å¦‚æœä½ ä¿®æ”¹äº†hiterï¼Œä¹Ÿè¦ä¿®æ”¹ cmd/compile/internal/reflectdata/reflect.go å’Œ reflect/value.go æ¥åŒ¹é…è¿™ä¸ªç»“æ„çš„å¸ƒå±€ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 // A hash iteration structure. // If you modify hiter, also change cmd/compile/internal/reflectdata/reflect.go // and reflect/value.go to match the layout of this structure. type hiter struct { // å¿…é¡»åœ¨ç¬¬ä¸€ä½ç½®ã€‚å†™å…¥nilæ¥è¡¨ç¤ºè¿­ä»£ç»“æŸ(å‚è§cmd/compile/internal/walk/range.go)ã€‚ key unsafe.Pointer // Must be in first position. Write nil to indicate iteration end (see cmd/compile/internal/walk/range.go). // å¿…é¡»åœ¨ç¬¬äºŒä½ç½®(å‚è§cmd/compile/internal/walk/range.go)ã€‚ elem unsafe.Pointer // Must be in second position (see cmd/compile/internal/walk/range.go). // mapç±»å‹ç»“æ„ t *maptype\t// mapå†…å­˜ç»“æ„ h *hmap\t// å¸¸è§„æ¡¶åœ°å€ buckets unsafe.Pointer // bucket ptr at hash_iter initialization time // æ­£åœ¨è¿­ä»£çš„æ¡¶ï¼Œå¦‚æœbptr == nilåˆ™ä»bucketè·å–æ¡¶å·è¿­ä»£ bptr *bmap // current bucket overflow *[]*bmap // keeps overflow buckets of hmap.buckets alive oldoverflow *[]*bmap // keeps overflow buckets of hmap.oldbuckets alive // å¼€å§‹éå†çš„æ¡¶å·ï¼Œéšæœºçš„ï¼Œç”¨äºå¼€å§‹éå†çš„èµ·ç‚¹ä»¥åŠç»“æŸéå†çš„ç»ˆç‚¹ startBucket uintptr // bucket iteration started at // tophashåç§»å€¼ï¼Œåœ¨[0,7]ä¸­éšæœºç”Ÿæˆçš„å€¼ï¼Œç”¨äºåç»­ i + offset \u0026amp; 7 ç”¨ä½œåç§»é‡ offset uint8 // intra-bucket offset to start from during iteration (should be big enough to hold bucketCnt-1) // å½“å‰éå†å·²è¿‡æœ€å¤§æ¡¶(1 \u0026lt;\u0026lt; B)æ—¶è¢«è®¾ç½®ä¸ºtrue wrapped bool // already wrapped around from end of bucket array to beginning B uint8 // åˆå§‹åŒ–æ—¶æ¡¶çš„æ•°é‡ 1 \u0026lt;\u0026lt; B // å½“å‰æ¡¶éå†çš„ç´¢å¼•ï¼Œé»˜è®¤å€¼ä»0å¼€å§‹ï¼Œè¯¥å€¼é…åˆoffsetéå†tophashï¼Œi + offset \u0026amp; 7 i uint8 // åˆå§‹åŒ–æ—¶æ˜¯startBucketçš„å€¼ // 1. bptr == nilæ—¶bucketå­˜å‚¨éœ€è¦éå†çš„æ¡¶å· // 2. bptr != nilæ—¶bucketä¸‹ä¸ªæ¡¶çš„æ¡¶å· bucket uintptr // ä¸‹ä¸ªè¿­ä»£å™¨è¿­ä»£çš„æ¡¶å· checkBucket uintptr // éœ€è¦æ£€æŸ¥çš„æ¡¶å· } åˆå§‹åŒ–è¿­ä»£å™¨ mapiterinit() mapiterinit() åˆå§‹åŒ–ç”¨äºåœ¨ map ä¸Šè¿›è¡ŒèŒƒå›´æœç´¢çš„ hiter ç»“æ„ä½“ã€‚ 'it'æŒ‡å‘çš„hiterç»“æ„ä½“ç”±ç¼–è¯‘å™¨order passåˆ†é…åˆ°æ ˆä¸Šï¼Œæˆ–ç”±reflect_mapiterinitåˆ†é…åˆ°å †ä¸Šã€‚ ä¸¤è€…éƒ½éœ€è¦å°†hiterç½®é›¶ï¼Œå› ä¸ºè¯¥ç»“æ„ä½“åŒ…å«æŒ‡é’ˆã€‚ å‚æ•°ï¼š t *maptypeï¼šmap ç±»å‹ç»“æ„ã€‚ h *hmapï¼šmap å†…å­˜ç»“æ„ã€‚ it *hiterï¼šéå†å™¨å­˜å‚¨çš„ç»“æ„ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 // mapiterinit initializes the hiter struct used for ranging over maps. // The hiter struct pointed to by \u0026#39;it\u0026#39; is allocated on the stack // by the compilers order pass or on the heap by reflect_mapiterinit. // Both need to have zeroed hiter since the struct contains pointers. func mapiterinit(t *maptype, h *hmap, it *hiter) { if raceenabled \u0026amp;\u0026amp; h != nil { callerpc := getcallerpc() racereadpc(unsafe.Pointer(h), callerpc, abi.FuncPCABIInternal(mapiterinit)) } it.t = t // 1) æœªåˆå§‹åŒ–çš„map æˆ– key/elemå¯¹ä¸ºç©ºçš„map if h == nil || h.count == 0 { return } if unsafe.Sizeof(hiter{})/goarch.PtrSize != 12 { throw(\u0026#34;hash_iter size incorrect\u0026#34;) // see cmd/compile/internal/reflectdata/reflect.go } it.h = h // grab snapshot of bucket state // // 2) æŠ“å–æ¡¶çŠ¶æ€å¿«ç…§ it.B = h.B it.buckets = h.buckets if t.bucket.ptrdata == 0 { // Allocate the current slice and remember pointers to both current and old. // This preserves all relevant overflow buckets alive even if // the table grows and/or overflow buckets are added to the table // while we are iterating. // // åˆ†é…å½“å‰åˆ‡ç‰‡å¹¶è®°ä½æŒ‡å‘å½“å‰å’Œæ—§åˆ‡ç‰‡çš„æŒ‡é’ˆã€‚ // è¿™ä½¿å¾—æ‰€æœ‰ç›¸å…³çš„æº¢å‡ºæ¡¶éƒ½ä¿æŒæ´»è·ƒï¼Œå³ä½¿è¡¨å¢é•¿ï¼Œand/or åœ¨è¿­ä»£æ—¶æº¢å‡ºæ¡¶è¢«æ·»åŠ åˆ°è¡¨ä¸­ã€‚ h.createOverflow()\t// åˆ¤æ–­h.extraæ˜¯å¦åˆå§‹åŒ– it.overflow = h.extra.overflow it.oldoverflow = h.extra.oldoverflow } // decide where to start // // 3) å†³å®šä»å“ªé‡Œå¼€å§‹ var r uintptr if h.B \u0026gt; 31-bucketCntBits {\t// h.B \u0026gt; 31 - 3 r = uintptr(fastrand64()) // uint64 } else { r = uintptr(fastrand()) // uint32 } // 4) ç”¨äºç¡®å®šä»é‚£ä¸ªæ¡¶å¼€å§‹éå† it.startBucket = r \u0026amp; bucketMask(h.B) // éšæœºæ•°ç¡®å®šå¼€å§‹çš„æ¡¶å· // 5) ç”¨äºç¡®å®šåœ¨æ¯ä¸ªæ¡¶çš„éšæœºåç§»é‡ it.offset = uint8(r \u0026gt;\u0026gt; h.B \u0026amp; (bucketCnt - 1)) // éšæœºçš„åç§»é‡[0,7]ä¸­éšæœºæ•° // iterator state it.bucket = it.startBucket\t// å½“å‰è¿­ä»£æ¡¶å· // Remember we have an iterator. // Can run concurrently with another mapiterinit(). // // 6) è®°ä½æˆ‘ä»¬æœ‰ä¸€ä¸ªè¿­ä»£å™¨ã€‚å¯ä»¥ä¸å¦ä¸€ä¸ªmapiterinit()å¹¶å‘è¿è¡Œã€‚ if old := h.flags; old\u0026amp;(iterator|oldIterator) != iterator|oldIterator { atomic.Or8(\u0026amp;h.flags, iterator|oldIterator) // è®¾ç½®è¿­ä»£æ ‡å¿— iteratorå’ŒoldIterator } mapiternext(it) } è¿­ä»£ mapiternext() æ‰©å®¹å‘ç”Ÿåœ¨è¿­ä»£å™¨ä¹‹å‰ï¼Œæ­¤æ—¶åº”è¯¥å»å˜é‡æ‰©å®¹åçš„æ‰€æœ‰æ¡¶ï¼Œéƒ½æ˜¯ä»æ—§æ¡¶å‡ºå‘ã€‚è¿™ç§æƒ…å†µæ—§æ¡¶é‡Œé¢å¯èƒ½æ²¡key/elemä»¥åŠoverflowä¿¡æ¯ã€‚ æ‰©å®¹å‘ç”Ÿåœ¨è¿­ä»£å™¨ä¹‹åï¼Œæ­¤æ—¶åº”è¯¥éå†æ‰€æœ‰çš„æ—§æ¡¶æ•°é‡ï¼Œä»æ—§æ¡¶å‡ºå‘ã€‚è¿™ç§æƒ…å†µæ—§æ¡¶ä¿ç•™äº†æ‰€æœ‰çš„key/elemä»¥åŠoverflowä¿¡æ¯ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 func mapiternext(it *hiter) { h := it.h\t// *hmap if raceenabled { callerpc := getcallerpc() racereadpc(unsafe.Pointer(h), callerpc, abi.FuncPCABIInternal(mapiternext)) } if h.flags\u0026amp;hashWriting != 0 { fatal(\u0026#34;concurrent map iteration and map write\u0026#34;) } t := it.t // *maptype bucket := it.bucket\t// éœ€è¦è¿­ä»£æ¡¶å· b := it.bptr // å½“å‰æ­£åœ¨è¿­ä»£çš„æ¡¶ *bmap i := it.i // å½“å‰éå†bptræ¡¶çš„ç´¢å¼• checkBucket := it.checkBucket // éœ€è¦æ£€æŸ¥çš„æ¡¶ next:\t// æ ¹æ®bucketè·å–*bmap if b == nil {\t// mapéå†å®Œäº† if bucket == it.startBucket \u0026amp;\u0026amp; it.wrapped { // end of iteration // ç»“æŸè¿­ä»£å™¨ it.key = nil it.elem = nil return } // h.growing()ï¼šæ­£åœ¨æ‰©å®¹ä¸­ // it.B == h.Bï¼šæ‰©å®¹å‘ç”Ÿåœ¨è¿­ä»£å™¨ä¹‹å‰ï¼Œè¿­ä»£å™¨å¼€å§‹æ—¶å·²ç»åœ¨è¿›è¡Œæ‰©å®¹äº† // 1. è¿™ç§æƒ…å†µå¯èƒ½å‘ç”Ÿéƒ¨åˆ†æ•°æ®è¿˜åœ¨æ—§æ¡¶é‡Œé¢ï¼Œä¹Ÿå¯èƒ½åœ¨æ–°æ¡¶é‡Œé¢ // 2. éšç€æ‰©å®¹åœ¨è¿›è¡Œä¸­ï¼Œå¯èƒ½å‡ºç°éƒ¨åˆ†æ•°æ®åœ¨æ—§æ¡¶éƒ¨åˆ†æ•°æ®åœ¨æ–°æ¡¶ if h.growing() \u0026amp;\u0026amp; it.B == h.B {\t// æ•°æ®å¯èƒ½åœ¨æ—§æ¡¶é‡Œé¢ï¼Œå¯èƒ½åœ¨æ–°æ¡¶é‡Œ // Iterator was started in the middle of a grow, and the grow isn\u0026#39;t done yet. // If the bucket we\u0026#39;re looking at hasn\u0026#39;t been filled in yet (i.e. the old // bucket hasn\u0026#39;t been evacuated) then we need to iterate through the old // bucket and only return the ones that will be migrated to this bucket. // // è¿­ä»£å™¨æ˜¯åœ¨æ‰©å®¹è¿‡ç¨‹è¿›è¡Œä¸­å¯åŠ¨çš„ï¼Œè€Œä¸”æ‰©å®¹è¿˜æ²¡æœ‰å®Œæˆ // å¦‚æœæˆ‘ä»¬æŸ¥çœ‹çš„æ¡¶è¿˜æ²¡æœ‰è¢«å¡«å……ï¼ˆå³æ—§æ¡¶è¿˜æ²¡æœ‰è¢«æ¸…ç©ºï¼‰ï¼Œé‚£ä¹ˆæˆ‘ä»¬éœ€è¦è¿­ä»£æ—§æ¡¶ï¼Œå¹¶åªè¿”å›å°†è¦è¿ç§»åˆ°æ­¤æ¡¶çš„é‚£äº›ã€‚ oldbucket := bucket \u0026amp; it.h.oldbucketmask() // æ—§æ¡¶ç¼–å· b = (*bmap)(add(h.oldbuckets, oldbucket*uintptr(t.bucketsize)))\t// æ—§æ¡¶ *bmap // å…¶å®è¿™ç§æƒ…å†µä¸€ç›´æ˜¯åœ¨æ£€æŸ¥æ—§æ¡¶ï¼Œæ—§æ¡¶æ•°æ®æœ‰æ²¡è¢«è¿ç§»è¿ç§»åˆ°å“ªé‡Œäº† if !evacuated(b) { // æ—§æ¡¶æœ‰æ•°æ®ï¼Œå¯èƒ½ä¸‹é¢æ•°æ®è¢«è¿ç§»åˆ°æ–°æ¡¶äº† // éœ€è¦æ£€æŸ¥æ–°æ¡¶çš„æ¡¶å¥½ï¼Œå› æ­¤æ–°æ¡¶æ—§æ¡¶éƒ½è¦æŸ¥çœ‹ checkBucket = bucket\t} else { // å¦‚æœæ—§æ¡¶æ²¡æœ‰æ•°æ®åˆ™è¯´æ˜æ•°æ®ä¸€å®šåœ¨æ–°æ¡¶ b = (*bmap)(add(it.buckets, bucket*uintptr(t.bucketsize))) // æ–°æ¡¶ *bmap // å› æ­¤ä¸éœ€è¦å†æ£€æŸ¥å…¶ä»–çš„æ¡¶äº† checkBucket = noCheck } } else { // !h.growing() || h.growing() \u0026amp;\u0026amp; it.B != h.B // 1. !h.growing(): (æ²¡æœ‰æ‰©å®¹)æ•°æ®åœ¨bæ¡¶é‡Œï¼Œéå†bæ¡¶å³å¯ã€‚ // 2. h.growing() \u0026amp;\u0026amp; it.B != h.B; (æ‰©å®¹å‘ç”Ÿåœ¨è¿­ä»£ä¹‹å)å¯èƒ½bæ¡¶è¢«è¿ç§»äº†ä½†æ˜¯bæ¡¶ä»ç„¶ä¿æŒç€key/elem; // (2)è¿™ç§æƒ…å†µæˆ‘ä»¬ä¸ºä»€ä¹ˆä¸èƒ½ç›´æ¥æ‹¿å»bæ¡¶çš„elemï¼Œå› ä¸ºå¯èƒ½keyåˆè¢«åˆ é™¤æˆ–æ›´æ–°äº†éœ€è¦æŸ¥çœ‹æ–°æ•°æ® // è¿™é‡Œå¯ä»¥çœ‹å‡ºè¿­ä»£æ•°æ®æ—¶æ˜¯æŒ‰ç…§ä¿å­˜å¿«ç…§çš„æ•°æ®ä¸ºå‡†çš„ã€‚ b = (*bmap)(add(it.buckets, bucket*uintptr(t.bucketsize))) checkBucket = noCheck } bucket++ // è¿­ä»£è¿‡äº†æœ€å¤§æ¡¶å· // 1. æ‰©å®¹å‘ç”Ÿåœ¨è¿­ä»£ä¹‹å‰ï¼Œéœ€è¦éå†æ‰€æœ‰æ‰©å®¹åçš„æ¡¶æ•°é‡ï¼Œè¢«ç–æ•£çš„key/elemä¸ç®¡ // 2. æ‰©å®¹å‘ç”Ÿåœ¨è¿­ä»£ä¹‹åï¼Œåˆ™åªä¼šè¿­ä»£æ—§æ¡¶æ•°é‡ï¼Œè¢«ç–æ•£çš„key/elemå»æ–°æ¡¶é‡Œé¢æ‰¾ if bucket == bucketShift(it.B) { // bucket == 1 \u0026lt;\u0026lt; B bucket = 0\t// æ¡¶å·é‡ç½®ä¸º0 it.wrapped = true // æ ‡è®°wrappedå·²è¿‡æœ€å¤§æ¡¶å· } i = 0 } // è¿­ä»£æ¡¶ for ; i \u0026lt; bucketCnt; i++ { offi := (i + it.offset) \u0026amp; (bucketCnt - 1) // tophash[offi] \u0026lt;= 1 || tophash[offi] == 4 // å½“å‰slotå¤„æ²¡æœ‰æ•°æ®ï¼Œå› ä¸ºä¸€ç›´éå†çš„æ˜¯æ—§æ¡¶bï¼Œå¦‚æœæ˜¯ä¸‹é¢è¿™ä¸¤ç§æ¡ä»¶ç›´æ¥è·³è¿‡å³å¯ if isEmpty(b.tophash[offi]) || b.tophash[offi] == evacuatedEmpty { // TODO: emptyRest is hard to use here, as we start iterating // in the middle of a bucket. It\u0026#39;s feasible, just tricky. continue } k := add(unsafe.Pointer(b), dataOffset+uintptr(offi)*uintptr(t.keysize)) if t.indirectkey() { // é—´æ¥å­˜å‚¨ k = *((*unsafe.Pointer)(k)) } e := add(unsafe.Pointer(b), dataOffset+bucketCnt*uintptr(t.keysize)+uintptr(offi)*uintptr(t.elemsize)) // æ‰©å®¹å‘ç”Ÿåœ¨è¿­ä»£å™¨ä¹‹å‰; ç¿»å€æ‰©å®¹æ‰éœ€è¦æ£€æŸ¥æ—§æ¡¶ // checkBucket != noCheckï¼šæœ‰éœ€è¦ç‰¹æ®Šæ£€æŸ¥çš„æ¡¶ // !h.sameSizeGrow()ï¼šå½“å‰æ˜¯ç¿»å€æ‰©å®¹ if checkBucket != noCheck \u0026amp;\u0026amp; !h.sameSizeGrow() {\t// Special case: iterator was started during a grow to a larger size // and the grow is not done yet. We\u0026#39;re working on a bucket whose // oldbucket has not been evacuated yet. Or at least, it wasn\u0026#39;t // evacuated when we started the bucket. So we\u0026#39;re iterating // through the oldbucket, skipping any keys that will go // to the other new bucket (each oldbucket expands to two // buckets during a grow). // // ç‰¹æ®Šæƒ…å†µ:è¿­ä»£å™¨åœ¨å¢é•¿åˆ°æ›´å¤§çš„å°ºå¯¸æœŸé—´å¯åŠ¨ï¼Œä½†å¢é•¿è¿˜æ²¡æœ‰å®Œæˆã€‚ // æˆ‘ä»¬æ­£åœ¨å¤„ç†ä¸€ä¸ªæ¡¶ï¼Œå®ƒçš„æ—§æ¡¶è¿˜æ²¡æœ‰è¢«æ¸…ç©ºã€‚ // è‡³å°‘ï¼Œæˆ‘ä»¬å¯åŠ¨æ°´æ¡¶æ—¶è¿˜æ²¡äººæ’¤ç¦»ã€‚å› æ­¤ï¼Œæˆ‘ä»¬éå†oldbucketï¼Œè·³è¿‡æ‰€æœ‰å°†è¿›å…¥å¦ä¸€ä¸ªæ–°æ¡¶çš„é”®(æ¯ä¸ªoldbucketåœ¨å¢é•¿è¿‡ç¨‹ä¸­ä¼šæ‰©å±•åˆ°ä¸¤ä¸ªæ¡¶)ã€‚ // k == k æˆç«‹ï¼Œè¿™ç§è¯·æ¬¾å‡ºç°åœ¨ +0å’Œ-0è™½ç„¶ç›¸ç­‰ä½†æ˜¯ç”Ÿæˆçš„hashç¡®å®ä¸ç›¸åŒ if t.reflexivekey() || t.key.equal(k, k) {\t// If the item in the oldbucket is not destined for // the current new bucket in the iteration, skip it. // // å¦‚æœæ—§æ¡¶ä¸­çš„é¡¹åœ¨è¿­ä»£ä¸­ä¸æ˜¯ä¸ºå½“å‰çš„æ–°æ¡¶æŒ‡å®šçš„ï¼Œåˆ™è·³è¿‡å®ƒã€‚ hash := t.hasher(k, uintptr(h.hash0)) // hash\u0026amp;bucketMask(it.B) != checkBucket; è¡¨ç¤ºå½“å‰key/elemä¸åº”è¯¥åœ¨checkBucketæ¡¶ä¸­ // åˆ™è·³è¿‡åç»­åˆ°ï¼Œåç»­ä¼šå»æ‰¾è¿™ç§æƒ…å†µ if hash\u0026amp;bucketMask(it.B) != checkBucket { continue } } else { // Hash isn\u0026#39;t repeatable if k != k (NaNs). We need a // repeatable and randomish choice of which direction // to send NaNs during evacuation. We\u0026#39;ll use the low // bit of tophash to decide which way NaNs go. // NOTE: this case is why we need two evacuate tophash // values, evacuatedX and evacuatedY, that differ in // their low bit. // // å¦‚æœ k != k (NaNs)ï¼Œåˆ™ hash æ˜¯ä¸å¯é‡å¤çš„ã€‚ // åœ¨ç–æ•£è¿‡ç¨‹ä¸­ï¼Œæˆ‘ä»¬éœ€è¦ä¸€ä¸ªå¯é‡å¤ä¸”éšæœºçš„é€‰æ‹©å°†NaNsæ´¾å¾€å“ªä¸ªæ–¹å‘ã€‚ // æˆ‘ä»¬å°†ä½¿ç”¨tophashçš„ä½ä½æ¥å†³å®šNaNsçš„æ–¹å‘ã€‚ // æ³¨æ„:åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œæˆ‘ä»¬éœ€è¦ä¸¤ä¸ªç–æ•£tophashå€¼evacuatedXå’ŒevacuatedYï¼Œå®ƒä»¬çš„ä½ä½ä¸åŒã€‚ if checkBucket\u0026gt;\u0026gt;(it.B-1) != uintptr(b.tophash[offi]\u0026amp;1) { continue\t// ç–æ•£çš„ä¸æ˜¯å½“å‰æ¡¶åˆ™è·³è¿‡åç»­ä¼šå»æŸ¥æ‰¾ } } } // const evacuatedX = 2 // const evacuatedY = 3 // // tophash[offi] != 2æˆ–3 || k != k // tophash[offi] != 2æˆ–3; å­˜åœ¨æ•°æ® // k != kï¼šNaN æƒ…å†µ if (b.tophash[offi] != evacuatedX \u0026amp;\u0026amp; b.tophash[offi] != evacuatedY) || !(t.reflexivekey() || t.key.equal(k, k)) { // This is the golden data, we can return it. // OR // key!=key, so the entry can\u0026#39;t be deleted or updated, so we can just return it. // That\u0026#39;s lucky for us because when key!=key we can\u0026#39;t look it up successfully. // // è¿™æ˜¯é»„é‡‘æ•°æ®ï¼Œæˆ‘ä»¬å¯ä»¥è¿”å›å®ƒã€‚æˆ– key!=keyï¼Œå› æ­¤entryä¸èƒ½è¢«åˆ é™¤æˆ–æ›´æ–°ï¼Œå› æ­¤æˆ‘ä»¬å¯ä»¥ç›´æ¥è¿”å›å®ƒã€‚ // è¿™å¯¹æˆ‘ä»¬æ¥è¯´æ˜¯å¹¸è¿çš„ï¼Œå› ä¸ºå½“ key!=key æ— æ³•æˆåŠŸæŸ¥æ‰¾æ—¶ã€‚ it.key = k if t.indirectelem() { e = *((*unsafe.Pointer)(e)) } it.elem = e } else {\t// tophash[offi] == 2æˆ–3ï¼›æ•°æ®è¢«è¿ç§»äº† // The hash table has grown since the iterator was started. // The golden data for this key is now somewhere else. // Check the current hash table for the data. // This code handles the case where the key // has been deleted, updated, or deleted and reinserted. // NOTE: we need to regrab the key as it has potentially been // updated to an equal() but not identical key (e.g. +0.0 vs -0.0). // // è‡ªè¿­ä»£å™¨å¯åŠ¨ä»¥æ¥ï¼Œæ•£åˆ—è¡¨ä¸€ç›´åœ¨å¢é•¿ã€‚ // è¿™ä¸ªå¯†é’¥çš„é»„é‡‘æ•°æ®ç°åœ¨åœ¨å…¶ä»–åœ°æ–¹ã€‚ // æ£€æŸ¥å½“å‰æ•£åˆ—è¡¨ä¸­çš„æ•°æ®ã€‚ // è¿™æ®µä»£ç å¤„ç†é”®è¢«åˆ é™¤ã€æ›´æ–°æˆ–åˆ é™¤å¹¶é‡æ–°æ’å…¥çš„æƒ…å†µã€‚ // æ³¨æ„:æˆ‘ä»¬éœ€è¦é‡æ–°è·å–å¯†é’¥ï¼Œå› ä¸ºå®ƒå¯èƒ½å·²ç»æ›´æ–°åˆ°equal()ï¼Œä½†keyä¸ç›¸åŒ(ä¾‹å¦‚+0.0 vs -0.0)ã€‚ rk, re := mapaccessK(t, h, k) // æ ¹æ®kæŸ¥æ‰¾æ•°æ® if rk == nil { continue // key has been deleted } it.key = rk it.elem = re } it.bucket = bucket // è®°å½•å½“å‰æ­£åœ¨è¿­ä»£çš„æ¡¶å· if it.bptr != b { // avoid unnecessary write barrier; see issue 14921 it.bptr = b } it.i = i + 1 // ä¸‹æ¬¡éœ€è¦è¿­ä»£çš„tophashç´¢å¼• it.checkBucket = checkBucket // éœ€è¦æ£€æŸ¥çš„æ¡¶å· return } // è¿­ä»£bæ¡¶çš„æº¢å‡ºæ¡¶ b = b.overflow(t) i = 0 goto next } mapaccessK() åŒæ—¶è¿”å›keyå’Œelemã€‚ç”±mapè¿­ä»£å™¨ä½¿ç”¨ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 // returns both key and elem. Used by map iterator func mapaccessK(t *maptype, h *hmap, key unsafe.Pointer) (unsafe.Pointer, unsafe.Pointer) { if h == nil || h.count == 0 { return nil, nil } hash := t.hasher(key, uintptr(h.hash0)) m := bucketMask(h.B) b := (*bmap)(add(h.buckets, (hash\u0026amp;m)*uintptr(t.bucketsize))) // *bmap if c := h.oldbuckets; c != nil { // æ­£å¤„äºæ‰©å®¹çŠ¶æ€ if !h.sameSizeGrow() { // ç¿»å€æ‰©å®¹ // There used to be half as many buckets; mask down one more power of two. m \u0026gt;\u0026gt;= 1 } oldb := (*bmap)(add(c, (hash\u0026amp;m)*uintptr(t.bucketsize))) if !evacuated(oldb) { // æŸ¥çœ‹æ—§æ¡¶æ˜¯å¦æœ‰æ•°æ® b = oldb } } top := tophash(hash) bucketloop: for ; b != nil; b = b.overflow(t) { for i := uintptr(0); i \u0026lt; bucketCnt; i++ { if b.tophash[i] != top { if b.tophash[i] == emptyRest { break bucketloop } continue } k := add(unsafe.Pointer(b), dataOffset+i*uintptr(t.keysize)) if t.indirectkey() { k = *((*unsafe.Pointer)(k)) } if t.key.equal(key, k) { e := add(unsafe.Pointer(b), dataOffset+bucketCnt*uintptr(t.keysize)+i*uintptr(t.elemsize)) if t.indirectelem() { e = *((*unsafe.Pointer)(e)) } return k, e } } } return nil, nil } ä¸èƒ½ä½œä¸ºmap keyç±»å‹ å®˜æ–¹è§£é‡Š mapçš„é”®å¯ä»¥æ˜¯ä»»ä½•å¯æ¯”è¾ƒçš„ç±»å‹ã€‚ è¯­è¨€è§„èŒƒç²¾ç¡®åœ°å®šä¹‰äº†è¿™ä¸€ç‚¹ï¼Œç®€è€Œè¨€ä¹‹ï¼Œå¯æ¯”ç±»å‹æ˜¯boolean, numeric, string, pointer, channel, and interfaceç±»å‹ï¼Œä»¥åŠåªåŒ…å«è¿™äº›ç±»å‹çš„ç»“æ„ä½“æˆ–æ•°ç»„ã€‚ å€¼å¾—æ³¨æ„çš„æ˜¯ï¼Œåˆ—è¡¨ä¸­æ²¡æœ‰ã€slicesã€‘,ã€ mapsã€‘, and ã€functionsã€‘; è¿™äº›ç±»å‹ä¸èƒ½ä½¿ç”¨==è¿›è¡Œæ¯”è¾ƒï¼Œä¹Ÿä¸èƒ½ç”¨ä½œæ˜ å°„é”®ã€‚ ä½†æ˜¯sliceã€mapã€functionèƒ½ä¸nilä½œä¸ºæ¯”è¾ƒã€‚ sliceä¸èƒ½ä½œä¸ºmap key slice ä¸èƒ½æ¯”è¾ƒï¼Œå› æ­¤ä¹Ÿä¸èƒ½ä½œä¸ºmap keyã€‚æ›´æ·±å±‚çš„åŸå› åº”è¯¥æ˜¯ Slice ä¸èƒ½ä½œä¸ºmap keyå› æ­¤Sliceå®šä¹‰ä¸ºä¸å¯æ¯”è¾ƒç±»å‹ã€‚ æ ¹æœ¬åŸå› æ˜¯ slice æ˜¯ä¸å¯æ¯”è¾ƒç±»å‹ï¼Œåœ¨Goä¸­Sliceä½œä¸ºåªæ˜¯åº•å±‚æ•°ç»„çš„è¿ç»­çš„æè¿°ç¬¦ï¼Œå¦‚æœæŒ‰ç…§å…ƒç´ çš„æ¯”è¾ƒæ–¹å¼Sliceå¯ä»¥åƒArrayä¸€æ ·è¿›è¡Œæ¯”è¾ƒï¼Œä½†æ˜¯å½“Sliceä½œä¸ºmap keyå€¼åˆ™ä¼šå‡ºç°è¿™ç§æƒ…å†µå½“ä¸€ä¸ªsliceä½œä¸ºkeyä¿å­˜åœ¨mapä¸­ï¼Œæˆ‘ä»¬ä¿®æ”¹å½“å‰sliceçš„å…ƒç´ å€¼ä¼šä¿®æ”¹mapä¸­çš„sliceçš„keyå€¼ï¼Œè¿™ä¸mapçš„å­˜å‚¨æ„ä¹‰ç›¸è¿èƒŒã€‚å› æ­¤Goå¹²è„†ä¸æ”¯æŒSliceçš„æ¯”è¾ƒï¼Œæ¯”è¾ƒå‡½æ•°ä¸ºnilã€‚å¦å¤–ä¸€æ–¹é¢sliceçš„capåœ¨æ¯”è¾ƒä¸­åˆæ˜¾å¾—ä¸æ˜¯å¾ˆé‡è¦ï¼Œæ¯”å¦‚ make([]int64, 0, 10) å’Œ make([]int64, 0, 9) æ˜¯å¦ç›¸ç­‰å‘¢ï¼Œå› æ­¤Sliceä½œä¸ºå¯æ¯”è¾ƒç±»å‹æ˜¯æœ‰æ­§ä¹‰çš„ã€‚ å¦‚æœArrayä½œä¸ºç”±äºArrayæ˜¯å›ºå®šé•¿åº¦çš„å› æ­¤æ¯”è¾ƒå…ƒç´ å³å¯ï¼Œå¦å¤–arrayä½œä¸ºmap keyæ˜¯å‰¯æœ¬çš„å½¢å¼ä¸å­˜åœ¨sliceçš„æƒ…å†µã€‚ mapä¸èƒ½ä½œä¸ºkey map ä¸èƒ½æ¯”è¾ƒï¼Œå› æ­¤ä¹Ÿä¸èƒ½ä½œä¸ºmap keyã€‚æ›´æ·±å±‚çš„åŸå› åº”è¯¥æ˜¯ map ä¸èƒ½ä½œä¸ºmap keyå› æ­¤mapå®šä¹‰ä¸ºä¸å¯æ¯”è¾ƒç±»å‹ã€‚ å¦‚æœmapèƒ½æ¯”è¾ƒï¼Œé‚£ä¹ˆæ¯”è¾ƒ map çš„æ‰€æœ‰ key/elem å¯¹å³å¯ï¼Œä½†æ˜¯å½“mapä½œä¸ºmap keyæ—¶keyä¸­ä¿å­˜çš„æ˜¯*hmapï¼Œå› æ­¤å½“æˆ‘ä»¬ä¿®æ”¹è¿™ä¸ªä½œä¸ºmap keyçš„mapå€¼ä¹Ÿä¼šä¿®æ”¹åˆ°mapä¸­ç›¸åº”çš„keyå€¼ï¼Œè¿™ç§é—®é¢˜å’Œsliceç±»ä¼¼è¿™ä¸mapçš„å­˜å‚¨æ„ä¹‰ç›¸è¿èƒŒã€‚å› æ­¤Goå¹²è„†ä¸æ”¯æŒMapçš„æ¯”è¾ƒï¼Œæ¯”è¾ƒå‡½æ•°ä¸ºnilã€‚ functionä¸èƒ½ä½œä¸ºkey function ä¸èƒ½æ¯”è¾ƒï¼Œå› æ­¤ä¸èƒ½ä½œä¸ºmap keyã€‚æ›´æ·±å±‚çš„åŸå› åº”è¯¥æ˜¯ function ä¸èƒ½ä½œä¸ºmap keyå› æ­¤functionå®šä¹‰ä¸ºä¸å¯æ¯”è¾ƒç±»å‹ã€‚ functionç±»å‹çš„ç»„æˆç”±funcval{fn uintptr}ç»“æ„ä½“ä»¥åŠä¸€ç³»åˆ—æ•è·åˆ—è¡¨ã€‚å¦‚æœç›´æ¥åˆ¤æ–­å‡½æ•°çš„ç­¾åå¯èƒ½å­˜åœ¨ä¸åŒçš„ç­¾åå‡½æ•°å®ç°çš„å‡½æ•°ä½“ä¸åŒï¼Œå› æ­¤å‡½æ•°ç­¾åä¸èƒ½ä½œä¸ºåˆ¤æ–­å‡½æ•°ç›¸ç­‰ä¾æ®ï¼Œå¦‚æœä½¿ç”¨\u0026amp;funcvalä½œä¸ºmap keyï¼Œä¼šå‡ºç°å¦‚æœç›¸åŒçš„\u0026amp;funcvalä¸åŒçš„æ•è·åˆ—è¡¨å…¶å®å¹¶æ²¡æœ‰æˆåŠŸåŒ¹é…åˆ°keyã€‚ for range range mapåªæ˜¯æ­¤æ—¶mapçš„ä¸€ä¸ªå¿«ç…§ã€‚ å¯¹äºkeyä¸ºNaNçš„ï¼Œfor rangeèƒ½éå†å‡ºæ¥ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 map1 := map[string]string{\u0026#34;one\u0026#34;:\u0026#34;1\u0026#34;, \u0026#34;tow\u0026#34;:\u0026#34;2\u0026#34;} for i, v := range map1 { fmt.Println(i, v) // original body } // ------------------------------- // ä¸‹é¢æ˜¯ä¸Šé¢ç¼–è¯‘åä»£ç  // ------------------------------- // å®šä¹‰éå†æ‰€éœ€è¦çš„keyå’Œvalueå˜é‡ var i, v string\t// map_iteration_structæ˜¯ä¸€ä¸ªhiterç»“æ„ä½“ï¼Œå­˜å‚¨ç€mapçš„éå†ç›¸å…³ä¿¡æ¯ var hiter map_iteration_struct\t// mapiterinit åˆå§‹åŒ–mapå‚çœ‹runtime/map.goæ–‡ä»¶ // hiteræ˜¯ä¸€ä¸ªå“ˆå¸Œè¿­ä»£ç»“æ„ï¼Œmapiternextè¿­ä»£ä¸‹ä¸€ä¸ªå“ˆå¸Œ for mapiterinit(type, range, \u0026amp;hiter); hiter.key != nil; mapiternext(\u0026amp;hiter) { index_temp := *hiter.key value_temp := *hiter.val i = index_temp v = value_temp fmt.Println(i, v) // original body } mapç›¸å…³ç»ƒä¹ é¢˜ ç¤ºä¾‹ä¸€ map[string]map[string]stringç±»å‹éå†ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 package main import \u0026#34;fmt\u0026#34; var mm map[string]map[string]string func init() { mm = make(map[string]map[string]string, 1024) } func main() { // æµ‹è¯•éªŒè¯ modifyUser(mm, \u0026#34;one\u0026#34;) modifyUser(mm, \u0026#34;two\u0026#34;) modifyUser(mm, \u0026#34;three\u0026#34;) fmt.Println(mm) modifyUser(mm, \u0026#34;one\u0026#34;) fmt.Println(mm) } // 1. ä½¿ç”¨map[string]map[string]stringç±»å‹ // 2. keyï¼šè¡¨ç¤ºç”¨æˆ·åï¼Œæ˜¯å”¯ä¸€çš„ï¼Œä¸å¯ä»¥é‡å¤ // 3. å¦‚æœæŸä¸ªç”¨æˆ·åå­˜åœ¨ï¼Œå°±å°†å…¶å¯†ç ä¿®æ”¹\u0026#34;888888\u0026#34;ï¼Œå¦‚æœä¸å­˜åœ¨å°±å¢åŠ è¿™ä¸ªç”¨æˆ·ä¿¡æ¯ï¼ˆåŒ…æ‹¬æ˜µç§°nicknameå’Œå¯†ç pwdï¼‰ // 4. ç¼–å†™ä¸€ä¸ªå‡½æ•°modifyUser(users map[string]map[string]string, name string)å®Œæˆä¸Šè¿°åŠŸèƒ½ func modifyUser(user map[string]map[string]string, name string) { if v, ok := user[name]; ok { // å› ä¸ºvå­˜å‚¨çš„æ—¶*hmapæŒ‡é’ˆ // å› æ­¤ç›´æ¥ä¿®æ”¹v[\u0026#34;pwd\u0026#34;]æ—¶å¯è¡Œçš„ v[\u0026#34;pwd\u0026#34;] = \u0026#34;888888\u0026#34; return } user[name] = map[string]string{\u0026#34;pwd\u0026#34;: name, \u0026#34;nickname\u0026#34;: \u0026#34;nickname\u0026#34;} } ç¤ºä¾‹äºŒ mapä½œä¸ºé›†åˆä½¿ç”¨ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 package main import \u0026#34;fmt\u0026#34; // 1. mapä½œä¸ºé›†åˆä½¿ç”¨ var mm map[string]struct{} func init() { mm = make(map[string]struct{}, 8) mm[\u0026#34;redis\u0026#34;] = struct{}{} mm[\u0026#34;mysql\u0026#34;] = struct{}{} mm[\u0026#34;nginx\u0026#34;] = struct{}{} } func main() { if _, ok := mm[\u0026#34;php\u0026#34;]; ok { // æŒ‡å®šå…ƒç´ å­˜åœ¨ } for k := range mm { fmt.Println(k) } } ","permalink":"https://heliu.site/posts/golang/map/theory/","summary":"Golang mapæºç ä»‹ç»ã€‚","title":"Map(åŸç†)"},{"content":"type maptype struct maptype æ˜¯ map çš„å…ƒç±»å‹ç»“æ„ä½“ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 type maptype struct { typ _type // mapç±»å‹ key *_type // keyç±»å‹ elem *_type // elemç±»å‹ // æ¡¶çš„ç±»å‹ï¼Œæ¡¶åŒ…å«tophashsã€keysã€elemsã€overflowè¿™å››å— // ç”±äºkey/elemæ˜¯ä¸ç¡®å®šçš„ç±»å‹ï¼Œæ‰€ä»¥bucketä¹Ÿæ˜¯ä¸åŒçš„ç±»å‹ // bucketæ˜¯å¦åŒ…å«æŒ‡é’ˆç±»å‹ï¼Œæ˜¯å–å†³äºè¯¥ç»“æ„ä¸­æ˜¯å¦å­˜åœ¨æŒ‡é’ˆ //\t1. tophashs æ˜¯éæŒ‡é’ˆ // 2. keysã€elems æ˜¯æ ¹æ®å…·ä½“æƒ…å†µçš„ // 3. overflow æ˜¯ä¸ªæŒ‡é’ˆï¼Œé‚£ä¹ˆæ˜¯å¦æ„å‘³åˆ™bucketæ˜¯å¦åŒ…å«æŒ‡é’ˆç±»å‹? // å…¶å®bucketæ˜¯å¦åŒ…å«æŒ‡é’ˆç±»å‹æ˜¯æ ¹æ®keysã€elemså†³å®šçš„ // bucket çš„ç»„æˆç”± tophashã€keysã€elemsã€overflow bucket *_type // internal type representing a hash bucket // function for hashing keys (ptr to key, seed) -\u0026gt; hash // hashå‡½æ•°ï¼Œç”¨äº(key, h.hash0) hasher func(unsafe.Pointer, uintptr) uintptr\tkeysize uint8 // size of key slot // keyå€¼å¤§å° elemsize uint8 // size of elem slot // valueå€¼å¤§å° bucketsize uint16 // size of bucket // æ¡¶å¤§å° flags uint32 // mapçš„æ ‡å¿—ä½ } è‡ªå®šä¹‰mapç±»å‹ 1 2 3 4 type u struct { maptype u uncommontype } maptypeçš„ç»„æˆï¼Œä»¥åŠmaptype.bucketçš„ç»„æˆã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;unsafe\u0026#34; ) type tpe struct { size uintptr ptrdata uintptr // size of memory prefix holding all pointers hash uint32 tflag uint8 align uint8 fieldAlign uint8 kind uint8 // function for comparing objects of this type // (ptr to object A, ptr to object B) -\u0026gt; ==? equal func(unsafe.Pointer, unsafe.Pointer) bool // gcdata stores the GC type data for the garbage collector. // If the KindGCProg bit is set in kind, gcdata is a GC program. // Otherwise it is a ptrmask bitmap. See mbitmap.go for details. gcdata *byte str int32 ptrToThis int32 } type maptype struct { typ tpe // mapç±»å‹ key *tpe // keyç±»å‹ elem *tpe // elemç±»å‹ // æ¡¶çš„ç±»å‹ï¼Œæ¡¶åŒ…å«tophashsã€keysã€elemsã€overflowè¿™å››å— // ç”±äºkey/elemæ˜¯ä¸ç¡®å®šçš„ç±»å‹ï¼Œæ‰€ä»¥bucketä¹Ÿæ˜¯ä¸åŒçš„ç±»å‹ // bucketæ˜¯å¦åŒ…å«æŒ‡é’ˆç±»å‹ï¼Œæ˜¯å–å†³äºè¯¥ç»“æ„ä¸­æ˜¯å¦å­˜åœ¨æŒ‡é’ˆ //\t1. tophashs æ˜¯éæŒ‡é’ˆ // 2. keysã€elems æ˜¯æ ¹æ®å…·ä½“æƒ…å†µçš„ // 3. overflow æ˜¯ä¸ªæŒ‡é’ˆï¼Œé‚£ä¹ˆæ˜¯å¦æ„å‘³åˆ™bucketæ˜¯å¦åŒ…å«æŒ‡é’ˆç±»å‹? // å…¶å®bucketæ˜¯å¦åŒ…å«æŒ‡é’ˆç±»å‹æ˜¯æ ¹æ®keysã€elemså†³å®šçš„ bucket *tpe // internal type representing a hash bucket // function for hashing keys (ptr to key, seed) -\u0026gt; hash // hashå‡½æ•°ï¼Œç”¨äº(key, h.hash0) hasher func(unsafe.Pointer, uintptr) uintptr keysize uint8 // size of key slot\t// keyå€¼å¤§å° elemsize uint8 // size of elem slot\t// valueå€¼å¤§å° bucketsize uint16 // size of bucket\t// æ¡¶å¤§å° flags uint32 // mapçš„æ ‡å¿—ä½ } type e struct { i *tpe d uintptr } func main() { m := make(map[string]uint8, 8) var d any = m dd1 := **(**maptype)(unsafe.Pointer(\u0026amp;d)) dd := *(**(**maptype)(unsafe.Pointer(\u0026amp;d))).bucket // 8 + 16*8 + 8 + 8 // 8 + 128 + 8 + 8 // 98 -\u0026gt; 152 fmt.Printf(\u0026#34;%#v\\n\u0026#34;, dd1) fmt.Printf(\u0026#34;%#v\\n\u0026#34;, dd) // Output: // main.maptype{ // typ:main.tpe{ // size:0x8, // ptrdata:0x8, // hash:0xfc5c9caf, // tflag:0x2, // align:0x8, // fieldAlign:0x8, // kind:0x35, // 0x35 = 53 = 32 + 21 // equal:(func(unsafe.Pointer, unsafe.Pointer) bool)(nil), // gcdata:(*uint8)(0x71b448), // str:13639, // ptrToThis:0 // }, // key:(*main.tpe)(0x6e8140), // elem:(*main.tpe)(0x6e82c0), // bucket:(*main.tpe)(0x6f1d40), // hasher:(func(unsafe.Pointer, uintptr) uintptr)(0x6adf40), // keysize:0x10, // string å¤§å° 16 byte // elemsize:0x1, // uint8 å¤§å° 1 byte // bucketsize:0x98, // æ¡¶å¤§å° tophash + 8key + 8elem + 1overflow // flags:0xc //} // // kind:0x35ï¼š32.é—´æ¥å­˜å‚¨åœ¨æ¥å£ä¸­; 21.mapç±»å‹ //main.tpe{ // size:0x98, // ptrdata:0x98, // hash:0x9f98cd28, // tflag:0x2, // align:0x8, // fieldAlign:0x8, // kind:0x19, // equal:(func(unsafe.Pointer, unsafe.Pointer) bool)(nil), // gcdata:(*uint8)(0x71b5f8), // str:17051, // ptrToThis:0 //} } ","permalink":"https://heliu.site/posts/golang/map/meta/","summary":"Golang mapå…ƒç±»å‹ç»“æ„ã€‚","title":"Map å…ƒç±»å‹"},{"content":"å‡½æ•°å®šä¹‰ å‡½æ•°åŸºæœ¬ç»„æˆï¼šå…³é”®å­—funcã€å‡½æ•°åã€å‚æ•°åˆ—è¡¨ã€è¿”å›å€¼åˆ—è¡¨ã€å‡½æ•°ä½“ã€è¿”å›è¯­å¥ã€‚ 1 2 3 4 func å‡½æ•°å(å‚æ•°åˆ—è¡¨) (è¿”å›å€¼åˆ—è¡¨) { // å‡½æ•°ä½“ return // è¿”å›è¯­å¥ } é™¤äº†main()ã€init()å‡½æ•°å¤–ï¼Œå…¶ä»–æ‰€æœ‰ç±»å‹çš„å‡½æ•°éƒ½å¯ä»¥æœ‰ã€å‚æ•°ã€‘ä¸ã€è¿”å›å€¼ã€‘ã€‚ å‡½æ•°ä¸€èˆ¬ä¹Ÿå¯ä»¥è¿™ä¹ˆå†™ï¼šfunc FunctionName Signature [FunctionBody] funcå®šä¹‰å‡½æ•°å…³é”®å­—ã€‚FunctionNameå‡½æ•°åã€‚ Signatureå‡½æ•°ç­¾åï¼ŒåŒ…æ‹¬å‡½æ•°å‚æ•°å’Œå‡½æ•°è¿”å›å€¼ï¼Œå‡½æ•°ç­¾åæ˜¯è¯†åˆ«ä¸€ä¸ªå‡½æ•°çš„ä¾æ®ã€‚ FunctionBodyå‡½æ•°ä½“ã€‚ func FunctionName (a typea, b typed) (t1 type1, t2 type2) å‡½æ•°ç­¾åç”±å‡½æ•°å‚æ•°ã€è¿”å›å€¼ä»¥åŠå®ƒä»¬çš„ç±»å‹ç»„æˆã€‚ (a typea, b typed) (t1 type1, t2 type2) å¦‚æœä¸¤ä¸ªå‡½æ•°çš„å‚æ•°åˆ—è¡¨å’Œè¿”å›å€¼åˆ—è¡¨çš„å˜é‡ç±»å‹èƒ½ä¸€ä¸€å¯¹åº”ï¼Œé‚£ä¹ˆè¿™ä¸¤ä¸ªå‡½æ•°å°±æœ‰ç›¸åŒå¾—ç­¾åã€‚ ä¸‹é¢testaä¸testbå…·æœ‰ç›¸åŒå¾—å‡½æ•°ç­¾åã€‚ func testa (a, b int, z float32) bool func testb (a, b int, z float32) (bool) å‡½æ•°è°ƒç”¨ä¼ å…¥çš„å‚æ•°å¿…é¡»æŒ‰ç…§å‚æ•°å£°æ˜çš„é¡ºåºã€‚Goè¯­è¨€ã€æ²¡æœ‰é»˜è®¤å‚æ•°å€¼ã€‘ã€‚ å‡½æ•°ç­¾åä¸­çš„æœ€åä¼ å…¥å‚æ•°å¯ä»¥å…·æœ‰å‰ç¼€ä¸º...çš„ç±»å‹(...int)ï¼Œè¿™æ ·çš„å‚æ•°ç§°ä¸ºã€å¯å˜å‚æ•°ã€‘ã€‚ åœ¨æ¥æ”¶è¿™ç§(...)å‚æ•°çš„æ—¶å€™ï¼Œå½“åšã€åˆ‡ç‰‡ã€‘å¤„ç†å³å¯ã€‚ æ³¨æ„(sâ€¦)è¿™ç§å½¢å¼çš„såªèƒ½æ˜¯åˆ‡ç‰‡æˆ–è€…æ˜¯å­—ç¬¦ä¸²ï¼ˆåªèƒ½åœ¨append()å‡½æ•°æˆ–å¯å˜å‚æ•°å‡½æ•°ä¸­ä½¿ç”¨ï¼‰ã€ä¸èƒ½æ˜¯æ•°ç»„ã€‘ã€‚ å¯ä»¥ä½¿ç”¨é›¶ä¸ªæˆ–å¤šä¸ªå‚æ•°æ¥è°ƒç”¨è¯¥å‡½æ•°ï¼Œè¿™æ ·çš„å‡½æ•°ç§°ä¸ºã€å˜å‚å‡½æ•°ã€‘ã€‚ // å…¶å®valueså°±æ˜¯ []int åˆ‡ç‰‡ func doFix(prefix string, values ...int) ä½¿ç”¨ å‡½æ•°çš„å‚æ•°å’Œè¿”å›å€¼åˆ—è¡¨å§‹ç»ˆå¸¦æ‹¬å·ï¼Œä½†åªæœ‰ä¸€ä¸ªæœªå‘½åçš„å‚æ•°å€¼ï¼Œå¯ä»¥å°†å…¶å†™ä¸ºæœªåŠ æ‹¬å·çš„ç±»å‹ã€‚ ä¸€ä¸ªå‡½æ•°ä¹Ÿå¯ä»¥æ‹¥æœ‰å¤šä¸ªè¿”å›å€¼ï¼Œè¿”å›ç±»å‹ä¹‹é—´éœ€è¦ä½¿ç”¨é€—å·åˆ†éš”ï¼Œå¹¶ä½¿ç”¨å°æ‹¬å·ï¼ˆï¼‰å°†å®ƒä»¬æ‹¬èµ·æ¥ã€‚ func testa (a, b int, z float32) bool func swap (a int, b int) (t1 int, t2 int) åœ¨å‡½æ•°ä½“ä¸­ï¼Œå‚æ•°æ˜¯å±€éƒ¨å˜é‡ï¼Œè¢«åˆå§‹åŒ–ä¸ºè°ƒç”¨è€…ä¼ å…¥çš„å€¼ã€‚ å‡½æ•°çš„å‚æ•°å’Œå‘½åè¿”å›å€¼æ˜¯å‡½æ•°æœ€å¤–å±‚çš„å±€éƒ¨å˜é‡ï¼Œå®ƒä»¬çš„ä½œç”¨åŸŸå°±æ˜¯æ•´ä¸ªå‡½æ•°ã€‚ å¦‚æœå‡½æ•°çš„ç­¾åå£°æ˜äº†è¿”å›å€¼ï¼Œåˆ™å‡½æ•°ä½“çš„è¯­å¥åˆ—è¡¨å¿…é¡»ä»¥ç»ˆæ­¢è¯­å¥ç»“æŸã€‚ ä½†æ˜¯å¦‚æœå‡½æ•°æ²¡æœ‰å£°æ˜è¿”å›å€¼ä¹Ÿæ˜¯å¯ä»¥ä½¿ç”¨returnç»“æŸå‡½æ•°åé¢ä»£ç ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 func IndexRune(s string,r rune) int { for i, c := range s { if c == r { return i } } //å¿…é¡»æœ‰ç»ˆæ­¢è¯­å¥returnï¼Œ // å¦åˆ™ä¼šå‘ç”Ÿç¼–è¯‘é”™è¯¯ missing return at end of function return } // æ²¡æœ‰æŒ‡å®šè¿”å›å€¼çš„å‡½æ•°ï¼Œä¹Ÿæ˜¯å¯ä»¥ä½¿ç”¨returnç»“æŸæ•´ä¸ªå‡½æ•°è¿è¡Œçš„ func Show() { fmt.Println(123) return } Goè¯­è¨€å‡½æ•°é‡è½½æ˜¯ä¸è¢«å…è®¸çš„ã€‚\nå‡½æ•°é‡è½½ï¼šå¯ä»¥ç¼–å†™å¤šä¸ªåŒåå‡½æ•°ï¼Œåªè¦å®ƒä»¬æ‹¥æœ‰ä¸åŒçš„å½¢å‚æˆ–è€…ä¸åŒçš„è¿”å›å€¼ã€‚ å®˜æ–¹ä¸æ”¯æŒé‡è½½åŸå› ï¼Œè®©Goä¿å­˜ç®€å•ã€‚ å‡½æ•°å¯ä»¥ä½œä¸ºå‡½æ•°ç±»å‹è¢«ä½¿ç”¨ã€‚å‡½æ•°ç±»å‹å°±æ˜¯å‡½æ•°ç­¾åã€‚å‡½æ•°ç±»å‹çš„æœªåˆå§‹åŒ–å˜é‡çš„å€¼ä¸ºnilï¼ˆå‡½æ•°æ˜¯å¼•ç”¨ç±»å‹ï¼‰ã€‚\nå‡½æ•°ä½œä¸ºå‚æ•°è¢«ä½¿ç”¨ï¼Œè¿™ç§æ˜¯å›è°ƒã€‚å…¶å®å°±æ˜¯funcvalæŒ‡é’ˆã€‚\nå‡½æ•°ä½œä¸ºè¿”å›å€¼è¢«ä½¿ç”¨ï¼Œè¿™ç§æ˜¯é—­åŒ…ã€‚å…¶å®å°±æ˜¯funcvalæŒ‡é’ˆã€‚\n1 2 3 4 5 // é€šè¿‡typeå…³é”®å­—ï¼Œå®šä¹‰ä¸€ä¸ªæ–°çš„å‡½æ•°ç±»å‹ funcType type funcType func(int, int) int // é€šè¿‡varå…³é”®å­—ï¼Œåˆ›å»ºå‡½æ•°å˜é‡ var f func() int 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;unsafe\u0026#34; ) type funcType func(int, int) int func main() { var f funcType = func(a, b int) int { return a + b } fmt.Println(unsafe.Sizeof(f)) // Output: // 8 } å‡½æ•°å¯ä»¥åœ¨è¡¨è¾¾å¼ä¸­èµ‹å€¼ç»™å˜é‡ï¼Œè¿™æ ·ä½œä¸ºè¡¨è¾¾å¼ä¸­çš„å³å€¼å‡ºç°ï¼Œç§°ä¸ºå‡½æ•°å€¼å­—é¢é‡ã€‚ å‡½æ•°å€¼å­—é¢é‡æ˜¯ä¸€ç§è¡¨è¾¾å¼ï¼Œå®ƒçš„å€¼è¢«ç§°ä¸ºåŒ¿åå‡½æ•°ã€‚ 1 2 3 f := func() int { return 7 } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 // å®šä¹‰å‡½æ•°ç±»å‹ funcType type funcType func(time.Time) func main() { // ç›´æ¥èµ‹å€¼ç»™å˜é‡ f := func(t time.Time) time.Time { return t } fmt.Println(\u0026#34;ä¸€ï¼š\u0026#34;, f( time.Now() )) // å®šä¹‰å‡½æ•°ç±»å‹ funcType å˜é‡ timer var timer funcType = CurrentTime timer( time.Now() ) // å…ˆæŠŠCurrentTimeå‡½æ•°è½¬ä¸ºfuncTypeç±»å‹ï¼Œç„¶åä¼ å…¥å‚æ•°è°ƒç”¨ // funcType(CurrentTime) CurrentTimeè½¬æ¢ä¸ºfuncTypeç±»å‹ funcType(CurrentTime)(time.Now()) // Output: // ä¸€ï¼š 2021-04-11 12:25:15.8479173 +0800 CST m=+0.001997401 // äºŒï¼š 2021-04-11 12:25:15.8589326 +0800 CST m=+0.013013701 // äºŒï¼š 2021-04-11 12:25:15.8599231 +0800 CST m=+0.014004301 } func CurrentTime (start time.Time) { fmt.Println(\u0026#34;äºŒï¼š\u0026#34;, start) } ...int å‡½æ•°åªèƒ½æ˜¯æœ€åä¸€ä¸ªå‚æ•°æ˜¯ ...int å½¢å¼ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 package main func main() { show(\u0026#34;aaa\u0026#34;) } //go:noinline func show(name string, params ...int) { // paramsé»˜è®¤å€¼[]int(nil) // params == nil println(name, params) } main.mainç›¸å…³æ±‡ç¼–ï¼š 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 func main() { 0x4551e0 493b6610 CMPQ 0x10(R14), SP # 1. æ ˆå¢é•¿åˆ¤æ–­ 0x4551e4 7630 JBE 0x455216 0x4551e6 4883ec30 SUBQ $0x30, SP # 2. è®¾ç½®æ ˆå¤§å° 0x4551ea 48896c2428 MOVQ BP, 0x28(SP) # 3. ä¿å­˜rbpå¯„å­˜å™¨å€¼ 0x4551ef 488d6c2428 LEAQ 0x28(SP), BP # 4. è®¾ç½®rbpæ–°å€¼ show(\u0026#34;aaa\u0026#34;) # AXå’ŒBXå¯„å­˜å™¨ç”¨äºä¼ é€’å‚æ•° ã€name stringã€‘ 0x4551f4 488d05fdc70000 LEAQ 0xc7fd(IP), AX # name.data = 0xc7fd(IP) 0x4551fb bb03000000 MOVL $0x3, BX # name.len = 0x3 # params == nil ã€params ...intã€‘ # CXã€DIã€SI ç”¨äºä¼ é€’ ..int å‚æ•°ï¼Œæ˜¯ []int 0x455200 31c9 XORL CX, CX # params.data = 0 0x455202 31ff XORL DI, DI # params.len = 0 0x455204 4889fe MOVQ DI, SI # params.cap = 0 0x455207 e814000000 ALL main.show(SB) # è°ƒç”¨ main.show å‡½æ•° } 0x45520c 488b6c2428 MOVQ 0x28(SP), BP 0x455211 4883c430 ADDQ $0x30, SP 0x455215 c3 RET func main() { 0x455216 e845cdffff CALL runtime.morestack_noctxt.abi0(SB) 0x45521b ebc3 JMP main.main(SB) ...intä¼ é€’å‚æ•°ï¼š 1 2 3 4 5 6 7 8 9 10 11 package main func main() { //var s []int = []int{1, 2} X(1, 2, 3, 4) // []int 24å­—èŠ‚ } func X(ss ...int) int { // å¯èƒ½ss==nilï¼Œå› æ­¤ç¼–è¯‘å™¨è¦åšæ£€æŸ¥ return ss[0] } main.mainç›¸å…³æ±‡ç¼–ï¼š 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 $ go build -gcflags=\u0026#34;-N -l\u0026#34; -o ./h1 heliu.site/helium $ go tool objdump -S -s \u0026#39;^main.main$\u0026#39; ./h1 TEXT main.main(SB) /mnt/hgfs/workspace/helium/main.go func main() { 0x4551e0 493b6610 CMPQ 0x10(R14), SP # æ ˆå¢é•¿åˆ¤æ–­ 0x4551e4 0f8687000000 JBE 0x455271 0x4551ea 4883ec60 SUBQ $0x60, SP 0x4551ee 48896c2458 MOVQ BP, 0x58(SP) 0x4551f3 488d6c2458 LEAQ 0x58(SP), BP X(1, 2, 3, 4) # []int 24å­—èŠ‚ # 0x18-0x38 åˆ†åˆ«ä½œä¸ºå‚æ•°1,2,3,4 0x4551f8 440f117c2418 MOVUPS X15, 0x18(SP) # 0x18-0x28 æ¸…é›¶ 0x4551fe 440f117c2428 MOVUPS X15, 0x28(SP) # 0x28-0x38 æ¸…é›¶ 0x455204 488d542418 LEAQ 0x18(SP), DX # DX=0x18(SP) 0x455209 4889542438 MOVQ DX, 0x38(SP) # 0x38(SP)=0x18(SP) 0x45520e 8402 TESTB AL, 0(DX) 0x455210 48c744241801000000 MOVQ $0x1, 0x18(SP) # 1 0x455219 8402 TESTB AL, 0(DX) 0x45521b 48c744242002000000 MOVQ $0x2, 0x20(SP) # 2 0x455224 8402 TESTB AL, 0(DX) 0x455226 48c744242803000000 MOVQ $0x3, 0x28(SP) # 3 0x45522f 8402 TESTB AL, 0(DX) 0x455231 48c744243004000000 MOVQ $0x4, 0x30(SP) # 4 0x45523a 488b442438 MOVQ 0x38(SP), AX # AX=0x38(SP) 0x45523f 8400 TESTB AL, 0(AX) 0x455241 eb00 JMP 0x455243 0x455243 4889442440 MOVQ AX, 0x40(SP) # ss.data=0x38(SP) 0x455248 48c744244804000000 MOVQ $0x4, 0x48(SP) # ss.len=4 0x455251 48c744245004000000 MOVQ $0x4, 0x50(SP) # ss.cap=4 0x45525a bb04000000 MOVL $0x4, BX # BX=4 0x45525f 4889d9 MOVQ BX, CX # CX=4 # AX=0x38(SP), BX=4, CX=4; ä½œä¸º main.X(SB) çš„è°ƒç”¨å‚æ•° 0x455262 e819000000 CALL main.X(SB) } 0x455267 488b6c2458 MOVQ 0x58(SP), BP 0x45526c 4883c460 ADDQ $0x60, SP 0x455270 c3 RET func main() { 0x455271 e8eaccffff CALL runtime.morestack_noctxt.abi0(SB) 0x455276 e965ffffff JMP main.main(SB) main.Xç›¸å…³æ±‡ç¼–ï¼š 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 $ go tool objdump -S -s \u0026#39;^main.X$\u0026#39; ./h1 TEXT main.X(SB) /mnt/hgfs/workspace/helium/main.go func X(ss ...int) int { 0x455280 4883ec20 SUBQ $0x20, SP 0x455284 48896c2418 MOVQ BP, 0x18(SP) 0x455289 488d6c2418 LEAQ 0x18(SP), BP # ss ...int 0x45528e 4889442428 MOVQ AX, 0x28(SP) # slice.data 0x455293 48895c2430 MOVQ BX, 0x30(SP) # slice.len 0x455298 48894c2438 MOVQ CX, 0x38(SP) # slice.cap 0x45529d 48c744241000000000 MOVQ $0x0, 0x10(SP) # main.X è¿”å›å€¼ 0 return ss[0] 0x4552a6 488b4c2430 MOVQ 0x30(SP), CX # CX=4 0x4552ab 488b542428 MOVQ 0x28(SP), DX # DX=slice.data # TEST é€»è¾‘ä¸è¿ç®—ï¼Œå› ä¸ºss[0]å–ç¬¬ä¸€ä¸ªä¸‹æ ‡ï¼Œå› æ­¤CX=0æ˜¯ä¸èƒ½æ»¡è¶³çš„ï¼Œç›´æ¥panic 0x4552b0 4885c9 TESTQ CX, CX # CX \u0026amp; CX; è¿™é‡Œåšäº†ä¸€æ¬¡è¶Šç•Œæ£€æŸ¥ 0x4552b3 7702 JA 0x4552b7 0x4552b5 eb12 JMP 0x4552c9 0x4552b7 488b02 MOVQ 0(DX), AX # AX=ss[0] 0x4552ba 4889442410 MOVQ AX, 0x10(SP) # main.X è¿”å›å€¼ 1 0x4552bf 488b6c2418 MOVQ 0x18(SP), BP 0x4552c4 4883c420 ADDQ $0x20, SP 0x4552c8 c3 RET 0x4552c9 31c0 XORL AX, AX 0x4552cb e8f0d3ffff CALL runtime.panicIndex(SB) # panicï¼Œæ— æ•ˆçš„ç´¢å¼• 0x4552d0 90 NOPL main.mainå’Œmain.X å‡½æ•°çš„æ ˆå¸ƒå±€æƒ…å†µï¼š 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 // +88 runtime.main back // -------------------------------- --------------------------------------- // +80 BP of runtime.main +58 // -------------------------------- rbp \u0026lt;------- ------------------ // +78 4 +50 sliceStruct.cap // -------------------------------- \u0026lt;------- // +70 4 +48 sliceStruct.len []intåˆ‡ç‰‡ä¼ å‚å‰ // -------------------------------- \u0026lt;------- // +68 0x18(rsp) +40 sliceStruct.data // -------------------------------- \u0026lt;------- ------------------ // +60 0x18(rsp) +38 å…³è”æ•°ç»„å¼€å§‹ä½ç½® // -------------------------------- \u0026lt;------- ------------------ // +58 4 +30 // -------------------------------- // +50 3 +28 // -------------------------------- ä¼ å‚å˜é‡ // +48 2 +20 // -------------------------------- // +40 1 +18 // -------------------------------- \u0026lt;------- ------------------ // +38 4 +10 // -------------------------------- // +30 4 +08 Xå‡½æ•°çš„å‚æ•° []int // -------------------------------- // +28 0x18(rsp) +00 // -------------------------------- rsp \u0026lt;------- ------------------ // +20 main.main back // -------------------------------- --------------------------------------- // +18 BP of main.main // -------------------------------- rbp // +10 1 Xå‡½æ•°çš„è¿”å›å€¼ // -------------------------------- Xå‡½æ•°æ ˆ // +08 // -------------------------------- // +00 // -------------------------------- rsp ----------------------------------- s...å½¢å¼ä¼ å‚ï¼š 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 package main func main() { var s []int = []int{1, 2} X(s...) // []int 24å­—èŠ‚ } func X(ss ...int) int { // if len(ss) \u0026gt;= 2 { // return ss[1] // } else { // return 0 // } return ss[1] // è¿™é‡Œä¼šè¿›è¡Œä¸€æ¬¡è¶Šç•Œæ£€æŸ¥ } main.mainç›¸å…³æ±‡ç¼–ä»£ç ï¼š 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 $ go tool objdump -S -s \u0026#39;^main.main$\u0026#39; ./h1 TEXT main.main(SB) /mnt/hgfs/workspace/helium/main.go func main() { 0x4551e0 493b6610 CMPQ 0x10(R14), SP # æ ˆå¢é•¿åˆ¤æ–­ 0x4551e4 7669 JBE 0x45524f 0x4551e6 4883ec50 SUBQ $0x50, SP 0x4551ea 48896c2448 MOVQ BP, 0x48(SP) 0x4551ef 488d6c2448 LEAQ 0x48(SP), BP var s []int = []int{1, 2} # 0x18(SP)-0x28(SP) ç”¨äº 1,2 å‚æ•°çš„å­˜æ”¾ 0x4551f4 440f117c2418 MOVUPS X15, 0x18(SP) # 0x18(SP)-0x28(SP) æ¸…é›¶ 0x4551fa 488d442418 LEAQ 0x18(SP), AX # AX=0x18(SP) 0x4551ff 4889442428 MOVQ AX, 0x28(SP) # 0x28(SP)=AX=0x18(SP) 0x455204 8400 TESTB AL, 0(AX) 0x455206 48c744241801000000 MOVQ $0x1, 0x18(SP) # 0x18(SP)=1 0x45520f 8400 TESTB AL, 0(AX) 0x455211 48c744242002000000 MOVQ $0x2, 0x20(SP) # 0x20(SP)=2 0x45521a 8400 TESTB AL, 0(AX) 0x45521c eb00 JMP 0x45521e 0x45521e 4889442430 MOVQ AX, 0x30(SP) # ss.data=0x18(SP) 0x455223 48c744243802000000 MOVQ $0x2, 0x38(SP) # ss.len=2 0x45522c 48c744244002000000 MOVQ $0x2, 0x40(SP) # ss.cap=2 X(s...) # []int 24å­—èŠ‚ 0x455235 bb02000000 MOVL $0x2, BX # BX=2 0x45523a 4889d9 MOVQ BX, CX # CX=2 0x45523d 0f1f00 NOPL 0(AX) # AX=0x18(SP); BX=2; CX=2; ç”¨ä½œ main.X å‡½æ•°çš„ä¼ å‚ 0x455240 e81b000000 CALL main.X(SB) } 0x455245 488b6c2448 MOVQ 0x48(SP), BP 0x45524a 4883c450 ADDQ $0x50, SP 0x45524e c3 RET func main() { 0x45524f e80ccdffff CALL runtime.morestack_noctxt.abi0(SB) 0x455254 eb8a JMP main.main(SB) main.Xå‡½æ•°ç›¸å…³æ±‡ç¼–ï¼š 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 $ go tool objdump -S -s \u0026#39;^main.X$\u0026#39; ./h1 TEXT main.X(SB) /mnt/hgfs/workspace/helium/main.go func X(ss ...int) int { 0x455260 4883ec20 SUBQ $0x20, SP 0x455264 48896c2418 MOVQ BP, 0x18(SP) 0x455269 488d6c2418 LEAQ 0x18(SP), BP 0x45526e 4889442428 MOVQ AX, 0x28(SP) # ss.data 0x455273 48895c2430 MOVQ BX, 0x30(SP) # ss.len 0x455278 48894c2438 MOVQ CX, 0x38(SP) # ss.cap 0x45527d 48c744241000000000 MOVQ $0x0, 0x10(SP) # è¿”å›å€¼ä¸´æ—¶å†…å­˜ 0 return ss[1] # è¿™é‡Œä¼šè¿›è¡Œä¸€æ¬¡è¶Šç•Œæ£€æŸ¥ 0x455286 488b4c2430 MOVQ 0x30(SP), CX # CX=2 0x45528b 488b542428 MOVQ 0x28(SP), DX # DX=2 0x455290 4883f901 CMPQ $0x1, CX # è¿™é‡Œè¿›è¡Œè¶Šç•Œæ£€æŸ¥ 0x455294 7702 JA 0x455298 0x455296 eb13 JMP 0x4552ab 0x455298 488b4208 MOVQ 0x8(DX), AX # AX=ss[1] 0x45529c 4889442410 MOVQ AX, 0x10(SP) # è¿”å›å€¼ä¸´æ—¶å†…å­˜ ss[1] 0x4552a1 488b6c2418 MOVQ 0x18(SP), BP 0x4552a6 4883c420 ADDQ $0x20, SP 0x4552aa c3 RET 0x4552ab b801000000 MOVL $0x1, AX 0x4552b0 e80bd4ffff CALL runtime.panicIndex(SB) 0x4552b5 90 NOPL main.mainå’Œmain.Xå‡½æ•°çš„æ ˆå¸ƒå±€æƒ…å†µï¼š 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 // +50 runtime.main back // ------------------------------------- ---------------------------------------------- // +48 BP of runtime.main // ------------------------------------- rbp \u0026lt;---------------- ------- --------- // +40 2 sliceStruct.cap // ------------------------------------- \u0026lt;---------------- // +38 2 sliceStruct.len []int // ------------------------------------- \u0026lt;---------------- // +30 0x18(rsp) sliceStruct.data // ------------------------------------- \u0026lt;---------------- ------- åˆå§‹åŒ–så˜é‡ // +28 0x18(rsp) åº•å±‚æ•°ç»„é¦–åœ°å€ // ------------------------------------- // +20 2 // ------------------------------------- // +18 1 // ------------------------------------- \u0026lt;---------------- ------- --------- // +10 // ------------------------------------- \u0026lt;---------------- // +08 Xå‡½æ•°å‚æ•°[]int // ------------------------------------- \u0026lt;---------------- // +00 // ------------------------------------- rsp \u0026lt;---------------- ------- --------- å‡½æ•°è°ƒç”¨ Goè¯­è¨€ä¸­å‡½æ•°é»˜è®¤ä½¿ç”¨æŒ‰å€¼ä¼ é€’æ¥ä¼ é€’å‚æ•°ï¼Œä¹Ÿå°±æ˜¯ä¼ é€’å‚æ•°çš„å‰¯æœ¬ã€‚å‡½æ•°æ¥æ”¶å‚æ•°å‰¯æœ¬ä¹‹åï¼Œåœ¨ä½¿ç”¨å˜é‡çš„è¿‡ç¨‹ä¸­å¯èƒ½å¯¹å‰¯æœ¬çš„å€¼è¿›è¡Œæ›´æ”¹ï¼Œä½†ä¸ä¼šå½±å“åŸæ¥çš„å˜é‡ã€‚ å¦‚æœå¸Œæœ›å‡½æ•°å¯ä»¥ç›´æ¥ä¿®æ”¹å‚æ•°çš„å€¼ï¼Œè€Œä¸æ˜¯å¯¹å‚æ•°çš„å‰¯æœ¬è¿›è¡Œæ“ä½œã€‚éœ€è¦å°†å‚æ•°çš„åœ°å€ä¼ é€’ç»™å‡½æ•°ï¼Œè¿™å°±æ˜¯æŒ‰å¼•ç”¨ä¼ å€¼ã€‚å¦‚Function(\u0026amp;arg1)ï¼Œæ­¤æ—¶ä¼ é€’ç»™å‡½æ•°çš„æ˜¯ä¸€ä¸ªæŒ‡é’ˆã€‚å¦‚æœä¼ é€’ç»™å‡½æ•°çš„æ˜¯ä¸€ä¸ªæŒ‡é’ˆï¼Œåˆ™å¯ä»¥é€šè¿‡è¿™ä¸ªæŒ‡é’ˆæ¥ä¿®æ”¹å¯¹åº”åœ°å€ä¸Šçš„å˜é‡å€¼ã€‚ åœ¨è¿›è¡Œå‡½æ•°è°ƒç”¨æ—¶ï¼Œåƒåˆ‡ç‰‡(slice)ã€å­—å…¸(map)ã€å‡½æ•°(func)ã€é€šé“(channel)ç­‰è¿™æ ·çš„å¼•ç”¨ç±»å‹éƒ½æ˜¯é»˜è®¤ä½¿ç”¨å¼•ç”¨ä¼ é€’ã€‚ å‘½åè¿”å›å€¼è¢«åˆå§‹åŒ–ä¸ºç›¸åº”ç±»å‹çš„é›¶å€¼ï¼Œå½“éœ€è¦è¿”å›çš„æ—¶å€™ï¼Œåªéœ€è¦ä¸€æ¡ç®€å•çš„ä¸å¸¦å‚æ•°çš„returnè¯­å¥ã€‚å³ä½¿åªæœ‰ä¸€ä¸ªå‘½åè¿”å›å€¼ï¼Œä¹Ÿéœ€è¦ä½¿ç”¨()æ‹¬èµ·æ¥ã€‚å¦‚type funcType func() (b bool)ã€type funcType1 func() boolã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 func main() { // å¸¸è§„è°ƒç”¨ï¼Œå‚æ•°å¯ä»¥æ˜¯å¤šä¸ª list(1, 2, 3, 4, 5, 6) // []int{1, 2, 3, 4, 5, 6} []int // åœ¨å‚æ•°åŒç±»å‹æ—¶ï¼Œå¯ä»¥ç»„æˆsliceä½¿ç”¨ params... è¿›è¡Œå‚æ•°ä¼ é€’ numbers := []int{1, 2, 3, 4, 5, 6, 7} // numbers... è¯­æ³•åªå¯¹sliceå’Œstringä½¿ç”¨ã€‚ list(numbers...) // []int{1, 2, 3, 4, 5, 6, 7} []int fmt.Println(numbers) // [2 2 3 4 5 6 7] // Output: // []int{1, 2, 3, 4, 5, 6} []int // []int{1, 2, 3, 4, 5, 6, 7} []int // [2 2 3 4 5 6 7] } // å˜é•¿å‚æ•°ï¼Œå‚æ•°ä¸å®šé•¿ func list(nums ...int) { if nums == nil { painc(\u0026#34;åˆ‡ç‰‡æœªåˆå§‹åŒ– nil\u0026#34;) } fmt.Printf(\u0026#34;%#v %T\\n\u0026#34;, nums, nums) nums[0] += 1 } å†…ç½®å‡½æ•° å†…ç½®å‡½æ•°æ˜¯é¢„å…ˆå£°æ˜çš„ï¼Œå®ƒä»¬åƒä»»ä½•å…¶ä»–å‡½æ•°ä¸€æ ·è¢«è°ƒç”¨ã€‚ å†…ç½®å‡½æ•°æ²¡æœ‰æ ‡å‡†çš„ç±»å‹ï¼Œå› æ­¤åªèƒ½å‡ºç°åœ¨è°ƒç”¨è¡¨è¾¾å¼ä¸­ï¼Œä¸èƒ½ç”¨ä½œå‡½æ•°å€¼ã€‚ å®ƒä»¬æœ‰æ—¶å€™å¯ä»¥é’ˆå¯¹ä¸åŒçš„ç±»å‹è¿›è¡Œæ“ä½œã€‚ å†…ç½®å‡½æ•°make()å’Œnew()éƒ½å’Œå†…å­˜åˆ†é…ç›¸å…³ï¼Œä½†ä¹Ÿæœ‰å·®å¼‚ã€‚ å†…ç½®å‡½æ•° è¯´æ˜ make(T) makeåªç”¨äºsliceã€mapä»¥åŠchannelè¿™ä¸‰ç§å¼•ç”¨æ•°æ®çš„å†…å­˜åˆ†é…å’Œåˆå§‹åŒ–ï¼Œmake(T)è¿”å›ç±»å‹Tçš„å€¼ï¼ˆä¸æ˜¯*Tï¼‰ new(T) newç”¨äºå€¼ç±»å‹çš„å†…å­˜åˆ†é…ï¼Œå¹¶ä¸”ç½®ä¸ºé›¶å€¼ï¼Œnew(T)åˆ†é…ç±»å‹Tçš„é›¶å€¼å¹¶è¿”å›å…¶åœ°å€ï¼Œä¹Ÿå°±æ˜¯æŒ‡å‘ç±»å‹Tçš„æŒ‡é’ˆ å†…ç½®å‡½æ•°make()ç”¨ä½œäºsliceã€mapå’Œchannelä¸‰ç§æ•°æ®ç±»å‹æ—¶ï¼Œå‚æ•°åŠä½œç”¨æœ‰äº›åŒºåˆ«ã€‚ make å‡½æ•°åŸå‹ï¼šfunc make(t Type, size ...IntegerType) Type new å‡½æ•°åŸå‹ï¼šfunc new(Type) *Type T çš„ç±»å‹ å‚æ•° è¯´æ˜ slice make(T, n) Tä¸ºåˆ‡ç‰‡ç±»å‹ï¼Œé•¿åº¦å’Œå®¹é‡éƒ½ä¸ºn slice make(T, n, m) Tä¸ºåˆ‡ç‰‡ç±»å‹ï¼Œé•¿åº¦nï¼Œå®¹é‡mï¼ˆn \u0026lt;=mï¼Œå¦åˆ™é”™è¯¯ ï¼‰ map make(T) Tä¸ºå­—å…¸ç±»å‹ map make(T, n) Tä¸ºå­—å…¸ç±»å‹ï¼Œåˆ†é…nä¸ªå…ƒç´ çš„ç©ºé—´ channel make(T) Tä¸ºé€šé“ç±»å‹ï¼Œæ— ç¼“å†²åŒº channel make(T, n) Tä¸ºé€šé“ç±»å‹ï¼Œç¼“å†²åŒºå®¹é‡ä¸ºn å†…ç½®å‡½æ•°make()çš„å®é™…ä½¿ç”¨ä¸¾ä¾‹ 1 2 3 4 5 6 s := make([]int, 10, 100) // åˆ‡ç‰‡ï¼Œlen(s) == 10, cap(s) == 100 s := make([]int, 1e3) // åˆ‡ç‰‡ï¼Œlen(s) == cap(s) == 1000 s := make([]int, 1 \u0026lt;\u0026lt; 63) // éæ³•ï¼Œintç±»å‹çš„å¤§å°*len(s) ä»¥é€ æˆå†…å­˜ä¸è¶³ï¼Œæ‰€ä»¥å¯¼è‡´éæ³• int*cap(s)å¦‚æœæº¢å‡ºä¹Ÿæ˜¯ä¸€æ ·çš„ s := make([]int, 10, 0) // éæ³•ï¼Œlen(s) \u0026gt; cap(s) c := make(chan int, 10) // é€šé“ç¼“å†²åŒºæœ‰10ä¸ªå…ƒç´  m := make(map[string]int, 100) // mapçš„åˆå§‹ç©ºé—´æœ‰å¤§çº¦100ä¸ªå…ƒç´  new(T) å†…ç½®å‡½æ•°åœ¨è¿è¡Œæ—¶ä¸ºè¯¥ç±»å‹çš„å˜é‡åˆ†é…å†…å­˜ï¼Œè¿”å›æŒ‡å‘å®ƒçš„ç±»å‹ *T çš„å€¼ï¼Œå¹¶å¯¹å˜é‡åˆå§‹åŒ– 1 2 3 4 5 type S struct { a int b float64 } new(S) // \u0026amp;S{0,0.0} new(S) ä¸ºSç±»å‹çš„å˜é‡åˆ†é…å†…å­˜ï¼Œå¹¶åˆå§‹åŒ–ï¼ˆa = 0, b = 0.0ï¼‰ï¼Œè¿”å›åŒ…å«è¯¥ä½ç½®åœ°å€çš„ç±»å‹ *S çš„å€¼ã€‚ sliceã€mapå’Œchannelè¿™ä¸‰ç§æ•°æ®ç±»å‹å£°æ˜æ—¶ï¼Œå¯è®¾ç½®é•¿åº¦æˆ–å®¹é‡ï¼Œæ‰€ä»¥é€šè¿‡å†…ç½®å‡½æ•°len()å’Œcap()å¾—åˆ°å¯¹åº”é•¿åº¦ä¸å®¹é‡ã€‚ len å‡½æ•°åŸå‹ï¼šfunc len(v Type) int cap å‡½æ•°åŸå‹ï¼šfunc cap(v Type) int å†…ç½®å‡½æ•° å‚æ•°sçš„ç±»å‹ ç»“æœè¯´æ˜ len(s) string stringç±»å‹sçš„é•¿åº¦ï¼ˆæŒ‰ç…§å­—èŠ‚è®¡ç®—ï¼‰ len(s) [n]Tï¼Œ*[n]T æ•°ç»„ç±»å‹sçš„é•¿åº¦ï¼ˆ[n]Tã€[n]*Tã€*[n]Tï¼‰æ•°ç»„æŒ‡é’ˆ*[n]Tæ”¯æŒè¯­æ³•ç³– len(s) []T åˆ‡ç‰‡ç±»å‹sçš„é•¿åº¦ len(s) map[K]T å­—å…¸ç±»å‹sçš„é•¿åº¦ len(s) chan T é€šé“ç±»å‹sçš„ç¼“å†²åŒºæ’é˜Ÿçš„å…ƒç´ æ•°é‡ cap(s) []T åˆ‡ç‰‡ç±»å‹sçš„å®¹é‡ cap(s) chan T é€šé“ç±»å‹sçš„ç¼“å†²åŒºå®¹é‡ 1 2 3 4 5 6 7 8 9 10 11 12 13 package main import \u0026#34;fmt\u0026#34; func main() { var a = new([2]int) // *[2]int // len(a) è¯­æ³•ç³– fmt.Printf(\u0026#34;%#v %T %d\u0026#34;, a, a, len(a)) // Output: // \u0026amp;[2]int{0, 0} *[2]int 2 } å¯¹äºlen(s)å’Œcap(s)ï¼Œå¦‚æœsä¸ºnilå€¼ï¼Œåˆ™ä¸¤ä¸ªå‡½æ•°çš„å–å€¼éƒ½æ˜¯0ï¼Œæ­¤å¤–ï¼š 1 0 \u0026lt;= len(s) \u0026lt;= cap(s) Goè¯­è¨€ä¸­ï¼Œå¸¸é‡åœ¨æŸäº›è®¡ç®—æ¡ä»¶ä¸‹ä¹Ÿå¯ä»¥é€šè¿‡è¡¨è¾¾å¼è®¡ç®—å¾—åˆ°ã€‚ å‡å¦‚sæ˜¯å­—ç¬¦ä¸²å¸¸é‡ï¼Œåˆ™è¡¨è¾¾å¼len(s)æ˜¯å¸¸é‡ã€‚ å¦‚sçš„ç±»å‹æ˜¯æ•°ç»„æˆ–æŒ‡å‘æ•°ç»„çš„æŒ‡é’ˆè€Œè¡¨è¾¾å¼ä¸åŒ…å«é€šé“æ¥æ”¶æˆ–ï¼ˆéå¸¸é‡ï¼‰å‡½æ•°è°ƒç”¨ï¼Œåˆ™è¡¨è¾¾å¼len(s)å’Œcap(s)æ˜¯å¸¸é‡ï¼Œå¦åˆ™lenå’Œcapçš„è°ƒç”¨ä¸æ˜¯å¸¸é‡ã€‚ 1 2 3 4 5 6 7 8 9 const ( c1 = imag(2i) // 2.0 imag(2i) == 2.0 æ˜¯å¸¸é‡ c2 = len([10]float64{2}) // 10 [10]float64{2} æ— å‡½æ•°è°ƒç”¨ c3 = len([10]float64{c1}) // 10 [10]float64{c1} æ— å‡½æ•°è°ƒç”¨ c4 = len([10]float64{imag(2i)}) // 10 imag(2i)å¸¸é‡æ— å‡½æ•°è°ƒç”¨ c5 = len([10]float64{imag(z)}) // æ— æ•ˆ imag(z) éå¸¸é‡å‡½æ•°è°ƒç”¨ ) var z complex128 é€’å½’ä¸å›è°ƒ é€’å½’å‡½æ•°ï¼šå‡½æ•°ç›´æ¥æˆ–é—´æ¥è°ƒç”¨å‡½æ•°æœ¬èº«ã€‚ä½¿ç”¨é€’å½’å‡½æ•°æ—¶ç»å¸¸ä¼šé‡åˆ°æ ˆæº¢å‡ºã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 func main() { var i uint64 = 7 fmt.Printf(\u0026#34;%d çš„é˜¶ä¹˜æ˜¯ %d\\n\u0026#34;, i, Factorial(i)) // 7 çš„é˜¶ä¹˜æ˜¯ 5040 fmt.Printf(\u0026#34;%d çš„é˜¶ä¹˜æ˜¯ %d\\n\u0026#34;, i, Fac2(i)) // 7 çš„é˜¶ä¹˜æ˜¯ 5040 // Output: // 7 çš„é˜¶ä¹˜æ˜¯ 5040 // 7 çš„é˜¶ä¹˜æ˜¯ 5040 } // Factorial å‡½æ•°é€’å½’è°ƒç”¨ n! = n*(n-1)...*1 func Factorial(n uint64) (result uint64) { if n \u0026gt; 0 { result = n * Factorial(n - 1) return result } return 1 } // Fac2 å¾ªç¯å½¢å¼å®ç° n! = n*(n-1)...*1 func Fac2(n uint64) (result uint64) { result = 1 var un uint64 = 1 for i := un; i \u0026lt;= n; i++ { result *= i } return } Goè¯­è¨€ä¸­ä¹Ÿå¯ä»¥ä½¿ç”¨ç›¸äº’è°ƒç”¨çš„é€’å½’å‡½æ•°ï¼Œå¤šä¸ªå‡½æ•°ä¹‹é—´ç›¸äº’è°ƒç”¨å½¢æˆé—­ç¯ã€‚ å›è°ƒï¼šGoè¯­è¨€å‡½æ•°å¯ä»¥ä½œä¸ºå…¶ä»–å‡½æ•°çš„å‚æ•°è¿›è¡Œä¼ é€’ï¼Œç„¶ååœ¨å…¶ä»–å‡½æ•°å†…è°ƒç”¨æ‰§è¡Œã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 func main() { callback(1, Add) // Output: // 1 + 2 = 3 } func Add(a, b int) { fmt.Printf(\u0026#34;%d + %d = %d\u0026#34;, a, b, a + b) // 1 + 2 = 3 } func callback(y int, f func(int, int)) { f(y, 2) // å›è°ƒå‡½æ•°f } åŒ¿åå‡½æ•° åŒ¿åå‡½æ•°ï¼šå‡½æ•°å€¼å­—é¢é‡æ˜¯ä¸€ç§è¡¨è¾¾å¼ã€‚ä¸ç»™å‡½æ•°èµ·åå­—çš„æ—¶å€™ï¼Œå¯ä»¥ä½¿ç”¨åŒ¿åå‡½æ•°ã€‚ è¿™æ ·çš„å‡½æ•°ä¸èƒ½ç‹¬ç«‹å­˜åœ¨ï¼Œä½†æ˜¯å¯ä»¥è¢«èµ‹å€¼äºæŸä¸ªå˜é‡ï¼Œå³ä¿å­˜å‡½æ•°çš„åœ°å€åˆ°å˜é‡ä¸­ã€‚ 1 2 3 4 5 6 fplus := func(x, y int) int { return x + y } // ç„¶åé€šè¿‡å˜é‡åå¯¹å‡½æ•°è¿›è¡Œè°ƒç”¨ fplus(3, 4) å½“ç„¶ï¼Œä¹Ÿå¯ä»¥ç›´æ¥å¯¹åŒ¿åå‡½æ•°è¿›è¡Œè°ƒç”¨ã€‚æ³¨æ„åŒ¿åå‡½æ•°çš„æœ€ååŠ ä¸Šæ‹¬å·å¹¶å¡«å…¥å‚æ•°å€¼ï¼Œå¦‚æœæ²¡æœ‰å‚æ•°ï¼Œä¹Ÿéœ€è¦åŠ ä¸Šæ‹¬å·ï¼Œä»£è¡¨ç›´æ¥è°ƒç”¨ã€‚ 1 2 3 func(x, y int) int { return x + y }(3, 4) è®¡ç®—0 ~ 100ä¸‡æ•´æ•°çš„æ€»å’Œçš„åŒ¿åå‡½æ•°ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 func main() { fn := func() { fmt.Println(\u0026#34;hello\u0026#34;) } fn() fmt.Println(\u0026#34;åŒ¿åå‡½æ•°åŠ æ³•æ±‚é›†ï¼š\u0026#34;, func(x, y int) int {return x + y}(3,4)) func() { sum := 0 for i := 1; i \u0026lt;= 1e6; i++ { sum += i } fmt.Println(\u0026#34;åŒ¿åå‡½æ•°åŠ æ³•å¾ªç¯æ±‚å’Œï¼š\u0026#34;, sum) }() // Output: // hello // åŒ¿åå‡½æ•°åŠ æ³•æ±‚é›†ï¼š 7 // åŒ¿åå‡½æ•°åŠ æ³•å¾ªç¯æ±‚å’Œï¼š 500000500000 } å˜å‚å‡½æ•° å¯å˜å‚æ•°å°±æ˜¯ä¸å®šé•¿å‚æ•°ï¼Œæ”¯æŒå¯å˜å‚æ•°åˆ—è¡¨çš„å‡½æ•°å¯ä»¥æ”¯æŒä»»æ„ä¸ªä¼ å…¥å‚æ•°ã€‚å¦‚ï¼šfmt.Println å‡½æ•°å°±æ˜¯ä¸€ä¸ªæ”¯æŒå¯å˜é•¿å‚æ•°åˆ—è¡¨çš„å‡½æ•°ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 package main import \u0026#34;fmt\u0026#34; func main() { s := []string{\u0026#34;hello\u0026#34;, \u0026#34;world\u0026#34;} // æ³¨æ„è¿™é‡Œçš„åˆ‡ç‰‡ s... æŠŠåˆ‡ç‰‡æ‰“æ’’ä¼ å…¥ï¼Œä¸så…·æœ‰ç›¸åŒåº•å±‚æ•°ç»„çš„å€¼ Greeting(s...) fmt.Println(s) // Output: // 0 hello // 1 world // [hello 123456] } // è¿™é‡Œçš„whoå‚æ•°å…¶å®å°±æ˜¯åˆ‡ç‰‡[]stringç±»å‹ï¼Œä¹Ÿå°±æ˜¯æ‰€è°“çš„å¯å˜å‚æ•° func Greeting(who ...string){ for k, v := range who{ fmt.Println(k, v) } who[1] = \u0026#34;123456\u0026#34; } ","permalink":"https://heliu.site/posts/golang/func/use/","summary":"Golang å‡½æ•°ä½¿ç”¨ä»‹ç»ã€‚","title":"å‡½æ•°ä½¿ç”¨"},{"content":" CPUåœ¨æ‰§è¡Œç¨‹åºæ—¶ï¼ŒIPå¯„å­˜å™¨ä¼šæŒ‡å‘ä¸‹ä¸€æ¡å³å°†è¢«æ‰§è¡Œçš„æŒ‡ä»¤ï¼Œè€ŒSPå¯„å­˜å™¨ä¼šæŒ‡å‘æ ˆé¡¶ã€‚ CALLæŒ‡ä»¤ä¼šå…ˆæŠŠä¸‹ä¸€æ¡æŒ‡ä»¤çš„åœ°å€å‹å…¥æ ˆä¸­ï¼Œè¿™å°±æ˜¯æ‰€è°“çš„è¿”å›åœ°å€ã€‚ç„¶åè·³è½¬åˆ°è¢«è°ƒç”¨å‡½æ•°å»æ‰§è¡Œã€‚å½“è¢«è°ƒç”¨å‡½æ•°æ‰§è¡Œå®Œæˆåä¼šè¿”å›åˆ°CALLæŒ‡ä»¤å‹æ ˆçš„è¿”å›åœ°å€ç»§ç»­æ‰§è¡Œã€‚ç”±äºCALLæŒ‡ä»¤å¼•å‘äº†å…¥æ ˆå’ŒæŒ‡ä»¤è·³è½¬ï¼Œæ‰€ä»¥SPå’ŒIPå¯„å­˜å™¨çš„å€¼éƒ½å‘ç”Ÿäº†æ”¹å˜ã€‚ RETæŒ‡ä»¤ä¼šä»æ ˆä¸Šå¼¹å‡ºè¿”å›åœ°å€ï¼Œç„¶åè·³è½¬åˆ°è¯¥åœ°å€å¤„ç»§ç»­æ‰§è¡Œã€‚ æ ˆå¸§å¸ƒå±€ ç¼–è¯‘å™¨ç”Ÿæˆçš„æŒ‡ä»¤è´Ÿè´£æ ˆå¸§çš„è€Œåˆ†é…ä¸é‡Šæ”¾ã€‚æ ˆå¸§çš„å¸ƒå±€ä¹Ÿæ˜¯ç”±ç¼–è¯‘å™¨åœ¨ç¼–è¯‘é˜¶æ®µç¡®å®šçš„ï¼Œå…¶ä¾æ®å°±æ˜¯å‡½æ•°ä»£ç ï¼Œæ‰€ä»¥ä¹Ÿå¯ä»¥è¯´å‡½æ•°æ ˆå¸§æ˜¯ç”±ç¼–è¯‘å™¨ç®¡ç†çš„ã€‚\nå‚ç…§å‡½æ•°æ ˆå¸§å¸ƒå±€å›¾ï¼Œå‡½æ•°æ ˆå¸§åŒ…å«ä»¥ä¸‹å‡ éƒ¨åˆ†ï¼š\nreturn addressï¼šå‡½æ•°è¿”å›åœ°å€ï¼Œå ç”¨ä¸€ä¸ªæŒ‡é’ˆå¤§å°ç©ºé—´ã€‚å®é™…ä¸Šæ˜¯åœ¨å‡½æ•°è¢«è°ƒç”¨æ—¶ç”±CALLæŒ‡ä»¤è‡ªåŠ¨å‹æ ˆçš„ï¼Œå¹¶éç”±è¢«è°ƒç”¨å‡½æ•°åˆ†é…ã€‚ caller's BPï¼šè°ƒç”¨è€…çš„æ ˆå¸§åŸºå€ï¼Œå ç”¨ä¸€ä¸ªæŒ‡é’ˆå¤§å°ç©ºé—´ã€‚ç”¨æ¥å°†è°ƒç”¨è·¯å¾„ä¸Šæ‰€æœ‰çš„æ ˆå¸§è¿æˆä¸€ä¸ªé“¾è¡¨ï¼Œæ–¹ä¾¿æ ˆå›æº¯ï¼Œåªåœ¨éƒ¨åˆ†å¹³å°æ¶æ„ä¸Šå­˜åœ¨ã€‚å‡½æ•°é€šè¿‡å°†æ ˆæŒ‡é’ˆSPç›´æ¥å‘ä¸‹ç§»åŠ¨æŒ‡å®šå¤§å°ï¼Œä¸€æ¬¡æ€§åˆ†é…caller's BPã€localså’Œargs to calleeæ‰€å ç”¨çš„ç©ºé—´ï¼Œåœ¨x86æ¶æ„ä¸Šå°±æ˜¯ä½¿ç”¨SUBæŒ‡ä»¤å°†SPå‡å»æŒ‡å®šå¤§å°çš„ã€‚ localsï¼šå±€éƒ¨å˜é‡åŒºé—´ï¼Œå ç”¨è‹¥å¹²æœºå™¨å­—èŠ‚ã€‚ç”¨æ¥å­˜æ”¾å‡½æ•°çš„å±€éƒ¨å˜é‡ï¼Œæ ¹æ®å‡½æ•°çš„å±€éƒ¨å˜é‡å ç”¨ç©ºé—´å¤§å°æ¥åˆ†é…ï¼Œæ²¡æœ‰å±€éƒ¨å˜é‡çš„å‡½æ•°ä¸åˆ†é…ã€‚ args to calleeï¼šè°ƒç”¨ä¼ å‚åŒºåŸŸï¼Œå ç”¨è‹¥å¹²æœºå™¨å­—èŠ‚ã€‚è¿™ä¸€åŒºåŸŸæ‰€å ç©ºé—´å¤§å°ï¼Œä¼šæŒ‰ç…§å½“å‰å‡½æ•°è°ƒç”¨çš„æ‰€æœ‰å‡½æ•°ä¸­è¿”å›å€¼åŠ ä¸Šå‚æ•°æ‰€å ç”¨çš„ç©ºé—´æ¥åˆ†é…ã€‚å½“æ²¡æœ‰è°ƒç”¨ä»»ä½•å‡½æ•°æ—¶ï¼Œä¸éœ€è¦åˆ†é…è¯¥åŒºé—´ã€‚ ç»¼ä¸Šï¼Œåªæœ‰ return address æ˜¯ä¸€å®šå­˜åœ¨çš„ï¼Œå…¶ä»–ä¸‰ä¸ªåŒºé—´éƒ½è¦æ ¹æ®å®é™…æƒ…å†µåˆ†æã€‚ æŒ‰ç…§ä¸€èˆ¬ä»£ç çš„é€»è¾‘ï¼Œå‡½æ•°çš„æ ˆå¸§åº”è¯¥åŒ…å«è¿”å›å€¼ã€å‚æ•°ã€è¿”å›åœ°å€å’Œå±€éƒ¨å˜é‡è¿™å››éƒ¨åˆ†ã€‚ ä¼ å‚ äº¤æ¢ä¸¤ä¸ªå˜é‡çš„å€¼(å€¼ä¼ é€’)ã€‚ 1 2 3 4 5 6 7 8 9 10 11 package main func main() { a,b := 1,2 swap(a,b) } //go:noinline func swap(a,b int) { a,b = b,a } ç›¸å…³æ±‡ç¼–ä»£ç  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 func main() { 0x4551e0 493b6610 CMPQ 0x10(R14), SP # æ¯”è¾ƒæ ˆæ˜¯å¦æº¢å‡º 0x4551e4 7639 JBE 0x45521f 0x4551e6 4883ec28 SUBQ $0x28, SP # main.mainå‡½æ•°é¢„åˆ†é…æ ˆå¸§å¤§å° 0x4551ea 48896c2420 MOVQ BP, 0x20(SP) # å­˜å‚¨è¢«è°ƒç”¨å‡½æ•°runtime.mainçš„BP 0x4551ef 488d6c2420 LEAQ 0x20(SP), BP # è°ƒæ•´å½“å‰main.mainçš„BP a,b := 1,2 0x4551f4 48c744241801000000 MOVQ $0x1, 0x18(SP) # å˜é‡a 0x4551fd 48c744241002000000 MOVQ $0x2, 0x10(SP) # å˜é‡b swap(a,b) 0x455206 488b442418 MOVQ 0x18(SP), AX # main.swapçš„aå‚æ•° AX = a = 1 0x45520b bb02000000 MOVL $0x2, BX # main.swapçš„bå‚æ•° BX = 2 0x455210 e82b000000 CALL main.swap(SB) # è°ƒç”¨swapå‡½æ•° } 0x455215 488b6c2420 MOVQ 0x20(SP), BP # æ¢å¤runtime.mainçš„BP 0x45521a 4883c428 ADDQ $0x28, SP # è°ƒæ•´æ ˆ 0x45521e c3 RET # å‡½æ•°è¿”å› ï¼Œå¼¹å‡ºruntime.mainçš„ä¸‹ä¸€æ¡IPåœ°å€ï¼ŒSPå‡8 func main() { 0x45521f 90 NOPL 0x455220 e83bcdffff CALL runtime.morestack_noctxt.abi0(SB) # æ ˆæº¢å‡ºæ—¶ä¼šè·³è½¬åˆ°è¿™é‡Œæ¥ï¼Œä»æ–°åˆ†é…æ ˆç©ºé—´ 0x455225 ebb9 JMP main.main(SB) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 func swap(a,b int) { 0x455240 4883ec10 SUBQ $0x10, SP # é¢„åˆ†é…æ ˆå¤§å° 0x455244 48896c2408 MOVQ BP, 0x8(SP) # å­˜å‚¨main.mainçš„BP 0x455249 488d6c2408 LEAQ 0x8(SP), BP # è°ƒæ•´BPå¯„å­˜å™¨ 0x45524e 4889442418 MOVQ AX, 0x18(SP) # æŠŠå‚æ•°aæ”¾å…¥æ ˆä¸Šï¼Œåœ¨main.mainçš„æ ˆä¸Š 0x455253 48895c2420 MOVQ BX, 0x20(SP) # æŠŠå‚æ•°bæ”¾å…¥æ ˆä¸Šï¼Œåœ¨main.mainçš„æ ˆä¸Š a,b = b,a 0x455258 48890424 MOVQ AX, 0(SP) # æŠŠå‚æ•°aå¾—å€¼ä¸´æ—¶æ”¾å…¥(rsp) 0x45525c 488b442420 MOVQ 0x20(SP), AX # æŠŠå‚æ•°bçš„å€¼æ”¾å…¥ AX=2 0x455261 4889442418 MOVQ AX, 0x18(SP) # æŠŠå‚æ•°bçš„å€¼å’Œå‚æ•°aäº¤æ¢a=2 0x455266 488b0424 MOVQ 0(SP), AX # å–å‡ºä¸´æ—¶å­˜æ”¾çš„açš„å€¼1 0x45526a 4889442420 MOVQ AX, 0x20(SP) # æŠŠä¸´æ—¶å­˜æ”¾açš„å€¼å¤åˆ¶ç»™b=1 } 0x45526f 488b6c2408 MOVQ 0x8(SP), BP # æ¢å¤main.mainçš„BP 0x455274 4883c410 ADDQ $0x10, SP # è°ƒæ•´æ ˆå¤§å° 0x455278 c3 RET # å‡½æ•°è¿”å› å›¾ç‰‡å¤‡æ³¨ï¼šå›¾ç‰‡+08å¤„çš„runtime.main BPåº”è¯¥æ˜¯main.main BPã€‚\näº¤æ¢ä¸¤ä¸ªå˜é‡çš„å€¼(å¼•ç”¨ä¼ é€’)ã€‚ 1 2 3 4 5 6 7 8 9 10 11 package main func main() { a,b := 1,2 swap(\u0026amp;a,\u0026amp;b) } //go:noinline func swap(a,b *int) { *a,*b = *b,*a } ç›¸å…³æ±‡ç¼–ä»£ç  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 func main() { 0x4551e0 493b6610 CMPQ 0x10(R14), SP 0x4551e4 7639 JBE 0x45521f 0x4551e6 4883ec28 SUBQ $0x28, SP 0x4551ea 48896c2420 MOVQ BP, 0x20(SP) 0x4551ef 488d6c2420 LEAQ 0x20(SP), BP a,b := 1,2 0x4551f4 48c744241801000000 MOVQ $0x1, 0x18(SP) 0x4551fd 48c744241002000000 MOVQ $0x2, 0x10(SP) swap(\u0026amp;a,\u0026amp;b) 0x455206 488d442418 LEAQ 0x18(SP), AX # AX=0x18(SP) -\u0026gt; 0x1 æ³¨æ„è¿™é‡Œçš„0x18åç§»é‡æ˜¯å˜é‡açš„åœ°å€ 0x45520b 488d5c2410 LEAQ 0x10(SP), BX # BX=0x10(SP) -\u0026gt; 0x2 æ³¨æ„è¿™é‡Œçš„0x10åç§»é‡æ˜¯å˜é‡açš„åœ°å€ 0x455210 e82b000000 CALL main.swap(SB) # è°ƒç”¨main.swapå‡½æ•° } 0x455215 488b6c2420 MOVQ 0x20(SP), BP 0x45521a 4883c428 ADDQ $0x28, SP 0x45521e c3 RET func main() { 0x45521f 90 NOPL 0x455220 e83bcdffff CALL runtime.morestack_noctxt.abi0(SB) 0x455225 ebb9 JMP main.main(SB) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 func swap(a,b *int) { 0x455240 4883ec10 SUBQ $0x10, SP 0x455244 48896c2408 MOVQ BP, 0x8(SP) 0x455249 488d6c2408 LEAQ 0x8(SP), BP 0x45524e 4889442418 MOVQ AX, 0x18(SP) 0x455253 48895c2420 MOVQ BX, 0x20(SP) *a,*b = *b,*a 0x455258 8400 TESTB AL, 0(AX) 0x45525a 488b00 MOVQ 0(AX), AX # å–AX=0x1 0x45525d 48890424 MOVQ AX, 0(SP) 0x455261 488b442418 MOVQ 0x18(SP), AX # AX=0x30(SP) 0x455266 8400 TESTB AL, 0(AX) 0x455268 488b4c2420 MOVQ 0x20(SP), CX # CX=0x28(SP) 0x45526d 8401 TESTB AL, 0(CX) 0x45526f 488b09 MOVQ 0(CX), CX # CX=0x2 0x455272 488908 MOVQ CX, 0(AX) # AX=0x30(SP) -\u0026gt; 0x2 0x455275 488b442420 MOVQ 0x20(SP), AX # AX=0x28(SP) 0x45527a 8400 TESTB AL, 0(AX) 0x45527c 488b0c24 MOVQ 0(SP), CX # CX=0x1 0x455280 488908 MOVQ CX, 0(AX) # AX=0x28(SP) -\u0026gt; 0x1 } 0x455283 488b6c2408 MOVQ 0x8(SP), BP 0x455288 4883c410 ADDQ $0x10, SP 0x45528c c3 RET å›¾ç‰‡å¤‡æ³¨ï¼šå›¾ç‰‡+08å¤„çš„runtime.main BPåº”è¯¥æ˜¯main.main BPã€‚\näº¤æ¢ä¸¤ä¸ªå˜é‡çš„å€¼(å¼•ç”¨ä¼ é€’)ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 package main func main() { a,b := 1,2 swap(\u0026amp;a,\u0026amp;b) //println(a, b)\t// 1,2 } //go:noinline func swap(a,b *int) { // temp = a // a = b // b = temp // å˜é‡aã€bæ˜¯å‡½æ•°å†…çš„å±€éƒ¨å˜é‡ï¼Œ // å› æ­¤äº¤æ¢ä¸ä¼šå½±å“å¤–éƒ¨æŒ‡é’ˆæ•°æ® a,b = b,a\t// è¿™ç§æƒ…å†µå’Œç¬¬ä¸€ç§å‰¯æœ¬ä¼ å‚äº¤æ¢ä¸€è‡´ //println(*a, *b)\t// 2,1 } ç›¸å…³æ±‡ç¼–ä»£ç  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 func main() { 0x4551e0 493b6610 CMPQ 0x10(R14), SP 0x4551e4 7639 JBE 0x45521f 0x4551e6 4883ec28 SUBQ $0x28, SP 0x4551ea 48896c2420 MOVQ BP, 0x20(SP) 0x4551ef 488d6c2420 LEAQ 0x20(SP), BP a,b := 1,2 0x4551f4 48c744241801000000 MOVQ $0x1, 0x18(SP) # å˜é‡a 0x4551fd 48c744241002000000 MOVQ $0x2, 0x10(SP) # å˜é‡b swap(\u0026amp;a,\u0026amp;b) 0x455206 488d442418 LEAQ 0x18(SP), AX # å‚æ•°a 0x45520b 488d5c2410 LEAQ 0x10(SP), BX # å‚æ•°b 0x455210 e82b000000 CALL main.swap(SB) # å‡½æ•°è°ƒç”¨ } 0x455215 488b6c2420 MOVQ 0x20(SP), BP 0x45521a 4883c428 ADDQ $0x28, SP 0x45521e c3 RET func main() { 0x45521f 90 NOPL 0x455220 e83bcdffff CALL runtime.morestack_noctxt.abi0(SB) 0x455225 ebb9 JMP main.main(SB) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 func swap(a,b *int) { 0x455240 4883ec10 SUBQ $0x10, SP 0x455244 48896c2408 MOVQ BP, 0x8(SP) 0x455249 488d6c2408 LEAQ 0x8(SP), BP 0x45524e 4889442418 MOVQ AX, 0x18(SP) 0x455253 48895c2420 MOVQ BX, 0x20(SP) a,b = b,a 0x455258 48890424 MOVQ AX, 0(SP) # AXå¯„å­˜å™¨å‚æ•°aä¿å­˜åœ¨ä¸´æ—¶å®¹å™¨é‡Œ 0x45525c 488b442420 MOVQ 0x20(SP), AX # AX=0x28(SP) S.b 0x455261 4889442418 MOVQ AX, 0x18(SP) # äº¤æ¢ 0x455266 488b0424 MOVQ 0(SP), AX 0x45526a 4889442420 MOVQ AX, 0x20(SP) } 0x45526f 488b6c2408 MOVQ 0x8(SP), BP 0x455274 4883c410 ADDQ $0x10, SP 0x455278 c3 RET å›¾ç‰‡å¤‡æ³¨ï¼šå›¾ç‰‡+08å¤„çš„runtime.main BPåº”è¯¥æ˜¯main.main BPã€‚\nè¿”å›å€¼ åŒ¿åè¿”å›å€¼ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 package main func main() { var a int = 1 b := incr(a) _ = b } //go:noinline func incr(a int) int { var b int = 2 // defer é—­åŒ…æ•è·çš„æ˜¯incrå±€éƒ¨å˜é‡ defer func() { a++ b++ }() a++ b = a return b // ç”±äºbåœ¨incræ ˆç©ºé—´åˆ›å»ºdeferå½±å“ä¸åˆ° } ç›¸å…³æ±‡ç¼–ä»£ç  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 func main() { 0x4552a0 493b6610 CMPQ 0x10(R14), SP 0x4552a4 7630 JBE 0x4552d6 0x4552a6 4883ec20 SUBQ $0x20, SP 0x4552aa 48896c2418 MOVQ BP, 0x18(SP) 0x4552af 488d6c2418 LEAQ 0x18(SP), BP var a int = 1 0x4552b4 48c744241001000000 MOVQ $0x1, 0x10(SP) b := incr(a) 0x4552bd b801000000 MOVL $0x1, AX # AX=1 0x4552c2 e819000000 CALL main.incr(SB) 0x4552c7 4889442408 MOVQ AX, 0x8(SP) } 0x4552cc 488b6c2418 MOVQ 0x18(SP), BP 0x4552d1 4883c420 ADDQ $0x20, SP 0x4552d5 c3 RET func main() { 0x4552d6 e825cdffff CALL runtime.morestack_noctxt.abi0(SB) 0x4552db ebc3 JMP main.main(SB) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 func incr(a int) int { 0x4552e0 4c8d6424f8 LEAQ -0x8(SP), R12 0x4552e5 4d3b6610 CMPQ 0x10(R14), R12 0x4552e9 0f86d9000000 JBE 0x4553c8 0x4552ef 4881ec88000000 SUBQ $0x88, SP 0x4552f6 4889ac2480000000 MOVQ BP, 0x80(SP) 0x4552fe 488dac2480000000 LEAQ 0x80(SP), BP 0x455306 4889842490000000 MOVQ AX, 0x90(SP) 0x45530e 48c744240800000000 MOVQ $0x0, 0x8(SP) var b int = 2 0x455317 48c744241002000000 MOVQ $0x2, 0x10(SP) defer func() { 0x455320 48c744246800000000 MOVQ $0x0, 0x68(SP) 0x455329 440f117c2470 MOVUPS X15, 0x70(SP) 0x45532f 488d4c2468 LEAQ 0x68(SP), CX # CX=0x68(SP) 0x455334 48894c2460 MOVQ CX, 0x60(SP) 0x455339 8401 TESTB AL, 0(CX) 0x45533b 488d159e000000 LEAQ main.incr.func1(SB), DX # DX=main.incr.func1 0x455342 4889542468 MOVQ DX, 0x68(SP) 0x455347 8401 TESTB AL, 0(CX) 0x455349 488d942490000000 LEAQ 0x90(SP), DX # DX=0x90(SP) 0x455351 4889542470 MOVQ DX, 0x70(SP) 0x455356 8401 TESTB AL, 0(CX) 0x455358 488d542410 LEAQ 0x10(SP), DX # DX=0x10(SP) 0x45535d 4889542478 MOVQ DX, 0x78(SP) 0x455362 48894c2430 MOVQ CX, 0x30(SP) 0x455367 488d442418 LEAQ 0x18(SP), AX # AX=0x18(SP) 0x45536c e88f50fdff CALL runtime.deferprocStack(SB) # æ³¨å†Œdeferé“¾è¡¨ 0x455371 85c0 TESTL AX, AX 0x455373 7539 JNE 0x4553ae 0x455375 eb00 JMP 0x455377 a++ 0x455377 488b842490000000 MOVQ 0x90(SP), AX # AX=1 0x45537f 48ffc0 INCQ AX # AX=2 0x455382 4889842490000000 MOVQ AX, 0x90(SP) b = a 0x45538a 4889442410 MOVQ AX, 0x10(SP) return b // ç”±äºbåœ¨incræ ˆç©ºé—´åˆ›å»ºdeferå½±å“ä¸åˆ° 0x45538f 4889442408 MOVQ AX, 0x8(SP) # returnå…ˆæŠŠå€¼å¤åˆ¶ç»™I.oç„¶ååœ¨å»deferçš„ 0x455394 e88756fdff CALL runtime.deferreturn(SB) # æ‰§è¡Œdeferï¼Œdeferæ•è·çš„æ˜¯aå’Œbä¸I.oæ— å…³ 0x455399 488b442408 MOVQ 0x8(SP), AX # deferå®Œä¹‹ååœ¨ä»I.oå–å€¼åˆ°AX 0x45539e 488bac2480000000 MOVQ 0x80(SP), BP 0x4553a6 4881c488000000 ADDQ $0x88, SP 0x4553ad c3 RET defer func() { 0x4553ae e86d56fdff CALL runtime.deferreturn(SB) 0x4553b3 488b442408 MOVQ 0x8(SP), AX 0x4553b8 488bac2480000000 MOVQ 0x80(SP), BP 0x4553c0 4881c488000000 ADDQ $0x88, SP 0x4553c7 c3 RET func incr(a int) int { 0x4553c8 4889442408 MOVQ AX, 0x8(SP) 0x4553cd e82eccffff CALL runtime.morestack_noctxt.abi0(SB) 0x4553d2 488b442408 MOVQ 0x8(SP), AX 0x4553d7 e904ffffff JMP main.incr(SB) å›¾ç‰‡å¤‡æ³¨ï¼šå›¾ç‰‡+80å¤„çš„runtime.main BPåº”è¯¥æ˜¯main.main BPã€‚\nå®åè¿”å›å€¼ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 package main func main() { var a int = 1 b := incr(a) _ = b } //go:noinline func incr(a int) (b int) { // defer é—­åŒ…æ•è·çš„æ˜¯incrå±€éƒ¨å˜é‡ defer func() { a++ b++ }() a++ b = a return b // ç”±äºbåœ¨incræ ˆç©ºé—´åˆ›å»ºdeferå½±å“ä¸åˆ° } ç›¸å…³æ±‡ç¼–ä»£ç  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 func main() { 0x4552a0 493b6610 CMPQ 0x10(R14), SP 0x4552a4 7630 JBE 0x4552d6 0x4552a6 4883ec20 SUBQ $0x20, SP 0x4552aa 48896c2418 MOVQ BP, 0x18(SP) 0x4552af 488d6c2418 LEAQ 0x18(SP), BP var a int = 1 0x4552b4 48c744241001000000 MOVQ $0x1, 0x10(SP) b := incr(a) 0x4552bd b801000000 MOVL $0x1, AX # AX=1 0x4552c2 e819000000 CALL main.incr(SB) 0x4552c7 4889442408 MOVQ AX, 0x8(SP) } 0x4552cc 488b6c2418 MOVQ 0x18(SP), BP 0x4552d1 4883c420 ADDQ $0x20, SP 0x4552d5 c3 RET func main() { 0x4552d6 e825cdffff CALL runtime.morestack_noctxt.abi0(SB) 0x4552db ebc3 JMP main.main(SB) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 func incr(a int) (b int) { 0x4552e0 493b6610 CMPQ 0x10(R14), SP 0x4552e4 0f86b8000000 JBE 0x4553a2 0x4552ea 4883c480 ADDQ $-0x80, SP 0x4552ee 48896c2478 MOVQ BP, 0x78(SP) 0x4552f3 488d6c2478 LEAQ 0x78(SP), BP 0x4552f8 4889842488000000 MOVQ AX, 0x88(SP) 0x455300 48c744240800000000 MOVQ $0x0, 0x8(SP) defer func() { 0x455309 48c744246000000000 MOVQ $0x0, 0x60(SP) 0x455312 440f117c2468 MOVUPS X15, 0x68(SP) # æ¸…ç©º0x68(SP)å16B 0x455318 488d4c2460 LEAQ 0x60(SP), CX # CX=0x60(SP) 0x45531d 48894c2458 MOVQ CX, 0x58(SP) 0x455322 8401 TESTB AL, 0(CX) 0x455324 488d1595000000 LEAQ main.incr.func1(SB), DX # DX=main.incr.func1 0x45532b 4889542460 MOVQ DX, 0x60(SP) 0x455330 8401 TESTB AL, 0(CX) 0x455332 488d942488000000 LEAQ 0x88(SP), DX # DX=0x88(SP) 0x45533a 4889542468 MOVQ DX, 0x68(SP) 0x45533f 8401 TESTB AL, 0(CX) 0x455341 488d542408 LEAQ 0x8(SP), DX # DX=0x8(SP) 0x455346 4889542470 MOVQ DX, 0x70(SP) 0x45534b 48894c2428 MOVQ CX, 0x28(SP) 0x455350 488d442410 LEAQ 0x10(SP), AX # AX=0x10(SP)ï¼Œdeferç»“æ„ä½“èµ·å§‹åœ°å€ 0x455355 e8a650fdff CALL runtime.deferprocStack(SB) # æ³¨å†Œdefer 0x45535a 85c0 TESTL AX, AX 0x45535c 7530 JNE 0x45538e 0x45535e 6690 NOPW 0x455360 eb00 JMP 0x455362 a++ 0x455362 488b842488000000 MOVQ 0x88(SP), AX # AX=1 0x45536a 48ffc0 INCQ AX # AX=2 0x45536d 4889842488000000 MOVQ AX, 0x88(SP) b = a 0x455375 4889442408 MOVQ AX, 0x8(SP) return b // ç”±äºbåœ¨incræ ˆç©ºé—´åˆ›å»ºdeferå½±å“ä¸åˆ° 0x45537a e8a156fdff CALL runtime.deferreturn(SB) # æ‰§è¡Œdeferé“¾è¡¨ 0x45537f 488b442408 MOVQ 0x8(SP), AX # ä»I.oä¸­å–å‡ºè¿”å›å€¼æ”¾å…¥AX 0x455384 488b6c2478 MOVQ 0x78(SP), BP 0x455389 4883ec80 SUBQ $-0x80, SP 0x45538d c3 RET defer func() { 0x45538e e88d56fdff CALL runtime.deferreturn(SB) 0x455393 488b442408 MOVQ 0x8(SP), AX 0x455398 488b6c2478 MOVQ 0x78(SP), BP 0x45539d 4883ec80 SUBQ $-0x80, SP 0x4553a1 c3 RET func incr(a int) (b int) { 0x4553a2 4889442408 MOVQ AX, 0x8(SP) 0x4553a7 e854ccffff CALL runtime.morestack_noctxt.abi0(SB) 0x4553ac 488b442408 MOVQ 0x8(SP), AX 0x4553b1 e92affffff JMP main.incr(SB) å›¾ç‰‡å¤‡æ³¨ï¼šå›¾ç‰‡+78å¤„çš„runtime.main BPåº”è¯¥æ˜¯main.main BPã€‚\nå¯»å€æ–¹å¼ å¦‚æœæŠŠæ•´ä¸ªå‡½æ•°æ ˆå¸§è§†ä¸ºä¸€ä¸ªstructï¼ŒSPå­˜å‚¨ç€è¿™ä¸ªstructçš„èµ·å§‹åœ°å€ï¼Œç„¶åå°±å¯ä»¥é€šè¿‡ã€åŸºå€+ä½ç§»ã€‘çš„æ–¹å¼æ¥å¯»å€structçš„å„ä¸ªå­—æ®µï¼Œä¹Ÿå°±æ˜¯æ ˆå¸§ä¸Šçš„å±€éƒ¨å˜é‡ã€å‚æ•°å’Œè¿”å›å€¼ã€‚ åœ¨Goæ±‡ç¼–ä¸­ï¼Œå¯„å­˜å™¨çš„åå­—æ²¡æœ‰ä½æ•°ä¹‹åˆ†ï¼Œæ¯”å¦‚AXå¯„å­˜å™¨æ²¡æœ‰ä»€ä¹ˆRAXã€EAXä¹‹ç±»çš„åå­—ï¼ŒæŒ‡ä»¤ä¸­ä¸€å¾‹åªèƒ½ä½¿ç”¨AXã€‚æ‰€ä»¥å¦‚æœæŒ‡ä»¤ä¸­æœ‰æ“ä½œçš„å¯„å­˜å™¨æˆ–æ˜¯æŒ‡ä»¤éœ€è¦è®¿é—®å†…å­˜ï¼Œåˆ™æ“ä½œç éƒ½éœ€è¦å¸¦ä¸Šåç¼€ B(8ä½)ã€W(16ä½)ã€D(32ä½)ã€Q(64ä½)ã€‚ Go è¯­è¨€ä¸­å‡½æ•°çš„è¿”å›å€¼å¯ä»¥æ˜¯åŒ¿åçš„ï¼Œä¹Ÿå¯ä»¥æ˜¯å‘½åçš„ã€‚ å¯¹äºåŒ¿åè¿”å›å€¼è€Œè¨€ï¼Œåªèƒ½é€šè¿‡returnè¯­å¥ä¸ºè¿”å›å€¼èµ‹å€¼ã€‚ å¯¹äºå‘½åè¿”å›å€¼ï¼Œå¯ä»¥åœ¨ä»£ç ä¸­é€šè¿‡å…¶åç§°ç›´æ¥æ“ä½œï¼Œä¸å‚æ•°å’Œå±€éƒ¨å˜é‡ç±»ä¼¼ã€‚ è°ƒç”¨çº¦å®š åœ¨è¿›è¡Œå‡½æ•°è°ƒç”¨çš„æ—¶å€™ï¼Œè°ƒç”¨è€…éœ€è¦æŠŠå‚æ•°ä¼ é€’ç»™è¢«è°ƒç”¨è€…ï¼Œè€Œè¢«è°ƒç”¨è€…ä¹Ÿè¦æŠŠè¿”å›å€¼å›ä¼ ç»™è°ƒç”¨è€…ã€‚ è°ƒç”¨çº¦å®šå°±æ˜¯ç”¨æ¥è§„èŒƒå‚æ•°å’Œè¿”å›å€¼çš„ä¼ é€’é—®é¢˜çš„ã€‚å¦‚æœåŸºäºæ ˆä¼ é€’è¿˜ä¼šè§„å®šæ ˆç©ºé—´ç”±è°è´Ÿè´£åˆ†é…ã€é‡Šæ”¾ã€‚ è°ƒç”¨çº¦å®šï¼š è¿”å›å€¼å’Œå‚æ•°éƒ½é€šè¿‡æ ˆä¼ é€’ï¼Œå¯¹åº”çš„æ ˆç©ºé—´ç”±è°ƒç”¨è€…è´Ÿè´£åˆ†é…å’Œé‡Šæ”¾ã€‚ è¿”å›å€¼å’Œå‚æ•°åœ¨æ ˆä¸Šçš„å¸ƒå±€ç­‰ä»·äºä¸¤ä¸ªstructï¼Œstructçš„èµ·å§‹åœ°å€æŒ‰ç…§å¹³å°æœºå™¨å­—èŠ‚é•¿åº¦å¯¹é½ã€‚ å¯„å­˜å™¨ä¼ å‚ Goåœ¨1.17ç‰ˆæœ¬å‰éƒ½æ˜¯é‡‡ç”¨çš„æ ˆçš„å½¢å¼ä¼ é€’å‚æ•°å’Œè¿”å›å€¼ã€‚è¿™æ ·å®ç°ç®€å•ä¸”èƒ½æ”¯æŒæµ·é‡çš„å‚æ•°ä¼ é€’ï¼Œç¼ºç‚¹å°±æ˜¯ä¸å¯„å­˜å™¨ä¼ å‚ç›¸æ¯”æ€§èƒ½æ–¹é¢ä¼šå·®ä¸€äº›ã€‚ åœ¨1.17ç‰ˆæœ¬åGoé‡‡ç”¨äº†å¯„å­˜å™¨ä¼ å‚ï¼Œå½“ç„¶åªæ˜¯åœ¨éƒ¨åˆ†ç¡¬ä»¶æ¶æ„ä¸Šå®ç°äº†ã€‚å³ä½¿æœ‰16ä¸ªé€šç”¨å¯„å­˜å™¨çš„amd64æ¶æ„ï¼Œå¯ç”¨äºä¼ å‚çš„å¯„å­˜å™¨ä¹Ÿæ˜¯æœ‰ä¸Šé™çš„ï¼Œå‚æ•°å¤ªå¤šæ—¶è¿˜æ˜¯æœ‰ä¸€éƒ¨åˆ†é€šè¿‡æ ˆä¼ é€’ã€‚ Goé‡‡ç”¨AXã€BXã€CXã€DIã€SIã€R8ã€R9ã€R10ã€R11è¿™9ä¸ªå¯„å­˜å™¨ä¾é¡ºåºä¼ é€’å‚æ•°æˆ–è¿”å›å€¼ï¼Œå¤šæœ‰çš„å‚æ•°æˆ–è¿”å›å€¼åˆ™æ—¶é€šè¿‡æ ˆä¼ é€’çš„æ–¹å¼ã€‚ æ€»ä½“æ¥è®²ï¼Œä½¿ç”¨9ä¸ªé€šç”¨å¯„å­˜å™¨ä¼ é€’å‚æ•°è¿›è¡Œä¼˜åŒ–ï¼Œæœ€å¤šåªèƒ½ä¼ é€’9ä¸ªæœºå™¨å­—èŠ‚å¤§å°ï¼Œè€Œä¸æ˜¯9ä¸ªå‚æ•°æˆ–è¿”å›å€¼ã€‚åƒstringä¼šå ç”¨ä¸¤ä¸ªæœºå™¨å­—èŠ‚ï¼Œsliceåˆ™ä¼šå ç”¨ä¸‰ä¸ªæœºå™¨å­—èŠ‚ã€‚ å‚è€ƒ https://mp.weixin.qq.com/s/zcqzarXMJrDUY5DLXZXY1Q ","permalink":"https://heliu.site/posts/golang/func/stack/","summary":"å‡½æ•°è°ƒç”¨æ ˆä»‹ç»ã€‚","title":"å‡½æ•°è°ƒç”¨æ ˆ"},{"content":"å†…å­˜å¯¹é½ åœ¨Cè¯­è¨€å‡½æ•°è°ƒç”¨ä¸­ï¼Œé€šè¿‡æ ˆä¼ é€’çš„å‚æ•°éœ€è¦å¯¹é½åˆ°å¹³å°çš„ä½å®½ã€‚ å‡å¦‚é€šè¿‡æ ˆä¼ é€’4ä¸ªcharç±»å‹çš„å‚æ•°ï¼ŒGCCç”Ÿæˆçš„ 32 ä½ç¨‹åºéœ€è¦ 16 å­—èŠ‚ç©ºé—´ï¼Œ64 ä½ç¨‹åºéœ€è¦ 32 å­—èŠ‚æ ˆç©ºé—´ã€‚ å¦‚æœä¼ é€’å¤§é‡å‚æ•°ï¼Œåˆ™è¿™ç§å¯¹é½æ–¹å¼ä¼šå­˜åœ¨å¾ˆå¤§çš„æ ˆç©ºé—´æµªè´¹ã€‚ Goè¯­è¨€å‡½æ•°æ ˆå¸§ä¸­è¿”å›å€¼å’Œå‚æ•°çš„å¯¹é½æ–¹å¼ä¸ struct ç±»ä¼¼ï¼Œå¯¹äºæœ‰è¿”å›å€¼å’Œå‚æ•°çš„å‡½æ•°ï¼Œå¯ä»¥æŠŠæ‰€æœ‰è¿”å›å€¼å’Œæ‰€æœ‰å‚æ•°ç­‰ä»·æˆä¸¤ä¸ª structï¼š ä¸€ä¸ªã€è¿”å›å€¼ structã€‘ å’Œä¸€ä¸ªã€å‚æ•° structã€‘ã€‚ å› ä¸ºå†…å­˜å¯¹é½æ–¹å¼æ›´åŠ ç´§å‡‘ï¼Œæ‰€ä»¥åœ¨æ”¯æŒå¤§é‡å‚æ•°å’Œè¿”å›å€¼æ—¶èƒ½å¤Ÿåšåˆ°è¾ƒé«˜çš„æ ˆç©ºé—´åˆ©ç”¨ç‡ã€‚ é€šè¿‡å¦‚ä¸‹ç¤ºä¾‹å¯ä»¥éªŒè¯å‡½æ•°å‚æ•°å’Œè¿”å›å€¼çš„å¯¹é½æ–¹å¼ä¸ struct æˆå‘˜çš„å¯¹é½æ–¹å¼æ˜¯ä¸€è‡´çš„ï¼Œä»£ç å¦‚ä¸‹ï¼š ä»¥ä¸Šçš„æè¿°éƒ½æ˜¯åœ¨å‡½æ•°é€šè¿‡æ ˆä¼ é€’å‚æ•°å’Œè¿”å›å€¼çš„åŸºç¡€ä¸Šçš„ã€‚åœ¨go1.18åç‰ˆæœ¬ä¸­é‡‡ç”¨äº†å¯„å­˜å™¨ä¼ å‚ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 package main type args struct { a int8 // 1 b int64 // 8 c int32 // 4 d int16 // 2 } //go:noinline func f1(a args) (r args) { println(\u0026amp;r.d, \u0026amp;r.c, \u0026amp;r.b, \u0026amp;r.a, \u0026amp;a.d, \u0026amp;a.c, \u0026amp;a.b, \u0026amp;a.a) return } //go:noinline func f2(aa int8, ab int64, ac int32, ad int16) (ra int8, rb int64, rc int32, rd int16) { println(\u0026amp;rd, \u0026amp;rc, \u0026amp;rb, \u0026amp;ra, \u0026amp;ad, \u0026amp;ac, \u0026amp;ab, \u0026amp;aa) return } func main() { f1(args{}) // 0xc000034744 r.d // 0xc000034740 r.c // 0xc000034738 r.b // 0xc000034730 r.a // 0xc00003476c a.d // 0xc000034768 a.c // 0xc000034760 a.b // 0xc000034758 a.a f2(0, 0, 0, 0) // 0xc00003473a rd // 0xc00003473c rc // 0xc000034740 rb // 0xc000034739 ra // 0xc00003476c ad // 0xc000034768 ac // 0xc000034760 ab // 0xc000034758 aa } æ±‡ç¼–ä»£ç  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 TEXT main.main(SB) /mnt/hgfs/workspace/helium/main.go func main() { 0x4551e0 493b6610 CMPQ 0x10(R14), SP 0x4551e4 7657 JBE 0x45523d 0x4551e6 4883ec38 SUBQ $0x38, SP 0x4551ea 48896c2430 MOVQ BP, 0x30(SP) 0x4551ef 488d6c2430 LEAQ 0x30(SP), BP f1(args{}) 0x4551f4 c644241800 MOVB $0x0, 0x18(SP) # a.a 0x4551f9 48c744242000000000 MOVQ $0x0, 0x20(SP) # a.b 0x455202 c744242800000000 MOVL $0x0, 0x28(SP) # a.c 0x45520a 66c744242c0000 MOVW $0x0, 0x2c(SP) # a.d 0x455211 0fb6442418 MOVZX 0x18(SP), AX # a.a AX 0x455216 488b5c2420 MOVQ 0x20(SP), BX # a.b BX 0x45521b 8b4c2428 MOVL 0x28(SP), CX # a.c CX 0x45521f 31ff XORL DI, DI # a.d DI 0x455221 e83a000000 CALL main.f1(SB) f2(0, 0, 0, 0) 0x455226 31c0 XORL AX, AX # aa AX 0x455228 31db XORL BX, BX # ab BX 0x45522a 31c9 XORL CX, CX # ac CX 0x45522c 31ff XORL DI, DI # ad DI 0x45522e e8ad010000 CALL main.f2(SB) } 0x455233 488b6c2430 MOVQ 0x30(SP), BP 0x455238 4883c438 ADDQ $0x38, SP 0x45523c c3 RET func main() { 0x45523d 0f1f00 NOPL 0(AX) 0x455240 e81bcdffff CALL runtime.morestack_noctxt.abi0(SB) 0x455245 eb99 JMP main.main(SB) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 TEXT main.f1(SB) /mnt/hgfs/workspace/helium/main.go func f1(a args) (r args) { 0x4551e0 493b6610 CMPQ 0x10(R14), SP 0x4551e4 0f8642010000 JBE 0x45532c 0x4551ea 4883ec68 SUBQ $0x68, SP 0x4551ee 48896c2460 MOVQ BP, 0x60(SP) 0x4551f3 488d6c2460 LEAQ 0x60(SP), BP # å‚æ•°åˆ†é…æ ˆå¤§å°ç©ºé—´ 0x4551f8 88442470 MOVB AL, 0x70(SP) # a.a 0x4551fc 48895c2478 MOVQ BX, 0x78(SP) # a.b 0x455201 898c2480000000 MOVL CX, 0x80(SP) # a.c 0x455208 6689bc2484000000 MOVW DI, 0x84(SP) # a.d # è¿”å›å€¼åˆ†é…æ ˆå¤§å°ç©ºé—´ 0x455210 c644240800 MOVB $0x0, 0x8(SP) # r.a 0x455215 48c744241000000000 MOVQ $0x0, 0x10(SP) # r.b 0x45521e c744241800000000 MOVL $0x0, 0x18(SP) # r.c 0x455226 66c744241c0000 MOVW $0x0, 0x1c(SP) # r.d println(\u0026amp;r.d, \u0026amp;r.c, \u0026amp;r.b, \u0026amp;r.a, \u0026amp;a.d, \u0026amp;a.c, \u0026amp;a.b, \u0026amp;a.a) ... ... 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 TEXT main.f2(SB) /mnt/hgfs/workspace/helium/main.go func f2(aa int8, ab int64, ac int32, ad int16) (ra int8, rb int64, rc int32, rd int16) { 0x455360 493b6610 CMPQ 0x10(R14), SP 0x455364 0f8631010000 JBE 0x45549b 0x45536a 4883ec60 SUBQ $0x60, SP 0x45536e 48896c2458 MOVQ BP, 0x58(SP) 0x455373 488d6c2458 LEAQ 0x58(SP), BP # å‚æ•°ä¼ å‚ï¼Œä½¿ç”¨å¯„å­˜å™¨ï¼Œä½†æ˜¯å‚æ•°ç©ºé—´è¿˜æ˜¯æ²¡æœ‰ä¼˜åŒ– 0x455378 88442468 MOVB AL, 0x68(SP) # aa 0x45537c 48895c2470 MOVQ BX, 0x70(SP) # ab 0x455381 894c2478 MOVL CX, 0x78(SP) # ac 0x455385 66897c247c MOVW DI, 0x7c(SP) # ad # è¿”å›å€¼åˆ†é…æ ˆå¤§å°ç©ºé—´ 0x45538a c644240900 MOVB $0x0, 0x9(SP) # ra 0x45538f 48c744241000000000 MOVQ $0x0, 0x10(SP) # rb 0x455398 c744240c00000000 MOVL $0x0, 0xc(SP) # rc 0x4553a0 66c744240a0000 MOVW $0x0, 0xa(SP) # rd println(\u0026amp;rd, \u0026amp;rc, \u0026amp;rb, \u0026amp;ra, \u0026amp;ad, \u0026amp;ac, \u0026amp;ab, \u0026amp;aa) ... ... é€ƒé€¸åˆ†æ ä»€ä¹ˆæ˜¯é€ƒé€¸åˆ†æ å±€éƒ¨å˜é‡åœ°å€ä½œä¸ºè¿”å›å€¼(1) åœ¨è§£é‡Šé€ƒé€¸åˆ†æä¹‹å‰ï¼Œå…ˆæ¥æ€è€ƒä¸€ä¸ªåœºæ™¯ï¼Œå¦‚æœä¸€ä¸ªå‡½æ•°æŠŠè‡ªå·²æ ˆå¸§ä¸ŠæŸä¸ªå±€éƒ¨å˜é‡çš„åœ°å€ä½œä¸ºè¿”å›å€¼è¿”å›ã€‚ ä¼šæœ‰ä»€ä¹ˆé—®é¢˜ï¼Ÿç¤ºä¾‹ä»£ç å¦‚ä¸‹ï¼š 1 2 3 4 5 6 7 8 9 10 11 package main func main() { println(*newInt()) } //go:noinline func newInt() *int { var a int return \u0026amp;a } å‰é¢å¯¹å‡½æ•°æ ˆå¸ƒå±€çš„è®²è§£ newInt() å‡½æ•°çš„å±€éƒ¨å˜é‡aåº”è¯¥åˆ†é…åœ¨å‡½æ•°æ ˆçš„ locals åŒºé—´ã€‚ åœ¨newInt()å‡½æ•°è¿”å›åï¼Œå®ƒçš„æ ˆéšå³é”€æ¯ï¼Œè¿”å›çš„å˜é‡açš„åœ°å€å°±ä¼šå˜æˆä¸€ä¸ªæ‚¬æŒ‚æŒ‡é’ˆï¼Œcaller ä¸­å¯¹è¯¥åœ°å€è¿›è¡Œçš„æ‰€æœ‰è¯»å†™éƒ½æ˜¯ä¸åˆæ³•çš„ï¼Œä¼šé€ æˆç¨‹åºé€»è¾‘é”™è¯¯ç”šè‡³å´©æºƒã€‚ äº‹å®æ˜¯è¿™æ ·çš„å—ï¼Ÿä¸Šè¿°åˆ†ææœ‰ä¸ªå‰ææ¡ä»¶ï¼Œå³å˜é‡ a è¢«åˆ†é…åœ¨æ ˆä¸Šã€‚å‡å¦‚ç¼–è¯‘å™¨èƒ½å¤Ÿæ£€æµ‹åˆ°è¿™ç§æ¨¡å¼ï¼Œè€Œè‡ªåŠ¨æŠŠå˜é‡ a æ”¹ä¸ºå †åˆ†é…ï¼Œå°±ä¸å­˜åœ¨ä¸Šè¿°é—®é¢˜äº†ã€‚ åç¼–è¯‘ newInt() å‡½æ•°ï¼Œçœ‹ä¸€ä¸‹ç»“æœï¼Œä»£ç å¦‚ä¸‹ï¼š é‡ç‚¹å…³æ³¨ä¸Šè¿°æ±‡ç¼–ä»£ç ä¸­ runtime.newobject() å‡½æ•°è°ƒç”¨ï¼Œè¯¥å‡½æ•°æ˜¯ Go è¯­è¨€å†…ç½®å‡½æ•° new() çš„å…·ä½“å®ç°ï¼Œç”¨æ¥åœ¨è¿è¡Œé˜¶æ®µåˆ†é…å•ä¸ªå¯¹è±¡ã€‚ CALL æŒ‡ä»¤ AX å¯„å­˜å™¨å°±æ˜¯ *int ç±»å‹ï¼Œä¹Ÿæ˜¯è¿”å›çš„å€¼ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 TEXT main.newInt(SB) /mnt/hgfs/workspace/helium/main.go func newInt() *int { 0x455240 493b6610 CMPQ 0x10(R14), SP # æ ˆå¢é•¿åˆ¤æ–­ 0x455244 7643 JBE 0x455289 0x455246 4883ec28 SUBQ $0x28, SP 0x45524a 48896c2420 MOVQ BP, 0x20(SP) 0x45524f 488d6c2420 LEAQ 0x20(SP), BP 0x455254 48c744241000000000 MOVQ $0x0, 0x10(SP) # *int ä¸´æ—¶è¿”å›å€¼ç©ºé—´ var a int 0x45525d 488d05bc4a0000 LEAQ 0x4abc(IP), AX # type.int å…ƒç±»å‹ # func newobject(typ *_type) unsafe.Pointer # è¿™é‡Œè°ƒç”¨ newobject å‡½æ•°è¿›è¡Œäº†å †åˆ†é… 0x455264 e8d75cfbff CALL runtime.newobject(SB) # AX=*int ç±»å‹ 0x455269 4889442418 MOVQ AX, 0x18(SP) 0x45526e 48c70000000000 MOVQ $0x0, 0(AX) # *a=0 return \u0026amp;a 0x455275 488b442418 MOVQ 0x18(SP), AX 0x45527a 4889442410 MOVQ AX, 0x10(SP) # è¿”å›å€¼ AX 0x45527f 488b6c2420 MOVQ 0x20(SP), BP 0x455284 4883c428 ADDQ $0x28, SP 0x455288 c3 RET func newInt() *int { 0x455289 e8d2ccffff CALL runtime.morestack_noctxt.abi0(SB) 0x45528e ebb0 JMP main.newInt(SB) å±€éƒ¨å˜é‡åœ°å€ä½œä¸ºè¿”å›å€¼(2) å¦‚æœæŠŠ newInt() å‡½æ•°ä¸­çš„å–åœ°å€è¿ç®—æ”¹æˆä½¿ç”¨å†…ç½®å‡½æ•° new()ï¼Œæ•ˆæœä¹Ÿæ˜¯ä¸€æ ·çš„ï¼Œä»£ç å¦‚ä¸‹ï¼š 1 2 3 4 //go:noinline func newInt() *int { return new(int) } ç›¸å…³æ±‡ç¼–ï¼š 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 $ go build -gcflags=\u0026#34;-N -l\u0026#34; -o ./h1 myzx.cn/helium $ go tool objdump -S -s \u0026#39;^main.newInt$\u0026#39; ./h1 TEXT main.newInt(SB) /mnt/hgfs/workspace/helium/main.go func newInt() *int { 0x455240 493b6610 CMPQ 0x10(R14), SP 0x455244 7637 JBE 0x45527d 0x455246 4883ec28 SUBQ $0x28, SP 0x45524a 48896c2420 MOVQ BP, 0x20(SP) 0x45524f 488d6c2420 LEAQ 0x20(SP), BP 0x455254 48c744241000000000 MOVQ $0x0, 0x10(SP) # *int è¿”å›å€¼ç©ºé—´ return new(int) # func newobject(typ *_type) unsafe.Pointer 0x45525d 488d05bc4a0000 LEAQ 0x4abc(IP), AX # type.int å…ƒç±»å‹ 0x455264 e8d75cfbff CALL runtime.newobject(SB) # AX=*int 0x455269 4889442418 MOVQ AX, 0x18(SP) 0x45526e 4889442410 MOVQ AX, 0x10(SP) 0x455273 488b6c2420 MOVQ 0x20(SP), BP 0x455278 4883c428 ADDQ $0x28, SP 0x45527c c3 RET func newInt() *int { 0x45527d 0f1f00 NOPL 0(AX) 0x455280 e8dbccffff CALL runtime.morestack_noctxt.abi0(SB) 0x455285 ebb9 JMP main.newInt(SB) å½“å‡½æ•°å±€éƒ¨å˜é‡çš„ç”Ÿå‘½å‘¨æœŸè¶…è¿‡å‡½æ•°æ ˆçš„ç”Ÿå‘½å‘¨æœŸæ—¶ï¼Œç¼–è¯‘å™¨æŠŠè¯¥å±€éƒ¨å˜é‡ç”±æ ˆåˆ†é…æ”¹ä¸ºå †åˆ†é…ï¼Œå³å˜é‡ä»æ ˆä¸Šé€ƒé€¸åˆ°å †ä¸Šã€‚ ä¸é€ƒé€¸åˆ†æ åªè¦ä½¿ç”¨äº†new()å‡½æ•°å°±ä¼šé€ æˆå †åˆ†é…?\nå‰é¢é€ƒé€¸åˆ†æä»£ç ç¤ºä¾‹ä¸­å°†å‡½æ•°çš„æŸä¸ªå±€éƒ¨å˜é‡çš„åœ°å€ä½œä¸ºè¿”å›å€¼è¿”å›ï¼Œæˆ–è€…é€šè¿‡å†…ç½®å‡½æ•° new() åŠ¨æ€åˆ†é…å˜é‡å¹¶è¿”å›å…¶åœ°å€ã€‚ å…¶ä¸­å†…ç½®å‡½æ•°new()æœ‰ç€éå¸¸æ˜æ˜¾çš„å †åˆ†é…çš„å«ä¹‰ï¼Œæ˜¯ä¸æ˜¯åªè¦ä½¿ç”¨äº†new()å‡½æ•°å°±ä¼šé€ æˆå †åˆ†é…å‘¢ï¼Ÿ è¿›ä¸€æ­¥çŒœæƒ³ï¼Œå¦‚æœå¯¹å±€éƒ¨å˜é‡è¿›è¡Œå–åœ°å€æ“ä½œä¼šè¢«è½¬æ¢ä¸ºnew()å‡½æ•°è°ƒç”¨ï¼Œé‚£å°±ä¸ä¼šè¿›è¡Œæ‰€è°“çš„é€ƒé€¸åˆ†æäº†ã€‚ å…ˆéªŒè¯new()å‡½æ•°ä¸å †åˆ†é…æ˜¯å¦æœ‰å¿…ç„¶å…³ç³»ï¼Œä»£ç å¦‚ä¸‹ï¼š 1 2 3 4 5 //go:noinline func New() int { p := new(int) return *p } åç¼–è¯‘new()å‡½æ•°ï¼Œå¾—åˆ°çš„æ±‡ç¼–ä»£ç å¦‚ä¸‹ï¼š å³ä¾¿ä»£ç ä¸­ä½¿ç”¨äº†new()å‡½æ•°ï¼Œåªè¦å˜é‡çš„ç”Ÿå‘½å‘¨æœŸæ²¡æœ‰è¶…è¿‡è¿‡å½“å‰å‡½æ•°æ ˆçš„ç”Ÿå‘½å‘¨æœŸï¼Œç¼–è¯‘å™¨å°±ä¸ä¼šè¿›è¡Œå †åˆ†é…ã€‚ äº‹å®ä¸Šï¼Œåªè¦ä»£ç é€»è¾‘å…è®¸ï¼Œç¼–è¯‘å™¨æ€»æ˜¯å€¾å‘äºæŠŠå˜é‡åˆ†é…åœ¨æ ˆä¸Šï¼Œå› ä¸ºæ¯”é…åœ¨å †ä¸Šæ›´é«˜æ•ˆã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 TEXT main.New(SB) /mnt/hgfs/workspace/helium/main.go func New() int { 0x455240 4883ec20 SUBQ $0x20, SP 0x455244 48896c2418 MOVQ BP, 0x18(SP) 0x455249 488d6c2418 LEAQ 0x18(SP), BP 0x45524e 48c7042400000000 MOVQ $0x0, 0(SP) # è¿”å›åœ°å€ int p := new(int) # new å‡½æ•°ç›´æ¥æ˜¯åœ¨æ ˆä¸Šåˆ†é…çš„ 0x455256 48c744240800000000 MOVQ $0x0, 0x8(SP) # 0x8(SP) ç”¨ä½œintç±»å‹å­˜å‚¨ 0 0x45525f 488d4c2408 LEAQ 0x8(SP), CX # CX=0x8(SP); ä¹Ÿå°±æ˜¯ *int 0x455264 48894c2410 MOVQ CX, 0x10(SP) # 0x10(SP); *int return *p 0x455269 8401 TESTB AL, 0(CX) 0x45526b 488b442408 MOVQ 0x8(SP), AX 0x455270 48890424 MOVQ AX, 0(SP) 0x455274 488b6c2418 MOVQ 0x18(SP), BP 0x455279 4883c420 ADDQ $0x20, SP 0x45527d c3 RET è¿™ä¹Ÿå°±æ˜¯æœ¬èŠ‚æ‰€è°“çš„ä¸é€ƒé€¸åˆ†æï¼Œæˆ–è€…è¯´æœªé€ƒé€¸åˆ†æï¼Œè¿™ç§è¯´æ³•å¹¶ä¸ä¸¥è°¨ï¼Œä¸»è¦æ˜¯ä¸ºäº†çªå‡ºç¼–è¯‘å™¨å€¾å‘äºè®©å˜é‡ä¸é€ƒé€¸ã€‚ ä¸é€ƒé€¸åˆ¤æ–­ åŒ…çº§åˆ«æŒ‡é’ˆ(1) æœ¬èŠ‚ä¸»è¦æ¢ç´¢ç¼–è¯‘å™¨è¿›è¡Œé€ƒé€¸åˆ†ææ—¶è¿½è¸ªçš„èŒƒå›´ï¼Œä»¥åŠåœ¨ä»€ä¹ˆæƒ…å†µä¸‹å°±è®¤ä¸ºå˜é‡é€ƒé€¸äº†æˆ–è€…ç¡®å®šå˜é‡æ²¡æœ‰é€ƒé€¸ã€‚ å‰é¢ç ”ç©¶å˜é‡é€ƒé€¸æ‰€æœ‰çš„æ–¹æ³•ï¼Œä¸»è¦é€šè¿‡è®©å‡½æ•°è¿”å›å±€éƒ¨å˜é‡çš„åœ°å€ï¼Œä½¿å±€éƒ¨å˜é‡çš„ç”Ÿå‘½å‘¨æœŸè¶…è¿‡å¯¹åº”å‡½æ•°æ ˆå¸§çš„ç”Ÿå‘½å‘¨æœŸã€‚ æŒ‰ç…§è¿™ä¸ªè§„åˆ™æ¥çŒœæƒ³ï¼Œå¦‚æœæŠŠå±€éƒ¨å˜é‡çš„åœ°å€èµ‹å€¼ç»™åŒ…çº§åˆ«çš„æŒ‡é’ˆå˜é‡ï¼Œåº”è¯¥ä¹Ÿä¼šé€ æˆå˜é‡é€ƒé€¸ã€‚ å‡†å¤‡ä¸€ä¸ªç¤ºä¾‹ï¼Œä»£ç å¦‚ä¸‹ï¼š 1 2 3 4 5 6 7 var pt *int //go:noinline func setNew() { var a int pt = \u0026amp;a } åç¼–è¯‘ setNew() å‡½æ•°ï¼Œä»£ç å¦‚ä¸‹ï¼š 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 TEXT main.setNew(SB) /mnt/hgfs/workspace/helium/main.go func setNew() { 0x455220 493b6610 CMPQ 0x10(R14), SP # æ ˆå¢é•¿åˆ¤æ–­ 0x455224 765d JBE 0x455283 0x455226 4883ec20 SUBQ $0x20, SP 0x45522a 48896c2418 MOVQ BP, 0x18(SP) 0x45522f 488d6c2418 LEAQ 0x18(SP), BP var a int 0x455234 488d05e54a0000 LEAQ 0x4ae5(IP), AX # type.int å…ƒç±»å‹ 0x45523b 0f1f440000 NOPL 0(AX)(AX*1) # func newobject(typ *_type) unsafe.Pointer # è¿™é‡Œç›´æ¥è°ƒç”¨äº† newobject å †åˆ†é…äº† int 0x455240 e8fb5cfbff CALL runtime.newobject(SB) # *int 0x455245 4889442410 MOVQ AX, 0x10(SP) 0x45524a 48c70000000000 MOVQ $0x0, 0(AX) # a = 0 pt = \u0026amp;a 0x455251 488b4c2410 MOVQ 0x10(SP), CX # CX=0x10(SP)=*int # åˆ¤æ–­æ˜¯å¦å¼€å¯å†™å±éšœï¼Œå› ä¸ºå¯èƒ½åœ¨GCé˜¶æ®µï¼Œå˜é‡çš„èµ‹å€¼éœ€è¦å†™å±éšœ 0x455256 833d0320090000 CMPL $0x0, runtime.writeBarrier(SB) 0x45525d 7403 JE 0x455262 0x45525f 90 NOPL 0x455260 eb09 JMP 0x45526b 0x455262 48890db7320600 MOVQ CX, main.pt(SB) # ç»™å…¨å±€å˜é‡ pt èµ‹å€¼ 0x455269 eb0e JMP 0x455279 0x45526b 488d3dae320600 LEAQ main.pt(SB), DI # å†™å±éšœå¼€å¯çš„æ—¶å€™è°ƒç”¨å†™å±éšœç›¸å…³å‡½æ•°ï¼Œè®°å½•æŒ‡é’ˆçš„å˜æ›´ï¼Œå·²å¸®åŠ©GC 0x455272 e8a9d0ffff CALL runtime.gcWriteBarrierCX(SB) 0x455277 eb00 JMP 0x455279 } 0x455279 488b6c2418 MOVQ 0x18(SP), BP 0x45527e 4883c420 ADDQ $0x20, SP 0x455282 c3 RET func setNew() { 0x455283 e8d8ccffff CALL runtime.morestack_noctxt.abi0(SB) 0x455288 eb96 JMP main.setNew(SB) é€šè¿‡ runtime.newobject() å‡½æ•°è°ƒç”¨å°±èƒ½ç¡®å®šï¼Œå˜é‡aé€ƒé€¸åˆ°äº†å †ä¸Šï¼ŒéªŒè¯äº†ä¸Šè¿°çŒœæƒ³ã€‚ åŒ…çº§åˆ«æŒ‡é’ˆ(2) è¿›ä¸€æ­¥è¿˜å¯ä»¥éªŒè¯é€ƒé€¸åˆ†æçš„ä¾èµ–ä¼ é€’æ€§ï¼Œå‡†å¤‡ç¤ºä¾‹ä»£ç å¦‚ä¸‹ï¼š 1 2 3 4 5 6 7 8 9 var pp **int //go:noinline func dep() { var a int var p *int p = \u0026amp;a pp = \u0026amp;p } åç¼–è¯‘ dep() å‡½æ•°ï¼š å¯ä»¥å‘ç°ï¼Œå˜é‡ p å’Œ a éƒ½é€ƒé€¸äº†ã€‚ p çš„åœ°å€è¢«èµ‹å€¼ç»™åŒ…çº§åˆ«çš„æŒ‡é’ˆå˜é‡ ppï¼Œè€Œ a çš„åœ°å€åˆè¢«èµ‹å€¼ç»™äº† pï¼Œå› ä¸º p é€ƒé€¸é€ æˆ a ä¹Ÿé€ƒé€¸äº†ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 TEXT main.dep(SB) /mnt/hgfs/workspace/helium/main.go func dep() { 0x455220 493b6610 CMPQ 0x10(R14), SP # æ ˆå¢é•¿åˆ¤æ–­ 0x455224 0f86b0000000 JBE 0x4552da 0x45522a 4883ec28 SUBQ $0x28, SP 0x45522e 48896c2420 MOVQ BP, 0x20(SP) 0x455233 488d6c2420 LEAQ 0x20(SP), BP var a int 0x455238 488d05e14a0000 LEAQ 0x4ae1(IP), AX # type.int å…ƒç±»å‹; 0x45523f 90 NOPL # func newobject(typ *_type) unsafe.Pointer 0x455240 e8fb5cfbff CALL runtime.newobject(SB) # å †åˆ†é…äº† a å˜é‡; AX *int 0x455245 4889442418 MOVQ AX, 0x18(SP) # 0x18(SP); æ˜¯açš„å†…å­˜ç©ºé—´ï¼ŒæŒ‡å‘å †åˆ†é…æ•°æ® 0x45524a 48c70000000000 MOVQ $0x0, 0(AX) # åˆå§‹åŒ– 0 var p *int 0x455251 488d0508320000 LEAQ 0x3208(IP), AX # type *int å…ƒç±»å‹ # func newobject(typ *_type) unsafe.Pointer 0x455258 e8e35cfbff CALL runtime.newobject(SB) # **int 0x45525d 4889442410 MOVQ AX, 0x10(SP) 0x455262 833df71f090000 CMPL $0x0, runtime.writeBarrier(SB) 0x455269 7402 JE 0x45526d 0x45526b eb09 JMP 0x455276 0x45526d 48c70000000000 MOVQ $0x0, 0(AX) 0x455274 eb11 JMP 0x455287 0x455276 4889c7 MOVQ AX, DI 0x455279 31c0 XORL AX, AX 0x45527b 0f1f440000 NOPL 0(AX)(AX*1) 0x455280 e89bcfffff CALL runtime.gcWriteBarrier(SB) 0x455285 eb00 JMP 0x455287 p = \u0026amp;a 0x455287 488b7c2410 MOVQ 0x10(SP), DI 0x45528c 488b442418 MOVQ 0x18(SP), AX 0x455291 833dc81f090000 CMPL $0x0, runtime.writeBarrier(SB) 0x455298 7402 JE 0x45529c 0x45529a eb06 JMP 0x4552a2 0x45529c 488907 MOVQ AX, 0(DI) 0x45529f 90 NOPL 0x4552a0 eb07 JMP 0x4552a9 0x4552a2 e879cfffff CALL runtime.gcWriteBarrier(SB) 0x4552a7 eb00 JMP 0x4552a9 pp = \u0026amp;p 0x4552a9 488b442410 MOVQ 0x10(SP), AX 0x4552ae 833dab1f090000 CMPL $0x0, runtime.writeBarrier(SB) 0x4552b5 7402 JE 0x4552b9 0x4552b7 eb09 JMP 0x4552c2 0x4552b9 48890560320600 MOVQ AX, main.pp(SB) 0x4552c0 eb0e JMP 0x4552d0 0x4552c2 488d3d57320600 LEAQ main.pp(SB), DI 0x4552c9 e852cfffff CALL runtime.gcWriteBarrier(SB) 0x4552ce eb00 JMP 0x4552d0 } 0x4552d0 488b6c2420 MOVQ 0x20(SP), BP 0x4552d5 4883c428 ADDQ $0x28, SP 0x4552d9 c3 RET func dep() { 0x4552da e881ccffff CALL runtime.morestack_noctxt.abi0(SB) 0x4552df 90 NOPL 0x4552e0 e93bffffff JMP main.dep(SB) å‡å¦‚æŸä¸ªå‡½æ•°æœ‰ä¸€ä¸ªå‚æ•°å’Œä¸€ä¸ªè¿”å›å€¼ï¼Œç±»å‹éƒ½æ˜¯æ•´å‹æŒ‡é’ˆï¼Œå‡½æ•°åªæ˜¯ç®€å•åœ°æŠŠå‚æ•°ä½œä¸ºè¿”å›å€¼ã€‚ åœ¨å‡½æ•°é—´ä¼ é€’ å°±åƒä¸‹é¢çš„ gom.RetArg() å‡½æ•°ï¼Œä»£ç å¦‚ä¸‹ï¼š 1 2 3 4 5 6 package gom //go:noinline func RetArg(p *int) *int { return p } åœ¨å¦ä¸€ä¸ªåŒ…ä¸­ arg() å‡½æ•°è°ƒç”¨äº† inner.RetArg() å‡½æ•°å°†å±€éƒ¨å˜é‡ a çš„åœ°å€ä½œä¸ºå‚æ•°ï¼Œå¹¶è¿”å›äº†ä¸€ä¸ª int ç±»å‹çš„è¿”å›å€¼ã€‚ ä»£ç å¦‚ä¸‹ï¼š 1 2 3 4 5 6 7 package main //go:noinline func arg() int { var a int return *gom.RetArg(\u0026amp;a) } åœ¨ arg() å‡½æ•°ä¸­å¹¶æ²¡æœ‰æŠŠå˜é‡ a çš„åœ°å€ä½œä¸ºè¿”å›å€¼ï¼Œä¹Ÿä¸å­˜åœ¨åˆ°æŸä¸ªåŒ…çº§åˆ«æŒ‡é’ˆå˜é‡çš„ä¾èµ–é“¾è·¯ï¼Œæ‰€ä»¥å˜é‡aæ˜¯å¦ä¼šé€ƒé€¸çš„å…³é”®å°±åœ¨äºinner.RetArg()å‡½æ•°ã€‚ inner. RetArg()å‡½æ•°åªæ˜¯æŠŠä¼ è¿‡å»çš„æŒ‡é’ˆåˆä¼ äº†å›æ¥ï¼Œè€Œä¸”ä½œä¸ºè¢«è°ƒç”¨è€…æ¥è®²ï¼Œå®ƒçš„ç”Ÿå‘½å‘¨æœŸæ˜¯å®Œå…¨åŒ…å«åœ¨arg()å‡½æ•°çš„ç”Ÿå‘½å‘¨æœŸä»¥å†…çš„ï¼Œæ‰€ä»¥ä¸åº”è¯¥é€ æˆå˜é‡ a é€ƒé€¸ã€‚ äº‹å®åˆ°åº•å¦‚ä½•å‘¢? è¿˜è¦é€šè¿‡åç¼–è¯‘éªŒè¯ï¼ŒèŠ‚é€‰éƒ¨åˆ†å…³é”®æ±‡ç¼–ä»£ç å¦‚ä¸‹ï¼š å˜é‡aç¡®å®æ˜¯åœ¨æ ˆä¸Šåˆ†é…çš„ï¼Œä¹Ÿå°±è¯´æ˜ç¼–è¯‘å™¨å‚è€ƒäº†inner.RetArg()å‡½æ•°çš„å…·ä½“å®ç°ï¼ŒåŸºäºä»£ç é€»è¾‘åˆ¤å®šå˜é‡ a æ²¡æœ‰é€ƒé€¸ã€‚ è™½ç„¶ä»£ç ä¸­é€šè¿‡**noinlineé˜»æ­¢äº†å†…è”ä¼˜åŒ–ï¼Œä½†æ˜¯æ²¡èƒ½é˜»æ­¢ç¼–è¯‘å™¨å‚è€ƒå‡½æ•°å®ç°**ã€‚ å‡å¦‚é€šè¿‡æŸç§æ–¹å¼èƒ½å¤Ÿé˜»æ­¢ç¼–è¯‘å™¨å‚è€ƒå‡½æ•°å®ç°ï¼Œåˆä¼šæœ‰ä»€ä¹ˆæ ·çš„ç»“æœå‘¢? 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 TEXT main.arg(SB) /mnt/hgfs/workspace/helium/main.go func arg() int { 0x455240 493b6610 CMPQ 0x10(R14), SP # æ ˆå¢é•¿åˆ¤æ–­ 0x455244 7643 JBE 0x455289 0x455246 4883ec28 SUBQ $0x28, SP 0x45524a 48896c2420 MOVQ BP, 0x20(SP) 0x45524f 488d6c2420 LEAQ 0x20(SP), BP 0x455254 48c744240800000000 MOVQ $0x0, 0x8(SP) # return int var a int 0x45525d 48c744241000000000 MOVQ $0x0, 0x10(SP) return *gom.RetArg(\u0026amp;a) # å¯ä»¥çœ‹å‡ºè¿™é‡Œè°ƒç”¨gom.RetArgå‡½æ•°æ—¶å‚æ•°ç›´æ¥æ˜¯åœ¨æ ˆä¸Šåˆ†é…çš„ï¼Œå¹¶æ²¡æœ‰å †åˆ†é… 0x455266 488d442410 LEAQ 0x10(SP), AX 0x45526b e870ffffff CALL example.com/helium/gom.RetArg(SB) 0x455270 4889442418 MOVQ AX, 0x18(SP) 0x455275 8400 TESTB AL, 0(AX) 0x455277 488b00 MOVQ 0(AX), AX 0x45527a 4889442408 MOVQ AX, 0x8(SP) 0x45527f 488b6c2420 MOVQ 0x20(SP), BP 0x455284 4883c428 ADDQ $0x28, SP 0x455288 c3 RET func arg() int { 0x455289 e8d2ccffff CALL runtime.morestack_noctxt.abi0(SB) 0x45528e ebb0 JMP main.arg(SB) linkname æœºåˆ¶ å¯ä»¥ä½¿ç”¨ linkname æœºåˆ¶ï¼Œè¿åŒä¿®æ”¹åçš„ arg() å‡½æ•°çš„ä»£ç å¦‚ä¸‹ï¼š 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 package main import ( \u0026#34;example.com/helium/gom\u0026#34; _ \u0026#34;unsafe\u0026#34; // ä½¿ç”¨äº† go:linkname å¿…é¡»è¦å¼•å…¥ unsafe åŒ… ) func main() { arg() } //go:linkname retArg example.com/helium/gom.RetArg func retArg(p *int) *int //go:noinline func arg() int { var a int var b int return *gom.RetArg(\u0026amp;a) + retArg(\u0026amp;b) } å†æ¬¡åç¼–è¯‘ arg() å‡½æ•°ï¼ŒèŠ‚é€‰å˜é‡ a å’Œ b åˆ†é…ç›¸å…³çš„æ±‡ç¼–ä»£ç å¦‚ä¸‹ï¼š å˜é‡ a ä¾æ—§æ˜¯æ ˆåˆ†é…ï¼Œå˜é‡ b å·²ç»é€ƒé€¸äº†ã€‚ åœ¨ä¸Šè¿°ä»£ç ä¸­çš„ retArg() å‡½æ•°åªæ˜¯ä¸ªå‡½æ•°å£°æ˜æ²¡æœ‰ç»™å‡ºå…·ä½“å®ç°ï¼Œé€šè¿‡ linkname æœºåˆ¶è®©é“¾æ¥å™¨åœ¨é“¾æ¥é˜¶æ®µé“¾æ¥åˆ° inner.RetArg() å‡½æ•°ã€‚ retArg() å‡½æ•°åªæœ‰å£°æ˜æ²¡æœ‰å®ç°ï¼Œè€Œä¸”ç¼–è¯‘å™¨ä¸ä¼šè·Ÿè¸ª linknameï¼Œæ‰€ä»¥æ— æ³•æ ¹æ®ä»£ç é€»è¾‘åˆ¤å®šå˜é‡ b åˆ°åº•æœ‰æ²¡æœ‰é€ƒé€¸ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 TEXT main.arg(SB) /mnt/hgfs/workspace/helium/main.go func arg() int { 0x455240 493b6610 CMPQ 0x10(R14), SP # æ ˆå¢é•¿åˆ¤æ–­ 0x455244 7677 JBE 0x4552bd 0x455246 4883ec40 SUBQ $0x40, SP 0x45524a 48896c2438 MOVQ BP, 0x38(SP) 0x45524f 488d6c2438 LEAQ 0x38(SP), BP 0x455254 48c744241000000000 MOVQ $0x0, 0x10(SP) # return int var a int 0x45525d 48c744241800000000 MOVQ $0x0, 0x18(SP) # a,0 var b int 0x455266 488d05b34a0000 LEAQ 0x4ab3(IP), AX # type.int 0x45526d e8ce5cfbff CALL runtime.newobject(SB) # *int 0x455272 4889442430 MOVQ AX, 0x30(SP) # å˜é‡bï¼Œå †åˆ†é…äº† 0x455277 48c70000000000 MOVQ $0x0, 0(AX) return *gom.RetArg(\u0026amp;a) + *retArg(\u0026amp;b) 0x45527e 488d442418 LEAQ 0x18(SP), AX 0x455283 e858ffffff CALL example.com/helium/gom.RetArg(SB) 0x455288 4889442428 MOVQ AX, 0x28(SP) 0x45528d 488b442430 MOVQ 0x30(SP), AX 0x455292 e849ffffff CALL example.com/helium/gom.RetArg(SB) 0x455297 4889442420 MOVQ AX, 0x20(SP) 0x45529c 488b4c2428 MOVQ 0x28(SP), CX 0x4552a1 8401 TESTB AL, 0(CX) 0x4552a3 8400 TESTB AL, 0(AX) 0x4552a5 488b09 MOVQ 0(CX), CX 0x4552a8 480308 ADDQ 0(AX), CX 0x4552ab 48894c2410 MOVQ CX, 0x10(SP) 0x4552b0 4889c8 MOVQ CX, AX 0x4552b3 488b6c2438 MOVQ 0x38(SP), BP 0x4552b8 4883c440 ADDQ $0x40, SP 0x4552bc c3 RET func arg() int { 0x4552bd 0f1f00 NOPL 0(AX) 0x4552c0 e89bccffff CALL runtime.morestack_noctxt.abi0(SB) 0x4552c5 e976ffffff JMP main.arg(SB) æŠŠé€»è¾‘ä¸Šæ²¡æœ‰é€ƒé€¸çš„å˜é‡åˆ†é…åˆ°å †ä¸Šä¸ä¼šé€ æˆé”™è¯¯ï¼Œåªæ˜¯æ•ˆç‡ä½ä¸€äº›ã€‚ ä½†æ˜¯æŠŠé€»è¾‘ä¸Šé€ƒé€¸äº†çš„å˜é‡åˆ†é…åˆ°æ ˆä¸Šå°±ä¼šé€ æˆæ‚¬æŒ‚æŒ‡é’ˆç­‰é—®é¢˜ã€‚ å› æ­¤ç¼–è¯‘å™¨åªæœ‰åœ¨èƒ½å¤Ÿç¡®å®šå˜é‡æ²¡æœ‰é€ƒé€¸çš„æƒ…å†µä¸‹ï¼Œæ‰ä¼šå°†å…¶åˆ†é…åˆ°æ ˆä¸Šï¼Œåœ¨èƒ½å¤Ÿç¡®å®šå˜é‡å·²ç»é€ƒé€¸æˆ–æ— æ³•ç¡®å®šåˆ°åº•æœ‰æ²¡æœ‰é€ƒé€¸çš„æƒ…å†µä¸‹ï¼Œéƒ½è¦æŒ‰ç…§å·²ç»é€ƒé€¸æ¥å¤„ç†ã€‚ è¿™ä¹Ÿå°±è§£é‡Šäº†ä¸ºä»€ä¹ˆåœ¨ä¸Šè¿°ä»£ç ä¸­çš„å˜é‡ b é€»è¾‘ä¸Šæ²¡é€ƒé€¸å´è¢«åˆ†é…åœ¨äº†å †ä¸Šã€‚ å‡½æ•°ç¤ºä¾‹ ç¤ºä¾‹ä¸€ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 package main func main() { sum(1, 2) } // sum è®¡ç®—a, bçš„å¹³æ–¹å’Œ func sum(a, b int) int { a2 := a * a b2 := b * b c := a2 + b2 return c } main.mainæ±‡ç¼–ï¼š 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 TEXT main.main(SB) /mnt/hgfs/g/hello1/hello.go # åˆ¤æ–­æ ˆæ˜¯å¦æº¢å‡º 0x10(R14)æŒ‡å‘g.stackguard0ä½ç½® hello.go:3 0x45b4a0 493b6610 cmp rsp, qword ptr [r14+0x10] cmp 0x10(R14), rsp # è·³è½¬åˆ°0x45b4cfå¤„è®¾ç½®æ ˆä¿¡æ¯ï¼Œåœ¨é‡æ–°è°ƒmain.mainå‡½æ•° hello.go:3 0x45b4a4 7629 jbe 0x45b4cf jbe 0x45b4cf # ä¸ºå½“å‰æ ˆé¢„åˆ†é…å‚æ•°ç©ºé—´ï¼Œç¬¬ä¸€ä¸ª8Bå­˜å‚¨runtime.mainçš„rbpï¼Œç¬¬äºŒä¸ª8Bå­˜å‚¨main.sunçš„å‚æ•°bä¸º1ï¼Œç¬¬ä¸‰ä¸ª8Bå­˜å‚¨main.sunçš„å‚æ•°aä¸º2 hello.go:3 0x45b4a6 4883ec18 sub rsp, 0x18 sub 0x18, rsp # æŠŠruntime.mainçš„æ ˆrbpå­˜å…¥0x10(rsp)å¤„ hello.go:3 0x45b4aa 48896c2410 mov qword ptr [rsp+0x10], rbp mov rbp, 0x10(rsp) # ä»æ–°è®¾ç½®å½“å‰main.mainçš„æ ˆrbpå€¼ä¸º0x10(rsp)å¤„ hello.go:3 0x45b4af 488d6c2410 lea rbp, ptr [rsp+0x10] lea 0x10(rsp), rbp # ä¸ºmain.sumå‡†å¤‡ç¬¬ä¸€ä¸ªå‚æ•°ï¼Œæ”¾å…¥å¯„å­˜å™¨AXä¸­ hello.go:4 0x45b4b4 b801000000 mov eax, 0x1 mov 0x1, AX # ä¸ºmain.sumå‡†å¤‡ç¬¬äºŒä¸ªå‚æ•°ï¼Œæ”¾å…¥å¯„å­˜å™¨BXä¸­ hello.go:4 0x45b4b9 bb02000000 mov ebx, 0x2 mov 0x2, BX hello.go:4 0x45b4be 6690 data16 nop hello.go:4 0x45b4c0 e81b000000 call $main.sum call $main.sum # æŠŠruntime.mainçš„æ ˆrbpå€¼ä»0x10(rsp)å¤„æ”¾å…¥rbpå¯„å­˜å™¨ hello.go:5 0x45b4c5 488b6c2410 mov rbp, qword ptr [rsp+0x10] mov 0x10(rsp), rbp # rspå¯„å­˜å™¨æ¢å¤è°ƒç”¨main.mainä¹‹å‰æƒ…å†µ hello.go:5 0x45b4ca 4883c418 add rsp, 0x18 add 0x18, rsp # è¿”å›ï¼Œrsp-8å¼¹å‡ºè¿”å›åœ°å€ç»™ripè¿”å›çš„runtime.mainç»§ç»­æ‰§è¡Œ hello.go:5 0x45b4ce c3 ret ret hello.go:3 0x45b4cf e88ccdffff call $runtime.morestack_noctxt call $runtime.morestack_noctxt .:0 0x45b4d4 ebca jmp $main.main jmp $main.main main.sumæ±‡ç¼–ï¼š 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 TEXT main.sum(SB) /mnt/hgfs/g/hello1/hello.go # ä¸ºmain.sumæ ˆé¢„åˆ†é…0x28ç©ºé—´ hello.go:8 0x45b4e0 4883ec28 sub rsp, 0x28 sub 0x28, rsp # æŠŠmain.mainçš„rbpå­˜å‚¨åˆ°0x20(rsp)ä½ç½® hello.go:8 0x45b4e4 48896c2420 mov qword ptr [rsp+0x20], rbp mov rbp, 0x20(rsp) # ä»æ–°è®¾ç½®main.sumçš„rbpå€¼ hello.go:8 0x45b4e9 488d6c2420 lea rbp, ptr [rsp+0x20] lea 0x20(rsp), rbp # æŠŠä¼ é€’çš„ç¬¬ä¸€ä¸ªå‚æ•°å…¥æ ˆï¼Œæ³¨æ„çœ‹è¿™é‡Œå‚å‚æ•°æ ˆåˆ†é…åœ¨main.mainçš„æ ˆä¸Š hello.go:8 0x45b4ee 4889442430 mov qword ptr [rsp+0x30], rax mov AX, 0x30(rsp) # a = 1 # æŠŠä¼ é€’çš„ç¬¬äºŒä¸ªå‚æ•°å…¥æ ˆï¼Œæ³¨æ„çœ‹è¿™é‡Œå‚å‚æ•°æ ˆåˆ†é…åœ¨main.mainçš„æ ˆä¸Š hello.go:8 0x45b4f3 48895c2438 mov qword ptr [rsp+0x38], rbx mov BX, 0x38(rsp) # b = 2 # åˆå§‹åŒ–rspçš„ç¬¬ä¸€ä¸ª8å­—èŠ‚å—ï¼Œè¿”å›å€¼ç©ºé—´åˆå§‹åŒ– hello.go:8 0x45b4f8 48c7042400000000 mov qword ptr [rsp], 0x0 mov 0x0, (rsp) # return # ä¸ºä¹˜æ³•è¿ç®—åšå‡†å¤‡ï¼ŒæŠŠå˜é‡açš„å€¼æ”¾å…¥å¯„å­˜å™¨ hello.go:9 0x45b500 488b4c2430 mov rcx, qword ptr [rsp+0x30] mov 0x30(rsp), CX # ä¸ºä¹˜æ³•è¿ç®—åšå‡†å¤‡ï¼ŒæŠŠå˜é‡açš„å€¼æ”¾å…¥å¯„å­˜å™¨ hello.go:9 0x45b505 488b542430 mov rdx, qword ptr [rsp+0x30] mov 0x30(rsp), DX # ä¹˜æ³•è¿ç®—ï¼Œç»“æœå­˜å‚¨åœ¨DXä¸­ hello.go:9 0x45b50a 480fafd1 imul rdx, rcx imul CX, DX # a*a # 0X18(rsp)çš„åœ°å€ä¸ºå˜é‡a2 hello.go:9 0x45b50e 4889542418 mov qword ptr [rsp+0x18], rdx mov DX, 0X18(rsp) # a2=a*a # ä¸ºä¹˜æ³•è¿ç®—åšå‡†å¤‡ï¼ŒæŠŠå˜é‡bçš„å€¼æ”¾å…¥å¯„å­˜å™¨ hello.go:10 0x45b513 488b4c2438 mov rcx, qword ptr [rsp+0x38] mov 0x38(rsp), CX # ä¸ºä¹˜æ³•è¿ç®—åšå‡†å¤‡ï¼ŒæŠŠå˜é‡bçš„å€¼æ”¾å…¥å¯„å­˜å™¨ hello.go:10 0x45b518 488b542438 mov rdx, qword ptr [rsp+0x38] mov 0x38(rsp), DX # ä¹˜æ³•è¿ç®—ï¼Œç»“æœå­˜å‚¨åœ¨DXä¸­ hello.go:10 0x45b51d 480fafd1 imul rdx, rcx imul CX, DX # b*b # 0X10(rsp)çš„åœ°å€ä¸ºå˜é‡b2 hello.go:10 0x45b521 4889542410 mov qword ptr [rsp+0x10], rdx mov DX, 0x10(rsp) # b2 = b*b # æŠŠa2å€¼æ”¾å…¥CXå¯„å­˜å™¨ hello.go:11 0x45b526 488b4c2418 mov rcx, qword ptr [rsp+0x18] mov 0x18(rsp), CX # è®¡ç®— a2 + b2 hello.go:11 0x45b52b 488d0411 lea rax, ptr [rcx+rdx*1] lea (CX+DX*1), AX # a2+b2 # a2 + b2 å€¼å­˜å…¥0x8(rsp)æ˜¯å˜é‡çš„å€¼ hello.go:11 0x45b52f 4889442408 mov qword ptr [rsp+0x8], rax mov AX, 0x8(rsp) # c = a2+b2 # a2 + b2 å€¼å­˜å…¥(rsp) è¯¥å€¼æ˜¯è¿”å›å€¼ç©ºé—´ hello.go:13 0x45b534 48890424 mov qword ptr [rsp], rax mov AX, (rsp) # return # å¼¹å‡ºmain.mainçš„rbp hello.go:13 0x45b538 488b6c2420 mov rbp, qword ptr [rsp+0x20] mov 0x20(rsp), rbp # ä½¿rspæŒ‡å‘main.mainçš„æ ˆrspä½ç½® .:0 0x45b53d 4883c428 add rsp, 0x28 add 0x28, rsp # å¼¹å‡ºmain.mainçš„ä¸‹ä¸€æ¡æŒ‡ä»¤åœ°å€ .:0 0x45b541 c3 ret ret æ ˆåˆ†å¸ƒæƒ…å†µï¼š // æˆ‘ä»¬çœ‹ä¸€ä¸‹ä»£ç åœ¨14è¡Œæ—¶ä¹Ÿå°±æ˜¯main.sumå‡½æ•°è¿”å›å‰çš„æ ˆå¸ƒå±€æƒ…å†µ // // æ ˆåº• // ---------------------------- é«˜åœ°å€ // | b // ---------------------------- // | a runtime.mainå‡½æ•°æ ˆå¸§ // ---------------------------- // | è¿”å›åˆ°runtime.mainçš„åœ°å€ +0x48 // -----------\u0026gt; ---------------------------- \u0026lt;------------------------------------- // | è°ƒç”¨å‡½æ•°runtime.mainçš„rbp +0x40 // ---------------------------- // | main.sumçš„ç¬¬äºŒä¸ªå‚æ•° 0x2 +0x38 // ---------------------------- main.mainå‡½æ•°æ ˆå¸§ // | main.sumçš„ç¬¬ä¸€ä¸ªå‚æ•° 0x1 +0x30 // ---------------------------- // | è¿”å›åˆ°main.mainçš„åœ°å€ +0x28 // -----------\u0026gt; ---------------------------- \u0026lt;------------------------------------- // | è°ƒç”¨å‡½æ•°main.mainçš„rbp +0x20 // ---------------------------- // | å˜é‡a2 0x1 +0x18 // ---------------------------- // | å˜é‡b2 0x4 +0x10 main.sumå‡½æ•°æ ˆå¸§ // ---------------------------- // | å˜é‡c 0x5 +0x8 // ---------------------------- // | main.sumçš„è¿”å›å€¼åœ°å€ 0x5 +0x0 // -----------\u0026gt; ---------------------------- \u0026lt;------------------------------------- ç¼–è¯‘æŒ‡ä»¤ ç¼–è¯‘æŒ‡ä»¤ï¼šgo build -gcflags=\u0026quot;-N -l\u0026quot; slice1.goã€‚ æŸ¥çœ‹å…·ä½“æ–¹æ³•çš„æ±‡ç¼–æŒ‡ä»¤ï¼šgo tool objdump -S -s \u0026lsquo;^main.main$\u0026rsquo; slice1ã€‚ ","permalink":"https://heliu.site/posts/golang/func/align/","summary":"Golang å†…å­˜å¯¹é½å’Œé€ƒé€¸åˆ†æä»‹ç»ã€‚","title":"å†…å­˜å¯¹é½å’Œé€ƒé€¸åˆ†æ"},{"content":" å‡½æ•°åœ¨ Go è¯­è¨€ä¸­å±äºç¬¬ä¸€ç±»å€¼(First Class Value)ï¼Œè¯¥ç±»å‹çš„å€¼å¯ä»¥ä½œä¸ºå‡½æ•°çš„å‚æ•°å’Œè¿”å›å€¼ï¼Œä¹Ÿå¯ä»¥èµ‹ç»™å˜é‡ã€‚ å½“æŠŠä¸€ä¸ªå‡½æ•°èµ‹å€¼ç»™æŸä¸ªå˜é‡åï¼Œè¿™ä¸ªå˜é‡å°±è¢«ç§°ä¸º Function Valueã€‚ å£°æ˜ä¸€ä¸ª Function Value å˜é‡çš„ç¤ºä¾‹ä»£ç å¦‚ä¸‹ï¼š var fn func(a, b int) int å…¶ä¸­ fn å°±æ˜¯ä¸ª Function Value å˜é‡ï¼Œå®ƒçš„ç±»å‹æ˜¯ func(int, int) intã€‚ Function Value å¯ä»¥åƒä¸€èˆ¬å‡½æ•°é‚£æ ·è¢«è°ƒç”¨ï¼Œåœ¨ä½¿ç”¨ä½“éªŒä¸Šéå¸¸ç±»ä¼¼äº C è¯­è¨€ä¸­çš„å‡½æ•°æŒ‡é’ˆã€‚ Function Value æœ¬è´¨ä¸Šæ˜¯ä¸æ˜¯å‡½æ•°æŒ‡é’ˆå‘¢ï¼Ÿ æœ¬èŠ‚ä¼šåˆ†æ Function Value å’Œå‡½æ•°æŒ‡é’ˆçš„å®ç°åŸç†ï¼Œè¿˜æœ‰é—­åŒ…çš„å®ç°åŸç†ï¼Œä»¥åŠ Function Value æ˜¯å¦‚ä½•æ”¯æŒé—­åŒ…çš„ã€‚ å‡½æ•°æŒ‡é’ˆ ç†Ÿæ‚‰ C è¯­è¨€çš„è¯»è€…åº”è¯¥æœ‰è¿‡ä½¿ç”¨å‡½æ•°æŒ‡é’ˆçš„ç»éªŒï¼Œå‡½æ•°æŒ‡é’ˆå­˜å‚¨çš„éƒ½æ˜¯åœ°å€ï¼Œåªä¸è¿‡ä¸æ˜¯æŒ‡å‘æŸç§ç±»å‹çš„æ•°æ®ã€‚ è€Œæ˜¯æŒ‡å‘ä»£ç æ®µä¸­æŸä¸ªå‡½æ•°çš„ç¬¬ä¸€æ¡æŒ‡ä»¤ï¼Œå¦‚å›¾æ‰€ç¤ºã€‚ Function Value åˆ†æ å‡†å¤‡ä¸€ä¸ª go æ–‡ä»¶å¹¶å†™å…¥ï¼Œç¤ºä¾‹ä»£ç å¦‚ä¸‹ï¼š 1 2 3 4 5 6 7 8 9 10 package main func main() { println(helper(nil, 0, 0)) } //go:noinline func helper(fn func(int, int) int, a, b int) int { return fn(a, b) } ä¾ç„¶æŠŠ Function Value çš„è°ƒç”¨éš”ç¦»åœ¨ä¸€ä¸ªå‡½æ•°ä¸­ï¼Œä»¥ä¾¿äºåˆ†æã€‚main.helperåç¼–è¯‘ä»£ç å¦‚ä¸‹ï¼š 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 $ go build -gcflags=\u0026#34;-N -l\u0026#34; -o ./h1 myzx.cn/helium $ go tool objdump -S -s \u0026#39;^main.helper$\u0026#39; ./h1 TEXT main.helper(SB) /mnt/hgfs/workspace/helium/main.go func helper(fn func(int, int) int, a, b int) int { 0x455240 493b6610 CMPQ 0x10(R14), SP # æ ˆå¢é•¿åˆ¤æ–­ 0x455244 7650 JBE 0x455296 0x455246 4883ec28 SUBQ $0x28, SP 0x45524a 48896c2420 MOVQ BP, 0x20(SP) 0x45524f 488d6c2420 LEAQ 0x20(SP), BP 0x455254 4889442430 MOVQ AX, 0x30(SP) # fn 0x455259 48895c2438 MOVQ BX, 0x38(SP) # a 0x45525e 48894c2440 MOVQ CX, 0x40(SP) # b 0x455263 48c744241000000000 MOVQ $0x0, 0x10(SP) # return int return fn(a, b) 0x45526c 488b442438 MOVQ 0x38(SP), AX # AX=a 0x455271 488b5c2440 MOVQ 0x40(SP), BX # BX=b 0x455276 488b542430 MOVQ 0x30(SP), DX # DX=fn # è¿™é‡Œçœ‹å‡º Function Value æ˜¯ä¸€ä¸ªäºŒçº§æŒ‡é’ˆ 0x45527b 488b0a MOVQ 0(DX), CX # CX=fn.fn 0x45527e 6690 NOPW # DX å¯„å­˜å™¨å­˜å‚¨çš„æ˜¯ fnï¼Œä¹Ÿå°±æ˜¯ä¸Šä¸‹æ–‡ # CALL CX; æŒ‡ä»¤è¯´æ˜ï¼ŒCXå¯„å­˜å™¨æœ€ç»ˆå­˜å‚¨çš„æ˜¯å®é™…å‡½æ•°çš„åœ°å€ 0x455280 ffd1 CALL CX # CALL fn.fn 0x455282 4889442418 MOVQ AX, 0x18(SP) 0x455287 4889442410 MOVQ AX, 0x10(SP) 0x45528c 488b6c2420 MOVQ 0x20(SP), BP 0x455291 4883c428 ADDQ $0x28, SP 0x455295 c3 RET func helper(fn func(int, int) int, a, b int) int { 0x455296 4889442408 MOVQ AX, 0x8(SP) 0x45529b 48895c2410 MOVQ BX, 0x10(SP) 0x4552a0 48894c2418 MOVQ CX, 0x18(SP) 0x4552a5 e8b6ccffff CALL runtime.morestack_noctxt.abi0(SB) 0x4552aa 488b442408 MOVQ 0x8(SP), AX 0x4552af 488b5c2410 MOVQ 0x10(SP), BX 0x4552b4 488b4c2418 MOVQ 0x18(SP), CX 0x4552b9 eb85 JMP main.helper(SB) é€šè¿‡ä¸Šè¿°é€»è¾‘ï¼Œå¯ä»¥ç¡®å®šFunction Valueç¡®å®æ˜¯ä¸ªæŒ‡é’ˆï¼Œè€Œä¸”æ˜¯ä¸ªä¸¤çº§æŒ‡é’ˆã€‚ å¦‚å›¾æ‰€ç¤ºï¼ŒFunction Value ä¸ç›´æ¥æŒ‡å‘ç›®æ ‡å‡½æ•°ï¼Œè€Œæ˜¯ä¸€ä¸ªç›®æ ‡å‡½æ•°çš„æŒ‡é’ˆã€‚ é—­åŒ… è¯´åˆ°Goè¯­è¨€çš„é—­åŒ…ï¼Œæ¯”è¾ƒç›´è§‚çš„æ„Ÿå—å°±æ˜¯ä¸ªæœ‰çŠ¶æ€çš„ Function Valueã€‚ åœ¨Goè¯­è¨€ä¸­æ¯”è¾ƒå…¸å‹çš„é—­åŒ…åœºæ™¯å°±æ˜¯åœ¨æŸä¸ªå‡½æ•°å†…å®šä¹‰äº†å¦ä¸€ä¸ªå‡½æ•°ï¼Œå†…å±‚å‡½æ•°ä½¿ç”¨äº†å¤–å±‚å‡½æ•°çš„å±€éƒ¨å˜é‡ï¼Œå¹¶ä¸”å†…å±‚å‡½æ•°æœ€ç»ˆè¢«å¤–å±‚å‡½æ•°ä½œä¸ºè¿”å›å€¼è¿”å›ã€‚ ä»£ç å¦‚ä¸‹ï¼š 1 2 3 4 5 func mc(n int) func() int { return func() int { return n } } æ¯æ¬¡è°ƒç”¨ mc() å‡½æ•°éƒ½ä¼šè¿”å›ä¸€ä¸ªæ–°çš„é—­åŒ…ï¼Œé—­åŒ…è®°ä½äº†å‚æ•°çš„å€¼ï¼Œæ‰€ä»¥æ˜¯æœ‰çŠ¶æ€çš„ã€‚ åŸºäºç›®å‰å¯¹å‡½æ•°æ ˆå¸§çš„äº†è§£ï¼Œå‡½æ•°æ ˆå¸§éšç€å‡½æ•°è¿”å›è€Œé”€æ¯ï¼Œä¸èƒ½ç”¨æ¥ä¿å­˜çŠ¶æ€ã€‚ ç ”ç©¶å‡½æ•°æŒ‡é’ˆå’Œ Function Value çš„æ—¶å€™ä¹Ÿæ²¡æœ‰å‘ç°å“ªé‡Œç”¨æ¥ä¿å­˜çŠ¶æ€ï¼Œæ‰€ä»¥è¿™é‡Œå°±æœ‰ä¸ªé—®é¢˜ï¼Œé—­åŒ…çš„çŠ¶æ€ä¿å­˜åœ¨å“ªé‡Œå‘¢ï¼Ÿ é—­åŒ…å¯¹è±¡ ä¸ºäº†æ‘˜æ¸…æ¥šè¿™ä¸ªé—®é¢˜ï¼Œå…ˆæ¥å°è¯•ä¸€ä¸‹åç¼–è¯‘ï¼Œä»æ±‡ç¼–ä»£ç ä¸­æ‰¾ç­”æ¡ˆï¼Œmain.mcåç¼–è¯‘ä»£ç å¦‚ä¸‹ï¼š 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 $ go build -gcflags=\u0026#34;-N -l\u0026#34; -o ./h1 myzx.cn/helium $ go tool objdump -S -s \u0026#39;^main.mc$\u0026#39; ./h1 TEXT main.mc(SB) /mnt/hgfs/workspace/helium/main.go func mc(n int) func() int { 0x455220 493b6610 CMPQ 0x10(R14), SP # æ ˆå¢é•¿åˆ¤æ–­ 0x455224 765b JBE 0x455281 0x455226 4883ec28 SUBQ $0x28, SP 0x45522a 48896c2420 MOVQ BP, 0x20(SP) 0x45522f 488d6c2420 LEAQ 0x20(SP), BP # å‚æ•°æ ˆç©ºé—´åˆ†é… 0x455234 4889442430 MOVQ AX, 0x30(SP) # n # è¿”å›å€¼æ ˆç©ºé—´åˆ†é… 0x455239 48c744241000000000 MOVQ $0x0, 0x10(SP) # return func() int return func() int { # 0x7497(IP) æ˜¯ Function Value çš„ç»“æ„å…ƒç±»å‹ # type funcval struct {fn unsafe.Pointer, n int} 0x455242 488d0597740000 LEAQ 0x7497(IP), AX # Function Value ç»“æ„çš„å…ƒç±»å‹ # åˆ›å»º funcval ç»“æ„éœ€è¦çš„å†…å­˜ç©ºé—´ï¼Œæ˜¯å †åˆ†é… 0x455249 e8f25cfbff CALL runtime.newobject(SB) # AX=\u0026amp;funcval 0x45524e 4889442418 MOVQ AX, 0x18(SP) # è¿™é‡Œmain.mc.func1(SB)æ˜¯mcè¿”å›çš„é—­åŒ…åœ¨ä»£ç æ®µçš„åœ°å€ 0x455253 488d0d46000000 LEAQ main.mc.func1(SB), CX # CX=main.mc.func1(SB) 0x45525a 488908 MOVQ CX, 0(AX) # funcval.fn=main.mc.func1(SB) 0x45525d 488b4c2418 MOVQ 0x18(SP), CX 0x455262 8401 TESTB AL, 0(CX) 0x455264 488b542430 MOVQ 0x30(SP), DX # DX=n # å¯ä»¥çœ‹å‡ºè¿™é‡Œæ•è·äº†å˜é‡nï¼Œå¹¶ä¸”æ˜¯æ‹·è´æ•è· 0x455269 48895108 MOVQ DX, 0x8(CX) # funcval.n = n 0x45526d 488b442418 MOVQ 0x18(SP), AX # AX=\u0026amp;funcval 0x455272 4889442410 MOVQ AX, 0x10(SP) 0x455277 488b6c2420 MOVQ 0x20(SP), BP 0x45527c 4883c428 ADDQ $0x28, SP 0x455280 c3 RET func mc(n int) func() int { 0x455281 4889442408 MOVQ AX, 0x8(SP) 0x455286 e8d5ccffff CALL runtime.morestack_noctxt.abi0(SB) 0x45528b 488b442408 MOVQ 0x8(SP), AX 0x455290 eb8e JMP main.mc(SB) æ ¹æ®ä¸Šé¢ä»£ç å¯ä»¥æ¨æ–­å‡ºFunction ValueåŠ¨æ€åˆ†é…çš„å¯¹è±¡çš„ç±»å‹ã€‚ åº”è¯¥æ˜¯ä¸€ä¸ª struct ç±»å‹ï¼Œç¬¬1ä¸ªå­—æ®µæ˜¯å‡½æ•°åœ°å€ï¼Œç¬¬2ä¸ªå­—æ®µæ˜¯ int ç±»å‹ï¼Œä»£ç å¦‚ä¸‹ï¼š 1 2 3 4 struct { F uintptr n int } è¯´æ˜ç¼–è¯‘å™¨è¯†åˆ«å‡ºäº†é—­åŒ…è¿™ç§ä»£ç æ¨¡å¼ï¼Œå¹¶ä¸”è‡ªåŠ¨å®šä¹‰äº†è¿™ä¸ª struct ç±»å‹è¿›è¡Œæ”¯æŒï¼Œå‡ºäºé¢å‘å¯¹è±¡ç¼–ç¨‹ä¸­æŠŠæ•°æ®ç§°ä¸ºå¯¹è±¡çš„ä¹ æƒ¯ï¼Œåæ–‡ä¸­å°±æŠŠè¿™ç§ struct ç§°ä¸ºé—­åŒ…å¯¹è±¡ã€‚ é—­åŒ…å¯¹è±¡çš„æˆå‘˜å¯ä»¥è¿›ä¸€æ­¥åˆ’åˆ†ï¼Œç¬¬1ä¸ªå­—æ®µFç”¨æ¥å­˜å‚¨ç›®æ ‡å‡½æ•°çš„åœ°å€ï¼Œè¿™åœ¨æ‰€æœ‰çš„é—­åŒ…å¯¹è±¡ä¸­éƒ½æ˜¯ä¸€è‡´çš„ï¼Œåæ–‡ä¸­å°†è¿™ä¸ªç›®æ ‡å‡½æ•°ç§°ä¸ºé—­åŒ…å‡½æ•°ã€‚ ä»ç¬¬2ä¸ªå­—æ®µå¼€å§‹ï¼Œåç»­çš„å­—æ®µç§°ä¸ºé—­åŒ…çš„æ•è·åˆ—è¡¨ï¼Œä¹Ÿå°±æ˜¯å†…å±‚å‡½æ•°ä¸­ç”¨åˆ°çš„æ‰€æœ‰å®šä¹‰åœ¨å¤–å±‚å‡½æ•°ä¸­çš„å˜é‡ã€‚ ç¼–è¯‘å™¨è®¤ä¸ºè¿™äº›å˜é‡è¢«é—­åŒ…æ•è·äº†ï¼Œä¼šæŠŠå®ƒä»¬è¿½åŠ åˆ°é—­åŒ…å¯¹è±¡çš„ struct å®šä¹‰ä¸­ã€‚ ä¸Šä¾‹ä¸­åªæ•è·äº†ä¸€ä¸ªå˜é‡ nï¼Œå¦‚æœæ•è·çš„å˜é‡å¢å¤šï¼Œstruct çš„æ•è·åˆ—è¡¨ä¹Ÿä¼šåŠ é•¿ã€‚ ä¸€ä¸ªæ•è·ä¸¤ä¸ªå˜é‡çš„é—­åŒ…ç¤ºä¾‹ä»£ç å¦‚ä¸‹ï¼š 1 2 3 4 5 func mc(n, m int) func() (int, int) { return func() (int, int) { return n, m } } ä¸Šè¿°ä»£ç å¯¹åº”çš„é—­åŒ…å¯¹è±¡å®šä¹‰ä»£ç å¦‚ä¸‹ï¼š 1 2 3 4 5 struct { F uintptr n int m int } çœ‹åˆ°é—­åŒ… é€šè¿‡åç¼–è¯‘æ¥é€†å‘æ¨æ–­é—­åŒ…å¯¹è±¡çš„ç»“æ„è¿˜æ˜¯æ¯”è¾ƒçƒ¦ççš„ï¼Œå¦‚æœèƒ½æœ‰ä¸€ç§æ–¹æ³•ï¼Œèƒ½å¤Ÿç›´è§‚çœ‹åˆ°é—­åŒ…å¯¹è±¡çš„ç»“æ„å®šä¹‰ï¼Œé‚£çœŸæ˜¯å†å¥½ä¸è¿‡äº†ã€‚ æ ¹æ®ä¹‹å‰çš„æ¢ç´¢ï¼Œå·²ç»çŸ¥é“ Go åºåœ¨è¿è¡Œé˜¶æ®µä¼šé€šè¿‡ runtime.newobject() å‡½æ•°åŠ¨æ€åŒ¹é…é—­åŒ…å¯¹è±¡ã€‚ Go æºç ä¸­ newobject() å‡½æ•°çš„åŸå‹å¦‚ä¸‹ï¼š func newobject(typ *_type) unsafe.Pointer å‡½æ•°çš„è¿”å›å€¼æ˜¯ä¸ªæŒ‡é’ˆï¼Œä¹Ÿå°±æ˜¯æ–°åˆ†é…çš„å¯¹è±¡çš„åœ°å€ï¼Œå‚æ•°æ˜¯ä¸ª _type ç±»å‹çš„æŒ‡é’ˆã€‚ é€šè¿‡æºç å¯ä»¥å¾—çŸ¥è¿™ä¸ª _type æ˜¯ä¸ª structï¼Œåœ¨ Go è¯­è¨€çš„ runtime åŒ…ä¸­è¢«ç”¨æ¥æè¿°ä¸€ä¸ªæ•°æ®ç±»å‹ï¼Œé€šè¿‡å®ƒå¯ä»¥æ‰¾åˆ°ç›®æ ‡æ•°æ®ç±»å‹çš„å¤§å°ï¼Œå¯¹é½è¾¹ç•Œï¼Œç±»å‹åç§°ç­‰ã€‚ å‡å¦‚èƒ½å¤Ÿè·å¾—ä¼ é€’ç»™ runtime.newobjet() å‡½æ•°çš„ç±»å‹å…ƒæ•°æ®æŒ‡é’ˆ typï¼Œå†é€šè¿‡åå°„è¿›è¡Œè§£æï¼Œå°±èƒ½æ‰“å°å‡ºé—­åŒ…å¯¹è±¡çš„ç»“æ„å®šä¹‰äº†ã€‚é‚£å¦‚ä½•æ‰èƒ½è·å¾—è¿™ä¸ª typ å‚æ•°å‘¢ï¼Ÿ åœ¨Cè¯­è¨€ä¸­æœ‰ç§å¸¸ç”¨çš„å‡½æ•° Hook æŠ€æœ¯ï¼Œå°±æ˜¯åœ¨è¿è¡Œé˜¶æ®µå°†ç›®æ ‡å‡½æ•°å¤´éƒ¨çš„ä»£ç æ›¿æ¢ä¸ºä¸€æ¡è·³è½¬æŒ‡ä»¤ï¼Œè·³è½¬åˆ°ä¸€ä¸ªæ–°çš„å‡½æ•°ã€‚ åœ¨ x86 å¹³å°ä¸Šå°±æ˜¯åœ¨è¿›ç¨‹åœ°å€ç©ºé—´ä¸­æ‰¾åˆ°è¦ Hook çš„å‡½æ•°ï¼Œå°†å…¶å¤´éƒ¨æ›¿æ¢ä¸ºä¸€æ¡ JMP æŒ‡ä»¤ï¼ŒåŒæ—¶æŒ‡å®š JMP æŒ‡ä»¤è¦è·³è½¬åˆ°çš„æ–°å‡½æ•°çš„åœ°å€ã€‚ è¿™é¡¹æŠ€æœ¯åœ¨ Go ç¨‹åºä¸­ä¾ç„¶é€‚ç”¨ï¼Œå¯ä»¥ç”¨ä¸€ä¸ªè‡ªå·±å®ç°çš„å‡½æ•°æ¢æ‰ runtime.newobject() å‡½æ•°ï¼Œåœ¨è¿™ä¸ªå‡½æ•°ä¸­å°±èƒ½è·å¾— typ å‚æ•°å¹¶è¿›è¡Œè§£æäº†ã€‚ è¿˜æœ‰ä¸€ä¸ªé—®é¢˜æ˜¯ runtime.newobiect() å‡½æ•°å±äºæœªå¯¼å‡ºçš„å‡½æ•°ï¼Œåœ¨runtimeåŒ…å¤–æ— æ³•è®¿é—®ã€‚ è¿™ä¸€ç‚¹å¯ä»¥é€šè¿‡ linkname æœºåˆ¶æ¥ç»•è¿‡ï¼Œåœ¨å½“å‰åŒ…ä¸­å£°æ˜ä¸€ä¸ªç±»ä¼¼çš„å‡½æ•°ï¼Œè®©é“¾æ¥å™¨å°†å…¶é“¾æ¥åˆ°runtime.newobject()å‡½æ•°å³å¯ã€‚ æœ¬ä¹¦ä½¿ç”¨å¼€æºæ¨¡å— github.com/fengyoulin/hookingo å®ç°è¿è¡Œé˜¶æ®µå‡½æ•°æ›¿æ¢ï¼Œæ‰“å°é—­åŒ…å¯¹è±¡ç»“æ„çš„å®Œæ•´ä»£ç å¦‚ä¸‹ï¼š 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 package main import ( \u0026#34;github.com/fengyoulin/hookingo\u0026#34; \u0026#34;reflect\u0026#34; \u0026#34;unsafe\u0026#34; ) var hno hookingo.Hook //go:linkname newobject runtime.newobject func newobject(typ unsafe.Pointer) unsafe.Pointer //go:linkname newobject2 runtime.mallocgc func newobject2(size uintptr, typ unsafe.Pointer, b bool) unsafe.Pointer func fno(typ unsafe.Pointer) unsafe.Pointer { t := reflect.TypeOf(0) // type Type interface{} // è¿™é‡Œä¸ºä»€ä¹ˆèµ‹å€¼çš„æ˜¯ä¸‹æ ‡1ï¼Ÿæ¥ä¸‹æ¥æˆ‘ä»¬åˆ†æä¸ºä»€ä¹ˆæ˜¯1è€Œä¸æ˜¯0ä¸‹æ ‡ã€‚ // æ ¹æ®åé¢åˆ†æç¡®å®æ˜¯ä¿®æ”¹ä¸‹æ ‡1ï¼Œå› ä¸ºt.String()éœ€è¦ç”¨åˆ°1è¿™ä¸ªä¸‹æ ‡çš„æ•°æ®ã€‚ (*(*[2]unsafe.Pointer)(unsafe.Pointer(\u0026amp;t)))[1] = typ // ç›¸å½“äºåå°„äº†é—­åŒ…ç±»å‹ println(t.String()) //fn, ok := hno.Origin().(func(typ unsafe.Pointer) unsafe.Pointer) //if ok { // return fn(typ) // è°ƒç”¨åŸruntime.newobject //} //println(\u0026#34;ok\u0026#34;, ok) //os.Exit(1) println(*(*uintptr)(unsafe.Pointer(typ))) return newobject2(*(*uintptr)(typ), typ, true) } // åˆ›å»ºä¸€ä¸ªé—­åŒ…ï¼Œmake closure func mc(start int, text string) func() string { // è¿™é‡Œ start éœ€è¦å †åˆ†é… // func() string ä¹Ÿéœ€è¦å †åˆ†é… return func() string { l := len(text) s := start % l r := text[s:] start++ return r } } func main() { var err error hno, err = hookingo.Apply(newobject, fno) // åº”ç”¨é’©å­ï¼Œæ›¿æ¢å‡½æ•° if err != nil { panic(err) } f := mc(10, \u0026#34;hello, closure!\u0026#34;) println(f()) } $ C:\\Users\\Helium\\go\\bin\\go1.17.exe run -gcflags -l . # go1.17 ç‰ˆæœ¬ int # æ‰“å°çš„æ˜¯mcçš„startå †åˆ†é… 8 # int å ç”¨å†…å­˜å¤§å° struct { F uintptr; text string; start *int } 32 sure! $ go run -gcflags -l . # go1.20.3ç‰ˆæœ¬ int 8 struct { F uintptr; text string; start *int } 32 sure! å› ä¸ºstartä¼šè¢«ä¿®æ”¹ï¼Œæ‰€ä»¥æ•è·åœ°å€é€ æˆå †åˆ†é…ï¼Œå› æ­¤ç»“æœç¬¬ä¸€è¡Œæ‰“å°äº†ä¸€ä¸ªintã€‚ ç¬¬äºŒè¡Œçš„structå°±æ˜¯é—­åŒ…ç»“æ„çš„ç±»å‹ï¼Œè¿™æ˜¯é€šè¿‡ç±»å‹å…ƒæ•°æ®ç›´æ¥è·å–åˆ°çš„ï¼Œæ˜¯ç”±ç¼–è¯‘å™¨æ„é€ çš„ç»“æ„ç±»å‹ã€‚ æˆ‘ä»¬æŠ„éƒ¨åˆ†fno()å‡½æ•°çš„ç›¸å…³ä»£ç ï¼štyp unsafe.Pointerï¼šæ¥è‡ªç±»å‹çš„*_typeç±»å‹æ•°æ®ã€‚ 1 2 3 4 5 6 7 func fno(typ unsafe.Pointer) unsafe.Pointer { t := reflect.TypeOf(0) // type Type interface{} // è¿™é‡Œä¸ºä»€ä¹ˆèµ‹å€¼çš„æ˜¯ä¸‹æ ‡1ï¼Ÿæ¥ä¸‹æ¥æˆ‘ä»¬åˆ†æä¸ºä»€ä¹ˆæ˜¯1è€Œä¸æ˜¯0ä¸‹æ ‡ã€‚ (*(*[2]unsafe.Pointer)(unsafe.Pointer(\u0026amp;t)))[1] = typ // ç›¸å½“äºåå°„äº†é—­åŒ…ç±»å‹ println(t.String()) // ... ... } åˆ†æreflect.TypeOf()å‡½æ•°å¦‚ä¸‹ï¼š 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 // TypeOf returns the reflection Type that represents the dynamic type of i. // If i is a nil interface value, TypeOf returns nil. func TypeOf(i any) Type { // emptyInterface æ˜¯ç©ºæ¥å£çš„å†…å­˜ç»“æ„ eface := *(*emptyInterface)(unsafe.Pointer(\u0026amp;i)) // eface.typ è¿™é‡Œç›´æ¥å–äº† typ å­—æ®µï¼Œæ²¡æœ‰è¦wordå­—æ®µ // é€šè¿‡åˆ†ætoType()å‡½æ•°å¯çŸ¥ï¼ŒæŠŠeface.typæ”¾å…¥äº†éç©ºæ¥å£Typeä¸­ã€‚ // å› æ­¤å¿…é¡»è¦åˆ†æéç©ºæ¥å£ä¸­å­˜å‚¨çš„æ˜¯ä»€ä¹ˆï¼Ÿéç©ºæ¥å£å†…å­˜å¸ƒå±€ // type iface struct { // tab *itab // ç±»å‹å…ƒæ•°æ® // data *unsafe.Pointer // è£…ç®±çš„æ•°æ® // } // å› æ­¤ tab *itab è£…è½½çš„æ˜¯ *rtype ç±»å‹ç»“æ„ï¼Œä¹Ÿå°±æ˜¯ç»“æ„ä½“æŒ‡é’ˆ // æŒ‰ç…§ä¼ å…¥å‚æ•°0è¿™é‡Œå¯ä»¥çœ‹å‡ºåº”è¯¥æ˜¯intçš„å…ƒç±»å‹ // é‡è¦çš„æ˜¯ dataï¼Œè¿™å­˜å‚¨çš„æ˜¯ *rtype è¿™ä¸ªæŒ‡é’ˆæ•°æ®ï¼Œç±»å‹åå°„å°±æ˜¯ä¾é è¿™ä¸ªdataã€‚ // å› ä¸ºæˆ‘ä»¬è°ƒç”¨Typeéç©ºæ¥å£çš„æ‰€æœ‰æ–¹æ³•æ¥æ”¶å™¨çš„å‚æ•°éƒ½æ˜¯ *rtypeï¼Œè¿™ä¹Ÿå°±æ˜¯ä¸ºä»€ä¹ˆä¿®æ”¹ä¸‹æ ‡1çš„åŸå› ã€‚ // æˆ‘ä»¬åœ¨è°ƒç”¨t.String()æ–¹æ³•æ—¶ï¼Œéœ€è¦çš„æ—¶dataè¿™ä¸ªæ˜¯æˆ‘ä»¬æƒ³è¦çš„ç±»å‹å³å¯ã€‚ return toType(eface.typ) } // emptyInterface is the header for an interface{} value. type emptyInterface struct { typ *rtype // å­˜å‚¨ç€ç±»å‹ç»“æ„ word unsafe.Pointer } åˆ†ætoType()å‡½æ•°å¦‚ä¸‹ï¼š 1 2 3 4 5 6 7 8 9 10 11 // toType converts from a *rtype to a Type that can be returned // to the client of package reflect. In gc, the only concern is that // a nil *rtype must be replaced by a nil Type, but in gccgo this // function takes care of ensuring that multiple *rtype for the same // type are coalesced into a single Type. func toType(t *rtype) Type { if t == nil { return nil } return t } è°ƒç”¨é—­åŒ… é—­åŒ…å‡½æ•°åœ¨è¢«è°ƒç”¨çš„æ—¶å€™ï¼Œå¿…é¡»å¾—åˆ°å½“å‰é—­åŒ…å¯¹è±¡çš„åœ°å€æ‰èƒ½è®¿é—®å…¶ä¸­çš„æ•è·åˆ—è¡¨ï¼Œè¿™ä¸ªåœ°å€æ˜¯å¦‚ä½•ä¼ é€’çš„å‘¢ï¼Ÿ è°ƒç”¨è€…åœ¨è°ƒç”¨ Function Value çš„æ—¶å€™åªæ˜¯åƒè°ƒç”¨ä¸€ä¸ªæ™®é€šå‡½æ•°é‚£æ ·ä¼ é€’äº†å£°æ˜çš„å‚æ•°ï¼Œå¦‚æœ Function Value èƒŒåæ˜¯ä¸ªé—­åŒ…å‡½æ•°ï¼Œåˆ™æ— æ³•é€šè¿‡æ ˆä¸Šçš„å‚æ•°å¾—åˆ°é—­åŒ…å¯¹è±¡åœ°å€ã€‚ é™¤éç¼–è¯‘å™¨ä¼ é€’äº†ä¸€ä¸ªéšå«çš„å‚æ•°ï¼Œè¿™ä¸ªå‚æ•°å¦‚æœé€šè¿‡æ ˆä¼ é€’ï¼Œé‚£å°±æ”¹å˜äº†å‡½æ•°çš„åŸå‹ï¼Œè¿™æ ·å°±ä¼šé€ æˆä¸ä¸€è‡´ï¼Œæ˜¯è¡Œä¸é€šçš„ã€‚ è¿˜æ˜¯é€šè¿‡åæ±‡ç¼–æ¥çœ‹ä¸€ä¸‹é—­åŒ…å‡½æ•°æ˜¯ä»å“ªé‡Œå¾—åˆ°çš„è¿™ä¸ªåœ°å€ï¼Œå…ˆæ¥æ„é€ é—­åŒ…ï¼Œä»£ç å¦‚ä¸‹ï¼š 1 2 3 4 5 func mc(n int) func int { return func() int { return n } } æ ¹æ®å‰é¢çš„æ¢ç´¢ï¼Œå¯ä»¥ç¡®å®šé—­åŒ…å¯¹è±¡çš„ç»“æ„å®šä¹‰ä»£ç å¦‚ä¸‹ï¼š 1 2 3 4 struct { F uintptr n int } åç¼–è¯‘é—­åŒ…å‡½æ•°å¾—åˆ°çš„æ±‡ç¼–ä»£ç å¦‚ä¸‹ï¼š ç¬¬7è¡Œï¼Œå°† DX å¯„å­˜å™¨ç”¨ä½œåŸºå€,å†åŠ ä¸Šä½ç§» 8ï¼ŒæŠŠè¯¥åœ°å€å¤„çš„å€¼å¤åˆ¶åˆ° CX å¯„å­˜å™¨ä¸­ã€‚ ç¬¬8è¡Œï¼ŒæŠŠ CX å¯„å­˜å™¨å€¼å¤åˆ¶ç»™é—­åŒ…å‡½æ•°çš„è¿”å›å€¼ã€‚ ç¬¬11è¡Œï¼ŒæŠŠè¿”å›å€¼æ”¾å…¥AXå¯„å­˜å™¨ä¸­ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 $ go tool objdump -S -s \u0026#39;^main.mc.func1$\u0026#39; ./h1 TEXT main.mc.func1(SB) /mnt/hgfs/workspace/helium/main.go return func() int { 0x4552a0 4883ec18 SUBQ $0x18, SP 0x4552a4 48896c2410 MOVQ BP, 0x10(SP) 0x4552a9 488d6c2410 LEAQ 0x10(SP), BP 0x4552ae 488b4a08 MOVQ 0x8(DX), CX # CX=0x8(DX) 0x4552b2 48894c2408 MOVQ CX, 0x8(SP) 0x4552b7 48c7042400000000 MOVQ $0x0, 0(SP) return n 0x4552bf 488b442408 MOVQ 0x8(SP), AX # AX=0x8(DX) 0x4552c4 48890424 MOVQ AX, 0(SP) 0x4552c8 488b6c2410 MOVQ 0x10(SP), BP 0x4552cd 4883c418 ADDQ $0x18, SP 0x4552d1 c3 RET æ˜¾ç„¶ï¼ŒDXå¯„å­˜å™¨å­˜å‚¨çš„å°±æ˜¯é—­åŒ…å¯¹è±¡çš„åœ°å€ï¼Œè°ƒç”¨è€…è´Ÿè´£åœ¨è°ƒç”¨ä¹‹å‰æŠŠé—­åŒ…å¯¹è±¡çš„åœ°å€å­˜å‚¨åˆ° DX å¯„å­˜å™¨ä¸­ï¼Œè·Ÿ C++ ä¸­çš„ thiscalléå¸¸ç±»ä¼¼ã€‚ ä¹‹å‰æœ‰å¾ˆå¤šè¯»è€…åœ¨åç¼–è¯‘ Function Value è°ƒç”¨ä»£ç æ—¶ï¼Œæ€»ä¼šçœ‹åˆ°ä¸º DX å¯„å­˜å™¨èµ‹å€¼ï¼Œå¹¶ä¸ºæ­¤æ„Ÿåˆ°ç–‘æƒ‘ï¼Œè¿™å°±æ˜¯åŸå› ã€‚ è°ƒç”¨è€…ä¸å¿…åŒºåˆ†æ˜¯ä¸æ˜¯é—­åŒ…ã€æœ‰æ²¡æœ‰æ•è·åˆ—è¡¨ï¼Œå®é™…ä¸Šä¹ŸåŒºåˆ†ä¸äº†ï¼Œåªèƒ½ç»Ÿä¸€ä½œä¸ºé—­åŒ…æ¥å¤„ç†ï¼Œæ‰€ä»¥æ€»è¦é€šè¿‡ DX ä¼ é€’åœ°å€ã€‚ å¦‚æœ Function Value èƒŒåä¸æ˜¯é—­åŒ…ï¼Œè¿™ä¸ªåœ°å€å°±ä¸ä¼šè¢«ç”¨åˆ°ï¼Œä¹Ÿä¸ä¼šé€ æˆä»€ä¹ˆå½±å“ã€‚ é—­åŒ…ä¸å˜é‡é€ƒé€¸ å˜é‡é€ƒé€¸è·Ÿé—­åŒ…ä¹‹é—´çš„å…³ç³»å¾ˆå¯†åˆ‡ï¼Œå› ä¸º Function Value æœ¬èº«å°±æ˜¯ä¸ªæŒ‡é’ˆï¼Œç¼–è¯‘å™¨ä¹Ÿå¯ä»¥æŒ‰ç…§åŒæ ·çš„æ–¹å¼æ¥åˆ†æ Function Value æœ‰æ²¡æœ‰é€ƒé€¸ã€‚ å¦‚æœ Function Value æ²¡æœ‰é€ƒé€¸é‚£å°±å¯ä»¥ä¸ç”¨åœ¨å †ä¸Šåˆ†é…é—­åŒ…å¯¹è±¡äº†ï¼Œåˆ†é…åœ¨æ ˆä¸Šå³å¯ã€‚ ä½¿ç”¨ä¸€ä¸ªç¤ºä¾‹è¿›è¡ŒéªŒè¯ï¼Œä»£ç å¦‚ä¸‹ï¼š 1 2 3 4 5 6 func sc(n int) int { f := func() int { return n } return f() } ä»£ç é€»è¾‘è¿‡äºç®€å•ï¼Œä¸ºäº†é¿å…é—­åŒ…å‡½æ•°è¢«ç¼–è¯‘å™¨ä¼˜åŒ–æ‰ï¼Œç¼–è¯‘æ—¶éœ€è¦ç¦ç”¨å†…è”ä¼˜åŒ–ï¼Œå‘½ä»¤å¦‚ä¸‹ï¼š$ go build -gcflags='-l'ã€‚ å†æ¥åç¼–è¯‘ sc() å‡½æ•°ï¼Œmain.scåç¼–è¯‘å‘½ä»¤åŠè¾“å‡ºç»“æœå¦‚ä¸‹ï¼š 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 $ go build -gcflags=\u0026#34;-l -N\u0026#34; -o ./h1 myzx.cn/helium $ go tool objdump -S -s \u0026#39;^main.sc$\u0026#39; ./h1 TEXT main.sc(SB) /mnt/hgfs/workspace/helium/main.go func sc(n int) int { 0x455220 493b6610 CMPQ 0x10(R14), SP 0x455224 7664 JBE 0x45528a 0x455226 4883ec38 SUBQ $0x38, SP 0x45522a 48896c2430 MOVQ BP, 0x30(SP) 0x45522f 488d6c2430 LEAQ 0x30(SP), BP 0x455234 4889442440 MOVQ AX, 0x40(SP) # åˆ†é…å‚æ•°ç©ºé—´ 0x455239 48c7042400000000 MOVQ $0x0, 0(SP) # åˆ†é…è¿”å›å€¼ç©ºé—´ f := func() int { 0x455241 440f117c2410 MOVUPS X15, 0x10(SP) 0x455247 488d542410 LEAQ 0x10(SP), DX # \u0026amp;funcval 0x45524c 4889542428 MOVQ DX, 0x28(SP) 0x455251 8402 TESTB AL, 0(DX) 0x455253 488d0546000000 LEAQ main.sc.func1(SB), AX 0x45525a 4889442410 MOVQ AX, 0x10(SP) # funcval.fn 0x10(SP) 0x45525f 8402 TESTB AL, 0(DX) 0x455261 488b442440 MOVQ 0x40(SP), AX # å‚æ•°nçš„å€¼ 0 0x455266 4889442418 MOVQ AX, 0x18(SP) # funcval.data 0x18(SP) 0 0x45526b 4889542420 MOVQ DX, 0x20(SP) return f() 0x455270 488b442410 MOVQ 0x10(SP), AX 0x455275 ffd0 CALL AX 0x455277 4889442408 MOVQ AX, 0x8(SP) 0x45527c 48890424 MOVQ AX, 0(SP) 0x455280 488b6c2430 MOVQ 0x30(SP), BP 0x455285 4883c438 ADDQ $0x38, SP 0x455289 c3 RET func sc(n int) int { 0x45528a 4889442408 MOVQ AX, 0x8(SP) 0x45528f e8ccccffff CALL runtime.morestack_noctxt.abi0(SB) 0x455294 488b442408 MOVQ 0x8(SP), AX 0x455299 eb85 JMP main.sc(SB) å‡½æ•° åœ¨Goè¯­è¨€ä¸­å‡½æ•°å±äºå¤´ç­‰å¯¹è±¡ï¼Œå¯ä»¥è¢«å½“ä½œå‚æ•°ä¼ é€’ã€ä¹Ÿå¯ä»¥ä½œä¸ºå‡½æ•°è¿”å›å€¼ã€ç»‘å®šåˆ°å˜é‡ã€‚ Goè¯­è¨€ç§°è¿™æ ·çš„å‚æ•°ã€è¿”å›å€¼å’Œå˜é‡ä¸ºFunction Valueã€‚ Function Valueæœ¬è´¨ä¸Šæ˜¯ä¸€ä¸ªæŒ‡é’ˆï¼Œå´ä¸ç›´æ¥æŒ‡å‘å‡½æ•°æŒ‡ä»¤å…¥å£ï¼Œè€Œæ˜¯æŒ‡å‘runtime.funcvalç»“æ„ä½“ï¼Œå‡½æ•°å˜é‡å­˜å‚¨çš„æ˜¯*funcvalç±»å‹ï¼Œä¹Ÿå°±æ˜¯funcvalç»“æ„ä½“çš„åœ°å€ã€‚ 1 2 3 4 5 6 7 8 9 10 11 // é—­åŒ…æ˜¯å‡½æ•°ç±»å‹funcType // é—­åŒ…æ•è·çš„å˜é‡ï¼Œç³»ç»Ÿç»´æŠ¤ç€ä¸€ä¸ªå…³ç³»åˆ—è¡¨ï¼Œæ ¹æ®è¿™ä¸ªåˆ—è¡¨èƒ½æ­£ç¡®çš„æ‰¾åˆ°æ•è·çš„å˜é‡ç±»å‹å¤§å°ç­‰ä¿¡æ¯ type funcval struct { fn uintptr // æŒ‡å‘ç¨‹åºçš„ä»£ç æ®µ // variable-size, fn-specific data here } // ç´§æ¥ç€funcvalç»“æ„ä½“åé¢å†…å­˜åœ°å€æ˜¯æ•è·çš„çš„å˜é‡åˆ—è¡¨ // æ³¨æ„æ•è·çš„æ˜¯å˜é‡çš„åœ°å€ï¼Œä½¿ç”¨çš„å´æ˜¯å˜é‡çš„å€¼ // é—­åŒ…ä¸­æ•è·çš„å¦‚æœæ˜¯æŒ‡é’ˆç±»å‹é‚£ä¹ˆæ˜¯å¼•ç”¨ï¼Œæ˜¯æ™®é€šç±»å‹é‚£ä¹ˆæ˜¯æ‹·è´ // f -\u0026gt; *funcval è¿™ä¸ªç»“æ„ä½“ä»å®šä¹‰ä¸Šçœ‹åªæœ‰ä¸€ä¸ªåœ°å€ï¼Œè¿™ä¸ªåœ°å€æ‰æ˜¯å‡½æ•°çš„æŒ‡ä»¤å…¥å£ã€‚ä¸€ä¸ªFunction Valueæ˜¯ä»¥ä¸‹å›¾æ‰€ç¤ºå½¢å¼å­˜åœ¨çš„ã€‚ é—­åŒ… Closureï¼šç»´åŸºç™¾ç§‘ é—­åŒ…åœ¨å®ç°ä¸Šæ˜¯ä¸€ä¸ªç»“æ„ä½“ï¼Œå®ƒå­˜å‚¨äº†ä¸€ä¸ªå‡½æ•°ï¼ˆé€šå¸¸æ˜¯å…¶å…¥å£åœ°å€ï¼‰å’Œä¸€ä¸ªå…³è”çš„ç¯å¢ƒï¼ˆç›¸å½“äºä¸€ä¸ªç¬¦å·æŸ¥æ‰¾è¡¨ï¼‰ã€‚ ç¯å¢ƒé‡Œæ˜¯è‹¥å¹²å¯¹ç¬¦å·å’Œå€¼çš„å¯¹åº”å…³ç³»ï¼Œå®ƒæ—¢è¦åŒ…æ‹¬çº¦æŸå˜é‡ï¼ˆè¯¥å‡½æ•°å†…éƒ¨ç»‘å®šçš„ç¬¦å·ï¼‰ï¼Œä¹Ÿè¦åŒ…æ‹¬è‡ªç”±å˜é‡ï¼ˆåœ¨å‡½æ•°å¤–éƒ¨å®šä¹‰ä½†åœ¨å‡½æ•°å†…è¢«å¼•ç”¨ï¼‰ï¼Œæœ‰äº›å‡½æ•°ä¹Ÿå¯èƒ½æ²¡æœ‰è‡ªç”±å˜é‡ã€‚ é—­åŒ…è·Ÿå‡½æ•°æœ€å¤§çš„ä¸åŒåœ¨äºï¼Œå½“æ•æ‰é—­åŒ…çš„æ—¶å€™ï¼Œå®ƒçš„è‡ªç”±å˜é‡ä¼šåœ¨æ•æ‰æ—¶è¢«ç¡®å®šï¼Œè¿™æ ·å³ä¾¿è„±ç¦»äº†æ•æ‰æ—¶çš„ä¸Šä¸‹æ–‡ï¼Œå®ƒä¹Ÿèƒ½ç…§å¸¸è¿è¡Œã€‚ æ‰€ä»¥åƒä¸‹é¢è¿™ä¸ªä¾‹å­ï¼š 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 func create() func(){ c := 2 // cä¼šè¢«åˆ†é…åœ¨æ ˆä¸Šï¼Œä»¥æ‹·è´å½¢å¼è¢«æ•è· return func(){ // ã€ç”±äºcå˜é‡åé¢æ²¡æœ‰å˜åŒ–ï¼Œæ‰€ä»¥è¿™é‡Œæ•è·å˜æˆæ‹·è´cçš„å€¼2å°±è¡Œï¼Œä¸éœ€è¦æ•è·cçš„åœ°å€ã€‘ fmt.Println(c) } } func main(){ // f1 { // fn ---\u0026gt; é—­åŒ…å‡½æ•°åœ°å€ // 2 ---\u0026gt; æ‹·è´cçš„å€¼å³å¯ï¼ˆä¸éœ€è¦æ•è·cçš„åœ°å€ï¼‰ï¼Œè¿™é‡Œ2 // } f1 := create() f2 := create() f1() f2() // é—­åŒ…å‡½æ•°çš„å†…å­˜ç»“æ„å¸ƒå±€ s := **(**struct{ fn uintptr // æŒ‡å‘å‡½æ•°ä»£ç åœ°å€ data1 int // æ•è·å˜é‡ })(unsafe.Pointer(\u0026amp;f1)) fmt.Printf(\u0026#34;%#v\\n\u0026#34;, s) // struct {fn uintptr;data1 int}{fn:0x47f520, data1:2} } createå‡½æ•°çš„è¿”å›å€¼æ˜¯ä¸€ä¸ªå‡½æ•°ï¼Œå¹¶ä¸”å¼•ç”¨äº†å…¶å¤–å±‚å‡½æ•°å®šä¹‰çš„å±€éƒ¨å˜é‡cã€‚ è€Œä¸”ï¼Œå³ä¾¿createå‡½æ•°ç»“æŸï¼Œä¾ç„¶å¯ä»¥é€šè¿‡f1å’Œf2æ­£å¸¸æ‰§è¡Œè¿™ä¸ªå‡½æ•°å¹¶ä½¿ç”¨å®šä¹‰åœ¨createå†…éƒ¨çš„å˜é‡cã€‚ æ‰€ä»¥è¿™ä¸ªè¿”å›å€¼ç¬¦åˆé—­åŒ…çš„å®šä¹‰ï¼Œè€Œè¿™ä¸ªè‡ªç”±å˜é‡cï¼Œé€šå¸¸è¢«ç§°ä¸ºæ•è·å˜é‡ã€‚ è™½ç„¶createå‡½æ•°çš„è¿”å›å€¼å‡½æ•°å½¢æˆé—­åŒ…ï¼Œä½†æ˜¯Goè¯­è¨€é‡Œå¹¶æ²¡æœ‰æŠŠé—­åŒ…ä»Function Valueä¸­ç‰¹åˆ«åŒºåˆ†å‡ºæ¥ã€‚ åœ¨Goè¯­è¨€ä¸­é—­åŒ…åªæ˜¯æ‹¥æœ‰ä¸€ä¸ªæˆ–å¤šä¸ªæ•è·å˜é‡çš„Function Valueè€Œå·²ã€‚ è¿™äº›æ•è·å˜é‡å°±æ˜¯å®ƒçš„æ•è·åˆ—è¡¨ï¼Œå°±æ”¾åœ¨å¯¹åº”çš„funcvalç»“æ„ä½“çš„åé¢ã€‚ æ‰€ä»¥ä¸Šä¾‹ä¸­ï¼Œf1å’Œf2çš„å†…å­˜å¸ƒå±€å¦‚ä¸‹å›¾æ‰€ç¤ºï¼š æ¯ä¸ªé—­åŒ…å¯¹è±¡éƒ½æ˜¯ä¸€ä¸ªFunction Valueï¼Œä½†æ˜¯å„è‡ªæŒæœ‰è‡ªå·±çš„æ•è·åˆ—è¡¨ï¼Œè¿™ä¹Ÿæ˜¯ç§°é—­åŒ…ä¸ºæœ‰çŠ¶æ€çš„å‡½æ•°çš„åŸå› ã€‚ é—­åŒ…æ•è·å˜é‡å€¼ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 package main func main() { f := create() _ = f() } //go:noinline func create() func() int { c := 2 // å †åˆ†é… struct { F uintptr; c int } return func() int { // æ³¨æ„è¿™é‡Œçš„cå˜é‡ä¸éœ€è¦è¢«æ•è· // cæ²¡æœ‰æ›´æ”¹ï¼Œåªéœ€è¦æ‹·è´å˜é‡cçš„å€¼å³å¯ return c } } main å‡½æ•°æ±‡ç¼–ä»£ç ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 func main() { 0x4551e0 493b6610 CMPQ 0x10(R14), SP # æ ˆå¢é•¿åˆ¤æ–­ 0x4551e4 7629 JBE 0x45520f 0x4551e6 4883ec10 SUBQ $0x10, SP # main.mainæ ˆåˆ†é… 0x4551ea 48896c2408 MOVQ BP, 0x8(SP) 0x4551ef 488d6c2408 LEAQ 0x8(SP), BP f := create() 0x4551f4 e827000000 CALL main.create(SB) # AXè¿”å›\u0026amp;funcval 0x4551f9 48890424 MOVQ AX, 0(SP) _ = f() 0x4551fd 488b08 MOVQ 0(AX), CX # CX=funcval.fn 0x455200 4889c2 MOVQ AX, DX # DX=\u0026amp;funcval 0x455203 ffd1 CALL CX } 0x455205 488b6c2408 MOVQ 0x8(SP), BP 0x45520a 4883c410 ADDQ $0x10, SP 0x45520e c3 RET func main() { 0x45520f e84ccdffff CALL runtime.morestack_noctxt.abi0(SB) 0x455214 ebca JMP main.main(SB) create å‡½æ•°æ±‡ç¼–ä»£ç ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 func create() func() int { 0x455220 493b6610 CMPQ 0x10(R14), SP # æ ˆå¢é•¿åˆ¤æ–­ 0x455224 765f JBE 0x455285 0x455226 4883ec30 SUBQ $0x30, SP # åˆ†é…createæ ˆç©ºé—´ 0x45522a 48896c2428 MOVQ BP, 0x28(SP) 0x45522f 488d6c2428 LEAQ 0x28(SP), BP 0x455234 48c744241800000000 MOVQ $0x0, 0x18(SP) # ä¸´æ—¶è¿”å›ç©ºé—´8å­—èŠ‚ï¼Œ*funcval c := 2 0x45523d 48c744241002000000 MOVQ $0x2, 0x10(SP) # å‚æ•° c return func() int { # AX=0x7493(IP)ï¼Œfuncvalç»“æ„ä½“ç±»å‹çš„_typeç±»å‹æŒ‡é’ˆä½ç½®ï¼Œå†…å­˜å¤§å°16B 0x455246 488d0593740000 LEAQ 0x7493(IP), AX # æ ¹æ®*_typeè¿›è¡Œå †åˆ†é…ï¼ŒAX=\u0026amp;funcval 0x45524d e8ee5cfbff CALL runtime.newobject(SB) 0x455252 4889442420 MOVQ AX, 0x20(SP) # CX=main.create.func1 ä»£ç åœ°å€ 0x455257 488d0d42000000 LEAQ main.create.func1(SB), CX 0x45525e 488908 MOVQ CX, 0(AX) # funcval.fn=main.create.func1 0x455261 488b4c2420 MOVQ 0x20(SP), CX # CX=\u0026amp;funcval 0x455266 8401 TESTB AL, 0(CX) 0x455268 488b542410 MOVQ 0x10(SP), DX # DX=0x2 0x45526d 48895108 MOVQ DX, 0x8(CX) # funcval.data=0x2 0x455271 488b442420 MOVQ 0x20(SP), AX # AX=\u0026amp;funcval 0x455276 4889442418 MOVQ AX, 0x18(SP) 0x45527b 488b6c2428 MOVQ 0x28(SP), BP 0x455280 4883c430 ADDQ $0x30, SP 0x455284 c3 RET func create() func() int { 0x455285 e8d6ccffff CALL runtime.morestack_noctxt.abi0(SB) 0x45528a eb94 JMP main.create(SB) main.create.func1 å‡½æ•°æ±‡ç¼–ä»£ç ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 TEXT main.create.func1(SB) /mnt/hgfs/g/hello1/func1.go return func() int { 0x4552a0 4883ec18 SUBQ $0x18, SP 0x4552a4 48896c2410 MOVQ BP, 0x10(SP) 0x4552a9 488d6c2410 LEAQ 0x10(SP), BP 0x4552ae 488b4a08 MOVQ 0x8(DX), CX # CX=0x2 0x4552b2 48894c2408 MOVQ CX, 0x8(SP) 0x4552b7 48c7042400000000 MOVQ $0x0, 0(SP) // æ³¨æ„è¿™é‡Œçš„cå˜é‡ä¸éœ€è¦è¢«æ•è· 0x4552bf 488b442408 MOVQ 0x8(SP), AX # AX=0x2 0x4552c4 48890424 MOVQ AX, 0(SP) 0x4552c8 488b6c2410 MOVQ 0x10(SP), BP 0x4552cd 4883c418 ADDQ $0x18, SP 0x4552d1 c3 RET mainå’Œcreateçš„æ ˆåˆ†å¸ƒã€‚ | runtime.main callback -------------------------- +40 +08 | runtime.main BP -------------------------- BP --------------- +38 +00 | create.r *funcval main.mainæ ˆ -------------------------- SP --------------- +30 | main.main callback -------------------------- +28 | main.main BP -------------------------- BP --------------- +20 | \u0026amp;funcval create.o -\u0026gt; ä¸´æ—¶funcvalå †åˆ†é… -------------------------- +18 | \u0026amp;funcval create.r -\u0026gt; createçš„è¿”å›å€¼ -------------------------- +10 | 0x2 create.c main.createæ ˆ -------------------------- +08 | -------------------------- +00 | -------------------------- SP --------------- é—­åŒ…æ•è·å˜é‡åœ°å€ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 package main func main() { f := create() _ = f() } //go:noinline func create() func() int { c := 2 // å †åˆ†é… struct { F uintptr; c *int } return func() int { c++ // æ•è·cå˜é‡åœ°å€ï¼Œåœ¨å †ä¸Šåˆ†é… return c } } main å‡½æ•°æ±‡ç¼–ä»£ç ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 func main() { 0x4551e0 493b6610 CMPQ 0x10(R14), SP 0x4551e4 7629 JBE 0x45520f 0x4551e6 4883ec10 SUBQ $0x10, SP 0x4551ea 48896c2408 MOVQ BP, 0x8(SP) 0x4551ef 488d6c2408 LEAQ 0x8(SP), BP f := create() 0x4551f4 e827000000 CALL main.create(SB) # è°ƒç”¨å‡½æ•° AXè¿”å›\u0026amp;funcval 0x4551f9 48890424 MOVQ AX, 0(SP) _ = f() 0x4551fd 488b08 MOVQ 0(AX), CX # CX=funcval.fn 0x455200 4889c2 MOVQ AX, DX # DX=\u0026amp;funcval 0x455203 ffd1 CALL CX } 0x455205 488b6c2408 MOVQ 0x8(SP), BP 0x45520a 4883c410 ADDQ $0x10, SP 0x45520e c3 RET func main() { 0x45520f e84ccdffff CALL runtime.morestack_noctxt.abi0(SB) 0x455214 ebca JMP main.main(SB) create å‡½æ•°æ±‡ç¼–ä»£ç ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 func create() func() int { 0x455220 493b6610 CMPQ 0x10(R14), SP 0x455224 0f8686000000 JBE 0x4552b0 0x45522a 4883ec30 SUBQ $0x30, SP 0x45522e 48896c2428 MOVQ BP, 0x28(SP) 0x455233 488d6c2428 LEAQ 0x28(SP), BP 0x455238 48c744241000000000 MOVQ $0x0, 0x10(SP) c := 2 0x455241 488d05f84a0000 LEAQ 0x4af8(IP), AX # AX=0x4af8(IP)ï¼Œintçš„å…ƒç±»å‹ 0x455248 e8f35cfbff CALL runtime.newobject(SB) # ç”³è¯·å†…å­˜ï¼ŒAX=*int 0x45524d 4889442420 MOVQ AX, 0x20(SP) # å˜é‡c 0x455252 48c70002000000 MOVQ $0x2, 0(AX) # ç»™cèµ‹å€¼2 return func() int { 0x455259 488d0580740000 LEAQ 0x7480(IP), AX # funcvalçš„å…ƒç±»å‹ï¼Œç”³è¯·16B 0x455260 e8db5cfbff CALL runtime.newobject(SB) # AX=\u0026amp;funcval 0x455265 4889442418 MOVQ AX, 0x18(SP) 0x45526a 488d0d4f000000 LEAQ main.create.func1(SB), CX # CX=main.create.func1 0x455271 488908 MOVQ CX, 0(AX) # funcval.fn=main.create.func1 0x455274 488b4c2418 MOVQ 0x18(SP), CX # CX=\u0026amp;funcval 0x455279 8401 TESTB AL, 0(CX) 0x45527b 488b542420 MOVQ 0x20(SP), DX # DX=*int -\u0026gt; 2 0x455280 488d7908 LEAQ 0x8(CX), DI # DI=funcval.data 0x455284 833dd51f090000 CMPL $0x0, runtime.writeBarrier(SB) 0x45528b 7402 JE 0x45528f 0x45528d eb06 JMP 0x455295 0x45528f 48895108 MOVQ DX, 0x8(CX) # funcval.data=*int -\u0026gt; 2 0x455293 eb07 JMP 0x45529c 0x455295 e8a6d0ffff CALL runtime.gcWriteBarrierDX(SB) 0x45529a eb00 JMP 0x45529c 0x45529c 488b442418 MOVQ 0x18(SP), AX # AX=\u0026amp;funcval 0x4552a1 4889442410 MOVQ AX, 0x10(SP) 0x4552a6 488b6c2428 MOVQ 0x28(SP), BP 0x4552ab 4883c430 ADDQ $0x30, SP 0x4552af c3 RET func create() func() int { 0x4552b0 e8abccffff CALL runtime.morestack_noctxt.abi0(SB) 0x4552b5 e966ffffff JMP main.create(SB) main.create.func1 å‡½æ•°æ±‡ç¼–ä»£ç ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 TEXT main.create.func1(SB) /mnt/hgfs/g/hello1/func1.go return func() int { 0x4552c0 4883ec18 SUBQ $0x18, SP 0x4552c4 48896c2410 MOVQ BP, 0x10(SP) 0x4552c9 488d6c2410 LEAQ 0x10(SP), BP 0x4552ce 488b4a08 MOVQ 0x8(DX), CX 0x4552d2 48894c2408 MOVQ CX, 0x8(SP) 0x4552d7 48c7042400000000 MOVQ $0x0, 0(SP) c++ // æ•è·cå˜é‡åœ°å€ï¼Œåœ¨å †ä¸Šåˆ†é… 0x4552df 488b4c2408 MOVQ 0x8(SP), CX 0x4552e4 488b09 MOVQ 0(CX), CX 0x4552e7 488b542408 MOVQ 0x8(SP), DX 0x4552ec 48ffc1 INCQ CX 0x4552ef 48890a MOVQ CX, 0(DX) return c 0x4552f2 488b4c2408 MOVQ 0x8(SP), CX 0x4552f7 488b01 MOVQ 0(CX), AX 0x4552fa 48890424 MOVQ AX, 0(SP) 0x4552fe 488b6c2410 MOVQ 0x10(SP), BP 0x455303 4883c418 ADDQ $0x18, SP 0x455307 c3 RET mainå’Œcreateçš„æ ˆåˆ†å¸ƒã€‚ | runtime.main callback ------------------------- +40 +08 | runtime.main BP ------------------------- BP ------------ +38 +00 | \u0026amp;funcval c.r main.mainæ ˆ ------------------------- SP ------------ +30 | main.main callback ------------------------- +28 | main.main BP ------------------------- BP ------------ +20 | *int -\u0026gt; 2 c ------------------------- +18 | \u0026amp;funcval c.o ------------------------- +10 | \u0026amp;funcval c.r ------------------------- +08 | ------------------------- +00 | ------------------------- SP ------------ è°ƒç”¨ é€šè¿‡Function Valueè°ƒç”¨å‡½æ•°æ—¶ï¼Œä¼šæŠŠå¯¹åº”çš„funcvalç»“æ„ä½“åœ°å€å­˜å…¥ç‰¹å®šå¯„å­˜å™¨ï¼Œå¦‚amd64å¹³å°ä½¿ç”¨çš„æ˜¯DXå¯„å­˜å™¨ï¼Œå‚çœ‹ä¸Šé¢çš„æ±‡ç¼–ç¡®å®ä½¿ç”¨DXå¯„å­˜å™¨å­˜å‚¨çš„ã€‚ ç»§ç»­ä½¿ç”¨é—­åŒ…çš„ç¤ºä¾‹ï¼Œé€šè¿‡f1è°ƒç”¨é—­åŒ…å‡½æ•°æ—¶ï¼Œä¼šæŠŠf1å­˜å‚¨çš„funcvalç»“æ„ä½“åœ°å€å­˜å…¥å¯„å­˜å™¨DXï¼Œè¿™æ ·åœ¨é—­åŒ…å‡½æ•°çš„æŒ‡ä»¤ä¸­å°±å¯ä»¥é€šè¿‡è¿™ä¸ªå¯„å­˜å™¨å­˜å‚¨çš„åœ°å€åŠ ä¸Š8å­—èŠ‚çš„åç§»ï¼Œå°±æ‰¾åˆ°f1çš„æ•è·å˜é‡äº†ã€‚ åŒæ ·çš„ï¼Œé€šè¿‡f2è°ƒç”¨é—­åŒ…å‡½æ•°æ—¶ï¼Œä¼šæŠŠf2å­˜å‚¨çš„funcvalç»“æ„ä½“åœ°å€å­˜å…¥å¯„å­˜å™¨ï¼Œé—­åŒ…å‡½æ•°æ‰§è¡Œæ—¶æ‰¾åˆ°çš„å°±æ˜¯f2çš„æ•è·å˜é‡äº†ã€‚ å¦‚æœæ˜¯æ²¡æœ‰æ•è·åˆ—è¡¨çš„Function Valueï¼Œç›´æ¥å¿½ç•¥è¿™ä¸ªå¯„å­˜å™¨å³å¯ã€‚ é€šè¿‡è¿™æ ·çš„æ–¹å¼ï¼ŒGoè¯­è¨€å®ç°äº†å¯¹Function Valueçš„ç»Ÿä¸€è°ƒç”¨ã€‚ é™æ€åˆ†é… å¯¹äºæ²¡æœ‰æ•è·åˆ—è¡¨çš„Function Valueï¼Œå¦‚æœå¤šä¸ªå˜é‡å…³è”åˆ°åŒä¸€ä¸ªå‡½æ•°ï¼Œç¼–è¯‘å™¨ä¼šåšå‡ºä¼˜åŒ–ï¼Œè®©å®ƒä»¬å…±ç”¨ä¸€ä¸ªfuncvalç»“æ„ä½“ã€‚ æ³¨æ„ funcval åé¢å­˜å‚¨çš„æ˜¯æ•è·çš„å‚æ•°ï¼Œå®é™…ä¼ å‚ä¸åœ¨è¿™é‡Œï¼Œåœ¨è°ƒç”¨è¯¥å‡½æ•°æ—¶åœ¨è°ƒç”¨æ ˆä¸Šã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 func A(i int) { i++ fmt.Println(i) } func B(){ f1 := A f1(1) } func C(){ f2 := A f2(1) } åƒä¸Šé¢è¿™ç§æƒ…å†µï¼Œç¼–è¯‘é˜¶æ®µä¼šåˆ›å»ºä¸€ä¸ªfuncvalç»“æ„ä½“æ”¾åˆ°åªè¯»æ•°æ®æ®µï¼Œè€Œæ‰§è¡Œé˜¶æ®µï¼Œf1å’Œf2éƒ½ä¼šä½¿ç”¨å®ƒã€‚ é™æ€åˆ†é…éªŒè¯ 1 2 3 4 5 6 7 8 9 10 11 package main func main() { f1 := A f1(1) } //go:noinline func A(i int) { i++ } main å‡½æ•°æ±‡ç¼–ä»£ç ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 func main() { 0x4551e0 493b6610 CMPQ 0x10(R14), SP 0x4551e4 7632 JBE 0x455218 0x4551e6 4883ec18 SUBQ $0x18, SP 0x4551ea 48896c2410 MOVQ BP, 0x10(SP) 0x4551ef 488d6c2410 LEAQ 0x10(SP), BP f1 := A 0x4551f4 488d15251d0100 LEAQ 0x11d25(IP), DX # DX=\u0026amp;funcval 0x4551fb 4889542408 MOVQ DX, 0x8(SP) f1(1) 0x455200 488b0d191d0100 MOVQ 0x11d19(IP), CX # CX=funcval.fnï¼Œå‡½æ•°Açš„åœ°å€ 0x455207 b801000000 MOVL $0x1, AX # AX=0x1ï¼Œå‚æ•° 0x45520c ffd1 CALL CX } 0x45520e 488b6c2410 MOVQ 0x10(SP), BP 0x455213 4883c418 ADDQ $0x18, SP 0x455217 c3 RET func main() { 0x455218 e843cdffff CALL runtime.morestack_noctxt.abi0(SB) 0x45521d ebc1 JMP main.main(SB) A å‡½æ•°æ±‡ç¼–ä»£ç ã€‚ 1 2 3 4 5 6 7 8 TEXT main.A(SB) /mnt/hgfs/g/hello1/func1.go func A(i int) { 0x455220 4889442408 MOVQ AX, 0x8(SP) i++ 0x455225 48ffc0 INCQ AX 0x455228 4889442408 MOVQ AX, 0x8(SP) } 0x45522d c3 RET mainå’ŒAçš„æ ˆåˆ†å¸ƒã€‚ | runtime.main callback ------------------------------- +10 | runtime.main BP ------------------------------- BP +08 | 0x11d25(IP) A ------------------------------- +00 | ------------------------------- SP æ•è·åˆ—è¡¨ å› ä¸ºæ•è·åˆ—è¡¨éœ€è¦ç”±é—­åŒ…å¯¹è±¡å„è‡ªæŒæœ‰ï¼Œæ‰€ä»¥æœ‰æ•è·åˆ—è¡¨çš„Function Valueè¦åˆ°æ‰§è¡Œé˜¶æ®µæ‰ä¼šåœ¨å †ä¸Šåˆ†é…å¯¹åº”çš„funcvalç»“æ„ä½“ä»¥åŠæ•è·åˆ—è¡¨ç©ºé—´ã€‚ ä½†æ˜¯ï¼Œæ•è·åˆ—è¡¨é‡Œå­˜ä»€ä¹ˆï¼Ÿç›´æ¥æ‹·è´æ•è·å˜é‡å€¼å—ï¼Ÿæ‰æ²¡æœ‰é‚£ä¹ˆç®€å•ã€‚ é—­åŒ…æ•è·çš„å˜é‡è¦åœ¨é—­åŒ…å‡½æ•°å’Œå¤–å±‚å‡½æ•°ä¸­è¡¨ç°ä¸€è‡´ï¼Œå¦‚æœå•çº¯å€¼æ‹·è´ï¼Œå°±æ— æ³•ä¿è¯è¿™ä¸€ç‚¹ï¼Œæ‰€ä»¥ç¼–è¯‘å™¨é’ˆå¯¹æ•è·å˜é‡çš„ä¸åŒæƒ…å†µåˆ†åˆ«åšå‡ºäº†ä¸åŒçš„å¤„ç†ã€‚ æ•è·å˜é‡ã€é™¤äº†åˆå§‹åŒ–èµ‹å€¼å¤–åœ¨ä»»ä½•åœ°æ–¹éƒ½æ²¡æœ‰è¢«ä¿®æ”¹è¿‡ï¼Œé‚£å°±å¯ä»¥ç›´æ¥æ‹·è´å€¼ã€‘ï¼Œå› ä¸ºå®ƒä¸ä¼šå†å˜åŒ–ã€‚ æ•è·å˜é‡é™¤äº†åˆå§‹åŒ–èµ‹å€¼å¤–ï¼Œè¿˜è¢«ä¿®æ”¹è¿‡ï¼Œå°±è¦å†ç»†åˆ†äº†ã€‚ æ•è·å±€éƒ¨å˜é‡ è¿™ä¸ªä¾‹å­ä¸­ï¼Œè¢«æ•è·çš„æ˜¯å±€éƒ¨å˜é‡iï¼Œé™¤äº†åˆå§‹åŒ–èµ‹å€¼å¤–è¿˜è¢«ä¿®æ”¹è¿‡ï¼Œæ‰€ä»¥å±€éƒ¨å˜é‡iæ”¹ä¸ºå †åˆ†é…ï¼Œæ ˆä¸Šåªå­˜ä¸€ä¸ªåœ°å€ã€‚ åœ¨è¿™ä¸ªç¤ºä¾‹ä¸­ï¼Œä¸ºäº†è®©è¢«æ•è·çš„å±€éƒ¨å˜é‡åœ¨é—­åŒ…å‡½æ•°å’Œå¤–å±‚å‡½æ•°ä¸­ä¿æŒä¸€è‡´ï¼Œæœ¬è¯¥åœ¨æ ˆä¸Šåˆ†é…çš„å±€éƒ¨å˜é‡è¢«åˆ†é…åˆ°å †ä¸Šï¼Œè¿™å…¶å®ä¹Ÿæ˜¯å˜é‡é€ƒé€¸çš„ä¸€ç§åœºæ™¯ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 func create() (fs [2]func()){ for i := 0; i \u0026lt; 2; i++ { // struct { F uintptr; i *int } fs[i] = func(){ fmt.Println(\u0026amp;i, i) } } return } func main() { fs := create() for i := 0; i \u0026lt; len(fs); i++ { fs[i]() } // Output: // 0xc0000ac058 2 // 0xc0000ac058 2 } æ•è·å±€éƒ¨å˜é‡ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 package main func main() { fs := create() for i := 0; i \u0026lt; len(fs); i++ { fs[i]() } } //go:noinline func create() (fs [2]func()) { for i := 0; i \u0026lt; 2; i++ { // å †åˆ†é… struct { F uintptr; i *int } fs[i] = func() { i++ } } return } main æ±‡ç¼–ä»£ç ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 func main() { 0x4551e0 493b6610 CMPQ 0x10(R14), SP 0x4551e4 7675 JBE 0x45525b 0x4551e6 4883ec30 SUBQ $0x30, SP 0x4551ea 48896c2428 MOVQ BP, 0x28(SP) 0x4551ef 488d6c2428 LEAQ 0x28(SP), BP fs := create() 0x4551f4 e887000000 CALL main.create(SB) # è°ƒç”¨main.create 0x4551f9 0f100424 MOVUPS 0(SP), X0 # å°†0(SP)å16Bå†…å®¹æ”¾å…¥X0ï¼Œè¿™é‡Œçš„ä¸¤è¡Œä»£ç ç›¸å½“äºfsèµ‹å€¼ 0x4551fd 0f11442418 MOVUPS X0, 0x18(SP) # å°†X0è¿ç§»åˆ°0x18(SP)å16B for i := 0; i \u0026lt; len(fs); i++ { 0x455202 48c744241000000000 MOVQ $0x0, 0x10(SP) # iåˆå§‹åŒ– 0 0x45520b eb00 JMP 0x45520d 0x45520d 48837c241002 CMPQ $0x2, 0x10(SP) # iå’Œ0x2æ¯”è¾ƒ \u0026lt;--- å¾ªç¯åˆ¤æ–­æ¡ä»¶ 0x455213 7c02 JL 0x455217 0x455215 eb2f JMP 0x455246 fs[i]() 0x455217 488b442410 MOVQ 0x10(SP), AX # AX=0 0x45521c 0f1f4000 NOPL 0(AX) 0x455220 4883f802 CMPQ $0x2, AX 0x455224 7202 JB 0x455228 0x455226 eb28 JMP 0x455250 0x455228 488d44c418 LEAQ 0x18(SP)(AX*8), AX # AX=\u0026amp;funcval 0x45522d 488b10 MOVQ 0(AX), DX # DX=\u0026amp;funcval.fn 0x455230 488b02 MOVQ 0(DX), AX # AX=funcval.fn 0x455233 ffd0 CALL AX # è°ƒç”¨å‡½æ•° 0x455235 eb00 JMP 0x455237 for i := 0; i \u0026lt; len(fs); i++ { 0x455237 488b5c2410 MOVQ 0x10(SP), BX # BX=0 0x45523c 48ffc3 INCQ BX # BX=1 0x45523f 48895c2410 MOVQ BX, 0x10(SP) # i=1 0x455244 ebc7 JMP 0x45520d # \u0026lt;--- ä¸€è½®å¾ªç¯ç»“æŸè·³è½¬å¾ªç¯å¼€å¤´ } 0x455246 488b6c2428 MOVQ 0x28(SP), BP 0x45524b 4883c430 ADDQ $0x30, SP 0x45524f c3 RET fs[i]() 0x455250 b902000000 MOVL $0x2, CX 0x455255 e866d4ffff CALL runtime.panicIndex(SB) 0x45525a 90 NOPL func main() { 0x45525b 0f1f440000 NOPL 0(AX)(AX*1) 0x455260 e8fbccffff CALL runtime.morestack_noctxt.abi0(SB) 0x455265 e976ffffff JMP main.main(SB) create æ±‡ç¼–ä»£ç ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 func create() (fs [2]func()) { 0x455280 493b6610 CMPQ 0x10(R14), SP 0x455284 0f86d0000000 JBE 0x45535a 0x45528a 4883ec28 SUBQ $0x28, SP 0x45528e 48896c2420 MOVQ BP, 0x20(SP) 0x455293 488d6c2420 LEAQ 0x20(SP), BP 0x455298 440f117c2430 MOVUPS X15, 0x30(SP) # 0x30(SP)å¼€å§‹çš„16Båœ°å€æ¸…é›¶ for i := 0; i \u0026lt; 2; i++ { 0x45529e 488d059b4a0000 LEAQ 0x4a9b(IP), AX # AX=0x4a9b(IP)ï¼Œintçš„å…ƒç±»å‹ \u0026lt;--- å˜é‡iåˆå§‹åŒ– 0x4552a5 e8965cfbff CALL runtime.newobject(SB) # å˜é‡iç”³è¯·å†…å­˜ï¼ŒAXè¿”å› *int 0x4552aa 4889442418 MOVQ AX, 0x18(SP) 0x4552af 48c70000000000 MOVQ $0x0, 0(AX) # iå˜é‡èµ‹å€¼0 0x4552b6 eb00 JMP 0x4552b8 0x4552b8 488b4c2418 MOVQ 0x18(SP), CX # CX=\u0026amp;i \u0026lt;--- å¾ªç¯ä»è¿™é‡Œå¼€å§‹ï¼Œåé¢æ»¡è¶³æ¡ä»¶ä¼šè·³è½¬å›æ¥ 0x4552bd 48833902 CMPQ $0x2, 0(CX) # iä¸2æ¯”è¾ƒ 0x4552c1 7c05 JL 0x4552c8 0x4552c3 e97d000000 JMP 0x455345 fs[i] = func() { # struct { F uintptr; i *int } 0x4552c8 488d0511740000 LEAQ 0x7411(IP), AX # AX=0x7411(IP)ï¼Œfuncvalå…ƒç±»å‹ å†…å­˜16B 0x4552cf e86c5cfbff CALL runtime.newobject(SB) # ç”³è¯·å†…å­˜16Bï¼ŒAX=\u0026amp;funcval 0x4552d4 4889442410 MOVQ AX, 0x10(SP) 0x4552d9 488d0da0000000 LEAQ main.create.func1(SB), CX # CX=main.create.func1 0x4552e0 488908 MOVQ CX, 0(AX) # funcval.fn=main.create.func1 0x4552e3 488b4c2410 MOVQ 0x10(SP), CX # CX=\u0026amp;funcval 0x4552e8 8401 TESTB AL, 0(CX) 0x4552ea 488b542418 MOVQ 0x18(SP), DX # DX=\u0026amp;int 0x4552ef 488d7908 LEAQ 0x8(CX), DI # DI=funcval.data 0x4552f3 833d661f090000 CMPL $0x0, runtime.writeBarrier(SB) # æ£€æŸ¥å†™å±éšœ 0x4552fa 7402 JE 0x4552fe 0x4552fc eb06 JMP 0x455304 0x4552fe 48895108 MOVQ DX, 0x8(CX) # funcval.data=\u0026amp;int 0x455302 eb07 JMP 0x45530b 0x455304 e837d0ffff CALL runtime.gcWriteBarrierDX(SB) # è°ƒç”¨å†™å±éšœå‡½æ•° 0x455309 eb00 JMP 0x45530b 0x45530b 488b542418 MOVQ 0x18(SP), DX # DX=\u0026amp;int 0x455310 488b02 MOVQ 0(DX), AX # AX=0 0x455313 488b542410 MOVQ 0x10(SP), DX # DX=\u0026amp;funcval 0x455318 4883f802 CMPQ $0x2, AX # AXå’Œ2æ¯”è¾ƒ 0x45531c 7204 JB 0x455322 0x45531e 6690 NOPW 0x455320 eb2d JMP 0x45534f 0x455322 488d4cc430 LEAQ 0x30(SP)(AX*8), CX # CX=0x30(SP)(AX*8)ï¼ŒAX=0 -\u0026gt; 0x30(SP)ï¼ŒAX=1 -\u0026gt; 0x38(SP) 0x455327 488911 MOVQ DX, 0(CX) # è¿”å›æ•°ç»„éå†èµ‹å€¼ 0x45532a eb00 JMP 0x45532c for i := 0; i \u0026lt; 2; i++ { 0x45532c 488b4c2418 MOVQ 0x18(SP), CX # CX=\u0026amp;int 0x455331 488b09 MOVQ 0(CX), CX # CX=0 0x455334 488b542418 MOVQ 0x18(SP), DX # DX=\u0026amp;int 0x455339 48ffc1 INCQ CX # CX=1 0x45533c 48890a MOVQ CX, 0(DX) # ièµ‹å€¼1 0x45533f 90 NOPL 0x455340 e973ffffff JMP 0x4552b8 # è·³è½¬åˆ°å‰é¢å¼€å§‹ä¸‹ä¸€è½®å¾ªç¯ return 0x455345 488b6c2420 MOVQ 0x20(SP), BP 0x45534a 4883c428 ADDQ $0x28, SP 0x45534e c3 RET fs[i] = func() { 0x45534f b902000000 MOVL $0x2, CX 0x455354 e867d3ffff CALL runtime.panicIndex(SB) 0x455359 90 NOPL func create() (fs [2]func()) { 0x45535a e801ccffff CALL runtime.morestack_noctxt.abi0(SB) 0x45535f 90 NOPL 0x455360 e91bffffff JMP main.create(SB) mainå’Œcreateçš„æ ˆå¸ƒå±€ã€‚ | runtime.main callback --------------------------- +58 +28 | runtime.main BP --------------------------- BP --------------- +50 +20 | \u0026amp;funcval c.r --------------------------- +48 +18 | \u0026amp;funcval c.r --------------------------- +40 +10 | 0x0 i main.mainæ ˆ --------------------------- +38 +08 | \u0026amp;funcval fs[1] --------------------------- +30 +00 | \u0026amp;funcval fs[0] --------------------------- SP --------------- +28 | main.main callback --------------------------- +20 | main.main BP --------------------------- BP --------------- +18 | *int -\u0026gt; 0 1 i --------------------------- +10 | \u0026amp;funcval --------------------------- main.createæ ˆ +08 | --------------------------- +00 | --------------------------- SP --------------- æ•è·å‚æ•° å¦‚æœæ˜¯å‚æ•°è¢«æ•è·ï¼Œé‚£ä¹ˆè°ƒç”¨è€…ä¾ç„¶ä»æ ˆä¸Šä¼ é€’å‚æ•°ï¼Œä½†æ˜¯è¢«è°ƒç”¨å‡½æ•°ä¼šæŠŠå®ƒæ‹·è´åˆ°å †ä¸Šä¸€ä»½ï¼Œç„¶åå’Œé—­åŒ…å‡½æ•°éƒ½ä½¿ç”¨å †ä¸Šåˆ†é…çš„é‚£ä¸€ä¸ªã€‚\nå€¼ä¼ é€’å‚æ•°æ—¶ã€‚\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 func Te1(a int) func() int { // æ­¤æ—¶çš„aå‚æ•°åœ¨å †ä¸Šåˆ†é… // è¿”å›é—­åŒ…æ•è·äº†å‡½æ•°å‚æ•°ï¼Œå‚æ•°aä¼šè¢«å¤åˆ¶åˆ°å †ä¸Šä¾›æ•´ä¸ªTe1å‡½æ•°åŠè¿”å›é—­åŒ…ä½¿ç”¨ // å †åˆ†é… struct { F uintptr; a *int } return func() int { a++ return a } } func main() { var a1 int f := Te1(a1) fmt.Println(f()) // 1 fmt.Println(a1) // 0 // å¯ä»¥çœ‹å‡º å‚æ•°è¢«é—­åŒ…æ•è·å…³ç³»çš„åªæ˜¯æ•è·å‡½æ•°å†…ç›¸å…³å‚æ•°ï¼Œå‚çœ‹ä¸‹é¢æ±‡ç¼– } å€¼ä¼ é€’å‚æ•° 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 package main func main() { a1 := 1 b := Te1(a1) b() } //go:noinline func Te1(a int) func() int { // è¿”å›é—­åŒ…æ•è·äº†å‡½æ•°å‚æ•° // å‚æ•°aä¼šè¢«å¤åˆ¶åˆ°å †ä¸Šä¾›æ•´ä¸ªTe1å‡½æ•°åŠè¿”å›é—­åŒ…ä½¿ç”¨ // struct { F uintptr; a *int } // æ ¹æ®æ±‡ç¼–å¯è§ï¼ŒTe1å †åˆ†é…äº†aï¼Œå¹¶æŠŠä¼ å…¥çš„å‚æ•°1æ‹·è´ç»™äº†aã€‚ return func() int { a++ return a } } main å‡½æ•°æ±‡ç¼–ä»£ç ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 func main() { 0x4551e0 493b6610 CMPQ 0x10(R14), SP 0x4551e4 7638 JBE 0x45521e 0x4551e6 4883ec20 SUBQ $0x20, SP 0x4551ea 48896c2418 MOVQ BP, 0x18(SP) 0x4551ef 488d6c2418 LEAQ 0x18(SP), BP a1 := 1 0x4551f4 48c744240801000000 MOVQ $0x1, 0x8(SP) # a1=1 b := Te1(a1) 0x4551fd b801000000 MOVL $0x1, AX # AX=0x1 0x455202 e839000000 CALL main.Te1(SB) # è°ƒç”¨å‡½æ•° 0x455207 4889442410 MOVQ AX, 0x10(SP) b() 0x45520c 488b08 MOVQ 0(AX), CX # CX=funcval.fn 0x45520f 4889c2 MOVQ AX, DX # DX=\u0026amp;funcval 0x455212 ffd1 CALL CX } 0x455214 488b6c2418 MOVQ 0x18(SP), BP 0x455219 4883c420 ADDQ $0x20, SP 0x45521d c3 RET func main() { 0x45521e 6690 NOPW 0x455220 e83bcdffff CALL runtime.morestack_noctxt.abi0(SB) 0x455225 ebb9 JMP main.main(SB) main.Te1 å‡½æ•°æ±‡ç¼–ä»£ç ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 func Te1(a int) func() int { 0x455240 493b6610 CMPQ 0x10(R14), SP 0x455244 0f8691000000 JBE 0x4552db 0x45524a 4883ec30 SUBQ $0x30, SP 0x45524e 48896c2428 MOVQ BP, 0x28(SP) 0x455253 488d6c2428 LEAQ 0x28(SP), BP 0x455258 4889442438 MOVQ AX, 0x38(SP) # å‚æ•°a 0x45525d 48c744241000000000 MOVQ $0x0, 0x10(SP) 0x455266 488d05d34a0000 LEAQ 0x4ad3(IP), AX # AX=0x4ad3(IP)ï¼Œintå…ƒç±»å‹ï¼Œå‚æ•°aå †åˆ†é… 0x45526d e8ce5cfbff CALL runtime.newobject(SB) # ç”³è¯·å†…å­˜ AX=\u0026amp;int *int 0x455272 4889442420 MOVQ AX, 0x20(SP) # å †åˆ†é…çš„å˜é‡a *int 0x455277 488b4c2438 MOVQ 0x38(SP), CX # CX=1 0x45527c 488908 MOVQ CX, 0(AX) # AX=\u0026amp;int -\u0026gt; 1 return func() int { # struct { F uintptr; a *int } 0x45527f 488d055a740000 LEAQ 0x745a(IP), AX # AX=0x745a(IP)ï¼Œfuncvalç»“æ„ä½“å…ƒç±»å‹ï¼Œå 16B 0x455286 e8b55cfbff CALL runtime.newobject(SB) # ç”³è¯·å†…å­˜ï¼ŒAX=\u0026amp;funcval 0x45528b 4889442418 MOVQ AX, 0x18(SP) 0x455290 488d0d69000000 LEAQ main.Te1.func1(SB), CX # CX=main.Te1.func1 0x455297 488908 MOVQ CX, 0(AX) # funcval.fn=main.Te1.func1 0x45529a 488b4c2418 MOVQ 0x18(SP), CX # CX=\u0026amp;funcval 0x45529f 8401 TESTB AL, 0(CX) 0x4552a1 488b542420 MOVQ 0x20(SP), DX # DX=\u0026amp;int 0x4552a6 488d7908 LEAQ 0x8(CX), DI # DI=funcval.data 0x4552aa 833daf1f090000 CMPL $0x0, runtime.writeBarrier(SB) 0x4552b1 7402 JE 0x4552b5 0x4552b3 eb0b JMP 0x4552c0 0x4552b5 48895108 MOVQ DX, 0x8(CX) # funcval.data=\u0026amp;int 0x4552b9 eb0c JMP 0x4552c7 0x4552bb 0f1f440000 NOPL 0(AX)(AX*1) 0x4552c0 e87bd0ffff CALL runtime.gcWriteBarrierDX(SB) 0x4552c5 eb00 JMP 0x4552c7 0x4552c7 488b442418 MOVQ 0x18(SP), AX # AX=\u0026amp;funcval 0x4552cc 4889442410 MOVQ AX, 0x10(SP) 0x4552d1 488b6c2428 MOVQ 0x28(SP), BP 0x4552d6 4883c430 ADDQ $0x30, SP 0x4552da c3 RET func Te1(a int) func() int { 0x4552db 4889442408 MOVQ AX, 0x8(SP) 0x4552e0 e87bccffff CALL runtime.morestack_noctxt.abi0(SB) 0x4552e5 488b442408 MOVQ 0x8(SP), AX 0x4552ea e951ffffff JMP main.Te1(SB) main.Te1.func1 å‡½æ•°æ±‡ç¼–ä»£ç ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 TEXT main.Te1.func1(SB) /mnt/hgfs/workspace/helium/main.go return func() int { 0x455300 4883ec18 SUBQ $0x18, SP 0x455304 48896c2410 MOVQ BP, 0x10(SP) 0x455309 488d6c2410 LEAQ 0x10(SP), BP 0x45530e 488b4a08 MOVQ 0x8(DX), CX 0x455312 48894c2408 MOVQ CX, 0x8(SP) 0x455317 48c7042400000000 MOVQ $0x0, 0(SP) a++ 0x45531f 488b4c2408 MOVQ 0x8(SP), CX 0x455324 488b09 MOVQ 0(CX), CX 0x455327 488b542408 MOVQ 0x8(SP), DX 0x45532c 48ffc1 INCQ CX 0x45532f 48890a MOVQ CX, 0(DX) return a 0x455332 488b4c2408 MOVQ 0x8(SP), CX 0x455337 488b01 MOVQ 0(CX), AX 0x45533a 48890424 MOVQ AX, 0(SP) 0x45533e 488b6c2410 MOVQ 0x10(SP), BP 0x455343 4883c418 ADDQ $0x18, SP 0x455347 c3 RET æ ˆå¸ƒå±€ä¿¡æ¯ã€‚ +58 +20 | runtime.main callback ---------------------------------- +50 +18 | runtime.main BP ---------------------------------- BP -------------- +48 +10 | \u0026amp;funcval å˜é‡b ---------------------------------- +40 +08 | 0x1 å˜é‡a1 main.mainæ ˆ ---------------------------------- +38 +00 | 0x1 å‚æ•°a ---------------------------------- SP -------------- +30 | main.main callback ---------------------------------- +28 | main.main BP ---------------------------------- BP -------------- +20 | \u0026amp;int -\u0026gt; 1 a ---------------------------------- +18 | \u0026amp;funcval r.o ---------------------------------- +10 | \u0026amp;funcval r main.Te1æ ˆ ---------------------------------- +08 | ---------------------------------- +00 | ---------------------------------- SP -------------- å¼•ç”¨ä¼ é€’å‚æ•°æ—¶ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 // å¦‚æœæ•è·çš„æ˜¯æŒ‡é’ˆæƒ…å†µå‘¢ï¼Œæ ¹æ®ä¸‹é¢ä»£ç å¯ä»¥çœ‹å‡ºè·Ÿä¸Šé¢æƒ…å†µä¸€æ ·çš„è§„åˆ™ // è¿™ç§æƒ…å†µè·Ÿæ•è·å…¨å±€å˜é‡åŸºæœ¬è¡¨ç°ä¸€è‡´ func Te1(a *int) func() int { // è¿”å›é—­åŒ…æ•è·äº†å‡½æ•°å‚æ•°ï¼Œå‚æ•°aä¼šè¢«å¤åˆ¶åˆ°æ ˆä¸Šä¾›æ•´ä¸ªTe1å‡½æ•°åŠè¿”å›é—­åŒ…ä½¿ç”¨ // å †åˆ†é… struct { F uintptr; a *int } return func() int { *a++ return *a } } func main() { var a1 int f := Te1(\u0026amp;a1) fmt.Println(a1) // 0 fmt.Println(f()) // 1 fmt.Println(a1) // 1 a1++ fmt.Println(f()) // 3 fmt.Println(a1) // 3 // æ³¨æ„è¿™é‡Œä¸‹é¢çš„ä¸€è¡Œä»£ç ï¼Œä¼šå…ˆæ‰§è¡Œf() f() åœ¨æ‰“å°æ‰€ä»¥å‡ºç°äº†å¥‡æ€ªçš„è¾“å‡º // å› ä¸ºå‚æ•°ä¼šå…ˆè¢«å®æ—¶è®¡ç®—ï¼Œå› æ­¤å…ˆæ‰§è¡Œäº†f()å’Œf()ï¼Œç„¶åå†æ‰“å°æ•°æ®çš„ã€‚ // fmt.Println(a1, f(), a1, f(), a1) // 2 1 2 2 2 } å¼•ç”¨ä¼ é€’å‚æ•° 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 package main func main() { a1 := 1 b := Te1(\u0026amp;a1) b() } //go:noinline func Te1(a *int) func() int { // è¿”å›é—­åŒ…æ•è·äº†å‡½æ•°å‚æ•° // å‚æ•°aä¼šè¢«å¤åˆ¶åˆ°å †ä¸Šä¾›æ•´ä¸ªTe1å‡½æ•°åŠè¿”å›é—­åŒ…ä½¿ç”¨ // struct { F uintptr; a *int } return func() int { *a++ return *a } } main å‡½æ•°æ±‡ç¼–ä»£ç ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 func main() { 0x4551e0 493b6610 CMPQ 0x10(R14), SP 0x4551e4 764c JBE 0x455232 0x4551e6 4883ec28 SUBQ $0x28, SP 0x4551ea 48896c2420 MOVQ BP, 0x20(SP) 0x4551ef 488d6c2420 LEAQ 0x20(SP), BP a1 := 1 # è¿™é‡Œå¯ä»¥çœ‹å‡ºï¼Œç›´æ¥å°±ç»™aå †åˆ†é…äº† 0x4551f4 488d05454b0000 LEAQ 0x4b45(IP), AX # AX=0x4b45(IP)ï¼Œintå…ƒç±»å‹ 0x4551fb 0f1f440000 NOPL 0(AX)(AX*1) 0x455200 e83b5dfbff CALL runtime.newobject(SB) # AX=\u0026amp;int 0x455205 4889442418 MOVQ AX, 0x18(SP) 0x45520a 48c70001000000 MOVQ $0x1, 0(AX) # a=1 b := Te1(\u0026amp;a1) 0x455211 488b442418 MOVQ 0x18(SP), AX # AX=\u0026amp;int 0x455216 e825000000 CALL main.Te1(SB) # è°ƒç”¨å‡½æ•°ï¼ŒAX=\u0026amp;funcval 0x45521b 4889442410 MOVQ AX, 0x10(SP) b() 0x455220 488b08 MOVQ 0(AX), CX # CX=funcval.fn 0x455223 4889c2 MOVQ AX, DX # DX=\u0026amp;funcval 0x455226 ffd1 CALL CX # è°ƒç”¨å‡½æ•° } 0x455228 488b6c2420 MOVQ 0x20(SP), BP 0x45522d 4883c428 ADDQ $0x28, SP 0x455231 c3 RET func main() { 0x455232 e829cdffff CALL runtime.morestack_noctxt.abi0(SB) 0x455237 eba7 JMP main.main(SB) main.Te1 å‡½æ•°æ±‡ç¼–ä»£ç ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 func Te1(a *int) func() int { 0x455240 493b6610 CMPQ 0x10(R14), SP 0x455244 7675 JBE 0x4552bb 0x455246 4883ec28 SUBQ $0x28, SP 0x45524a 48896c2420 MOVQ BP, 0x20(SP) 0x45524f 488d6c2420 LEAQ 0x20(SP), BP 0x455254 4889442430 MOVQ AX, 0x30(SP) # å‚æ•°a *int 0x455259 48c744241000000000 MOVQ $0x0, 0x10(SP) # è¿”å›å€¼ func() int return func() int { # struct { F uintptr; i *int } 0x455262 488d0577740000 LEAQ 0x7477(IP), AX # AX=0x7477(IP)ï¼Œfuncvalç»“æ„ä½“ 16B 0x455269 e8d25cfbff CALL runtime.newobject(SB # AX=\u0026amp;funcval 0x45526e 4889442418 MOVQ AX, 0x18(SP) 0x455273 488d0d66000000 LEAQ main.Te1.func1(SB), CX # CX=main.Te1.func1 0x45527a 488908 MOVQ CX, 0(AX) # funcval.fn=main.Te1.func1 0x45527d 488b4c2418 MOVQ 0x18(SP), CX # CX=\u0026amp;funcval 0x455282 8401 TESTB AL, 0(CX) 0x455284 488b542430 MOVQ 0x30(SP), DX # DX=\u0026amp;int 0x455289 488d7908 LEAQ 0x8(CX), DI # DI=funcval.data 0x45528d 833dcc1f090000 CMPL $0x0, runtime.writeBarrier(SB) 0x455294 7402 JE 0x455298 0x455296 eb08 JMP 0x4552a0 0x455298 48895108 MOVQ DX, 0x8(CX) # funcval.data=\u0026amp;int 0x45529c eb09 JMP 0x4552a7 0x45529e 6690 NOPW 0x4552a0 e89bd0ffff CALL runtime.gcWriteBarrierDX(SB) 0x4552a5 eb00 JMP 0x4552a7 0x4552a7 488b442418 MOVQ 0x18(SP), AX # AX=\u0026amp;funcval 0x4552ac 4889442410 MOVQ AX, 0x10(SP) 0x4552b1 488b6c2420 MOVQ 0x20(SP), BP 0x4552b6 4883c428 ADDQ $0x28, SP 0x4552ba c3 RET main.Te1.func1 å‡½æ•°æ±‡ç¼–ä»£ç ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 func Te1(a *int) func() int { 0x4552bb 4889442408 MOVQ AX, 0x8(SP) 0x4552c0 e89bccffff CALL runtime.morestack_noctxt.abi0(SB) 0x4552c5 488b442408 MOVQ 0x8(SP), AX 0x4552ca e971ffffff JMP main.Te1(SB) return func() int { 0x4552e0 4883ec18 SUBQ $0x18, SP 0x4552e4 48896c2410 MOVQ BP, 0x10(SP) 0x4552e9 488d6c2410 LEAQ 0x10(SP), BP 0x4552ee 488b4a08 MOVQ 0x8(DX), CX # CX=\u0026amp;int 0x4552f2 48894c2408 MOVQ CX, 0x8(SP) 0x4552f7 48c7042400000000 MOVQ $0x0, 0(SP) *a++ 0x4552ff 488b4c2408 MOVQ 0x8(SP), CX # CX=\u0026amp;int 0x455304 8401 TESTB AL, 0(CX) 0x455306 488b542408 MOVQ 0x8(SP), DX # DX=\u0026amp;int 0x45530b 8402 TESTB AL, 0(DX) 0x45530d 488b09 MOVQ 0(CX), CX # CX=1 0x455310 48ffc1 INCQ CX # CX=2 0x455313 48890a MOVQ CX, 0(DX) # \u0026amp;int -\u0026gt; 2 return *a 0x455316 488b4c2408 MOVQ 0x8(SP), CX # CX=\u0026amp;int 0x45531b 8401 TESTB AL, 0(CX) 0x45531d 488b01 MOVQ 0(CX), AX # AX=2 0x455320 48890424 MOVQ AX, 0(SP) 0x455324 488b6c2410 MOVQ 0x10(SP), BP 0x455329 4883c418 ADDQ $0x18, SP 0x45532d c3 RET æ ˆåˆ†å¸ƒæƒ…å†µã€‚ +58 +28 | address of runtime.main ------------------------------ +50 +20 | BP of runtime.main ------------------------------ BP +48 +18 | \u0026amp;int -\u0026gt; 1 a1 ------------------------------ +40 +10 | \u0026amp;funcval b ------------------------------ +38 +08 | ------------------------------ +30 +00 | \u0026amp;int T.a ------------------------------ SP +28 | address of main.main ------------------------------ +20 | BP of main.main ------------------------------ BP +18 | \u0026amp;funcval T.o ------------------------------ +10 | \u0026amp;funcval T.r ------------------------------ +08 | ------------------------------ +00 | ------------------------------ SP æ•è·è¿”å›å€¼ å¦‚æœæ˜¯è¿”å›å€¼è¢«æ•è·ï¼Œé‚£ä¹ˆå¤„ç†æ–¹å¼å°±åˆæœ‰äº›ä¸åŒäº†ã€‚ è¿”å›å€¼ç©ºé—´ä¾ç„¶ç”±è°ƒç”¨è€…åœ¨æ ˆä¸Šåˆ†é…ï¼Œä½†æ˜¯è¢«è°ƒç”¨å‡½æ•°ï¼ˆé—­åŒ…çš„å¤–å±‚å‡½æ•°ï¼‰ä¼šåœ¨å †ä¸Šä¹Ÿåˆ†é…ä¸€ä¸ªï¼Œå¹¶ä¸”ä¸é—­åŒ…å‡½æ•°éƒ½ä½¿ç”¨å †ä¸Šè¿™ä¸€ä¸ªï¼Œä½†æ˜¯ï¼Œåœ¨å¤–å±‚å‡½æ•°è¿”å›å‰è¦æŠŠå †ä¸Šçš„è¿”å›å€¼æ‹·è´åˆ°æ ˆä¸Šé‚£ä¸€ä¸ªã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 package main func main() { b, _ := Te1() b() } //go:noinline func Te1() (y func() int, y1 int) { y1++ // 1 // å †åˆ†é… struct { F uintptr; y1 *int } return func() int { y1++ return 1 }, y1 } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 func main() { 0x4551e0 493b6610 CMPQ 0x10(R14), SP 0x4551e4 763b JBE 0x455221 0x4551e6 4883ec18 SUBQ $0x18, SP 0x4551ea 48896c2410 MOVQ BP, 0x10(SP) 0x4551ef 488d6c2410 LEAQ 0x10(SP), BP b, _ := Te1() 0x4551f4 48c744240800000000 MOVQ $0x0, 0x8(SP) 0x4551fd 0f1f00 NOPL 0(AX) 0x455200 e83b000000 CALL main.Te1(SB) 0x455205 4889442408 MOVQ AX, 0x8(SP) 0x45520a 48890424 MOVQ AX, 0(SP) b() 0x45520e 488b1424 MOVQ 0(SP), DX 0x455212 488b02 MOVQ 0(DX), AX 0x455215 ffd0 CALL AX } 0x455217 488b6c2410 MOVQ 0x10(SP), BP 0x45521c 4883c418 ADDQ $0x18, SP 0x455220 c3 RET func main() { 0x455221 e83acdffff CALL runtime.morestack_noctxt.abi0(SB) 0x455226 ebb8 JMP main.main(SB) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 func Te1() (y func() int, y1 int) { 0x455240 493b6610 CMPQ 0x10(R14), SP 0x455244 0f868e000000 JBE 0x4552d8 0x45524a 4883ec30 SUBQ $0x30, SP 0x45524e 48896c2428 MOVQ BP, 0x28(SP) 0x455253 488d6c2428 LEAQ 0x28(SP), BP 0x455258 48c744241000000000 MOVQ $0x0, 0x10(SP) 0x455261 488d05d84a0000 LEAQ 0x4ad8(IP), AX # AX=0x4ad8(IP)ï¼Œintå…ƒç±»å‹ 0x455268 e8d35cfbff CALL runtime.newobject(SB) # AX=\u0026amp;int 0x45526d 4889442420 MOVQ AX, 0x20(SP) y1++ 0x455272 48ff00 INCQ 0(AX) # y1=1 return func() int { # struct { F uintptr; y1 *int } 0x455275 488d0564740000 LEAQ 0x7464(IP), AX # AX=0x7464(IP)ï¼Œfuncvalå…ƒç±»å‹ 16B 0x45527c 0f1f4000 NOPL 0(AX) 0x455280 e8bb5cfbff CALL runtime.newobject(SB) # AX=\u0026amp;funcval 0x455285 4889442418 MOVQ AX, 0x18(SP) 0x45528a 488d0d6f000000 LEAQ main.Te1.func1(SB), CX # CX=main.Te1.func1 0x455291 488908 MOVQ CX, 0(AX) # funcval.fn=main.Te1.func1 0x455294 488b4c2418 MOVQ 0x18(SP), CX # CX=\u0026amp;funcval 0x455299 8401 TESTB AL, 0(CX) 0x45529b 488b542420 MOVQ 0x20(SP), DX # DX=\u0026amp;int 0x4552a0 488d7908 LEAQ 0x8(CX), DI # DI=funcval.data 0x4552a4 833db51f090000 CMPL $0x0, runtime.writeBarrier(SB) 0x4552ab 7402 JE 0x4552af 0x4552ad eb06 JMP 0x4552b5 0x4552af 48895108 MOVQ DX, 0x8(CX) # funcval.data=\u0026amp;int 0x4552b3 eb07 JMP 0x4552bc 0x4552b5 e886d0ffff CALL runtime.gcWriteBarrierDX(SB) 0x4552ba eb00 JMP 0x4552bc 0x4552bc 488b442418 MOVQ 0x18(SP), AX # AX=\u0026amp;funcval è¿”å›å‚æ•°1 0x4552c1 4889442410 MOVQ AX, 0x10(SP) 0x4552c6 488b4c2420 MOVQ 0x20(SP), CX # CX=\u0026amp;int 0x4552cb 488b19 MOVQ 0(CX), BX # BX=1 è¿”å›å‚æ•°2 0x4552ce 488b6c2428 MOVQ 0x28(SP), BP 0x4552d3 4883c430 ADDQ $0x30, SP 0x4552d7 c3 RET func Te1() (y func() int, y1 int) { 0x4552d8 e883ccffff CALL runtime.morestack_noctxt.abi0(SB) 0x4552dd 0f1f00 NOPL 0(AX) 0x4552e0 e95bffffff JMP main.Te1(SB) +50 +18 | address of runtime.main ----------------------------- +48 +10 | BP of runtime.main ----------------------------- BP +40 +08 | 0 ----------------------------- +38 +00 | ----------------------------- SP +30 | address of main.main ----------------------------- +28 | BP of main.main ----------------------------- BP +20 | \u0026amp;int 1 y1 ----------------------------- +18 | \u0026amp;funcval y ----------------------------- +10 | \u0026amp;funcval ----------------------------- +08 | ----------------------------- +00 | ----------------------------- SP è‡ªå·±æ•è·è‡ªå·± 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 package main func main() { x()() } //go:noinline func x() (y func()) { // struct { F uintptr } y = func() { //println(\u0026#34;y\u0026#34;) } // deferåœ¨returnèµ‹å€¼å®Œæˆä¹‹åæ‰§è¡Œ //defer func() { //\ty = func() { // fmt.Println(\u0026#34;æˆ‘èƒ½æ”¹å˜äº†Yçš„å€¼ï¼Ÿ\u0026#34;) //\t} //}() // struct { F uintptr; y *func() } return func() { //println(\u0026#34;z\u0026#34;) y() } } main æ±‡ç¼–ä»£ç ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 func main() { 0x4551e0 493b6610 CMPQ 0x10(R14), SP 0x4551e4 7629 JBE 0x45520f 0x4551e6 4883ec10 SUBQ $0x10, SP 0x4551ea 48896c2408 MOVQ BP, 0x8(SP) 0x4551ef 488d6c2408 LEAQ 0x8(SP), BP x()() 0x4551f4 e847000000 CALL main.x(SB) # AX=\u0026amp;funcval 0x4551f9 48890424 MOVQ AX, 0(SP) 0x4551fd 488b08 MOVQ 0(AX), CX # CX=funcval.fn 0x455200 4889c2 MOVQ AX, DX # DX=\u0026amp;funcval 0x455203 ffd1 CALL CX } 0x455205 488b6c2408 MOVQ 0x8(SP), BP 0x45520a 4883c410 ADDQ $0x10, SP 0x45520e c3 RET func main() { 0x45520f e84ccdffff CALL runtime.morestack_noctxt.abi0(SB) 0x455214 ebca JMP main.main(SB) x æ±‡ç¼–ä»£ç ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 func x() (y func()) { 0x455240 493b6610 CMPQ 0x10(R14), SP 0x455244 0f86bf000000 JBE 0x455309 0x45524a 4883ec28 SUBQ $0x28, SP 0x45524e 48896c2420 MOVQ BP, 0x20(SP) 0x455253 488d6c2420 LEAQ 0x20(SP), BP # func() å˜é‡y 0x455258 488d05e1480000 LEAQ 0x48e1(IP), AX # AX=0x48e1(IP)ï¼Œfuncvalå…ƒç±»å‹ 0x45525f 90 NOPL 0x455260 e8db5cfbff CALL runtime.newobject(SB) # AX=\u0026amp;funcval 0x455265 4889442418 MOVQ AX, 0x18(SP) y = func() { 0x45526a 833def1f090000 CMPL $0x0, runtime.writeBarrier(SB) 0x455271 7402 JE 0x455275 0x455273 eb0d JMP 0x455282 # funcval.fn -\u0026gt; println(\u0026#34;y\u0026#34;) æ›¿æ¢ y 0x455275 488d0d841d0100 LEAQ 0x11d84(IP), CX # CX=0x11d84(IP)ï¼Œå‡½æ•°ä»£ç å¤„ 0x45527c 488908 MOVQ CX, 0(AX) # funcval.fn=0x11d84(IP) 0x45527f 90 NOPL 0x455280 eb11 JMP 0x455293 0x455282 4889c7 MOVQ AX, DI 0x455285 488d0d741d0100 LEAQ 0x11d74(IP), CX 0x45528c e88fd0ffff CALL runtime.gcWriteBarrierCX(SB) 0x455291 eb00 JMP 0x455293 return func() { # struct { F uintptr; y *func() } 0x455293 488d0586740000 LEAQ 0x7486(IP), AX # AX=0x7486(IP)ï¼Œfuncvalå…ƒç±»å‹ 16B 0x45529a e8a15cfbff CALL runtime.newobject(SB) # AX=\u0026amp;funcval.1 0x45529f 4889442410 MOVQ AX, 0x10(SP) 0x4552a4 488d0d75000000 LEAQ main.x.func2(SB), CX # CX=main.x.func2 0x4552ab 488908 MOVQ CX, 0(AX) # funcval.1.fn=main.x.func2 0x4552ae 488b4c2410 MOVQ 0x10(SP), CX # CX=\u0026amp;funcval.1 0x4552b3 8401 TESTB AL, 0(CX) 0x4552b5 488b542418 MOVQ 0x18(SP), DX # DX=\u0026amp;funcval 0x4552ba 488d7908 LEAQ 0x8(CX), DI # DI=funcval.1.data 0x4552be 833d9b1f090000 CMPL $0x0, runtime.writeBarrier(SB) 0x4552c5 7402 JE 0x4552c9 0x4552c7 eb06 JMP 0x4552cf 0x4552c9 48895108 MOVQ DX, 0x8(CX) # funcval.1.data=\u0026amp;funcval 0x4552cd eb07 JMP 0x4552d6 0x4552cf e86cd0ffff CALL runtime.gcWriteBarrierDX(SB) 0x4552d4 eb00 JMP 0x4552d6 0x4552d6 488b7c2418 MOVQ 0x18(SP), DI # DI=\u0026amp;funcval 0x4552db 488b4c2410 MOVQ 0x10(SP), CX # CX=\u0026amp;funcval.1 0x4552e0 833d791f090000 CMPL $0x0, runtime.writeBarrier(SB) 0x4552e7 7402 JE 0x4552eb 0x4552e9 eb05 JMP 0x4552f0 0x4552eb 48890f MOVQ CX, 0(DI) # funcval.fn=\u0026amp;funcval.1 0x4552ee eb07 JMP 0x4552f7 0x4552f0 e82bd0ffff CALL runtime.gcWriteBarrierCX(SB) 0x4552f5 eb00 JMP 0x4552f7 0x4552f7 488b4c2418 MOVQ 0x18(SP), CX # CX=\u0026amp;funcval 0x4552fc 488b01 MOVQ 0(CX), AX # AX=funcval.fn 0x4552ff 488b6c2420 MOVQ 0x20(SP), BP 0x455304 4883c428 ADDQ $0x28, SP 0x455308 c3 RET func x() (y func()) { 0x455309 e852ccffff CALL runtime.morestack_noctxt.abi0(SB) 0x45530e e92dffffff JMP main.x(SB) unsafe Goè¯­è¨€é‡ŒFunction Valueæœ¬è´¨ä¸Šæ˜¯æŒ‡å‘funcvalç»“æ„ä½“çš„æŒ‡é’ˆ Goè¯­è¨€é‡Œé—­åŒ…åªæ˜¯æ‹¥æœ‰æ•è·åˆ—è¡¨çš„Function Value æ•è·å˜é‡åœ¨å¤–å±‚å‡½æ•°ä¸é—­åŒ…å‡½æ•°ä¸­è¦ä¿æŒä¸€è‡´ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;unsafe\u0026#34; ) type fv struct { fn unsafe.Pointer i *int // æ•è·çš„å˜é‡i } func main() { g := callback() fn := **(**fv)(unsafe.Pointer(\u0026amp;g)) fmt.Printf(\u0026#34;%#v\\n\u0026#34;, fn) fmt.Println(*(fn.i)) // 13 // Output: // main.fv{fn:(unsafe.Pointer)(0xeccdc0), i:(*int)(0xc00000a098)} // 13 // å¯ä»¥çœ‹å‡ºæ•è·çš„æ˜¯içš„åœ°å€ } func callback() func() { i := 13 // struct { F uintptr; i *int } return func() { i++ } } å‚è€ƒ æœ¬ç¯‡æ–‡ç« å‚è€ƒäº†ã€Šæ·±åº¦æ¢ç´¢Goè¯­è¨€ã€‹ä¹¦å†…å®¹ã€‚ å‚è€ƒ https://mp.weixin.qq.com/s/hO0S4WcG0hUzCmMNMKtS-gã€‚ ","permalink":"https://heliu.site/posts/golang/func/value/","summary":"æœ¬ç¯‡ä»‹ç»é—­åŒ…çš„ç»„æˆç»“æ„ã€‚","title":"Function Value"},{"content":"defer çš„ä¸‰ä¸ªè§„åˆ™ï¼š\nè§„åˆ™ä¸€ï¼šdefer å£°æ˜æ—¶ï¼Œå…¶åé¢å‡½æ•°å‚æ•°ä¼šè¢«å®æ—¶è§£æã€‚ è§„åˆ™äºŒï¼šdefer æ‰§è¡Œé¡ºåºä¸ºå…ˆè¿›åå‡ºï¼ˆFILOï¼‰(First Insert Last Out)ã€‚ è§„åˆ™ä¸‰ï¼šdefer å¯ä»¥è¯»å–å‡½æ•°çš„æœ‰åè¿”å›å€¼ã€‚ deferå‡½æ•°å‚æ•°ä¼šè¢«å®æ—¶è§£æ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 package main import \u0026#34;fmt\u0026#34; func main() { var i int = 1 // è§„åˆ™ä¸€ï¼šå½“deferè¢«å£°æ˜æ—¶ï¼Œå…¶åé¢å‡½æ•°å‚æ•°ä¼šè¢«å®æ—¶è§£æ // æ³¨æ„ï¼Œfmt.Println åœ¨deferåé¢ï¼Œå®ƒçš„å‚æ•°ä¼šå®æ—¶è®¡ç®— // è¾“å‡ºï¼šresult =\u0026gt; 2 (è€Œä¸æ˜¯4) defer fmt.Println(\u0026#34;result1 =\u0026gt;\u0026#34;, func() int {return i*2}()) i++ // ã€é—­åŒ…ä¸­çš„iåœ¨åé¢æœ‰ä¿®æ”¹ï¼Œæ‰€ä»¥é—­åŒ…æ•è·çš„æ˜¯å˜é‡içš„åœ°å€ã€‘ // æ‰€ä»¥é—­åŒ…æ‰§è¡Œæ—¶ï¼Œiçš„å€¼ä¸º3 // struct { F uintptr; i *int } defer func() { fmt.Println(\u0026#34;result2 =\u0026gt;\u0026#34;, i*2) }() i++ // Output: // result2 =\u0026gt; 6 // result1 =\u0026gt; 2 } deferæ‰§è¡Œé¡ºåºæ˜¯å…ˆè¿›åå‡º 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 package main import \u0026#34;fmt\u0026#34; func main() { defer fmt.Print(\u0026#34; !!! \u0026#34;) defer fmt.Print(\u0026#34; world \u0026#34;) fmt.Print(\u0026#34;hello \u0026#34;) // hello \u0026lt;- world \u0026lt;- !!! // æ³¨å†Œé¡ºåºï¼š\u0026lt;----------------------- // æ‰§è¡Œé¡ºåºï¼š-----------------------\u0026gt; // Output: // hello world !!! } deferå¯ä»¥è¯»å–å‡½æ•°çš„æœ‰åè¿”å›å€¼ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 package main import \u0026#34;fmt\u0026#34; func main() { fmt.Println(\u0026#34;result2 =\u0026gt;\u0026#34;, fun1()) // Output: // result2 =\u0026gt; 11 } func fun1() (i int) { // å †åˆ†é… struct { F uintptr; i *int } defer func() { i = i + 10 }() return 1 } æ±‡ç¼–ä»£ç  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 TEXT main.fun1(SB) /mnt/hgfs/workspace/helium/main.go func fun1() (i int) { 0x4552e0 493b6610 CMPQ 0x10(R14), SP 0x4552e4 0f868a000000 JBE 0x455374 0x4552ea 4883ec78 SUBQ $0x78, SP 0x4552ee 48896c2470 MOVQ BP, 0x70(SP) 0x4552f3 488d6c2470 LEAQ 0x70(SP), BP 0x4552f8 48c744240800000000 MOVQ $0x0, 0x8(SP) # i int defer func() { 0x455301 440f117c2460 MOVUPS X15, 0x60(SP) 0x455307 488d4c2460 LEAQ 0x60(SP), CX 0x45530c 48894c2458 MOVQ CX, 0x58(SP) 0x455311 8401 TESTB AL, 0(CX) # funcval.fn 0x455313 488d1566000000 LEAQ main.fun1.func1(SB), DX 0x45531a 4889542460 MOVQ DX, 0x60(SP) 0x45531f 8401 TESTB AL, 0(CX) # *int æ•è·çš„æ˜¯æœ‰åè¿”å›å€¼åœ°å€ 0x455321 488d542408 LEAQ 0x8(SP), DX 0x455326 4889542468 MOVQ DX, 0x68(SP) # funcval.data=i *int 0x45532b 48894c2428 MOVQ CX, 0x28(SP) # defer.fn=\u0026amp;funcval 0x455330 488d442410 LEAQ 0x10(SP), AX # AX=0x10(SP)=\u0026amp;_defer # AX å¯„å­˜å™¨å­˜å‚¨çš„æ˜¯runtime.deferprocStack()å‡½æ•°çš„å‚æ•° *_defer 0x455335 e8c650fdff CALL runtime.deferprocStack(SB) # panicæµç¨‹recoveråä¼šæ¢å¤åˆ°è¿™é‡Œï¼Œå¹¶æŠŠAXç½®ä¸º1ã€‚ # æ­£å¸¸æƒ…å†µä¸‹AXç½®ä¸º0çš„ã€‚ 0x45533a 85c0 TESTL AX, AX 0x45533c 7522 JNE 0x455360 0x45533e 6690 NOPW 0x455340 eb00 JMP 0x455342 return 1 0x455342 48c744240801000000 MOVQ $0x1, 0x8(SP) 0x45534b e8d056fdff CALL runtime.deferreturn(SB) 0x455350 488b442408 MOVQ 0x8(SP), AX 0x455355 488b6c2470 MOVQ 0x70(SP), BP 0x45535a 4883c478 ADDQ $0x78, SP 0x45535e c3 RET 0x45535f 90 NOPL defer func() { 0x455360 e8bb56fdff CALL runtime.deferreturn(SB) 0x455365 488b442408 MOVQ 0x8(SP), AX 0x45536a 488b6c2470 MOVQ 0x70(SP), BP 0x45536f 4883c478 ADDQ $0x78, SP 0x455373 c3 RET func fun1() (i int) { 0x455374 e887ccffff CALL runtime.morestack_noctxt.abi0(SB) 0x455379 e962ffffff JMP main.fun1(SB) 1 2 3 4 5 6 7 8 9 10 11 12 13 TEXT main.fun1.func1(SB) /mnt/hgfs/workspace/helium/main.go defer func() { 0x455380 4883ec10 SUBQ $0x10, SP 0x455384 48896c2408 MOVQ BP, 0x8(SP) 0x455389 488d6c2408 LEAQ 0x8(SP), BP 0x45538e 488b4208 MOVQ 0x8(DX), AX # AX=i int 0x455392 48890424 MOVQ AX, 0(SP) i += 10 0x455396 4883000a ADDQ $0xa, 0(AX) }() 0x45539a 488b6c2408 MOVQ 0x8(SP), BP 0x45539f 4883c410 ADDQ $0x10, SP 0x4553a3 c3 RET ç”±äºåœ¨Goè¯­è¨€ä¸­ï¼Œreturnè¯­å¥ä¸æ˜¯åŸå­æ“ä½œï¼Œreturnç­‰å‡½æ•°æ‰§è¡Œdeferå’Œé”€æ¯æ ˆç­‰æ“ä½œã€‚ æœ€å…ˆæ˜¯æ‰€æœ‰è¿”å›å€¼åœ¨è¿›å…¥å‡½æ•°æ—¶éƒ½ä¼šåˆå§‹åŒ–ä¸ºå…¶ç±»å‹çš„é›¶å€¼ï¼ˆå§‘ä¸”ç§°ä¸ºretèµ‹å€¼ï¼‰ é€€å‡ºæ—¶å…ˆç»™è¿”å›å€¼èµ‹å€¼ ç„¶åæ‰§è¡Œdeferå‘½ä»¤ æœ€åæ‰æ˜¯returnæ“ä½œï¼Œreturnæ“ä½œåŒ…å«ä¸¤ä¸ªæ­¥éª¤ï¼Œä¸€æ˜¯ç»™è¢«è°ƒç”¨æ ˆçš„è¿”å›å€¼èµ‹å€¼ï¼Œç„¶åæ‰§è¡Œdeferæ³¨å†Œå‡½æ•°ï¼ŒäºŒæ˜¯æŠŠè¢«è°ƒå‡½æ•°çš„æ ˆçš„è¿”å›å€¼è¿”å›ç»™è°ƒç”¨å‡½æ•° è¿”å›å€¼=xxx | v è°ƒç”¨defer() | v return 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 package main import \u0026#34;fmt\u0026#34; func main() { fmt.Println(\u0026#34;=====================================\u0026#34;) fmt.Println(\u0026#34;fun1 return:\u0026#34;, fun1()) // fun1 return:2 fmt.Println(\u0026#34;=====================================\u0026#34;) fmt.Println(\u0026#34;fun2 return:\u0026#34;, fun2()) // fun2 return:0 fmt.Println(\u0026#34;=====================================\u0026#34;) fmt.Println(\u0026#34;fun3 return:\u0026#34;, fun3()) // fun3 return:5 fmt.Println(\u0026#34;=====================================\u0026#34;) fmt.Println(\u0026#34;fun4 return:\u0026#34;, fun4()) // fun4 return:19 // Output: // ===================================== // fun1 defer1:1 // fun1 defer2:2 // fun1 return:2 // ===================================== // fun2 defer1:1 // fun2 defer2:2 // fun2 return:0 // ===================================== // fun3 defer:10 // fun3 return:5 // ===================================== // fun4 defer:8 // fun4 return:19 } func fun1() (i int) { // struct { F uintptr; i *int } defer func() { i++ fmt.Println(\u0026#34;fun1 defer2:\u0026#34;, i) // fun1 defer2:2 }() // struct { F uintptr; i *int } defer func() { i++ fmt.Println(\u0026#34;fun1 defer1:\u0026#34;, i) // fun1 defer1:1 }() // è¿™é‡Œä¹Ÿæ˜¯ç»™ièµ‹å€¼ // å½“åši=0;return; return 0 } func fun2() int { var i int // struct { F uintptr; i *int } defer func() { i++ fmt.Println(\u0026#34;fun2 defer2:\u0026#34;, i) // fun2 defer2: 2 }() // struct { F uintptr; i *int } defer func() { i++ fmt.Println(\u0026#34;fun2 defer1:\u0026#34;, i) // fun2 defer1: 1 }() return i } func fun3() (r int) { t := 5 // struct { F uintptr; t *int } defer func() { t = t + 5 fmt.Println(\u0026#34;fun3 defer:\u0026#34;, t) // fun3 defer:10 }() return t } func fun4() int { i := 8 // struct { F uintptr, i int } // å› ä¸ºæ˜¯æ˜¾ç¤ºä¼ å‚ defer func(i int) { fmt.Println(\u0026#34;fun4 defer:\u0026#34;, i) // fun4 defer:8 }(i) i = 19 return i } åŒ¿åè¿”å›å€¼ã€‚ deferè®¡ç®—å‡½æ•°æ‰§è¡Œæ—¶é—´ æ ¹æ®deferå»¶è¿Ÿæ‰§è¡Œçš„ç‰¹æ€§ï¼Œå¯ä»¥åˆ©ç”¨å®ƒæ¥è®¡ç®—ä»£ç å—çš„æ‰§è¡Œæ—¶é—´ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;time\u0026#34; ) func main() { defer timeCost(time.Now()) // è¿™é‡Œåˆ©ç”¨å‚æ•°æ˜¯å®æ—¶è§£æçš„ fmt.Println(\u0026#34;start ...\u0026#34;) time.Sleep(time.Second * 5) fmt.Println(\u0026#34;finish ...\u0026#34;) // Output: // start ... // finish ... // 5.0068172s } func timeCost(start time.Time) { terminal := time.Since(start) // now - start fmt.Println(terminal) } ","permalink":"https://heliu.site/posts/golang/func/defer-use/","summary":"defer çš„ä½¿ç”¨è§„åˆ™ä»‹ç»ã€‚","title":"defer(ä½¿ç”¨)"},{"content":" è·Ÿåœ¨deferåé¢çš„å‡½æ•°è°ƒç”¨ä¸ä¼šç«‹åˆ»æ‰§è¡Œï¼Œåƒæ˜¯è¢«æ³¨å†Œåˆ°äº†å½“å‰å‡½æ•°ä¸­ï¼Œç­‰åˆ°å½“å‰å‡½æ•°è¿”å›ä¹‹å‰æŒ‰ç…§å…ˆè¿›åå‡ºï¼ˆFirst In Last Outï¼‰é¡ºåºè°ƒç”¨æ‰€æœ‰æ³¨å†Œçš„å‡½æ•°ã€‚ deferåå‡ºç°å¤šæ¬¡è°ƒç”¨ï¼Œåªé’ˆå¯¹æœ€åé‚£ä¸ªå‡½æ•°ä¼šè¢«å»¶è¿Ÿã€‚æ¯”å¦‚ defer fn()()ï¼Œfn()è¿”å›ä¸€ä¸ªé—­åŒ…å‡½æ•°ã€‚ 1 2 3 4 5 6 7 // defer fn()() func fn() func() { return func() { println(\u0026#34;defer\u0026#34;) } } è¢«å»¶è¿Ÿè°ƒç”¨çš„å‡½æ•°çš„å‚æ•°ä¼šç«‹åˆ»æ±‚å€¼ã€‚æ¯”å¦‚ defer close(getChan())ã€‚ æ³¨å†Œçš„deferä¼šåœ¨ä»¥ä¸‹ä¸‰ä¸ªåœ°æ–¹è¢«è¿è¡Œï¼š (1)å‡½æ•°è¿”å›ä¹Ÿå°±æ˜¯ return æ—¶ï¼Œä¸€èˆ¬æƒ…å†µåœ¨deferreturn()å‡½æ•°ä¸­ã€‚ (2)panic() å‡½æ•°è§¦å‘æ—¶ã€‚ (3)runtime.Goexit() å‡½æ•°è¢«è°ƒç”¨æ—¶ã€‚ deferç»“æ„ deferå­˜åœ¨ä¸‰ç§æƒ…å†µï¼š (1)å †åˆ†é… defer ç»“æ„ä½“ï¼Œä½¿ç”¨ defer é“¾è¡¨ã€‚ (2)defer ç»“æ„ä½“åˆ†é…åœ¨å‡½æ•°è°ƒç”¨æ ˆä¸Šï¼Œä½¿ç”¨ defer é“¾è¡¨ã€‚ (3)ä½¿ç”¨ open-coded defer å½¢å¼ï¼Œä¸ç”¨å †åˆ†é…ä¹Ÿä¸ç”¨ defer é“¾è¡¨ã€‚ ä½†æ˜¯è¿˜æ˜¯éœ€è¦ä¸€ä¸ª _defer ç»“æ„ä½“è®°å½•ç›¸å…³ä¿¡æ¯ï¼Œè¯¥é“¾è¡¨è®°å½•åœ¨å…¨å±€é“¾è¡¨åé¢å­˜å‚¨çš„è¿™ä¸ªå‡½æ•°æ³¨å†Œçš„æ‰€æœ‰ defer ä¿¡æ¯ã€‚ è¯¥é“¾è¡¨åœ¨ panic å‘ç”Ÿæ˜¯æˆ– runtime.Goexit() è§¦å‘æ—¶ï¼Œé€šè¿‡æ ˆæ‰«æå½¢å¼è¢«è¿½åŠ åˆ° goroutine._panic åé¢ã€‚ æ–‡ä»¶ä½ç½®ï¼šgo1.19.3/src/runtime/runtime2.goã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 // A _defer holds an entry on the list of deferred calls. // If you add a field here, add code to clear it in deferProcStack. // This struct must match the code in cmd/compile/internal/ssagen/ssa.go:deferstruct // and cmd/compile/internal/ssagen/ssa.go:(*state).call. // Some defers will be allocated on the stack and some on the heap. // All defers are logically part of the stack, so write barriers to // initialize them are not required. All defers must be manually scanned, // and for heap defers, marked. type _defer struct { // è¡¨ç¤ºæœ‰ä¸ª panic æˆ–è€… runtime.Goexit() å‡½æ•°è§¦å‘å¼€å§‹æ‰§è¡Œè¯¥deferå‡½æ•°ã€‚ started bool // startedå’Œ_panicè¢«ç”¨äºpanicå‘ç”Ÿæ—¶ï¼Œæ­£å¸¸è¿™é‡Œæ˜¯ false // æ˜¯å¦ä¸ºå †åˆ†é…ï¼Œæ˜¯(true) å¦(false) // 1. å †åˆ†é…åˆ™æ˜¯é€šè¿‡ deferproc() å‡½æ•°æ³¨å†Œçš„deferé“¾è¡¨ // 2. æ ˆåˆ†é…åˆ™æ˜¯é€šè¿‡ deferprocStack() å‡½æ•°æ³¨å†Œdeferé“¾è¡¨ heap bool // å †åˆ†é…æ—¶ä¼šè°ƒç”¨ deferproc() å‡½æ•° // openDefer indicates that this _defer is for a frame with open-coded // defers. We have only one defer record for the entire frame (which may // currently have 0, 1, or more defers active). // // æ˜¯å¦æ˜¯å±•å¼€æ–¹å¼\topen-coded defer // å±•å¼€æ–¹å¼çš„ä¿¡æ¯è®°å½•åœ¨fdã€varpã€framepcä¸­ openDefer bool // spå’Œpcç”¨äºåœ¨å‘ç”Ÿ panic() å¹¶ä¸”æœ‰ recover() å‡½æ•°æ¢å¤çš„æƒ…å†µä¸‹ç¨‹åºéœ€è¦è·³è½¬åˆ°å“ªé‡Œï¼Œ // æ³¨æ„ä¸€æ—¦ä½¿ç”¨è¿™é‡Œè·³è½¬é‚£ä¹ˆ return0() å‡½æ•°å°†è¿”å›1è¡¨ç¤ºåé¢æ¥åˆ°æ‰§è¡Œ deferreturn() å‡½æ•°ã€‚ // getcallersp()å‡½æ•°è·å–è°ƒç”¨è€…çš„SPï¼Œä¹Ÿå°±æ˜¯è°ƒç”¨deferproc()å‡½æ•°ä¹‹å‰çš„SPå¯„å­˜å™¨çš„å€¼(è°ƒç”¨è€…å‡½æ•°SPå¯„å­˜å™¨å€¼)ï¼Œ // ç”¨äºè®°å½•å½“å‰å‡½æ•°çš„rspæ ˆä¿¡æ¯ï¼Œåœ¨deferreturn()å‡½æ•°ä¸­ç”¨äºåˆ¤æ–­deferæ˜¯å¦ç”±å½“å‰å‡½æ•°æ³¨å†Œã€‚ // è¿™ä¸ªå€¼æœ‰ä¸¤ä¸ªç”¨é€”ï¼š // 1. åœ¨deferreturn()å‡½æ•°æ‰§è¡Œdeferå‡½æ•°æ—¶ç”¨æ¥åˆ¤æ–­è¯¥deferæ˜¯ä¸æ˜¯è¢«å½“å‰å‡½æ•°æ³¨å†Œçš„ã€‚ // 2. åœ¨æ‰§è¡Œrecover()å‡½æ•°çš„æ—¶å€™ç”¨æ¥è¿˜åŸæ ˆæŒ‡é’ˆã€‚ sp uintptr // sp at time of defer\tSPå¯„å­˜å™¨çš„å€¼ // getcallerpc()å‡½æ•°è·å–è°ƒç”¨è€…æŒ‡ä»¤æŒ‡é’ˆçš„ä½ç½®ï¼Œä»è°ƒç”¨è€…è§†è§’çœ‹æ¥å°±æ˜¯CALL runtime.deferprocåé¢çš„é‚£æ¡æŒ‡ä»¤çš„åœ°å€ // ä¸»è¦ç”¨é€”ï¼šåœ¨æ‰§è¡Œrecover()å‡½æ•°çš„æ—¶å€™è¿˜åŸIPå¯„å­˜å™¨æŒ‡ä»¤æŒ‡é’ˆ pc uintptr // pc at time of defer\tIPå¯„å­˜å™¨çš„å€¼ // open-coded defers æ—¶è¯¥å€¼æ˜¯nilã€‚ // æ³¨æ„ï¼šåœ¨å‰é¢1.12ç‰ˆæœ¬ä¸­fnçš„ç±»å‹æ˜¯*funcvalï¼Œè€Œè¿™é‡Œæ˜¯func()å‡½æ•°ç±»å‹ï¼Œ // æ‰€æœ‰deferåé¢çš„ä¸æ˜¯func()å½¢å¼çš„éƒ½ä¼šåœ¨å°è£…ä¸€å±‚ï¼Œå½¢æˆFunction Valueå½¢å¼ã€‚ // å› ä¸ºå­˜åœ¨è¿™æ ·ä¸€å±‚å°è£…ï¼Œæ—§ç‰ˆçš„ siz å­—æ®µå¯ä»¥ä¸¢å¼ƒã€‚ fn func() // can be nil for open-coded defers // æ˜¯è§¦å‘deferå‡½æ•°æ‰§è¡Œçš„panicæŒ‡é’ˆï¼Œæ­£å¸¸æµç¨‹æ‰§è¡Œdeferæ—¶å®ƒå°±æ˜¯nil // _panicçš„å€¼æ˜¯åœ¨å½“å‰goroutineå‘ç”Ÿpanicåï¼Œruntimeåœ¨æ‰§è¡Œdeferå‡½æ•°æ—¶ï¼Œå°†è¯¥æŒ‡é’ˆæŒ‡å‘å½“å‰çš„_panicç»“æ„ // æœ‰panicè§¦å‘æ—¶ï¼Œ_panicæŒ‡å‘è§¦å‘çš„panicï¼Œè®°å½•å½“å‰è§¦å‘è¿™ä¸ªdeferçš„panicç»“æ„ä½“ã€‚ _panic *_panic // panic that is running defer // linkæŒ‡é’ˆç”¨æ¥æŒ‡å‘ä¸‹ä¸€ä¸ª_deferç»“æ„ï¼Œä»è€Œå½¢æˆé“¾è¡¨ link *_defer // next defer on G; can point to either heap or stack!\t// If openDefer is true, the fields below record values about the stack // frame and associated function that has the open-coded defer(s). sp // above will be the sp for the frame, and pc will be address of the // deferreturn call in the function. // // å¦‚æœ openDefer ä¸ºçœŸï¼Œåˆ™ä¸‹é¢çš„å­—æ®µè®°å½•æœ‰å…³æ ˆå¸§å’Œå…·æœ‰open-coded deferçš„å…³è”å‡½æ•°çš„å€¼ // ä¸‹é¢å­—æ®µè®°å½•ç€é€šè¿‡æ ˆæ‰«æå½¢å¼çš„æ‰€æœ‰deferä¿¡æ¯ï¼Œä»¥ä¾¿æ‰§è¡Œå‘ç”Ÿå¼‚å¸¸æ˜¯èƒ½æ­£ç¡®æ‰¾åˆ°æ‰€æœ‰çš„defer fd unsafe.Pointer // funcdata for the function associated with the frame\tvarp uintptr // value of varp for the stack frame // framepc is the current pc associated with the stack frame. Together, // with sp above (which is the sp associated with the stack frame), // framepc/sp can be used as pc/sp pair to continue a stack trace via // gentraceback(). framepc uintptr } å †åˆ†é… deferproc() å‡½æ•°ç”¨äºæ³¨å†Œ defer å‡½æ•°ï¼Œä¹Ÿæ˜¯å †åˆ†é…çš„ç›¸å…³å‡½æ•°ã€‚ è¿™ç§å½¢å¼æ³¨å†Œçš„ defer æ˜¯æœ€æ…¢çš„ã€‚ deferproc() å‡½æ•°çš„å¤§è‡´é€»è¾‘ï¼š æŠŠdeferå‡½æ•°çš„ç›¸å…³æ•°æ®å­˜å‚¨åœ¨runtime._deferè¿™ä¸ªç»“æ„ä¸­å¹¶æ·»åŠ åˆ°å½“å‰goroutineçš„deferé“¾è¡¨å¤´éƒ¨ã€‚ é€šè¿‡deferproc()å‡½æ•°æ³¨å†Œå®Œä¸€ä¸ªdeferå‡½æ•°åï¼Œdeferproc()å‡½æ•°çš„è¿”å›å€¼æ˜¯0ï¼ˆè¯¥å‡½æ•°å¹¶æ²¡æœ‰è¿”å›å€¼ï¼Œåªæ˜¯é€šè¿‡return0()å‡½æ•°æŠŠ0å†™å…¥AXå¯„å­˜å™¨ï¼‰ã€‚ åé¢å¦‚æœå‘ç”Ÿäº†panicï¼Œåˆé€šè¿‡è¯¥deferå‡½æ•°æˆåŠŸrecover()ï¼Œé‚£ä¹ˆæŒ‡ä»¤æŒ‡é’ˆå’Œæ ˆæŒ‡é’ˆå°±ä¼šæ¢å¤åˆ°è¿™é‡Œè®¾ç½®çš„pcã€spå¤„ï¼Œçœ‹èµ·æ¥å°±åƒåˆšä»runtime.deferproc()å‡½æ•°è¿”å›ï¼Œåªä¸è¿‡è¿”å›å€¼ä¸º1ï¼Œç¼–è¯‘å™¨æ’å…¥çš„ifè¯­å¥ç»§è€Œä¼šè·³è¿‡å‡½æ•°ä½“ï¼Œä»…æ‰§è¡Œæœ«å°¾çš„deferreturn()å‡½æ•°ã€‚ deferproc() åˆ›å»ºä¸€ä¸ªæ–°çš„ deferå‡½æ•° fnï¼Œå®ƒæ²¡æœ‰å‚æ•°å’Œè¿”å›å€¼ã€‚ ç¼–è¯‘å™¨å°†deferè¯­å¥è½¬æ¢æˆå¯¹è¿™ä¸ªå‡½æ•°thisè°ƒç”¨ã€‚ fnæ˜¯æ¥è‡ªdefer func()åé¢çš„å‡½æ•°å…¶ç»“æ„æ˜¯ä¸€ä¸ªfuncvalæŒ‡é’ˆã€‚ å‚æ•°ï¼šfn func()ï¼Œå¯ä»¥ç†è§£ä¸ºdefer a(1)è¿™ç§å½¢å¼å°è£…æˆdefer func(){a(1)}å½¢å¼çš„è°ƒç”¨ã€‚ ç›¸æ¯”äºä¹‹å‰çš„deferproc()å‡½æ•°ï¼Œè¿™é‡Œå°‘äº†å‚æ•°çš„æ‹·è´ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 // Create a new deferred function fn, which has no arguments and results. // The compiler turns a defer statement into a call to this. func deferproc(fn func()) { // 1) è·å–å½“å‰æ­£åœ¨è¿è¡Œçš„g gp := getg()\t// gp.m.curgè®°å½•å½“å‰å·¥ä½œçº¿ç¨‹æ­£åœ¨è¿è¡Œçš„gï¼Œå¦‚æœä¸ç›¸ç­‰é‚£è¯´æ˜åº”è¯¥æ˜¯åœ¨g0æ ˆ if gp.m.curg != gp {\t// go code on the system stack can\u0026#39;t defer throw(\u0026#34;defer on system stack\u0026#34;) } // 2) è·å–æˆ–è€…åˆ›å»ºä¸€ä¸ªdeferï¼Œæ³¨æ„è¯¥deferç»“æ„ä½“æ˜¯åœ¨ã€å †ã€‘ä¸Šåˆ†é…çš„ d := newdefer()\tif d._panic != nil { // ä»ç¼“å­˜ä¸­è·å–çš„å­˜åœ¨å…¶ä»–panicè§¦å‘æ ‡è®° throw(\u0026#34;deferproc: d.panic != nil after newdefer\u0026#34;) } // 3) æ¯”å¦‚ç°åœ¨æœ‰ä¸‰ä¸ªdeferéœ€è¦æ³¨å†Œï¼šdefer 1, defer 2, defer 3 // g._defer = 3 é€šè¿‡linkå½¢æˆé“¾è¡¨ 3 -\u0026gt; 2 -\u0026gt; 1 æ³¨å†Œé¡ºåº // æ‰§è¡Œé¡ºåºï¼š3 -\u0026gt; 2 -\u0026gt; 1 // goroutineä¸Š_deferå§‹ç»ˆå­˜å‚¨çš„æ˜¯æœ€æ–°çš„_deferç»“æ„ d.link = gp._defer // è®°å½•goroutineä¸Šçš„deferé“¾è¡¨ä¿¡æ¯ï¼Œgp._deferè®°å½•çš„æ˜¯é“¾è¡¨çš„æœ€åä¸€ä¸ª_deferç»“æ„ä½“çš„æŒ‡é’ˆ gp._defer = d // å½“å‰goroutineé“¾æ¥ä¸Šdeferé“¾è¡¨ï¼Œgp._deferå§‹ç»ˆè®°å½•çš„æ˜¯æœ€åä¸€ä¸ª // 4) è¿™é‡Œéƒ½æ˜¯func()å½¢å¼çš„é—­åŒ…ï¼Œä¸æ˜¯è¯¥å½¢å¼çš„ä¼šåœ¨å¤–å±‚å°è£…ä¸€å±‚ d.fn = fn // è®°å½•å½“å‰deferæ³¨å†Œå‡½æ•° // 5) getcallerpc()å‡½æ•°è·å–è°ƒç”¨è€…æŒ‡ä»¤æŒ‡é’ˆçš„ä½ç½®ï¼Œ // ä»è°ƒç”¨è€…è§†è§’çœ‹æ¥å°±æ˜¯ã€CALL runtime.deferprocã€‘åé¢çš„é‚£æ¡æŒ‡ä»¤çš„åœ°å€ // ä¸»è¦ç”¨é€”ï¼šåœ¨æ‰§è¡Œrecover()å‡½æ•°çš„æ—¶å€™è¿˜åŸæŒ‡ä»¤æŒ‡é’ˆ d.pc = getcallerpc() // è®°å½•å½“å‰æ³¨å†Œdeferå‡½æ•°æ—¶çš„ä¸‹ä¸€æ¡æŒ‡ä»¤åœ°å€ IPåœ°å€ // We must not be preempted between calling getcallersp and // storing it to d.sp because getcallersp\u0026#39;s result is a // uintptr stack pointer. // // 6) getcallersp()å‡½æ•°è·å–è°ƒç”¨è€…çš„SPï¼Œä¹Ÿå°±æ˜¯è°ƒç”¨deferproc()å‡½æ•°ä¹‹å‰çš„SPå¯„å­˜å™¨çš„å€¼ // è¿™ä¸ªå€¼æœ‰ä¸¤ä¸ªç”¨é€”ï¼š // 1. åœ¨deferreturn()å‡½æ•°æ‰§è¡Œdeferå‡½æ•°æ—¶ç”¨æ¥åˆ¤æ–­è¯¥deferæ˜¯ä¸æ˜¯è¢«å½“å‰å‡½æ•°æ³¨å†Œçš„ // 2. åœ¨æ‰§è¡Œrecover()å‡½æ•°çš„æ—¶å€™ç”¨æ¥è¿˜åŸæ ˆæŒ‡é’ˆ d.sp = getcallersp() // è®°å½•å½“å‰è°ƒç”¨å‡½æ•°çš„rspæ ˆä¿¡æ¯ SPæ ˆé¡¶ // deferproc returns 0 normally. // a deferred func that stops a panic // makes the deferproc return 1. // the code the compiler generates always // checks the return value and jumps to the // end of the function if deferproc returns != 0. // // 7) deferproc æ­£å¸¸è¿”å› 0 // ä¸€ä¸ªåœæ­¢paincçš„deferå‡½æ•°ä½¿ deferproc è¿”å› 1 // ç¼–è¯‘å™¨ç”Ÿæˆçš„ä»£ç æ€»æ˜¯æ£€æŸ¥è¿”å›å€¼ï¼Œå¦‚æœ deferproc returns != 0 åˆ™è·³è½¬åˆ°å‡½æ•°çš„æœ«å°¾ return0()\t// æ˜¯å¦æ”¹æ‰deferreturnå‡½æ•° // No code can go here - the C return register has // been set and must not be clobbered. // return0() å‡½æ•°æŠŠè¿”å›å€¼0æˆ–1å†™å…¥ã€AXã€‘å¯„å­˜å™¨ä¸­ } newdefer() è¯¥å‡½æ•°ç”¨å¤„åˆ›å»º_deferç»“æ„ä½“ã€‚ è¯¥å‡½æ•°ä¸ºäº†é¿å…é¢‘ç¹çš„å †åˆ†é…_deferç»“æ„ä½“è€Œé‡‡ç”¨çš„ç¼“å­˜æ± ã€‚ è¦é‡Šæ”¾ defer éœ€è¦è°ƒç”¨ freedefer() å‡½æ•°ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 // Allocate a Defer, usually using per-P pool. // Each defer must be released with freedefer. The defer is not // added to any defer chain yet. func newdefer() *_defer { var d *_defer // åˆå§‹åŒ–ä¸€ä¸ªå˜é‡ï¼Œæ­¤æ—¶ä¸ºnil mp := acquirem() // è·å–å½“å‰çš„Må¹¶ç¦æ­¢è¢«æŠ¢å  pp := mp.p.ptr() // è·å–å½“å‰çš„P // len(pp.deferpool) == 0ï¼šå½“å‰Pä¸Šçš„å¯ç”¨deferç»“æ„å¦‚æœä¸ºç©º // sched.deferpool != nilï¼šå½“å‰å…¨å±€sched.deferpoolçš„å¯ç”¨deferä¸ä¸ºç©º // Pä¸Šçš„deferpoolæ˜¯åˆ‡ç‰‡[]*_deferï¼Œ // schedä¸Šçš„æ˜¯é“¾è¡¨å½¢å¼*_defer if len(pp.deferpool) == 0 \u0026amp;\u0026amp; sched.deferpool != nil {\t// æŠŠå…¨å±€çš„deferæ‹¿éƒ¨åˆ†æ”¾åˆ°Pçš„deferä¸­å¤‡ç”¨ lock(\u0026amp;sched.deferlock) // é”ä½sched.deferlock // å¦‚æœå½“å‰Pä¸Šçš„é•¿åº¦ \u0026lt; å…¶å®¹é‡çš„ä¸€åŠ å¹¶ä¸” å…¨å±€sched.deferpoolå­˜åœ¨ // è¿™é‡Œçš„å¾ªç¯ä¿è¯Pæœ¬åœ°æ± å­çš„deferå¤§äºä¸€åŠ for len(pp.deferpool) \u0026lt; cap(pp.deferpool)/2 \u0026amp;\u0026amp; sched.deferpool != nil { d := sched.deferpool // ä»schedæ‹¿åˆ°é“¾è¡¨ä¿¡æ¯ sched.deferpool = d.link // æŠŠå½“å‰é“¾è¡¨çš„ä¸Šä¸€ä¸ªè¿”å›ç»™schedï¼Œè¿™æ ·å°±å»ä¸‹äº†æœ€åä¸€ä¸ªdeferç»“æ„ d.link = nil // æŠŠå½“å‰çš„deferç»“æ„linkç»™é‡ç½®nilï¼Œè¡¨ç¤ºæ— é“¾æ¥åˆ°å…¶ä»–defer pp.deferpool = append(pp.deferpool, d) // æŠŠå–ä¸‹çš„è¿™ä¸ªæ”¾å…¥Pçš„deferæ± å­ä¸­ } unlock(\u0026amp;sched.deferlock) // è§£é” } // åˆ¤æ–­å½“å‰Pä¸­çš„deferæ± å­æ˜¯å¦å­˜åœ¨ç©ºé—²çš„deferç»“æ„ if n := len(pp.deferpool); n \u0026gt; 0 { d = pp.deferpool[n-1] // å–Pæœ€åä¸€ä¸ªdeferç»“æ„ // è¿™ä¸€æ­¥æ˜¯ä¸ºäº†å¸®åŠ©GC pp.deferpool[n-1] = nil // æŠŠå–ä¸‹çš„è¿™ä¸ªdeferä»Pçš„ç©ºé—²æ± å­ä¸­é‡ç½®ä¸ºnil pp.deferpool = pp.deferpool[:n-1] // ç¼©çŸ­Pç©ºé—²æ± çš„é•¿åº¦ } releasem(mp) // å–æ¶ˆå½“å‰Mç¦æ­¢è¢«æŠ¢å é” mp, pp = nil, nil // å¸®åŠ©GCï¼Œæ¸…é™¤æŒ‡é’ˆå¼•ç”¨ // å¦‚æœä¸Šé¢æ²¡æœ‰æ‰¾åˆ°ç©ºé—²çš„ï¼Œé‚£ä¹ˆå°±ä½¿ç”¨new()å‡½æ•°è‡ªå·±åˆ›å»ºä¸€ä¸ª // æ³¨æ„è¿™é‡Œæ˜¯new()å‡½æ•°åœ¨å †ä¸Šåˆ†é…äº†ä¸€ä¸ª_deferç»“æ„ä½“ if d == nil { // Allocate new defer. d = new(_defer) } d.heap = true // æ ‡è®°å½“å‰deferæ˜¯å †åˆ†é… return d } return0() return0() æ˜¯ä¸€ä¸ªå­˜æ ¹ï¼Œç”¨äºä» deferproc() è¿”å› 0ã€‚ å®ƒåœ¨ deferproc() çš„æœ€åè¢«è°ƒç”¨ï¼Œä»¥é€šçŸ¥è°ƒç”¨ Go å‡½æ•°å®ƒä¸åº”è¯¥è·³è½¬åˆ° deferreturn()ã€‚ å¼‚å¸¸æƒ…å†µä¸‹ return0() å‡½æ•°ä¼šè¿”å› 1ï¼Œæ­¤æ—¶ GO å°±ä¼šè·³è½¬åˆ°æ‰§è¡Œ deferreturn()ã€‚ ä¹Ÿå°±æ˜¯ panic å‘ç”Ÿæ—¶ recover() å‡½æ•°åˆæ¢å¤äº†ï¼Œæ¥åˆ°æ‰§è¡Œæ—¶è¿™é‡Œä¼šè¿”å› 1ï¼Œè¡¨ç¤ºå»æ‰§è¡Œ deferreturn() å‡½æ•°å¤„ç†å‰©ä¸‹çš„ deferã€‚ 1 2 3 4 5 6 // return0 is a stub used to return 0 from deferproc. // It is called at the very end of deferproc to signal // the calling Go function that it should not jump // to deferreturn. // in asm_*.s func return0() æ ˆåˆ†é… ç›¸æ¯”å †ä¸Šåˆ†é…ï¼Œæ ˆä¸Šåˆ†é…åšäº†ä¸€ç‚¹ä¼˜åŒ–ï¼Œå³æŠŠ runtime._defer ç»“æ„åˆ†é…åˆ°å½“å‰å‡½æ•°çš„æ ˆå¸§ä¸Šã€‚ å¾ˆæ˜æ˜¾è¿™ä¸é€‚åˆäºå¾ªç¯ä¸­çš„ deferï¼Œå¾ªç¯ä¸­çš„ defer ä»ç„¶éœ€è¦é€šè¿‡ deferproc() å‡½æ•°å®ç°ï¼Œè¿™ç§ä¼˜åŒ–åªé€‚åˆç”¨äºåªä¼šæ‰§è¡Œä¸€æ¬¡çš„ deferã€‚ ç¼–è¯‘å™¨é€šè¿‡ runtime.deferprocStack() å‡½æ•°æ¥æ‰§è¡Œè¿™ç±» defer çš„æ³¨å†Œï¼Œç›¸æ¯”äº runtime.deferproc() å‡½æ•°ï¼Œ å°‘äº†é€šè¿‡ç¼“å†²æ± æˆ–å †åˆ†é… _defer ç»“æ„çš„æ­¥éª¤ï¼Œæ€§èƒ½æ–¹é¢è¿˜æ˜¯ç¨æœ‰æå‡çš„ã€‚ deferprocStack è¯¥å‡½æ•°ç”¨äº_deferç»“æ„ä½“åœ¨å‡½æ•°æ ˆä¸Šåˆ†é…æ—¶ï¼Œéœ€è¦æŠŠè¿™ä¸ª_deferè¿½åŠ åˆ°å½“å‰gçš„_deferä¸Šå»ï¼Œä»¥åŠåˆå§‹åŒ–ä¸€äº›ä¿¡æ¯ã€‚ è¯¥å‡½æ•°çš„åŠŸèƒ½å’Œdeferproc()å‡½æ•°åŠŸèƒ½ç±»ä¼¼ï¼Œå”¯ä¸€åŒºåˆ«å°±æ˜¯fnæ˜¯åœ¨è°ƒç”¨deferprocStack()å‡½æ•°å‰å°±è¢«è®¾ç½®åœ¨è°ƒç”¨æ ˆä¸Šã€‚ deferprocStack() å°†ä¸€ä¸ªæ–°çš„å»¶è¿Ÿå‡½æ•°ä¸å †æ ˆä¸Šçš„å»¶è¿Ÿè®°å½•è¿›è¡Œæ’é˜Ÿã€‚ runtime._defer ç»“æ„ä¸­æ–°å¢äº†ä¸€ä¸ª bool å‹çš„å­—æ®µ heap æ¥è¡¨ç¤ºæ˜¯å¦ä¸ºå †ä¸Šåˆ†é…ï¼Œå¯¹äºè¿™ç§æ ˆä¸Šåˆ†é…çš„ _defer ç»“æ„ï¼Œ deferreturn() å‡½æ•°å°±ä¸ä¼šç”¨ freedefer() å‡½æ•°è¿›è¡Œé‡Šæ”¾äº†ã€‚å› ä¸ºç¼–è¯‘å™¨åœ¨æ ˆå¸§ä¸Šå·²ç»æŠŠ _defer ç»“æ„çš„æŸäº›å­—æ®µåŒ…æ‹¬åé¢è¿½åŠ çš„ fn å‚æ•°éƒ½å‡†å¤‡å¥½äº†ï¼Œ æ‰€ä»¥ deferprocStack() å‡½æ•°è¿™é‡Œåªéœ€ä¸ºå‰©ä½™çš„å‡ ä¸ªå­—æ®µèµ‹å€¼ï¼Œä¸ deferproc() å‡½æ•°çš„é€»è¾‘åŸºæœ¬ä¸€è‡´ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 // deferprocStack queues a new deferred function with a defer record on the stack. // The defer record must have its fn field initialized. // All other fields can contain junk. // Nosplit because of the uninitialized pointer fields on the stack. // //go:nosplit func deferprocStack(d *_defer) { gp := getg() // è·å–å½“å‰g if gp.m.curg != gp { // go code on the system stack can\u0026#39;t defer throw(\u0026#34;defer on system stack\u0026#34;) } // fn is already set. // The other fields are junk on entry to deferprocStack and // are initialized here. // // fnåœ¨è°ƒç”¨deferprocStack()å‡½æ•°å‰å·²è¢«è®¾ç½® // å…¶ä»–å­—æ®µåœ¨è¿›å…¥deferprocStack()æ—¶æ˜¯åƒåœ¾å­—æ®µï¼Œå¹¶åœ¨æ­¤å¤„åˆå§‹åŒ– d.started = false // å½“å‰deferæœªå¼€å§‹ d.heap = false // ä¸æ˜¯å †åˆ†é… d.openDefer = false // ä¸æ˜¯ open-coded defer å½¢å¼ d.sp = getcallersp() // è®°å½•å½“å‰è¢«è°ƒç”¨å‡½æ•°çš„ä¸‹ä¸€æ¡æŒ‡ä»¤å¤„ d.pc = getcallerpc() // è®°å½•å½“å‰è¢«è°ƒç”¨å‡½æ•°çš„rspå¯„å­˜å™¨ä¿¡æ¯ d.framepc = 0 d.varp = 0 // The lines below implement: // d.panic = nil // d.fd = nil // d.link = gp._defer // gp._defer = d // But without write barriers. The first three are writes to // the stack so they don\u0026#39;t need a write barrier, and furthermore // are to uninitialized memory, so they must not use a write barrier. // The fourth write does not require a write barrier because we // explicitly mark all the defer structures, so we don\u0026#39;t need to // keep track of pointers to them with a write barrier. // // ä¸‹é¢çš„è¡Œå®ç°ï¼š // d.panic = nil // d.fd = nil // d.link = gp._defer // gp._defer = d // ä½†æ²¡æœ‰ä¹¦å†™éšœç¢ã€‚å‰ä¸‰ä¸ªæ˜¯å¯¹æ ˆçš„å†™å…¥ï¼Œå› æ­¤å®ƒä»¬ä¸éœ€è¦å†™å±éšœï¼Œ // è€Œä¸”æ˜¯å¯¹æœªåˆå§‹åŒ–å†…å­˜çš„å†™å…¥ï¼Œæ‰€ä»¥å®ƒä»¬ä¸èƒ½ä½¿ç”¨å†™å±éšœã€‚ // ç¬¬å››æ¬¡å†™å…¥ä¸éœ€è¦å†™å±éšœï¼Œå› ä¸ºæˆ‘ä»¬æ˜¾å¼æ ‡è®°äº†æ‰€æœ‰çš„deferç»“æ„ï¼Œ // æ‰€ä»¥æˆ‘ä»¬ä¸éœ€è¦ç”¨å†™å±éšœè·Ÿè¸ªæŒ‡å‘å®ƒä»¬çš„æŒ‡é’ˆ // å› ä¸ºdç»“æ„æ˜¯åœ¨æ ˆä¸Šåˆ†é…çš„ï¼ŒGCä¼šæ‰«ægoroutineæ ˆ *(*uintptr)(unsafe.Pointer(\u0026amp;d._panic)) = 0\t*(*uintptr)(unsafe.Pointer(\u0026amp;d.fd)) = 0 *(*uintptr)(unsafe.Pointer(\u0026amp;d.link)) = uintptr(unsafe.Pointer(gp._defer))\t*(*uintptr)(unsafe.Pointer(\u0026amp;gp._defer)) = uintptr(unsafe.Pointer(d)) return0() // No code can go here - the C return register has // been set and must not be clobbered. } open code defer ç¼–è¯‘å™¨ç›´æ¥å°† defer å‡½æ•°æ³¨å…¥åˆ°å‡½æ•°è°ƒç”¨ä»£ç ä¸­ï¼Œè¿™æ ·æ—¢ä¸ä½¿ç”¨å †åˆ†é…_deferä¹Ÿä¸ä½¿ç”¨é“¾è¡¨é“¾æ¥_deferã€‚ Go1.14 åé¢çš„ç‰ˆæœ¬æ”¯æŒ open code deferã€‚ Go1.14é€šè¿‡å¢åŠ ä¸€ä¸ªæ ‡è¯†å˜é‡dfæ¥è§£å†³è¿™ç±»é—®é¢˜ï¼Œç”¨dfä¸­çš„æ¯ä¸€ä½å¯¹åº”æ ‡è¯†å½“å‰å‡½æ•°ä¸­çš„ä¸€ä¸ªdeferå‡½æ•°æ˜¯å¦è¦æ‰§è¡Œã€‚(8bitä½) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 func A(i int) { defer A1(i, 2*i) if (i \u0026gt; 1) { defer A2(\u0026#34;Hello\u0026#34;, \u0026#34;eggo\u0026#34;) } // code to do something return } func A1(a,b int){ //...... } func A2(m,n string){ //...... } ç»è¿‡ç¼–è¯‘å™¨è½¬æ¢åã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 func A(i int){ var df byte //A1çš„å‚æ•° var a, b int = i, 2*i df |= 1 //A2çš„å‚æ•° var m,n string = \u0026#34;Hello\u0026#34;, \u0026#34;eggo\u0026#34; if i \u0026gt; 1 { df |= 2 } //code to do something //åˆ¤æ–­A2æ˜¯å¦è¦è°ƒç”¨ if df\u0026amp;2 \u0026gt; 0 { df = df\u0026amp;^2 A2(m, n) } //åˆ¤æ–­A1æ˜¯å¦è¦è°ƒç”¨ if df\u0026amp;1 \u0026gt; 0 { df = df\u0026amp;^1 A1(a, b) } return //çœç•¥éƒ¨åˆ†ä¸recoverç›¸å…³çš„é€»è¾‘ } Go1.14æŠŠdeferå‡½æ•°åœ¨å½“å‰å‡½æ•°å†…å±•å¼€å¹¶ç›´æ¥è°ƒç”¨ï¼Œè¿™ç§æ–¹å¼è¢«ç§°ä¸ºopen coded deferï¼Œè¿™ç§æ–¹å¼ä¸ä»…ä¸ç”¨åˆ›å»º_deferç»“æ„ä½“ï¼Œä¹Ÿè„±ç¦»äº†deferé“¾è¡¨çš„æŸç¼šï¼Œä¸è¿‡è¿™ç§æ–¹å¼ä¾ç„¶ä¸é€‚ç”¨äºå¾ªç¯ä¸­çš„deferï¼Œæ‰€ä»¥1.12ç‰ˆæœ¬deferçš„å¤„ç†æ–¹å¼æ˜¯ä¸€ç›´ä¿ç•™çš„ã€‚ open code defer æ»¡è¶³çš„æ¡ä»¶ æ²¡æœ‰ç¦ç”¨ç¼–è¯‘å™¨ä¼˜åŒ–ï¼Œå³æ²¡æœ‰è®¾ç½® -gcflags \u0026quot;-N\u0026quot;ã€‚ å‡½æ•°ä¸­å­˜åœ¨deferçš„ä½¿ç”¨ã€‚ å‡½æ•°å†… defer çš„æ•°é‡ä¸è¶…è¿‡8ä¸ªï¼Œä¸”è¿”å›è¯­å¥(return)ä¸å»¶è¿Ÿè¯­å¥(defer)ä¸ªæ•°çš„æ•°é‡çš„ä¹˜ç§¯ä¸è¶…è¿‡15ã€‚ æ²¡æœ‰deferå‘ç”Ÿåœ¨å¾ªç¯è¯­å¥ä¸­ã€‚ è¿è¡Œdefer deferreturn() å¼€å§‹è¿è¡Œdeferé“¾è¡¨ï¼Œè¯¥å‡½æ•°åœ¨returnå‰è¢«è°ƒç”¨ã€‚ è¯¥å‡½æ•°æ˜¯deferåœ¨å †ä¸Šåˆ†é…å’Œæ ˆä¸Šåˆ†é…æ—¶æœ€åreturnéƒ½ä¼šè°ƒç”¨çš„å‡½æ•°ã€‚ open-coded deferå½¢å¼æ­£ç¡®æƒ…å†µä¸‹æ˜¯ä¸ä¼šè°ƒç”¨deferreturn()å‡½æ•°ï¼Œå¦‚æœè°ƒç”¨è¯¥å‡½æ•°ä¸€å®šæ˜¯æœ‰panic()æˆ–Goexit()å‘ç”Ÿã€‚å› ä¸ºopen-coded deferæ²¡æœ‰deferé“¾è¡¨å¿…é¡»è¦å…ˆä»å‡½æ•°æ ˆä¸­å›æº¯æ‰¾å‡ºdeferç»“æ„å†…å®¹ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 // deferreturn runs deferred functions for the caller\u0026#39;s frame. // The compiler inserts a call to this at the end of any // function which calls defer. // // deferreturn å‡½æ•°ä¸ºè°ƒç”¨è€…çš„æ ˆå¸§è¿è¡Œ defer å‡½æ•° // ç¼–è¯‘å™¨åœ¨è°ƒç”¨ defer å‡½æ•°çš„æœ«å°¾æ’å…¥å¯¹ deferretrun å‡½æ•°çš„è°ƒç”¨ func deferreturn() { // å› ä¸ºå½“å‰gä¸Šçš„deferå­˜å‚¨çš„æ˜¯æœ€æ–°çš„_deferç»“æ„ gp := getg() // è·å–å½“å‰çš„goroutine for { // 1) è·å–goroutineæœ€æ–°çš„_defer // è¿™é‡Œå†³å®šäº†deferæ˜¯å€’å™ï¼Œä¹Ÿå°±æ˜¯åé¢çš„deferå…ˆæ‰§è¡Œï¼Œå‰é¢çš„deferåæ‰§è¡Œ // gp._defer -\u0026gt; defer3 -\u0026gt; defer2 -\u0026gt; defer d := gp._defer // è·å–å½“å‰gåé¢çš„deferé“¾è¡¨ if d == nil { // æ²¡æœ‰é“¾è¡¨åˆ™è¿”å› return } // 2) åˆ¤æ–­ defer å‡½æ•°æ³¨å†Œæ˜¯å¦åœ¨å½“å‰è°ƒç”¨ deferreturn å‡½æ•°çš„æ ˆä¸­ // ä¹Ÿå°±æ˜¯ deferreturn å‡½æ•°åªèƒ½è¿è¡Œå½“å‰è°ƒç”¨è€…å‡½æ•°æ³¨å†Œçš„ defer å‡½æ•° // å‡½æ•°çš„æ ˆSPæ˜¯åœ¨å‡½æ•°å¼€å§‹å°±åˆ†é…çš„ï¼Œåœ¨æœ¬å‡½æ•°å†…è¯¥SPå€¼æ˜¯ä¸ä¼šå‘ç”Ÿå˜åŒ–çš„ sp := getcallersp() // è·å–å½“å‰è°ƒç”¨å‡½æ•°çš„æ ˆå¸§ï¼Œåœ¨Goä¸­å‡½æ•°çš„rspæ ˆæ˜¯å·²å¼€å§‹å°±è¢«é¢„åˆ†é…çš„ // è¿™é‡Œçš„åˆ¤æ–­æ¡ä»¶ä¹Ÿè¡¨æ˜è‡ªå·±å‡½æ•°æ³¨å†Œçš„deferä¸èƒ½è·‘å…¶ä»–å‡½æ•°é‡Œé¢å–è¿è¡Œ if d.sp != sp { // å¦‚æœå’Œæ³¨å†Œçš„deferä¸ä¸€è‡´è¯´æ˜å½“å‰deferä¸æ˜¯è¯¥å‡½æ•°çš„ï¼Œç›´æ¥è¿”å› return } // 3) è¿è¡Œæ³¨å†Œçš„deferå‡½æ•°ï¼Œå¹¶é‡Šæ”¾_deferå¯¹è±¡ // 3.1) open coded deferå½¢å¼ // d.openDeferä¸ºçœŸï¼Œè¯´æ˜å½“å‰æ˜¯ä» gopanic å‡½æ•°çš„ open coded defers è·³è½¬è€Œæ¥ if d.openDefer {\t// æ­¤æ—¶dæ˜¯åŒä¸€ä¸ªå‡½æ•°çš„ä¸€ç¾¤_defer // doneä¸ºtrueï¼Œè¡¨ç¤ºæ²¡æœ‰recoveræˆ–å…¶ä»–ï¼Œè¿™ä¸€ç»„deferéƒ½æ‰§è¡Œå®Œã€‚ // å‰é¢åœ¨panicä¸­å›æº¯æ ˆåç»„è£…äº†ä¸€ç»„deferå‡½æ•°æˆ_deferç»“æ„ï¼Œå…¶ä¸­æŸä¸ªå‡½æ•°çš„recoverç”Ÿæ•ˆäº†ï¼Œ // æœ€åä¼šç»§ç»­æ‰§è¡Œdeferreturn()å‡½æ•°ï¼Œä¼šæ‰¾è¿™é‡Œç»§ç»­æ‰§è¡Œå‰©ä¸‹çš„deferå‡½æ•°ã€‚ done := runOpenDeferFrame(gp, d) // å»è¿è¡Œè¿™ä¸€ç¾¤deferï¼Œç›¸å½“äºå¾ªç¯ // done deferæ˜¯å¦æ‰§è¡Œå®Œï¼Œæ­£å¸¸é€»è¾‘åˆ°è¿™é‡Œæ˜¯æ²¡æœ‰panicçš„ï¼Œå› ä¸ºåˆšä»recoveræ¢å¤è¿‡æ¥æ¥åˆ°æ‰§è¡Œåé¢çš„defer // å¦‚æœä¸Šé¢deferå‡½æ•°ä¸­åˆå‡ºç°panicåˆ™ï¼Œä¸ä¼šå†å›åˆ°è¿™é‡Œäº†ã€‚ if !done { // åªæœ‰å‡ºç°ç¨‹åºé€»è¾‘é”™è¯¯è¿™é‡Œæ‰ä¼šåˆ¤æ–­ä¸ºçœŸ throw(\u0026#34;unfinished open-coded defers in deferreturn\u0026#34;) } // è¿™ä¸€ç»„deferè¿è¡Œå®Œäº†ï¼Œ_deferç»“æ„å¯ä»¥é‡Šæ”¾äº†ã€‚ gp._defer = d.link // ç§»é™¤å½“å‰deferåœ¨gä¸­çš„é“¾æ¥ freedefer(d) // é‡Šæ”¾å½“å‰çš„deferå ç”¨å†…å­˜ // If this frame uses open defers, then this // must be the only defer record for the // frame, so we can just return. // // å¦‚æœæ­¤æ ˆå¸§ä½¿ç”¨open defersï¼Œé‚£ä¹ˆè¿™ä¸€å®šæ˜¯è¯¥æ ˆå¸§çš„å”¯ä¸€å»¶è¿Ÿè®°å½•ï¼Œå› æ­¤æˆ‘ä»¬å¯ä»¥ç›´æ¥è¿”å› return } // 3.2) å †å’Œæ ˆå½¢å¼çš„_deferå¯¹è±¡ï¼Œæ‰§è¡Œå¹¶é‡Šæ”¾_deferå¯¹è±¡ fn := d.fn // è·å–å½“å‰æ³¨å†Œçš„å‡½æ•° d.fn = nil // å¸®åŠ©GC gp._defer = d.link // ç§»é™¤å½“å‰deferåœ¨gä¸­çš„é“¾æ¥ freedefer(d) // é‡Šæ”¾å½“å‰çš„deferå ç”¨å†…å­˜ fn() // æ‰§è¡Œå½“å‰æ³¨å†Œçš„å‡½æ•° } } freedefer() é‡Šæ”¾deferï¼ˆé’ˆå¯¹å †åˆ†é…æƒ…å†µï¼‰ï¼Œè¯¥å‡½æ•°ç”¨äºdeferreturn()æ‰§è¡Œå®Œéœ€è¦å¤„ç†_deferç»“æ„ä½“çš„æ”¶å°¾å·¥ä½œã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 // Free the given defer. // The defer cannot be used after this call. // // This is nosplit because the incoming defer is in a perilous state. // It\u0026#39;s not on any defer list, so stack copying won\u0026#39;t adjust stack // pointers in it (namely, d.link). Hence, if we were to copy the // stack, d could then contain a stale pointer. // //go:nosplit func freedefer(d *_defer) { d.link = nil // è®¾ç½®linkä¸ºnil // After this point we can copy the stack. if d._panic != nil { // å¦‚æœå½“å‰_panicå­˜åœ¨å€¼åˆ™æŠ›å‡ºå¼‚å¸¸ freedeferpanic() // ç›´æ¥æŠ›å‡ºå¼‚å¸¸ } if d.fn != nil { // å¦‚æœå½“å‰fnå­˜åœ¨å€¼åˆ™æŠ›å‡ºå¼‚å¸¸ freedeferfn() // ç›´æ¥æŠ›å‡ºå¼‚å¸¸ } if !d.heap { // å¦‚æœå½“å‰ä¸æ˜¯å †åˆ†é…ï¼Œç›´æ¥è¿”å› return } // ä»¥ä¸‹æ˜¯é’ˆå¯¹deferç»“æ„ä½“æ˜¯å †åˆ†é…çš„æƒ…å†µ mp := acquirem() // è·å–Må¹¶ç¦æ­¢å½“å‰è¢«æŠ¢å  pp := mp.p.ptr() // è·å–P // å½“å‰Pçš„æœ¬åœ°æ± æ»¡äº†ï¼Œéœ€è¦ç§»é™¤ä¸€åŠåˆ°å…¨å±€æ± ä¸­å» // pp.deferpool æ˜¯ä¸€ä¸ªåˆ‡ç‰‡ if len(pp.deferpool) == cap(pp.deferpool) { // è¿™é‡Œè¯´æ˜Pçš„ç©ºé—²æ± æ»¡äº† // Transfer half of local cache to the central cache. // // å°†På¾—ä¸€åŠçš„deferè½¬ç§»åˆ°schedçš„deferç©ºé—²åˆ—è¡¨ä¸­å» // firstï¼šè®°å½•ç¬¬ä¸€ä¸ª_defer // lastï¼šè®°å½•æœ€åä¸€ä¸ª_defer // é€šè¿‡linkå½¢æˆé“¾è¡¨ var first, last *_defer for len(pp.deferpool) \u0026gt; cap(pp.deferpool)/2 {\tn := len(pp.deferpool) d := pp.deferpool[n-1] // æ³¨æ„è¿™é‡Œçš„dæ˜¯å±€éƒ¨å˜é‡ pp.deferpool[n-1] = nil // å¸®åŠ©GC pp.deferpool = pp.deferpool[:n-1] if first == nil { first = d } else { last.link = d } last = d } lock(\u0026amp;sched.deferlock) // åŠ é” last.link = sched.deferpool // æŠŠå…¨å±€çš„é“¾æ¥åˆ°laståé¢ sched.deferpool = first // æŠŠç¬¬ä¸€ä¸ªfirstè¿½åŠ åˆ°å…¨å±€æ± ä¸­ unlock(\u0026amp;sched.deferlock) // è§£é” } *d = _defer{} // æ¸…ç©ºå½“å‰defer pp.deferpool = append(pp.deferpool, d) // æŠŠdæ”¾å…¥Pä¸­çš„ç©ºé—²deferæ± ä¸­ releasem(mp) // å–æ¶ˆMç¦æ­¢è¢«æŠ¢å  mp, pp = nil, nil } runOpenDeferFrame() å±•å¼€å½¢å¼çš„deferå¤„ç†å‡½æ•°ï¼Œè¿è¡Œæ³¨å†Œçš„deferã€‚ ä¸ºå¼€æ”¾ç¼–ç åšäº†ç‰¹æ®Šçš„ä¼˜åŒ–ï¼Œè¿è¡Œæ—¶ä¼šè°ƒç”¨runtime.runOpenDeferFrame()æ‰§è¡Œæ´»è·ƒçš„å¼€æ”¾ç¼–ç å»¶è¿Ÿå‡½æ•°ï¼Œ è¯¥å‡½æ•°ä¼šæ‰§è¡Œä»¥ä¸‹çš„å·¥ä½œï¼š ä»runtime._deferç»“æ„ä½“ä¸­è¯»å– deferBitsã€å‡½æ•° defer æ•°é‡ç­‰ä¿¡æ¯ï¼› å¾ªç¯ä¸­ä¾æ¬¡è¯»å–å‡½æ•°çš„åœ°å€å’Œå‚æ•°ä¿¡æ¯å¹¶é€šè¿‡ deferBits åˆ¤æ–­è¯¥å‡½æ•°æ˜¯å¦éœ€è¦è¢«æ‰§è¡Œï¼› è°ƒç”¨deferCallSave()éœ€è¦æ‰§è¡Œçš„ defer å‡½æ•°ï¼› è¯¥å‡½æ•°å¦‚æœåœ¨deferreturn()å‡½æ•°ä¸­è¢«è°ƒç”¨ï¼Œé‚£å‡½æ•°é‡Œå­˜åœ¨çš„panic()æ ‡å¿—æ²¡æœ‰ä½œç”¨ï¼Œå› ä¸ºæ­£å¸¸æµç¨‹ä¸ä¼šè°ƒç”¨deferreturn()å‡½æ•°ï¼Œåªæ˜¯åœ¨panic()å’Œruntime.Goexit()éœ€è¦æ³¨æ„ã€‚ é€šè¿‡è¿”å›å€¼æ¥åˆ¤æ–­ç›®æ ‡æ ˆå¸§ä¸Šçš„open coded deferå·²ç»å®Œå…¨æ‰§è¡Œï¼Œå¹¶ä¸”æ²¡æœ‰recoverã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 // runOpenDeferFrame runs the active open-coded defers in the frame specified by // d. It normally processes all active defers in the frame, but stops immediately // if a defer does a successful recover. It returns true if there are no // remaining defers to run in the frame. // // gp *g å½“å‰çš„goroutine // d *_defer å½“å‰gåé¢çš„deferé“¾è¡¨ func runOpenDeferFrame(gp *g, d *_defer) bool { done := true // æ‰€æœ‰deferä¿¡æ¯éƒ½å­˜å‚¨åœ¨funcdataä¸­ fd := d.fd\t// readvarintUnsafe ä» fd å¼€å§‹ä»¥ varint æ ¼å¼è¯»å– uint32ï¼Œå¹¶è¿”å› uint32 å’ŒæŒ‡å‘ varint åé¢å­—èŠ‚çš„æŒ‡é’ˆ deferBitsOffset, fd := readvarintUnsafe(fd) nDefers, fd := readvarintUnsafe(fd) // nDefersæ³¨å†Œçš„deferä¸ªæ•°ï¼Œå‡½æ•°ä¸­deferæ•°é‡ // å½“å‰æ‰§è¡Œçš„defer deferBits := *(*uint8)(unsafe.Pointer(d.varp - uintptr(deferBitsOffset))) // deferBitså°±æ˜¯æ³¨å†Œå‡½æ•°çš„è®°å½•æ ‡å¿— // éå†æ³¨å†Œçš„deferæ•°é‡ for i := int(nDefers) - 1; i \u0026gt;= 0; i-- { // read the funcdata info for this defer ä»deferä¸­è¯»å–funcdataä¿¡æ¯ var closureOffset uint32 closureOffset, fd = readvarintUnsafe(fd) // closureOffset deferæ³¨å†Œå‡½æ•°çš„åç§»é‡ if deferBits\u0026amp;(1\u0026lt;\u0026lt;i) == 0 { // åˆ¤æ–­å½“å‰ä½ä¸Šæ˜¯å¦æœ‰deferæ»¡è¶³æ¡ä»¶çš„æ³¨å†Œ continue } // æ‰§è¡Œçš„å‡½æ•°å’Œå‚æ•° closure := *(*func())(unsafe.Pointer(d.varp - uintptr(closureOffset))) // å¾—åˆ°æ³¨å†Œçš„å‡½æ•° d.fn = closure // 8bit 0000_0000 deferBits = deferBits \u0026amp;^ (1 \u0026lt;\u0026lt; i) // æ¸…é›¶æŒ‡å®šiä½ä¸Šçš„æ ‡å¿— *(*uint8)(unsafe.Pointer(d.varp - uintptr(deferBitsOffset))) = deferBits // å›å†™å†…å­˜ p := d._panic // Call the defer. Note that this can change d.varp if // the stack moves. deferCallSave(p, d.fn) // è°ƒç”¨æ³¨å†Œçš„å‡½æ•°å¹¶å¤„ç†panicç›¸å…³ï¼Œfn()é‡Œé¢å¯èƒ½å†æ¬¡å‘ç”Ÿpanicå¯¼è‡´è¿™é‡Œæ‰§è¡Œäº†éƒ¨åˆ† if p != nil \u0026amp;\u0026amp; p.aborted { // å¦‚æœå½“å‰deferç”±panicè§¦å‘ï¼Œå¹¶ä¸”å·²è¢«ä¸­æ­¢ï¼Œåˆ™ç›´æ¥é€€å‡ºï¼Œè¿™é‡Œå¥½åƒæ°¸è¿œä¸ºfalse break } d.fn = nil // å¦‚æœå½“å‰deferç”±panicè§¦å‘ï¼Œå¹¶ä¸”å½“å‰panicè¢«æ¢å¤äº†ï¼Œåº”è¯¥ç»“æŸdeferç»§ç»­å»æ‰§è¡Œpanicä¹‹åçš„ä»£ç  if d._panic != nil \u0026amp;\u0026amp; d._panic.recovered { done = deferBits == 0 // æ ‡è®°deferå‡½æ•°æ˜¯å¦å·²è¢«å¤„ç†å®Œ break } } return done } deferCallSave() 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 // deferCallSave calls fn() after saving the caller\u0026#39;s pc and sp in the // panic record. This allows the runtime to return to the Goexit defer // processing loop, in the unusual case where the Goexit may be // bypassed by a successful recover. // // This is marked as a wrapper by the compiler so it doesn\u0026#39;t appear in // tracebacks. func deferCallSave(p *_panic, fn func()) { if p != nil { // ä»¥ä¸‹å‚æ•°åœ¨fn()ä¸­å¦‚æœå­˜åœ¨recoverå‡½æ•°æ—¶ä¼šè¢«ç”¨åˆ° p.argp = unsafe.Pointer(getargp()) p.pc = getcallerpc() p.sp = unsafe.Pointer(getcallersp()) } fn() // è°ƒç”¨æ³¨å†Œçš„deferå‡½æ•° if p != nil { // ä»¥ä¸‹å‚æ•°åœ¨ä¸‹ä¸€ä¸ªopen defersæ—¶è¢«ç”¨åˆ° p.pc = 0 p.sp = unsafe.Pointer(nil) } } readvarintUnsafe() 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 // readvarintUnsafe reads the uint32 in varint format starting at fd, and returns the // uint32 and a pointer to the byte following the varint. // // There is a similar function runtime.readvarint, which takes a slice of bytes, // rather than an unsafe pointer. These functions are duplicated, because one of // the two use cases for the functions would get slower if the functions were // combined. // // readvarintUnsafe ä» fd å¼€å§‹ä»¥ varint æ ¼å¼è¯»å– uint32ï¼Œå¹¶è¿”å› uint32 å’ŒæŒ‡å‘ varint åé¢å­—èŠ‚çš„æŒ‡é’ˆ // è¿˜æœ‰ä¸€ä¸ªç±»ä¼¼çš„å‡½æ•°è¿è¡Œæ—¶ã€‚readvarintï¼Œå®ƒéœ€è¦ä¸€ä¸ªå­—èŠ‚ç‰‡ï¼Œè€Œä¸æ˜¯ä¸€ä¸ªä¸å®‰å…¨çš„æŒ‡é’ˆã€‚ // è¿™äº›åŠŸèƒ½æ˜¯é‡å¤çš„ï¼Œå› ä¸ºå¦‚æœå°†è¿™äº›åŠŸèƒ½ç»„åˆèµ·æ¥ï¼Œä¸¤ä¸ªåŠŸèƒ½ç”¨ä¾‹ä¸­çš„ä¸€ä¸ªä¼šå˜æ…¢ func readvarintUnsafe(fd unsafe.Pointer) (uint32, unsafe.Pointer) { var r uint32 var shift int for { b := *(*uint8)((unsafe.Pointer(fd))) fd = add(fd, unsafe.Sizeof(b)) if b \u0026lt; 128 { return r + uint32(b)\u0026lt;\u0026lt;shift, fd } r += ((uint32(b) \u0026amp;^ 128) \u0026lt;\u0026lt; shift) shift += 7 if shift \u0026gt; 28 { panic(\u0026#34;Bad varint\u0026#34;) } } } addOneOpenDeferFrame() è¯¥å‡½æ•°æ˜¯å‘ç”Ÿpanic()æˆ–runtime.Goexit()æ—¶å›æº¯æ ˆå¯»æ‰¾deferä¿¡æ¯å‡½æ•°ã€‚ å°†æœ€è¿‘çš„ä¸€ä¸ªopen coded deferæ ˆå¸§æ·»åŠ åˆ°_deferé“¾è¡¨ä¸­ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 // addOneOpenDeferFrame scans the stack (in gentraceback order, from inner frames to // outer frames) for the first frame (if any) with open-coded defers. If it finds // one, it adds a single entry to the defer chain for that frame. The entry added // represents all the defers in the associated open defer frame, and is sorted in // order with respect to any non-open-coded defers. // // addOneOpenDeferFrame stops (possibly without adding a new entry) if it encounters // an in-progress open defer entry. An in-progress open defer entry means there has // been a new panic because of a defer in the associated frame. addOneOpenDeferFrame // does not add an open defer entry past a started entry, because that started entry // still needs to finished, and addOneOpenDeferFrame will be called when that started // entry is completed. The defer removal loop in gopanic() similarly stops at an // in-progress defer entry. Together, addOneOpenDeferFrame and the defer removal loop // ensure the invariant that there is no open defer entry further up the stack than // an in-progress defer, and also that the defer removal loop is guaranteed to remove // all not-in-progress open defer entries from the defer chain. // // If sp is non-nil, addOneOpenDeferFrame starts the stack scan from the frame // specified by sp. If sp is nil, it uses the sp from the current defer record (which // has just been finished). Hence, it continues the stack scan from the frame of the // defer that just finished. It skips any frame that already has a (not-in-progress) // open-coded _defer record in the defer chain. // // Note: All entries of the defer chain (including this new open-coded entry) have // their pointers (including sp) adjusted properly if the stack moves while // running deferred functions. Also, it is safe to pass in the sp arg (which is // the direct result of calling getcallersp()), because all pointer variables // (including arguments) are adjusted as needed during stack copies. // // gp *g å½“å‰goroutine // pc uintptr å½“å‰å‘ç”Ÿpanicçš„ä¸‹ä¸€æ¡æŒ‡ä»¤å¤„ // sp unsafe.Pointer å½“å‰å‘ç”Ÿpanicçš„å‡½æ•°æ ˆé¡¶ func addOneOpenDeferFrame(gp *g, pc uintptr, sp unsafe.Pointer) { var prevDefer *_defer\t// goroutineçš„ä¸Šä¸€ä¸ªdeferç»“æ„ if sp == nil { prevDefer = gp._defer pc = prevDefer.framepc sp = unsafe.Pointer(prevDefer.sp) } systemstack(func() { gentraceback(pc, uintptr(sp), 0, gp, 0, nil, 0x7fffffff, func(frame *stkframe, unused unsafe.Pointer) bool { if prevDefer != nil \u0026amp;\u0026amp; prevDefer.sp == frame.sp { // Skip the frame for the previous defer that // we just finished (and was used to set // where we restarted the stack scan) return true } f := frame.fn fd := funcdata(f, _FUNCDATA_OpenCodedDeferInfo) if fd == nil { return true } // Insert the open defer record in the // chain, in order sorted by sp. d := gp._defer var prev *_defer for d != nil { dsp := d.sp if frame.sp \u0026lt; dsp { break } if frame.sp == dsp { if !d.openDefer { throw(\u0026#34;duplicated defer entry\u0026#34;) } // Don\u0026#39;t add any record past an // in-progress defer entry. We don\u0026#39;t // need it, and more importantly, we // want to keep the invariant that // there is no open defer entry // passed an in-progress entry (see // header comment). if d.started { return false } return true } prev = d d = d.link } if frame.fn.deferreturn == 0 { throw(\u0026#34;missing deferreturn\u0026#34;) } d1 := newdefer() d1.openDefer = true d1._panic = nil // These are the pc/sp to set after we\u0026#39;ve // run a defer in this frame that did a // recover. We return to a special // deferreturn that runs any remaining // defers and then returns from the // function. d1.pc = frame.fn.entry() + uintptr(frame.fn.deferreturn) d1.varp = frame.varp d1.fd = fd // Save the SP/PC associated with current frame, // so we can continue stack trace later if needed. d1.framepc = frame.pc d1.sp = frame.sp d1.link = d if prev == nil { gp._defer = d1 } else { prev.link = d1 } // Stop stack scanning after adding one open defer record return false }, nil, 0) }) } runtime.Goexit() ç«‹å³ç»ˆæ­¢å½“å‰goroutineæ‰§è¡Œï¼Œåœ¨ç»ˆæ­¢è°ƒç”¨å®ƒçš„Goroutineçš„è¿è¡Œä¹‹å‰ä¼šå…ˆæ‰§è¡Œè¯¥Goroutionä¸­è¿˜æ²¡æœ‰æ‰§è¡Œçš„deferè¯­å¥ã€‚ è¯¥å‡½æ•°è¿è¡Œå®Œdeferé“¾è¡¨æ³¨å†Œçš„å‡½æ•°ï¼Œç›´æ¥è°ƒç”¨goexit1()å‡½æ•°ï¼Œè¯¥å‡½æ•°ç›´æ¥åˆ‡æ¢goroutineå¤„ç†goroutineçš„åç»­å·¥ä½œã€‚ Goexit()ä»£ç çš„é€»è¾‘ä¸gopanic()å‡½æ•°ç›¸ä¼¼åº¦å¾ˆé«˜ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 // Goexit terminates the goroutine that calls it. No other goroutine is affected. // Goexit runs all deferred calls before terminating the goroutine. Because Goexit // is not a panic, any recover calls in those deferred functions will return nil. // // Calling Goexit from the main goroutine terminates that goroutine // without func main returning. Since func main has not returned, // the program continues execution of other goroutines. // If all other goroutines exit, the program crashes. func Goexit() { // Run all deferred functions for the current goroutine. // This code is similar to gopanic, see that implementation // for detailed comments. gp := getg() // Create a panic object for Goexit, so we can recognize when it might be // bypassed by a recover(). // ä¸º Goexit åˆ›å»ºä¸€ä¸ªææ…Œå¯¹è±¡ï¼Œè¿™æ ·æˆ‘ä»¬å°±å¯ä»¥è¯†åˆ«å®ƒä½•æ—¶å¯èƒ½è¢« recover() ç»•è¿‡ var p _panic p.goexit = true p.link = gp._panic gp._panic = (*_panic)(noescape(unsafe.Pointer(\u0026amp;p))) addOneOpenDeferFrame(gp, getcallerpc(), unsafe.Pointer(getcallersp())) // è¿è¡Œdeferå‡½æ•° for { d := gp._defer if d == nil { break } if d.started { if d._panic != nil { d._panic.aborted = true d._panic = nil } if !d.openDefer { d.fn = nil gp._defer = d.link freedefer(d) continue } } d.started = true d._panic = (*_panic)(noescape(unsafe.Pointer(\u0026amp;p))) if d.openDefer { done := runOpenDeferFrame(gp, d) if !done { // We should always run all defers in the frame, // since there is no panic associated with this // defer that can be recovered. throw(\u0026#34;unfinished open-coded defers in Goexit\u0026#34;) } if p.aborted { // Since our current defer caused a panic and may // have been already freed, just restart scanning // for open-coded defers from this frame again. addOneOpenDeferFrame(gp, getcallerpc(), unsafe.Pointer(getcallersp())) } else { addOneOpenDeferFrame(gp, 0, nil) } } else { // Save the pc/sp in deferCallSave(), so we can \u0026#34;recover\u0026#34; back to this // loop if necessary. deferCallSave(\u0026amp;p, d.fn) } if p.aborted { // We had a recursive panic in the defer d we started, and // then did a recover in a defer that was further down the // defer chain than d. In the case of an outstanding Goexit, // we force the recover to return back to this loop. d will // have already been freed if completed, so just continue // immediately to the next defer on the chain. p.aborted = false continue } if gp._defer != d { throw(\u0026#34;bad defer entry in Goexit\u0026#34;) } d._panic = nil d.fn = nil gp._defer = d.link freedefer(d) // Note: we ignore recovers here because Goexit isn\u0026#39;t a panic } // è¿™é‡Œæ˜¯Goexit()å‡½æ•°å…³é”®ï¼Œå¤„ç†å®Œdeferåç›´æ¥åˆ‡æ¢goroutineäº†ã€‚ goexit1() } ","permalink":"https://heliu.site/posts/golang/func/defer-theory/","summary":"defer ç»„æˆä»‹ç»ã€‚","title":"defer(åŸç†)"},{"content":" åªæœ‰åœ¨ defer å‡½æ•°ä¸­è°ƒç”¨ recover() å‡½æ•°æ‰æœ‰æ•ˆï¼Œå› ä¸ºå‘ç”Ÿ panic ä¹‹ååªæœ‰ defer å‡½æ•°èƒ½å¤Ÿå¾—åˆ°æ‰§è¡Œã€‚ Go è¯­è¨€åœ¨è®¾è®¡ä¸Šä¿è¯æ‰€æœ‰çš„ defer å‡½æ•°éƒ½èƒ½å¤Ÿå¾—åˆ°è°ƒç”¨ï¼Œæ‰€ä»¥é€‚åˆç”¨ defer æ¥é‡Šæ”¾èµ„æºï¼Œå³ä½¿å‘ç”Ÿ panic ä¹Ÿä¸ä¼šé€ æˆèµ„æºæ³„éœ²ã€‚ type _panic struct è¯¥ç»“æ„ä½“å­˜å‚¨ç€panicçš„ç›¸å…³ä¿¡æ¯ã€‚ æ–‡ä»¶ä½ç½®ï¼šgo1.19.3/src/runtime/runtime2.goã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 // A _panic holds information about an active panic. // // A _panic value must only ever live on the stack. // // The argp and link fields are stack pointers, but don\u0026#39;t need special // handling during stack growth: because they are pointer-typed and // _panic values only live on the stack, regular stack pointer // adjustment takes care of them. type _panic struct { // argp è®¾ç½®ä¸ºå½“å‰gopanic()å‡½æ•°æ ˆå¸§ä¸Šargs to calleeåŒºé—´çš„èµ·å§‹åœ°å€ã€‚ // ä¸»è¦ä½œç”¨ï¼šç”¨äºdefer()å‡½æ•°æ‰§è¡Œæ—¶åˆ¤æ–­recover()å‡½æ•°æ‰€åœ¨èŒƒå›´æ˜¯å¦èƒ½ç”Ÿæ•ˆã€‚ argp unsafe.Pointer // pointer to arguments of deferred call run during panic; cannot move - known to liblink // åˆ™æ˜¯panicå‡½æ•°è‡ªå·±çš„å‚æ•°ï¼Œä¹Ÿå°±æ˜¯ã€panic(v any)ã€‘è¿™é‡Œçš„ç©ºæ¥å£ã€vã€‘çš„å‚æ•°ã€‚ // ä¸»è¦ä½œç”¨ï¼šç»“æŸæ—¶ç”¨äºæ‰“å°é”™è¯¯ä¿¡æ¯ã€‚ arg any // argument to panic // é€šè¿‡linké“¾æ¥åˆ°å‰ä¸€ä¸ªæ³¨å†Œçš„panicå½¢æˆé“¾è¡¨ï¼Œ // è§£é‡Šï¼šæ–°å¢çš„panicæ€»æ˜¯ä»å·¦è¾¹æ’å…¥ link *_panic // link to earlier panic\tg._painc // pc æ¥è‡ª defer.pc æ‹·è´çš„å€¼ // ä¸»è¦ä½œç”¨ï¼šç”¨äºå½“å‰panicè¢«æ¢å¤æ—¶è¦æ‰§è¡Œçš„ä¸‹ä¸€æ¡æŒ‡ä»¤åœ°å€åŠIPå¯„å­˜å™¨çš„å€¼ pc uintptr // where to return to in runtime if this panic is bypassed\t// sp æ¥è‡ª defer.sp æ‹·è´çš„å€¼ // ä¸»è¦ä½œç”¨ï¼šç”¨äºå½“å‰panicè¢«æ¢å¤æ—¶è¦æ¢å¤çš„æ ˆé¡¶SPå¯„å­˜å™¨çš„å€¼ sp unsafe.Pointer // where to return to in runtime if this panic is bypassed // è¡¨ç¤ºå½“å‰panicå·²ç»è¢«æŸä¸ªdeferå‡½æ•°é€šè¿‡recoveræ¢å¤ã€‚ã€å·²æ¢å¤ã€‘ // è§£é‡Šï¼šè¯¥å€¼åœ¨recover()å‡½æ•°ä¸­è¢«æ ‡è®° recovered bool // whether this panic is over // è¡¨ç¤ºå‘ç”Ÿäº†åµŒå¥—çš„panicï¼Œæ—§çš„panicè¢«æ–°çš„panicæµç¨‹æ ‡è®°ä¸ºabortedã€‚ã€å·²ä¸­æ­¢ã€‘ // è§£é‡Šï¼šå°±æ˜¯å‘ç”Ÿäº†åµŒå¥—panicäº†ã€‚ aborted bool // the panic was aborted // æ˜¯å¦æ‰§è¡Œruntime.Goexit()å‡½æ•°ï¼Œruntime.Goexit()å‡½æ•°æ˜¯ // goroutineæ‰§è¡Œå®Œåè·³è½¬åˆ°çš„æ¸…ç†é¦–å°¾å·¥ä½œçš„å‡½æ•° // goexitå­—æ®µåœ¨ï¼Œruntime.Goexit()å‡½æ•°ä¸­è¢«æ ‡è®°ä¸ºtrueã€‚ goexit bool } panic 1 2 3 4 5 6 7 8 9 10 11 // The panic built-in function stops normal execution of the current // goroutine. When a function F calls panic, normal execution of F stops // immediately. Any functions whose execution was deferred by F are run in // the usual way, and then F returns to its caller. To the caller G, the // invocation of F then behaves like a call to panic, terminating G\u0026#39;s // execution and running any deferred functions. This continues until all // functions in the executing goroutine have stopped, in reverse order. At // that point, the program is terminated with a non-zero exit code. This // termination sequence is called panicking and can be controlled by the // built-in function recover. func panic(v any) gopanic() gopanic() ä¹Ÿå°±æ˜¯ panic() å‘ç”Ÿæ—¶è°ƒç”¨çš„å‡½æ•°ã€‚ gopanic() å‡½æ•°ä¸­å…³é”®çš„ open coded defer éƒ¨åˆ†ï¼š åœ¨ for å¾ªç¯å¼€å§‹ä¹‹å‰ï¼Œå…ˆé€šè¿‡ addOneOpenDeferFrame() å‡½æ•°å°†æœ€è¿‘çš„ä¸€ä¸ª open coded defer æ ˆå¸§æ·»åŠ åˆ° _defer é“¾è¡¨ä¸­ã€‚ åœ¨è°ƒç”¨ defer å‡½æ•°çš„æ—¶å€™ï¼Œå¦‚æœ openDefer ä¸º true ï¼Œåˆ™ä½¿ç”¨ runOpenDeferFrame() å‡½æ•°æ¥æ‰§è¡Œï¼Œé€šè¿‡è¿”å›å€¼æ¥åˆ¤æ–­ç›®æ ‡æ ˆå¸§ä¸Šçš„ open coded defer å·²ç»å®Œå…¨æ‰§è¡Œï¼Œå¹¶ä¸”æ²¡æœ‰ recoverï¼Œå°±å†æ¬¡è°ƒç”¨ addOneOpenDeferFrame() å‡½æ•°æŠŠä¸‹ä¸€ä¸ª open coded defer æ ˆå¸§æ·»åŠ åˆ° _defer é“¾è¡¨ã€‚ æ ¹æ® runOpenDeferFrame() å‡½æ•°çš„è¿”å›å€¼æ¥åˆ¤æ–­ï¼Œåªæœ‰å®Œå…¨æ‰§è¡Œçš„èŠ‚ç‚¹æ‰èƒ½ä» _defer é“¾è¡¨ä¸­ç§»é™¤ã€‚äº‹å®ä¸Šåªæœ‰ openDefer èŠ‚ç‚¹æ‰æœ‰å¯èƒ½å‡ºç°ä¸å®Œå…¨æ‰§è¡Œçš„æƒ…å†µï¼Œå› ä¸ºä¸€ä¸ªæ ˆå¸§ä¸Šå¯èƒ½æœ‰å¤šä¸ª open coded defer å‡½æ•°ï¼Œå‡å¦‚å…¶ä¸­æŸä¸€ä¸ªå‡½æ•°è°ƒç”¨äº† recover() å‡½æ•°ï¼Œåç»­çš„å°±ä¸ä¼šå†è¢«è°ƒç”¨äº†ï¼Œæ‰€ä»¥è¯¥èŠ‚ç‚¹ä¸èƒ½ä» _defer é“¾è¡¨ä¸­ç§»é™¤ï¼Œrecover ä¹‹åçš„é€»è¾‘è´Ÿè´£è°ƒç”¨è¿™äº›å‰©ä½™çš„ open coded deferã€‚ æ£€æŸ¥åˆ°å½“å‰ panic çš„ recover ä¸º true åï¼Œéœ€è¦æŠŠ _defer é“¾è¡¨ä¸­å°šæœªå¼€å§‹æ‰§è¡Œçš„ openDefer èŠ‚ç‚¹ç§»é™¤ï¼Œå› ä¸º recover ä¹‹åè¿™äº› open coded defer ä¼šè¢«æ­£å¸¸è°ƒç”¨ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 // The implementation of the predeclared function panic. func gopanic(e any) { // è·å–å½“å‰æ­£åœ¨è¿è¡Œçš„goroutine gp := getg() // è°ƒç”¨gopanic()åº”è¯¥æ˜¯åœ¨ç”¨æˆ·æ ˆä¸Šå‘ç”Ÿçš„ if gp.m.curg != gp { print(\u0026#34;panic: \u0026#34;) printany(e) print(\u0026#34;\\n\u0026#34;) // panic åœ¨ç³»ç»Ÿæ ˆä¸Š throw(\u0026#34;panic on system stack\u0026#34;) } // ç”³è¯·å†…å­˜æœŸé—´ä¸å…è®¸panic if gp.m.mallocing != 0 { print(\u0026#34;panic: \u0026#34;) printany(e) print(\u0026#34;\\n\u0026#34;) // malloc æœŸé—´ panic // malloc æ˜¯åœ¨ç”³è¯·å†…å­˜æœŸé—´ throw(\u0026#34;panic during malloc\u0026#34;) } // æŠ¢å æœŸé—´ä¸å…è®¸panic if gp.m.preemptoff != \u0026#34;\u0026#34; { print(\u0026#34;panic: \u0026#34;) printany(e) print(\u0026#34;\\n\u0026#34;) print(\u0026#34;preempt off reason: \u0026#34;) print(gp.m.preemptoff) print(\u0026#34;\\n\u0026#34;) throw(\u0026#34;panic during preemptoff\u0026#34;) } // MæŒæœ‰é”æœŸé—´ä¸å…è®¸panic if gp.m.locks != 0 { print(\u0026#34;panic: \u0026#34;) printany(e) print(\u0026#34;\\n\u0026#34;) throw(\u0026#34;panic holding locks\u0026#34;) } // 1) åˆ›å»ºä¸€ä¸ª_panicç»“æ„å¹¶åˆå§‹åŒ– // å¯ä»¥çœ‹å‡ºpanicå’Œdeferç»“æ„éƒ½æ˜¯ç”¨çš„ç”¨æˆ·å†…å­˜ç©ºé—´ // åˆå§‹åŒ–ä¸€ä¸ªpanicç»“æ„ä½“ï¼Œåœ¨æ ˆä¸Šåˆ†é… var p _panic\tp.arg = e // ä¿å­˜panicçš„å‚æ•°ï¼Œè¯¥å‚æ•°æ˜¯panic(v any) // _panicé€šè¿‡linké“¾æ¥å…¶ä»–panic // è®°å½•goroutineä¸Šçš„æœ€åä¸€ä¸ªpanicï¼Œä¹Ÿå°±æ˜¯å½¢æˆä¸€ä¸ªpanicçš„é“¾è¡¨ p.link = gp._panic\t// g._panic ä¿å­˜çš„æ˜¯æœ€æ–°çš„panic // ç‰¹æ„ä½¿ç”¨noescapeå‡½æ•°æ¥é¿å…pé€ƒé€¸ï¼Œåº”ä¸ºpanicæœ¬èº«å°±æ˜¯ä¸æ ˆçš„çŠ¶æ€å¼ºç›¸å…³çš„ // å½“å‰panicè¿½åŠ åˆ°goroutineçš„panicé“¾è¡¨ä¸Šï¼Œè®°å½•æœ€æ–°çš„ä¸€ä¸ªpanic gp._panic = (*_panic)(noescape(unsafe.Pointer(\u0026amp;p)))\t// ä½¿ç”¨åŸå­é”æ ‡è®°panicæ­£åœ¨å‘ç”Ÿï¼Œç”¨äºruntime.main()å‡½æ•°ç­‰å¾… // å½“runtime.main()å³å°†è¦ç»“æŸæ—¶ï¼Œéœ€è¦å¾ªç¯ç­‰å¾…panicå®Œæˆã€‚ // å…·ä½“ä»£ç å‚çœ‹ runtime.main() å‡½æ•°ã€‚ atomic.Xadd(\u0026amp;runningPanicDefers, 1) // 2) open code defers å½¢å¼æ‰«ææ ˆï¼Œæ”¶é›†ä¿¡æ¯,å·²å¤‡åé¢å¾ªç¯gp.defer // By calculating getcallerpc/getcallersp here, we avoid scanning the // gopanic frame (stack scanning is slow...) // // é€šè¿‡è¿™é‡Œè®¡ç®—getcallerpc/getcallerspï¼Œæˆ‘ä»¬é¿å…æ‰«ægopanicå¸§ï¼ˆå †æ ˆæ‰«æå¾ˆæ…¢......ï¼‰ // å°†æœ€è¿‘çš„ä¸€ä¸ªopen coded deferæ ˆå¸§æ·»åŠ åˆ°_deferé“¾è¡¨ä¸­ï¼Œå¯èƒ½æ˜¯ä¸€ç»„deferå‡½æ•°ç»„æˆçš„ä¸€ä¸ª_deferç»“æ„ã€‚ addOneOpenDeferFrame(gp, getcallerpc(), unsafe.Pointer(getcallersp())) // åœ¨è¿™ä¸ªå¾ªç¯ä¸­é€ä¸ªè°ƒç”¨é“¾è¡¨ä¸­çš„deferå‡½æ•°ï¼Œå¹¶æ£€æµ‹recoverçš„çŠ¶æ€ã€‚ // å¦‚æœæ‰€æœ‰çš„deferå‡½æ•°éƒ½æ‰§è¡Œå®Œåè¿˜æ˜¯æ²¡æœ‰recoverï¼Œåˆ™å¾ªç¯å°±ä¼šç»“æŸï¼Œ // æœ€åçš„fatalpanic()å‡½æ•°å°±ä¼šç»“æŸå½“å‰è¿›ç¨‹ã€‚ for { // å–æœ€æ–°çš„ä¸€ä¸ªdefer // è¿™é‡Œå¯ä»¥çœ‹çœ‹å‡ºå–å‡ºçš„deferä¸ä¸€å®šæ˜¯å½“å‰å‘ç”Ÿpanicæ³¨å†Œçš„deferå¯èƒ½æ˜¯ä¸Šæ¸¸è°ƒç”¨å‡½æ•°æ³¨å†Œçš„ d := gp._defer if d == nil { // deferå·²ç»è¿è¡Œå®Œäº†ï¼Œç»“æŸå¾ªç¯ break } // If defer was started by earlier panic or Goexit (and, since we\u0026#39;re back here, that triggered a new panic), // take defer off list. An earlier panic will not continue running, but we will make sure below that an // earlier Goexit does continue running. // // d.startedä¸ºçœŸï¼Œè¡¨æ˜å½“å‰æ˜¯ä¸€ä¸ªåµŒå¥—çš„panicï¼Œ // ä¹Ÿå°±æ˜¯åœ¨åŸæœ‰panicæˆ–Goexit()å‡½æ•°æ‰§è¡Œdeferå‡½æ•°çš„æ—¶å€™åˆè§¦å‘äº†panic // å› ä¸ºè§¦å‘panicçš„deferå‡½æ•°è¿˜æ²¡æœ‰æ‰§è¡Œå®Œï¼Œæ‰€ä»¥è¿˜æ²¡æœ‰ä»é“¾è¡¨ä¸­ç§»é™¤ã€‚ // è¿™é‡Œä¼šæŠŠdç›¸å…³çš„æ—§çš„_panicè®¾ç½®ä¸ºabortedï¼Œç„¶åæŠŠdä»é“¾è¡¨ä¸­ç§»é™¤ï¼Œå¹¶é€šè¿‡freedefer()å‡½æ•°é‡Šæ”¾deferã€‚ if d.started { // é¦–æ¬¡è§¦å‘panicè¿™é‡Œä¸º falseï¼Œå¤šæ¬¡è§¦å‘è¿™é‡Œä¸º true // d._panicè®°å½•çš„æ˜¯å‰ä¸€ä¸ªpanicï¼Œ // åœ¨æ‰§è¡Œd.fn()å‡½æ•°çš„æ—¶å€™åˆå‘ç”Ÿäº†panicçš„æƒ…å†µã€‚ if d._panic != nil { // æŠŠå‰ä¸€ä¸ªpanicæ ‡è®°ä¸ºå·²ç»ˆæ­¢çŠ¶æ€ d._panic.aborted = true // å·²ç»ˆæ­¢ } d._panic = nil // ä¸æ˜¯open deferså½¢å¼æ—¶ï¼Œåˆ™ç›´æ¥å›æ”¶å½“å‰deferç»“æ„ä½“å³å¯ï¼Œ // å› ä¸ºå½“å‰gopanic()æ­£æ˜¯å½“å‰deferå‡½æ•°ä¸­è§¦å‘ï¼Œå› æ­¤ç›´æ¥ç»“æŸæœ¬æ¬¡å¾ªç¯å³å¯ã€‚ if !d.openDefer {\t// For open-coded defers, we need to process the // defer again, in case there are any other defers // to call in the frame (not including the defer // call that caused the panic). // // å½“å‰deferå·²æ‰§è¡Œå®Œï¼Œå³å°†è¢«å›æ”¶ã€‚ d.fn = nil gp._defer = d.link // å› ä¸ºå½“å‰deferä¸­å‘ç”Ÿäº†panicï¼Œåç»­ä»£ç ä¸ä¼šè¢«æ‰§è¡Œï¼Œç›´æ¥å›æ”¶deferå³å¯ freedefer(d)\tcontinue } // å¦åˆ™åº”è¯¥å»runOpenDeferFrameå›æ”¶ } // åç»­çš„3å¤§å—é€»è¾‘å°±æ˜¯ï¼šè°ƒç”¨deferå‡½æ•°ã€é‡Šæ”¾_deferç»“æ„å’Œæ£€æµ‹recoverã€‚ // 2.1) è°ƒç”¨deferå‡½æ•° // Mark defer as started, but keep on list, so that traceback // can find and update the defer\u0026#39;s argument frame if stack growth // or a garbage collection happens before executing d.fn. // // å¦‚æœdeferå‡½æ•°åˆè§¦å‘äº†panicï¼Œæ–°çš„panicéå†deferé“¾è¡¨æ—¶ï¼Œå°±èƒ½å¤Ÿé€šè¿‡started // çš„å€¼ç¡®å®šç¡®å®šè¯¥deferå‡½æ•°å·²ç»è¢«è°ƒç”¨è¿‡äº†ï¼Œé¿å…é‡å¤è°ƒç”¨ã€‚ d.started = true // æ ‡è®°å½“å‰deferè¢«panicè§¦å‘ // Record the panic that is running the defer. // If there is a new panic during the deferred call, that panic // will find d in the list and will mark d._panic (this panic) aborted. // // ä¸ºd._panicèµ‹å€¼ï¼Œå°†då…³è”åˆ°å½“å‰panicå¯¹è±¡pï¼Œ // ä½¿ç”¨noescapeå‡½æ•°é¿å…pé€ƒé€¸ï¼Œè¿™ä¸€æ­¥æ˜¯ä¸ºäº†åç»­åµŒå¥—çš„panicèƒ½å¤Ÿé€šè¿‡d._panicæ‰¾åˆ°ä¸Šä¸€ä¸ªpanic d._panic = (*_panic)(noescape(unsafe.Pointer(\u0026amp;p))) // å½“å‰deferçš„_panicè®°å½•è§¦å‘çš„panicæ˜¯é‚£ä¸ª done := true if d.openDefer { // å½“å‰æ˜¯open code defersæ¨¡å¼æ—¶ // è¿è¡Œå½“å‰deferçš„fnå‡½æ•°ï¼Œdone=trueè¡¨ç¤ºæ‰€æœ‰çš„deferå·²ç»è¿è¡Œå®Œ // é€šè¿‡è¿”å›å€¼æ¥åˆ¤æ–­ç›®æ ‡æ ˆå¸§ä¸Šçš„open coded deferå·²ç»å®Œå…¨æ‰§è¡Œï¼Œå¹¶ä¸”æ²¡æœ‰recoverï¼Œ // å°±å†æ¬¡è°ƒç”¨addOneOpenDeferFrame()å‡½æ•°æŠŠä¸‹ä¸€ä¸ªopen coded deferæ ˆå¸§æ·»åŠ åˆ°_deferé“¾è¡¨ done = runOpenDeferFrame(gp, d) // è¿™é‡Œè¿è¡Œçš„æ˜¯ä¸€ç»„defer // å› ä¸ºä¸Šé¢è¿è¡Œçš„d.fn()å‡½æ•°ï¼Œå¯èƒ½å…¶ä¸­å­˜åœ¨recover()å‡½æ•°ï¼Œæ‰€ä»¥è¦åˆ¤æ–­recoveredå­—æ®µ if done \u0026amp;\u0026amp; !d._panic.recovered {\t// done=trueï¼Œå¹¶ä¸”å½“å‰è¿™ä¸ªpanicå¹¶æ²¡æœ‰è¢«æ¢å¤æ—¶ // å†å»å¯»æ‰¾åé¢å‡½æ•°çš„defer // ä»è°ƒç”¨æ ˆçš„æ ˆé¡¶å¼€å§‹å›æº¯æ‰«æï¼Œç›´åˆ°æ‰¾åˆ°ä¸€ä¸ªå¸¦æœ‰open coded deferçš„æ ˆå¸§ï¼Œ // ä¸ºè¯¥æ ˆå¸§åˆ†é…ä¸€ä¸ª_deferç»“æ„ï¼Œä¸ºå„ä¸ªå­—æ®µèµ‹å€¼åæ·»åŠ åˆ°deferé“¾è¡¨ä¸­åˆé€‚çš„ä½ç½®ã€‚ // ä¸ç®¡ç›®æ ‡æ ˆå¸§ä¸Šæœ‰å‡ ä¸ªopen coded deferå‡½æ•°ï¼Œåªåˆ†é…ä¸€ä¸ª_deferç»“æ„ï¼Œ // å› ä¸ºåç»­é€šè¿‡runOpenDeferFrame()å‡½æ•°æ¥æ‰§è¡Œçš„æ—¶å€™ï¼Œä¼šä¸€å¹¶æ‰§è¡Œæ ˆå¸§ä¸Šçš„æ‰€æœ‰ // open coded deferå‡½æ•°ã€‚æ·»åŠ åˆ°_deferé“¾è¡¨ä¸­çš„ä½ç½®æ˜¯æ ¹æ®ç›®æ ‡æ ˆå¸§åœ¨è°ƒç”¨æ ˆä¸­çš„ä½ç½® // è®¡ç®—çš„ï¼Œè€Œä¸æ˜¯æ·»åŠ åˆ°å¤´éƒ¨ã€‚ addOneOpenDeferFrame(gp, 0, nil)\t} } else {\t// deferæ˜¯å †æˆ–æ ˆåˆ†å¸ƒæ—¶ // getargp()ï¼šè®¾ç½®ä¸ºå½“å‰gopanic()å‡½æ•°æ ˆå¸§ä¸Šargs to calleeåŒºé—´çš„èµ·å§‹åœ°å€ï¼Œ // recover()å‡½æ•°é€šè¿‡è¿™ä¸ªå€¼æ¥åˆ¤æ–­è‡ªèº«æ˜¯å¦ç›´æ¥è¢«deferå‡½æ•°è°ƒç”¨ p.argp = unsafe.Pointer(getargp()) // è¯¥å€¼åœ¨fnæ‰§è¡Œå‡½æ•°ä¸­ç”¨äºrecoverå‡½æ•°æ¯”è¾ƒåˆ¤æ–­ // æ‰§è¡Œdeferæ³¨å†Œçš„å‡½æ•°ï¼Œå¦‚æœè¿™é‡Œåˆå‘ç”Ÿäº†panicæ—¶åˆ™å½“å‰deferå¹¶æœªè¢«æ¸…é™¤ï¼Œåˆä¼šä»æ–°gopanic d.fn()\t} // ä¸ºä»€ä¹ˆå‰é¢è®¾ç½®äº†argpå€¼è¿™é‡Œåˆè¦æ¸…é™¤æ‰ï¼Ÿ // å› æ­¤d.fn()æ‰§è¡Œçš„deferå‡½æ•°ä¸­å¯èƒ½ä¼šæœ‰recover()å‡½æ•°ï¼Œéœ€è¦åˆ¤æ–­argpçš„å€¼ p.argp = nil // æ¸…é™¤ // 2.2) é‡Šæ”¾_deferç»“æ„ // Deferred function did not panic. Remove d. // // è°ƒç”¨å®Œd.fn()å‡½æ•°åï¼Œä¸åº”è¯¥ä¼šå‡ºç°gp._deferä¸ç­‰äºdè¿™ç§æƒ…å†µã€‚ // å‡å¦‚åœ¨d.fn()å‡½æ•°æ‰§è¡Œçš„è¿‡ç¨‹ä¸­æ²¡æœ‰é€ æˆæ–°çš„panicï¼Œé‚£ä¹ˆæ‰€æœ‰æ–°æ³¨å†Œçš„deferéƒ½åº”è¯¥åœ¨ // d.fn()å‡½æ•°è¿”å›çš„æ—¶å€™è¢«deferreturn()å‡½æ•°ç§»å‡ºé“¾è¡¨ã€‚ // å‡å¦‚d.fn()å‡½æ•°æ‰§è¡Œè¿‡ç¨‹ä¸­é€ æˆäº†æ–°çš„panicï¼Œè‹¥æ²¡æœ‰recoverï¼Œåˆ™ä¸ä¼šå†å›åˆ°è¿™é‡Œï¼Œ // è‹¥ç»recoverä¹‹åå†å›åˆ°è¿™é‡Œï¼Œåˆ™æ‰€æœ‰åœ¨d.fn()å‡½æ•°æ‰§è¡Œè¿‡ç¨‹ä¸­æ³¨å†Œçš„deferä¹Ÿ // éƒ½åº”è¯¥åœ¨d.fn()å‡½æ•°è¿”å›ä¹‹å‰è¢«ç§»é™¤é“¾è¡¨ã€‚ if gp._defer != d {\tthrow(\u0026#34;bad defer entry in panic\u0026#34;) } // å½“å‰deferæ‰§è¡Œå®Œéœ€è¦æŠŠ_panicæ ‡è®°ä¸ºnilï¼Œåé¢ä¼šåˆ é™¤è¿™ä¸ªdefer d._panic = nil\t// trigger shrinkage to test stack copy. See stack_test.go:TestStackPanic //GC() // æŠŠpcå’Œspå­—æ®µä¿å­˜åœ¨å±€éƒ¨å˜é‡ä¸­ï¼Œä¾›æ¥ä¸‹æ¥æ£€æµ‹æ‰§è¡Œrecoveræ—¶ä½¿ç”¨ // æ­¤å¤„é¢spç±»å‹å¿…é¡»æ—¶æŒ‡é’ˆï¼Œå› ä¸ºåç»­å¦‚æœæ ˆè¢«ç§»åŠ¨ï¼Œåªæœ‰æŒ‡é’ˆç±»å‹ä¼šå¾—åˆ°æ›´æ–° pc := d.pc // è¦æ¢å¤çš„PCå’ŒSPçš„å€¼ sp := unsafe.Pointer(d.sp) // must be pointer so it gets adjusted during stack copy if done { // done=trueï¼Œè¿™ä¸€ç»„deferå‡½æ•°å·²æ‰§è¡Œå®Œ // å› æ­¤deferå‡½æ•°å¯ä»¥è¢«é‡Šæ”¾æ‰ d.fn = nil\tgp._defer = d.link // ä»goroutine._deferä¸Šç§»é™¤è‡ªå·± freedefer(d) // å›æ”¶defer } // 2.3)æ£€æµ‹ recover() æ˜¯å¦æ ‡è®°äº†panic // å¦‚æœ d.fn() å‡½æ•°æˆåŠŸåœ°æ‰§è¡Œäº†recover()ï¼Œåˆ™å½“å‰_panicå¯¹è±¡çš„pçš„recoveredå­—æ®µå°±ä¼šè¢«è®¾ç½®ä¸ºtrue // æ­¤å¤„é€šè¿‡æ£€æµ‹åå°±ä¼šæ‰§è¡Œrecoveré€»è¾‘ã€‚è¿™é‡Œæ‰æ˜¯recover()å‡½æ•°çš„å…·ä½“å®ç°åŠŸèƒ½ï¼Œè·³è½¬åˆ°æŒ‡å®šä»£ç å¤„ã€‚ if p.recovered { // 2.3.1) recover()ç”Ÿæ•ˆ // 1. ç§»é™¤å½“å‰_panicï¼Œå› ä¸ºå½“å‰_panicå·²è¢«æ¢å¤ // 2. å‘å‰å¯»æ‰¾ç§»é™¤è¢«æ ‡è®°ä¸ºabortedä¸ºçœŸçš„_panic gp._panic = p.link\t// æŠŠå½“å‰panicä»goroutine._panicä¸Šç§»é™¤æ‰è‡ªå·± // gp._panic != nilï¼šåé¢è¿˜æœ‰ panic // gp._panic.goexitï¼šç”±runtime.Goexit()å‡½æ•°è§¦å‘ // gp._panic.abortedï¼šå½“å‰panicå·²è¢«ç»ˆæ­¢ if gp._panic != nil \u0026amp;\u0026amp; gp._panic.goexit \u0026amp;\u0026amp; gp._panic.aborted {\t// A normal recover would bypass/abort the Goexit. Instead, // we return to the processing loop of the Goexit. // // æ­£å¸¸æ¢å¤å°† bypass/abortåˆ° Goexitã€‚ ç›¸åï¼Œæˆ‘ä»¬è¿”å›åˆ° Goexit çš„å¤„ç†å¾ªç¯ã€‚ gp.sigcode0 = uintptr(gp._panic.sp) // å¹¶æ²¡æœ‰å€¼ gp.sigcode1 = uintptr(gp._panic.pc) // mcallå‡½æ•°ä»å½“å‰gæ ˆåˆ‡æ¢åˆ°g0æ ˆï¼Œåœ¨æ‰§è¡Œrecoveryå‡½æ•°ï¼Œæ¢å¤åæ˜¯æ¥åˆ°ä»å½“å‰æœ€æ–°panicçš„å¤„å¾€ä¸‹æ‰§è¡Œ // recoveryå‡½æ•°åˆ¤æ–­æ ˆæº¢å‡ºåï¼Œç›´æ¥æŠŠspå’Œpcå€¼èµ‹å€¼ç»™å½“å‰goroutineçš„schedç„¶åä½¿ç”¨gogoå‡½æ•°å†æ¬¡è¢«è°ƒåº¦èµ·æ¥æ¥åˆ°æ‰§è¡Œ mcall(recovery)\t// è¿™ç§æƒ…å†µåº”è¯¥æŠ¥é”™ // ä»è¿™é‡Œè·³è½¬åˆ°deferreturnå‡½æ•° throw(\u0026#34;bypassed recovery failed\u0026#34;) // mcall should not return åº”è¯¥æ°¸è¿œä¸ä¼šè¿”å›åˆ°è¿™é‡Œ } // è§£é”panicæ ‡å¿—ï¼Œruntime.main()å¯ä»¥ç»§ç»­æ‰§è¡Œ atomic.Xadd(\u0026amp;runningPanicDefers, -1)\t// After a recover, remove any remaining non-started, // open-coded defer entries, since the corresponding defers // will be executed normally (inline). Any such entry will // become stale once we run the corresponding defers inline // and exit the associated stack frame. We only remove up to // the first started (in-progress) open defer entry, not // including the current frame, since any higher entries will // be from a higher panic in progress, and will still be // needed. d := gp._defer var prev *_defer if !done { // Skip our current frame, if not done. It is // needed to complete any remaining defers in // deferreturn() // // è·³è¿‡å½“å‰å¸§ï¼Œå¦‚æœè¿˜æ²¡æœ‰å®Œæˆã€‚éœ€è¦åœ¨deferreturn()ä¸­å®Œæˆæ‰€æœ‰å‰©ä½™çš„å»¶è¿Ÿ // open coded deferæ—¶å‘ç”Ÿäº†recoveræ—¶ã€‚ prev = d d = d.link } for d != nil { if d.started { // This defer is started but we // are in the middle of a // defer-panic-recover inside of // it, so don\u0026#39;t remove it or any // further defer entries // // è¿™ä¸ªdeferå·²ç»å¯åŠ¨ï¼Œä½†æ˜¯æˆ‘ä»¬æ­£åœ¨å®ƒå†…éƒ¨è¿›è¡Œä¸€ä¸ª defer-panic-recovery // æ‰€ä»¥ä¸è¦åˆ é™¤å®ƒæˆ–ä»»ä½•è¿›ä¸€æ­¥çš„deferæ¡ç›® break } if d.openDefer { if prev == nil { gp._defer = d.link } else { prev.link = d.link } newd := d.link freedefer(d) d = newd } else { prev = d d = d.link } } gp._panic = p.link // Aborted panics are marked but remain on the g.panic list. // Remove them from the list. // // å¾ªç¯ç§»é™¤é“¾è¡¨å¤´éƒ¨æ‰€æœ‰å·²ç»æ ‡è®°ä¸ºabortedçš„_panic // è¿™é‡Œå¯ä»¥çœ‹å‡ºå½“æœ€åä¸€ä¸ªpanicè¢«æ¢å¤å‰é¢çš„æ‰€æœ‰å·²æ ‡è®°abortedä¸­æ­¢çš„panicä¼šè¢«ç§»é™¤ã€‚ for gp._panic != nil \u0026amp;\u0026amp; gp._panic.aborted { gp._panic = gp._panic.link } // å¦‚æœæ²¡æœ‰å‘ç”Ÿpanicï¼Œåˆ™æ­¤æ—¶gp._panicåº”è¯¥ä¸ºnilï¼Œä¸ä¸ºnilå°±è¡¨æ˜å‘ç”Ÿäº†åµŒå¥—çš„panic // è€Œä¸”åªæ˜¯å†…å±‚çš„panicè¢«recover if gp._panic == nil { // must be done with signal gp.sig = 0 } // Pass information about recovering frame to recovery. // è¦æ¢å¤çš„PCå’ŒSPçš„å€¼ï¼Œä¹Ÿå°±æ˜¯å½“å‰deferæ³¨å†Œçš„åä¸€æ¡æŒ‡ä»¤å¤„ï¼Œæ˜¯ä¸€æ¡JMPæŒ‡ä»¤ // è·³è½¬å»æ‰§è¡Œdeferreturn()å‡½æ•°ã€‚ gp.sigcode0 = uintptr(sp) // éœ€è¦æ¢å¤åˆ°çš„SPåœ°å€ï¼Œä¹Ÿå°±æ˜¯æ³¨å†Œdeferå‡½æ•°çš„æ ˆé¡¶å¯„å­˜å™¨ gp.sigcode1 = pc // éœ€è¦æ¢å¤åˆ°IPåœ°å€ï¼Œä¹Ÿå°±æ˜¯æ³¨å†Œdeferå‡½æ•°çš„ä¸‹ä¸€æ¡æŒ‡ä»¤å¤„ // recoveryå‡½æ•°è´Ÿè´£ç”¨å­˜å‚¨åœ¨sigcode0å’Œsigcode1ä¸­çš„spå’Œpcæ¢å¤gpçš„æ‰§è¡ŒçŠ¶æ€ mcall(recovery) // mcallå‡½æ•°åˆ‡æ¢åˆ°ç³»ç»Ÿg0æ ˆå»è°ƒç”¨gogoå‡½æ•°æ‰§è¡Œè·³è½¬ throw(\u0026#34;recovery failed\u0026#34;) // mcall should not return } } // æ‰€æœ‰çš„deferæ³¨å†Œå‡½æ•°éƒ½æ²¡æœ‰recoverï¼Œæœ€åä¼šåˆ°è¿™é‡Œå»æ‰“å°é”™è¯¯ä¿¡æ¯ // ran out of deferred calls - old-school panic now // Because it is unsafe to call arbitrary user code after freezing // the world, we call preprintpanics to invoke all necessary Error // and String methods to prepare the panic strings before startpanic. // // gp._panicï¼šä¿å­˜çš„æœ€æ–°çš„panic preprintpanics(gp._panic)\t// æŠŠpanicçš„å‚æ•°è§£ææ”¾å…¥arg // æ‰“å°panicä¿¡æ¯ï¼Œå¹¶ç»“æŸå½“å‰è¿›ç¨‹ fatalpanic(gp._panic) // should not return // å‘ä¸€ä¸ªnilçš„åœ°å€å†™å…¥å€¼ï¼Œä¼šæŠ¥é”™ï¼Œä¸‹é¢è¿™è¡Œä»£ç æ˜¯é˜²æ­¢ä¸‡ä¸€ï¼Œä¸åº”è¯¥æ‰§è¡Œåˆ°è¿™é‡Œåœ¨å‰ä¸€ä¸ªå‡½æ•°ä¸­ä¼šç»“æŸè°ƒè¿›ç¨‹ *(*int)(nil) = 0 // not reached } runOpenDeferFrame() å¾ªç¯æ‰§è¡ŒæŒ‡å®šæ ˆå¸§ä¸Šæ‰€æœ‰çš„open coded deferå‡½æ•°ã€‚ è¿”å›å€¼è¡¨ç¤ºæ ˆå¸§ä¸Šæ‰€æœ‰çš„open coded deferå‡½æ•°æ˜¯å¦éƒ½æ‰§è¡Œå®Œæ¯•ï¼Œå¦‚æœå› ä¸ºæŸä¸ªdeferå‡½æ•°æ‰§è¡Œäº†recover è€Œé€ æˆå¾ªç¯ä¸­æ­¢ï¼Œåˆ™è¿”å›å€¼ä¸ºfalseã€‚ addOneOpenDeferFrame()å’ŒrunOpenDeferFrame()å‡½æ•°éƒ½ä¾èµ–ç¬¦å·è¡¨ä¸­ç›®æ ‡æ ˆå¸§çš„OpenCodedDerferInfoã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 // runOpenDeferFrame runs the active open-coded defers in the frame specified by // d. It normally processes all active defers in the frame, but stops immediately // if a defer does a successful recover. It returns true if there are no // remaining defers to run in the frame. func runOpenDeferFrame(gp *g, d *_defer) bool { done := true fd := d.fd deferBitsOffset, fd := readvarintUnsafe(fd) nDefers, fd := readvarintUnsafe(fd) // å½“å‰çš„dfä½ï¼Œè®°å½•ç€deferæ‰§è¡Œä¸å¦çš„ç›¸å…³ä¿¡æ¯ deferBits := *(*uint8)(unsafe.Pointer(d.varp - uintptr(deferBitsOffset))) // éå†å½“å‰å‡½æ•°æ³¨å†Œçš„deferåˆ—è¡¨ for i := int(nDefers) - 1; i \u0026gt;= 0; i-- { // read the funcdata info for this defer var closureOffset uint32 closureOffset, fd = readvarintUnsafe(fd) if deferBits\u0026amp;(1\u0026lt;\u0026lt;i) == 0 { // å½“å‰ä½æ²¡æœ‰æ³¨å†Œdeferç›´æ¥è·³è¿‡ continue } closure := *(*func())(unsafe.Pointer(d.varp - uintptr(closureOffset))) d.fn = closure // deferæ³¨å†Œçš„å‡½æ•° deferBits = deferBits \u0026amp;^ (1 \u0026lt;\u0026lt; i) // æ¸…é™¤å½“å‰æ ‡è®°ä½ *(*uint8)(unsafe.Pointer(d.varp - uintptr(deferBitsOffset))) = deferBits // å›å†™ç»™å†…å­˜ p := d._panic // Call the defer. Note that this can change d.varp if // the stack moves. // å†æ¬¡panicæ—¶ï¼Œç›´æ¥è·³è½¬ï¼Œå…¶ä»–æƒ…å†µç»§ç»­èµ°ä¸‹é¢æµç¨‹ deferCallSave(p, d.fn) // è°ƒç”¨fnå‡½æ•°ï¼Œå¯èƒ½recoverä¹Ÿå¯èƒ½panic // è¿™ç§æƒ…å†µæ˜¯åˆpanic if p != nil \u0026amp;\u0026amp; p.aborted { break } d.fn = nil // å¸®åŠ©GC // è¯¥panicæ˜¯å¦è¢«æ¢å¤ if d._panic != nil \u0026amp;\u0026amp; d._panic.recovered { done = deferBits == 0 // deferBits == 0 è¡¨ç¤ºopen code defersçš„deferä»¥è¿è¡Œå®Œ break } } return done } recovery() è¯¥å‡½æ•°è´Ÿè´£ç”¨äºå­˜å‚¨åœ¨sigcode0å’Œsigcode1ä¸­çš„spå’Œpcæ¢å¤gpçš„æ‰§è¡ŒçŠ¶æ€ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 // Unwind the stack after a deferred function calls recover // after a panic. Then arrange to continue running as though // the caller of the deferred function returned normally. func recovery(gp *g) { // Info about defer passed in G struct. sp := gp.sigcode0 pc := gp.sigcode1 // d\u0026#39;s arguments need to be in the stack. // // ç¡®ä¿spä¸ä¸º0ï¼Œå¹¶åœ¨åœ¨gpçš„æ ˆä¸­ if sp != 0 \u0026amp;\u0026amp; (sp \u0026lt; gp.stack.lo || gp.stack.hi \u0026lt; sp) { print(\u0026#34;recover: \u0026#34;, hex(sp), \u0026#34; not in [\u0026#34;, hex(gp.stack.lo), \u0026#34;, \u0026#34;, hex(gp.stack.hi), \u0026#34;]\\n\u0026#34;) throw(\u0026#34;bad recovery\u0026#34;) } // Make the deferproc for this d return again, // this time returning 1. The calling function will // jump to the standard return epilogue. // // æŠŠspå’Œpcèµ‹å€¼ç»™gp.schedä¸­å¯¹åº”çš„å­—æ®µï¼Œ // å¹¶æŠŠè¿”å›å€¼è®¾ç½®ä¸º1ã€‚ gp.sched.sp = sp // ä¸ºè·³è½¬å‡†å¤‡ SP gp.sched.pc = pc // ä¸ºè·³è½¬å‡†å¤‡ PC gp.sched.lr = 0 gp.sched.ret = 1 // è®¾ç½®è¿”å›å€¼ 1,è¿™é‡Œå°±æ˜¯AX=1çš„ç”±æ¥ // è°ƒç”¨gogo()å‡½æ•°ä¹‹åï¼Œgpçš„æ ˆæŒ‡é’ˆå’ŒæŒ‡ä»¤æŒ‡é’ˆæœºä¼šæ¢å¤åˆ°spå’Œpcçš„ä½ç½®ï¼Œ // è€Œè¿™ä¸ªä½ç½®æ˜¯deferproc()å‡½æ•°é€šè¿‡getcallersp()å‡½æ•°å’Œgetcallerpc()å‡½æ•°è·å¾—çš„ã€‚ gogo(\u0026amp;gp.sched) // è°ƒç”¨gogoå‡½æ•°å»è·³è½¬ } preprintpanics() 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 // Call all Error and String methods before freezing the world. // Used when crashing with panicking. func preprintpanics(p *_panic) { // é˜²æ­¢panic defer func() { if recover() != nil { throw(\u0026#34;panic while printing panic value\u0026#34;) } }() for p != nil { // p.argæ˜¯anyç±»å‹ï¼Œæ¥è‡ªpanic(v any) switch v := p.arg.(type) { case error: // å®ç°äº†erroræ¥å£ p.arg = v.Error() // ä¿å­˜ä¿¡æ¯ string case stringer:\t// å®ç°äº†stringeræ¥å£ p.arg = v.String() // ä¿å­˜ä¿¡æ¯ string } p = p.link // æŒ‡å‘ä¸‹ä¸€ä¸ªpanic } } printpanics() 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 // Print all currently active panics. Used when crashing. // Should only be called after preprintpanics. func printpanics(p *_panic) { if p.link != nil { // é€’å½’å›è°ƒä»æ³¨å†Œç¬¬ä¸€ä¸ªpanicå¼€å§‹ printpanics(p.link) // ä¸æ˜¯goexitï¼Œæ‰“å°ç¬¦å· if !p.link.goexit { print(\u0026#34;\\t\u0026#34;) } } // æ˜¯goexitè§¦å‘ç›´æ¥è¿”å› if p.goexit { return } print(\u0026#34;panic: \u0026#34;) // æ‰“å°é”™è¯¯ä¿¡æ¯ printany(p.arg) // å¦‚æœå·²ç»recoveredï¼Œåˆ™æ‰“å° [recovered] if p.recovered { print(\u0026#34; [recovered]\u0026#34;) } print(\u0026#34;\\n\u0026#34;) } recover() 1 2 3 4 5 6 7 8 9 10 // The recover built-in function allows a program to manage behavior of a // panicking goroutine. Executing a call to recover inside a deferred // function (but not any function called by it) stops the panicking sequence // by restoring normal execution and retrieves the error value passed to the // call of panic. If recover is called outside the deferred function it will // not stop a panicking sequence. In this case, or when the goroutine is not // panicking, or if the argument supplied to panic was nil, recover returns // nil. Thus the return value from recover reports whether the goroutine is // panicking. func recover() any gorecover() è¯¥å‡½æ•°å¿…é¡»åœ¨deferä¸­ä½œä¸ºä¸€éƒ¨åˆ†è¢«ä½¿ç”¨ã€‚ è¯¥å‡½æ•°ä¸»è¦ä½œç”¨æ˜¯è®¾ç½® painc çš„ recovered è¡¨ç¤ºå·²è¢«æ¢å¤ã€‚ è¢«æ¢å¤çš„panicä¼šè·³è½¬åˆ°æ¢å¤çš„deferæ³¨å†Œä¸‹ä¸€è¡ŒæŒ‡ä»¤å¤„é€šè¿‡ifæ¡ä»¶è·³è½¬åˆ°deferreturnå‡½æ•°å¤„å»æ‰§è¡Œå‰©ä½™çš„deferã€‚ gopanic()å‡½æ•°çš„ä¸»è¦é€»è¾‘ï¼Œå…¶ä¸­forå¾ªç¯æ¯è°ƒç”¨å®Œä¸€ä¸ªdeferå‡½æ•°éƒ½ä¼šæ£€æŸ¥p.recoveredå­—æ®µï¼Œå¦‚æœå€¼ä¸ºtrueå°±æ‰§è¡Œ recoveré€»è¾‘ã€‚ä¹Ÿå°±æ˜¯è¯´çœŸæ­£çš„recoveré€»è¾‘æ˜¯åœ¨gopanic()å‡½æ•°ä¸­å®ç°çš„ï¼Œdeferå‡½æ•°ä¸­è°ƒç”¨äº†å†…ç½®å‡½æ•°recover()ï¼Œ å®é™…ä¸Šåªä¼šè®¾ç½®_panicçš„ä¸€ç§çŠ¶æ€ã€‚å†…ç½®å‡½æ•°recover()å¯¹åº”runtimeä¸­gorecover()å‡½æ•°ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 // The implementation of the predeclared function recover. // Cannot split the stack because it needs to reliably // find the stack segment of its caller. // // TODO(rsc): Once we commit to CopyStackAlways, // this doesn\u0026#39;t need to be nosplit. //go:nosplit func gorecover(argp uintptr) any { // argp å‚æ•°æ ¹æ®AXå¯„å­˜å™¨ä¼ é€’ // 1. è¯¥å‚æ•°æ˜¯æ¥è‡ªè°ƒç”¨å½“å‰deferå‡½æ•°çš„è°ƒç”¨è€…SPæ ˆ // 2. å› æ­¤é¡¶å±‚çš„deferèƒ½æ•è·ä¸‹å±‚çš„panic // Must be in a function running as part of a deferred call during the panic. // Must be called from the topmost function of the call // (the function used in the defer statement). // p.argp is the argument pointer of that topmost deferred function call. // Compare against argp reported by caller. // If they match, the caller is the one who can recover. // // å¿…é¡»åœ¨ä¸€ä¸ªå‡½æ•°ä¸­ï¼Œè¯¥å‡½æ•°ä½œä¸º panic æœŸé—´ defer è°ƒç”¨çš„ä¸€éƒ¨åˆ†è¿è¡Œ // å¿…é¡»ä»è°ƒç”¨çš„æœ€é¡¶å±‚å‡½æ•°è°ƒç”¨ (åœ¨deferè¯­å¥ä¸­ä½¿ç”¨çš„å‡½æ•°) // p.argp æ˜¯æœ€ä¸Šé¢é‚£ä¸ª defer å‡½æ•°è°ƒç”¨çš„å®å‚æŒ‡é’ˆ // ä¸è°ƒç”¨è€…æŠ¥å‘Šçš„ argp è¿›è¡Œæ¯”è¾ƒ // å¦‚æœå®ƒä»¬åŒ¹é…ï¼Œè°ƒç”¨æ–¹å°±å¯ä»¥æ¢å¤ gp := getg() // è·å–å½“å‰æ­£åœ¨æ‰§è¡Œçš„g p := gp._panic // æœ€æ–°æ³¨å†Œçš„panic // p != nilï¼šå­˜åœ¨æ³¨å†Œçš„panic // !p.goexitï¼šä¸æ˜¯goexitå‡½æ•°è§¦å‘çš„ // !p.recoveredï¼šè¯¥panicæ²¡æœ‰è¢«æ¢å¤ // argp == uintptr(p.argp)ï¼šå¿…é¡»åœ¨deferå‡½æ•°ä¸­ç›´æ¥è°ƒç”¨recoverå‡½æ•°æ‰æœ‰ç”¨ï¼Œä¸å¯åµŒå¥—åœ¨å…¶ä»–å‡½æ•°ä¸­ // 1. p.argpï¼šå­˜å‚¨çš„æ˜¯è°ƒç”¨panicçš„è°ƒç”¨è€…æ ˆSPä½ç½® if p != nil \u0026amp;\u0026amp; !p.goexit \u0026amp;\u0026amp; !p.recovered \u0026amp;\u0026amp; argp == uintptr(p.argp) { p.recovered = true // æ ‡è¯†å½“å‰è¿™ä¸ªpanicä»å¼‚å¸¸æˆ–é”™è¯¯åœºæ™¯ä¸­æ¢å¤ return p.arg // è¯¥å‚æ•°æ˜¯panic(v any)ä¼ é€’çš„ç©ºæ¥å£å‚æ•°ï¼Œç›´æ¥è¿”å›ç»™recoverå‡½æ•°è°ƒç”¨è€…å³å¯ } return nil } å†…ç½®å‡½æ•°recover()æ˜¯æ²¡æœ‰å‚æ•°çš„ï¼Œä½†æ˜¯gorecover()å‡½æ•°å´æœ‰ä¸€ä¸ªå‚æ•°argpï¼Œè¿™ä¹Ÿæ˜¯ç¼–è¯‘å™¨åšçš„æ‰‹è„šã€‚ ç¼–è¯‘å™¨ä¼šæŠŠè°ƒç”¨è€…çš„args from calleråŒºé—´çš„èµ·å§‹åœ°å€ä½œä¸ºå‚æ•°ä¼ é€’ç»™gorecover()å‡½æ•°ã€‚ 1 2 3 4 5 6 func fn() { defer func(a int) { recover() println(a) }(0) } ç»ç¼–è¯‘è½¬æ¢åçš„ç­‰ä»·ä»£ç å¦‚ä¸‹ï¼š 1 2 3 4 5 6 func fn() { defer func(a int) { gorecover(uintptr(unsafe.Pointer(\u0026amp;a))) println(\u0026amp;a) }(0) } ä¸ºä»€ä¹ˆè¦ä¼ é€’è¿™ä¸ªargpå‚æ•°å‘¢ï¼Ÿ ä»ä»£ç é€»è¾‘æ¥çœ‹ï¼Œgorecover()å‡½æ•°ä¼šæŠŠå®ƒè·Ÿå½“å‰_panicå¯¹è±¡pçš„argpå­—æ®µæ¯”è¾ƒï¼Œåªæœ‰ç›¸ç­‰æ—¶æ‰ä¼šæŠŠp.recoveredè®¾ç½®ä¸ºtrueã€‚ ä»å‚æ•°é€»è¾‘ä¸Šçœ‹argp == uintptr(p.argp)æ˜¯ä¸ç›¸ç­‰çš„ï¼Œç¼–è¯‘å™¨ä¼šåœ¨è°ƒç”¨fn()å‡½æ•°ä¸­æ’å…¥ä»¥ä¸‹ä»£ç é€»è¾‘æ¥ä¿®æ­£argpçš„å€¼ã€‚ å¦‚æœgp._panicä¸ä¸ºnilä¸”gp._panic.argpçš„å€¼ç­‰äºå½“å‰å‡½æ•°æ ˆå¸§args from calleråŒºé—´çš„èµ·å§‹åœ°å€ï¼Œå°±æŠŠå®ƒçš„å€¼æ”¹æˆå½“å‰ å‡½æ•°æ ˆå¸§args to calleeåŒºé—´çš„èµ·å§‹åœ°å€ã€‚ä¸ç¼–è¯‘å™¨æ’å…¥çš„è¿™äº›æŒ‡ä»¤ç­‰ä»·çš„Goä»£ç å¦‚ä¸‹ï¼š 1 2 3 4 5 6 7 gp := getg() if gp._panic != nil { // è¿™ä¸€æ¡é™åˆ¶åªæ˜¯é™åˆ¶äº†recover()å¿…é¡»åœ¨deferå‡½æ•°ä¸­ã€ç›´æ¥è°ƒç”¨ã€‘æ‰èµ·ä½œç”¨ã€‚ if gp._panic.argp == uintptr(unsafe.Pointer(\u0026amp;argtype)) { gp._panic.argp = getargp(0) } } Goè¯­è¨€å¯¹recoverå¼ºåŠ çš„ä¸€æ¡é™åˆ¶ï¼šå¿…é¡»åœ¨deferå‡½æ•°ä¸­ç›´æ¥è°ƒç”¨recover()å‡½æ•°æ‰æœ‰ç”¨ï¼Œä¸å¯åµŒå¥—åœ¨å…¶ä»–å‡½æ•°ä¸­ã€‚ recover()å‡½æ•°è°ƒç”¨æœ‰æ•ˆçš„ç¤ºä¾‹ä»£ç ï¼š 1 2 3 4 5 func fn() { defer func() { recover() }() } recover()å‡½æ•°è°ƒç”¨æ— æ•ˆçš„ç¤ºä¾‹ä»£ç ï¼š 1 2 3 4 5 6 7 8 9 func fn() { defer func() { r() }() } func r() { recover() } Goè¯­è¨€çš„recoverä¸å…¶ä»–è¯­è¨€çš„tryå’Œcatchæœ‰æ˜æ˜¾çš„ä¸åŒï¼Œå³ä¸åƒcatchè¯­å¥é‚£æ ·èƒ½å¤Ÿé™å®šå¼‚å¸¸çš„ç±»å‹ã€‚ å¦‚æœæ²¡æœ‰å¯¹recoverçš„è¿™ç§é™åˆ¶ï¼Œå°±ä¼šä½¿ä»£ç è¡Œä¸ºå˜å¾—ä¸å¯æ§ï¼Œpanicå¯èƒ½ç»å¸¸ä¼šè¢«æŸä¸ªæ·±åº¦åµŒå¥—çš„recoveræ¢å¤ï¼Œç„¶è€Œè¿™å¹¶ä¸æ˜¯å¼€å‘è€…æƒ³è¦çš„ã€‚ panic()æ±‡ç¼– 1 2 3 4 5 package main func main() { panic(\u0026#34;111111\u0026#34;) } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 TEXT main.main(SB) /mnt/hgfs/g/hello1/hello.go hello.go:3 0x45b4a0 493b6610 cmp rsp, qword ptr [r14+0x10] hello.go:3 0x45b4a4 7622 jbe 0x45b4c8 hello.go:3 0x45b4a6 4883ec18 sub rsp, 0x18 hello.go:3 0x45b4aa 48896c2410 mov qword ptr [rsp+0x10], rbp hello.go:3 0x45b4af 488d6c2410 lea rbp, ptr [rsp+0x10] # å‡†å¤‡ç©ºæ¥å£å‚æ•° AX=rip+0x4c65 etype.type *typeç±»å‹ hello.go:4 0x45b4b4 488d05654c0000 lea rax, ptr [rip+0x4c65] # å‡†å¤‡ç©ºæ¥å£å‚æ•° BX=rip+0x1463e etype.data uintptrç±»å‹ hello.go:4 0x45b4bb 488d1d3e460100 lea rbx, ptr [rip+0x1463e] # gopanicæ ‡è¯†panicå¼€å§‹ï¼ŒAXå’ŒBXå¯„å­˜å™¨å­˜å‚¨çš„æ˜¯è¦ä¼ é€’çš„æ•°æ® hello.go:4 0x45b4c2 e8d946fdff call $runtime.gopanic hello.go:4 0x45b4c7 90 nop hello.go:3 0x45b4c8 e893cdffff call $runtime.morestack_noctxt .:0 0x45b4cd ebd1 jmp $main.main ","permalink":"https://heliu.site/posts/golang/func/painc-theory/","summary":"panicã€recover ç›¸å…³æµç¨‹ä»‹ç»ã€‚","title":"paincã€recover(åŸç†)"},{"content":" æ¥å£ç±»å‹ï¼šæ˜¯Goè¯­è¨€çš„ä¸€ç§æ•°æ®ç±»å‹ï¼Œè¢«è®¾è®¡æˆä¸€ä¸ªå®¹å™¨è£…è½½å…¶ä»–éæ¥å£ç±»å‹ã€‚ æ¥å£æ˜¯ä»€ä¹ˆ æ¥å£æ˜¯èƒ½è£…è½½ä»»æ„å…¶ä»–ç±»å‹çš„å®¹å™¨ï¼Œæ¥å£åˆ†ã€ç©ºæ¥å£ã€‘å’Œã€éç©ºæ¥å£ã€‘ã€‚ ç©ºæ¥å£ï¼šèƒ½è£…è½½å…¶ä»–ä»»æ„éæ¥å£ç±»å‹ã€‚ éç©ºæ¥å£ï¼šä¹Ÿèƒ½è£…è½½å…¶ä»–éæ¥å£ç±»å‹ï¼Œä½†æ˜¯å¿…é¡»å®ç°äº†éç©ºæ¥å£çš„æ‰€æœ‰æ–¹æ³•é›†ã€‚ éç©ºæ¥å£ å®šä¹‰äº†ä¸€ç»„æ–¹æ³•é›†åˆï¼Œè¿™äº›æ–¹æ³•é›†åˆåªæ˜¯è¢«å®šä¹‰ï¼Œå¹¶æ²¡æœ‰åœ¨æ¥å£ä¸­å®ç°ã€‚ å› æ­¤éç©ºæ¥å£è£…è½½çš„ç±»å‹å¿…å®šæ˜¯å®ç°äº†éç©ºæ¥å£å®šä¹‰çš„æ‰€æœ‰æ–¹æ³•ã€‚ æ¥å£ä¸­å®šä¹‰çš„æ–¹æ³•å¦‚æœæœ‰éå¯¼å‡ºæ–¹æ³•æ—¶ï¼ˆä¹Ÿå°±æ˜¯å°å†™å­—æ¯å¼€å¤´çš„æ–¹æ³•ï¼‰åªèƒ½åœ¨å®šä¹‰è¯¥æ¥å£çš„åŒä¸€åŒ…ä¸­è¢«å…¶ä»–ç±»å‹å®ç°ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 package gom type Connectable interface { // è¿™é‡Œæ¥å£å®šä¹‰éå¯¼å‡ºæ–¹æ³• // åªèƒ½æ˜¯gomè¿™ä¸ªåŒ…èŒƒå›´çš„ç±»å‹æ‰èƒ½å®ç°Connectableæ¥å£ connect() } type Point struct { X float64 } // Point å®ç°äº† Connectable æ¥å£ // gom ä»¥å¤–çš„åŒ…å®ç°ä¸äº† Connectable æ¥å£ï¼Œå› ä¸ºåŒ…å«å°å†™æ–¹æ³• func (p Point) connect() { } éç©ºæ¥å£å­˜å‚¨ç»“æ„ï¼š 1 2 3 4 type iface struct { itab *itab // å­˜å‚¨éç©ºæ¥å£å’Œè£…è½½ç±»å‹çš„ç›¸å…³ä¿¡æ¯ data unsafe.Pointer // è£…è½½ç±»å‹çš„åŠ¨æ€å€¼åœ°å€ } ç©ºæ¥å£ æ²¡æœ‰å¿…é¡»å®ç°çš„ä¸€ç»„æ–¹æ³•é›†åˆï¼Œå› æ­¤éç©ºæ¥å£èƒ½è£…è½½ä»»æ„å…¶ä»–ç±»å‹ã€‚ æ‰€æœ‰çš„ç±»å‹åŒ…æ‹¬è‡ªå®šä¹‰ç±»å‹å…¶å®éƒ½å·²ç»å®ç°äº†ç©ºæ¥å£interface{}ï¼Œæ‰€ä»¥ç©ºæ¥å£interface{}å¯ä»¥å­˜ä»»æ„ç±»å‹ã€‚ ç©ºæ¥å£å­˜å‚¨ç»“æ„ï¼š 1 2 3 4 type eface struct { typ *_type // å­˜å‚¨ç±»å‹çš„ç±»å‹å…ƒæ•°æ®ä¿¡æ¯ data unsafe.Pointer // å­˜å‚¨ç±»å‹çš„å­˜å‚¨å€¼åœ°å€ } ç©ºæ¥å£å’Œéç©ºæ¥å£ æ¥å£ç±»å‹çš„åˆå§‹åŒ–å˜é‡çš„å€¼ä¸ºnilã€‚ 1 2 3 4 5 6 7 8 9 10 11 // ç©ºæ¥å£åˆå§‹å€¼ type eface struct { typ *_type // nil data unsafe.Pointer // nil } // éç©ºæ¥å£åˆå§‹å€¼ type iface struct { itab *itab // nil data unsafe.Pointer // nil } ç©ºæ¥å£ç¤ºä¾‹ 1 2 3 4 5 6 7 8 9 // æ¥å£iå¯ä»¥è£…è½½ä»»æ„å…¶ä»–ç±»å‹ var i interface{} = 99 // type eface struct { // typ *_type ---\u0026gt; å­˜å‚¨çš„æ˜¯intç±»å‹çš„_typeæŒ‡é’ˆ // data uintptr ---\u0026gt; å­˜å‚¨çš„åœ°å€æŒ‡é’ˆå†…å­˜æ˜¯99 // } i = 44.09 // æ¥å£å­˜å‚¨çš„æ˜¯float64ç±»å‹ i = \u0026#34;All\u0026#34; // æ¥å£å­˜å‚¨çš„æ˜¯stringç±»å‹ éç©ºæ¥å£ç¤ºä¾‹ æ¥å£å°±æ˜¯ä¸€ç»„æŠ½è±¡æ–¹æ³•çš„é›†åˆï¼Œå®ƒå¿…é¡»ç”±å…¶ä»–éinterfaceç±»å‹ï¼ˆå…·ä½“ç±»å‹ï¼‰å®ç°ï¼Œè€Œä¸èƒ½è‡ªæˆ‘å®ç°ã€‚ 1 2 3 type Stringer interface{ String() string } å•æ–¹æ³•æ¥å£ç”±æ–¹æ³•åç§°åŠ ä¸Šeråç¼€æˆ–ç±»ä¼¼ä¿®æ”¹æ¥å‘½åï¼Œä»¥æ„é€ ä»£ç†åè¯ï¼Œå¦‚Readerã€Writerã€Formatterã€CloseNotiferç­‰ã€‚ è¿˜æœ‰ä¸€äº›ä¸å¸¸ç”¨çš„æ–¹å¼ï¼ˆå½“åç¼€erä¸åˆé€‚ï¼‰ï¼Œæ¯”å¦‚Recoverableï¼Œæ­¤æ—¶æ¥å£åä»¥ableç»“å°¾ï¼Œæˆ–è€…ä»¥Iå¼€å¤´ç­‰ 1 2 3 4 5 6 7 type Reader interface { Read(p []byte) (n int, err error) } type Writer interface { Write(p []byte) (n int, err error) } åœ¨Goè¯­è¨€ä¸­ï¼Œå¦‚æœæ¥å£çš„æ‰€æœ‰æ–¹æ³•åœ¨æŸä¸ªç±»å‹æ–¹æ³•é›†ä¸­è¢«å®ç°ï¼Œåˆ™è®¤ä¸ºè¯¥ç±»å‹å®ç°äº†è¿™ä¸ªæ¥å£ã€‚ ç±»å‹ä¸ç”¨æ˜¾ç¤ºå£°æ˜å®ç°æ¥å£ï¼Œåªéœ€è¦å®ç°æ¥å£æ‰€æœ‰æ–¹æ³•ï¼Œè¿™æ ·çš„éšå¼å®ç°è§£è€¦äº†å®ç°æ¥å£çš„åŒ…å’Œå®šä¹‰æ¥å£çš„åŒ…ã€‚ åŒä¸€ä¸ªæ¥å£å¯è¢«å¤šä¸ªç±»å‹å®ç°ï¼Œä¸€ä¸ªç±»å‹ä¹Ÿå¯ä»¥å®ç°å¤šä¸ªæ¥å£ï¼š å®ç°æŸä¸ªæ¥å£çš„ç±»å‹ï¼Œè¿˜å¯ä»¥æœ‰å…¶ä»–çš„æ–¹æ³•ï¼Œæ¯”å¦‚å†…åµŒå…¶ä»–å­—æ®µè¿™äº›å­—æ®µåˆ†åˆ«å®ç°äº†éƒ¨åˆ†æ–¹æ³•ä»è€Œå®ç°æ¥å£ã€‚ æœ‰æ—¶ç”šè‡³éƒ½ä¸çŸ¥é“æŸä¸ªç±»å‹å®šä¹‰çš„æ–¹æ³•é›†å·§åˆåœ°å®ç°äº†å¦å¤–ä¸€ä¸ªæ¥å£ã€‚ ç±»å‹éœ€è¦å®ç°æ¥å£æ–¹æ³•é›†ä¸­çš„æ‰€æœ‰æ–¹æ³•ï¼Œç±»å‹å®ç°äº†è¿™ä¸ªæ¥å£ï¼Œé‚£ä¹ˆæ¥å£ç±»å‹çš„å˜é‡ä¹Ÿå°±å¯ä»¥å­˜æ”¾è¯¥ç±»å‹çš„å€¼ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 // B æ¥å£ä¸­æœ‰éå¯¼å‡ºæ–¹æ³•æ—¶ï¼Œåªèƒ½åœ¨æœ¬åŒ…ä¸­è¢«å®ç°ï¼Œå…¶ä»–åŒ…ä¸­å®ç°ä¸äº†è¯¥æ¥å£ // 1. è¿™ç§æƒ…å†µå¸¸å¸¸è¢«ç”¨äºï¼ŒæŸä¸ªå¯¼å‡ºçš„æ¥å£ä¸æƒ³è®©å¤–éƒ¨åŒ…çš„å…¶ä»–ç±»å®ç°æ—¶ã€‚ // åœ¨å¯¼å‡ºæ¥å£ä¸­å®šä¹‰éå¯¼å‡ºæ–¹æ³•æ—¶ // 2. åœ¨éå¯¼å‡ºæ¥å£ä¸­å®šä¹‰å…¨éƒ¨éƒ½æ˜¯å¯¼å‡ºæ–¹æ³•ï¼Œå¤–åŒ…èƒ½å®ç°è¯¥æ¥å£ï¼Œä½†æ˜¯éå¯¼å‡ºæ¥å£å´ä¸å¯ç”¨ã€‚ type B interface { f() } type A struct { Books int } func (a A) f() { fmt.Println(\u0026#34;A.f()ï¼š\u0026#34;, a.Books) } type I int func (i I) f() { fmt.Println(\u0026#34;I.f()\u0026#34;, i) } func main() { var a A = A{Books: 9} a.f() // A.f(a) // Output: // A.f()ï¼š9 // æ¥å£ç±»å‹å¯æ¥å—ç»“æ„ä½“Açš„å€¼ï¼Œå› ä¸ºç»“æ„ä½“Aå®ç°äº†æ¥å£ var b B = A{Books: 99} b.f() // B.f(b) // Output: // A.f()ï¼š99 // Iæ˜¯intç±»å‹å¼•ç”³å‡ºæ¥çš„æ–°ç±»å‹ var i I = 199 i.f() // Output: // I.f()199 // æ¥å£ç±»å‹å¯æ¥å—æ–°ç±»å‹Içš„å€¼ï¼Œå› ä¸ºæ–°ç±»å‹Iå®ç°äº†æ¥å£ var b2 B = I(299) b2.f() // Output: // I.f()299 } æ¥å£åµŒå…¥ ä¸€ä¸ªæ¥å£å¯ä»¥åŒ…å«ä¸€ä¸ªæˆ–å¤šä¸ªå…¶ä»–çš„æ¥å£ï¼šä½†åœ¨æ¥å£å†…ä¸èƒ½åµŒå…¥ç»“æ„ä½“ã€‚ä¸èƒ½åµŒå…¥æ¥å£è‡ªèº«ï¼Œæˆ–è€…å½¢æˆé—­ç¯ï¼Œå¦åˆ™ç¼–è¯‘ä¼šå‡ºé”™è¯¯ã€‚ æ¥å£åµŒå…¥å½¢æˆé—­ç¯ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // 1. ç¼–è¯‘é”™è¯¯ æ¥å£ä¸èƒ½åµŒå…¥è‡ªèº« ä¼šå½¢æˆæ— é™å¾ªç¯ // Bad \u0026lt;---\u0026gt; Bad é—­ç¯ type Bad interface { Bad } // 2. ç¼–è¯‘é”™è¯¯ æ¥å£ä¹‹å‰äº’ç›¸åµŒå¥—å½¢æˆé—­ç¯ å½¢æˆæ— é™å¾ªç¯ // Bad1 --\u0026gt; Bad2 --\u0026gt; Bad1 é—­ç¯ type Bad1 interface { Bad2 } type Bad2 interface { Bad1 } åµŒå…¥æ¥å£ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 type ReadWrite interface { Read(b Buffer) bool Write(b Buffer) bool } type Lock interface { Lock() Unlock() } // åµŒå…¥å…¶ä»–æ¥å£ type File interface { Lock // åµŒå…¥çš„æ¥å£Lock Close() // è‡ªå¸¦çš„Close()æ–¹æ³• } ç±»å‹æ–­è¨€ å¯ä»¥æŠŠå®ç°äº†æŸä¸ªæ¥å£çš„ç±»å‹å€¼ä¿å­˜åœ¨æ¥å£å˜é‡ä¸­ï¼Œä½†æ˜¯åè¿‡æ¥æŸä¸ªæ¥å£å˜é‡å±äºå“ªä¸ªç±»å‹å‘¢? å¦‚ä½•æ£€æµ‹æ¥å£å˜é‡çš„ç±»å‹å‘¢ï¼Ÿè¿™å°±æ˜¯ç±»å‹æ–­è¨€çš„ä½œç”¨ï¼ˆæ³¨æ„çš„æ˜¯ï¼šæ¥å£æ–­è¨€æ—¶æ˜¯æ¥å£ç‰¹æœ‰çš„ï¼‰ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 type I interface { f() } type T string func (t T) f() { fmt.Println(\u0026#34;T Method\u0026#34;) } type Stringer interface { String() string } func main() { // ç±»å‹æ–­è¨€ var varI I = T(\u0026#34;Tstring\u0026#34;) // 1. éç©ºæ¥å£.(å…·ä½“ç±»å‹) // å¦‚æœæ–­è¨€æˆåŠŸï¼Œvæ˜¯varLè½¬æ¢åˆ°ç±»å‹Içš„å€¼ï¼Œokçš„å€¼æ˜¯true // å¦åˆ™væ˜¯ç±»å‹Tçš„é›¶å€¼ï¼Œokçš„å€¼æ˜¯falseï¼Œä¹Ÿæ²¡æœ‰è¿è¡Œæ—¶é”™è¯¯å‘ç”Ÿ if v, ok := varI.(T); ok { fmt.Println(\u0026#34;varIç±»å‹æ–­è¨€ç»“æœä¸ºï¼š\u0026#34;, v) v.f() } // Output: // varIç±»å‹æ–­è¨€ç»“æœä¸ºï¼š Tstring // T Method // Type-Switch åšç±»å‹æ–­è¨€ var value interface{} // value.(type) åªèƒ½åœ¨switchä¸­ä½¿ç”¨ï¼Œä¼šä¾æ¬¡æ£€æŸ¥caseçš„å€¼è¿›è¡Œæ–­è¨€ï¼Œå¦‚value.(string)å†è¯•value.(Stringer)ã€value.(int) ç­‰ // è¿™ç§å½¢å¼ä¸‹ä¸å…è®¸ä½¿ç”¨ fallthrough å…³é”®å­— // åœ¨å¤„ç†æœªçŸ¥ç±»å‹çš„æ•°æ®ï¼ˆä¾‹å¦‚è§£æJSONç­‰ç¼–ç çš„æ•°æ®ï¼‰æ›´åŠ æ–¹ä¾¿ switch str := value.(type) { // str æ˜¯æ–­è¨€å‡ºæ¥çš„å€¼ä¹Ÿå°±æ˜¯ eface.data case string: fmt.Println(\u0026#34;stringï¼š\u0026#34;, str) case Stringer: fmt.Println(\u0026#34;Stringerï¼š\u0026#34;, str) case int,uint,float32,float64: fmt.Println(\u0026#34;æˆ‘æ˜¯ä¸Šé¢ç±»å‹å…¶ä¸­ä¸€ä¸ª\u0026#34;) case nil: fmt.Println(\u0026#34;nil\u0026#34;) default: fmt.Println(\u0026#34;valueç±»å‹ä¸åœ¨ä¸Šé¢ä¸­\u0026#34;) } // Output: // nil // Comma-ok æ–­è¨€ // æ–­è¨€æ˜¯å¦æ˜¯æŸä¸ªå…·ä½“çš„ç±»å‹ å…¶å®ä¸Šé¢çš„ value.(type) å°±æ˜¯è¿™ç§å½¢å¼çš„ç»„åˆ value = \u0026#34;ç±»å‹æ–­è¨€æ£€æŸ¥\u0026#34; if str, ok := value.(string); ok { fmt.Printf(\u0026#34;valueç±»å‹æ–­è¨€ç»“æœä¸ºï¼š%T\\n\u0026#34;, str) // strå·²è¿‘è½¬ä¸ºstringç±»å‹ } else { fmt.Printf(\u0026#34;value ä¸æ˜¯ string ç±»å‹ \\n\u0026#34;) } // Output: // valueç±»å‹æ–­è¨€ç»“æœä¸ºï¼šstring } ç±»å‹å®ç°ä¸åŒçš„æ¥å£å°†æ‹¥æœ‰ä¸åŒçš„è¡Œä¸ºæ–¹æ³•ç»“åˆï¼Œè¿™å°±æ˜¯å¤šæ€çš„æœ¬è´¨ã€‚ ä½¿ç”¨æ¥å£ä»£ç æ›´å…·æœ‰æ™®é€‚æ€§ï¼Œä¾‹å¦‚å‡½æ•°çš„å‚æ•°ä¸ºæ¥å£å˜é‡ã€‚æ ‡å‡†åº“æ‰€æœ‰åŒ…ä¸­éµå¾ªäº†è¿™ä¸ªåŸåˆ™ã€‚ åœ¨Goè¯­è¨€ä¸­ï¼Œä¸€ä¸ªæ¥å£å€¼å…¶å®ç”±ä¸¤éƒ¨åˆ†ç»„æˆï¼štype:valueã€‚ æ‰€ä»¥åœ¨åšç±»å‹æ–­è¨€æ—¶ï¼Œå˜é‡åªèƒ½æ˜¯æ¥å£ç±»å‹å˜é‡ï¼Œæ–­è¨€å¾—åˆ°çš„å€¼å…¶å®å°±æ˜¯æ¥å£å€¼ä¸­å¯¹åº”çš„ç±»å‹åã€‚ æ¥å£ä¸åŠ¨æ€ç±»å‹ æ¥å—ä¸€ä¸ªï¼ˆæˆ–å¤šä¸ªï¼‰æ¥å£ç±»å‹ä½œä¸ºå‚æ•°çš„å‡½æ•°ï¼Œå®å‚å¯ä»¥æ˜¯ä»»ä½•å®ç°äº†è¯¥æ¥å£çš„ç±»å‹ï¼Œå®ç°äº†æŸä¸ªæ¥å£çš„ç±»å‹å¯ä»¥è¢«ä¼ ç»™ä»»ä½•ä»¥æ­¤æ¥å£ä¸ºå‚æ•°çš„å‡½æ•°ã€‚ Goè¯­è¨€åŠ¨æ€ç±»å‹çš„å®ç°é€šå¸¸éœ€è¦ç¼–è¯‘å™¨é™æ€æ£€æŸ¥çš„æ”¯æŒï¼š å½“å˜é‡è¢«èµ‹å€¼ç»™ä¸€ä¸ªæ¥å£ç±»å‹çš„å˜é‡æ—¶ï¼Œç¼–è¯‘å™¨ä¼šæ£€æŸ¥å…¶æ˜¯å¦å®ç°äº†è¯¥æ¥å£çš„æ‰€æœ‰æ–¹æ³•ï¼ˆåœ¨èµ‹å€¼æ—¶æ£€æŸ¥ï¼‰ ä¹Ÿå¯ä»¥é€šè¿‡ç±»å‹æ–­è¨€æ¥æ£€æŸ¥æ¥å£å˜é‡æ˜¯å¦å®ç°äº†ç›¸åº”ç±»å‹ã€‚ æ¥å£çš„ç»§æ‰¿ å½“ä¸€ä¸ªç±»å‹åŒ…å«ï¼ˆå†…åµŒï¼‰å¦å¤–ä¸€ä¸ªç±»å‹ï¼ˆå®ç°äº†ä¸€ä¸ªæˆ–å¤šä¸ªæ¥å£ï¼‰æ—¶ï¼Œè¿™ä¸ªç±»å‹å°±å¯ä»¥ä½¿ç”¨ï¼ˆå¦ä¸€ä¸ªç±»å‹ï¼‰æ‰€æœ‰çš„æ¥å£æ–¹æ³•ã€‚ ç±»å‹å¯ä»¥é€šè¿‡ç»§æ‰¿å¤šä¸ªæ¥å£æ¥æä¾›åƒå¤šé‡ç»§æ‰¿ä¸€æ ·çš„ç‰¹æ€§ã€‚ 1 2 3 4 5 6 // åœ¨ç»“æ„ä½“ä¸­å†…åµŒæ¥å£ï¼Œè¯¥ç»“æ„ä½“å°†å…·æœ‰æ¥å£çš„æ–¹æ³• // å…³äºè¿™ç§åœ¨ç»“æ„ä½“ä¸­ä¼šè¯¦ç»†ä»‹ç» type ReaderWriter struct { io.Reader // æ¥å£ io.Writer // æ¥å£ } ä½¿ç”¨ç¤ºä¾‹ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 // Sayer å•æ–¹æ³•æ¥å£ï¼Œå¾…å®ç°æ–¹æ³•say type Sayer interface { say() } // dog ç©ºç»“æ„ä½“ type dog struct {} // say dogç»“æ„ä½“å®šä¹‰sayæ–¹æ³• func (d dog) say() { fmt.Println(\u0026#34;wan ...\u0026#34;) } // cat ç©ºç»“æ„ä½“ type cat struct {} // say catç»“æ„ä½“å®šä¹‰sayæ–¹æ³• func (c cat) say() { fmt.Println(\u0026#34;miao ...\u0026#34;) } func main() { var x Sayer a := cat{} b := dog{} // æ¥å£Sayerè£…è½½catç»“æ„ä½“ x = a x.say() // miao ... // æ¥å£Sayerè£…è½½dogç»“æ„ä½“ x = b x.say() // wan ... } æ¥å£è£…è½½æŒ‡é’ˆç±»å‹å’Œå€¼ç±»å‹ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 // Sayer å•æ–¹æ³•æ¥å£ï¼Œå¾…å®ç°æ–¹æ³•say type Sayer interface { say() } // dog ç©ºç»“æ„ä½“ type dog struct {} // say catç»“æ„ä½“å®šä¹‰sayæ–¹æ³• func (d dog) say() { fmt.Println(\u0026#34;wan ...\u0026#34;) } func main() { var x Sayer b := dog{} // æ¥å£Sayerè£…è½½dogç»“æ„ä½“ x = b x.say() // dog.say(x) // æ¥å£Sayerè£…è½½*dogç±»å‹ c := \u0026amp;dog{} x = c // x.say() -\u0026gt; (*dog).say(x) -\u0026gt; dog.say(*c) // (*dog).say(x) æ˜¯æ¥å£ç”Ÿæˆçš„åŒ…è£…æ–¹æ³•ï¼Œé‡Œé¢ä¼šè°ƒç”¨ dog.say(*c) æ–¹æ³• x.say() // (*c).say() -\u0026gt; dog.say(*c) è¿™é‡Œå¹¶ä¸æ˜¯è¯­æ³•ç³–å½¢å¼ // Output: // wan ... // wan ... } ","permalink":"https://heliu.site/posts/golang/interface/use/","summary":"Golang interface ä½¿ç”¨ä»‹ç»ã€‚","title":"æ¥å£(ä½¿ç”¨)"},{"content":" ç¤ºä¾‹ä»£ç ã€‚ 1 2 3 4 5 6 7 package main import \u0026#34;fmt\u0026#34; func main() { fmt.Println(\u0026#34;Hello World!\u0026#34;) } ç¨‹åºåŠ è½½é˜¶æ®µ ç¨‹åºåœ¨è¢«æ“ä½œç³»ç»ŸåŠ è½½èµ·æ¥è¿è¡Œæ—¶éƒ½ä¼šä¾æ¬¡ç»è¿‡å¦‚ä¸‹é˜¶æ®µï¼š ä»ç£ç›˜ä¸ŠæŠŠå¯æ‰§è¡Œç¨‹åºè¯»å…¥å†…å­˜ã€‚ åˆ›å»ºè¿›ç¨‹å’Œä¸»çº¿ç¨‹ã€‚ ä¸ºä¸»çº¿ç¨‹åˆ†é…æ ˆç©ºé—´ã€‚ æŠŠç”±ç”¨æˆ·åœ¨å‘½ä»¤è¡Œè¾“å…¥çš„å‚æ•°æ‹·è´åˆ°ä¸»çº¿ç¨‹çš„æ ˆã€‚ æŠŠä¸»çº¿ç¨‹æ”¾å…¥æ“ä½œç³»ç»Ÿçš„è¿è¡Œé˜Ÿåˆ—ç­‰å¾…è¢«è°ƒåº¦æ‰§è¡Œèµ·æ¥è¿è¡Œã€‚ åœ¨ä¸»çº¿ç¨‹ç¬¬ä¸€æ¬¡è¢«è°ƒåº¦èµ·æ¥æ‰§è¡Œç¬¬ä¸€æ¡æŒ‡ä»¤ä¹‹å‰ï¼Œä¸»çº¿ç¨‹çš„å‡½æ•°æ ˆå¦‚ä¸‹å›¾æ‰€ç¤ºï¼šspæŒ‡å‘æ ˆé¡¶ã€‚ ç›¸å…³æ¦‚å¿µï¼š rspï¼šæŒ‡å‘å½“å‰æ ˆçš„æ ˆé¡¶ï¼Œè¡¨ç¤ºå½“å‰æ ˆå·²ç»ç”¨åˆ°ä»€ä¹ˆä½ç½®ã€‚ rbpï¼šæŒ‡å‘å½“å‰æ ˆçš„æ ˆåº•ï¼Œè¡¨ç¤ºå½“å‰æ ˆçš„èµ·ç‚¹ä½ç½®ã€‚ ripï¼šCPUå³å°†æ‰§è¡Œçš„ä¸‹ä¸€æ¡æŒ‡ä»¤åœ¨å†…å­˜ä¸­çš„åœ°å€ï¼Œæ§åˆ¶ç€ç¨‹åºçš„æµç¨‹ã€‚ SBï¼šGOæ±‡ç¼–ç›¸å…³çš„è™šæ‹Ÿå¯„å­˜å™¨ï¼Œä¿å­˜ç¨‹åºåœ°å€ç©ºé—´çš„èµ·å§‹åœ°å€ã€‚ SBå¯„å­˜å™¨ä¿å­˜çš„æ˜¯å½“å‰å‡½æ•°åœ¨ä»£ç åŒºçš„èµ·å§‹ä½ç½®ã€‚ å‡ºç°åœ¨GOæ±‡ç¼–çš„å‡½æ•°å®šä¹‰ã€å‡½æ•°è°ƒç”¨ã€å…¨å±€å˜é‡å®šä¹‰ä»¥åŠå¯¹å…¶å¼•ç”¨ä¼šç”¨åˆ°è¿™ä¸ªSBè™šæ‹Ÿå¯„å­˜å™¨ã€‚ FPï¼šGOæ±‡ç¼–ç›¸å…³çš„è™šæ‹Ÿå¯„å­˜å™¨ï¼Œä¸»è¦ç”¨æ¥å¼•ç”¨å‡½æ•°å‚æ•°ã€‚ Goè¯­è¨€è§„å®šå‡½æ•°è°ƒç”¨æ—¶å‚æ•°éƒ½å¿…é¡»æ”¾åœ¨æ ˆä¸Šï¼Œæ¯”å¦‚è¢«è°ƒç”¨å‡½æ•°ä½¿ç”¨first_arg+0(FP)æ¥å¼•ç”¨è°ƒç”¨è€…ä¼ é€’è¿›æ¥çš„ç¬¬ä¸€ä¸ªå‚æ•°ã€‚ ç”¨second_arg+8(FP)æ¥å¼•ç”¨ç¬¬äºŒä¸ªå‚æ•°ç­‰ã€‚è¿™é‡Œçš„first_argå’Œsecond_argä»…ä»…æ˜¯ä¸€ä¸ªå¸®åŠ©æˆ‘ä»¬é˜…è¯»æºä»£ç çš„ç¬¦å·ã€‚ å¯¹ç¼–è¯‘å™¨æ¥è¯´æ— å®é™…æ„ä¹‰ï¼Œ+0å’Œ+8è¡¨ç¤ºç›¸å¯¹äºFPå¯„å­˜å™¨çš„åç§»é‡ã€‚ $16-8ï¼šæ•°å­—16è¯´æ˜æ­¤å‡½æ•°çš„æ ˆå¸§å¤§å°ä¸º16å­—èŠ‚ï¼Œ8è¯´æ˜æ­¤å‡½æ•°çš„å‚æ•°å’Œè¿”å›å€¼ä¸€å…±éœ€è¦å ç”¨8å­—èŠ‚å†…å­˜ã€‚ ç¨‹åºå…¥å£ ç¬¬ä¸€è¡Œä»£ç ï¼šå®šä¹‰äº†_rt0_amd64_linuxè¿™ä¸ªç¬¦å·ï¼Œå¹¶ä¸æ˜¯çœŸæ­£çš„CPUæŒ‡ä»¤ã€‚ NOSPLITå‘Šè¯‰ç¼–è¯‘å™¨ä¸è¦åœ¨è¿™ä¸ªå‡½æ•°ä¸­æ’å…¥æ£€æŸ¥æ ˆæ˜¯å¦æº¢å‡ºçš„ä»£ç ã€‚ ç¬¬äºŒè¡Œçš„JMPæŒ‡ä»¤ï¼šæ‰æ˜¯ä¸»çº¿ç¨‹çš„ç¬¬ä¸€æ¡æŒ‡ä»¤ã€‚ è¿™æ¡æŒ‡ä»¤ç®€å•çš„è·³è½¬åˆ°ï¼ˆç›¸å½“äºgoè¯­è¨€æˆ–cä¸­çš„gotoå…³é”®å­—ï¼‰_rt0_amd64 è¿™ä¸ªç¬¦å·å¤„ç»§ç»­æ‰§è¡Œã€‚ æ–‡ä»¶ä½ç½®ï¼šgo1.19.3/src/runtime/rt0_linux_amd64.sã€‚ 7 8 TEXT _rt0_amd64_linux(SB),NOSPLIT,$-8 JMP _rt0_amd64(SB) å‰ä¸¤è¡ŒæŒ‡ä»¤ï¼šæŠŠæ“ä½œç³»ç»Ÿå†…æ ¸ä¼ é€’è¿‡æ¥çš„å‚æ•°argcå’Œargvæ•°ç»„çš„åœ°å€åˆ†åˆ«æ”¾åœ¨DIå’ŒSIå¯„å­˜å™¨ä¸­ã€‚ éœ€è¦æ³¨æ„çš„æ˜¯ï¼šã€MOVQ 0(SP), DIã€‘æ‹·è´çš„æ˜¯argcçš„å€¼æ˜¯ä¸ª8å­—èŠ‚çš„å­˜å‚¨çš„æ˜¯å‚æ•°çš„ä¸ªæ•°ï¼Œæ˜¯ä¸ªæ•°å­—ã€‚ ã€LEAQ 8(SP), SIã€‘åˆ™æ˜¯å–çš„argvçš„åœ°å€ï¼Œæ˜¯ä¸ªæŒ‡é’ˆ*argvï¼Œä¹Ÿæ˜¯8å­—èŠ‚ã€‚ ç¬¬ä¸‰è¡ŒæŒ‡ä»¤ï¼šè·³è½¬åˆ° rt0_go å»æ‰§è¡Œã€‚ æ–‡ä»¶ä½ç½®ï¼šgo1.19.3/src/runtime/asm_amd64.sã€‚ 11 12 13 14 15 16 17 18 19 # _rt0_amd64 is common startup code for most amd64 systems when using # internal linking. This is the entry point for the program from the # kernel for an ordinary -buildmode=exe program. The stack holds the # number of arguments and the C-style argv. TEXT _rt0_amd64(SB),NOSPLIT,$-8 MOVQ 0(SP), DI # DI = argc # å‡è®¾SPå­˜å‚¨å€¼ä¸º0x00ff00ï¼Œåˆ™SI=0x00ff08ï¼ŒæŒ‡å‘çš„æ˜¯ *argv LEAQ 8(SP), SI # SI = 8(SP); *argv JMP\truntimeÂ·rt0_go(SB) rt0_goå‡½æ•°å®Œæˆäº†goç¨‹åºå¯åŠ¨æ—¶çš„æ‰€æœ‰åˆå§‹åŒ–å·¥ä½œã€‚ ç¬¬4æ¡æŒ‡ä»¤ï¼ˆANDQ $~15, SPï¼‰ï¼š ç”¨äºè°ƒæ•´æ ˆé¡¶å¯„å­˜å™¨çš„å€¼ä½¿å…¶æŒ‰16å­—èŠ‚å¯¹é½ï¼Œä¹Ÿå°±æ˜¯è®©æ ˆé¡¶å¯„å­˜å™¨SPæŒ‡å‘çš„å†…å­˜çš„åœ°å€ä¸º16çš„å€æ•°ã€‚ ä¹‹æ‰€ä»¥è¦æŒ‰16å­—èŠ‚å¯¹é½ï¼Œæ˜¯å› ä¸ºCPUæœ‰ä¸€ç»„SSEæŒ‡ä»¤ï¼Œè¿™äº›æŒ‡ä»¤ä¸­å‡ºç°çš„å†…å­˜åœ°å€å¿…é¡»æ˜¯16çš„å€æ•°ã€‚ æœ€åä¸¤æ¡æŒ‡ä»¤ï¼šæŠŠargcå’Œargvæ¬åˆ°æ–°çš„ä½ç½®ã€‚ æ–‡ä»¶ä½ç½®ï¼šgo1.19.3/src/runtime/asm_amd64.sã€‚ 159 160 161 162 163 164 165 166 167 168 169 170 171 172 TEXT runtimeÂ·rt0_go(SB),NOSPLIT|TOPFRAME,$0 # copy arguments forward on an even stack # # åœ¨å¶æ•°æ ˆä¸Šå‘å‰å¤åˆ¶å‚æ•° # argcæ˜¯ä¸ª8å­—èŠ‚çš„æ•°å€¼ï¼Œå› æ­¤AXå­˜å‚¨çš„æ˜¯æ‹·è´çš„å€¼ # argvæ ¹æ®å‰é¢å¯çŸ¥ï¼Œè¿™é‡ŒBXå­˜å‚¨çš„æ˜¯argvçš„åœ°å€ï¼Œå› æ­¤åŸæ•°æ®è¿˜åœ¨8(SP)çš„ä½ç½® MOVQ DI, AX # AX=argc MOVQ SI, BX # BX=*argv SUBQ $(5*8), SP # 3args 2auto # $~15ï¼š0000_1111 -\u0026gt; 1111_0000 # ç»è¿‡ ANDQ è°ƒæ•´åï¼Œä¸€å®šæ˜¯å¤§äºç­‰äº40byte ANDQ $~15, SP # è°ƒæ•´æ ˆé¡¶å¯„å­˜å™¨ä½¿å…¶æŒ‰16å­—èŠ‚å¯¹é½ MOVQ AX, 24(SP) # argcæ”¾åœ¨SP+24å­—èŠ‚å¤„ MOVQ BX, 32(SP) # argvæ”¾åœ¨SP+32å­—èŠ‚å¤„ï¼Œæ­¤æ—¶æ˜¯argvçš„åœ°å€ï¼Œ*argv æ€»ç»“ï¼šè¿™éƒ¨åˆ†ä»£ç å®Œæˆäº†argcå’Œargvçš„æ‹·è´ï¼ˆargvæ˜¯æ‹·è´äº†åœ°å€ï¼Œargvåˆ™æ˜¯æ‹·è´äº†å‰¯æœ¬å€¼ï¼‰ï¼Œæ ˆæŒ‰ç…§16å­—èŠ‚å¯¹é½äº†ã€‚ åˆå§‹åŒ–g0 g0çš„ä¸»è¦ä½œç”¨æ˜¯æä¾›ä¸€ä¸ªæ ˆä¾›runtimeä»£ç æ‰§è¡Œï¼Œå› æ­¤è¿™é‡Œä¸»è¦å¯¹g0çš„å‡ ä¸ªä¸æ ˆæœ‰å…³çš„æˆå‘˜è¿›è¡Œäº†åˆå§‹åŒ–ã€‚ ä»è¿™é‡Œå¯ä»¥çœ‹å‡ºg0çš„æ ˆå¤§çº¦æœ‰64KBï¼Œåœ°å€èŒƒå›´ä¸ºSP - 64*1024 + 104 ï½ SPã€‚ æ³¨æ„ï¼šè™½ç„¶è¿™é‡Œç»™g0æŒ‡å®šäº†å¤§æ¦‚64KBå¤§å°çš„æ ˆç©ºé—´å¤§å°ï¼Œä½†æ˜¯SPå¯„å­˜å™¨çš„å€¼å´æ²¡æœ‰å‡å»64KBå¤§å°ã€‚ æ–‡ä»¶ä½ç½®ï¼šgo1.19.3/src/runtime/asm_amd64.sã€‚ 168 169 170 171 172 173 174 175 176 177 178 179 180 181 # create istack out of the given (operating system) stack. # _cgo_init may update stackguard. # ä»ç»™å®šçš„æ“ä½œç³»ç»Ÿæ ˆä¸­åˆ›å»º istack (è‡ªå·±çš„æ ˆ)ã€‚_cgo_init å¯èƒ½ä¼šæ›´æ–° stackguardã€‚ # ä¸‹é¢è¿™æ®µä»£ç ä»ç³»ç»Ÿçº¿ç¨‹çš„æ ˆç©ºåˆ†å‡ºä¸€éƒ¨åˆ†å½“åšg0çš„æ ˆï¼Œç„¶ååˆå§‹åŒ–g0çš„æ ˆä¿¡æ¯å’Œstackgard MOVQ $runtimeÂ·g0(SB), DI # DI = \u0026amp;g0 LEAQ (-64*1024+104)(SP), BX # BX = SP - 64*1024 + 104 # g0.stackguard0å’Œg0.stackguard1ç”¨äºæ ˆæº¢å‡ºæ£€æŸ¥ï¼Œå®ç°æ ˆçš„è‡ªåŠ¨ä¼¸ç¼©ï¼ŒæŠ¢å è°ƒåº¦ä¹Ÿä¼šç”¨åˆ°stackguard0 MOVQ BX, g_stackguard0(DI) # g0.stackguard0 = SP - 64*1024 + 104 MOVQ BX, g_stackguard1(DI) # g0.stackguard1 = SP - 64*1024 + 104 # g0.stack ä¸»è¦ç”¨æ¥è®°å½•goroutineæ‰€ä½¿ç”¨çš„æ ˆï¼Œ[lo, hi) # g0.stack.lo æ ˆé¡¶ï¼ŒæŒ‡å‘å†…å­˜ä½åœ°å€ # g0.stack.hi æ ˆåº•ï¼ŒæŒ‡å‘å†…å­˜é«˜åœ°å€ MOVQ BX, (g_stack+stack_lo)(DI) # g0.stack.lo = SP - 64*1024 + 104 lo MOVQ SP, (g_stack+stack_hi)(DI) # g0.stack.hi = SP hi è¿è¡Œå®Œä¸Šé¢è¿™å‡ è¡ŒæŒ‡ä»¤åg0ä¸æ ˆä¹‹é—´çš„å…³ç³»å¦‚ä¸‹å›¾æ‰€ç¤ºï¼š æ€»ç»“ï¼šè¿™éƒ¨åˆ†ä»£ç ç»™g0é¢„ç•™äº†å¤§çº¦64KBçš„å°çš„æ ˆç©ºé—´ï¼ˆæ³¨æ„è¿™é‡Œçš„SPå¯„å­˜å™¨å€¼å¹¶æ²¡æœ‰è¢«ä¿®æ”¹ï¼‰ï¼Œè®¾ç½®äº†stackã€stackguard0ã€stackguard1å­—æ®µï¼Œè¿™äº›å­—æ®µéƒ½æ˜¯ä¸g0æ ˆç›¸å…³çš„ã€‚ CPU ç›¸å…³ è°ƒç”¨CPUç›¸å…³æŒ‡ä»¤ï¼Œå°è¯•è·å–CPUç›¸å…³ä¿¡æ¯ï¼Œæ¯”å¦‚CPUçš„å‚å•†ã€å¤„ç†å™¨å‹å·ç­‰ï¼Œå¦‚æœè·å–æˆåŠŸåˆ™è®°å½•åœ¨å…¨å±€å˜é‡ä¸­ã€‚ åˆ¤æ–­æ˜¯å¦éœ€è¦è°ƒç”¨åˆå§‹åŒ–CGOç›¸å…³å‡½æ•°ï¼ˆç¨‹åºä¸­æœ‰ç›¸å…³Cä»£ç åˆ™ä¼šè°ƒç”¨ï¼Œæ²¡æœ‰åˆ™ä¸ä¼šè°ƒç”¨ï¼‰ã€‚ æ–‡ä»¶ä½ç½®ï¼šgo1.19.3/src/runtime/asm_amd64.sã€‚ 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 # find out information about the processor we\u0026#39;re on # # æ‰¾å‡ºæˆ‘ä»¬æ­£åœ¨ä½¿ç”¨çš„å¤„ç†å™¨ä¿¡æ¯ # EAXå¯„å­˜å™¨è®¾ç½®ä¸ºç¼–å·0ï¼Œå› ä¸ºCPUIDæŒ‡ä»¤ä¼šä½¿ç”¨åˆ°è¯¥å¯„å­˜å™¨ã€‚ MOVL $0, AX # EAX = 0 # CPUID æ˜¯ä¸€ç§ç”¨äºæŸ¥è¯¢å¤„ç†å™¨ä¿¡æ¯çš„æŒ‡ä»¤ï¼Œå®ƒå¯ä»¥è¿”å›å¤„ç†å™¨æ”¯æŒçš„åŠŸèƒ½åˆ—è¡¨å’Œç‰¹æ€§ä¿¡æ¯ã€‚ # CPUID æŒ‡ä»¤éœ€è¦å°†æŸ¥è¯¢ä¿¡æ¯çš„ç¼–å·å­˜å‚¨åœ¨ EAX å¯„å­˜å™¨ä¸­ï¼Œç„¶åæ‰§è¡Œ CPUID æŒ‡ä»¤ã€‚ # å¤„ç†å™¨å°†è¿”å›ç»“æœå­˜å‚¨åœ¨ EAXã€EBXã€ECX å’Œ EDX å››ä¸ªå¯„å­˜å™¨ä¸­ï¼Œå…·ä½“çš„è¿”å›å€¼æ ¼å¼å’Œå«ä¹‰å–å†³äºæŸ¥è¯¢ä¿¡æ¯çš„ç¼–å·ã€‚ # EAX æ˜¯ 0 æ—¶ï¼šè¿”å›æœ€å¤§æ”¯æŒçš„åŠŸèƒ½ç¼–å·ï¼ˆåŒ…æ‹¬è¯¥ç¼–å·ï¼‰å’Œå‚å•† IDï¼ˆ12 ä¸ªå­—ç¬¦ï¼‰ã€‚ # 1. EAXï¼šè¿”å›æœ€å¤§æ”¯æŒçš„åŠŸèƒ½ç¼–å· # 2. EBXï¼šå¦‚æœæ˜¯ Inter è¿”å› \u0026#34;Genu\u0026#34;ã€‚å¦‚æœæ˜¯ AMD è¿”å› \u0026#34;Auth\u0026#34; ã€‚ # 3. ECXï¼šå¦‚æœæ˜¯ Inter è¿”å› \u0026#34;ntel\u0026#34;ã€‚å¦‚æœæ˜¯ AMD è¿”å› \u0026#34;enti\u0026#34; ã€‚ # 4. EDXï¼šå¦‚æœæ˜¯ Inter è¿”å› \u0026#34;ntel\u0026#34;ã€‚å¦‚æœæ˜¯ AMD è¿”å› \u0026#34;cAMD\u0026#34; ã€‚ # Genuntelntelæ˜¯è‹±ç‰¹å‚å•†åç§°ã€‚AuthenticAMDè¡¨ç¤ºæ˜¯AMDå‚å•†åç§°ã€‚ # EAX æ˜¯ 1 æ—¶ï¼šè¿”å›å¤„ç†å™¨çš„åŸºæœ¬ä¿¡æ¯ï¼ŒåŒ…æ‹¬å¤„ç†å™¨å‹å·ã€ç³»åˆ—ã€æ‰©å±•å‹å·ã€æ‰©å±•ç³»åˆ—ç­‰ã€‚ # 1. EAX çš„ä½0-3å°†åŒ…å«å¤„ç†å™¨ç±»å‹ç¼–ç ï¼Œä½4-7å°†åŒ…å«å¤„ç†å™¨å®¶æ—ç¼–ç ï¼Œä½8-11å°†åŒ…å«å¤„ç†å™¨å‹å·ç¼–ç ï¼Œ # ä½12-13å°†åŒ…å«å¤„ç†å™¨æ‰©å±•å‹å·ç¼–ç ï¼Œä½14-15å°†åŒ…å«å¤„ç†å™¨æ‰©å±•å®¶æ—ç¼–ç ã€‚ # 2. EBXã€ECXã€EDX ä¸‰ä¸ªå¯„å­˜å™¨å°†åŒ…å«å…¶ä»–å¤„ç†å™¨ç‰¹æ€§çš„ä¿¡æ¯ã€‚æ­¤å¤„æˆ‘ä»¬ä¸å…³å¿ƒè¿™äº›æ•°æ®ã€‚ # æŸ¥è¯¢ CPU æ”¯æŒçš„åŠŸèƒ½åˆ—è¡¨ï¼ˆç¼–å· 0ï¼‰ï¼š0ã€1ã€2ã€4ã€0x80000000ã€0x80000001 # 1. EAX çš„å€¼ä¸º 0x0ï¼šè¿”å›æœ€å¤§æ”¯æŒçš„åŠŸèƒ½ç¼–å·ï¼ˆåŒ…æ‹¬è¯¥ç¼–å·ï¼‰å’Œå‚å•† IDï¼ˆ12 ä¸ªå­—ç¬¦ï¼‰ã€‚ # 2. EAX çš„å€¼ä¸º 0x1ï¼šè¿”å›å¤„ç†å™¨çš„åŸºæœ¬ä¿¡æ¯ï¼ŒåŒ…æ‹¬å¤„ç†å™¨å‹å·ã€ç³»åˆ—ã€æ‰©å±•å‹å·ã€æ‰©å±•ç³»åˆ—ç­‰ã€‚ # 3. EAX çš„å€¼ä¸º 0x80000000hï¼šè¿”å›æœ€å¤§æ”¯æŒçš„æ‰©å±•åŠŸèƒ½ç¼–å·å’Œå‚å•† IDï¼ˆ12 ä¸ªå­—ç¬¦ï¼‰ã€‚ # 4. EAX çš„å€¼ä¸º 0x80000001hï¼šè¿”å›å¤„ç†å™¨çš„æ‰©å±•ä¿¡æ¯ï¼ŒåŒ…æ‹¬æ‰©å±•ç‰¹æ€§ã€è™šæ‹ŸåŒ–æ”¯æŒç­‰ã€‚ CPUID CMPL AX, $0 JE nocpuinfo # AX == 0ï¼Œæ²¡æœ‰CPUä¿¡æ¯ # ä»¥ä¸‹åˆ¤æ–­å½“å‰å¤„ç†å™¨æ˜¯å¦æ˜¯ GenuineIntel # BX != \u0026#34;Genu\u0026#34;; JNE å°±ä¼šè·³è½¬ CMPL BX, $0x756E6547 # \u0026#34;Genu\u0026#34; JNE\tnotintel # ä¸æ˜¯è‹±ç‰¹å¤„ç†å™¨æ—¶ # BX != \u0026#34;ineI\u0026#34;; JNE å°±ä¼šè·³è½¬ CMPL DX, $0x49656E69 # \u0026#34;ineI\u0026#34; JNE\tnotintel # ä¸æ˜¯è‹±ç‰¹å¤„ç†å™¨æ—¶ # BX != \u0026#34;ntel\u0026#34;; JNE å°±ä¼šè·³è½¬ CMPL CX, $0x6C65746E # \u0026#34;ntel\u0026#34; JNE\tnotintel # ä¸æ˜¯è‹±ç‰¹å¤„ç†å™¨æ—¶ # å°†runtimeçš„å…¨å±€å˜é‡ isIntel è®¾ç½®ä¸º 1 # è¯¥å˜é‡åœ¨ runtime/runtime2.go å…¨å±€å˜é‡ä¸­ # è¡¨ç¤ºå½“å‰å¤„ç†å™¨æ˜¯ GenuineIntel MOVB $1, runtimeÂ·isIntel(SB) notintel: # ä¸æ˜¯intel # Load EAX=1 cpuid flags MOVL $1, AX CPUID # å°†runtimeçš„å…¨å±€å˜é‡ processorVersionInfo è®¾ç½®ä¸º AX # AXå¯„å­˜å™¨å­˜å‚¨çš„æ˜¯å¤„ç†å™¨çš„æ ‡è¯†ï¼Œå¯ä»¥è¯†åˆ«ç‰¹å®šçš„å¤„ç†å™¨ã€‚ # ç”±äºåˆ¤æ–­CPUæ˜¯å¦æ”¯æŒç›¸å…³çš„æŒ‡ä»¤é›†ï¼Œæ¯”å¦‚AVXæŒ‡ä»¤é›†ã€‚ MOVL AX, runtimeÂ·processorVersionInfo(SB) nocpuinfo: # æ²¡æœ‰cpuä¿¡æ¯ # if there is an _cgo_init, call it. # # å¦‚æœå­˜åœ¨_cgo_initï¼Œåˆ™è°ƒç”¨å®ƒã€‚ä»£ç ä¸­å­˜åœ¨è°ƒç”¨Cç›¸å…³å‡½æ•°æ—¶è¿™é‡ŒAXä¼šæœ‰å€¼å¹¶åˆ¤æ–­æˆåŠŸ # cgo_initå‡½æ•°æ˜¯ä¸€ä¸ªå†…éƒ¨å‡½æ•°ï¼Œç”¨äºåˆå§‹åŒ–Cè¯­è¨€ä»£ç å’ŒGoä»£ç ä¹‹é—´çš„æ¥å£ã€‚ # cgo_initå‡½æ•°æ˜¯Goè¿è¡Œæ—¶ç³»ç»Ÿçš„ä¸€éƒ¨åˆ†ï¼Œå®ƒåœ¨ç¨‹åºå¯åŠ¨æ—¶è¢«è‡ªåŠ¨è°ƒç”¨ã€‚ # å®ƒä¼šåˆå§‹åŒ–cgoç›¸å…³çš„å…¨å±€å˜é‡ï¼Œè®¾ç½®cgoçš„ä¿¡å·å¤„ç†å™¨ï¼Œå¹¶å°†Cè¯­è¨€ä»£ç ä¸­çš„å‡½æ•°æŒ‡é’ˆè½¬æ¢ä¸ºGoè¯­è¨€ä¸­çš„å‡½æ•°ç±»å‹ï¼Œ # ä»¥ä¾¿èƒ½å¤Ÿåœ¨Goè¯­è¨€ä¸­è°ƒç”¨å®ƒä»¬ã€‚ # ä½¿ç”¨ CGO çš„æƒ…å†µä¸‹ï¼š # 1. Goä¼šåˆ›å»ºä¸€ä¸ªCè¯­è¨€çš„çº¿ç¨‹ï¼Œå¹¶ä½¿ç”¨çº¿ç¨‹æœ¬åœ°å­˜å‚¨ï¼ˆThread-Local Storageï¼ŒTLSï¼‰æ¥å­˜å‚¨Cè¯­è¨€å‡½æ•°æ‰€éœ€è¦çš„æ•°æ®ã€‚ # 2. å½“ä½¿ç”¨cgoè°ƒç”¨Cè¯­è¨€å‡½æ•°æ—¶ï¼Œcgoä¼šè‡ªåŠ¨åˆå§‹åŒ–è¿™ä¸ªçº¿ç¨‹çš„TLSã€‚è¿™ä¸ªåˆå§‹åŒ–æ˜¯åœ¨_cgo_initå‡½æ•°ä¸­å®Œæˆçš„ï¼Œ # è¿™ä¸ªå‡½æ•°æ˜¯ç”±Goç¼–è¯‘å™¨è‡ªåŠ¨ç”Ÿæˆçš„ã€‚ MOVQ _cgo_init(SB), AX # å°†å¯„å­˜å™¨ AX ä¸­çš„å€¼ä¸è‡ªå·±è¿›è¡ŒæŒ‰ä½é€»è¾‘ä¸è¿ç®—ï¼Œå¹¶æ›´æ–°æ ‡å¿—å¯„å­˜å™¨çš„å€¼ã€‚ # å¦‚æœå…¨éƒ¨ä¸º 1ï¼Œé‚£ä¹ˆç»“æœå°±æ˜¯éé›¶å€¼ï¼Œå¦åˆ™å°±æ˜¯é›¶ã€‚ # è¿™æ¡æŒ‡ä»¤çš„ä½œç”¨å°±æ˜¯åˆ¤æ–­ AX çš„å€¼æ˜¯å¦ä¸ºé›¶ã€‚ TESTQ AX, AX # è¿™æ¡æŒ‡ä»¤æ˜¯ä¸€ä¸ªæ¡ä»¶è·³è½¬æŒ‡ä»¤ï¼Œå®ƒä¼šæ ¹æ®ä¸Šä¸€æ¡æŒ‡ä»¤æ›´æ–°çš„æ ‡å¿—å¯„å­˜å™¨çš„å€¼æ¥åˆ¤æ–­æ˜¯å¦è·³è½¬åˆ°ç›®æ ‡æ ‡ç­¾ needtlsã€‚ # JZ æ˜¯â€œJump if Zeroâ€çš„ç¼©å†™ï¼Œæ„æ€æ˜¯å¦‚æœä¸Šä¸€æ¡æŒ‡ä»¤çš„ã€ç»“æœä¸ºé›¶ã€‘ï¼Œåˆ™è·³è½¬åˆ°ç›®æ ‡æ ‡ç­¾ã€‚ # è·³è½¬è¿™é‡Œè¡¨ç¤ºä¿®æ”¹å» TLS è®¾ç½® JZ\tneedtls # æ²¡æœ‰ _cgo_init å‡½æ•°æ—¶è·³è½¬åˆ° needtls # arg 1: g0, already in DI # å‚æ•°1ï¼šg0, å·²ç»åœ¨ DI ä¸­ï¼Œå‰é¢åˆå§‹åŒ–g0æ—¶æ”¾å…¥DIä¸­çš„ # å‚æ•°2ï¼šsetg_gcc æ”¾å…¥ SI MOVQ $setg_gcc\u0026lt;\u0026gt;(SB), SI # arg 2: setg_gcc #ifdef GOOS_android\tMOVQ $runtimeÂ·tls_g(SB), DX # arg 3: \u0026amp;tls_g # arg 4: TLS base, stored in slot 0 (Android\u0026#39;s TLS_SLOT_SELF). # Compensate for tls_g (+16). MOVQ -16(TLS), CX #else # å‚æ•°3,4ï¼šéƒ½ä¸º0ï¼Œä½¿ç”¨å¹³å°çš„TLSæ—¶ä¸ä½¿ç”¨ MOVQ $0, DX\t# arg 3, 4: not used when using platform\u0026#39;s TLS MOVQ $0, CX #endif #ifdef GOOS_windows # Adjust for the Win64 calling convention. MOVQ CX, R9 # arg 4 MOVQ DX, R8 # arg 3 MOVQ SI, DX # arg 2 MOVQ DI, CX # arg 1 #endif # DIã€SIã€DXã€CXå‚æ•°å·²å‡†å¤‡å¥½ # DI = \u0026amp;g0 # SI = setg_gcc # DX = 0 # CX = 0 # AX=_cgo_init; è°ƒç”¨ _cgo_init å‡½æ•° CALL AX # update stackguard after _cgo_init # åœ¨ _cgo_init åæ›´æ–° stackguardï¼Œå› ä¸ºæ›´æ–°äº†stack.loçš„å€¼äº†ã€‚ MOVQ $runtimeÂ·g0(SB), CX # CX = \u0026amp;g0 MOVQ (g_stack+stack_lo)(CX), AX # AX = g0.stack.lo; lo = SP + 8MB - 4KB # _StackGuard æ˜¯ 928byte ADDQ $const__StackGuard, AX # AX = AX + _StackGuard # g0.stackguard0 = g0.stack.lo + _StackGuard # g0.stack.lo = SP + 8MB - 4KB # stackguard0 ç”¨äº runtime æ ˆæº¢å‡ºåˆ¤æ–­ã€‚ MOVQ AX, g_stackguard0(CX) # g0.stackguard1 = g0.stack.lo + _StackGuard # stackguard1 è¢« g0 å’Œ gsignal ä¸­çš„Cä»£ç ä½¿ç”¨ã€‚ç”¨äºæ ˆæº¢å‡ºåˆ¤æ–­ MOVQ AX, g_stackguard1(CX) ## è¿™é‡Œæ˜¯ ifndefï¼Œä¸æ˜¯windowsåˆ™JMP okä¸éœ€è¦å»TLS ## è¿™ç§æƒ…å†µå‘ç”Ÿåœ¨ _cgo_init å‡½æ•°è¢«è°ƒç”¨æ—¶å€™ # #ifndef GOOS_windows JMP ok #endif needtls: ## éœ€è¦TLSçš„æƒ…å†µåˆ¤æ–­ #ifdef GOOS_plan9 # skip TLS setup on Plan 9 JMP ok ## è·³è¿‡TLSè®¾ç½®ï¼Œä¸è¦æ‰‹åŠ¨è®¾ç½® #endif #ifdef GOOS_solaris # skip TLS setup on Solaris JMP ok ## è·³è¿‡TLSè®¾ç½®ï¼Œä¸è¦æ‰‹åŠ¨è®¾ç½® #endif #ifdef GOOS_illumos # skip TLS setup on illumos JMP ok ## è·³è¿‡TLSè®¾ç½®ï¼Œä¸è¦æ‰‹åŠ¨è®¾ç½® #endif #ifdef GOOS_darwin # skip TLS setup on Darwin JMP ok ## è·³è¿‡TLSè®¾ç½®ï¼Œä¸è¦æ‰‹åŠ¨è®¾ç½® #endif #ifdef GOOS_openbsd # skip TLS setup on OpenBSD JMP ok ## è·³è¿‡TLSè®¾ç½®ï¼Œä¸è¦æ‰‹åŠ¨è®¾ç½® #endif cgoåˆå§‹åŒ– åˆå§‹åŒ– C è¯­è¨€ä»£ç å’Œ Go ä»£ç ä¹‹é—´çš„æ¥å£ã€‚ å‚æ•°ï¼š G *gï¼š\u0026amp;runtime.g0ã€‚ void (*setg)(void*)ï¼šsetg_gccå‡½æ•°ã€‚ void **tlsgï¼šNULLã€‚ void **tlsbaseï¼šNULLã€‚ æ–‡ä»¶ä½ç½®ï¼šgo1.19.3/src/runtime/cgo/gcc_linux_amd64.cã€‚ è¯¥å‡½æ•°åªæ˜¯è®¾ç½®äº†g0æ ˆçš„stack.lo = SP - 8MB + 4KBï¼Œå¹¶æ²¡æœ‰åˆ›å»ºæ–°çš„çº¿ç¨‹ã€‚ è¿™æ®µä»£ç æ‰§è¡Œäº†ä»¥ä¸‹é‡è¦ä»»åŠ¡ï¼š çº¿ç¨‹æ ˆçš„åˆå§‹åŒ–å’Œè®¾ç½®ï¼š Goè¿è¡Œæ—¶ä½¿ç”¨goroutinesæ¥å¹¶å‘æ‰§è¡Œä»£ç ï¼Œæ¯ä¸ªgoroutineæœ‰è‡ªå·±çš„æ ˆã€‚ å½“ä½¿ç”¨cgoæ—¶ï¼ŒGoè¿è¡Œæ—¶éœ€è¦ä¸Cä»£ç çš„çº¿ç¨‹æ ˆè¿›è¡Œäº¤äº’ã€‚ è¿™æ®µä»£ç ç¡®ä¿äº†Cçº¿ç¨‹çš„æ ˆä¸Goè¿è¡Œæ—¶çš„æ ˆè®¾ç½®æ˜¯ä¸€è‡´çš„ã€‚ æ ˆè¾¹ç•Œè®¾ç½®ï¼š è®¾ç½®stackloå­—æ®µæ˜¯ä¸ºäº†ç¡®å®šgoroutineæ ˆçš„åº•éƒ¨ä½ç½®ã€‚ åœ¨Goä¸­ï¼Œæ¯ä¸ªgoroutineçš„æ ˆéƒ½æœ‰ä¸€ä¸ªåº•éƒ¨å’Œé¡¶éƒ¨ï¼Œstackloå’Œstackhiåˆ†åˆ«ä»£è¡¨æ ˆçš„åº•éƒ¨å’Œé¡¶éƒ¨åœ°å€ã€‚ ä»¥ä¸‹æ˜¯ä¸ºä»€ä¹ˆè¦è¿™æ ·è®¾ç½®çš„åŸå› ï¼š å®‰å…¨è¾¹ç•Œï¼šé€šè¿‡å°†stackloè®¾ç½®ä¸ºè·ç¦»æ ˆé¡¶8MBå‡å»4KBçš„ä½ç½®ï¼Œä»£ç ä¸ºæ ˆæº¢å‡ºæ£€æµ‹ç•™å‡ºäº†ç©ºé—´ã€‚å¦‚æœgoroutineçš„æ ˆå¢é•¿è¶…è¿‡äº†è¿™ä¸ªè®¾ç½®çš„èŒƒå›´ï¼Œé‚£ä¹ˆå®ƒå°†è§¦å‘æ ˆæº¢å‡ºé”™è¯¯ï¼Œè€Œä¸æ˜¯è¦†ç›–å…¶ä»–å†…å­˜ï¼Œè¿™æœ‰åŠ©äºé˜²æ­¢å†…å­˜æŸåã€‚ æ ˆç©ºé—´é¢„ç•™ï¼šåœ¨Cå’ŒGoä»£ç ä¹‹é—´è¿›è¡Œåˆ‡æ¢æ—¶ï¼Œå¯èƒ½éœ€è¦é¢å¤–çš„æ ˆç©ºé—´æ¥å¤„ç†å‡½æ•°è°ƒç”¨ã€å‚æ•°ä¼ é€’ç­‰ã€‚é¢„ç•™ç©ºé—´å¯ä»¥ç¡®ä¿åœ¨è¿™äº›æ“ä½œä¸­æœ‰è¶³å¤Ÿçš„ç©ºé—´ï¼Œé¿å…æ ˆæº¢å‡ºã€‚ ä¸Goè¿è¡Œæ—¶æ ˆç®¡ç†å…¼å®¹ï¼šGoè¿è¡Œæ—¶è´Ÿè´£ç®¡ç†goroutinesçš„æ ˆï¼ŒåŒ…æ‹¬æ ˆçš„å¢é•¿å’Œæ”¶ç¼©ã€‚è¿™æ®µä»£ç ç¡®ä¿äº†Cçº¿ç¨‹çš„æ ˆä¸Goè¿è¡Œæ—¶çš„æ ˆç®¡ç†ç­–ç•¥å…¼å®¹ã€‚ åˆå§‹åŒ–setg_gccï¼šsetg_gccæ˜¯ä¸€ä¸ªå…¨å±€å˜é‡ï¼Œç”¨äºåœ¨Cä»£ç ä¸­è®¾ç½®å½“å‰çš„goroutineã€‚åœ¨Cä»£ç ä¸­è°ƒç”¨Goå‡½æ•°æ—¶ï¼Œéœ€è¦æ­£ç¡®è®¾ç½®å½“å‰çš„goroutineï¼Œè¿™æ ·Goè¿è¡Œæ—¶æ‰èƒ½æ­£ç¡®ç®¡ç†goroutineçš„çŠ¶æ€ã€‚ æ€»çš„æ¥è¯´ï¼Œè¿™æ®µä»£ç æ˜¯cgoåˆå§‹åŒ–çš„ä¸€éƒ¨åˆ†ï¼Œç›®çš„æ˜¯ä¸ºäº†ç¡®ä¿Cçº¿ç¨‹çš„æ ˆä¸Goè¿è¡Œæ—¶çš„goroutineæ ˆèƒ½å¤Ÿæ­£ç¡®åœ°ååŒå·¥ä½œï¼ŒåŒæ—¶ä¿æŒæ ˆçš„å®‰å…¨æ€§å’Œæ€§èƒ½ã€‚ 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 static void (*setg_gcc)(void*); // This will be set in gcc_android.c for android-specific customization. void (*x_cgo_inittls)(void **tlsg, void **tlsbase) __attribute__((common)); void x_cgo_init(G *g, void (*setg)(void*), void **tlsg, void **tlsbase) { // ç”³æ˜ä¸€ä¸ª pthread_attr_t ç±»å‹å˜é‡ *attrï¼ŒæŒ‡é’ˆç±»å‹. // pthread_attr_t æ˜¯çº¿ç¨‹çš„å±æ€§ç»“æ„ pthread_attr_t *attr; // ç”³æ˜ä¸€ä¸ª size_t ç±»å‹å˜é‡ sizeã€‚ size_t size; // ç”¨äºä¿å­˜æ–°åˆ›å»ºçš„è¿™ä¸ªçº¿ç¨‹çš„æ ˆå¤§å° /* The memory sanitizer distributed with versions of clang before 3.8 has a bug: if you call mmap before malloc, mmap may return an address that is later overwritten by the msan library. Avoid this problem by forcing a call to malloc here, before we ever call malloc. This is only required for the memory sanitizer, so it\u0026#39;s unfortunate that we always run it. It should be possible to remove this when we no longer care about versions of clang before 3.8. The test for this is misc/cgo/testsanitizers. GCC works hard to eliminate a seemingly unnecessary call to malloc, so we actually use the memory we allocate. */ setg_gcc = setg; // å‘setg_gccå…¨å±€é™æ€å˜é‡èµ‹å€¼setg_gcc()å‡½æ•°çš„åœ°å€ // å‘æ“ä½œç³»ç»Ÿç”³è¯· *attr ç±»å‹éœ€è¦çš„å†…å­˜ï¼Œå…¶å®å°±æ˜¯ä¸€ä¸ªæŒ‡é’ˆå¤§å°ã€‚ attr = (pthread_attr_t*)malloc(sizeof *attr); if (attr == NULL) { // ç”³è¯·å¤±è´¥ fatalf(\u0026#34;malloc failed: %s\u0026#34;, strerror(errno)); } // åˆå§‹åŒ–çº¿ç¨‹å±æ€§å¯¹è±¡ï¼›åˆ›å»ºçš„é»˜è®¤æ ˆå¤§å°ä¸º8M pthread_attr_init(attr); // pthread_attr_getstacksize è·å–çº¿ç¨‹çš„æ ˆå¤§å° pthread_attr_getstacksize(attr, \u0026amp;size); // __builtin_frame_address(0) æŸ¥çœ‹å½“å‰å‡½æ•°çš„æ ˆå¸§åœ°å€ï¼Œå› æ­¤å’ŒSPå¯„å­˜å™¨å€¼ç›¸å·®ä¸å¤§ // æ³¨æ„è¿™é‡Œä¿®æ”¹çš„æ˜¯ stack.lo = SP - 8MB + 4KBï¼ŒåŠ ä¸Š4KBæ˜¯ä¸ºäº†åˆ¤æ–­å½“å‰åˆ†é…çš„æ ˆæ˜¯å¦è¶…è¿‡4KB // å› ä¸ºgå‚æ•°ä¼ é€’çš„æ˜¯æŒ‡é’ˆï¼Œè¿™é‡Œç›´æ¥ä¿®æ”¹äº†g0çš„stack.loå­—æ®µçš„å€¼ï¼Œè¿™é‡Œç›¸å½“äºæ‰©å¤§äº†g0æ ˆå¤§å°ã€‚ g-\u0026gt;stacklo = (uintptr)__builtin_frame_address(0) - size + 4096; // lo \u0026gt;= hiï¼Œé”™è¯¯çš„æ ˆè¾¹ç•Œã€‚hi-\u0026gt;loï¼ˆé«˜-\u0026gt;ä½ï¼‰ï¼Œåˆ¤æ–­æ˜¯å¦æº¢å‡º if (g-\u0026gt;stacklo \u0026gt;= g-\u0026gt;stackhi) fatalf(\u0026#34;bad stack bounds: lo=%p hi=%p\\n\u0026#34;, g-\u0026gt;stacklo, g-\u0026gt;stackhi); // é”€æ¯ attr è¿™ä¸ªçº¿ç¨‹å±æ€§å¯¹è±¡ pthread_attr_destroy(attr); free(attr); // é‡Šæ”¾ attr å ç”¨çš„å†…å­˜ if (x_cgo_inittls) { x_cgo_inittls(tlsg, tlsbase); } } æ ¹æ®æ±‡ç¼–ä»£ç å¯çŸ¥ï¼Œsetg_gcc()å‡½æ•°åº”è¯¥æ˜¯æŠŠgæ”¾å…¥TLSå’ŒR14å¯„å­˜å™¨ä¸­ã€‚ æ–‡ä»¶ä½ç½®ï¼šgo1.19.3/src/runtime/asm_amd64.sã€‚ 1049 1050 1051 1052 1053 1054 # void setg_gcc(G*); set g called from gcc. TEXT setg_gcc\u0026lt;\u0026gt;(SB),NOSPLIT,$0 get_tls(AX) MOVQ DI, g(AX) MOVQ DI, R14 # set the g register RET ä¼ å…¥ç»™x_cgo_initçš„G *gå‚æ•°å…¶å®æ˜¯g0ï¼Œè€Œg0ç»“æ„ä½“ç¬¬ä¸€ä¸ªå­—æ®µå°±æ˜¯stackï¼ŒåŒ…å«stackloå’Œstackhiï¼Œå› æ­¤èƒ½ç›´æ¥è½¬æ¢ã€‚ æ–‡ä»¶ä½ç½®ï¼šgo1.19.3/src/runtime/cgo/libcgo.hã€‚ 17 18 19 20 21 22 23 24 25 26 27 /* * The beginning of the per-goroutine structure, * as defined in ../pkg/runtime/runtime.h. * Just enough to edit these two fields. */ typedef struct G G; struct G { uintptr stacklo; uintptr stackhi; }; æ€»ç»“ï¼šè¿™éƒ¨åˆ†ä»£ç ï¼Œå°è¯•è·å–CPUç›¸å…³ä¿¡æ¯å¹¶ä¿å­˜åœ¨å…¨å±€å˜é‡ä¸­ã€‚åˆ¤æ–­æ˜¯å¦å­˜åœ¨CGOç›¸å…³åˆå§‹åŒ–ï¼Œå¦‚æœéœ€è¦åˆ™ä»æ–°è®¾ç½®g0çš„æ ˆå¤§å°ã€‚ è¿è¡Œå®Œä¸Šé¢è¿™cgoåˆå§‹åŒ–ä¸æ ˆä¹‹é—´çš„å…³ç³»å¦‚ä¸‹å›¾æ‰€ç¤ºï¼š ä¸»çº¿ç¨‹ä¸m0ç»‘å®š è®¾ç½®tls è®¾ç½®å¥½g0æ ˆä¹‹åï¼Œè·å–åˆ°CPUå‹å·ä»¥åŠcgoåˆå§‹åŒ–åï¼Œè®¾ç½®å·¥ä½œçº¿ç¨‹TLSã€‚ è°ƒç”¨settlså‡½æ•°åˆå§‹åŒ–ä¸»çº¿ç¨‹çš„çº¿ç¨‹æœ¬åœ°å­˜å‚¨(TLS)ï¼Œç›®çš„æ˜¯æŠŠm0ä¸ä¸»çº¿ç¨‹å…³è”åœ¨ä¸€èµ·ã€‚ è®¾ç½®äº†çº¿ç¨‹æœ¬åœ°å­˜å‚¨ä¹‹åæ¥ä¸‹æ¥çš„å‡ æ¡æŒ‡ä»¤åœ¨äºéªŒè¯TLSåŠŸèƒ½æ˜¯å¦æ­£å¸¸ï¼Œå¦‚æœä¸æ­£å¸¸åˆ™ç›´æ¥aborté€€å‡ºç¨‹åºã€‚ æ–‡ä»¶ä½ç½®ï¼šgo1.19.3/src/runtime/asm_amd64.sã€‚ 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 # 1) è®¾ç½® TLS # ä¸‹é¢å¼€å§‹åˆå§‹åŒ–tlsï¼ˆthread local storageï¼Œçº¿ç¨‹æœ¬åœ°å­˜å‚¨ï¼‰ # LEAå°†å†…å­˜åœ°å€èµ‹å€¼ç»™DIï¼Œå–m0çš„tlsæˆå‘˜çš„åœ°å€åˆ°DIå¯„å­˜å™¨ LEAQ runtimeÂ·m0+m_tls(SB), DI # DI=\u0026amp;m0.tls # è°ƒç”¨settlsè®¾ç½®çº¿ç¨‹æœ¬åœ°å­˜å‚¨ï¼Œsettlså‡½æ•°çš„å‚æ•°åœ¨DIå¯„å­˜å™¨ä¸­ CALL runtimeÂ·settls(SB) # 2) éªŒè¯ TLS æ˜¯å¦å¯ç”¨ # store through it, to make sure it works # # é€šè¿‡å®ƒè¿›è¡Œå­˜å‚¨ï¼Œä»¥ç¡®ä¿å®ƒæœ‰æ•ˆ # éªŒè¯settlsæ˜¯å¦å¯ä»¥æ­£å¸¸å·¥ä½œï¼Œå¦‚æœæœ‰é—®é¢˜åˆ™aborté€€å‡ºç¨‹åº get_tls(BX)\t# è·å–fsæ®µåŸºåœ°å€å¹¶æ”¾å…¥BXå¯„å­˜å™¨ï¼Œå…¶å®å°±æ˜¯m0.tls[1]çš„åœ°å€ï¼Œget_tlsçš„ä»£ç ç”±ç¼–è¯‘å™¨ç”Ÿæˆ # é€šè¿‡ FS å¯„å­˜å™¨å­˜å‚¨çš„å€¼è¿›è¡Œè®¾ç½® MOVQ $0x123, g(BX) # æŠŠæ•´å‹å¸¸é‡0x123æ‹·è´åˆ°fsæ®µåŸºåœ°å€åç§»-8çš„å†…å­˜ä½ç½®ï¼Œä¹Ÿå°±æ˜¯m0.tls[0]=0x123 # é€šè¿‡ runtime.mtls[0] è¿›è¡Œå–å€¼ MOVQ runtimeÂ·m0+m_tls(SB), AX # AX=m0.tls[0]ï¼ŒMOVå°†å€¼èµ‹å€¼ç»™AX # æ¯”è¾ƒ AX ä¸ $0x123 æ˜¯å¦ç›¸ç­‰ CMPQ AX, $0x123 # æ£€æŸ¥m0.tls[0]çš„å€¼æ˜¯å¦é€šè¿‡çº¿ç¨‹æœ¬åœ°å­˜å‚¨å­˜å…¥çš„0x123æ¥éªŒè¯tlsåŠŸèƒ½æ˜¯å¦æ­£å¸¸ # å¦‚æœå‰é¢çš„æ¯”è¾ƒç»“æœæ˜¯ç›¸ç­‰ï¼Œè·³è½¬åˆ°å½“å‰æŒ‡ä»¤åœ°å€åŠ 2ä¸ªå­—èŠ‚çš„ä½ç½®ï¼ˆå³ä¸‹ä¸€æ¡æŒ‡ä»¤ï¼‰ # å¦‚æœæ¯”è¾ƒç»“æœä¸æ˜¯ç›¸ç­‰ï¼Œåˆ™ç»§ç»­æ‰§è¡Œä¸‹ä¸€æ¡æŒ‡ä»¤ã€‚ JEQ 2(PC) # è·³è¿‡ä¸‹é¢è¿™ä¸€æ¡æŒ‡ä»¤ CALL runtimeÂ·abort(SB) # å¦‚æœçº¿ç¨‹æœ¬åœ°å­˜å‚¨ä¸èƒ½æ­£å¸¸å·¥ä½œï¼Œé€€å‡ºç¨‹åº runtimeÂ·settls(SB) å°†tls-baseè®¾ç½®ä¸ºDIå¯„å­˜å™¨çš„å€¼ï¼ŒDIå¯„å­˜å™¨å­˜å‚¨çš„æ˜¯m0.tlsçš„åœ°å€ã€‚ é€šè¿‡arch_prctlç³»ç»Ÿè°ƒç”¨æŠŠm0.tls[1]çš„åœ°å€è®¾ç½®æˆäº†fsæ®µçš„æ®µåŸºå€ã€‚ CPUä¸­æœ‰ä¸ªå«fsçš„æ®µå¯„å­˜å™¨ä¸ä¹‹å¯¹åº”ï¼š è€Œæ¯ä¸ªçº¿ç¨‹éƒ½æœ‰è‡ªå·±çš„ä¸€ç»„CPUå¯„å­˜å™¨å€¼ï¼Œæ“ä½œç³»ç»Ÿåœ¨æŠŠçº¿ç¨‹è°ƒç¦»CPUè¿è¡Œæ—¶ä¼šå¸®æˆ‘ä»¬æŠŠæ‰€æœ‰å¯„å­˜å™¨ä¸­çš„å€¼ä¿å­˜åœ¨å†…å­˜ä¸­ã€‚ è°ƒåº¦çº¿ç¨‹èµ·æ¥è¿è¡Œæ—¶åˆä¼šä»å†…å­˜ä¸­æŠŠè¿™äº›å¯„å­˜å™¨çš„å€¼æ¢å¤åˆ°CPUã€‚åœ¨æ­¤ä¹‹åå·¥ä½œçº¿ç¨‹ä»£ç å°±å¯ä»¥é€šè¿‡fså¯„å­˜å™¨æ¥æ‰¾åˆ°m.tlsã€‚ æ–‡ä»¶ä½ç½®ï¼šgo1.19.3/src/runtime/sys_linux_amd64.sã€‚ 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 # set tls base to DI TEXT runtimeÂ·settls(SB),NOSPLIT,$32 #ifdef GOOS_android # Android stores the TLS offset in runtimeÂ·tls_g. SUBQ runtimeÂ·tls_g(SB), DI #else # DIå¯„å­˜å™¨ä¸­å­˜æ”¾çš„æ˜¯m.tls[0]çš„åœ°å€ï¼Œmçš„tlsæˆå‘˜æ˜¯ä¸€ä¸ªæ•°ç»„ # ä¸‹é¢è¿™ä¸€å¥ä»£ç æŠŠDIå¯„å­˜å™¨ä¸­çš„åœ°å€åŠ 8ï¼Œä¸ºä»€ä¹ˆè¦+8å‘¢ï¼Œä¸»è¦è·ŸELFå¯æ‰§è¡Œæ–‡ä»¶æ ¼å¼ä¸­çš„TLSå®ç°çš„æœºåˆ¶æœ‰å…³ # æ‰§è¡Œä¸‹é¢è¿™å¥æŒ‡ä»¤ä¹‹åDIå¯„å­˜å™¨ä¸­å­˜æ”¾çš„å°±æ˜¯m.tls[1]çš„åœ°å€äº† ADDQ $8, DI # ELF wants to use -8(FS) #endif # AMD64 Linuxå¹³å°çº¦å®šåœ¨è¿›è¡Œç³»ç»Ÿè°ƒç”¨æ—¶ä½¿ç”¨ï¼š # 1. raxå¯„å­˜å™¨å­˜æ”¾ç³»ç»Ÿè°ƒç”¨ç¼–å· # 2. åŒæ—¶çº¦å®šä½¿ç”¨rdi, rsi, rdx, r10, r8å’Œr9æ¥ä¼ é€’å‰6ä¸ªç³»ç»Ÿè°ƒç”¨å‚æ•° # ä¸‹é¢é€šè¿‡arch_prctlç³»ç»Ÿè°ƒç”¨è®¾ç½®FSæ®µåŸºåœ°å€ # arch_prctlç³»ç»Ÿè°ƒç”¨çš„ç¬¬äºŒä¸ªå‚æ•°ï¼Œè®¾ç½®è¯¥å€¼ä¸ºFSæ®µåŸºåœ°å€ MOVQ DI, SI # SI = DI # arch_prctlçš„ç¬¬ä¸€ä¸ªå‚æ•°ï¼šARCH_SET_FS å‚æ•°å€¼è¡¨ç¤ºè®¾ç½®çº¿ç¨‹çš„TLSåœ°å€çš„ã€‚ # åœ¨ x86 æ¶æ„ä¸­ï¼ŒFS å¯„å­˜å™¨ç”¨äºå­˜å‚¨ TLS ï¼ˆThread Local Storageï¼‰çš„åœ°å€ MOVQ $0x1002, DI\t# ARCH_SET_FS # AX ç³»ç»Ÿè°ƒç”¨ç¼–å· MOVQ $SYS_arch_prctl, AX # AX = $SYS_arch_prctl # DI = ARCH_SET_FS # SI = \u0026amp;m.tls[1] SYSCALL # ç³»ç»Ÿè°ƒç”¨ï¼Œè¿›å…¥å†…æ ¸ # åˆ¤æ–­ç³»ç»Ÿè°ƒç”¨æ˜¯å¦æˆåŠŸ # å°† AX å¯„å­˜å™¨ä¸­çš„å€¼ä¸ 0xfffffffffffff001 è¿›è¡Œæ¯”è¾ƒ # å¦‚æœ AX ä¸­çš„å€¼å°äºç­‰äº 0xfffffffffffff001ï¼Œåˆ™è·³è½¬åˆ°å½“å‰æŒ‡ä»¤åœ°å€åŠ ä¸Š2çš„åœ°å€ï¼ˆå³è·³è½¬åˆ°ä¸‹ä¸€æ¡æŒ‡ä»¤çš„ä¸‹ä¸€æ¡æŒ‡ä»¤ï¼‰ã€‚ CMPQ AX, $0xfffffffffffff001 JLS\t2(PC) # è·³è¿‡ä»¥ä¸‹ä¸¤æ¡æŒ‡ä»¤ MOVL $0xf1, 0xf1 # crash ç³»ç»Ÿè°ƒç”¨å¤±è´¥ç›´æ¥crashï¼Œå¤±è´¥åŸå› æ˜¯æŠŠ$0xf1æ”¾å…¥ä¸å­˜åœ¨åœ°å€é‡Œé¢ RET # ç›´æ¥è¿”å› ç›¸å…³å®å®šä¹‰ã€‚ æ–‡ä»¶ä½ç½®ï¼šgo1.19.3/src/runtime/go_tls.hã€‚ 9 10 11 12 #ifdef GOARCH_amd64 #define get_tls(r) MOVQ TLS, r // get_tlså‡½æ•°å®šä¹‰ï¼ŒTLSå…¶å®å°±æ˜¯FSå¯„å­˜å™¨çš„å€¼ #define g(r) 0(r)(TLS*1) // (r + TLS*1 + 0) #endif m0ç»‘å®š é¦–å…ˆæŠŠg0çš„åœ°å€æ”¾å…¥ä¸»çº¿ç¨‹çš„çº¿ç¨‹æœ¬åœ°å­˜å‚¨ï¼ˆTLSï¼‰ä¸­ï¼Œç„¶åé€šè¿‡ã€m0.g0=\u0026amp;g0ã€‘ã€g0.m=\u0026amp;m0ã€‘æŠŠm0å’Œg0ç»‘å®šåœ¨ä¸€èµ·ã€‚ ä¹‹ååœ¨ä¸»çº¿ç¨‹ä¸­é€šè¿‡get_tlså¯ä»¥è·å–åˆ°g0ï¼Œé€šè¿‡g0çš„mæˆå‘˜åˆå¯ä»¥æ‰¾åˆ°m0ã€‚ ä¿å­˜åœ¨ä¸»çº¿ç¨‹æœ¬åœ°å­˜å‚¨ä¸­çš„å€¼æ˜¯g0çš„åœ°å€ï¼Œä¹Ÿå°±æ˜¯è¯´å·¥ä½œçº¿ç¨‹çš„ç§æœ‰å…¨å±€å˜é‡å…¶å®æ˜¯ä¸€ä¸ªæŒ‡å‘gçš„æŒ‡é’ˆè€Œä¸æ˜¯æŒ‡å‘mçš„æŒ‡é’ˆã€‚ ç›®å‰è¿™ä¸ªæŒ‡é’ˆæŒ‡å‘g0ï¼Œè¡¨ç¤ºä»£ç æ­£è¿è¡Œåœ¨g0æ ˆã€‚ æ–‡ä»¶ä½ç½®ï¼šgo1.19.3/src/runtime/asm_amd64.sã€‚ 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 ok: # 1) g0 ä¸ TLS ç»‘å®š # set the per-goroutine and per-mach \u0026#34;registers\u0026#34; get_tls(BX)\t# è·å–fsæ®µåŸºåœ°å€åˆ°BXå¯„å­˜å™¨ LEAQ runtimeÂ·g0(SB), CX # CX = \u0026amp;g0; var g0 g; # æŠŠg0çš„åœ°å€ä¿å­˜åœ¨çº¿ç¨‹æœ¬åœ°å­˜å‚¨é‡Œé¢ MOVQ CX, g(BX) # m0.tls[0]=\u0026amp;g0 LEAQ runtimeÂ·m0(SB), AX # AX = \u0026amp;m0; var m0 m; # 2) m0 å’Œ g0 ç›¸äº’ç»‘å®š # m0.g0 = \u0026amp;g0 # g0.m = \u0026amp;m0 # save m-\u0026gt;g0 = g0 MOVQ CX, m_g0(AX) # m0.g0=g0 # save m0 to g0-\u0026gt;m # mçš„ç¬¬ä¸€ä¸ªå­—æ®µå°±æ˜¯m0.g0æ‰€ä»¥è¿™é‡ŒAXä»£è¡¨çš„å°±æ˜¯m0.g0çš„åœ°å€å¤„ MOVQ AX, g_m(CX) # g0.m=m0\t# CLD æŒ‡ä»¤æ˜¯ Clear Direction Flag çš„ç¼©å†™ã€‚ç”¨äºå°†æ–¹å‘æ ‡å¿—ä½ DFï¼ˆDirection Flagï¼‰æ¸…é›¶ã€‚ # åœ¨x86æ¶æ„çš„è®¡ç®—æœºä¸­ï¼Œæ–¹å‘æ ‡å¿—ä½DFæ˜¯ä¸€ä¸ªæ ‡å¿—å¯„å­˜å™¨ä¸­çš„ä¸€ä½ï¼Œç”¨äºæŒ‡ç¤ºå­—ç¬¦ä¸²æ“ä½œæŒ‡ä»¤ï¼ˆå¦‚ MOVSBã€LODSBã€STOSB ç­‰ï¼‰ # åœ¨æ‰§è¡Œæ—¶æ˜¯æŒ‰ç…§é€’å¢æ–¹å‘è¿˜æ˜¯é€’å‡æ–¹å‘è¿›è¡Œæ“ä½œã€‚ # å½“ DF ä¸º 0 æ—¶ï¼Œå­—ç¬¦ä¸²æŒ‡é’ˆå°†æŒ‰ç…§é€’å¢æ–¹å‘ç§»åŠ¨ï¼›å½“ DF ä¸º 1 æ—¶ï¼Œå­—ç¬¦ä¸²æŒ‡é’ˆå°†æŒ‰ç…§é€’å‡æ–¹å‘ç§»åŠ¨ã€‚ # CLD æŒ‡ä»¤å°†æ–¹å‘æ ‡å¿—ä½ DF æ¸…é›¶ï¼Œè¡¨ç¤ºå­—ç¬¦ä¸²æ“ä½œæŒ‡ä»¤å°†æŒ‰ç…§é€’å¢æ–¹å‘è¿›è¡Œæ“ä½œã€‚ # å¦‚æœæˆ‘ä»¬ä½¿ç”¨MOVSBæŒ‡ä»¤å°†ä¸€ä¸ªé•¿åº¦ä¸º10å­—èŠ‚çš„å­—ç¬¦ä¸²ä»å­˜å‚¨å™¨ä¸­å¤åˆ¶åˆ°å¯„å­˜å™¨ä¸­ï¼Œå®ƒä¼šæŒ‰ç…§é€’å¢æ–¹å‘ä»å­˜å‚¨å™¨ä¸­çš„ç¬¬ä¸€ä¸ªå­—èŠ‚å¼€å§‹è¯»å–æ•°æ®ï¼Œ # å¹¶å°†å®ƒä»¬å¤åˆ¶åˆ°å¯„å­˜å™¨ä¸­ã€‚ç„¶åï¼Œå®ƒä¼šé€’å¢å­˜å‚¨å™¨åœ°å€å’Œå¯„å­˜å™¨åœ°å€ï¼Œä»¥ä¾¿è¯»å–å’Œå¤åˆ¶ä¸‹ä¸€ä¸ªå­—èŠ‚ï¼Œç›´åˆ°æ•´ä¸ªå­—ç¬¦ä¸²è¢«å¤åˆ¶åˆ°å¯„å­˜å™¨ä¸­ä¸ºæ­¢ã€‚ # æ„æ€æ˜¯ï¼Œåœ¨ä½¿ç”¨å­—ç¬¦ä¸²æ“ä½œæŒ‡ä»¤æ—¶ï¼Œè¿™äº›æŒ‡ä»¤ä¼šæŒ‰ç…§é€’å¢æ–¹å‘æ“ä½œï¼Œå³æŒ‰ç…§å­˜å‚¨å™¨åœ°å€é€’å¢çš„é¡ºåºå¤åˆ¶æ•°æ®ã€‚ CLD # convention is D is always left cleared æ­¤æ—¶ï¼Œä¸»çº¿ç¨‹ï¼Œm0ï¼Œg0ä»¥åŠg0çš„æ ˆä¹‹é—´çš„å…³ç³»å¦‚ä¸‹å›¾æ‰€ç¤ºï¼š æ€»ç»“ï¼šè¿™æ®µå‡½æ•°é€šè¿‡runtimeÂ·settls()å‡½æ•°æŠŠå½“å‰å·¥ä½œçº¿ç¨‹çš„FSå¯„å­˜å™¨åœ°å€è®¾ç½®ä¸º\u0026amp;m0.tls[1]åœ°å€çš„å€¼ï¼Œç„¶åå†éªŒè¯æ˜¯å¦è®¾ç½®æˆåŠŸã€‚ç„¶åæŠŠg0åœ°å€æ”¾å…¥FSæ®µå¯„å­˜å™¨ä¸­ï¼Œä¹Ÿå°±æ˜¯\u0026amp;m0.tls[0]å¤„ï¼Œè¡¨ç¤ºå½“å‰å·¥ä½œçº¿ç¨‹æ­£åœ¨æ‰§è¡Œg0ã€‚æ¥ç€è®¾ç½®m0.g0=g0å’Œg0.m=m0ï¼ŒæŠŠg0å’Œm0ç›¸å…³è”èµ·ã€‚ æ£€æŸ¥ ç¼–è¯‘å™¨ä¼šåœ¨å¾ˆå¤šå‡½æ•°éœ€è¦å‰å°è£…ä¸€å±‚æŠŠgå†™å…¥R14å¯„å­˜å™¨ä¸­ã€‚è¿™é‡Œç¼–è¯‘å™¨ä¼šæŠŠg0å†™å…¥R14å¯„å­˜å…¶ä¸­ã€‚ ä¸»è¦æ˜¯runtimeÂ·check()å‡½æ•°ï¼Œæ£€æŸ¥å†…ç½®ç±»å‹çš„ç›¸å…³ã€‚ æ–‡ä»¶ä½ç½®ï¼šgo1.19.3/src/runtime/asm_amd64.sã€‚ 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 # Check GOAMD64 reqirements # We need to do this after setting up TLS, so that # we can report an error if there is a failure. See issue 49586. # # æ£€æŸ¥GOAMD64è¦æ±‚æˆ‘ä»¬éœ€è¦åœ¨è®¾ç½®TLSåæ‰§è¡Œæ­¤æ“ä½œï¼Œä»¥ä¾¿åœ¨å‡ºç°å¤±è´¥æ—¶æŠ¥å‘Šé”™è¯¯ã€‚ #ifdef NEED_FEATURES_CX\tMOVL $0, AX CPUID CMPL AX, $0 JE\tbad_cpu MOVL $1, AX CPUID ANDL $NEED_FEATURES_CX, CX CMPL CX, $NEED_FEATURES_CX JNE\tbad_cpu #endif #ifdef NEED_MAX_CPUID MOVL $0x80000000, AX CPUID CMPL AX, $NEED_MAX_CPUID JL bad_cpu #endif #ifdef NEED_EXT_FEATURES_BX MOVL $7, AX MOVL $0, CX CPUID ANDL $NEED_EXT_FEATURES_BX, BX CMPL BX, $NEED_EXT_FEATURES_BX JNE bad_cpu #endif #ifdef NEED_EXT_FEATURES_CX MOVL $0x80000001, AX CPUID ANDL $NEED_EXT_FEATURES_CX, CX CMPL CX, $NEED_EXT_FEATURES_CX JNE bad_cpu #endif #ifdef NEED_OS_SUPPORT_AX XORL CX, CX XGETBV ANDL $NEED_OS_SUPPORT_AX, AX CMPL AX, $NEED_OS_SUPPORT_AX JNE bad_cpu #endif #ifdef NEED_DARWIN_SUPPORT MOVQ $commpage64_version, BX CMPW (BX), $13 # cpu_capabilities64 undefined in versions \u0026lt; 13 JL bad_cpu MOVQ $commpage64_cpu_capabilities64, BX MOVQ (BX), BX MOVQ $NEED_DARWIN_SUPPORT, CX ANDQ CX, BX CMPQ BX, CX JNE bad_cpu #endif # \u0026#34;TEXT runtime.check(SB)\u0026#34; æ˜¯ç”±ç¼–è¯‘å™¨å®ç°ï¼Œå› ä¸ºä»¥ä¸‹checkæ–¹æ³•ç”±runtimeçš„Goå®ç°éœ€è¦è·å–gã€‚ # ç¼–è¯‘å™¨å®ç° \u0026#34;TEXT runtime.check(SB)\u0026#34; æ˜¯éœ€è¦æŠŠg0å†™å…¥R14ä¸­ï¼Œç„¶åJMPè·³è½¬åˆ°check # è¯¥å‡½æ•°åœ¨ go1.19.3/src/runtime/runtime1.go:check() # ä¸»è¦æ˜¯æ£€æŸ¥goæ”¯æŒçš„å˜é‡å†…å­˜æƒ…å†µï¼ŒåŸå­CASå‡½æ•°ç­‰ CALL runtimeÂ·check(SB) runtimeÂ·check(SB) æ±‡ç¼–å¼€å¤´å‡ è¡Œã€‚ TEXT runtime.check(SB) \u0026lt;autogenerated\u0026gt; xorps xmm15, xmm15\t# æ¸…é™¤xmm15å¯„å­˜å™¨ï¼Œå¯èƒ½åé¢å‡½æ•°éœ€è¦ä½¿ç”¨ mov r14, qword ptr fs:[0xfffffff8] # R14 = g0 jmp $runtime.check # è·³è½¬ check() å‡½æ•° runtime.check()çš„æºç å®šä¹‰åœ¨/src/runtime/runtime1.goæ–‡ä»¶ä¸­ã€‚ 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 func check() { var ( a int8 b uint8 c int16 d uint16 e int32 f uint32 g int64 h uint64 i, i1 float32 j, j1 float64 k unsafe.Pointer l *uint16 m [4]byte ) type x1t struct { x uint8 } type y1t struct { x1 x1t y uint8 } var x1 x1t var y1 y1t // æ£€æŸ¥ int8 ç±»å‹å ç”¨å­—èŠ‚é•¿åº¦ if unsafe.Sizeof(a) != 1 { throw(\u0026#34;bad a\u0026#34;) } // æ£€æŸ¥ uint8 ç±»å‹å ç”¨å­—èŠ‚é•¿åº¦ if unsafe.Sizeof(b) != 1 { throw(\u0026#34;bad b\u0026#34;) } if unsafe.Sizeof(c) != 2 { throw(\u0026#34;bad c\u0026#34;) } if unsafe.Sizeof(d) != 2 { throw(\u0026#34;bad d\u0026#34;) } if unsafe.Sizeof(e) != 4 { throw(\u0026#34;bad e\u0026#34;) } if unsafe.Sizeof(f) != 4 { throw(\u0026#34;bad f\u0026#34;) } if unsafe.Sizeof(g) != 8 { throw(\u0026#34;bad g\u0026#34;) } if unsafe.Sizeof(h) != 8 { throw(\u0026#34;bad h\u0026#34;) } if unsafe.Sizeof(i) != 4 { throw(\u0026#34;bad i\u0026#34;) } if unsafe.Sizeof(j) != 8 { throw(\u0026#34;bad j\u0026#34;) } if unsafe.Sizeof(k) != goarch.PtrSize { throw(\u0026#34;bad k\u0026#34;) } if unsafe.Sizeof(l) != goarch.PtrSize { throw(\u0026#34;bad l\u0026#34;) } if unsafe.Sizeof(x1) != 1 { throw(\u0026#34;bad unsafe.Sizeof x1\u0026#34;) } if unsafe.Offsetof(y1.y) != 1 { throw(\u0026#34;bad offsetof y1.y\u0026#34;) } if unsafe.Sizeof(y1) != 2 { throw(\u0026#34;bad unsafe.Sizeof y1\u0026#34;) } if timediv(12345*1000000000+54321, 1000000000, \u0026amp;e) != 12345 || e != 54321 { throw(\u0026#34;bad timediv\u0026#34;) } var z uint32 z = 1 // æ£€æŸ¥åŸå­æ“ä½œç›¸å…³ if !atomic.Cas(\u0026amp;z, 1, 2) { throw(\u0026#34;cas1\u0026#34;) } if z != 2 { throw(\u0026#34;cas2\u0026#34;) } z = 4 if atomic.Cas(\u0026amp;z, 5, 6) { throw(\u0026#34;cas3\u0026#34;) } if z != 4 { throw(\u0026#34;cas4\u0026#34;) } z = 0xffffffff if !atomic.Cas(\u0026amp;z, 0xffffffff, 0xfffffffe) { throw(\u0026#34;cas5\u0026#34;) } if z != 0xfffffffe { throw(\u0026#34;cas6\u0026#34;) } m = [4]byte{1, 1, 1, 1} atomic.Or8(\u0026amp;m[1], 0xf0) if m[0] != 1 || m[1] != 0xf1 || m[2] != 1 || m[3] != 1 { throw(\u0026#34;atomicor8\u0026#34;) } m = [4]byte{0xff, 0xff, 0xff, 0xff} atomic.And8(\u0026amp;m[1], 0x1) if m[0] != 0xff || m[1] != 0x1 || m[2] != 0xff || m[3] != 0xff { throw(\u0026#34;atomicand8\u0026#34;) } *(*uint64)(unsafe.Pointer(\u0026amp;j)) = ^uint64(0) if j == j { throw(\u0026#34;float64nan\u0026#34;) } if !(j != j) { throw(\u0026#34;float64nan1\u0026#34;) } *(*uint64)(unsafe.Pointer(\u0026amp;j1)) = ^uint64(1) if j == j1 { throw(\u0026#34;float64nan2\u0026#34;) } if !(j != j1) { throw(\u0026#34;float64nan3\u0026#34;) } *(*uint32)(unsafe.Pointer(\u0026amp;i)) = ^uint32(0) if i == i { throw(\u0026#34;float32nan\u0026#34;) } if i == i { throw(\u0026#34;float32nan1\u0026#34;) } *(*uint32)(unsafe.Pointer(\u0026amp;i1)) = ^uint32(1) if i == i1 { throw(\u0026#34;float32nan2\u0026#34;) } if i == i1 { throw(\u0026#34;float32nan3\u0026#34;) } testAtomic64() if _FixedStack != round2(_FixedStack) { throw(\u0026#34;FixedStack is not power-of-2\u0026#34;) } if !checkASM() { throw(\u0026#34;assembly checks failed\u0026#34;) } } æ€»ç»“ï¼šè¿™æ®µä»£ç ä¸»è¦æ˜¯è°ƒç”¨äº†runtimeÂ·check()å‡½æ•°ï¼Œè¯¥å‡½æ•°ä¸»è¦æ˜¯æ£€æŸ¥ç¼–è¯‘å™¨æ˜¯å¦æŒ‰ç…§é¢„æœŸï¼Œæ£€æŸ¥äº†ç›¸å…³å†…å­˜å ç”¨å€¼å’ŒåŸå­æ“ä½œç­‰ã€‚ åˆå§‹åŒ–m0 å¤„ç†å‘½ä»¤è¡Œå‚æ•°ï¼Œè°ƒç”¨osinitå‡½æ•°è·å–CPUæ ¸çš„æ•°é‡å¹¶ä¿å­˜åœ¨å…¨å±€å˜é‡ncpuä¹‹ä¸­ï¼Œ è°ƒåº¦å™¨åˆå§‹åŒ–æ—¶éœ€è¦çŸ¥é“å½“å‰ç³»ç»Ÿæœ‰å¤šå°‘ä¸ªCPUæ ¸ã€‚ è°ƒç”¨runtime.args()å‡½æ•°æ¥æš‚å­˜å‘½ä»¤è¡Œå‚æ•°ä»¥å¾…åç»­è§£æã€‚éƒ¨åˆ†ç³»ç»Ÿä¼šåœ¨è¿™é‡Œè·å–ä¸ç¡¬ä»¶ç›¸å…³çš„ä¸€äº›å‚æ•°ï¼Œä¾‹å¦‚ç‰©ç†é¡µé¢å¤§å°ã€‚ æ–‡ä»¶ä½ç½®ï¼šgo1.19.3/src/runtime/asm_amd64.sã€‚ 338 339 340 341 342 343 344 345 346 347 348 349 350 # 1) å‡†å¤‡è°ƒç”¨argså‡½æ•°ï¼Œå‰é¢å››æ¡æŒ‡ä»¤æŠŠå‚æ•°æ”¾åœ¨æ ˆä¸Š MOVL\t24(SP), AX\t# copy argc AX=argc MOVL\tAX, 0(SP)\t# argcæ”¾åœ¨æ ˆé¡¶ï¼Œä¸ºè°ƒç”¨runtimeÂ·argsçš„ç¬¬ä¸€ä¸ªå‚æ•°ï¼Œvar argc int32 MOVQ\t32(SP), AX\t# copy argv AX=*argv MOVQ\tAX, 8(SP)\t# argvæ”¾åœ¨SP+8çš„ä½ç½®ï¼Œä¸ºè°ƒç”¨runtimeÂ·argsçš„ç¬¬äºŒä¸ªå‚æ•°ï¼Œvar argv **byte # ä¿å­˜ argcå’Œargv éå† auxv è®¾ç½® physPageSize å’Œ startupRandomData ä»¥åŠå¤„ç† VDSO # å¤„ç†æ“ä½œç³»ç»Ÿä¼ é€’è¿‡æ¥çš„å‚æ•°å’Œenvï¼Œå¤åˆ¶å…¨å±€å˜é‡argcå’Œargvå€¼ï¼Œå¹¶å¤„ç†ç³»ç»Ÿå‚æ•°èµ‹å€¼ç»™cpuç›¸å…³ CALL\truntimeÂ·args(SB) # è·å–CPUæ ¸æ•°ä¿å­˜åœ¨ncpuä¸­ï¼Œè·å–physHugePageSizeå‚æ•°ã€‚ # physHugePageSize æ˜¯åˆ†é…å¤§é¡µé¢æ—¶å€™è¢«ç”¨åˆ°ã€‚ CALL\truntimeÂ·osinit(SB)\t# æ‰§è¡Œçš„ç»“æœæ˜¯å…¨å±€å˜é‡ncpu = CPUæ ¸æ•° CALL\truntimeÂ·schedinit(SB)\t# è°ƒåº¦ç³»ç»Ÿåˆå§‹åŒ– args(SB) å…³äº argv çš„åˆ†å¸ƒå›¾ã€‚ argvï¼šæ˜¯ä¸€ä¸ªæŒ‡å‘å­—ç¬¦æŒ‡é’ˆçš„æŒ‡é’ˆæ•°ç»„ï¼Œå…¶ä¸­æ¯ä¸ªå­—ç¬¦æŒ‡é’ˆæŒ‡å‘ä¸€ä¸ªä»¥ null ç»“å°¾çš„å­—ç¬¦ä¸²ï¼Œè¿™äº›å­—ç¬¦ä¸²ä»£è¡¨äº†ç¨‹åºå¯åŠ¨æ—¶åœ¨å‘½ä»¤è¡Œä¸Šè¾“å…¥çš„å‚æ•°ã€‚æ•°ç»„çš„ç¬¬ä¸€ä¸ªå…ƒç´  argv[0] é€šå¸¸åŒ…å«äº†ç¨‹åºçš„åç§°æˆ–è·¯å¾„ï¼Œè€Œéšåçš„å…ƒç´  argv[1] åˆ° argv[argc-1] åŒ…å«äº†ç¨‹åºçš„å®é™…å‚æ•°ã€‚ envpï¼šæ˜¯ä¸€ä¸ªæŒ‡å‘ç¯å¢ƒå˜é‡çš„æŒ‡é’ˆæ•°ç»„ï¼Œè¿™äº›ç¯å¢ƒå˜é‡åœ¨ç¨‹åºå¯åŠ¨æ—¶ç”±æ“ä½œç³»ç»Ÿä¼ é€’ç»™ç¨‹åºã€‚æ¯ä¸ªæ•°ç»„å…ƒç´ éƒ½æ˜¯ä¸€ä¸ªä»¥ null ç»“å°¾çš„å­—ç¬¦ä¸²ï¼Œè¡¨ç¤ºä¸€ä¸ªé”®å€¼å¯¹ï¼Œå…¶ä¸­é”®å’Œå€¼ä¹‹é—´é€šè¿‡ç­‰å·(=)è¿æ¥ã€‚ç¯å¢ƒå˜é‡æ˜¯æ“ä½œç³»ç»Ÿç”¨æ¥å­˜å‚¨æœ‰å…³å½“å‰ä¼šè¯æˆ–æ‰§è¡Œç¯å¢ƒçš„ä¿¡æ¯çš„ä¸€ç§æ–¹å¼ã€‚å®ƒä»¬é€šå¸¸ç”¨äºé…ç½®ç¨‹åºçš„è¡Œä¸ºï¼Œæä¾›è·¯å¾„ä¿¡æ¯ï¼Œæˆ–è€…å­˜å‚¨ç”¨æˆ·ç‰¹å®šçš„è®¾ç½®ã€‚ ä»¥ä¸‹æ˜¯ä¸€äº›å¸¸è§çš„ç¯å¢ƒå˜é‡åŠå…¶ç”¨é€”ï¼š HOMEï¼šç”¨æˆ·çš„ä¸»ç›®å½•è·¯å¾„ã€‚ PATHï¼šæ‰§è¡Œå‘½ä»¤æ—¶è¦æœç´¢çš„ç›®å½•åˆ—è¡¨ã€‚ PWDï¼šå½“å‰å·¥ä½œç›®å½•çš„è·¯å¾„ã€‚ USERï¼šå½“å‰ç™»å½•çš„ç”¨æˆ·åã€‚ SHELLï¼šç”¨æˆ·ç™»å½•çš„ shell çš„è·¯å¾„ã€‚ LANGï¼šç³»ç»Ÿè¯­è¨€å’Œåœ°åŒºè®¾ç½®ã€‚ DISPLAYï¼šX Window System çš„æ˜¾ç¤ºå˜é‡ï¼Œç”¨äºå›¾å½¢ç•Œé¢ç¨‹åºã€‚ EDITORï¼šç”¨æˆ·çš„é¦–é€‰æ–‡æœ¬ç¼–è¾‘å™¨ã€‚ TERMï¼šç»ˆç«¯ç±»å‹ã€‚ auxvï¼šä¸ºç¨‹åºæä¾›äº†å…³äºå…¶æ‰§è¡Œç¯å¢ƒçš„é¢å¤–ä¿¡æ¯ã€‚ ä»¥ä¸‹æ˜¯ä¸€äº›å¸¸è§çš„ auxv æ¡ç›®ç±»å‹åŠå…¶å«ä¹‰ï¼š AT_NULLï¼šæ ‡å¿—ç€ auxv æ•°ç»„çš„ç»“æŸã€‚ AT_EXECFDï¼šæ‰§è¡Œæ–‡ä»¶çš„æ–‡ä»¶æè¿°ç¬¦ã€‚ AT_PHDRï¼šç¨‹åºå¤´è¡¨çš„åœ°å€ã€‚ AT_PHENTï¼šç¨‹åºå¤´è¡¨ä¸­æ¯ä¸ªæ¡ç›®çš„å¤§å°ã€‚ AT_PHNUMï¼šç¨‹åºå¤´è¡¨ä¸­çš„æ¡ç›®æ•°é‡ã€‚ AT_PAGESZï¼šç³»ç»Ÿçš„é¡µé¢å¤§å°ã€‚ AT_BASEï¼šåŠ¨æ€é“¾æ¥å™¨çš„åŸºåœ°å€ã€‚ AT_ENTRYï¼šç¨‹åºçš„å…¥å£ç‚¹åœ°å€ã€‚ AT_UIDï¼šæ‰§è¡Œç¨‹åºçš„ç”¨æˆ·çš„çœŸå®ç”¨æˆ· IDã€‚ AT_EUIDï¼šæ‰§è¡Œç¨‹åºçš„æœ‰æ•ˆç”¨æˆ· IDã€‚ AT_GIDï¼šæ‰§è¡Œç¨‹åºçš„ç»„ IDã€‚ AT_EGIDï¼šæ‰§è¡Œç¨‹åºçš„æœ‰æ•ˆç»„ IDã€‚ AT_SECUREï¼šæŒ‡ç¤ºç¨‹åºæ˜¯å¦åœ¨ â€œsecure modeâ€ ä¸‹æ‰§è¡Œã€‚ AT_RANDOMï¼šæä¾›éšæœºå€¼çš„æŒ‡é’ˆï¼Œç”¨äºå®‰å…¨ç›®çš„ã€‚ æš‚å­˜å‘½ä»¤è¡Œå‚æ•°ä»¥å¾…åç»­è§£æã€‚ æ–‡ä»¶ä½ç½®ï¼šgo1.19.3/src/runtime/runtime1.goã€‚ 66 67 68 69 70 71 72 73 74 75 76 77 func args(c int32, v **byte) { // ä¿å­˜ argc å’Œ argv argc = c // runtimeçš„å…¨å±€å˜é‡ä¸­ argv = v // runtimeçš„å…¨å±€å˜é‡ä¸­ // åŠ è½½ auxv sysargs(c, v) } var ( argc int32 argv **byte ) sysargs() æ–‡ä»¶ä½ç½®ï¼šgo1.19.3/src/runtime/os_linux.goã€‚ 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 func sysargs(argc int32, argv **byte) { // è·³è¿‡ argv + NULL n := argc + 1 // skip over argv, envp to get to auxv // è·³è¿‡ argv å’Œ envp ç›´æ¥åˆ° auxv for argv_index(argv, n) != nil { n++ } // skip NULL separator n++ // è·³è¿‡ NULL // now argv+n is auxv // argv+n åç°åœ¨æ˜¯ auxvã€‚ auxv := (*[1 \u0026lt;\u0026lt; 28]uintptr)(add(unsafe.Pointer(argv), uintptr(n)*goarch.PtrSize)) if sysauxv(auxv[:]) != 0 { return } // In some situations we don\u0026#39;t get a loader-provided // auxv, such as when loaded as a library on Android. // Fall back to /proc/self/auxv. // // åœ¨æŸäº›æƒ…å†µä¸‹ï¼Œæˆ‘ä»¬ä¸ä¼šå¾—åˆ°åŠ è½½å™¨æä¾›çš„auxvï¼Œæ¯”å¦‚åœ¨Androidä¸Šä½œä¸ºåº“åŠ è½½æ—¶ã€‚ // å›åˆ° /proc/self/auxvï¼Œå»åŠ è½½ä¿¡æ¯ã€‚ // var procAuxv []byte = []byte(\u0026#34;/proc/self/auxv\\x00\u0026#34;) fd := open(\u0026amp;procAuxv[0], 0 /* O_RDONLY */, 0) // æ‰“å¼€æŒ‡å®šæ–‡ä»¶å¥æŸ„ if fd \u0026lt; 0 { // On Android, /proc/self/auxv might be unreadable (issue 9229), so we fallback to // try using mincore to detect the physical page size. // mincore should return EINVAL when address is not a multiple of system page size. const size = 256 \u0026lt;\u0026lt; 10 // size of memory region to allocate p, err := mmap(nil, size, _PROT_READ|_PROT_WRITE, _MAP_ANON|_MAP_PRIVATE, -1, 0) if err != 0 { return } var n uintptr for n = 4 \u0026lt;\u0026lt; 10; n \u0026lt; size; n \u0026lt;\u0026lt;= 1 { err := mincore(unsafe.Pointer(uintptr(p)+n), 1, \u0026amp;addrspace_vec[0]) if err == 0 { physPageSize = n break } } if physPageSize == 0 { physPageSize = size } munmap(p, size) return } var buf [128]uintptr // ä»å½“å‰æ–‡ä»¶ä¸­è¯»å–ä¿¡æ¯ n = read(fd, noescape(unsafe.Pointer(\u0026amp;buf[0])), int32(unsafe.Sizeof(buf))) closefd(fd) // å…³é—­æ–‡ä»¶å¥æŸ„ if n \u0026lt; 0 { return } // Make sure buf is terminated, even if we didn\u0026#39;t read // the whole file. // ç¡®ä¿bufè¢«ç»ˆæ­¢ï¼Œå³ä½¿æˆ‘ä»¬æ²¡æœ‰è¯»å–æ•´ä¸ªæ–‡ä»¶ã€‚ buf[len(buf)-2] = _AT_NULL sysauxv(buf[:]) } argv_index() æ–‡ä»¶ä½ç½®ï¼šgo1.19.3/src/runtime/runtime1.goã€‚ 59 60 61 62 63 64 // nosplit for use in linux startup sysargs // //go:nosplit func argv_index(argv **byte, i int32) *byte { return *(**byte)(add(unsafe.Pointer(argv), uintptr(i)*goarch.PtrSize)) } sysauxv() è®¾ç½® startupRandomData ç”¨äºHashï¼ŒphysPageSize ç‰©ç†å†…å­˜é¡µå¤§å°ï¼Œå¦‚æœè¿™äº›å­˜åœ¨çš„æƒ…å†µä¸‹ã€‚ è®¾ç½®å…¨å±€å˜é‡ç‰©ç†é¡µé¢å¤§å°ç­‰ã€‚ æ–‡ä»¶ä½ç½®ï¼šgo1.19.3/src/runtime/os_linux.goã€‚ 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 func sysauxv(auxv []uintptr) int { var i int // éå†auxvç›´åˆ°ç»“æŸ _AT_NULLï¼Œä¸€æ¬¡æ€§å–ä¸¤ä¸ªåˆ†åˆ«æ˜¯ tag å’Œ val for ; auxv[i] != _AT_NULL; i += 2 { tag, val := auxv[i], auxv[i+1] switch tag { case _AT_RANDOM: // The kernel provides a pointer to 16-bytes // worth of random data. // // å†…æ ¸æä¾›äº†ä¸€ä¸ªæŒ‡å‘16å­—èŠ‚éšæœºæ•°æ®çš„æŒ‡é’ˆã€‚ // startupRandomDataä¿å­˜åœ¨å¯åŠ¨æ—¶åˆå§‹åŒ–çš„éšæœºå­—èŠ‚ã€‚è¿™äº›æ¥è‡ªELF AT_RANDOMè¾…åŠ©å‘é‡ã€‚ startupRandomData = (*[16]byte)(unsafe.Pointer(val))[:] case _AT_PAGESZ: physPageSize = val // å¦‚æœæ˜¯ç‰©ç†é¡µå¤§å°è®¾ç½®è¯¥å€¼ } archauxv(tag, val) // è¯¥å‡½æ•°åœ¨linuxä¸‹æ˜¯ç©º vdsoauxv(tag, val) // å¤„ç† vdso } return i / 2 } osinit(SB) runtime.osinit()å‡½æ•°ä¸­ï¼Œæ‰€æœ‰çš„ç³»ç»Ÿéƒ½ä¼šåœ¨è¿™é‡Œè·å–CPUæ ¸å¿ƒæ•°ï¼Œå¦‚æœä¸Šä¸€æ­¥runtime.args()æ²¡æœ‰æˆåŠŸè·å–ç‰©ç†é¡µé¢å¤§å°ï¼Œåˆ™éƒ¨åˆ†ç³»ç»Ÿä¼šå†æ¬¡è·å–ã€‚Linuxç³»ç»Ÿä¼šåœ¨è¿™é‡Œè·å–Hugeç‰©ç†é¡µé¢çš„å¤§å°ã€‚ æ–‡ä»¶ä½ç½®ï¼šgo1.19.3/src/runtime/os_linux.goã€‚ 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 func osinit() { // è·å– CPU æ ¸æ•° ncpu = getproccount() // è·å–Linuxä¸­ç‰©ç†å†…å­˜å¤§é¡µé¢å¤§å°ã€‚ // å¤§é¡µé¢æ˜¯æŒ‡æ¯”æ™®é€šé¡µé¢ï¼ˆé€šå¸¸ä¸º 4KBï¼‰æ›´å¤§çš„é¡µé¢å¤§å°ï¼Œé€šå¸¸ä¸º 2MB æˆ– 1GBã€‚ // ä½¿ç”¨å¤§é¡µé¢å¯ä»¥æé«˜å†…å­˜è®¿é—®æ•ˆç‡å’Œç³»ç»Ÿæ€§èƒ½ï¼Œå› ä¸ºåœ¨ä½¿ç”¨å¤§é¡µé¢æ—¶ï¼Œå†…æ ¸éœ€è¦ç®¡ç†æ›´å°‘çš„é¡µè¡¨å’Œ TLB æ¡ç›®ã€‚ // è¯¥æ–¹æ³•é€šè¿‡openå»\u0026#34;/sys/kernel/mm/transparent_hugepage/hpage_pmd_size\u0026#34;è·¯å¾„è¯»å–çš„ physHugePageSize = getHugePageSize() if iscgo { // #42494 glibc and musl reserve some signals for // internal use and require they not be blocked by // the rest of a normal C runtime. When the go runtime // blocks...unblocks signals, temporarily, the blocked // interval of time is generally very short. As such, // these expectations of *libc code are mostly met by // the combined go+cgo system of threads. However, // when go causes a thread to exit, via a return from // mstart(), the combined runtime can deadlock if // these signals are blocked. Thus, don\u0026#39;t block these // signals when exiting threads. // - glibc: SIGCANCEL (32), SIGSETXID (33) // - musl: SIGTIMER (32), SIGCANCEL (33), SIGSYNCCALL (34) sigdelset(\u0026amp;sigsetAllExiting, 32) sigdelset(\u0026amp;sigsetAllExiting, 33) sigdelset(\u0026amp;sigsetAllExiting, 34) } osArchInit() // linuxä¸Šè¯¥å‡½æ•°ä¸ºç©º } è·å–cpuæ ¸æ•° è¿™æ®µä»£ç é€šè¿‡è°ƒç”¨æ“ä½œç³»ç»Ÿçš„sched_getaffinityç³»ç»Ÿè°ƒç”¨æ¥è·å–å½“å‰è¿›ç¨‹çš„CPUäº²å’ŒåŠ›æ©ç ï¼Œè¿™ä¸ªæ©ç æ˜¯ä¸€ä¸ªä½å›¾ï¼Œå…¶ä¸­æ¯ä¸ªæ¯”ç‰¹ä½å¯¹åº”ä¸€ä¸ªCPUæ ¸å¿ƒã€‚å¦‚æœæŸä¸ªæ¯”ç‰¹ä½ä¸º1ï¼Œåˆ™è¡¨ç¤ºå¯¹åº”çš„CPUæ ¸å¿ƒæ˜¯å¯ç”¨çš„ã€‚ä»£ç é€šè¿‡éå†è¿™ä¸ªä½å›¾å¹¶è®¡ç®—ä¸º1çš„æ¯”ç‰¹ä½çš„æ•°é‡æ¥å¾—åˆ°å¯ç”¨çš„CPUæ ¸å¿ƒæ•°ã€‚è¿™æ˜¯ä¸€ä¸ªé«˜æ•ˆçš„æ–¹å¼æ¥è·å–ç³»ç»Ÿèµ„æºä¿¡æ¯ï¼Œç‰¹åˆ«æ˜¯åœ¨éœ€è¦æ ¹æ®æ ¸å¿ƒæ•°æ¥è°ƒæ•´ç¨‹åºå¹¶è¡Œåº¦çš„åœºæ™¯ä¸­ã€‚ æ–‡ä»¶ä½ç½®ï¼šgo1.19.3/src/runtime/os_linux.goã€‚ 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 func getproccount() int32 { // This buffer is huge (8 kB) but we are on the system stack // and there should be plenty of space (64 kB). // Also this is a leaf, so we\u0026#39;re not holding up the memory for long. // See golang.org/issue/11823. // The suggested behavior here is to keep trying with ever-larger // buffers, but we don\u0026#39;t have a dynamic memory allocator at the // moment, so that\u0026#39;s a bit tricky and seems like overkill. // // è¿™ä¸ªç¼“å†²åŒºå¾ˆå¤§(8 kB)ï¼Œä½†æˆ‘ä»¬åœ¨ç³»ç»Ÿå †æ ˆä¸Šï¼Œåº”è¯¥æœ‰è¶³å¤Ÿçš„ç©ºé—´(64 kB)ã€‚ // è€Œä¸”è¿™æ˜¯ä¸€ä¸ªå¶å­ï¼Œæ‰€ä»¥æˆ‘ä»¬ä¸ä¼šå ç”¨å†…å­˜å¾ˆé•¿æ—¶é—´ã€‚ // è¿™é‡Œå»ºè®®çš„è¡Œä¸ºæ˜¯ç»§ç»­å°è¯•ä½¿ç”¨æ›´å¤§çš„ç¼“å†²åŒºï¼Œä½†æˆ‘ä»¬ç›®å‰æ²¡æœ‰åŠ¨æ€å†…å­˜åˆ†é…å™¨ï¼Œæ‰€ä»¥è¿™æœ‰ç‚¹æ£˜æ‰‹ï¼Œä¼¼ä¹æœ‰ç‚¹è¿‡åº¦ã€‚ // å®šä¹‰äº†ä¸€ä¸ªå¸¸é‡maxCPUsï¼Œå€¼ä¸º65536ã€‚ // è¿™ä¸ªå€¼å¹¶ä¸æ˜¯çœŸæ­£çš„CPUæ ¸å¿ƒæ•°ï¼Œè€Œæ˜¯ä¸€ä¸ªé¢„å®šä¹‰çš„æœ€å¤§å€¼ï¼Œç”¨äºç¡®å®šç¼“å†²åŒºå¤§å°ã€‚ const maxCPUs = 64 * 1024 // 65536 // å®šä¹‰äº†ä¸€ä¸ªå­—èŠ‚åˆ‡ç‰‡bufï¼Œå¤§å°ä¸º8192å­—èŠ‚ï¼ˆå³8KBï¼‰ã€‚ // è¿™æ˜¯å› ä¸ºæ¯ä¸ªCPUæ ¸å¿ƒå¯ä»¥ç”¨ä¸€ä¸ªæ¯”ç‰¹ä½è¡¨ç¤ºï¼Œæ‰€ä»¥8192å­—èŠ‚å¯ä»¥è¡¨ç¤º65536ä¸ªæ¯”ç‰¹ä½ï¼Œå¯¹åº”maxCPUsä¸ªCPUæ ¸å¿ƒ var buf [maxCPUs / 8]byte // 8KB // è¿™è¡Œä»£ç æ˜¯æ ¸å¿ƒï¼Œå®ƒè°ƒç”¨äº†æ“ä½œç³»ç»Ÿæä¾›çš„sched_getaffinityç³»ç»Ÿè°ƒç”¨ã€‚ // è¿™ä¸ªç³»ç»Ÿè°ƒç”¨ç”¨äºè·å–ç»™å®šè¿›ç¨‹IDï¼ˆè¿™é‡Œæ˜¯0ï¼Œè¡¨ç¤ºå½“å‰è¿›ç¨‹ï¼‰çš„CPUäº²å’ŒåŠ›æ©ç ã€‚ // 1. ç¬¬ä¸€ä¸ªå‚æ•°0è¡¨ç¤ºå½“å‰è¿›ç¨‹çš„è¿›ç¨‹IDã€‚ // 2. ç¬¬äºŒä¸ªå‚æ•°æ˜¯ç¼“å†²åŒºbufçš„å¤§å°ã€‚ // 3. ç¬¬ä¸‰ä¸ªå‚æ•°æ˜¯ç¼“å†²åŒºçš„æŒ‡é’ˆã€‚ // ræ˜¯ç³»ç»Ÿè°ƒç”¨çš„è¿”å›å€¼ï¼Œå®ƒè¡¨ç¤ºå®é™…å†™å…¥ç¼“å†²åŒºçš„å­—èŠ‚æ•°ã€‚ r := sched_getaffinity(0, unsafe.Sizeof(buf), \u0026amp;buf[0]) // int32 // å¦‚æœç³»ç»Ÿè°ƒç”¨è¿”å›è´Ÿå€¼ï¼Œè¡¨ç¤ºå‘ç”Ÿäº†é”™è¯¯ã€‚ // åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œå‡½æ•°è¿”å›1ï¼Œè¿™å¯èƒ½æ„å‘³ç€è‡³å°‘æœ‰ä¸€ä¸ªCPUæ ¸å¿ƒæ˜¯å¯ç”¨çš„ã€‚ if r \u0026lt; 0 { return 1 } n := int32(0) // éå†ç¼“å†²åŒºç›´åˆ°å®é™…å†™å…¥çš„å­—èŠ‚æ•°ã€‚ // è¿™æ®µä»£ç å®é™…ä¸Šæ˜¯åœ¨è®¡ç®—ç¼“å†²åŒºä¸­è®¾ç½®ä¸º1çš„æ¯”ç‰¹ä½çš„æ•°é‡ï¼Œæ¯ä¸ªä¸º1çš„æ¯”ç‰¹ä½ä»£è¡¨ä¸€ä¸ªå¯ç”¨çš„CPUæ ¸å¿ƒã€‚ for _, v := range buf[:r] { // å¯¹äºç¼“å†²åŒºçš„æ¯ä¸ªå­—èŠ‚ï¼Œå¦‚æœå®ƒä¸ä¸º0ï¼Œåˆ™è¿›è¡Œå¤„ç†ã€‚ for v != 0 { // é€šè¿‡æ£€æŸ¥æ¯ä¸ªæ¯”ç‰¹ä½æ˜¯å¦ä¸º1æ¥è®¡ç®—æ ¸å¿ƒæ•°ã€‚ // è¿™é‡Œä½¿ç”¨äº†ä½è¿ç®—\u0026amp;æ¥æ£€æŸ¥æœ€ä½ä½æ˜¯å¦ä¸º1ï¼Œå¦‚æœæ˜¯ï¼Œåˆ™å¢åŠ æ ¸å¿ƒæ•°ã€‚ n += int32(v \u0026amp; 1) // å°†å­—èŠ‚å³ç§»ä¸€ä½ï¼Œç»§ç»­æ£€æŸ¥ä¸‹ä¸€ä¸ªæ¯”ç‰¹ä½ã€‚ v \u0026gt;\u0026gt;= 1 } // n = 4 } // å¦‚æœè®¡ç®—å¾—å‡ºçš„æ ¸å¿ƒæ•°ä¸º0ï¼ˆè¿™å¯èƒ½æ˜¯ä¸€ä¸ªé”™è¯¯çš„æƒ…å†µï¼‰ï¼Œåˆ™é»˜è®¤è®¾ç½®ä¸º1ã€‚ if n == 0 { n = 1 } // å‡½æ•°è¿”å›è®¡ç®—å‡ºçš„CPUæ ¸å¿ƒæ•°ã€‚ return n } sched_getaffinity å‡½æ•°åŸå‹ã€‚ æ–‡ä»¶ä½ç½®ï¼šgo1.19.3/src/runtime/os_linux.goã€‚ 448 449 //go:noescape func sched_getaffinity(pid, len uintptr, buf *byte) int32 æ±‡ç¼–æ–‡ä»¶åœ°å€ï¼šgo1.19.3/src/runtime/sys_linux_amd64.sã€‚ 660 661 662 663 664 665 666 667 668 669 670 TEXT runtimeÂ·sched_getaffinity(SB),NOSPLIT,$0 # ç¬¬ä¸€ä¸ªå‚æ•° pid ä¸º 0 MOVQ pid+0(FP), DI\t# ç¬¬äºŒä¸ªå‚æ•° len å ç”¨å†…å­˜å¤§å°å­—èŠ‚ MOVQ len+8(FP), SI # ç¬¬ä¸‰ä¸ªå‚æ•° buf *byte æŒ‡é’ˆ MOVQ buf+16(FP), DX MOVL $SYS_sched_getaffinity, AX # $SYS_sched_getaffinity = 204 SYSCALL MOVL AX, ret+24(FP) # ä¿å­˜è¿”å›å€¼ RET è·å–ç‰©ç†å†…å­˜é¡µå¤§å° è¿™æ®µä»£ç é€šè¿‡è¯»å–æ“ä½œç³»ç»Ÿæ–‡ä»¶/sys/kernel/mm/transparent_hugepage/hpage_pmd_sizeæ¥è·å–é€æ˜å¤§é¡µçš„å¤§å°ã€‚ è¿™ä¸ªæ–‡ä»¶é€šå¸¸åŒ…å«ä¸€ä¸ªæ•´æ•°ï¼Œè¡¨ç¤ºé€æ˜å¤§é¡µçš„å¤§å°ï¼ˆé€šå¸¸æ˜¯2çš„å¹‚ï¼‰ã€‚ä»£ç é€šè¿‡æ ‡å‡†çš„æ–‡ä»¶æ‰“å¼€ã€è¯»å–å’Œå…³é—­æ“ä½œæ¥è·å–è¿™ä¸ªå€¼ï¼Œå¹¶è¿›è¡Œäº†ä¸€äº›åŸºæœ¬çš„é”™è¯¯å¤„ç†å’ŒéªŒè¯ï¼Œä»¥ç¡®ä¿è¿”å›çš„æ˜¯ä¸€ä¸ªåˆç†çš„é¡µå¤§å°ã€‚å¦‚æœæ–‡ä»¶ä¸å­˜åœ¨ã€æ— æ³•è¯»å–æˆ–å†…å®¹ä¸ç¬¦åˆé¢„æœŸï¼Œå‡½æ•°å°†è¿”å›0ã€‚è¿”å›å€¼uintptræ˜¯ä¸€ä¸ªæ— ç¬¦å·æ•´æ•°ç±»å‹ï¼Œè¶³ä»¥å­˜å‚¨å†…å­˜é¡µå¤§å°ã€‚ 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 // å®šä¹‰äº†ä¸€ä¸ªå­—èŠ‚åˆ‡ç‰‡sysTHPSizePathï¼Œå…¶ä¸­åŒ…å«äº†é€æ˜å¤§é¡µå¤§å°çš„é…ç½®æ–‡ä»¶è·¯å¾„ã€‚ // æœ«å°¾çš„\\x00æ˜¯ç©ºå­—ç¬¦ï¼Œç”¨äºå­—ç¬¦ä¸²çš„ç»ˆæ­¢ã€‚ var sysTHPSizePath = []byte(\u0026#34;/sys/kernel/mm/transparent_hugepage/hpage_pmd_size\\x00\u0026#34;) func getHugePageSize() uintptr { var numbuf [20]byte // è°ƒç”¨openå‡½æ•°ä»¥åªè¯»æ¨¡å¼æ‰“å¼€ä¸Šè¿°è·¯å¾„æŒ‡å®šçš„æ–‡ä»¶ã€‚ // 0ä½œä¸ºç¬¬äºŒä¸ªå‚æ•°è¡¨ç¤ºåªè¯»æ¨¡å¼ï¼ˆO_RDONLYï¼‰ï¼Œç¬¬ä¸‰ä¸ªå‚æ•°æ˜¯æ¨¡å¼ï¼Œè¿™é‡Œä¼ 0è¡¨ç¤ºä¸éœ€è¦ç‰¹æ®Šçš„æ–‡ä»¶æƒé™ã€‚ fd := open(\u0026amp;sysTHPSizePath[0], 0 /* O_RDONLY */, 0) // å¦‚æœopenå‡½æ•°è¿”å›çš„æ–‡ä»¶æè¿°ç¬¦å°äº0ï¼Œè¡¨ç¤ºæ‰“å¼€æ–‡ä»¶å¤±è´¥ï¼Œå‡½æ•°è¿”å›0ã€‚ if fd \u0026lt; 0 { return 0 } // ä½¿ç”¨noescapeå‡½æ•°æ¥é˜²æ­¢ptré€ƒé€¸åˆ°å †ä¸Šï¼Œunsafe.Pointerå°†numbufæ•°ç»„çš„åœ°å€è½¬æ¢ä¸ºæŒ‡é’ˆã€‚ ptr := noescape(unsafe.Pointer(\u0026amp;numbuf[0])) // è°ƒç”¨readå‡½æ•°ä»æ–‡ä»¶æè¿°ç¬¦fdè¯»å–å†…å®¹åˆ°numbufæ•°ç»„ä¸­ï¼Œæœ€å¤šè¯»å–numbufçš„é•¿åº¦ä¸ªå­—èŠ‚ã€‚ n := read(fd, ptr, int32(len(numbuf))) // è¯»å–å®Œæˆåå…³é—­æ–‡ä»¶æè¿°ç¬¦ã€‚ closefd(fd) // å¦‚æœè¯»å–çš„å­—èŠ‚æ•°å°äºæˆ–ç­‰äº0ï¼Œè¡¨ç¤ºè¯»å–å¤±è´¥æˆ–æ–‡ä»¶ä¸ºç©ºï¼Œå‡½æ•°è¿”å›0ã€‚ if n \u0026lt;= 0 { return 0 } // å‡å»1ï¼Œä»¥ç§»é™¤è¯»å–åˆ°çš„å­—ç¬¦ä¸²æœ«å°¾çš„æ¢è¡Œç¬¦ã€‚ n-- // remove trailing newline // å°†è¯»å–åˆ°çš„å­—èŠ‚è½¬æ¢ä¸ºå­—ç¬¦ä¸²ï¼Œç„¶åä½¿ç”¨atoiå‡½æ•°å°†å­—ç¬¦ä¸²è½¬æ¢ä¸ºæ•´æ•°ã€‚okè¡¨ç¤ºè½¬æ¢æ˜¯å¦æˆåŠŸã€‚ v, ok := atoi(slicebytetostringtmp((*byte)(ptr), int(n))) // å¦‚æœè½¬æ¢å¤±è´¥æˆ–å¾—åˆ°çš„å€¼å°äº0ï¼Œåˆ™å°†vè®¾ç½®ä¸º0ã€‚ if !ok || v \u0026lt; 0 { v = 0 } // æ£€æŸ¥væ˜¯å¦ä¸º2çš„å¹‚ã€‚ // ä¸€ä¸ªæ•°æ˜¯2çš„å¹‚å½“ä¸”ä»…å½“å®ƒä¸å…¶è‡ªèº«å‡1çš„ä½ä¸ç»“æœä¸º0ã€‚å¦‚æœä¸æ˜¯2çš„å¹‚ï¼Œåˆ™è¿”å›0ã€‚ if v\u0026amp;(v-1) != 0 { // v is not a power of 2 return 0 } // å¦‚æœä¸€åˆ‡æ­£å¸¸ï¼Œå°†è¯»å–åˆ°çš„å€¼è½¬æ¢ä¸ºuintptrç±»å‹å¹¶è¿”å›ã€‚ return uintptr(v) } schedinit(SB) åˆå§‹åŒ–è°ƒåº¦ç³»ç»Ÿï¼ŒåŠ è½½è¿‡ç¨‹ï¼š call osinitï¼šè°ƒç”¨osinit()å‡½æ•°ï¼Œè®¾ç½®runtime.ncpuå’Œruntime.physHugePageSizeå‚æ•°çš„å€¼ã€‚ call schedinitï¼šè°ƒç”¨schedinit()å‡½æ•°ï¼Œåˆå§‹åŒ–è°ƒåº¦å™¨ã€‚ make \u0026amp; queue new Gï¼šåˆ›å»ºç¬¬ä¸€ä¸ªmain goroutineï¼Œå¹¶åŠ å…¥é˜Ÿåˆ—ã€‚ call runtimeÂ·mstartï¼šè°ƒç”¨runtimeÂ·mstart()å‡½æ•°å¼€å¯è°ƒåº¦å¾ªç¯ã€‚ è¿™ä¸ªæ–°çš„goroutineè¿è¡Œruntime.main()å‡½æ•°ã€‚ æ–‡ä»¶ä½ç½®ï¼šgo1.19.3/src/runtime/proc.goã€‚ 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 756 757 758 759 760 761 762 763 764 765 766 767 768 769 770 771 772 773 774 775 776 777 778 779 780 781 782 783 784 785 786 787 788 789 790 791 792 793 794 795 796 797 // The bootstrap sequence is: // //\tcall osinit //\tcall schedinit //\tmake \u0026amp; queue new G //\tcall runtimeÂ·mstart // // The new G calls runtimeÂ·main. func schedinit() { // åˆå§‹åŒ–é”ï¼Œå¦‚æœæœ‰é”æ’åæƒ…å†µä¸‹ lockInit(\u0026amp;sched.lock, lockRankSched) lockInit(\u0026amp;sched.sysmonlock, lockRankSysmon) lockInit(\u0026amp;sched.deferlock, lockRankDefer) lockInit(\u0026amp;sched.sudoglock, lockRankSudog) lockInit(\u0026amp;deadlock, lockRankDeadlock) lockInit(\u0026amp;paniclk, lockRankPanic) lockInit(\u0026amp;allglock, lockRankAllg) lockInit(\u0026amp;allpLock, lockRankAllp) lockInit(\u0026amp;reflectOffs.lock, lockRankReflectOffs) lockInit(\u0026amp;finlock, lockRankFin) lockInit(\u0026amp;trace.bufLock, lockRankTraceBuf) lockInit(\u0026amp;trace.stringsLock, lockRankTraceStrings) lockInit(\u0026amp;trace.lock, lockRankTrace) lockInit(\u0026amp;cpuprof.lock, lockRankCpuprof) lockInit(\u0026amp;trace.stackTab.lock, lockRankTraceStackTab) // Enforce that this lock is always a leaf lock. // All of this lock\u0026#39;s critical sections should be // extremely short. // å¼ºåˆ¶è¿™ä¸ªé”å§‹ç»ˆæ˜¯ä¸€ä¸ªå¶é”ã€‚æ‰€æœ‰é”çš„å…³é”®éƒ¨åˆ†éƒ½åº”è¯¥éå¸¸çŸ­ã€‚ lockInit(\u0026amp;memstats.heapStats.noPLock, lockRankLeafRank) // raceinit must be the first call to race detector. // In particular, it must be done before mallocinit below calls racemapshadow. // // getg()å‡½æ•°åœ¨æºä»£ç ä¸­æ²¡æœ‰å¯¹åº”çš„å®šä¹‰ï¼Œç”±ç¼–è¯‘å™¨æ’å…¥ç±»ä¼¼ä¸‹é¢ä¸¤è¡Œä»£ç  // 1. get_tls(CX) =\u0026gt; MOVQ TLS, CX // 2. MOVQ g(CX), BX; // èµ·å§‹å°±æ˜¯ä»TLSä¸­å–å‡ºgoroutineï¼Œæ­¤æ—¶åº”è¯¥æ˜¯*g0ã€‚ä¹Ÿå°±æ˜¯\u0026amp;m0.tls[0]é‡Œé¢å­˜å‚¨çš„å€¼*g0ã€‚ // å‰é¢ä»£ç å¯çŸ¥ï¼Œg0çš„åœ°å€è¢«æ”¾å…¥äº†TLSä¸­ï¼Œå› æ­¤è¿™é‡Œä»TLSè·å–g0çš„åœ°å€ _g_ := getg() // _g_ = \u0026amp;g0 if raceenabled { _g_.racectx, raceprocctx0 = raceinit() } // è®¾ç½®æœ€å¤šå¯åŠ¨10000ä¸ªæ“ä½œç³»ç»Ÿçº¿ç¨‹ï¼Œä¹Ÿå°±æ˜¯æœ€å¤š10000ä¸ªM sched.maxmcount = 10000 // The world starts stopped. // // åœ¨æ²¡æœ‰é”æ’åä¸‹ï¼Œè¯¥å‡½æ•°ä¸ºç©ºã€‚å› ä¸ºæ­¤æ—¶å°±åªæœ‰m0ä¸€ä¸ªçº¿ç¨‹ã€‚ // åœ¨æœ‰é”æ’åä¸‹ï¼Œè¯¥å‡½æ•°æŠŠworldIsStoppedå…¨å±€å˜é‡è®¾ç½®ä¸º1ï¼Œå°±è¿”å›äº†ã€‚ worldStopped() // STW // æ ¡éªŒç¨‹åºçš„å„ä¸ªæ¨¡å—ï¼Œå› ä¸ºgolangæ”¯æŒsharedã€pluginç­‰buildæ¨¡å¼ï¼Œå¯èƒ½ä¼šæœ‰å¾ˆå¤šä¸ªäºŒè¿›åˆ¶æ¨¡å— // è¿™é‡Œä¼šæ ¡éªŒå„ä¸ªæ¨¡å—çš„ç¬¦å·ã€ABIç­‰ï¼Œç¡®ä¿æ¨¡å—é—´ä¸€è‡´ã€‚ moduledataverify() // æ ˆå†…å­˜åˆå§‹åŒ–ï¼Œstackpool å’Œ stackLarge åˆå§‹åŒ– // goroutineçš„æ ˆæ˜¯åŠ¨æ€åˆ†é…ã€åŠ¨æ€å¢é•¿çš„ï¼Œè¿™ä¸€æ­¥ä¼šåˆå§‹åŒ–ç”¨äºæ ˆåˆ†é…çš„å…¨å±€ç¼“å­˜æ± ï¼Œä»¥åŠç›¸å…³çš„é”ã€‚ stackinit() // æ ˆå†…å­˜åˆå§‹åŒ– // å †å†…å­˜åˆå§‹åŒ–ï¼ŒåŒ…æ‹¬åˆå§‹åŒ–mheapã€mcache0ä»¥åŠè®¾ç½®å †çš„arenaHint mallocinit()\t// è¿›è¡Œä¸CPUç›¸å…³çš„åˆå§‹åŒ–å·¥ä½œï¼Œæ£€æµ‹CPUæ˜¯å¦æ”¯æŒæŸäº›æŒ‡ä»¤é›†ï¼Œä»¥åŠæ ¹æ®GODEBUGç¯å¢ƒå˜é‡æ¥å¯ç”¨æˆ–ç¦ç”¨æŸäº›ç¡¬ä»¶ç‰¹æ€§ cpuinit() // must run before alginit // æ ¹æ®CPUå¯¹AESç›¸å…³æŒ‡ä»¤çš„æ”¯æŒæƒ…å†µï¼Œé€‰æ‹©ä¸åŒå¾—Hashç®—æ³•ï¼Œæ‰€ä»¥å¿…é¡»åœ¨ cpuinit() åé¢è°ƒç”¨ // mapã€hashå¿…é¡»åœ¨ alginit() å‡½æ•°è°ƒç”¨åæ‰å¯ä»¥ä½¿ç”¨ alginit() // maps, hash, fastrand must not be used before this call // åˆå§‹åŒ– fastrandseedï¼Œåœ¨æ¥ä¸‹æ¥çš„mcommoninit()å‡½æ•°ä¸­è¢«ç”¨åˆ° fastrandinit() // must run before mcommoninit // åˆå§‹åŒ–m0ï¼Œå› ä¸ºä»å‰çš„ä»£ç æˆ‘ä»¬çŸ¥é“ g0-\u0026gt;m=\u0026amp;m0 // ä¸ºå½“å‰å·¥ä½œçº¿ç¨‹Måˆ†é…IDã€åˆå§‹åŒ–gsignalï¼Œå¹¶æŠŠMæ·»åŠ åˆ°allmå…¨å±€é“¾è¡¨ä¸­ // è¯¥å‡½æ•°åœ¨æ–°åˆ›å»ºå·¥ä½œçº¿ç¨‹æ—¶ä¹Ÿä¼šè°ƒç”¨ã€‚ mcommoninit(_g_.m, -1) // m0 // åŸºäºæ‰€æœ‰çš„å·²åŠ è½½æ¨¡å—ï¼Œæ„é€ ä¸€ä¸ªæ´»è·ƒæ¨¡å—åˆ‡ç‰‡ modulesSliceï¼Œå¹¶åˆå§‹åŒ–GCéœ€è¦çš„Maskæ•°æ® modulesinit() // provides activeModules // Typelinksinitæ‰«ææ¥è‡ªé¢å¤–æ¨¡å—çš„ç±»å‹ï¼Œå¹¶æ„å»ºmoduledataç±»å‹æ˜ å°„ï¼Œç”¨äºæ¶ˆé™¤é‡å¤ç±»å‹æŒ‡é’ˆã€‚ // åŸºäºæ´»è·ƒæ¨¡å—åˆ—è¡¨æ„å»ºæ¨¡å—çº§çš„typemapï¼Œå®ç°å…¨å±€èŒƒå›´å†…å¯¹ç±»å‹å…ƒæ•°æ®å»é‡ã€‚ typelinksinit() // uses maps, activeModules // éå†æ´»è·ƒæ¨¡å—åˆ—è¡¨ï¼Œå°†ç¼–è¯‘å™¨é˜¶æ®µç”Ÿæˆçš„æ‰€æœ‰itabæ·»åŠ åˆ°itabTableä¸­ // è¯¥å‡½æ•°ä¼šè°ƒç”¨itabAdd()å‡½æ•°ï¼Œæ¥å£çš„æ—¶å€™çŸ¥é“è¯¥å‡½æ•°ä¼šç”Ÿæˆ*itab itabsinit() // uses activeModules stkobjinit() // must run before GC starts sigsave(\u0026amp;_g_.m.sigmask) initSigmask = _g_.m.sigmask // è§£æå‘½ä»¤è¡Œå‚æ•°ï¼Œç¨‹åºä¸­é€šè¿‡os.Argså¾—åˆ°çš„å‚æ•°æ˜¯åœ¨è¿™é‡Œåˆå§‹åŒ–çš„ï¼ˆWindowsé™¤å¤–ï¼‰ // å­˜å…¥ argslice []string å˜é‡ä¸­ goargs() // è§£æç¯å¢ƒå˜é‡ï¼Œç¨‹åºä¸­é€šè¿‡os.Getenvè·å–çš„ç¯å¢ƒå˜é‡æ˜¯åœ¨è¿™é‡Œåˆå§‹åŒ–çš„ï¼ˆWindowsé™¤å¤–ï¼‰ // å­˜å…¥ envs []string å˜é‡ä¸­ goenvs() // è§£æç¯å¢ƒå˜é‡GODEBUGï¼Œä¸ºruntimeå„ä¸ªè°ƒè¯•å‚æ•°èµ‹å€¼ parsedebugvars() // åˆå§‹åŒ–ä¸GCç›¸å…³çš„å‚æ•°ï¼Œæ ¹æ®ç¯å¢ƒå˜é‡GOGCè®¾ç½®gcpercent gcinit() lock(\u0026amp;sched.lock) // è·å– mutex è§£é” // ä¸Šæ¬¡ç½‘ç»œè½®è¯¢çš„æ—¶é—´ç‚¹ï¼Œè®¾ç½®ä¸ºå½“å‰æ—¶é—´ç‚¹ sched.lastpoll = uint64(nanotime()) // ç³»ç»Ÿä¸­æœ‰å¤šå°‘æ ¸ï¼Œå°±åˆ›å»ºå’Œåˆå§‹åŒ–å¤šå°‘ä¸ªPç»“æ„ä½“å¯¹è±¡ procs := ncpu\t// ncpuè¯¥å€¼åœ¨runtime.osinitå‡½æ•°ä¸­è¢«è®¾ç½® // å¦‚æœç¯å¢ƒå˜é‡æŒ‡å®šäº†GOMAXPROCSï¼Œåˆ™åˆ›å»ºæŒ‡å®šæ•°é‡çš„p if n, ok := atoi32(gogetenv(\u0026#34;GOMAXPROCS\u0026#34;)); ok \u0026amp;\u0026amp; n \u0026gt; 0 { procs = n\t} // procresize åˆ›å»ºå’Œåˆå§‹åŒ–å…¨å±€å˜é‡allp // æ ¹æ® CPU çš„æ ¸æ•°æˆ–ç¯å¢ƒå˜é‡GOMAXPROCç¡®å®šPçš„æ•°é‡ï¼Œè°ƒç”¨procresizeè¿›è¡Œè°ƒæ•´ // procresize è¿”å›nilè¡¨ç¤ºæ‰€æœ‰çš„Pä¸­æœ¬åœ°é˜Ÿåˆ—éƒ½æ²¡æœ‰å¯è¿è¡Œçš„goroutineã€‚ if procresize(procs) != nil { throw(\u0026#34;unknown runnable goroutine during bootstrap\u0026#34;) } unlock(\u0026amp;sched.lock) // mutex è§£é” // World is effectively started now, as P\u0026#39;s can run. worldStarted() // Start World // For cgocheck \u0026gt; 1, we turn on the write barrier at all times // and check all pointer writes. We can\u0026#39;t do this until after // procresize because the write barrier needs a P. // // å¯¹äºcgocheck \u0026gt; 1ï¼Œæˆ‘ä»¬åœ¨ä»»ä½•æ—¶å€™éƒ½æ‰“å¼€å†™å±éšœå¹¶æ£€æŸ¥æ‰€æœ‰çš„æŒ‡é’ˆå†™ã€‚ // æˆ‘ä»¬ä¸èƒ½è¿™æ ·åšï¼Œç›´åˆ°procresizeä¹‹åï¼Œå› ä¸ºå†™å±éšœéœ€è¦ä¸€ä¸ªPã€‚ if debug.cgocheck \u0026gt; 1 { // debug.cgocheckåœ¨parsedebugvars()å‡½æ•°ä¸­è¢«è®¾ç½®ä¸º1 // å¼€å¯å†™å±éšœ writeBarrier.cgo = true writeBarrier.enabled = true // åˆå§‹åŒ–æ‰€æœ‰Pä¸Šçš„å†™å±éšœç¼“å­˜åŒº for _, p := range allp { p.wbBuf.reset() } } // æœªçŸ¥ç¼–è¯‘ç‰ˆæœ¬æ—¶ if buildVersion == \u0026#34;\u0026#34; { // Condition should never trigger. This code just serves // to ensure runtimeÂ·buildVersion is kept in the resulting binary. // // æ¡ä»¶åº”è¯¥æ°¸è¿œä¸ä¼šè§¦å‘ã€‚è¿™æ®µä»£ç åªæ˜¯ç”¨äºç¡®ä¿runtimeÂ·buildVersionä¿å­˜åœ¨ç»“æœäºŒè¿›åˆ¶æ–‡ä»¶ä¸­ã€‚ buildVersion = \u0026#34;unknown\u0026#34; } if len(modinfo) == 1 { // Condition should never trigger. This code just serves // to ensure runtimeÂ·modinfo is kept in the resulting binary. // // æ¡ä»¶åº”è¯¥æ°¸è¿œä¸ä¼šè§¦å‘ã€‚è¿™æ®µä»£ç åªæ˜¯ç”¨äºç¡®ä¿runtimeÂ·modinfoä¿å­˜åœ¨ç»“æœäºŒè¿›åˆ¶æ–‡ä»¶ä¸­ã€‚ modinfo = \u0026#34;\u0026#34; } } mcommoninit() getg()è·å–å‡ºæ¥çš„æ˜¯g0ï¼Œç„¶åè°ƒç”¨mcommoninitå‡½æ•°å¯¹m0(g0.m)è¿›è¡Œå¿…è¦çš„åˆå§‹åŒ–ã€‚ é¢„åˆ†é…çš„IDå¯ä»¥ä½œä¸º'id'ä¼ é€’ï¼Œä¹Ÿå¯ä»¥é€šè¿‡ä¼ é€’ -1 æ¥çœç•¥ï¼Œç³»ç»Ÿé»˜è®¤åˆ†é…ã€‚ è¯¥å‡½æ•°åœ¨æ–°åˆ›å»ºå·¥ä½œçº¿ç¨‹æ—¶ä¹Ÿä¼šè¢«è°ƒç”¨ï¼Œå› æ­¤å¯èƒ½ä¼šå‡ºç°ç«äº‰ã€‚ æ€»ç»“ï¼šè¯¥æ–¹æ³•ä¸»è¦ä¸ºå·¥ä½œçº¿ç¨‹åˆ†é…ï¼ˆæŒ‡å®šä¸€ä¸ªå”¯ä¸€idï¼‰ï¼Œå¹¶åˆå§‹åŒ–mçš„ç›¸å…³å‚æ•°ï¼ŒæŠŠmåŠ å…¥åˆ°å…¨å±€allmä¸­ã€‚ æ–‡ä»¶ä½ç½®ï¼šgo1.19.3/src/runtime/proc.goã€‚ 785 786 787 788 789 790 791 792 793 794 795 796 797 798 799 800 801 802 803 804 805 806 807 808 809 810 811 812 813 814 815 816 817 818 819 820 821 822 823 824 825 826 827 828 829 830 831 832 833 834 835 836 837 838 839 840 841 842 843 844 845 846 847 848 849 // Pre-allocated ID may be passed as \u0026#39;id\u0026#39;, or omitted by passing -1. func mcommoninit(mp *m, id int64) { _g_ := getg() // \u0026amp;g0 // g0 stack won\u0026#39;t make sense for user (and is not necessary unwindable). // // g0å †æ ˆå¯¹ç”¨æˆ·æ¥è¯´æ²¡æœ‰æ„ä¹‰(å¹¶ä¸”ä¸ä¸€å®šæ˜¯å¯æ’¤é”€çš„)ã€‚ if _g_ != _g_.m.g0 { callers(1, mp.createstack[:]) } // è·å– mutex é” lock(\u0026amp;sched.lock) if id \u0026gt;= 0 { mp.id = id // ä½¿ç”¨ä¼ é€’æ¥çš„id } else { mp.id = mReserveID() // ç³»ç»Ÿåˆ†é… } // æ ¹æ®mp.idå’Œfastrandseedç”Ÿæˆéšæœºhash lo := uint32(int64Hash(uint64(mp.id), fastrandseed)) // æ ¹æ®cputicks()å’Œ^fastrandseedç”Ÿæˆéšæœºhashã€‚cputicks()æ˜¯å½“å‰CPUæ—¶é—´ hi := uint32(int64Hash(uint64(cputicks()), ^fastrandseed)) // å¦‚æœ lo å’Œ hi åˆšå¥½äº’è¡¥æ—¶ if lo|hi == 0 { hi = 1 } // Same behavior as for 1.17. // TODO: Simplify ths. // // ä¸‹é¢é€šè¿‡ uint32 çš„ lo å’Œ hi ç»„æˆä¸€ä¸ª(hi\u0026lt;\u0026lt;32 + lo)çš„uint64éšæœºå€¼ // å› ä¸ºå†…å­˜å­˜å‚¨çš„åŸå› æ‰€ä»¥æœ‰ä»¥ä¸‹åˆ¤æ–­ï¼Œä»¥åŠæ•°æ®çš„æ“ä½œä¸ä¸€æ · if goarch.BigEndian { // æ•°æ®å­˜å‚¨æ˜¯å¤§ç«¯å­˜å‚¨æ—¶ mp.fastrand = uint64(lo)\u0026lt;\u0026lt;32 | uint64(hi) } else { // æ•°æ®å­˜å‚¨æ˜¯å°ç«¯å­˜å‚¨æ—¶ // linux x86èµ°è¿™é‡Œã€‚fastrandè¡¨ç¤ºMçš„éšæœºå€¼ã€‚ mp.fastrand = uint64(hi)\u0026lt;\u0026lt;32 | uint64(lo) } // åˆ›å»ºä¿¡å·å¤„ç†çš„gsignalã€‚ // åˆ†é…ä¸€ä¸ª32KBå¤§å°çš„æ ˆï¼Œç„¶å mp.gsignal.m = mp mpreinit(mp) if mp.gsignal != nil { // è®¾ç½® mp.gsignal.stackguard1 = 0 + _StackGuard mp.gsignal.stackguard1 = mp.gsignal.stack.lo + _StackGuard } // Add to allm so garbage collector doesn\u0026#39;t free g-\u0026gt;m // when it is just in a register or thread-local storage. mp.alllink = allm // mp.alllink ä¸ allm ç»‘å®š // NumCgoCall() iterates over allm w/o schedlock, // so we need to publish it safely. atomicstorep(unsafe.Pointer(\u0026amp;allm), unsafe.Pointer(mp)) // atomically allm = mp unlock(\u0026amp;sched.lock) // mutex è§£é” // Allocate memory to hold a cgo traceback if the cgo call crashes. // å¦‚æœcgoè°ƒç”¨å´©æºƒï¼Œåˆ†é…å†…å­˜ä¿å­˜cgoå›æº¯ã€‚ if iscgo || GOOS == \u0026#34;solaris\u0026#34; || GOOS == \u0026#34;illumos\u0026#34; || GOOS == \u0026#34;windows\u0026#34; { mp.cgoCallers = new(cgoCallers) } } mReserveID() å‘ç³»ç»Ÿç”³è¯·IDã€‚å°±æ˜¯é€’å¢çš„å€¼ã€‚ æ–‡ä»¶ä½ç½®ï¼šgo1.19.3/src/runtime/proc.goã€‚ 769 770 771 772 773 774 775 776 777 778 779 780 781 782 783 784 785 786 // mReserveID returns the next ID to use for a new m. This new m is immediately // considered \u0026#39;running\u0026#39; by checkdead. // // sched.lock must be held. func mReserveID() int64 { // è°ƒç”¨è¯¥æ–¹æ³•æ—¶ sched.lock é”å¿…é¡»å·²è¢«æŒæœ‰ assertLockHeld(\u0026amp;sched.lock) // mnext å€¼å·²ç»æº¢å‡º if sched.mnext+1 \u0026lt; sched.mnext { throw(\u0026#34;runtime: thread ID overflow\u0026#34;) } id := sched.mnext // åˆ†é…è¯¥å€¼ sched.mnext++ // æ£€æŸ¥æ˜¯å¦è¶…å‡ºè®¾ç½®çš„æœ€å¤§å€¼ checkmcount() return id } 759 760 761 762 763 764 765 766 767 768 // sched.lock must be held. func checkmcount() { assertLockHeld(\u0026amp;sched.lock) // sched.maxmcount æœ€å¤§å€¼é»˜è®¤è¢«è®¾ç½®ä¸º 10000 if mcount() \u0026gt; sched.maxmcount { print(\u0026#34;runtime: program exceeds \u0026#34;, sched.maxmcount, \u0026#34;-thread limit\\n\u0026#34;) throw(\u0026#34;thread exhaustion\u0026#34;) } } 4490 4491 4492 4493 func mcount() int32 { // sched.nmfreed å·²é‡Šæ”¾çš„å·¥ä½œçº¿ç¨‹æ•°é‡ return int32(sched.mnext - sched.nmfreed) } mpreinit() mpreinit ä¸ºgsignalåˆ†é…32KBæ ˆï¼Œå¹¶ç»‘å®šå½“å‰Mã€‚ æ–‡ä»¶ä½ç½®ï¼šgo1.19.3/src/runtime/os_linux.goã€‚ 381 382 383 384 385 386 // Called to initialize a new m (including the bootstrap m). // Called on the parent thread (main thread in case of bootstrap), can allocate memory. func mpreinit(mp *m) { mp.gsignal = malg(32 * 1024) // Linux wants \u0026gt;= 2K mp.gsignal.m = mp } atomicstorep() atomicstorep åŸå­åœ°æ‰§è¡Œ *ptr = newï¼Œå¹¶è°ƒç”¨ä¸€ä¸ªå†™å±éšœã€‚ æ–‡ä»¶ä½ç½®ï¼šgo1.19.3/src/runtime/atomic_pointer.goã€‚ 28 29 30 31 32 33 34 35 36 37 // atomicstorep performs *ptr = new atomically and invokes a write barrier. // //go:nosplit func atomicstorep(ptr unsafe.Pointer, new unsafe.Pointer) { // å¦‚æœå¼€å¯äº†å†™å±éšœ if writeBarrier.enabled { atomicwb((*unsafe.Pointer)(ptr), new) } atomic.StorepNoWB(noescape(ptr), new) // *ptr = new } æ­¤æ—¶ï¼Œä¸»çº¿ç¨‹ï¼Œm0ï¼Œg0ä»¥åŠg0çš„æ ˆä¹‹é—´çš„å…³ç³»å¦‚ä¸‹å›¾æ‰€ç¤ºï¼š goargs() ä¿å­˜argvå‚æ•°åˆ°argsliceä¸­ã€‚ æ–‡ä»¶ä½ç½®ï¼šgo1.19.3/src/runtime/runtime1.goã€‚ 72 73 74 75 76 77 78 79 80 81 82 83 84 85 func goargs() { if GOOS == \u0026#34;windows\u0026#34; { return } // ç”³è¯·å‚æ•°éœ€è¦çš„å†…å­˜å¤§å° argslice = make([]string, argc) for i := int32(0); i \u0026lt; argc; i++ { // argv_index åœ¨7.1.2ä¸­åˆ—å‡ºï¼Œå°±æ˜¯åç§»iä¸ªå­—èŠ‚ argslice[i] = gostringnocopy(argv_index(argv, i)) } } var envs []string var argslice []string gostringnocopyç»„è£…æˆä¸€ä¸ªå­—ç¬¦ä¸²ã€‚ æ–‡ä»¶ä½ç½®ï¼šgo1.19.3/src/runtime/string.goã€‚ 564 565 566 567 568 569 570 //go:nosplit func gostringnocopy(str *byte) string { // findnullå¯»æ‰¾åˆ°nullç»“æŸè¯†åˆ«å­—ç¬¦ä¸²é•¿åº¦ ss := stringStruct{str: unsafe.Pointer(str), len: findnull(str)} s := *(*string)(unsafe.Pointer(\u0026amp;ss)) return s } goenvs() è§£æç¯å¢ƒå˜é‡ã€‚ æ–‡ä»¶ä½ç½®ï¼šgo1.19.3/src/runtime/os_linux.goã€‚ 367 368 369 func goenvs() { goenvs_unix() } æ–‡ä»¶ä½ç½®ï¼šgo1.19.3/src/runtime/runtime1.goã€‚ 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 func goenvs_unix() { // TODO(austin): ppc64 in dynamic linking mode doesn\u0026#39;t // guarantee env[] will immediately follow argv. Might cause // problems. n := int32(0) // è·³è¿‡argv + NULLï¼Œåˆ°envpï¼Œè®¡ç®—envpçš„é•¿åº¦ã€‚ // argv_index å‚è€ƒ7.1.2 for argv_index(argv, argc+1+n) != nil { n++ } envs = make([]string, n) // ç”³è¯·né•¿åº¦çš„å†…å­˜ for i := int32(0); i \u0026lt; n; i++ { envs[i] = gostring(argv_index(argv, argc+1+i)) } } æ–‡ä»¶ä½ç½®ï¼šgo1.19.3/src/runtime/string.goã€‚ 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 // This is exported via linkname to assembly in syscall (for Plan9). // //go:linkname gostring func gostring(p *byte) string { l := findnull(p) // æ‰¾å‡ºå­—ç¬¦ä¸²é•¿åº¦ if l == 0 { return \u0026#34;\u0026#34; } // rawstring å‡½æ•°åœ¨å­—ç¬¦ä¸²åŒ…ä¸­å·²ç»ä»‹ç»è¿‡ // åˆ†ä¼šçš„så’Œbåˆ†åˆ«å…±ç”¨ä¸€ä¸ªåº•å±‚ï¼Œè¿™æ ·æ“ä½œbåˆ‡ç‰‡sä¹Ÿä¼šè·Ÿç€æ”¹å˜ s, b := rawstring(l) // s string, b []byte // æ‹·è´æ•°æ®åˆ°bä¸­ä»pæ‹·è´é•¿åº¦lå­—èŠ‚ã€‚ memmove(unsafe.Pointer(\u0026amp;b[0]), unsafe.Pointer(p), uintptr(l)) return s } åˆå§‹åŒ–allp ä¸‹é¢åˆ†æprocresize()å‡½æ•°ã€‚ è€ƒè™‘åˆ°åˆå§‹åŒ–å®Œæˆä¹‹åç”¨æˆ·ä»£ç è¿˜å¯ä»¥é€šè¿‡GOMAXPROCS()å‡½æ•°è°ƒç”¨å®ƒé‡æ–°åˆ›å»ºå’Œåˆå§‹åŒ–pç»“æ„ä½“å¯¹è±¡ã€‚ è€Œåœ¨è¿è¡Œè¿‡ç¨‹ä¸­å†åŠ¨æ€çš„è°ƒæ•´pç‰µæ¶‰åˆ°çš„é—®é¢˜æ¯”è¾ƒå¤šï¼Œæ‰€ä»¥è¿™ä¸ªå‡½æ•°çš„å¤„ç†æ¯”è¾ƒå¤æ‚ã€‚ procresize() æ›´æ”¹å¤„ç†å™¨æ•°é‡ã€‚sched.lockå¿…é¡»è¢«æŒæœ‰å¹¶ä¸”å¿…é¡»æ˜¯åœ¨STWæœŸé—´ã€‚ gcworkbufsä¸èƒ½è¢«GCæˆ–å†™å±éšœä»£ç ä¿®æ”¹ï¼Œå› æ­¤å¦‚æœPæ•°å®é™…å‘ç”Ÿå˜åŒ–ï¼ŒGCå¿…é¡»ä¸è¿è¡Œã€‚ è¿”å›å…·æœ‰æœ¬åœ°å·¥ä½œçš„påˆ—è¡¨ï¼Œå®ƒä»¬éœ€è¦ç”±è°ƒç”¨è€…è°ƒåº¦ã€‚ è¯¥å‡½æ•°ä¼šåœ¨ã€ç¨‹åºåˆå§‹åŒ–ã€‘æˆ–ã€startTheWorldWithSemaã€‘å‡½æ•°ä¸­è¢«è°ƒç”¨ã€‚ å‡½æ•°æµç¨‹ï¼š ä½¿ç”¨make([]*p, nprocs)åˆå§‹åŒ–å…¨å±€å˜é‡allpï¼Œå³allp = make([]*p, nprocs)ã€‚ å¾ªç¯åˆ›å»ºå¹¶åˆå§‹åŒ–nprocsä¸ªpç»“æ„ä½“å¯¹è±¡å¹¶ä¾æ¬¡ä¿å­˜åœ¨allpåˆ‡ç‰‡ä¹‹ä¸­ã€‚ æŠŠm0å’Œallp[0]ç»‘å®šåœ¨ä¸€èµ·ï¼Œå³ã€m0.p = allp[0], allp[0].m = m0ã€‘ã€‚ æŠŠé™¤äº†allp[0]ä¹‹å¤–çš„æ‰€æœ‰pæ”¾å…¥åˆ°å…¨å±€å˜é‡schedçš„pidleç©ºé—²é˜Ÿåˆ—ä¹‹ä¸­ã€‚ æ–‡ä»¶ä½ç½®ï¼šgo1.19.3/src/runtime/proc.goã€‚ 4793 4794 4795 4796 4797 4798 4799 4800 4801 4802 4803 4804 4805 4806 4807 4808 4809 4810 4811 4812 4813 4814 4815 4816 4817 4818 4819 4820 4821 4822 4823 4824 4825 4826 4827 4828 4829 4830 4831 4832 4833 4834 4835 4836 4837 4838 4839 4840 4841 4842 4843 4844 4845 4846 4847 4848 4849 4850 4851 4852 4853 4854 4855 4856 4857 4858 4859 4860 4861 4862 4863 4864 4865 4866 4867 4868 4869 4870 4871 4872 4873 4874 4875 4876 4877 4878 4879 4880 4881 4882 4883 4884 4885 4886 4887 4888 4889 4890 4891 4892 4893 4894 4895 4896 4897 4898 4899 4900 4901 4902 4903 4904 4905 4906 4907 4908 4909 4910 4911 4912 4913 4914 4915 4916 4917 4918 4919 4920 4921 4922 4923 4924 4925 4926 4927 4928 4929 4930 4931 4932 4933 4934 4935 4936 4937 4938 4939 4940 4941 4942 4943 4944 4945 4946 4947 4948 4949 4950 4951 4952 4953 4954 4955 4956 4957 4958 4959 4960 4961 4962 4963 4964 4965 4966 4967 4968 4969 4970 4971 4972 4973 4974 4975 4976 4977 4978 4979 4980 4981 4982 4983 4984 // Change number of processors. // // sched.lock must be held, and the world must be stopped. // // gcworkbufs must not be being modified by either the GC or the write barrier // code, so the GC must not be running if the number of Ps actually changes. // // Returns list of Ps with local work, they need to be scheduled by the caller. func procresize(nprocs int32) *p { // sched.lock é”å·²ç»è¢«æŒæœ‰ assertLockHeld(\u0026amp;sched.lock) // å¿…é¡»æ˜¯ STW æœŸé—´ assertWorldStopped() // ç³»ç»Ÿåˆå§‹åŒ–æ—¶ï¼Œgomaxprocs = 0 old := gomaxprocs // æ—§çš„æ•°é‡ï¼Œä¹Ÿå°±æ˜¯ä¸Šæ¬¡çš„æ•°é‡ // nprocs æœåŠ¡å™¨cpuæ ¸æ•°ï¼Œæˆ–ç”¨æˆ·é€šè¿‡GOMAXPROCSç¯å¢ƒå˜é‡æŒ‡å®šçš„æ•°é‡ if old \u0026lt; 0 || nprocs \u0026lt;= 0 { throw(\u0026#34;procresize: invalid arg\u0026#34;) } if trace.enabled { traceGomaxprocs(nprocs) } // update statistics now := nanotime() // å½“å‰æ—¶é—´ // sched.procresizetime æœ€åä¸€æ¬¡æ”¹å˜gomaxprocsçš„æ—¶é—´ if sched.procresizetime != 0 { // ä»å¤‡æ³¨ä¸­çœ‹å‡ºè¯¥å€¼æ˜¯procresizetimeå˜åŒ–çš„ç§¯åˆ†ï¼Œå› è¯¥ç”¨äºç»Ÿè®¡ç›¸å…³ // âˆ«gomaxprocs dt up to procresizetime sched.totaltime += int64(old) * (now - sched.procresizetime) } sched.procresizetime = now // ä»¥32ä¸ºä¸€ç»„ï¼Œåˆ†åˆ«å¤„ç†Pçš„æ ‡å¿—ä½ // idlepMaskï¼šè¡¨ç¤ºåœ¨_Pidleåˆ—è¡¨ä¸­çš„ä½æ©ç ï¼Œæ¯ä¸€ä¸ªPè¡¨ç¤ºä¸€ä½ï¼Œè®°å½•é‚£äº›På¤„ç†_Pidleï¼ˆç©ºé—²ï¼‰çŠ¶æ€ // timerpMaskï¼šè¡¨ç¤ºPåœ¨timerä¸Šçš„ä½æ©ç ï¼Œæ¯ä¸€ä¸ªPè¡¨ç¤ºä¸€ä½ï¼Œè®°å½•Pä¸timerç›¸å…³ï¼ˆ1è¡¨ç¤ºæœ‰timerï¼Œ0è¡¨ç¤ºæ²¡æœ‰timerï¼‰ // idlepMaskå’ŒtimerpMaskç”¨äºå¿«é€Ÿåˆ¤æ–­Pçš„çŠ¶æ€å’ŒPä¸Šæ˜¯å¦æœ‰timerã€‚ maskWords := (nprocs + 31) / 32 // int32 // Grow allp if necessary. // // å¦‚æœæœ‰å¿…è¦æ‰©å±•allpã€‚ if nprocs \u0026gt; int32(len(allp)) { // åˆå§‹åŒ–æ—¶ æˆ– Pçš„æ•°é‡æ‰©å¤§æ—¶ // Synchronize with retake, which could be running // concurrently since it doesn\u0026#39;t run on a P. lock(\u0026amp;allpLock)\t// è·å– mutex é” // å½“å‰ allp çš„å®¹é‡è¶³å¤Ÿæœ¬æ¬¡æ‰©å±•ã€‚å¤„ç†P if nprocs \u0026lt;= int32(cap(allp)) { allp = allp[:nprocs] } else { // ä»æ–°ç”³è¯·å†…å­˜å¹¶æ‹·è´ nallp := make([]*p, nprocs) // Copy everything up to allp\u0026#39;s cap so we // never lose old allocated Ps. copy(nallp, allp[:cap(allp)]) allp = nallp } // idlepMaskå’ŒtimerpMaskå¤„ç†ï¼Œå®¹é‡å¤Ÿï¼Œç›´æ¥ä½¿ç”¨ if maskWords \u0026lt;= int32(cap(idlepMask)) { idlepMask = idlepMask[:maskWords] timerpMask = timerpMask[:maskWords] } else { // å®¹é‡ä¸å¤Ÿï¼Œç”³è¯·å†…å­˜å¹¶æ¬è¿ // åˆ›å»ºä¸€ä¸ª []uint32ï¼Œæ¯ä¸€ä½åˆ†åˆ«ä»£è¡¨ä¸€ä¸ªP nidlepMask := make([]uint32, maskWords) // No need to copy beyond len, old Ps are irrelevant. copy(nidlepMask, idlepMask) idlepMask = nidlepMask ntimerpMask := make([]uint32, maskWords) copy(ntimerpMask, timerpMask) timerpMask = ntimerpMask } unlock(\u0026amp;allpLock) // mutex è§£é” } // initialize new P\u0026#39;s // // åˆå§‹åŒ–æ‰€æœ‰æ–°åˆ›å»ºçš„Pï¼Œä»oldå¤„å¼€å§‹å› æ­¤ä¹‹å‰çš„å·²ç»åˆå§‹åŒ–äº† for i := old; i \u0026lt; nprocs; i++ { pp := allp[i] if pp == nil { // å¯è§Pæ˜¯å †åˆ†é…çš„ pp = new(p) } pp.init(i) // åˆå§‹åŒ–å½“å‰P // åŸå­è®¾ç½® ã€allp[i] = ppã€‘ atomicstorep(unsafe.Pointer(\u0026amp;allp[i]), unsafe.Pointer(pp)) // ä¿å­˜allpä¸­å» } _g_ := getg() // g0 // å½“å‰mç»‘å®šäº†Pæ—¶ï¼Œåˆå§‹åŒ–æ—¶må¹¶æ²¡æœ‰ç»‘å®šPï¼Œ_g_.m.p == 0ã€‚ // _g_.m.p != 0 \u0026amp;\u0026amp; _g_.m.p.ptr().id \u0026lt; nprocs è¿™ç§æƒ…å†µæˆç«‹å‘ç”Ÿåœ¨ï¼š // å‘ç”Ÿæ‰©å®¹ æˆ– å‘ç”Ÿç¼©å®¹(å½“å‰På¹¶ä¸åœ¨è£å‰ªä¹‹å¤–) if _g_.m.p != 0 \u0026amp;\u0026amp; _g_.m.p.ptr().id \u0026lt; nprocs { // continue to use the current P // // ç»§ç»­ä½¿ç”¨å½“å‰Pï¼Œ_Prunning è¿è¡Œä¸­çŠ¶æ€ _g_.m.p.ptr().status = _Prunning _g_.m.p.ptr().mcache.prepareForSweep() // æ¸…ç† } else { // release the current P and acquire allp[0]. // // We must do this before destroying our current P // because p.destroy itself has write barriers, so we // need to do that from a valid P. if _g_.m.p != 0 { // è¿™ç§æƒ…å†µå‘ç”Ÿåœ¨Påœ¨ç¼©å®¹(å½“å‰På¹¶ä¸åœ¨è£å‰ªä¹‹å¤–) if trace.enabled { // Pretend that we were descheduled // and then scheduled again to keep // the trace sane. traceGoSched() traceProcStop(_g_.m.p.ptr()) } // å½“å‰Mç»‘å®šçš„pä¸å½“å‰Mè§£ç»‘ // å› ä¸º M ä¸ P ç›¸äº’ç»‘å®šçš„ï¼Œè¿™é‡Œè¦è§£ç»‘ _g_.m.p.ptr().m = 0 // p.m = 0 } // åˆå§‹åŒ–æ—¶ï¼Œä¼šèµ°è¿™é‡Œ // è§£ç»‘Mä¸På…³ç³» _g_.m.p = 0 // m.p = 0 // é€‰å–allp[0]ç»‘å®šå½“å‰å·¥ä½œçº¿ç¨‹ p := allp[0] p.m = 0 // _Pidle ç©ºé—²çŠ¶æ€ p.status = _Pidle // æ ‡è®°å½“å‰Pä¸ºç©ºé—²çŠ¶æ€ // è¯¥æ–¹æ³•è¦æ±‚På’ŒMéƒ½æ˜¯æ²¡æœ‰ç»‘å®šçš„ï¼Œå¹¶ä¸”Pä¸€å®šæ˜¯_PidleçŠ¶æ€ã€‚ // p.m = m; m.p = p; acquirep(p) // mä¸pç›¸äº’ç»‘å®šï¼Œå¹¶ä¿®æ”¹pçš„çŠ¶æ€ä¸ºè¿è¡Œä¸­ã€‚ if trace.enabled { traceGoStart() } } // g.m.p is now set, so we no longer need mcache0 for bootstrapping. // // g.m.p ç°åœ¨å·²ç»è®¾ç½®ï¼Œå› æ­¤æˆ‘ä»¬ä¸å†éœ€è¦ mcache0 æ¥è¿›è¡Œå¼•å¯¼ã€‚ // mcache0 åœ¨ p.init() å‡½æ•°ä¸­è¢«ä½¿ç”¨ mcache0 = nil // è¯¥å€¼åœ¨å‰é¢schedinit()å‡½æ•°ä¸­ï¼Œæ ˆç›¸å…³åˆå§‹åŒ–æ—¶è¢«è®¾ç½® // release resources from unused P\u0026#39;s // // ä»æœªä½¿ç”¨çš„ P é‡Šæ”¾èµ„æºï¼Œè¿™ç§æƒ…å†µå‘ç”Ÿåœ¨ç¼©å®¹Pæ—¶ for i := nprocs; i \u0026lt; old; i++ { p := allp[i] p.destroy() // å›æ”¶P // can\u0026#39;t free P itself because it can be referenced by an M in syscall // // ä¸èƒ½é‡Šæ”¾Pæœ¬èº«ï¼Œå› ä¸ºå®ƒå¯ä»¥è¢«ç³»ç»Ÿè°ƒç”¨ä¸­çš„Må¼•ç”¨ } // Trim allp. // è£å‰ª allpã€‚ if int32(len(allp)) != nprocs { lock(\u0026amp;allpLock) allp = allp[:nprocs] idlepMask = idlepMask[:maskWords] timerpMask = timerpMask[:maskWords] unlock(\u0026amp;allpLock) } var runnablePs *p // éå†æ‰€æœ‰Pï¼Œå¤„ç†Pçš„æœ¬åœ°é˜Ÿåˆ—ä¸­æœ‰goroutineçš„éœ€è¦ç»‘å®šMè¿è¡Œè¿™äº›goroutineã€‚ for i := nprocs - 1; i \u0026gt;= 0; i-- { p := allp[i] // è·³è¿‡å½“å‰Pï¼Œå½“å‰å·¥ä½œçº¿ç¨‹ç»‘å®šçš„Pæ­£åœ¨æ‰§è¡Œè¿™é‡Œçš„ä»£ç éœ€è¦è·³è¿‡ if _g_.m.p.ptr() == p { continue } p.status = _Pidle // çŠ¶æ€ä¿®æ”¹ä¸º _Pidle ç©ºé—² if runqempty(p) { // Pçš„runqæ˜¯ç©ºçš„æ—¶ pidleput(p, now) // æŠŠå½“å‰PæŒ‚åœ¨å…¨å±€schedç©ºé—²é“¾è¡¨ä¸­ } else { p.m.set(mget()) // pç»‘å®šm p.link.set(runnablePs) runnablePs = p } } // é‡ç½® stealOrderï¼Œè¯¥å€¼ç”¨äºéšæœºä»allpä¸­å·å–goroutineåˆå§‹æ¡ä»¶ stealOrder.reset(uint32(nprocs)) // åˆå§‹åŒ–Påé¢è¦ç”¨åˆ°å·å–çš„æ•°æ® // åŸå­ç»‘å®š gomaxprocs = nprocs var int32p *int32 = \u0026amp;gomaxprocs // make compiler check that gomaxprocs is an int32 atomic.Store((*uint32)(unsafe.Pointer(int32p)), uint32(nprocs)) // gomaxprocs = nprocs if old != nprocs { // Notify the limiter that the amount of procs has changed. gcCPULimiter.resetCapacity(now, nprocs) } // runnablePs != nil è¯´æ˜é™¤äº†å½“å‰På¤–çš„å…¶ä»–Pä¸­å­˜åœ¨goroutine return runnablePs } p.init() åˆå§‹åŒ–Pã€‚ æ–‡ä»¶ä½ç½®ï¼šgo1.19.3/src/runtime/proc.goã€‚ 4669 4670 4671 4672 4673 4674 4675 4676 4677 4678 4679 4680 4681 4682 4683 4684 4685 4686 4687 4688 4689 4690 4691 4692 4693 4694 4695 4696 4697 4698 4699 4700 4701 4702 4703 4704 4705 4706 4707 4708 4709 4710 4711 4712 // init initializes pp, which may be a freshly allocated p or a // previously destroyed p, and transitions it to status _Pgcstop. func (pp *p) init(id int32) { pp.id = id\t// åˆ†é…Pçš„idï¼Œè¯¥idæ˜¯å”¯ä¸€çš„ pp.status = _Pgcstop // è®¾ç½®PçŠ¶æ€ _Pgcstop GCåœæ­¢çŠ¶æ€ pp.sudogcache = pp.sudogbuf[:0] // Pä¸Šsudogç¼“å­˜ pp.deferpool = pp.deferpoolbuf[:0] // Pä¸Šdeferæ±  pp.wbBuf.reset() // Pçš„wbBufé‡ç½®ï¼Œè¯¥å­—æ®µä¸å†™å±éšœç›¸å…³ // pp.mcache æ²¡æœ‰åˆå§‹åŒ– if pp.mcache == nil { if id == 0 { // ç¨‹åºåˆšåˆå§‹åŒ–æ—¶ï¼Œmcache0åœ¨schedinit()ä¸­çš„mallocinit()å‡½æ•°ä¸­è¢«åˆ›å»º if mcache0 == nil { throw(\u0026#34;missing mcache?\u0026#34;) } // Use the bootstrap mcache0. Only one P will get // mcache0: the one with ID 0. pp.mcache = mcache0 } else { // ä½¿ç”¨ allocmcache() åˆ†é…ç¼“å­˜ pp.mcache = allocmcache() } } if raceenabled \u0026amp;\u0026amp; pp.raceprocctx == 0 { if id == 0 { pp.raceprocctx = raceprocctx0 raceprocctx0 = 0 // bootstrap } else { pp.raceprocctx = raceproccreate() } } lockInit(\u0026amp;pp.timersLock, lockRankTimers) // åˆå§‹åŒ– P.timersLock é” // This P may get timers when it starts running. Set the mask here // since the P may not go through pidleget (notably P 0 on startup). // // è¿™ä¸ªPå¼€å§‹è¿è¡Œæ—¶å¯èƒ½ä¼šæœ‰timesã€‚åœ¨è¿™é‡Œè®¾ç½®å¯èƒ½ä¸ä¼šç»è¿‡pidleget(ç‰¹åˆ«æ˜¯åœ¨å¯åŠ¨æ—¶P 0)ã€‚ timerpMask.set(id) // Similarly, we may not go through pidleget before this P starts // running if it is P 0 on startup. // // ç±»ä¼¼çš„ï¼Œå¦‚æœè¿™ä¸ªPæ˜¯åœ¨å¯åŠ¨çš„æ˜¯P 0ï¼Œæˆ‘ä»¬å¯èƒ½ä¸ä¼šåœ¨è¿™ä¸ªPå¼€å§‹è¿è¡Œä¹‹å‰ç»å†pidlegetã€‚ idlepMask.clear(id) } acquirep() Må’ŒPç›¸äº’ç»‘å®šã€‚m.p = pã€p.m = mã€‚ æ–‡ä»¶ä½ç½®ï¼šgo1.19.3/src/runtime/proc.goã€‚ 4938 4939 4940 4941 4942 4943 4944 4945 4946 4947 4948 4949 4950 4951 4952 4953 4954 4955 4956 4957 4958 4959 4960 4961 // Associate p and the current m. // // This function is allowed to have write barriers even if the caller // isn\u0026#39;t because it immediately acquires _p_. // //go:yeswritebarrierrec func acquirep(_p_ *p) { // Do the part that isn\u0026#39;t allowed to have write barriers. // // ä¸å…è®¸æœ‰å†™å…¥éšœç¢çš„éƒ¨åˆ†ã€‚ wirep(_p_) // mä¸pç›¸äº’ç»‘å®šï¼Œå¹¶ä¿®æ”¹pçš„çŠ¶æ€ä¸ºè¿è¡Œä¸­ã€‚ // Have p; write barriers now allowed. // Perform deferred mcache flush before this P can allocate // from a potentially stale mcache. // // åœ¨è¿™ä¸ªPå¯ä»¥ä»å¯èƒ½è¿‡æœŸçš„mcacheè¿›è¡Œåˆ†é…ä¹‹å‰æ‰§è¡Œå»¶è¿Ÿçš„mcacheåˆ·å†™ã€‚ _p_.mcache.prepareForSweep() // GCç›¸å…³ if trace.enabled { traceProcStart() } } wirep() wirepæ˜¯acquirep çš„ç¬¬ä¸€æ­¥ï¼Œå®ƒå®é™…ä¸Šå°†å½“å‰Må…³è”åˆ° _p_ã€‚ è¿™é‡Œä¸å…è®¸æ ˆæ£€æŸ¥ï¼Œä»¥åŠå†™å±éšœç›¸å…³ä»£ç ï¼Œå› ä¸ºMè¿˜æ²¡æœ‰ç»‘å®šPã€‚ mä¸pç›¸äº’ç»‘å®šï¼Œå¹¶ä¿®æ”¹pçš„çŠ¶æ€ä¸ºè¿è¡Œä¸­ã€‚ æ–‡ä»¶ä½ç½®ï¼šgo1.19.3/src/runtime/proc.goã€‚ 4959 4960 4961 4962 4963 4964 4965 4966 4967 4968 4969 4970 4971 4972 4973 4974 4975 4976 4977 4978 4979 4980 4981 4982 4983 4984 4985 4986 4987 // wirep is the first step of acquirep, which actually associates the // current M to _p_. This is broken out so we can disallow write // barriers for this part, since we don\u0026#39;t yet have a P. // //go:nowritebarrierrec //go:nosplit func wirep(_p_ *p) { // åœ¨å½“å‰è¿™é‡Œåªèƒ½æ˜¯g0ï¼Œä½†æ˜¯å…¶ä»–åœ°æ–¹å¯èƒ½æ˜¯g _g_ := getg() // g0 // æ­¤æ—¶Mä¸€å®šæ˜¯æ²¡æœ‰ç»‘å®šPçš„ã€‚ if _g_.m.p != 0 { throw(\u0026#34;wirep: already in go\u0026#34;) } // æ­¤æ—¶pä¸€å®šæ²¡æœ‰ç»‘å®šMï¼Œå¹¶ä¸”Pä¸€å®šæ˜¯_PidleçŠ¶æ€ï¼ˆç©ºé—²ï¼‰ if _p_.m != 0 || _p_.status != _Pidle { id := int64(0) if _p_.m != 0 { id = _p_.m.ptr().id } print(\u0026#34;wirep: p-\u0026gt;m=\u0026#34;, _p_.m, \u0026#34;(\u0026#34;, id, \u0026#34;) p-\u0026gt;status=\u0026#34;, _p_.status, \u0026#34;\\n\u0026#34;) throw(\u0026#34;wirep: invalid p state\u0026#34;) } // Mä¸Pç›¸äº’ç»‘å®šï¼Œå¹¶è®¾ç½®Pçš„çŠ¶æ€ä¸ºè¿è¡Œä¸­ _g_.m.p.set(_p_) // m.p = _p_ _p_.m.set(_g_.m) // _p_.m = m // _Prunning è¿è¡Œä¸­çŠ¶æ€ _p_.status = _Prunning // ä¿®æ”¹å½“å‰Pä¸ºè¿è¡ŒçŠ¶æ€ } p.destroy() destroyé‡Šæ”¾ä¸ppç›¸å…³çš„æ‰€æœ‰èµ„æºï¼Œå¹¶å°†å…¶è½¬æ¢ä¸ºçŠ¶æ€_Pdeadã€‚ sched.lockå¿…é¡»è¢«æŒæœ‰å¹¶ä¸”STWã€‚ è¯¥å‡½æ•°å¤„ç†Pä¸­çš„goroutineï¼Œä»¥åŠè¿ç§»ppä¸Šæ‰€æœ‰çš„timerï¼Œä»¥åŠå†™å±éšœç›¸å…³å†…å­˜é‡Šæ”¾ç­‰ã€‚ æ–‡ä»¶ä½ç½®ï¼šgo1.19.3/src/runtime/proc.goã€‚ 4707 4708 4709 4710 4711 4712 4713 4714 4715 4716 4717 4718 4719 4720 4721 4722 4723 4724 4725 4726 4727 4728 4729 4730 4731 4732 4733 4734 4735 4736 4737 4738 4739 4740 4741 4742 4743 4744 4745 4746 4747 4748 4749 4750 4751 4752 4753 4754 4755 4756 4757 4758 4759 4760 4761 4762 4763 4764 4765 4766 4767 4768 4769 4770 4771 4772 4773 4774 4775 4776 4777 4778 4779 4780 4781 4782 4783 4784 4785 4786 4787 4788 4789 4790 4791 4792 4793 4794 4795 4796 4797 4798 4799 4800 4801 4802 4803 4804 4805 4806 4807 4808 // destroy releases all of the resources associated with pp and // transitions it to status _Pdead. // // sched.lock must be held and the world must be stopped. func (pp *p) destroy() { assertLockHeld(\u0026amp;sched.lock) assertWorldStopped() // Move all runnable goroutines to the global queue // // å°†å½“å‰Pçš„æ‰€æœ‰å¯è¿è¡Œçš„goroutinesç§»åŠ¨åˆ°å…¨å±€é˜Ÿåˆ— for pp.runqhead != pp.runqtail { // Pop from tail of local queue pp.runqtail-- gp := pp.runq[pp.runqtail%uint32(len(pp.runq))].ptr() // Push onto head of global queue globrunqputhead(gp) // åŠ å…¥åˆ°å…¨å±€é˜Ÿåˆ—æ± ä¸­ } // pp.runnext ä¸Šå­˜åœ¨ goroutineï¼ŒåŠ å…¥åˆ°å…¨å±€æ±  if pp.runnext != 0 { globrunqputhead(pp.runnext.ptr()) pp.runnext = 0 } // P ä¸­è¿˜æœ‰timerã€‚ if len(pp.timers) \u0026gt; 0 { // å½“å‰å·¥ä½œçº¿ç¨‹ç»‘å®šçš„P plocal := getg().m.p.ptr() // The world is stopped, but we acquire timersLock to // protect against sysmon calling timeSleepUntil. // This is the only case where we hold the timersLock of // more than one P, so there are no deadlock concerns. // // STWäº†ï¼Œä½†æ˜¯æˆ‘ä»¬è·å¾—äº†timersLockæ¥é˜²æ­¢sysmonè°ƒç”¨timeSleepUntil // è¿™æ˜¯æˆ‘ä»¬æŒæœ‰ä¸æ­¢ä¸€ä¸ªPçš„å®šæ—¶å™¨é”çš„å”¯ä¸€æƒ…å†µï¼Œå› æ­¤ä¸å­˜åœ¨æ­»é”é—®é¢˜ã€‚ lock(\u0026amp;plocal.timersLock) // plocal lock(\u0026amp;pp.timersLock) // pp // æŠŠpp.timersä¸­æ‰€æœ‰æœ‰æ•ˆçš„timeré‡æ–°æ·»åŠ åˆ°plocal.timersä¸­ // è¿™é‡ŒæŠŠéœ€è¦åˆ é™¤çš„ppä¸Šçš„æ‰€æœ‰timerè½¬ç§»åˆ°å½“å‰å·¥ä½œçº¿ç¨‹ç»‘å®šçš„Pä¸Šé¢ moveTimers(plocal, pp.timers) pp.timers = nil // æƒ…å†µ pp.timersï¼Œå› ä¸ºtimerså·²ç»è¿ç§»åˆ°äº†å½“å‰å·¥ä½œçº¿ç¨‹çš„Päº†ã€‚ // numTimersï¼šè®°å½•çš„æ˜¯å †ä¸­ timer çš„æ€»æ•°ï¼Œåº”è¯¥ä¸ timers åˆ‡ç‰‡çš„é•¿åº¦ä¸€è‡´ã€‚ pp.numTimers = 0 // deletedTimersï¼šè®°å½•çš„æ˜¯å †ä¸­å·²åˆ é™¤ä½†è¿˜æœªè¢«ç§»é™¤çš„ timer çš„æ€»æ•°ã€‚ pp.deletedTimers = 0 // timer0Whenï¼šè¡¨ç¤ºä½äºæœ€å°å †å †é¡¶çš„ timer çš„è§¦å‘æ—¶é—´ï¼Œä¹Ÿå°±æ˜¯èµ‹å€¼å…¶ when å­—æ®µã€‚ atomic.Store64(\u0026amp;pp.timer0When, 0) // pp.timer0When = 0 unlock(\u0026amp;pp.timersLock) unlock(\u0026amp;plocal.timersLock) } // Flush p\u0026#39;s write barrier buffer. // // åˆ·æ–°pçš„å†™å±éšœç¼“å†²åŒºã€‚å†™å±éšœç›¸å…³ if gcphase != _GCoff { wbBufFlush1(pp) pp.gcw.dispose() } for i := range pp.sudogbuf { pp.sudogbuf[i] = nil } pp.sudogcache = pp.sudogbuf[:0] for j := range pp.deferpoolbuf { pp.deferpoolbuf[j] = nil } pp.deferpool = pp.deferpoolbuf[:0] // åˆ‡æ¢åˆ°g0æ ˆå¤„ç†mspancache systemstack(func() { // ç›¸å…³å†…å­˜é‡Šæ”¾ for i := 0; i \u0026lt; pp.mspancache.len; i++ { // Safe to call since the world is stopped. mheap_.spanalloc.free(unsafe.Pointer(pp.mspancache.buf[i])) } pp.mspancache.len = 0 lock(\u0026amp;mheap_.lock) pp.pcache.flush(\u0026amp;mheap_.pages) unlock(\u0026amp;mheap_.lock) }) freemcache(pp.mcache) // é‡Šæ”¾å†…å­˜ pp.mcache = nil gfpurge(pp) // å›æ”¶P traceProcFree(pp) if raceenabled { if pp.timerRaceCtx != 0 { // The race detector code uses a callback to fetch // the proc context, so arrange for that callback // to see the right thing. // This hack only works because we are the only // thread running. mp := getg().m phold := mp.p.ptr() mp.p.set(pp) racectxend(pp.timerRaceCtx) pp.timerRaceCtx = 0 mp.p.set(phold) } raceprocdestroy(pp.raceprocctx) pp.raceprocctx = 0 } pp.gcAssistTime = 0 pp.status = _Pdead // ä¿®æ”¹PçŠ¶æ€ä¸ºç©ºé—² } pidleput() å‚æ•°ï¼š _p_ *pï¼šå½“å‰æ“ä½œçš„pï¼Œè¯¥pçš„æœ¬åœ°é˜Ÿåˆ—åº”è¯¥æ˜¯ç©ºçš„ã€‚ now int64ï¼šå½“å‰æ—¶é—´ã€‚ æŠŠå½“_p_æŒ‚åœ¨å…¨å±€schedç©ºé—²é“¾è¡¨ä¸­ã€‚ æ–‡ä»¶ä½ç½®ï¼šgo1.19.3/src/runtime/proc.goã€‚ 5696 5697 5698 5699 5700 5701 5702 5703 5704 5705 5706 5707 5708 5709 5710 5711 5712 5713 5714 5715 5716 5717 5718 5719 5720 5721 5722 5723 5724 5725 5726 5727 5728 5729 5730 // pidleput puts p on the _Pidle list. now must be a relatively recent call // to nanotime or zero. Returns now or the current time if now was zero. // // This releases ownership of p. Once sched.lock is released it is no longer // safe to use p. // // sched.lock must be held. // // May run during STW, so write barriers are not allowed. // //go:nowritebarrierrec func pidleput(_p_ *p, now int64) int64 { // è°ƒç”¨è¯¥å‡½æ•°æ—¶ sched.lock å¿…é¡»è¢«æŒæœ‰ assertLockHeld(\u0026amp;sched.lock) // å½“å‰På‡†å¤‡æ”¾å…¥ç©ºé—²é“¾è¡¨ï¼Œå› æ­¤runqä¸­ä¸èƒ½æœ‰goroutine if !runqempty(_p_) { throw(\u0026#34;pidleput: P has non-empty run queue\u0026#34;) } if now == 0 { now = nanotime() } // æ›´æ–°TimerPMask updateTimerPMask(_p_) // clear if there are no timers. idlepMask.set(_p_.id) // æ ‡è®°_p_æ˜¯ç©ºé—²çš„ // æ”¾å…¥å…¨å±€é“¾è¡¨ä¸­ _p_.link = sched.pidle sched.pidle.set(_p_) // sched.pidle = _p_ // ç©ºé—²Pæ•°é‡åŠ ä¸€ atomic.Xadd(\u0026amp;sched.npidle, 1) // sched.npidle if !_p_.limiterEvent.start(limiterEventIdle, now) { throw(\u0026#34;must be able to track idle limiter event\u0026#34;) } return now } main goroutine schedinitå®Œæˆè°ƒåº¦ç³»ç»Ÿåˆå§‹åŒ–åã€‚ è¿”å›åˆ°rt0_goå‡½æ•°ä¸­å¼€å§‹è°ƒç”¨newproc()åˆ›å»ºä¸€ä¸ªæ–°çš„goroutineç”¨äºæ‰§è¡ŒmainPCæ‰€å¯¹åº”çš„runtimeÂ·mainå‡½æ•°ã€‚ æ–‡ä»¶ä½ç½®ï¼šgo1.19.3/src/runtime/asm_amd64.sã€‚ ä»¥ä¸‹runtimeÂ·newprocã€runtimeÂ·mstartå°†åœ¨åç»­æ–‡ç« ä¸­ä»‹ç»ã€‚ 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 # create a new goroutine to start program # # åˆ›å»ºä¸€ä¸ªæ–°çš„goroutineæ¥å¯åŠ¨ç¨‹åºã€‚ # AX = runtimeÂ·main # runtimeÂ·main æ˜¯ä¸€ä¸ªé—­åŒ…ï¼Œ\u0026amp;funcval{fn:runtime.main} MOVQ $runtimeÂ·mainPC(SB), AX # entry # å°†AXçš„å€¼å‹å…¥æ ˆä¸­ PUSHQ AX # AXçš„å€¼ä½œä¸ºruntimeÂ·newproc()å‡½æ•°çš„å‚æ•° CALL runtimeÂ·newproc(SB) # åˆ›å»ºmain goroutine POPQ AX # start this M CALL runtimeÂ·mstart(SB) # ä¸»çº¿ç¨‹è¿›å…¥å¾ªç¯è°ƒåº¦ï¼Œè¿è¡Œåˆšåˆšåˆ›å»ºçš„goroutine # ä¸Šé¢çš„mstartæ°¸è¿œä¸åº”è¯¥è¿”å›çš„ï¼Œå¦‚æœè¿”å›äº†ï¼Œä¸€å®šæ˜¯ä»£ç é€»è¾‘æœ‰é—®é¢˜ï¼Œç›´æ¥abort CALL runtimeÂ·abort(SB)\t# mstart should never return RET # å‰é¢æ²¡æœ‰è·å–åˆ°CPUç›¸å…³ä¿¡æ¯æ—¶ä¼šèµ°è¿™é‡Œçš„å¼‚å¸¸ bad_cpu: # show that the program requires a certain microarchitecture level. MOVQ $2, 0(SP) MOVQ $bad_cpu_msg\u0026lt;\u0026gt;(SB), AX MOVQ AX, 8(SP) MOVQ $84, 16(SP) CALL runtimeÂ·write(SB) MOVQ $1, 0(SP) CALL runtimeÂ·exit(SB) CALL runtimeÂ·abort(SB) RET # Prevent dead-code elimination of debugCallV2, which is # intended to be called by debuggers. MOVQ $runtimeÂ·debugCallV2\u0026lt;ABIInternal\u0026gt;(SB), AX RET å…¶ä»–å†…å®¹ argcå’Œargv åœ¨è®¡ç®—æœºç¼–ç¨‹ä¸­ï¼Œé€šå¸¸ä½¿ç”¨å‘½ä»¤è¡Œå‚æ•°æ¥å‘ç¨‹åºä¼ é€’é¢å¤–çš„ä¿¡æ¯ã€‚ Cè¯­è¨€ä¸­çš„mainå‡½æ•°æ¥å—ä¸¤ä¸ªå‚æ•°ï¼Œåˆ†åˆ«æ˜¯argcå’Œargvã€‚ å…¶ä¸­argcè¡¨ç¤ºå‘½ä»¤è¡Œå‚æ•°çš„æ•°é‡ï¼Œè€Œargvæ˜¯ä¸€ä¸ªæŒ‡å‘å‚æ•°å­—ç¬¦ä¸²æ•°ç»„çš„æŒ‡é’ˆï¼Œå…¶ä¸­æ¯ä¸ªå…ƒç´ éƒ½åŒ…å«ä¸€ä¸ªå‘½ä»¤è¡Œå‚æ•°ã€‚ å¦‚æœä½ åœ¨å‘½ä»¤è¡Œä¸­æ‰§è¡Œä»¥ä¸‹å‘½ä»¤ï¼š$ my_program arg1 arg2 arg3 åˆ™argcçš„å€¼å°†æ˜¯4ï¼Œå…¶ä¸­åŒ…æ‹¬ç¨‹åºåmy_programå’Œ3ä¸ªå‚æ•°arg1ã€arg2å’Œarg3ã€‚è€ŒargvæŒ‡å‘ä¸€ä¸ªå­—ç¬¦ä¸²æ•°ç»„ï¼Œå…¶å†…å®¹å¦‚ä¸‹ï¼š argv[0] = \u0026#34;my_program\u0026#34; argv[1] = \u0026#34;arg1\u0026#34; argv[2] = \u0026#34;arg2\u0026#34; argv[3] = \u0026#34;arg3\u0026#34; æ¯”å¦‚åœ¨Goè¯­è¨€ä¸­ï¼Œargcå’Œargvä½¿ç”¨ï¼š 1 2 3 4 5 6 7 8 9 10 11 12 13 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;os\u0026#34; ) func main() { args := os.Args // []string fmt.Printf(\u0026#34;Pathï¼š%s\\n\u0026#34;, args[0]) fmt.Printf(\u0026#34;Argsï¼š%#v\\n\u0026#34;, args[1:]) } å½“æˆ‘ä»¬æ‰§è¡Œgo runå‘½ä»¤è¿è¡Œä¸Šé¢çš„ç¨‹åºå¹¶ä¼ é€’ä¸€äº›å‚æ•°æ—¶ï¼Œå°†ä¼šå¾—åˆ°ç±»ä¼¼ä»¥ä¸‹çš„è¾“å‡ºï¼š [root@localhost hello1]# go run tt12.go foo bar baz js Pathï¼š/tmp/go-build1239766326/b001/exe/tt12 Argsï¼š[]string{\u0026#34;foo\u0026#34;, \u0026#34;bar\u0026#34;, \u0026#34;baz\u0026#34;, \u0026#34;js\u0026#34;} ","permalink":"https://heliu.site/posts/golang/goroutine/flow/","summary":"Golang ç¨‹åºåŠ è½½åçš„æ‰§è¡Œæµç¨‹ä»‹ç»ã€‚","title":"Go æ‰§è¡Œæµç¨‹"},{"content":" goå…³é”®å­—æµç¨‹ï¼š newproc()å‡½æ•°æ˜¯goå…³é”®å­—åˆ›å»ºgoroutineçš„åˆå§‹åŒ–å‡½æ•°ã€‚ ä¹Ÿæ˜¯åˆ›å»ºç¬¬ä¸€ä¸ªgoroutine(runtime.main)çš„å‡½æ•°ã€‚ newproc() è¯¥å‡½æ•°æ˜¯æ•´ä¸ªgoå…³é”®å­—çš„æ‰§è¡Œæµç¨‹ä»£ç ï¼Œå…¶ä¸­åŒ…æ‹¬newgçš„åˆ›å»ºï¼Œnewgæ”¾å…¥Pä¸­ï¼Œå”¤é†’å…¶ä»–Pèµ·æ¥å·¥ä½œç­‰ã€‚ åˆ›å»ºä¸€ä¸ªæ–°çš„goroutineè¿è¡Œfnã€‚æŠŠå®ƒæ”¾åˆ°ç­‰å¾…è¿è¡Œçš„gé˜Ÿåˆ—ä¸­ã€‚ç¼–è¯‘å™¨å°†goè¯­å¥è½¬æ¢ä¸ºå¯¹thisçš„è°ƒç”¨ã€‚ å…³äºå‚æ•°çš„è¯´æ˜ï¼š fn *funcvalï¼šfnæ˜¯ä¸€ä¸ªé—­åŒ…å˜é‡ã€‚çœ‹è¿‡ä¹‹å‰ç‰ˆæœ¬çš„è¯¥å‡½æ•°å°±ä¼šå‘ç°go A(1,2)è¿™ç§å½¢å¼çš„å‚æ•°æ€ä¹ˆå¤„ç†çš„ï¼Ÿ åœ¨ä¹‹å‰ç‰ˆæœ¬ä¸­è¯¥å‡½æ•°çš„å½¢å¼å¦‚è¿™func newproc(siz int32, fn *funcval)ï¼Œå¤šäº†ä¸€ä¸ªsizå‚æ•°è¡¨ç¤ºå‚æ•°å…±å å¤šå°‘å­—èŠ‚ã€‚ åœ¨ä¹‹å‰çš„ç‰ˆæœ¬ä¸­Goçš„ä¼ å‚æ˜¯å…¥æ ˆå½¢å¼çš„ï¼Œåœ¨1.18ä¸­å·²ç»æ”¹æˆäº†å¯„å­˜å™¨ä¼ å‚å½¢å¼ã€‚ åœ¨1.18ä¸­åœ¨Aå‡½æ•°çš„å¤–å±‚åœ¨å°è£…äº†ä¸€å±‚é—­åŒ…æ‰€ä»¥å°‘ä¼ ä¸€ä¸ªå‚æ•°ï¼Œgo A(1,2) -\u0026gt; go func() {A(1,2)}ä½œä¸ºå‚æ•°ä¼ å…¥newprocå‡½æ•°ã€‚ fn *funcvalï¼šè¿™é‡Œçš„å‡½æ•°åŸå‹æ˜¯ func()ï¼Œæ²¡æœ‰å‚æ•°å’Œè¿”å›å€¼ã€‚ æ–‡ä»¶ä½ç½®ï¼šgo1.19.3/src/runtime/proc.goã€‚ 4091 4092 4093 4094 4095 4096 4097 4098 4099 4100 4101 4102 4103 4104 4105 4106 4107 4108 4109 4110 4111 4112 4113 4114 4115 4116 4117 4118 4119 4120 4121 4122 4123 4124 4125 4126 4127 4128 // Create a new g running fn. // Put it on the queue of g\u0026#39;s waiting to run. // The compiler turns a go statement into a call to this. func newproc(fn *funcval) { // getgå‡½æ•°åœ¨æºä»£ç ä¸­æ²¡æœ‰å¯¹åº”çš„å®šä¹‰ï¼Œç”±ç¼–è¯‘å™¨æ’å…¥ç±»ä¼¼ä¸‹é¢ä¸¤è¡Œä»£ç  // get_tls(CX); # è·å–fså¯„å­˜å™¨åœ°å€ï¼Œæ”¾å…¥å¯„å­˜å™¨CXä¸­ï¼Œfsåœ°å€è¢«è®¾ç½®æˆ\u0026amp;m.tls[1]å¤„åœ°å€ // MOVQ g(CX), BX; # BXå­˜å™¨é‡Œé¢ç°åœ¨æ”¾çš„æ˜¯å½“å‰gçš„åœ°å€ï¼Œg(CX)è·å–fs-8ä½ç½®å­˜å‚¨æ•°æ®,ä¹Ÿå°±æ˜¯å½“å‰æ‰§è¡Œçš„gï¼Œä¹Ÿå°±æ˜¯m.tls[0]åœ°å€ gp := getg() // è·å–å½“å‰è¿è¡Œçš„gï¼Œm.tls[0]å­˜å‚¨çš„å°±æ˜¯å½“å‰å·¥ä½œçº¿ç¨‹Mç»‘å®šçš„gï¼Œä¹Ÿå°±æ˜¯å½“å‰æ­£åœ¨è¿è¡Œçš„g // getcallerpc()è¿”å›ä¸€ä¸ªåœ°å€ï¼Œä¹Ÿå°±æ˜¯è°ƒç”¨newprocæ—¶ç”±callæŒ‡ä»¤å‹æ ˆçš„å‡½æ•°è¿”å›åœ°å€ // å¯¹äºæˆ‘ä»¬ç°åœ¨è¿™ä¸ªåœºæ™¯æ¥è¯´ï¼Œpcå°±æ˜¯CALL runtimeÂ·newproc(SB)æŒ‡ä»¤åé¢çš„POPQ AXè¿™æ¡æŒ‡ä»¤çš„åœ°å€ // ä¸»è¦ç”¨äºæ–°åˆ›å»ºçš„ goroutine è®°å½•è‡ªå·±æ˜¯åœ¨å“ªé‡Œè¢«åˆ›å»ºçš„ã€‚ pc := getcallerpc() // systemstackçš„ä½œç”¨æ˜¯åˆ‡æ¢åˆ°g0æ ˆæ‰§è¡Œä½œä¸ºå‚æ•°çš„å‡½æ•° // æˆ‘ä»¬è¿™ä¸ªåœºæ™¯ç°åœ¨æœ¬èº«å°±åœ¨g0æ ˆï¼Œå› æ­¤ä»€ä¹ˆä¹Ÿä¸åšï¼Œç›´æ¥è°ƒç”¨ä½œä¸ºå‚æ•°çš„å‡½æ•° systemstack(func() { // åˆ›å»ºä¸€ä¸ªæ–°çš„goroutineå¹¶åˆå§‹åŒ–ï¼Œè®¾ç½®å¥½æ ˆå¤§å°æ‰§è¡Œåœ°å€å’Œæ‰§è¡Œå®Œè¿”å›åœ°å€ // è¯¥é—­åŒ…å‡½æ•°æ•è·fnã€gpã€pcä¸‰ä¸ªå˜é‡ // ç”±äºfnå’Œgpéƒ½æ˜¯æŒ‡é’ˆï¼Œæ•è·å€¼å³å¯ï¼Œè€Œpcæ˜¯uintptrç±»å‹ï¼Œä¹Ÿæ˜¯æ•è·çš„å€¼ newg := newproc1(fn, gp, pc) // ç”±äºå½“å‰åœ¨g0æ ˆä¸Šï¼Œå› æ­¤getg()è·å–çš„æ˜¯g0 // getg().m è·å–çš„æ˜¯å½“å‰çš„å·¥ä½œçº¿ç¨‹M // è·å–å½“å‰mç»‘å®šçš„P _p_ := getg().m.p.ptr() // æŠŠnewgæ”¾å…¥_p_çš„è¿è¡Œé˜Ÿåˆ—ï¼Œåˆå§‹åŒ–çš„æ—¶å€™ä¸€å®šæ˜¯pçš„æœ¬åœ°è¿è¡Œé˜Ÿåˆ— // å…¶å®ƒgoroutineçš„æ—¶å€™å¯èƒ½å› ä¸ºæœ¬åœ°é˜Ÿåˆ—æ»¡äº†è€Œæ”¾å…¥å…¨å±€é˜Ÿåˆ— runqput(_p_, newg, true) // true.æ”¾å…¥Pçš„ç¬¬ä¸€ä½ï¼Œfalse.æ”¾å…¥Pçš„æœ€åä¸€ä½ // mainStartedå…¨å±€å˜é‡æ ‡è®°ä¸»çº¿ç¨‹runtime.mainæ˜¯å¦å·²ç»å¯åŠ¨ // å³ä¸»goroutineå·²ç»å¼€å§‹æ‰§è¡Œï¼Œæ­¤åæ‰ä¼šé€šè¿‡wakeup()å‡½æ•°å¯åŠ¨æ–°çš„å·¥ä½œçº¿ç¨‹ï¼Œ // ä»¥ä¿è¯main()å‡½æ•°æ€»ä¼šè¢«ä¸»çº¿ç¨‹è°ƒåº¦æ‰§è¡Œã€‚ if mainStarted { wakep()\t// å”¤é†’P } }) } systemstack() systemstackåœ¨ç³»ç»Ÿæ ˆä¸Šè¿è¡Œfnã€‚ å¦‚æœä»per-OS-thread (g0)æ ˆè°ƒç”¨systemstackï¼Œæˆ–è€…ä»ä¿¡å·å¤„ç†(gsignal)æ ˆè°ƒç”¨systemstackï¼Œåˆ™systemstackç›´æ¥è°ƒç”¨fnå¹¶ä¸”è¿”å›ã€‚ å¦åˆ™ï¼Œsystemstackå°†ä»æ™®é€šgoroutineçš„æœ‰é™æ ˆä¸­è°ƒç”¨ã€‚åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œsystemstackåˆ‡æ¢åˆ°per-OS-threadæ ˆï¼Œè°ƒç”¨fnç„¶ååˆ‡æ¢å›æ¥ã€‚ é€šå¸¸ä½¿ç”¨ fn å­—é¢é‡ä½œä¸ºå‚æ•°ï¼Œä»¥ä¾¿äºç³»ç»Ÿæ ˆè°ƒç”¨å‘¨å›´çš„ä»£ç è´¡çŒ®è¾“å…¥å’Œè¾“å‡ºï¼š // ... set up y ... systemstack(func() { x = bigcall(y) }) // ... use x ... go:noescapeï¼šæŒ‡ç¤ºç¼–è¯‘å™¨åœ¨ç¼–è¯‘ä»£ç æ—¶ä¸å¯¹å‡½æ•°è¿›è¡Œé€ƒé€¸åˆ†æã€‚ å‘Šè¯‰ç¼–è¯‘å™¨è¯¥å‡½æ•°ä¸ä¼šå°†å…¶å‚æ•°çš„åœ°å€æ³„éœ²åˆ°å‡½æ•°å¤–éƒ¨ï¼Œå› æ­¤å¯ä»¥é¿å…é€ƒé€¸åˆ†æå’Œå †åˆ†é…ï¼Œä»è€Œæé«˜ä»£ç çš„æ€§èƒ½ã€‚ è¿™ä¸ªæŒ‡ä»¤é€šå¸¸åœ¨ä¸€äº›éœ€è¦é«˜æ€§èƒ½çš„å‡½æ•°ä¸­ä½¿ç”¨ï¼Œå¦‚ä¸€äº›å¸¸ç”¨çš„å†…ç½®å‡½æ•°æˆ–ä¸€äº›ç‰¹å®šçš„åº“å‡½æ•°ã€‚ æ–‡ä»¶ä½ç½®ï¼šgo1.19.3/src/runtime/stubs.goã€‚ 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 // systemstack runs fn on a system stack. // If systemstack is called from the per-OS-thread (g0) stack, or // if systemstack is called from the signal handling (gsignal) stack, // systemstack calls fn directly and returns. // Otherwise, systemstack is being called from the limited stack // of an ordinary goroutine. In this case, systemstack switches // to the per-OS-thread stack, calls fn, and switches back. // It is common to use a func literal as the argument, in order // to share inputs and outputs with the code around the call // to system stack: // // ... set up y ... // systemstack(func() { // x = bigcall(y) // }) // ... use x ... // //go:noescape func systemstack(fn func()) runtimeÂ·systemstack() systemstackå‡½æ•°è¢«è®¾è®¡ç”¨æ¥ä¸´æ—¶æ€§çš„åˆ‡æ¢è‡³å½“å‰Mçš„g0æ ˆï¼Œå®ŒæˆæŸäº›æ“ä½œåå†åˆ‡æ¢å›åŸæ¥goroutineçš„æ ˆã€‚ è¯¥å‡½æ•°ä¸»è¦ç”¨äºæ‰§è¡Œruntimeä¸­ä¸€äº›ä¼šè§¦å‘æ ˆå¢é•¿çš„å‡½æ•°ï¼Œå› ä¸ºgoroutineçš„æ ˆæ˜¯è¢«runtimeç®¡ç†çš„ï¼Œæ‰€ä»¥runtimeä¸­è¿™äº›é€»è¾‘å°±ä¸èƒ½åœ¨æ™®é€šçš„gorooutineä¸Šæ‰§è¡Œï¼Œä»¥å…é™·å…¥é€’å½’ã€‚ g0çš„æ ˆæ˜¯ç”±æ“ä½œç³»ç»Ÿåˆ†é…çš„ï¼Œå¯ä»¥è®¤ä¸ºç©ºé—´è¶³å¤Ÿå¤§ï¼Œè¢«runtimeç”¨æ¥æ‰§è¡Œè‡ªèº«é€»è¾‘éå¸¸å®‰å…¨ã€‚ æ–‡ä»¶ä½ç½®ï¼šgo1.19.3/src/runtime/asm_amd64.sã€‚ 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 # func systemstack(fn func()) TEXT runtimeÂ·systemstack(SB), NOSPLIT, $0-8 # é—­åŒ…å‚æ•° fn func()ï¼ŒæŠŠfnå­˜å…¥DIå¯„å­˜å™¨ MOVQ fn+0(FP), DI # DI = fn get_tls(CX) # CX = \u0026amp;m.tls[1]; TLS # è¿™é‡Œè·å–çš„gæ˜¯å½“å‰æ­£åœ¨è¿è¡Œçš„gï¼Œå¯èƒ½æ˜¯g0ä¹Ÿå¯èƒ½ä¸æ˜¯ # ä»TLSè·å–å½“å‰gï¼Œå­˜å…¥AXå¯„å­˜å™¨ MOVQ g(CX), AX # AX = g # å½“å‰æ­£åœ¨è¿è¡Œçš„å·¥ä½œçº¿ç¨‹mï¼Œå°†g.må­˜å…¥BXå¯„å­˜å™¨ä¸­ MOVQ g_m(AX), BX # BX = m # 1) éªŒè¯æ•°æ® # å¦‚æœå½“å‰ g æ˜¯ m.gsignal # è·³è½¬ noswitch æ²¡æœ‰ä»€ä¹ˆå¯åšç›´æ¥è°ƒç”¨ fn å³å¯ # å¯çŸ¥m.gsignalçš„æ ˆæ˜¯g0æ ˆ CMPQ AX, m_gsignal(BX) JEQ noswitch # gsignal ä¹Ÿæ˜¯ç³»ç»Ÿæ ˆï¼Œä¸ç”¨åˆ‡æ¢ # å°†m.g0å­˜å…¥DXå¯„å­˜å™¨ MOVQ m_g0(BX), DX # DX = g0 # æ¯”è¾ƒ g å’Œ g0ï¼Œæ˜¯å¦æ˜¯ä¸€ä¸ªï¼Œå¦‚æœæ˜¯ç›´æ¥è·³è½¬ noswitch # æ¯”è¾ƒå½“å‰gæ˜¯ä¸æ˜¯g0 CMPQ AX, DX JEQ\tnoswitch # å·²ç»åœ¨g0ä¸Šï¼Œä¸éœ€è¦åˆ‡æ¢ # æ¯”è¾ƒå½“å‰gæ˜¯å¦å’Œm.curgä¸ä¸€è‡´ # æ¯”è¾ƒ g å’Œ m.curgï¼Œå¦‚æœä¸ç›¸ç­‰è·³è½¬ bad # ç¨‹åºåˆšå¯åŠ¨åˆå§‹åŒ–æ—¶m.curgä¸ºnilï¼Œä¼šåœ¨å‰é¢çš„g0åˆ¤æ–­å¤„ç›´æ¥è·³è½¬äº†ï¼Œä¸ä¼šèµ°åˆ°è¿™é‡Œ # ä¸ºä»€ä¹ˆè¦æ¯”è¾ƒcrugæ˜¯å¦æ˜¯å½“å‰g?æ˜¯å› ä¸ºä»g0åˆ‡æ¢å›å½“å‰géœ€è¦m.curgè¿™ä¸ªå‚æ•°ã€‚ # è¿™ç§æƒ…å†µåœ¨æ™®é€š goroutine åˆ‡æ¢ g0 æ ˆæ—¶ç”¨åˆ° CMPQ AX, m_curg(BX) JNE\tbad # 2) å­˜å‚¨gä¿¡æ¯ # switch stacks # save our state in g-\u0026gt;sched. Pretend to # be systemstack_switch if the G stack is scanned. # # å°†å½“å‰gçš„ä¿¡æ¯ä¿å­˜åˆ° g-\u0026gt;sched ä¸­ã€‚å¦‚æœGæ ˆå·²è¢«æ‰«æï¼Œåˆ™å‡è£…æ˜¯ systemstack_switch è°ƒç”¨çš„ã€‚ # ä¿å­˜ goroutine çš„è°ƒåº¦ä¿¡æ¯ã€‚ CALL gosave_systemstack_switch\u0026lt;\u0026gt;(SB) # 3) åˆ‡æ¢åˆ°g0æ ˆ # g0å†™å…¥TLSã€g0å†™å…¥R14å¯„å­˜å™¨ä¸­ã€g0çš„æ ˆé¡¶å€¼å†™å…¥SPå¯„å­˜å™¨ä¸­ # switch to g0 MOVQ DX, g(CX) # g0å†™å…¥TLSä¸­ # R14 = g0 MOVQ DX, R14 # set the g register # BX = g0.sched.gobuf.sp MOVQ (g_sched+gobuf_sp)(DX), BX # SP = g0.sched.gobuf.sp MOVQ BX, SP # æ¢å¤g0çš„SP # 4) è°ƒç”¨ fn å‡½æ•°ï¼Œæ­¤æ—¶å·²ç»åˆ‡æ¢åˆ°g0æ ˆ # ä¸Šä¸‹æ–‡ä¿¡æ¯åœ¨DXå¯„å­˜å™¨ä¸­ï¼ŒåŒ…å«é—­åŒ…æ•è·çš„å˜é‡åˆ—è¡¨ # call target function MOVQ DI, DX # DX = fn = \u0026amp;funcval MOVQ 0(DI), DI # DI = funcval.fn CALL DI # fn() # 5) åˆ‡æ¢å›gæ ˆ # æ³¨æ„ï¼šå½“ä»g0åˆ‡æ¢å›gçš„æ—¶å€™ï¼Œå¹¶æ²¡æœ‰å°†g0çš„çŠ¶æ€ä¿å­˜åˆ°g0.schedä¸­ # ä¹Ÿå°±æ˜¯è¯´æ¯æ¬¡ä»g0åˆ‡æ¢è‡³å…¶ä»–çš„goroutineåï¼Œg0æ ˆä¸Šçš„å†…å®¹å°±è¢«æŠ›å¼ƒäº† # ä¸‹æ¬¡åˆ‡æ¢è‡³g0è¿˜æ˜¯ä»å¤´å¼€å§‹ã€‚ # ä»m.curgä¸­å–å‡ºgï¼Œç„¶åå†™å…¥TLSä¸­ï¼Œæ¢å¤SPå¯„å­˜å™¨çš„å€¼ # è¿™é‡Œæ²¡æœ‰æ¢å¤PCå¯„å­˜å™¨å’ŒBPå¯„å­˜å™¨çš„å€¼ï¼Œå› ä¸ºPCå¯„å­˜å™¨çš„å€¼è¿™é‡Œä¸éœ€è¦æ¢å¤é¡ºåºæ‰§è¡Œä»£ç å³å¯ï¼Œ # BPå¯„å­˜å™¨çš„å€¼åœ¨è°ƒç”¨systemstack()å‡½æ•°çš„æ•´ä¸ªè¿‡ç¨‹ä¸­éƒ½æ²¡æœ‰ä¿®æ”¹ï¼Œå› æ­¤ä¹Ÿä¸éœ€è¦æ¢å¤ã€‚ # switch back to g get_tls(CX) # CX = \u0026amp;m.tls[1] MOVQ g(CX), AX # AX = g0 MOVQ g_m(AX), BX # BX = m MOVQ m_curg(BX), AX # AX = m.curg; å½“å‰g MOVQ AX, g(CX) # gå­˜å…¥TLS # è°ƒç”¨ systemstack å‡½æ•°å‰çš„ SP; # R14å¯„å­˜å™¨åœ¨è¿™ä¸ªå‡½æ•°ä¸­æ²¡æœ‰è¢«è®¾ç½®å›æ¥ï¼Œåº”è¯¥æ˜¯ç¼–è¯‘å™¨è´Ÿè´£è®¾ç½®å›æ¥å§ã€‚ MOVQ (g_sched+gobuf_sp)(AX), SP # æ¢å¤SP; SP = g.sched.gobuf.sp MOVQ $0, (g_sched+gobuf_sp)(AX) # æ¸…é™¤ g.sched.gobuf.sp = 0 RET noswitch: # already on m stack; tail call the function # Using a tail call here cleans up tracebacks since we won\u0026#39;t stop # at an intermediate systemstack. # # å·²ç»åœ¨mæ ˆä¸Šï¼›ç”±äºæˆ‘ä»¬ä¸ä¼šåœ¨ä¸­é—´ç³»ç»Ÿæ ˆä¸Šåœæ­¢ï¼Œå› æ­¤åœ¨è¿™é‡Œç›´æ¥è°ƒç”¨fn MOVQ DI, DX # DX = \u0026amp;funcval MOVQ 0(DI), DI # DI = funcval.fn JMP\tDI # è°ƒç”¨fnå‡½æ•° bad: # Bad: g is not gsignal, not g0, not curg. What is it? # Badï¼šg ä¸æ˜¯ gsignalï¼Œä¹Ÿä¸æ˜¯ g0ï¼Œä¸æ˜¯ curgã€‚å®ƒæ˜¯ä»€ä¹ˆï¼Ÿ MOVQ $runtimeÂ·badsystemstack(SB), AX CALL AX INT\t$3 # è°ƒè¯•é”™è¯¯ gosave_systemstack_switch() ä¿å­˜è°ƒç”¨è€…çŠ¶æ€åˆ°g-\u0026gt;schedï¼Œä½†æ˜¯ä¼ªè£…PCå€¼ä»systemstack_switchå‡½æ•°è°ƒç”¨çš„ã€‚ è¯¥å‡½æ•°åªèƒ½ä»æ²¡æœ‰å±€éƒ¨å˜é‡çš„ï¼ˆ$0ï¼‰çš„å‡½æ•°è°ƒç”¨ï¼Œå¦åˆ™systemstack_switchæ˜¯ä¸æ­£ç¡®çš„ã€‚ R9å¯„å­˜å™¨çš„å€¼è¢«è¦†ç›–ã€‚ æ–‡ä»¶ä½ç½®ï¼šgo1.19.3/src/runtime/asm_amd64.sã€‚ 766 767 768 769 770 771 772 773 774 775 776 777 778 779 780 781 782 783 784 785 786 787 788 789 790 791 792 793 794 795 # Save state of caller into g-\u0026gt;sched, # but using fake PC from systemstack_switch. # Must only be called from functions with no locals ($0) # or else unwinding from systemstack_switch is incorrect. # Smashes R9. TEXT gosave_systemstack_switch\u0026lt;\u0026gt;(SB),NOSPLIT,$0 MOVQ $runtimeÂ·systemstack_switch(SB), R9 # g.sched.gobuf.pc = $runtimeÂ·systemstack_switch # ä¼ªè£…å½“å‰è°ƒç”¨æ˜¯ä» runtimeÂ·systemstack_switch å‡½æ•°å¼€å§‹çš„ã€‚ # ä»systemstack()åé¢çš„ä»£ç çœ‹å‡ºï¼Œè¿™é‡Œçš„PCå€¼æ²¡æœ‰è¢«ä½¿ç”¨ï¼ŒåŸå› æ˜¯PCä¸éœ€è¦è¿˜åŸè®¾ç½®ã€‚ # å› ä¸ºsystemstack()å‡½æ•°æ˜¯é—­åŒ…è°ƒç”¨fn()å‡½æ•°ï¼Œå› æ­¤æ‰§è¡Œå®Œåè¿˜åœ¨è°ƒç”¨è€…çš„ä»£ç ä¸­ã€‚ MOVQ R9, (g_sched+gobuf_pc)(R14) # g.sched.gobuf.pc = runtimeÂ·systemstack_switch # å› ä¸ºè°ƒç”¨gosave_systemstack_switch()å‡½æ•°ä½¿ç”¨äº†CALLæŒ‡ä»¤ï¼Œæ‰€ä»¥ä¼šæŠŠè¿”å›åœ°å€å‹å…¥æ ˆä¸­ # å› æ­¤ 8(SP)çš„ä½ç½®æ­£å¥½æ˜¯è°ƒç”¨è€…å‡½æ•°çš„æ ˆï¼Œä¹Ÿå°±æ˜¯systemstack()å‡½æ•°çš„æ ˆ # ä»systemstack()å‡½æ•°çš„å‡½æ•°åŸå‹å¯çŸ¥ï¼Œè¯¥å‡½æ•°æ²¡æœ‰åˆ†é…æ ˆå¤§å°ä¸º0ï¼Œå› æ­¤ä¹Ÿæ˜¯è°ƒç”¨systemstack()å‡½æ•°çš„SPå€¼ # è¿™é‡Œæ˜¯newproc()å‡½æ•°çš„çš„æ ˆé¡¶çš„å€¼ LEAQ 8(SP), R9 # 8(SP) æ˜¯è°ƒç”¨è€…å‰çš„SPæŒ‡å‘çš„å€¼ MOVQ R9, (g_sched+gobuf_sp)(R14) # g.sched.gobuf.sp æŒ‡å‘è°ƒç”¨è€…SP MOVQ $0, (g_sched+gobuf_ret)(R14) # g.sched.gobuf.ret = 0 # BPå¯„å­˜å™¨ä¸SPä¸€æ ·ï¼Œè¿™é‡Œä¹Ÿæ˜¯newproc()å‡½æ•°çš„æ ˆåº•çš„å€¼ MOVQ BP, (g_sched+gobuf_bp)(R14) # g.sched.gobuf.bp = BP; è°ƒç”¨è€…BP # Assert ctxt is zero. See func save. # # æ–­è¨€ ctxt æ˜¯0ã€‚å‚çœ‹ func saveã€‚ # g.sched.gobuf.ctxt å­˜å‚¨çš„æ˜¯é—­åŒ…çš„ä¸Šä¸‹æ–‡ï¼Œä¹Ÿå°±æ˜¯DXå¯„å­˜å™¨çš„å€¼æ˜¯å‡½æ•°çš„\u0026amp;funcval MOVQ (g_sched+gobuf_ctxt)(R14), R9 # R9 = g.sched.gobuf.ctxt TESTQ R9, R9 JZ\t2(PC) # åˆ¤æ–­ç»“æœä¸º0åˆ™è·³è¿‡abort()å‡½æ•° CALL runtimeÂ·abort(SB) RET systemstack_switch() æ–‡ä»¶ä½ç½®ï¼šï¼šgo1.19.3/src/runtime/asm_amd64.sã€‚ 453 454 455 456 457 458 459 # systemstack_switch is a dummy routine that systemstack leaves at the bottom # of the G stack. We need to distinguish the routine that # lives at the bottom of the G stack from the one that lives # at the top of the system stack because the one at the top of # the system stack terminates the stack walk (see topofstack()). TEXT runtimeÂ·systemstack_switch(SB), NOSPLIT, $0-0 RET newproc1() è¯¥å‡½æ•°ä¸»è¦æ˜¯åˆ›å»ºnew goroutineï¼Œå¹¶è®¾ç½®new goroutineè¯¥ä»å“ªé‡Œè¿›å…¥å“ªé‡Œé€€å‡ºã€‚ ä»fnå¼€å§‹ï¼Œåˆ›å»ºä¸€ä¸ªçŠ¶æ€ä¸º_Grunnableçš„æ–°gã€‚ callerpc æ˜¯åˆ›å»ºè¿™ä¸ªgoè¯­å¥çš„åœ°å€ï¼ˆä¹Ÿå°±æ˜¯goå…³é”®å­—ä»£ç çš„ä¸‹ä¸€æ¡æŒ‡é’ˆï¼‰ã€‚ è°ƒç”¨è€…è´Ÿè´£å°†æ–°çš„gæ·»åŠ åˆ°è°ƒåº¦å™¨ã€‚ å‚æ•°ï¼š fn *funcvalï¼šè¦æ‰§è¡Œå‡½æ•°çš„é—­åŒ…ã€‚ä¹Ÿå°±æ˜¯goå…³é”®å­—åé¢çš„å‡½æ•°é—­åŒ…ï¼Œä¸è¿‡å‡½æ•°é—­åŒ…åŸå‹æ˜¯func()ã€‚ callergp *gï¼šå½“å‰æ­£åœ¨è¿è¡Œçš„goroutineã€‚ä¹Ÿå°±æ˜¯è°ƒç”¨goå…³é”®å­—çš„goroutineã€‚ callerpc uintptrï¼šgoå…³é”®å­—çš„ä¸‹ä¸€è¡ŒæŒ‡ä»¤åœ°å€ã€‚ä¹Ÿå°±æ˜¯è°ƒç”¨goå…³é”®å­—åçš„ä¸‹ä¸€æ¡æŒ‡ä»¤ã€‚ è¿”å›å€¼ï¼š*gï¼šæ–°åˆ›å»ºçš„goroutineã€‚ æ–‡ä»¶ä½ç½®ï¼šgo1.19.3/src/runtime/proc.goã€‚ 4109 4110 4111 4112 4113 4114 4115 4116 4117 4118 4119 4120 4121 4122 4123 4124 4125 4126 4127 4128 4129 4130 4131 4132 4133 4134 4135 4136 4137 4138 4139 4140 4141 4142 4143 4144 4145 4146 4147 4148 4149 4150 4151 4152 4153 4154 4155 4156 4157 4158 4159 4160 4161 4162 4163 4164 4165 4166 4167 4168 4169 4170 4171 4172 4173 4174 4175 4176 4177 4178 4179 4180 4181 4182 4183 4184 4185 4186 4187 4188 4189 4190 4191 4192 4193 4194 4195 4196 4197 4198 4199 4200 4201 4202 4203 4204 4205 4206 4207 4208 4209 4210 4211 4212 4213 4214 4215 4216 4217 4218 4219 4220 4221 4222 4223 4224 4225 4226 4227 4228 4229 4230 4231 // Create a new g in state _Grunnable, starting at fn. callerpc is the // address of the go statement that created this. The caller is responsible // for adding the new g to the scheduler. func newproc1(fn *funcval, callergp *g, callerpc uintptr) *g { // è·å–å½“å‰å·¥ä½œçº¿ç¨‹æ­£åœ¨è¿è¡Œçš„gï¼Œè¯¥gæ˜¯g0ï¼Œ // å› ä¸ºnewproc1()å‡½æ•°åªä¼šåœ¨g0æ ˆä¸­è¢«è°ƒç”¨ã€‚ _g_ := getg() // g0 // \u0026#34;go nil\u0026#34; è¿™ç§å½¢å¼æ˜¯ä¸ä¼šå…è®¸çš„ã€‚ // var fn func() // nil // go fn() if fn == nil { _g_.m.throwing = -1 // do not dump full stacks throw(\u0026#34;go of nil func value\u0026#34;) } // ç¦ç”¨æŠ¢å ï¼Œå› ä¸ºå®ƒå¯ä»¥åœ¨æœ¬åœ°å˜é‡ä¸­æŒæœ‰p // å°†å½“å‰g.m.locks++ï¼Œå½“å‰gæ˜¯g0ã€‚ acquirem() // disable preemption because it can be holding p in a local var // è·å–å½“å‰å·¥ä½œçº¿ç¨‹Mç»‘å®šçš„P _p_ := _g_.m.p.ptr() // åˆå§‹åŒ–æ—¶_p_ = g0.m.pï¼Œä»å‰é¢çš„åˆ†æå¯ä»¥çŸ¥é“å…¶å®å°±æ˜¯allp[0] newg := gfget(_p_) // ä»Pçš„æœ¬åœ°ç¼“å†²é‡Œè·å–ä¸€ä¸ªæ²¡æœ‰ä½¿ç”¨çš„gï¼Œåˆå§‹åŒ–æ—¶æ²¡æœ‰ï¼Œè¿”å›nil // å¦‚æœä»å½“å‰Pçš„ç©ºé—²gé“¾è¡¨ä¸­æ²¡æœ‰è·å–åˆ°gï¼Œåˆ™åˆ›å»ºä¸€ä¸ª if newg == nil { // newä¸€ä¸ªgç»“æ„ä½“å¯¹è±¡ï¼Œç„¶åä»å †ä¸Šä¸ºå…¶åˆ†é…æ ˆï¼Œå¹¶è®¾ç½®gçš„stackæˆå‘˜å’Œä¸¤ä¸ªstackgardæˆå‘˜ newg = malg(_StackMin) // _StackMin = 2048 // _Gidle = 0ï¼šè¯¥çŠ¶æ€æ˜¯Gåˆšåˆšè¢«åˆ†é…è¿˜æ²¡åˆå§‹åŒ–æ—¶ // _Gdead = 6ï¼šè¯¥çŠ¶æ€è¡¨ç¤ºå½“å‰æ²¡æœ‰è¢«ç”¨åˆ°ï¼Œå®ƒå¯èƒ½åˆšåˆšå®Œæˆåˆå§‹åŒ–æˆ–åˆšåˆšé€€å‡ºè¿è¡Œï¼Œåœ¨ä¸€ä¸ªç©ºé—²é“¾è¡¨ä¸­ã€‚ // æ³¨æ„è¿™é‡Œæ˜¯CASæ“ä½œ casgstatus(newg, _Gidle, _Gdead) // åˆå§‹åŒ–gçš„çŠ¶æ€ä¸º_Gdead // æ”¾å…¥å…¨å±€å˜é‡ã€allgsåˆ‡ç‰‡ã€‘ä¸­ï¼Œæ–°å¢çš„gå…¨éƒ¨éƒ½ä¼šåŠ å…¥è¿™é‡Œï¼Œå¹¶ä¸”ä¸ä¼šç§»é™¤ï¼Œè¿™ä¹Ÿç¡®ä¿GCä¸ä¼šå»é‡Šæ”¾å®ƒä»¬ allgadd(newg) // publishes with a g-\u0026gt;status of Gdead so GC scanner doesn\u0026#39;t look at uninitialized stack. } // newg ç¼ºå°‘æ ˆ if newg.stack.hi == 0 { throw(\u0026#34;newproc1: newg missing stack\u0026#34;) } // newg çš„çŠ¶æ€åº”è¯¥æ˜¯ _Gdeadï¼šgoroutineå½“å‰æ²¡æœ‰è¢«ç”¨åˆ° if readgstatus(newg) != _Gdead { throw(\u0026#34;newproc1: new g is not Gdead\u0026#34;) } // è°ƒæ•´goroutineçš„æ ˆhiï¼Œç”¨äº usesLR ä¸ºtrueæ—¶ // sys.MinFrameSize = 0; goarch.PtrSize = 8; totalSize = 32; // extra space in case of reads slightly beyond frame totalSize := uintptr(4*goarch.PtrSize + sys.MinFrameSize) // sys.StackAlign = 8; totalSize = 32; totalSize = alignUp(totalSize, sys.StackAlign) // æ³¨æ„é¢„ç•™è¿™32å­—èŠ‚æ˜¯ä»æ ˆé«˜åœ°å€å¼€å§‹çš„ sp := newg.stack.hi - totalSize // é¢„ç•™32å­—èŠ‚ï¼Œä¸»è¦ç”¨äºä¸‹é¢usesLR spArg := sp if usesLR { // caller\u0026#39;s LR *(*uintptr)(unsafe.Pointer(sp)) = 0 prepGoExitFrame(sp) spArg += sys.MinFrameSize } // æŠŠnewg.schedç»“æ„ä½“æˆå‘˜çš„æ‰€æœ‰æˆå‘˜è®¾ç½®ä¸º0 // newg.schedæ˜¯ä¸€ä¸ªgobufç»“æ„ä½“ï¼Œä¿å­˜çš„CPUä¸»è¦çš„å‡ ä¸ªå¯„å­˜å™¨çš„å€¼ memclrNoHeapPointers(unsafe.Pointer(\u0026amp;newg.sched), unsafe.Sizeof(newg.sched)) newg.sched.sp = sp // newg.sched.spå¯„å­˜å™¨rspå¾—å€¼ï¼Œä¹Ÿå°±æ˜¯newgçš„æ ˆé¡¶ï¼Œæ³¨æ„è¿™é‡Œå…¶å®æŒ‡å‘çš„æ˜¯rbpå­˜å‚¨çš„å€¼ newg.stktopsp = sp // æ ˆé¡¶ä½ç½®ï¼Œè¯¥å€¼ç”¨äºå›æº¯ // newg.sched.pc ä¿å­˜çš„æ˜¯ripå¯„å­˜å™¨çš„å€¼ï¼Œnewg.sched.pc è¡¨ç¤ºå½“newgè¢«è°ƒåº¦èµ·æ¥è¿è¡Œæ—¶ä»è¿™ä¸ªåœ°å€å¼€å§‹æ‰§è¡ŒæŒ‡ä»¤ // æŠŠpcè®¾ç½®æˆäº†goexitè¿™ä¸ªå‡½æ•°åç§»1ï¼ˆsys.PCQuantumç­‰äº1ï¼‰çš„ä½ç½®ï¼Œ // è¿™é‡Œè®¾ç½®goroutineçš„æ‰§è¡Œåœ°å€ä¸ºgoexitå‡½æ•°çš„ç¬¬äºŒæ¡æŒ‡ä»¤çš„ä»£ç åœ°å€è€Œä¸æ˜¯fn.fn // è‡³äºä¸ºä»€ä¹ˆè¦è¿™ä¹ˆåšéœ€è¦ç­‰åˆ°åˆ†æå®Œgostartcallfnå‡½æ•°æ‰çŸ¥é“ // +PCQuantum so that previous instruction is in same function newg.sched.pc = abi.FuncPCABI0(goexit) + sys.PCQuantum newg.sched.g = guintptr(unsafe.Pointer(newg)) // è®°å½•å½“å‰çš„gobufæ˜¯æ¥è‡ªnewgè¿™ä¸ªgoroutine gostartcallfn(\u0026amp;newg.sched, fn) // è¯¥å‡½æ•°å¤„ç†newgä»å“ªé‡Œè¿›å…¥ä»å“ªé‡Œé€€å‡º newg.gopc = callerpc // ä¿å­˜goå…³é”®å­—åçš„ä¸‹ä¸€æ¡ä»£ç åœ°å€ï¼Œä¸»è¦ç”¨äºtraceback newg.ancestors = saveAncestors(callergp) // ä¿å­˜å½“å‰åˆ›å»ºgoå…³é”®çš„çš„goroutine // è®¾ç½®newgçš„startpcä¸ºfn.fnï¼Œè¯¥æˆå‘˜ä¸»è¦ç”¨äºå‡½æ•°è°ƒç”¨æ ˆçš„tracebackå’Œæ ˆæ”¶ç¼© // newgçœŸæ­£ä»å“ªé‡Œå¼€å§‹æ‰§è¡Œå¹¶ä¸ä¾èµ–äºè¿™ä¸ªæˆå‘˜ï¼Œè€Œæ˜¯sched.pc newg.startpc = fn.fn // åœ¨isSystemGoroutineä¸­è¢«ç”¨åˆ° // åˆ¤æ–­å½“å‰goroutineæ˜¯å¦æ˜¯ç³»ç»Ÿgoroutine // runtime.mainè¢«è®¤ä¸ºä¸æ˜¯ç³»ç»Ÿgoroutineã€‚ if isSystemGoroutine(newg, false) { // sched.ngsysï¼šè®°å½•çš„æ˜¯ç³»ç»Ÿgoroutineçš„æ•°é‡ï¼Œä¼šè¢«åŸå­æ€§çš„æ›´æ–°ã€‚ atomic.Xadd(\u0026amp;sched.ngsys, +1) } else { // Only user goroutines inherit pprof labels. // user goroutine ç»§æ‰¿ labels if _g_.m.curg != nil { newg.labels = _g_.m.curg.labels } } // Track initial transition? // ç”¨äºç¡®å®æ˜¯å¦è·Ÿè¸ªè¿™ä¸ªG newg.trackingSeq = uint8(fastrand()) // gTrackingPeriod = 8 if newg.trackingSeq%gTrackingPeriod == 0 { newg.tracking = true } // è®¾ç½®gçš„çŠ¶æ€ä¸º_Grunnableï¼Œè¡¨ç¤ºè¿™ä¸ªgä»£è¡¨çš„goroutineå¯ä»¥è¿è¡Œäº† // _Gdead = 6ï¼šè¯¥çŠ¶æ€è¡¨ç¤ºå½“å‰æ²¡æœ‰è¢«ç”¨åˆ°ï¼Œå®ƒå¯èƒ½åˆšåˆšå®Œæˆåˆå§‹åŒ–æˆ–åˆšåˆšé€€å‡ºè¿è¡Œï¼Œåœ¨ä¸€ä¸ªç©ºé—²é“¾è¡¨ä¸­ã€‚ // _Grunnable = 1ï¼šgoroutineåº”è¯¥åœ¨æŸä¸ªrunqä¸­ï¼Œå½“å‰å¹¶æ²¡æœ‰åœ¨è¿è¡Œç”¨æˆ·ä»£ç ï¼Œå®ƒçš„æ ˆä¸å½’è‡ªå·±æ‰€æœ‰ã€‚ casgstatus(newg, _Gdead, _Grunnable) gcController.addScannableStack(_p_, int64(newg.stack.hi-newg.stack.lo)) if _p_.goidcache == _p_.goidcacheend { // Sched.goidgen is the last allocated id, // this batch must be [sched.goidgen+1, sched.goidgen+GoidCacheBatch]. // At startup sched.goidgen=0, so main goroutine receives goid=1. _p_.goidcache = atomic.Xadd64(\u0026amp;sched.goidgen, _GoidCacheBatch) _p_.goidcache -= _GoidCacheBatch - 1 _p_.goidcacheend = _p_.goidcache + _GoidCacheBatch } // goid è¡¨ç¤ºGçš„å”¯ä¸€ID newg.goid = int64(_p_.goidcache) // è®¾ç½®å½“å‰goåœ¨Pä¸­çš„ä½ç½® _p_.goidcache++ if raceenabled { newg.racectx = racegostart(callerpc) } if trace.enabled { traceGoCreate(newg, newg.startpc) } releasem(_g_.m) // å…è®¸å½“å‰Mè¢«æŠ¢å  return newg } gfget() è¯¥å‡½æ•°ä¸»è¦æ˜¯ä»å½“å‰Pç©ºé—²çš„Gé“¾è¡¨ä¸­è·å–Gï¼Œæˆ–è€…ä»å…¨å±€çš„Pé“¾è¡¨ä¸­è·å–Gï¼Œå¦‚æœæœ¬åœ°Pä¸­æ²¡æœ‰ç©ºé—²çš„Gåˆ™ä»å…¨å±€çš„Pä¸­è¿ç§»éƒ¨åˆ†Gæ”¾å…¥æœ¬åœ°éPä¸­ã€‚ ä»gfreeåˆ—è¡¨è·å–ã€‚å¦‚æœå±€éƒ¨åˆ—è¡¨ä¸ºç©ºï¼Œåˆ™ä»å…¨å±€åˆ—è¡¨ä¸­è·å–ä¸€éƒ¨åˆ†åˆ°æœ¬åœ°ã€‚ å‚çœ‹ä¸‹é¢\u0026quot;ç©ºé—²çš„gé“¾è¡¨\u0026quot;ä¸­çš„gfgetå‡½æ•°æ³¨é‡Šï¼Œæœ‰äº›å˜åŒ–ã€‚ æ–‡ä»¶ä½ç½®ï¼šgo1.19.3/src/runtime/proc.goã€‚ 4282 4283 4284 4285 4286 4287 4288 4289 4290 4291 4292 4293 4294 4295 4296 4297 4298 4299 4300 4301 4302 4303 4304 4305 4306 4307 4308 4309 4310 4311 4312 4313 4314 4315 4316 4317 4318 4319 4320 4321 4322 4323 4324 4325 4326 4327 4328 4329 4330 4331 4332 // Get from gfree list. // If local list is empty, grab a batch from global list. func gfget(_p_ *p) *g { retry: // å¦‚æœå½“å‰Pçš„gFreeä¸ºç©º å¹¶ä¸” å…¨å±€çš„gFree.stackæˆ–gFree.noStackä¸ä¸ºç©º // sched.gFree.stack è¡¨ç¤ºè¿™é‡Œçš„goroutineå¸¦æœ‰æ ˆå¤§å°çš„é»˜è®¤æ˜¯2KB // sched.gFree.noStack è¡¨ç¤ºè¿™é‡Œçš„goroutineæ²¡æœ‰åˆ†é…æ ˆå¤§å°ï¼Œé»˜è®¤æ˜¯0KB if _p_.gFree.empty() \u0026amp;\u0026amp; (!sched.gFree.stack.empty() || !sched.gFree.noStack.empty()) { lock(\u0026amp;sched.gFree.lock) // Move a batch of free Gs to the P. for _p_.gFree.n \u0026lt; 32 { // å½“å‰Pçš„gFreeçš„æ•°é‡å°äº32ï¼Œä»sched.gFreeä¸­ç§»åŠ¨ä¸€éƒ¨åˆ†åˆ°Pçš„gFreeä¸­ // Prefer Gs with stacks. gp := sched.gFree.stack.pop() // ä»ched.gFree.stackå–ä¸€ä¸ªG if gp == nil { // å–ä¸åˆ°ï¼Œåˆ™ä»sched.gFree.noStackå–ä¸€ä¸ªG gp = sched.gFree.noStack.pop() if gp == nil { break } } sched.gFree.n-- // è®°å½•å½“å‰sched.gFreeå‡ä¸€ _p_.gFree.push(gp) // æŠŠå½“å‰å–åˆ°çš„GåŠ å…¥Pçš„gFreeä¸­ _p_.gFree.n++ // æŠŠPçš„gFreeçš„æ•°é‡åŠ ä¸€ } unlock(\u0026amp;sched.gFree.lock) goto retry } gp := _p_.gFree.pop() // ä»Pä¸­å–å‡ºä¸€ä¸ªG if gp == nil { return nil } _p_.gFree.n-- // æ ‡è®°å½“å‰Pçš„gFreeå‡ä¸€ if gp.stack.lo == 0 { // å¦‚æœå½“å‰Gçš„æ ˆé¡¶ä¸º0ï¼Œè¯´æ˜æ ˆè¢«é‡Šæ”¾äº† // Stack was deallocated in gfput. Allocate a new one. // å †æ ˆåœ¨gfput()å‡½æ•°ä¸­è¢«é‡Šæ”¾ åˆ†é…ä¸€ä¸ªæ–°çš„ systemstack(func() { gp.stack = stackalloc(_FixedStack) // é‡æ–°åˆ†é…æ ˆä¿¡æ¯ }) gp.stackguard0 = gp.stack.lo + _StackGuard // æŠŠgp.stackguard0ä¹Ÿæ‰§è¡Œè¯¥ä½ç½® } else { if raceenabled { racemalloc(unsafe.Pointer(gp.stack.lo), gp.stack.hi-gp.stack.lo) } if msanenabled { msanmalloc(unsafe.Pointer(gp.stack.lo), gp.stack.hi-gp.stack.lo) } if asanenabled { asanunpoison(unsafe.Pointer(gp.stack.lo), gp.stack.hi-gp.stack.lo) } } return gp } malg() è¯¥å‡½æ•°ä¸»è¦æ˜¯å¦‚æœä»gfget()å‡½æ•°ä¸­è·å–ä¸åˆ°ç©ºé—²çš„gï¼Œé‚£ä¹ˆå°±è‡ªå·±åˆ†é…ä¸€ä¸ªï¼Œå¹¶è®¾ç½®æ ˆç©ºé—´ åˆ†é…ä¸€ä¸ªæ–°çš„gï¼Œå®ƒçš„å †æ ˆè¶³å¤Ÿå¤§ï¼Œå¯ä»¥å®¹çº³stacksizeå­—èŠ‚ã€‚ æ–‡ä»¶ä½ç½®ï¼šgo1.19.3/src/runtime/proc.goã€‚ 4074 4075 4076 4077 4078 4079 4080 4081 4082 4083 4084 4085 4086 4087 4088 4089 4090 4091 4092 4093 4094 4095 4096 4097 // Allocate a new g, with a stack big enough for stacksize bytes. func malg(stacksize int32) *g { newg := new(g) // åˆ›å»ºä¸€ä¸ªGï¼Œè¿™é‡Œæ˜¯å †åˆ†é…çš„ // éœ€è¦åˆ†é…æ ˆå¤§å° if stacksize \u0026gt;= 0 { // _StackSystem = 0ï¼Œround2å‡½æ•°å‘ä¸Šå–æˆ2çš„å¹‚æ¬¡æ–¹ï¼Œstacksizeæ˜¯2KB stacksize = round2(_StackSystem + stacksize) // è®¡ç®—å¤§å°2çš„å¹‚æ¬¡æ–¹ // åˆ‡æ¢åˆ°g0æ ˆï¼Œå»åˆ†é…æ ˆ systemstack(func() {\t// åˆ†é…æ ˆï¼Œgoroutineåœ¨linuxä¸Šé»˜è®¤æ˜¯2KBå¤§å° newg.stack = stackalloc(uint32(stacksize)) }) // æ³¨æ„ï¼šstackguard0 = newg.stack.lo + _StackGuard æº¢å‡ºè­¦æˆ’çº¿ newg.stackguard0 = newg.stack.lo + _StackGuard // è®¾ç½®newg.stackguard0 newg.stackguard1 = ^uintptr(0) // Clear the bottom word of the stack. We record g // there on gsignal stack during VDSO on ARM and ARM64. // // æ¸…é™¤å †æ ˆçš„åº•éƒ¨å•è¯ã€‚åœ¨ARMå’ŒARM64ä¸Šè¿›è¡ŒVDSOæ—¶ï¼Œæˆ‘ä»¬åœ¨gsignalå †æ ˆä¸Šè®°å½•gã€‚ // è¿™é‡Œä¿®æ”¹çš„æ˜¯ newg.stack.lo åœ°å€æŒ‡å‘çš„å€¼ä¸º0ï¼Œä¸æ˜¯ newg.stack.lo = 0ã€‚ *(*uintptr)(unsafe.Pointer(newg.stack.lo)) = 0 } return newg } gostartcallfn() è¯¥å‡½æ•°ä¸»è¦ä½œç”¨æ˜¯å¤„ç†goå…³é”®æ³¨å†Œçš„é—­åŒ…ï¼Œä»¥åŠnewgä»å“ªé‡Œè¿›å…¥ä»å“ªé‡Œé€€å‡ºç­‰ã€‚ è°ƒæ•´gobufï¼Œè®©å®ƒåƒæ‰§è¡Œäº†å¯¹fnçš„è°ƒç”¨ä¸€æ ·ï¼Œç„¶ååœ¨fnä¸­çš„ç¬¬ä¸€ä¸ªæŒ‡ä»¤ä¹‹å‰åœæ­¢ã€‚ å‚æ•°ï¼š gobuf *gobufï¼šgoroutineçš„è°ƒåº¦ä¿¡æ¯ã€‚ fv *funcvalï¼šgoroutineè¦æ‰§è¡Œçš„é—­åŒ…ã€‚ æ–‡ä»¶ä½ç½®ï¼šgo1.19.3/src/runtime/stack.goã€‚ 1125 1126 1127 1128 1129 1130 1131 1132 1133 1134 1135 1136 1137 1138 1139 1140 1141 1142 1143 1144 // adjust Gobuf as if it executed a call to fn // and then stopped before the first instruction in fn. func gostartcallfn(gobuf *gobuf, fv *funcval) { var fn unsafe.Pointer\tif fv != nil { // çŸ¥é“é—­åŒ…çš„ç»“æ„ï¼ŒçŸ¥é“fv.fnä¸ºæ³¨å†Œå‡½æ•°çš„åœ°å€ // fn: gorotineçš„å…¥å£åœ°å€ï¼Œåˆå§‹åŒ–æ—¶å¯¹åº”çš„æ˜¯runtime.main fn = unsafe.Pointer(fv.fn)\t} else { // //go:nosplit // func nilfunc() { // *(*uint8)(nil) = 0 // } // å¦‚æœä¼ å…¥ã€nilã€‘çš„å‡½æ•°é—­åŒ…ï¼Œåˆ™å°è£…nilfuncå‡½æ•°ï¼Œè¿è¡Œèµ·æ¥è¯¥å‡½æ•°ä¼šæŠ¥é”™ã€‚ fn = unsafe.Pointer(abi.FuncPCABIInternal(nilfunc)) } // unsafe.Pointer(fv) ä½œä¸ºfnçš„ä¸Šä¸‹æ–‡ç¯å¢ƒä¼ å…¥ // unsafe.Pointer(fv) ä¼šä¼ å…¥DXå¯„å­˜å™¨ï¼ŒDXå¯„å­˜å™¨ç”¨äºé—­åŒ…è°ƒç”¨éšè—ä¼ å€¼ gostartcall(gobuf, fn, unsafe.Pointer(fv))\t} gostartcall() è¯¥å‡½æ•°ä¸»è¦æ•°å¤„ç†newgä»å“ªé‡Œè¿›å…¥ä»å“ªé‡Œé€€å‡ºã€‚ ä¼ªè£…newgæ³¨å†Œçš„å‡½æ•°æ˜¯ä»goexit+1ä»£ç å¤„è°ƒç”¨fnå‡½æ•°ï¼Œè¯¥newgæ‰§è¡Œå®Œåä¼šæ¥åˆ°æ‰§è¡Œgoexit+1åé¢ä»£ç ã€‚ è¯¥å‡½æ•°æ˜¯è®¾ç½®goroutineä»å“ªé‡Œè¿›å…¥ä»å“ªé‡Œå‡ºå»çš„å…³é”®ã€‚ å‚æ•°ï¼š buf *gobufï¼šgoroutineçš„è°ƒåº¦ä¿¡æ¯ã€‚ fn unsafe.Pointerï¼šé—­åŒ…å‡½æ•°funcval.fnçš„å€¼ã€‚ ctxt unsafe.Pointerï¼šé—­åŒ…å‡½æ•°funcvalçš„åœ°å€ã€‚ æ–‡ä»¶ä½ç½®ï¼šgo1.19.3/src/runtime/sys_x86.goã€‚ 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 // adjust Gobuf as if it executed a call to fn with context ctxt // and then stopped before the first instruction in fn. func gostartcall(buf *gobuf, fn, ctxt unsafe.Pointer) { sp := buf.sp // buf.sp æ ˆå¼€å§‹çš„ä½ç½® sp -= goarch.PtrSize // ä¸ºè¿”å›åœ°å€é¢„ç•™8Bç©ºé—´ // è¿™é‡Œåœ¨ä¼ªè£…fnæ˜¯è¢«goexit()å‡½æ•°è°ƒç”¨çš„ï¼Œä½¿å¾—fnæ‰§è¡Œå®Œåè¿”å›åˆ°goexitç»§ç»­æ‰§è¡Œï¼Œä»è€Œå®Œæˆæ¸…ç†å·¥ä½œ *(*uintptr)(unsafe.Pointer(sp)) = buf.pc // æŠŠgoexit+1ä»£ç åœ°å€æ”¾å…¥è¯¥å¤„ï¼Œæ¨¡æ‹Ÿæ˜¯è¢«goexitå‡½æ•°è°ƒç”¨çš„ buf.sp = sp // é‡æ–°è®¾ç½®newgçš„æ ˆé¡¶å¯„å­˜å™¨ // è¿™é‡Œæ‰çœŸæ­£è®©newgçš„ipå¯„å­˜å™¨æŒ‡å‘fnå‡½æ•°ï¼Œæ³¨æ„ï¼Œè¿™é‡Œåªæ˜¯åœ¨è®¾ç½®newgçš„ä¸€äº›ä¿¡æ¯ï¼Œnewgè¿˜æœªæ‰§è¡Œï¼Œ // ç­‰åˆ°newgè¢«è°ƒåº¦èµ·æ¥è¿è¡Œæ—¶ï¼Œè°ƒåº¦å™¨ä¼šæŠŠbuf.pcæ”¾å…¥cpuçš„IPå¯„å­˜å™¨ï¼Œ // ä»è€Œä½¿newgå¾—ä»¥åœ¨cpuä¸ŠçœŸæ­£çš„è¿è¡Œèµ·æ¥ buf.pc = uintptr(fn) // è¯¥å€¼ç”¨åœ¨é—­åŒ…çš„è°ƒç”¨ DX å¯„å­˜å™¨éœ€è¦çš„ä¸Šä¸‹æ–‡ï¼Œè¯¥å€¼æ˜¯è°ƒåº¦èµ·fnå‡½æ•°çš„å…³é”® buf.ctxt = ctxt // ä¿å­˜å½“å‰goroutineä¸Šä¸‹ç¯å¢ƒä¿¡æ¯ } runtime.gpexit() å½“goroutineè¿è¡Œå®Œæ—¶ä¼šè¿”å›åˆ°è¯¥å‡½æ•°å¤„ç»§ç»­è¿è¡Œåç»­æ”¶å°¾å·¥ä½œã€‚ éƒ¨åˆ†äººå¯èƒ½æ‹…å¿ƒgoexit()å‡½æ•°åŠ ä¸€ä¼šé€ æˆæŒ‡ä»¤é”™ä¹±ï¼Œå®é™…ä¸ä¼šæœ‰é—®é¢˜ï¼Œå› ä¸ºgoexit()å‡½æ•°çš„ä»£ç å·²ç»è€ƒè™‘åˆ°è¿™ä¸€å±‚äº†ã€‚ é¦–ä½å„æœ‰ä¸€æ¡NOPæŒ‡ä»¤å ä½ï¼Œæ‰€ä»¥å…¥å£åœ°å€åŠ ä¸€åä¸ä¼šå½±å“ï¼Œæ­£å¥½å¯¹å…¶åˆ°äº†æ¥ä¸‹æ¥çš„CALLæŒ‡ä»¤ã€‚ pcçš„å€¼ä¹‹æ‰€ä»¥éœ€è¦æ˜¯goexit()å‡½æ•°çš„åœ°å€åŠ ä¸€ï¼Œæ˜¯å› ä¸ºè¿™æ ·æ‰åƒæ˜¯goexit()å‡½æ•°è°ƒç”¨äº†fn()å‡½æ•°ï¼Œ å¦‚æœæŒ‡å‘goexit()å‡½æ•°çš„èµ·å§‹åœ°å€å°±ä¸åˆé€‚äº†ï¼Œé‚£æ ·goexit()å‡½æ•°çœ‹èµ·æ¥è¿˜æ²¡æœ‰æ‰§è¡Œã€‚ æ–‡ä»¶ä½ç½®ï¼šgo1.19.3/src/runtime/asm_amd64.sã€‚ 1591 1592 1593 1594 1595 1596 1597 // The top-most function running on a goroutine // returns to goexit+PCQuantum. TEXT runtimeÂ·goexit(SB),NOSPLIT|TOPFRAME,$0-0 BYTE $0x90 // NOP CALL runtimeÂ·goexit1(SB) // does not return // traceback from goexit1 must hit code range of goexit BYTE $0x90 // NOP runqput() è¯¥å‡½æ•°ä¸»è¦æ˜¯æŠŠè®¾ç½®å¥½çš„newgæ”¾å…¥Må…³è”çš„Pçš„é¦–ä½ç½®æˆ–å…¨å±€Pä¸­ç­‰å¾…è¢«è°ƒåº¦å™¨è°ƒåº¦èµ·æ¥æ‰§è¡Œã€‚ è¯¥å‡½æ•°ä¹Ÿæ˜¯è°ƒåº¦å¾ªç¯ä¸­ä»å…¨å±€è¿è¡Œgé“¾è¡¨ä¸­å–å‡ºgæ”¾å…¥æœ¬åœ°Pè°ƒç”¨çš„å‡½æ•°ã€‚ å‚æ•°ï¼š _p_ *pï¼šå½“å‰å·¥ä½œçº¿ç¨‹mç»‘å®šçš„Pã€‚ gp *gï¼šæ–°åˆ›å»ºçš„goroutineã€‚ next boolï¼štrue.è¡¨ç¤ºè¿½åŠ åˆ°Pçš„é¦–ä½ç½® false.è¡¨ç¤ºè¿½åŠ åˆ°Pçš„æœ«å°¾ä½ç½®ã€‚ æ–‡ä»¶ä½ç½®ï¼šgo1.19.3/src/runtime/proc.goã€‚ 5780 5781 5782 5783 5784 5785 5786 5787 5788 5789 5790 5791 5792 5793 5794 5795 5796 5797 5798 5799 5800 5801 5802 5803 5804 5805 5806 5807 5808 5809 5810 5811 5812 5813 5814 5815 5816 5817 5818 5819 5820 5821 5822 5823 5824 5825 5826 5827 5828 5829 5830 5831 5832 5833 5834 5835 5836 5837 // runqput tries to put g on the local runnable queue. // If next is false, runqput adds g to the tail of the runnable queue. // If next is true, runqput puts g in the _p_.runnext slot. // If the run queue is full, runnext puts g on the global queue. // Executed only by the owner P. func runqput(_p_ *p, gp *g, next bool) { // è¿™é‡Œæ˜¯ä¸ºäº†æ›¾åŠ éšæœºæ€§ï¼Œnewgä¸æ˜¯æ€»å­˜å…¥æŒ‡å®šä½ç½®,fastrandn(2) å–éšæœºæ•°å¯¹2æ±‚ä½™ if randomizeScheduler \u0026amp;\u0026amp; next \u0026amp;\u0026amp; fastrandn(2) == 0 { next = false } // å¦‚æœæ˜¯è¿½åŠ åˆ°Pçš„é¦–ä½ç½®å¤„ if next { retryNext: // æŠŠgpæ”¾åœ¨_p_.runnextæˆå‘˜é‡Œï¼Œrunnextæˆå‘˜ä¸­çš„goroutineä¼šè¢«ä¼˜å…ˆè°ƒåº¦èµ·æ¥è¿è¡Œ oldnext := _p_.runnext // å¤„ç†æ—§çš„å°†è¦è¢«æ‰§è¡Œçš„goroutine // ä½¿ç”¨é”çš„å½¢å¼æ›¿æ¢_p_.runnextçš„å€¼ä¸ºgpæ–°å€¼ï¼Œå¦‚æœå­˜åœ¨å…¶ä»–goroutineåœ¨æ“ä½œrunnextæˆå‘˜åˆ™éœ€è¦é‡è¯• if !_p_.runnext.cas(oldnext, guintptr(unsafe.Pointer(gp))) { goto retryNext } // å¦‚æœä¹‹å‰éœ€è¦å¤„ç†çš„goroutineä¸ºç©ºåˆ™è¿”å›å³å¯ if oldnext == 0 { return } // Kick the old runnext out to the regular run queue. gp = oldnext.ptr() // è·å–æ—§çš„goroutineåœ°å€ } retry: // P.runqhead uint32 è®°å½•ç€å½“å‰goroutineé˜Ÿåˆ—çš„é˜Ÿåˆ—å¤´ä½ç½® ä¸€ç›´å¾€ä¸ŠåŠ ï¼Œåˆ°æœ€å¤§å€¼å˜ä¸º0 // P.runqtail uint32 è®°å½•ç€å½“å‰goroutineé˜Ÿåˆ—çš„é˜Ÿåˆ—å°¾ä½ç½® ä¸€ç›´å¾€ä¸ŠåŠ ï¼Œåˆ°æœ€å¤§å€¼å˜ä¸º0 // P.runq [256]guintptr ä½¿ç”¨æ•°ç»„å®ç°çš„å¾ªç¯é˜Ÿåˆ— // å¯èƒ½æœ‰å…¶ä»–çº¿ç¨‹æ­£åœ¨å¹¶å‘å–runqheadæˆå‘˜ï¼Œæ‰€ä»¥éœ€è¦è·Ÿå…¶å®ƒçº¿ç¨‹åŒæ­¥ // è¿™é‡Œä¸ºä»€ä¹ˆåªåˆ¤æ–­_p_.runqheadé‚£æ˜¯å› ä¸ºæ‰€ä»¥å…¥æ•°æ®çš„éƒ½æ˜¯ä»é¦–å–èµ°çš„ h := atomic.LoadAcq(\u0026amp;_p_.runqhead) // load-acquire, synchronize with consumers t := _p_.runqtail // å¦‚æœt-h \u0026lt; 256åˆ™æ˜¯æ²¡æœ‰å­˜æ»¡ï¼Œå¯ä»¥æ¥åˆ°å­˜å‚¨g if t-h \u0026lt; uint32(len(_p_.runq)) { // åˆ¤æ–­é˜Ÿåˆ—æ˜¯å¦æ»¡äº† // é˜Ÿåˆ—è¿˜æ²¡å­˜æ»¡å¯ä»¥æ”¾å…¥æœ¬åœ°Pçš„é˜Ÿåˆ—ä¸­ï¼Œè¿™é‡Œæ”¾å…¥çš„æ˜¯tçš„ä½ç½®å¤„ _p_.runq[t%uint32(len(_p_.runq))].set(gp) // è™½ç„¶æ²¡æœ‰å…¶ä»–çº¿ç¨‹å¹¶å‘ä¿®æ”¹è¿™ä¸ªrunqtailï¼Œä½†å…¶ä»–çº¿ç¨‹ä¼šå¹¶å‘è¯»å–è¯¥å€¼ä»¥åŠpçš„runqæˆå‘˜ // è¿™é‡Œä½¿ç”¨StoreRelæ˜¯ä¸ºäº†ï¼š // 1. åŸå­å†™å…¥runqtail // 2. é˜²æ­¢ç¼–è¯‘å™¨å’ŒCPUä¹±åºï¼Œä¿è¯ä¸Šä¸€è¡Œä»£ç å¯¹runqçš„ä¿®æ”¹å‘ç”Ÿåœ¨ä¿®æ”¹runqtailä¹‹å‰ // 3. å¯è§è¡Œå±éšœï¼Œä¿è¯å½“å‰çº¿ç¨‹å¯¹è¿è¡Œé˜Ÿåˆ—çš„ä¿®æ”¹å¯¹å…¶ä»–çº¿ç¨‹ç«‹é©¬å¯è§ atomic.StoreRel(\u0026amp;_p_.runqtail, t+1) // store-release, makes the item available for consumption return } // Pçš„æœ¬åœ°è¿è¡Œé˜Ÿåˆ—å·²æ»¡ï¼Œéœ€è¦æ”¾å…¥å…¨å±€è¿è¡Œé˜Ÿåˆ— // å¦‚æœè¿™é‡Œè¿”å›falseï¼Œåˆ™è¯´æ˜Pçš„æœ¬åœ°è¿è¡Œé˜Ÿåˆ—Gä¸­éƒ¨åˆ†Gè¢«å…¶ä»–Må·èµ°äº†ï¼Œç»§ç»­æ‰§è¡Œgoto retry if runqputslow(_p_, gp, h, t) { return } // the queue is not full, now the put above must succeed // é˜Ÿåˆ—æœªæ»¡ï¼Œç°åœ¨ä¸Šé¢çš„ put å¿…é¡»æˆåŠŸ goto retry } runqputslow() å°†På¾—æœ¬åœ°é˜Ÿåˆ—çš„gè¿ç§»éƒ¨åˆ†åˆ°å…¨å±€é˜Ÿåˆ—ä¸­ã€‚ æ–‡ä»¶ä½ç½®ï¼šgo1.19.3/src/runtime/proc.goã€‚ 5818 5819 5820 5821 5822 5823 5824 5825 5826 5827 5828 5829 5830 5831 5832 5833 5834 5835 5836 5837 5838 5839 5840 5841 5842 5843 5844 5845 5846 5847 5848 5849 5850 5851 5852 5853 5854 5855 5856 5857 5858 5859 5860 5861 5862 5863 5864 5865 5866 5867 5868 5869 5870 // Put g and a batch of work from local runnable queue on global queue. // Executed only by the owner P. func runqputslow(_p_ *p, gp *g, h, t uint32) bool { var batch [len(_p_.runq)/2 + 1]*g // gpåŠ ä¸Š_p_æœ¬åœ°é˜Ÿåˆ—çš„ä¸€åŠ // First, grab a batch from local queue. n := t - h // è®¡ç®—å½“å‰Pä¸­å­˜å‚¨çš„æ•°é‡n n = n / 2 // å–ä¸€åŠ if n != uint32(len(_p_.runq)/2) { // åˆ¤æ–­Pæ˜¯å¦å·²æ»¡ throw(\u0026#34;runqputslow: queue is not full\u0026#34;) } // å¤åˆ¶Pæœ¬åœ°é˜Ÿåˆ—Gçš„ä¸€åŠï¼Œæ”¾å…¥batchä¸­ for i := uint32(0); i \u0026lt; n; i++ { // ä»Pçš„æœ¬åœ°é˜Ÿåˆ—headå¼€å¤´å¼€å§‹å¤åˆ¶ä¸€åŠå­˜å…¥batchä¸­ batch[i] = _p_.runq[(h+i)%uint32(len(_p_.runq))].ptr() } // è¿™é‡ŒæŠŠ_p_.runqheadå€¼è®¾ç½®æˆh+nï¼Œå¹¶åˆ¤æ–­æ—§å€¼hæ˜¯å¦å‘ç”Ÿå˜åŒ–ï¼Œå¦‚æœå‘ç”Ÿå˜åŒ–åˆ™è¯´æ˜å…¶ä»–goroutineæ­£åœ¨å·å–g if !atomic.CasRel(\u0026amp;_p_.runqhead, h, h+n) { // cas-release, commits consume // å¦‚æœcasæ“ä½œå¤±è´¥ï¼Œè¯´æ˜å·²ç»æœ‰å…¶ä»–å·¥ä½œçº¿ç¨‹ä»_p_çš„æœ¬åœ°è¿è¡Œé˜Ÿåˆ—å·èµ°ä¸€äº›goroutineï¼Œæ‰€ä»¥ç›´æ¥è¿”å› return false } batch[n] = gp // æœ€åä¸€ä¸ªä½ç½®å¤„è¿½åŠ gp // å¢åŠ éšæœºæ€§ æ‰“ä¹±batch if randomizeScheduler { for i := uint32(1); i \u0026lt;= n; i++ { j := fastrandn(i + 1)\t// fastrand()%n batch[i], batch[j] = batch[j], batch[i] } } // Link the goroutines. // å…¨å±€è¿è¡Œé˜Ÿåˆ—æ˜¯ä¸€ä¸ªé“¾è¡¨ï¼Œè¿™é‡Œé¦–å…ˆæŠŠæ‰€æœ‰éœ€è¦æ”¾å…¥å…¨å±€è¿è¡Œé˜Ÿåˆ—çš„gé“¾æ¥èµ·æ¥ // å‡å°‘åé¢å¯¹è¿å±…é“¾è¡¨çš„é”ä½æ—¶é—´ï¼Œä»è€Œé™ä½é”å†²çª // å‰ä¸€ä¸ªå’Œåä¸€ä¸ªé“¾æ¥èµ·æ¥ for i := uint32(0); i \u0026lt; n; i++ { batch[i].schedlink.set(batch[i+1]) } // type gQueue struct { // head guintptr // tail guintptr // } var q gQueue q.head.set(batch[0]) // è®¾ç½®å¼€å¤´ q.tail.set(batch[n]) // è®¾ç½®ç»“å°¾ // Now put the batch on global queue. lock(\u0026amp;sched.lock) // é”ä½å½“å‰sched globrunqputbatch(\u0026amp;q, int32(n+1)) // æ‹¼æ¥åˆ°å…¨å±€sched.runqä¸Šå» unlock(\u0026amp;sched.lock) // è§£é”å½“å‰sched return true } globrunqputbatch() æ–‡ä»¶ä½ç½®ï¼šgo1.19.3/src/runtime/proc.goã€‚ 5587 5588 5589 5590 5591 5592 5593 5594 5595 5596 5597 5598 // Put a batch of runnable goroutines on the global runnable queue. // This clears *batch. // sched.lock must be held. // May run during STW, so write barriers are not allowed. //go:nowritebarrierrec func globrunqputbatch(batch *gQueue, n int32) { assertLockHeld(\u0026amp;sched.lock) sched.runq.pushBackAll(*batch) // æŠŠå½“å‰batché“¾æ¥åˆ°å…¨å±€sched.runqä¸Šå» sched.runqsize += n // ç´¯åŠ å½“å‰sched.runqsizeæ•°é‡ *batch = gQueue{} // æ¸…ç©º } acquirem() æ–‡ä»¶ä½ç½®ï¼šgo1.19.3/src/runtime/runtime1.goã€‚ 473 474 475 476 477 478 //go:nosplit func acquirem() *m { _g_ := getg() _g_.m.locks++ return _g_.m } ","permalink":"https://heliu.site/posts/golang/goroutine/newproc/","summary":"Golang goå…³é”®å­—æµç¨‹ä»‹ç»ã€‚","title":"go å…³é”®å­—"},{"content":" æœ¬ç¯‡æ˜¯æ¥ç€ä¸Šä¸€ç¯‡ã€Šgoå…³é”®å­—ã€‹çš„åç»­ï¼Œgoroutineè¿è¡Œå®Œåçš„å›æ”¶é˜¶æ®µã€‚ goexit() goroutineè¿è¡Œç»“æŸåè¿”å›åˆ°goexit+PCQuantumå¤„ã€‚const PCQuantum = 1ã€‚ ä¹Ÿå°±æ˜¯æ¥ç€æ‰§è¡ŒCALL runtimeÂ·goexit1(SB)è¿™æ¡æŒ‡ä»¤ã€‚ æ–‡ä»¶ä½ç½®ï¼šgo1.19.3/src/runtime/asm_amd64.sã€‚ 1591 1592 1593 1594 1595 1596 1597 1598 // The top-most function running on a goroutine // returns to goexit+PCQuantum. TEXT runtimeÂ·goexit(SB),NOSPLIT|TOPFRAME,$0-0 BYTE $0x90 // NOP ä»ä¸‹ä¸€æ¡æŒ‡ä»¤å¼€å§‹æ‰§è¡Œ CALL runtimeÂ·goexit1(SB) // è¿™æ¡æŒ‡ä»¤è°ƒç”¨å‡½æ•°å°†æ°¸ä¸è¿”å› // traceback from goexit1 must hit code range of goexit // ä»goexit1å›æº¯å¿…é¡»è¾¾åˆ°goexitçš„ä»£ç èŒƒå›´ BYTE $0x90 // NOP goexit1() goexit1()å‡½æ•°é€šè¿‡è°ƒç”¨mcallä»å½“å‰è¿è¡Œçš„g2 goroutineåˆ‡æ¢åˆ°g0ï¼Œç„¶ååœ¨g0æ ˆä¸Šè°ƒç”¨å’Œæ‰§è¡Œgoexit0()è¿™ä¸ªå‡½æ•°ã€‚ æ–‡ä»¶ä½ç½®ï¼šgo1.19.3/src/runtime/proc.goã€‚ 3468 3469 3470 3471 3472 3473 3474 3475 3476 3477 3478 3479 3480 3481 3482 3483 // Finishes execution of the current goroutine. func goexit1() { if raceenabled { //ä¸ç«æ€æ£€æŸ¥æœ‰å…³ï¼Œä¸å…³æ³¨ racegoend() } if trace.enabled { //ä¸backtraceæœ‰å…³ï¼Œä¸å…³æ³¨ traceGoEnd() } // æ³¨æ„ï¼Œmcallå‡½æ•°çš„å‚æ•°æ˜¯ä¸€ä¸ªå‡½æ•°goexit0 // Function Value ç»“æ„ // type funcval struct { // fn uintptr // // é—­åŒ…æ•è·çš„å‚æ•°åœ¨è¿™ // } mcall(goexit0) } mcall() å‡½æ•°åŸå‹ï¼šfunc mcall(fn func(*g))ã€‚ runtime.mcall()å‡½æ•°å’Œsystemstack()å‡½æ•°å¾ˆåƒï¼Œä¹Ÿæ˜¯åˆ‡æ¢åˆ°ç³»ç»Ÿæ ˆå»æ‰§è¡ŒæŸä¸ªFunction Valueã€‚ ä½†æ˜¯ä¹Ÿæœ‰äº›ä¸åŒï¼Œmcall()å‡½æ•°ä¸èƒ½åœ¨g0æ ˆä¸Šè°ƒç”¨ï¼Œè€Œä¸”ä¹Ÿä¸ä¼šå†åˆ‡æ¢å›æ¥ã€‚ åˆ‡æ¢åˆ°m.g0æ ˆï¼Œè°ƒç”¨fn(g)ã€‚ Fnå¿…é¡»æ°¸ä¸è¿”å›ã€‚å®ƒåº”è¯¥è°ƒç”¨gogo(\u0026amp;g-\u0026gt;sched)æ¥ä¿æŒgçš„è¿è¡Œã€‚è¿™é‡Œçš„gåº”è¯¥æ˜¯g0ã€‚ ä»å½“å‰è¿è¡Œçš„gåˆ‡æ¢åˆ°g0ï¼Œè¿™ä¸€æ­¥åŒ…æ‹¬ä¿å­˜å½“å‰gçš„è°ƒåº¦ä¿¡æ¯ï¼ŒæŠŠg0è®¾ç½®åˆ°tlsä¸­ï¼Œä¿®æ”¹CPUçš„rspå¯„å­˜å™¨ä½¿å…¶æŒ‡å‘g0çš„æ ˆã€‚ ä»¥å½“å‰è¿è¡Œçš„gä¸ºå‚æ•°è°ƒç”¨fnå‡½æ•°(æ­¤å¤„ä¸ºgoexit0)ã€‚ mcallå‡½æ•°ä¸èƒ½åœ¨g0æ ˆä¸Šè°ƒç”¨ï¼Œè€Œä¸”ä¹Ÿä¸ä¼šå†åˆ‡æ¢å›æ¥ã€‚ æ–‡ä»¶ä½ç½®ï¼šgo1.19.3/src/runtime/asm_amd64.sã€‚ 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 # func mcall(fn func(*g)) # Switch to m-\u0026gt;g0\u0026#39;s stack, call fn(g). # Fn must never return. It should gogo(\u0026amp;g-\u0026gt;sched) # to keep running g. TEXT runtimeÂ·mcall\u0026lt;ABIInternal\u0026gt;(SB), NOSPLIT, $0-8 # 1) ä»AXä¸­è·å–å‚æ•°ï¼Œæ³¨æ„è¿™é‡Œè¿˜æ˜¯å†æ™®é€šgoroutineä¸­ä¸æ˜¯g0 # åœ¨go1.17åç‰ˆæœ¬ä¸­é‡‡ç”¨å¯„å­˜å™¨ä¼ å‚ï¼Œå› æ­¤AXä½œä¸ºç¬¬ä¸€ä¸ªå‚æ•°å­˜å‚¨çš„æ˜¯macllçš„å‚æ•° # ä¼ å‚é¡ºåº AXã€BXã€CXã€DIã€SIã€R8ã€R9ã€R10ã€R11 MOVQ AX, DX # DX = \u0026amp;funcval; \u0026amp;funcval -\u0026gt; goexit0 # 2) ä¿å­˜çŠ¶æ€åˆ° g-\u0026gt;schedã€‚è¿™é‡Œçš„gæ˜¯å½“å‰æ­£åœ¨è¿è¡Œçš„goroutineã€‚ # save state in g-\u0026gt;sched # ä»¥ä¸‹ä¿å­˜å½“å‰çŠ¶æ€åˆ°g-\u0026gt;schedä¸­ï¼Œåœ¨go 1.17ç‰ˆæœ¬åR14å¯„å­˜å™¨å­˜å‚¨çš„æ˜¯å½“å‰å·¥ä½œçº¿ç¨‹è¿è¡Œçš„goroutine # 0(SP)ï¼šå­˜å‚¨çš„æ˜¯goexit1å‡½æ•°è°ƒç”¨mallå‡½æ•°çš„ä¸‹ä¸€æ¡æŒ‡ä»¤åœ°å€ã€‚ä¹Ÿå°±æ˜¯goexit1()å‡½æ•°çš„è¿”å›åœ°å€ MOVQ 0(SP), BX # caller\u0026#39;s PC\tmcallè¿”å›åœ°å€æ”¾å…¥BX # g.sched.pc = BX MOVQ BX, (g_sched+gobuf_pc)(R14) # g.sched.pc = BXï¼Œä¿å­˜gçš„rip # fn+0(FP)è¡¨å½“å‰å‚æ•°æ‰€åœ¨æ ˆä½ç½®ï¼Œä¹Ÿå°±æ˜¯goexit1å‡½æ•°çš„SPä½ç½®å¤„ã€‚å› ä¸ºå‚æ•°åœ¨è°ƒç”¨è€…æ ˆä¸Šã€‚ LEAQ fn+0(FP), BX # caller\u0026#39;s SP MOVQ BX, (g_sched+gobuf_sp)(R14) # g.sched.sp = BXï¼Œä¿å­˜gçš„rsp # g.sched.bp = BP MOVQ BP, (g_sched+gobuf_bp)(R14) # g.sched.bp = BPï¼Œä¿å­˜gçš„rbp # 3) åˆ‡æ¢åˆ° m-\u0026gt;g0 åŠå…¶å †æ ˆï¼Œè°ƒç”¨fnå‡½æ•°ã€‚ # switch to m-\u0026gt;g0 \u0026amp; its stack, call fn # # BX = m MOVQ g_m(R14), BX # BX = g.mï¼Œæ‹¿åˆ°å½“å‰å·¥ä½œçº¿ç¨‹M # SI = g0 MOVQ m_g0(BX), SI # SI = g.m.g0ï¼Œé‚£å½“å½“å‰å·¥ä½œçº¿ç¨‹Mçš„g0æ ˆ # æ­¤åˆ»ï¼ŒSI = g0ï¼Œ R14 = gï¼Œæ‰€ä»¥è¿™é‡Œåœ¨åˆ¤æ–­gæ˜¯å¦æ˜¯g0ï¼Œå¦‚æœg == g0åˆ™ä¸€å®šæ˜¯å“ªé‡Œä»£ç å†™é”™äº† CMPQ SI, R14 # if g == m-\u0026gt;g0 call badmcall JNE goodm # SIå’ŒR14ä¸ç›¸ç­‰åˆ™è·³è½¬ JMP runtimeÂ·badmcall(SB) goodm: # æ­£å¸¸æµç¨‹è·³è½¬åˆ°è¿™é‡Œ # AX = g MOVQ R14, AX # AX (and arg 0) = gï¼ŒAX = g2ï¼Œå½“å‰gä¸æ˜¯g0ï¼ŒAXä¹Ÿæ˜¯goexit0å‡½æ•°éœ€è¦çš„å‚æ•° # R14 = g0 MOVQ SI, R14 # g = g.m.g0ï¼ŒR14 = g0ï¼Œè®¾ç½®å½“å‰æ­£åœ¨è¿è¡Œçš„æ˜¯g0 # CX = \u0026amp;m.tls[1] get_tls(CX) # Set G in TLS # TLS = g0 MOVQ R14, g(CX) # sp = g0.sched.sp MOVQ (g_sched+gobuf_sp)(R14), SP # AX = g å…¥æ ˆï¼Œæ­¤æ—¶å·²ç»åœ¨g0çš„æ ˆä¸Šäº† # AXå­˜å‚¨çš„æ—¶æ™®é€šçš„goroutineï¼Œè¿™é‡Œå…¥æ ˆä¹Ÿæ˜¯goexit0()å‡½æ•°çš„å‚æ•° PUSHQ AX # open up space for fn\u0026#39;s arg spill slot # R12 = funcval.fn; DX = \u0026amp;funcval MOVQ 0(DX), R12 # fnçš„ç¬¬ä¸€ä¸ªæˆå‘˜æ˜¯goexit0å‡½æ•°ä»£ç åœ°å€å¤„ï¼ŒR12 = fn.fn # è°ƒç”¨goexit0()å‡½æ•°ï¼Œå‚æ•°å†AXå¯„å­˜å™¨ä¸­ï¼Œä¸Šä¸‹æ–‡åœ¨DXå¯„å­˜å™¨ä¸­ã€‚ CALL R12 # è°ƒç”¨ goexit0(g)ï¼Œè¿™é‡Œã€æ°¸ä¸ä¼šè¿”å›ã€‘ POPQ AX JMP\truntimeÂ·badmcall2(SB) RET goexit0() åœ¨g0ä¸Šç»§ç»­æ‰§è¡Œgoexit0()ã€‚å‚æ•°ï¼šgp *gï¼Œå½“å‰è¿è¡Œå®Œçš„æ™®é€šçš„goroutineã€‚ ä»g2æ ˆåˆ‡æ¢åˆ°g0æ ˆä¹‹åï¼Œä¸‹é¢å¼€å§‹åœ¨g0æ ˆæ‰§è¡Œgoexit0()å‡½æ•°ï¼Œè¯¥å‡½æ•°å®Œæˆæœ€åçš„æ¸…ç†å·¥ä½œï¼š æŠŠgçš„çŠ¶æ€ä»_Grunningå˜æ›´ä¸º_Gdeadã€‚ ç„¶åæŠŠgçš„ä¸€äº›å­—æ®µæ¸…ç©ºæˆé›¶å€¼ã€‚ è°ƒç”¨dropgå‡½æ•°è§£é™¤gå’Œmä¹‹é—´çš„å…³ç³»ï¼Œå…¶å®å°±æ˜¯è®¾ç½® g-\u0026gt;m = nil,m-\u0026gt;currg = nilã€‚ æŠŠgæ”¾å…¥pçš„freegé˜Ÿåˆ—ç¼“å­˜èµ·æ¥ä¾›ä¸‹æ¬¡åˆ›å»ºgæ—¶å¿«é€Ÿè·å–è€Œä¸ç”¨ä»å†…å­˜åˆ†é…ã€‚freegå°±æ˜¯gçš„ä¸€ä¸ªå¯¹è±¡æ± ã€‚ è°ƒç”¨schedule()å‡½æ•°å†æ¬¡è¿›è¡Œè°ƒåº¦ã€‚ æ–‡ä»¶ä½ç½®ï¼šgo1.19.3/src/runtime/runtime/proc.goã€‚ 3479 3480 3481 3482 3483 3484 3485 3486 3487 3488 3489 3490 3491 3492 3493 3494 3495 3496 3497 3498 3499 3500 3501 3502 3503 3504 3505 3506 3507 3508 3509 3510 3511 3512 3513 3514 3515 3516 3517 3518 3519 3520 3521 3522 3523 3524 3525 3526 3527 3528 3529 3530 3531 3532 3533 3534 3535 3536 3537 3538 3539 3540 3541 3542 3543 3544 3545 3546 3547 3548 3549 3550 3551 3552 3553 3554 3555 3556 3557 3558 3559 3560 3561 3562 3563 3564 3565 // goexit continuation on g0. func goexit0(gp *g) { _g_ := getg() // _g_ = g0 _p_ := _g_.m.p.ptr() // _p_ = g0.m.p // _Grunningï¼š2 è¡¨ç¤ºè¿™ä¸ª goroutine å¯ä»¥æ‰§è¡Œç”¨æˆ·ä»£ç ã€‚ å †æ ˆç”±è¿™ä¸ª goroutine æ‹¥æœ‰ã€‚ // å®ƒä¸åœ¨è¿è¡Œé˜Ÿåˆ—ä¸­ã€‚å®ƒè¢«åˆ†é…äº†ä¸€ä¸ª M å’Œä¸€ä¸ª Pï¼ˆg.m å’Œ g.m.p æ˜¯æœ‰æ•ˆçš„ï¼‰ // _Gdeadï¼š6 è¡¨ç¤ºè¿™ä¸ª goroutine å½“å‰æœªè¢«ä½¿ç”¨ï¼Œå®ƒå¯èƒ½åˆšåˆšé€€å‡ºï¼Œåœ¨ç©ºé—²åˆ—è¡¨ä¸­ï¼Œæˆ–è€…åˆšåˆšè¢«åˆå§‹åŒ– casgstatus(gp, _Grunning, _Gdead) // gé©¬ä¸Šé€€å‡ºï¼Œæ‰€ä»¥è®¾ç½®å…¶çŠ¶æ€ä¸º_Gdead gcController.addScannableStack(_p_, -int64(gp.stack.hi-gp.stack.lo)) // å·²åˆ†é…æ ˆæ€»é‡ // sSystemGoroutine æŠ¥å‘Šåœ¨å †æ ˆè½¬å‚¨å’Œæ­»é”æ£€æµ‹å™¨ä¸­æ˜¯å¦å¿…é¡»çœç•¥ goroutine g // è¿™æ˜¯åœ¨ runtime.* å…¥å£ç‚¹å¯åŠ¨çš„ä»»ä½• goroutineï¼Œé™¤äº† runtime.mainã€runtime.handleAsyncEvent // ï¼ˆä»…é™ wasmï¼‰å’Œæœ‰æ—¶ runtime.runfinq // å¦‚æœ fixed ä¸ºçœŸï¼Œä»»ä½•å¯ä»¥åœ¨ç”¨æˆ·å’Œç³»ç»Ÿä¹‹é—´å˜åŒ–çš„ goroutineï¼ˆå³ç»ˆç»“å™¨ goroutineï¼‰éƒ½è¢«è®¤ä¸ºæ˜¯ç”¨æˆ· goroutine if isSystemGoroutine(gp, false) { atomic.Xadd(\u0026amp;sched.ngsys, -1) // sched.ngsys è®°å½•ç³»ç»Ÿgoroutineçš„æ•°é‡ } // æ¸…ç©ºgä¿å­˜çš„ä¸€äº›ä¿¡æ¯ gp.m = nil // lockedm å…³è”åˆ°ä¸å½“å‰Gç»‘å®šçš„Mï¼Œå¯ä»¥å‚è€ƒä¸‹ LockOSThreadã€‚ locked := gp.lockedm != 0 gp.lockedm = 0 _g_.m.lockedg = 0 gp.preemptStop = false gp.paniconfault = false gp._defer = nil // should be true already but just in case. gp._panic = nil // non-nil for Goexit during panic. points at stack-allocated data. gp.writebuf = nil gp.waitreason = 0 gp.param = nil gp.labels = nil gp.timer = nil // gcBlackenEnabledï¼šè¡¨ç¤ºè¾…åŠ©åŠ©æ‰‹å’Œåå°æ ‡è®°çº¿ç¨‹å…è®¸å°†å¯¹è±¡ç½®ä¸ºé»‘è‰²; // gcAssistBytesï¼šè¡¨ç¤ºå½“å‰goroutineè¿˜æœ‰ä¿¡ç”¨å€¼ã€‚ï¼ˆGCç›¸å…³ï¼‰ if gcBlackenEnabled != 0 \u0026amp;\u0026amp; gp.gcAssistBytes \u0026gt; 0 { // Flush assist credit to the global pool. This gives // better information to pacing if the application is // rapidly creating an exiting goroutines. assistWorkPerByte := gcController.assistWorkPerByte.Load() scanCredit := int64(assistWorkPerByte * float64(gp.gcAssistBytes)) atomic.Xaddint64(\u0026amp;gcController.bgScanCredit, scanCredit) gp.gcAssistBytes = 0 } // g2-\u0026gt;m = nil, m-\u0026gt;currg = nil è§£ç»‘gå’Œmä¹‹å…³ç³» // m-\u0026gt;currgè®°å½•ç€å‰ä¸€ä¸ªgä¿¡æ¯ // func dropg() { // _g_ := getg() // _g_ = g0 // setMNoWB(\u0026amp;_g_.m.curg.m, nil) // g2-\u0026gt;m = nil // setGNoWB(\u0026amp;_g_.m.curg, nil) // m-\u0026gt;currg = nil // } // // func setMNoWB(mp **m, new *m) { // (*muintptr)(unsafe.Pointer(mp)).set(new) // } dropg() // è§£ç»‘gpçš„må’Œå½“å‰m.currgå€¼ if GOARCH == \u0026#34;wasm\u0026#34; { // no threads yet on wasm gfput(_p_, gp) schedule() // never returns } // lockedInt å†…éƒ¨lockOSThreadçš„è·Ÿè¸ª if _g_.m.lockedInt != 0 { print(\u0026#34;invalid m-\u0026gt;lockedInt = \u0026#34;, _g_.m.lockedInt, \u0026#34;\\n\u0026#34;) throw(\u0026#34;internal lockOSThread error\u0026#34;) } // go keyword æ–‡æ¡£å…³äº gfput å’Œ gfget å‡½æ•°æ³¨è§£ã€‚ gfput(_p_, gp) // g2æ”¾å…¥pçš„freegé˜Ÿåˆ—ï¼Œæ–¹ä¾¿ä¸‹æ¬¡é‡ç”¨ï¼Œå…å¾—å†å»ç”³è¯·å†…å­˜ï¼Œæé«˜æ•ˆç‡ if locked { // The goroutine may have locked this thread because // it put it in an unusual kernel state. Kill it // rather than returning it to the thread pool. // Return to mstart, which will release the P and exit // the thread. if GOOS != \u0026#34;plan9\u0026#34; { // See golang.org/issue/22227. gogo(\u0026amp;_g_.m.g0.sched) } else { // Clear lockedExt on plan9 since we may end up re-using // this thread. _g_.m.lockedExt = 0 } } schedule() // ä¸‹é¢å†æ¬¡è°ƒç”¨schedule } ","permalink":"https://heliu.site/posts/golang/goroutine/user/","summary":"Golang user goroutine ä»‹ç»ã€‚","title":"user goroutine"},{"content":" æœ¬ç¯‡ä»‹ç»ã€ŠGo æ‰§è¡Œæµç¨‹ã€‹ä¸­ï¼Œå…³äºruntimeÂ·mainPC(SB)è¿™ä¸ªå‡½æ•°çš„ç›¸å…³å†…å®¹ã€‚ runtimeÂ·mainPC(SB) è¯¥å‡½æ•°æ˜¯ä¸»çº¿ç¨‹goroutineæ³¨å†Œçš„å‡½æ•°ï¼Œé¦–å…ˆä¼šè¢«å”¤èµ·æ‰§è¡Œã€‚ ä¹Ÿæ˜¯runtime.gogo()å‡½æ•°åˆ‡æ¢æ ˆå’Œä»£ç åœ°å€è·³è½¬è€Œæ¥ã€‚ æ–‡ä»¶ä½ç½®ï¼šgo1.19.3/src/runtime/proc.goã€‚ 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 // The main goroutine. func main() { g := getg()\t// goroutine -\u0026gt; runtime.main // Racectx of m0-\u0026gt;g0 is used only as the parent of the main goroutine. // It must not be used for anything else. // // m0-\u0026gt;g0 çš„ Racectx ä»…ç”¨ä½œä¸» goroutine çš„çˆ¶çº§ // å®ƒä¸èƒ½ç”¨äºå…¶ä»–ä»»ä½•äº‹æƒ…ï¼Œä»…ä»…ç”±äºæ ‡è¯† g.m.g0.racectx = 0 // 0 è¡¨ç¤ºä¸»goroutime // Max stack size is 1 GB on 64-bit, 250 MB on 32-bit. // Using decimal instead of binary GB and MB because // they look nicer in the stack overflow failure message. // // æœ€å¤§æ ˆå¤§å°åœ¨ 64 ä½ä¸Šä¸º 1 GBï¼Œåœ¨ 32 ä½ä¸Šä¸º 250 MBã€‚ // ä½¿ç”¨åè¿›åˆ¶è€Œä¸æ˜¯äºŒè¿›åˆ¶ GB å’Œ MBï¼Œå› ä¸ºå®ƒä»¬åœ¨æ ˆæº¢å‡ºå¤±è´¥æ¶ˆæ¯ä¸­çœ‹èµ·æ¥æ›´å¥½ã€‚ if goarch.PtrSize == 8 { // maxstacksize æ˜¯å•ä¸ªgoroutineæ ˆå¤§å°çš„æœ€å¤§ä¸Šé™å€¼ã€‚[2KB,1GB] maxstacksize = 1000000000 } else { maxstacksize = 250000000 } // An upper limit for max stack size. Used to avoid random crashes // after calling SetMaxStack and trying to allocate a stack that is too big, // since stackalloc works with 32-bit sizes. // // æ ˆå¤§å°çš„ä¸Šé™ã€‚ç”¨äºé¿å…åœ¨è°ƒç”¨SetMaxStackå¹¶è¯•å›¾åˆ†é…è¿‡å¤§çš„æ ˆä¹‹åçš„éšæœºå´©æºƒï¼Œå› ä¸ºstackallocå¯ä»¥å¤„ç†32ä½å¤§å°çš„æ ˆã€‚ // ç”¨äºåˆ¤æ–­å•ä¸ªgoroutineæ ˆå¤§å°ä¸Šé™ã€‚åœ¨newstack()å‡½æ•°ä¸­è¢«ä½¿ç”¨ã€‚ maxstackceiling = 2 * maxstacksize // Allow newproc to start new Ms. // // æ ‡è®°ä¸»çº¿ç¨‹runtime.mainå·²å¯åŠ¨ï¼Œå…è®¸ newproc å¯åŠ¨æ–°çš„Mã€‚ mainStarted = true // ã€åˆ›å»ºç›‘æ§çº¿ç¨‹ã€‘ï¼Œè¯¥çº¿ç¨‹ç‹¬ç«‹äºè°ƒåº¦å™¨ä¹‹å¤–ï¼Œä¸éœ€è¦è·ŸPå…³è”ã€‚ // wasmä¸Šè¿˜æ²¡æœ‰çº¿ç¨‹ï¼Œæ‰€ä»¥æ²¡æœ‰sysmonã€‚ if GOARCH != \u0026#34;wasm\u0026#34; { // no threads on wasm yet, so no sysmon // åˆ‡æ¢åˆ°g0æ ˆæ‰§è¡Œnewmå‡½æ•°åˆ›å»ºç›‘æ§çº¿ç¨‹sysmonã€‚ systemstack(func() { newm(sysmon, nil, -1) }) } // Lock the main goroutine onto this, the main OS thread, // during initialization. Most programs won\u0026#39;t care, but a few // do require certain calls to be made by the main thread. // Those can arrange for main.main to run in the main thread // by calling runtime.LockOSThread during initialization // to preserve the lock. // // åœ¨åˆå§‹åŒ–æœŸé—´ï¼Œå°†main goroutineé”å®šåˆ°è¿™ä¸ªä¸»æ“ä½œç³»ç»Ÿçº¿ç¨‹ä¸Šã€‚ // å¤§å¤šæ•°ç¨‹åºä¸ä¼šåœ¨æ„ï¼Œä½†æœ‰ä¸€äº›ç¡®å®éœ€è¦mainçº¿ç¨‹è¿›è¡ŒæŸäº›è°ƒç”¨ã€‚ // å®ƒä»¬å¯ä»¥é€šè¿‡è°ƒç”¨runtimeæ¥å®‰æ’main.mainåœ¨ä¸»çº¿ç¨‹ä¸­è¿è¡Œã€‚LockOSThreadåœ¨åˆå§‹åŒ–æœŸé—´ä¿å­˜é”ã€‚ lockOSThread() // runtime.mainåˆå§‹åŒ–æ—¶åªæœ‰m0è¿™ä¸ªçº¿ç¨‹ if g.m != \u0026amp;m0 { throw(\u0026#34;runtime.main not on m0\u0026#34;) } // Record when the world started. // Must be before doInit for tracing init. // // runtimeInitTime æ˜¯è¿è¡Œæ—¶å¼€å§‹çš„nanotime()ã€‚ // è®°å½•the world startedå¼€å§‹æ—¶é—´ã€‚ // å¦‚æœè¦è·Ÿè¸ªinitï¼Œå¿…é¡»åœ¨doInitä¹‹å‰ã€‚ runtimeInitTime = nanotime() if runtimeInitTime == 0 { throw(\u0026#34;nanotime returning zero\u0026#34;) } if debug.inittrace != 0 { inittrace.id = getg().goid inittrace.active = true } // åˆå§‹åŒ–ä¸ºruntimeåŒ…å®Œæˆçš„ä¸€ç»„åˆå§‹åŒ–ï¼Œæ‰§è¡ŒruntimeåŒ…ä¸­æ‰€æœ‰çš„initå‡½æ•°ã€‚ // å¿…é¡»åœ¨deferä¹‹å‰ã€‚é€’å½’è°ƒç”¨runtimeåŒ…çš„ç›¸å…³init()å‡½æ•°ã€‚ doInit(\u0026amp;runtime_inittask) // Must be before defer. // Defer unlock so that runtime.Goexit during init does the unlock too. // // å»¶è¿Ÿè§£é”ï¼Œä»¥ä¾¿ runtime.Goexit åœ¨ init æœŸé—´ä¹Ÿè¿›è¡Œè§£é” needUnlock := true\t// æ ‡è®°å½“å‰ä¸»çº¿ç¨‹è¿˜æœªè¢«è§£é”ï¼Œmainå‡½æ•°é€€å‡ºäº†éœ€è¦æ‰§è¡Œdeferè§£é” defer func() { if needUnlock { unlockOSThread() } }() // åˆ›å»ºGCç›¸å…³çš„æ‰«æå™¨å’Œæ¸…ç†å™¨ã€‚ gcenable() // æ¸…æ‰«åç¨‹ï¼Œå‚çœ‹GCç›¸å…³ // main_init_done æ˜¯ cgocallbackg ä½¿ç”¨çš„ä¸€ä¸ªä¿¡å·ï¼Œè¡¨æ˜åˆå§‹åŒ–å·²ç»å®Œæˆ // å®ƒæ˜¯åœ¨ _cgo_notify_runtime_init_done ä¹‹å‰å®Œæˆçš„ï¼Œæ‰€ä»¥æ‰€æœ‰çš„ cgo è°ƒç”¨éƒ½å¯ä»¥ä¾èµ–å®ƒå­˜åœ¨ // å½“ main_init å®Œæˆæ—¶ï¼Œå®ƒè¢«å…³é—­ï¼Œè¿™æ„å‘³ç€ cgocallbackg å¯ä»¥å¯é åœ°ä»ä¸­æ¥æ”¶ main_init_done = make(chan bool) if iscgo { if _cgo_thread_start == nil { throw(\u0026#34;_cgo_thread_start missing\u0026#34;) } if GOOS != \u0026#34;windows\u0026#34; { if _cgo_setenv == nil { throw(\u0026#34;_cgo_setenv missing\u0026#34;) } if _cgo_unsetenv == nil { throw(\u0026#34;_cgo_unsetenv missing\u0026#34;) } } if _cgo_notify_runtime_init_done == nil { throw(\u0026#34;_cgo_notify_runtime_init_done missing\u0026#34;) } // Start the template thread in case we enter Go from // a C-created thread and need to create a new thread. startTemplateThread() cgocall(_cgo_notify_runtime_init_done, nil) } // é€’å½’è°ƒç”¨mainåŒ…ç›¸å…³å¼•ç”¨åŒ…çš„init()å‡½æ•° doInit(\u0026amp;main_inittask) // Disable init tracing after main init done to avoid overhead // of collecting statistics in malloc and newproc // // åœ¨ä¸»åˆå§‹åŒ–å®Œæˆåç¦ç”¨åˆå§‹åŒ–è·Ÿè¸ªä»¥é¿å…åœ¨ malloc å’Œ newproc ä¸­æ”¶é›†ç»Ÿè®¡ä¿¡æ¯çš„å¼€é”€ inittrace.active = false close(main_init_done)\t// å…³é—­main_init_doneï¼Œæ­¤æ—¶åœ¨main_init_doneä¸Šé¢çš„goroutineå°†è¢«æ‰§è¡Œ needUnlock = false\t// æ ‡è®°å½“å‰ä¸»çº¿ç¨‹OSå·²è¢«è§£é” unlockOSThread()\t// è§£é”ä¸»çº¿ç¨‹ if isarchive || islibrary { // A program compiled with -buildmode=c-archive or c-shared // has a main, but it is not executed. // ä½¿ç”¨ -buildmode=c-archive æˆ– c-shared ç¼–è¯‘çš„ç¨‹åºæœ‰ä¸€ä¸ª mainï¼Œä½†å®ƒä¸ä¼šè¢«æ‰§è¡Œ return } // è¿›è¡Œé—´æ¥è°ƒç”¨ï¼Œå› ä¸ºé“¾æ¥å™¨åœ¨æ”¾ç½®è¿è¡Œæ—¶æ—¶ä¸çŸ¥é“ä¸»åŒ…çš„åœ°å€ // main.mainå‡½æ•°æ˜¯æˆ‘ä»¬ä¸»åŒ…çš„åœ°å€æ‰€åœ¨ fn := main_main // make an indirect call, as the linker doesn\u0026#39;t know the address of the main package when laying down the runtime fn() // è¿›å…¥main.mainå¼€å§‹æ‰§è¡Œä»£ç  if raceenabled { racefini() } // Make racy client program work: if panicking on // another goroutine at the same time as main returns, // let the other goroutine finish printing the panic trace. // Once it does, it will exit. See issues 3934 and 20018. // // è®©racyå®¢æˆ·ç«¯ç¨‹åºå·¥ä½œï¼šå¦‚æœåœ¨mainè¿”å›çš„åŒæ—¶åœ¨å¦ä¸€ä¸ªgoroutineä¸Špaincï¼Œè®©å¦ä¸€ä¸ªgoroutineå®Œæˆæ‰“å°paincè·Ÿè¸ª if atomic.Load(\u0026amp;runningPanicDefers) != 0 { // Running deferred functions should not take long. for c := 0; c \u0026lt; 1000; c++ { if atomic.Load(\u0026amp;runningPanicDefers) == 0 { break } Gosched() } } if atomic.Load(\u0026amp;panicking) != 0 { gopark(nil, nil, waitReasonPanicWait, traceEvGoStop, 1) } // è¿›å…¥ç³»ç»Ÿè°ƒç”¨ï¼Œé€€å‡ºè¿›ç¨‹ï¼Œå¯ä»¥çœ‹å‡ºmain goroutineå¹¶æœªè¿”å›ï¼Œè€Œæ˜¯ç›´æ¥è¿›å…¥ç³»ç»Ÿè°ƒç”¨é€€å‡ºè¿›ç¨‹äº† exit(0) // ä¿æŠ¤æ€§ä»£ç ï¼Œå¦‚æœexitæ„å¤–è¿”å›ï¼Œä¸‹é¢çš„ä»£ç ä¹Ÿä¼šè®©è¯¥è¿›ç¨‹crashæ­»æ‰ for { var x *int32\t// è¿™é‡Œä¸ºnil *x = 0\t// ç»™ä¸€ä¸ªä¸å­˜åœ¨çš„åœ°å€èµ‹å€¼ï¼Œä¼šå‡ºé”™çš„ } } lockOSThread() æ–‡ä»¶ä½ç½®ï¼šgo1.19.3/src/runtime/proc.goã€‚ 4416 4417 4418 4419 4420 //go:nosplit func lockOSThread() { getg().m.lockedInt++ dolockOSThread() } dolockOSThread() ä¸‹é¢çš„LockOSThreadå’ŒlockOSThreadåœ¨ä¿®æ”¹m.lockedåè°ƒç”¨dolockOSThread()ã€‚ åœ¨è¿™ä¸ªè°ƒç”¨æœŸé—´ä¸å…è®¸æŠ¢å ï¼Œå¦åˆ™è¿™ä¸ªå‡½æ•°ä¸­çš„må¯èƒ½ä¸è°ƒç”¨è€…ä¸­çš„mä¸åŒã€‚ æ–‡ä»¶ä½ç½®ï¼šgo1.19.3/src/runtime/proc.goã€‚ 4370 4371 4372 4373 4374 4375 4376 4377 4378 4379 4380 4381 4382 // dolockOSThread is called by LockOSThread and lockOSThread below // after they modify m.locked. Do not allow preemption during this call, // or else the m might be different in this function than in the caller. // //go:nosplit func dolockOSThread() { if GOARCH == \u0026#34;wasm\u0026#34; { return // no threads on wasm yet } _g_ := getg() _g_.m.lockedg.set(_g_) _g_.lockedm.set(_g_.m) } unlockOSThread() æ–‡ä»¶ä½ç½®ï¼šgo1.19.3/src/runtime/proc.goã€‚ 4462 4463 4464 4465 4466 4467 4468 4469 4470 4471 //go:nosplit func unlockOSThread() { _g_ := getg() // æ²¡æœ‰åŠ é”æ—¶è§£é”ã€‚ if _g_.m.lockedInt == 0 { systemstack(badunlockosthread) } _g_.m.lockedInt-- dounlockOSThread() } dounlockOSThread() æ–‡ä»¶ä½ç½®ï¼šgo1.19.3/src/runtime/proc.goã€‚ 4422 4423 4424 4425 4426 4427 4428 4429 4430 4431 4432 4433 4434 4435 4436 4437 // dounlockOSThread is called by UnlockOSThread and unlockOSThread below // after they update m-\u0026gt;locked. Do not allow preemption during this call, // or else the m might be in different in this function than in the caller. // //go:nosplit func dounlockOSThread() { if GOARCH == \u0026#34;wasm\u0026#34; { return // no threads on wasm yet } _g_ := getg() if _g_.m.lockedInt != 0 || _g_.m.lockedExt != 0 { return } _g_.m.lockedg = 0 _g_.lockedm = 0 } doInit() type initTask struct initTaskè¡¨ç¤ºéœ€è¦ä¸ºåŒ…æ‰§è¡Œçš„åˆå§‹åŒ–é›†åˆã€‚ ä¸../../test/initempty.go:initTaskä¿æŒåŒæ­¥ã€‚ æ–‡ä»¶ä½ç½®ï¼šgo1.19.3/src/runtime/proc.goã€‚ 6272 6273 6274 6275 6276 6277 6278 6279 6280 6281 6282 6283 6284 6285 6286 6287 6288 // An initTask represents the set of initializations that need to be done for a package. // Keep in sync with ../../test/initempty.go:initTask type initTask struct { // TODO: pack the first 3 fields more tightly? // // å°†å‰3ä¸ªå­—æ®µå°è£…å¾—æ›´ç´§å¯†? // stateï¼š0 æœªåˆå§‹åŒ–ï¼›1 åˆå§‹åŒ–ä¸­ï¼›2 å·²åˆå§‹åŒ– state uintptr // 0 = uninitialized, 1 = in progress, 2 = done ndeps uintptr // å½“å‰åŒ…ä¾èµ–å‡ ä¸ªåŒ… nfns uintptr // å½“å‰åŒ…æœ‰å‡ ä¸ªinitå‡½æ•° // followed by ndeps instances of an *initTask, one per package depended on // followed by nfns pcs, one per init function to run // // ç„¶åæ˜¯*initTaskçš„ndepså®ä¾‹ï¼Œæ¯ä¸ªåŒ…ä¾èµ–äºä¸€ä¸ªnfns pcsï¼Œæ¯ä¸ªinitå‡½æ•°è¿è¡Œä¸€ä¸ª // ndeps ä¸ª *initTask // æŒ‡å‘å½“å‰åŒ…ç»“æ„çš„é‚£äº›åŒ…çš„initTask // nfns ä¸ª func() // å½“å‰åŒ…çš„é‚£äº›initå‡½æ•° } ç»“æ„å›¾ï¼šä¸€ä¸ªinitTaskå°±æ˜¯ä¸€ä¸ªåŒ…ç»“æ„ã€‚ [ndeps]*initTaskï¼šåŒ…å«å½“å‰åŒ…å¼•ç”¨çš„å…¶ä»–åŒ…ç»“æ„ã€‚ [nfns]func()ï¼šè¡¨ç¤ºå½“å‰åŒ…å®šä¹‰çš„æ‰€æœ‰init()å‡½æ•°ã€‚ runtime.mainå‡½æ•°ä¸­ä¼šé€’å½’ä»æœ€åè°ƒç”¨init()å‡½æ•°ã€‚ åŒ…åˆå§‹åŒ–ï¼Œé™æ€åˆå§‹åŒ–ã€éé™æ€åˆå§‹åŒ–ã€‚ é™æ€åˆå§‹åŒ–ï¼šåŒ…çº§åˆ«å˜é‡çš„åˆå§‹åŒ–å·¥ä½œåº”è¯¥åœ¨ç¨‹åºä»£ç å¼€å§‹ä½¿ç”¨è¿™äº›å˜é‡å‰å®Œæˆï¼Œå‚çœ‹åŒ…åˆå§‹åŒ–æ–‡æ¡£ã€‚ éé™æ€åˆå§‹åŒ–ï¼šåŒ…çº§åˆ«å˜é‡mçš„åˆå§‹å€¼éœ€è¦è¿›è¡Œå‡½æ•°è°ƒç”¨ï¼Œå¹¶ä¸æ˜¯ä¸€ä¸ªèƒ½å¤Ÿè¢«ç¼–è¯‘å™¨åœ¨ç¼–è¯‘é˜¶æ®µæ±‚å€¼çš„è¡¨è¾¾å¼æ—¶ã€‚ doInit()å‡½æ•°ï¼šåªæ˜¯æ‰§è¡Œæ³¨å†ŒåŒ…çš„init()å‡½æ•°ä½œç”¨ã€‚ æ–‡ä»¶ä½ç½®ï¼šgo1.19.3/src/runtime/proc.goã€‚ 6294 6295 6296 6297 6298 6299 6300 6301 6302 6303 6304 6305 6306 6307 6308 6309 6310 6311 6312 6313 6314 6315 6316 6317 6318 6319 6320 6321 6322 6323 6324 6325 6326 6327 6328 6329 6330 6331 6332 6333 6334 6335 6336 6337 6338 6339 6340 6341 6342 6343 6344 6345 6346 6347 6348 6349 6350 6351 6352 6353 6354 6355 6356 6357 6358 6359 6360 6361 6362 6363 6364 func doInit(t *initTask) { switch t.state { // å·²åˆå§‹åŒ– case 2: // fully initialized return // æ­£åœ¨åˆå§‹åŒ–ä¸­ case 1: // initialization in progress\tthrow(\u0026#34;recursive call during initialization - linker skew\u0026#34;) // æ²¡æœ‰åˆå§‹åŒ– default: // not initialized yet\t// æ ‡è®°å½“å‰åŒ…æ­£åœ¨åˆå§‹åŒ–ä¸­ t.state = 1 // initialization in progress // éå†å½“å‰åŒ…ä¾èµ–çš„åŒ…ï¼Œt.ndepsè®°å½•çš„ä¾èµ–çš„åŒ…æ•°é‡ for i := uintptr(0); i \u0026lt; t.ndeps; i++ { // åç§»åˆ°æŒ‡å®šä½ç½®ï¼Œè·å–åˆ°ndepsä½ç½®çš„*initTaskæ•°æ® // 3*goarch.PtrSize è¡¨ç¤ºå‰stateã€ndepsã€nfnsæ‰€å çš„å†…å­˜å¤§å° p := add(unsafe.Pointer(t), (3+i)*goarch.PtrSize) // 64ä½å 8å­—èŠ‚ t2 := *(**initTask)(p) // *initTask // è¿™é‡Œä¹Ÿæ˜¯å¯¼è‡´ä»æœ€å†…å±‚çš„åŒ…å¼€å§‹å€’å™æ‰§è¡Œåˆå§‹åŒ–çš„åŸå›  doInit(t2) // é€’å½’ } // å¦‚æœå½“å‰åŒ…æ²¡æœ‰initå‡½æ•°ï¼Œç›´æ¥æŠŠåŒ…æ ‡è®°æˆ2å·²å®Œæˆå¹¶ç›´æ¥è¿”å› if t.nfns == 0 { t.state = 2 // initialization done return } var ( start int64 // è°ƒè¯•æ¨¡å¼æƒ…å†µä½¿ç”¨ï¼Œè®°å½•å¼€å§‹æ—¶é—´ before tracestat ) if inittrace.active { start = nanotime() // Load stats non-atomically since tracinit is updated only by this init goroutine. before = inittrace } // åç§»åˆ°initå‡½æ•°çš„åœ°å€å¤„ firstFunc := add(unsafe.Pointer(t), (3+t.ndeps)*goarch.PtrSize) // éå†å¹¶æ‰§è¡ŒåŒ…æ³¨å†Œçš„initå‡½æ•°ï¼ŒåŒä¸€ä¸ªåŒ…çš„ä¸åŒgoæ–‡ä»¶ä¸­initå‡½æ•°æ‰§è¡Œæ—¶æ˜¯æ— åºçš„ for i := uintptr(0); i \u0026lt; t.nfns; i++ { p := add(firstFunc, i*goarch.PtrSize) // åç§»åˆ°initå‡½æ•°ä½ç½® f := *(*func())(unsafe.Pointer(\u0026amp;p))\t// func() f()\t// æ‰§è¡Œinitå‡½æ•° } // è°ƒè¯•æ¨¡å¼ä¸‹ æ‰“å°ç›¸å…³å‚æ•° if inittrace.active { end := nanotime() // Load stats non-atomically since tracinit is updated only by this init goroutine. after := inittrace f := *(*func())(unsafe.Pointer(\u0026amp;firstFunc)) pkg := funcpkgpath(findfunc(abi.FuncPCABIInternal(f))) var sbuf [24]byte print(\u0026#34;init \u0026#34;, pkg, \u0026#34; @\u0026#34;) print(string(fmtNSAsMS(sbuf[:], uint64(start-runtimeInitTime))), \u0026#34; ms, \u0026#34;) print(string(fmtNSAsMS(sbuf[:], uint64(end-start))), \u0026#34; ms clock, \u0026#34;) print(string(itoa(sbuf[:], after.bytes-before.bytes)), \u0026#34; bytes, \u0026#34;) print(string(itoa(sbuf[:], after.allocs-before.allocs)), \u0026#34; allocs\u0026#34;) print(\u0026#34;\\n\u0026#34;) } // æ ‡è®°å½“å‰åŒ…å·²åˆå§‹åŒ–å®Œæˆ t.state = 2 // initialization done } } gcenable() gcenableåœ¨runtimeåˆå§‹åŒ–ä¹‹åè¢«è°ƒç”¨ï¼Œåœ¨æˆ‘ä»¬å‡†å¤‡è®©ç”¨æˆ·ä»£ç è¿è¡Œä¹‹å‰è¢«è°ƒç”¨ã€‚ å®ƒå¯åŠ¨ background sweeper goroutineï¼Œä»¥åŠ background scavenger goroutineï¼Œå¹¶å¯åŠ¨GCã€‚ æ–‡ä»¶ä½ç½®ï¼šgo1.19.3/src/runtime/mgc.goã€‚ æ›´è¯¦æƒ…ä»‹ç»å‚çœ‹GCç¯‡æ–‡ç« ã€‚ 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 // gcenable is called after the bulk of the runtime initialization, // just before we\u0026#39;re about to start letting user code run. // It kicks off the background sweeper goroutine, the background // scavenger goroutine, and enables GC. func gcenable() { // Kick off sweeping and scavenging. // å¯åŠ¨ sweeping å’Œ scavengingã€‚ c := make(chan int, 2) // æœ‰ç¼“å†²2 go bgsweep(c) // æ‰«æ go bgscavenge(c) // æ¸…æ‰« // ç­‰å¾…è¿™ä¸¤ä¸ªgoroutineè¿è¡Œèµ·æ¥ã€‚ \u0026lt;-c \u0026lt;-c // ç°åœ¨è¿è¡Œæ—¶å·²ç»åˆå§‹åŒ–ï¼ŒGCå°±å¯ä»¥äº†ã€‚ memstats.enablegc = true // now that runtime is initialized, GC is okay } bgsweep() æ–‡ä»¶ä½ç½®ï¼šgo1.19.3/src/runtime/mgcsweep.goã€‚ 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 func bgsweep(c chan int) { sweep.g = getg() // sweep g // åˆå§‹åŒ–é”æ’å lockInit(\u0026amp;sweep.lock, lockRankSweep) lock(\u0026amp;sweep.lock) // mutex lock sweep.parked = true c \u0026lt;- 1 // é€šçŸ¥ gcenable å‡½æ•°è§£é™¤é˜»å¡ // è°ƒç¦»CPU goparkunlock(\u0026amp;sweep.lock, waitReasonGCSweepWait, traceEvGoBlock, 1) for { for sweepone() != ^uintptr(0) { sweep.nbgsweep++ Gosched() } for freeSomeWbufs(true) { Gosched() } lock(\u0026amp;sweep.lock) if !isSweepDone() { // This can happen if a GC runs between // gosweepone returning ^0 above // and the lock being acquired. unlock(\u0026amp;sweep.lock) continue } sweep.parked = true goparkunlock(\u0026amp;sweep.lock, waitReasonGCSweepWait, traceEvGoBlock, 1) } } bgscavenge() åå°æ¸…æ‰«å™¨ã€‚åå°æ¸…æ‰«ç¨‹åºåœ¨mheapç»“æ„ä½“ä¸­æ¯”ä¾‹æ¸…é™¤ç»Ÿè®¡ä¿¡æ¯æ‰€æè¿°çš„çº¿ä»¥ä¸‹ç»´æŠ¤åº”ç”¨ç¨‹åºçš„RSSã€‚ æ–‡ä»¶ä½ç½®ï¼šgo1.19.3/src/runtime/mgcscavenge.goã€‚ 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 // Background scavenger. // // The background scavenger maintains the RSS of the application below // the line described by the proportional scavenging statistics in // the mheap struct. func bgscavenge(c chan int) { scavenger.init() // scavenger åˆå§‹åŒ– c \u0026lt;- 1 // é€šçŸ¥ gcenable å‡½æ•°è§£é™¤é˜»å¡ // è°ƒç¦»CPU scavenger.park() for { released, workTime := scavenger.run() if released == 0 { scavenger.park() continue } atomic.Xadduintptr(\u0026amp;mheap_.pages.scav.released, released) scavenger.sleep(workTime) } } ","permalink":"https://heliu.site/posts/golang/goroutine/main/","summary":"Golang runtime.main gorouttine ä»‹ç»ã€‚","title":"main goroutine"},{"content":" æœ¬ç¯‡ä»‹ç»Golangç›¸å…³è°ƒåº¦ä»£ç ï¼Œæœ¬ç¯‡ä¹Ÿæ˜¯ç†è§£GMPæ¨¡å‹çš„é‡ç‚¹ç¯‡èŠ‚ã€‚ runtimeÂ·mstart(SB) å·¥ä½œçº¿ç¨‹Mçš„è‡ªæ—‹çŠ¶æ€(spinning)è§£é‡Šï¼šå·¥ä½œçº¿ç¨‹åœ¨ä»å…¶å®ƒå·¥ä½œçº¿ç¨‹çš„æœ¬åœ°è¿è¡Œé˜Ÿåˆ—ä¸­ç›—å–goroutineæ—¶çš„çŠ¶æ€ç§°ä¸ºè‡ªæ—‹çŠ¶æ€ã€‚\nè¯¥å‡½æ•°æ˜¯æ‰€æœ‰æ–°åˆ›å»ºçš„å·¥ä½œçº¿ç¨‹éœ€è¦æ‰§è¡Œçš„å‡½æ•°ï¼Œä¹Ÿæ˜¯è°ƒåº¦å¾ªç¯çš„å…¥å£å‡½æ•°ã€‚ æ‰€æœ‰ã€æ–°åˆ›å»ºçš„å·¥ä½œçº¿ç¨‹ã€‘å¼€å§‹è¿è¡Œçš„å…¥å£éƒ½æ˜¯ä»è¿™ä¸ªå‡½æ•°å¼€å§‹è¿è¡Œçš„ã€‚ æ–‡ä»¶ä½ç½®ï¼šgo1.19.3/src/runtime/asm_amd64.sã€‚ 389 390 391 392 393 TEXT runtimeÂ·mstart(SB),NOSPLIT|TOPFRAME,$0 # è°ƒç”¨runtime.mstart0å‡½æ•°ï¼Œè¯¥å‡½æ•°æ°¸è¿œä¸ä¼šè¿”å› CALL runtimeÂ·mstart0(SB) # æœªè¾¾åˆ°ã€‚ä¸ä¼šåˆ°è¿™é‡Œæ¥ã€‚ RET # not reached mstart0() mstart0æ˜¯æ–°Msçš„Goå…¥å£ç‚¹ã€‚è¯¥å‡½æ•°æ˜¯ä¸å…è®¸æ ˆå¢é•¿æ£€æŸ¥çš„ï¼Œå› ä¸ºæˆ‘ä»¬ç”šè‡³å¯èƒ½è¿˜æ²¡æœ‰è®¾ç½®å †æ ˆè¾¹ç•Œã€‚ èƒ½åœ¨STWæœŸé—´è¿è¡Œï¼ˆå› ä¸ºå®ƒè¿˜æ²¡æœ‰Pï¼‰ï¼Œæ‰€ä»¥ä¸å…è®¸å†™å±éšœã€‚ åˆå§‹åŒ–g0æ ˆå¤§å°ï¼Œä»¥åŠè°ƒç”¨mstart1()å‡½æ•°å¼€å¯è°ƒåº¦å¾ªç¯ã€‚ å› ä¸ºå¯èƒ½å­˜åœ¨å…¶ä»–åˆšåˆ›å»ºçš„å·¥ä½œçº¿ç¨‹å¹¶æ²¡æœ‰åˆå§‹åŒ–g0æ ˆå¤§å°ï¼Œæ‰€ä»¥è¿™é‡Œéœ€è¦è®¾ç½®ä¸€ä¸‹ã€‚ æ–‡ä»¶ä½ç½®ï¼šgo1.19.3/src/runtime/proc.goã€‚ 1347 1348 1349 1350 1351 1352 1353 1354 1355 1356 1357 1358 1359 1360 1361 1362 1363 1364 1365 1366 1367 1368 1369 1370 1371 1372 1373 1374 1375 1376 1377 1378 1379 1380 1381 1382 1383 1384 1385 1386 1387 1388 1389 1390 1391 1392 1393 1394 1395 1396 1397 1398 1399 1400 1401 1402 1403 1404 1405 1406 1407 1408 1409 1410 1411 1412 1413 1414 1415 1416 1417 1418 1419 1420 1421 1422 1423 1424 1425 1426 1427 1428 // mstart0 is the Go entry-point for new Ms. // This must not split the stack because we may not even have stack // bounds set up yet. // // May run during STW (because it doesn\u0026#39;t have a P yet), so write // barriers are not allowed. // //go:nosplit //go:nowritebarrierrec func mstart0() { // è¯¥å‡½æ•°æ˜¯å·¥ä½œçº¿ç¨‹Mèµ·æ¥æ‰§è¡Œçš„å…¥å£å‡½æ•°ï¼Œè¿™é‡Œä¸€å®šæ˜¯g0æ ˆã€‚ _g_ := getg() // _g_ = g0 // å½“å‰gæ˜¯å¦å·²åˆ†é…æ ˆï¼š // 1. ç¨‹åºåˆšåˆå§‹åŒ–æ—¶å‰é¢æ˜¯åˆ†é…äº†å¤§çº¦64KBå¤§å°æ ˆã€‚ // 2. å¦‚æœæ˜¯é€šè¿‡wakeup()å‡½æ•°åˆ›å»ºçš„å·¥ä½œçº¿ç¨‹ï¼Œè¿™é‡Œå¯èƒ½æ˜¯æ²¡æœ‰åˆ†é…æ ˆå¤§å°çš„ã€‚ osStack := _g_.stack.lo == 0 // åˆ¤æ–­å½“å‰g0æ˜¯å¦åˆ†é…æ ˆ if osStack { // æ ˆæœªåˆ†é…å¤§å°æ—¶ï¼Œè¿™ä¹Ÿæ˜¯æ–°åˆ›å»ºçš„å·¥ä½œçº¿ç¨‹éœ€è¦å¤„ç†çš„gæ ˆæƒ…å†µ // Initialize stack bounds from system stack. // Cgo may have left stack size in stack.hi. // minit may update the stack bounds. // // ä»ç³»ç»Ÿæ ˆåˆå§‹åŒ–æ ˆè¾¹ç•Œã€‚Cgo å¯èƒ½åœ¨ stack.hi ä¸­ç•™ä¸‹äº†æ ˆå¤§å°ã€‚minit å¯èƒ½ä¼šæ›´æ–°æ ˆè¾¹ç•Œã€‚ // // Note: these bounds may not be very accurate. // We set hi to \u0026amp;size, but there are things above // it. The 1024 is supposed to compensate this, // but is somewhat arbitrary. // // æ³¨æ„ï¼šè¿™äº›ç•Œé™å¯èƒ½ä¸æ˜¯å¾ˆå‡†ç¡®ã€‚ // æˆ‘ä»¬å°† hi è®¾ç½®ä¸º \u0026amp;sizeï¼Œä½†æ˜¯ä¸Šé¢è¿˜æœ‰ä¸€äº›ä¸œè¥¿ã€‚ // 1024 åº”è¯¥å¯ä»¥å¼¥è¡¥è¿™ä¸€ç‚¹ï¼Œä½†æœ‰äº›æ­¦æ–­ã€‚ // ä»¥ä¸Šçš„æ„æ€æ˜¯ç›´æ¥åœ¨å½“å‰å·¥ä½œçº¿ç¨‹ç³»ç»Ÿæ ˆä¸Šç»™å½“å‰è¿™ä¸ªg0åˆ†é…æ ˆå¤§å°ã€‚ // å¯èƒ½ä¸Šé¢æœ‰æ ˆæ•°æ®ï¼Œåç§»1024å­—èŠ‚åº”è¯¥èƒ½å¼¥è¡¥è¿™äº›æ•°æ®ã€‚ size := _g_.stack.hi // size å¤šåŠæ˜¯0; size ä¸€å®šæ˜¯åˆ†é…åœ¨å½“å‰æ ˆä¸Šçš„ï¼Œå› æ­¤\u0026amp;sizeå°±æ˜¯æ ˆåœ°å€ã€‚ if size == 0 {\t// sys.StackGuardMultiplier = 1; å¯è§å…¶ä»–å·¥ä½œçº¿ç¨‹çš„g0æ ˆå¤§çº¦ä¸º8KBã€‚ size = 8192 * sys.StackGuardMultiplier // è®¾ç½®sizeä¸ºæŒ‡å®šå€¼ } // noescapeå‡½æ•°å–sizeåœ°å€å¹¶ä¸0å¼‚æˆ–ï¼Œå®é™…ä½œç”¨æ˜¯éšè—(é˜²æ­¢)sizeå˜é‡é€ƒé€¸åˆ†ææŒ‡é’ˆ // é˜²æ­¢ç¼–è¯‘å™¨æŠŠsizeå˜é‡å †åˆ†é…ï¼Œè¿™é‡Œéœ€è¦çš„æ˜¯æ ˆåˆ†é… // å› æ­¤å½“å‰_g_çš„æ ˆå¤‡ä»½åˆ†é…åˆ°å½“å‰æ ˆçš„sizeå˜é‡ä½ç½® // noescapeå‡½æ•°ï¼š // func noescape(p unsafe.Pointer) unsafe.Pointer { // x := uintptr(p) // return unsafe.Pointer(x ^ 0) // é˜²æ­¢å˜é‡xé€ƒé€¸ // } // ä»¥\u0026amp;sizeä¸ºèµ·ç‚¹è®¾ç½®g0æ ˆã€‚g0.stack -\u0026gt; [\u0026amp;size, \u0026amp;size - 8192 + 1024] _g_.stack.hi = uintptr(noescape(unsafe.Pointer(\u0026amp;size))) // hiå­˜å‚¨sizeçš„åœ°å€ï¼Œä¹Ÿå°±æ˜¯rbp _g_.stack.lo = _g_.stack.hi - size + 1024 // loå­˜å‚¨æ ˆé¡¶ä½ç½®ï¼Œä¹Ÿå°±æ˜¯rsp } // Initialize stack guard so that we can start calling regular // Go code. // // åˆå§‹åŒ–æ ˆä¿æŠ¤ï¼Œä»¥ä¾¿æˆ‘ä»¬å¯ä»¥å¼€å§‹è°ƒç”¨å¸¸è§„ Go ä»£ç ã€‚ // stackguard0 = _g_.stack.lo + 928; æ ˆæº¢å‡ºæ£€æŸ¥çš„é˜ˆå€¼ç‚¹ã€‚ _g_.stackguard0 = _g_.stack.lo + _StackGuard // This is the g0, so we can also call go:systemstack // functions, which check stackguard1. // // è¿™æ˜¯ g0ï¼Œæ‰€ä»¥æˆ‘ä»¬ä¹Ÿå¯ä»¥è°ƒç”¨ go:systemstack å‡½æ•°æ¥æ£€æŸ¥ stackguard1ã€‚ _g_.stackguard1 = _g_.stackguard0 mstart1() // è°ƒç”¨mstart1å¼€å¯è°ƒåº¦å¾ªç¯ï¼Œè¯¥å‡½æ•°æ°¸è¿œä¸ä¼šè¿”å› // Exit this thread.\t// // é€€å‡ºè¿™ä¸ªçº¿ç¨‹ï¼Œç¨‹åºä¸ä¼šåˆ°è¿™é‡Œã€‚ if mStackIsSystemAllocated() { // Windows, Solaris, illumos, Darwin, AIX and Plan 9 always system-allocate // the stack, but put it in _g_.stack before mstart, // so the logic above hasn\u0026#39;t set osStack yet. // // Windowsã€Solarisã€illumosã€Darwinã€AIX å’ŒPlan 9 æ€»æ˜¯ç³»ç»Ÿåˆ†é…æ ˆï¼Œä½†æ˜¯åœ¨mstart ä¹‹å‰æ”¾åœ¨_g_.stack ä¸­ï¼Œ // æ‰€ä»¥ä¸Šé¢çš„é€»è¾‘è¿˜æ²¡æœ‰è®¾ç½®osStack osStack = true } mexit(osStack) // ç»“æŸå½“å‰çº¿ç¨‹ã€‚ } æ€»ç»“ï¼šå·¥ä½œçº¿ç¨‹å¼€å§‹æ‰§è¡Œä½¿ï¼Œå…ˆåˆ¤æ–­g0æ˜¯å¦åˆ†é…äº†æ ˆå¤§å°ï¼Œæ²¡æœ‰åˆ™åˆ†é…å¤§çº¦8KBå¤§å°æ ˆç©ºé—´ï¼Œç„¶åè®¾ç½®stackguard0ã€stackguard1ã€‚ mstart1() è®¾ç½®g0è¢«è°ƒåº¦æ—¶çš„è°ƒåº¦ä¿¡æ¯ï¼Œæ¯”å¦‚ä»å“ªé‡Œè¿›å…¥ï¼Œæ ˆä»å“ªé‡Œå¼€å§‹ç­‰ï¼Œä»¥åŠç»™å½“å‰å·¥ä½œçº¿ç¨‹Mç»‘å®šä¸ªPå¹¶å¼€å¯è°ƒåº¦å¾ªç¯ã€‚ è®¾ç½®g0çš„è°ƒåº¦ä¿¡æ¯æ˜¯åœ¨äºï¼Œåœ¨è°ƒåº¦å¾ªç¯è¿‡ç¨‹ä¸­ä¼šåˆ‡æ¢åˆ°g0æ ˆæ‰§è¡Œruntimeçš„ç›¸å…³å‡½æ•°ï¼Œä»¥å…æ ˆæ— é™æ‰©å¤§ã€‚ æ–‡ä»¶ä½ç½®ï¼šgo1.19.3/src/runtime/proc.goã€‚ 1394 1395 1396 1397 1398 1399 1400 1401 1402 1403 1404 1405 1406 1407 1408 1409 1410 1411 1412 1413 1414 1415 1416 1417 1418 1419 1420 1421 1422 1423 1424 1425 1426 1427 1428 1429 1430 1431 1432 1433 1434 1435 1436 1437 1438 1439 1440 1441 1442 1443 1444 1445 1446 1447 1448 1449 1450 1451 1452 1453 1454 1455 1456 1457 1458 1459 // The go:noinline is to guarantee the getcallerpc/getcallersp below are safe, // so that we can set up g0.sched to return to the call of mstart1 above. //go:noinline func mstart1() { _g_ := getg() // _g_ = g0 // å½“å‰_g_ ä¸€å®šæ˜¯g0ï¼Œå› ä¸ºè¯¥å‡½æ•°åªæœ‰ç¨‹åºåˆå§‹åŒ–æˆ–çº¿ç¨‹åˆšå¯åŠ¨æ—¶æ‰ä¼šè°ƒç”¨ã€‚ if _g_ != _g_.m.g0 { throw(\u0026#34;bad runtimeÂ·mstart\u0026#34;) } // Set up m.g0.sched as a label returning to just // after the mstart1 call in mstart0 above, for use by goexit0 and mcall. // We\u0026#39;re never coming back to mstart1 after we call schedule, // so other calls can reuse the current frame. // And goexit0 does a gogo that needs to return from mstart1 // and let mstart0 exit the thread. // // å°† m.g0.sched è®¾ç½®ä¸ºä¸Šé¢ mstart0 ä¸­ mstart1 è°ƒç”¨åè¿”å›çš„æ ‡ç­¾ï¼Œä¾› goexit0 å’Œ mcall ä½¿ç”¨ // åœ¨è°ƒç”¨ schedule ä¹‹åï¼Œæˆ‘ä»¬æ°¸è¿œä¸ä¼šå›åˆ° mstart1ï¼Œå› æ­¤å…¶ä»–è°ƒç”¨å¯ä»¥é‡ç”¨å½“å‰å¸§ // è€Œgoexit0åšäº†ä¸€ä¸ªgogoï¼Œéœ€è¦ä»mstart1è¿”å›ï¼Œè®©mstart0é€€å‡ºçº¿ç¨‹ // g0.sched.g = g0 _g_.sched.g = guintptr(unsafe.Pointer(_g_)) // è®¾ç½®g0çš„è°ƒåº¦ä¿¡æ¯æ˜¯å½“å‰g // g0.sched.pc = getcallerpc() // getcallerpc()ï¼šè°ƒç”¨è€…å‡½æ•°çš„ä¸‹ä¸€æ¡æŒ‡ä»¤ï¼Œä¹Ÿå°±æ˜¯mstart0()å‡½æ•°è°ƒç”¨mstart1()å‡½æ•°åçš„ifåˆ¤æ–­æŒ‡ä»¤ä»£ç å¤„ã€‚ _g_.sched.pc = getcallerpc() // è¿™é‡Œæ˜¯ç†è§£è°ƒåº¦å¾ªç¯çš„å…³é”®ï¼Œè°ƒåº¦å¾ªç¯æ¯æ¬¡åˆ‡æ¢åˆ°g0æ ˆéƒ½ä»è¿™é‡Œ(æŒ‡å®šçš„å›ºå®šä½ç½®)è®¾ç½®çš„ä½ç½®å¼€å§‹ä½¿ç”¨æ ˆã€‚ // g0.sched.pc = getcallersp() // getcallersp()ï¼šè°ƒç”¨è€…å½“å‰çš„SPå¯„å­˜å™¨å€¼ï¼Œä¹Ÿå°±æ˜¯mstart0()å‡½æ•°è°ƒç”¨mstart1()å‡½æ•°æ—¶SPå¯„å­˜å™¨çš„å€¼ã€‚ // è®¾ç½®rspå¯„å­˜å™¨å€¼ä¸ºmaster0è°ƒç”¨master1æ—¶çš„æ ˆé¡¶å¤„ï¼Œè®¾ç½®åœ¨è¿™é‡Œä¾¿äºæ¯æ¬¡åˆ‡æ¢çš„g0æ ˆéƒ½æ˜¯ä»å›ºå®šä½ç½®å¼€å§‹ _g_.sched.sp = getcallersp() // go1.19.3/src/runtime/asm_amd64.s // TEXT runtimeÂ·asminit(SB),NOSPLIT,$0-0 // // No per-thread init. // RET // æ²¡æœ‰ä»€ä¹ˆå¯åšçš„ã€‚ asminit() // è¯¥å‡½æ•°çš„æ±‡ç¼–ä»£ç ä»€ä¹ˆéƒ½æ²¡åšï¼Œåˆå§‹åŒ–Må·¥ä½œçº¿ç¨‹ minit() // è°ƒç”¨ä»¥åˆå§‹åŒ–ä¸€ä¸ªæ–°çš„ mï¼ˆåŒ…æ‹¬å¼•å¯¼ç¨‹åº mï¼‰ï¼Œåœ¨æ–°çº¿ç¨‹ä¸Šè°ƒç”¨ï¼Œæ— æ³•åˆ†é…å†…å­˜ // Install signal handlers; after minit so that minit can // prepare the thread to be able to handle the signals. // // å®‰è£…ä¿¡å·å¤„ç†ç¨‹åºï¼› åœ¨ minit ä¹‹åï¼Œä»¥ä¾¿ minit å¯ä»¥å‡†å¤‡çº¿ç¨‹ä»¥å¤„ç†ä¿¡å· if _g_.m == \u0026amp;m0 { // åˆ¤æ–­g0ç»‘å®šçš„mæ˜¯å¦æ˜¯m0ï¼Œm0æ˜¯main.goroutineä¹Ÿå°±æ˜¯ä¸»çº¿ç¨‹æ—¶æ‰§è¡Œä¸‹é¢æ–¹æ³• mstartm0() } // å¦‚æœ_g_.m.mstartfnå­˜åœ¨åˆ™æ‰§è¡Œè¯¥å‡½æ•°ï¼š // 1. ä¸€èˆ¬çš„æƒ…å†µä¸‹è¯¥å‡½æ•°æ˜¯ï¼Œmspinning()å‡½æ•°ã€‚è¯¥å‡½æ•°åªæœ‰ä¸€æ¡æŒ‡ä»¤ï¼Œæ ‡è®°mçš„mspiningå­—æ®µä¸ºtrueã€‚ // 2. å¦‚æœæ˜¯sysmonçº¿ç¨‹ä¸‹ï¼Œè¿™é‡Œæ˜¯ç›´æ¥è°ƒç”¨sysmon()å‡½æ•°ï¼Œè¯¥å‡½æ•°æ˜¯ä¸€ä¸ªæ— é™å¾ªç¯ï¼Œè¿™é‡Œä¸ä¼šè¿”å›ã€‚ if fn := _g_.m.mstartfn; fn != nil { fn() } // ç¨‹åºåˆšåˆå§‹åŒ–æ—¶ï¼Œä¸€å®šæ˜¯m0ï¼Œå› ä¸ºåœ¨å‰é¢m0å·²ç»ç»‘å®šäº†Pï¼Œæ‰€ä»¥æ˜¯m0éœ€è¦è·³è¿‡ã€‚ // é€šè¿‡wakeup()å‡½æ•°åˆ›å»ºçš„æ–°çš„å·¥ä½œçº¿ç¨‹mæ—¶ï¼Œè¿™é‡Œéœ€è¦ç»‘å®šä¸ªPã€‚ if _g_.m != \u0026amp;m0 { // ä¸æ˜¯m0åˆ™éœ€è¦ç»™å·¥ä½œçº¿ç¨‹Mç»‘å®šä¸€ä¸ªP // _g_.m.nextp.ptr()è·å–ä¸‹ä¸€ä¸ªPï¼Œnextpåœ¨wakeup()å‡½æ•°ç›¸å…³è¢«èµ‹å€¼ã€‚ acquirep(_g_.m.nextp.ptr()) // è°ƒç”¨acquirep(_g_.m.nextp.ptr())ç»‘å®šp _g_.m.nextp = 0 } // å¼€å¯å¾ªç¯è°ƒåº¦ï¼Œè¯¥å‡½æ•°æ°¸è¿œä¸è¿”å› schedule() } minit() åˆå§‹åŒ–ä¸€ä¸ªæ–°çš„mï¼ˆåŒ…æ‹¬å¼•å¯¼ç¨‹åºmï¼‰ã€‚åœ¨æ–°çº¿ç¨‹ä¸Šè°ƒç”¨ï¼Œæ— æ³•åˆ†é…å†…å­˜ã€‚ æ–‡ä»¶ä½ç½®ï¼šgo1.19.3/src/runtime/os_linux.goã€‚ 390 391 392 393 394 395 396 397 398 399 400 // Called to initialize a new m (including the bootstrap m). // Called on the new thread, cannot allocate memory. func minit() { // åˆå§‹åŒ– Signals minitSignals() // Cgo-created threads and the bootstrap m are missing a // procid. We need this for asynchronous preemption and it\u0026#39;s // useful in debuggers. getg().m.procid = uint64(gettid()) } æ–‡ä»¶ä½ç½®ï¼šgo1.19.3/src/runtime/signal_unix.goã€‚ 1192 1193 1194 1195 1196 1197 // minitSignals is called when initializing a new m to set the // thread\u0026#39;s alternate signal stack and signal mask. func minitSignals() { minitSignalStack() minitSignalMask() } acquirep() å‚æ•°_p_ *pï¼šç©ºé—²çš„påœ¨wakeup()å‡½æ•°æ—¶å­˜å…¥m.nextpå¤„ï¼Œä¾›å·¥ä½œçº¿ç¨‹å¯åŠ¨åç»‘å®šè¿™ä¸ªPã€‚ æ–‡ä»¶ä½ç½®ï¼šgo1.19.3/src/runtime/proc.goã€‚ 4938 4939 4940 4941 4942 4943 4944 4945 4946 4947 4948 4949 4950 4951 4952 4953 4954 4955 4956 4957 4958 4959 // Associate p and the current m. // // This function is allowed to have write barriers even if the caller // isn\u0026#39;t because it immediately acquires _p_. // //go:yeswritebarrierrec func acquirep(_p_ *p) { // Do the part that isn\u0026#39;t allowed to have write barriers. wirep(_p_)\t// ç»‘å®šPä¸å½“å‰å·¥ä½œçº¿ç¨‹M // Have p; write barriers now allowed. // Perform deferred mcache flush before this P can allocate // from a potentially stale mcache. // // åœ¨æ­¤ P å¯ä»¥ä»å¯èƒ½è¿‡æ—¶çš„ mcache åˆ†é…ä¹‹å‰æ‰§è¡Œå»¶è¿Ÿ mcache åˆ·æ–° _p_.mcache.prepareForSweep() if trace.enabled { traceProcStart() } } ç»‘å®šä¼ å…¥çš„Påœ¨å½“å‰å·¥ä½œçº¿ç¨‹ã€‚wirepæ˜¯acquirepçš„ç¬¬ä¸€æ­¥ï¼Œå®é™…ä¸Šæ˜¯å°†å½“å‰çš„Må…³è”åˆ°_p_ã€‚ è¿™æ˜¯è¢«æ‰“ç ´çš„ï¼Œæ‰€ä»¥æˆ‘ä»¬å¯ä»¥ç¦æ­¢è¿™éƒ¨åˆ†çš„å†™å±éšœï¼Œå› ä¸ºæˆ‘ä»¬è¿˜æ²¡æœ‰Pã€‚ æ–‡ä»¶ä½ç½®ï¼šgo1.19.3/src/runtime/proc.goã€‚ 4959 4960 4961 4962 4963 4964 4965 4966 4967 4968 4969 4970 4971 4972 4973 4974 4975 4976 4977 4978 4979 4980 4981 4982 4983 4984 4985 // wirep is the first step of acquirep, which actually associates the // current M to _p_. This is broken out so we can disallow write // barriers for this part, since we don\u0026#39;t yet have a P. // //go:nowritebarrierrec //go:nosplit func wirep(_p_ *p) { _g_ := getg() // è·å–å½“å‰çš„g if _g_.m.p != 0 { // å½“å‰å·¥ä½œçº¿ç¨‹å¦‚æœç»‘å®šäº†Påˆ™æœ‰é—®é¢˜ throw(\u0026#34;wirep: already in go\u0026#34;) } // å½“å‰Pç»‘å®šäº†å·¥ä½œçº¿ç¨‹å­˜åœ¨é—®é¢˜ï¼Œè¯¥Pä¸æ˜¯ç©ºé—²çš„ æˆ– å½“å‰Pä¸å¤„äºç©ºé—²çŠ¶æ€ if _p_.m != 0 || _p_.status != _Pidle { id := int64(0) if _p_.m != 0 { id = _p_.m.ptr().id } print(\u0026#34;wirep: p-\u0026gt;m=\u0026#34;, _p_.m, \u0026#34;(\u0026#34;, id, \u0026#34;) p-\u0026gt;status=\u0026#34;, _p_.status, \u0026#34;\\n\u0026#34;) throw(\u0026#34;wirep: invalid p state\u0026#34;) } // å½“å‰å·¥ä½œçº¿ç¨‹Mç»‘å®šP _g_.m.p.set(_p_) // m.p = _p_\t// å½“å‰Pç»‘å®šå·¥ä½œçº¿ç¨‹M _p_.m.set(_g_.m) // _p_.m = m _p_.status = _Prunning // æŠŠå½“å‰PçŠ¶æ€ä¿®æ”¹ä¸º_Prunning } schedule() å¾ªç¯è°ƒåº¦å¼€å§‹ã€‚æ¯è½®å¾ªç¯éƒ½ä»è¿™é‡Œå¼€å§‹ã€‚è¯¥å‡½æ•°ç®—æ˜¯è°ƒåº¦å™¨çš„æ ¸å¿ƒå‡½æ•°ï¼Œè¿è¡Œèµ·æ¥çš„çº¿ç¨‹ä¼šä¸€ç›´æ‰§è¡Œå®ƒã€‚ ä¸€è½®è°ƒåº¦å™¨ï¼šæ‰¾åˆ°ä¸€ä¸ªå¯è¿è¡Œçš„goroutineå¹¶æ‰§è¡Œå®ƒã€‚æ°¸ä¸è¿”å›ã€‚ æ–‡ä»¶ä½ç½®ï¼šgo1.19.3/src/runtime/proc.goã€‚ 3183 3184 3185 3186 3187 3188 3189 3190 3191 3192 3193 3194 3195 3196 3197 3198 3199 3200 3201 3202 3203 3204 3205 3206 3207 3208 3209 3210 3211 3212 3213 3214 3215 3216 3217 3218 3219 3220 3221 3222 3223 3224 3225 3226 3227 3228 3229 3230 3231 3232 3233 3234 3235 3236 3237 3238 3239 3240 3241 3242 3243 3244 3245 3246 3247 3248 3249 3250 3251 3252 3253 3254 3255 3256 3257 3258 3259 3260 3261 3262 3263 3264 3265 3266 3267 3268 3269 3270 3271 3272 3273 3274 3275 3276 3277 3278 3279 3280 3281 3282 3283 3284 3285 3286 3287 3288 3289 3290 3291 3292 // One round of scheduler: find a runnable goroutine and execute it. // Never returns. func schedule() { // è·å–å½“å‰æ­£åœ¨è¿è¡Œçš„gï¼Œæ‰§è¡Œè¯¥å‡½æ•°æ—¶ä¸€èˆ¬éƒ½æ˜¯ç³»ç»Ÿæ ˆg0 _g_ := getg() // _g_ = g0 // è°ƒåº¦å¼€å§‹æ—¶ g0.m.locks = 0 // æ ¡éªŒå½“å‰çº¿ç¨‹æ²¡æœ‰é”ï¼Œä¸å…è®¸å†æŒæœ‰é”çš„æƒ…å†µä¸‹è¿›è¡Œè°ƒåº¦ï¼Œä»¥å…é€ æˆruntimeå†…éƒ¨é”™è¯¯ // å› ä¸ºm.locksçš„åŠ é”å’Œè§£é”æ—¶æˆå¯¹å‡ºç°çš„ï¼Œå› æ­¤è¿™é‡Œåº”è¯¥ä¸º0 if _g_.m.locks != 0 { throw(\u0026#34;schedule: holding locks\u0026#34;) } // g0.m.lockedg = 0 // åˆ¤æ–­å½“å‰Mæœ‰æ²¡æœ‰å’ŒGç»‘å®šï¼Œå¦‚æœæœ‰ï¼Œè¿™ä¸ªMå°±ä¸èƒ½ç”¨æ¥æ‰§è¡Œå…¶ä»–çš„Gäº†, // åªèƒ½æŒ‚èµ·ç­‰å¾…ç»‘å®šçš„Gå¾—åˆ°è°ƒåº¦ã€‚ if _g_.m.lockedg != 0 { stoplockedm() execute(_g_.m.lockedg.ptr(), false) // Never returns. } // We should not schedule away from a g that is executing a cgo call, // since the cgo call is using the m\u0026#39;s g0 stack. // // æˆ‘ä»¬ä¸åº”è¯¥å®‰æ’è¿œç¦»æ­£åœ¨æ‰§è¡Œ cgo è°ƒç”¨çš„ gï¼Œå› ä¸º cgo è°ƒç”¨æ­£åœ¨ä½¿ç”¨ m çš„ g0 å †æ ˆ // åˆ¤æ–­çº¿ç¨‹æ˜¯ä¸æ˜¯æ­£åœ¨è¿›è¡Œcgoå‡½æ•°è°ƒç”¨ï¼Œè¿™ç§æƒ…å†µä¸‹g0æ ˆæ­£åœ¨è¢«cgoä½¿ç”¨ï¼Œæ‰€ä»¥ä¹Ÿä¸å…è®¸è°ƒåº¦ã€‚ if _g_.m.incgo { throw(\u0026#34;schedule: in cgo\u0026#34;) } top: pp := _g_.m.p.ptr() // pp = p // é€šè¿‡æŠŠpreemptå­—æ®µè®¾ç½®ä¸ºfalseï¼Œæ¥ç¦æ­¢å¯¹Pçš„æŠ¢å ã€‚ pp.preempt = false // Safety check: if we are spinning, the run queue should be empty. // Check this before calling checkTimers, as that might call // goready to put a ready goroutine on the local run queue. // // å®‰å…¨æ£€æŸ¥ï¼šå¦‚æœæˆ‘ä»¬æ­£åœ¨è‡ªæ—‹ï¼Œé‚£ä¹ˆè¿è¡Œé˜Ÿåˆ—åº”è¯¥æ˜¯ç©ºçš„ã€‚ // åœ¨è°ƒç”¨checkTimersä¹‹å‰è¯·æ£€æŸ¥è¿™ä¸€ç‚¹ï¼Œå› ä¸ºè¿™å¯èƒ½ä¼šè°ƒç”¨goreadyå°†å‡†å¤‡å¥½çš„goroutineæ”¾å…¥æœ¬åœ°è¿è¡Œé˜Ÿåˆ—ã€‚ // å¯¹ spinning çš„åˆ¤æ–­å±äºä¸€è‡´æ€§æ£€éªŒï¼Œåœ¨Pæœ¬åœ°runqæœ‰ä»»åŠ¡çš„æƒ…å†µä¸‹ï¼ŒMä¸åº”è¯¥å¤„äºspinningçŠ¶æ€ã€‚ if _g_.m.spinning \u0026amp;\u0026amp; (pp.runnext != 0 || pp.runqhead != pp.runqtail) { throw(\u0026#34;schedule: spinning with local work\u0026#34;) } // å¯»æ‰¾ä¸€ä¸ªå¯ç”¨çš„ goroutine // inheritTimeï¼šæ˜¯å¦ç»§æ‰¿å½“å‰æ—¶é—´ç‰‡ // 1. true ç»§æ‰¿å½“å‰æ—¶é—´ç‰‡ // 2. false ä¸ç»§æ‰¿å½“å‰æ—¶é—´ç‰‡ // tryWakePï¼šå½“å‰goroutineæ˜¯å¦æ˜¯æ™®é€šçš„ã€‚ä¹Ÿå°±æ˜¯user goroutineã€‚ // 1. false æ™®é€šçš„goroutineã€‚ // 2. true ä¸æ˜¯æ™®é€šçš„goroutineï¼Œå¯èƒ½æ˜¯GC workã€trace readeréœ€è¦å”¤é†’Pã€‚ // gpï¼šå½“å‰æ‰¾åˆ°çš„ goroutineã€‚ gp, inheritTime, tryWakeP := findRunnable() // blocks until work is available // This thread is going to run a goroutine and is not spinning anymore, // so if it was marked as spinning we need to reset it now and potentially // start a new spinning M. // // è¿™ä¸ªçº¿ç¨‹å°†è¿è¡Œä¸€ä¸ªgoroutineï¼Œä¸å†æ—‹è½¬ï¼Œæ‰€ä»¥å¦‚æœå®ƒè¢«æ ‡è®°ä¸ºæ—‹è½¬ï¼Œ // æˆ‘ä»¬ç°åœ¨éœ€è¦é‡ç½®å®ƒï¼Œå¹¶å¯èƒ½å¯åŠ¨ä¸€ä¸ªæ–°çš„æ—‹è½¬Mã€‚ if _g_.m.spinning { // é‡ç½®å½“å‰Mä½éæ—‹è½¬ï¼Œå¹¶å°è¯•é‡æ–°å¯åŠ¨ä¸€ä¸ªPæ ‡è®°ä¸ºæ—‹è½¬ã€‚ resetspinning() } // sched.disable.userï¼šç¦æ­¢è°ƒåº¦ç”¨æˆ·goroutineã€‚ // !schedEnabled(gp)ï¼šgpæ˜¯user goroutineã€‚ // å¯èƒ½æ¥è‡ªGCï¼Œå…¶ä¸­ä¸¤ç§æ¨¡å¼ä¸å…è®¸GCæœŸé—´è¿è¡Œuser goroutine if sched.disable.user \u0026amp;\u0026amp; !schedEnabled(gp) { // Scheduling of this goroutine is disabled. Put it on // the list of pending runnable goroutines for when we // re-enable user scheduling and look again. // // æ­¤goroutineçš„è°ƒåº¦è¢«ç¦ç”¨ã€‚ // å½“æˆ‘ä»¬é‡æ–°å¯ç”¨ç”¨æˆ·è°ƒåº¦å¹¶å†æ¬¡æŸ¥çœ‹æ—¶ï¼Œå°†å®ƒæ”¾åœ¨æŒ‚èµ·çš„å¯è¿è¡Œgoroutineåˆ—è¡¨ä¸­ã€‚ lock(\u0026amp;sched.lock) if schedEnabled(gp) { // Something re-enabled scheduling while we // were acquiring the lock. unlock(\u0026amp;sched.lock) } else { // user goroutine æ—¶æŒ‚èµ· sched.disable.runnable.pushBack(gp) sched.disable.n++ unlock(\u0026amp;sched.lock) goto top } } // If about to schedule a not-normal goroutine (a GCworker or tracereader), // wake a P if there is one. // // å¦‚æœè¦è°ƒåº¦ä¸€ä¸ªä¸æ­£å¸¸çš„goroutine (GCworkeræˆ–tracereader)ï¼Œå¦‚æœæœ‰Pï¼Œåˆ™å”¤é†’Pã€‚ // å°è¯•æ¢æ–°ä¸€ä¸ªæ–°çº¿ç¨‹ç»‘å®šPæ¥å·¥ä½œã€‚ if tryWakeP { wakep() } if gp.lockedm != 0 { // Hands off own p to the locked m, // then blocks waiting for a new p. // // æŠŠè‡ªå·±çš„päº¤ç»™é”ä½çš„mï¼Œç„¶åblockç­‰å¾…ä¸€ä¸ªæ–°çš„pã€‚ startlockedm(gp) goto top } execute(gp, inheritTime) } findRunnable()ğŸš€ æŸ¥æ‰¾è¦æ‰§è¡Œçš„å¯è¿è¡Œgoroutineã€‚è¯•å›¾ä»å…¶ä»–Pä¸­çªƒå–ï¼Œä»æœ¬åœ°æˆ–å…¨å±€é˜Ÿåˆ—ã€è½®è¯¢ç½‘ç»œä¸­è·å–gã€‚ tryWakePè¡¨ç¤ºè¿”å›çš„ä¸æ˜¯æ™®é€šçš„goroutineï¼ˆGCå·¥ä½œç¨‹åºã€è·Ÿè¸ªè¯»å–å™¨ï¼‰ï¼Œå› æ­¤è°ƒç”¨è€…åº”è¯¥å°è¯•å”¤é†’Pã€‚ æ–‡ä»¶ä½ç½®ï¼šgo1.19.3/src/runtime/proc.goã€‚ 2651 2652 2653 2654 2655 2656 2657 2658 2659 2660 2661 2662 2663 2664 2665 2666 2667 2668 2669 2670 2671 2672 2673 2674 2675 2676 2677 2678 2679 2680 2681 2682 2683 2684 2685 2686 2687 2688 2689 2690 2691 2692 2693 2694 2695 2696 2697 2698 2699 2700 2701 2702 2703 2704 2705 2706 2707 2708 2709 2710 2711 2712 2713 2714 2715 2716 2717 2718 2719 2720 2721 2722 2723 2724 2725 2726 2727 2728 2729 2730 2731 2732 2733 2734 2735 2736 2737 2738 2739 2740 2741 2742 2743 2744 2745 2746 2747 2748 2749 2750 2751 2752 2753 2754 2755 2756 2757 2758 2759 2760 2761 2762 2763 2764 2765 2766 2767 2768 2769 2770 2771 2772 2773 2774 2775 2776 2777 2778 2779 2780 2781 2782 2783 2784 2785 2786 2787 2788 2789 2790 2791 2792 2793 2794 2795 2796 2797 2798 2799 2800 2801 2802 2803 2804 2805 2806 2807 2808 2809 2810 2811 2812 2813 2814 2815 2816 2817 2818 2819 2820 2821 2822 2823 2824 2825 2826 2827 2828 2829 2830 2831 2832 2833 2834 2835 2836 2837 2838 2839 2840 2841 2842 2843 2844 2845 2846 2847 2848 2849 2850 2851 2852 2853 2854 2855 2856 2857 2858 2859 2860 2861 2862 2863 2864 2865 2866 2867 2868 2869 2870 2871 2872 2873 2874 2875 2876 2877 2878 2879 2880 2881 2882 2883 2884 2885 2886 2887 2888 2889 2890 2891 2892 2893 2894 2895 2896 2897 2898 2899 2900 2901 2902 2903 2904 2905 2906 2907 2908 2909 2910 2911 2912 2913 2914 2915 2916 2917 2918 2919 2920 2921 2922 2923 2924 2925 2926 2927 2928 2929 2930 2931 2932 2933 2934 2935 2936 2937 2938 2939 2940 2941 2942 2943 2944 2945 2946 2947 2948 2949 2950 2951 2952 2953 2954 2955 2956 2957 2958 2959 2960 2961 2962 2963 2964 2965 2966 2967 2968 2969 2970 2971 2972 2973 2974 2975 2976 2977 2978 2979 2980 2981 2982 2983 2984 2985 2986 2987 2988 2989 2990 2991 2992 2993 2994 2995 2996 2997 2998 2999 3000 3001 3002 3003 3004 3005 3006 3007 3008 3009 3010 3011 3012 3013 3014 3015 3016 3017 3018 3019 3020 3021 3022 3023 3024 3025 3026 3027 3028 3029 3030 3031 3032 3033 3034 3035 3036 3037 3038 3039 3040 3041 3042 3043 3044 3045 3046 3047 3048 3049 3050 3051 3052 3053 3054 3055 3056 3057 3058 3059 3060 3061 3062 3063 3064 3065 3066 3067 3068 3069 3070 3071 3072 3073 3074 3075 3076 3077 3078 3079 3080 3081 3082 3083 3084 3085 3086 3087 3088 3089 3090 3091 3092 3093 3094 3095 3096 3097 3098 3099 3100 3101 3102 3103 3104 3105 3106 3107 3108 3109 3110 3111 3112 3113 3114 3115 3116 3117 3118 3119 3120 3121 3122 // Finds a runnable goroutine to execute. // Tries to steal from other P\u0026#39;s, get g from local or global queue, poll network. // tryWakeP indicates that the returned goroutine is not normal (GC worker, trace // reader) so the caller should try to wake a P. func findRunnable() (gp *g, inheritTime, tryWakeP bool) { _g_ := getg() // _g_ = g0 // The conditions here and in handoffp must agree: if // findrunnable would return a G to run, handoffp must start // an M. // // è¿™é‡Œå’Œhandoffpä¸­çš„æ¡ä»¶å¿…é¡»ä¸€è‡´ï¼šå¦‚æœfindrunnableå°†è¿”å›ä¸€ä¸ªGæ¥è¿è¡Œï¼Œåˆ™handoffpå¿…é¡»å¯åŠ¨ä¸€ä¸ªMã€‚ top: _p_ := _g_.m.p.ptr() // _p_ = p // 1) å¸®åŠ©STWï¼ŒæŠ¢å å½“å‰Pã€‚ // STW å³å°†å¼€å§‹è¦æ±‚ç­‰å¾…ï¼ŒæŒ‚èµ·å½“å‰Mã€‚ // æ£€æµ‹sched.gcwaitingï¼ŒæŒ‚èµ·è‡ªå·±ï¼Œä»¥ä¾¿åŠæ—¶å“åº”STWï¼Œ // è°ƒåº¦é€»è¾‘ä¸­å¾ˆå¤šåœ°æ–¹éƒ½æœ‰å¯¹gcwaitingçš„æ£€æµ‹ã€‚ if sched.gcwaiting != 0 { // åœ¨GCçš„STWæœŸé—´è¢«è®¾ç½® gcstopm() goto top } // 2) æ£€æŸ¥å½“å‰Pæ˜¯å¦åˆ°è¾¾å®‰å…¨ç‚¹ã€‚ // å¦‚æœå½“å‰Pè¦æ±‚è¿è¡Œ runSafePointFn() å‡½æ•°ã€‚ // runSafePointFn() å‡½æ•°è¢«GCç”¨æ¥åœ¨å®‰å…¨ç‚¹æ‰§è¡Œæ¸…ç©ºå·¥ä½œé˜Ÿåˆ—ä¹‹ç±»çš„æ“ä½œã€‚ if _p_.runSafePointFn != 0 { runSafePointFn() } // 3) å» timers é‡Œçœ‹çœ‹ï¼Œæ˜¯å¦æœ‰åˆ°ç‚¹çš„å®šæ—¶å™¨ã€‚ // è¿™é‡Œå¦‚æœæœ‰ timer åˆ°è§¦å‘ç‚¹äº†ï¼Œä¼šè§¦å‘å¹¶æ‰§è¡Œæ³¨å†Œå‡½æ•°ã€‚ // ç”±äºè°ƒåº¦å¾ªç¯æ˜¯ä»¥æ—¶é—´ç‰‡å½¢å¼è°ƒåº¦çš„ï¼Œå› æ­¤ timer çš„è§¦å‘æ—¶é—´ä¸Šçº¿å°±æ˜¯10msã€‚ // å› æ­¤æŠ¢å èƒ½æŠ¢å è¶…è¿‡10msä»¥ä¸Šçš„goroutine? // checkTimers ä¸ºå‡†å¤‡å¥½çš„ P è¿è¡Œä»»ä½•timers // å¦‚æœ now ä¸ä¸º 0ï¼Œåˆ™ä¸ºå½“å‰æ—¶é—´ï¼Œå¦‚æœ now è¢«ä¼ é€’ä¸º 0ï¼Œåˆ™è¿”å›ä¼ é€’çš„æ—¶é—´æˆ–å½“å‰æ—¶é—´ // ä»¥åŠä¸‹ä¸€ä¸ªtimeråº”è¯¥è¿è¡Œçš„æ—¶é—´ï¼Œå¦‚æœæ²¡æœ‰ä¸‹ä¸€ä¸ªè®¡æ—¶å™¨ï¼Œåˆ™ä¸º 0ï¼Œå¹¶æŠ¥å‘Šå®ƒæ˜¯å¦è¿è¡Œäº†ä»»ä½•è®¡æ—¶å™¨ // å¦‚æœä¸‹ä¸€ä¸ªtimeråº”è¯¥è¿è¡Œçš„æ—¶é—´ä¸ä¸º0ï¼Œå®ƒæ€»æ˜¯å¤§äºè¿”å›çš„æ—¶é—´ // func checkTimers(pp *p, now int64) (rnow, pollUntil int64, ran bool) // å‚æ•°ï¼š // 1. pp *p å½“å‰éœ€è¦æ£€æŸ¥çš„P // 2. now int64 å½“å‰æ—¶é—´ï¼Œå¦‚æœä¸º0åˆ™å–å½“å‰æ—¶é—´ // è¿”å›å€¼ï¼š // 1. rnow int64ï¼šå‚æ•°nowçš„æ—¶é—´ã€‚ // 2. pollUntil int64ï¼š\u0026gt;0.æœ€è¿‘timerè§¦å‘çš„æ—¶é—´ç‚¹ã€‚0.æ²¡æœ‰ä»»ä½•timerã€‚ // 3. ran bool timeré‡Œé¢æ˜¯å¦å­˜åœ¨å·²ç»å»¶è¿Ÿæ—¶é—´åˆ°ç‚¹çš„gï¼Œtrueå­˜åœ¨ï¼Œfalseä¸å­˜åœ¨ // now and pollUntil are saved for work stealing later, // which may steal timers. It\u0026#39;s important that between now // and then, nothing blocks, so these numbers remain mostly // relevant. // // nowå’ŒpollUntilè¢«ä¿å­˜ä»¥å¤‡ä»¥åçªƒå–å·¥ä½œï¼Œè¿™å¯èƒ½ä¼šçªƒå–timersã€‚ // é‡è¦çš„æ˜¯ï¼Œä»ç°åœ¨åˆ°é‚£æ—¶ï¼Œæ²¡æœ‰ä»»ä½•é˜»ç¢ï¼Œæ‰€ä»¥è¿™äº›æ•°å­—ä»ç„¶å¾ˆé‡è¦ã€‚ // å¤„ç†å½“å‰Pç›¸å…³çš„timersï¼Œå¯èƒ½å­˜åœ¨ä¸€äº›åœ¨timerä¸­çš„gåˆ°æ—¶é—´ç‚¹äº†éœ€è¦æ”¾å›Pä¸­ç­‰å¾…è¢«æ‰§è¡Œ now, pollUntil, _ := checkTimers(_p_, 0) // 4) å°è¯•å®‰æ’ trace readerã€‚ // Try to schedule the trace reader. // // å°è¯•å®‰æ’ trace readerã€‚ if trace.enabled || trace.shutdown { gp = traceReader() if gp != nil { casgstatus(gp, _Gwaiting, _Grunnable) traceGoUnpark(gp, 0) return gp, false, true } } // 5) å†™æ ‡è®°æœŸé—´ï¼Œå°è¯•å®‰æ’ GC workerã€‚ // Try to schedule a GC worker. // å°è¯•å®‰æ’ GC workerã€‚ if gcBlackenEnabled != 0 { // åœ¨GCã€å¹¶å‘æ ‡è®°ã€‘æœŸé—´è¢«è®¾ç½® // å”¤é†’æ ‡è®°åç¨‹ï¼Œå‚çœ‹GCæ–‡æ¡£ gp, now = gcController.findRunnableGCWorker(_p_, now) // è·å–åˆ°æ ‡è®°åç¨‹ if gp != nil { return gp, false, true // è¿”å›æ ‡è®°åç¨‹ } } // 6) Pè°ƒåº¦æ¬¡æ•°æ¯æ»¡61æ¬¡éœ€è¦å»å…¨å±€é˜Ÿåˆ—æ‹¿å»goroutineï¼Œé˜²æ­¢å…¨å±€goroutineä¸€ç›´å¾—ä¸åˆ°è¿è¡Œã€‚ // Check the global runnable queue once in a while to ensure fairness. // Otherwise two goroutines can completely occupy the local runqueue // by constantly respawning each other. // // å¶å°”æ£€æŸ¥ä¸€æ¬¡å…¨å±€å¯è¿è¡Œé˜Ÿåˆ—ä»¥ç¡®ä¿å…¬å¹³æ€§ã€‚ // å¦åˆ™ï¼Œä¸¤ä¸ªgoroutineå¯ä»¥é€šè¿‡ä¸æ–­åœ°ç›¸äº’é‡æ–°éƒ¨ç½²æ¥å®Œå…¨å æ®æœ¬åœ°è¿è¡Œé˜Ÿåˆ—ã€‚ // ä¸ºäº†ä¿è¯è°ƒåº¦çš„å…¬å¹³æ€§ï¼Œæ¯ä¸ªå·¥ä½œçº¿ç¨‹æ¯è¿›è¡Œ61æ¬¡è°ƒåº¦å°±éœ€è¦ä¼˜å…ˆä»å…¨å±€è¿è¡Œé˜Ÿåˆ—ä¸­è·å–goroutineå‡ºæ¥è¿è¡Œã€‚ // å› ä¸ºå¦‚æœåªè°ƒåº¦æœ¬åœ°è¿è¡Œé˜Ÿåˆ—ä¸­çš„goroutineï¼Œåˆ™å…¨å±€è¿è¡Œé˜Ÿåˆ—ä¸­çš„goroutineæœ‰å¯èƒ½å¾—ä¸åˆ°è¿è¡Œã€‚ // p.schedtickï¼šè®°å½•è°ƒåº¦å‘ç”Ÿçš„æ¬¡æ•°ï¼Œå®é™…ä¸Šåœ¨æ¯å‘ç”Ÿä¸€æ¬¡goroutineåˆ‡æ¢ä¸”ä¸ç»§æ‰¿æ—¶é—´ç‰‡çš„æƒ…å†µä¸‹ï¼Œè¯¥å­—æ®µä¼šåŠ ä¸€ã€‚ // sched.runqsizeï¼šè®°å½•çš„æ˜¯å…¨å±€å°±ç»ªé˜Ÿåˆ—çš„é•¿åº¦ã€‚ä¹Ÿå°±æ˜¯å…¨å±€é˜Ÿåˆ—goroutineçš„ä¸ªæ•°ã€‚ if _p_.schedtick%61 == 0 \u0026amp;\u0026amp; sched.runqsize \u0026gt; 0 { lock(\u0026amp;sched.lock) // ä»schedä¸­è·å–goroutineéœ€è¦æŒæœ‰locké”ã€‚ // ä»å…¨å±€é˜Ÿåˆ—ä¸­è·å–1ä¸ªgoroutineï¼Œç„¶åæ”¾å…¥Pçš„æœ¬åœ°é˜Ÿåˆ—ã€‚ gp = globrunqget(_p_, 1) // åªæ‹¿å–ä¸€ä¸ª unlock(\u0026amp;sched.lock) // mutex è§£é” if gp != nil { return gp, false, false } } // 7) æ˜¯å¦æœ‰ finalizer Gã€‚ // Wake up the finalizer G. // // å”¤é†’ finalizer Gã€‚ // è¯¥goroutineç”±runtime.SetFinalizerå‡½æ•°åˆ›é€ ã€‚ // åªä¼šåˆ›å»ºä¸€ä¸ªgoroutineã€‚ if fingwait \u0026amp;\u0026amp; fingwake { if gp := wakefing(); gp != nil { ready(gp, 0, true) } } if *cgo_yield != nil { asmcgocall(*cgo_yield, nil) } // 8) ä»Pçš„æœ¬åœ°é˜Ÿåˆ—æ‹¿å» goroutineã€‚ // local runq // ä»æœ¬åœ°Pçš„é˜Ÿåˆ—ä¸­è·å–goroutineã€‚ if gp, inheritTime := runqget(_p_); gp != nil { return gp, inheritTime, false } // 9) ä»å…¨å±€é˜Ÿåˆ—ä¸­æ‹¿å»goroutineã€‚ // global runq // ä»å…¨å±€é˜Ÿåˆ—ä¸­è·å–goroutineã€‚ if sched.runqsize != 0 { lock(\u0026amp;sched.lock) gp := globrunqget(_p_, 0) // æ‹¿å–å¤šä¸ª unlock(\u0026amp;sched.lock) if gp != nil { return gp, false, false } } // 10) netpoll æ˜¯å¦æœ‰å°±ç»ªçš„goroutineã€‚ // Poll network. // This netpoll is only an optimization before we resort to stealing. // We can safely skip it if there are no waiters or a thread is blocked // in netpoll already. If there is any kind of logical race with that // blocked thread (e.g. it has already returned from netpoll, but does // not set lastpoll yet), this thread will do blocking netpoll below // anyway. // // netpollinited()ï¼šåˆ¤æ–­netpollæ˜¯å¦å·²ç»åˆå§‹åŒ–ã€‚ // netpollWaitersï¼šæ˜¯å¦æœ‰ç­‰å¾…çš„goroutineã€‚ // sched.lastpollï¼šä¸Šæ¬¡ç½‘ç»œè½®è¯¢çš„æ—¶é—´ç‚¹ã€‚ä¸º0æ—¶è¡¨ç¤ºæœ‰çº¿ç¨‹æ­£åœ¨é˜»å¡å¼è°ƒç”¨netpollå‡½æ•° if netpollinited() \u0026amp;\u0026amp; atomic.Load(\u0026amp;netpollWaiters) \u0026gt; 0 \u0026amp;\u0026amp; atomic.Load64(\u0026amp;sched.lastpoll) != 0 { // netpoll(0)ï¼šåˆ¤æ–­å½“å‰æ˜¯å¦æœ‰å°±ç»ªäº‹ä»¶ï¼Œ0è¡¨ç¤ºç«‹å³è¿”å›ã€‚éé˜»å¡ã€‚ if list := netpoll(0); !list.empty() { // non-blocking gp := list.pop() // å¼¹å‡ºä¸€ä¸ªgoroutineã€‚ injectglist(\u0026amp;list) // å¤„ç†å‰©ä¸‹çš„goroutine casgstatus(gp, _Gwaiting, _Grunnable) // ä¿®æ”¹goroutineçŠ¶æ€ if trace.enabled { traceGoUnpark(gp, 0) } return gp, false, false } } // 11) ä»¥ä¸Šéƒ½æ²¡è·å–åˆ°goroutineã€‚æ ‡è®°è‡ªæ—‹å°è¯•ä»å…¶ä»–Pä¸­å·å–goroutineã€‚ // Spinning Ms: steal work from other Ps. // // Limit the number of spinning Ms to half the number of busy Ps. // This is necessary to prevent excessive CPU consumption when // GOMAXPROCS\u0026gt;\u0026gt;1 but the program parallelism is low. // // Spinning Ms:ä»å…¶ä»–Pé‚£é‡Œçªƒå–goroutineã€‚ // å°†è‡ªæ—‹çš„Mé™åˆ¶ä¸ºç¹å¿™Mçš„ä¸€åŠã€‚ // è¿™æ˜¯å¿…è¦çš„ï¼Œä»¥é˜²æ­¢åœ¨ GOMAXPROCS\u0026gt;\u0026gt;1 ä½†ç¨‹åºå¹¶è¡Œæ€§è¾ƒä½æ—¶è¿‡åº¦æ¶ˆè€—CPUã€‚ // å¦‚æœå½“å‰å¤„äºspinningçŠ¶æ€çš„Mçš„æ•°é‡å¤§äºå¿™ç¢Œçš„Pçš„æ•°é‡çš„ä¸€åŠï¼Œå°±è®©å½“å‰Mé˜»å¡(ä¼‘çœ )ã€‚ // ç›®çš„æ˜¯é¿å…åœ¨gomaxprocsè¾ƒå¤§è€Œç¨‹åºå®é™…çš„å¹¶å‘æ€§å¾ˆä½çš„æƒ…å†µä¸‹ï¼Œé€ æˆä¸å¿…è¦çš„CPUæ¶ˆè€—ã€‚ procs := uint32(gomaxprocs) // è·å–å½“å‰Pçš„æ•°é‡ // _g_.m.spinning == trueï¼šå½“å‰Må¤„äºè‡ªæ—‹ã€‚ // 2*atomic.Load(\u0026amp;sched.nmspinning) \u0026lt; procs-atomic.Load(\u0026amp;sched.npidle)ï¼šè‡ªæ—‹æ˜¯ç¹å¿™çš„ä¸€åŠè¿˜å°æ—¶ï¼Œæ ‡è®°å½“å‰Mä¸ºè‡ªæ—‹ if _g_.m.spinning || 2*atomic.Load(\u0026amp;sched.nmspinning) \u0026lt; procs-atomic.Load(\u0026amp;sched.npidle) { if !_g_.m.spinning { // æ»¡è¶³å·å–çš„æ—¶å€™æ‰ä¼šæ ‡è®°Mä¸ºè‡ªæ—‹çŠ¶æ€ _g_.m.spinning = true // æ ‡è®°ä¸ºè‡ªæ—‹çŠ¶æ€ atomic.Xadd(\u0026amp;sched.nmspinning, 1) // ç´¯åŠ è‡ªæ—‹Mçš„æ•°é‡ } // å»å…¶ä»–Pä¸­å·å– goroutineã€‚å·å–å…¶ä»–Pä¸­goroutineçš„ä¸€åŠã€‚ // ä»p.runnextä¸­å·å–çš„goroutineæ—¶ï¼ŒinheritTimeè¯¥å€¼ä¸ºtrueï¼Œè¡¨ç¤ºç»§æ‰¿ä¸Šä¸ªæ—¶é—´ç‰‡ã€‚ gp, inheritTime, tnow, w, newWork := stealWork(now) now = tnow // æ›´æ–°å½“å‰æ—¶é—´ // æˆåŠŸå·å–åˆ°goroutine if gp != nil { // Successfully stole. return gp, inheritTime, false } // newWork æŸä¸ªPä¸­æœ‰timerè¢«è§¦å‘äº†ï¼Œåœ¨æ¥ä¸€æ¬¡è°ƒåº¦å¾ªç¯ if newWork { // There may be new timer or GC work; restart to // discover. goto top } // wä¸ä¸º0ï¼Œè¡¨ç¤ºæœ€è¿‘è§¦å‘çš„timerçš„æ—¶é—´ç‚¹ if w != 0 \u0026amp;\u0026amp; (pollUntil == 0 || w \u0026lt; pollUntil) { // Earlier timer to wait for. pollUntil = w // è®°å½•æœ€è¿‘è¦è§¦å‘çš„æ—¶é—´ç‚¹ } } // 12) æœ‰GCæ ‡è®°å·¥ä½œè¿™å»å¸®åŠ©GC // We have nothing to do. // // If we\u0026#39;re in the GC mark phase, can safely scan and blacken objects, // and have work to do, run idle-time marking rather than give up the P. // // æˆ‘ä»¬æ— äº‹å¯åšã€‚ // å¦‚æœæˆ‘ä»¬åœ¨GCæ ‡è®°é˜¶æ®µï¼Œå¯ä»¥å®‰å…¨åœ°æ‰«æå’Œå˜é»‘å¯¹è±¡ï¼Œå¹¶ä¸”æœ‰å·¥ä½œè¦åšï¼Œè¿è¡Œç©ºé—²æ—¶é—´æ ‡è®°è€Œä¸æ˜¯æ”¾å¼ƒPã€‚ if gcBlackenEnabled != 0 \u0026amp;\u0026amp; gcMarkWorkAvailable(_p_) \u0026amp;\u0026amp; gcController.addIdleMarkWorker() { node := (*gcBgMarkWorkerNode)(gcBgMarkWorkerPool.pop()) if node != nil { _p_.gcMarkWorkerMode = gcMarkWorkerIdleMode gp := node.gp.ptr() casgstatus(gp, _Gwaiting, _Grunnable) if trace.enabled { traceGoUnpark(gp, 0) } return gp, false, false } gcController.removeIdleMarkWorker() } // wasm only: // If a callback returned and no other goroutine is awake, // then wake event handler goroutine which pauses execution // until a callback was triggered. gp, otherReady := beforeIdle(now, pollUntil) // åœ¨linuxä¸‹è¿”å› (nil, false) if gp != nil { casgstatus(gp, _Gwaiting, _Grunnable) if trace.enabled { traceGoUnpark(gp, 0) } return gp, false, false } if otherReady { goto top } // 13) ä¿å­˜allpã€idlepMaskå’ŒtimerpMaskçš„å¿«ç…§ // å½“å‰å·¥ä½œçº¿ç¨‹å³å°†ä¼‘çœ ï¼Œä¼‘çœ å‰å†æ¬¡å»å¿«ç…§é‡Œé¢çœ‹çœ‹æœ‰æ²¡æœ‰å·¥ä½œè¦åš // Before we drop our P, make a snapshot of the allp slice, // which can change underfoot once we no longer block // safe-points. We don\u0026#39;t need to snapshot the contents because // everything up to cap(allp) is immutable. // // åœ¨æˆ‘ä»¬ä¸¢å¼ƒPä¹‹å‰ï¼Œåšä¸€ä¸ªallpåˆ‡ç‰‡çš„å¿«ç…§ï¼Œä¸€æ—¦æˆ‘ä»¬ä¸å†é˜»å¡safe-pointsï¼Œå®ƒå°±ä¼šæ”¹å˜ã€‚ // æˆ‘ä»¬ä¸éœ€è¦å¯¹å†…å®¹è¿›è¡Œå¿«ç…§ï¼Œå› ä¸ºcap(allp)ä¹‹å‰çš„æ‰€æœ‰å†…å®¹éƒ½æ˜¯ä¸å¯å˜çš„ã€‚ allpSnapshot := allp // Also snapshot masks. Value changes are OK, but we can\u0026#39;t allow // len to change out from under us. // // è¿˜æœ‰å¿«ç…§æ©ç ã€‚å€¼æ›´æ”¹æ˜¯å¯ä»¥çš„ï¼Œä½†æ˜¯æˆ‘ä»¬ä¸èƒ½å…è®¸lenä»æˆ‘ä»¬ä¸‹é¢æ›´æ”¹ã€‚ idlepMaskSnapshot := idlepMask timerpMaskSnapshot := timerpMask // 14) åœ¨çœ‹ä¸€ä¸‹gcwaitingå’ŒrunSafePointFnï¼Œä»¥åŠå…¨å±€é˜Ÿåˆ—sched.runqsize // return P and block lock(\u0026amp;sched.lock) // æœ‰GCç­‰å¾… æˆ– Pæœ‰å®‰å…¨ç‚¹å‡½æ•°æ‰§è¡Œ if sched.gcwaiting != 0 || _p_.runSafePointFn != 0 { unlock(\u0026amp;sched.lock) goto top } // å…¨å±€é˜Ÿåˆ—æœ‰ goroutine if sched.runqsize != 0 { // å› ä¸º sched.lock é”å·²è¢«æŒæœ‰ï¼Œæ‰€ä»¥ä¸€å®šèƒ½å–å‡º gpã€‚ä¸ä¸º nilã€‚ gp := globrunqget(_p_, 0) unlock(\u0026amp;sched.lock) return gp, false, false } // 15) è§£é™¤å½“å‰Mä¸Pçš„ç»‘å®šå…³ç³»ï¼Œå¹¶æŠŠPåŠ å…¥å…¨å±€ç©ºé—²é˜Ÿåˆ—ä¸­ // è§£é™¤mä¸pçš„ç»‘å®šå…³ç³»ï¼Œå¹¶è®¾ç½®pä¸ºç©ºé—²çŠ¶æ€ã€‚ if releasep() != _p_ { throw(\u0026#34;findrunnable: wrong p\u0026#34;) } // æŠŠPåŠ å…¥ç©ºé—²é˜Ÿåˆ— now = pidleput(_p_, now) unlock(\u0026amp;sched.lock) // 16) æ ¹æ®å‰é¢å¿«ç…§ä¿å­˜çš„ä¿¡æ¯ï¼Œå†æ¬¡æ£€æŸ¥å…¶ä»–Pæ˜¯å¦å¯å·å–ï¼ŒGCæœ‰æ²¡æ ‡è®°å·¥ä½œéœ€è¦ååŠ©ï¼Œtimeræœ‰æ²¡è§¦å‘ // Delicate dance: thread transitions from spinning to non-spinning // state, potentially concurrently with submission of new work. We must // drop nmspinning first and then check all sources again (with // #StoreLoad memory barrier in between). If we do it the other way // around, another thread can submit work after we\u0026#39;ve checked all // sources but before we drop nmspinning; as a result nobody will // unpark a thread to run the work. // // This applies to the following sources of work: // // * Goroutines added to a per-P run queue. // * New/modified-earlier timers on a per-P timer heap. // * Idle-priority GC work (barring golang.org/issue/19112). // // If we discover new work below, we need to restore m.spinning as a signal // for resetspinning to unpark a new worker thread (because there can be more // than one starving goroutine). However, if after discovering new work // we also observe no idle Ps it is OK to skip unparking a new worker // thread: the system is fully loaded so no spinning threads are required. // Also see \u0026#34;Worker thread parking/unparking\u0026#34; comment at the top of the file. wasSpinning := _g_.m.spinning // å¤„ç†å½“å‰Mæ˜¯è‡ªæ—‹çŠ¶æ€ if _g_.m.spinning { _g_.m.spinning = false // æ ‡è®°å½“å‰Mæœªéè‡ªæ—‹ if int32(atomic.Xadd(\u0026amp;sched.nmspinning, -1)) \u0026lt; 0 { throw(\u0026#34;findrunnable: negative nmspinning\u0026#34;) } // Note the for correctness, only the last M transitioning from // spinning to non-spinning must perform these rechecks to // ensure no missed work. We are performing it on every M that // transitions as a conservative change to monitor effects on // latency. See golang.org/issue/43997. // Check all runqueues once again. // // å†æ¬¡æ£€æŸ¥æ‰€æœ‰è¿è¡Œé˜Ÿåˆ—ã€‚ // æ£€æŸ¥æ˜¯å¦æœ‰å¯å·å–çš„Pï¼Œå¦‚æœæœ‰åˆ™å–å‡ºä¸€ä¸ªç©ºé—²çš„Pç»‘å®šMã€‚ _p_ = checkRunqsNoP(allpSnapshot, idlepMaskSnapshot) if _p_ != nil { acquirep(_p_) // ç»‘å®šP _g_.m.spinning = true atomic.Xadd(\u0026amp;sched.nmspinning, 1) goto top // æœ‰å·¥ä½œå¯åšå†è·‘ä¸€éè°ƒåº¦å¾ªç¯ } // Check for idle-priority GC work again. // // å†æ¬¡æ£€æŸ¥ç©ºé—²ä¼˜å…ˆçº§GCå·¥ä½œã€‚æ˜¯å¦æœ‰ç¼–è¾‘å·¥ä½œéœ€è¦åš _p_, gp = checkIdleGCNoP() if _p_ != nil { acquirep(_p_) // ç»‘å®šP _g_.m.spinning = true atomic.Xadd(\u0026amp;sched.nmspinning, 1) // Run the idle worker. _p_.gcMarkWorkerMode = gcMarkWorkerIdleMode casgstatus(gp, _Gwaiting, _Grunnable) if trace.enabled { traceGoUnpark(gp, 0) } return gp, false, false } // Finally, check for timer creation or expiry concurrently with // transitioning from spinning to non-spinning. // // Note that we cannot use checkTimers here because it calls // adjusttimers which may need to allocate memory, and that isn\u0026#39;t // allowed when we don\u0026#39;t have an active P. // // æœ€åï¼Œå†çœ‹çœ‹timerã€‚ pollUntil = checkTimersNoP(allpSnapshot, timerpMaskSnapshot, pollUntil) } // 17) network æ˜¯å¦æœ‰éœ€è¦å¤„ç†çš„goroutineï¼Œæˆ–timeræ˜¯å¦å³å°†è§¦å‘ï¼Œ // æ ‡è®°sched.lastpollä¸º0ï¼Œé˜»å¡å¼ç­‰å¾…å§ã€‚netpollä¸­ä¸€äº›è¯»å†™è¶…æ—¶éœ€è¦ç”¨åˆ°timer // Poll network until next timer. // // Poll network ç›´åˆ°ä¸‹ä¸€ä¸ª timerã€‚ // netpollinited()ï¼šnetpoll å·²åˆå§‹åŒ–ã€‚ // netpollWaitersï¼šè®°å½•å½“å‰goroutineè¢«æŒ‚åœ¨epollä¸­çš„ç­‰å¾…æ•°é‡ã€‚ // pollUntilï¼š\u0026gt;0.ä¸‹ä¸ªtimerè§¦å‘çš„è€Œæ—¶é—´ç‚¹ã€‚ // atomic.Xchg64(\u0026amp;sched.lastpoll, 0)ï¼šè¿™é‡Œæ˜¯å”¯ä¸€çš„æŠŠsched.lastpollä¿®æ”¹ä¸º0çš„æƒ…å†µï¼Œ // è¡¨ç¤ºå½“å‰éœ€è¦é˜»å¡å¼çš„è°ƒç”¨netpollå‡½æ•°ã€‚ // è¿™é‡Œçš„atomic.Xchg64(\u0026amp;sched.lastpoll, 0) != 0 å…·æœ‰æ’ä»–æ€§ã€‚åªèƒ½æœ‰ä¸€ä¸ªå·¥ä½œçº¿ç¨‹å¤„äºé˜»å¡ç­‰å¾…ä¸­ã€‚ if netpollinited() \u0026amp;\u0026amp; (atomic.Load(\u0026amp;netpollWaiters) \u0026gt; 0 || pollUntil != 0) \u0026amp;\u0026amp; atomic.Xchg64(\u0026amp;sched.lastpoll, 0) != 0 { // sched.pollUntil = pollUntilï¼Œé¢„è®¡çš„é˜»å¡æ—¶é—´ç‚¹ã€‚ atomic.Store64(\u0026amp;sched.pollUntil, uint64(pollUntil)) if _g_.m.p != 0 { throw(\u0026#34;findrunnable: netpoll with p\u0026#34;) } if _g_.m.spinning { throw(\u0026#34;findrunnable: netpoll with spinning\u0026#34;) } // Refresh now. now = nanotime() delay := int64(-1) if pollUntil != 0 { // è®¡ç®—é¢„è®¡é˜»å¡çš„æ—¶é—´ delay = pollUntil - now if delay \u0026lt; 0 { // è§¦å‘æ—¶é—´ä»¥è¿‡ï¼Œè¦æ±‚ç«‹å³è¿”å› delay = 0 } } // faketimeæ˜¯è‡ª1970å¹´ä»¥æ¥æ¨¡æ‹Ÿçš„ä»¥çº³ç§’ä¸ºå•ä½çš„æ—¶é—´ã€‚ // 0å€¼æ„å‘³ç€ä¸ä½¿ç”¨faketimeã€‚ if faketime != 0 { // When using fake time, just poll. // å½“ä½¿ç”¨ fake timeï¼Œåªæ˜¯pollã€‚ delay = 0 } // é˜»å¡ç›´åˆ°æœ‰æ–°çš„workå¯ç”¨ï¼Œdelayæ˜¯ä¸€ä¸ªå…·ä½“çš„æ—¶é—´æ®µ list := netpoll(delay) // block until new work is available atomic.Store64(\u0026amp;sched.pollUntil, 0) // sched.pollUntil = 0 atomic.Store64(\u0026amp;sched.lastpoll, uint64(now)) // sched.lastpoll = now if faketime != 0 \u0026amp;\u0026amp; list.empty() { // Using fake time and nothing is ready; stop M. // When all M\u0026#39;s stop, checkdead will call timejump. stopm() goto top } lock(\u0026amp;sched.lock) // ä»ç©ºé—²Pé“¾è¡¨ä¸­è·å–ä¸€ä¸ªP _p_, _ = pidleget(now) unlock(\u0026amp;sched.lock) if _p_ == nil { // æ²¡æœ‰å¯ç”¨çš„ç©ºé—²Pæ—¶ã€‚ // å¦‚æœæœ‰å°±ç»ªçš„goroutineæ”¾å…¥å…¨å±€goroutineæ± ã€‚ injectglist(\u0026amp;list) } else { acquirep(_p_) // ç»‘å®šP if !list.empty() { // å–å‡ºä¸€ä¸ªgoroutineï¼Œç”¨äºè¿”å› gp := list.pop() // å‰©ä½™çš„ä¼˜å…ˆåŠ å…¥å…¨å±€æ± ã€‚ injectglist(\u0026amp;list) // ä¿®æ”¹goroutineçŠ¶æ€ä¸ºå¾…è¿è¡ŒçŠ¶æ€ casgstatus(gp, _Gwaiting, _Grunnable) if trace.enabled { traceGoUnpark(gp, 0) } // è¿”å›æ‰¾åˆ°çš„ goroutine return gp, false, false } // å¦‚æœä¹‹å‰Mæ˜¯è‡ªæ—‹ï¼Œåˆ™å†æ¬¡æ ‡è®°ä¸ºè‡ªæ—‹å¹¶ä»æ–°å†æ¥ä¸€æ¬¡ã€‚ if wasSpinning { _g_.m.spinning = true atomic.Xadd(\u0026amp;sched.nmspinning, 1) } goto top } } else if pollUntil != 0 \u0026amp;\u0026amp; netpollinited() { // æœ‰å…¶ä»–çš„çº¿ç¨‹åœ¨é˜»å¡ netpollã€‚ // sched.pollUntilï¼šä¸‹æ¬¡timeråº”è¯¥è¢«å”¤é†’æ—¶é—´ç‚¹ã€‚ pollerPollUntil := int64(atomic.Load64(\u0026amp;sched.pollUntil)) // timerè§¦å‘äº† æˆ– è§¦å‘æ—¶é—´å·²åˆ° å«é†’é˜»å¡çš„netpoll if pollerPollUntil == 0 || pollerPollUntil \u0026gt; pollUntil { netpollBreak() // å«é†’epoll } } // æŒ‚èµ·å½“å‰çº¿ç¨‹ç­‰å¾…å…¶ä»–çº¿ç¨‹å”¤é†’ã€‚ stopm() goto top } gcstopm() ä¸ºstopTheWorldåœæ­¢å½“å‰Mã€‚ å½“TheWordStartæ—¶è¿”å›ã€‚è¾…åŠ©STWã€‚ æ–‡ä»¶ä½ç½®ï¼šgo1.19.3/src/runtime/proc.goã€‚ è¯¥æ–¹æ³•åœ¨GCå‘èµ·æ—¶ï¼Œå…¶ä»–çº¿ç¨‹éƒ½åœ¨è¿™ä¸ªæ–¹æ³•ä¸ŠæŠŠè‡ªå·±æŒ‚èµ·ã€‚ 2481 2482 2483 2484 2485 2486 2487 2488 2489 2490 2491 2492 2493 2494 2495 2496 2497 2498 2499 2500 2501 2502 2503 2504 2505 2506 2507 2508 2509 2510 2511 2512 2513 2514 2515 // Stops the current m for stopTheWorld. // Returns when the world is restarted. func gcstopm() { _g_ := getg() // _g_ = g0 // sched.gcwaitingï¼šæ˜¯1ï¼Œè¡¨ç¤ºå½“å‰STWæ­£åœ¨ç­‰å¾…Påœä¸‹æ¥ã€‚ if sched.gcwaiting == 0 { throw(\u0026#34;gcstopm: not waiting for gc\u0026#34;) } // å½“å‰Mæ­£å¤„äºè‡ªæ—‹çŠ¶æ€ä¸‹ã€‚ if _g_.m.spinning { _g_.m.spinning = false // æ¸…é™¤è‡ªæ—‹æ ‡è®° // OK to just drop nmspinning here, // startTheWorld will unpark threads as necessary. // // è‡ªæ—‹è®¡æ•°å‡ºç°é”™è¯¯ if int32(atomic.Xadd(\u0026amp;sched.nmspinning, -1)) \u0026lt; 0 { throw(\u0026#34;gcstopm: negative nmspinning\u0026#34;) } } // è§£ç»‘å½“å‰Mä¸P _p_ := releasep() lock(\u0026amp;sched.lock) // _Pgcstopï¼šGCåœæ­¢çŠ¶æ€ã€‚ // Pè¢«STWæŒ‚èµ·ä»¥æ‰§è¡ŒGCï¼Œæ‰€æœ‰æƒå½’æ‰§è¡ŒSTWçš„Mæ‰€æœ‰ï¼Œæ‰§è¡ŒSTWçš„Mä¼šç»§ç»­ä½¿ç”¨å¤„äº_PgcstopçŠ¶æ€çš„Pã€‚ _p_.status = _Pgcstop // sched.stopwaitï¼šè®°å½•äº†STWéœ€è¦åœæ­¢çš„Pçš„æ•°é‡ sched.stopwait-- // å·²ç»åœä¸‹äº†æ‰€æœ‰çš„Pï¼Œéœ€è¦å”¤é†’åœ¨ sched.stopnote ä¸Šå‘èµ·STWçš„å·¥ä½œçº¿ç¨‹ã€‚ if sched.stopwait == 0 { notewakeup(\u0026amp;sched.stopnote) } unlock(\u0026amp;sched.lock) stopm() // åœæ­¢å½“å‰å·¥ä½œçº¿ç¨‹ã€‚ } releasep() è§£é™¤på’Œå½“å‰mçš„å…³è”ã€‚ æ–‡ä»¶ä½ç½®ï¼šgo1.19.3/src/runtime/proc.goã€‚ 4984 4985 4986 4987 4988 4989 4990 4991 4992 4993 4994 4995 4996 4997 4998 4999 5000 5001 5002 5003 5004 5005 5006 5007 // Disassociate p and the current m. func releasep() *p { _g_ := getg() // _g_ = g0 if _g_.m.p == 0 { throw(\u0026#34;releasep: invalid arg\u0026#34;) } _p_ := _g_.m.p.ptr() // _p_ = p // _p_.m == _g_.m \u0026amp;\u0026amp; _p_.status == _Prunning if _p_.m.ptr() != _g_.m || _p_.status != _Prunning { print(\u0026#34;releasep: m=\u0026#34;, _g_.m, \u0026#34; m-\u0026gt;p=\u0026#34;, _g_.m.p.ptr(), \u0026#34; p-\u0026gt;m=\u0026#34;, hex(_p_.m), \u0026#34; p-\u0026gt;status=\u0026#34;, _p_.status, \u0026#34;\\n\u0026#34;) throw(\u0026#34;releasep: invalid p state\u0026#34;) } if trace.enabled { traceProcStop(_g_.m.p.ptr()) } // è§£é™¤ p ä¸ m ç›¸äº’ç»‘å®šçš„å…³ç³»ã€‚ _g_.m.p = 0 _p_.m = 0 // _Pidleï¼šç©ºé—²çŠ¶æ€ã€‚ // æ­¤æ—¶çš„Pæ²¡æœ‰è¢«ç”¨æ¥æ‰§è¡Œç”¨æˆ·ä»£ç æˆ–è°ƒåº¦å™¨ä»£ç ï¼Œé€šå¸¸ä½äºç©ºé—²é“¾è¡¨ä¸­ï¼Œèƒ½å¤Ÿè¢«è°ƒåº¦å™¨è·å–ã€‚ _p_.status = _Pidle return _p_ } stopm() åœæ­¢æ‰§è¡Œå½“å‰mï¼Œç›´åˆ°æœ‰æ–°çš„å·¥ä½œå¯ç”¨ã€‚è¿”å›è·å–çš„Pã€‚ æ–‡ä»¶ä½ç½®ï¼šgo1.19.3/src/runtime/proc.goã€‚ 2229 2230 2231 2232 2233 2234 2235 2236 2237 2238 2239 2240 2241 2242 2243 2244 2245 2246 2247 2248 2249 2250 2251 2252 // Stops execution of the current m until new work is available. // Returns with acquired P. func stopm() { _g_ := getg() // _g_ = g0 if _g_.m.locks != 0 { throw(\u0026#34;stopm holding locks\u0026#34;) } if _g_.m.p != 0 { throw(\u0026#34;stopm holding p\u0026#34;) } if _g_.m.spinning { throw(\u0026#34;stopm spinning\u0026#34;) } lock(\u0026amp;sched.lock) mput(_g_.m) // æŠŠå½“å‰måŠ å…¥sched.midleä¸­ã€‚ unlock(\u0026amp;sched.lock) mPark() // å·¥ä½œçº¿ç¨‹sleepåœ¨m.parkä¸Š // å·¥ä½œçº¿ç¨‹å†æ¬¡è¢«wakeupæ—¶ï¼Œç»‘å®šPã€‚ acquirep(_g_.m.nextp.ptr()) // æ­¤å¤„pæ¥è‡ªm.nextpã€‚ _g_.m.nextp = 0 } mput() æŠŠmpåˆ—å…¥midleåˆ—è¡¨ä¸­ã€‚ sched.lock å¿…é¡»è¢«æŒæœ‰ã€‚ å¯èƒ½åœ¨STWæœŸé—´è¿è¡Œï¼Œå› æ­¤ä¸å…è®¸å‡ºç°å†™å±éšœã€‚ æ–‡ä»¶ä½ç½®ï¼šgo1.19.3/src/runtime/proc.goã€‚ 5533 5534 5535 5536 5537 5538 5539 5540 5541 5542 5543 5544 5545 5546 // Put mp on midle list. // sched.lock must be held. // May run during STW, so write barriers are not allowed. // //go:nowritebarrierrec func mput(mp *m) { assertLockHeld(\u0026amp;sched.lock) // æŠŠå½“å‰måŠ å…¥sched.midleã€‚ mp.schedlink = sched.midle sched.midle.set(mp) sched.nmidle++ checkdead() // æ£€æŸ¥æ­»é”ã€‚ } mPark() mParkä¼šå¯¼è‡´çº¿ç¨‹è‡ªè¡Œåœé©»ï¼Œä¸€æ—¦è¢«å”¤é†’å°±ä¼šè¿”å›ã€‚ æ–‡ä»¶ä½ç½®ï¼šgo1.19.3/src/runtime/proc.goã€‚ 1452 1453 1454 1455 1456 1457 1458 1459 // mPark causes a thread to park itself, returning once woken. // //go:nosplit func mPark() { gp := getg() // gp = g0 notesleep(\u0026amp;gp.m.park) // sleep noteclear(\u0026amp;gp.m.park) // æ¸…é™¤ m.park } acquirep() å…³è”på’Œå½“å‰mã€‚ æ–‡ä»¶ä½ç½®ï¼šgo1.19.3/src/runtime/proc.goã€‚ 4938 4939 4940 4941 4942 4943 4944 4945 4946 4947 4948 4949 4950 4951 4952 4953 4954 4955 4956 4957 // Associate p and the current m. // // This function is allowed to have write barriers even if the caller // isn\u0026#39;t because it immediately acquires _p_. // //go:yeswritebarrierrec func acquirep(_p_ *p) { // Do the part that isn\u0026#39;t allowed to have write barriers. wirep(_p_) // Have p; write barriers now allowed. // Perform deferred mcache flush before this P can allocate // from a potentially stale mcache. _p_.mcache.prepareForSweep() if trace.enabled { traceProcStart() } } globrunqget() å°è¯•ä»å…¨å±€å¯è¿è¡Œé˜Ÿåˆ—ä¸­è·å–ä¸€æ‰¹Gï¼Œsched.lockå¿…é¡»è¢«æŒæœ‰ã€‚ å‚æ•°ï¼š _p_ *pï¼šå½“å‰å·¥ä½œçº¿ç¨‹ç»‘å®šçš„Pã€‚ max int32ï¼šä»å…¨å±€é˜Ÿåˆ—ä¸­æ‹¿å¤šå°‘ä¸ªgåˆ°æœ¬åœ°Pä¸­ã€‚è¯¥å‚æ•°ä¸€èˆ¬æ˜¯1ï¼Œå¦‚æœæ˜¯å…¶ä»–På·å–åˆ™æ˜¯å¤§äº1ã€‚ è¿”å›å€¼*gï¼šä»å…¨å±€é˜Ÿåˆ—ä¸­é‚£åˆ°çš„goroutineã€‚ æ–‡ä»¶ä½ç½®ï¼šgo1.19.3/src/runtime/proc.goã€‚ 5601 5602 5603 5604 5605 5606 5607 5608 5609 5610 5611 5612 5613 5614 5615 5616 5617 5618 5619 5620 5621 5622 5623 5624 5625 5626 5627 5628 5629 5630 5631 5632 5633 5634 5635 5636 5637 5638 5639 5640 5641 5642 5643 5644 // Try get a batch of G\u0026#39;s from the global runnable queue. // sched.lock must be held. func globrunqget(_p_ *p, max int32) *g { assertLockHeld(\u0026amp;sched.lock) // sched.runqsizeï¼šè®°å½•çš„æ˜¯å…¨å±€å°±ç»ªé˜Ÿåˆ—çš„é•¿åº¦ã€‚ // ä¹Ÿå°±æ˜¯å…¨å±€é˜Ÿåˆ—goroutineçš„ä¸ªæ•°ã€‚ if sched.runqsize == 0 { return nil } // æ ¹æ®pçš„æ•°é‡å¹³åˆ†å…¨å±€è¿è¡Œé˜Ÿåˆ—ä¸­çš„goroutines n := sched.runqsize/gomaxprocs + 1 // ä¸Šé¢è®¡ç®—nçš„æ–¹æ³•å¯èƒ½å¯¼è‡´nå¤§äºå…¨å±€è¿è¡Œé˜Ÿåˆ—ä¸­çš„goroutineæ•°é‡ if n \u0026gt; sched.runqsize { n = sched.runqsize } // maxï¼šè¡¨ç¤ºæœ€å¤šæ‹¿å»goroutineä¸ªæ•°ã€‚ if max \u0026gt; 0 \u0026amp;\u0026amp; n \u0026gt; max { n = max } // æœ€å¤šåªèƒ½å–æœ¬åœ°é˜Ÿåˆ—å®¹é‡çš„ä¸€åŠã€‚ // _p_.runqï¼šæœ€å¤§256ã€‚ if n \u0026gt; int32(len(_p_.runq))/2 { n = int32(len(_p_.runq)) / 2 } sched.runqsize -= n // å‡å»å–å‡ºçš„æ•°é‡ // popä»å…¨å±€è¿è¡Œé˜Ÿåˆ—çš„é˜Ÿåˆ—å¤´å–ä¸€ä¸ªgoroutineã€‚ // è¿™ä¸ªgoroutineç”¨äºè¿”å›ã€‚ gp := sched.runq.pop() n-- // éå†ä»å…¨å±€é˜Ÿåˆ—ä¸­æ‹¿å–goroutineåˆ°Pçš„æœ¬åœ°é˜Ÿåˆ—ä¸­ã€‚ for ; n \u0026gt; 0; n-- { // ä»å…¨å±€è¿è¡Œé˜Ÿåˆ—ä¸­å–å‡ºä¸€ä¸ªgoroutine gp1 := sched.runq.pop() // æ”¾å…¥æœ¬åœ°è¿è¡Œé˜Ÿåˆ—ï¼Œfalse.æ”¾å…¥å°¾éƒ¨ã€‚ // 1. goå…³é”®å­—æ—¶ï¼Œè°ƒç”¨è¯¥æ–¹æ³•ä¼ å…¥çš„true // 2. ä»å…¨å±€æ‹¿å–æ—¶ï¼Œè¿™é‡Œä¼ å…¥çš„æ—¶false runqput(_p_, gp1, false) } return gp } runqput() æŠŠgpæ”¾å…¥_p_çš„å°¾éƒ¨ã€‚ å‚æ•°ï¼š _p_ *pï¼šæœ¬åœ°Pã€‚ gp *gï¼šéœ€è¦æ”¾å…¥_p_çš„goroutineã€‚ next boolï¼štrueæ”¾å…¥æœ¬åœ°_p_çš„å¼€å¤´ï¼Œfalseæ”¾å…¥æœ¬åœ°_p_çš„å°¾éƒ¨ã€‚ æ–‡ä»¶ä½ç½®ï¼šgo1.19.3/src/runtime/proc.goã€‚ 5780 5781 5782 5783 5784 5785 5786 5787 5788 5789 5790 5791 5792 5793 5794 5795 5796 5797 5798 5799 5800 5801 5802 5803 5804 5805 5806 5807 5808 5809 5810 5811 5812 5813 5814 5815 5816 5817 // runqput tries to put g on the local runnable queue. // If next is false, runqput adds g to the tail of the runnable queue. // If next is true, runqput puts g in the _p_.runnext slot. // If the run queue is full, runnext puts g on the global queue. // Executed only by the owner P. func runqput(_p_ *p, gp *g, next bool) { if randomizeScheduler \u0026amp;\u0026amp; next \u0026amp;\u0026amp; fastrandn(2) == 0 { next = false } if next { retryNext: oldnext := _p_.runnext if !_p_.runnext.cas(oldnext, guintptr(unsafe.Pointer(gp))) { goto retryNext } if oldnext == 0 { return } // Kick the old runnext out to the regular run queue. gp = oldnext.ptr() } retry: h := atomic.LoadAcq(\u0026amp;_p_.runqhead) // load-acquire, synchronize with consumers t := _p_.runqtail if t-h \u0026lt; uint32(len(_p_.runq)) { _p_.runq[t%uint32(len(_p_.runq))].set(gp) atomic.StoreRel(\u0026amp;_p_.runqtail, t+1) // store-release, makes the item available for consumption return } // ä»_P_ä¸­ç§»é™¤ä¸€éƒ¨åˆ†åˆ°å…¨å±€ä¸­ï¼ŒåŒ…å«gpã€‚ if runqputslow(_p_, gp, h, t) { return } // the queue is not full, now the put above must succeed goto retry } runqget() ä»æœ¬åœ°å¯è¿è¡Œé˜Ÿåˆ—ä¸­è·å–goroutineã€‚ å¦‚æœinheritTimeä¸ºtrueï¼Œåˆ™gpåº”ç»§æ‰¿å½“å‰æ—¶é—´ç‰‡ä¸­çš„å‰©ä½™æ—¶é—´ã€‚å¦åˆ™ï¼Œå®ƒåº”è¯¥å¼€å§‹ä¸€ä¸ªæ–°çš„æ—¶é—´ç‰‡ã€‚ å¤šæœ‰è€…ç”±å½“å‰Pæ‹¥æœ‰ã€‚ å‚æ•°ï¼š_p_ *pï¼šå½“å‰æœ¬åœ°Pï¼Œå¯èƒ½å‡ºç°å…¶ä»–å·¥ä½œçº¿ç¨‹Må·å–Pçš„æƒ…å†µã€‚ è¿”å›å€¼ï¼š gp *gï¼šå½“å‰è·å–åˆ°çš„goroutineã€‚ inheritTime boolï¼šæ˜¯å¦ç»§æ‰¿å½“å‰æ—¶é—´ç‰‡ã€‚ æ–‡ä»¶ä½ç½®ï¼šgo1.19.3/src/runtime/proc.goã€‚ 5893 5894 5895 5896 5897 5898 5899 5900 5901 5902 5903 5904 5905 5906 5907 5908 5909 5910 5911 5912 5913 5914 5915 5916 5917 5918 5919 5920 5921 5922 5923 5924 5925 5926 5927 5928 5929 5930 5931 5932 5933 5934 5935 // Get g from local runnable queue. // If inheritTime is true, gp should inherit the remaining time in the // current time slice. Otherwise, it should start a new time slice. // Executed only by the owner P. func runqget(_p_ *p) (gp *g, inheritTime bool) { // If there\u0026#39;s a runnext, it\u0026#39;s the next G to run. // // å¦‚æœæœ‰ runnextï¼Œå®ƒå°±æ˜¯ä¸‹ä¸€ä¸ªè¦è¿è¡Œçš„ G next := _p_.runnext // If the runnext is non-0 and the CAS fails, it could only have been stolen by another P, // because other Ps can race to set runnext to 0, but only the current P can set it to non-0. // Hence, there\u0026#39;s no need to retry this CAS if it falls. // // å¦‚æœ runnext æ˜¯ non-0 å¹¶ä¸” CAS å¤±è´¥ï¼Œå®ƒåªèƒ½è¢«å¦ä¸€ä¸ªPçªƒå–ï¼Œå› ä¸ºå…¶ä»–På¯ä»¥ç«ç›¸å°†runnextè®¾ç½®ä¸º0ï¼Œ // å½“å‰På¯ä»¥å°†å…¶è®¾ç½®ä¸ºé 0ã€‚ å› æ­¤ï¼Œå¦‚æœè¯¥ CAS å¤±è´¥ï¼Œåˆ™æ— éœ€é‡è¯•ã€‚ if next != 0 \u0026amp;\u0026amp; _p_.runnext.cas(next, 0) { // ä» p.runnextä¸Šå–å‡ºçš„goroutineï¼Œéƒ½ç»§æ‰¿äº†ä¸Šæ¬¡çš„æ—¶é—´ç‰‡ // channel çš„sendå’Œrecvæ“ä½œéƒ½ä¼šæŠŠgoroutineæŒ‚åœ¨ p.runnext ä¸Š return next.ptr(), true } // p.runnext == 0 || å½“å‰goroutineå·²è¢«çªƒå–ã€‚ for { // åŸå­è¯»å– _p_.runqheadã€‚ // å½“å‰På’Œå…¶ä»–Pæ¥å·å–goroutineéƒ½æ˜¯ä»runqheadå¼€å§‹çš„ï¼Œå› æ­¤éœ€è¦åŸå­è¯»å–ã€‚ h := atomic.LoadAcq(\u0026amp;_p_.runqhead) // load-acquire, synchronize with other consumers // runqtailï¼šåªæœ‰æœ¬åœ°Pä¼šä¿®æ”¹è¿™ä¸ªå€¼åŠ å…¥goroutineã€‚å½“å‰Påœ¨æ­¤æ“ä½œå› æ­¤runqtailä¸ä¼šæ”¹å˜ä¸éœ€åŸå­æ“ä½œã€‚ t := _p_.runqtail // æœ¬åœ°Pé˜Ÿåˆ—ä¸ºç©ºã€‚ if t == h { return nil, false } // å–å‡ºå½“å‰hä½ç½®ä¸Šçš„gï¼Œæ³¨æ„å¾ªç¯é˜Ÿåˆ—æ˜¯é€šè¿‡runqheadå’Œrunqtailä¸æ–­çš„ç´¯åŠ ç„¶åé€šè¿‡æ±‚ä½™åˆ¤æ–­ä½ç½®çš„ // ç”±äºrunqheadå’Œrunqtailéƒ½æ˜¯uint32ç±»å‹å¾ªç¯æ•°ç»„å¤§å°ä¸º256æ­£å¥½æ˜¯æ•´å€æ•°ï¼Œ // å› æ­¤uint32ä¸æ–­ç´¯è®¡æœ€åä¼šä»0åˆå¼€å§‹ï¼Œå½¢æˆä¸€ä¸ªå¾ªç¯ gp := _p_.runq[h%uint32(len(_p_.runq))].ptr() // CAS è®¾ç½® _p_.runqheadï¼Œè¿™æ®µæ—¶é—´å¯èƒ½ _p_.runqhead çš„å€¼å‘ç”Ÿå˜åŒ–è€Œå¤±è´¥ã€‚ if atomic.CasRel(\u0026amp;_p_.runqhead, h, h+1) { // cas-release, commits consume return gp, false } } } injectglist() injectglist å°†åˆ—è¡¨ä¸Šçš„æ¯ä¸ªå¯è¿è¡Œçš„Gæ·»åŠ åˆ°æŸä¸ªè¿è¡Œé˜Ÿåˆ—ï¼Œå¹¶æ¸…é™¤glistã€‚ å¦‚æœå½“å‰ä¸å­˜åœ¨Pï¼Œåˆ™å°†å®ƒä»¬æ·»åŠ åˆ°å…¨å±€é˜Ÿåˆ—ï¼Œå¹¶å¯åŠ¨å¤šè¾¾npimä¸ªé˜Ÿåˆ—æ¥è¿è¡Œå®ƒä»¬ã€‚ å¦åˆ™ï¼Œå¯¹äºæ¯ä¸ªç©ºé—²çš„Pï¼Œå°†Gæ·»åŠ åˆ°å…¨å±€é˜Ÿåˆ—ï¼Œå¹¶å¯åŠ¨ä¸€ä¸ªmã€‚å‰©ä½™çš„Gæ·»åŠ åˆ°å½“å‰Pçš„æœ¬åœ°å°±ç»ªé˜Ÿåˆ—ã€‚ è¿™å¯èƒ½ä¼šä¸´æ—¶è·å–sched.lockã€‚å¯ä»¥ä¸GCå¹¶å‘è¿è¡Œã€‚ è¯¥å‡½æ•°åœ¨netpollåè°ƒç”¨ï¼Œå¯ä»¥æ˜¯ç›‘æ§çº¿ç¨‹ä¸­è¿™ç§æƒ…å†µä¸‹æ²¡æœ‰Pï¼Œæˆ–åˆ™è°ƒåº¦å¾ªç¯ä¸­ã€‚ æ–‡ä»¶ä½ç½®ï¼šgo1.19.3/src/runtime/proc.goã€‚ 3113 3114 3115 3116 3117 3118 3119 3120 3121 3122 3123 3124 3125 3126 3127 3128 3129 3130 3131 3132 3133 3134 3135 3136 3137 3138 3139 3140 3141 3142 3143 3144 3145 3146 3147 3148 3149 3150 3151 3152 3153 3154 3155 3156 3157 3158 3159 3160 3161 3162 3163 3164 3165 3166 3167 3168 3169 3170 3171 3172 3173 3174 3175 3176 3177 3178 3179 3180 3181 3182 3183 3184 3185 3186 3187 3188 3189 3190 3191 3192 3193 3194 3195 3196 3197 // injectglist adds each runnable G on the list to some run queue, // and clears glist. If there is no current P, they are added to the // global queue, and up to npidle M\u0026#39;s are started to run them. // Otherwise, for each idle P, this adds a G to the global queue // and starts an M. Any remaining G\u0026#39;s are added to the current P\u0026#39;s // local run queue. // This may temporarily acquire sched.lock. // Can run concurrently with GC. func injectglist(glist *gList) { // goroutine ç©ºåˆ—è¡¨ if glist.empty() { return } if trace.enabled { for gp := glist.head.ptr(); gp != nil; gp = gp.schedlink.ptr() { traceGoUnpark(gp, 0) } } // Mark all the goroutines as runnable before we put them // on the run queues. head := glist.head.ptr() var tail *g // è·å–é˜Ÿåˆ—æœ€åä¸€ä¸ª goroutine qsize := 0 // è®°å½•goroutineæ•°é‡ // ä¿®æ”¹è¿™äº›goroutineçš„çŠ¶æ€ for gp := head; gp != nil; gp = gp.schedlink.ptr() { tail = gp qsize++ // _Gwaitingï¼šgoroutineé˜»å¡åœ¨runtimeä¸­ï¼Œæ²¡æœ‰æ‰§è¡Œç”¨æˆ·ä»£ç ã€‚å®ƒä¸åœ¨ä»»ä½•runqä¸­ï¼Œä½†æ˜¯åº”è¯¥è¢«è®°å½•åœ¨å…¶ä»–åœ°æ–¹ã€‚ // _Grunnableï¼šgoroutineåº”è¯¥åœ¨æŸä¸ªrunqä¸­ï¼Œå½“å‰å¹¶æ²¡æœ‰åœ¨è¿è¡Œç”¨æˆ·ä»£ç ï¼Œå®ƒçš„æ ˆä¸å½’è‡ªå·±æ‰€æœ‰ã€‚ casgstatus(gp, _Gwaiting, _Grunnable) } // Turn the gList into a gQueue. // å°†è¿™ä¸ªgListè½¬æ¢ä¸ºä¸€ä¸ªgQueueã€‚ var q gQueue // åŒå‘é“¾è¡¨ q.head.set(head) q.tail.set(tail) *glist = gList{} startIdle := func(n int) { // æŒ‡å®šæ•°é‡çš„ç©ºé—²Pèµ·æ¥å·¥ä½œ for ; n != 0 \u0026amp;\u0026amp; sched.npidle != 0; n-- { startm(nil, false) } } pp := getg().m.p.ptr() // pp // å¦‚æœæ¥è‡ªsysmonç›‘æ§çº¿ç¨‹ï¼Œpp = nilã€‚ if pp == nil { lock(\u0026amp;sched.lock) // æ”¾å…¥å…¨å±€ sched.runq æ± ä¸­ globrunqputbatch(\u0026amp;q, int32(qsize)) unlock(\u0026amp;sched.lock) // å”¤é†’qsizeå¤šä¸ªç©ºé—²Pæ¥å¤„ç†è¿™äº›goroutine startIdle(qsize) return } // ä»¥ä¸‹æ˜¯å­˜åœ¨Pçš„æƒ…å†µ // ç©ºé—²çš„Pçš„æ•°é‡ npidle := int(atomic.Load(\u0026amp;sched.npidle)) var globq gQueue var n int // æŠŠç©ºé—²Pæ•°é‡ä¸ªæ•°çš„goroutineæ”¾å…¥å…¨å±€æ± ä¸­ï¼Œç„¶åå”¤é†’Pèµ·æ¥å·¥ä½œ for n = 0; n \u0026lt; npidle \u0026amp;\u0026amp; !q.empty(); n++ { g := q.pop() globq.pushBack(g) } if n \u0026gt; 0 { lock(\u0026amp;sched.lock) // æ”¾å…¥å…¨å±€ sched.runq æ± ä¸­ globrunqputbatch(\u0026amp;globq, int32(n)) unlock(\u0026amp;sched.lock) // å”¤é†’qsizeå¤šä¸ªç©ºé—²Pæ¥å¤„ç†è¿™äº›goroutine startIdle(n) qsize -= n } if !q.empty() { // è¿˜å‰©çš„goroutineæ”¾å…¥æœ¬åœ°é˜Ÿåˆ—ä¸­ runqputbatch(pp, \u0026amp;q, qsize) } } stealWork() stealWorkè¯•å›¾ä»ä»»ä½•Pä¸­çªƒå–ä¸€ä¸ªå¯è¿è¡Œçš„goroutineæˆ–timerã€‚ å¦‚æœè¿”å›å€¼newWorkä¸ºtrueï¼Œåˆ™æ–°å·¥ä½œå¯èƒ½å·²ç»å‡†å¤‡å¥½äº†ã€‚ å¦‚æœnowä¸æ˜¯0ï¼Œåˆ™ä¸ºå½“å‰æ—¶é—´ã€‚stealWorkè¿”å›ç»è¿‡çš„æ—¶é—´ï¼Œå¦‚æœnowè¢«ä¼ é€’ä¸º0ï¼Œåˆ™è¿”å›å½“å‰æ—¶é—´ã€‚ å‚æ•°now int64ï¼šä¸æ˜¯ 0ï¼Œåˆ™ä¸ºå½“å‰æ—¶é—´ã€‚ è¿”å›å€¼ï¼š gp *gï¼šè·å–åˆ°çš„goroutineã€‚ inheritTime boolï¼šæ˜¯å¦ç»§æ‰¿å½“å‰æ—¶é—´ç‰‡ã€‚ rnow int64ï¼šè·å–æ—¶é—´ç‚¹ã€‚ pollUntil int64ï¼štimerçš„è§¦å‘æ—¶é—´ç‚¹ã€‚ newWork boolï¼šä¸º trueï¼Œåˆ™æ–°å·¥ä½œå¯èƒ½å·²ç»å‡†å¤‡å¥½äº†ã€‚ä¼šè·³è½¬åˆ°findRunnableå‡½æ•°topæ ‡ç­¾å¤„ä»æ–°å¼€å§‹ã€‚ çªƒå–é€»è¾‘ä¼šå¾ªç¯å°è¯•4æ¬¡ï¼Œæœ€åä¸€æ¬¡æ‰ä¼šçªƒå–runnextå’Œtimerï¼Œä¹Ÿå°±æ˜¯è¯´å‰3æ¬¡åªä¼šä»å…¶ä»–Pçš„æœ¬åœ°runqä¸­çªƒå–ã€‚ stealOrderç”¨æ¥å®ç°ä¸€ä¸ªå…¬å¹³çš„éšæœºçªƒå–é¡ºåºï¼ŒtimerpMaskå’ŒidlepMaskç”¨æ¥å¿«é€Ÿåˆ¤æ–­æŒ‡å®šä½ç½®çš„Pæ˜¯å¦æœ‰timeræˆ–æ˜¯ç©ºé—²ã€‚ æ–‡ä»¶ä½ç½®ï¼šgo1.19.3/src/runtime/proc.goã€‚ 2899 2900 2901 2902 2903 2904 2905 2906 2907 2908 2909 2910 2911 2912 2913 2914 2915 2916 2917 2918 2919 2920 2921 2922 2923 2924 2925 2926 2927 2928 2929 2930 2931 2932 2933 2934 2935 2936 2937 2938 2939 2940 2941 2942 2943 2944 2945 2946 2947 2948 2949 2950 2951 2952 2953 2954 2955 2956 2957 2958 2959 2960 2961 2962 2963 2964 2965 2966 2967 2968 2969 2970 2971 2972 2973 2974 2975 2976 2977 2978 2979 2980 2981 2982 2983 2984 2985 2986 2987 2988 2989 2990 2991 2992 2993 2994 2995 2996 2997 2998 2999 3000 3001 3002 3003 3004 3005 3006 3007 3008 3009 3010 3011 3012 3013 3014 3015 3016 3017 // stealWork attempts to steal a runnable goroutine or timer from any P. // // If newWork is true, new work may have been readied. // // If now is not 0 it is the current time. stealWork returns the passed time or // the current time if now was passed as 0. func stealWork(now int64) (gp *g, inheritTime bool, rnow, pollUntil int64, newWork bool) { pp := getg().m.p.ptr() // pp = p ranTimer := false // newWork çš„è¿”å›å€¼ // å°è¯•å·å–æœ€å¤§æ¬¡æ•° const stealTries = 4 // æ‰§è¡Œå››æ¬¡éå†ï¼Œå°±æ˜¯å°½æœ€å¤§åŠªåŠ›å»å…¶ä»–Pä¸­æŸ¥çœ‹ for i := 0; i \u0026lt; stealTries; i++ { // æœ€åä¸€æ¬¡æ—¶ï¼š // 1. å‰ä¸‰æ¬¡å°è¯•å»Pçš„runqæœ¬åœ°é˜Ÿåˆ—ä¸­å·å–goroutineã€‚ // 2. æœ€åä¸€æ¬¡å…ˆå»å„ä¸ªPçš„timersé‡Œçœ‹çœ‹ï¼Œç„¶åå½“å·å–çš„Pçš„runqä¸ºç©ºæ—¶ï¼Œ // å°è¯•å·å–P.runnextä¸Šçš„goroutineã€‚ stealTimersOrRunNextG := i == stealTries-1 // randomOrder/randomEnum æ˜¯éšæœºå·¥ä½œçªƒå–çš„è¾…åŠ©ç±»å‹ï¼Œä¸€è½®allpéå†å¼€å§‹ã€‚ // å®ƒä»¬å…è®¸ä»¥ä¸åŒçš„ä¼ªéšæœºé¡ºåºæšä¸¾æ‰€æœ‰ P è€Œä¸é‡å¤ã€‚ // è¯¥ç®—æ³•åŸºäºè¿™æ ·ä¸€ä¸ªäº‹å®ï¼š // å¦‚æœæˆ‘ä»¬æœ‰Xä½¿å¾—Xå’ŒGOMAXPROCSäº’è´¨ï¼Œé‚£ä¹ˆ(i + X)%GOMAXPROCSçš„åºåˆ—ç»™å‡ºæ‰€éœ€çš„æšä¸¾ã€‚ // stealOrder.start(fastrand())ï¼šä»ä¸€ä¸ªéšæœºä½ç½®å¼€å§‹ã€‚ // !enum.done()ï¼šå½“å‰æ˜¯å¦å·²ç»éå†ä¸€åœˆäº†ã€‚ // enum.next()ï¼šè·³è½¬åˆ°ä¸‹ä¸€ä¸ªä½ç½®ã€‚ for enum := stealOrder.start(fastrand()); !enum.done(); enum.next() { // æœ‰STWæ­£åœ¨ç­‰å¾…PæŒ‚èµ·ã€‚ç›´æ¥è¿”å›ã€‚ // è·³è½¬åˆ°findRunnableå‡½æ•°topæ ‡ç­¾å¤„ä»æ–°å¼€å§‹ã€‚ if sched.gcwaiting != 0 { // GC work may be available. return nil, false, now, pollUntil, true } // éšæœºé€‰çš„pï¼Œå¦‚æœæ˜¯å½“å‰çš„è·³è¿‡ã€‚ // enum.position()ï¼šå½“å‰å·å–Pçš„ä¸‹æ ‡ã€‚ p2 := allp[enum.position()] if pp == p2 { continue } // Steal timers from p2. This call to checkTimers is the only place // where we might hold a lock on a different P\u0026#39;s timers. We do this // once on the last pass before checking runnext because stealing // from the other P\u0026#39;s runnext should be the last resort, so if there // are timers to steal do that first. // // We only check timers on one of the stealing iterations because // the time stored in now doesn\u0026#39;t change in this loop and checking // the timers for each P more than once with the same value of now // is probably a waste of time. // // timerpMask tells us whether the P may have timers at all. If it // can\u0026#39;t, no need to check at all. // // ä»p2ä¸­çªƒå– timersã€‚å¯¹checkTimersçš„è°ƒç”¨æ˜¯å”¯ä¸€å¯ä»¥å¯¹ä¸åŒPçš„timersæŒæœ‰é”çš„åœ°æ–¹ã€‚ // æˆ‘ä»¬åœ¨æ£€æŸ¥runnextä¹‹å‰çš„æœ€åä¸€éæ‰§è¡Œæ­¤æ“ä½œï¼Œå› ä¸ºä»å¦ä¸€ä¸ªPçš„runnextä¸­çªƒå–è®¡æ—¶å™¨åº”è¯¥æ˜¯æœ€åçš„æ‰‹æ®µï¼Œ // æ‰€ä»¥å¦‚æœæœ‰timerså¯ä»¥çªƒå–ï¼Œè¯·å…ˆçªƒå–ã€‚ // æˆ‘ä»¬åªæ£€æŸ¥å…¶ä¸­ä¸€ä¸ªçªƒå–è¿­ä»£çš„å®šæ—¶å™¨ï¼Œå› ä¸ºå­˜å‚¨åœ¨nowä¸­çš„æ—¶é—´åœ¨è¿™ä¸ªå¾ªç¯ä¸­ä¸ä¼šæ”¹å˜ï¼Œ // å¦‚æœç”¨ç›¸åŒçš„nowå€¼å¤šæ¬¡æ£€æŸ¥æ¯ä¸ªPçš„å®šæ—¶å™¨ï¼Œå¯èƒ½å°±æ˜¯æµªè´¹æ—¶é—´ã€‚ // timerpMaskå‘Šè¯‰æˆ‘ä»¬Pæ˜¯å¦æœ‰å®šæ—¶å™¨ã€‚å¦‚æœå®ƒä¸èƒ½ï¼Œæ ¹æœ¬ä¸éœ€è¦æ£€æŸ¥ã€‚ // timerpMask æ˜¯Pçš„ä½å›¾è®°å½•å½“å‰Pä¸Šæ˜¯å¦æœ‰ timerã€‚ if stealTimersOrRunNextG \u0026amp;\u0026amp; timerpMask.read(enum.position()) { // å†æ¬¡çœ‹çœ‹ timersï¼Œæ˜¯å¦æœ‰åˆ°ç‚¹éœ€è¦æ‰§è¡Œçš„timerã€‚ // tnowï¼šè¿”å›çš„now // wï¼šè§¦å‘æ—¶é—´ç‚¹ // ranï¼štimeræ˜¯å¦å·²ç»è¿è¡Œäº† // å¦‚æœranä¸ºtrueï¼Œè¡¨ç¤ºcheckTimers()æ‰§è¡Œäº†p2çš„timerï¼Œ // å¯èƒ½ä¼šä½¿æŸäº›goroutineå˜æˆ_GrunnableçŠ¶æ€ï¼Œ // æ‰€ä»¥å…ˆæ£€æŸ¥å½“å‰Pçš„æœ¬åœ°runqï¼Œå¦‚æœæ²¡æœ‰æ‰¾åˆ°ç»§ç»­å»å·å–ã€‚ tnow, w, ran := checkTimers(p2, now) now = tnow // w != 0ï¼šè¿˜æœªè§¦å‘çš„æ—¶é—´ç‚¹ // pollUntil == 0ï¼šä¸Šæ¬¡æ£€æŸ¥æ²¡æœ‰timer // w \u0026lt; pollUntilï¼šè§¦å‘æ—¶é—´ç‚¹ç¼©å° if w != 0 \u0026amp;\u0026amp; (pollUntil == 0 || w \u0026lt; pollUntil) { pollUntil = w // æœ€è¿‘çš„timerè§¦å‘çš„æ—¶é—´ç‚¹ } // æœ‰è§¦å‘timerè¿è¡Œï¼Œéœ€è¦å»Pçš„æœ¬åœ°runqä¸­å»æ‰¾æ‰¾å¯èƒ½æœ‰goroutineè¢«æ”¾é‡Œé¢äº†ã€‚ // æ¯”å¦‚time.Sleepã€‚ if ran { // Running the timers may have // made an arbitrary number of G\u0026#39;s // ready and added them to this P\u0026#39;s // local run queue. That invalidates // the assumption of runqsteal // that it always has room to add // stolen G\u0026#39;s. So check now if there // is a local G to run. if gp, inheritTime := runqget(pp); gp != nil { return gp, inheritTime, now, pollUntil, ranTimer } // æ ‡è®°ä¸ºtrueï¼Œå†æ¬¡è·‘ä¸€è¾¹è°ƒåº¦å¾ªç¯ ranTimer = true } } // Don\u0026#39;t bother to attempt to steal if p2 is idle. // // å¦‚æœp2æ˜¯ç©ºé—²çš„ä¸è¦å°è¯•å·å–ã€‚ // åœ¨åˆ›å»ºgoroutineæ—¶å€™æˆ‘ä»¬é‡è§è¿‡idlepMaskï¼Œè¯¥å€¼æ˜¯Pçš„ä½å›¾ï¼Œè®°å½•äº†æ‰€æœ‰ç©ºé—²çš„Pçš„bitä½(åŸå­æ›´æ–°)ã€‚ // idlepMask.read(enum.position())ï¼štrue.å½“å‰Pæ˜¯ç©ºé—²çš„ï¼Œfalse.å½“å‰Pä¸æ˜¯ç©ºé—²çš„ã€‚ if !idlepMask.read(enum.position()) { // runqsteal å‡½æ•°ä»p2ä¸­å·å–goroutineåˆ°ppä¸­ã€‚ // stealTimersOrRunNextGè¡¨ç¤ºæœ€å¤§ç¨‹åº¦å·å–runnextã€‚ if gp := runqsteal(pp, p2, stealTimersOrRunNextG); gp != nil { return gp, false, now, pollUntil, ranTimer } } } } // No goroutines found to steal. Regardless, running a timer may have // made some goroutine ready that we missed. Indicate the next timer to // wait for. return nil, false, now, pollUntil, ranTimer } runqsteal() ä»p2çš„æœ¬åœ°å¯è¿è¡Œé˜Ÿåˆ—ä¸­çªƒå–ä¸€åŠçš„gï¼Œå¹¶æ”¾å…¥pçš„æœ¬åœ°å¯è¿è¡Œé˜Ÿåˆ—ä¸­ã€‚ è¿”å›ä¸€ä¸ªè¢«çªƒå–çš„g(å¦‚æœå¤±è´¥åˆ™è¿”å›nil)ã€‚ å‚æ•°ï¼š _p_ *pï¼šå½“å‰çªƒå–å…¶ä»–Pçš„å·¥ä½œçº¿ç¨‹ç»‘å®šçš„Pã€‚ p2 *pï¼šè¢«çªƒå–çš„Pã€‚ stealRunNextG boolï¼štrueå°½æœ€å¤§åŠªåŠ›å»p.runnextä¸Šå·å–ï¼Œfalseä¸å·å–p.runnextçš„goroutineã€‚ è¿”å›å€¼*gï¼šå·å–åˆ°çš„goroutineã€‚ æ–‡ä»¶ä½ç½®ï¼šgo1.19.3/src/runtime/proc.goã€‚ 6015 6016 6017 6018 6019 6020 6021 6022 6023 6024 6025 6026 6027 6028 6029 6030 6031 6032 6033 6034 6035 6036 6037 6038 6039 6040 6041 6042 6043 // Steal half of elements from local runnable queue of p2 // and put onto local runnable queue of p. // Returns one of the stolen elements (or nil if failed). func runqsteal(_p_, p2 *p, stealRunNextG bool) *g { t := _p_.runqtail // å°è¯•ä»p2ä¸­å·å–ä¸€åŠçš„goroutineã€‚ n := runqgrab(p2, \u0026amp;_p_.runq, t, stealRunNextG) // p2ä¸­ä¹Ÿæ²¡æœ‰ if n == 0 { return nil } // ä»pçš„æœ¬åœ°runqä¸­å–å‡ºä¸€ä¸ªgoroutineï¼Œç”¨äºè¿”å›ç»™è°ƒåº¦å™¨è°ƒåº¦èµ·æ¥ã€‚ n-- // å› ä¸ºå·å–æ˜¯ä»runqtailå¼€å§‹çš„ï¼Œå› æ­¤runqtailå¤„ä¹Ÿæ˜¯headå¤´å¤„ã€‚ // å…¶å®æ˜¯å–çš„é˜Ÿåˆ—ä¸­çš„æœ€åä¸€ä¸ªï¼Œæ–¹ä¾¿åé¢ StoreRel åŸå­æ“ä½œè®¾ç½® runqtail å€¼ã€‚ gp := _p_.runq[(t+n)%uint32(len(_p_.runq))].ptr() if n == 0 { return gp } // è¿˜æœ‰å…¶ä»–çš„éœ€è¦å¤„ç†ï¼ŒåŸå­è¯»å– _p_.runqhead h := atomic.LoadAcq(\u0026amp;_p_.runqhead) // load-acquire, synchronize with consumers // è¿™é‡Œåˆ¤æ–­å·å–çš„gæ˜¯å¦å¤§äºPæœ¬åœ°çš„ä¸€åŠæ•°é‡ï¼Œåˆ™æ˜¯æº¢å‡ºäº† if t-h+n \u0026gt;= uint32(len(_p_.runq)) { throw(\u0026#34;runqsteal: runq overflow\u0026#34;) } // åŸå­è®¾ç½® _p_.runqtail = t+n atomic.StoreRel(\u0026amp;_p_.runqtail, t+n) // store-release, makes the item available for consumption return gp } runqgrab() ä»_p_çš„å¯è¿è¡Œé˜Ÿåˆ—ä¸­è·å–ä¸€æ‰¹goroutinesåˆ°batchã€‚ Batchæ˜¯ä¸€ä¸ªä»batchHeadå¼€å§‹çš„ç¯å½¢ç¼“å†²åŒºã€‚ è¿”å›æŠ“å–çš„goroutinesçš„æ•°é‡ã€‚å¯ä»¥è¢«ä»»æ„Pæ‰§è¡Œã€‚ å‚æ•°ï¼šå‡è®¾ä»p2å·å–åˆ°pã€‚ _p_ *pï¼šå·å–ç›®æ ‡çš„Pã€‚å°±æ˜¯p2. batch *[256]guintptrï¼šä»_p_å·å–goroutineéœ€è¦æ”¾åˆ°çš„Pçš„runqæœ¬åœ°é˜Ÿåˆ—æ± ã€‚å°±æ˜¯pçš„æœ¬åœ°runqæ± ã€‚ batchHead uint32ï¼špçš„runqtailå¤„ã€‚ stealRunNextG boolï¼šæ˜¯å¦è¿‘æœ€å¤§åŠªåŠ›å»runnextä¸Šå·å–ã€‚ è¿”å›å€¼ï¼šuint32ï¼šå·å–goroutineçš„æ•°é‡ã€‚ æ–‡ä»¶ä½ç½®ï¼šgo1.19.3/src/runtime/proc.goã€‚ 5959 5960 5961 5962 5963 5964 5965 5966 5967 5968 5969 5970 5971 5972 5973 5974 5975 5976 5977 5978 5979 5980 5981 5982 5983 5984 5985 5986 5987 5988 5989 5990 5991 5992 5993 5994 5995 5996 5997 5998 5999 6000 6001 6002 6003 6004 6005 6006 6007 6008 6009 6010 6011 6012 6013 6014 6015 6016 6017 6018 6019 6020 6021 6022 6023 6024 6025 6026 6027 6028 6029 6030 6031 6032 6033 6034 6035 6036 6037 6038 6039 6040 6041 6042 6043 6044 6045 6046 6047 6048 // Grabs a batch of goroutines from _p_\u0026#39;s runnable queue into batch. // Batch is a ring buffer starting at batchHead. // Returns number of grabbed goroutines. // Can be executed by any P. func runqgrab(_p_ *p, batch *[256]guintptr, batchHead uint32, stealRunNextG bool) uint32 { // å·å–goroutineçš„ä»£ç é‡‡ç”¨çš„æ˜¯è‡ªæ—‹æ–¹å¼ï¼Œè€Œæ²¡æœ‰é‡‡ç”¨é”æ¥å®ç°ã€‚ for { // _p_ æ˜¯ p2ï¼Œä¹‹æ‰€ä»¥éœ€è¦åŸå­è¯»å–å› ä¸ºp2æ­£åœ¨è¿è¡Œæœ‰å¹¶å‘çš„å¯èƒ½ã€‚ h := atomic.LoadAcq(\u0026amp;_p_.runqhead) // load-acquire, synchronize with other consumers t := atomic.LoadAcq(\u0026amp;_p_.runqtail) // load-acquire, synchronize with the producer // ä¸ºä»€ä¹ˆä¸æ‹…å¿ƒ runqtail æº¢å‡ºï¼Ÿ // å› ä¸ºï¼Œrunqtailå’Œrunqheadéƒ½æ˜¯uint32ç±»å‹ï¼Œå°±ç®—æº¢å‡ºä¹Ÿèƒ½ä¿è¯è®¡ç®—æ­£ç¡®ã€‚æ¯”å¦‚ 0 - 3 ä¹Ÿèƒ½å¾—åˆ°æ­£ç¡®å€¼ n := t - h n = n - n/2 // è®¡ç®—å·å–çš„æ•°é‡ï¼Œä¸ºå½“å‰å®¹é‡çš„ä¸€åŠã€‚ // p2 ä¸­æœ¬åœ°runqæ± ä¸­æ²¡æœ‰goroutineã€‚ if n == 0 { // p2æœ¬åœ°runqæ± ä¸ºç©ºï¼Œå°è¯•å» runnext è·å–goroutineã€‚ if stealRunNextG { // Try to steal from _p_.runnext. // // å°è¯•ä» _p_.runnext ä¸­å·å–ã€‚ if next := _p_.runnext; next != 0 { // _p_.runnext ä¸Šæœ‰goroutineã€‚ if _p_.status == _Prunning { // å½“å‰Pæ­£åœ¨è¿è¡Œä¸­ // Sleep to ensure that _p_ isn\u0026#39;t about to run the g // we are about to steal. // The important use case here is when the g running // on _p_ ready()s another g and then almost // immediately blocks. Instead of stealing runnext // in this window, back off to give _p_ a chance to // schedule runnext. This will avoid thrashing gs // between different Ps. // A sync chan send/recv takes ~50ns as of time of // writing, so 3us gives ~50x overshoot. // // Sleep å·²ç¡®ä¿ _p_ ä¸ä¼šè¿è¡Œæˆ‘ä»¬å°†è¦åˆ‡å–çš„gã€‚ // è¿™é‡Œçš„é‡è¦ç”¨ä¾‹æ˜¯å½“ g åœ¨ _p_ ready() ä¸Šè¿è¡Œæ—¶ï¼Œå¦ä¸€ä¸ª g ç„¶åå‡ ä¹ç«‹å³é˜»å¡ã€‚ // ä¸è¦åœ¨è¿™ä¸ªçª—å£æœŸåˆ‡å– runnextï¼Œè€Œæ˜¯é€€è€Œæ±‚å…¶æ¬¡ï¼Œè®©_p_æœ‰æœºä¼šè°ƒåº¦runnextã€‚ // è¿™å°†é¿å…gåœ¨ä¸åŒçš„Psä¹‹é—´çš„æŠ–åŠ¨ã€‚ // sync chan çš„ send/recv å¤§çº¦éœ€è¦ ~50nsï¼Œæ‰€ä»¥ç»™å‡º 3us å¤§çº¦æ˜¯å®ƒçš„ 50x å€ã€‚ if GOOS != \u0026#34;windows\u0026#34; \u0026amp;\u0026amp; GOOS != \u0026#34;openbsd\u0026#34; \u0026amp;\u0026amp; GOOS != \u0026#34;netbsd\u0026#34; { usleep(3) // sleep 3us } else { // On some platforms system timer granularity is // 1-15ms, which is way too much for this // optimization. So just yield. // // åœ¨æŸäº›å¹³å°ä¸Šï¼Œç³»ç»Ÿè®¡æ—¶å™¨ç²’åº¦ä¸º1-15msï¼Œè¿™å¯¹äºè¿™ç§ä¼˜åŒ–æ¥è¯´å¤ªè¿‡äº†ã€‚æ‰€ä»¥å°±å±ˆæœå§ã€‚ osyield() // åœ¨semaphoreä¸­æœ‰ç›¸å…³çš„ä»‹ç»ã€‚ä¼šå°è¯•è®©å‡ºCPUï¼Œè®©å…¶ä»–ä¼˜å…ˆçº§æ›´é«˜çš„çº¿ç¨‹æ‰§è¡Œã€‚ } } // CAS æ“ä½œäº¤æ¢ _p_.runnext å°è¯•å·å– goroutineã€‚ // å¤§æ¦‚ç‡ä¼šå¤±è´¥ä»è¿™é‡Œç›´æ¥é€€å‡ºã€‚ if !_p_.runnext.cas(next, 0) { continue } // å·å–åˆ°goroutineæŠŠå®ƒæ”¾å…¥Pçš„æœ¬åœ°runqæ± ã€‚ batch[batchHead%uint32(len(batch))] = next return 1 } } return 0 } // è¯»å–ä¸ä¸€è‡´çš„ h å’Œ t å€¼ã€‚ // å°ç»†èŠ‚ï¼šæŒ‰ç†è¯´é˜Ÿåˆ—ä¸­çš„goroutineä¸ªæ•°æœ€å¤šå°±æ˜¯len(_p_.runq)ï¼Œæ‰€ä»¥nçš„æœ€å¤§å€¼ä¹Ÿå°±æ˜¯len(_p_.runq)/2ï¼Œ // é‚£ä¸ºä»€ä¹ˆéœ€è¦è¿™ä¸ªåˆ¤æ–­å‘¢ï¼Ÿ // åŸå› ï¼šè¯»å–runqheadå’Œrunqtailæ˜¯ä¸¤ä¸ªæ“ä½œè€Œéä¸€ä¸ªåŸå­æ“ä½œï¼Œå½“æˆ‘ä»¬è¯»å–runqheadä¹‹åä½†è¿˜æœªè¯»å–runqtailä¹‹å‰ï¼Œ // å¦‚æœæœ‰å…¶å®ƒçº¿ç¨‹å¿«é€Ÿçš„åœ¨å¢åŠ ï¼ˆè¿™æ˜¯å®Œå…¨æœ‰å¯èƒ½çš„ï¼Œå…¶å®ƒå·å–è€…ä»é˜Ÿåˆ—ä¸­å·å–goroutineä¼šå¢åŠ runqheadï¼Œ // è€Œé˜Ÿåˆ—çš„æ‰€æœ‰è€…å¾€é˜Ÿåˆ—ä¸­æ·»åŠ goroutineä¼š å¢åŠ runqtailï¼‰è¿™ä¸¤ä¸ªå€¼ï¼Œåˆ™ä¼šå¯¼è‡´æˆ‘ä»¬è¯»å–å‡ºæ¥çš„runqtailå·²ç»è¿œè¿œå¤§äº // æˆ‘ä»¬ä¹‹å‰è¯»å–å‡ºæ¥æ”¾åœ¨å±€éƒ¨å˜é‡hé‡Œé¢çš„runqheadäº†ã€‚ // ä¹Ÿå°±æ˜¯ä»£ç æ³¨é‡Šä¸­æ‰€è¯´çš„hå’Œtå·²ç»ä¸ä¸€è‡´äº†ï¼Œæ‰€ä»¥è¿™é‡Œéœ€è¦è¿™ä¸ªifåˆ¤æ–­æ¥æ£€æµ‹å¼‚å¸¸æƒ…å†µã€‚ // å¦‚æœ n \u0026gt; uint32(len(_p_.runq)/2) æˆç«‹è¯´æ˜åœ¨t := atomic.LoadAcq(\u0026amp;_p_.runqtail)ä»£ç årunqtailå‘ç”Ÿäº†å˜åŒ–ã€‚ if n \u0026gt; uint32(len(_p_.runq)/2) { // read inconsistent h and t continue } // ä»p2ä¸­æ‹·è´goroutineåˆ°pçš„runqæœ¬åœ°æ±  for i := uint32(0); i \u0026lt; n; i++ { g := _p_.runq[(h+i)%uint32(len(_p_.runq))] // ä»p2çš„hå¤„å¾€åå–goroutine batch[(batchHead+i)%uint32(len(batch))] = g// ä»p.runqtailå¾€åæœ€åŠ  } // CAS åŸå­äº¤æ¢ p2.runqhead ä» h ä¿®æ”¹ä¸º h+nï¼Œå¦‚æœå¤±è´¥è¯´æ˜hè¢«ä¿®æ”¹äº† // 1. å¯èƒ½å…¶ä»–Pä¹Ÿåœ¨å·å–è¿™ä¸ªPçš„goroutineå¹¶ä¸”å·å–æˆåŠŸäº†ã€‚ // 2. å½“å‰è¢«å·å–çš„è¿™ä¸ªPå¯èƒ½ä¹Ÿåœ¨å–runqheadå‡ºçš„goroutineæ¥è¿è¡Œã€‚å¯¼è‡´runqheadå˜åŒ–ã€‚ // ä¸ºä»€ä¹ˆä¸æ‹…å¿ƒ runqtail çš„å€¼å‘¢ï¼Ÿè€Œæ˜¯åªéœ€è¦ä¿è¯ runqhead å’Œ runqtail ä¸€èµ·æ˜¯åŸå­çš„å‘¢ï¼Ÿ // å› ä¸ºï¼Œrunqtail åªæœ‰å½“å‰Pæ­£æœ€åŠ ï¼Œå¹¶ä¸”æ˜¯é€’å¢çš„ï¼Œèƒ½ä¿è¯æˆ‘ä»¬è¦å»çš„æ•°æ®nã€‚ if atomic.CasRel(\u0026amp;_p_.runqhead, h, h+n) { // cas-release, commits consume return n } } } type randomOrder struct stealOrderç”¨æ¥å®ç°ä¸€ä¸ªå…¬å¹³çš„éšæœºçªƒå–é¡ºåºã€‚ æ–‡ä»¶ä½ç½®ï¼šgo1.19.3/src/runtime/proc.goã€‚ // å…³äºå–På¾—ç®—æ³• var stealOrder randomOrder // randomOrder/randomEnum are helper types for randomized work stealing. // They allow to enumerate all Ps in different pseudo-random orders without repetitions. // The algorithm is based on the fact that if we have X such that X and GOMAXPROCS // are coprime, then a sequences of (i + X) % GOMAXPROCS gives the required enumeration. // // randomOrder/randomEnum æ˜¯éšæœºå·¥ä½œçªƒå–çš„è¾…åŠ©ç±»å‹ // å®ƒä»¬å…è®¸ä»¥ä¸åŒçš„ä¼ªéšæœºé¡ºåºæšä¸¾æ‰€æœ‰ P è€Œä¸é‡å¤ // è¯¥ç®—æ³•åŸºäºè¿™æ ·ä¸€ä¸ªäº‹å®ï¼š // å¦‚æœæˆ‘ä»¬æœ‰ X ä½¿å¾— X å’Œ GOMAXPROCS äº’è´¨ï¼Œé‚£ä¹ˆ (i + X) %GOMAXPROCS çš„åºåˆ—ç»™å‡ºæ‰€éœ€çš„æšä¸¾ type randomOrder struct { count uint32 // å­˜å‚¨å½“å‰æ‰€æœ‰çš„Pæ•°é‡ï¼Œä¹Ÿæ˜¯CPUçš„æ ¸æ•° coprimes []uint32 // å­˜å‚¨ä¸countäº’è´¨æ•°é›† } type randomEnum struct { i uint32 // ä»0å¼€å§‹è®°å½•éå†çš„æ¬¡æ•° count uint32 // randomOrder.count pos uint32 // å½“å‰åœ¨[0, count-1]èŒƒå›´çš„ä¸‹æ ‡ä½ç½® inc uint32 // å½“å‰åœ¨randomOrder.coprimesä¸­é€‰å–çš„å€¼ } // é‡ç½®randomOrder func (ord *randomOrder) reset(count uint32) { ord.count = count\t// è®°å½•æ€»ä¸ªæ•° ord.coprimes = ord.coprimes[:0] // æ¸…ç©ºcoprimes for i := uint32(1); i \u0026lt;= count; i++ { if gcd(i, count) == 1 { ord.coprimes = append(ord.coprimes, i) } } } // ç”Ÿæˆäº’è´¨æ•°å‡½æ•° func gcd(a, b uint32) uint32 { for b != 0 { a, b = b, a%b } return a } // å¼€å§‹ func (ord *randomOrder) start(i uint32) randomEnum { return randomEnum{ count: ord.count, pos: i % ord.count, inc: ord.coprimes[i%uint32(len(ord.coprimes))], } } // å½“å‰æ˜¯å¦éå†ä¸€åœˆäº† func (enum *randomEnum) done() bool { return enum.i == enum.count } // ä¸‹ä¸€ä¸ªäº’è´¨æ•° func (enum *randomEnum) next() { enum.i++ enum.pos = (enum.pos + enum.inc) % enum.count\t// è¿™é‡Œæ˜¯éšæœºçš„é€‰å–ä¸‹ä¸€ä¸ªéšæœºå¤„ } // è·å–å½“å‰ä½ç½® func (enum *randomEnum) position() uint32 { return enum.pos } // ç›—å–ç®—æ³•è§£é‡Š // 1. ç›—å–è¿‡ç¨‹ç”¨äº†ä¸¤ä¸ªåµŒå¥—forå¾ªç¯ã€‚ // 2. å†…å±‚å¾ªç¯å®ç°äº†ç›—å–é€»è¾‘ï¼Œä»ä»£ç å¯ä»¥çœ‹å‡ºç›—å–çš„å®è´¨å°±æ˜¯éå†allpä¸­çš„æ‰€æœ‰pï¼ŒæŸ¥çœ‹å…¶è¿è¡Œé˜Ÿåˆ—æ˜¯å¦æœ‰goroutineï¼Œå¦‚æœæœ‰ï¼Œ // åˆ™å–å…¶ä¸€åŠåˆ°å½“å‰å·¥ä½œçº¿ç¨‹çš„è¿è¡Œé˜Ÿåˆ—ï¼Œç„¶åä»findrunnableè¿”å›ï¼Œå¦‚æœæ²¡æœ‰åˆ™ç»§ç»­éå†ä¸‹ä¸€ä¸ªp // 3. ä½†è¿™é‡Œä¸ºäº†ä¿è¯å…¬å¹³æ€§ï¼Œéå†allpæ—¶å¹¶ä¸æ˜¯å›ºå®šçš„ä»allp[0]å³ç¬¬ä¸€ä¸ªpå¼€å§‹ï¼Œè€Œæ˜¯ä»éšæœºä½ç½®ä¸Šçš„på¼€å§‹ï¼Œ // è€Œä¸”éå†çš„é¡ºåºä¹ŸéšæœºåŒ–äº†ï¼Œå¹¶ä¸æ˜¯ç°åœ¨è®¿é—®äº†ç¬¬iä¸ªpä¸‹ä¸€æ¬¡å°±è®¿é—®ç¬¬i+1ä¸ªpï¼Œ // è€Œæ˜¯ä½¿ç”¨äº†ä¸€ç§ä¼ªéšæœºçš„æ–¹å¼éå†allpä¸­çš„æ¯ä¸ªpï¼Œé˜²æ­¢æ¯æ¬¡éå†æ—¶ä½¿ç”¨åŒæ ·çš„é¡ºåºè®¿é—®allpä¸­çš„å…ƒç´  // ä¸‹é¢æ˜¯è¿™ä¸ªç®—æ³•çš„ä¼ªä»£ç ï¼š // offset := uint32(random()) % nprocs // coprime := éšæœºé€‰å–ä¸€ä¸ªå°äºnprocsä¸”ä¸nprocsäº’è´¨çš„æ•° // for i := 0; i \u0026lt; nprocs; i++ { // p := allp[offset] // ä»pçš„è¿è¡Œé˜Ÿåˆ—å·å–goroutine // if å·å–æˆåŠŸ { // break // } // offset += coprime // offset = offset % nprocs // } // // ä¸‹é¢ä¸¾ä¾‹è¯´æ˜ä¸€ä¸‹ä¸Šè¿°ç®—æ³•è¿‡ç¨‹ï¼Œç°å‡è®¾nprocsä¸º8ï¼Œä¹Ÿå°±æ˜¯ä¸€å…±æœ‰8ä¸ªp // å¦‚æœç¬¬ä¸€æ¬¡éšæœºé€‰æ‹©çš„offset = 6ï¼Œcoprime = 3(3ä¸8äº’è´¨ï¼Œæ»¡è¶³ç®—æ³•è¦æ±‚)çš„è¯ï¼Œåˆ™ä»allpåˆ‡ç‰‡ä¸­å·å–çš„ä¸‹æ ‡é¡ºåºä¸º // 6, 1, 4, 7, 2, 5, 0, 3ï¼Œè®¡ç®—è¿‡ç¨‹ï¼š // 6ï¼Œ(6+3)%8=1ï¼Œ(1+3)%8=4, (4+3)%8=7, (7+3)%8=2, (2+3)%8=5, (5+3)%8=0, (0+3)%8=3 // å¦‚æœç¬¬äºŒæ¬¡éšæœºé€‰æ‹©çš„offset = 4ï¼Œcoprime = 5çš„è¯ï¼Œåˆ™ä»allpåˆ‡ç‰‡ä¸­å·å–çš„ä¸‹æ ‡é¡ºåºä¸º // 1, 6, 3, 0, 5, 2, 7, 4ï¼Œè®¡ç®—è¿‡ç¨‹ï¼š // 1ï¼Œ(1+5)%8=6ï¼Œ(6+5)%8=3, (3+5)%8=0, (0+5)%8=5, (5+5)%8=2, (2+5)%8=7, (7+5)%8=4 releasep() è§£é™¤å½“å‰Må’ŒPçš„ç»‘å®šå…³ç³»ã€‚ æ–‡ä»¶ä½ç½®ï¼šgo1.19.3/src/runtime/proc.goã€‚ 4984 4985 4986 4987 4988 4989 4990 4991 4992 4993 4994 4995 4996 4997 4998 4999 5000 5001 5002 5003 5004 5005 5006 5007 5008 5009 5010 // Disassociate p and the current m. func releasep() *p { _g_ := getg() // è·å–å½“å‰è¿è¡Œçš„gï¼Œè¿™é‡Œæ˜¯g0 if _g_.m.p == 0 { // å½“å‰è¦è§£ç»‘çš„Pä¸å­˜åœ¨ï¼Œç³»ç»Ÿä»£ç æœ‰é€»è¾‘é—®é¢˜ throw(\u0026#34;releasep: invalid arg\u0026#34;) } _p_ := _g_.m.p.ptr() // è·å–å½“å‰å·¥ä½œçº¿ç¨‹Mç»‘å®šçš„Pï¼Œä¹Ÿå°±æ˜¯éœ€è¦è§£ç»‘çš„P // _Prunning è¡¨ç¤º P ç”± M æ‹¥æœ‰å¹¶ç”¨äºè¿è¡Œç”¨æˆ·ä»£ç æˆ–è°ƒåº¦ç¨‹åº // åªæœ‰æ‹¥æœ‰è¿™ä¸ª P çš„ M æ‰å…è®¸ä» _Prunning æ›´æ”¹ P çš„çŠ¶æ€ // M å¯ä»¥å°† P è½¬æ¢ä¸º _Pidleï¼ˆå¦‚æœå®ƒæ²¡æœ‰æ›´å¤šå·¥ä½œè¦åšï¼‰ã€_Psyscallï¼ˆå½“è¿›å…¥ç³»ç»Ÿè°ƒç”¨æ—¶ï¼‰æˆ– _Pgcstopï¼ˆåœæ­¢ GCï¼‰ // M ä¹Ÿå¯ä»¥å°† P çš„æ‰€æœ‰æƒç›´æ¥äº¤ç»™å¦ä¸€ä¸ª Mï¼ˆä¾‹å¦‚ï¼Œå®‰æ’é”å®šçš„ Gï¼‰ if _p_.m.ptr() != _g_.m || _p_.status != _Prunning { // å½“å‰Pç»‘å®šçš„mä¸gç»‘å®šçš„mä¸æ˜¯åŒä¸€ä¸ª æˆ– å½“å‰Pä¸æ˜¯_PrunningçŠ¶æ€ print(\u0026#34;releasep: m=\u0026#34;, _g_.m, \u0026#34; m-\u0026gt;p=\u0026#34;, _g_.m.p.ptr(), \u0026#34; p-\u0026gt;m=\u0026#34;, hex(_p_.m), \u0026#34; p-\u0026gt;status=\u0026#34;, _p_.status, \u0026#34;\\n\u0026#34;) throw(\u0026#34;releasep: invalid p state\u0026#34;) } if trace.enabled { traceProcStop(_g_.m.p.ptr()) } _g_.m.p = 0\t// è§£ç»‘å·¥ä½œçº¿ç¨‹Mä¸Pçš„å…³è” _p_.m = 0\t// è§£ç»‘Pä¸Mçš„å…³è” // _Pidle è¡¨ç¤º P æœªç”¨äºè¿è¡Œç”¨æˆ·ä»£ç æˆ–è°ƒåº¦ç¨‹åº // é€šå¸¸ï¼Œå®ƒä½äºç©ºé—² P åˆ—è¡¨ä¸­å¹¶ä¸”å¯ä¾›è°ƒåº¦ç¨‹åºä½¿ç”¨ï¼Œä½†å®ƒå¯èƒ½åªæ˜¯åœ¨å…¶ä»–çŠ¶æ€ä¹‹é—´è½¬æ¢ // P ç”±ç©ºé—²åˆ—è¡¨æˆ–æ­£åœ¨è½¬æ¢å…¶çŠ¶æ€çš„ä»»ä½•ä¸œè¥¿æ‹¥æœ‰ã€‚ å®ƒçš„è¿è¡Œé˜Ÿåˆ—æ˜¯ç©ºçš„ _p_.status = _Pidle return _p_\t// è¿”å›å½“å‰P } pidleput() pidleput å°†pæ”¾åˆ°_Pidleåˆ—è¡¨ä¸­ã€‚ è¿™é‡Šæ”¾äº†pçš„æ‰€æœ‰æƒã€‚ä¸€æ—¦sched.lockè¢«é‡Šæ”¾ï¼Œä½¿ç”¨på°±ä¸å†å®‰å…¨äº†ã€‚ sched.lockå¿…é¡»è¢«æŒæœ‰ï¼Œå¯ä»¥åœ¨STWæœŸé—´è¿è¡Œï¼Œå› æ­¤ä¸å…è®¸å†™å…¥å±éšœã€‚ æ–‡ä»¶ä½ç½®ï¼šgo1.19.3/src/runtime/proc.goã€‚ 5696 5697 5698 5699 5700 5701 5702 5703 5704 5705 5706 5707 5708 5709 5710 5711 5712 5713 5714 5715 5716 5717 5718 5719 // pidleput puts p to on the _Pidle list. // // This releases ownership of p. Once sched.lock is released it is no longer // safe to use p. // // sched.lock must be held. // // May run during STW, so write barriers are not allowed. //go:nowritebarrierrec func pidleput(_p_ *p) { assertLockHeld(\u0026amp;sched.lock) // åˆ¤æ–­Pçš„æœ¬åœ°é˜Ÿåˆ—ä¸åº”è¯¥è¿˜æœ‰goroutineï¼Œåˆ¤æ–­ä¸‹ if !runqempty(_p_) { throw(\u0026#34;pidleput: P has non-empty run queue\u0026#34;) } // å¦‚æœPæ²¡æœ‰timerï¼Œå°†æ¸…é™¤timerpMaskä½ä¸Šå¯¹åº”çš„æ©ç ä½ï¼ŒtimerpMaskæ˜¯è®°å½•å¿™ç¢Œçš„ updateTimerPMask(_p_) // clear if there are no timers. idlepMask.set(_p_.id) // è®¾ç½®idlepMaskå¯¹åº”çš„Pçš„æ©ç ä½ï¼ŒidlepMaskæ˜¯è®°å½•ç©ºé—²çš„ _p_.link = sched.pidle // å½“å‰Pè®°å½•å…¨å±€çš„ç©ºé—²é“¾è¡¨ sched.pidle.set(_p_) // æŠŠå½“å‰Pé“¾æ¥åˆ°å…¨å±€ç©ºé—²é“¾è¡¨å // ä½¿ç”¨åŸå­é”æŠŠå½“å‰schedç©ºé—²çš„Pæ•°é‡åŠ 1 atomic.Xadd(\u0026amp;sched.npidle, 1) // TODO: fast atomic } runqempty() runqempty æŠ¥å‘Š_p_åœ¨å…¶æœ¬åœ°è¿è¡Œé˜Ÿåˆ—ä¸­æ˜¯å¦æ²¡æœ‰ Gsã€‚ å®ƒæ°¸è¿œä¸ä¼šè™šå‡åœ°è¿”å›trueã€‚ æ–‡ä»¶ä½ç½®ï¼šgo1.19.3/src/runtime/proc.goã€‚ 5752 5753 5754 5755 5756 5757 5758 5759 5760 5761 5762 5763 5764 5765 5766 5767 5768 5769 5770 5771 5772 5773 // runqempty reports whether _p_ has no Gs on its local run queue. // It never returns true spuriously. func runqempty(_p_ *p) bool { // Defend against a race where 1) _p_ has G1 in runqnext but runqhead == runqtail, // 2) runqput on _p_ kicks G1 to the runq, 3) runqget on _p_ empties runqnext. // Simply observing that runqhead == runqtail and then observing that runqnext == nil // does not mean the queue is empty. // // ä»¥ä¸‹æƒ…å†µï¼š // 1. _p_ åœ¨ runqnext ä¸­æœ‰ G1 ä½† runqhead == runqtail // 2. _p_ ä¸Šçš„ runqput å°† G1 è¸¢åˆ° runq // 3. _p_ ä¸Šçš„ runqget æ¸…ç©º runqnext // ç®€å•åœ°è§‚å¯Ÿ runqhead == runqtail ç„¶åè§‚å¯Ÿ runqnext == nil å¹¶ä¸æ„å‘³ç€é˜Ÿåˆ—æ˜¯ç©ºçš„ for { head := atomic.Load(\u0026amp;_p_.runqhead)\ttail := atomic.Load(\u0026amp;_p_.runqtail) runnext := atomic.Loaduintptr((*uintptr)(unsafe.Pointer(\u0026amp;_p_.runnext))) if tail == atomic.Load(\u0026amp;_p_.runqtail) { return head == tail \u0026amp;\u0026amp; runnext == 0 } } } pidleget() ç›¸å…³è”å‡½æ•°pidlegetä»ç©ºé—²åˆ—è¡¨ä¸­è·å–ä¸€ä¸ªPã€‚ æ–‡ä»¶ä½ç½®ï¼šgo1.19.3/src/runtime/proc.goã€‚ 5727 5728 5729 5730 5731 5732 5733 5734 5735 5736 5737 5738 5739 5740 5741 5742 5743 5744 5745 5746 5747 5748 5749 5750 // pidleget tries to get a p from the _Pidle list, acquiring ownership. // // sched.lock must be held. // // May run during STW, so write barriers are not allowed. // //go:nowritebarrierrec func pidleget(now int64) (*p, int64) { assertLockHeld(\u0026amp;sched.lock) _p_ := sched.pidle.ptr() if _p_ != nil { // Timer may get added at any time now. if now == 0 { now = nanotime() } timerpMask.set(_p_.id) idlepMask.clear(_p_.id) sched.pidle = _p_.link atomic.Xadd(\u0026amp;sched.npidle, -1) _p_.limiterEvent.stop(limiterEventIdle, now) } return _p_, now } checkRunqsNoP() æ£€æŸ¥å¿«ç…§ä¸­æ‰€æœ‰çš„Pæ˜¯å¦æœ‰å¯ä»¥å·å–çš„Gã€‚ æ–‡ä»¶ä½ç½®ï¼šgo1.19.3/src/runtime/proc.goã€‚ 2974 2975 2976 2977 2978 2979 2980 2981 2982 2983 2984 2985 2986 2987 2988 2989 2990 2991 2992 2993 2994 2995 2996 2997 2998 2999 // Check all Ps for a runnable G to steal. // // On entry we have no P. If a G is available to steal and a P is available, // the P is returned which the caller should acquire and attempt to steal the // work to. func checkRunqsNoP(allpSnapshot []*p, idlepMaskSnapshot pMask) *p { // å˜é‡allpçš„å¿«ç…§ï¼Œallpè®°å½•äº†æ‰€æœ‰çš„Påˆ—è¡¨ for id, p2 := range allpSnapshot {\t// ä¼‘çœ ä¹‹å‰åœ¨çœ‹ä¸€ä¸‹æ˜¯å¦æœ‰å·¥ä½œè¦åš // idlepMaskSnapshot å¿«ç…§è®°å½•ç€å½“å‰Pçš„çŠ¶æ€ // !idlepMaskSnapshot.read(uint32(id)) å½“å‰PçŠ¶æ€ä¸ä¸ºç©ºçš„ å¹¶ä¸” å½“å‰På­˜å‚¨groutineçš„ if !idlepMaskSnapshot.read(uint32(id)) \u0026amp;\u0026amp; !runqempty(p2) { lock(\u0026amp;sched.lock) pp := pidleget()\t// ä»ç©ºé—²çš„Pä¸­æ‹¿å»ä¸€ä¸ªPï¼Œä¸ºåç»­Mç»‘å®šPåšå‡†å¤‡ï¼Œå› ä¸ºæœ‰å…¨å±€çš„På­˜åœ¨gå¯ä»¥èµ·å»æ‹¿æ¥ç”¨ unlock(\u0026amp;sched.lock) if pp != nil { return pp } // Can\u0026#39;t get a P, don\u0026#39;t bother checking remaining Ps. // æ‹¿ä¸åˆ°Pï¼Œåˆ«è´¹å¿ƒæ£€æŸ¥å‰©ä½™çš„P break } } return nil } checkIdleGCNoP() æ£€æŸ¥æ˜¯å¦æœ‰GCéœ€è¦å¸®åŠ©ã€‚ æ–‡ä»¶ä½ç½®ï¼šgo1.19.3/src/runtime/proc.goã€‚ 3013 3014 3015 3016 3017 3018 3019 3020 3021 3022 3023 3024 3025 3026 3027 3028 3029 3030 3031 3032 3033 3034 3035 3036 3037 3038 3039 3040 3041 3042 3043 3044 3045 3046 3047 3048 3049 3050 3051 3052 3053 3054 3055 3056 3057 3058 3059 3060 3061 3062 3063 3064 3065 3066 3067 3068 3069 3070 3071 3072 3073 // Check for idle-priority GC, without a P on entry. // // If some GC work, a P, and a worker G are all available, the P and G will be // returned. The returned P has not been wired yet. func checkIdleGCNoP() (*p, *g) { // N.B. Since we have no P, gcBlackenEnabled may change at any time; we // must check again after acquiring a P. As an optimization, we also check // if an idle mark worker is needed at all. This is OK here, because if we // observe that one isn\u0026#39;t needed, at least one is currently running. Even if // it stops running, its own journey into the scheduler should schedule it // again, if need be (at which point, this check will pass, if relevant). if atomic.Load(\u0026amp;gcBlackenEnabled) == 0 || !gcController.needIdleMarkWorker() { return nil, nil } if !gcMarkWorkAvailable(nil) { return nil, nil } // Work is available; we can start an idle GC worker only if there is // an available P and available worker G. // // We can attempt to acquire these in either order, though both have // synchronization concerns (see below). Workers are almost always // available (see comment in findRunnableGCWorker for the one case // there may be none). Since we\u0026#39;re slightly less likely to find a P, // check for that first. // // Synchronization: note that we must hold sched.lock until we are // committed to keeping it. Otherwise we cannot put the unnecessary P // back in sched.pidle without performing the full set of idle // transition checks. // // If we were to check gcBgMarkWorkerPool first, we must somehow handle // the assumption in gcControllerState.findRunnableGCWorker that an // empty gcBgMarkWorkerPool is only possible if gcMarkDone is running. lock(\u0026amp;sched.lock) pp, now := pidlegetSpinning(0) if pp == nil { unlock(\u0026amp;sched.lock) return nil, nil } // Now that we own a P, gcBlackenEnabled can\u0026#39;t change (as it requires STW). if gcBlackenEnabled == 0 || !gcController.addIdleMarkWorker() { pidleput(pp, now) unlock(\u0026amp;sched.lock) return nil, nil } node := (*gcBgMarkWorkerNode)(gcBgMarkWorkerPool.pop()) if node == nil { pidleput(pp, now) unlock(\u0026amp;sched.lock) gcController.removeIdleMarkWorker() return nil, nil } unlock(\u0026amp;sched.lock) return pp, node.gp.ptr() } checkTimersNoP() æ£€æŸ¥å¿«ç…§ä¸­æ‰€æœ‰çš„Pæ˜¯å¦æœ‰timerè¦è§¦å‘äº†ã€‚ æ–‡ä»¶ä½ç½®ï¼šgo1.19.3/src/runtime/proc.goã€‚ 2997 2998 2999 3000 3001 3002 3003 3004 3005 3006 3007 3008 3009 3010 3011 // Check all Ps for a timer expiring sooner than pollUntil. // // Returns updated pollUntil value. func checkTimersNoP(allpSnapshot []*p, timerpMaskSnapshot pMask, pollUntil int64) int64 { for id, p2 := range allpSnapshot { if timerpMaskSnapshot.read(uint32(id)) { w := nobarrierWakeTime(p2) if w != 0 \u0026amp;\u0026amp; (pollUntil == 0 || w \u0026lt; pollUntil) { pollUntil = w } } } return pollUntil } stopm() å·¥ä½œçº¿ç¨‹è¿›å…¥ä¼‘çœ ï¼Œç­‰å¾…è¢«å…¶ä»–å·¥ä½œçº¿ç¨‹å”¤é†’ã€‚ æ–‡ä»¶ä½ç½®ï¼šgo1.19.3/src/runtime/proc.goã€‚ 2229 2230 2231 2232 2233 2234 2235 2236 2237 2238 2239 2240 2241 2242 2243 2244 2245 2246 2247 2248 2249 2250 // Stops execution of the current m until new work is available. // Returns with acquired P. func stopm() { _g_ := getg() // è·å–å½“å‰å·¥ä½œçº¿ç¨‹Mç»‘å®šçš„g if _g_.m.locks != 0 { // åˆ¤æ–­å½“å‰å·¥ä½œçº¿ç¨‹æ˜¯å¦æœ‰é”ä¸ºè§£é” throw(\u0026#34;stopm holding locks\u0026#34;) } if _g_.m.p != 0 { // åˆ¤æ–­å½“å‰å·¥ä½œçº¿ç¨‹æ˜¯å¦è¿˜ç»‘å®šäº†Pï¼Œå› ä¸ºå‰é¢Mä¸På·²ç»è§£ç»‘äº† throw(\u0026#34;stopm holding p\u0026#34;) } if _g_.m.spinning { // åˆ¤æ–­å½“å‰å·¥ä½œçº¿ç¨‹æ˜¯å¦è¿˜å¤„äºè‡ªæ—‹çŠ¶æ€æ ‡è®°ï¼Œåº”ä¸ºå‰é¢å·²ç»å–æ¶ˆäº†è¯¥æ ‡è®° throw(\u0026#34;stopm spinning\u0026#34;) } lock(\u0026amp;sched.lock) // é”ä½å…¨å±€sched mput(_g_.m) // æŠŠmç»“æ„ä½“å¯¹è±¡æ”¾å…¥sched.midleç©ºé—²é˜Ÿåˆ— unlock(\u0026amp;sched.lock) // è§£é” mPark() // è¿›å…¥ç³»ç»Ÿè°ƒç”¨è¿›å…¥ç¡çœ  acquirep(_g_.m.nextp.ptr()) // å·¥ä½œçº¿ç¨‹è¢«å”¤é†’åä»è¿™é‡Œå¼€å§‹æ‰§è¡Œï¼Œç»™Mç»‘å®šP _g_.m.nextp = 0 } mput() å½“å·¥ä½œçº¿ç¨‹ç©ºé—²æ—¶å³å°†è¿›å…¥ä¼‘çœ çŠ¶æ€æ—¶ä¼šåˆ¤æ–­ä¸€æ¬¡checkdead()ã€‚ æ–‡ä»¶ä½ç½®ï¼šgo1.19.3/src/runtime/proc.goã€‚ 5533 5534 5535 5536 5537 5538 5539 5540 5541 5542 5543 5544 5545 5546 5547 // Put mp on midle list. // sched.lock must be held. // May run during STW, so write barriers are not allowed. //go:nowritebarrierrec func mput(mp *m) { assertLockHeld(\u0026amp;sched.lock) // æ£€æŸ¥sched.locké” mp.schedlink = sched.midle // å½“å‰Mè®°å½•å…¨å±€ç©ºé—²Mé“¾è¡¨ sched.midle.set(mp) // æŠŠå½“å‰Mè¿½åŠ åˆ°å…¨å±€ç©ºé—²é“¾è¡¨ä¸­å» sched.nmidle++ // å…¨å±€ç©ºé—²Mæ•°é‡åŠ ä¸€ // æ£€æŸ¥æ­»é”æƒ…å†µ // æ£€æŸ¥åŸºäºè¿è¡Œ M çš„æ•°é‡ï¼Œå¦‚æœ 0 -\u0026gt; æ­»é” // sched.lock å¿…é¡»è¢«æŒæœ‰ checkdead() } mget() æ–‡ä»¶ä½ç½®ï¼šgo1.19.3/src/runtime/proc.goã€‚ 5547 5548 5549 5550 5551 5552 5553 5554 5555 5556 5557 5558 5559 5560 // Try to get an m from midle list. // sched.lock must be held. // May run during STW, so write barriers are not allowed. //go:nowritebarrierrec func mget() *m { assertLockHeld(\u0026amp;sched.lock) mp := sched.midle.ptr() if mp != nil { sched.midle = mp.schedlink sched.nmidle-- } return mp } mPark() ç¡çœ å‡½æ•°ï¼ŒmPark()å¯¼è‡´çº¿ç¨‹è‡ªè¡Œåœæ”¾ï¼Œä¸€æ—¦å”¤é†’å°±è¿”å›ã€‚ stopmçš„æ ¸å¿ƒæ˜¯è°ƒç”¨mputæŠŠmç»“æ„ä½“å¯¹è±¡æ”¾å…¥schedçš„midleç©ºé—²é˜Ÿåˆ—ï¼Œç„¶åé€šè¿‡notesleep(\u0026amp;m.park)å‡½æ•°è®©è‡ªå·±è¿›å…¥ç¡çœ çŠ¶æ€ã€‚ noteæ˜¯go runtimeå®ç°çš„ä¸€æ¬¡æ€§ç¡çœ å’Œå”¤é†’æœºåˆ¶ï¼Œä¸€ä¸ªçº¿ç¨‹å¯ä»¥é€šè¿‡è°ƒç”¨notesleep(*note)è¿›å…¥ç¡çœ çŠ¶æ€ï¼Œè€Œå¦å¤–ä¸€ä¸ªçº¿ç¨‹åˆ™å¯ä»¥é€šè¿‡notewakeup(*note)æŠŠå…¶å”¤é†’ã€‚ noteçš„åº•å±‚å®ç°æœºåˆ¶è·Ÿæ“ä½œç³»ç»Ÿç›¸å…³ï¼Œä¸åŒç³»ç»Ÿä½¿ç”¨ä¸åŒçš„æœºåˆ¶ï¼š æ¯”å¦‚linuxä¸‹ä½¿ç”¨çš„futexç³»ç»Ÿè°ƒç”¨ã€‚ è€Œmacä¸‹åˆ™æ˜¯ä½¿ç”¨çš„pthread_cond_tæ¡ä»¶å˜é‡ã€‚ noteå¯¹è¿™äº›åº•å±‚æœºåˆ¶åšäº†ä¸€ä¸ªæŠ½è±¡å’Œå°è£…ï¼Œè¿™ç§å°è£…ç»™æ‰©å±•æ€§å¸¦æ¥äº†å¾ˆå¤§çš„å¥½å¤„ï¼Œæ¯”å¦‚å½“ç¡çœ å’Œå”¤é†’åŠŸèƒ½éœ€è¦æ”¯æŒæ–°å¹³å°æ—¶ï¼Œåªéœ€è¦åœ¨noteå±‚å¢åŠ å¯¹ç‰¹å®šå¹³å°çš„æ”¯æŒå³å¯ï¼Œä¸éœ€è¦ä¿®æ”¹ä¸Šå±‚çš„ä»»ä½•ä»£ç ã€‚ å›åˆ°stopmï¼Œå½“ä»notesleepå‡½æ•°è¿”å›åï¼Œéœ€è¦å†æ¬¡ç»‘å®šä¸€ä¸ªpï¼Œç„¶åè¿”å›åˆ°findrunnableå‡½æ•°ç»§ç»­é‡æ–°å¯»æ‰¾å¯è¿è¡Œçš„goroutineï¼Œä¸€æ—¦æ‰¾åˆ°å¯è¿è¡Œçš„goroutineå°±ä¼šè¿”å›åˆ°scheduleå‡½æ•°ï¼Œå¹¶æŠŠæ‰¾åˆ°çš„goroutineè°ƒåº¦èµ·æ¥è¿è¡Œï¼Œå¦‚ä½•æŠŠgoroutineè°ƒåº¦èµ·æ¥è¿è¡Œçš„ä»£ç æˆ‘ä»¬å·²ç»åˆ†æè¿‡äº†ã€‚ æ–‡ä»¶ä½ç½®ï¼šgo1.19.3/src/runtime/proc.goã€‚ 1452 1453 1454 1455 1456 1457 1458 // mPark causes a thread to park itself, returning once woken. //go:nosplit func mPark() { gp := getg() notesleep(\u0026amp;gp.m.park) // è¿›å…¥ä¼‘çœ çŠ¶æ€ï¼Œè¿™é‡Œä¼ å…¥Mçš„parkï¼Œç¡çœ åœ¨è¿™ä¸ªä¸Šé¢ noteclear(\u0026amp;gp.m.park) // è¢«å…¶ä»–å·¥ä½œçº¿ç¨‹å”¤é†’ï¼Œä»£ç ä»è¿™é‡Œå¼€å§‹æ‰§è¡Œ } notesleep() å®ç°ä¼‘çœ çš„å‡½æ•°ã€‚ notesleepå‡½æ•°è°ƒç”¨futexsleepè¿›å…¥ç¡çœ ï¼Œè¿™é‡Œä¹‹æ‰€ä»¥éœ€è¦ç”¨ä¸€ä¸ªå¾ªç¯ï¼Œæ˜¯å› ä¸ºfutexsleepæœ‰å¯èƒ½æ„å¤–ä»ç¡çœ ä¸­è¿”å›ï¼Œæ‰€ä»¥ä»futexsleepå‡½æ•°è¿”å›åè¿˜éœ€è¦æ£€æŸ¥note.keyæ˜¯å¦è¿˜æ˜¯0ã€‚ å¦‚æœæ˜¯0åˆ™è¡¨ç¤ºå¹¶ä¸æ˜¯å…¶å®ƒå·¥ä½œçº¿ç¨‹å”¤é†’äº†æˆ‘ä»¬ï¼Œåªæ˜¯futexsleepæ„å¤–è¿”å›äº†ï¼Œéœ€è¦å†æ¬¡è°ƒç”¨futexsleepè¿›å…¥ç¡çœ ã€‚ æ–‡ä»¶ä½ç½®ï¼šgo1.19.3/src/runtime/lock_futex.goã€‚ 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 func notesleep(n *note) { gp := getg() // è·å–å½“å‰å·¥ä½œçº¿ç¨‹ç»‘å®šçš„gï¼Œåº”è¯¥æ˜¯g0åœ¨è°ƒåº¦å¾ªç¯è¿‡ç¨‹ä¸­è¢«åˆ‡æ¢åˆ°g0äº† if gp != gp.m.g0 { throw(\u0026#34;notesleep not on g0\u0026#34;) } ns := int64(-1) // è¶…æ—¶æ—¶é—´è®¾ç½®ä¸º-1ï¼Œè¡¨ç¤ºæ— é™æœŸç­‰å¾… if *cgo_yield != nil { // Sleep for an arbitrary-but-moderate interval to poll libc interceptors. // ä¼‘çœ ä¸€ä¸ªä»»æ„ä½†é€‚ä¸­çš„é—´éš”æ¥è½®è¯¢ libc æ‹¦æˆªå™¨cgoç›¸å…³çš„ ns = 10e6 } // ä½¿ç”¨å¾ªç¯ï¼Œä¿è¯ä¸æ˜¯æ„å¤–è¢«å”¤é†’ for atomic.Load(key32(\u0026amp;n.key)) == 0 { gp.m.blocked = true // blockedè¡¨ç¤ºMåœ¨å½“å‰çš„noteä¸Šè¢«å±è”½ futexsleep(key32(\u0026amp;n.key), 0, ns) // è¿›å…¥ä¼‘çœ å‡½æ•° if *cgo_yield != nil { asmcgocall(*cgo_yield, nil) } gp.m.blocked = false } } futexsleep() åŸå­çš„if(*addr == val)ä¼‘çœ ï¼Œå¯èƒ½ä¼šè¢«è™šå‡å”¤é†’ï¼› è¿™æ˜¯å…è®¸çš„ç¡çœ æ—¶é—´ä¸è¦è¶…è¿‡nsï¼›ns \u0026lt; 0æ„å‘³ç€æ°¸è¿œã€‚ æ–‡ä»¶ä½ç½®ï¼šgo1.19.3/src/runtime/os_linux.goã€‚ 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 // Atomically, //\tif(*addr == val) sleep // Might be woken up spuriously; that\u0026#39;s allowed. // Don\u0026#39;t sleep longer than ns; ns \u0026lt; 0 means forever. // //go:nosplit func futexsleep(addr *uint32, val uint32, ns int64) { // Some Linux kernels have a bug where futex of // FUTEX_WAIT returns an internal error code // as an errno. Libpthread ignores the return value // here, and so can we: as it says a few lines up, // spurious wakeups are allowed. // // ä¸€äº› Linux å†…æ ¸å­˜åœ¨ä¸€ä¸ªé”™è¯¯ï¼Œå³ FUTEX_WAIT çš„ futex è¿”å›å†…éƒ¨é”™è¯¯ä»£ç ä½œä¸º errno // Libpthread å¿½ç•¥äº†è¿™é‡Œçš„è¿”å›å€¼ï¼Œæˆ‘ä»¬ä¹Ÿå¯ä»¥ï¼šæ­£å¦‚å®ƒæ‰€è¯´çš„å‡ è¡Œï¼Œè™šå‡å”¤é†’æ˜¯å…è®¸çš„ if ns \u0026lt; 0 {\t// æ°¸ä¹…ç¡çœ  futex(unsafe.Pointer(addr), _FUTEX_WAIT_PRIVATE, val, nil, nil, 0) return } var ts timespec ts.setNsec(ns) // è®¾ç½®æ—¶é—´ futex(unsafe.Pointer(addr), _FUTEX_WAIT_PRIVATE, val, unsafe.Pointer(\u0026amp;ts), nil, 0) } futex() å‡½æ•°åŸå‹ï¼šfunc futex(addr unsafe.Pointer, op int32, val uint32, ts, addr2 unsafe.Pointer, val3 uint32) int32ç”±æ±‡ç¼–å®ç°ã€‚ futexç³»ç»Ÿè°ƒç”¨ä¸ºæˆ‘ä»¬æä¾›çš„åŠŸèƒ½ä¸ºå¦‚æœ*addr == valåˆ™è¿›å…¥ç¡çœ ï¼Œå¦åˆ™ç›´æ¥è¿”å›ã€‚ æ–‡ä»¶ä½ç½®ï¼šgo1.19.3/src/runtime/sys_linux_amd64.sã€‚ 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 # int64 futex(int32 *uaddr, int32 op, int32 val, #\tstruct timespec *timeout, int32 *uaddr2, int32 val2); TEXT runtimeÂ·futex(SB),NOSPLIT,$0 # ä¸‹é¢çš„6æ¡æŒ‡ä»¤åœ¨ä¸ºfutexç³»ç»Ÿè°ƒç”¨å‡†å¤‡å‚æ•° MOVQ addr+0(FP), DI MOVL op+8(FP), SI MOVL val+12(FP), DX MOVQ ts+16(FP), R10 MOVQ addr2+24(FP), R8 MOVL val3+32(FP), R9 MOVL $SYS_futex, AX # ç³»ç»Ÿè°ƒç”¨ç¼–å·æ”¾å…¥AXå¯„å­˜å™¨ SYSCALL # æ‰§è¡Œfutexç³»ç»Ÿè°ƒç”¨è¿›å…¥ç¡çœ ï¼Œä»ç¡çœ ä¸­è¢«å”¤é†’åæ¥ç€æ‰§è¡Œä¸‹ä¸€æ¡MOVLæŒ‡ä»¤ MOVL AX, ret+40(FP) # ä¿å­˜ç³»ç»Ÿè°ƒç”¨çš„è¿”å›å€¼ RET execute() ğŸš€ gpæ”¾åˆ°å½“å‰Mä¸Šå–è¿è¡Œã€‚è¯¥å‡½æ•°ä»g0æ ˆåˆ‡æ¢åˆ°æ™®é€šgoroutineæ ˆä¸Šã€‚ å¦‚æœinheritTimeä¸ºtrueï¼Œåˆ™gpå°†ç»§æ‰¿å½“å‰æ—¶é—´ç‰‡ä¸­çš„å‰©ä½™æ—¶é—´ã€‚å¦åˆ™ï¼Œå®ƒå°†å¯åŠ¨ä¸€ä¸ªæ–°çš„æ—¶é—´ç‰‡ã€‚æ°¸è¿œä¸è¿”å›ã€‚ å†™å±éšœæ˜¯å…è®¸çš„ï¼Œå› ä¸ºè¿™æ˜¯åœ¨å‡ ä¸ªåœ°æ–¹è·å¾—Påç«‹å³è°ƒç”¨çš„ã€‚ å‚æ•°ï¼š gp *gï¼šå½“å‰è°ƒåº¦çš„goroutineã€‚ inheritTime boolï¼štrue.ç»§æ‰¿å½“å‰æ—¶é—´ç‰‡ï¼Œfalse.ä¸ç»§æ‰¿å½“å‰æ—¶é—´ç‰‡ã€‚ æ–‡ä»¶ä½ç½®ï¼šgo1.19.3/src/runtime/proc.goã€‚ 2508 2509 2510 2511 2512 2513 2514 2515 2516 2517 2518 2519 2520 2521 2522 2523 2524 2525 2526 2527 2528 2529 2530 2531 2532 2533 2534 2535 2536 2537 2538 2539 2540 2541 2542 2543 2544 2545 2546 2547 2548 2549 2550 2551 2552 2553 2554 2555 2556 2557 2558 2559 2560 2561 2562 2563 2564 2565 2566 2567 2568 // Schedules gp to run on the current M. // If inheritTime is true, gp inherits the remaining time in the // current time slice. Otherwise, it starts a new time slice. // Never returns. // // Write barriers are allowed because this is called immediately after // acquiring a P in several places. // //go:yeswritebarrierrec func execute(gp *g, inheritTime bool) { // å½“å‰æ˜¯åœ¨ç³»ç»Ÿg0æ ˆ _g_ := getg() // _g_ = g0 if goroutineProfile.active { // Make sure that gp has had its stack written out to the goroutine // profile, exactly as it was when the goroutine profiler first stopped // the world. tryRecordGoroutineProfile(gp, osyield) } // Assign gp.m before entering _Grunning so running Gs have an // M. // // åœ¨è¾“å…¥_Grunningä¹‹å‰æŒ‡å®šgp.mï¼Œä»¥ä¾¿è¿è¡ŒGså…·æœ‰mã€‚ _g_.m.curg = gp // m.curg = gp gp.m = _g_.m // gp.m = m // _Grunnableï¼šå®ƒå½“å‰æ²¡æœ‰æ‰§è¡Œç”¨æˆ·ä»£ç ã€‚ // _Grunningï¼šè¡¨ç¤ºè¿™ä¸ªgoroutineå¯ä»¥æ‰§è¡Œç”¨æˆ·ä»£ç ã€‚ casgstatus(gp, _Grunnable, _Grunning) // ä¿®æ”¹å½“å‰gçš„çŠ¶æ€ä¸ºè¿è¡Œä¸­ gp.waitsince = 0 // è®¾ç½®gè¢«é˜»å¡çš„å¤§çº¦æ—¶é—´ // æŠ¢å ä¿¡å·ï¼Œé‡å¤stackguard0 = stackpreempt gp.preempt = false // const _StackGuard = 928; // è®¾ç½®å½“å‰gæ ˆæ‰©å®¹é˜ˆå€¼ç‚¹ã€‚ gp.stackguard0 = gp.stack.lo + _StackGuard // æ˜¯å¦ç»§æ‰¿å½“å‰æ—¶é—´ç‰‡ã€‚å…·ä½“çš„æŠ¢å åœ¨sysmonç›‘æ§çº¿ç¨‹ä¸­ã€‚ if !inheritTime { // ä¸ç»§æ‰¿ä¸Šä¸€ä¸ªæ—¶é—´ç‰‡æ—¶ï¼Œè°ƒåº¦æ¬¡æ•°ä¼šåŠ ä¸€ _g_.m.p.ptr().schedtick++ // è°ƒåº¦æ¬¡æ•°åŠ ä¸€ } // Check whether the profiler needs to be turned on or off. // // æ£€æŸ¥åˆ†æå™¨æ˜¯å¦éœ€è¦æ‰“å¼€æˆ–å…³é—­ hz := sched.profilehz // sched.profilehzï¼šç”¨æ¥è®¾ç½®æ€§èƒ½åˆ†æçš„é‡‡æ ·é¢‘ç‡ã€‚ if _g_.m.profilehz != hz { setThreadCPUProfiler(hz) } if trace.enabled { // GoSysExit has to happen when we have a P, but before GoStart. // So we emit it here. if gp.syscallsp != 0 \u0026amp;\u0026amp; gp.sysblocktraced { traceGoSysExit(gp.sysexitticks) } traceGoStart() } // gogoå®Œæˆä»g0åˆ°gpçœŸæ­£çš„åˆ‡æ¢ gogo(\u0026amp;gp.sched) } gogo() gogo()å‡½æ•°å®Œæˆä»g0åˆ°gpçš„çš„åˆ‡æ¢ï¼šCPUæ‰§è¡Œæƒçš„è½¬è®©ä»¥åŠæ ˆçš„åˆ‡æ¢ã€‚ å‡½æ•°åŸå‹ï¼šfunc gogo(buf *gobuf)ã€‚ å‚æ•°buf *gobufï¼šéœ€è¦åˆ‡æ¢çš„goroutineçš„è°ƒåº¦ä¿¡æ¯ã€‚ æ–‡ä»¶ä½ç½®ï¼šgo1.19.3/src/runtime/asm_amd64.sã€‚ 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 # func gogo(buf *gobuf) # restore state from Gobuf; longjmp TEXT runtimeÂ·gogo(SB), NOSPLIT, $0-8 # 1) å–å‡ºgobufä¿¡æ¯ï¼Œé‡Œé¢åŒ…å«éœ€è¦è°ƒåº¦çš„ä¿¡æ¯ # å–å‡ºéœ€è¦è°ƒåº¦çš„goroutineï¼Œgp.sched.gï¼Œåˆ¤æ–­è¿™ä¸ªgoroutineä¸ä¸ºnil # executeå‡½æ•°åœ¨è°ƒç”¨gogoæ—¶æŠŠgpçš„schedæˆå‘˜çš„åœ°å€ä½œä¸ºå®å‚ï¼ˆå‹å‚bufï¼‰ä¼ é€’äº†è¿‡æ¥ # è¯¥å‚æ•°ä½äºFPå¯„å­˜å™¨æ‰€æŒ‡çš„ä½ç½®ï¼Œæ‰€ä»¥ç¬¬ä¸€æ¡æŒ‡ä»¤æ˜¯è·å–å‚æ•° # buf = \u0026amp;gp.sched; BX = *gobuf MOVQ buf+0(FP), BX # *gobuf # æŠŠbufçš„å€¼ä¹Ÿå°±æ˜¯gp.schedçš„åœ°å€æ”¾åœ¨äº†BXå¯„å­˜å™¨ä¹‹ä¸­ # è¿™æ ·ä¾¿äºåé¢çš„æŒ‡ä»¤ä¾é BXå¯„å­˜å™¨æ¥å­˜å–gp.schedçš„æˆå‘˜ # æ³¨æ„è¿™é‡Œæ˜¯é—´æ¥å¯»å€æ–¹å¼ # gobuf-\u0026gt;g --\u0026gt; dx register MOVQ gobuf_g(BX), DX\t# DX = gp.sched.g; *g # ä¸‹é¢è¿™è¡Œä»£ç æ²¡æœ‰å®è´¨ä½œç”¨ï¼Œæ£€æŸ¥gp.sched.gæ˜¯å¦æ˜¯nilï¼Œå¦‚æœæ˜¯nilè¿›ç¨‹ä¼šcrashæ­»æ‰ # å¦‚æœDXä¸ºç©ºä½¿ç”¨0(DX)å½¢å¼ç®€ä»‹å¯»å€ä¼šæŠ¥é”™ã€‚ç¡®ä¿ g ä¸æ˜¯ nilã€‚ MOVQ 0(DX), CX # make sure g != nil # 2) ä½¿ç”¨JMPæŒ‡ä»¤è·³è½¬åˆ°gogoå‡½æ•° JMP gogo\u0026lt;\u0026gt;(SB) # æ³¨æ„è¿™é‡Œä½¿ç”¨çš„æ˜¯JMP 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 TEXT gogo\u0026lt;\u0026gt;(SB), NOSPLIT, $0 # 3) æŠŠgpæ”¾å…¥TLSä¸­å’ŒR14å¯„å­˜å™¨ä¸­ # è·å–å½“å‰å·¥ä½œçº¿ç¨‹Mçš„fsæ®µåŸºå€ï¼Œå‰é¢æŠŠfsæ®µåŸºå€è®¾ç½®æˆäº†\u0026amp;m.tls[1]çš„åœ°å€ get_tls(CX) # CX = \u0026amp;m.tls[1] = TLS # æŠŠDXå€¼ä¹Ÿå°±æ˜¯éœ€è¦è¿è¡Œçš„goroutineçš„æŒ‡é’ˆå†™å…¥çº¿ç¨‹æœ¬åœ°å­˜å‚¨ä¹‹ä¸­ # è¿è¡Œè¿™æ¡æŒ‡ä»¤ä¹‹å‰ï¼Œçº¿ç¨‹æœ¬åœ°å­˜å‚¨å­˜æ”¾çš„æ˜¯g0çš„åœ°å€ MOVQ DX, g(CX) # TLS = gp.sched.g # åœ¨g1.17å’Œ1.18ç‰ˆæœ¬ä¸­ R14å¯„å­˜å™¨è¢«ç”¨æ¥æŒ‡å‘å½“å‰goroutineçš„runtime.gç»“æ„ # R14 = gp.sched.g MOVQ DX, R14 # set the g register # 4) è®¾ç½®æ ˆé¡¶SPå¯„å­˜å™¨ï¼Œåˆ‡gpçš„æ ˆï¼Œåˆ‡æ¢æ ˆ # æŠŠCPUçš„SPå¯„å­˜å™¨è®¾ç½®ä¸ºsched.spï¼Œå®Œæˆäº†æ ˆçš„åˆ‡æ¢ï¼Œgp.sched.spè®°å½•ç€gçš„æ ˆé¡¶ä½ç½® # è®¾ç½®CPUçš„æ ˆé¡¶å¯„å­˜å™¨SPä¸ºgp.sched.spï¼Œè¿™æ¡æŒ‡ä»¤å®Œæˆäº†æ ˆçš„åˆ‡æ¢ï¼Œä»g0çš„æ ˆåˆ‡æ¢åˆ°äº†gpçš„æ ˆ # rsp = gp.sched.sp MOVQ gobuf_sp(BX), SP # restore SP # 5) è®¾ç½® AX = gp.sched.ret # è®¾ç½® DX = gp.sched.ctxt é—­åŒ…ä¸Šä¸‹æ–‡ # è®¾ç½® BP = BP = gp.sched.bp æ ˆåº•å¯„å­˜å™¨ # ä¸‹é¢ä¸‰æ¡åŒæ ·æ˜¯æ¢å¤è°ƒåº¦ä¸Šä¸‹æ–‡åˆ°CPUç›¸å…³å¯„å­˜å™¨ # éœ€è¦è¿”å›çš„åœ°å€ MOVQ gobuf_ret(BX), AX # AX = gp.sched.ret\t# ä¸Šä¸‹æ–‡ç¯å¢ƒï¼Œä¹Ÿå°±æ˜¯å½“å‰æ³¨å†Œå‡½æ•°çš„é—­åŒ…æ•è·å±‚ï¼Œfuncvalåœ°å€å¤„ MOVQ gobuf_ctxt(BX), DX # DX = gp.sched.ctxt\t# è®¾ç½®æ ˆåŸºåœ°å€ MOVQ gobuf_bp(BX), BP # BP = gp.sched.bp\t# 6) æ¸…ç©ºgpçš„gobuf.spã€gobuf.retã€gobuf.ctxtã€gobuf.bp # æ¸…ç©ºgp.schedä¸­ä¸å†éœ€è¦çš„å€¼ï¼Œå› ä¸ºæˆ‘ä»¬å·²æŠŠç›¸å…³å€¼æ”¾å…¥CPUå¯¹åº”çš„å¯„å­˜å™¨äº† # clear to help garbage collector MOVQ $0, gobuf_sp(BX) # g.gobuf.sp = 0 MOVQ $0, gobuf_ret(BX) # g.gobuf.ret = 0 MOVQ $0, gobuf_ctxt(BX) # g.gobuf.ctxt = 0 MOVQ $0, gobuf_bp(BX) # g.gobuf.bp = 0 # 7) è·³è½¬åˆ°g.gobuf.pcæ‰§è¡Œgpçš„ç›¸å…³ä»£ç  # æ³¨æ„ï¼šä»g0åˆ‡æ¢çš„gpè¿‡ç¨‹ä¸­ï¼Œå¹¶æ²¡æœ‰ä¿å­˜g0çš„ç›¸å…³æ ˆä¿¡æ¯ # gp.sched.pc è®°å½•ç€æ³¨å†Œå‡½æ•°å¼€å§‹çš„ä»£ç åœ°å€ # æŠŠgp.sched.pcçš„å€¼è¯»å–åˆ°BXå¯„å­˜å™¨ï¼Œè¿™ä¸ªpcå€¼æ˜¯gpè¿™ä¸ªgoroutineé©¬ä¸Šéœ€è¦æ‰§è¡Œçš„ç¬¬ä¸€æ¡æŒ‡ä»¤çš„åœ°å€ # å¯¹äºruntime.mainè¿™ä¸ªåœºæ™¯æ¥è¯´å®ƒç°åœ¨å°±æ˜¯runtime.mainå‡½æ•°çš„ç¬¬ä¸€æ¡æŒ‡ä»¤ï¼Œç°åœ¨è¿™æ¡æŒ‡ä»¤çš„åœ°å€å°±æ”¾åœ¨BXå¯„å­˜å™¨é‡Œé¢ # DXå¯„å­˜å™¨ä½œä¸ºä¸Šä¸‹æ–‡ï¼Œè®°å½•ç€é—­åŒ…å‡½æ•°çš„ç›¸å…³æ•è·å˜é‡ MOVQ gobuf_pc(BX), BX # BX = g.gobuf.pc # è¿™é‡Œçš„JMP BXæŒ‡ä»¤æŠŠBXå¯„å­˜å™¨é‡Œé¢çš„æŒ‡ä»¤åœ°å€æ”¾å…¥CPUçš„ripå¯„å­˜å™¨ # äºæ˜¯ï¼ŒCPUå°±ä¼šè·³è½¬åˆ°è¯¥åœ°å€ç»§ç»­æ‰§è¡Œå±äºgpè¿™ä¸ªgoroutineçš„ä»£ç ï¼Œè¿™æ ·å°±å®Œæˆäº†goroutineçš„åˆ‡æ¢ # è¿˜éœ€è¦æ³¨æ„çš„æ˜¯ï¼šDXå¯„å­˜å™¨çš„å€¼ gp.sched.ctxt å­˜å‚¨çš„æ˜¯é—­åŒ…çš„ä¸Šä¸‹æ–‡ä¿¡æ¯ï¼Œå¦‚æœé—­åŒ…æ•è·äº†å˜é‡åˆ™ä¼šä½¿ç”¨å®ƒã€‚ JMP BX # è·³è½¬åˆ°æ³¨å†Œçš„goroutineå»æ‰§è¡Œäº† æ€»ç»“ï¼š execute()å‡½æ•°å®Œæˆä»ç³»ç»Ÿæ ˆg0åˆ‡æ¢åˆ°æ™®é€šgoroutineçš„è¿‡ç¨‹ï¼ˆè¿™é‡Œæ˜¯å‚æ•°gpï¼‰ã€‚ è¯¥å‡½æ•°å°†å·¥ä½œçº¿ç¨‹mä¸gpç›¸äº’ç»‘å®šï¼Œç„¶ååˆ‡æ¢gpçš„çŠ¶æ€å¹¶è®¾ç½®æ ˆæº¢å‡ºç›¸å…³å‚æ•°ï¼Œä»¥åŠè®¾ç½®è°ƒåº¦æ¬¡æ•°ï¼Œ æ¥ç€è°ƒç”¨gogo()å‡½æ•°æŠŠæ ˆä»g0åˆ‡æ¢æˆgpçš„æ ˆï¼Œå¹¶æŠŠgpçš„è°ƒåº¦ä¿¡æ¯ä¿å­˜åœ¨ç›¸å…³å¯„å­˜å™¨ä¸­ï¼Œç„¶ååˆ‡æ¢åˆ°gpå¼€å§‹æ‰§è¡Œç›¸å…³ä»£ç ã€‚ è¿™é‡Œéœ€è¦æ³¨æ„çš„æ˜¯ï¼Œä»g0åˆ‡æ¢åˆ°gpè¿‡ç¨‹ä¸­å¹¶æ²¡æœ‰ä¿å­˜g0çš„ç›¸å…³æ ˆé¡¶SPç›¸å…³ä¿¡æ¯ï¼Œå› æ­¤g0æ ˆæ€»æ˜¯ä»ä¸€ä¸ªå›ºå®šçš„å¼€å§‹çš„ä½ç½®å¼€å§‹çš„ã€‚ å…¶ä»–ç›¸å…³å‡½æ•° checkTimers() è¯¥å‡½æ•°æ˜¯å”¤é†’time.Sleepã€time.Timerç­‰çš„ç›¸å…³å‡½æ•°ï¼ŒæŸ¥çœ‹runtime.timeræ–‡æ¡£ã€‚ æ–‡ä»¶ä½ç½®ï¼šgo1.19.3/src/runtime/proc.goã€‚ 3269 3270 3271 3272 3273 3274 3275 3276 3277 3278 3279 3280 3281 3282 3283 3284 3285 3286 3287 3288 3289 3290 3291 3292 3293 3294 3295 3296 3297 3298 3299 3300 3301 3302 3303 3304 3305 3306 3307 3308 3309 3310 3311 3312 3313 3314 3315 3316 3317 3318 3319 3320 3321 3322 3323 3324 3325 3326 3327 3328 3329 3330 3331 3332 3333 3334 3335 3336 3337 3338 3339 3340 3341 3342 3343 3344 // checkTimers runs any timers for the P that are ready. // If now is not 0 it is the current time. // It returns the passed time or the current time if now was passed as 0. // and the time when the next timer should run or 0 if there is no next timer, // and reports whether it ran any timers. // If the time when the next timer should run is not 0, // it is always larger than the returned time. // We pass now in and out to avoid extra calls of nanotime. // //go:yeswritebarrierrec func checkTimers(pp *p, now int64) (rnow, pollUntil int64, ran bool) { // If it\u0026#39;s not yet time for the first timer, or the first adjusted // timer, then there is nothing to do. next := int64(atomic.Load64(\u0026amp;pp.timer0When)) nextAdj := int64(atomic.Load64(\u0026amp;pp.timerModifiedEarliest)) if next == 0 || (nextAdj != 0 \u0026amp;\u0026amp; nextAdj \u0026lt; next) { next = nextAdj } if next == 0 { // No timers to run or adjust. // æ— éœ€è¿è¡Œæˆ–è°ƒæ•´è®¡æ—¶å™¨ return now, 0, false } if now == 0 { now = nanotime() } if now \u0026lt; next { // Next timer is not ready to run, but keep going // if we would clear deleted timers. // This corresponds to the condition below where // we decide whether to call clearDeletedTimers. if pp != getg().m.p.ptr() || int(atomic.Load(\u0026amp;pp.deletedTimers)) \u0026lt;= int(atomic.Load(\u0026amp;pp.numTimers)/4) { return now, next, false } } lock(\u0026amp;pp.timersLock) // å¦‚æœå½“å‰Pçš„timerså­˜åœ¨æ•°æ® if len(pp.timers) \u0026gt; 0 {\t// pp.timersè®°å½•ç€å½“å‰Pä¸­æ‰€æœ‰ç›¸å…³çš„timer // adjusttimers åœ¨å½“å‰ P çš„å †ä¸­æŸ¥æ‰¾ä»»ä½•å·²ä¿®æ”¹ä¸ºæ›´æ—©è¿è¡Œçš„å®šæ—¶å™¨ï¼Œå¹¶å°†å®ƒä»¬æ”¾åœ¨å †ä¸­çš„æ­£ç¡®ä½ç½® // åœ¨æŸ¥æ‰¾è¿™äº›è®¡æ—¶å™¨æ—¶ï¼Œå®ƒè¿˜ä¼šç§»åŠ¨å·²ä¿®æ”¹ä¸ºç¨åè¿è¡Œçš„è®¡æ—¶å™¨ï¼Œå¹¶åˆ é™¤å·²åˆ é™¤çš„è®¡æ—¶å™¨ // è°ƒç”¨è€…å¿…é¡»é”å®š pp çš„è®¡æ—¶å™¨ adjusttimers(pp, now) for len(pp.timers) \u0026gt; 0 { // Note that runtimer may temporarily unlock // pp.timersLock. // è¯·æ³¨æ„ï¼Œruntimer å¯èƒ½ä¼šæš‚æ—¶è§£é” pp.timersLock // runtimerå‡½æ•° // runtimer æ£€æŸ¥timersä¸­çš„ç¬¬ä¸€ä¸ªtimerã€‚ å¦‚æœå®ƒåŸºäºnowå‡†å¤‡å¥½ï¼Œå®ƒä¼šè¿è¡Œtimerå¹¶åˆ é™¤æˆ–æ›´æ–°å®ƒ // å¦‚æœå®ƒè¿è¡Œäº†ä¸€ä¸ªtimerï¼Œåˆ™è¿”å› 0ï¼Œå¦‚æœæ²¡æœ‰æ›´å¤šçš„timerï¼Œåˆ™è¿”å› -1ï¼Œæˆ–è€…ç¬¬ä¸€ä¸ªtimeråº”è¯¥è¿è¡Œçš„æ—¶é—´ if tw := runtimer(pp, now); tw != 0 { if tw \u0026gt; 0 { pollUntil = tw } break } ran = true } } // If this is the local P, and there are a lot of deleted timers, // clear them out. We only do this for the local P to reduce // lock contention on timersLock. // å¦‚æœå½“å‰Pæ˜¯å½“å‰å·¥ä½œçº¿ç¨‹ç»‘å®šçš„Pï¼Œå¹¶ä¸”æœ‰å¾ˆå¤šè¢«åˆ é™¤çš„timerï¼Œæ¸…é™¤å®ƒä»¬ // æˆ‘ä»¬åªå¯¹æœ¬åœ° P è¿™æ ·åšï¼Œä»¥å‡å°‘ timersLock ä¸Šçš„é”äº‰ç”¨ if pp == getg().m.p.ptr() \u0026amp;\u0026amp; int(atomic.Load(\u0026amp;pp.deletedTimers)) \u0026gt; len(pp.timers)/4 { clearDeletedTimers(pp) } unlock(\u0026amp;pp.timersLock) return now, pollUntil, ran } checkdead() æ£€æŸ¥æ­»é”æƒ…å†µã€‚æ£€æŸ¥åŸºäºæ­£åœ¨è¿è¡Œçš„Mçš„æ•°é‡ï¼Œå¦‚æœ0 -\u0026gt; deadlockã€‚ sched.lockå¿…é¡»è¢«æŒæœ‰ã€‚ æ–‡ä»¶ä½ç½®ï¼šgo1.19.3/src/runtime/proc.goã€‚ 5017 5018 5019 5020 5021 5022 5023 5024 5025 5026 5027 5028 5029 5030 5031 5032 5033 5034 5035 5036 5037 5038 5039 5040 5041 5042 5043 5044 5045 5046 5047 5048 5049 5050 5051 5052 5053 5054 5055 5056 5057 5058 5059 5060 5061 5062 5063 5064 5065 5066 5067 5068 5069 5070 5071 5072 5073 5074 5075 5076 5077 5078 5079 5080 5081 5082 5083 5084 5085 5086 5087 5088 5089 5090 5091 5092 5093 5094 5095 5096 5097 5098 5099 5100 5101 5102 5103 5104 5105 5106 5107 5108 5109 5110 5111 5112 5113 5114 5115 5116 5117 5118 5119 5120 5121 5122 5123 5124 5125 5126 // Check for deadlock situation. // The check is based on number of running M\u0026#39;s, if 0 -\u0026gt; deadlock. // sched.lock must be held. func checkdead() { // sched.lock å¿…é¡»è¢«æŒæœ‰ assertLockHeld(\u0026amp;sched.lock) // For -buildmode=c-shared or -buildmode=c-archive it\u0026#39;s OK if // there are no running goroutines. The calling program is // assumed to be running. if islibrary || isarchive { return } // If we are dying because of a signal caught on an already idle thread, // freezetheworld will cause all running threads to block. // And runtime will essentially enter into deadlock state, // except that there is a thread that will call exit soon. if panicking.Load() \u0026gt; 0 { return } // If we are not running under cgo, but we have an extra M then account // for it. (It is possible to have an extra M on Windows without cgo to // accommodate callbacks created by syscall.NewCallback. See issue #6751 // for details.) var run0 int32 if !iscgo \u0026amp;\u0026amp; cgoHasExtraM { mp := lockextra(true) haveExtraM := extraMCount \u0026gt; 0 unlockextra(mp) if haveExtraM { run0 = 1 } } //func mcount() int32 { // return int32(sched.mnext - sched.nmfreed) //} run := mcount() - sched.nmidle - sched.nmidlelocked - sched.nmsys if run \u0026gt; run0 { return } if run \u0026lt; 0 { print(\u0026#34;runtime: checkdead: nmidle=\u0026#34;, sched.nmidle, \u0026#34; nmidlelocked=\u0026#34;, sched.nmidlelocked, \u0026#34; mcount=\u0026#34;, mcount(), \u0026#34; nmsys=\u0026#34;, sched.nmsys, \u0026#34;\\n\u0026#34;) throw(\u0026#34;checkdead: inconsistent counts\u0026#34;) } grunning := 0 forEachG(func(gp *g) { if isSystemGoroutine(gp, false) { return } s := readgstatus(gp) switch s \u0026amp;^ _Gscan { case _Gwaiting, _Gpreempted: grunning++ case _Grunnable, _Grunning, _Gsyscall: print(\u0026#34;runtime: checkdead: find g \u0026#34;, gp.goid, \u0026#34; in status \u0026#34;, s, \u0026#34;\\n\u0026#34;) throw(\u0026#34;checkdead: runnable g\u0026#34;) } }) if grunning == 0 { // possible if main goroutine calls runtimeÂ·Goexit() unlock(\u0026amp;sched.lock) // unlock so that GODEBUG=scheddetail=1 doesn\u0026#39;t hang fatal(\u0026#34;no goroutines (main called runtime.Goexit) - deadlock!\u0026#34;) } // Maybe jump time forward for playground. if faketime != 0 { if when := timeSleepUntil(); when \u0026lt; maxWhen { faketime = when // Start an M to steal the timer. pp, _ := pidleget(faketime) if pp == nil { // There should always be a free P since // nothing is running. throw(\u0026#34;checkdead: no p for timer\u0026#34;) } mp := mget() if mp == nil { // There should always be a free M since // nothing is running. throw(\u0026#34;checkdead: no m for timer\u0026#34;) } // M must be spinning to steal. We set this to be // explicit, but since this is the only M it would // become spinning on its own anyways. sched.nmspinning.Add(1) mp.spinning = true mp.nextp.set(pp) notewakeup(\u0026amp;mp.park) return } } // There are no goroutines running, so we can look at the P\u0026#39;s. for _, pp := range allp { // å½“æŸä¸ªPä¸­å­˜åœ¨timerï¼Œå³ä½¿å…¨éƒ¨Péƒ½ç¡çœ äº†ä¹Ÿä¸ä¼šæŠ¥é”™ if len(pp.timers) \u0026gt; 0 { return } } unlock(\u0026amp;sched.lock) // unlock so that GODEBUG=scheddetail=1 doesn\u0026#39;t hang fatal(\u0026#34;all goroutines are asleep - deadlock!\u0026#34;) } ","permalink":"https://heliu.site/posts/golang/goroutine/mstart/","summary":"Golang GMPè°ƒåº¦æ¨¡å‹ä»‹ç»ã€‚","title":"GMP è°ƒåº¦æ¨¡å‹"},{"content":"runtime.main ç›‘æ§çº¿ç¨‹åœ¨runtime.mainä¸­è¢«åˆ›å»ºã€‚ func main() { // ... if GOARCH != \u0026#34;wasm\u0026#34; { // no threads on wasm yet, so no sysmon // systemstack()å‡½æ•°åˆ‡æ¢åˆ°g0æ ˆå»è¿è¡Œé—­åŒ…å‡½æ•° systemstack(func() { // newmæ–°åˆ›å»ºä¸€ä¸ªçº¿ç¨‹ï¼Œä»sysmonå…¥å£å‡½æ•°å¼€å§‹æ‰§è¡Œ newm(sysmon, nil, -1) // ç›‘æ§çº¿ç¨‹sysmonä¸éœ€è¦På°±èƒ½è¿è¡Œ }) } // ... } variables // forcegcperiod is the maximum time in nanoseconds between garbage // collections. If we go this long without a garbage collection, one // is forced to run. // // This is a variable for testing purposes. It normally doesn\u0026#39;t change. // // forceegcperiodæ˜¯ä¸¤æ¬¡åƒåœ¾å›æ”¶ä¹‹é—´çš„æœ€å¤§æ—¶é—´ï¼Œå•ä½ä¸ºçº³ç§’ã€‚ // å¦‚æœè¿™ä¹ˆé•¿æ—¶é—´éƒ½æ²¡æœ‰åƒåœ¾æ”¶é›†ï¼Œé‚£ä¹ˆåƒåœ¾æ”¶é›†å°†è¢«è¿«è¿è¡Œã€‚ // è¿™æ˜¯ä¸€ä¸ªç”¨äºæµ‹è¯•çš„å˜é‡ã€‚å®ƒé€šå¸¸ä¸ä¼šæ”¹å˜ã€‚ var forcegcperiod int64 = 2 * 60 * 1e9 // 2min sysmon() å‰é¢åˆ›å»ºç›‘æ§çº¿ç¨‹å¯ä»¥çœ‹å‡ºï¼Œç›‘æ§çº¿ç¨‹æ˜¯æ²¡æœ‰ç»‘å®šPçš„ã€‚ è¿™ä¸ªç›‘æ§çº¿ç¨‹æ˜¯ä¸€ä¸ªç‹¬ç«‹çš„çº¿ç¨‹ï¼Œæ— éœ€På³å¯è¿è¡Œï¼Œsysmonæ¯20us ~ 10msè¿è¡Œä¸€æ¬¡ã€‚ timeråœ¨æ¯æ¬¡è°ƒåº¦å™¨è°ƒåº¦å’Œçªƒå–å…¶ä»–gçš„æ—¶å€™è§¦å‘ï¼Œè¿™ç§å…·æœ‰ä¸€å®šçš„éšæœºæ€§å’Œä¸ç¡®å®šæ€§ï¼Œç³»ç»Ÿç›‘æ§çº¿ç¨‹è§¦å‘ä¾ç„¶æ˜¯ä¸€ä¸ªå…œåº•ä¿éšœã€‚ ç›‘æ§çº¿ç¨‹ä¸»è¦èŒè´£ï¼š æœ€é•¿10msé—´éš”æ‰§è¡Œä¸€æ¬¡ç½‘ç»œè½®è¯¢ï¼ˆä¿è¯I/Oè½®è¯¢ï¼‰ã€‚å› ä¸ºnetpollæ˜¯éšæœºçš„ï¼Œä¸æ˜¯å®šæ—¶é—´æ®µçš„ã€‚ æŠ¢å è¶…è¿‡æ—¶é—´ç‰‡çš„Gã€‚ è¶…è¿‡é¢„å®šæ—¶é—´ï¼Œå‘èµ·ä¸€è½®GCã€‚ æ€»æ˜¯åœ¨æ²¡æœ‰Pçš„æƒ…å†µä¸‹è¿è¡Œï¼Œå› æ­¤ä¸å…è®¸å†™å±éšœã€‚ æ–‡ä»¶ä½ç½®ï¼šgo1.19.3/src/runtime/proc.goã€‚ 5131 5132 5133 5134 5135 5136 5137 5138 5139 5140 5141 5142 5143 5144 5145 5146 5147 5148 5149 5150 5151 5152 5153 5154 5155 5156 5157 5158 5159 5160 5161 5162 5163 5164 5165 5166 5167 5168 5169 5170 5171 5172 5173 5174 5175 5176 5177 5178 5179 5180 5181 5182 5183 5184 5185 5186 5187 5188 5189 5190 5191 5192 5193 5194 5195 5196 5197 5198 5199 5200 5201 5202 5203 5204 5205 5206 5207 5208 5209 5210 5211 5212 5213 5214 5215 5216 5217 5218 5219 5220 5221 5222 5223 5224 5225 5226 5227 5228 5229 5230 5231 5232 5233 5234 5235 5236 5237 5238 5239 5240 5241 5242 5243 5244 5245 5246 5247 5248 5249 5250 5251 5252 5253 5254 5255 5256 5257 5258 5259 5260 5261 5262 5263 5264 5265 5266 5267 5268 5269 5270 5271 5272 5273 5274 5275 5276 5277 5278 5279 5280 5281 5282 5283 5284 5285 5286 5287 5288 5289 5290 5291 5292 5293 5294 5295 5296 5297 5298 5299 5300 5301 5302 5303 5304 5305 5306 5307 5308 5309 5310 5311 5312 5313 5314 5315 5316 5317 5318 5319 5320 5321 5322 5323 5324 5325 5326 5327 5328 5329 5330 5331 5332 5333 5334 5335 5336 5337 5338 5339 5340 5341 5342 5343 5344 5345 5346 5347 5348 5349 5350 5351 5352 5353 5354 5355 5356 5357 5358 5359 5360 5361 5362 5363 5364 5365 5366 5367 5368 5369 5370 5371 5372 5373 5374 5375 5376 5377 5378 5379 // Always runs without a P, so write barriers are not allowed. // //go:nowritebarrierrec func sysmon() { lock(\u0026amp;sched.lock) sched.nmsys++ // ç³»ç»ŸMæ•°é‡ checkdead() // æ£€æŸ¥æ­»é” unlock(\u0026amp;sched.lock) lasttrace := int64(0) // æœ€åè·Ÿè¸ªæ—¶é—´ // idleï¼šåœ¨ä»¥ä¸‹ä¸¤ç§æƒ…å†µä¸‹æ‰ä¼šé‡ç½®ä¸º0 // 1. æœ‰é™·å…¥ç³»ç»Ÿè°ƒåº¦çš„Péœ€è¦è¢«æŠ¢å æ—¶ã€‚ // 2. sysmonä»æ·±åº¦ç¡çœ ä¸­é†’æ¥æ—¶ã€‚ // è¿›å…¥æ·±åº¦ç¡çœ åœ¨è¿™ä¸¤ç§æ¡ä»¶ä¸‹ï¼š // 1. STWæœŸé—´ï¼Œsysmonå¯ä»¥è¿›å…¥æ·±åº¦ç¡çœ ã€‚ // 2. åœ¨æ‰€æœ‰Péƒ½ç©ºé—²æ—¶(å¯èƒ½éƒ½é™·å…¥ç³»ç»Ÿè°ƒç”¨)ã€‚ // å…¶ä»–æƒ…å†µidleä¼šç´¯åŠ ï¼Œå› æ­¤sysmonçš„è°ƒåº¦é—´éš”ä¼šè¶‹å‘äº10msã€‚è¿™ä¸€ä¸ªgoroutineè¿è¡Œçš„æ—¶é—´ç‰‡æ—¶é—´å€¼ã€‚ idle := 0 // how many cycles in succession we had not wokeup somebody // ä¸‹æ¬¡sysmonè¿è¡Œçš„æ—¶é—´é—´éš”ï¼Œå¾®ç§’ã€‚æ ¹æ®idleè®¡ç®—è€Œæ¥ã€‚ delay := uint32(0) for { // 1) è®¡ç®—ä¸‹æ¬¡è¿è¡Œæ—¶é—´é—´éš” // 1. é»˜è®¤20usã€‚(20å¾®ç§’)ã€‚ // 2. è¿ç»­50ä¸ªå‘¨æœŸæ— äº‹å¯åšåˆ™ç¿»å€æ—¶é—´ï¼Œåé¢ä¾æ¬¡ç¿»å€ã€‚ // 3. æœ€é«˜10msã€‚(10æ¯«ç§’)ã€‚ if idle == 0 { // start with 20us sleep... delay = 20 } else if idle \u0026gt; 50 { // start doubling the sleep after 1ms... delay *= 2\t} if delay \u0026gt; 10*1000 { // up to 10ms delay = 10 * 1000\t} // ç³»ç»Ÿè°ƒç”¨sleep delayå¾®ç§’ usleep(delay) // sysmon should not enter deep sleep if schedtrace is enabled so that // it can print that information at the right time. // // It should also not enter deep sleep if there are any active P\u0026#39;s so // that it can retake P\u0026#39;s from syscalls, preempt long running G\u0026#39;s, and // poll the network if all P\u0026#39;s are busy for long stretches. // // It should wakeup from deep sleep if any P\u0026#39;s become active either due // to exiting a syscall or waking up due to a timer expiring so that it // can resume performing those duties. If it wakes from a syscall it // resets idle and delay as a bet that since it had retaken a P from a // syscall before, it may need to do it again shortly after the // application starts work again. It does not reset idle when waking // from a timer to avoid adding system load to applications that spend // most of their time sleeping. // // å¦‚æœå¯ç”¨äº† schedtraceï¼Œsysmon ä¸åº”è¿›å…¥æ·±åº¦ç¡çœ ï¼Œä»¥ä¾¿å®ƒå¯ä»¥åœ¨æ­£ç¡®çš„æ—¶é—´æ‰“å°è¯¥ä¿¡æ¯ // å¦‚æœæœ‰ä»»ä½•æ´»åŠ¨çš„Pï¼Œå®ƒä¹Ÿä¸åº”è¯¥è¿›å…¥æ·±åº¦ç¡çœ ï¼Œä»¥ä¾¿å®ƒå¯ä»¥ä»ç³»ç»Ÿè°ƒç”¨ä¸­é‡æ–°è·å–Pï¼Œ // æŠ¢å é•¿æ—¶é—´è¿è¡Œçš„Gï¼Œå¹¶åœ¨æ‰€æœ‰Pé•¿æ—¶é—´å¿™ç¢Œæ—¶è½®è¯¢ç½‘ç»œ // å¦‚æœä»»ä½• P ç”±äºé€€å‡ºç³»ç»Ÿè°ƒç”¨æˆ–ç”±äºè®¡æ—¶å™¨åˆ°æœŸè€Œå”¤é†’ï¼Œ // å®ƒåº”è¯¥ä»æ·±åº¦ç¡çœ ä¸­å”¤é†’ï¼Œä»¥ä¾¿å®ƒå¯ä»¥æ¢å¤æ‰§è¡Œè¿™äº›èŒè´£ // æœå®ƒä»ç³»ç»Ÿè°ƒç”¨ä¸­å”¤é†’ï¼Œå®ƒä¼šé‡ç½®ç©ºé—²å’Œå»¶è¿Ÿä½œä¸ºèµŒæ³¨ï¼Œå› ä¸ºå®ƒä¹‹å‰å·²ç»ä»ç³»ç»Ÿè°ƒç”¨ä¸­é‡æ–°è·å¾—äº†Pï¼Œ // å®ƒå¯èƒ½éœ€è¦åœ¨åº”ç”¨ç¨‹åºå†æ¬¡å¼€å§‹å·¥ä½œåä¸ä¹…å†æ¬¡è¿™æ ·åš // å®ƒä¸ä¼šåœ¨ä»è®¡æ—¶å™¨å”¤é†’æ—¶é‡ç½®ç©ºé—²ï¼Œä»¥é¿å…å°†ç³»ç»Ÿè´Ÿè½½æ·»åŠ åˆ°å¤§éƒ¨åˆ†æ—¶é—´éƒ½åœ¨ä¼‘çœ çš„åº”ç”¨ç¨‹åº now := nanotime() // å½“å‰æ—¶é—´ // 2) æ»¡è¶³ä»¥ä¸‹æ¡ä»¶å·¥ä½œçº¿ç¨‹ä¼šè¿›å…¥æ·±åº¦ç¡çœ ï¼š // 1. STWæ­£åœ¨ç­‰å¾…å…¶ä»–Påœä¸‹æ¥ï¼Œè¿™æ®µæ—¶é—´sysmonçº¿ç¨‹å¯ä»¥æ·±åº¦ç¡çœ ï¼Œåœ¨start the worldæ—¶ä¼šå”¤é†’sysmonã€‚ // 2. å…¨éƒ¨Péƒ½å¤„äºç©ºé—²ï¼Œè¿™æ®µæ—¶é—´sysmonçº¿ç¨‹å¯ä»¥æ·±åº¦ç¡çœ ï¼Œè¿™å¯èƒ½æ˜¯å¤„äºç³»ç»Ÿè°ƒç”¨ä¸­æ—¶ï¼Œç³»ç»Ÿè°ƒç”¨è¿”å›æ—¶ä¼šå”¤é†’sysmonã€‚ if debug.schedtrace \u0026lt;= 0 \u0026amp;\u0026amp; (sched.gcwaiting != 0 || atomic.Load(\u0026amp;sched.npidle) == uint32(gomaxprocs)) { lock(\u0026amp;sched.lock) // mutex lock // åŠ é”åï¼Œå†æ¬¡åˆ¤æ–­ä¸€æ¬¡åŸå› æ˜¯è·å–é”è¿™æ®µæ—¶é—´å¯èƒ½æ¡ä»¶ä¸æˆç«‹äº†ã€‚ if atomic.Load(\u0026amp;sched.gcwaiting) != 0 || atomic.Load(\u0026amp;sched.npidle) == uint32(gomaxprocs) { syscallWake := false // ç³»ç»Ÿè°ƒç”¨å”¤é†’? // 2.1) æœ€è¿‘ä¸€æ¬¡timerçš„è§¦å‘æ—¶é—´ç‚¹æˆ–æ²¡æœ‰timeræ—¶éƒ½åº”è¯¥sleepã€‚ // timeSleepUntilå‡½æ•°åªä¼šåœ¨sysmonå’Œcheckdeadå‡½æ•°ä¸­è¢«è°ƒç”¨ï¼š // 1. nextè¡¨ç¤ºæœ€å…ˆè§¦å‘timerçš„æ—¶é—´ç‚¹ï¼ŒtimeSleepUntilå‡½æ•°ä¼šéå†æ‰€æœ‰çš„På–é€‰æ‹©æœ€å°çš„timerè§¦å‘æ—¶é—´ç‚¹ã€‚ // 2. è¿”å› maxWhen = 1\u0026lt;\u0026lt;63 - 1ï¼Œè¡¨ç¤ºæ²¡æœ‰å®šæ—¶å™¨ã€‚ next, _ := timeSleepUntil() // 2.2) è¿˜æœªåˆ°è§¦å‘timerçš„æ—¶é—´ç‚¹æ—¶æˆ–æ²¡æœ‰timerï¼Œè¿™æ®µæ—¶é—´å¯ä»¥sleepã€‚ if next \u0026gt; now {\tatomic.Store(\u0026amp;sched.sysmonwait, 1) // sched.sysmonwait = 1 unlock(\u0026amp;sched.lock)\t// Make wake-up period small enough // for the sampling to be correct. // // ä½¿å”¤é†’å‘¨æœŸè¶³å¤Ÿå°ï¼Œä»¥ä¿è¯å–æ ·æ­£ç¡®ã€‚ // 2.3) è®¡ç®—ç¡çœ æ—¶é—´é—´éš”æœ€å¤§å€¼1åˆ†é’Ÿã€‚ sleep := forcegcperiod / 2 // 1min if next-now \u0026lt; sleep { sleep = next - now } // osRelaxMinNS è¡¨ç¤ºå¦‚æœä¸‹ä¸€ä¸ªè®¡æ—¶å™¨ä»ç°åœ¨å¼€å§‹å°‘äº 60 æ¯«ç§’ï¼Œåˆ™ sysmon ä¸åº”è¯¥ osRelax // ç”±äº osRelaxing å¯èƒ½ä¼šå°†è®¡æ—¶å™¨åˆ†è¾¨ç‡é™ä½åˆ° 15.6 æ¯«ç§’ï¼Œè¿™å°†è®¡æ—¶å™¨é”™è¯¯ä¿æŒåœ¨å¤§çº¦ 4 åˆ†ä¹‹ä¸€ä»¥ä¸‹ // const osRelaxMinNS = 0 shouldRelax := sleep \u0026gt;= osRelaxMinNS if shouldRelax { // osRelax åœ¨ä¸æ‰€æœ‰ç©ºé—²çš„ P ä¹‹é—´è½¬æ¢æ—¶ç”±è°ƒåº¦ç¨‹åºè°ƒç”¨ // åœ¨ linux amd64 ä¸‹è¯¥å‡½æ•°ä¸ºç©º osRelax(true)\t} // 2.4) åœ¨sched.sysmonnoteä¸Šç¡çœ sleepçº³ç§’ã€‚ // ç¡çœ  sleep ns æ—¶é—´ï¼Œç¡çœ åœ¨ sched.sysmonnote ä¸Šã€‚ // æœ€é•¿æƒ…å†µä¼šç¡çœ 1minï¼Œä¹Ÿå°±æ˜¯å…¨éƒ¨Péƒ½æ— äº‹å¯åšæ—¶ã€‚ // sleepæ—¶é—´åï¼Œä¹Ÿå°±æ˜¯æœ€æ–°çš„timeréœ€è¦è§¦å‘çš„æ—¶é—´ç‚¹ï¼Œå”¤é†’ç›‘æ§çº¿ç¨‹ã€‚ // å½“ STW æ­£åœ¨è¿›è¡Œæ—¶ï¼Œè¿™é‡Œä¼šæŠŠç›‘æ§çº¿ç¨‹sleep 1minï¼Œåœ¨start the worldæ—¶ä¼šå”¤é†’ // åœ¨sched.sysmonnoteä¸Šçš„ç›‘æ§çº¿ç¨‹ã€‚ // å½“ç³»ç»Ÿè°ƒç”¨è¿”å›ï¼Œåœ¨runtime_exitsyscall()å‡½æ•°ä¸­ä¼šå“åº”çš„å”¤é†’ // åœ¨sched.sysmonnoteä¸Šçš„ç›‘æ§çº¿ç¨‹ã€‚ // syscallWake = trueã€‚ syscallWake = notetsleep(\u0026amp;sched.sysmonnote, sleep) if shouldRelax { osRelax(false) } lock(\u0026amp;sched.lock) // sched.sysmonwait = 0;sched.sysmonnote.key = 0; atomic.Store(\u0026amp;sched.sysmonwait, 0) noteclear(\u0026amp;sched.sysmonnote) } // ç”±ç³»ç»Ÿè°ƒç”¨é†’æ¥æˆ–è§¦å‘timeræ—¶é—´ç‚¹å·²ç»è¿‡äº†ï¼Œé‡ç½®è®¡æ—¶ã€‚ if syscallWake { idle = 0 delay = 20 } } unlock(\u0026amp;sched.lock) } lock(\u0026amp;sched.sysmonlock) // Update now in case we blocked on sysmonnote or spent a long time // blocked on schedlock or sysmonlock above. // // å¦‚æœæˆ‘ä»¬åœ¨sysmonnoteä¸Šè¢«é˜»å¡ï¼Œæˆ–è€…åœ¨ä¸Šé¢çš„schedlockæˆ–sysmonlockä¸ŠèŠ±äº†å¾ˆé•¿æ—¶é—´é˜»å¡ï¼Œç°åœ¨æ›´æ–°ã€‚ now = nanotime() // trigger libc interceptors if needed if *cgo_yield != nil { asmcgocall(*cgo_yield, nil) } // 3) network poll; ç½‘ç»œè½®è¯¢ã€‚ // ç½‘ç»œè½®è¯¢çš„æ—¶é—´é—´éš”è®¾ç½®ä¸º10msã€‚ // poll network if not polled for more than 10ms // // è¶…è¿‡10msæ²¡æœ‰è¿›è¡Œç½‘ç»œè½®è¯¢ï¼Œåˆ™è¿›è¡Œç½‘ç»œè½®è¯¢ã€‚ // sched.lastpollï¼šè®°å½•çš„æ˜¯ä¸Šæ¬¡æ‰§è¡Œnetpollçš„æ—¶é—´ã€‚ // 1. å¦‚æœç­‰äº0ï¼Œåˆ™è¡¨ç¤ºæŸä¸ªçº¿ç¨‹æ­£åœ¨é˜»å¡å¼åœ°æ‰§è¡Œnetpollã€‚ // 2. å¤§äº0ï¼Œåˆ™æ˜¯ä¸Šæ¬¡æ‰§è¡Œæ—¶é—´ç‚¹ã€‚ lastpoll := int64(atomic.Load64(\u0026amp;sched.lastpoll)) // ä»¥ä¸‹ä¸‰ç§æƒ…å†µä¸ä¼šè½®è¯¢ç½‘ç»œï¼š // 1. æ²¡æœ‰åˆå§‹åŒ– netpoll æ—¶ã€‚ // 2. å…¶ä»–çº¿ç¨‹é˜»å¡å¼è®¿é—® netpoll æ—¶ã€‚ // 3. ä¸Šæ¬¡è½®è¯¢æ—¶é—´è¿˜æ²¡åˆ° 10ms æ—¶ã€‚ // éœ€è¦æŸ¥çœ‹networkï¼šå·²åˆå§‹åŒ– \u0026amp;\u0026amp; æ²¡æœ‰å…¶ä»–çº¿ç¨‹åœ¨é˜»å¡è°ƒç”¨epoll \u0026amp;\u0026amp; ä¸Šæ¬¡epollå·²è¶…è¿‡10msäº† if netpollinited() \u0026amp;\u0026amp; lastpoll != 0 \u0026amp;\u0026amp; lastpoll+10*1000*1000 \u0026lt; now { // CASæ›´æ–° sched.lastpoll æ—¶é—´ã€‚ atomic.Cas64(\u0026amp;sched.lastpoll, uint64(lastpoll), uint64(now)) // 3.1) è½®è¯¢ pollã€‚å‚æ•°0ç«‹å³è¿”å›ã€‚ // network pollæ˜¯å¦æœ‰å°±ç»ªçš„äº‹ä»¶ã€‚ // ä¼ é€’å‚æ•°0è¡¨ç¤ºepollè½®è¯¢waitç­‰å¾…å‡½æ•°ç«‹å³è¿”å›ã€‚ // éé˜»å¡å¼è½®è¯¢ï¼Œè¿”å›å°±ç»ªçš„goroutineåˆ—è¡¨ã€‚ list := netpoll(0) // non-blocking - returns list of goroutines // å­˜åœ¨å°±ç»ªçš„ goroutineã€‚ if !list.empty() { // Need to decrement number of idle locked M\u0026#39;s // (pretending that one more is running) before injectglist. // Otherwise it can lead to the following situation: // injectglist grabs all P\u0026#39;s but before it starts M\u0026#39;s to run the P\u0026#39;s, // another M returns from syscall, finishes running its G, // observes that there is no work to do and no other running M\u0026#39;s // and reports deadlock. // // è®¾ç½® sched.nmidlelocked += -1 incidlelocked(-1) // å¤„ç†å‡†å¤‡å¥½çš„goroutine // è¯¥å‡½æ•°åœ¨è°ƒåº¦å¾ªç¯å‡½æ•°ä¸­æœ‰è¯¦ç»†æ³¨è§£ã€‚ injectglist(\u0026amp;list) incidlelocked(1) } } // åœ¨ linux amd64 ä¸‹ä¸ä¼šè§¦å‘ã€‚ if GOOS == \u0026#34;netbsd\u0026#34; \u0026amp;\u0026amp; needSysmonWorkaround { // netpoll is responsible for waiting for timer // expiration, so we typically don\u0026#39;t have to worry // about starting an M to service timers. (Note that // sleep for timeSleepUntil above simply ensures sysmon // starts running again when that timer expiration may // cause Go code to run again). // // However, netbsd has a kernel bug that sometimes // misses netpollBreak wake-ups, which can lead to // unbounded delays servicing timers. If we detect this // overrun, then startm to get something to handle the // timer. // // See issue 42515 and // https://gnats.netbsd.org/cgi-bin/query-pr-single.pl?number=50094. if next, _ := timeSleepUntil(); next \u0026lt; now { startm(nil, false) } } if atomic.Load(\u0026amp;scavenge.sysmonWake) != 0 { // Kick the scavenger awake if someone requested it. wakeScavenger() } // 4) æ£€æŸ¥æ‰€æœ‰çš„PæŸ¥çœ‹æ˜¯å¦å­˜åœ¨è¿è¡Œæ—¶é—´å¤ªé•¿çš„Géœ€è¦è®¾ç½®æŠ¢å è¯·æ±‚ã€‚ // 1. goroutineè¿è¡Œæ—¶é—´è¶…è¿‡10msæ—¶éœ€è¦æŠ¢å ã€‚ // 2. goroutineé™·å…¥ç³»ç»Ÿè°ƒç”¨ï¼Œè¿è¡Œæ—¶é—´è¶…è¿‡10msæˆ–åœ¨ç¬¬äºŒè½®æ¥æ˜¯sysmonç³»ç»Ÿè°ƒç”¨è¿˜æ²¡è¿”å›æ—¶ã€‚ // é™·å…¥ç³»ç»Ÿè°ƒç”¨è€ŒæŠ¢å Pçš„æƒ…å†µï¼š // 1. è¿è¡Œæ—¶é—´è¶…è¿‡10msï¼Œå¯èƒ½ä¸€å¼€å§‹å°±é™·å…¥ç³»ç»Ÿè°ƒç”¨ï¼Œæˆ–ä¸­é€”é™·å…¥ç³»ç»Ÿè°ƒç”¨ã€‚ä¸è®ºé‚£ç§æƒ…å†µéƒ½åº”è¯¥æŠ¢å ã€‚ // 2. è¿è¡Œæ—¶é—´æ²¡åˆ°10msï¼Œä½†æ˜¯ä¸¤è½®sysmonäº†è¿˜æ˜¯åœ¨ç³»ç»Ÿè°ƒç”¨ä¸­ï¼Œéœ€è¦æŠ¢å Pã€‚è¿™æ—¶å€™æ—¶é—´é—´éš”åœ¨(0, 20ms)è¿™ä¸ªèŒƒå›´ã€‚ // retake P\u0026#39;s blocked in syscalls // and preempt long running G\u0026#39;s // // é‡æ–°è·å–åœ¨ç³»ç»Ÿè°ƒç”¨ä¸­é˜»å¡çš„ P å¹¶æŠ¢å é•¿æ—¶é—´è¿è¡Œçš„ G // retakeå‡½æ•°è¿”å›å€¼ï¼Œé™·å…¥ç³»ç»Ÿè°ƒç”¨çš„éœ€è¦æŠ¢å çš„Pçš„æ•°é‡ã€‚ if retake(now) != 0 { // ä¸ºä»€ä¹ˆé™·å…¥ç³»ç»Ÿè°ƒåº¦çš„Péœ€è¦é‡ç½®ç›‘æ§é¢‘ç‡ï¼Ÿ // åŸå› æ˜¯é™·å…¥ç³»ç»Ÿè°ƒåº¦çš„Pï¼ŒæŠŠæ—¶é—´è°ƒå›20usï¼Œä¸‹è½®ç›‘æ§çº¿ç¨‹æ¥æ—¶åˆ¤æ–­æ˜¯å¦è¿˜åœ¨ç³»ç»Ÿè°ƒç”¨ä¸­ã€‚ idle = 0 } else { idle++ } // 5) GCç›¸å…³ï¼Œå®šæ—¶æ£€æŸ¥GCæ˜¯å¦è¯¥è§¦å‘äº† // check if we need to force a GC // t.test()ï¼šåˆ¤æ–­æ˜¯å¦æ»¡è¶³å®šæ—¶GCé—´éš”2åˆ†é’Ÿçš„æ¡ä»¶ // forcegc.idle.Load()ï¼šå½“å‰å®šæ—¶GCæ˜¯ç©ºé—²çš„ if t := (gcTrigger{kind: gcTriggerTime, now: now}); t.test() \u0026amp;\u0026amp; atomic.Load(\u0026amp;forcegc.idle) != 0 { lock(\u0026amp;forcegc.lock) // è·å–äº’æ–¥é” forcegc.idle = 0 // æ ‡è®°æœ¬è½®å®šæ—¶GCå¼€å§‹äº† var list gList // goroutineçš„åˆ—è¡¨ï¼Œæœ€åä¼šæŠŠé‡Œé¢çš„goroutineæ”¾å…¥Pçš„æœ¬åœ°é˜Ÿåˆ— list.push(forcegc.g)// forcegchelper goroutine åŠ å…¥æœ¬åœ°é˜Ÿåˆ—ï¼Œå»è§¦å‘goroutine injectglist(\u0026amp;list) // list åŠ å…¥Pçš„æœ¬åœ°é˜Ÿåˆ—ç­‰å¾…Mè°ƒç”¨ï¼Œç­‰å¾…forcegchelper()å‡½æ•°ç»§ç»­è¿è¡Œå§ unlock(\u0026amp;forcegc.lock)// è§£é” } if debug.schedtrace \u0026gt; 0 \u0026amp;\u0026amp; lasttrace+int64(debug.schedtrace)*1000000 \u0026lt;= now { lasttrace = now schedtrace(debug.scheddetail \u0026gt; 0) } unlock(\u0026amp;sched.sysmonlock) } } ","permalink":"https://heliu.site/posts/golang/goroutine/sysmon/","summary":"Golang sysmonç›‘æ§çº¿ç¨‹ä»‹ç»ã€‚","title":"sysmon ç›‘æ§çº¿ç¨‹"},{"content":"å”¤é†’å·¥ä½œçº¿ç¨‹ å»å°è¯•å”¤é†’å·¥ä½œçº¿ç¨‹æ¡ä»¶ï¼šatomic.Load(\u0026amp;sched.npidle) != 0 \u0026amp;\u0026amp; atomic.Load(\u0026amp;sched.nmspinning) == 0ã€‚ atomic.Load(\u0026amp;sched.npidle) != 0ï¼šæœ‰ç©ºé—²çš„Pã€‚ atomic.Load(\u0026amp;sched.nmspinning) == 0ï¼šæ²¡æœ‰å·¥ä½œçº¿ç¨‹æ­£åœ¨å°è¯•ä»å…¶ä»–å·¥ä½œçº¿ç¨‹çš„æœ¬åœ°é˜Ÿåˆ—å·å–goroutineã€‚(å°±æ˜¯æ²¡æœ‰spinningè‡ªæ—‹çš„goroutineæ—¶) å”¤é†’ç©ºé—²çš„På’ŒMç”±wakep()å‡½æ•°å®Œæˆã€‚ wakep() å°è¯•æ·»åŠ ä¸€ä¸ªPæ¥æ‰§è¡ŒGã€‚å½“Gæ˜¯å¯è¿è¡Œæ—¶è°ƒç”¨(newproc, ready)ã€‚ wakep()å‡½æ•°è¢«è°ƒç”¨çš„åœ°æ–¹ï¼šã€åˆ›å»ºgæ—¶å€™ï¼Œåœ¨newproc()å‡½æ•°ä¸­ï¼Œå°±æ˜¯goå…³é”®å­—ã€‘ï¼Œã€gæ”¾å›Pçš„æ—¶å€™ï¼Œåœ¨ready()å‡½æ•°ä¸­ã€‘ã€‚ newproc()å‡½æ•°ä¸­ï¼Œä¹Ÿå°±æ˜¯goå…³é”®å­—æ—¶ï¼Œruntime.mainå·²å¯åŠ¨æ—¶ã€‚ï¼ˆè¿™ç§æƒ…å†µå‘ç”Ÿåœ¨goå…³é”®å­—æ—¶ï¼‰ ready()å‡½æ•°ä¸­ï¼Œè¯¥å‡½æ•°é€šè¿‡æŠŠéœ€è¦å”¤é†’çš„goroutineæ”¾å…¥è¿è¡Œé˜Ÿåˆ—æ¥å”¤é†’å®ƒã€‚ï¼ˆè¿™ç§æƒ…å†µåœ¨gè¢«æŒ‚åœ¨äº†å…¶ä»–åœ°æ–¹æ—¶éœ€è¦æ¢å¤åˆ°Pä¸­æ—¶ï¼‰ ä¹Ÿå°±æ˜¯åªè¦gè¢«æ”¾å…¥æœ¬åœ°é˜Ÿåˆ—ä¸­ï¼Œå‡†å¤‡è¿è¡Œæ—¶éƒ½éœ€è¦è°ƒç”¨wakep()å‡½æ•°å°è¯•åˆ©ç”¨ç©ºé—²çš„Må’ŒPæ¥è¿è¡Œå®ƒã€‚ æ–‡ä»¶ä½ç½®ï¼šgo1.19.3/src/runtime/proc.goã€‚ 2420 2421 2422 2423 2424 2425 2426 2427 2428 2429 2430 2431 2432 2433 2434 2435 2436 2437 2438 2439 2440 2441 2442 2443 2444 2445 2446 2447 // Tries to add one more P to execute G\u0026#39;s. // Called when a G is made runnable (newproc, ready). func wakep() { // æ²¡æœ‰ç©ºé—²çš„Pï¼Œç›´æ¥è¿”å›ã€‚å½“å‰æ‰€æœ‰çš„Péƒ½åœ¨å·¥ä½œã€‚å› ä¸ºPçš„æ•°é‡æ˜¯å›ºå®šçš„ã€‚ if atomic.Load(\u0026amp;sched.npidle) == 0 { return } // be conservative about spinning threads // // å¯¹è‡ªæ—‹çš„çº¿ç¨‹æŒä¿å®ˆæ€åº¦ï¼š // 1. sched.nmspinning != 0ï¼šæœ‰å…¶ä»–çº¿ç¨‹æ­£åœ¨è‡ªæ—‹ï¼ˆå°±æ˜¯åœ¨å…¶ä»–çº¿ç¨‹ä¸­å»å·å–gï¼‰ // 2. !atomic.Cas(\u0026amp;sched.nmspinning, 0, 1)ï¼šé€šè¿‡casæ“ä½œå†æ¬¡ç¡®è®¤æ˜¯å¦æœ‰å…¶ä»–å·¥ä½œçº¿ç¨‹å¤„äºspinningçŠ¶æ€ // ä»è¿›å…¥wakep()åˆ¤æ–­åˆ°çœŸæ­£å¯åŠ¨å·¥ä½œçº¿ç¨‹ä¹‹å‰çš„è¿™ä¸€æ®µæ—¶é—´ä¹‹å†…ï¼Œå¦‚æœå·²ç»æœ‰å·¥ä½œçº¿ç¨‹è¿›å…¥äº†spinningçŠ¶æ€è€Œåœ¨å››å¤„å¯»æ‰¾éœ€è¦è¿è¡Œçš„goroutine // è¿™æ ·çš„è¯æˆ‘ä»¬å°±æ²¡æœ‰å¿…è¦å†å¯åŠ¨ä¸€ä¸ªå¤šä½™çš„å·¥ä½œçº¿ç¨‹å‡ºæ¥äº† // å¦‚æœcasæ“ä½œæˆåŠŸï¼Œåˆ™ç»§ç»­è°ƒç”¨startmåˆ›å»ºä¸€ä¸ªæ–°çš„æˆ–å”¤é†’ä¸€ä¸ªå¤„äºç¡çœ çŠ¶æ€çš„å·¥ä½œçº¿ç¨‹å‡ºæ¥å·¥ä½œ // // 1. atomic.Load(\u0026amp;sched.nmspinning) != 0 æˆç«‹ï¼šæœ‰å…¶ä»–å·¥ä½œçº¿ç¨‹æ­£åœ¨è‡ªæ—‹ï¼Œç›´æ¥returné€€å‡º // 2. atomic.Load(\u0026amp;sched.nmspinning) == 0 æˆç«‹ï¼šå½“å‰æ²¡æœ‰å¿™ç¢Œçš„å·¥ä½œçº¿ç¨‹ // atomic.Cas(\u0026amp;sched.nmspinning, 0, 1) == trueï¼šå½“å‰æ²¡æœ‰å¿™ç¢Œçš„å·¥ä½œçº¿ç¨‹ï¼Œå½“å‰å¯ä»¥åˆ›å»ºå·¥ä½œçº¿ç¨‹ï¼Œå¹¶æ ‡è®°sched.nmspinning=1é˜»æ­¢åæ¥è€… // atomic.Cas(\u0026amp;sched.nmspinning, 0, 1) == falseï¼šå½“å‰æœ‰å…¶ä»–å¿™ç¢Œçš„å·¥ä½œçº¿ç¨‹ï¼Œç›´æ¥returné€€å‡º if atomic.Load(\u0026amp;sched.nmspinning) != 0 || !atomic.Cas(\u0026amp;sched.nmspinning, 0, 1) { return } // ç¨‹åºæ‰§è¡Œåˆ°è¿™é‡Œè¯´æ˜ï¼šsched.nmspinningä¸€å®šè¢«æ ‡è®°ä¸º1äº†ã€‚ startm(nil, true) } startm() è°ƒåº¦ä¸€äº›Mæ¥è¿è¡Œp(å¦‚æœéœ€è¦ï¼Œåˆ›å»ºä¸€ä¸ªM)ã€‚ å¦‚æœp==nilï¼Œå°è¯•å¾—åˆ°ä¸€ä¸ªç©ºé—²çš„pï¼Œå¦‚æœæ²¡æœ‰ç©ºé—²çš„pä»€ä¹ˆéƒ½ä¸åšã€‚ å¯ä»¥ä½¿ç”¨m.p==nilè¿è¡Œï¼Œå› æ­¤ä¸å…è®¸å†™å…¥éšœç¢ã€‚ å¦‚æœè®¾ç½®äº†spinningï¼Œåˆ™è°ƒç”¨è€…å¢åŠ äº†nmspinningï¼Œè€Œstartmå°†å‡å°‘nmspinningæˆ–åœ¨æ–°å¯åŠ¨çš„Mä¸­è®¾ç½®m.spinningã€‚ ä¼ é€’nilçš„Pçš„è°ƒç”¨æ–¹å¿…é¡»ä»ä¸å¯æŠ¢å çš„ä¸Šä¸‹æ–‡ä¸­è°ƒç”¨ã€‚è§ä¸‹é¢å¯¹acquiremã€‚ å¿…é¡»æ²¡æœ‰å†™éšœç¢ï¼Œå› ä¸ºè¿™ä¸ªå¯èƒ½æ²¡æœ‰Pã€‚ go:nowritebarrierrecï¼šä¸å…è®¸ç¼–è¯‘å™¨æ’å…¥å†™å±éšœç›¸å…³ä»£ç ã€‚ åœ¨æŠ¢å ç³»ç»Ÿè°ƒç”¨çš„Pçš„æ—¶å€™è¯¥å‡½æ•°ä¼šè¢«è°ƒç”¨ï¼Œå¹¶ä¼ å…¥ç©ºé—²çš„På’Œfalseå‚æ•°ã€‚ å‚æ•°ï¼š _p_ *pï¼šnilè¡¨ç¤ºæ²¡æœ‰æŒ‡å®šPï¼Œå¦åˆ™æŒ‡å®šPã€‚ spinning boolï¼štrue.sched.nmspinningçš„å€¼åœ¨å‰é¢è¢«åŠ ä¸€äº†ã€‚false.æ²¡æœ‰åŠ ä¸€ã€‚ æ–‡ä»¶ä½ç½®ï¼šgo1.19.3/src/runtime/proc.goã€‚ 2257 2258 2259 2260 2261 2262 2263 2264 2265 2266 2267 2268 2269 2270 2271 2272 2273 2274 2275 2276 2277 2278 2279 2280 2281 2282 2283 2284 2285 2286 2287 2288 2289 2290 2291 2292 2293 2294 2295 2296 2297 2298 2299 2300 2301 2302 2303 2304 2305 2306 2307 2308 2309 2310 2311 2312 2313 2314 2315 2316 2317 2318 2319 2320 2321 2322 2323 2324 2325 2326 2327 2328 2329 2330 2331 2332 2333 2334 2335 2336 2337 2338 2339 2340 2341 2342 2343 2344 2345 2346 2347 2348 2349 2350 2351 2352 2353 2354 2355 2356 2357 2358 2359 2360 2361 2362 2363 2364 2365 2366 2367 2368 2369 2370 2371 2372 2373 2374 2375 2376 2377 2378 2379 2380 // Schedules some M to run the p (creates an M if necessary). // If p==nil, tries to get an idle P, if no idle P\u0026#39;s does nothing. // May run with m.p==nil, so write barriers are not allowed. // If spinning is set, the caller has incremented nmspinning and startm will // either decrement nmspinning or set m.spinning in the newly started M. // // Callers passing a non-nil P must call from a non-preemptible context. See // comment on acquirem below. // // Must not have write barriers because this may be called without a P. // //go:nowritebarrierrec func startm(_p_ *p, spinning bool) { // Disable preemption. // // Every owned P must have an owner that will eventually stop it in the // event of a GC stop request. startm takes transient ownership of a P // (either from argument or pidleget below) and transfers ownership to // a started M, which will be responsible for performing the stop. // // Preemption must be disabled during this transient ownership, // otherwise the P this is running on may enter GC stop while still // holding the transient P, leaving that P in limbo and deadlocking the // STW. // // Callers passing a non-nil P must already be in non-preemptible // context, otherwise such preemption could occur on function entry to // startm. Callers passing a nil P may be preemptible, so we must // disable preemption before acquiring a P from pidleget below. mp := acquirem() // ç¦æ­¢å½“å‰Mè¢«æŠ¢å  lock(\u0026amp;sched.lock) // é”ä½å…¨å±€sched // æœ‰ç©ºé—²çš„pæ‰ä¼šå»å”¤é†’çº¿ç¨‹ if _p_ == nil { // å¦‚æœæ²¡æœ‰æŒ‡å®šPï¼Œåˆ™éœ€è¦ä»Pçš„ç©ºé—²åˆ—è¡¨ä¸­è·å–ä¸€ä¸ªP _p_ = pidleget(0) // ä»Pçš„ç©ºé—²é˜Ÿåˆ—ä¸­è·å–ç©ºé—²çš„P // æ²¡æœ‰ç©ºé—²çš„Pï¼Œæ„å‘³ç€æ‰€æœ‰çš„Péƒ½å¾ˆå¿™ä¸éœ€è¦å”¤é†’ if _p_ == nil {\tunlock(\u0026amp;sched.lock) // ä¹‹å‰çš„CasæŠŠnmspinningåŠ ä¸€ï¼Œè¿™é‡Œéœ€è¦å‡å›æ¥ if spinning {\t// The caller incremented nmspinning, but there are no idle Ps, // so it\u0026#39;s okay to just undo the increment and give up. // // æ­£å¸¸é€»è¾‘è¿™é‡Œä¸åº”è¯¥å‡æˆè´Ÿæ•°ï¼Œå¦åˆ™æ˜¯ç³»ç»Ÿé€»è¾‘å­˜åœ¨é”™è¯¯ if int32(atomic.Xadd(\u0026amp;sched.nmspinning, -1)) \u0026lt; 0 { throw(\u0026#34;startm: negative nmspinning\u0026#34;) } } // ä¸acquiremå‡½æ•°å‘¼åº”ï¼Œå¹¶æ£€æŸ¥æ˜¯å¦æœ‰æŠ¢å è¯·æ±‚å‘ç”Ÿ releasem(mp)\treturn // æ²¡æœ‰ç©ºé—²çš„Pç›´æ¥è¿”å› } } // å°è¯•ä»mç©ºé—²é˜Ÿåˆ—ä¸­è·å–æ­£å¤„äºç¡çœ ä¹‹ä¸­çš„å·¥ä½œçº¿ç¨‹ // æ‰€æœ‰å¤„äºç¡çœ çŠ¶æ€çš„méƒ½åœ¨æ­¤é˜Ÿåˆ—ä¸­ nmp := mget() // æ²¡æœ‰å¤„äºç¡çœ çŠ¶æ€çš„å·¥ä½œçº¿ç¨‹ï¼Œè¿™ç§æƒ…å†µéœ€è¦å»åˆ›å»ºçº¿ç¨‹ if nmp == nil {\t// No M is available, we must drop sched.lock and call newm. // However, we already own a P to assign to the M. // // Once sched.lock is released, another G (e.g., in a syscall), // could find no idle P while checkdead finds a runnable G but // no running M\u0026#39;s because this new M hasn\u0026#39;t started yet, thus // throwing in an apparent deadlock. // // Avoid this situation by pre-allocating the ID for the new M, // thus marking it as \u0026#39;running\u0026#39; before we drop sched.lock. This // new M will eventually run the scheduler to execute any // queued G\u0026#39;s. // // è¿™é‡Œæ˜¯ä¸ºéœ€è¦æ–°åˆ›å»ºçš„å·¥ä½œçº¿ç¨‹å‡†å¤‡å·¥ä½œ id := mReserveID() // ç»™éœ€è¦åˆ›å»ºçš„å·¥ä½œçº¿ç¨‹åˆ†é…ID unlock(\u0026amp;sched.lock) // åˆå§‹åŒ–fnå‡½æ•°ï¼Œè¯¥å‡½æ•°åœ¨å·¥ä½œçº¿ç¨‹åˆšå¯åŠ¨æ—¶ä¼šè¢«è°ƒç”¨ var fn func() // nil if spinning { // å¦‚æœéœ€è¦æ ‡è®°å½“å‰å·¥ä½œçº¿ç¨‹æ˜¯è‡ªæ—‹çŠ¶æ€ // The caller incremented nmspinning, so set m.spinning in the new M. // // mspinningå‡½æ•°å°±ä¸€è¡Œä»£ç  \u0026#39;getg().m.spinning = true\u0026#39; æ ‡è®°å½“å‰å·¥ä½œçº¿ç¨‹æ˜¯è‡ªæ—‹çŠ¶æ€ // å› ä¸ºå…¨å±€çš„sched.nmspinningå·²ç»åŠ ä¸€äº†ï¼Œå› æ­¤éœ€è¦æ ‡è®°mçš„spinning fn = mspinning\t} newm(fn, _p_, id) // åˆ›å»ºæ–°çš„å·¥ä½œçº¿ç¨‹ // Ownership transfer of _p_ committed by start in newm. // Preemption is now safe. releasem(mp) return } // åˆ°è¿™é‡Œè¯´æ˜æœ‰æ­£åœ¨å¤„äºç¡çœ çš„å·¥ä½œçº¿ç¨‹ unlock(\u0026amp;sched.lock) // ä»ç©ºé—²çš„çº¿ç¨‹é˜Ÿåˆ—ä¸­æ‹¿å‡ºæ¥çš„ spinning æ ‡å¿—ä½å­˜åœ¨ï¼Œè¯´æ˜sleepæ—¶æœ‰é—®é¢˜ if nmp.spinning { // ç³»ç»Ÿé€»è¾‘å­˜åœ¨é—®é¢˜ throw(\u0026#34;startm: m is spinning\u0026#34;) } // å·¥ä½œçº¿ç¨‹è¿˜ä¸å…¶ä»–Pæœ‰å…³ï¼Œè¯´æ˜æœ‰é—®é¢˜ if nmp.nextp != 0 { // ç³»ç»Ÿé€»è¾‘å­˜åœ¨é—®é¢˜ throw(\u0026#34;startm: m has p\u0026#34;) } // ç©ºé—²çš„Pä¸­ä¸åº”è¯¥å­˜åœ¨gï¼Œç³»ç»Ÿé€»è¾‘å­˜åœ¨é—®é¢˜ if spinning \u0026amp;\u0026amp; !runqempty(_p_) {\tthrow(\u0026#34;startm: p has runnable gs\u0026#34;) } // The caller incremented nmspinning, so set m.spinning in the new M. // // è°ƒç”¨è€…å¢åŠ nmspinningï¼Œå› æ­¤å°†m.spinningè®¾ç½®ä¸ºæ–°çš„Mã€‚å› æ­¤å½“å‰è¿™ä¸ªMå°±æ˜¯è¿™ä¸ªè‡ªæ—‹çš„M nmp.spinning = spinning // æ ‡è®°å½“å‰éœ€è¦å”¤é†’çš„å·¥ä½œçº¿ç¨‹ è‡ªæ—‹çš„çŠ¶æ€ // å½“å‰Mçš„Pæš‚æ—¶æ”¾åœ¨nextpä¸Š // è¿™é‡Œä¹Ÿå°±æ˜¯ä¸ºä»€ä¹ˆæ–°åˆ›å»ºçš„å·¥ä½œçº¿ç¨‹ç›´æ¥åœ¨nextpå»å–Pï¼ŒåŸå› åœ¨è¿™é‡Œå…³è”çš„ // å› ä¸º_p_åªåœ¨è¿™é‡Œå­˜åœ¨ï¼Œå› æ­¤ä¸ä¼šå­˜åœ¨å…¶ä»–å·¥ä½œçº¿ç¨‹ä½¿ç”¨è¯¥Pã€‚ nmp.nextp.set(_p_)\t// å”¤é†’å·¥ä½œçº¿ç¨‹ï¼Œå·¥ä½œçº¿ç¨‹ç¡çœ åœ¨ nmp.park ä¸Šé¢ notewakeup(\u0026amp;nmp.park)\t// Ownership transfer of _p_ committed by wakeup. Preemption is now // safe. // // å”¤é†’æäº¤çš„_p_çš„æ‰€æœ‰æƒè½¬ç§»ã€‚ æŠ¢å ç°åœ¨æ˜¯å®‰å…¨çš„ // ä¸acquiremå‡½æ•°å‘¼åº”ï¼Œå¹¶æ£€æŸ¥æ˜¯å¦æœ‰æŠ¢å è¯·æ±‚å‘ç”Ÿ releasem(mp) } acquirem() måŠ é”ç¦æ­¢æŠ¢å å½“å‰mã€‚ æ–‡ä»¶ä½ç½®ï¼šgo1.19.3/src/runtime/runtime1.goã€‚ 473 474 475 476 477 478 //go:nosplit func acquirem() *m { _g_ := getg() _g_.m.locks++ return _g_.m } releasem() æ–‡ä»¶ä½ç½®ï¼šgo1.19.3/src/runtime/runtime1.goã€‚ 482 483 484 485 486 487 488 489 490 func releasem(mp *m) { _g_ := getg() mp.locks-- // å½“å‰Mæ²¡æœ‰é”ï¼Œå¹¶ä¸”Géœ€è¦è¢«æŠ¢å  if mp.locks == 0 \u0026amp;\u0026amp; _g_.preempt { // restore the preemption request in case we\u0026#39;ve cleared it in newstack _g_.stackguard0 = stackPreempt // è®¾ç½®æŠ¢å æ ‡å¿— } } pidleget() ä»sched.pidleä¸­å°è¯•è·å–ä¸€ä¸ªç©ºé—²çš„Pã€‚ å‚æ•°now int64ï¼š0åˆ™å–å½“å‰æ—¶é—´ç‚¹ã€‚ è¿”å›å€¼ï¼š *pï¼šè¿”å›ä¸€ä¸ªç©ºé—²çš„Pï¼Œå¦åˆ™ä¸ºnilæ²¡æœ‰ç©ºé—²çš„Pã€‚ int64ï¼šä¼ å…¥nowçš„æ—¶é—´å€¼ï¼Œ0åˆ™æ˜¯å½“å‰æ—¶é—´å€¼ã€‚ æ–‡ä»¶ä½ç½®ï¼šgo1.19.3/src/runtime/proc.goã€‚ 5727 5728 5729 5730 5731 5732 5733 5734 5735 5736 5737 5738 5739 5740 5741 5742 5743 5744 5745 5746 5747 5748 5749 5750 5751 5752 5753 5754 5755 5756 // pidleget tries to get a p from the _Pidle list, acquiring ownership. // // sched.lock must be held. // // May run during STW, so write barriers are not allowed. // //go:nowritebarrierrec func pidleget(now int64) (*p, int64) { // sched.lock å¿…é¡»è¢«æŒæœ‰ assertLockHeld(\u0026amp;sched.lock) // ä»sched.pidleä¸Šè·å–ç©ºé—²çš„P _p_ := sched.pidle.ptr() if _p_ != nil { // Timer may get added at any time now. if now == 0 { now = nanotime() } // è®¾ç½®timerpMaskå’ŒidlepMask timerpMask.set(_p_.id) idlepMask.clear(_p_.id) // ä»å…¨å±€ç©ºé—²çš„Pä¸­ç§»é™¤_p_ sched.pidle = _p_.link // å…¨å±€çš„ç©ºé—²Pçš„æ¬¡æ•°å‡ä¸€ atomic.Xadd(\u0026amp;sched.npidle, -1) // limiterEventè·Ÿè¸ªGC CPUé™åˆ¶å™¨çš„äº‹ä»¶ã€‚ _p_.limiterEvent.stop(limiterEventIdle, now) } return _p_, now } mget() å°è¯•ä»sched.midleè·å–ä¸€ä¸ªç©ºé—²çš„å·¥ä½œçº¿ç¨‹mï¼Œèµ·æ¥ç»‘å®šPè¿è¡Œã€‚ æ–‡ä»¶ä½ç½®ï¼šgo1.19.3/src/runtime/proc.goã€‚ 5547 5548 5549 5550 5551 5552 5553 5554 5555 5556 5557 5558 5559 5560 5561 5562 5563 5564 // Try to get an m from midle list. // sched.lock must be held. // May run during STW, so write barriers are not allowed. // //go:nowritebarrierrec func mget() *m { assertLockHeld(\u0026amp;sched.lock) // ç©ºé—²çš„måœ¨sched.midleä¸Š mp := sched.midle.ptr() if mp != nil { // ä»sched.midleä¸Šç§»é™¤mp sched.midle = mp.schedlink // ç©ºé—²çš„mæ•°é‡å‡ä¸€ sched.nmidle-- } return mp } mReserveID() ç»™æ–°åˆ›å»ºçš„å·¥ä½œçº¿ç¨‹åˆ†é…å”¯ä¸€çš„IDã€‚ æ–‡ä»¶ä½ç½®ï¼šgo1.19.3/src/runtime/proc.goã€‚ 769 770 771 772 773 774 775 776 777 778 779 780 781 782 783 784 785 786 787 788 789 790 // mReserveID returns the next ID to use for a new m. This new m is immediately // considered \u0026#39;running\u0026#39; by checkdead. // // sched.lock must be held. func mReserveID() int64 { // sched.locké”å¿…é¡»è¢«æŒæœ‰ assertLockHeld(\u0026amp;sched.lock) // åˆ†é…çš„IDæº¢å‡ºäº† if sched.mnext+1 \u0026lt; sched.mnext { throw(\u0026#34;runtime: thread ID overflow\u0026#34;) } id := sched.mnext // åˆ†é…çš„ID sched.mnext++ // ä¸‹ä¸€ä¸ªID // æ£€æŸ¥sched.mnext - sched.nmfreed \u0026gt; sched.maxmcount // sched.maxmcount åœ¨ runtime.main ä¸­è¢«è®¾ç½®ä¸º 10000 // sched.mnext ä¸‹ä¸€ä¸ªåˆ†é…çš„IDï¼Œè¯¥å€¼æ˜¯ç´¯åŠ çš„ // sched.nmfreed å·²ç»é‡Šæ”¾çš„å·¥ä½œçº¿ç¨‹æ•°é‡ // å› æ­¤è¿™é‡Œæ˜¯æ£€æŸ¥å½“å‰å·²ç»åˆ›å»ºçš„å·¥ä½œçº¿ç¨‹æ•°é‡ä¸èƒ½å¤§äºæœ€å¤§å€¼ checkmcount() return id } notewakeup() é¦–å…ˆä½¿ç”¨atomic.Xchgè®¾ç½®note.keyå€¼ä¸º1ã€‚ è¿™æ˜¯ä¸ºäº†ä½¿è¢«å”¤é†’çš„çº¿ç¨‹å¯ä»¥é€šè¿‡æŸ¥çœ‹è¯¥å€¼æ˜¯å¦ç­‰äº1æ¥ç¡®å®šæ˜¯è¢«å…¶å®ƒçº¿ç¨‹å”¤é†’è¿˜æ˜¯æ„å¤–ä»ç¡çœ ä¸­è‹é†’äº†è¿‡æ¥ï¼Œ å¦‚æœè¯¥å€¼ä¸º1åˆ™è¡¨ç¤ºæ˜¯è¢«å”¤é†’çš„ï¼Œå¯ä»¥ç»§ç»­å·¥ä½œäº†ã€‚ ä½†å¦‚æœè¯¥å€¼ä¸º0åˆ™è¡¨ç¤ºæ˜¯æ„å¤–è‹é†’ï¼Œéœ€è¦å†æ¬¡è¿›å…¥ç¡çœ ï¼Œ å·¥ä½œçº¿ç¨‹è‹é†’ä¹‹åçš„å¤„ç†é€»è¾‘æˆ‘ä»¬å·²ç»åœ¨notesleep()å‡½æ•°ä¸­è§è¿‡ï¼Œæ‰€ä»¥è¿™é‡Œç•¥è¿‡ã€‚ æ–‡ä»¶ä½ç½®ï¼šgo1.19.3/src/runtime/lock_futex.goã€‚ 139 140 141 142 143 144 145 146 147 func notewakeup(n *note) { // è®¾ç½®n.key = 1, è¢«å”¤é†’çš„çº¿ç¨‹é€šè¿‡æŸ¥çœ‹è¯¥å€¼æ˜¯å¦ç­‰äº1æ¥ç¡®å®šæ˜¯è¢«å…¶å®ƒçº¿ç¨‹å”¤é†’è¿˜æ˜¯æ„å¤–ä»ç¡çœ ä¸­è‹é†’ old := atomic.Xchg(key32(\u0026amp;n.key), 1) if old != 0 { // å¦‚æœæ—§å€¼ä¸æ˜¯0è¯´æ˜ç³»ç»Ÿé€»è¾‘æœ‰é—®é¢˜ print(\u0026#34;notewakeup - double wakeup (\u0026#34;, old, \u0026#34;)\\n\u0026#34;) throw(\u0026#34;notewakeup - double wakeup\u0026#34;) } futexwakeup(key32(\u0026amp;n.key), 1) // è°ƒç”¨futexwakeupå”¤é†’ } futexwakeup() å¯¹äºLinuxå¹³å°æ¥è¯´ï¼Œå·¥ä½œçº¿ç¨‹é€šè¿‡noteç¡çœ å…¶å®æ˜¯é€šè¿‡futexç³»ç»Ÿè°ƒç”¨ç¡çœ åœ¨å†…æ ¸ä¹‹ä¸­ï¼Œ æ‰€ä»¥å”¤é†’å¤„äºç¡çœ çŠ¶æ€çš„çº¿ç¨‹ä¹Ÿéœ€è¦é€šè¿‡futexç³»ç»Ÿè°ƒç”¨è¿›å…¥å†…æ ¸æ¥å”¤é†’ã€‚ æ‰€ä»¥è¿™é‡Œçš„futexwakeup()åˆç»§ç»­è°ƒç”¨åŒ…è£…äº†futexç³»ç»Ÿè°ƒç”¨çš„futex()å‡½æ•°æ¥å®ç°å”¤é†’ç¡çœ åœ¨å†…æ ¸ä¸­çš„å·¥ä½œçº¿ç¨‹ã€‚ æ–‡ä»¶ä½ç½®ï¼šgo1.19.3/src/runtime/os_linux.goã€‚ 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 // If any procs are sleeping on addr, wake up at most cnt. //go:nosplit func futexwakeup(addr *uint32, cnt uint32) { // è°ƒç”¨futexå‡½æ•°å”¤é†’å·¥ä½œçº¿ç¨‹ ret := futex(unsafe.Pointer(addr), _FUTEX_WAKE_PRIVATE, cnt, nil, nil, 0) if ret \u0026gt;= 0 {\t// è°ƒç”¨æˆåŠŸæ˜¯è¿™é‡Œç›´æ¥è¿”å› return } // I don\u0026#39;t know that futex wakeup can return // EAGAIN or EINTR, but if it does, it would be // safe to loop and call futex again. systemstack(func() { print(\u0026#34;futexwakeup addr=\u0026#34;, addr, \u0026#34; returned \u0026#34;, ret, \u0026#34;\\n\u0026#34;) }) // ç¨‹åºä¸ä¼šåˆ°è¿™é‡Œæ¥ï¼Œå³ä½¿åˆ°è¿™é‡Œæ¥äº†ï¼Œå‘ä¸€ä¸ªæœªçŸ¥åœ°å€å†™å…¥æ•°æ®ç›´æ¥å®•æœº *(*int32)(unsafe.Pointer(uintptr(0x1006))) = 0x1006 } futex() futex()å‡½æ•°ç”±æ±‡ç¼–ä»£ç å†™æˆï¼Œå‰é¢çš„å‡ æ¡æŒ‡ä»¤éƒ½åœ¨ä¸ºfutexç³»ç»Ÿè°ƒç”¨å‡†å¤‡å‚æ•°ï¼Œ å‚æ•°å‡†å¤‡å®Œæˆä¹‹ååˆ™é€šè¿‡SYSCALLæŒ‡ä»¤è¿›å…¥æ“ä½œç³»ç»Ÿå†…æ ¸å®Œæˆçº¿ç¨‹çš„å”¤é†’åŠŸèƒ½ã€‚ å†…æ ¸åœ¨å®Œæˆå”¤é†’å·¥ä½œä¹‹åå½“å‰å·¥ä½œçº¿ç¨‹åˆ™ä»å†…æ ¸è¿”å›åˆ°futex()å‡½æ•°ç»§ç»­æ‰§è¡ŒSYSCALLæŒ‡ä»¤ä¹‹åçš„ä»£ç å¹¶æŒ‰å‡½æ•°è°ƒç”¨é“¾åŸè·¯è¿”å›ã€‚ ç»§ç»­æ‰§è¡Œå…¶å®ƒä»£ç ï¼Œè€Œè¢«å”¤é†’çš„å·¥ä½œçº¿ç¨‹åˆ™ç”±å†…æ ¸è´Ÿè´£åœ¨é€‚å½“çš„æ—¶å€™è°ƒåº¦åˆ°CPUä¸Šè¿è¡Œã€‚ é™·å…¥ç³»ç»Ÿè°ƒç”¨å¤ªé•¿æ—¶é—´çš„å·¥ä½œçº¿ç¨‹ä¼šåœ¨ç›‘æ§çº¿ç¨‹ä¸­å‰¥ç¦»På’ŒGï¼Œå…·ä½“çš„å‚çœ‹ç›‘æ§çº¿ç¨‹ç›¸å…³ä»£ç ã€‚è¿™é‡Œæ²¡æœ‰æ ‡è®°å·¥ä½œçº¿ç¨‹é™·å…¥ç³»ç»Ÿè°ƒç”¨çš„æ ‡å¿—ã€‚ åº”è¯¥æ˜¯å½“å‰å‡½æ•°è°ƒç”¨ä¸ä¼šå½¢æˆé˜»å¡ã€‚ æ–‡ä»¶ä½ç½®ï¼šgo1.19.3/src/runtime/sys_linux_amd64.sã€‚ 549 550 551 552 553 554 555 556 557 558 559 560 561 562 # int64 futex(int32 *uaddr, int32 op, int32 val, # struct timespec *timeout, int32 *uaddr2, int32 val2); TEXT runtimeÂ·futex(SB),NOSPLIT,$0 #è¿™6æ¡æŒ‡ä»¤åœ¨ä¸ºfutexç³»ç»Ÿè°ƒç”¨å‡†å¤‡å‚æ•° MOVQ addr+0(FP), DI MOVL op+8(FP), SI MOVL val+12(FP), DX MOVQ ts+16(FP), R10 MOVQ addr2+24(FP), R8 MOVL val3+32(FP), R9 MOVL $SYS_futex, AX # futexç³»ç»Ÿè°ƒç”¨ç¼–å·æ”¾å…¥AXå¯„å­˜å™¨ SYSCALL # ç³»ç»Ÿè°ƒç”¨ï¼Œè¿›å…¥å†…æ ¸ MOVL AX, ret+40(FP) # ç³»ç»Ÿè°ƒç”¨é€šè¿‡AXå¯„å­˜å™¨è¿”å›è¿”å›å€¼ï¼Œè¿™é‡ŒæŠŠè¿”å›å€¼ä¿å­˜åˆ°å†…å­˜ä¹‹ä¸­ RET åˆ›å»ºå·¥ä½œçº¿ç¨‹ å¦‚æœæ²¡æœ‰æ­£å¤„äºä¼‘çœ çŠ¶æ€çš„å·¥ä½œçº¿ç¨‹ï¼Œåˆ™éœ€è¦è°ƒç”¨newm()å‡½æ•°æ–°å»ºä¸€ä¸ªå·¥ä½œçº¿ç¨‹ã€‚ newm() åˆ›å»ºè°ƒåº¦çº¿ç¨‹å’Œç›‘æ§çº¿ç¨‹éƒ½æ˜¯é€šè¿‡è¯¥å‡½æ•°ï¼Œæ‰§è¡Œè¯¥å‡½æ•°æ—¶éƒ½ä¼šæŠŠæ ˆåˆ‡æ¢åˆ°g0æ ˆï¼Œå› ä¸ºg0æ ˆæ¯”è¾ƒå¤§ã€‚ è¯¥å‡½æ•°åœ¨ä»¥ä¸‹ä¸¤ç§æƒ…å†µä¸‹ä½¿ç”¨ï¼š newm(sysmon, nil, -1)ï¼šåˆ›å»ºã€ç›‘æ§çº¿ç¨‹ã€‘ã€‚ sysmonå·¥ä½œçº¿ç¨‹å¼€å§‹æ‰§è¡Œæ—¶é¦–å…ˆè°ƒç”¨çš„å‡½æ•°ã€‚ï¼ˆä¸æ˜¯å…¥å£å‡½æ•°ï¼Œnewm()åˆ›å»ºçš„å…¥å£å‡½æ•°éƒ½æ˜¯å›ºå®šçš„mstart()å‡½æ•°ï¼‰ nilè¡¨ç¤ºä¸éœ€è¦ç»‘å®šPã€‚ -1ç³»ç»Ÿä¼šè‡ªåŠ¨åˆ†é…ä¸€ä¸ªé€’å¢çš„æ•°å­—ã€‚ï¼ˆå…¨å±€å”¯ä¸€çš„IDï¼‰ newm(fn, _p_, id)ï¼šåˆ›å»ºã€è°ƒåº¦çº¿ç¨‹ã€‘ã€‚ fnå·¥ä½œçº¿ç¨‹å¼€å§‹æ‰§è¡Œæ—¶é¦–å…ˆè°ƒç”¨çš„å‡½æ•°ã€‚ï¼ˆä¸æ˜¯å…¥å£å‡½æ•°ï¼Œnewm()åˆ›å»ºçš„å…¥å£å‡½æ•°éƒ½æ˜¯å›ºå®šçš„mstart()å‡½æ•°ï¼‰ _p_çº¿ç¨‹å¯åŠ¨æ—¶éœ€è¦ç»‘å®šçš„Pã€‚ åˆ›å»ºå·¥ä½œçº¿ç¨‹çš„å”¯ä¸€IDã€‚ åˆ›å»ºä¸€ä¸ªæ–°çš„mã€‚å®ƒå°†ä»å¯¹fnæˆ–è°ƒåº¦å™¨çš„è°ƒç”¨å¼€å§‹ã€‚fnéœ€è¦æ˜¯é™æ€çš„ï¼Œè€Œä¸æ˜¯ä¸€ä¸ªå †åˆ†é…é—­åŒ…ã€‚å¯ä»¥ä½¿ç”¨ m.p==nilè¿è¡Œï¼Œå› æ­¤ä¸å…è®¸å†™å…¥éšœç¢ã€‚ idæ˜¯å¯é€‰çš„ï¼Œé¢„åˆ†é…çš„Mçš„idã€‚é€šè¿‡ä¼ é€’-1æ¥çœç•¥ã€‚ go:nowritebarrierrecï¼šå‘Šè¯‰ç¼–è¯‘å™¨è¯¥å‡½æ•°åŠé‡Œé¢æ‰€è°ƒç”¨çš„å‡½æ•°éƒ½ä¸æ’å…¥å†™å±éšœä»£ç ã€‚ å‚æ•°ï¼š fn func()ï¼šæ–°åˆ›å»ºçš„å·¥ä½œçº¿ç¨‹å¯åŠ¨åéœ€è¦æ‰§è¡Œçš„å‡½æ•°ï¼Œä¸èƒ½æ˜¯ä¸€ä¸ªå †åˆ†é…çš„é—­åŒ…ï¼Œå¿…é¡»æ˜¯ä¸€ä¸ªé™æ€çš„å‡½æ•°ã€‚ ä¹Ÿå°±æ˜¯æ‰€æœ‰åˆ›å»ºçš„çº¿ç¨‹å…¥å£å‡½æ•°éƒ½æ˜¯mstart()å‡½æ•°æ˜¯çº¿ç¨‹çš„å…¥å£å‡½æ•°æ•°ï¼Œå‚çœ‹newosproc()å‡½æ•°ã€‚ _p_ *pï¼šæ–°åˆ›å»ºçš„å·¥ä½œçº¿ç¨‹éœ€è¦ç»‘å®šçš„Pï¼Œè¯¥å€¼å¯ä»¥ä¸º nilï¼Œè¡¨ç¤ºä¸ç»‘å®šPã€‚ id int64ï¼šæ–°åˆ›å»ºçš„å·¥ä½œçº¿ç¨‹çš„IDå€¼ï¼Œè¯¥å€¼å¯ä»¥æ˜¯-1ï¼Œè¡¨ç¤ºç³»ç»Ÿè‡ªåŠ¨åˆ†é…ä¸€ä¸ªé€’å¢çš„IDæ•°å€¼ã€‚ æ–‡ä»¶ä½ç½®ï¼šgo1.19.3/src/runtime/proc.goã€‚ 2089 2090 2091 2092 2093 2094 2095 2096 2097 2098 2099 2100 2101 2102 2103 2104 2105 2106 2107 2108 2109 2110 2111 2112 2113 2114 2115 2116 2117 2118 2119 2120 2121 2122 2123 2124 2125 2126 2127 2128 2129 2130 2131 2132 2133 2134 2135 2136 2137 2138 2139 2140 2141 2142 2143 2144 2145 2146 2147 2148 // Create a new m. It will start off with a call to fn, or else the scheduler. // fn needs to be static and not a heap allocated closure. // May run with m.p==nil, so write barriers are not allowed. // // id is optional pre-allocated m ID. Omit by passing -1. // //go:nowritebarrierrec func newm(fn func(), _p_ *p, id int64) { // allocm adds a new M to allm, but they do not start until created by // the OS in newm1 or the template thread. // // doAllThreadsSyscall requires that every M in allm will eventually // start and be signal-able, even with a STW. // // Disable preemption here until we start the thread to ensure that // newm is not preempted between allocm and starting the new thread, // ensuring that anything added to allm is guaranteed to eventually // start. // // allocmå°†ä¸€ä¸ªæ–°çš„Mæ·»åŠ åˆ°allmä¸­ï¼Œä½†æ˜¯ç›´åˆ°æ“ä½œç³»ç»Ÿåœ¨newm1æˆ–æ¨¡æ¿çº¿ç¨‹ä¸­åˆ›å»ºå®ƒä»¬æ‰å¼€å§‹ã€‚ // doAllThreadsSyscall è¦æ±‚allmä¸­çš„æ¯ä¸ªMæœ€ç»ˆéƒ½å°†å¯åŠ¨å¹¶å¯å‘é€ä¿¡å·ï¼Œå³ä½¿æ˜¯STWã€‚ // åœ¨è¿™é‡Œç¦ç”¨æŠ¢å ï¼Œç›´åˆ°æˆ‘ä»¬å¯åŠ¨çº¿ç¨‹ï¼Œä»¥ç¡®ä¿newmåœ¨allocmå’Œå¯åŠ¨æ–°çº¿ç¨‹ä¹‹é—´ä¸è¢«æŠ¢å ï¼Œç¡®ä¿æ·»åŠ åˆ°allmçš„ä»»ä½•å†…å®¹æœ€ç»ˆéƒ½èƒ½å¯åŠ¨ã€‚ acquirem()\t// ç¦æ­¢å½“å‰å·¥ä½œçº¿ç¨‹è¢«æŠ¢å  // allocmä»å †ä¸Šåˆ†é…ä¸€ä¸ªmç»“æ„ä½“ï¼Œå¹¶ç»‘å®šMä¸å…¶ä»–ç›¸å…³ä¾‹å¦‚allpç­‰ mp := allocm(_p_, fn, id) mp.nextp.set(_p_)\t// è®¾ç½®å½“å‰Méœ€è¦ç”¨åˆ°çš„P mp.sigmask = initSigmask if gp := getg(); gp != nil \u0026amp;\u0026amp; gp.m != nil \u0026amp;\u0026amp; (gp.m.lockedExt != 0 || gp.m.incgo) \u0026amp;\u0026amp; GOOS != \u0026#34;plan9\u0026#34; { // We\u0026#39;re on a locked M or a thread that may have been // started by C. The kernel state of this thread may // be strange (the user may have locked it for that // purpose). We don\u0026#39;t want to clone that into another // thread. Instead, ask a known-good thread to create // the thread for us. // // This is disabled on Plan 9. See golang.org/issue/22227. // // TODO: This may be unnecessary on Windows, which // doesn\u0026#39;t model thread creation off fork. lock(\u0026amp;newmHandoff.lock) if newmHandoff.haveTemplateThread == 0 { throw(\u0026#34;on a locked thread with no template thread\u0026#34;) } mp.schedlink = newmHandoff.newm newmHandoff.newm.set(mp) if newmHandoff.waiting { newmHandoff.waiting = false notewakeup(\u0026amp;newmHandoff.wake) } unlock(\u0026amp;newmHandoff.lock) // The M has not started yet, but the template thread does not // participate in STW, so it will always process queued Ms and // it is safe to releasem. releasem(getg().m) return } newm1(mp) releasem(getg().m) } acquirem() æ–‡ä»¶ä½ç½®ï¼šgo1.19.3/src/runtime/runtime1.goã€‚ 473 474 475 476 477 478 //go:nosplit func acquirem() *m { _g_ := getg() _g_.m.locks++ return _g_.m } allocm() åˆ†é…ä¸€ä¸ªä¸ä¸ä»»ä½•çº¿ç¨‹å…³è”çš„æ–°mã€‚å¦‚æœéœ€è¦ï¼Œå¯ä»¥ä½¿ç”¨pä½œä¸ºåˆ†é…ä¸Šä¸‹æ–‡ã€‚ fnè¢«è®°å½•ä¸ºæ–°mçš„m.mstartfnã€‚idæ˜¯å¯é€‰çš„ï¼Œé¢„åˆ†é…çš„mçš„idã€‚é€šè¿‡ä¼ é€’-1æ¥çœç•¥ã€‚ è¿™ä¸ªå‡½æ•°å…è®¸æœ‰å†™éšœç¢ï¼Œå³ä½¿è°ƒç”¨è€…æ²¡æœ‰ï¼Œå› ä¸ºå®ƒå€Ÿç”¨äº†_p_ã€‚ go:yeswritebarrierrecï¼šå…è®¸ç¼–è¯‘å™¨æ’å…¥å†™å±éšœç›¸å…³ä»£ç ï¼Œå› ä¸ºè°ƒç”¨è€…ä½¿ç”¨çš„æ˜¯go:nowritebarrierrecã€‚ æ–‡ä»¶ä½ç½®ï¼šgo1.19.3/src/runtime/proc.goã€‚ 1706 1707 1708 1709 1710 1711 1712 1713 1714 1715 1716 1717 1718 1719 1720 1721 1722 1723 1724 1725 1726 1727 1728 1729 1730 1731 1732 1733 1734 1735 1736 1737 1738 1739 1740 1741 1742 1743 1744 1745 1746 1747 1748 1749 1750 1751 1752 1753 1754 1755 1756 1757 1758 1759 1760 1761 1762 1763 1764 1765 1766 1767 1768 1769 1770 1771 1772 1773 1774 1775 1776 1777 1778 1779 1780 1781 1782 1783 1784 1785 1786 1787 1788 1789 1790 // Allocate a new m unassociated with any thread. // Can use p for allocation context if needed. // fn is recorded as the new m\u0026#39;s m.mstartfn. // id is optional pre-allocated m ID. Omit by passing -1. // // This function is allowed to have write barriers even if the caller // isn\u0026#39;t because it borrows _p_. // //go:yeswritebarrierrec func allocm(_p_ *p, fn func(), id int64) *m { allocmLock.rlock() // è¯»åŠ é” // The caller owns _p_, but we may borrow (i.e., acquirep) it. We must // disable preemption to ensure it is not stolen, which would make the // caller lose ownership. acquirem() // ç¦æ­¢å½“å‰Mè¢«æŠ¢å  _g_ := getg() // å½“å‰g // æ³¨æ„è¿™é‡Œæ˜¯æ­£åœ¨æ‰§è¡Œçš„å·¥ä½œçº¿ç¨‹,åœ¨æ­¤å‡½æ•°ä¸­ä¸º malloc ä¸´æ—¶å€Ÿç”¨ p if _g_.m.p == 0 { // å¦‚æœå½“å‰Mæ²¡æœ‰ç»‘å®šPï¼Œåˆ™å»ç»‘å®šä¸€ä¸ªP // åœ¨è¿™ä¸ªå‡½æ•°ä¸­æš‚æ—¶å€Ÿç”¨pæ¥ä»£æ›¿mallocs // å½“å‰è¿™ä¸ªå·¥ä½œçº¿ç¨‹æ²¡æœ‰ç»‘å®špéœ€è¦ä¸´æ—¶å€Ÿç”¨è¿™ä¸ª_p_ï¼Œè¿™ç§æƒ…å†µå¯èƒ½æ˜¯sysmonçº¿ç¨‹ä¸­æ¥çš„ã€‚ acquirep(_p_) // temporarily borrow p for mallocs in this function } // Release the free M list. We need to do this somewhere and // this may free up a stack we can use. // // sched.freem å­˜å‚¨çš„æ˜¯ç­‰å¾…é‡Šæ”¾çš„mçš„é“¾è¡¨ if sched.freem != nil { // é‡Šæ”¾éœ€è¦é‡Šæ”¾çš„Måˆ—è¡¨ lock(\u0026amp;sched.lock) var newList *m // freem æ˜¯ä¸€ç»„å·²ç»è¿è¡Œç»“æŸçš„Mæ„æˆçš„é“¾è¡¨ï¼ˆä¸æ˜¯ç©ºé—²çš„ï¼‰ã€‚ for freem := sched.freem; freem != nil; { // freeWait é‡Šæ”¾g0å’Œåˆ é™¤mæ˜¯å¦å®‰å…¨(freeMRef, freeMStack, freeMWaitä¸­çš„ä¸€ä¸ª) if freem.freeWait != 0 { next := freem.freelink freem.freelink = newList newList = freem freem = next continue } // stackfree must be on the system stack, but allocm is // reachable off the system stack transitively from // startm. // // stackfree å¿…é¡»åœ¨ç³»ç»Ÿæ ˆä¸Šï¼Œä½†allocmä»startmå¼€å§‹åœ¨ç³»ç»Ÿæ ˆä¹‹å¤–æ˜¯å¯è®¿é—®çš„ã€‚ systemstack(func() { stackfree(freem.g0.stack) // é‡Šæ”¾æ ˆ }) freem = freem.freelink } sched.freem = newList unlock(\u0026amp;sched.lock) } // å †åˆ†é…ä¸€ä¸ªm mp := new(m)\t// Må¼€å§‹å‰éœ€è¦æ‰§è¡Œçš„å‡½æ•°ï¼Œä¸æ˜¯Mçš„å…¥å£å‡½æ•°ï¼Œæ˜¯æ‰§è¡Œmstartåä¼šè°ƒç”¨çš„å‡½æ•°ã€‚ // 1. å¦‚æœæ˜¯è°ƒåº¦çº¿ä¸‹è¿™é‡Œå­˜å‚¨çš„æ˜¯mspinning()å‡½æ•° // 2. å¦‚æœæ˜¯ç›‘æ§çº¿ç¨‹å­˜å‚¨çš„æ˜¯sysmon()å‡½æ•° mp.mstartfn = fn\t// åˆå§‹åŒ–Mï¼Œä¸»è¦æ˜¯æŠŠmåŠ å…¥åˆ°allmä¸­ï¼Œmè®°å½•allmåœ°å€ç­‰ // è¯¥å‡½æ•°åœ¨ç¨‹åºåˆå§‹åŒ–è¿‡ç¨‹ä¸­ä¹Ÿè¢«è°ƒç”¨è¿‡ mcommoninit(mp, id)\t// In case of cgo or Solaris or illumos or Darwin, pthread_create will make us a stack. // Windows and Plan 9 will layout sched stack on OS stack. if iscgo || mStackIsSystemAllocated() { mp.g0 = malg(-1) } else { // runtime çš„g0æ ˆåˆ†é…çš„æ˜¯64kbå·¦å³å¤§å°ï¼Œå…¶ä»–çš„g0æ ˆåˆ†é…çš„æ˜¯8kbå·¦å³å¤§å° // å…³äºmalgå‡½æ•°ï¼Œæ˜¯æ¥è‡ªæ ˆç›¸å…³ mp.g0 = malg(8192 * sys.StackGuardMultiplier) // åˆ†é…ä¸€ä¸ªå¤§æ¦‚8Kbå·¦å³çš„g0ä½œä¸ºç³»ç»Ÿæ ˆ } mp.g0.m = mp\t// g0ä¸må…³è” if _p_ == _g_.m.p.ptr() { // å¦‚æœå‰é¢ä¸´æ—¶å€Ÿç”¨äº†Pï¼Œè¿™é‡Œéœ€è¦è¿˜å‡ºæ¥ releasep() // è§£ç»‘å½“å‰å·¥ä½œçº¿ç¨‹Må’ŒPçš„å…³è” } releasem(_g_.m) // åˆ¤æ–­å½“å‰gæ˜¯å¦éœ€è¦è¢«æŠ¢å ï¼Œè®¾ç½®æŠ¢å æ ‡å¿— allocmLock.runlock() return mp } acquirep() æŠŠpå’Œå½“å‰mè”ç³»èµ·æ¥ã€‚ è¿™ä¸ªå‡½æ•°å…è®¸æœ‰å†™éšœç¢ï¼Œå³ä½¿è°ƒç”¨è€…æ²¡æœ‰ï¼Œå› ä¸ºå®ƒç«‹å³è·å¾—_p_ã€‚ go:yeswritebarrierrecï¼šå…è®¸ç¼–è¯‘å™¨æ’å…¥å†™å±éšœç›¸å…³ä»£ç ã€‚ æ–‡ä»¶ä½ç½®ï¼šgo1.19.3/src/runtime/proc.goã€‚ 4938 4939 4940 4941 4942 4943 4944 4945 4946 4947 4948 4949 4950 4951 4952 4953 4954 4955 4956 4957 4958 4959 // Associate p and the current m. // // This function is allowed to have write barriers even if the caller // isn\u0026#39;t because it immediately acquires _p_. // //go:yeswritebarrierrec func acquirep(_p_ *p) { // Do the part that isn\u0026#39;t allowed to have write barriers. wirep(_p_)\t// æŠŠ P ä¸ M ç»‘å®šèµ·æ¥ // Have p; write barriers now allowed. // ç°åœ¨æœ‰päº†ï¼›ç°åœ¨å…è®¸å†™å±éšœã€‚ // Perform deferred mcache flush before this P can allocate // from a potentially stale mcache. // åœ¨æ­¤På¯ä»¥ä»å¯èƒ½ä¸æ–°é²œçš„mcacheåˆ†é…ä¹‹å‰ï¼Œæ‰§è¡Œå»¶è¿Ÿçš„mcacheåˆ·æ–°ã€‚ _p_.mcache.prepareForSweep() if trace.enabled { traceProcStart() } } wirepæ˜¯acquirepçš„ç¬¬ä¸€æ­¥ï¼Œå®ƒå®é™…ä¸Šå°†å½“å‰Må…³è”åˆ°_p_ã€‚ å› ä¸ºæˆ‘ä»¬è¿˜æ²¡æœ‰Pï¼Œæ‰€ä»¥æˆ‘ä»¬å¯ä»¥åœ¨è¿™éƒ¨åˆ†ä¸å…è®¸å†™éšœç¢ã€‚ go:nowritebarrierrecï¼šä¸å…è®¸ç¼–è¯‘å™¨æ’å…¥å†™å±éšœç›¸å…³ä»£ç ã€‚ æ–‡ä»¶ä½ç½®ï¼šgo1.19.3/src/runtime/proc.goã€‚ 4959 4960 4961 4962 4963 4964 4965 4966 4967 4968 4969 4970 4971 4972 4973 4974 4975 4976 4977 4978 4979 4980 4981 4982 4983 4984 4985 // wirep is the first step of acquirep, which actually associates the // current M to _p_. This is broken out so we can disallow write // barriers for this part, since we don\u0026#39;t yet have a P. // //go:nowritebarrierrec //go:nosplit func wirep(_p_ *p) { _g_ := getg() // g // è¿™é‡Œæ¥çš„mä¸€å®šéœ€è¦æ˜¯æ²¡ç»‘å®špçš„ã€‚ if _g_.m.p != 0 { throw(\u0026#34;wirep: already in go\u0026#34;) } // å½“å‰pä¹Ÿæ˜¯ä¸èƒ½ç»‘å®šmçš„ï¼Œå¹¶ä¸”å½“å‰pçš„çŠ¶æ€ä¸èƒ½æ˜¯ _Pidle if _p_.m != 0 || _p_.status != _Pidle { id := int64(0) if _p_.m != 0 { id = _p_.m.ptr().id } print(\u0026#34;wirep: p-\u0026gt;m=\u0026#34;, _p_.m, \u0026#34;(\u0026#34;, id, \u0026#34;) p-\u0026gt;status=\u0026#34;, _p_.status, \u0026#34;\\n\u0026#34;) throw(\u0026#34;wirep: invalid p state\u0026#34;) } // p ä¸ m ç›¸äº’ç»‘å®š _g_.m.p.set(_p_) // m.p = _p_ _p_.m.set(_g_.m) // _p_.m = m _p_.status = _Prunning // è®¾ç½®pçš„çŠ¶æ€ä¸ºè¿è¡Œä¸­ } mcommoninit() é¢„åˆ†é…çš„IDå¯ä»¥ä½œä¸º'ID'ä¼ é€’ï¼Œä¹Ÿå¯ä»¥é€šè¿‡ä¼ é€’-1æ¥çœç•¥ã€‚ æ–‡ä»¶ä½ç½®ï¼šgo1.19.3/src/runtime/proc.goã€‚ 785 786 787 788 789 790 791 792 793 794 795 796 797 798 799 800 801 802 803 804 805 806 807 808 809 810 811 812 813 814 815 816 817 818 819 820 821 822 823 824 825 826 827 828 829 830 831 832 833 // Pre-allocated ID may be passed as \u0026#39;id\u0026#39;, or omitted by passing -1. func mcommoninit(mp *m, id int64) { _g_ := getg() // g // g0 stack won\u0026#39;t make sense for user (and is not necessary unwindable). if _g_ != _g_.m.g0 { // ä¸èƒ½æ˜¯g0æ ˆ callers(1, mp.createstack[:]) } lock(\u0026amp;sched.lock) if id \u0026gt;= 0 { mp.id = id } else { mp.id = mReserveID() } lo := uint32(int64Hash(uint64(mp.id), fastrandseed)) hi := uint32(int64Hash(uint64(cputicks()), ^fastrandseed)) if lo|hi == 0 { hi = 1 } // Same behavior as for 1.17. // TODO: Simplify ths. if goarch.BigEndian { mp.fastrand = uint64(lo)\u0026lt;\u0026lt;32 | uint64(hi) } else { mp.fastrand = uint64(hi)\u0026lt;\u0026lt;32 | uint64(lo) } mpreinit(mp) // ä¿¡å·ç›¸å…³ if mp.gsignal != nil { mp.gsignal.stackguard1 = mp.gsignal.stack.lo + _StackGuard } // Add to allm so garbage collector doesn\u0026#39;t free g-\u0026gt;m // when it is just in a register or thread-local storage. mp.alllink = allm // è®°å½•å½“å‰m.alllinkçš„å…¨å±€allmåœ°å€ // NumCgoCall() iterates over allm w/o schedlock, // so we need to publish it safely. atomicstorep(unsafe.Pointer(\u0026amp;allm), unsafe.Pointer(mp))\t// æŠŠmæ·»åŠ åˆ°å…¨å±€allmä¸­ unlock(\u0026amp;sched.lock) // Allocate memory to hold a cgo traceback if the cgo call crashes. if iscgo || GOOS == \u0026#34;solaris\u0026#34; || GOOS == \u0026#34;illumos\u0026#34; || GOOS == \u0026#34;windows\u0026#34; { mp.cgoCallers = new(cgoCallers) } } newm1() æ–‡ä»¶ä½ç½®ï¼šgo1.19.3/src/runtime/proc.goã€‚ 2145 2146 2147 2148 2149 2150 2151 2152 2153 2154 2155 2156 2157 2158 2159 2160 2161 2162 2163 2164 2165 2166 2167 2168 2169 2170 func newm1(mp *m) { if iscgo { // cgoç›¸å…³ä»£ç  var ts cgothreadstart if _cgo_thread_start == nil { throw(\u0026#34;_cgo_thread_start missing\u0026#34;) } ts.g.set(mp.g0) ts.tls = (*uint64)(unsafe.Pointer(\u0026amp;mp.tls[0])) ts.fn = unsafe.Pointer(abi.FuncPCABI0(mstart)) if msanenabled { msanwrite(unsafe.Pointer(\u0026amp;ts), unsafe.Sizeof(ts)) } if asanenabled { asanwrite(unsafe.Pointer(\u0026amp;ts), unsafe.Sizeof(ts)) } execLock.rlock() // Prevent process clone. asmcgocall(_cgo_thread_start, unsafe.Pointer(\u0026amp;ts)) execLock.runlock() return } execLock.rlock() // Prevent process clone. // newosprocå‡½æ•° è°ƒç”¨cloneå‡½æ•°åˆ›å»ºä¸€ä¸ªç³»ç»Ÿçº¿ç¨‹ // æ–°å»ºçš„è¿™ä¸ªç³»ç»Ÿçº¿ç¨‹å°†ä»mstart()å‡½æ•°å¼€å§‹è¿è¡Œã€‚ newosproc(mp) execLock.runlock() } newosproc() å¯ä»¥m.p==nil è¿è¡Œï¼Œå› æ­¤ä¸å…è®¸å†™å±éšœã€‚ æ–‡ä»¶ä½ç½®ï¼šgo1.19.3/src/runtime/os_linux.goã€‚ 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 // May run with m.p==nil, so write barriers are not allowed. // //go:nowritebarrier func newosproc(mp *m) { stk := unsafe.Pointer(mp.g0.stack.hi) // è·å–å½“å‰æ–°åˆ›å»ºçš„Mçš„g0æ ˆæ ˆé¡¶ä½ç½® /* * note: strace gets confused if we use CLONE_PTRACE here. */ if false { print(\u0026#34;newosproc stk=\u0026#34;, stk, \u0026#34; m=\u0026#34;, mp, \u0026#34; g=\u0026#34;, mp.g0, \u0026#34; clone=\u0026#34;, abi.FuncPCABI0(clone), \u0026#34; id=\u0026#34;, mp.id, \u0026#34; ostk=\u0026#34;, \u0026amp;mp, \u0026#34;\\n\u0026#34;) } // Disable signals during clone, so that the new thread starts // with signals disabled. It will enable them in minit. // // åœ¨å…‹éš†æœŸé—´ç¦ç”¨ä¿¡å·ï¼Œä»¥ä¾¿æ–°çº¿ç¨‹ä»¥ç¦ç”¨ä¿¡å·å¼€å§‹ã€‚ å®ƒå°†åœ¨minitä¸­å¯ç”¨å®ƒä»¬ã€‚ var oset sigset sigprocmask(_SIG_SETMASK, \u0026amp;sigset_all, \u0026amp;oset) // cloneFlags = _CLONE_VM | /* share memory */ // æŒ‡å®šçˆ¶å­çº¿ç¨‹å…±äº«è¿›ç¨‹åœ°å€ç©ºé—´ // _CLONE_FS | /* share cwd, etc */ // _CLONE_FILES | /* share fd table */ // _CLONE_SIGHAND | /* share sig handler table */ // _CLONE_SYSVSEM | /* share SysV semaphore undo lists (see issue #20763) */ // _CLONE_THREAD /* revisit - okay for now */ // åˆ›å»ºå­çº¿ç¨‹è€Œä¸æ˜¯å­è¿›ç¨‹ // ç¨‹åºçš„å…¥å£éƒ½æ˜¯ã€mstart()ã€‘å‡½æ•°å¼€å§‹ ret := clone(cloneFlags, stk, unsafe.Pointer(mp), unsafe.Pointer(mp.g0), unsafe.Pointer(abi.FuncPCABI0(mstart))) sigprocmask(_SIG_SETMASK, \u0026amp;oset, nil) // æ€ä¹ˆä¹Ÿåº”è¯¥å‡ºç° ret å°äº0çš„æƒ…å†µ if ret \u0026lt; 0 { print(\u0026#34;runtime: failed to create new OS thread (have \u0026#34;, mcount(), \u0026#34; already; errno=\u0026#34;, -ret, \u0026#34;)\\n\u0026#34;) if ret == -_EAGAIN { println(\u0026#34;runtime: may need to increase max user processes (ulimit -u)\u0026#34;) } throw(\u0026#34;newosproc\u0026#34;) } } clone() Cå‡½æ•°åŸå‹ï¼šint32 clone(int32 flags, void *stk, M *mp, G *gp, void (*fn)(void))\nint32 flagsï¼šæŒ‡å®šå†…æ ¸åˆ›å»ºçº¿ç¨‹æ—¶éœ€è¦çš„é€‰é¡¹ã€‚ void *stkï¼šæ–°çº¿ç¨‹åº”è¯¥ä½¿ç”¨çš„æ ˆï¼š å› ä¸ºå³å°†è¢«åˆ›å»ºçš„çº¿ç¨‹ä¸å½“å‰çº¿ç¨‹å…±äº«åŒä¸€ä¸ªè¿›ç¨‹åœ°å€ç©ºé—´ï¼Œæ‰€ä»¥è¿™é‡Œå¿…é¡»ä¸ºå­çº¿ç¨‹æŒ‡å®šå…¶ä½¿ç”¨çš„æ ˆï¼Œå¦åˆ™çˆ¶å­çº¿ç¨‹ä¼šå…±äº«åŒä¸€ä¸ªæ ˆä»è€Œé€ æˆæ··ä¹±ã€‚ ä»ä¸Šé¢çš„newosproc()å‡½æ•°å¯ä»¥çœ‹å‡ºï¼Œæ–°çº¿ç¨‹ä½¿ç”¨çš„æ ˆä¸ºm.g0.stack.loï½m.g0.stack.hiè¿™æ®µå†…å­˜ï¼Œè€Œè¿™æ®µå†…å­˜æ˜¯newm()å‡½æ•°åœ¨åˆ›å»ºmç»“æ„ä½“å¯¹è±¡æ—¶ä»è¿›ç¨‹çš„å †ä¸Šåˆ†é…è€Œæ¥çš„ã€‚ M *mpï¼šå·¥ä½œçº¿ç¨‹ M çš„ä¿¡æ¯è®°å½•ã€‚ G *gpï¼šg0æ ˆä¿¡æ¯è®°å½•ã€‚ void (*fn)(void)ï¼šå­çº¿ç¨‹ç¨‹åºå…¥å£å‡½æ•°ã€‚ ä¸Šé¢ä¸‰ä¸ªå‚æ•°ï¼ˆM *mpã€G *gpã€void (*fn)(void)ï¼‰ä¿å­˜åˆ°å¯„å­˜å™¨ï¼ˆR13ã€R9ã€R12ï¼‰ä¸­ï¼š ä¹‹æ‰€ä»¥éœ€è¦åœ¨ç³»ç»Ÿè°ƒç”¨ä¹‹å‰ä¿å­˜è¿™å‡ ä¸ªå‚æ•°ï¼ŒåŸå› åœ¨äºè¿™å‡ ä¸ªå‚æ•°ç›®å‰è¿˜ä½äºçˆ¶çº¿ç¨‹çš„æ ˆä¹‹ä¸­ã€‚ ä¸€æ—¦é€šè¿‡ç³»ç»Ÿè°ƒç”¨æŠŠå­çº¿ç¨‹åˆ›å»ºå‡ºæ¥ä¹‹åï¼Œå­çº¿ç¨‹å°†ä¼šä½¿ç”¨æˆ‘ä»¬åœ¨cloneç³»ç»Ÿè°ƒç”¨æ—¶ç»™å®ƒæŒ‡å®šçš„æ ˆã€‚ æ‰€ä»¥è¿™é‡Œéœ€è¦æŠŠè¿™å‡ ä¸ªå‚æ•°å…ˆä¿å­˜åˆ°å¯„å­˜å™¨ï¼Œç­‰å­çº¿ç¨‹ä»ç³»ç»Ÿè°ƒç”¨è¿”å›åç›´æ¥åœ¨å¯„å­˜å™¨ä¸­è·å–è¿™å‡ ä¸ªå‚æ•°ã€‚ è¿™é‡Œè¦æ³¨æ„çš„æ˜¯è™½ç„¶è¿™ä¸ªå‡ ä¸ªå‚æ•°å€¼ä¿å­˜åœ¨äº†çˆ¶çº¿ç¨‹çš„å¯„å­˜å™¨ä¹‹ä¸­ï¼Œä½†åˆ›å»ºå­çº¿ç¨‹æ—¶ï¼Œæ“ä½œç³»ç»Ÿå†…æ ¸ä¼šæŠŠçˆ¶çº¿ç¨‹çš„æ‰€æœ‰å¯„å­˜å™¨å¸®æˆ‘ä»¬å¤åˆ¶ä¸€ä»½ç»™å­çº¿ç¨‹ï¼Œæ‰€ä»¥å½“å­çº¿ç¨‹å¼€å§‹è¿è¡Œæ—¶å°±èƒ½æ‹¿åˆ°çˆ¶çº¿ç¨‹ä¿å­˜åœ¨å¯„å­˜å™¨ä¸­çš„å€¼ï¼Œä»è€Œæ‹¿åˆ°è¿™å‡ ä¸ªå‚æ•°ã€‚ æ–‡ä»¶ä½ç½®ï¼šgo1.19.3/src/runtime/sys_linux_amd64.sã€‚ 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 # int32 clone(int32 flags, void *stk, M *mp, G *gp, void (*fn)(void)); TEXT runtimeÂ·clone(SB),NOSPLIT,$0 # 1) æ¥å—å‚æ•°åˆ†è˜–æ”¾å…¥ DIã€SIã€R13ã€R9ã€R12å¯„å­˜å™¨ä¸­ # æ¸…é™¤ DXã€R10ã€D8å¯„å­˜å™¨çš„å€¼ # ç¬¬ä¸€ä¸ªå‚æ•° flagsï¼Œcloneéœ€è¦çš„å‚æ•° MOVL flags+0(FP), DI # DI = flags # ç¬¬äºŒä¸ªå‚æ•° stkï¼Œg0æ ˆç©ºé—´ MOVQ stk+8(FP), SI # SI = stk MOVQ $0, DX # æ¸…é™¤DXå¯„å­˜å™¨ MOVQ $0, R10 # æ¸…é™¤R10å¯„å­˜å™¨ MOVQ $0, R8 # æ¸…é™¤R8å¯„å­˜å™¨ # Copy mp, gp, fn off parent stack for use by child. # Careful: Linux system call clobbers CX and R11. # # ä»çˆ¶å †æ ˆä¸­å¤åˆ¶ mpã€gpã€fn ä»¥ä¾›å­çº§ä½¿ç”¨ # å°å¿ƒï¼šLinuxç³»ç»Ÿè°ƒç”¨clobbers CXå’ŒR11 # ç¬¬ä¸‰ä¸ªå‚æ•° mp # åœ¨cloneåå­çº¿ç¨‹å¼€å§‹è¿è¡Œæ—¶ï¼ŒR13ã€R9ã€R12çš„å€¼ä¼šè¢«æ‹·è´ç»™å­çº¿ç¨‹ MOVQ mp+16(FP), R13 # R13 = mp # ç¬¬å››ä¸ªå‚æ•° gpï¼Œè¿™é‡Œæ˜¯ g0 MOVQ gp+24(FP), R9 # R9 = gp # ç¬¬äº”ä¸ªå‚æ•° fnï¼Œmstart()å‡½æ•° MOVQ fn+32(FP), R12 # R12 = fn # 2) åˆ¤æ–­ mp å’Œ gp çš„å€¼æ˜¯ä¸º nil # åˆ¤æ–­mp==nilå’Œg0=nil # m å¦‚æœR13ä¸º0åˆ™è·³è½¬ CMPQ R13, $0 JEQ\tnog1 # g\tå¦‚æœR9ä¸º0åˆ™è·³è½¬ CMPQ R9, $0 JEQ\tnog1 # 3) æ‰¾åˆ°éœ€è¦è®¾ç½®TLSçš„åœ°å€å€¼ï¼Œä¹Ÿå°±æ˜¯\u0026amp;m.tls[1] # è°ƒç”¨ç³»ç»ŸSYS_cloneå‡½æ•°å…‹éš†çº¿ç¨‹ # æŠŠm.tlsåœ°å€å­˜å…¥R8å¯„å­˜å™¨ LEAQ m_tls(R13), R8 # R8 = TLS #ifdef GOOS_android # Android stores the TLS offset in runtimeÂ·tls_g. SUBQ runtimeÂ·tls_g(SB), R8 #else # R8 = -8(FS); R8=\u0026amp;m.tls[1]å¤„åœ°å€ ADDQ $8, R8\t# ELF wants to use -8(FS) #endif # æ·»åŠ CLONE_SETTLSæ ‡å¿— ORQ $0x00080000, DI #add flag CLONE_SETTLS(0x00080000) to call clone nog1: MOVL $SYS_clone, AX # å†™å…¥cloneå‡½æ•°æ ‡å¿—ï¼Œç„¶åè°ƒç”¨ç³»ç»Ÿå‡½æ•° # ç³»ç»Ÿè°ƒç”¨çº¦å®šå¯„å­˜å™¨ DI SI DX R10 R8 R9 å‚æ•°ä¼ å‚ # DI = flags # SI = stk # DX = 0 # R10 = 0 # R8 = R8=\u0026amp;m.tls[1] # R9 = gp SYSCALL # 4) ç³»ç»Ÿè°ƒç”¨åï¼Œæ–°åˆ›å»ºçš„å­çº¿ç¨‹å’Œå½“å‰çº¿ç¨‹éƒ½ä¼šä»ç³»ç»Ÿè°ƒç”¨ä¸­è¿”å›ç„¶åæ‰§è¡Œåé¢çš„ä»£ç  # # é‚£ä¹ˆä»ç³»ç»Ÿè°ƒç”¨è¿”å›ä¹‹åæˆ‘ä»¬æ€ä¹ˆçŸ¥é“å“ªä¸ªæ˜¯çˆ¶çº¿ç¨‹å“ªä¸ªæ˜¯å­çº¿ç¨‹ï¼Œä»è€Œæ¥å†³å®šå®ƒä»¬çš„æ‰§è¡Œæµç¨‹ï¼Ÿ # ä½¿ç”¨è¿‡forkç³»ç»Ÿè°ƒç”¨çš„è¯»è€…åº”è¯¥çŸ¥é“ï¼Œæˆ‘ä»¬éœ€è¦é€šè¿‡è¿”å›å€¼æ¥åˆ¤æ–­çˆ¶å­çº¿ç¨‹ï¼š # 1. ç³»ç»Ÿè°ƒç”¨çš„è¿”å›å€¼å¦‚æœæ˜¯0åˆ™è¡¨ç¤ºè¿™æ˜¯å­çº¿ç¨‹ # 2. ä¸ä¸º0åˆ™è¡¨ç¤ºè¿™ä¸ªæ˜¯çˆ¶çº¿ç¨‹ # 4.1) çˆ¶çº¿ç¨‹çš„å¤„ç†é€»è¾‘ # In parent, return. # # åœ¨çˆ¶çº¿ç¨‹ä¸­ï¼Œç›´æ¥è¿”å›ã€‚ # åˆ¤æ–­ç³»ç»Ÿè°ƒç”¨SYS_cloneçš„è¿”å›å€¼AXä¸0æ¯”è¾ƒ CMPQ AX, $0 # JEQ è¡¨ç¤ºAXæ˜¯0åˆ™æ‰§è¡Œ 3(PC)è·³è¿‡3æ¡æŒ‡ä»¤ JEQ\t3(PC) #è·³è½¬åˆ°å­çº¿ç¨‹éƒ¨åˆ† # è¿™é‡Œæ˜¯çˆ¶çº¿ç¨‹ç›´æ¥æŠŠè¿”å›å€¼å†™å…¥æ ˆï¼Œç„¶åé€€å‡ºå‡½æ•° MOVL AX, ret+40(FP)\tRET\t# 4.2) å­çº¿ç¨‹çš„å¤„ç†é€»è¾‘ï¼Œè®¾ç½®SPï¼Œåˆ¤æ–­mpå’Œgpï¼Œè®¾ç½®mp.procid # In child, on new stack. # # åœ¨å­çº¿ç¨‹ä¸­ï¼Œåœ¨newæ ˆä¸Šã€‚ # æ–°åˆ›å»ºçš„å­çº¿ç¨‹ä»è¿™é‡Œå¼€å§‹ï¼Œæ³¨æ„ä¸€ä¸‹ä»£ç æ˜¯åœ¨å­çº¿ç¨‹ä¸­ï¼Œå¯„å­˜å™¨ä¹Ÿæ˜¯å­çº¿ç¨‹çš„ # è®¾ç½®CPUæ ˆé¡¶å¯„å­˜å™¨æŒ‡å‘å­çº¿ç¨‹çš„æ ˆé¡¶ï¼Œè¿™æ¡æŒ‡ä»¤çœ‹èµ·æ¥æ˜¯å¤šä½™çš„ï¼Ÿå†…æ ¸åº”è¯¥å·²ç»æŠŠSPè®¾ç½®å¥½äº† MOVQ SI, SP # If g or m are nil, skip Go-related setup. # # å¦‚æœ g æˆ– m ä¸º nilï¼Œè·³è¿‡ Go-related è®¾ç½®ã€‚ # m\tæ–°åˆ›å»ºçš„mç»“æ„ä½“å¯¹è±¡çš„åœ°å€ï¼Œç”±çˆ¶çº¿ç¨‹ä¿å­˜åœ¨R13å¯„å­˜å™¨ä¸­çš„å€¼è¢«å¤åˆ¶åˆ°äº†å­çº¿ç¨‹ CMPQ R13, $0 # R13 = mp JEQ\tnog2 # R13 ä¸º 0 æ—¶è·³è½¬ # g\tm.g0çš„åœ°å€ï¼Œç”±çˆ¶çº¿ç¨‹ä¿å­˜åœ¨R9å¯„å­˜å™¨ä¸­çš„å€¼è¢«å¤åˆ¶åˆ°äº†å­çº¿ç¨‹ CMPQ R9, $0 # R9 = gp JEQ\tnog2 # R9 ä¸º 0 æ—¶è·³è½¬ # Initialize m-\u0026gt;procid to Linux tid # # å°†m-\u0026gt;procidåˆå§‹åŒ–ä¸ºLinux tidã€‚ MOVL $SYS_gettid, AX\t# é€šè¿‡gettid()ç³»ç»Ÿè°ƒç”¨è·å–çº¿ç¨‹IDï¼ˆtidï¼‰ SYSCALL MOVQ AX, m_procid(R13) # m.procid = tid # Set FS to point at m-\u0026gt;tls. # # æ–°çº¿ç¨‹åˆšåˆšåˆ›å»ºå‡ºæ¥ï¼Œè¿˜æœªè®¾ç½®çº¿ç¨‹æœ¬åœ°å­˜å‚¨ï¼Œå³mç»“æ„ä½“å¯¹è±¡è¿˜æœªä¸å·¥ä½œçº¿ç¨‹å…³è”èµ·æ¥ï¼Œ # ä¸‹é¢çš„æŒ‡ä»¤è´Ÿè´£è®¾ç½®æ–°çº¿ç¨‹çš„TLSï¼ŒæŠŠmå¯¹è±¡å’Œå·¥ä½œçº¿ç¨‹å…³è”èµ·æ¥ # è¿™ä¸¤è¡Œä»£ç åœ¨go1.18ä¸­æ¶ˆå¤±äº†ï¼ŒåŸå› åœ¨äºCLONE_SETTLSé…åˆå‚æ•°å’ŒR8å¯„å­˜å™¨åœ¨cloneä¸­è¢«è®¾ç½®äº† # LEAQ m_tls(R13), DI # å–m.tlså­—æ®µçš„åœ°å€\t# CALL runtimeÂ·settls(SB) # In child, set up new stack get_tls(CX)\t# CX=\u0026amp;m.tls[1]; CX=TLS MOVQ R13, g_m(R9) # g0.m = m MOVQ R9, g(CX) # m.tls[0]=\u0026amp;g0 # R14=\u0026amp;g0 R14å¯„å­˜å™¨ä¸»è¦å­˜å‚¨å½“å‰æ­£åœ¨è¿è¡Œçš„goroutine MOVQ R9, R14 # set g register CALL runtimeÂ·stackcheck(SB) # æ£€æŸ¥ SP æ˜¯å¦åœ¨ [g-\u0026gt;stack.lo, g-\u0026gt;stack.hi) èŒƒå›´å†… nog2: # Call fn. This is the PC of an ABI0 function. # # è°ƒç”¨mstart()å‡½æ•°å¼€å§‹è°ƒåº¦å¾ªç¯ CALL R12\t# æ°¸ä¸è¿”å› # It shouldn\u0026#39;t return. If it does, exit that thread. MOVL $111, DI MOVL $SYS_exit, AX SYSCALL JMP\t-3(PC) // keep exiting stackcheck() æ£€æŸ¥SPæ˜¯å¦åœ¨[g-\u0026gt;stack.lo, g-\u0026gt;stack.hi)èŒƒå›´å†…ã€‚ æ–‡ä»¶ä½ç½®ï¼šgo1.19.3/src/runtime/sys_linux_amd64.sã€‚ 1061 1062 1063 1064 1065 1066 1067 1068 1069 1070 1071 1072 1073 # check that SP is in range [g-\u0026gt;stack.lo, g-\u0026gt;stack.hi) TEXT runtimeÂ·stackcheck(SB), NOSPLIT, $0-0 get_tls(CX) # CX=TLS MOVQ g(CX), AX # AX=g0 # g0.stack.hi ä¸ SP æ¯”è¾ƒ CMPQ (g_stack+stack_hi)(AX), SP JHI\t2(PC) CALL runtimeÂ·abort(SB) # g0.stack.lo ä¸ SP æ¯”è¾ƒ CMPQ SP, (g_stack+stack_lo)(AX) JHI\t2(PC) CALL runtimeÂ·abort(SB) RET ","permalink":"https://heliu.site/posts/golang/goroutine/newm/","summary":"Golang wakep()å’Œnewm()å‡½æ•°ä»‹ç»ã€‚","title":"å·¥ä½œçº¿ç¨‹çš„å”¤é†’å’Œåˆ›å»º"},{"content":" goroutineçš„ä¸»åŠ¨è°ƒåº¦æ˜¯æŒ‡å½“å‰æ­£åœ¨è¿è¡Œçš„goroutineé€šè¿‡ç›´æ¥è°ƒç”¨runtime.Gosched()å‡½æ•°æš‚æ—¶æ”¾å¼ƒè¿è¡Œè€Œå‘ç”Ÿçš„è°ƒåº¦ã€‚ ä¸»åŠ¨è°ƒåº¦å®Œå…¨æ˜¯ã€ç”¨æˆ·ä»£ç ã€‘è‡ªå·±æ§åˆ¶çš„ï¼Œæˆ‘ä»¬æ ¹æ®ä»£ç å°±å¯ä»¥é¢„è§ä»€ä¹ˆåœ°æ–¹ä¸€å®šä¼šå‘ç”Ÿè°ƒåº¦ã€‚ ä½¿ç”¨ç¤ºä¾‹ï¼š 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 package main import ( \u0026#34;runtime\u0026#34; \u0026#34;sync\u0026#34; ) const N = 1 func main() { var wg sync.WaitGroup wg.Add(N) for i := 0; i \u0026lt; N; i++ { go start(\u0026amp;wg) } wg.Wait() } func start(wg *sync.WaitGroup) { for i := 0; i \u0026lt; 1000; i++ { runtime.Gosched() // è¿™é‡Œä¼šè®©å‡ºè°ƒåº¦ } wg.Done() } Gosched() Goschedæ”¾å¼ƒå½“å‰CPUè¿è¡Œæƒé™ï¼Œå…è®¸å…¶ä»–goroutineè¿è¡Œã€‚ å®ƒä¼šæŒ‚èµ·å½“å‰çš„goroutineï¼Œå› æ­¤æ‰§è¡Œä¼šè‡ªåŠ¨æ¢å¤ã€‚ æ–‡ä»¶ä½ç½®ï¼šgo1.19.3/src/runtime/proc.goã€‚ 314 315 316 317 318 319 320 321 322 323 324 325 // Gosched yields the processor, allowing other goroutines to run. It does not // suspend the current goroutine, so execution resumes automatically. func Gosched() { // amd64 linuxå¹³å°æ˜¯ç©ºå‡½æ•° checkTimeouts()\t// mcall å‡½æ•°åœ¨ user goroutine ä¸­å·²åˆ†æï¼Œåˆ‡æ¢åˆ°g0æ ˆè°ƒç”¨ gosched_m å‡½æ•°ã€‚ // ç›¸å…³ user goroutine å¯„å­˜å™¨ä¿¡æ¯åœ¨ mcall å‡½æ•°ä¸­è¢«ä¿å­˜äº†ã€‚ mcall(gosched_m) // goroutine å†æ¬¡è¢«è°ƒåº¦èµ·æ¥åˆ™ä»è¿™é‡Œå¼€å§‹è¿è¡Œ } gosched_m() æ ¹æ®mcall()å‡½æ•°çŸ¥é“è¿™é‡Œçš„gp *gæ˜¯user goroutineï¼Œä¸æ˜¯g0ã€‚ ä½†æ˜¯å½“å‰å·²ç»åˆ‡æ¢åˆ°g0æ ˆäº†ã€‚ æ–‡ä»¶ä½ç½®ï¼šgo1.19.3/src/runtime/proc.goã€‚ 3381 3382 3383 3384 3385 3386 3387 3388 3389 // Gosched continuation on g0. func gosched_m(gp *g) { // traceback ä¸å…³æ³¨ if trace.enabled {\ttraceGoSched() } // gp is user goroutine goschedImpl(gp) } goschedImpl() user goroutineä¿®æ”¹çŠ¶æ€åä¸Mè§£ç»‘ï¼ŒåŠ å…¥å…¨å±€é˜Ÿåˆ—æ± ä¸­ï¼Œå¼€å¯ä¸‹ä¸€è½®è°ƒåº¦å¾ªç¯ã€‚ æ–‡ä»¶ä½ç½®ï¼šgo1.19.3/src/runtime/proc.goã€‚ 3366 3367 3368 3369 3370 3371 3372 3373 3374 3375 3376 3377 3378 3379 3380 3381 3382 3383 3384 3385 3386 3387 3388 3389 func goschedImpl(gp *g) { // readgstatus(gp) -\u0026gt; atomic.Load(\u0026amp;gp.atomicstatus) // åŸå­è·å– user goroutine çš„çŠ¶æ€ status := readgstatus(gp) // åˆ¤æ–­ user goroutine çŠ¶æ€ if status\u0026amp;^_Gscan != _Grunning { dumpgstatus(gp) throw(\u0026#34;bad g status\u0026#34;) } // å½“å‰ user goroutine å³å°†è¢«æŒ‚èµ·ï¼Œéœ€è¦ä¿®æ”¹çŠ¶æ€ // _Grunningï¼š goroutineå¯èƒ½æ­£åœ¨è¿è¡Œç”¨æˆ·ä»£ç ï¼Œå®ƒçš„æ ˆå½’è‡ªå·±æ‰€æœ‰ã€‚ // _Grunnableï¼šgoroutineåº”è¯¥åœ¨æŸä¸ªrunqä¸­ï¼Œå½“å‰å¹¶æ²¡æœ‰åœ¨è¿è¡Œç”¨æˆ·ä»£ç ï¼Œå®ƒçš„æ ˆä¸å½’è‡ªå·±æ‰€æœ‰ã€‚ casgstatus(gp, _Grunning, _Grunnable) // è®¾ç½®å½“å‰m.curg = nil, gp.m = nil è§£é™¤mä¸gä¹‹å‰çš„ç»‘å®šå…³ç³» dropg()\tlock(\u0026amp;sched.lock) // æŠŠgpæ”¾å…¥schedçš„å…¨å±€è¿è¡Œé˜Ÿåˆ—runq globrunqput(gp)\tunlock(\u0026amp;sched.lock) // åœ¨scheduleå‡½æ•°ä¸­ä¼šåˆ¤æ–­ m.locks != 0 åˆ¤æ–­ // å› æ­¤å½“å‰Mè¿˜å­˜åœ¨é”æƒ…å†µä¸‹ä¸è¦è®©å‡º schedule() // è¿›å…¥æ–°ä¸€è½®è°ƒåº¦ } drop() dropgå»é™¤må’Œå½“å‰goroutine m-\u0026gt;curg(ç®€ç§°gp)ä¹‹é—´çš„å…³è”ã€‚ é€šå¸¸ï¼Œè°ƒç”¨è€…ä¼šå°†gpçš„çŠ¶æ€è®¾ç½®ä¸ºä¸è¿è¡ŒçŠ¶æ€ï¼Œç„¶åç«‹å³è°ƒç”¨dropgå®Œæˆå·¥ä½œã€‚è°ƒç”¨è€…è¿˜è´Ÿè´£å®‰æ’gpåœ¨é€‚å½“çš„æ—¶é—´ä½¿ç”¨readyé‡æ–°å¯åŠ¨ã€‚ åœ¨è°ƒç”¨dropgå¹¶å®‰æ’ç¨åå‡†å¤‡å¥½gpä¹‹åï¼Œè°ƒç”¨è€…å¯ä»¥åšå…¶ä»–å·¥ä½œï¼Œä½†æœ€ç»ˆåº”è¯¥è°ƒç”¨scheduleæ¥é‡æ–°å¯åŠ¨è¿™ä¸ªmä¸Šçš„goroutineçš„è°ƒåº¦ã€‚ æ–‡ä»¶ä½ç½®ï¼šgo1.19.3/src/runtime/proc.goã€‚ 3255 3256 3257 3258 3259 3260 3261 3262 3263 3264 3265 3266 3267 3268 3269 // dropg removes the association between m and the current goroutine m-\u0026gt;curg (gp for short). // Typically a caller sets gp\u0026#39;s status away from Grunning and then // immediately calls dropg to finish the job. The caller is also responsible // for arranging that gp will be restarted using ready at an // appropriate time. After calling dropg and arranging for gp to be // readied later, the caller can do other work but eventually should // call schedule to restart the scheduling of goroutines on this m. func dropg() { _g_ := getg() // g0 // gp.m = nil setMNoWB(\u0026amp;_g_.m.curg.m, nil) // m.curg = nil setGNoWB(\u0026amp;_g_.m.curg, nil) } setMNoWB() æ–‡ä»¶ä½ç½®ï¼šgo1.19.3/src/runtime/runtime2.goã€‚ 307 308 309 310 311 312 313 314 // setMNoWB performs *mp = new without a write barrier. // For times when it\u0026#39;s impractical to use an muintptr. // //go:nosplit //go:nowritebarrier func setMNoWB(mp **m, new *m) { (*muintptr)(unsafe.Pointer(mp)).set(new) // *mp = new } setGNoWB() æ–‡ä»¶ä½ç½®ï¼šgo1.19.3/src/runtime/runtime2.goã€‚ 273 274 275 276 277 278 279 280 // setGNoWB performs *gp = new without a write barrier. // For times when it\u0026#39;s impractical to use a guintptr. // //go:nosplit //go:nowritebarrier func setGNoWB(gp **g, new *g) { (*guintptr)(unsafe.Pointer(gp)).set(new) // *gp = new } globrunqput() æŠŠgpæ”¾åˆ°å…¨å±€å¯è¿è¡Œé˜Ÿåˆ—ä¸­ã€‚sched.lockå¿…é¡»è¢«æŒæœ‰ã€‚ å¯èƒ½åœ¨STWæœŸé—´è¿è¡Œï¼Œå› æ­¤ä¸å…è®¸å†™å±éšœã€‚ æ–‡ä»¶ä½ç½®ï¼šgo1.19.3/src/runtime/proc.goã€‚ 5563 5564 5565 5566 5567 5568 5569 5570 5571 5572 5573 5574 5575 // Put gp on the global runnable queue. // sched.lock must be held. // May run during STW, so write barriers are not allowed. // //go:nowritebarrierrec func globrunqput(gp *g) { // sched.lock é”å¿…é¡»è¢«æŒæœ‰ assertLockHeld(\u0026amp;sched.lock) // gp åŠ å…¥å…¨å±€é˜Ÿåˆ—ä¸­ sched.runq.pushBack(gp) sched.runqsize++ } ","permalink":"https://heliu.site/posts/golang/goroutine/gosched/","summary":"Golang runtime.Gosched()å‡½æ•°ä¸»åŠ¨è®©å‡ºCPUä»‹ç»ã€‚","title":"ä¸»åŠ¨è®©å‡ºè°ƒåº¦"},{"content":" æŠ¢å è°ƒåº¦ï¼ˆgoroutineå› è¿è¡Œæ—¶é—´è¿‡é•¿ï¼‰ã€‚ æŠ¢å è°ƒåº¦ï¼šå› goroutineè¿è¡Œæ—¶é—´è¿‡é•¿è€Œå‘ç”Ÿçš„ã€‚ goroutineå› è¯»å†™channelç­‰é˜»å¡è€Œå¯¼è‡´çš„è¢«åŠ¨è°ƒåº¦ï¼Œä»¥åŠé€šè¿‡è°ƒç”¨Gosched()å‡½æ•°å‘èµ·çš„ä¸»åŠ¨è°ƒåº¦ã€‚ æŠ¢å æ ‡è¯† retake() _Prunningï¼Œè¡¨ç¤ºå¯¹åº”çš„goroutineæ­£åœ¨è¿è¡Œï¼Œå¦‚æœå…¶è¿è¡Œæ—¶é—´è¶…è¿‡äº†10æ¯«ç§’åˆ™å¯¹éœ€è¦æŠ¢å ã€‚ _Psyscallï¼Œè¡¨ç¤ºå¯¹åº”çš„goroutineæ­£åœ¨å†…æ ¸æ‰§è¡Œç³»ç»Ÿè°ƒç”¨ï¼Œæ­¤æ—¶éœ€è¦æ ¹æ®å¤šä¸ªæ¡ä»¶æ¥åˆ¤æ–­æ˜¯å¦éœ€è¦æŠ¢å ã€‚ è¯¥å‡½æ•°åªåœ¨sysmonç›‘æ§çº¿ç¨‹ä¸­è¢«è°ƒç”¨ã€‚ å‚æ•°now int64ï¼šå½“å‰æ—¶é—´ã€‚ è¿”å›å€¼uint32ï¼šå¤„äºç³»ç»Ÿè°ƒç”¨ä¸­éœ€è¦æŠ¢å Pçš„æ•°é‡ã€‚ æ–‡ä»¶ä½ç½®ï¼šgo1.19.3/src/runtime/proc.goã€‚ // forcePreemptNS is the time slice given to a G before it is // preempted. // // forcePreemptNS æ˜¯åœ¨Gè¢«æŠ¢å ä¹‹å‰ç»™å®ƒçš„æ—¶é—´ç‰‡ã€‚ const forcePreemptNS = 10 * 1000 * 1000 // 10ms 5285 5286 5287 5288 5289 5290 5291 5292 5293 5294 5295 5296 5297 5298 5299 5300 5301 5302 5303 5304 5305 5306 5307 5308 5309 5310 5311 5312 5313 5314 5315 5316 5317 5318 5319 5320 5321 5322 5323 5324 5325 5326 5327 5328 5329 5330 5331 5332 5333 5334 5335 5336 5337 5338 5339 5340 5341 5342 5343 5344 5345 5346 5347 5348 5349 5350 5351 5352 5353 5354 5355 5356 5357 5358 5359 5360 5361 5362 5363 5364 5365 5366 5367 5368 5369 5370 5371 5372 5373 5374 5375 5376 5377 5378 5379 5380 5381 5382 5383 5384 5385 5386 5387 5388 5389 5390 5391 5392 5393 5394 5395 5396 5397 5398 5399 5400 5401 5402 5403 5404 5405 5406 5407 5408 5409 5410 5411 5412 5413 5414 5415 5416 5417 5418 5419 5420 5421 5422 5423 5424 5425 5426 5427 5428 5429 5430 5431 5432 5433 5434 5435 5436 5437 5438 5439 5440 5441 5442 5443 5444 5445 // æ£€æŸ¥æ‰€æœ‰çš„PæŸ¥çœ‹æ˜¯å¦å­˜åœ¨è¿è¡Œæ—¶é—´å¤ªé•¿çš„Géœ€è¦è®¾ç½®æŠ¢å è¯·æ±‚ã€‚ // 1. goroutineè¿è¡Œæ—¶é—´è¶…è¿‡10msæ—¶éœ€è¦æŠ¢å ã€‚ // 2. goroutineé™·å…¥ç³»ç»Ÿè°ƒç”¨ï¼Œè¿è¡Œæ—¶é—´è¶…è¿‡10msæˆ–åœ¨ç¬¬äºŒè½®æ¥æ˜¯sysmonç³»ç»Ÿè°ƒç”¨è¿˜æ²¡è¿”å›æ—¶ã€‚ // é™·å…¥ç³»ç»Ÿè°ƒç”¨è€ŒæŠ¢å Pçš„æƒ…å†µï¼š // 1. è¿è¡Œæ—¶é—´è¶…è¿‡10msï¼Œå¯èƒ½ä¸€å¼€å§‹å°±é™·å…¥ç³»ç»Ÿè°ƒç”¨ï¼Œæˆ–ä¸­é€”é™·å…¥ç³»ç»Ÿè°ƒç”¨ã€‚ä¸è®ºé‚£ç§æƒ…å†µéƒ½åº”è¯¥æŠ¢å ã€‚ // 2. è¿è¡Œæ—¶é—´æ²¡åˆ°10msï¼Œä½†æ˜¯ä¸¤è½®sysmonäº†è¿˜æ˜¯åœ¨ç³»ç»Ÿè°ƒç”¨ä¸­ï¼Œéœ€è¦æŠ¢å Pã€‚ func retake(now int64) uint32 { n := 0 // 1) é”ä½ allpï¼Œç°åœ¨éœ€è¦éå†æ‰€æœ‰çš„PæŸ¥çœ‹æ˜¯å¦å­˜åœ¨è¿è¡Œæ—¶é—´è¿‡é•¿è€Œéœ€è¦æŠ¢å çš„Gã€‚ // Prevent allp slice changes. This lock will be completely // uncontended unless we\u0026#39;re already stopping the world. // // é˜²æ­¢ allp åˆ‡ç‰‡æ›´æ”¹ã€‚ é™¤éæˆ‘ä»¬å·²ç»STWï¼Œå¦åˆ™è¿™æŠŠé”å°†æ˜¯å®Œå…¨æ— äººäº‰å¤ºçš„ lock(\u0026amp;allpLock) // allpåŠ é” // 2) éå†æ‰€æœ‰çš„Pï¼Œæ ¹æ®è¿è¡Œæ—¶é—´æ˜¯å¦è®¾ç½®æŠ¢å æ ‡å¿—ã€‚ // We can\u0026#39;t use a range loop over allp because we may // temporarily drop the allpLock. Hence, we need to re-fetch // allp each time around the loop. // // æˆ‘ä»¬ä¸èƒ½ä½¿ç”¨rangeæ¥éå†allpï¼Œå› ä¸ºæˆ‘ä»¬å¯èƒ½ä¼šæš‚æ—¶æ”¾å¼ƒallpLocké”ï¼ˆä¼šæš‚æ—¶è§£é”ï¼‰ã€‚ // å› æ­¤ï¼Œæˆ‘ä»¬éœ€è¦åœ¨æ¯æ¬¡å¾ªç¯ä¸­é‡æ–°è·å–allpã€‚ // rangeä¼šæ‹·è´ï¼Œå› æ­¤å¢é•¿æˆ–ç¼©å°äº†allpä¸ä¼šå®æ—¶å˜åŒ–ã€‚ for i := 0; i \u0026lt; len(allp); i++ { // éå†æ‰€æœ‰çš„P _p_ := allp[i] // 2.1) æœªåˆå§‹åŒ–çš„Pè·³è¿‡ã€‚å¯èƒ½æ­£åœ¨å¢é•¿Pã€‚ if _p_ == nil { // This can happen if procresize has grown // allp but not yet created new Ps. // // å¦‚æœprocresizeå·²ç»å¢é•¿äº†æ‰€æœ‰pï¼Œä½†è¿˜æ²¡æœ‰åˆ›å»ºæ–°çš„pï¼Œåˆ™å¯èƒ½å‘ç”Ÿè¿™ç§æƒ…å†µã€‚ continue } // 2.2) åˆ¤æ–­æ˜¯å¦è¿è¡Œæ—¶é—´è¿‡é•¿ // _p_.sysmontickç”¨äºsysmonçº¿ç¨‹è®°å½•è¢«ç›‘æ§pçš„ç³»ç»Ÿè°ƒç”¨æ—¶é—´å’Œè¿è¡Œæ—¶é—´ // type sysmontick struct { // schedtick uint32 // è°ƒåº¦å™¨è°ƒåº¦æ¬¡æ•° // schedwhen int64 // ä¸Šæ¬¡è°ƒåº¦æ—¶é—´ // // syscalltick uint32 // ç³»ç»Ÿè°ƒç”¨æ¬¡æ•° // syscallwhen int64 // ä¸Šæ¬¡è°ƒåº¦æ—¶é—´ // } pd := \u0026amp;_p_.sysmontick // ä¸sysmonçº¿ç¨‹ç›¸å…³ // _Prunningï¼šå¯¹åº”çš„goroutineæ­£åœ¨è¿è¡Œ // _Psyscallï¼šå¯¹åº”çš„goroutineæ­£åœ¨å†…æ ¸æ‰§è¡Œç³»ç»Ÿè°ƒç”¨ s := _p_.status // På½“å‰æ‰€å¤„çŠ¶æ€ _Prunningï¼Œ_Psyscall // æ ‡è®°å½“å‰Pæ˜¯å¦å·²è®¾ç½®æŠ¢å è¯·æ±‚ // false.æœªè®¾ç½® true.å·²è®¾ç½® sysretake := false // 2.3) å…ˆåˆ¤æ–­ schedtick å’Œ schedwhen æ—¶é—´æ˜¯å¦è¿è¡Œæ—¶é—´è¿‡é•¿ã€‚ // Gçš„è¿è¡Œæ—¶é—´æ˜¯åŒ…æ‹¬ç³»ç»Ÿè°ƒç”¨çš„æ—¶é—´çš„ã€‚ if s == _Prunning || s == _Psyscall { // Preempt G if it\u0026#39;s running for too long.\t// // å¦‚æœGè¿è¡Œå¤ªä¹…ï¼Œå°±æŠ¢å å®ƒã€‚ // _p_.schedtickè°ƒåº¦æ¬¡æ•°ï¼Œè¯¥å€¼æ˜¯åœ¨Pä¸Šçš„ï¼Œè®°å½•å½“å‰çš„è°ƒåº¦æ¬¡æ•°ã€‚ // æ³¨æ„åŒºåˆ«sysmontickä¸Šçš„schedtick t := int64(_p_.schedtick) // _p_.schedtickï¼šæ¯å‘ç”Ÿä¸€æ¬¡è°ƒåº¦ï¼Œè°ƒåº¦å™¨++è¯¥å€¼ // pd.schedtick == tè¯´æ˜(pd.schedwhenï½now)è¿™æ®µæ—¶é—´æœªå‘ç”Ÿè¿‡è°ƒåº¦ï¼ˆè¿™ç§æƒ…å†µä¹Ÿå°±æ˜¯æˆ‘ä»¬è¦å¤„ç†çš„æŠ¢å æƒ…å†µï¼‰ï¼Œ // æ‰€ä»¥è¿™æ®µæ—¶é—´æ˜¯åŒä¸€ä¸ªgoroutineä¸€ç›´åœ¨è¿è¡Œï¼Œä¸‹é¢æ£€æŸ¥ä¸€ç›´è¿è¡Œæ˜¯å¦è¶…è¿‡äº†10æ¯«ç§’ï¼Œå¦åˆ™åˆ™æ˜¯å‘ç”Ÿè¿‡è°ƒåº¦ if int64(pd.schedtick) != t { // å¦‚æœä¸ç›¸ç­‰è¯´æ˜æ˜¯ä¸€æ¬¡æ–°çš„è°ƒåº¦ // ç›‘æ§çº¿ç¨‹ç›‘æ§åˆ°ä¸€æ¬¡æ–°çš„è°ƒåº¦ï¼Œæ‰€ä»¥é‡ç½®è·Ÿsysmonç›¸å…³çš„schedtickå’Œschedwhenå˜é‡ // 2.4) æ£€æµ‹åˆ°ä¸‹æ¬¡è°ƒåº¦ï¼Œæ›´æ–°è°ƒåº¦æ—¶é—´ pd.schedtick = uint32(t) pd.schedwhen = now } else if pd.schedwhen+forcePreemptNS \u0026lt;= now { // 2.4) æœ¬æ¬¡è°ƒåº¦å·²è¶…è¿‡ 10msï¼Œè®¾ç½®æŠ¢å æ ‡è¯†ã€‚ // ä»æŸgoroutineç¬¬ä¸€æ¬¡è¢«sysmonçº¿ç¨‹ç›‘æ§åˆ°æ­£åœ¨è¿è¡Œä¸€ç›´è¿è¡Œåˆ°ç°åœ¨è¶…è¿‡äº†10æ¯«ç§’ // æŠ¢å ç”¨æˆ·ä»£ç çš„goroutineæ—¶æ˜¯éœ€è¦åˆ¤æ–­æ˜¯å¦èƒ½æŠ¢å çš„æ¡ä»¶çš„ã€‚ preemptone(_p_) // è®¾ç½®æŠ¢å è¯·æ±‚ï¼Œéç³»ç»Ÿè°ƒç”¨æ—¶åœ¨è¿™é‡Œåå°±ç»“æŸäº†ã€‚ // In case of syscall, preemptone() doesn\u0026#39;t // work, because there is no M wired to P. // // åœ¨ç³»ç»Ÿè°ƒç”¨çš„æƒ…å†µä¸‹ï¼Œpreemptone()ä¸èµ·ä½œç”¨ï¼Œå› ä¸ºMæ²¡æœ‰è¿æ¥åˆ°Pã€‚æ­¤æ—¶å·²ç»é™·å…¥åˆ°ç³»ç»Ÿè°ƒåº¦ä¸­ï¼Œä¸ä¼šå“åº”è¯·æ±‚ã€‚ sysretake = true // å·²æ ‡è®°äº†æŠ¢å  } // 2.4) æœ¬åœ°è°ƒåº¦è¿è¡Œæ—¶é—´è¿˜æœªåˆ°10msã€‚ } // 2.5) På¤„äºç³»ç»Ÿè°ƒç”¨ä¹‹ä¸­æ—¶ã€‚ if s == _Psyscall { // Retake P from syscall if it\u0026#39;s there for more than 1 sysmon tick (at least 20us). // // å¦‚æœPå­˜åœ¨è¶…è¿‡1ä¸ªsysmon tick(è‡³å°‘20us)ï¼Œåˆ™ä»sycallä¸­é‡æ–°å–Pã€‚ // _p_.syscalltickç”¨äºè®°å½•ç³»ç»Ÿè°ƒç”¨çš„æ¬¡æ•°ï¼Œä¸»è¦ç”±å·¥ä½œçº¿ç¨‹åœ¨å®Œæˆç³»ç»Ÿè°ƒç”¨ä¹‹å++ t := int64(_p_.syscalltick)\t// sysretake = falseï¼šå‰é¢æ²¡æœ‰è®¾ç½®æŠ¢å æ ‡å¿—ã€‚ // 1. æœ¬è½®è°ƒåº¦Gè¿˜æ²¡åˆ°è¾¾10msã€‚ // 2. æ–°çš„ä¸€è½®è°ƒåº¦ï¼Œå·²ç»é‡ç½®äº†ã€‚ // int64(pd.syscalltick) != tï¼šæ–°çš„ä¸€è½®ç³»ç»Ÿè°ƒåº¦äº†ã€‚ if !sysretake \u0026amp;\u0026amp; int64(pd.syscalltick) != t { pd.syscalltick = uint32(t) // update syscalltick pd.syscallwhen = now // update syscallwhen continue } // 2.6) sysretake == true || (sysretake == false \u0026amp;\u0026amp; int64(pd.syscalltick) == t) // 1. sysretake == trueï¼šå‰é¢å·²ç»è®¾ç½®äº†æŠ¢å è¯·æ±‚ï¼ŒGè¿è¡Œæ—¶é—´è¶…è¿‡äº†10msï¼Œç°åœ¨å¤„äºç³»ç»Ÿè°ƒç”¨ä¸­ã€‚ // 2. (sysretake == false \u0026amp;\u0026amp; int64(pd.syscalltick) == t)ï¼š // goroutineæ²¡æœ‰è¶…è¿‡10msï¼Œä½†æ˜¯ç›‘æ§å…ˆåˆ°ç¬¬äºŒè½®äº†ï¼Œç°åœ¨å¤„äºç³»ç»Ÿè°ƒç”¨ä¸­ã€‚ // å› æ­¤è¿™ç§æƒ…å†µå–å†³äºç›‘æ§çº¿ç¨‹çš„è°ƒåº¦æ—¶é—´é—´éš”ã€‚ // On the one hand we don\u0026#39;t want to retake Ps if there is no other work to do, // but on the other hand we want to retake them eventually // because they can prevent the sysmon thread from deep sleep. // // ä¸€æ–¹é¢æˆ‘ä»¬ä¸æƒ³åœ¨æ²¡æœ‰å…¶ä»–å·¥ä½œçš„æƒ…å†µä¸‹é‡æ–°è·å– Psï¼Œ // å¦ä¸€æ–¹é¢æˆ‘ä»¬å¸Œæœ›æœ€ç»ˆé‡æ–°è·å–å®ƒä»¬ï¼Œå› ä¸ºå®ƒä»¬å¯ä»¥é˜²æ­¢ sysmon çº¿ç¨‹æ·±åº¦ç¡çœ ã€‚ // åªè¦æ»¡è¶³ä¸‹é¢ä¸‰ä¸ªæ¡ä»¶ä¸­çš„ä»»æ„ä¸€ä¸ªï¼Œåˆ™æŠ¢å è¯¥pï¼Œå¦åˆ™ä¸æŠ¢å  // 1. pçš„è¿è¡Œé˜Ÿåˆ—é‡Œé¢æœ‰ç­‰å¾…è¿è¡Œçš„goroutineã€‚ï¼ˆæœ‰éœ€è¦è¿è¡Œçš„goroutineï¼Œéœ€è¦æŠ¢å Pï¼‰ // 2. æ²¡æœ‰æ— æ‰€äº‹äº‹çš„pï¼Œä¹Ÿå°±æ˜¯æ²¡æœ‰è‡ªæ—‹çš„Pæˆ–ç©ºé—²çš„Pã€‚ï¼ˆç³»ç»Ÿå¾ˆå¿™ï¼Œéœ€è¦æŠ¢å Pï¼‰ // 3. ä»ä¸Šä¸€æ¬¡ç›‘æ§çº¿ç¨‹è§‚å¯Ÿåˆ°på¯¹åº”çš„må¤„äºç³»ç»Ÿè°ƒç”¨ä¹‹ä¸­åˆ°ç°åœ¨å·²ç»è¶…è¿‡10äº†æ¯«ç§’ã€‚ï¼ˆç³»ç»Ÿè°ƒç”¨æ—¶é—´å¤ªé•¿ï¼Œéœ€è¦æŠ¢å Pï¼‰ if runqempty(_p_) \u0026amp;\u0026amp; atomic.Load(\u0026amp;sched.nmspinning)+atomic.Load(\u0026amp;sched.npidle) \u0026gt; 0 \u0026amp;\u0026amp; pd.syscallwhen+10*1000*1000 \u0026gt; now { // ä¸éœ€è¦æŠ¢å ï¼š_p_æœ¬åœ°é˜Ÿåˆ—ä¸ºç©º \u0026amp;\u0026amp; å­˜åœ¨è‡ªæ—‹æˆ–ç©ºé—²çš„Pï¼ˆç³»ç»Ÿä¸å¿™ï¼‰ \u0026amp;\u0026amp; ç³»ç»Ÿè°ƒç”¨æ—¶é—´è¿˜æ²¡æœ‰è¶…è¿‡äº†10ms continue } // Drop allpLock so we can take sched.lock. // // è¿™é‡Œæ˜¯å‰é¢ä¸èƒ½æœ‰for rangeçš„åŸå› ï¼Œè§£é”è¿™æ®µæ—¶é—´å¯èƒ½allpä¼šå‘ç”Ÿå˜åŒ–ã€‚ unlock(\u0026amp;allpLock) // è§£é” allpLock // Need to decrement number of idle locked M\u0026#39;s // (pretending that one more is running) before the CAS. // Otherwise the M from which we retake can exit the syscall, // increment nmidle and report deadlock. // // éœ€è¦åœ¨CASä¹‹å‰å‡å°‘ç©ºé—²é”å®šMçš„æ•°é‡(å‡è£…è¿˜æœ‰ä¸€ä¸ªæ­£åœ¨è¿è¡Œ)ã€‚ // å¦åˆ™ï¼Œæˆ‘ä»¬é‡æ–°è·å–çš„Må¯ä»¥é€€å‡ºç³»ç»Ÿè°ƒç”¨ï¼Œå¢åŠ nmidå¹¶æŠ¥å‘Šæ­»é”ã€‚ incidlelocked(-1) // sched.nmidlelocked += -1 // è¿™é‡Œä½¿ç”¨Casä¿®æ”¹Pçš„ä½¿ç”¨æƒï¼ŒåŸå› æ˜¯æ­¤æ—¶æ­¤åˆ»æ­£å¥½å­˜åœ¨ç³»ç»Ÿè°ƒç”¨è¿”å›äº†ï¼Œä¹Ÿæ­£åœ¨è·å–Pçš„ä½¿ç”¨æƒ // å¦‚æœä½¿ç”¨æƒè·å–æˆåŠŸåˆ™è°ƒç”¨handoffp()å¯»æ‰¾æ–°çš„å·¥ä½œçº¿ç¨‹æ¥æ¥ç®¡è¿™ä¸ªp // _Pidleï¼šç©ºé—²çŠ¶æ€ã€‚æ­¤æ—¶çš„Pæ²¡æœ‰è¢«ç”¨æ¥æ‰§è¡Œç”¨æˆ·ä»£ç æˆ–è°ƒåº¦å™¨ä»£ç ï¼Œé€šå¸¸ä½äºç©ºé—²é“¾è¡¨ä¸­ï¼Œèƒ½å¤Ÿè¢«è°ƒåº¦å™¨è·å–ï¼Œ // å®ƒçš„çŠ¶æ€å¯èƒ½æ­£åœ¨ç”±ç©ºé—²è½¬å˜æˆå…¶ä»–çŠ¶æ€ã€‚Pçš„æ‰€æœ‰æƒå½’ç©ºé—²é“¾è¡¨æˆ–æŸä¸ªæ­£åœ¨æ”¹å˜å®ƒçŠ¶æ€çš„çº¿ç¨‹æ‰€æœ‰ï¼Œæœ¬åœ°runqä¸ºç©ºã€‚ if atomic.Cas(\u0026amp;_p_.status, s, _Pidle) { if trace.enabled { traceGoSysBlock(_p_) traceProcStop(_p_) } n++ _p_.syscalltick++ // ç³»ç»Ÿè°ƒåº¦æ¬¡æ•°åŠ ä¸€ // å°è¯•å¯»æ‰¾ä¸€ä¸ªæ–°çš„må‡ºæ¥æ¥ç®¡P // æŠ¢å é™·å…¥ç³»ç»Ÿè°ƒç”¨çš„Pæ—¶ï¼Œæ²¡æœ‰å¤šä½™çš„æ¡ä»¶ handoffp(_p_)\t} incidlelocked(1) lock(\u0026amp;allpLock) } } unlock(\u0026amp;allpLock) return uint32(n) } incidlelocked() æ–‡ä»¶ä½ç½®ï¼šgo1.19.3/src/runtime/proc.goã€‚ 5505 5506 5507 5508 5509 5510 5511 5512 5513 5514 func incidlelocked(v int32) { lock(\u0026amp;sched.lock) // nmidlelocked é”å®šç­‰å¾…å·¥ä½œçš„Mçš„æ•°é‡ // åªä¼šåœ¨è¯¥å‡½æ•°ä¸­åŠ å‡ï¼Œåœ¨checkdead()å‡½æ•°ä¸­åˆ¤æ–­ sched.nmidlelocked += v if v \u0026gt; 0 { checkdead() } unlock(\u0026amp;sched.lock) } preemptone() sysmonçº¿ç¨‹å¦‚æœç›‘æ§åˆ°æŸä¸ªgoroutineè¿ç»­è¿è¡Œè¶…è¿‡äº†10æ¯«ç§’ï¼Œåˆ™ä¼šè°ƒç”¨preemptone()å‡½æ•°å‘è¯¥goroutineå‘å‡ºæŠ¢å è¯·æ±‚ã€‚ å‘Šè¯‰åœ¨å¤„ç†å™¨Pä¸Šè¿è¡Œçš„goroutineåœæ­¢ã€‚ è¿™ä¸ªå‡½æ•°åªæ˜¯å°½äº†æœ€å¤§åŠªåŠ›ã€‚å®ƒå¯èƒ½ä¼šé”™è¯¯åœ°æ²¡æœ‰é€šçŸ¥goroutineã€‚ä¹Ÿå¯èƒ½ä¼šé€šçŸ¥é”™è¯¯çš„goroutineã€‚ å³ä½¿å®ƒé€šçŸ¥äº†æ­£ç¡®çš„goroutineï¼Œå¦‚æœgoroutineåŒæ—¶æ‰§è¡Œnewstackï¼Œå®ƒå¯èƒ½ä¼šå¿½ç•¥è¯·æ±‚ã€‚ ä¸éœ€è¦é”ã€‚å¦‚æœå‘å‡ºæŠ¢å è¯·æ±‚ï¼Œåˆ™è¿”å›trueã€‚ å®é™…çš„æŠ¢å å°†åœ¨æœªæ¥çš„æŸä¸ªæ—¶é—´ç‚¹å‘ç”Ÿï¼Œå¹¶ä¸”å°†ç”±gp-\u0026gt;statusä¸å†æ˜¯Grunningè¡¨ç¤ºã€‚è®¾ç½®æŠ¢å è¯·æ±‚ã€‚ è¯¥å‡½æ•°ä¼šåœ¨retake()å‡½æ•°ä¸­è°ƒç”¨ï¼ŒGCæœŸé—´è°ƒç”¨ã€‚ å¯ä»¥çœ‹å‡ºï¼Œpreemptoneå‡½æ•°åªæ˜¯ç®€å•çš„è®¾ç½®äº†è¢«æŠ¢å goroutineå¯¹åº”çš„gç»“æ„ä½“ä¸­çš„ preemptæˆå‘˜ä¸ºtrueå’Œstackguard0æˆå‘˜ä¸ºstackPreemptï¼ˆstackPreemptæ˜¯ä¸€ä¸ªå¸¸é‡0xfffffffffffffadeï¼Œæ˜¯éå¸¸å¤§çš„ä¸€ä¸ªæ•°ï¼‰å°±è¿”å›äº†ï¼Œå¹¶æœªçœŸæ­£å¼ºåˆ¶è¢«æŠ¢å çš„goroutineæš‚åœä¸‹æ¥ã€‚ æ—¢ç„¶è®¾ç½®äº†ä¸€äº›æŠ¢å æ ‡å¿—ï¼Œé‚£ä¹ˆå°±ä¸€å®šéœ€è¦å¯¹è¿™äº›æ ‡å¿—è¿›è¡Œå¤„ç†ï¼Œä¸‹é¢æˆ‘ä»¬å°±æ¥åˆ†æè¢«æŠ¢å çš„goroutineå¦‚ä½•å¤„ç†è¿™äº›æ ‡å¿—å»å“åº”ç›‘æ§çº¿ç¨‹æå‡ºçš„æŠ¢å è¯·æ±‚ã€‚ æ–‡ä»¶ä½ç½®ï¼šgo1.19.3/src/runtime/proc.goã€‚ 5378 5379 5380 5381 5382 5383 5384 5385 5386 5387 5388 5389 5390 5391 5392 5393 5394 5395 5396 5397 5398 5399 5400 5401 5402 5403 5404 5405 5406 5407 5408 5409 5410 5411 5412 5413 5414 5415 5416 5417 5418 5419 5420 5421 5422 5423 5424 5425 5426 5427 5428 5429 5430 5431 5432 5433 5434 5435 // Tell the goroutine running on processor P to stop. // This function is purely best-effort. It can incorrectly fail to inform the // goroutine. It can inform the wrong goroutine. Even if it informs the // correct goroutine, that goroutine might ignore the request if it is // simultaneously executing newstack. // No lock needs to be held. // Returns true if preemption request was issued. // The actual preemption will happen at some point in the future // and will be indicated by the gp-\u0026gt;status no longer being // Grunning func preemptone(_p_ *p) bool { // 1) æŠ¢å Pçš„å…³è”çš„m mp := _p_.m.ptr() // mp := m // 2) æŠ¢å çš„Pæ²¡æœ‰ç»‘å®šMï¼Œæˆ–æŠ¢å çš„Pçš„Mä¸å½“å‰è¿è¡ŒGçš„Mä¸€è‡´ã€ä¸è®¾ç½®æŠ¢å æ ‡å¿—ã€‘ // 1. mp == nilï¼šå¯èƒ½æ¥è‡ªsysmonæŠ¢å ç©ºé—²çš„Pçš„æ—¶å€™ï¼Œè¿™æ—¶å€™Pæ˜¯æ²¡æœ‰ç»‘å®šMçš„ã€‚ // 2. mp == getg().mï¼šæŠ¢å çš„æ˜¯è‡ªå·±ï¼Œå¾ˆå¤§å¯èƒ½è¿™ç§æƒ…å†µæ¥è‡ªGCåœ¨ç­‰å¾…å…¶ä»–Påœä¸‹æ¥çš„æ—¶å€™ã€‚ if mp == nil || mp == getg().m { return false } // 3) æŠ¢å çš„å·¥ä½œçº¿ç¨‹åˆšå¥½å¤„ç†å®Œgoroutineï¼Œæˆ–æŠ¢å çš„å·¥ä½œçº¿ç¨‹æ­£åœ¨g0ä¸­ã€ä¸è®¾ç½®æŠ¢å æ ‡å¿—ã€‘ gp := mp.curg // mpå·¥ä½œçº¿ç¨‹ä¸Šæ­£åœ¨è¿è¡Œçš„goroutine // 1. gp == nilï¼šå½“å‰å·¥ä½œçº¿ç¨‹æ­£åœ¨æ‰§è¡Œçš„goroutineåˆšå¥½è¿è¡Œå®Œè¢«è°ƒç¦»Mæ—¶ã€‚ // 2. gp == mp.g0ï¼šå½“å‰æ­£åœ¨g0ä¸Šï¼Œå¯èƒ½åœ¨æ‰§è¡Œè°ƒåº¦ä»£ç ã€‚ if gp == nil || gp == mp.g0 { return false } gp.preempt = true // æ ‡è®°æ­£åœ¨è¿è¡Œçš„Pçš„gè®¾ç½®æŠ¢å æ ‡å¿— // Every call in a goroutine checks for stack overflow by // comparing the current stack pointer to gp-\u0026gt;stackguard0. // Setting gp-\u0026gt;stackguard0 to StackPreempt folds // preemption into the normal stack overflow check. // // goroutineä¸­çš„æ¯ä¸ªè°ƒç”¨éƒ½é€šè¿‡å°†å½“å‰å †æ ˆæŒ‡é’ˆä¸gp-\u0026gt;stackguard0è¿›è¡Œæ¯”è¾ƒæ¥æ£€æŸ¥å †æ ˆæº¢å‡ºã€‚ // è®¾ç½®gp-\u0026gt;stackguard0ä¸ºStackPreemptå°†æŠ¢å è½¬æ¢ä¸ºæ­£å¸¸çš„æ ˆæº¢å‡ºæ£€æŸ¥ã€‚ // stackPreemptæ˜¯ä¸€ä¸ªå¸¸é‡0xfffffffffffffadeï¼Œæ˜¯éå¸¸å¤§çš„ä¸€ä¸ªæ•°ã€‚ gp.stackguard0 = stackPreempt // è®¾ç½®stackguard0ä½¿è¢«æŠ¢å çš„goroutineå»å¤„ç†æŠ¢å è¯·æ±‚ // Request an async preemption of this P. // // è¯·æ±‚è¿™ä¸ªPçš„å¼‚æ­¥æŠ¢å ã€‚è¿™ç§æƒ…å†µæ˜¯å¯¹äºæ²¡æœ‰è°ƒç”¨ä»»ä½•å‡½æ•°çš„goroutineï¼Œæ²¡æœ‰æŠ¢å æœºä¼šçš„æƒ…å†µä¸‹ã€‚ // 1. preemptMSupportedï¼šå…¶ä¸­çš„ preemptMSupported æ˜¯ä¸ªå¸¸é‡ï¼Œå› ä¸ºå—ç¡¬ä»¶ç‰¹æ€§çš„é™åˆ¶ï¼Œ // åœ¨æŸäº›å¹³å°ä¸Šæ˜¯æ— æ³•æ”¯æŒè¿™ç§æŠ¢å çš„ã€‚ // 2. debug.asyncpreemptoffï¼šåˆ™æ˜¯è®©ç”¨æˆ·å¯ä»¥é€šè¿‡ GODEBUG ç¯å¢ƒå˜é‡æ¥ç¦ç”¨å¼‚æ­¥æŠ¢å ï¼Œ // é»˜è®¤æƒ…å†µä¸‹æ˜¯è¢«å¯ç”¨çš„ã€‚ if preemptMSupported \u0026amp;\u0026amp; debug.asyncpreemptoff == 0 { // åœ¨Pçš„æ•°æ®ç»“æ„ä¸­ä¹Ÿæ–°å¢äº†ä¸€ä¸ªpreemptå­—æ®µï¼Œè¿™é‡Œä¼šæŠŠå®ƒè®¾ç½®ä¸ºtrueã€‚ _p_.preempt = true // å®é™…ä¸ŠæŠ¢å æ“ä½œæ˜¯ç”± preemptM å‡½æ•°å®Œæˆçš„ã€‚ preemptM(mp)\t// è¯¥å‡½æ•°å‘èµ·å¼‚æ­¥æŠ¢å ç»™MPå‘é€æŠ¢å ä¿¡å· } return true } handoffp() ä»ç³»ç»Ÿè°ƒç”¨ä¸­å…³é—­Pæˆ–é”å®šMã€‚æ€»æ˜¯åœ¨æ²¡æœ‰Pçš„æƒ…å†µä¸‹è¿è¡Œï¼Œå› æ­¤ä¸å…è®¸æœ‰å†™å±éšœã€‚ handoffp()å‡½æ•°ä¸»è¦ä»»åŠ¡æ˜¯é€šè¿‡å„ç§æ¡ä»¶åˆ¤æ–­æ˜¯å¦éœ€è¦å¯åŠ¨å·¥ä½œçº¿ç¨‹æ¥æ¥ç®¡_p_ï¼Œå¦‚æœä¸éœ€è¦åˆ™æŠŠ_p_æ”¾å…¥Pçš„å…¨å±€ç©ºé—²é˜Ÿåˆ—ã€‚ _p_çš„æœ¬åœ°è¿è¡Œé˜Ÿåˆ—æˆ–å…¨å±€è¿è¡Œé˜Ÿåˆ—é‡Œé¢æœ‰å¾…è¿è¡Œçš„goroutineã€‚ éœ€è¦å¸®åŠ©gcå®Œæˆæ ‡è®°å·¥ä½œã€‚ ç³»ç»Ÿæ¯”è¾ƒå¿™ï¼Œæ‰€æœ‰å…¶å®ƒ_p_éƒ½åœ¨è¿è¡Œgoroutineï¼Œéœ€è¦å¸®å¿™ã€‚ æ‰€æœ‰å…¶å®ƒPéƒ½å·²ç»å¤„äºç©ºé—²çŠ¶æ€ï¼Œå¦‚æœéœ€è¦ç›‘æ§ç½‘ç»œè¿æ¥è¯»å†™äº‹ä»¶ï¼Œåˆ™éœ€è¦å¯åŠ¨æ–°çš„mæ¥pollç½‘ç»œè¿æ¥ã€‚ æ–‡ä»¶ä½ç½®ï¼šgo1.19.3/src/runtime/proc.goã€‚ 2350 2351 2352 2353 2354 2355 2356 2357 2358 2359 2360 2361 2362 2363 2364 2365 2366 2367 2368 2369 2370 2371 2372 2373 2374 2375 2376 2377 2378 2379 2380 2381 2382 2383 2384 2385 2386 2387 2388 2389 2390 2391 2392 2393 2394 2395 2396 2397 2398 2399 2400 2401 2402 2403 2404 2405 2406 2407 2408 2409 2410 2411 2412 2413 2414 2415 2416 2417 2418 2419 2420 2421 2422 2423 2424 2425 2426 2427 2428 2429 2430 2431 2432 2433 2434 2435 2436 2437 2438 2439 // Hands off P from syscall or locked M. // Always runs without a P, so write barriers are not allowed. // //go:nowritebarrierrec func handoffp(_p_ *p) { // handoffp must start an M in any situation where // findrunnable would return a G to run on _p_. // // åœ¨findrunnableè¿”å›Gå¹¶åœ¨_p_ä¸Šè¿è¡Œçš„ä»»ä½•æƒ…å†µä¸‹ï¼Œhandffpå¿…é¡»å¼€å§‹ä¸€ä¸ªMã€‚ // if it has local work, start it straight away // // å¦‚æœå®ƒæœ‰æœ¬åœ°å·¥ä½œï¼Œéœ€è¦å¯åŠ¨mæ¥æ¥ç®¡ if !runqempty(_p_) || sched.runqsize != 0 { startm(_p_, false) // åˆ›å»ºMæ¥æ¥ç®¡P return } // if there\u0026#39;s trace work to do, start it straight away if (trace.enabled || trace.shutdown) \u0026amp;\u0026amp; traceReaderAvailable() { startm(_p_, false) return } // if it has GC work, start it straight away // // GCæ­£åœ¨å·¥ä½œï¼Œä¹Ÿéœ€è¦å¯åŠ¨mæ¥æ¥ç®¡ if gcBlackenEnabled != 0 \u0026amp;\u0026amp; gcMarkWorkAvailable(_p_) { startm(_p_, false) return } // no local work, check that there are no spinning/idle M\u0026#39;s, // otherwise our help is not required // // æ²¡æœ‰æœ¬åœ°å·¥ä½œï¼Œæ£€æŸ¥æ˜¯å¦æœ‰ spinning/idle çš„Mï¼Œå¦åˆ™ä¸éœ€è¦æˆ‘ä»¬çš„å¸®åŠ©ã€‚ // 1. atomic.Load(\u0026amp;sched.nmspinning)+atomic.Load(\u0026amp;sched.npidle) == 0ï¼šæ²¡æœ‰è‡ªæ—‹çš„Må’Œç©ºé—²çš„Pæ—¶ã€‚ // 2. atomic.Cas(\u0026amp;sched.nmspinning, 0, 1)ï¼šsched.nmspinning = 1ã€‚ if atomic.Load(\u0026amp;sched.nmspinning)+atomic.Load(\u0026amp;sched.npidle) == 0 \u0026amp;\u0026amp; atomic.Cas(\u0026amp;sched.nmspinning, 0, 1) { // TODO: fast atomic startm(_p_, true) // è¿™æ—¶å€™å¯åŠ¨çš„Mç»‘å®šPå¯ä»¥èµ·å»å…¶ä»–Pä¸­å·å–ä»»åŠ¡ï¼Œå¦‚æœå­˜åœ¨ç©ºé—²çš„Påˆ™è¡¨ç¤ºå…¶ä»–Pä¸å¿™ return } lock(\u0026amp;sched.lock) // GCæ­£åœ¨STWç­‰å¾…æ—¶ã€‚ if sched.gcwaiting != 0 { _p_.status = _Pgcstop // ä¿®æ”¹çŠ¶æ€ä¸ºGCè€Œåœä¸‹ sched.stopwait-- // å› ä¸ºGCè€Œåœä¸‹æ¥ // å½“å‰STWè¦æ±‚çš„På…¨éƒ¨åœä¸‹æ¥æ—¶ï¼Œå°±å¯ä»¥å”¤é†’ç­‰å¾…åœ¨sched.stopnoteä¸Šçš„å‘èµ·STWçš„çº¿ç¨‹äº†ã€‚ if sched.stopwait == 0 { notewakeup(\u0026amp;sched.stopnote) } unlock(\u0026amp;sched.lock) return } if _p_.runSafePointFn != 0 \u0026amp;\u0026amp; atomic.Cas(\u0026amp;_p_.runSafePointFn, 1, 0) { sched.safePointFn(_p_) sched.safePointWait-- if sched.safePointWait == 0 { notewakeup(\u0026amp;sched.safePointNote) } } // å…¨å±€é˜Ÿåˆ—æ± æœ‰Géœ€è¦å¤„ç†æ—¶ã€‚ if sched.runqsize != 0 { unlock(\u0026amp;sched.lock) startm(_p_, false) return } // If this is the last running P and nobody is polling network, // need to wakeup another M to poll network. // // å¦‚æœè¿™æ˜¯æœ€åä¸€ä¸ªè¿è¡Œçš„På¹¶ä¸”æ²¡æœ‰å…¶ä»–çº¿ç¨‹åœ¨é˜»å¡å¼ç­‰å¾…netpollï¼Œéœ€è¦å”¤é†’ä¸€ä¸ªMæ¥å¤„ç†netpollã€‚ // 1. sched.npidle == uint32(gomaxprocs-1)ï¼šå½“å‰æ˜¯æœ€åä¸€ä¸ªç©ºé—²P // 2. atomic.Load64(\u0026amp;sched.lastpoll) != 0ï¼šæ²¡æœ‰å…¶ä»–çº¿ç¨‹åœ¨é˜»å¡å¼è®¿é—®netpollã€‚ if sched.npidle == uint32(gomaxprocs-1) \u0026amp;\u0026amp; atomic.Load64(\u0026amp;sched.lastpoll) != 0 { unlock(\u0026amp;sched.lock) startm(_p_, false) return } // The scheduler lock cannot be held when calling wakeNetPoller below // because wakeNetPoller may call wakep which may call startm. // // å½“è°ƒç”¨wakeNetPolleræ—¶ï¼Œè°ƒåº¦å™¨é”ä¸èƒ½ä¿æŒï¼Œå› ä¸ºwakeNetPollerå¯èƒ½ä¼šè°ƒç”¨wakeepï¼Œè€Œåè€…å¯èƒ½ä¼šè°ƒç”¨startmã€‚ when := nobarrierWakeTime(_p_) // æœ€æ–°timerè§¦å‘æ—¶é—´ç‚¹ pidleput(_p_, 0) //æ— äº‹å¯åšï¼ŒæŠŠpæ”¾å…¥å…¨å±€ç©ºé—²é˜Ÿåˆ— unlock(\u0026amp;sched.lock) if when != 0 { wakeNetPoller(when) } // èµ°åˆ°è¿™é‡Œä¸ä¼šæŠ¢å P } å“åº”æŠ¢å è¯·æ±‚ æŠ¢å çš„ç›¸å…³å‡½æ•°è°ƒç”¨é“¾morestack_noctxt()-\u0026gt;morestack()-\u0026gt;newstack()ã€‚ ä»æºä»£ç ä¸­morestack()å‡½æ•°çš„æ³¨é‡Šå¯ä»¥çŸ¥é“ï¼Œè¯¥å‡½æ•°ä¼šè¢«ç¼–è¯‘å™¨è‡ªåŠ¨æ’å…¥åˆ°å‡½æ•° åºè¨€(prologue) ä¸­ã€‚ morestack_noctxt() æ–‡ä»¶ä½ç½®ï¼šgo1.19.3/src/runtime/asm_amd64.sã€‚ 574 575 576 577 # morestack but not preserving ctxt. TEXT runtimeÂ·morestack_noctxt(SB),NOSPLIT,$0 MOVL $0, DX # DX = 0ï¼ŒDXå¯„å­˜å™¨è¢«ç”¨ä½œå‡½æ•°è°ƒç”¨çš„éšè—ä¼ å€¼ JMP\truntimeÂ·morestack(SB) # æ³¨æ„è¿™é‡Œä½¿ç”¨çš„æ˜¯JMPä¸æ˜¯CALLå› æ­¤ä¸æ˜¯å‡½æ•°è°ƒç”¨ æˆ‘ä»¬å‡è®¾æ˜¯åœ¨main.mainå‡½æ•°åºè¨€ä¸­è°ƒç”¨äº†morestack_noctxt()å‡½æ•°ï¼Œåˆ™å‡½æ•°çš„æ ˆå¸§ç»“æ„å¦‚ä¸‹ï¼š // +10 | // ---------------------------- runtime.main SP // +08 | runtime.main callback // ---------------------------- main.main SP // +00 | main.main callback // ---------------------------- morestack_noctxt SP // // runtimeÂ·morestack(SB)æ˜¯é€šè¿‡JMPè°ƒç”¨çš„ï¼Œæ‰€ä»¥æ²¡æœ‰é‡æ–°åˆ†é…æ ˆå¸§ morestack() å½“éœ€è¦æ›´å¤šæ ˆæ—¶ï¼Œåœ¨å‡½æ•°prologæœŸé—´è°ƒç”¨ã€‚ å›æº¯ä¾‹ç¨‹å°†g0ä¸Šçš„morestackè§†ä¸ºæ ˆçš„é¡¶éƒ¨(ä¾‹å¦‚ï¼Œmorestackè°ƒç”¨newstackè°ƒç”¨è°ƒåº¦å™¨è°ƒç”¨newmè°ƒç”¨gc)ï¼Œ å› æ­¤æˆ‘ä»¬å¿…é¡»è®°å½•å‚æ•°å¤§å°ã€‚ä¸ºæ­¤ï¼Œå®ƒæ²¡æœ‰å‚æ•°ã€‚ æ–‡ä»¶ä½ç½®ï¼šgo1.19.3/src/runtime/asm_amd64.sã€‚ è¯¥å‡½æ•°ï¼Œä¿æŠ¤è°ƒç”¨è€…ä¿¡æ¯ï¼Œåˆ‡æ¢åˆ°g0æ ˆè°ƒç”¨runtimeÂ·newstackæ–¹æ³•ã€‚ 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 # Called during function prolog when more stack is needed. # # The traceback routines see morestack on a g0 as being # the top of a stack (for example, morestack calling newstack # calling the scheduler calling newm calling gc), so we must # record an argument size. For that purpose, it has no arguments. TEXT runtimeÂ·morestack(SB),NOSPLIT,$0-0 # Cannot grow scheduler stack (m-\u0026gt;g0). get_tls(CX) # CX = \u0026amp;m.tls[1] MOVQ g(CX), BX # BX = m.tls[0] = g MOVQ g_m(BX), BX # BX = g.m MOVQ m_g0(BX), SI # SI = m.g0 CMPQ g(CX), SI # æ¯”è¾ƒå½“å‰gæ˜¯å¦æ˜¯g0 JNE\t3(PC) # åˆ¤æ–­ä¸ä¸ºé›¶æ—¶åˆ™è·³è½¬ # runtimeÂ·badmorestackg0 é”™è¯¯ä¿¡æ¯ \u0026#34;morestack()å‡½æ•°åœ¨g0æ ˆä¸Šè¢«è°ƒç”¨\u0026#34; CALL runtimeÂ·badmorestackg0(SB) # int 3 è¿›å…¥ä¸­æ–­æŒ‡ä»¤ï¼Œè¿™æ˜¯ä¸€ä¸ªè°ƒè¯•æŒ‡ä»¤ CALL runtimeÂ·abort(SB) # Cannot grow signal stack (m-\u0026gt;gsignal). MOVQ m_gsignal(BX), SI # SI = m.gsignal CMPQ g(CX), SI JNE\t3(PC) # åˆ¤æ–­ä¸ä¸ºé›¶æ—¶åˆ™è·³è½¬ # runtimeÂ·badmorestackgsignal é”™è¯¯ä¿¡æ¯ \u0026#34;morestack()å‡½æ•°åœ¨gsignalä¸Šè¢«è°ƒç”¨\u0026#34; CALL runtimeÂ·badmorestackgsignal(SB) CALL runtimeÂ·abort(SB) # Called from f. # Set m-\u0026gt;morebuf to f\u0026#39;s caller. # # ä»fè°ƒç”¨ã€‚è®¾ç½®m-\u0026gt;morebufä¸ºfçš„è°ƒç”¨è€…ã€‚ # NOP SP æŒ‡ä»¤æ„ä¹‰ï¼š # 1. NOP SPæŒ‡ä»¤ä¸åšä»»ä½•æ“ä½œã€‚å…·ä½“æ¥è¯´ï¼Œå®ƒä¼šå°†å †æ ˆæŒ‡é’ˆ(SP)å‘åç§»åŠ¨0ä¸ªå­—èŠ‚ï¼Œè¿™å®é™…ä¸Šæ˜¯æ²¡æœ‰ä»»ä½•æ•ˆæœçš„ã€‚ # 2. åœ¨ Go çš„æ±‡ç¼–è¯­è¨€ä¸­ï¼Œæœ‰æ—¶éœ€è¦ä½¿ç”¨ \u0026#34;NOP SP\u0026#34; è¿™æ¡æŒ‡ä»¤æ¥è¿›è¡ŒæŒ‡ä»¤å¯¹é½ï¼Œä½†è¿™ä¹Ÿå¯èƒ½ä¼šå¯¼è‡´ vet å·¥å…·äº§ç”Ÿè¯¯æŠ¥ï¼Œå› ä¸ºå®ƒä¼šè®¤ä¸ºè¿™ä¼šå¯¼è‡´å †æ ˆåç§»é‡çš„æ”¹å˜ã€‚ # \u0026#34;# tell vet SP changed - stop checking offsets\u0026#34; è¿™è¡Œæ³¨é‡Šçš„æ„ä¹‰ï¼š # 1. ä¸ºäº†é¿å…è¿™ç§æƒ…å†µï¼Œç¨‹åºå‘˜å¯ä»¥æ·»åŠ è¿™ä¸ªæ³¨é‡Šæ¥å‘Šè¯‰vetå·¥å…·ï¼Œå®é™…ä¸Šæ²¡æœ‰å¯¹å †æ ˆåç§»é‡è¿›è¡Œä»»ä½•æ›´æ”¹ï¼Œå› æ­¤vetå·¥å…·å¯ä»¥åœæ­¢æ£€æŸ¥å †æ ˆåç§»é‡ã€‚ # 2. è¿™å¥è¯çš„æ„æ€æ˜¯ï¼Œç¨‹åºå‘˜åœ¨æ·»åŠ NOP SPæŒ‡ä»¤æ—¶é‡åˆ°äº†vetå·¥å…·çš„è¯¯æŠ¥é—®é¢˜ï¼Œä¸ºäº†è§£å†³è¿™ä¸ªé—®é¢˜ï¼Œä»–ä»¬æ·»åŠ äº†è¿™ä¸ªæ³¨é‡Šï¼Œå‘Šè¯‰vetå·¥å…·ä¸éœ€è¦ç»§ç»­æ£€æŸ¥å †æ ˆåç§»é‡ã€‚ # æŒ‡ä»¤å¯¹é½ï¼šæ˜¯æŒ‡å°†æŒ‡ä»¤åœ°å€å¯¹é½åˆ°ä¸€å®šçš„è¾¹ç•Œä¸Šï¼Œä½¿å¾—æŒ‡ä»¤çš„æ‰§è¡Œæ•ˆç‡æ›´é«˜ã€‚ # 1. åœ¨è®¡ç®—æœºç³»ç»Ÿä¸­ï¼ŒCPU é€šå¸¸éœ€è¦ä»å†…å­˜ä¸­è¯»å–æŒ‡ä»¤å¹¶æ‰§è¡Œå®ƒä»¬ï¼Œè¿™æ˜¯ä¸€ä¸ªéå¸¸è€—æ—¶çš„è¿‡ç¨‹ã€‚ # 2. ä¸ºäº†æé«˜æ‰§è¡Œæ•ˆç‡ï¼ŒCPU éœ€è¦åœ¨è®¿é—®å†…å­˜æ—¶ä¿æŒä¸€å®šçš„å¯¹é½æ–¹å¼ï¼Œä»¥ä¾¿æ›´å¿«åœ°è¯»å–æŒ‡ä»¤å¹¶è¿›è¡Œå¤„ç†ã€‚ # 3. åœ¨æŒ‡ä»¤å¯¹é½ä¸­ï¼ŒæŒ‡ä»¤åœ°å€é€šå¸¸è¢«è¦æ±‚å¯¹é½åˆ°ä¸€ä¸ªç‰¹å®šçš„è¾¹ç•Œï¼Œé€šå¸¸æ˜¯2çš„å¹‚æ¬¡æ–¹ï¼Œå¦‚2ã€4ã€8ç­‰ã€‚ # 4. è¿™æ„å‘³ç€æŒ‡ä»¤åœ°å€çš„ä½ä½å¿…é¡»æ˜¯0ï¼Œè¿™ä½¿å¾— CPU å¯ä»¥æ›´å¿«åœ°è¯»å–æŒ‡ä»¤å¹¶è¿›è¡Œå¤„ç†ï¼Œä»è€Œæé«˜ç¨‹åºçš„æ‰§è¡Œæ•ˆç‡ã€‚ # 5. åœ¨ç¼–å†™æ±‡ç¼–è¯­è¨€ç¨‹åºæ—¶ï¼Œç¨‹åºå‘˜é€šå¸¸éœ€è¦æ‰‹åŠ¨å¯¹æŒ‡ä»¤è¿›è¡Œå¯¹é½ã€‚è¿™å¯ä»¥é€šè¿‡æ·»åŠ ä¸€äº›æ— æ“ä½œæŒ‡ä»¤ï¼Œå¦‚NOPæŒ‡ä»¤ï¼Œæ¥å®ç°ã€‚ # 6. è¿™äº›æŒ‡ä»¤ä¸ä¼šå¯¹ç¨‹åºçš„æ‰§è¡Œäº§ç”Ÿä»»ä½•å½±å“ï¼Œåªæ˜¯ç”¨æ¥å¡«å……æŒ‡ä»¤æµä¸­çš„ç©ºéš™ï¼Œä»¥ç¡®ä¿æŒ‡ä»¤åœ°å€å¯¹é½ã€‚ # 7. è¿™äº›æ“ä½œå¯ä»¥å¸®åŠ© CPU æ›´å¿«åœ°è¯»å–æŒ‡ä»¤å¹¶æé«˜ç¨‹åºçš„æ‰§è¡Œæ•ˆç‡ã€‚ NOP\tSP\t# tell vet SP changed - stop checking offsets # ä»¥ä¸‹ä»£ç ä¿å­˜è°ƒç”¨è€…ä¿¡æ¯ï¼Œæ¯”å¦‚åœ¨main.mainçš„åºè¨€ä¸­è°ƒäº†morestack_noctxt()-\u0026gt;morestack()å‡½æ•°ï¼Œéœ€è¦ä¿å­˜çš„æ˜¯main.mainçš„ä¿¡æ¯ # 8(SP)ï¼šmainå‡½æ•°åœ¨è°ƒç”¨morestack_noctxtä¹‹å‰çš„rspå¯„å­˜å™¨ # é€šè¿‡ä¸Šé¢å‡½æ•°æ ˆå¸§çš„åˆ†é… 8(SP) æ˜¯runtime.mainå‡½æ•°çš„è¿”å›åœ°å€ï¼Œæ³¨æ„è¿™é‡Œæ˜¯ä¿å­˜åœ¨mä¸Šçš„ï¼Œm-\u0026gt;morebuf # ä¿å­˜åˆ°m-\u0026gt;morebufç”¨äºæä¾›ç»™æ¥ä¸‹æ¥çš„newstack()å‡½æ•°ä½¿ç”¨ MOVQ 8(SP), AX\t# f\u0026#39;s caller\u0026#39;s PC; MOVQ AX, (m_morebuf+gobuf_pc)(BX) # m.morebuf.gobuf.pc=AX # 16(SP)ï¼šè°ƒç”¨è€…å‡½æ•°çš„SPï¼Œä¹Ÿå°±æ˜¯runtime.mainçš„SPå¯„å­˜å™¨åœ°å€ï¼Œæ³¨æ„è¿™é‡Œæ˜¯ LEAQ æŒ‡ä»¤ LEAQ 16(SP), AX\t# f\u0026#39;s caller\u0026#39;s SP # AX = 16(SP); è¯¥å€¼æ˜¯runtime.mainå‡½æ•°çš„rspå¯„å­˜å™¨å­˜å‚¨çš„åœ°å€ MOVQ AX, (m_morebuf+gobuf_sp)(BX) # m.morebuf.gobuf.sp=AX get_tls(CX) # CX = \u0026amp;m.tls[1] MOVQ g(CX), SI # SI = m.tls[0] = g; è¿™é‡Œæ˜¯gï¼Œä¸æ˜¯g0 MOVQ SI, (m_morebuf+gobuf_g)(BX) # m.morebuf.gobuf.g = g # åˆ°è¿™é‡Œæˆ‘ä»¬å·²ç»åœ¨m-\u0026gt;morebufä¿å­˜å¥½äº†è°ƒç”¨è€…runtime.mainçš„ripã€rspã€gç›¸å…³ä¿¡æ¯ # Set g-\u0026gt;sched to context in f. # # å°† g-\u0026gt;sched è®¾ç½®ä¸ºfçš„ä¸Šä¸‹æ–‡ï¼Œè¿™æ‰æ˜¯éœ€è¦æ¢å¤çš„ç°åœºæ•°æ® # SPæ ˆé¡¶å¯„å­˜å™¨ç°åœ¨æŒ‡å‘çš„æ˜¯morestack_noctxtå‡½æ•°çš„è¿”å›åœ°å€ï¼Œæ³¨æ„ä¸‹é¢éƒ½æ˜¯ä¿å­˜åœ¨gä¸Šçš„ï¼Œg-\u0026gt;schedä¸æ˜¯g0ä¸Š # 0(SP)ï¼šé€šè¿‡ä¸Šé¢å‡½æ•°æ ˆå¸§çš„åˆ†é… 0(SP) æ˜¯main.mainå‡½æ•°çš„è¿”å›åœ°å€ï¼Œä¹Ÿå°±æ˜¯ripä¸­çš„å€¼å°±æ˜¯main.mainçš„ä¸‹æ¡ä»£ç åœ°å€ MOVQ 0(SP), AX # f\u0026#39;s PC # g.sched.gobuf.pc = AX MOVQ AX, (g_sched+gobuf_pc)(SI) # æ‰§è¡Œå®Œmorestack_noctxtå‡½æ•°ä¹‹ååº”è¯¥è¿”å›å»ç»§ç»­æ‰§è¡ŒæŒ‡ä»¤çš„åœ°å€ AX # 8(SP)ï¼šè°ƒç”¨è€…å‡½æ•°çš„SPï¼Œä¹Ÿå°±æ˜¯main.mainçš„SPå¯„å­˜å™¨åœ°å€ï¼Œè¿™ä¸ªåœ°å€æ˜¯æ²¡æœ‰å‹å…¥ripæŒ‡ä»¤æ•°æ®å‰çš„åœ°å€ï¼Œæ³¨æ„è¿™é‡Œæ˜¯ LEAQ æŒ‡ä»¤ LEAQ 8(SP), AX # f\u0026#39;s SP; MOVQ AX, (g_sched+gobuf_sp)(SI) # g.sched.gobuf.sp = AX # ç”±äºBPå¯„å­˜å™¨çš„å€¼ä¸€è‡´æ²¡æœ‰å˜ï¼Œæ‰€ä»¥è¿™é‡ŒBPå¯„å­˜å™¨è¿˜æ˜¯æŒ‡å‘main.mainçš„æ ˆåº• MOVQ BP, (g_sched+gobuf_bp)(SI) # g.sched.gobuf.bp = BP # DXå¯„å­˜å™¨è¢«è®¾ç½®ä¸ºäº†0ï¼Œåœ¨runtimeÂ·morestack_noctxt()å‡½æ•°ä¸­ MOVQ DX, (g_sched+gobuf_ctxt)(SI)# g.sched.gobuf.ctxt = DX; # åˆ°è¿™é‡Œå½“å‰g-\u0026gt;schedå·²ä¿å­˜å¥½äº†æ¢å¤åˆ°main.mainçš„ç°åœºï¼ŒåŒ…æ‹¬ripã€rspã€rbpã€rdx # Call newstack on m-\u0026gt;g0\u0026#39;s stack. # åˆ‡æ¢åˆ°g0æ ˆï¼Œå¹¶è®¾ç½®tlsçš„gä¸ºg0 MOVQ m_g0(BX), BX # BX = g0 # è®¾ç½®TLSä¸­çš„gä¸ºg0 MOVQ BX, g(CX) # m.tls[0] = g0 # æŠŠg0æ ˆçš„æ ˆé¡¶å¯„å­˜å™¨çš„å€¼æ¢å¤åˆ°CPUçš„å¯„å­˜å™¨ï¼Œè¾¾åˆ°åˆ‡æ¢æ ˆçš„ç›®çš„ï¼Œä¸‹é¢è¿™ä¸€æ¡æŒ‡ä»¤æ‰§è¡Œä¹‹å‰ï¼Œ # CPUè¿˜æ˜¯ä½¿ç”¨çš„è°ƒç”¨æ­¤å‡½æ•°çš„gçš„æ ˆï¼Œæ‰§è¡Œä¹‹åCPUå°±å¼€å§‹ä½¿ç”¨g0çš„æ ˆäº† MOVQ (g_sched+gobuf_sp)(BX), SP # rsp = g0.sched.gobuf.sp CALL runtimeÂ·newstack(SB) # è°ƒç”¨ newstack() å‡½æ•° CALL runtimeÂ·abort(SB) # crash if newstack returns RET æ±‡ç¼–è¯­è¨€\u0026quot;int 3\u0026quot;æ˜¯ä¸€ä¸ªä¸­æ–­æŒ‡ä»¤ï¼Œå®ƒå‘æ“ä½œç³»ç»Ÿå‘å‡ºä¸€ä¸ªè°ƒè¯•ä¿¡å·ï¼Œè¦æ±‚åœ¨ç¨‹åºçš„å½“å‰ä½ç½®åœæ­¢æ‰§è¡Œå¹¶è¿›å…¥è°ƒè¯•å™¨ã€‚ é€šå¸¸ï¼Œè°ƒè¯•å™¨ä¼šåœ¨æ­¤å¤„æš‚åœç¨‹åºçš„æ‰§è¡Œï¼Œå¹¶å…è®¸ç¨‹åºå‘˜æ£€æŸ¥ç¨‹åºçŠ¶æ€ã€å˜é‡å€¼å’Œç¨‹åºæµç¨‹ç­‰ä¿¡æ¯ï¼Œä»¥å¸®åŠ©ä»–ä»¬è°ƒè¯•ç¨‹åºã€‚ TEXT runtimeÂ·abort(SB),NOSPLIT,$0-0 INT\t$3 loop: JMP\tloop newstack() è¯¥å‡½æ•°ä¸»è¦æœ‰ä¸¤ä¸ªèŒè´£ï¼šä¸€ä¸ªæ˜¯ã€æ‰©æ ˆã€‘ï¼Œå¦ä¸€ä¸ªæ˜¯å“åº”sysmonæå‡ºçš„ã€æŠ¢å è¯·æ±‚ã€‘ã€‚ newstack()å‡½æ•°é¦–å…ˆæ£€æŸ¥g.stackguard0æ˜¯å¦è¢«è®¾ç½®ä¸ºstackPreemptï¼Œå¦‚æœæ˜¯åˆ™è¡¨ç¤ºsysmonå·²ç»å‘ç°æˆ‘ä»¬è¿è¡Œå¾—å¤ªä¹…äº†å¹¶å¯¹æˆ‘ä»¬å‘èµ·äº†æŠ¢å è¯·æ±‚ã€‚ å½“éœ€è¦æ›´å¤šå †æ ˆæ—¶ä»runtimeÂ·morestackè°ƒç”¨ã€‚åˆ†é…æ›´å¤§çš„å †æ ˆå¹¶é‡æ–°å®šä½åˆ°æ–°å †æ ˆã€‚å¯¹äºå›ºå®šçš„å¹³æ‘Šä»£ä»·ï¼Œå †æ ˆå¢é•¿æ˜¯ä¹˜æ³•çš„ã€‚ g-\u0026gt;atomicstatuså°†åœ¨è¿›å…¥æ—¶è¿›è¡ŒGrunningæˆ–Gscanrunningã€‚è°ƒåº¦ç¨‹åºè¯•å›¾åœæ­¢è¿™ä¸ªgï¼Œç„¶åå®ƒå°†è®¾ç½®preemptStopã€‚ è¿™å¿…é¡»æ˜¯nowritebarrierrecï¼Œå› ä¸ºå®ƒå¯ä»¥ä½œä¸ºå †æ ˆå¢é•¿çš„ä¸€éƒ¨åˆ†ä»å…¶ä»–nowritebarrierrecå‡½æ•°è°ƒç”¨ï¼Œä½†ç¼–è¯‘å™¨ä¸ä¼šæ£€æŸ¥è¿™ä¸€ç‚¹ã€‚ go:nowritebarrierrecï¼šç¼–è¯‘å™¨ä¸æ’å…¥å†™å±éšœç›¸å…³ä»£ç ï¼ŒåŒ…æ‹¬å½“å‰å‡½æ•°ä»¥åŠè°ƒç”¨çš„ä»»ä½•å‡½æ•°ä¸­ã€‚ æ–‡ä»¶ä½ç½®ï¼šgo1.19.3/src/runtime/stack.goã€‚ 950 951 952 953 954 955 956 957 958 959 960 961 962 963 964 965 966 967 968 969 970 971 972 973 974 975 976 977 978 979 980 981 982 983 984 985 986 987 988 989 990 991 992 993 994 995 996 997 998 999 1000 1001 1002 1003 1004 1005 1006 1007 1008 1009 1010 1011 1012 1013 1014 1015 1016 1017 1018 1019 1020 1021 1022 1023 1024 1025 1026 1027 1028 1029 1030 1031 1032 1033 1034 1035 1036 1037 1038 1039 1040 1041 1042 1043 1044 1045 1046 1047 1048 1049 1050 1051 1052 1053 1054 1055 1056 1057 1058 1059 1060 1061 1062 1063 1064 1065 1066 1067 1068 1069 1070 1071 1072 1073 1074 1075 1076 1077 1078 1079 1080 1081 1082 1083 1084 1085 1086 1087 1088 1089 1090 1091 1092 1093 1094 1095 1096 1097 1098 1099 1100 1101 1102 1103 1104 1105 1106 1107 1108 1109 1110 1111 1112 1113 1114 1115 1116 1117 1118 1119 1120 1121 1122 1123 1124 1125 1126 1127 1128 1129 1130 1131 1132 1133 1134 1135 1136 1137 1138 1139 1140 1141 1142 // Called from runtimeÂ·morestack when more stack is needed. // Allocate larger stack and relocate to new stack. // Stack growth is multiplicative, for constant amortized cost. // // g-\u0026gt;atomicstatus will be Grunning or Gscanrunning upon entry. // If the scheduler is trying to stop this g, then it will set preemptStop. // // This must be nowritebarrierrec because it can be called as part of // stack growth from other nowritebarrierrec functions, but the // compiler doesn\u0026#39;t check this. // //go:nowritebarrierrec func newstack() { thisg := getg() // thisg = g0; æ ¹æ®morestack()å‡½æ•°çš„ç›¸å…³ä»£ç  // TODO: double check all gp. shouldn\u0026#39;t be getg(). // // æ ¹æ®morestack()å‡½æ•°çš„ç›¸å…³ä»£ç ï¼Œè¿™é‡Œthisg.m.morebuf.g.ptr()æ˜¯gä¸æ˜¯g0 if thisg.m.morebuf.g.ptr().stackguard0 == stackFork { throw(\u0026#34;stack growth after fork\u0026#34;) } // m-\u0026gt;curg æ˜¯å½“å‰mä¸Šæ­£åœ¨è¿è¡Œçš„g if thisg.m.morebuf.g.ptr() != thisg.m.curg { print(\u0026#34;runtime: newstack called from g=\u0026#34;, hex(thisg.m.morebuf.g), \u0026#34;\\n\u0026#34;+\u0026#34;\\tm=\u0026#34;, thisg.m, \u0026#34; m-\u0026gt;curg=\u0026#34;, thisg.m.curg, \u0026#34; m-\u0026gt;g0=\u0026#34;, thisg.m.g0, \u0026#34; m-\u0026gt;gsignal=\u0026#34;, thisg.m.gsignal, \u0026#34;\\n\u0026#34;) morebuf := thisg.m.morebuf traceback(morebuf.pc, morebuf.sp, morebuf.lr, morebuf.g.ptr()) throw(\u0026#34;runtime: wrong goroutine in newstack\u0026#34;) } gp := thisg.m.curg // gp åœ¨è¿™é‡Œä¾‹å­æ˜¯runtime.mainçš„goroutine // g.throwsplit åœ¨ç³»ç»Ÿè°ƒç”¨å‰ä¼šè¢«è®¾ç½®ä¸ºtrueæˆ–å…¶ä»–åœ°æ–¹ã€‚å› æ­¤gå‡ºç°åœ¨è¿™é‡Œä¸åˆé€‚ã€‚ if thisg.m.curg.throwsplit { // Update syscallsp, syscallpc in case traceback uses them. morebuf := thisg.m.morebuf gp.syscallsp = morebuf.sp gp.syscallpc = morebuf.pc pcname, pcoff := \u0026#34;(unknown)\u0026#34;, uintptr(0) f := findfunc(gp.sched.pc) if f.valid() { pcname = funcname(f) pcoff = gp.sched.pc - f.entry() } print(\u0026#34;runtime: newstack at \u0026#34;, pcname, \u0026#34;+\u0026#34;, hex(pcoff), \u0026#34; sp=\u0026#34;, hex(gp.sched.sp), \u0026#34; stack=[\u0026#34;, hex(gp.stack.lo), \u0026#34;, \u0026#34;, hex(gp.stack.hi), \u0026#34;]\\n\u0026#34;, \u0026#34;\\tmorebuf={pc:\u0026#34;, hex(morebuf.pc), \u0026#34; sp:\u0026#34;, hex(morebuf.sp), \u0026#34; lr:\u0026#34;, hex(morebuf.lr), \u0026#34;}\\n\u0026#34;, \u0026#34;\\tsched={pc:\u0026#34;, hex(gp.sched.pc), \u0026#34; sp:\u0026#34;, hex(gp.sched.sp), \u0026#34; lr:\u0026#34;, hex(gp.sched.lr), \u0026#34; ctxt:\u0026#34;, gp.sched.ctxt, \u0026#34;}\\n\u0026#34;) thisg.m.traceback = 2 // Include runtime frames traceback(morebuf.pc, morebuf.sp, morebuf.lr, gp) throw(\u0026#34;runtime: stack split at bad time\u0026#34;) } // m.morebuf åœ¨ä¸Šé¢çš„morestackå‡½æ•°ä¸­è¢«è®¾ç½®ä¸ºè°ƒç”¨å‡½æ•°çš„ç›¸å…³ä¿¡æ¯ã€‚ morebuf := thisg.m.morebuf thisg.m.morebuf.pc = 0 thisg.m.morebuf.lr = 0 thisg.m.morebuf.sp = 0 thisg.m.morebuf.g = 0 // NOTE: stackguard0 may change underfoot, if another thread // is about to try to preempt gp. Read it just once and use that same // value now and below. // // æ³¨æ„ï¼šå¦‚æœå¦ä¸€ä¸ªçº¿ç¨‹å³å°†å°è¯•æŠ¢å gpï¼Œstackguard0å¯èƒ½ä¼šåœ¨è„šä¸‹å‘ç”Ÿå˜åŒ–ã€‚ // åªéœ€é˜…è¯»ä¸€æ¬¡å¹¶åœ¨ç°åœ¨å’Œä¸‹é¢ä½¿ç”¨ç›¸åŒçš„å€¼ stackguard0 := atomic.Loaduintptr(\u0026amp;gp.stackguard0) // è·å–gp.stackguard0 // Be conservative about where we preempt. // We are interested in preempting user Go code, not runtime code. // If we\u0026#39;re holding locks, mallocing, or preemption is disabled, don\u0026#39;t // preempt. // This check is very early in newstack so that even the status change // from Grunning to Gwaiting and back doesn\u0026#39;t happen in this case. // That status change by itself can be viewed as a small preemption, // because the GC might change Gwaiting to Gscanwaiting, and then // this goroutine has to wait for the GC to finish before continuing. // If the GC is in some way dependent on this goroutine (for example, // it needs a lock held by the goroutine), that small preemption turns // into a real deadlock. preempt := stackguard0 == stackPreempt // åˆ¤æ–­å½“å‰æ˜¯å¦çœŸéœ€è¦è¢«æŠ¢å  if preempt { // canPreemptM -\u0026gt; mp.locks == 0 \u0026amp;\u0026amp; mp.mallocing == 0 \u0026amp;\u0026amp; mp.preemptoff == \u0026#34;\u0026#34; \u0026amp;\u0026amp; mp.p.ptr().status == _Prunning if !canPreemptM(thisg.m) { // canPreemptM(thisg.m); true.å¯ä»¥æŠ¢å ; false.ä¸å…è®¸æŠ¢å  // ä»¥ä¸‹æ˜¯ã€ä¸å…è®¸ã€‘æŠ¢å æ—¶ï¼Œå†æ¬¡æ¢å¤gpã€‚ // Let the goroutine keep running for now. // gp-\u0026gt;preempt is set, so it will be preempted next time. // // ç°åœ¨è®©goroutineç»§ç»­è¿è¡Œã€‚gp-\u0026gt;preemptå·²è®¾ç½®ï¼Œå› æ­¤ä¸‹æ¬¡å°†è¢«æŠ¢å ã€‚ // (gp-\u0026gt;preemptåœ¨å‰é¢å·²è¢«è®¾ç½®ä¸ºtrue) // è¿˜åŸstackguard0ä¸ºæ­£å¸¸å€¼ï¼Œè¡¨ç¤ºæˆ‘ä»¬å·²ç»å¤„ç†è¿‡æŠ¢å è¯·æ±‚äº† gp.stackguard0 = gp.stack.lo + _StackGuard // æ¢å¤gpï¼Œè¿™é‡Œæ°¸è¿œä¸ä¼šè¿”å› gogo(\u0026amp;gp.sched) // never return } } if gp.stack.lo == 0 { throw(\u0026#34;missing stack in newstack\u0026#34;) } sp := gp.sched.sp if goarch.ArchFamily == goarch.AMD64 || goarch.ArchFamily == goarch.I386 || goarch.ArchFamily == goarch.WASM { // The call to morestack cost a word. sp -= goarch.PtrSize } if stackDebug \u0026gt;= 1 || sp \u0026lt; gp.stack.lo { print(\u0026#34;runtime: newstack sp=\u0026#34;, hex(sp), \u0026#34; stack=[\u0026#34;, hex(gp.stack.lo), \u0026#34;, \u0026#34;, hex(gp.stack.hi), \u0026#34;]\\n\u0026#34;, \u0026#34;\\tmorebuf={pc:\u0026#34;, hex(morebuf.pc), \u0026#34; sp:\u0026#34;, hex(morebuf.sp), \u0026#34; lr:\u0026#34;, hex(morebuf.lr), \u0026#34;}\\n\u0026#34;, \u0026#34;\\tsched={pc:\u0026#34;, hex(gp.sched.pc), \u0026#34; sp:\u0026#34;, hex(gp.sched.sp), \u0026#34; lr:\u0026#34;, hex(gp.sched.lr), \u0026#34; ctxt:\u0026#34;, gp.sched.ctxt, \u0026#34;}\\n\u0026#34;) } if sp \u0026lt; gp.stack.lo { print(\u0026#34;runtime: gp=\u0026#34;, gp, \u0026#34;, goid=\u0026#34;, gp.goid, \u0026#34;, gp-\u0026gt;status=\u0026#34;, hex(readgstatus(gp)), \u0026#34;\\n \u0026#34;) print(\u0026#34;runtime: split stack overflow: \u0026#34;, hex(sp), \u0026#34; \u0026lt; \u0026#34;, hex(gp.stack.lo), \u0026#34;\\n\u0026#34;) throw(\u0026#34;runtime: split stack overflow\u0026#34;) } // åˆ¤æ–­æŠ¢å ï¼Œå‘èµ·æŠ¢å  if preempt { if gp == thisg.m.g0 { throw(\u0026#34;runtime: preempt g0\u0026#34;) } if thisg.m.p == 0 \u0026amp;\u0026amp; thisg.m.locks == 0 { throw(\u0026#34;runtime: g is running but p is not\u0026#34;) } if gp.preemptShrink { // We\u0026#39;re at a synchronous safe point now, so // do the pending stack shrink. gp.preemptShrink = false shrinkstack(gp) } // åœæ­¢æŠ¢å ï¼Œå¼€å¯ä¸‹ä¸€æ¬¡è°ƒåº¦å¾ªç¯,makerootæœŸé—´æ”¹å€¼ä¼šè¢«è®¾ç½®ä¸ºtrueã€‚ if gp.preemptStop {\tpreemptPark(gp) // never returns } // Act like goroutine called runtime.Gosched. // // åƒè°ƒç”¨ runtime.Gosched çš„ goroutine ä¸€æ · // è°ƒç”¨gopreempt_mæŠŠgpåˆ‡æ¢å‡ºå»ï¼ŒæŠ¢å è¿™ä¸ªgoroutineæˆåŠŸäº† gopreempt_m(gp) // never return } // ä¸‹é¢ä»£ç æ˜¯æ‰©å¤§æ ˆç›¸å…³ä»£ç  // Allocate a bigger segment and move the stack. oldsize := gp.stack.hi - gp.stack.lo newsize := oldsize * 2 // æ‰©å¤§ä¸ºåŸæ¥çš„2å€ // Make sure we grow at least as much as needed to fit the new frame. // (This is just an optimization - the caller of morestack will // recheck the bounds on return.) if f := findfunc(gp.sched.pc); f.valid() { max := uintptr(funcMaxSPDelta(f)) needed := max + _StackGuard used := gp.stack.hi - gp.sched.sp for newsize-used \u0026lt; needed { newsize *= 2 } } if stackguard0 == stackForceMove { // Forced stack movement used for debugging. // Don\u0026#39;t double the stack (or we may quickly run out // if this is done repeatedly). newsize = oldsize } if newsize \u0026gt; maxstacksize || newsize \u0026gt; maxstackceiling { if maxstacksize \u0026lt; maxstackceiling { print(\u0026#34;runtime: goroutine stack exceeds \u0026#34;, maxstacksize, \u0026#34;-byte limit\\n\u0026#34;) } else { print(\u0026#34;runtime: goroutine stack exceeds \u0026#34;, maxstackceiling, \u0026#34;-byte limit\\n\u0026#34;) } print(\u0026#34;runtime: sp=\u0026#34;, hex(sp), \u0026#34; stack=[\u0026#34;, hex(gp.stack.lo), \u0026#34;, \u0026#34;, hex(gp.stack.hi), \u0026#34;]\\n\u0026#34;) throw(\u0026#34;stack overflow\u0026#34;) } // The goroutine must be executing in order to call newstack, // so it must be Grunning (or Gscanrunning). casgstatus(gp, _Grunning, _Gcopystack) // The concurrent GC will not scan the stack while we are doing the copy since // the gp is in a Gcopystack status. copystack(gp, newsize) if stackDebug \u0026gt;= 1 { print(\u0026#34;stack grow done\\n\u0026#34;) } casgstatus(gp, _Gcopystack, _Grunning) gogo(\u0026amp;gp.sched) // å†æ¬¡æ¢å¤è¿™ä¸ªgoroutine } canPreemptM canPreemptMæŠ¥å‘Šmpæ˜¯å¦å¤„äºå¯ä»¥å®‰å…¨æŠ¢å çš„çŠ¶æ€ã€‚ å®ƒæ˜¯nosplitå› ä¸ºå®ƒæœ‰nosplitçš„è°ƒç”¨è€…ã€‚ go:nosplitï¼šå‘Šè¯‰ç¼–è¯‘å™¨ä¸è¦åœ¨å½“å‰å‡½æ•°ä¸­æ’å…¥ä»»ä½•æ ˆæ‰©å±•ä»£ç ï¼Œè¿™æ ·å¯ä»¥ç¡®ä¿å½“å‰å‡½æ•°ä¸ä¼šå¯¼è‡´æ ˆçš„å¤§å°å‘ç”Ÿå˜åŒ–ã€‚ åœ¨Goè¯­è¨€ä¸­ï¼Œæ¯ä¸ªgoroutineéƒ½æœ‰ä¸€ä¸ªå›ºå®šçš„æ ˆå¤§å°ï¼Œå½“æ ˆçš„å¤§å°ä¸è¶³ä»¥å®¹çº³å½“å‰å‡½æ•°çš„æ‰§è¡Œæ—¶ï¼Œå°±ä¼šå‘ç”Ÿæ ˆæº¢å‡ºé”™è¯¯ã€‚ å› æ­¤ï¼Œä½¿ç”¨\u0026quot;go:nosplit\u0026quot;æŒ‡ä»¤å¯ä»¥ç¡®ä¿å‡½æ•°çš„æ‰§è¡Œä¸ä¼šå¯¼è‡´æ ˆçš„å¤§å°å‘ç”Ÿå˜åŒ–ï¼Œä»è€Œé¿å…æ ˆæº¢å‡ºé”™è¯¯çš„å‘ç”Ÿã€‚è¿™ä¸ªæŒ‡ä»¤é€šå¸¸ç”¨äºä¸€äº›å…³é”®æ€§çš„å‡½æ•°ä¸­ï¼Œæ¯”å¦‚åƒåœ¾å›æ”¶å™¨å’Œè°ƒåº¦å™¨ç­‰ã€‚ éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œä½¿ç”¨\u0026quot;go:nosplit\u0026quot;æŒ‡ä»¤å¯èƒ½ä¼šå½±å“ç¨‹åºçš„æ€§èƒ½ã€‚å› ä¸ºä¸å†æ’å…¥æ ˆæ‰©å±•ä»£ç ï¼Œè¿™æ„å‘³ç€åœ¨æ‰§è¡Œå‡½æ•°æ—¶ï¼Œæ ˆçš„å¤§å°ä¸ä¼šåŠ¨æ€è°ƒæ•´ã€‚å› æ­¤ï¼Œç¨‹åºå‘˜éœ€è¦åœ¨ä½¿ç”¨\u0026quot;go:nosplit\u0026quot;æŒ‡ä»¤æ—¶ä»”ç»†è€ƒè™‘æ€§èƒ½å’Œæ ˆæº¢å‡ºé”™è¯¯ä¹‹é—´çš„æƒè¡¡ã€‚ æ–‡ä»¶ä½ç½®ï¼šgo1.19.3/src/runtime/preempt.goã€‚ 282 283 284 285 286 287 288 289 290 291 292 293 294 295 // canPreemptM reports whether mp is in a state that is safe to preempt. // // It is nosplit because it has nosplit callers. // //go:nosplit func canPreemptM(mp *m) bool { // èƒ½å¦æŠ¢å æ¡ä»¶ï¼štrue.èƒ½æŠ¢å ï¼Œfalse.ä¸èƒ½æŠ¢å ã€‚ // 1. mp.locks == 0ï¼šè¡¨ç¤ºå½“å‰goroutineæŒæœ‰çš„äº’æ–¥é”æ•°é‡ï¼Œæ²¡åˆ°0æ—¶ï¼Œä¸åº”è¯¥è¢«æŠ¢å ã€‚ // 2. mp.mallocing == 0ï¼šå½“å‰goroutineæ­£åœ¨åˆ†é…å†…å­˜ï¼Œä¸åº”è¯¥è¢«æŠ¢å ã€‚ // 3. mp.preemptoffï¼šå¦‚æœè¯¥å€¼è¢«è®¾ç½®ä¸ºéç©ºå­—ç¬¦ä¸²ï¼Œåˆ™è¡¨ç¤ºå½“å‰goroutineä¸åº”è¯¥è¢«æŠ¢å ã€‚ // 4. mp.p.ptr().status == _Prunningï¼šå½“å‰Pæ­£åœ¨è¿è¡Œä¸­ã€‚ // æ»¡è¶³ä»¥ä¸Šæ¡ä»¶åˆ™èƒ½æŠ¢å gã€‚è¯¥å‡½æ•°ä¹Ÿä¼šåœ¨ä¿¡å·æŠ¢å å‡½æ•°isAsyncPreempt()å‡½æ•°ä¸­è°ƒç”¨ï¼Œç”¨äºåˆ¤æ–­æ˜¯å¦å…è®¸æŠ¢å  return mp.locks == 0 \u0026amp;\u0026amp; mp.mallocing == 0 \u0026amp;\u0026amp; mp.preemptoff == \u0026#34;\u0026#34; \u0026amp;\u0026amp; mp.p.ptr().status == _Prunning } gopreempt_m æŠ¢å è°ƒåº¦ï¼Œåé€»è¾‘å’Œruntime.Goschedä¸€æ ·ã€‚ æ–‡ä»¶ä½ç½®ï¼šgo1.19.3/src/runtime/proc.goã€‚ 3402 3403 3404 3405 3406 3407 func gopreempt_m(gp *g) { if trace.enabled { traceGoPreempt() } goschedImpl(gp) } ç³»ç»Ÿè°ƒç”¨å‰å handoffp()ï¼Œå¯¹æ­£åœ¨è¿›è¡Œç³»ç»Ÿè°ƒç”¨çš„goroutineçš„æŠ¢å å®è´¨ä¸Šæ˜¯å‰¥å¤ºä¸å…¶å¯¹åº”çš„å·¥ä½œçº¿ç¨‹æ‰€ç»‘å®šçš„pã€‚ è™½ç„¶è¯´å¤„äºç³»ç»Ÿè°ƒç”¨ä¹‹ä¸­çš„å·¥ä½œçº¿ç¨‹å¹¶ä¸éœ€è¦pï¼Œä½†ä¸€æ—¦ä»æ“ä½œç³»ç»Ÿå†…æ ¸è¿”å›åˆ°ç”¨æˆ·ç©ºé—´ä¹‹åå°±å¿…é¡»ç»‘å®šä¸€ä¸ªpæ‰èƒ½è¿è¡Œgoä»£ç ã€‚ ç³»ç»Ÿè°ƒç”¨ Syscall6() ç³»ç»Ÿè°ƒç”¨æ—¶æœ€ç»ˆä¼šè°ƒç”¨è¯¥æ±‡ç¼–å‡½æ•°ã€‚ æ–‡ä»¶ä½ç½®ï¼šgo1.19.3/src/syscall/asm_unix_amd64.sã€‚ å‡½æ•°åŸå‹ï¼šfunc Syscall6(num, a1, a2, a3, a4, a5, a6 uintptr) (r1, r2, errno uintptr)ã€‚ 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 TEXT Â·Syscall6(SB),NOSPLIT,$0-80 # è°ƒç”¨ runtime.entersyscall å‡½æ•°ï¼Œä¿å­˜ç°åœºè§£é™¤ç»‘å®šå…³ç³» CALL runtimeÂ·entersyscall\u0026lt;ABIInternal\u0026gt;(SB) # ç³»ç»Ÿè°ƒç”¨å‚æ•°ï¼ŒæŒ‰ç…§linuxç³»ç»Ÿçº¦å®šå¯„å­˜å™¨å¹¶è°ƒç”¨SYSCALLæ‰§è¡Œè¿›å…¥å†…æ ¸ã€‚ # ç³»ç»Ÿè°ƒç”¨ç¼–å·æ”¾å…¥AXã€‚ MOVQ trap+0(FP), AX # syscall entry MOVQ a1+8(FP), DI MOVQ a2+16(FP), SI MOVQ a3+24(FP), DX MOVQ a4+32(FP), R10 MOVQ a5+40(FP), R8 MOVQ a6+48(FP), R9 SYSCALL # è¿›å…¥å†…æ ¸ # ä»å†…æ ¸è¿”å›ï¼Œåˆ¤æ–­æ ‡è¯†æ˜¯å¦è·³è½¬ JCC\tok6 MOVQ $-1, r1+56(FP) # r1 MOVQ $0, r2+64(FP) # r2 MOVQ AX, err+72(FP) # errno CALL runtimeÂ·exitsyscall\u0026lt;ABIInternal\u0026gt;(SB) RET ok6: # ç³»ç»Ÿè°ƒç”¨è¿”å›çš„å€¼ä¿å­˜æ ˆ MOVQ AX, r1+56(FP) # r1 MOVQ DX, r2+64(FP) # r2 MOVQ $0, err+72(FP) # errno CALL runtimeÂ·exitsyscall\u0026lt;ABIInternal\u0026gt;(SB) RET ç³»ç»Ÿè°ƒç”¨å‰ entersyscall() goç³»ç»Ÿè°ƒç”¨åº“å’Œæ™®é€šcgoè°ƒç”¨ä½¿ç”¨çš„æ ‡å‡†ç³»ç»Ÿè°ƒç”¨é¡¹ã€‚ è¿™æ˜¯é€šè¿‡syscallåŒ…å’Œx/sysä¸­çš„é“¾æ¥åå¯¼å‡ºåˆ°ç¨‹åºé›†çš„ã€‚ æ–‡ä»¶ä½ç½®ï¼šgo1.19.3/src/runtime/proc.goã€‚ 3672 3673 3674 3675 3676 3677 3678 3679 3680 3681 3682 // Standard syscall entry used by the go syscall library and normal cgo calls. // // This is exported via linkname to assembly in the syscall package and x/sys. // //go:nosplit //go:linkname entersyscall func entersyscall() { // getcallerpc()ï¼šè°ƒç”¨è€…å½“å‰PCå€¼ã€‚ // getcallersp()ï¼šè°ƒç”¨è€…å½“å‰SPå€¼ã€‚ reentersyscall(getcallerpc(), getcallersp()) } reentersyscall() æ–‡ä»¶ä½ç½®ï¼šgo1.19.3/src/runtime/proc.goã€‚ 3575 3576 3577 3578 3579 3580 3581 3582 3583 3584 3585 3586 3587 3588 3589 3590 3591 3592 3593 3594 3595 3596 3597 3598 3599 3600 3601 3602 3603 3604 3605 3606 3607 3608 3609 3610 3611 3612 3613 3614 3615 3616 3617 3618 3619 3620 3621 3622 3623 3624 3625 3626 3627 3628 3629 3630 3631 3632 3633 3634 3635 3636 3637 3638 3639 3640 3641 3642 3643 3644 3645 3646 3647 3648 3649 3650 3651 3652 3653 3654 3655 3656 3657 3658 3659 3660 3661 3662 3663 3664 3665 3666 3667 3668 3669 3670 3671 3672 3673 3674 3675 3676 3677 3678 3679 3680 3681 3682 3683 3684 3685 3686 3687 3688 // The goroutine g is about to enter a system call. // Record that it\u0026#39;s not using the cpu anymore. // This is called only from the go syscall library and cgocall, // not from the low-level system calls used by the runtime. // // Entersyscall cannot split the stack: the save must // make g-\u0026gt;sched refer to the caller\u0026#39;s stack segment, because // entersyscall is going to return immediately after. // // Nothing entersyscall calls can split the stack either. // We cannot safely move the stack during an active call to syscall, // because we do not know which of the uintptr arguments are // really pointers (back into the stack). // In practice, this means that we make the fast path run through // entersyscall doing no-split things, and the slow path has to use systemstack // to run bigger things on the system stack. // // reentersyscall is the entry point used by cgo callbacks, where explicitly // saved SP and PC are restored. This is needed when exitsyscall will be called // from a function further up in the call stack than the parent, as g-\u0026gt;syscallsp // must always point to a valid stack frame. entersyscall below is the normal // entry point for syscalls, which obtains the SP and PC from the caller. // // Syscall tracing: // At the start of a syscall we emit traceGoSysCall to capture the stack trace. // If the syscall does not block, that is it, we do not emit any other events. // If the syscall blocks (that is, P is retaken), retaker emits traceGoSysBlock; // when syscall returns we emit traceGoSysExit and when the goroutine starts running // (potentially instantly, if exitsyscallfast returns true) we emit traceGoStart. // To ensure that traceGoSysExit is emitted strictly after traceGoSysBlock, // we remember current value of syscalltick in m (_g_.m.syscalltick = _g_.m.p.ptr().syscalltick), // whoever emits traceGoSysBlock increments p.syscalltick afterwards; // and we wait for the increment before emitting traceGoSysExit. // Note that the increment is done even if tracing is not enabled, // because tracing can be enabled in the middle of syscall. We don\u0026#39;t want the wait to hang. // //go:nosplit func reentersyscall(pc, sp uintptr) { // user goroutine _g_ := getg() // æ‰§è¡Œç³»ç»Ÿè°ƒç”¨çš„goroutine // Disable preemption because during this function g is in Gsyscall status, // but can have inconsistent g-\u0026gt;sched, do not let GC observe it. // // ç¦ç”¨æŠ¢å ï¼Œå› ä¸ºåœ¨è¿™ä¸ªåŠŸèƒ½æœŸé—´gå¤„äºGsyscallçŠ¶æ€ï¼Œä½†å¯èƒ½æœ‰ä¸ä¸€è‡´çš„g-\u0026gt;schedï¼Œä¸è¦è®©GCè§‚å¯Ÿå®ƒã€‚ _g_.m.locks++ // Entersyscall must not call any function that might split/grow the stack. // (See details in comment above.) // Catch calls that might, by replacing the stack guard with something that // will trip any stack check and leaving a flag to tell newstack to die. _g_.stackguard0 = stackPreempt // è®¾ç½®æŠ¢å ï¼Œåœ¨è°ƒç”¨è¿”å›æ—¶ä¼šä¿®æ”¹å›æ¥ // ä¸èƒ½æ‰©å±•æ ˆï¼Œåœ¨è°ƒç”¨è¿”å›æ—¶ä¼šä¿®æ”¹å›æ¥ _g_.throwsplit = true // Leave SP around for GC and traceback. save(pc, sp) // ä¿å­˜gçš„ç°åœºä¿¡æ¯ï¼Œrspï¼Œrbpï¼Œripç­‰ _g_.syscallsp = sp _g_.syscallpc = pc // ç›‘æ§çº¿ç¨‹ä¾èµ–_GsyscallçŠ¶æ€å®æ–½ç³»ç»Ÿè°ƒç”¨æ—¶çš„æŠ¢å  casgstatus(_g_, _Grunning, _Gsyscall) // åˆ‡æ¢gçŠ¶æ€ä¸ºç³»ç»Ÿè°ƒç”¨ä¸­ // SPæ˜¯å¦åœ¨goroutineçš„æ ˆèŒƒå›´å†… if _g_.syscallsp \u0026lt; _g_.stack.lo || _g_.stack.hi \u0026lt; _g_.syscallsp { systemstack(func() { print(\u0026#34;entersyscall inconsistent \u0026#34;, hex(_g_.syscallsp), \u0026#34; [\u0026#34;, hex(_g_.stack.lo), \u0026#34;,\u0026#34;, hex(_g_.stack.hi), \u0026#34;]\\n\u0026#34;) throw(\u0026#34;entersyscall\u0026#34;) }) } if trace.enabled { systemstack(traceGoSysCall) // systemstack itself clobbers g.sched.{pc,sp} and we might // need them later when the G is genuinely blocked in a // syscall save(pc, sp) } // sysmon ç›‘æ§çº¿ç¨‹æ­£æŒ‚èµ·åœ¨ sched.sysmonwait if atomic.Load(\u0026amp;sched.sysmonwait) != 0 { // åˆ‡æ¢åˆ°g0æ ˆè°ƒç”¨ entersyscall_sysmon å‡½æ•° // entersyscall_sysmon å‡½æ•°å”¤é†’ sysmon ç›‘æ§çº¿ç¨‹ systemstack(entersyscall_sysmon) save(pc, sp) } if _g_.m.p.ptr().runSafePointFn != 0 { // runSafePointFn may stack split if run on this stack systemstack(runSafePointFn) save(pc, sp) } // æŠŠPçš„è°ƒç”¨æ¬¡æ•°æ‹·è´ç»™M _g_.m.syscalltick = _g_.m.p.ptr().syscalltick _g_.sysblocktraced = true // Må’ŒPç›¸äº’è§£é™¤å…³è”ï¼Œå¹¶æŠŠPæš‚å­˜ä¸m.oldpä¸­ï¼Œ // ç­‰å¾…ç³»ç»Ÿè°ƒç”¨å®Œåä½¿ç”¨ // è§£é™¤p.må…³è”çš„m pp := _g_.m.p.ptr() // pp = p pp.m = 0 // m.oldp = pp _g_.m.oldp.set(pp) // è§£é™¤ m.p çš„å…³ç³» p _g_.m.p = 0 atomic.Store(\u0026amp;pp.status, _Psyscall) // pp.status = _Psyscall // STWæ­£åœ¨ç­‰å¾…æ—¶ if sched.gcwaiting != 0 { // åˆ‡æ¢åˆ°g0æ ˆè°ƒç”¨entersyscall_gcwaitå‡½æ•° // entersyscall_gcwaitå‡½æ•°ï¼Œå°†PçŠ¶æ€è®¾ç½®ä¸º _Pgcstopï¼Œå¦‚æœSTWå·²å®Œæˆåˆ™å”¤é†’åœ¨sched.stopnoteä¸Šç­‰å¾…çš„STWå‘èµ·çš„çº¿ç¨‹ã€‚ systemstack(entersyscall_gcwait) save(pc, sp) } _g_.m.locks-- } save() ä¿å­˜goroutineç°åœºã€‚ æ–‡ä»¶ä½ç½®ï¼šgo1.19.3/src/runtime/proc.goã€‚ 3543 3544 3545 3546 3547 3548 3549 3550 3551 3552 3553 3554 3555 3556 3557 3558 3559 3560 3561 3562 3563 3564 3565 3566 3567 3568 3569 3570 3571 3572 3573 // save updates getg().sched to refer to pc and sp so that a following // gogo will restore pc and sp. // // save must not have write barriers because invoking a write barrier // can clobber getg().sched. // //go:nosplit //go:nowritebarrierrec func save(pc, sp uintptr) { gp := getg() if gp == gp.m.g0 || gp == gp.m.gsignal { // m.g0.sched is special and must describe the context // for exiting the thread. mstart1 writes to it directly. // m.gsignal.sched should not be used at all. // This check makes sure save calls do not accidentally // run in contexts where they\u0026#39;d write to system g\u0026#39;s. throw(\u0026#34;save on system g not allowed\u0026#34;) } gp.sched.pc = pc gp.sched.sp = sp gp.sched.lr = 0 gp.sched.ret = 0 // We need to ensure ctxt is zero, but can\u0026#39;t have a write // barrier here. However, it should always already be zero. // Assert that. if gp.sched.ctxt != nil { badctxt() } } ç³»ç»Ÿè°ƒç”¨å exitsyscall() è¿™ä¸ªgoroutine gé€€å‡ºç³»ç»Ÿè°ƒç”¨ã€‚å®‰æ’å®ƒå†æ¬¡åœ¨cpuä¸Šè¿è¡Œã€‚ è¿™ä»…ä»goç³»ç»Ÿè°ƒç”¨åº“ä¸­è°ƒç”¨ï¼Œè€Œä¸æ˜¯ä»è¿è¡Œæ—¶ä½¿ç”¨çš„ä½çº§ç³»ç»Ÿè°ƒç”¨ä¸­è°ƒç”¨ã€‚ å†™å±éšœæ˜¯ä¸è¢«å…è®¸çš„ï¼Œå› ä¸ºæˆ‘ä»¬çš„På¯èƒ½è¢«å·äº†ã€‚ æ–‡ä»¶ä½ç½®ï¼šgo1.19.3/src/runtime/proc.goã€‚ 3761 3762 3763 3764 3765 3766 3767 3768 3769 3770 3771 3772 3773 3774 3775 3776 3777 3778 3779 3780 3781 3782 3783 3784 3785 3786 3787 3788 3789 3790 3791 3792 3793 3794 3795 3796 3797 3798 3799 3800 3801 3802 3803 3804 3805 3806 3807 3808 3809 3810 3811 3812 3813 3814 3815 3816 3817 3818 3819 3820 3821 3822 3823 3824 3825 3826 3827 3828 3829 3830 3831 3832 3833 3834 3835 3836 3837 3838 3839 3840 3841 3842 3843 3844 3845 3846 3847 3848 3849 3850 3851 3852 3853 3854 3855 3856 3857 3858 3859 3860 3861 3862 3863 3864 3865 3866 // The goroutine g exited its system call. // Arrange for it to run on a cpu again. // This is called only from the go syscall library, not // from the low-level system calls used by the runtime. // // Write barriers are not allowed because our P may have been stolen. // // This is exported via linkname to assembly in the syscall package. // //go:nosplit //go:nowritebarrierrec //go:linkname exitsyscall func exitsyscall() { // user goroutine _g_ := getg() // goroutine g _g_.m.locks++ // see comment in entersyscall if getcallersp() \u0026gt; _g_.syscallsp { throw(\u0026#34;exitsyscall: syscall frame is no longer valid\u0026#34;) } // g.waitsinceï¼Œgè¢«é˜»å¡çš„å¤§çº¦æ—¶é—´ _g_.waitsince = 0 // è¿›å…¥ç³»ç»Ÿè°ƒç”¨ä¹‹å‰æ‰€ç»‘å®šçš„p oldp := _g_.m.oldp.ptr() _g_.m.oldp = 0 // exitsyscallfast å°è¯•ç»‘å®šPï¼ŒæˆåŠŸè¿”å›trueï¼Œå¤±è´¥è¿”å›falseã€‚ if exitsyscallfast(oldp) { // When exitsyscallfast returns success, we have a P so can now use // write barriers if goroutineProfile.active { // Make sure that gp has had its stack written out to the goroutine // profile, exactly as it was when the goroutine profiler first // stopped the world. systemstack(func() { tryRecordGoroutineProfileWB(_g_) }) } if trace.enabled { if oldp != _g_.m.p.ptr() || _g_.m.syscalltick != _g_.m.p.ptr().syscalltick { systemstack(traceGoStart) } } // There\u0026#39;s a cpu for us, so we can run. _g_.m.p.ptr().syscalltick++ // We need to cas the status and scan before resuming... casgstatus(_g_, _Gsyscall, _Grunning) // Garbage collector isn\u0026#39;t running (since we are), // so okay to clear syscallsp. _g_.syscallsp = 0 _g_.m.locks-- if _g_.preempt { // restore the preemption request in case we\u0026#39;ve cleared it in newstack // æ¢å¤æŠ¢å è¯·æ±‚ï¼Œä»¥é˜²æˆ‘ä»¬åœ¨newstackä¸­æ¸…é™¤äº†å®ƒ _g_.stackguard0 = stackPreempt } else { // otherwise restore the real _StackGuard, we\u0026#39;ve spoiled it in entersyscall/entersyscallblock // å¦åˆ™æ¢å¤çœŸæ­£çš„_StackGuardï¼Œæˆ‘ä»¬å·²ç»åœ¨entersyscall/entersyscallblockä¸­ç ´åäº†å®ƒ _g_.stackguard0 = _g_.stack.lo + _StackGuard } _g_.throwsplit = false // sched.disable.user == trueï¼Œç”¨æˆ·goroutineè¢«ç¦æ­¢è¿è¡Œ // schedEnabledåˆ¤æ–­gæ˜¯å¦æ˜¯ç³»ç»Ÿgoroutine if sched.disable.user \u0026amp;\u0026amp; !schedEnabled(_g_) { // Scheduling of this goroutine is disabled. Gosched() // è®©å‡ºCPUï¼Œå½“å‰goroutineã€‚ } return } // Mç»‘å®šPæ²¡æœ‰æˆåŠŸæ—¶ã€‚ _g_.sysexitticks = 0 if trace.enabled { // Wait till traceGoSysBlock event is emitted. // This ensures consistency of the trace (the goroutine is started after it is blocked). for oldp != nil \u0026amp;\u0026amp; oldp.syscalltick == _g_.m.syscalltick { osyield() } // We can\u0026#39;t trace syscall exit right now because we don\u0026#39;t have a P. // Tracing code can invoke write barriers that cannot run without a P. // So instead we remember the syscall exit time and emit the event // in execute when we have a P. _g_.sysexitticks = cputicks() } _g_.m.locks-- // Call the scheduler. // // æ²¡æœ‰ç»‘å®šåˆ°pï¼Œè°ƒç”¨mcallåˆ‡æ¢åˆ°g0æ ˆæ‰§è¡Œexitsyscall0å‡½æ•° mcall(exitsyscall0) // mcallå‡½æ•°ä¼šä¿å­˜ç°åœºï¼Œåˆ‡æ¢g0è°ƒç”¨exitsyscall0å‡½æ•° // Scheduler returned, so we\u0026#39;re allowed to run now. // Delete the syscallsp information that we left for // the garbage collector during the system call. // Must wait until now because until gosched returns // we don\u0026#39;t know for sure that the garbage collector // is not running. _g_.syscallsp = 0 _g_.m.p.ptr().syscalltick++ _g_.throwsplit = false } exitsyscallfast() å°è¯•ç»‘å®šä¸€ä¸ªç©ºé—²çš„Pã€‚true.ç»‘å®šæˆåŠŸï¼Œfalse.ç»‘å®šå¤±è´¥ã€‚ æ–‡ä»¶ä½ç½®ï¼šgo1.19.3/src/runtime/proc.goã€‚ 3856 3857 3858 3859 3860 3861 3862 3863 3864 3865 3866 3867 3868 3869 3870 3871 3872 3873 3874 3875 3876 3877 3878 3879 3880 3881 3882 3883 3884 3885 3886 3887 3888 3889 3890 3891 3892 3893 3894 3895 3896 3897 3898 3899 3900 3901 3902 3903 3904 //go:nosplit func exitsyscallfast(oldp *p) bool { _g_ := getg() // g // Freezetheworld sets stopwait but does not retake P\u0026#39;s. // // Freezetheworld è®¾ç½®åœæ­¢ç­‰å¾…ï¼Œä½†ä¸é‡æ–°è·å–Pã€‚ // const freezeStopWait int = 0x7fffffff if sched.stopwait == freezeStopWait { return false } // Try to re-acquire the last P. // // è¯•ç€é‡æ–°è·å–last Pã€‚ if oldp != nil \u0026amp;\u0026amp; oldp.status == _Psyscall \u0026amp;\u0026amp; atomic.Cas(\u0026amp;oldp.status, _Psyscall, _Pidle) { // There\u0026#39;s a cpu for us, so we can run. // æˆ‘ä»¬æœ‰cpuï¼Œæ‰€ä»¥æˆ‘ä»¬å¯ä»¥è¿è¡Œã€‚ wirep(oldp) // ç»‘å®šP exitsyscallfast_reacquired() // å¤„ç†Pçš„syscalltickå­—æ®µ return true } // Try to get any other idle P. // // å°è¯•è·å–ä¸€ä¸ªç©ºé—²çš„Pã€‚ if sched.pidle != 0 { var ok bool // åˆ‡æ¢åˆ°g0æ ˆ systemstack(func() { // ä»å…¨å±€é˜Ÿåˆ—ä¸­å¯»æ‰¾ç©ºé—²çš„pï¼Œéœ€è¦åŠ é”ï¼Œæ¯”è¾ƒæ…¢ ok = exitsyscallfast_pidle() // æ¬åˆ°æˆåŠŸè¿”å›trueï¼Œç»‘å®šå¤±è´¥è¿”å›falseã€‚ if ok \u0026amp;\u0026amp; trace.enabled { if oldp != nil { // Wait till traceGoSysBlock event is emitted. // This ensures consistency of the trace (the goroutine is started after it is blocked). for oldp.syscalltick == _g_.m.syscalltick { osyield() } } traceGoSysExit(0) } }) if ok { return true } } return false } exitsyscallfast_pidle() æ–‡ä»¶ä½ç½®ï¼šgo1.19.3/src/runtime/proc.goã€‚ 3913 3914 3915 3916 3917 3918 3919 3920 3921 3922 3923 3924 3925 3926 3927 func exitsyscallfast_pidle() bool { lock(\u0026amp;sched.lock) _p_, _ := pidleget(0) // å¤„ç†sysmonï¼Œå› ä¸ºåœ¨é™·å…¥åˆ°ç³»ç»Ÿè°ƒç”¨æ˜¯sysmonå¯èƒ½è‡ªå·±æŠŠè‡ªå·±æŒ‚èµ·ï¼Œæ‰€ä»¥éœ€è¦æ¢å¤ if _p_ != nil \u0026amp;\u0026amp; atomic.Load(\u0026amp;sched.sysmonwait) != 0 { atomic.Store(\u0026amp;sched.sysmonwait, 0) notewakeup(\u0026amp;sched.sysmonnote) } unlock(\u0026amp;sched.lock) if _p_ != nil { acquirep(_p_) // ç»‘å®šPå¦‚æœæœ‰çš„è¯ return true } return false } exitsyscall0() exitsyscallåœ¨g0ä¸Šçš„æ…¢è·¯å¾„ã€‚è·å–På¤±è´¥å°†gpæ”¾å…¥å¯è¿è¡Œé˜Ÿåˆ—ä¸­ã€‚ é€šè¿‡mcall()è°ƒç”¨ï¼Œgpæ˜¯ä»è¿™ä¸ªMè°ƒç”¨gã€‚ æ–‡ä»¶ä½ç½®ï¼šgo1.19.3/src/runtime/proc.goã€‚ 3934 3935 3936 3937 3938 3939 3940 3941 3942 3943 3944 3945 3946 3947 3948 3949 3950 3951 3952 3953 3954 3955 3956 3957 3958 3959 3960 3961 3962 3963 3964 3965 3966 3967 3968 3969 3970 3971 3972 3973 3974 3975 3976 3977 3978 3979 3980 3981 3982 3983 3984 3985 3986 3987 // exitsyscall slow path on g0. // Failed to acquire P, enqueue gp as runnable. // // Called via mcall, so gp is the calling g from this M. // //go:nowritebarrierrec func exitsyscall0(gp *g) { // ä¿®æ”¹gpçŠ¶æ€ä¸º_Grunnable casgstatus(gp, _Gsyscall, _Grunnable) dropg() // è§£é™¤gå…³è”å…³ç³» lock(\u0026amp;sched.lock) var _p_ *p // åˆ¤æ–­gpæ˜¯å¦æ˜¯ç³»ç»Ÿgoroutineï¼Œå¦‚æœæ˜¯çš„è¯å†æ¬¡å°è¯•è·å–Pã€‚ if schedEnabled(gp) { _p_, _ = pidleget(0) } var locked bool if _p_ == nil { globrunqput(gp) // gpåŠ å…¥å…¨å±€å¯è¿è¡Œé˜Ÿåˆ— // Below, we stoplockedm if gp is locked. globrunqput releases // ownership of gp, so we must check if gp is locked prior to // committing the release by unlocking sched.lock, otherwise we // could race with another M transitioning gp from unlocked to // locked. // // ä¸‹é¢ï¼Œå¦‚æœgpè¢«é”å®šï¼Œæˆ‘ä»¬å°†åœæ­¢é˜»å¡ã€‚ // globrunqputé‡Šæ”¾äº†gpçš„æ‰€æœ‰æƒï¼Œæ‰€ä»¥æˆ‘ä»¬å¿…é¡»åœ¨é‡Šæ”¾ä¹‹å‰é€šè¿‡è§£é”sched.lockæ£€æŸ¥gpæ˜¯å¦è¢«é”å®šï¼Œå¦åˆ™æˆ‘ä»¬å¯ä»¥ä¸å¦ä¸€ä¸ªMè½¬æ¢gpä»è§£é”åˆ°é”å®šã€‚ locked = gp.lockedm != 0 } else if atomic.Load(\u0026amp;sched.sysmonwait) != 0 { // å°è¯•å”¤é†’sysmonï¼Œå¦‚æœæœ‰ atomic.Store(\u0026amp;sched.sysmonwait, 0) notewakeup(\u0026amp;sched.sysmonnote) } unlock(\u0026amp;sched.lock) if _p_ != nil { acquirep(_p_) // ç»‘å®šP // gp è¢«è°ƒåº¦èµ·æ¥è¿è¡Œ execute(gp, false) // Never returns. } if locked { // Wait until another thread schedules gp and so m again. // // N.B. lockedm must be this M, as this g was running on this M // before entersyscall. // // ç­‰å¾…å¦ä¸€ä¸ªçº¿ç¨‹è°ƒåº¦gpï¼Œç„¶åå†è°ƒåº¦mã€‚ // æ³¨æ„ï¼Œlockedmä¸€å®šæ˜¯è¿™ä¸ªMï¼Œå› ä¸ºè¿™ä¸ªgåœ¨entersyscallä¹‹å‰æ˜¯åœ¨è¿™ä¸ªMä¸Šè¿è¡Œçš„ã€‚ stoplockedm() execute(gp, false) // Never returns. } stopm() // å½“å‰å·¥ä½œçº¿ç¨‹è¢«æŒ‚èµ·ï¼Œç­‰å¾…è¢«å”¤é†’è·å–Pç„¶åè¿è¡Œèµ·æ¥ // è°ƒåº¦å¾ªç¯å¼€å§‹ schedule() // Never returns. } ä¿¡å·å½¢å¼å‘é€æŠ¢å  preemptM() preemptMå‘mpå‘é€æŠ¢å è¯·æ±‚ã€‚è¯¥è¯·æ±‚å¯ä»¥å¼‚æ­¥å¤„ç†ï¼Œå¹¶ä¸”å¯ä»¥ä¸å¯¹Mçš„å…¶ä»–è¯·æ±‚åˆå¹¶ã€‚ å½“æ¥æ”¶åˆ°è¯·æ±‚æ—¶ï¼Œå¦‚æœæ­£åœ¨è¿è¡Œçš„Gæˆ–Pè¢«æ ‡è®°ä¸ºæŠ¢å ï¼Œå¹¶ä¸”goroutineå¤„äºå¼‚æ­¥å®‰å…¨ç‚¹ï¼Œåˆ™å®ƒå°†æŠ¢å  goroutineã€‚ å®ƒæ€»æ˜¯åœ¨å¤„ç†æŠ¢å è¯·æ±‚åè‡ªåŠ¨é€’å¢mp.preemptGenã€‚ é€šè¿‡runtime.signalM()å‡½æ•°å‘æ‰§è¡ŒMå‘é€sigPreemptä¿¡å·ã€‚ è‡³äºsignalM()å‡½æ•°ï¼Œå°±æ˜¯è°ƒç”¨æ“ä½œç³»ç»Ÿçš„ä¿¡å·ç›¸å…³ç³»ç»Ÿè°ƒç”¨ï¼Œå°†æŒ‡å®šä¿¡å·å‘é€ç»™ç›®æ ‡çº¿ç¨‹ã€‚ è‡³æ­¤ï¼Œå¼‚æ­¥æŠ¢å é€»è¾‘çš„ä¸»è¦å·¥ä½œå°±ç®—å®Œæˆäº†å‰ä¸€åŠã€‚ preemptMè¿™ä¸ªå‡½æ•°ä¼šè°ƒç”¨signalMå°†åœ¨åˆå§‹åŒ–çš„å®‰è£…çš„_SIGURGä¿¡å·å‘é€åˆ°æŒ‡å®šçš„Mä¸Šã€‚ ä½¿ç”¨ preemptM å‘é€æŠ¢å ä¿¡å·çš„åœ°æ–¹ä¸»è¦æœ‰ä¸‹é¢å‡ ä¸ªï¼š Go åå°ç›‘æ§ runtime.sysmon æ£€æµ‹è¶…æ—¶å‘é€æŠ¢å ä¿¡å·ï¼› Go GC æ ˆæ‰«æå‘é€æŠ¢å ä¿¡å·ï¼› Go GC STW çš„æ—¶å€™è°ƒç”¨ preemptall æŠ¢å æ‰€æœ‰ Pï¼Œè®©å…¶æš‚åœï¼› æ–‡ä»¶ä½ç½®ï¼šgo1.19.3/src/runtime/signal_unix.goã€‚ å‚æ•°mp *mï¼šè¢«æŠ¢å çš„På…³è”çš„Mã€‚ 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 // preemptM sends a preemption request to mp. This request may be // handled asynchronously and may be coalesced with other requests to // the M. When the request is received, if the running G or P are // marked for preemption and the goroutine is at an asynchronous // safe-point, it will preempt the goroutine. It always atomically // increments mp.preemptGen after handling a preemption request. func preemptM(mp *m) { // On Darwin, don\u0026#39;t try to preempt threads during exec. // Issue #41702. if GOOS == \u0026#34;darwin\u0026#34; || GOOS == \u0026#34;ios\u0026#34; { execLock.rlock() } // mp.signalPending: è¿™ä¸ªMä¸Šæ˜¯å¦æœ‰ä¸€ä¸ªå¾…å¤„ç†çš„æŠ¢å ä¿¡å·ã€‚åŸå­æ“ä½œã€‚ if atomic.Cas(\u0026amp;mp.signalPending, 0, 1) { if GOOS == \u0026#34;darwin\u0026#34; || GOOS == \u0026#34;ios\u0026#34; { atomic.Xadd(\u0026amp;pendingPreemptSignals, 1) } // If multiple threads are preempting the same M, it may send many // signals to the same M such that it hardly make progress, causing // live-lock problem. Apparently this could happen on darwin. See // issue #37741. // Only send a signal if there isn\u0026#39;t already one pending. // // å¦‚æœå¤šä¸ªçº¿ç¨‹æŠ¢å åŒä¸€ä¸ªMï¼Œå®ƒå¯èƒ½ä¼šå‘åŒä¸€ä¸ªMå‘é€è®¸å¤šä¿¡å·ï¼Œ // ä½¿å…¶å‡ ä¹æ— æ³•å–å¾—è¿›å±•ï¼Œä»è€Œå¯¼è‡´å®æ—¶é”å®šé—®é¢˜ã€‚ // æ˜¾ç„¶è¿™å¯èƒ½å‘ç”Ÿåœ¨darwinèº«ä¸Šã€‚åªæœ‰åœ¨è¿˜æ²¡æœ‰æŒ‚èµ·çš„æƒ…å†µä¸‹æ‰å‘é€ä¿¡å·ã€‚ // const sigPreempt int = _SIGURG // const _SIGURG = 0x17 signalM(mp, sigPreempt) } if GOOS == \u0026#34;darwin\u0026#34; || GOOS == \u0026#34;ios\u0026#34; { execLock.runlock() } } signalM() signalMå‘mpå‘é€ä¿¡å·ã€‚ æ–‡ä»¶ä½ç½®ï¼šgo1.19.3/src/runtime/os_linux.goã€‚ 551 552 553 554 555 556 557 558 559 560 561 562 // signalM sends a signal to mp. func signalM(mp *m, sig int) { // å°†ä¿¡å·sigå‘é€åˆ°çº¿ç¨‹ç»„tgidä¸­å…·æœ‰çº¿ç¨‹ID tidçš„çº¿ç¨‹ã€‚ // int tgkill(int tgid, int tid, int sig); // 1. tgidï¼šä¸ºçº¿ç¨‹ç»„ä¸­ä¸»çº¿ç¨‹çš„çº¿ç¨‹IDï¼Œæˆ–è€…ç§°ä¸ºè¿›ç¨‹å·ã€‚ // å…¶å®å®ƒèƒ½èµ·åˆ°ä¿æŠ¤çš„ä½œç”¨ï¼Œé˜²æ­¢å‘é”™è¯¯çš„çº¿ç¨‹å‘é€ä¿¡å·ã€‚ // æ¯”å¦‚å‘çº¿ç¨‹IDä¸º1234çš„çº¿ç¨‹å‘é€ä¿¡å·æ—¶ï¼Œå¾ˆå¯èƒ½çº¿ç¨‹1234æ—©å°±é€€å‡ºäº†ï¼Œ // è€Œçº¿ç¨‹ID 1234æ°å¥½è¢«å†…æ ¸åˆ†é…ç»™äº†å¦ä¸€ä¸ªä¸ç›¸å¹²çš„è¿›ç¨‹ã€‚ // 2. tidï¼šçº¿ç¨‹IDã€‚ // 3. sigï¼šä¿¡å·å€¼ã€‚sigPreempt = _SIGURG = 0x17ã€‚ tgkill(getpid(), int(mp.procid), sig) } tgkill() ç³»ç»Ÿè°ƒç”¨ tgkill() å‡½æ•°å‘è¿›ç¨‹å†…çš„çº¿ç¨‹å‘é€ä¿¡å·ã€‚ æ–‡ä»¶ä½ç½®ï¼šgo1.19.3/src/runtime/sys_linux_amd64.sã€‚ 176 177 178 179 180 181 182 TEXT Â·tgkill(SB),NOSPLIT,$0 MOVQ tgid+0(FP), DI MOVQ tid+8(FP), SI MOVQ sig+16(FP), DX MOVL $SYS_tgkill, AX SYSCALL # è¿›å…¥ç³»ç»Ÿè°ƒç”¨ RET å…¨å±€ä¿¡å·å¤„ç†æ³¨å†Œ mstart1() ä¸»çº¿ç¨‹å¯åŠ¨è¿è¡Œåˆ°mstart()-\u0026gt;mstart0()-\u0026gt;mstart1()å‡½æ•°å†…æ—¶ã€‚ æ–‡ä»¶ä½ç½®ï¼šgo1.19.3/src/runtime/proc.goã€‚ 1394 1395 1396 1397 1398 1399 1400 1401 1402 1403 1404 1405 1406 1407 1408 1409 1410 1411 1412 // The go:noinline is to guarantee the getcallerpc/getcallersp below are safe, // so that we can set up g0.sched to return to the call of mstart1 above. // //go:noinline func mstart1() { // ... asminit() minit() // Install signal handlers; after minit so that minit can // prepare the thread to be able to handle the signals. // // å®‰è£…ä¿¡å·å¤„ç†ç¨‹åº;åœ¨minitä¹‹åï¼Œä»¥ä¾¿minitå¯ä»¥å‡†å¤‡çº¿ç¨‹ï¼Œä»¥ä¾¿èƒ½å¤Ÿå¤„ç†ä¿¡å·ã€‚ if gp.m == \u0026amp;m0 { mstartm0() } // ... } mstartm0() initsig(false)åˆ™æ˜¯æ³¨å†Œä¿¡å·å¤„ç†ç›¸å…³ã€‚ æ–‡ä»¶ä½ç½®ï¼šgo1.19.3/src/runtime/proc.goã€‚ 1435 1436 1437 1438 1439 1440 1441 1442 1443 1444 1445 1446 1447 1448 1449 1450 // mstartm0 implements part of mstart1 that only runs on the m0. // // Write barriers are allowed here because we know the GC can\u0026#39;t be // running yet, so they\u0026#39;ll be no-ops. // //go:yeswritebarrierrec func mstartm0() { // Create an extra M for callbacks on threads not created by Go. // An extra M is also needed on Windows for callbacks created by // syscall.NewCallback. See issue #6751 for details. if (iscgo || GOOS == \u0026#34;windows\u0026#34;) \u0026amp;\u0026amp; !cgoHasExtraM { cgoHasExtraM = true newextram() } initsig(false) } initsig() ä¿¡å·æ³¨å†Œã€‚ æ–‡ä»¶ä½ç½®ï¼šgo1.19.3/src/runtime/signal_unix.goã€‚ 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 // Initialize signals. // Called by libpreinit so runtime may not be initialized. // //go:nosplit //go:nowritebarrierrec func initsig(preinit bool) { if !preinit { // It\u0026#39;s now OK for signal handlers to run. // // ç°åœ¨å¯ä»¥è¿è¡Œä¿¡å·å¤„ç†ç¨‹åºäº†ã€‚ signalsOK = true } // For c-archive/c-shared this is called by libpreinit with // preinit == true. if (isarchive || islibrary) \u0026amp;\u0026amp; !preinit { return } // éå†ä¿¡å·æ•°ç»„ // const _NSIG int = 65; for i := uint32(0); i \u0026lt; _NSIG; i++ { // sigtable å…¨å±€å˜é‡å­˜å‚¨çš„æ˜¯æ‰€æœ‰ä¿¡å·åŠæè¿° t := \u0026amp;sigtable[i] // const _SigDefault int = 16; // å¦‚æœä¿¡å·æ²¡æœ‰è¢«æ˜¾å¼è¯·æ±‚ï¼Œå°±ä¸è¦ç›‘è§†å®ƒ // ç•¥è¿‡ä¿¡å·ï¼ŒSIGKILLã€SIGSTOPã€SIGTSTPã€SIGCONTã€SIGTTINã€SIGTTOU if t.flags == 0 || t.flags\u0026amp;_SigDefault != 0 { continue } // We don\u0026#39;t need to use atomic operations here because // there shouldn\u0026#39;t be any other goroutines running yet. fwdSig[i] = getsig(i) if !sigInstallGoHandler(i) { // Even if we are not installing a signal handler, // set SA_ONSTACK if necessary. if fwdSig[i] != _SIG_DFL \u0026amp;\u0026amp; fwdSig[i] != _SIG_IGN { setsigstack(i) } else if fwdSig[i] == _SIG_IGN { sigInitIgnored(i) } continue } handlingSig[i] = 1 setsig(i, abi.FuncPCABIInternal(sighandler)) } } setsig() è¿™é‡Œéœ€è¦æ³¨æ„çš„æ˜¯ï¼Œå½“ fn ç­‰äº sighandler çš„æ—¶å€™ï¼Œè°ƒç”¨çš„å‡½æ•°ä¼šè¢«æ›¿æ¢æˆ sigtrampã€‚ sigaction å‡½æ•°åœ¨ Linux ä¸‹ä¼šè°ƒç”¨ç³»ç»Ÿè°ƒç”¨å‡½æ•° sys_signal ä»¥åŠ sys_rt_sigaction å®ç°å®‰è£…ä¿¡å·ã€‚ æ–‡ä»¶ä½ç½®ï¼šgo1.19.3/src/runtime/os_linux.goã€‚ 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 //go:nosplit //go:nowritebarrierrec func setsig(i uint32, fn uintptr) { var sa sigactiont sa.sa_flags = _SA_SIGINFO | _SA_ONSTACK | _SA_RESTORER | _SA_RESTART sigfillset(\u0026amp;sa.sa_mask) // Although Linux manpage says \u0026#34;sa_restorer element is obsolete and // should not be used\u0026#34;. x86_64 kernel requires it. Only use it on // x86. if GOARCH == \u0026#34;386\u0026#34; || GOARCH == \u0026#34;amd64\u0026#34; { sa.sa_restorer = abi.FuncPCABI0(sigreturn) } if fn == abi.FuncPCABIInternal(sighandler) { // abi.FuncPCABIInternal(sighandler) matches the callers in signal_unix.go if iscgo { fn = abi.FuncPCABI0(cgoSigtramp) } else { // æ›¿æ¢ä¸ºè°ƒç”¨ sigtramp fn = abi.FuncPCABI0(sigtramp) } } sa.sa_handler = fn sigaction(i, \u0026amp;sa, nil) } ä¿¡å·å½¢å¼å“åº”æŠ¢å  sigtramp() å‡½æ•°åŸå‹ï¼šfunc sigtramp()ã€‚ sigtramp()å®é™…ä¸Šæ˜¯çœŸæ­£çš„ä¿¡å·å¤„ç†å‡½æ•°ï¼Œè¿›ç¨‹ä»å†…æ ¸æ€æ”¶åˆ°ä¿¡å·å›åˆ°ç”¨æˆ·æ€è°ƒç”¨çš„å¤„ç†å‡½æ•°å°±æ˜¯å®ƒã€‚ æ³¨é‡Šä¸­è¡¨æ˜è¿™ä¸ªå‡½æ•°ä»¥Cè¯­è¨€çš„è°ƒç”¨æƒ¯ä¾‹è¢«è°ƒç”¨ï¼ŒGoåœ¨è¿™é‡Œé€šè¿‡PUSH_REGS_HOST_TO_ABI0ä¿å­˜goè‡ªå·±è°ƒç”¨æƒ¯ä¾‹ç”¨çš„å¯„å­˜å™¨åï¼Œ è½¬æ¢æˆè‡ªå·±çš„è°ƒç”¨è§„èŒƒï¼Œç­‰å‡½æ•°è°ƒç”¨å®Œæ¯•ä¹‹åï¼Œå†é€šè¿‡POP_REGS_HOST_TO_ABI0æ¢å¤è¿™äº›å¯„å­˜å™¨çš„å€¼ã€‚ è°ƒåº¦è·¯å¾„sigtramp()-\u0026gt;sigtrampgo()-\u0026gt;sighandler()-\u0026gt;doSigPreempt()ã€‚ è¿™é‡Œä¼šè¢«è°ƒç”¨è¯´æ˜ä¿¡å·å·²ç»å‘é€å“åº”äº†ï¼ŒruntimeÂ·sigtrampä¼šè¿›è¡Œä¿¡å·çš„å¤„ç†ã€‚ runtimeÂ·sigtrampä¼šç»§ç»­è°ƒç”¨runtimeÂ·sigtrampgoã€‚ æ–‡ä»¶ä½ç½®ï¼šgo1.19.3/src/runtime/sys_linux_amd64.sã€‚ 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 # Called using C ABI. TEXT runtimeÂ·sigtramp(SB),NOSPLIT|TOPFRAME,$0 # Transition from C ABI to Go ABI. PUSH_REGS_HOST_TO_ABI0() # Set up ABIInternal environment: g in R14, cleared X15. get_tls(R12) # TLS MOVQ g(R12), R14 # R14 = g PXOR X15, X15 # Reserve space for spill slots. NOP SP # disable vet stack checking ADJSP $24 # Call into the Go signal handler # # å†…æ ¸ä¿®æ”¹ç”¨æˆ·æ€å¯„å­˜å™¨æ—¶è®¾ç½®çš„ rdiã€rsiã€rdx # ä¸‰ä¸ªå¯„å­˜å™¨çš„å€¼å°±æ˜¯å†…æ ¸æ¨¡ä»¿è°ƒç”¨sigtrampæ—¶ä¼ å…¥çš„å‚æ•° MOVQ DI, AX\t# sig MOVQ SI, BX\t# info MOVQ DX, CX\t# ctx CALL Â·sigtrampgo\u0026lt;ABIInternal\u0026gt;(SB) ADJSP $-24 POP_REGS_HOST_TO_ABI0() RET sigtrampgo() æ–‡ä»¶ä½ç½®ï¼šgo1.19.3/src/runtime/signal_unix.goã€‚ 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 // sigtrampgo is called from the signal handler function, sigtramp, // written in assembly code. // This is called by the signal handler, and the world may be stopped. // // It must be nosplit because getg() is still the G that was running // (if any) when the signal was delivered, but it\u0026#39;s (usually) called // on the gsignal stack. Until this switches the G to gsignal, the // stack bounds check won\u0026#39;t work. // //go:nosplit //go:nowritebarrierrec func sigtrampgo(sig uint32, info *siginfo, ctx unsafe.Pointer) { if sigfwdgo(sig, info, ctx) { return } c := \u0026amp;sigctxt{info, ctx} gp := sigFetchG(c) // g setg(gp) if gp == nil { if sig == _SIGPROF { // Some platforms (Linux) have per-thread timers, which we use in // combination with the process-wide timer. Avoid double-counting. if validSIGPROF(nil, c) { sigprofNonGoPC(c.sigpc()) } return } if sig == sigPreempt \u0026amp;\u0026amp; preemptMSupported \u0026amp;\u0026amp; debug.asyncpreemptoff == 0 { // This is probably a signal from preemptM sent // while executing Go code but received while // executing non-Go code. // We got past sigfwdgo, so we know that there is // no non-Go signal handler for sigPreempt. // The default behavior for sigPreempt is to ignore // the signal, so badsignal will be a no-op anyway. if GOOS == \u0026#34;darwin\u0026#34; || GOOS == \u0026#34;ios\u0026#34; { pendingPreemptSignals.Add(-1) } return } c.fixsigcode(sig) badsignal(uintptr(sig), c) return } setg(gp.m.gsignal) // If some non-Go code called sigaltstack, adjust. var gsignalStack gsignalStack setStack := adjustSignalStack(sig, gp.m, \u0026amp;gsignalStack) if setStack { gp.m.gsignal.stktopsp = getcallersp() } if gp.stackguard0 == stackFork { signalDuringFork(sig) } c.fixsigcode(sig) sighandler(sig, info, ctx, gp) setg(gp) if setStack { restoreGsignalStack(\u0026amp;gsignalStack) } } sighander() å“åº”æŠ¢å ã€‚è°ƒåº¦è·¯å¾„sigtramp()-\u0026gt;sigtrampgo()-\u0026gt;sighandler()-\u0026gt;doSigPreempt()ã€‚ æ–‡ä»¶ä½ç½®ï¼šgo1.19.3/src/runtime/signal_unix.goã€‚ 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 // sighandler is invoked when a signal occurs. The global g will be // set to a gsignal goroutine and we will be running on the alternate // signal stack. The parameter g will be the value of the global g // when the signal occurred. The sig, info, and ctxt parameters are // from the system signal handler: they are the parameters passed when // the SA is passed to the sigaction system call. // // The garbage collector may have stopped the world, so write barriers // are not allowed. // //go:nowritebarrierrec func sighandler(sig uint32, info *siginfo, ctxt unsafe.Pointer, gp *g) { // ... ... // sig == sigPreemptï¼šæŠ¢å ä¿¡å· // debug.asyncpreemptoff == 0ï¼šæ²¡æœ‰ç¦æ­¢æŠ¢å  // delayedSignalï¼šå»¶è¿Ÿä¿¡å·? if sig == sigPreempt \u0026amp;\u0026amp; debug.asyncpreemptoff == 0 \u0026amp;\u0026amp; !delayedSignal { // Might be a preemption signal. // å¯èƒ½æ˜¯ä¸€ä¸ªæŠ¢å ä¿¡å·ã€‚ doSigPreempt(gp, c) // Even if this was definitely a preemption signal, it // may have been coalesced with another signal, so we // still let it through to the application. // å³ä½¿è¿™ç¡®å®æ˜¯ä¸€ä¸ªæŠ¢å ä¿¡å·ï¼Œå®ƒå¯èƒ½å·²ç»ä¸å¦ä¸€ä¸ªä¿¡å·åˆå¹¶ï¼Œæ‰€ä»¥æˆ‘ä»¬ä»ç„¶è®©å®ƒé€šè¿‡åº”ç”¨ç¨‹åºã€‚ } // ... ... } doSigPreempt() doSigPreemptå¤„ç†gpä¸Šçš„æŠ¢å ä¿¡å·ã€‚ è°ƒç”¨åˆ°doSigPreemptæ—¶ï¼Œä¼šå°†ctxè¿™ä¸ªå‚æ•°ä¼ å…¥ï¼Œå…¶ä¸­åŒ…å«äº†è¿›ç¨‹ç”¨æˆ·æ€ç¡¬ä»¶ä¸Šä¸‹æ–‡ ctxtçš„ç±»å‹ä¸º*sigctxtï¼ŒæŒ‡å‘çš„æ˜¯ç”¨æˆ·æ€å †æ ˆä¸­å­˜æ”¾å†…æ ¸æ€å †æ ˆå†…å®¹çš„åœ°å€ã€‚ ç„¶åä¿¡å·å¤„ç†ç¨‹åºé€šè¿‡isAsyncSafePointæ¥åˆ¤æ–­æŠ¢å ä½ç½®æ˜¯å¦å®‰å…¨ï¼Œå¹¶è¿”å›å®‰å…¨çš„æŠ¢å åœ°å€ã€‚ å¦‚æœç¡®è®¤æŠ¢å æ²¡æœ‰é—®é¢˜ï¼Œæ¥ç€ä¼šè°ƒç”¨pushCallæ–¹æ³•æ¥ä¿®æ”¹ctxtä¸­çš„ç”¨æˆ·æ€ç¡¬ä»¶ä¸Šä¸‹æ–‡ï¼Œ ç”¨äºç¨åå†ä¸€æ¬¡ä»å†…æ ¸æ€è¿”å›ç”¨æˆ·æ€æ—¶æ¨¡æ‹Ÿå‡ºä¸€ä¸ªç”¨æˆ·æ€ç¨‹åºè°ƒç”¨asyncPreemptçš„å‡è±¡ã€‚ æ–‡ä»¶ä½ç½®ï¼šgo1.19.3/src/runtime/signal_unix.goã€‚ 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 // doSigPreempt handles a preemption signal on gp. func doSigPreempt(gp *g, ctxt *sigctxt) { // Check if this G wants to be preempted and is safe to // preempt. // æ£€æŸ¥è¿™ä¸ªGæ˜¯å¦å¸Œæœ›è¢«æŠ¢å ï¼Œå¹¶ä¸”æŠ¢å æ˜¯å®‰å…¨çš„ã€‚ // é€šè¿‡ wantAsyncPreempt å‡½æ•°ç¡®è®¤runtimeç¡®å®æƒ³è¦å¯¹æŒ‡å®šçš„Gå®æ–½å¼‚æ­¥æŠ¢å  if wantAsyncPreempt(gp) { // é€šè¿‡isAsyncSafePointå‡½æ•°ç¡®è®¤Gå½“å‰æ‰§è¡Œä¸Šä¸‹æ–‡æ˜¯èƒ½å¤Ÿå®‰å…¨åœ°è¿›è¡Œå¼‚æ­¥æŠ¢å çš„ã€‚ if ok, newpc := isAsyncSafePoint(gp, ctxt.sigpc(), ctxt.sigsp(), ctxt.siglr()); ok { // Adjust the PC and inject a call to asyncPreempt. // ä»¥ä¸Šä¸¤ä¸ªå‡½æ•°éƒ½ç¡®è®¤æ— è¯¯åï¼Œæ‰é€šè¿‡pushCallå‘Gçš„æ‰§è¡Œä¸Šä¸‹æ–‡ä¸­æ³¨å…¥ä¸€ä¸ªå‡½æ•°è°ƒç”¨ï¼Œ // è¦è°ƒç”¨çš„ç›®æ ‡å‡½æ•°æ˜¯ runtime.asyncPreempt å‡½æ•°ã€‚è¿™æ˜¯ä¸€ä¸ªæ±‡ç¼–å‡½æ•°ï¼Œå®ƒä¼šå…ˆæŠŠå„ä¸ªå¯„å­˜å™¨çš„å€¼ä¿å­˜åœ¨æ ˆä¸Šï¼Œ // ä¹Ÿå°±æ˜¯å°†ç°åœºä¿å­˜åœ¨æ ˆä¸Šï¼Œç„¶åè°ƒç”¨ runtime.asyncPreempt2å‡½æ•°ã€‚ ctxt.pushCall(abi.FuncPCABI0(asyncPreempt), newpc) // å°±æ˜¯å‘å½“å‰è¿è¡Œçš„goroutineæ³¨å†ŒåŠ å…¥asyncPreemptå‡½æ•° } } // Acknowledge the preemption. atomic.Xadd(\u0026amp;gp.m.preemptGen, 1) atomic.Store(\u0026amp;gp.m.signalPending, 0) if GOOS == \u0026#34;darwin\u0026#34; || GOOS == \u0026#34;ios\u0026#34; { atomic.Xadd(\u0026amp;pendingPreemptSignals, -1) } } wantAsyncPreempt() wantAsyncPreemptè¿”å›å¼‚æ­¥æŠ¢å æ˜¯å¦ä¸ºgpæ’é˜Ÿã€‚ æ–‡ä»¶ä½ç½®ï¼šgo1.19.3/src/runtime/preempt.goã€‚ 340 341 342 343 344 345 346 347 348 349 350 // wantAsyncPreempt returns whether an asynchronous preemption is // queued for gp. func wantAsyncPreempt(gp *g) bool { // Check both the G and the P. // åŒæ—¶æ£€æŸ¥Gå’ŒPçš„preemptå­—æ®µï¼Œå¹¶ä¸”Gå½“å‰éœ€è¦å¤„äº_GrunningçŠ¶æ€ã€‚ // åœ¨æ¯è½®è°ƒåº¦å¾ªç¯ä¸­ï¼ŒPå’ŒGçš„preemptå­—æ®µéƒ½ä¼šè¢«ç½®ä¸ºfalseï¼Œæ‰€ä»¥è¿™ä¸ªæ£€æµ‹èƒ½å¤Ÿé¿å…åˆšåˆšåˆ‡æ¢è‡³ä¸€ä¸ªæ–°çš„Gåé©¬ä¸Šåˆè¢«æŠ¢å ã€‚ // gp.preempt || gp.m.p != 0 \u0026amp;\u0026amp; gp.m.p.ptr().preemptï¼šåˆ¤æ–­Gæˆ–Pçš„preemptæŠ¢å æ ‡è¯†ä½ã€‚ // readgstatus(gp)\u0026amp;^_Gscan == _Grunningï¼šå½“å‰Gæ­£åœ¨è¿è¡ŒçŠ¶æ€ã€‚ // ç¡®è®¤æ˜¯å¦è®¾ç½®äº†æŠ¢å æ ‡å¿— return (gp.preempt || gp.m.p != 0 \u0026amp;\u0026amp; gp.m.p.ptr().preempt) \u0026amp;\u0026amp; readgstatus(gp)\u0026amp;^_Gscan == _Grunning } isAsyncSafePoint() å®ƒä»ä»¥ä¸‹å‡ ä¸ªæ–¹é¢æ¥ä¿è¯åœ¨å½“å‰ä½ç½®è¿›è¡Œå¼‚æ­¥æŠ¢å æ˜¯å®‰å…¨çš„ã€‚ å¯ä»¥æŒ‚èµ·Gå¹¶å®‰å…¨çš„æ‰«æå®ƒçš„æ ˆå’Œå¯„å­˜å™¨ï¼Œæ²¡æœ‰æ½œåœ¨çš„éšè—æŒ‡é’ˆï¼Œè€Œä¸”å½“å‰å¹¶æ²¡æœ‰æ‰“æ–­ä¸€ä¸ªå†™å±éšœã€‚ Gè¿˜æœ‰è¶³å¤Ÿçš„æ ˆç©ºé—´æ¥æ³¨å…¥ä¸€ä¸ªå¯¹asyncPreempt()å‡½æ•°çš„è°ƒç”¨ã€‚ å¯ä»¥å®‰å…¨åœ°å’Œ runtime è¿›è¡Œäº¤äº’ï¼Œä¾‹å¦‚æœªæŒæœ‰ runtime ç›¸å…³çš„é”ï¼Œå› æ­¤åœ¨å°è¯•è·å¾—é”æ—¶ä¸ä¼šé€ æˆæ­»é”ã€‚ isAsyncSafePointæŠ¥å‘ŠæŒ‡ä»¤PCä¸Šçš„gpæ˜¯å¦æ˜¯å¼‚æ­¥å®‰å…¨ç‚¹ã€‚è¿™è¡¨æ˜ï¼š æš‚åœgpå¹¶ä¿å®ˆåœ°æ‰«æå®ƒçš„å †æ ˆå’Œå¯„å­˜å™¨æ˜¯å®‰å…¨çš„ã€‚å®ƒæ²¡æœ‰æ½œåœ¨çš„éšè—æŒ‡é’ˆå€¼ï¼Œä¹Ÿä¸åƒå†™å±éšœé‚£æ ·ä½äºåŸå­åºåˆ—çš„ä¸­é—´ã€‚ gpæœ‰è¶³å¤Ÿçš„å †æ ˆç©ºé—´æ³¨å…¥asyncPreemptè°ƒç”¨ã€‚ é€šå¸¸æƒ…å†µä¸‹ï¼Œä¸è¿è¡Œæ—¶äº¤äº’æ˜¯å®‰å…¨çš„ï¼Œå³ä½¿æˆ‘ä»¬åœ¨ä¿¡å·å¤„ç†ç¨‹åºä¸­å°±åœåœ¨è¿™é‡Œã€‚ä¾‹å¦‚ï¼Œæ²¡æœ‰æŒæœ‰è¿è¡Œæ—¶é”ï¼Œå› æ­¤è·å–è¿è¡Œæ—¶é”ä¸ä¼šè‡ªæ­»é”ã€‚ åœ¨æŸäº›æƒ…å†µä¸‹ï¼ŒPCæ˜¯å®‰å…¨çš„å¼‚æ­¥æŠ¢å ï¼Œä½†å®ƒä¹Ÿéœ€è¦è°ƒæ•´æ¢å¤PCã€‚æ–°çš„PCåœ¨ç¬¬äºŒä¸ªç»“æœä¸­è¿”å›ã€‚ æ–‡ä»¶ä½ç½®ï¼šgo1.19.3/src/runtime/preempt.goã€‚ 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 // isAsyncSafePoint reports whether gp at instruction PC is an // asynchronous safe point. This indicates that: // // 1. It\u0026#39;s safe to suspend gp and conservatively scan its stack and // registers. There are no potentially hidden pointer values and it\u0026#39;s // not in the middle of an atomic sequence like a write barrier. // // 2. gp has enough stack space to inject the asyncPreempt call. // // 3. It\u0026#39;s generally safe to interact with the runtime, even if we\u0026#39;re // in a signal handler stopped here. For example, there are no runtime // locks held, so acquiring a runtime lock won\u0026#39;t self-deadlock. // // In some cases the PC is safe for asynchronous preemption but it // also needs to adjust the resumption PC. The new PC is returned in // the second result. func isAsyncSafePoint(gp *g, pc, sp, lr uintptr) (bool, uintptr) { mp := gp.m // Only user Gs can have safe-points. We check this first // because it\u0026#39;s extremely common that we\u0026#39;ll catch mp in the // scheduler processing this G preemption. // // åªæœ‰ç”¨æˆ·Gså¯ä»¥æœ‰å®‰å…¨ç‚¹ã€‚æˆ‘ä»¬é¦–å…ˆæ£€æŸ¥è¿™ä¸ªï¼Œå› ä¸ºåœ¨å¤„ç†GæŠ¢å çš„è°ƒåº¦å™¨ä¸­æ•è·mpæ˜¯éå¸¸å¸¸è§çš„ã€‚ if mp.curg != gp { return false, 0 } // Check M state. // æ£€æŸ¥MçŠ¶æ€ã€‚ // canPreemptM(mp) -\u0026gt; mp.locks == 0 \u0026amp;\u0026amp; mp.mallocing == 0 \u0026amp;\u0026amp; mp.preemptoff == \u0026#34;\u0026#34; \u0026amp;\u0026amp; mp.p.ptr().status == _Prunning if mp.p == 0 || !canPreemptM(mp) { return false, 0 } // Check stack space. // æ£€æŸ¥æ ˆç©ºé—´ã€‚ // asyncPreemptStackæ˜¯æ³¨å…¥ä¸€ä¸ªasyncPreemptè°ƒç”¨æ‰€éœ€çš„æ ˆç©ºé—´çš„å­—èŠ‚ã€‚ if sp \u0026lt; gp.stack.lo || sp-gp.stack.lo \u0026lt; asyncPreemptStack { return false, 0 } // Check if PC is an unsafe-point. // æ£€æŸ¥PCæ˜¯å¦ä¸ºä¸å®‰å…¨ç‚¹ã€‚ f := findfunc(pc) if !f.valid() { // Not Go code. return false, 0 } if (GOARCH == \u0026#34;mips\u0026#34; || GOARCH == \u0026#34;mipsle\u0026#34; || GOARCH == \u0026#34;mips64\u0026#34; || GOARCH == \u0026#34;mips64le\u0026#34;) \u0026amp;\u0026amp; lr == pc+8 \u0026amp;\u0026amp; funcspdelta(f, pc, nil) == 0 { // We probably stopped at a half-executed CALL instruction, // where the LR is updated but the PC has not. If we preempt // here we\u0026#39;ll see a seemingly self-recursive call, which is in // fact not. // This is normally ok, as we use the return address saved on // stack for unwinding, not the LR value. But if this is a // call to morestack, we haven\u0026#39;t created the frame, and we\u0026#39;ll // use the LR for unwinding, which will be bad. return false, 0 } up, startpc := pcdatavalue2(f, _PCDATA_UnsafePoint, pc) if up == _PCDATA_UnsafePointUnsafe { // Unsafe-point marked by compiler. This includes // atomic sequences (e.g., write barrier) and nosplit // functions (except at calls). return false, 0 } if fd := funcdata(f, _FUNCDATA_LocalsPointerMaps); fd == nil || f.flag\u0026amp;funcFlag_ASM != 0 { // This is assembly code. Don\u0026#39;t assume it\u0026#39;s well-formed. // TODO: Empirically we still need the fd == nil check. Why? // // TODO: Are there cases that are safe but don\u0026#39;t have a // locals pointer map, like empty frame functions? // It might be possible to preempt any assembly functions // except the ones that have funcFlag_SPWRITE set in f.flag. return false, 0 } name := funcname(f) if inldata := funcdata(f, _FUNCDATA_InlTree); inldata != nil { inltree := (*[1 \u0026lt;\u0026lt; 20]inlinedCall)(inldata) ix := pcdatavalue(f, _PCDATA_InlTreeIndex, pc, nil) if ix \u0026gt;= 0 { name = funcnameFromNameoff(f, inltree[ix].func_) } } if hasPrefix(name, \u0026#34;runtime.\u0026#34;) || hasPrefix(name, \u0026#34;runtime/internal/\u0026#34;) || hasPrefix(name, \u0026#34;reflect.\u0026#34;) { // For now we never async preempt the runtime or // anything closely tied to the runtime. Known issues // include: various points in the scheduler (\u0026#34;don\u0026#39;t // preempt between here and here\u0026#34;), much of the defer // implementation (untyped info on stack), bulk write // barriers (write barrier check), // reflect.{makeFuncStub,methodValueCall}. // // TODO(austin): We should improve this, or opt things // in incrementally. return false, 0 } switch up { case _PCDATA_Restart1, _PCDATA_Restart2: // Restartable instruction sequence. Back off PC to // the start PC. if startpc == 0 || startpc \u0026gt; pc || pc-startpc \u0026gt; 20 { throw(\u0026#34;bad restart PC\u0026#34;) } return true, startpc case _PCDATA_RestartAtEntry: // Restart from the function entry at resumption. return true, f.entry() } return true, pc } pushCall() pushCallå¹²äº†ä¸¤ä»¶äº‹ï¼š ä¿®æ”¹ç¨‹åºè®¡æ•°å™¨çš„æŒ‡å‘ä¸ºasyncPreemptå‡½æ•°çš„åœ°å€ã€‚ ä¿®æ”¹æ ˆé¡¶æŒ‡é’ˆï¼Œå°†å½“å‰ goroutine çš„åŸæœ¬ä¸­æ–­åœ°å€æ”¾å…¥å †æ ˆã€‚ æ–‡ä»¶ä½ç½®ï¼šgo1.19.3/src/runtime/signal_amd64.goã€‚ å…ˆæŠŠSPå‘ä¸‹ç§»åŠ¨ä¸€ä¸ªæŒ‡é’ˆå¤§å°çš„ä½ç½®ï¼ŒæŠŠPCçš„å€¼å­˜å…¥æ ˆä¸ŠSPæŒ‡å‘çš„ä½ç½®ï¼Œç„¶åå°†PCçš„å€¼æ›´æ–°ä¸ºtargetPCã€‚ è¿™æ ·å°±æ¨¡æ‹Ÿäº†ä¸€æ¡CALLæŒ‡ä»¤çš„æ•ˆæœï¼Œæ ˆä¸Šå­˜å…¥çš„PCçš„æ—§å€¼å°±ç›¸å½“äºè¿”å›åœ°å€ã€‚ æ­¤æ—¶æ•´ä¸ªæ‰§è¡Œä¸Šä¸‹æ–‡çš„çŠ¶æ€å°±åƒæ˜¯goroutineåœ¨è¢«ä¿¡å·æ‰“æ–­çš„ä½ç½®é¢å¤–æ‰§è¡Œäº†ä¸€æ¡CALL targetPCæŒ‡ä»¤ã€‚ ç”±äºæ‰§è¡Œæµç¨‹åˆšåˆšè·³è½¬åˆ°targetPCåœ°å€å¤„ï¼Œæ‰€ä»¥è¿˜æ²¡æ¥å¾—åŠæ‰§è¡Œç›®æ ‡åœ°å€å¤„çš„æŒ‡ä»¤ã€‚ å½“sighandler()å‡½æ•°å¤„ç†å®Œä¿¡å·å¹¶è¿”å›åï¼Œè¢«æ‰“æ–­çš„goroutineå¾—ä»¥ç»§ç»­æ‰§è¡Œï¼Œä¼šç«‹å³è°ƒç”¨è¢«æ³¨å…¥çš„asyncPreempt()å‡½æ•°ã€‚ç»è¿‡ä¸€è¿ä¸²çš„å‡½æ•°è°ƒç”¨ï¼Œæœ€ç»ˆæ‰§è¡Œåˆ°schedule()å‡½æ•°ã€‚ å‚æ•°ï¼š targetPC uintptrï¼šasyncPreempt å‡½æ•°çš„æ‰§è¡Œå…¥å£åœ°å€ã€‚ resumePC uintptrï¼šå…¶å®å°±æ˜¯å‘ç”Ÿä¸­æ–­å‰å½“å‰goroutineçš„ä¸‹ä¸€æŒ‡ä»¤åœ°å€ï¼Œä¹Ÿå°±æ˜¯PCçš„å€¼ã€‚ 80 81 82 83 84 85 86 87 88 89 func (c *sigctxt) pushCall(targetPC, resumePC uintptr) { // Make it look like we called target at resumePC. // è®©å®ƒçœ‹èµ·æ¥åƒæˆ‘ä»¬åœ¨resumePCä¸Šè°ƒç”¨äº†targetã€‚ sp := uintptr(c.rsp()) // å½“å‰goroutineçš„SP sp -= goarch.PtrSize *(*uintptr)(unsafe.Pointer(sp)) = resumePC // è®¾ç½®å½“å‰ä¸­æ–­ä¿å­˜çš„ä¸Šä¸‹æ–‡ä¿¡æ¯ï¼Œå› ä¸ºä¸­æ–­ç»“æŸåä»è¿™é‡Œæ¢å¤ã€‚ c.set_rsp(uint64(sp)) // ä¿®æ”¹ä¸­æ–­ä¿å­˜çš„ä¸Šä¸‹æ–‡SP c.set_rip(uint64(targetPC)) // ä¿®æ”¹ä¸­æ–­ä¿å­˜çš„ä¸Šä¸‹æ–‡PC } asyncPreempt() ä¸­æ–­ä¿¡å·å‡½æ•°å¤„ç†å®Œåï¼Œgoroutineå¾—åˆ°è¿è¡Œï¼Œç»§ç»­ä»åµŒå…¥çš„æœ¬å‡½æ•°å¼€å§‹æ‰§è¡Œã€‚ æ–‡ä»¶ä½ç½®ï¼šgo1.19.3/src/runtime/preempt_amd64.sã€‚ 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 TEXT Â·asyncPreempt(SB),NOSPLIT|NOFRAME,$0-0 PUSHQ BP # BPå…¥æ ˆ MOVQ SP, BP # BP = SP # Save flags before clobbering them PUSHFQ # obj doesn\u0026#39;t understand ADD/SUB on SP, but does understand ADJSP ADJSP $368 # But vet doesn\u0026#39;t know ADJSP, so suppress vet stack checking NOP SP MOVQ AX, 0(SP) MOVQ CX, 8(SP) MOVQ DX, 16(SP) MOVQ BX, 24(SP) MOVQ SI, 32(SP) MOVQ DI, 40(SP) MOVQ R8, 48(SP) MOVQ R9, 56(SP) MOVQ R10, 64(SP) MOVQ R11, 72(SP) MOVQ R12, 80(SP) MOVQ R13, 88(SP) MOVQ R14, 96(SP) MOVQ R15, 104(SP) #ifdef GOOS_darwin CMPB internalâˆ•cpuÂ·X86+const_offsetX86HasAVX(SB), $0 JE 2(PC) VZEROUPPER #endif MOVUPS X0, 112(SP) MOVUPS X1, 128(SP) MOVUPS X2, 144(SP) MOVUPS X3, 160(SP) MOVUPS X4, 176(SP) MOVUPS X5, 192(SP) MOVUPS X6, 208(SP) MOVUPS X7, 224(SP) MOVUPS X8, 240(SP) MOVUPS X9, 256(SP) MOVUPS X10, 272(SP) MOVUPS X11, 288(SP) MOVUPS X12, 304(SP) MOVUPS X13, 320(SP) MOVUPS X14, 336(SP) MOVUPS X15, 352(SP) CALL Â·asyncPreempt2(SB) # è°ƒç”¨asyncPreempt2 # ä¸‹æ¬¡goroutineå†åº¦è¢«è¿è¡Œèµ·æ¥æ—¶ï¼Œä»è¿™é‡Œæ¢å¤ã€‚ MOVUPS 352(SP), X15 MOVUPS 336(SP), X14 MOVUPS 320(SP), X13 MOVUPS 304(SP), X12 MOVUPS 288(SP), X11 MOVUPS 272(SP), X10 MOVUPS 256(SP), X9 MOVUPS 240(SP), X8 MOVUPS 224(SP), X7 MOVUPS 208(SP), X6 MOVUPS 192(SP), X5 MOVUPS 176(SP), X4 MOVUPS 160(SP), X3 MOVUPS 144(SP), X2 MOVUPS 128(SP), X1 MOVUPS 112(SP), X0 MOVQ 104(SP), R15 MOVQ 96(SP), R14 MOVQ 88(SP), R13 MOVQ 80(SP), R12 MOVQ 72(SP), R11 MOVQ 64(SP), R10 MOVQ 56(SP), R9 MOVQ 48(SP), R8 MOVQ 40(SP), DI MOVQ 32(SP), SI MOVQ 24(SP), BX MOVQ 16(SP), DX MOVQ 8(SP), CX MOVQ 0(SP), AX ADJSP $-368 POPFQ POPQ BP RET # è¿”å›ç»§ç»­å»æ‰§è¡ŒåŸæ¥çš„goroutineä»£ç  asyncPreempt2() æ–‡ä»¶ä½ç½®ï¼šgo1.19.3/src/runtime/preempt.goã€‚ 301 302 303 304 305 306 307 308 309 310 311 312 313 314 //go:nosplit func asyncPreempt2() { gp := getg() gp.asyncSafePoint = true // preemptStop ä¸»è¦åœ¨GCæ ‡è®°æœŸé—´è¢«ç”¨æ¥æŒ‚èµ·è¿è¡Œä¸­çš„ goroutine if gp.preemptStop { // preemptParkä¼šæŠŠå½“å‰gåˆ‡æ¢è‡³_GpreemptedçŠ¶æ€ï¼Œç„¶åè°ƒç”¨scheduleå‡½æ•° mcall(preemptPark) } else { // é€šè¿‡preemptoneå‡½æ•°å‘èµ·çš„å¼‚æ­¥æŠ¢å ä¼šè°ƒç”¨gopreempt_må‡½æ•°ï¼Œå®ƒæœ€ç»ˆä¹Ÿä¼šè°ƒç”¨scheduleå‡½æ•° mcall(gopreempt_m) } gp.asyncSafePoint = false } gopreempt_m() æ–‡ä»¶ä½ç½®ï¼šgo1.19.3/src/runtime/proc.goã€‚ 3402 3403 3404 3405 3406 3407 func gopreempt_m(gp *g) { if trace.enabled { traceGoPreempt() } goschedImpl(gp) } goschedImpl() GåŠ å…¥å…¨å±€é˜Ÿåˆ—ï¼Œè§£é™¤Gä¸Mçš„å…³ç³»ï¼Œå†æ¬¡å‘èµ·è°ƒåº¦å¾ªç¯ã€‚ æ–‡ä»¶ä½ç½®ï¼šgo1.19.3/src/runtime/proc.goã€‚ 3366 3367 3368 3369 3370 3371 3372 3373 3374 3375 3376 3377 3378 3379 3380 func goschedImpl(gp *g) { status := readgstatus(gp) // è·å–GçŠ¶æ€ if status\u0026amp;^_Gscan != _Grunning { dumpgstatus(gp) throw(\u0026#34;bad g status\u0026#34;) } // ä¿®æ”¹GçŠ¶æ€ _Grunnable casgstatus(gp, _Grunning, _Grunnable) dropg() // è§£é™¤ç»‘å®šå…³ç³» lock(\u0026amp;sched.lock) globrunqput(gp) // åŠ å…¥å…¨å±€é“¾è¡¨ unlock(\u0026amp;sched.lock) schedule() // è°ƒåº¦å¾ªç¯ } ","permalink":"https://heliu.site/posts/golang/goroutine/retake/","summary":"Golang æŠ¢å é•¿æ—¶é—´è¿è¡Œçš„goroutineã€‚","title":"è¢«åŠ¨è®©å‡ºè°ƒåº¦"},{"content":"type g struct æ¯ä¸€ä¸ªå®ä¾‹å¯¹è±¡ä»£è¡¨ä¸€ä¸ªgoroutineã€‚ è¯¥ç»“æ„ä½“ä¿å­˜CPUå¯„å­˜å™¨çš„å€¼ä»¥åŠgoroutineçš„æ‰€æœ‰ä¿¡æ¯ï¼ŒåŒ…æ‹¬æ ˆï¼Œgobufç»“æ„ä½“å’Œå…¶å®ƒçš„ä¸€äº›çŠ¶æ€ä¿¡æ¯ã€‚ è°ƒåº¦å™¨ä»£ç å¯ä»¥é€šè¿‡gå¯¹è±¡æ¥å¯¹goroutineè¿›è¡Œè°ƒåº¦ï¼š å½“goroutineè¢«è°ƒç¦»CPUæ—¶ï¼Œè°ƒåº¦å™¨ä»£ç è´Ÿè´£æŠŠCPUå¯„å­˜å™¨çš„å€¼ä¿å­˜åœ¨gå¯¹è±¡çš„æˆå‘˜å˜é‡ä¹‹ä¸­ã€‚ å½“goroutineè¢«è°ƒåº¦èµ·æ¥è¿è¡Œæ—¶ï¼Œè°ƒåº¦å™¨ä»£ç åˆè´Ÿè´£æŠŠgå¯¹è±¡çš„æˆå‘˜å˜é‡æ‰€ä¿å­˜çš„å¯„å­˜å™¨çš„å€¼æ¢å¤åˆ°CPUçš„å¯„å­˜å™¨ã€‚ type g struct { // Stack parameters. // stack describes the actual stack memory: [stack.lo, stack.hi). // stackguard0 is the stack pointer compared in the Go stack growth prologue. // It is stack.lo+StackGuard normally, but can be StackPreempt to trigger a preemption. // stackguard1 is the stack pointer compared in the C stack growth prologue. // It is stack.lo+StackGuard on g0 and gsignal stacks. // It is ~0 on other goroutine stacks, to trigger a call to morestackc (and crash). // // goroutineæ ˆä»¥åŠæ ˆæ‰©å®¹ç›¸å…³ä¿¡æ¯ // è®°å½•è¯¥goroutineä½¿ç”¨çš„æ ˆä¿¡æ¯ï¼Œ[lo,hi) stack stack // offset known to runtime/cgo // è¢«æ­£å¸¸çš„goroutineä½¿ç”¨ï¼Œç¼–è¯‘å™¨å®‰æ’åœ¨å‡½æ•°å¤´éƒ¨çš„æ ˆå¢é•¿ä»£ç ï¼Œç”¨å®ƒæ¥å’ŒSPæ¯”è¾ƒï¼ŒæŒ‰éœ€è¿›è¡Œæ ˆå¢é•¿ã€‚ // å®ƒçš„å€¼ä¸€èˆ¬æ˜¯ stcak.lo + StackGuardï¼Œä¹Ÿå¯èƒ½è¢«è®¾ç½®æˆ StackPreemptï¼Œä»¥è§¦å‘ä¸€æ¬¡æŠ¢å ã€‚ // const _StackGuard = 928; linux amd64 // const stackPreempt = 0xfffffade; ((1\u0026lt;\u0026lt;64) - 1) \u0026amp; -1314 stackguard0 uintptr // offset known to liblink // åŸç†å’Œ stackguard0 å·®ä¸å¤šï¼Œåªä¸è¿‡æ˜¯è¢« g0 å’Œ gsignal ä¸­çš„Cä»£ç ä½¿ç”¨ã€‚ stackguard1 uintptr // offset known to liblink // _panic å’Œ _defer åœ¨deferå’Œpanicä¸­è¢«ä½¿ç”¨ // panicé“¾è¡¨ï¼Œè®°å½•å½“å‰goroutineè§¦å‘çš„panicé“¾è¡¨ _panic *_panic // innermost panic - offset known to liblink // deferé“¾è¡¨ï¼Œè®°å½•æ•´ä¸ªè°ƒç”¨é“¾å‡½æ•°ä¸­æ³¨å†Œçš„deferå‡½æ•°é“¾è¡¨ _defer *_defer // innermost defer // å…³è”åˆ°æ­£åœ¨æ‰§è¡Œå½“å‰Gçš„å·¥ä½œçº¿ç¨‹Mï¼Œä¹Ÿå°±æ˜¯ type m struct ç»“æ„ä½“æŒ‡é’ˆ m *m // current m; offset known to arm liblink // ä¿å­˜è°ƒåº¦ä¿¡æ¯ï¼Œä¸»è¦æ˜¯å‡ ä¸ªå¯„å­˜å™¨çš„å€¼ï¼Œgè¢«è°ƒç¦»å‰CPUä»¥åŠå¯„å­˜å™¨ä¿¡æ¯ä¿å­˜åœ¨è¿™é‡Œï¼Œæ¢å¤åä»è¿™é‡Œä¿å­˜çš„ä¿¡æ¯å¼€å§‹ // è¢«è°ƒåº¦å™¨ï¼Œç”¨æ¥ä¿å­˜ goroutine çš„æ‰§è¡Œä¸Šä¸‹æ–‡ã€‚ sched gobuf // æ¡£æœŸå‰goroutineè¢«è°ƒåº¦æˆ–è€…è¢«ä¿å­˜æ˜¯CPUç›¸å…³ä¿¡æ¯å­˜å‚¨åœ¨è¿™é‡Œ // ç³»ç»Ÿè°ƒç”¨è¿›å…¥è°ƒç”¨å‰ï¼Œä¿å­˜SPå¯„å­˜å™¨å’ŒIPå¯„å­˜å™¨çš„å€¼ syscallsp uintptr// if status==Gsyscall, syscallsp = sched.sp to use during gc syscallpc uintptr// if status==Gsyscall, syscallpc = sched.pc to use during gc // åº”ä¸ºå †æ ˆé¡¶éƒ¨çš„spï¼Œç”¨äºå›æº¯ stktopsp uintptr// expected sp at top of stack, to check in traceback // param is a generic pointer parameter field used to pass // values in particular contexts where other storage for the // parameter would be difficult to find. It is currently used // in three ways: // 1. When a channel operation wakes up a blocked goroutine, it sets param to // point to the sudog of the completed blocking operation. // 2. By gcAssistAlloc1 to signal back to its caller that the goroutine completed // the GC cycle. It is unsafe to do so in any other way, because the goroutine\u0026#39;s // stack may have moved in the meantime. // 3. By debugCallWrap to pass parameters to a new goroutine because allocating a // closure in the runtime is forbidden. // // paramæ˜¯ä¸€ä¸ªé€šç”¨çš„æŒ‡é’ˆå‚æ•°å­—æ®µï¼Œç”¨äºåœ¨å¾ˆéš¾æ‰¾åˆ°å‚æ•°çš„å…¶ä»–å­˜å‚¨çš„ç‰¹å®šä¸Šä¸‹æ–‡ä¸­ä¼ é€’å€¼ã€‚å®ƒç›®å‰æœ‰ä¸‰ç§ä½¿ç”¨æ–¹å¼ï¼š // 1.å½“é€šé“æ“ä½œå”¤é†’è¢«é˜»å¡çš„goroutineæ—¶ï¼Œå®ƒå°†paramè®¾ç½®ä¸ºæŒ‡å‘å·²å®Œæˆé˜»å¡æ“ä½œçš„sudogã€‚ // 2.é€šè¿‡gcAssistAlloc1å‘å…¶è°ƒç”¨æ–¹å‘å‡ºä¿¡å·ï¼Œè¡¨æ˜goroutineå®Œæˆäº†GCå¾ªç¯ã€‚ // ä»¥ä»»ä½•å…¶ä»–æ–¹å¼è¿™æ ·åšéƒ½æ˜¯ä¸å®‰å…¨çš„ï¼Œå› ä¸ºgoroutineçš„å †æ ˆå¯èƒ½åœ¨æ­¤æœŸé—´å‘ç”Ÿäº†ç§»åŠ¨ã€‚ // 3.é€šè¿‡debugCallWrapå°†å‚æ•°ä¼ é€’ç»™æ–°çš„goroutineï¼Œå› ä¸ºç¦æ­¢åœ¨è¿è¡Œæ—¶åˆ†é…é—­åŒ…ã€‚ param unsafe.Pointer // passed parameter on wakeup // ç”¨æ¥è¡¨ç¤ºå½“å‰Gçš„çŠ¶æ€ã€‚ atomicstatus uint32 // è®°å½•å½“å‰Gçš„çŠ¶æ€ stackLock uint32 // sigprof/scang lock; TODO: fold in to atomicstatus // å½“å‰ goroutine çš„å…¨å±€å”¯ä¸€ IDã€‚ goid int64 // schedlinkå­—æ®µæŒ‡å‘å…¨å±€è¿è¡Œé˜Ÿåˆ—ä¸­çš„ä¸‹ä¸€ä¸ªg // æ‰€æœ‰ä½äºå…¨å±€è¿è¡Œé˜Ÿåˆ—ä¸­çš„gå½¢æˆä¸€ä¸ªé“¾è¡¨ // è¢«è°ƒåº¦å™¨ç”¨äºå®ç°å†…éƒ¨é“¾è¡¨ã€é˜Ÿåˆ—ï¼Œå¯¹åº”çš„ guintptr ç±»å‹ä»é€»è¾‘ä¸Šå°†ç­‰äº *gï¼Œ // è€Œåº•å±‚ç±»å‹å´æ˜¯ä¸ª uintptrï¼Œè¿™æ ·æ˜¯ä¸ºäº†é¿å…å†™å±éšœã€‚ schedlink guintptr waitsince int64 // gè¢«é˜»å¡çš„å¤§çº¦æ—¶é—´ waitreason waitReason // if status==Gwaiting // æŠ¢å è°ƒåº¦æ ‡å¿—ï¼Œå¦‚æœéœ€è¦æŠ¢å è°ƒåº¦ï¼Œè®¾ç½®preemptä¸ºtrue // æŠ¢å ä¿¡å·ï¼Œé‡å¤ stackguard0 = stackpreempt // ä¸ºtrueæ—¶ï¼Œè°ƒåº¦å™¨ä¼šåœ¨åˆé€‚çš„æ—¶æœºè§¦å‘ä¸€æ¬¡æŠ¢å  preempt bool // preemption signal, duplicates stackguard0 = stackpreempt preemptStop bool // transition to _Gpreempted on preemption; otherwise, just deschedule preemptShrink bool // shrink stack at synchronous safe point\tåœ¨åŒæ­¥å®‰å…¨ç‚¹æ”¶ç¼©å †æ ˆ // asyncSafePoint is set if g is stopped at an asynchronous // safe point. This means there are frames on the stack // without precise pointer information. asyncSafePoint bool paniconfault bool // panic (instead of crash) on unexpected fault address gcscandone bool // g has scanned stack; protected by _Gscan bit in status // ä¸èƒ½æ‰©å±•æ ˆï¼Œè¯¥å€¼åœ¨ç³»ç»Ÿè°ƒç”¨å‰è¢«è®¾ç½®ä¸ºtrueï¼Œåœ¨ç³»ç»Ÿè°ƒç”¨è¿”å›æ˜¯è®¾ç½®ä¸ºfalseã€‚ throwsplit bool // must not split stack // activeStackChans indicates that there are unlocked channels // pointing into this goroutine\u0026#39;s stack. If true, stack // copying needs to acquire channel locks to protect these // areas of the stack. // activeStackChans è¡¨ç¤ºæœ‰æœªé”å®šçš„é€šé“æŒ‡å‘è¿™ä¸ª goroutines å †æ ˆ // å¦‚æœä¸ºtrueï¼Œå †æ ˆå¤åˆ¶éœ€è¦è·å–é€šé“é”æ¥ä¿æŠ¤å †æ ˆçš„è¿™äº›åŒºåŸŸ activeStackChans bool // parkingOnChan indicates that the goroutine is about to // park on a chansend or chanrecv. Used to signal an unsafe point // for stack shrinking. It\u0026#39;s a boolean value, but is updated atomically. parkingOnChan uint8\t// èµ‹å€¼1ï¼Œè¡¨ç¤ºå½“å‰goroutineæ­£åœ¨chanä¸Š raceignore int8 // ignore race detection events sysblocktraced bool // StartTrace has emitted EvGoInSyscall about this goroutine tracking bool // whether we\u0026#39;re tracking this G for sched latency statistics trackingSeq uint8// used to decide whether to track this G runnableStamp int64// timestamp of when the G last became runnable, only used when tracking runnableTime int64// the amount of time spent runnable, cleared when running, only used when tracking sysexitticks int64// cputicks when syscall has returned (for tracing) traceseq uint64// trace event sequencer tracelastp puintptr// last P emitted an event for this goroutine // å…³è”åˆ°ä¸å½“å‰Gç»‘å®šçš„Mï¼Œå¯ä»¥å‚è€ƒä¸‹ LockOSThreadã€‚ lockedm muintptr sig uint32 writebuf []byte // sigcode0 å’Œ sigcode1 ç”¨äºä¸´æ—¶ä¼ å‚è®°å½• sigcode0 uintptr\t// è®°å½•å½“å‰éœ€è¦è·³è½¬çš„SPåœ°å€ï¼Œæ¯”å¦‚panicä¸­å³å°†è·³è½¬goexit sigcode1 uintptr\t// è®°å½•å½“å‰éœ€è¦è·³è½¬çš„PCåœ°å€ï¼Œæ¯”å¦‚panicä¸­å³å°†è·³è½¬goexit sigpc uintptr // åœ¨åˆ›å»ºgoroutineæ—¶å€™è¢«ä¿å­˜ gopc uintptr // pc of go statement that created this goroutine // åˆ›å»ºæ­¤goroutineçš„ç¥–å…ˆä¿¡æ¯goroutineï¼ˆä»…åœ¨debug.tracebackç¥–å…ˆæ—¶ä½¿ç”¨ï¼‰ï¼Œåœ¨åˆ›å»ºgoroutinæ—¶å€™è¢«ä¿å­˜ ancestors *[]ancestorInfo // ancestor information goroutine(s) that created this goroutine (only used if debug.tracebackancestors) // goroutineå‡½æ•°çš„pcã€‚åœ¨åˆ›å»ºgoroutinæ—¶å€™è¢«ä¿å­˜ startpc uintptr // pc of goroutine function racectx uintptr // æ ‡è®°å½“å‰goroutine 0è¡¨ç¤ºä¸»goroutine // è®°å½•è®©å½“å‰goroutineç­‰å¾…çš„sudogï¼Œsudogæ˜¯chançš„ç­‰å¾…é˜Ÿåˆ—ï¼Œç­‰å¾…è¢«è¯»ï¼Œc\u0026lt;-1æ“ä½œå¼•èµ·å½“å‰ï¼Œè¯¥å‚æ•°åœ¨å½“å‰goroutineè¢«æ¢å¤æ—¶åˆ¤æ–­ä½¿ç”¨ // Sudogç»“æ„è¿™ä¸ªgæ­£åœ¨ç­‰å¾…(æœ‰ä¸€ä¸ªæœ‰æ•ˆçš„elemæŒ‡é’ˆ);æŒ‰é”å®šé¡ºåºã€‚ // ä¸»è¦ç”¨äºå®ç° channel ä¸­çš„ç­‰å¾…é˜Ÿåˆ—ã€‚ waiting *sudog // sudog structures this g is waiting on (that have a valid elem ptr); in lock order cgoCtxt []uintptr// cgo traceback context labels unsafe.Pointer // profiler labels // ç¼“å­˜ timer ç”±äº time.Sleepã€‚ timer *timer // cached timer for time.Sleep // selectDone uint32 // are we participating in a select and did someone win the race? // Per-G GC state // gcAssistBytes is this G\u0026#39;s GC assist credit in terms of // bytes allocated. If this is positive, then the G has credit // to allocate gcAssistBytes bytes without assisting. If this // is negative, then the G must correct this by performing // scan work. We track this in bytes to make it fast to update // and check for debt in the malloc hot path. The assist ratio // determines how this corresponds to scan work debt. gcAssistBytes int64 // GCä¿¡ç”¨å€¼ } type stack struct Stackæè¿°äº†Goçš„æ‰§è¡Œæ ˆã€‚æ ˆçš„è¾¹ç•Œæ­£å¥½æ˜¯[lo, hi)ï¼Œä¸¤è¾¹éƒ½æ²¡æœ‰éšå¼çš„æ•°æ®ç»“æ„ã€‚ æ³¨æ„æ ˆæ˜¯å‘ä¸‹ç”Ÿé•¿çš„ã€‚ // Stack describes a Go execution stack. // The bounds of the stack are exactly [lo, hi), // with no implicit data structures on either side. type stack struct { lo uintptr // æ ˆé¡¶ï¼ŒæŒ‡å‘å†…å­˜ã€ä½åœ°å€ã€‘ hi uintptr // æ ˆåº•ï¼ŒæŒ‡å‘å†…å­˜ã€é«˜åœ°å€ã€‘ } type gobuf struct ä¿å­˜goroutineçš„è°ƒåº¦ä¿¡æ¯ï¼Œåº”ç”¨åœºæ™¯åœ¨è¿™goroutineè¢«é€‰ä¸­è°ƒåº¦èµ·æ¥å»æ‰§è¡Œï¼Œæˆ–å½“å‰goroutineè¢«æŠ¢å éœ€è¦ä¿å­˜CPUä¿¡æ¯ç„¶åä¸‹æ¬¡æ¥åˆ°ä»æ­¤å¤„æ‰§è¡Œã€‚ ç”¨æ¥å­˜å‚¨goroutineæ‰§è¡Œä¸Šä¸‹æ–‡çš„schedå­—æ®µéœ€è¦æ ¼å¤–æ³¨æ„ï¼Œå®ƒä¸goroutineåç¨‹åˆ‡æ¢çš„åº•å±‚å®ç°ç›¸å…³ã€‚ type gobuf struct { // spå­—æ®µå­˜å‚¨çš„æ˜¯æ ˆæŒ‡é’ˆï¼Œrspå¯„å­˜å™¨çš„å€¼ sp uintptr // ä¿å­˜CPUçš„SPå¯„å­˜å™¨çš„å€¼ï¼Œå­˜å‚¨çš„æ˜¯è¢«æŠ¢å æˆ–è°ƒåº¦æ—¶CPUä¿¡æ¯ // pcå­—æ®µå­˜å‚¨çš„æ˜¯æŒ‡ä»¤æŒ‡é’ˆï¼Œripå¯„å­˜å™¨çš„å€¼ pc uintptr // ä¿å­˜CPUçš„IPå¯„å­˜å™¨çš„å€¼ // gå­—æ®µç”¨æ¥åå‘å…³è”åˆ°å¯¹åº”çš„Gã€‚ g guintptr // è®°å½•å½“å‰è¿™ä¸ªgobufå¯¹è±¡å±äºé‚£ä¸ªgoroutine // ctxtå­—æ®µæŒ‡å‘é—­åŒ…å¯¹è±¡ï¼Œä¹Ÿå°±æ˜¯è¯´ç”¨goå…³é”®å­—åˆ›å»ºåç¨‹çš„æ—¶å€™ä¼ é€’çš„æ˜¯ä¸€ä¸ªé—­åŒ… // è¿™é‡Œä¼šå­˜å‚¨é—­åŒ…å¯¹è±¡çš„åœ°å€ã€‚rdxå¯„å­˜å™¨çš„å€¼ ctxt unsafe.Pointer // ä¸Šä¸‹æ–‡ä¿¡æ¯ // ä¿å­˜ç³»ç»Ÿè°ƒç”¨çš„è¿”å›å€¼ï¼Œå› ä¸ºä»ç³»ç»Ÿè°ƒç”¨è¿”å›ä¹‹åå¦‚æœpè¢«å…¶ä»–å·¥ä½œçº¿ç¨‹æŠ¢å  // åˆ™è¿™ä¸ªgoroutineä¼šè¢«æ”¾å…¥å…¨å±€è¿è¡Œé˜Ÿåˆ—è¢«å…¶ä»–å·¥ä½œçº¿ç¨‹è°ƒåº¦ï¼Œå…¶ä»–çº¿ç¨‹éœ€è¦çŸ¥é“ç³»ç»Ÿè°ƒç”¨çš„è¿”å›å€¼ // retå­—æ®µç”¨æ¥å­˜å‚¨è¿”å›å€¼ï¼Œå®é™…ä¸Šæ˜¯åˆ©ç”¨AXå¯„å­˜å™¨å®ç°ç±»ä¼¼Cå‡½æ•°çš„è¿”å›å€¼ï¼Œç›®å‰åªå‘ç°panic-recoveræœºåˆ¶ç”¨åˆ°äº†è¯¥å­—æ®µã€‚ ret sys.Uintreg // lrå­—æ®µåœ¨armç­‰æ¶æ„ä¸Šç”¨æ¥å­˜å‚¨è¿”åœ°å€ï¼Œx86æ²¡æœ‰ç”¨åˆ°è¯¥å­—æ®µã€‚ lr uintptr // bpå­—æ®µç”¨æ¥å­˜å‚¨æ ˆå¸§åŸºåœ°å€ã€‚rbpå¯„å­˜å™¨çš„å€¼ bp uintptr // å¯¹äºæ”¯æŒå¸§æŒ‡é’ˆçš„æ¶æ„ } G Status // defined constants const ( // goroutine å¼€å§‹åˆ›å»ºçš„çŠ¶æ€ï¼Œæ­¤æ—¶å°šæœªåˆå§‹åŒ–å®Œæˆï¼› _Gidle = iota // 0 // goroutine åœ¨å¾…æ‰§è¡Œé˜Ÿåˆ—ä¸­ï¼Œç­‰å¾…è¢«æ‰§è¡Œï¼› _Grunnable // 1 // goroutine æ­£åœ¨æ‰§è¡Œï¼ŒåŒä¸€æ—¶åˆ»ä¸€ä¸ªPä¸­åªæœ‰ä¸€ä¸ªgå¤„äºæ­¤çŠ¶æ€ï¼› _Grunning // 2 // goroutine æ­£åœ¨æ‰§è¡Œç³»ç»Ÿè°ƒç”¨ï¼› _Gsyscall // 3 // goroutine å¤„äºæŒ‚èµ·çŠ¶æ€ï¼Œéœ€è¦ç­‰å¾…è¢«å”¤é†’ã€‚gcã€channel æˆ–è€…é”æ“ä½œæ—¶ç»å¸¸ä¼šè¿›å…¥è¿™ç§çŠ¶æ€ï¼› _Gwaiting // 4 // _Gmoribund_unused is currently unused, but hardcoded in gdb // scripts. _Gmoribund_unused // 5 // goroutine åˆšåˆå§‹åŒ–å®Œæˆæˆ–è€…å·²ç»è¢«é”€æ¯ï¼Œä¼šå¤„äºæ­¤çŠ¶æ€ï¼› _Gdead // 6 // _Genqueue_unused is currently unused. _Genqueue_unused // 7 // goroutine æ­£åœ¨æ ˆæ‰©å®¹æµç¨‹ä¸­ï¼› _Gcopystack // 8 // goroutine è¢«æŠ¢å åçš„çŠ¶æ€ _Gpreempted // 9 // _Gscanä¸å‰é¢çš„ä¸€äº›çŠ¶æ€ç»„åˆã€‚ // é™¤äº†_Gscanrunningå¤–ï¼Œå…¶ä»–çš„ç»„åˆçŠ¶æ€éƒ½è¡¨ç¤ºGCæ­£åœ¨æ‰«ægoroutineçš„æ ˆï¼Œgoroutineæ²¡æœ‰åœ¨æ‰§è¡Œç”¨æˆ·ä»£ç ï¼Œ // æ ˆçš„æ‰€æœ‰æƒå½’è®¾ç½®äº†_Gscanæ ‡å¿—ä½çš„goroutineæ‰€æœ‰ã€‚ _Gscan = 0x1000 _Gscanrunnable = _Gscan + _Grunnable // 0x1001 // _Gscanrunningåœ¨GCé€šçŸ¥Gæ‰«ææ ˆçš„æ—¶å€™ï¼Œå®ƒè¢«ç”¨æ¥çŸ­æš‚çš„é˜»æ­¢çŠ¶æ€å˜æ¢ï¼Œå…¶ä»–æ–¹é¢å’Œ_Grunningä¸€æ ·ã€‚ // æ ˆæ‰«æå®Œæˆåï¼Œgoroutineå°†ä¼šåˆ‡æ¢å›åŸæ¥çš„çŠ¶æ€ï¼Œç§»é™¤_Gscanæ ‡å¿—ä½ã€‚ _Gscanrunning = _Gscan + _Grunning // 0x1002 _Gscansyscall = _Gscan + _Gsyscall // 0x1003 _Gscanwaiting = _Gscan + _Gwaiting // 0x1004 _Gscanpreempted = _Gscan + _Gpreempted // 0x1009 ) type m struct mç»“æ„ä½“ç”¨æ¥ä»£è¡¨å·¥ä½œçº¿ç¨‹ï¼Œå®ƒä¿å­˜äº†mè‡ªèº«ä½¿ç”¨çš„æ ˆä¿¡æ¯ã€‚ å½“å‰æ­£åœ¨è¿è¡Œçš„goroutineä»¥åŠä¸mç»‘å®šçš„pç­‰ä¿¡æ¯ã€‚ æ¯ä¸ªå·¥ä½œçº¿ç¨‹éƒ½æœ‰å”¯ä¸€çš„ä¸€ä¸ªmç»“æ„ä½“çš„å®ä¾‹å¯¹è±¡ä¸ä¹‹å¯¹åº”ï¼Œmç»“æ„ä½“å¯¹è±¡é™¤äº†è®°å½•ç€å·¥ä½œçº¿ç¨‹çš„è¯¸å¦‚æ ˆçš„èµ·æ­¢ä½ç½®ã€å½“å‰æ­£åœ¨æ‰§è¡Œçš„goroutineä»¥åŠæ˜¯å¦ç©ºé—²ç­‰ç­‰çŠ¶æ€ä¿¡æ¯ä¹‹å¤–ï¼Œè¿˜é€šè¿‡æŒ‡é’ˆç»´æŒç€ä¸pç»“æ„ä½“çš„å®ä¾‹å¯¹è±¡ä¹‹é—´çš„ç»‘å®šå…³ç³»ã€‚ äºæ˜¯ï¼Œé€šè¿‡mæ—¢å¯ä»¥æ‰¾åˆ°ä¸ä¹‹å¯¹åº”çš„å·¥ä½œçº¿ç¨‹æ­£åœ¨è¿è¡Œçš„goroutineï¼Œåˆå¯ä»¥æ‰¾åˆ°å·¥ä½œçº¿ç¨‹çš„å±€éƒ¨è¿è¡Œé˜Ÿåˆ—ç­‰èµ„æºã€‚ åªè¦æ¯ä¸ªå·¥ä½œçº¿ç¨‹æ‹¥æœ‰äº†å„è‡ªç§æœ‰çš„mç»“æ„ä½“å…¨å±€å˜é‡ï¼Œæˆ‘ä»¬å°±èƒ½åœ¨ä¸åŒçš„å·¥ä½œçº¿ç¨‹ä¸­ä½¿ç”¨ç›¸åŒçš„å…¨å±€å˜é‡åæ¥è®¿é—®ä¸åŒçš„mç»“æ„ä½“å¯¹è±¡ã€‚ type m struct { // å¹¶ä¸æ˜¯ä¸€ä¸ªçœŸæ­£çš„goroutineï¼Œå®ƒçš„æ ˆæ˜¯ç”±æ“ä½œç³»ç»Ÿåˆ†é…çš„ï¼Œ // åˆå§‹å¤§å°æ¯”æ™®é€šgoroutineçš„æ ˆè¦å¤§ï¼Œè¢«ç”¨ä½œè°ƒåº¦å™¨æ‰§è¡Œçš„æ ˆã€‚ // ç¨‹åºåˆšåˆå§‹åŒ–å¯åŠ¨æ—¶ç¬¬ä¸€ä¸ªg0æ ˆå¤§æ¦‚æœ‰64KBå¤§å°ï¼Œåé¢çš„å·¥ä½œçº¿ç¨‹çš„g0æ ˆæœ‰8KBå¤§å° g0 *g // goroutine with scheduling stack // è®°å½•è¢«è°ƒç”¨è€…ä¿¡æ¯ï¼Œåœ¨æŠ¢å è°ƒåº¦ä¸­è¢«è®¾ç½® morebuf gobuf // gobuf arg to morestack divmod uint32 // div/mod denominator for arm - known to liblink // Fields not known to debuggers. // çº¿ç¨‹IDï¼Œè¯¥å€¼åœ¨`go1.19.3/src/runtime/os_linux.go:minit`è¢«è°ƒç”¨ï¼Œè¯¥æ–¹æ³•åœ¨mstartå‡½æ•°çº¿ç¨‹åˆšå¯åŠ¨æ—¶åˆå§‹åŒ–ã€‚ // è¯¥å€¼é»˜è®¤æ˜¯ä¸€ä¸ªè‡ªå¢çš„ID procid uint64 // for debuggers, but offset not hard-coded // æœ¬è´¨ä¸Šæ˜¯ç”¨æ¥å¤„ç†ä¿¡å·çš„æ ˆï¼Œå› ä¸ºä¸€äº›UNIXç³»ç»Ÿæ”¯æŒä¸ºä¿¡å·å¤„ç†å™¨é…ç½®ç‹¬ç«‹çš„æ ˆã€‚ gsignal *g // signal-handling g goSigStack gsignalStack // Go-allocated signal handling stack sigmask sigset // storage for saved signal mask // é€šè¿‡TLSå®ç°mç»“æ„ä½“å¯¹è±¡ä¸å·¥ä½œçº¿ç¨‹ä¹‹å‰çš„ç»‘å®š // çº¿ç¨‹æœ¬åœ°å­˜å‚¨ï¼Œå­˜å‚¨å†…å®¹åªå¯¹å½“å‰çº¿ç¨‹å¯è§ã€‚çº¿ç¨‹æœ¬åœ°å­˜å‚¨çš„æ—¶m.tlsçš„åœ°å€ï¼Œm.tls[0]å­˜å‚¨çš„æ˜¯å½“å‰è¿è¡Œçš„gï¼Œ // å› æ­¤çº¿ç¨‹å¯ä»¥é€šè¿‡gæ‰¾åˆ°å½“å‰çš„mã€pã€g0ç­‰ä¿¡æ¯ã€‚ tls [6]uintptr // thread-local storage (for x86 extern register) mstartfn func() // å·¥ä½œçº¿ç¨‹å¯åŠ¨åéœ€è¦æ‰§è¡Œçš„å‡½æ•° // æŒ‡å‘å·¥ä½œçº¿ç¨‹æ­£åœ¨è¿è¡Œçš„goroutineçš„gç»“æ„ä½“å¯¹è±¡ï¼Œè¯¥å‚æ•°çš„ä½œç”¨æ˜¯åœ¨åˆ‡æ¢åˆ°g0æ ˆåæ¸…é™¤ä¹‹å‰çš„gï¼Œ // è®°å½•åœ¨è¿™é‡ŒæŒ‡å‘çš„æ˜¯Må½“å‰æ­£åœ¨æ‰§è¡Œçš„Gã€‚ curg *g // current running goroutine caughtsig guintptr // goroutine running during fatal signal // è®°å½•ä¸å½“å‰å·¥ä½œçº¿ç¨‹ç»‘å®šçš„pç»“æ„ä½“å¯¹è±¡ // GMPä¸­çš„Pï¼Œå³å…³è”åˆ°å½“å‰Mä¸Šçš„å¤„ç†å™¨ã€‚ p puintptr // attached p for executing go code (nil if not executing go code) // ç”¨æ¥å°†Pä¼ é€’ç»™Mï¼Œè°ƒåº¦å™¨ä¸€èˆ¬æ˜¯åœ¨Mé˜»å¡æ—¶ä¸ºm.nextpèµ‹å€¼ï¼Œç­‰åˆ°Må¼€å§‹è¿è¡Œåä¼šå°è¯•ä»nextpå¤„è·å–Pè¿›è¡Œå…³è”ã€‚ nextp puintptr // ç”¨æ¥æš‚å­˜æ‰§è¡Œç³»ç»Ÿè°ƒç”¨ä¹‹å‰å…³è”çš„Pã€‚ oldp puintptr // the p that was attached before executing a syscall // Mçš„å”¯ä¸€idã€‚ id int64 // å½“å‰çº¿ç¨‹çš„IDï¼Œæ ¹æ®schedt.mnextè®°å½•çš„å·¥ä½œçº¿ç¨‹ä¸ªæ•°è€Œè®¾ç½®çš„ // mallocing = 1ï¼Œå½“å‰goroutineæ­£åœ¨åˆ†é…å†…å­˜ mallocing int32 throwing int32 // ä¸ä¸ºç©ºæ—¶è¡¨ç¤ºè¦å…³é—­å¯¹curgçš„æŠ¢å ï¼Œå­—ç¬¦ä¸²å†…å®¹ç»™å‡ºäº†ç›¸å…³çš„åŸå› ã€‚ // ç”¨äºæ§åˆ¶å½“å‰ goroutine æ˜¯å¦å¯è¢«æŠ¢å ã€‚ //\t1. å½“ä¸€ä¸ª goroutine æ‰§è¡Œä¸€äº›å…³é”®æ“ä½œæ—¶ï¼ˆå¦‚è·å–é”ã€æ‰§è¡Œç³»ç»Ÿè°ƒç”¨ç­‰ï¼‰ï¼Œå®ƒå¯èƒ½éœ€è¦æš‚æ—¶å…³é—­æŠ¢å ï¼Œä»¥é¿å…åœ¨å…³é”®æ“ä½œæœŸé—´è¢«æŠ¢å å¯¼è‡´æ­»é”æˆ–ç«äº‰æ¡ä»¶çš„å‘ç”Ÿã€‚ // 2. ç¨‹åºå‘˜å¯ä»¥é€šè¿‡ä½¿ç”¨ runtime.LockOSThread() å‡½æ•°æ¥å°†å½“å‰ goroutine ç»‘å®šåˆ°ä¸€ä¸ª OS çº¿ç¨‹ä¸Šï¼Œä»è€Œé¿å…æŠ¢å çš„å‘ç”Ÿã€‚ // 3. å¦‚æœåœ¨æ‰§è¡Œå…³é”®æ“ä½œæ—¶éœ€è¦æš‚æ—¶å…³é—­æŠ¢å ï¼Œå¯ä»¥ä½¿ç”¨ runtime.LockOSThread() å‡½æ•°å°†å½“å‰ goroutine ç»‘å®šåˆ°ä¸€ä¸ª OS çº¿ç¨‹ä¸Šï¼Œå¹¶åœ¨æ“ä½œå®Œæˆåè°ƒç”¨ runtime.UnlockOSThread() å‡½æ•°å°†å…¶è§£ç»‘ã€‚ preemptoff string // if != \u0026#34;\u0026#34;, keep curg running on this m // è®°å½•å½“å‰MæŒæœ‰é”çš„æ•°é‡ï¼Œä¸ä¸º0æ—¶èƒ½å¤Ÿé˜»æ­¢æŠ¢å å‘ç”Ÿã€‚ // ç”¨æ¥è®°å½•å½“å‰ goroutine æŒæœ‰çš„äº’æ–¥é”æ•°é‡çš„ // 1. å½“ goroutine æŒæœ‰ä¸€ä¸ªäº’æ–¥é”æ—¶ï¼Œå®ƒä¸èƒ½è¢«æŠ¢å ï¼Œå› ä¸ºå¦‚æœè¢«æŠ¢å äº†ï¼Œå…¶ä»– goroutine å°±æ— æ³•è·å–è¯¥é”ã€‚ // 2. ä¸ºäº†é¿å…è¿™ç§æƒ…å†µçš„å‘ç”Ÿï¼ŒGo è¯­è¨€çš„è°ƒåº¦å™¨ä¼šåœ¨æ£€æŸ¥æ˜¯å¦åº”è¯¥æŠ¢å å½“å‰ goroutine ä¹‹å‰ï¼Œå…ˆæ£€æŸ¥å®ƒæ˜¯å¦æŒæœ‰äº’æ–¥é”ã€‚ // 3. å¦‚æœå½“å‰ goroutine æŒæœ‰äº’æ–¥é”ï¼Œåˆ™è°ƒåº¦å™¨ä¼šæš‚æ—¶å°†å…¶æ ‡è®°ä¸ºä¸å¯æŠ¢å çŠ¶æ€ï¼Œç›´åˆ°è¯¥ goroutine é‡Šæ”¾é”ä¸ºæ­¢ã€‚ // 4. å› æ­¤ï¼Œm.locks å­—æ®µæ˜¯ç”¨æ¥è¾…åŠ©è°ƒåº¦å™¨å®ç°è¿™ä¸€æœºåˆ¶çš„ã€‚ // 5. å½“ä¸€ä¸ª goroutine è·å–ä¸€ä¸ªäº’æ–¥é”æ—¶ï¼Œm.locks å­—æ®µä¼šè¢«æ›´æ–°ï¼Œæ ‡è®°è¯¥ goroutine æŒæœ‰ç›¸åº”çš„äº’æ–¥é”ã€‚ // 6. å½“ goroutine é‡Šæ”¾é”æ—¶ï¼Œm.locks å­—æ®µä¹Ÿä¼šè¢«æ›´æ–°ï¼Œæ¸…é™¤ç›¸åº”çš„æ ‡è®°ã€‚ // 7. è°ƒåº¦å™¨åœ¨å†³å®šæ˜¯å¦åº”è¯¥æŠ¢å ä¸€ä¸ª goroutine æ—¶ï¼Œä¼šæ£€æŸ¥è¯¥ goroutine æ˜¯å¦æŒæœ‰äº’æ–¥é”ï¼Œä»¥æ­¤æ¥é¿å…å› æŠ¢å å¯¼è‡´çš„é”ç«äº‰å’Œæ­»é”é—®é¢˜ã€‚ locks int32\t// å°è¯•è·å–é”çš„æ¬¡æ•°ï¼Œåœ¨lockä¸­åŠ ä¸€ï¼Œåœ¨unlockå‡ä¸€ dying int32 profilehz int32 // spiningçŠ¶æ€ï¼šè¡¨ç¤ºå½“å‰å·¥ä½œçº¿ç¨‹æ­£åœ¨è¯•å›¾ä»å…¶ä»–å·¥ä½œçº¿ç¨‹çš„æœ¬åœ°è¿è¡Œé˜Ÿåˆ—å·å–goroutine // è¡¨ç¤ºå½“å‰Mæ­£å¤„äºè‡ªæ—‹çŠ¶æ€ã€‚ spinning bool // m is out of work and is actively looking for work\tblocked bool // m is blocked on a note måœ¨noteä¸Šè¢«å±è”½ï¼Œè¡¨ç¤ºå½“å‰Mæ­£åœ¨ä¼‘çœ ä¸­ newSigstack bool // minit on C thread called sigaltstack printlock int8 incgo bool // m is executing a cgo call freeWait atomic.Uint32 // Whether it is safe to free g0 and delete m (one of freeMRef, freeMStack, freeMWait) // fastrand ç”¨äºåœ¨ä¸€äº›éšæœºå€¼çš„ä½¿ç”¨éœ€è¦ fastrand uint64 needextram bool traceback uint8 ncgocall uint64 // number of cgo calls in total ncgo int32 // number of cgo calls currently in progress cgoCallersUse uint32 // if non-zero, cgoCallers in use temporarily cgoCallers *cgoCallers // cgo traceback if crashing in cgo call doesPark bool // non-P running threads: sysmon and newmHandoff never use .park // æ²¡æœ‰goroutineéœ€è¦è¿è¡Œæ—¶ï¼Œå·¥ä½œçº¿ç¨‹ç¡çœ åœ¨è¿™ä¸ªparkæˆå‘˜ä¸Š // å…¶ä»–çº¿ç¨‹é€šè¿‡è¿™ä¸ªparkå”¤é†’è¯¥å·¥ä½œçº¿ç¨‹ // ç”¨æ¥æ”¯æŒMçš„sleepå’Œwakeupï¼Œå¯ä»¥å¾ˆæ–¹ä¾¿åœ°å®ç°æ¯ä¸ªMå•ç‹¬sleepå’Œwakeupã€‚ park note // è®°å½•æ‰€æœ‰å·¥ä½œçº¿ç¨‹çš„ä¸€ä¸ªé“¾è¡¨ // æŠŠæ‰€æœ‰çš„Mè¿èµ·æ¥ï¼Œæ„æˆallmé“¾è¡¨ã€‚ alllink *m // on allm // è¢«è°ƒåº¦å™¨ç”¨äºå®ç°é“¾è¡¨ï¼Œå¦‚ç©ºé—²Mé“¾è¡¨ã€‚ schedlink muintptr // å…³è”åˆ°ä¸å½“å‰Mç»‘å®šçš„Gï¼Œå¯å‚è€ƒLockOSThreadã€‚ lockedg guintptr createstack [32]uintptr // stack that created this thread. lockedExt uint32 // tracking for external LockOSThread lockedInt uint32 // tracking for internal lockOSThread nextwaitm muintptr // next m waiting for lock waitunlockf func(*g, unsafe.Pointer) bool waitlock unsafe.Pointer waittraceev byte waittraceskip int startingtrace bool syscalltick uint32 // ç”¨æ¥æŠŠå·²ç»é€€å‡ºè¿è¡Œçš„Mè¿èµ·æ¥ï¼Œæ„æˆsched.freemé“¾è¡¨ï¼Œæ–¹ä¾¿ä¸‹æ¬¡åˆ†é…æ—¶å¤ç”¨ã€‚ freelink *m // on sched.freem // mFixup is used to synchronize OS related m state (credentials etc) // use mutex to access. mFixup struct { lock mutex fn func(bool) bool } // these are here because they are too large to be on the stack // of low-level NOSPLIT functions. libcall libcall libcallpc uintptr // for cpu profiler libcallsp uintptr libcallg guintptr syscall libcall // stores syscall parameters on windows vdsoSP uintptr // SP for traceback while in VDSO call (0 if not in call) vdsoPC uintptr // PC for traceback while in VDSO call // preemptGen counts the number of completed preemption // signals. This is used to detect when a preemption is // requested, but fails. Accessed atomically. preemptGen uint32 // Whether this is a pending preemption signal on this M. // Accessed atomically. // // è¿™ä¸ªMä¸Šæ˜¯å¦æœ‰ä¸€ä¸ªå¾…å¤„ç†çš„æŠ¢å ä¿¡å·ã€‚åŸå­æ“ä½œã€‚ // è¯¥å‚æ•°åœ¨ preemptM å‡½æ•°ä¸­ä»0è®¾ç½®ä¸º1ã€‚ signalPending uint32 dlogPerM mOS // Up to 10 locks held by this m, maintained by the lock ranking code. locksHeldLen int locksHeld [10]heldLockInfo } type p struct pç»“æ„ä½“ç”¨äºä¿å­˜å·¥ä½œçº¿ç¨‹æ‰§è¡Œgoä»£ç æ—¶æ‰€å¿…éœ€çš„èµ„æºã€‚ æ¯”å¦‚goroutineçš„è¿è¡Œé˜Ÿåˆ—ï¼Œå†…å­˜åˆ†é…ç”¨åˆ°çš„ç¼“å­˜ï¼Œå±€éƒ¨goroutienè¿è¡Œé˜Ÿåˆ—ç­‰ç­‰ã€‚ type p struct { // Pçš„ä½ç§»IDï¼Œç­‰äºå½“å‰Påœ¨allpæ•°ç»„ä¸­çš„ä¸‹æ ‡ã€‚ id int32 // å½“å‰Pæ‰€å¤„çŠ¶æ€ï¼Œä¹Ÿå°±æ˜¯å½“å‰Pä¸Šçš„gçš„çŠ¶æ€ status uint32 // one of pidle/prunning/... // linkæ˜¯ä¸€ä¸ªæ²¡æœ‰å†™å±éšœçš„æŒ‡é’ˆï¼Œè¢«è°ƒåº¦å™¨ç”¨æ¥æ„é€ é“¾è¡¨ link puintptr // åœ¨æ¯æ¬¡è°ƒåº¦å™¨è°ƒç”¨æ—¶é€’å¢ï¼Œè®°å½•å½“å‰Pçš„è°ƒåº¦æ¬¡æ•° // è®°å½•è°ƒåº¦å‘ç”Ÿçš„æ¬¡æ•°ï¼Œå®é™…ä¸Šåœ¨æ¯å‘ç”Ÿä¸€æ¬¡goroutineåˆ‡æ¢ä¸”ä¸ç»§æ‰¿æ—¶é—´ç‰‡çš„æƒ…å†µä¸‹ï¼Œè¯¥å­—æ®µä¼šåŠ ä¸€ã€‚ schedtick uint32 // incremented on every scheduler call // åœ¨æ¯æ¬¡ç³»ç»Ÿè°ƒç”¨æ—¶é€’å¢ï¼Œè®°å½•å½“å‰Pçš„ç³»ç»Ÿè°ƒç”¨æ¬¡æ•° // å‘ç”Ÿæ¯ä¸€æ¬¡ç³»ç»Ÿè°ƒç”¨å°±ä¼šåŠ ä¸€ã€‚ syscalltick uint32 // incremented on every system call // sysmonè§‚å¯Ÿåˆ°çš„æœ€åä¸€ä¸ªæ—¶é’Ÿä¿¡å· // è¯¥å€¼è¢«ç”¨äºsysmonçº¿ç¨‹è®°å½•è¢«ç›‘æ§pçš„ç³»ç»Ÿè°ƒç”¨æ—¶é—´å’Œè¿è¡Œæ—¶é—´ï¼Œæ³¨æ„è¿™é‡Œæ˜¯ä¸sysmonç›¸å…³çš„ // type sysmontick struct { //\tschedtick uint32 //\tschedwhen int64 //\tsyscalltick uint32 //\tsyscallwhen int64 // } // è¢«ç›‘æ§çº¿ç¨‹ç”¨æ¥å­˜å‚¨ä¸Šä¸€æ¬¡æ£€æŸ¥æ—¶çš„è°ƒåº¦å™¨æ—¶é’Ÿæ»´ç­”ï¼Œç”¨äºå®ç°æ—¶é—´ç‰‡ç®—æ³•ã€‚ sysmontick sysmontick // last tick observed by sysmon // æœ¬è´¨ä¸Šæ˜¯ä¸ªæŒ‡é’ˆï¼Œåå‘å…³è”åˆ°å½“å‰Pç»‘å®šçš„Mã€‚ m muintptr // back-link to associated m (nil if idle) mcache *mcache\t// pçš„å†…å­˜æ¨¡å—ç®¡ç† pcache pageCache raceprocctx uintptr // ç”¨äºç¼“å­˜*_deferæ¥å£ï¼Œé¿å…é¢‘ç¹å †åˆ†é… deferpool []*_defer // pool of available defer structs of different sizes (see panic.go) // æ ¹æ®æºç ä¸­ pp.deferpool = pp.deferpoolbuf[:0] å¯çŸ¥ï¼Œdeferpoolbufåªæ˜¯ä½œä¸ºdeferpoolçš„å†…å­˜åœ°å€åœ¨ä½¿ç”¨ deferpoolbuf [32]*_defer // Cache of goroutine ids, amortizes accesses to runtimeÂ·sched.goidgen. // ç”¨æ¥ä»å…¨å±€sched,goidgenå¤„ç”Ÿæ°”goidåˆ†é…åŒºé—´ï¼Œæ‰¹é‡ç”³è¯·ä»¥å‡å°‘å…¨å±€èŒƒå›´çš„é”ç«äº‰ç”¨ã€‚ goidcache uint64 goidcacheend uint64 // Queue of runnable goroutines. Accessed without lock. // æœ¬åœ°goroutineè¿è¡Œé˜Ÿåˆ— // å½“å‰Pçš„å°±ç»ªé˜Ÿåˆ—ï¼Œç”¨ä¸€ä¸ªæ•°ç»„å’Œä¸€å¤´ä¸€å°¾ä¸¤ä¸ªä¸‹æ ‡å®ç°äº†ä¸€ä¸ªç¯å‹é˜Ÿåˆ—ã€‚ runqhead uint32\t// é˜Ÿåˆ—å¤´ runqtail uint32\t// é˜Ÿåˆ—å°¾ runq [256]guintptr // ä½¿ç”¨æ•°ç»„å®ç°çš„å¾ªç¯é˜Ÿåˆ— // runnext, if non-nil, is a runnable G that was ready\u0026#39;d by // the current G and should be run next instead of what\u0026#39;s in // runq if there\u0026#39;s time remaining in the running G\u0026#39;s time // slice. It will inherit the time left in the current time // slice. If a set of goroutines is locked in a // communicate-and-wait pattern, this schedules that set as a // unit and eliminates the (potentially large) scheduling // latency that otherwise arises from adding the ready\u0026#39;d // goroutines to the end of the run queue. // // å¦‚æœä¸ä¸ºnilï¼Œåˆ™æŒ‡å‘ä¸€ä¸ªè¢«å½“å‰Gå‡†å¤‡å¥½(å°±ç»ª)çš„Gï¼Œæ¥ä¸‹æ¥å°†ä¼šç»§æ‰¿å½“å‰Gçš„æ—¶é—´ç‰‡å¼€å§‹è¿è¡Œã€‚ // è¯¥å­—æ®µå­˜åœ¨çš„æ„ä¹‰åœ¨äºï¼Œå‡å¦‚æœ‰ä¸€ç»„goroutineä¸­æœ‰ç”Ÿäº§è€…å’Œæ¶ˆè´¹è€…ï¼Œå®ƒä»¬åœ¨ä¸€ä¸ªchannelä¸Šé¢‘ç¹çš„ç­‰å¾…ã€å”¤é†’ï¼Œ // é‚£ä¹ˆè°ƒåº¦å™¨ä¼šæŠŠå®ƒä»¬ä½œä¸ºä¸€ä¸ªå•å…ƒæ¥è°ƒåº¦ã€‚æ¯æ¬¡ä½¿ç”¨runnextæ¯”æ·»åŠ åˆ°æœ¬åœ°runqå°¾éƒ¨èƒ½å¤§å¹…å‡å°‘å»¶è¿Ÿã€‚ runnext guintptr\t// è®°å½•ç€ä¸‹ä¸€ä¸ªå°†è¦æ‰§è¡Œçš„goroutine // Available G\u0026#39;s (status == Gdead) // è®°å½•ç€æ‰€æœ‰çŠ¶æ€ä¸ºGdeadçš„ç©ºé—²çš„goroutineé“¾è¡¨ // goå…³é”®å­—é…çš„æ—¶å€™ä¼˜å…ˆä»è¿™é‡Œè·å–ï¼Œgoroutineæ‰§è¡Œå®Œæ—¶ä¿å­˜åœ¨è¿™é‡Œ // ç”¨æ¥ç¼“å­˜å·²ç»é€€å‡ºè¿è¡Œçš„Gï¼Œæ–¹ä¾¿å†æ¬¡åˆ†é…æ—¶è¿›è¡Œå¤ç”¨ã€‚ gFree struct { gList\t// type gList struct {head guintptr}\tguintptræ˜¯uintputrçš„è‡ªå®šä¹‰ç±»å‹ n int32\t// è®°å½•ç€å½“å‰ç©ºé—²çš„gçš„æ•°é‡ } sudogcache []*sudog sudogbuf [128]*sudog // Cache of mspan objects from the heap. mspancache struct { // We need an explicit length here because this field is used // in allocation codepaths where write barriers are not allowed, // and eliminating the write barrier/keeping it eliminated from // slice updates is tricky, moreso than just managing the length // ourselves. len int buf [128]*mspan } tracebuf traceBufPtr // traceSweep indicates the sweep events should be traced. // This is used to defer the sweep start event until a span // has actually been swept. traceSweep bool // traceSwept and traceReclaimed track the number of bytes // swept and reclaimed by sweeping in the current sweep loop. traceSwept, traceReclaimed uintptr palloc persistentAlloc // per-P to avoid mutex // ç”¨äºä¸‹é¢å­—æ®µå¯¹é½ _ uint32 // Alignment for atomic fields below // ä»¥ä¸‹timer0Whenå’ŒtimerModifiedEarliestå­—æ®µç»´æŠ¤è¿™è¿™ä¸ªPçš„æ‰§è¡Œæ—¶é—´ï¼Œä¹Ÿæ˜¯ç”¨äºæŠ¢æ–­åˆ¤æ–­ä¾æ® // The when field of the first entry on the timer heap. // This is updated using atomic functions. // This is 0 if the timer heap is empty. // timer å †ä¸Šç¬¬ä¸€ä¸ªæ¡ç›®çš„ when å­—æ®µã€‚ // è¿™æ˜¯ä½¿ç”¨åŸå­å‡½æ•°æ›´æ–°çš„ // å¦‚æœ timer å †ä¸ºç©ºï¼Œåˆ™ä¸º 0 timer0When uint64\t// å †é¡¶å…ƒç´ ä»€ä¹ˆæ—¶å€™æ‰§è¡Œ // The earliest known nextwhen field of a timer with // timerModifiedEarlier status. Because the timer may have been // modified again, there need not be any timer with this value. // This is updated using atomic functions. // This is 0 if the value is unknown. // å…·æœ‰ timerModifiedEarlier çŠ¶æ€çš„å®šæ—¶å™¨çš„æœ€æ—©å·²çŸ¥ nextwhen å­—æ®µã€‚ // å› ä¸ºå®šæ—¶å™¨å¯èƒ½å·²ç»è¢«å†æ¬¡ä¿®æ”¹ï¼Œæ‰€ä»¥ä¸éœ€è¦ä»»ä½•å…·æœ‰è¯¥å€¼çš„timer // è¿™æ˜¯ä½¿ç”¨åŸå­å‡½æ•°æ›´æ–°çš„ // å¦‚æœæ²¡æœ‰ timerModifiedEarlier è®¡æ—¶å™¨ï¼Œåˆ™ä¸º 0 timerModifiedEarliest uint64\t// å¦‚æœæœ‰timerä¿®æ”¹ä¸ºæ›´æ—©æ‰§è¡Œæ—¶é—´äº†ï¼Œå°†æ‰§è¡Œæ—¶é—´æ›´æ–°åˆ°å½“æ›´æ—©æ—¶é—´ // Per-P GC state gcAssistTime int64 // Nanoseconds in assistAlloc gcFractionalMarkTime int64 // Nanoseconds in fractional mark worker (atomic) // gcMarkWorkerMode is the mode for the next mark worker to run in. // That is, this is used to communicate with the worker goroutine // selected for immediate execution by // gcController.findRunnableGCWorker. When scheduling other goroutines, // this field must be set to gcMarkWorkerNotWorker. gcMarkWorkerMode gcMarkWorkerMode // gcMarkWorkerStartTime is the nanotime() at which the most recent // mark worker started. gcMarkWorkerStartTime int64 // gcw is this P\u0026#39;s GC work buffer cache. The work buffer is // filled by write barriers, drained by mutator assists, and // disposed on certain GC state transitions. gcw gcWork // wbBuf is this P\u0026#39;s GC write barrier buffer. // // TODO: Consider caching this in the running G. wbBuf wbBuf runSafePointFn uint32 // if 1, run sched.safePointFn at next safe point // statsSeq is a counter indicating whether this P is currently // writing any stats. Its value is even when not, odd when it is. statsSeq uint32 // Lock for timers. We normally access the timers while running // on this P, but the scheduler can also do it from a different P. // é”å®štimersã€‚æˆ‘ä»¬é€šå¸¸åœ¨æ­¤Pä¸Šè¿è¡Œæ—¶è®¿é—®timersï¼Œä½†è°ƒåº¦ç¨‹åºä¹Ÿå¯ä»¥ä»ä¸åŒçš„Pä¸Šæ‰§è¡Œæ­¤æ“ä½œ timersLock mutex\t// æ“ä½œtimerçš„äº’æ–¥é” // Actions to take at some time. This is used to implement the // standard library\u0026#39;s time package. // Must hold timersLock to access. // å¿…é¡»æŒæœ‰ timersLock æ‰èƒ½è®¿é—® // å½“å‰å…³äºPçš„timerï¼Œå¯èƒ½å‡ºç°å½“å‰Pä¸­å¾ˆå¤šgoroutineè¢«æŒ‚åœ¨ä¸åŒçš„timerä¸Š timers []*timer\t// è¯¥Pä¸Šçš„æ‰€æœ‰timerï¼Œå¿…é¡»åŠ é”å»æ“ä½œè¿™ä¸ªå­—æ®µï¼Œå› ä¸ºä¸åŒçš„Pæ“ä½œè¿™ä¸ªå­—æ®µä¼šæœ‰ç«äº‰ // Number of timers in P\u0026#39;s heap. // Modified using atomic instructions. // P å †ä¸­çš„timersæ•°é‡ï¼Œä½¿ç”¨åŸå­æŒ‡ä»¤ä¿®æ”¹ numTimers uint32\t// På †ä¸Šæ‰€æœ‰çš„timeræ•°é‡ // Number of timerModifiedEarlier timers on P\u0026#39;s heap. // This should only be modified while holding timersLock, // or while the timer status is in a transient state // such as timerModifying. // P çš„å †ä¸Š timerModifiedEarlier è®¡æ—¶å™¨çš„æ•°é‡ // è¿™åªåº”åœ¨æŒæœ‰ timersLock æ—¶ä¿®æ”¹ï¼Œæˆ–è€…å½“å®šæ—¶å™¨çŠ¶æ€å¤„äºè¯¸å¦‚ timerModifying ä¹‹ç±»çš„ç¬æ€çŠ¶æ€æ—¶è¿›è¡Œä¿®æ”¹ adjustTimers uint32 // Number of timerDeleted timers in P\u0026#39;s heap. // Modified using atomic instructions. // P çš„å †ä¸­ timerDeleted timersçš„æ•°é‡ // ä½¿ç”¨åŸå­æŒ‡ä»¤ä¿®æ”¹ deletedTimers uint32\t// è¢«æ ‡è®°ä¸ºåˆ é™¤çš„timerï¼Œè¦ä¹ˆæ˜¯æˆ‘ä»¬è°ƒç”¨stopï¼Œè¦ä¹ˆæ˜¯timerè‡ªå·±è§¦å‘åè¿‡æœŸå¯¼è‡´çš„åˆ é™¤ // Race context used while executing timer functions. timerRaceCtx uintptr // preempt is set to indicate that this P should be enter the // scheduler ASAP (regardless of what G is running on it). // preempt è®¾ç½®ä¸ºæŒ‡ç¤ºè¯¥ P åº”å°½å¿«è¿›å…¥è°ƒåº¦ç¨‹åºï¼ˆæ— è®º G åœ¨å…¶ä¸Šè¿è¡Œä»€ä¹ˆï¼‰ // åœ¨GO1.14ç‰ˆæœ¬è¢«å¼•å…¥ï¼Œä»¥æ”¯æŒæ–°çš„å¼‚æ­¥æŠ¢å æœºåˆ¶ã€‚ preempt bool pad cpu.CacheLinePad } P Status const ( // P status // _Pidle means a P is not being used to run user code or the // scheduler. Typically, it\u0026#39;s on the idle P list and available // to the scheduler, but it may just be transitioning between // other states. // // The P is owned by the idle list or by whatever is // transitioning its state. Its run queue is empty. // // ç©ºé—²çŠ¶æ€ã€‚æ­¤æ—¶çš„Pæ²¡æœ‰è¢«ç”¨æ¥æ‰§è¡Œç”¨æˆ·ä»£ç æˆ–è°ƒåº¦å™¨ä»£ç ï¼Œé€šå¸¸ä½äºç©ºé—²é“¾è¡¨ä¸­ï¼Œèƒ½å¤Ÿè¢«è°ƒåº¦å™¨è·å–ï¼Œ // å®ƒçš„çŠ¶æ€å¯èƒ½æ­£åœ¨ç”±ç©ºé—²è½¬å˜æˆå…¶ä»–çŠ¶æ€ã€‚Pçš„æ‰€æœ‰æƒå½’ç©ºé—²é“¾è¡¨æˆ–æŸä¸ªæ­£åœ¨æ”¹å˜å®ƒçŠ¶æ€çš„çº¿ç¨‹æ‰€æœ‰ï¼Œæœ¬åœ°runqä¸ºç©ºã€‚ _Pidle = iota // ç©ºé—²çŠ¶æ€ // _Prunning means a P is owned by an M and is being used to // run user code or the scheduler. Only the M that owns this P // is allowed to change the P\u0026#39;s status from _Prunning. The M // may transition the P to _Pidle (if it has no more work to // do), _Psyscall (when entering a syscall), or _Pgcstop (to // halt for the GC). The M may also hand ownership of the P // off directly to another M (e.g., to schedule a locked G). // // è¿è¡Œä¸­çŠ¶æ€ã€‚å½“å‰Pæ­£è¢«æŸä¸ªMæŒæœ‰ï¼Œå¹¶ä¸”ç”¨äºæ‰§è¡Œç”¨æˆ·ä»£ç æˆ–è°ƒåº¦å™¨ä»£ç ã€‚ // åªæœ‰æŒæœ‰Pæ‰€æœ‰æƒçš„Mï¼Œæ‰è¢«å…è®¸å°†Pçš„çŠ¶æ€ä»_Prunningè½¬å˜ä¸ºå…¶ä»–çŠ¶æ€ã€‚ // åœ¨ä»»åŠ¡éƒ½æ‰§è¡Œå®Œä»¥åï¼ŒMä¼šæŠŠPè®¾ç½®ä¸º_PidleçŠ¶æ€ã€‚åœ¨è¿›å…¥ç³»ç»Ÿè°ƒç”¨æ—¶ï¼ŒMä¼šæŠŠPè®¾ç½®ä¸º_PsyscallçŠ¶æ€ã€‚ // æŒ‚èµ·ä»¥æ‰§è¡ŒGCæ—¶ï¼Œä¼šè®¾ç½®ä¸º_PgcstopçŠ¶æ€ã€‚æŸäº›æƒ…å†µä¸‹ï¼ŒMè¿˜å¯èƒ½ä¼šç›´æ¥æŠŠPçš„æ‰€æœ‰æƒäº¤ç»™å¦ä¸€ä¸ªMã€‚ _Prunning // è¿è¡Œä¸­çŠ¶æ€ // _Psyscall means a P is not running user code. It has // affinity to an M in a syscall but is not owned by it and // may be stolen by another M. This is similar to _Pidle but // uses lightweight transitions and maintains M affinity. // // Leaving _Psyscall must be done with a CAS, either to steal // or retake the P. Note that there\u0026#39;s an ABA hazard: even if // an M successfully CASes its original P back to _Prunning // after a syscall, it must understand the P may have been // used by another M in the interim. // // ç³»ç»Ÿè°ƒç”¨çŠ¶æ€ã€‚æ­¤æ—¶çš„Pæ²¡æœ‰æ‰§è¡Œç”¨æˆ·ä»£ç ï¼Œå®ƒå’Œä¸€ä¸ªå¤„äºsyscallä¸­çš„Mé—´å­˜åœ¨å¼±å…³è”å…³ç³»ï¼Œå¯èƒ½ä¼šè¢«å¦å¤–ä¸€ä¸ªMçªƒå–èµ°ã€‚ _Psyscall // ç³»ç»Ÿè°ƒç”¨ä¸­çŠ¶æ€ // _Pgcstop means a P is halted for STW and owned by the M // that stopped the world. The M that stopped the world // continues to use its P, even in _Pgcstop. Transitioning // from _Prunning to _Pgcstop causes an M to release its P and // park. // // The P retains its run queue and startTheWorld will restart // the scheduler on Ps with non-empty run queues. // // GCåœæ­¢çŠ¶æ€ã€‚Pè¢«STWæŒ‚èµ·ä»¥æ‰§è¡ŒGCï¼Œæ‰€æœ‰æƒå½’æ‰§è¡ŒSTWçš„Mæ‰€æœ‰ï¼Œæ‰§è¡ŒSTWçš„Mä¼šç»§ç»­ä½¿ç”¨å¤„äº_PgcstopçŠ¶æ€çš„Pã€‚ // å½“Pçš„çŠ¶æ€ä»_Prunningè½¬å˜æˆ_Pgcstopæ—¶ï¼Œä¼šé€ æˆå…³è”çš„Mé‡Šæ”¾Pçš„æ‰€æœ‰æƒï¼Œç„¶åè¿›å…¥é˜»å¡çŠ¶æ€ã€‚ // Pä¼šä¿ç•™å®ƒçš„æœ¬åœ°runqï¼Œç„¶åStart The Worldä¼šä»æ–°å¯åŠ¨è¿™äº›æœ¬åœ°runqä¸ä¸ºç©ºçš„Pã€‚ _Pgcstop // GCåœæ­¢çŠ¶æ€ // _Pdead means a P is no longer used (GOMAXPROCS shrank). We // reuse Ps if GOMAXPROCS increases. A dead P is mostly // stripped of its resources, though a few things remain // (e.g., trace buffers). // // åœç”¨çŠ¶æ€ã€‚å› ä¸ºGOMAXPROCSæ”¶ç¼©ï¼Œä¼šé€ æˆå¤šä½™çš„Pè¢«åœç”¨ï¼Œå½“GOMAXPROCSå†æ¬¡å¢å¤§æ—¶è¿˜ä¼šè¢«å¤ç”¨ã€‚ // ä¸€ä¸ªåœç”¨çš„Pï¼Œå¤§éƒ¨åˆ†èµ„æºè¢«å‰¥å¤ºï¼Œåªæœ‰å¾ˆå°‘é‡ä¿ç•™ã€‚ _Pdead // åœç”¨çŠ¶æ€ ) type schedt struct schedtç»“æ„ä½“ç”¨æ¥ä¿å­˜è°ƒåº¦å™¨çš„çŠ¶æ€ä¿¡æ¯å’Œ(å¯è¿è¡Œæˆ–ç©ºé—²çš„)goroutineçš„å®¹å™¨ä»¥åŠä¿å­˜goroutineçš„è¿è¡Œé˜Ÿåˆ— æ¯ä¸ªGoç¨‹åºä¸­åªæœ‰ä¸€ä¸ªè°ƒåº¦å™¨ï¼Œå¤šä»¥æ¯ä¸ªGoç¨‹åºä¸­schedtç»“æ„ä½“åªæœ‰ä¸€ä¸ªå®ä¾‹å¯¹è±¡ï¼Œè¯¥å®ä¾‹å¯¹è±¡åœ¨æºä»£ç ä¸­è¢«å®šä¹‰æˆäº†ä¸€ä¸ªå…±äº«çš„å…¨å±€å˜é‡ è¿™æ ·æ¯ä¸ªå·¥ä½œçº¿ç¨‹éƒ½å¯ä»¥è®¿é—®å®ƒä»¥åŠå®ƒæ‰€æ‹¥æœ‰çš„goroutineè¿è¡Œé˜Ÿåˆ—ï¼Œæˆ‘ä»¬ç§°è¿™ä¸ªè¿è¡Œé˜Ÿåˆ—ä¸ºå…¨å±€goroutineè¿è¡Œé˜Ÿåˆ— å…¨å±€è¿è¡Œé˜Ÿåˆ—æ˜¯æ¯ä¸ªå·¥ä½œçº¿ç¨‹éƒ½å¯ä»¥è¯»å†™çš„ï¼Œå› æ­¤è®¿é—®å®ƒéœ€è¦åŠ é”ï¼Œç„¶è€Œåœ¨ä¸€ä¸ªç¹å¿™çš„ç³»ç»Ÿä¸­ï¼ŒåŠ é”ä¼šå¯¼è‡´ä¸¥é‡çš„æ€§èƒ½é—®é¢˜ äºæ˜¯åˆä¸ºæ¯ä¸ªå·¥ä½œçº¿ç¨‹å¼•å…¥ä¸€ä¸ªç§æœ‰çš„å±€éƒ¨goroutineè¿è¡Œé˜Ÿåˆ—ï¼Œå·¥ä½œçº¿ç¨‹ä¼˜å…ˆä½¿ç”¨è‡ªå·±çš„å±€éƒ¨è¿è¡Œé˜Ÿåˆ—ï¼Œåªæœ‰å¿…è¦æ—¶æ‰ä¼šå»è®¿é—®å…¨å±€è¿è¡Œé˜Ÿåˆ— è¿™å¤§å¤§å‡å°‘äº†é”å†²çªï¼Œæé«˜äº†å·¥ä½œçº¿ç¨‹çš„å¹¶å‘æ€§ åœ¨Goè°ƒåº¦å™¨æºä»£ç ä¸­ï¼Œå±€éƒ¨è¿è¡Œé˜Ÿåˆ—è¢«åŒ…å«åœ¨pç»“æ„ä½“çš„å®ä¾‹å¯¹è±¡ä¹‹ä¸­ï¼Œæ¯ä¸€ä¸ªè¿è¡Œç€goä»£ç çš„å·¥ä½œçº¿ç¨‹éƒ½ä¼šä¸ä¸€ä¸ªpç»“æ„ä½“çš„å®ä¾‹å¯¹è±¡å…³è”åœ¨ä¸€èµ· type schedt struct { // accessed atomically. keep at top to ensure alignment on 32-bit systems. // ç”¨ä½œå…¨å±€çš„goidåˆ†é…å™¨ï¼Œä»¥ä¿è¯goidçš„å”¯ä¸€æ€§ã€‚ // Pä¸­çš„goidcacheå°±æ˜¯ä»è¿™é‡Œæ‰¹é‡åˆ†é…è·å–goidçš„ã€‚ goidgen uint64 // ä»¥ä¸‹ä¸¤ä¸ªå­—æ®µå¯ä»¥åœ¨IOè½®è¯¢æ—¶åˆ¤æ–­æ˜¯å¦æœ‰éœ€è¦çš„timerå·²åˆ°æ—¶é—´éœ€è¦å»æ‰§è¡Œ // ä¸Šæ¬¡ç½‘ç»œè½®è¯¢çš„æ—¶é—´ç‚¹ï¼Œå¦‚æœå½“å‰è½®è¯¢ï¼Œåˆ™ä¸º 0 // è®°å½•çš„æ˜¯ä¸Šæ¬¡æ‰§è¡Œnetpollçš„æ—¶é—´ï¼Œå¦‚æœç­‰äº0ï¼Œåˆ™è¡¨ç¤ºæŸä¸ªçº¿ç¨‹æ­£åœ¨é˜»å¡å¼åœ°æ‰§è¡Œnetpollã€‚ lastpoll uint64 // time of last network poll, 0 if currently polling // ä¸‹æ¬¡timeråº”è¯¥è¢«å”¤é†’æ—¶é—´ç‚¹ï¼Œæ¥è‡ªtimerå››å‰æ•°ä¸­çš„æ—¶é—´ // è¡¨ç¤ºé˜»å¡å¼åœ°netpollå°†åœ¨ä½•æ—¶è¢«å”¤é†’ã€‚GO1.14ç‰ˆæœ¬é‡æ„äº†Timerï¼Œå¼•å…¥äº†è¯¥å­—æ®µï¼Œå”¤é†’netpollerä»¥å¤„ç†Timerã€‚ pollUntil uint64 // time to which current poll is sleeping // å…¨å±€èŒƒå›´çš„è°ƒåº¦å™¨é”ï¼Œè®¿é—®schedä¸­çš„å¾ˆå¤šå­—æ®µéœ€è¦æå‰è·å¾—è¯¥é”ã€‚ lock mutex // When increasing nmidle, nmidlelocked, nmsys, or nmfreed, be // sure to call checkdead(). // æœ‰ç©ºé—²çš„å·¥ä½œçº¿ç¨‹Mç»„æˆçš„é“¾è¡¨ // ç©ºé—²Mé“¾è¡¨çš„é“¾è¡¨å¤´ï¼Œnmidleè®°å½•çš„æ˜¯ç©ºé—²Mçš„æ•°é‡ï¼Œå³é“¾è¡¨çš„é•¿åº¦ã€‚ midle muintptr // idle m\u0026#39;s waiting for work // ç©ºé—²çš„å·¥ä½œçº¿ç¨‹æ•°é‡ nmidle int32 // number of idle m\u0026#39;s waiting for work // ç»Ÿè®¡çš„æ˜¯ä¸Gç»‘å®š(LockOSThread)ä¸”å¤„äºç©ºé—²çŠ¶æ€çš„Mï¼Œç»‘å®šçš„Gæ²¡æœ‰åœ¨è¿è¡Œï¼Œç›¸åº”çš„Mä¸èƒ½ç”¨æ¥è¿è¡Œå…¶ä»–Gï¼Œåªèƒ½æŒ‚èµ·ï¼Œä»¥ä¾¿è¿›å…¥ç©ºé—²çŠ¶æ€ã€‚ nmidlelocked int32 // number of locked m\u0026#39;s waiting for work // ä¸‹ä¸€ä¸ªå·¥ä½œçº¿ç¨‹Mçš„IDå€¼ // è®°å½•äº†å…±åˆ›å»ºäº†å¤šå°‘ä¸ªMï¼ŒåŒæ—¶ä¹Ÿè¢«ç”¨ä½œä¸‹ä¸€ä¸ªMçš„IDã€‚ mnext int64 // number of m\u0026#39;s that have been created and next M ID // æœ€å¤šåªèƒ½åˆ›å»ºmaxmcountä¸ªå·¥ä½œçº¿ç¨‹Mï¼Œåˆå§‹åŒ–æ—¶è¯¥å€¼ä¸º10000ï¼Œschedinit()ä¸­è¢«è®¾ç½®ã€‚ // é™åˆ¶äº†æœ€å¤šå…è®¸çš„Mçš„ä¸ªæ•°ï¼Œé™¤å»é‚£äº›å·²ç»é‡Šæ”¾çš„ã€‚ maxmcount int32 // maximum number of m\u0026#39;s allowed (or die) // ç»Ÿè®¡çš„æ˜¯ç³»ç»ŸMçš„ä¸ªæ•°ã€‚æ¯”å¦‚ç›‘æ§çº¿ç¨‹sysmonå¯åŠ¨æ—¶ä¼š nmsys++ã€‚ nmsys int32 // number of system m\u0026#39;s not counted for deadlock // ç»Ÿè®¡çš„æ˜¯ç´¯è®¡å·²ç»é‡Šæ”¾äº†æ‰€å°‘Mã€‚ nmfreed int64 // cumulative number of freed m\u0026#39;s // è®°å½•çš„æ˜¯ç³»ç»Ÿgoroutineçš„æ•°é‡ï¼Œä¼šè¢«åŸå­æ€§çš„æ›´æ–°ã€‚ ngsys uint32 // ç³»ç»Ÿ goroutine çš„æ•°é‡ï¼› åŸå­æ›´æ–° // ç”±ç©ºé—²çš„pç»“æ„ä½“å¯¹è±¡ç»„æˆçš„é“¾è¡¨ // ç©ºé—²Pé“¾è¡¨çš„è¡¨å¤´ï¼Œnpidleè®°å½•äº†ç©ºé—²Pçš„ä¸ªæ•°ï¼Œä¹Ÿå°±æ˜¯é“¾è¡¨çš„é•¿åº¦ã€‚ pidle puintptr // idle p\u0026#39;s // ç©ºé—²çš„pç»“æ„ä½“å¯¹è±¡çš„æ•°é‡ npidle uint32 // æ­£åœ¨è‡ªæ—‹çš„Mçš„æ•°é‡ // è®°å½•çš„æ˜¯å¤„äºè‡ªæ—‹çŠ¶æ€çš„Mçš„æ•°é‡ã€‚ nmspinning uint32 // See \u0026#34;Worker thread parking/unparking\u0026#34; comment in proc.go. // Global runnable queue. // goroutineå…¨å±€è¿è¡Œé˜Ÿåˆ—ï¼Œå…¨å±€çš„å°±ç»ªé˜Ÿåˆ—ã€‚ runq gQueue // è®°å½•çš„æ˜¯å…¨å±€å°±ç»ªé˜Ÿåˆ—çš„é•¿åº¦ã€‚ä¹Ÿå°±æ˜¯å…¨å±€é˜Ÿåˆ—goroutineçš„ä¸ªæ•°ã€‚ runqsize int32 // disable controls selective disabling of the scheduler. // // Use schedEnableUser to control this. // // disable is protected by sched.lock. // // ç”¨æ¥ç¦æ­¢è°ƒåº¦ç”¨æˆ·goroutineï¼Œå…¶ä¸­çš„userå˜é‡è¢«ç½®ä¸ºtrueåï¼Œè°ƒåº¦å™¨å°†ä¸åœ¨è°ƒåº¦æ‰§è¡Œç”¨æˆ·goroutineï¼Œ // ç³»ç»Ÿgoroutineä¸å—å½±å“ã€‚æœŸé—´å°±ç»ªçš„ç”¨æˆ·gouroutineä¼šè¢«ä¸´æ—¶å­˜å‚¨æ”¾åˆ°disable.runnableé˜Ÿåˆ—ä¸­ï¼Œå˜é‡nè®°å½•äº†é˜Ÿåˆ—é•¿åº¦ã€‚ // GCæœŸé—´ã€‚ disable struct { // user disables scheduling of user goroutines. user bool runnable gQueue // pending runnable Gs n int32 // length of runnable } // Global cache of dead G\u0026#39;s. // gFreeæ˜¯æ‰€æœ‰å·²é€€å‡ºçš„goroutineå¯¹åº”çš„gç»“æ„ä½“å¯¹è±¡ç»„æˆçš„é“¾è¡¨ // ç”¨äºç¼“å­˜gç»“æ„ä½“å¯¹è±¡ï¼Œé¿å…æ¯æ¬¡åˆ›å»ºgouroutineæ—¶éƒ½é‡æ–°åˆ†é…å†…å­˜ // ç”¨æ¥å­˜å‚¨å·²ç»é€€å‡ºè¿è¡Œçš„Gï¼Œlockæ˜¯æœ¬ç»“æ„å•ç‹¬çš„é”ï¼Œé¿å…äº‰ç”¨sched.lockã€‚stackå’ŒnoStackè¿™ä¸¤ä¸ªåˆ—è¡¨åˆ†åˆ«ç”¨æ¥å­˜å‚¨æœ‰æ ˆçš„Gï¼Œå› ä¸ºåœ¨ // Gç»“æŸè¿è¡Œè¢«å›æ”¶çš„æ—¶å€™ï¼Œå¦‚æœæ ˆå¤§å°è¶…è¿‡äº†æ ‡å‡†å¤§å°ï¼Œå°±ä¼šè¢«é‡Šæ”¾ï¼Œæ‰€ä»¥æœ‰ä¸€éƒ¨åˆ†Gæ˜¯æ²¡æœ‰æ ˆçš„ã€‚å˜é‡næ˜¯ä¸¤ä¸ªåˆ—è¡¨ä¹‹å’Œï¼Œä¹Ÿå°±æ˜¯æ€»ç¼“å­˜äº†å¤šå°‘ä¸ªGã€‚ gFree struct { lock mutex stack gList // Gs with stacks noStack gList // Gs without stacks n int32 } // Central cache of sudog structs. // æ„æˆäº† sudog ç»“æ„çš„ä¸­å¤®ç¼“å­˜ï¼Œä¾›å„ä¸ªPå­˜å‚¨ã€‚ sudoglock mutex sudogcache *sudog // Central pool of available defer structs of different sizes. // æ„æˆäº† _defer ç»“æ„çš„ä¸­å¤®ç¼“å­˜ã€‚ deferlock mutex deferpool [5]*_defer // freem is the list of m\u0026#39;s waiting to be freed when their // m.exited is set. Linked through m.freelink. // freem æ˜¯è®¾ç½® m.exited æ—¶ç­‰å¾…é‡Šæ”¾çš„ m çš„åˆ—è¡¨ã€‚ é€šè¿‡ m.freelink é“¾æ¥ã€‚ // ä¸€ç»„å·²ç»ç»“æŸè¿è¡Œçš„Mæ„æˆçš„é“¾è¡¨å¤´ï¼Œé€šè¿‡m.freemé“¾æ¥åˆ°ä¸‹ä¸€ä¸ªé¡¹ï¼Œé“¾è¡¨ä¸­çš„å†…å®¹åœ¨åˆ†é…æ–°çš„Mæ—¶ä¼šè¢«å¤ç”¨ã€‚ freem *m // è¡¨ç¤ºGCæ­£åœ¨ç­‰å¾…è¿è¡Œï¼Œå’Œstopwaitã€stopnoteä¸€åŒè¢«ç”¨äºå®ç°STWã€‚ // stopwaitè®°å½•äº†STWéœ€è¦åœæ­¢çš„Pçš„æ•°é‡ï¼Œå‘èµ·STWçš„çº¿ç¨‹ä¼šå…ˆæŠŠGOMAXPROCSèµ‹å€¼ç»™stopwaitï¼Œä¹Ÿå°±æ˜¯éœ€è¦åœæ­¢æ‰€æœ‰çš„Pã€‚ // å†æŠŠgcwaitingç½®ä¸º1ï¼Œç„¶åå†stopnoteä¸Šç¡çœ ç­‰å¾…è¢«å”¤é†’ã€‚å…¶ä»–æ­£åœ¨è¿è¡Œçš„Mæ£€æµ‹åˆ°gcwaitingåä¼šé‡Šæ”¾å…³è”Pçš„æ‰€æœ‰æƒï¼Œå¹¶æŠŠPçš„çŠ¶æ€ // ç½®ä¸º_Pgcstopï¼Œå†æŠŠstopwaitçš„å€¼å‡1ï¼Œç„¶åMæŠŠè‡ªå·±æŒ‚èµ·ã€‚Måœ¨è‡ªæˆ‘æŒ‚èµ·ä¹‹å‰å¦‚æœæ£€æµ‹åˆ°stopwait==0ï¼Œä¹Ÿå°±æ˜¯æ‰€æœ‰Péƒ½å·²ç»åœæ­¢äº†ï¼Œ // å°±ä¼šé€šè¿‡stopnoteå”¤é†’å‘èµ·STWçš„çº¿ç¨‹ã€‚ gcwaiting uint32 // gc is waiting to run; GCæ˜¯å¦æ­£åœ¨å¤„äºç­‰å¾… stopwait int32 stopnote note // sysmonwaitçš„å€¼ä¸º0æˆ–1ï¼Œè¡¨ç¤ºsysmonçº¿ç¨‹æ˜¯å¦sleepã€‚ // 1. 0æ—¶ï¼Œsysmonæ²¡æœ‰sleepã€‚ // 2. 1æ—¶ï¼Œsysmonåœ¨sysmonnoteä¸Šsleepã€‚ // å½“STWæ—¶sysmonå¯èƒ½ä¼šæŒ‚åœ¨sysmonnoteä¸Šï¼Œåœ¨STWé€€å‡ºæ—¶ä¼šå”¤é†’sysmonã€‚ // å½“æ‰€æœ‰Péƒ½ç©ºé—²(å¯èƒ½æ˜¯é™·å…¥ç³»ç»Ÿè°ƒç”¨ä¸­)ï¼Œsysmonå¯èƒ½ä¼šæŒ‚åœ¨ sysmonwait uint32 sysmonnote note // While true, sysmon not ready for mFixup calls. // Accessed atomically. // è¡¨ç¤ºä¸»çº¿ç¨‹å·²ç»åˆ›å»ºäº†ç›‘æ§çº¿ç¨‹sysmonï¼Œä½†æ˜¯åè€…å°šæœªå¼€å§‹è¿è¡Œï¼ŒæŸäº›æ“ä½œéœ€è¦ç­‰åˆ°sysmonå¯åŠ¨ä¹‹åæ‰èƒ½è¿›è¡Œã€‚ sysmonStarting uint32 // safepointFn should be called on each P at the next GC // safepoint if p.runSafePointFn is set. // å¦‚æœè®¾ç½®äº† p.runSafePointFnï¼Œåˆ™åº”è¯¥åœ¨ä¸‹ä¸€ä¸ª GC å®‰å…¨ç‚¹å¯¹æ¯ä¸ª P è°ƒç”¨ safepointFn // æ˜¯ä¸€ä¸ªFunction Value.safePointWait å’Œ Value.safePointNoteçš„å·¦å³ç±»ä¼¼stopwaitå’Œstopnoneï¼Œè¢«runtime.forEachPç”¨æ¥ç¡®ä¿æ¯ä¸ªPéƒ½åœ¨ // ä¸‹ä¸€ä¸ªGCå®‰å…¨ç‚¹æ‰§è¡Œäº† safePointFnã€‚ safePointFn func(*p) safePointWait int32 safePointNote note // ç”¨æ¥è®¾ç½®æ€§èƒ½åˆ†æçš„é‡‡æ ·é¢‘ç‡ã€‚ profilehz int32 // cpu profiling rate // æœ€åä¸€æ¬¡æ”¹å˜gomaxprocsçš„æ—¶é—´ï¼Œå‚çœ‹procresize()å‡½æ•° // ç»Ÿè®¡äº†æ”¹å˜GOMAXPROCSæ‰€èŠ±è´¹çš„æ—¶é—´ã€‚ procresizetime int64 // nanotime() of last change to gomaxprocs totaltime int64 // âˆ«gomaxprocs dt up to procresizetime // sysmonlock protects sysmon\u0026#39;s actions on the runtime. // // Acquire and hold this mutex to block sysmon from interacting // with the rest of the runtime. // ç›‘æ§çº¿ç¨‹sysmonè®¿é—®runtimeæ•°æ®æ—¶ä¼šåŠ ä¸Šçš„é”ï¼Œå…¶ä»–çº¿ç¨‹å¯ä»¥é€šè¿‡å®ƒå’Œç›‘æ§çº¿ç¨‹è¿›è¡ŒåŒæ­¥ã€‚ sysmonlock mutex } é‡è¦çš„å…¨å±€å˜é‡ var ( allgs []*g\t// ä¿å­˜æ‰€æœ‰çš„g allm *m // æ‰€æœ‰çš„mæ„æˆçš„ä¸€ä¸ªé“¾è¡¨ï¼ŒåŒ…æ‹¬ä¸‹é¢çš„m0 allp []*p // ä¿å­˜æ‰€æœ‰çš„pï¼Œlen(allp) == gomaxprocs ncpu int32 // ç³»ç»Ÿä¸­cpuæ ¸çš„æ•°é‡ï¼Œç¨‹åºå¯åŠ¨æ—¶ç”±runtimeä»£ç åˆå§‹åŒ– gomaxprocs int32 // pçš„æœ€å¤§å€¼ï¼Œé»˜è®¤ç­‰äºncpuï¼Œä½†å¯ä»¥é€šè¿‡GOMAXPROCSä¿®æ”¹ sched schedt // è°ƒåº¦å™¨ç»“æ„ä½“å¯¹è±¡ï¼Œè®°å½•äº†è°ƒåº¦å™¨çš„å·¥ä½œçŠ¶æ€ m0 m // ä»£è¡¨è¿›ç¨‹çš„ä¸»çº¿ç¨‹ g0 g // m0çš„g0ï¼Œä¹Ÿæ˜¯m0.g0 = \u0026amp;g0 // Information about what cpu features are available. // Packages outside the runtime should not use these // as they are not an external api. // Set on startup in asm_{386,amd64}.s processorVersionInfo uint32 // CPUå‚å•†ä¿¡æ¯ï¼Œèƒ½æ ¹æ®è¯¥æ ‡è¯†æ‰¾åˆ°å¯¹åº”å‚å•† isIntel bool // true.å½“å‰å¤„ç†å™¨ä¿¡æ¯æ˜¯è‹±ç‰¹ï¼Œfalse.ä¸æ˜¯è‹±ç‰¹å¤„ç†å™¨ ) ","permalink":"https://heliu.site/posts/golang/goroutine/struct/","summary":"Golang GMPç›¸å…³ç»“æ„ç®€ä»‹ã€‚","title":"runtimeä¸­é‡è¦çš„ç»“æ„ä½“"},{"content":" Go é€šè¿‡é€šä¿¡æ¥å…±äº«å†…å­˜ï¼Œè€Œä¸æ˜¯å…±äº«å†…å­˜æ¥é€šä¿¡ã€‚ channel å•çº¯åœ°å°†å‡½æ•°å¹¶å‘æ‰§è¡Œæ˜¯æ²¡æœ‰æ„ä¹‰çš„ã€‚å‡½æ•°ä¸å‡½æ•°é—´éœ€è¦äº¤æ¢æ•°æ®æ‰èƒ½ä½“ç°å¹¶å‘æ‰§è¡Œå‡½æ•°çš„æ„ä¹‰ã€‚ è™½ç„¶å¯ä»¥ä½¿ç”¨å…±äº«å†…å­˜è¿›è¡Œæ•°æ®äº¤æ¢ï¼Œä½†æ˜¯å…±äº«å†…å­˜åœ¨ä¸åŒçš„goroutineä¸­å®¹æ˜“å‘ç”Ÿç«æ€é—®é¢˜ã€‚ä¸ºäº†ä¿è¯æ•°æ®äº¤æ¢çš„æ­£ç¡®æ€§ï¼Œå¿…é¡»ä½¿ç”¨äº’æ–¥é‡å¯¹å†…å­˜è¿›è¡ŒåŠ é”ï¼Œè¿™ç§åšæ³•åŠ¿å¿…é€ æˆæ€§èƒ½é—®é¢˜ã€‚ Goè¯­è¨€çš„å¹¶å‘æ¨¡å‹æ˜¯CSPï¼ˆCommunicating Sequential Processesï¼‰ï¼Œæå€¡é€šè¿‡é€šä¿¡å…±äº«å†…å­˜è€Œä¸æ˜¯é€šè¿‡å…±äº«å†…å­˜è€Œå®ç°é€šä¿¡ã€‚ å¦‚æœè¯´goroutineæ˜¯Goç¨‹åºå¹¶å‘çš„æ‰§è¡Œä½“ï¼Œchannelå°±æ˜¯å®ƒä»¬ä¹‹é—´çš„è¿æ¥ã€‚channelæ˜¯å¯ä»¥è®©ä¸€ä¸ªgoroutineå‘é€ç‰¹å®šå€¼åˆ°å¦ä¸€ä¸ªgoroutineçš„é€šä¿¡æœºåˆ¶ã€‚ Go è¯­è¨€ä¸­çš„é€šé“ï¼ˆchannelï¼‰æ˜¯ä¸€ç§ç‰¹æ®Šçš„ç±»å‹ã€‚ é€šé“åƒä¸€ä¸ªä¼ é€å¸¦æˆ–è€…é˜Ÿåˆ—ï¼Œæ€»æ˜¯éµå¾ªå…ˆå…¥å…ˆå‡ºï¼ˆFirst In First Outï¼‰çš„è§„åˆ™ï¼Œä¿è¯æ”¶å‘æ•°æ®çš„é¡ºåºã€‚ æ¯ä¸€ä¸ªé€šé“éƒ½æ˜¯ä¸€ä¸ªå…·ä½“ç±»å‹çš„å¯¼ç®¡ï¼Œä¹Ÿå°±æ˜¯å£°æ˜channelçš„æ—¶å€™éœ€è¦ä¸ºå…¶æŒ‡å®šå…ƒç´ ç±»å‹ã€‚ é€šé“æ˜¯ç±»å‹ç›¸å…³çš„ï¼Œä¸€ä¸ªé€šé“åªèƒ½ä¼ é€’ï¼ˆå‘é€æˆ–æ¥æ”¶ï¼‰ä¸€ç§ç±»å‹çš„å€¼ï¼Œè¿™ä¸ªç±»å‹éœ€è¦åœ¨å£°æ˜é€šé“æ—¶æŒ‡å®šã€‚ channel ç±»å‹ channelæ˜¯ä¸€ç§ç±»å‹ï¼Œä¸€ç§å¼•ç”¨ç±»å‹ã€‚å£°æ˜é€šé“ç±»å‹çš„æ ¼å¼å¦‚ä¸‹ï¼š 1 var identily chan type 1 2 3 var ch1 chan int // å£°æ˜ä¸€ä¸ªä¼ é€’æ•´å‹çš„é€šé“ nil var ch2 chan bool // å£°æ˜ä¸€ä¸ªä¼ é€’å¸ƒå°”å‹çš„é€šé“ nil var ch3 chan []int // å£°æ˜ä¸€ä¸ªä¼ é€’intåˆ‡ç‰‡çš„é€šé“ nil åˆ›å»º channel é€šé“æ˜¯å¼•ç”¨ç±»å‹ï¼Œé€šé“ç±»å‹çš„ç©ºå€¼æ˜¯nilã€‚ 1 2 var ch chan in // é»˜è®¤å€¼ nil fmt.Println(ch) // nil make() å‡½æ•°åˆ›å»ºé€šé“ã€‚ 1 make(chan type, [ç¼“å†²å¤§å°]) 1 2 3 ch4 := make(chan int) ch5 := make(chan bool) ch6 := make(chan []int) 1 2 3 4 // æ— ç¼“å†² var channel1 chan int = make(chan int) // é€šé“å¤§å°é»˜è®¤å€¼ä¸º0 channel2 := make(chan int) // é€šé“å¤§å°é»˜è®¤å€¼ä¸º0 channel3 := make(chan int, 1) // æœ‰ç¼“å†² Go é€šé“æœ‰ä¸‰ç§ï¼šå‘é€ï¼ˆsendï¼‰ã€æ¥æ”¶ï¼ˆreceiveï¼‰ã€åŒæ—¶å‘é€å’Œæ¥æ”¶ã€‚ chan\u0026lt;-ï¼šè¡¨ç¤ºæ•°æ®è¿›å…¥é€šé“ï¼Œè¦æŠŠæ•°æ®å†™è¿›é€šé“ï¼Œå¯¹äºè°ƒç”¨è€…å°±æ˜¯å‘é€ sendï¼Œchan \u0026lt;- intã€‚ \u0026lt;-chanï¼šè¡¨ç¤ºæ•°æ®ä»é€šé“å‡ºæ¥ï¼Œå¯¹äºè°ƒç”¨è€…å°±æ˜¯å¾—åˆ°é€šé“çš„æ•°æ®ï¼Œå½“ç„¶å°±æ˜¯æ¥æ”¶ recvï¼Œ\u0026lt;-chan intã€‚ 1 2 3 receive_only := make(\u0026lt;-chan int) // å®šä¹‰æ¥æ”¶çš„channel send_only := make(chan\u0026lt;- int) // å®šä¹‰å‘é€çš„channel send_receive := make(chan int) // å®šä¹‰åŒæ—¶å‘é€æ¥æ”¶ channel æ“ä½œ é€šé“æœ‰å‘é€ï¼ˆsendï¼‰ã€æ¥æ”¶(receiveï¼‰å’Œå…³é—­ï¼ˆcloseï¼‰ä¸‰ç§æ“ä½œã€‚å‘é€å’Œæ¥æ”¶éƒ½ä½¿ç”¨ \u0026lt;- ç¬¦å·ã€‚ å®šä¹‰é€šé“ï¼Œæ— ç¼“å†²é€šé“ã€‚ 1 ch := make(chan int) // sizeé»˜è®¤ç­‰äº0 å‘é€ï¼šå°†ä¸€ä¸ªå€¼å‘é€åˆ°é€šé“ä¸­ã€‚ 1 ch \u0026lt;- 10 // æŠŠ10å‘é€åˆ°chä¸­ æ¥æ”¶ï¼šä»ä¸€ä¸ªé€šé“ä¸­æ¥æ”¶å€¼ã€‚ 1 2 x := \u0026lt;- ch // ä»chä¸­æ¥æ”¶å€¼å¹¶èµ‹å€¼ç»™å˜é‡x \u0026lt;-ch // ä»chä¸­æ¥æ”¶å€¼ï¼Œå¿½ç•¥ç»“æœ å…³é—­ï¼šé€šè¿‡è°ƒç”¨å†…ç½®çš„closeå‡½æ•°æ¥å…³é—­é€šé“ã€‚ 1 close(ch) å…³äºå…³é—­é€šé“éœ€è¦æ³¨æ„çš„äº‹æƒ…æ˜¯ï¼š åªæœ‰åœ¨é€šçŸ¥æ¥æ”¶æ–¹goroutineæ‰€æœ‰çš„æ•°æ®éƒ½å‘é€å®Œæ¯•çš„æ—¶å€™æ‰éœ€è¦å…³é—­é€šé“ã€‚ é€šé“æ˜¯å¯ä»¥è¢«åƒåœ¾å›æ”¶æœºåˆ¶å›æ”¶çš„ï¼Œå®ƒå’Œå…³é—­æ–‡ä»¶æ˜¯ä¸ä¸€æ ·çš„ã€‚ åœ¨ç»“æŸæ“ä½œä¹‹åå…³é—­æ–‡ä»¶æ˜¯å¿…é¡»è¦åšçš„ï¼Œä½†å…³é—­é€šé“ä¸æ˜¯å¿…é¡»çš„ã€‚ å…³é—­åçš„é€šé“æœ‰ä»¥ä¸‹ç‰¹ç‚¹ï¼š å¯¹ä¸€ä¸ªå…³é—­çš„é€šé“å†å‘é€å€¼å°±ä¼šå¯¼è‡´panicã€‚ å¯¹ä¸€ä¸ªå…³é—­çš„é€šé“è¿›è¡Œæ¥æ”¶ä¼šä¸€ç›´è·å–å€¼ç›´åˆ°é€šé“ä¸ºç©ºã€‚ å¯¹ä¸€ä¸ªå…³é—­çš„å¹¶ä¸”æ²¡æœ‰å€¼å¾—é€šé“æ‰§è¡Œæ¥æ”¶æ“ä½œä¼šå¾—åˆ°å¯¹åº”ç±»å‹çš„é›¶å€¼ã€‚ å…³é—­ä¸€ä¸ªå·²å…³é—­çš„é€šé“ä¼šå¯¼è‡´panicã€‚ æ— ç¼“å†²çš„é€šé“ æ— ç¼“å†²çš„é€šé“åˆç§°ä¸ºé˜»å¡çš„é€šé“ã€‚ 1 2 3 4 5 6 7 8 9 package main import \u0026#34;fmt\u0026#34; func main() { ch := make(chan int) ch \u0026lt;- 10 fmt.Println(\u0026#34;å‘é€æˆåŠŸ\u0026#34;) } ä¸Šé¢è¿™æ®µä»£ç èƒ½å¤Ÿé€šè¿‡ç¼–è¯‘ï¼Œä½†æ˜¯æ‰§è¡Œçš„æ—¶å€™ä¼šå‡ºç°ä»¥ä¸‹é”™è¯¯ï¼š fatal error: all goroutines are asleep - deadlock! æ‰€æœ‰çš„goroutineéƒ½ç¡çœ  - æ­»é” goroutine 1 [chan send]: main.main() D:/True-False/WWW/GoLang/src/xuexi/channel1.go:7 +0x5b exit status 2 ä¸ºä»€ä¹ˆä¼šå‡ºç°deadlocké”™è¯¯å‘¢ï¼Ÿ å› ä¸ºæˆ‘ä»¬ä½¿ç”¨ch := make(chan int)åˆ›å»ºçš„æ˜¯æ— ç¼“å†²çš„é€šé“ã€‚ æ— ç¼“å†²çš„é€šé“åªæœ‰åœ¨æœ‰äººæ¥æ”¶å€¼çš„æ—¶å€™æ‰èƒ½å‘é€å€¼ã€‚æ— ç¼“å†²çš„é€šé“å¿…é¡»æœ‰æ¥æ”¶æ‰èƒ½å‘é€ã€‚ ä¸Šé¢çš„ä»£ç ä¼šé˜»å¡åœ¨ch \u0026lt;- 10è¿™ä¸€è¡Œä»£ç å½¢æˆæ­»é”ï¼Œé‚£å¦‚ä½•è§£å†³è¿™ä¸ªé—®é¢˜å‘¢ï¼Ÿ ä¸€ç§æ–¹æ³•æ˜¯å¯ç”¨ä¸€ä¸ªgoroutineå»æ¥æ”¶å€¼ï¼Œä¾‹å¦‚ï¼š 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 package main import \u0026#34;fmt\u0026#34; func main() { ch := make(chan int) go recv(ch) ch \u0026lt;- 10 fmt.Println(\u0026#34;å‘é€æˆåŠŸ\u0026#34;) // Output: // 10 // å‘é€æˆåŠŸ } func recv(c chan int) { recv := \u0026lt;- c fmt.Println(recv) } æ— ç¼“å†²é€šé“ä¸Šçš„å‘é€æ“ä½œä¼šé˜»å¡ï¼Œç›´åˆ°å¦ä¸€ä¸ªgoroutineåœ¨è¯¥é€šé“ä¸Šæ‰§è¡Œæ¥æ”¶æ“ä½œã€‚ è¿™æ—¶å€¼æ‰èƒ½å‘é€æˆåŠŸï¼Œä¸¤ä¸ªgoroutineå°†ç»§ç»­æ‰§è¡Œã€‚ ç›¸åï¼Œå¦‚æœæ¥æ”¶æ“ä½œå…ˆæ‰§è¡Œï¼Œæ¥æ”¶æ–¹çš„goroutineå°†é˜»å¡ï¼Œç›´åˆ°å¦ä¸€ä¸ªgoroutineåœ¨è¯¥é€šé“ä¸Šå‘é€ä¸€ä¸ªå€¼ã€‚ ä½¿ç”¨æ— ç¼“å†²é€šé“è¿›è¡Œé€šä¿¡å°†å¯¼è‡´å‘é€å’Œæ¥æ”¶çš„goroutineåŒæ­¥åŒ–ï¼Œå› æ­¤ï¼Œæ— ç¼“å†²é€šé“ä¹Ÿè¢«ç§°ä¸ºåŒæ­¥é€šé“ã€‚ æœ‰ç¼“å†²çš„é€šé“ è§£å†³ä¸Šé¢é—®é¢˜çš„æ–¹æ³•è¿˜æœ‰ä¸€ç§å°±æ˜¯ä½¿ç”¨æœ‰ç¼“å†²åŒºçš„é€šé“ã€‚ æˆ‘ä»¬å¯ä»¥åœ¨ä½¿ç”¨makeå‡½æ•°åˆå§‹åŒ–é€šé“çš„æ—¶å€™ä¸ºå…¶æŒ‡å®šé€šé“çš„å®¹é‡ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 package main import \u0026#34;fmt\u0026#34; func main() { ch := make(chan int, 1) ch \u0026lt;- 10 fmt.Println(\u0026#34;å‘é€æˆåŠŸ\u0026#34;) // Output: // å‘é€æˆåŠŸ } åªè¦é€šé“çš„å®¹é‡å¤§äºé›¶ï¼Œé‚£ä¹ˆè¯¥é€šé“å°±æ˜¯æœ‰ç¼“å†²çš„é€šé“ï¼Œé€šé“çš„å®¹é‡è¡¨ç¤ºé€šé“ä¸­èƒ½å­˜æ”¾å…ƒç´ çš„æ•°é‡ã€‚ æˆ‘ä»¬å¯ä»¥ä½¿ç”¨å†…ç½®çš„lenå‡½æ•°è·å–é€šé“å†…å…ƒç´ çš„æ•°é‡ï¼Œä½¿ç”¨capå‡½æ•°è·å–é€šé“çš„å®¹é‡ï¼Œè™½ç„¶æˆ‘ä»¬å¾ˆå°‘ä¼šè¿™ä¹ˆåšã€‚ len(chan) è·å–é€šé“å†…çš„å…ƒç´ ä¸ªæ•°ã€‚ cap(chan) è·å–é€šé“å®¹é‡ã€‚ å…³é—­é€šé“ å¯ä»¥é€šè¿‡å†…ç½®çš„close()å‡½æ•°å…³é—­channelï¼Œå¦‚æœä½ çš„ç®¡é“ä¸å¾€é‡Œå­˜å€¼æˆ–è€…å–å€¼çš„æ—¶å€™ä¸€å®šè®°å¾—å…³é—­ç®¡é“ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 package main import \u0026#34;fmt\u0026#34; func main() { c := make(chan int) go func() { for i := 0; i \u0026lt; 5; i++ { c \u0026lt;- i } close(c)\t// å…³é—­é€šé“ }() for { if data, ok := \u0026lt;- c; ok { fmt.Println(data) } else { break } } /* for v := range c { fmt.Println(v) } */ fmt.Println(\u0026#34;mainç»“æŸ\u0026#34;) // Output: // 0 // 1 // 2 // 3 // 4 // mainç»“æŸ } ä»é€šé“å¾ªç¯å–å€¼ å½“é€šè¿‡é€šé“å‘é€æœ‰é™çš„æ•°æ®æ—¶ï¼Œæˆ‘ä»¬å¯ä»¥é€šè¿‡closeå‡½æ•°å…³é—­é€šé“æ¥å‘ŠçŸ¥ä»è¯¥é€šé“æ¥æ”¶å€¼çš„goroutineåœæ­¢ç­‰å¾…ï¼Œä½¿ç”¨closeå…³é—­é€šé“ï¼Œä¼šè§¦å‘é‚£äº›åœ¨ç­‰å¾…ä¸­çš„goroutineã€‚ å½“é€šé“è¢«å…³é—­æ—¶ï¼Œå¾€è¯¥é€šé“å‘é€å€¼ä¼šå¼•å‘panicï¼Œä»è¯¥é€šé“é‡Œæ¥æ”¶çš„å€¼ä¸€ç›´éƒ½æ˜¯ç±»å‹é›¶å€¼ã€‚ é‚£å¦‚ä½•åˆ¤æ–­ä¸€ä¸ªé€šé“æ˜¯å¦è¢«å…³é—­äº†å‘¢ï¼Ÿ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 package main import \u0026#34;fmt\u0026#34; func main() { ch1 := make(chan int) ch2 := make(chan int) go func() { for i := 0; i \u0026lt; 10; i++ { ch1 \u0026lt;- i } close(ch1) }() go func() { for { i, ok := \u0026lt;-ch1 // é€šé“å…³é—­åå†å–å€¼ ok = false if !ok { // é€šé“å…³é—­æ—¶é€€å‡ºå¾ªç¯ break } ch2 \u0026lt;- i * i } close(ch2) }() // æ‰“å°ch2ä¸­å€¼ï¼Œé€šé“å…³é—­åä¼šé€€å‡ºfor rangeå¾ªç¯ for i := range ch2 { fmt.Println(i) } // Output: // 0 // 1 // 4 // 9 // 16 // 25 // 36 // 49 // 64 // 81 } ä»ä¸Šé¢çš„ä¾‹å­ä¸­æˆ‘ä»¬çœ‹åˆ°æœ‰ä¸¤ç§æ–¹å¼åœ¨æ¥æ”¶å€¼çš„æ—¶å€™åˆ¤æ–­é€šé“æ˜¯å¦è¢«å…³é—­ï¼Œæˆ‘ä»¬é€šå¸¸ä½¿ç”¨çš„æ˜¯for rangeçš„æ–¹å¼ã€‚ å•å‘é€šé“ æœ‰çš„æ—¶å€™æˆ‘ä»¬ä¼šå°†é€šé“ä½œä¸ºå‚æ•°åœ¨å¤šä¸ªä»»åŠ¡å‡½æ•°é—´ä¼ é€’ï¼Œå¾ˆå¤šæ—¶å€™æˆ‘ä»¬åœ¨ä¸åŒçš„ä»»åŠ¡å‡½æ•°ä¸­ä½¿ç”¨é€šé“éƒ½ä¼šå¯¹å…¶è¿›è¡Œé™åˆ¶ï¼Œæ¯”å¦‚é™åˆ¶é€šé“åœ¨å‡½æ•°ä¸­åªèƒ½å‘é€æˆ–åªèƒ½æ¥æ”¶ã€‚ Goè¯­è¨€ä¸­æä¾›äº†å•å‘é€šé“æ¥å¤„ç†è¿™ç§æƒ…å†µã€‚ä¾‹å¦‚ï¼Œæˆ‘ä»¬æŠŠä¸Šé¢çš„ä¾‹å­æ”¹é€ å¦‚ä¸‹ï¼š 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 package main import \u0026#34;fmt\u0026#34; func main() { ch1 := make(chan int) ch2 := make(chan int) go counter(ch1) go squarer(ch2, ch1) printer(ch2) // Output: // 100 // 121 // 144 // 169 // 196 // 225 // 256 // 289 // 324 // 361 } func counter(out chan \u0026lt;- int) { for i := 10; i \u0026lt; 20; i++ { out \u0026lt;- i } close(out) } func squarer(out chan \u0026lt;- int, in \u0026lt;- chan int) { for i := range in { out \u0026lt;- i * i } close(out) } func printer(in \u0026lt;- chan int) { for i := range in { fmt.Println(i) } } å…¶ä¸­ï¼Œchan \u0026lt;- int æ˜¯ä¸€ä¸ªåªèƒ½å‘é€çš„é€šé“ï¼Œå¯ä»¥å‘é€ä½†æ˜¯ä¸èƒ½æ¥æ”¶ã€‚\u0026lt;- chan int æ˜¯ä¸€ä¸ªåªèƒ½æ¥æ”¶çš„é€šé“ï¼Œå¯ä»¥æ¥æ”¶ä½†æ˜¯ä¸èƒ½å‘é€ã€‚ åœ¨å‡½æ•°ä¼ å‚åŠä»»ä½•èµ‹å€¼æ“ä½œä¸­å°†åŒå‘é€šé“è½¬æ¢ä¸ºå•å‘é€šé“æ˜¯å¯ä»¥çš„ï¼Œä½†åè¿‡æ¥æ˜¯ä¸å¯ä»¥çš„ã€‚ æ€»ç»“ å…³é—­å·²ç»å…³é—­çš„channelä¹Ÿä¼šå¼•å‘panicã€‚ channel nil éç©º ç©ºçš„ æ»¡äº† æ²¡æ»¡ æ¥æ”¶ panic æ¥æ”¶å€¼ é˜»å¡ æ¥æ”¶å€¼ æ¥æ”¶å€¼ å‘é€ panic å‘é€å€¼ å‘é€å€¼ é˜»å¡ å‘é€å€¼ å…³é—­ panic å…³é—­æˆåŠŸï¼Œè¯»å®Œæ•°æ®åè¿”å›é›¶å€¼ å…³é—­æˆåŠŸï¼Œè¿”å›é›¶å€¼ å…³é—­æˆåŠŸï¼Œè¯»å®Œæ•°æ®åè¿”å›é›¶å€¼ å…³é—­æˆåŠŸï¼Œè¯»å®Œæ•°æ®åè¿”å›é›¶å€¼å€¼ select select å¤šè·¯å¤ç”¨ æŸäº›åœºæ™¯ä¸‹æˆ‘ä»¬éœ€è¦åŒæ—¶ä»å¤šä¸ªé€šé“æ¥æ”¶æ•°æ®ï¼Œé€šé“åœ¨æ¥æ”¶æ•°æ®æ—¶ï¼Œå¦‚æœæ²¡æœ‰æ•°æ®å¯ä»¥æ¥æ”¶å°†ä¼šå‘ç”Ÿé˜»å¡ã€‚ ä½ ä¹Ÿè®¸ä¼šå†™å‡ºå¦‚ä¸‹ä»£ç ä½¿ç”¨éå†çš„æ–¹å¼æ¥å®ç°ï¼š 1 2 3 4 5 6 7 for { // å°è¯•ä» ch1 æ¥æ”¶å€¼ data, ok := \u0026lt;-ch1 // å°è¯•ä» ch2 æ¥æ”¶å€¼ data, ok := \u0026lt;-ch2 // ... } è¿™ç§æ–¹å¼è™½ç„¶å¯ä»¥å®ç°ä»å¤šä¸ªé€šé“æ¥æ”¶å€¼çš„éœ€æ±‚ï¼Œä½†æ˜¯è¿è¡Œæ€§èƒ½ä¼šå·®å¾ˆå¤šã€‚ä¸ºäº†åº”å¯¹è¿™ç§åœºæ™¯ï¼ŒGoå†…ç½®äº†selectå…³é”®å­—ï¼Œå¯ä»¥åŒæ—¶å“åº”å¤šä¸ªé€šé“çš„æ“ä½œã€‚ selectçš„ä½¿ç”¨ç±»ä¼¼äºswitchè¯­å¥ï¼Œå®ƒæœ‰ä¸€ç³»åˆ—caseåˆ†æ”¯å’Œä¸€ä¸ªé»˜è®¤çš„åˆ†æ”¯ã€‚ æ¯ä¸ªcaseä¼šå¯¹åº”ä¸€ä¸ªé€šé“çš„é€šä¿¡ï¼ˆæ¥æ”¶æˆ–å‘é€ï¼‰è¿‡ç¨‹ã€‚ selectä¼šä¸€ç›´ç­‰å¾…ï¼Œç›´åˆ°æŸä¸ªcaseçš„é€šä¿¡æ“ä½œå®Œæˆæ—¶ï¼Œå°±ä¼šæ‰§è¡Œcaseåˆ†æ”¯å¯¹åº”çš„è¯­å¥ã€‚ å…·ä½“æ ¼å¼å¦‚ä¸‹ï¼š 1 2 3 4 5 6 7 8 select { case \u0026lt;- chan1: // å¦‚æœchan1æˆåŠŸè¯»åˆ°æ•°æ®ï¼Œåˆ™è¿›è¡Œè¯¥caseå¤„ç†è¯­å¥ case chan \u0026lt;- 1: // å¦‚æœæˆåŠŸå‘chan2å†™å…¥æ•°æ®ï¼Œåˆ™è¿›è¡Œè¯¥caseå¤„ç†è¯­å¥ default: // å¦‚æœä¸Šé¢éƒ½æ²¡æœ‰æˆåŠŸï¼Œåˆ™è¿›å…¥defaultå¤„ç†æµç¨‹ } select å¯ä»¥åŒæ—¶ç›‘å¬ä¸€ä¸ªæˆ–å¤šä¸ªchannelï¼Œç›´åˆ°å…¶ä¸­ä¸€ä¸ªchannel readyã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 package main import ( \u0026#34;fmt\u0026#34; ) func test11(ch chan string) { ch \u0026lt;- \u0026#34;test1\u0026#34; } func test21(ch chan string) { ch \u0026lt;- \u0026#34;test2\u0026#34; } func main() { // åˆ›å»º2ä¸ªé€šé“ output1 := make(chan string) output2 := make(chan string) // è·‘2ä¸ªå­åç¨‹ï¼Œå†™æ•°æ® go test11(output1) go test21(output2) // ç”±äºselectåªèƒ½é€‰æ‹©å…¶ä¸­ä¸€ä¸ªæ‰§è¡Œï¼Œå› æ­¤ä¸Šé¢ä¸¤ä¸ªgoroutineè‡³å°‘æœ‰ä¸€ä¸ªè¦é˜»å¡ // å› æ­¤åœ¨caseé‡Œé¢æ·»è¯»å–å¦å¤–ä¸€ä¸ªgoroutineï¼Œé˜²æ­¢goroutineè¢«ä¸€ç›´æŒ‚èµ·ã€‚ select { case s1 := \u0026lt;-output1: // recv \u0026lt;-output2 fmt.Println(\u0026#34;s1=\u0026#34;, s1) case s2 := \u0026lt;-output2: // recv \u0026lt;-output1 fmt.Println(\u0026#34;s2=\u0026#34;, s2) } // Output: // s2= test2 } å¦‚æœå¤šä¸ªchannelåŒæ—¶readyï¼Œåˆ™éšæœºé€‰æ‹©ä¸€ä¸ªæ‰§è¡Œã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 package main import ( \u0026#34;fmt\u0026#34; ) func main() { // åˆ›å»º2ä¸ªé€šé“ intChan := make(chan int, 1) stringChan := make(chan string, 1) go func() { intChan \u0026lt;- 1 }() go func() { stringChan \u0026lt;- \u0026#34;hello\u0026#34; }() select { case value := \u0026lt;- intChan: fmt.Println(\u0026#34;int:\u0026#34;, value) case value := \u0026lt;- stringChan: fmt.Println(\u0026#34;string:\u0026#34;, value) } fmt.Println(\u0026#34;mainç»“æŸ\u0026#34;) // Output: // string: hello // mainç»“æŸ } å¯ä»¥ç”¨äºåˆ¤æ–­é€šé“æ˜¯å¦å­˜æ»¡ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;time\u0026#34; ) func main() { // åˆ›å»ºé€šé“ output1 := make(chan string, 10) // å­—åç¨‹å†™æ•°æ® go write(output1) // å–æ•°æ® for s := range output1 { fmt.Println(\u0026#34;res:\u0026#34;, s) // å»¶è¿Ÿæ•°æ®è¯»å– time.Sleep(time.Second) } // Output: // write hello // res: hello // write hello // write hello // res: hello // write hello // res: hello // write hello // write hello // ... } func write(ch chan string) { for { select { case ch \u0026lt;- \u0026#34;hello\u0026#34;: fmt.Println(\u0026#34;write hello\u0026#34;) default: fmt.Println(\u0026#34;channel full\u0026#34;) } // å»¶è¿Ÿ ç­‰åˆ°æ•°æ®è¢«å–å‡º ä¸ç„¶ä¸€ç›´åœ¨æ‰§è¡Œdefaultæ¡ä»¶è¯­å¥ time.Sleep(500 * time.Millisecond) } } å‚è€ƒ https://www.topgoer.com ","permalink":"https://heliu.site/posts/golang/channel/use/","summary":"Golang channelä½¿ç”¨ä»‹ç»ã€‚","title":"Channel(ä½¿ç”¨)"},{"content":"åŒ…è§£é‡Šï¼š\nè¯¥æ–‡ä»¶åŒ…å« Go channels çš„å®ç°ã€‚ c.sendq å’Œ c.recvq ä¸­è‡³å°‘æœ‰ä¸€ä¸ªæ˜¯ç©ºçš„ï¼Œé™¤äº†ä½¿ç”¨ select è¯­å¥å‘é€å’Œæ¥æ”¶çš„æ— ç¼“å†² chan ä¸Šé˜»æ­¢äº†å•ä¸ª goroutine çš„æƒ…å†µå¤–ï¼Œåœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œc.sendq å’Œc.recvq çš„é•¿åº¦ä»…å— select è¯­å¥çš„å¤§å°é™åˆ¶ã€‚ select åŒæ—¶æ“ä½œå•ä¸ªæ— ç¼“å†² chan çš„è¯»å’Œå†™è¿™ç§æƒ…å†µä¸‹å¯èƒ½å­˜åœ¨ c.sendq å’Œ c.recvq éƒ½ä¸ä¸ºç©ºï¼ˆè¿™ç§æƒ…å†µä¸‹ selectä¸èƒ½æœ‰ default åˆ†æ”¯ï¼‰ã€‚ å¯¹äºç¼“å†² channelsï¼Œä¹Ÿæ˜¯: c.qcount \u0026gt; 0 è¡¨ç¤º c.recvq ä¸ºç©ºã€‚ç¼“å­˜åŒºæœ‰å€¼åˆ™ c.recvq ä¸€å®šä¸ºç©ºã€‚ c.qcount \u0026lt; c.dataqsiz æ„å‘³ç€ c.sendq æ˜¯ç©ºçš„ã€‚ç¼“å­˜åŒºæ²¡æœ‰æ»¡åˆ™ c.sendq ä¸€å®šä¸ºç©ºã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 package runtime // This file contains the implementation of Go channels. // Invariants: // At least one of c.sendq and c.recvq is empty, // except for the case of an unbuffered channel with a single goroutine // blocked on it for both sending and receiving using a select statement, // in which case the length of c.sendq and c.recvq is limited only by the // size of the select statement. // // For buffered channels, also: // c.qcount \u0026gt; 0 implies that c.recvq is empty. // c.qcount \u0026lt; c.dataqsiz implies that c.sendq is empty. type hchan struct hchan ç»“æ„å…¶å®å°±æ˜¯ä¸€ä¸ªã€æœ‰ç¼“å†²ã€‘å’Œã€åŒå‘é“¾è¡¨ã€‘ç»„æˆçš„é˜Ÿåˆ—ã€‚ è¿™ä¸ªé˜Ÿåˆ—ç»´æŠ¤ç€é€šä¿¡çš„æ•°æ®ï¼Œä»¥åŠæŒ‚èµ·ç­‰å¾…çš„ goroutineã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 type hchan struct { // å·²æœ‰å…ƒç´ ä¸ªæ•°ï¼ˆä¹Ÿå°±æ˜¯é€šé“ä¸­å…ƒç´ ä¸ªæ•°ï¼‰len(chan) // ç¼“å­˜åŒºå…ƒç´ ä¸ªæ•°ï¼Œä¸åŒ…æ‹¬sendqä¸Šé¢çš„goroutineæ•°é‡(å¦‚æœå­˜åœ¨) qcount uint // total data in the queue // æ•°ç»„å®¹é‡ï¼ˆä¹Ÿå°±æ˜¯chanå®¹é‡ï¼‰cap(chan)\t// ä¹Ÿå°±æ˜¯ make(chan int, size) è¿™é‡Œçš„size dataqsiz uint // size of the circular queue // æœ‰ç¼“å†²æ•°ç»„åœ°å€æŒ‡é’ˆï¼Œè¿™é‡Œæ˜¯æ ¹æ® dataqsiz*elemsize è®¡ç®—åˆ†é…çš„å†…å­˜æ•°ç»„å¤§å° buf unsafe.Pointer // points to an array of dataqsiz elements // å…ƒç´ å¤§å°ï¼Œæ¯”å¦‚intè¿™é‡Œå­˜å‚¨çš„å°±æ˜¯8ï¼Œstringçš„è¯è¿™é‡Œå­˜å‚¨çš„å°±æ˜¯16 elemsize uint16 // é€šé“æ˜¯å¦è¢«å…³é—­ 1.è¢«å…³é—­ 0.æ­£å¸¸ closed uint32 // chanå…ƒç´ ç±»å‹ï¼ŒæŒ‡å‘ç±»å‹å…ƒæ•°æ®ï¼Œæ¯”å¦‚chan intè¿™é‡Œè®°å½•çš„å°±æ˜¯intçš„å…ƒç±»å‹ elemtype *_type // element type // å½“å‰ç´¢å¼•ï¼ˆè®°å½•ä¸‹ä¸€æ¬¡sendä¸‹æ ‡ï¼‰ï¼Œä¸‹ä¸€æ¬¡å†™å–ä½ç½®ã€‚ sendx uint // send index // å½“å‰ç´¢å¼•ï¼ˆè®°å½•ä¸‹ä¸€æ¬¡recvä¸‹æ ‡ï¼‰ï¼Œä¸‹ä¸€æ¬¡è¯»å…¥ä½ç½®ã€‚ recvx uint // receive index // ç­‰å¾…å†™çš„é˜Ÿåˆ—ï¼Œæ˜¯ä¸€ä¸ªåŒå‘çš„goroutineé“¾è¡¨ recvq waitq // list of recv waiters // ç­‰å¾…è¯»çš„é˜Ÿåˆ—ï¼Œæ˜¯ä¸€ä¸ªåŒå‘çš„goroutineé“¾è¡¨ sendq waitq // list of send waiters // lock protects all fields in hchan, as well as several // fields in sudogs blocked on this channel. // // Do not change another G\u0026#39;s status while holding this lock // (in particular, do not ready a G), as this can deadlock // with stack shrinking. // // lockä¿æŠ¤hchanä¸­çš„æ‰€æœ‰å­—æ®µï¼Œä»¥åŠsudogsä¸­çš„ä¸€äº›å­—æ®µåœ¨è¿™ä¸ªé€šé“ä¸Šè¢«é˜»å¡ã€‚ // åœ¨æŒæœ‰è¯¥é”æ—¶ï¼Œä¸è¦æ”¹å˜å¦ä¸€ä¸ªGçš„çŠ¶æ€(ç‰¹åˆ«æ˜¯ä¸è¦å‡†å¤‡ä¸€ä¸ªG)ï¼Œå› ä¸ºè¿™å¯èƒ½ä¼šå¯¼è‡´æ ˆæ”¶ç¼©æ­»é”ã€‚ lock mutex\t// runtime.mutex ä¸ºäº†åº”å¯¹å¹¶å‘çš„è¯»å†™chanï¼Œå‚çœ‹runtime.mutexç›¸å…³æ–‡æ¡£ } hchan ç¼“å­˜åŒºå†…å­˜å¸ƒå±€å›¾ï¼ˆå¦‚æœå­˜åœ¨ç¼“å­˜åŒºæ—¶ï¼‰ raceaddr() è¯¥å‡½æ•°ä¸»è¦ç”¨äº make() å‡½æ•°ä¸­ï¼Œå½“ç”³è¯·æ€»å†…å­˜ä¸º0æ—¶ï¼Œè¿”å›å½“å‰bufå­—æ®µåœ°å€ä½œä¸º buf çš„å€¼ã€‚å½¢æˆæŒ‡é’ˆæŒ‡å‘é—­ç¯ã€‚ 1 2 3 4 5 6 7 8 9 10 11 func (c *hchan) raceaddr() unsafe.Pointer { // Treat read-like and write-like operations on the channel to // happen at this address. Avoid using the address of qcount // or dataqsiz, because the len() and cap() builtins read // those addresses, and we don\u0026#39;t want them racing with // operations like close(). // // å°†channelä¸Šçš„read-likeå’Œwrite-likeæ“ä½œè§†ä¸ºåœ¨æ­¤åœ°å€å‘ç”Ÿã€‚ // é¿å…ä½¿ç”¨qcountæˆ–dataqsizçš„åœ°å€ï¼Œå› ä¸ºlen()å’Œcap()å†…ç½®å‡½æ•°ä¼šè¯»å–è¿™äº›åœ°å€ï¼Œæˆ‘ä»¬ä¸å¸Œæœ›å®ƒä»¬ä¸close()ç­‰æ“ä½œç«äº‰ã€‚ return unsafe.Pointer(\u0026amp;c.buf) } sortkey() è¯¥å‡½æ•°åœ¨ goselect() å‡½æ•°ä¸­ä½¿ç”¨ï¼Œç”¨äºè¿”å› chan åœ°å€å‡åºæ’åº channelsã€‚ select ä¸­ç›¸å…³ç”¨åˆ°çš„å‡½æ•°ã€‚åœ¨åé¢ä»‹ç»selectæ—¶ï¼Œä¼šè¢«ä½¿ç”¨ã€‚ 1 2 3 func (c *hchan) sortkey() uintptr { return uintptr(unsafe.Pointer(c)) } Constant 1 2 3 4 5 6 7 8 9 10 11 const ( // æœ€å¤§å¯¹é½å­—èŠ‚æ•°ï¼Œä¸»è¦ç”¨äºä¸‹é¢çš„å®šä¹‰ã€‚ maxAlign = 8 // hchan å ç”¨å†…å­˜å¤§å°å­—èŠ‚ï¼Œä½¿ hchan æŒ‰ç…§ maxAlign å¤§å°å¯¹é½ // æ¯”å¦‚ hchan æ˜¯ 12byteï¼Œé‚£ä¹ˆ hchanSize åˆ™æ˜¯ 16byte // ä¸ºä»€ä¹ˆè¦ä½¿ hchan å¯¹é½ maxAlignï¼ŸåŸå› æ˜¯ hchan åæ¥ç€æ˜¯ chan å…ƒç´ çš„å†…å­˜ç©ºé—´å—(å¦‚æœæ˜¯æœ‰ç¼“å†²æƒ…å†µä¸‹) // è¿™ç§æƒ…å†µæ˜¯ä¸ºäº†å…¼å®¹32ä½ï¼Œå› ä¸ºåœ¨64ä½ä¸‹hchanå°±æ˜¯8å­—èŠ‚å¯¹é½çš„ï¼Œè¯¥å­—æ®µç”¨äºmakeå‡½æ•°ä¸­ç”³è¯· chan å†…å­˜éœ€è¦ã€‚ hchanSize = unsafe.Sizeof(hchan{}) + uintptr(-int(unsafe.Sizeof(hchan{}))\u0026amp;(maxAlign-1)) debugChan = false\t// debug ) type waitq struct waitq æ ¹æ® sudog å½¢æˆä¸€ä¸ªåŒå‘é“¾è¡¨ã€‚ å…¶å®å°±æ˜¯ä¸€ä¸ªé˜Ÿåˆ—çš„åŠŸèƒ½ï¼Œå…ƒç´ ã€ä» last å¤„æ·»åŠ ã€‘ï¼Œã€ä» first å¤„å–å‡ºã€‘ã€‚ 1 2 3 4 type waitq struct { first *sudog // æŒ‡å‘é“¾è¡¨çš„é¦–ä¸ª *sudog last *sudog // æŒ‡å‘é“¾è¡¨çš„å°¾éƒ¨ *sudog } dequeue() ä» first ä¸­å–å‡ºä¸€ä¸ª *sudogã€‚ç›¸å½“äºä»é˜Ÿåˆ—å¤´ï¼ˆfirstï¼‰å–å‡ºä¸€ä¸ª *sudogã€‚ è°ƒç”¨è¯¥æ–¹æ³•æ—¶ chan lock é”ä¸€å®šæ˜¯è¢«æŒæœ‰çš„ã€‚ä¸‹é¢å‡½æ•°ä¸­éœ€è¦ for {} çš„åŸå› æ˜¯æœ€åä¸€ä¸ª if æ¡ä»¶çš„ CAS æ“ä½œã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 func (q *waitq) dequeue() *sudog { for { sgp := q.first // ä»firstå¤„å–ä¸€ä¸ª *sudog if sgp == nil { return nil } y := sgp.next if y == nil { // æœ€åä¸€ä¸ª *sudog q.first = nil q.last = nil } else { y.prev = nil q.first = y // æ ‡è®°å·²åˆ é™¤ï¼ˆå‚çœ‹ dequeueSudoGï¼‰ sgp.next = nil // mark as removed (see dequeueSudoG) } // ä¸ºä»€ä¹ˆéœ€è¦ä¸‹é¢çš„åˆ¤æ–­æ¡ä»¶ï¼Ÿ // 1. select è¯­å¥ä¸­é˜»å¡äº†ä¸€ç»„ chan æ—¶ï¼Œæ‰€æœ‰ channels çš„ lock é”éƒ½å·²è¢«æŒæœ‰ã€‚ // 2. å½“å‰æ‰§è¡Œselectè¯­å¥çš„goroutineä¼šè¢«å°è£…åˆ°å¤šä¸ª*sudogä¸­é€šè¿‡waitlinkå­—æ®µå½¢æˆé“¾è¡¨ï¼Œç„¶åæŠŠå„ä¸ª*sudogçš„isSelectå­—æ®µæ ‡è®°ä¸ºtrueã€‚ // 3. æŠŠå„ä¸ª*sudogåˆ†åˆ«æŒ‚åœ¨å„è‡ªçš„sendqæˆ–recvqé“¾è¡¨ä¸­ã€‚ç­‰å¾…goroutineè¢«å”¤é†’ã€‚ // 4. æŸä¸€æ—¶åˆ»*sudogè¢«é€‰ä¸­å”¤é†’ï¼Œåˆ™ä¸€å®šä¼šæ‰§è¡Œå½“å‰å‡½æ•° *sudog.isSelect æ˜¯ trueï¼Œå¹¶ä¸”é€šè¿‡ CAS æŠŠ g.selectDone ä»0æ ‡è®°ä¸º1ã€‚ // 5. æ³¨æ„æ­¤æ—¶å”¤é†’çš„goroutineå¯èƒ½åœ¨å¤šä¸ªchannelä¸Šé¢ç­‰å¾…ã€‚æ­¤æ—¶å¯èƒ½ä¼šå‡ºç°åœ¨å…¶ä»–chanä¸Šè¿™ä¸ªgoroutineä¹Ÿè¢«é€‰ä¸­äº†ï¼Œä¹Ÿåœ¨æ‰§è¡Œå½“å‰å‡½æ•°ã€‚ // 6. åˆ™è¿™é‡Œä¼šç›´æ¥è·³è¿‡ã€‚å› ä¸ºå½“å‰goroutineå·²è¢«å”¤é†’ï¼Œåç»­ä¼šåœ¨å”¤é†’çš„goroutineç§»é™¤è¿™é‡Œgoroutineçš„goselectå‡½æ•°ä¸­ã€‚ // 7. goroutine å”¤é†’åä¼šè·å–æ‰€æœ‰çš„ channels lockï¼Œç„¶åæŠŠselectDoneè®¾ç½®ä¸º0ï¼Œæ­¤æ—¶å› ä¸ºæ‰€æœ‰çš„channel lockå·²è¢«æŒæœ‰æ‰€ä»¥èƒ½ç«‹å³ä¿®æ”¹selectDoneã€‚ // if a goroutine was put on this queue because of a // select, there is a small window between the goroutine // being woken up by a different case and it grabbing the // channel locks. Once it has the lock // it removes itself from the queue, so we won\u0026#39;t see it after that. // We use a flag in the G struct to tell us when someone // else has won the race to signal this goroutine but the goroutine // hasn\u0026#39;t removed itself from the queue yet. // // å¦‚æœä¸€ä¸ªgoroutineå› ä¸ºselectè¢«æ”¾åˆ°è¿™ä¸ªé˜Ÿåˆ—ä¸Šï¼Œé‚£ä¹ˆåœ¨goroutineè¢«ä¸åŒçš„æƒ…å†µå”¤é†’å’Œå®ƒè·å–é€šé“é”ä¹‹é—´æœ‰ä¸€ä¸ªå°çª—å£ã€‚ // ä¸€æ—¦å®ƒæœ‰äº†é”ï¼Œå®ƒå°±ä¼šä»é˜Ÿåˆ—ä¸­ç§»é™¤è‡ªå·±ï¼Œæ‰€ä»¥åœ¨é‚£ä¹‹åæˆ‘ä»¬å°±çœ‹ä¸åˆ°å®ƒäº†ã€‚ // æˆ‘ä»¬åœ¨Gç»“æ„ä½“ä¸­ä½¿ç”¨ä¸€ä¸ªæ ‡å¿—æ¥å‘Šè¯‰æˆ‘ä»¬ï¼Œå½“æœ‰å…¶ä»–äººèµ¢å¾—æ¯”èµ›æ—¶ï¼Œå‘è¿™ä¸ªgoroutineå‘å‡ºä¿¡å·ï¼Œä½†è¯¥goroutineè¿˜æ²¡æœ‰ä»é˜Ÿåˆ—ä¸­åˆ é™¤è‡ªå·±ã€‚ if sgp.isSelect \u0026amp;\u0026amp; !atomic.Cas(\u0026amp;sgp.g.selectDone, 0, 1) { continue } return sgp } } enqueue() ä» last æ”¾å…¥ *sudogã€‚ç›¸å½“äºä»é˜Ÿåˆ—å°¾ï¼ˆlastï¼‰æ·»åŠ å…ƒç´ ã€‚ è°ƒç”¨è¯¥æ–¹æ³•æ—¶ chan lock å·²è¢«æŒæœ‰ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 func (q *waitq) enqueue(sgp *sudog) { sgp.next = nil x := q.last if x == nil { // waitq æ˜¯ç©ºçš„ sgp.prev = nil q.first = sgp q.last = sgp return } sgp.prev = x x.next = sgp q.last = sgp } dequeueSudoG() åœ¨ selectgo() å‡½æ•°ä¸­è¢«ç”¨åˆ°ï¼Œç”¨äºå°†æŒ‡å®šçš„ *sudog å–å‡ºã€‚ å› ä¸º select ä¸èƒ½ç«‹å³å®Œæˆæ—¶ä¼šæŒ‚åœ¨æ‰€æœ‰çš„ channelï¼Œå½“æœ‰ channel å°±ç»ªåå…¶ä»– recvqã€sendq ä¸Šçš„éœ€è¦è°ƒç”¨è¿™ä¸ªå‡½æ•°å‰”é™¤æ‰ã€‚ è°ƒç”¨è¯¥å‡½æ•°æ˜¯ç›¸å…³çš„ channel lock å·²è¢«æŒæœ‰ã€‚ å‚æ•°ï¼šsgp *sudog æ˜¯é€šè¿‡ waitlink å­—æ®µç»„æˆçš„ *sudog é“¾è¡¨ã€‚ è¯¥å‡½æ•°ä¹Ÿæ˜¯åœ¨ go1.19.3/src/runtime/select.go æ–‡ä»¶ä¸­ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 func (q *waitq) dequeueSudoG(sgp *sudog) { // å½“å‰ sgp å¯èƒ½å¤„åœ¨é“¾è¡¨çš„ä»»ä½•ä½ç½®ï¼Œæˆ–è€…ä¸åœ¨é“¾è¡¨ä¸­ã€‚ x := sgp.prev y := sgp.next if x != nil { if y != nil { // middle of queue // // åœ¨ queue çš„ä¸­é—´ x.next = y y.prev = x sgp.next = nil sgp.prev = nil return } // end of queue // // åœ¨ queue çš„æœ€å x.next = nil q.last = x sgp.prev = nil return } if y != nil { // start of queue // // åœ¨queueå¼€å¤´ y.prev = nil q.first = y sgp.next = nil return } // x==y==nil. Either sgp is the only element in the queue, // or it has already been removed. Use q.first to disambiguate. // // x==y==nilã€‚ // è¦ä¹ˆ sgp æ˜¯é˜Ÿåˆ—ä¸­å”¯ä¸€çš„æˆå‘˜ï¼Œè¦ä¹ˆå®ƒå·²ç»è¢«åˆ é™¤ã€‚ä½¿ç”¨ q.first æ¥æ¶ˆé™¤æ­§ä¹‰ã€‚ if q.first == sgp { q.first = nil q.last = nil } } type sudog struct sudog è¡¨ç¤ºç­‰å¾…åˆ—è¡¨ä¸­çš„ gï¼Œä¾‹å¦‚ç”¨äºåœ¨ channel ä¸Š sending/receiving ã€‚ sudog æ˜¯å¿…è¦çš„ï¼Œå› ä¸º gâ†”synchronization å¯¹è±¡å…³ç³»æ˜¯å¤šå¯¹å¤šçš„ã€‚ ä¸€ä¸ª g å¯èƒ½ä¼šå‡ºç°åœ¨è®¸å¤šç­‰å¾…åˆ—è¡¨ä¸­ï¼Œæ‰€ä»¥ä¸€ä¸ªgå¯èƒ½ä¼šæœ‰è®¸å¤š sudog; å¹¶ä¸”è®¸å¤š g å¯èƒ½åœ¨åŒä¸€ä¸ª same å¯¹è±¡ä¸Šç­‰å¾…ï¼Œå› æ­¤ä¸€ä¸ªå¯¹è±¡å¯èƒ½æœ‰è®¸å¤š sudogã€‚ sudog æ˜¯ä»ä¸€ä¸ªç‰¹æ®Šçš„æ± ä¸­åˆ†é…çš„ã€‚ä½¿ç”¨ acquireSudog å’Œ releaseSudog æ¥åˆ†é…å’Œé‡Šæ”¾å®ƒä»¬ã€‚ æ–‡ä»¶ä½ç½®ï¼šgo1.19.3/src/runtime2.goã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 // sudog represents a g in a wait list, such as for sending/receiving // on a channel. // // sudog is necessary because the g â†” synchronization object relation // is many-to-many. A g can be on many wait lists, so there may be // many sudogs for one g; and many gs may be waiting on the same // synchronization object, so there may be many sudogs for one object. // // sudogs are allocated from a special pool. Use acquireSudog and // releaseSudog to allocate and free them. type sudog struct { // The following fields are protected by the hchan.lock of the // channel this sudog is blocking on. shrinkstack depends on // this for sudogs involved in channel ops. g *g // ç­‰å¾…çš„goroutine next *sudog // é“¾æ¥ä¸‹ä¸€ä¸ª*sudog å¯¹äºäºŒå‰æ ‘å°±æ˜¯left prev *sudog // é“¾æ¥å‰ä¸€ä¸ª*sudog å¯¹äºäºŒå‰æ ‘å°±æ˜¯right // seampherä¸­ï¼šä¿å­˜æ¥è‡ªä¿¡å·é‡çš„åœ°å€ï¼›æ¯”å¦‚åœ¨sync.Mutexä¸­åˆ™æ˜¯\u0026amp;sync.Mutex.semaè¯¥å­—æ®µçš„åœ°å€ã€‚ // channelsä¸­ï¼šåˆ™æ˜¯ä¿å­˜éœ€è¦ä¼ é€’çš„å€¼çš„åœ°å€ã€‚ï¼ˆéœ€è¦äº¤æ¢çš„æ•°æ®åœ°å€ï¼‰ elem unsafe.Pointer // data element (may point to stack) // The following fields are never accessed concurrently. // For channels, waitlink is only accessed by g. // For semaphores, all fields (including the ones above) // are only accessed when holding a semaRoot lock. // // ä»¥ä¸‹å­—æ®µæ°¸è¿œä¸ä¼šå¹¶å‘è®¿é—®ã€‚ // å¯¹äº channelsï¼Œwaitlink åªèƒ½ç”± g è®¿é—®ã€‚ // å¯¹äº semaphoresï¼Œæ‰€æœ‰å­—æ®µ(åŒ…æ‹¬ä¸Šé¢çš„å­—æ®µ)åªæœ‰åœ¨æŒæœ‰ semaRoot é”æ—¶æ‰èƒ½è®¿é—®ã€‚ // ä»¥ä¸‹æ—¶é—´éƒ½æ˜¯ä¸ºäº†åˆ†æ sudog acquiretime int64 // è·å¾— sudog çš„æ—¶é—´ releasetime int64 // é‡Šæ”¾æ—¶é—´\t// ticket ç”¨äºå½¢æˆæœ€å°å †ï¼Œä»rootå¾€ä¸‹æŒ‰ç…§ s.ticket \u0026lt;= both s.prev.ticket AND s.next.ticket; æœ€å°å †å°±æ˜¯ä¸€ç§å®Œå…¨äºŒå‰æ ‘ // 1. ticket åœ¨ semaRoot.queue å‡½æ•°ä¸­ä½œä¸ºäºŒå‰æ ‘æå¹²æƒ…å†µä¸‹è¢«åˆå§‹åŒ–ä¸º s.ticket = fastrand() | 1; s.ticket \u0026gt;= 0 // 2. ticket åœ¨ semaRoot.dequeue å‡½æ•°ä¸­è¿”å› sudog æ—¶ï¼Œè¢«é‡ç½®ä¸º0 // 3. ticket åœ¨ sync_runtime_SemacquireMutex å‡½æ•°ä¸­ å¦‚æœæ˜¯é¥¥é¥¿æ¨¡å¼åˆ™æ ‡è®°ä¸º1 // æœ€å°å †ç™¾åº¦ç™¾ç§‘ï¼šhttps://baike.baidu.com/item/%E6%9C%80%E5%B0%8F%E5%A0%86/9139372 ticket uint32 // isSelect indicates g is participating in a select, so // g.selectDone must be CAS\u0026#39;d to win the wake-up race. // // isSelect è¡¨ç¤º g æ­£åœ¨å‚ä¸ä¸€ä¸ª selectï¼Œå› æ­¤ g.selectDone å¿…é¡»ç»è¿‡ CAS å¤„ç†æ‰èƒ½èµ¢å¾—å”¤é†’ç«èµ›ã€‚ // å…·ä½“å‚è€ƒ goselect() å‡½æ•°ã€‚å½“å‰æ˜¯å› ä¸º select è¯­å¥è¢«æŒ‚èµ·æ—¶ï¼Œè¯¥å­—æ®µä¼šè¢«è®¾ç½®ä¸º trueã€‚ isSelect bool // åœ¨selectç»“æ„ä¸­è¢«ä½¿ç”¨ // success indicates whether communication over channel c // succeeded. It is true if the goroutine was awoken because a // value was delivered over channel c, and false if awoken // because c was closed. // // success c é€šé“é€šä¿¡æ˜¯å¦æˆåŠŸã€‚ // å¦‚æœ goroutine å› ä¸ºé€šè¿‡é€šé“ c ä¼ é€’å€¼è€Œè¢«å”¤é†’ï¼Œåˆ™ä¸º trueï¼Œå¦‚æœå› ä¸ºé€šé“ c è¢«å…³é—­è€Œè¢«å”¤é†’ï¼Œåˆ™ä¸º falseã€‚ success bool // åœ¨chanä¸­è¢«ä½¿ç”¨ï¼Œç”¨äºåˆ¤æ–­æœ¬æ¬¡é€šä¿¡æ˜¯å¦æˆåŠŸ // semaRootçš„äºŒå‰æ ‘ parent *sudog // semaRoot binary tree // g.waiting åˆ—è¡¨æˆ– semaRoot çš„ç­‰å¾…é“¾è¡¨ï¼ŒæŒ‡å‘é“¾è¡¨çš„å¤´ã€‚ // åœ¨ goselect() å‡½æ•°ä¸­ï¼ŒæŒ‚èµ·çš„ goroutine ç»„è£…çš„ *sudog é€šè¿‡ waitlink å­—æ®µå½¢æˆé“¾è¡¨ã€‚ // waitlink åªåœ¨ semapher æˆ– select è¯­å¥ä¸­è¢«ç”¨æ¥å½¢æˆé“¾è¡¨ã€‚ waitlink *sudog // g.waiting list or semaRoot // ç­‰å¾…å°¾éƒ¨ semaRootï¼ŒæŒ‡å‘é“¾è¡¨çš„å°¾éƒ¨ waittail *sudog // semaRoot // å½“å‰sudogæ‰€å±*hchanï¼Œselectä¸èƒ½å°±ç»ªè¦è¢«æŒ‚èµ·æ—¶ç”¨åˆ°ã€‚ c *hchan // channel } make() åˆå§‹åŒ– channelã€‚\nmakechan() å‡½æ•°åŸå‹ï¼šmake(chan Type, size int) å‚æ•°ï¼š t *chantypeï¼šchan å…ƒç±»å‹ç»“æ„ã€‚ size intï¼šchan å¤§å°ï¼Œé»˜è®¤0æ— ç¼“å†² chanï¼›\u0026gt;=1 éƒ½æ˜¯æœ‰ç¼“å†² chanã€‚ type chantype struct { typ _type // chanå…ƒç±»å‹ elem *_type // chan å…ƒç´ å…ƒç±»å‹ dir uintptr // é€šé“æ–¹å‘ } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 func makechan(t *chantype, size int) *hchan { elem := t.elem // chanå…ƒç´ å…ƒç±»å‹ // compiler checks this but be safe. // // ç¼–è¯‘å™¨ä¼šæ£€æŸ¥è¿™ä¸€ç‚¹ï¼Œä½†è¿™æ˜¯å®‰å…¨çš„ã€‚ if elem.size \u0026gt;= 1\u0026lt;\u0026lt;16 { // chanå…ƒç´ ç±»å‹å†…å­˜ \u0026gt;= 1\u0026lt;\u0026lt;16æ—¶ä¸é€‚åˆchan throw(\u0026#34;makechan: invalid channel element type\u0026#34;) } // hchan æ˜¯å¦å¯¹é½ maxAlign if hchanSize%maxAlign != 0 || elem.align \u0026gt; maxAlign { throw(\u0026#34;makechan: bad alignment\u0026#34;) } // mem = elem.size * uintptr(size) mem, overflow := math.MulUintptr(elem.size, uintptr(size)) if overflow || mem \u0026gt; maxAlloc-hchanSize || size \u0026lt; 0 { // å†…å­˜æº¢å‡º panic(plainError(\u0026#34;makechan: size out of range\u0026#34;)) } // Hchan does not contain pointers interesting for GC when elements stored in buf do not contain pointers. // buf points into the same allocation, elemtype is persistent. // SudoG\u0026#39;s are referenced from their owning thread so they can\u0026#39;t be collected. // TODO(dvyukov,rlh): Rethink when collector can move allocated objects. // // å½“å­˜å‚¨åœ¨bufä¸­çš„å…ƒç´ ä¸åŒ…å«æŒ‡é’ˆæ—¶ï¼Œhchanä¸åŒ…å«GCæ„Ÿå…´è¶£çš„æŒ‡é’ˆã€‚ // (å› æ­¤å¯ç›´æ¥åœ¨æ— æŒ‡é’ˆå†…å­˜å—åˆ†é…)ã€‚bufæŒ‡å‘ç›¸åŒçš„å†…å­˜åˆ†é…ï¼Œelemtypeæ˜¯æŒä¹…çš„ã€‚ // Sudog æ˜¯åœ¨å®ƒä»¬è‡ªå·±çš„çº¿ç¨‹ä¸­å¼•ç”¨çš„ï¼Œæ‰€ä»¥å®ƒä»¬æ— æ³•è¢«æ”¶é›†ã€‚ // TODO(dvyukov,rlh):é‡æ–°è€ƒè™‘æ”¶é›†å™¨ä½•æ—¶å¯ä»¥ç§»åŠ¨å·²åˆ†é…çš„å¯¹è±¡ã€‚ var c *hchan // nil switch { // ã€make(chan struct{}, n)ã€‘ OR ã€make(chan int, 0)ã€‘ å½¢å¼ case mem == 0: // channel å†…å­˜ä¸ºé›¶ // Queue or element size is zero. // // Queue æˆ– element çš„å¤§å°ä¸º0ã€‚ // æ³¨æ„è¿™é‡Œç”³è¯·çš„å†…å­˜è§„æ ¼å—æ˜¯æ— æŒ‡é’ˆçš„ï¼Œå…·ä½“åŸå› å‰é¢æ³¨é‡Šæœ‰è§£é‡Š c = (*hchan)(mallocgc(hchanSize, nil, true)) // ç”³è¯·hchanéœ€è¦çš„å†…å­˜ç©ºé—´ // Race detector uses this location for synchronization. // // ç«æ€æ£€æµ‹å™¨ä½¿ç”¨æ­¤ä½ç½®è¿›è¡ŒåŒæ­¥ã€‚ c.buf = c.raceaddr() // c.buf = \u0026amp;c.buf case elem.ptrdata == 0: // channel å†…å­˜ä¸ä¸ºé›¶ï¼Œå…ƒç´ ä¸åŒ…å«æŒ‡é’ˆ // Elements do not contain pointers. // Allocate hchan and buf in one call. // // å…ƒç´ ä¸åŒ…å«æŒ‡é’ˆã€‚ä¸€æ¬¡è°ƒç”¨å³å¯åˆ†é… hchan å’Œ bufã€‚ // hchanSize ä¸»è¦æ˜¯ä¸ºäº†è¿™é‡Œçš„å¯¹é½ã€‚æ³¨æ„è¿™é‡Œç”³è¯·çš„å†…å­˜è§„æ ¼å—æ˜¯æ— æŒ‡é’ˆçš„ï¼Œå…·ä½“åŸå› å‰é¢æ³¨é‡Šæœ‰è§£é‡Š c = (*hchan)(mallocgc(hchanSize+mem, nil, true)) // ç”³è¯·ã€hchan + bufã€‘éœ€è¦å†…å­˜å— c.buf = add(unsafe.Pointer(c), hchanSize) // å¯è§ç”³è¯·çš„æ˜¯ä¸€æ•´å—å†…å­˜ç©ºé—´ default: // channel å†…å­˜ä¸ä¸ºé›¶ï¼Œå…ƒç´ åŒ…å«æŒ‡é’ˆ // Elements contain pointers. // // å…ƒç´ åŒ…å«æŒ‡é’ˆã€‚ c = new(hchan) // ç”³è¯·å…ƒç´ éœ€è¦çš„å†…å­˜å— // æ³¨æ„è¿™é‡Œç”³è¯·çš„æ˜¯æœ‰æŒ‡é’ˆå†…å­˜è§„æ ¼å—ï¼Œå…·ä½“åŸå› æ˜¯chanå…ƒç´ ç±»å‹æœ‰æŒ‡é’ˆå¯èƒ½å­˜åœ¨å¤šçº§æŒ‡é’ˆå¼•ç”¨ï¼Œéœ€è¦GCå¸®åŠ© c.buf = mallocgc(mem, elem, true) } c.elemsize = uint16(elem.size) // chan å…ƒç´ å¤§å° c.elemtype = elem // chanå…ƒç´ å…ƒç±»å‹ c.dataqsiz = uint(size) // æœ‰ç¼“å­˜å®¹é‡ï¼Œä¸€æ—¦åˆå§‹åŒ–å°±æ˜¯ç¡®å®šçš„å€¼ // åˆå§‹åŒ– runtime.mutexï¼Œä¸»è¦æ˜¯åˆå§‹åŒ–é”æ’å lockInit(\u0026amp;c.lock, lockRankHchan)\tif debugChan { print(\u0026#34;makechan: chan=\u0026#34;, c, \u0026#34;; elemsize=\u0026#34;, elem.size, \u0026#34;; dataqsiz=\u0026#34;, size, \u0026#34;\\n\u0026#34;) } return c } makechan64() 1 2 3 4 5 6 7 func makechan64(t *chantype, size int64) *hchan { if int64(int(size)) != size { // å¦‚æœåœ¨32ä½ç³»ç»Ÿä¸‹è¿™é‡Œä¼šæŠ¥é”™ panic(plainError(\u0026#34;makechan: size out of range\u0026#34;)) } return makechan(t, int(size)) } c \u0026lt;- ep ep å‘é€åˆ° c ä¸­ã€‚\nchansend1() ç¼–è¯‘åä»£ç ä¸­ c \u0026lt;- x çš„å…¥å£ç‚¹ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 // // c \u0026lt;- ep // // as // // chansend1(c, \u0026amp;ep) // // entry point for c \u0026lt;- x from compiled code // //go:nosplit func chansend1(c *hchan, elem unsafe.Pointer) { chansend(c, elem, true, getcallerpc()) } chansend() é€šç”¨å•é€šé“ send/recvï¼Œå¦‚æœ block ä¸æ˜¯ nilï¼Œé‚£ä¹ˆåè®®å°†ä¸ä¼šè¿›å…¥ç¡çœ çŠ¶æ€ï¼Œå¦‚æœæ— æ³•å®Œæˆåˆ™è¿”å›ã€‚ å½“æ¶‰åŠ sleep çš„é€šé“è¢«å…³é—­æ—¶ï¼Œsleep å¯ä»¥ä½¿ç”¨ g.param == nil å”¤é†’ã€‚å¾ªç¯å¹¶é‡æ–°è¿è¡Œæ“ä½œæ˜¯æœ€ç®€å•çš„;æˆ‘ä»¬ä¼šçœ‹åˆ°å®ƒç°åœ¨å·²ç»å…³é—­äº†ã€‚ å‚æ•°ï¼š c *hchanï¼šhchan ç»“æ„ä½“çš„æŒ‡é’ˆã€‚æŒ‡å‘è¦æ¥ç”¨ send æ•°æ®çš„ channelã€‚ ep unsafe.Pointerï¼šep æ˜¯ c \u0026lt;- ep éœ€è¦å‘é€åˆ° chan çš„æ•°æ®åœ°å€ã€‚ æ˜¯ä¸€ä¸ªæŒ‡é’ˆï¼ŒæŒ‡å‘è¦è¢«é€å…¥é€šé“ c çš„æ•°æ®ï¼Œæ•°æ®ç±»å‹è¦å’Œ c çš„å…ƒç´ ç±»å‹ä¸€è‡´ã€‚ block boolï¼šfalse.ä¸èƒ½ç«‹å³å®Œæˆæ—¶ä¸é˜»å¡ã€‚ true.ä¸èƒ½ç«‹å³å®Œæˆæ—¶é˜»å¡ã€‚ è¡¨ç¤ºå¦‚æœ send æ“ä½œä¸èƒ½ç«‹å³å®Œæˆï¼Œæ˜¯å¦æƒ³è¦é˜»å¡ç­‰å¾…ã€‚ block bool å‚æ•° false çŠ¶æ€ç”¨äº select{case: default:} å½¢å¼ä¸­ã€‚true çŠ¶æ€ç”¨äº c \u0026lt;- ep æƒ…å†µä¸‹ã€‚ callerpc uintptrï¼šæ˜¯ c \u0026lt;- ep çš„ä¸‹ä¸€æ¡ä»£ç æŒ‡ä»¤åœ°å€ã€‚ç”¨äºè¿›è¡Œraceç›¸å…³æ£€æµ‹ã€‚ è¿”å›å€¼ï¼š boolï¼štrue.æ•°æ® send å®Œæˆã€‚false.è¡¨ç¤ºç›®å‰ä¸èƒ½å‘é€ï¼Œä½†å› ä¸ºä¸æƒ³é˜»å¡(blockä¸ºfalse)è€Œè¿”å›ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 /* * generic single channel send/recv * If block is not nil, * then the protocol will not * sleep but return if it could * not complete. * * sleep can wake up with g.param == nil * when a channel involved in the sleep has * been closed. it is easiest to loop and re-run * the operation; we\u0026#39;ll see that it\u0026#39;s now closed. */ func chansend(c *hchan, ep unsafe.Pointer, block bool, callerpc uintptr) bool { // 1) chanæ²¡æœ‰åˆå§‹åŒ–ï¼Œæ¯”å¦‚ var c chan intå½¢å¼ if c == nil { if !block { // select{case: default:} å— return false // è¿”å›falseï¼Œè¡¨ç¤ºæœªå‘é€æ•°æ®ã€‚ } // nil \u0026lt;- xï¼šå¦‚æœblockä¸ºtrueï¼Œå°±è®©å½“å‰åç¨‹æ°¸ä¹…åœ°é˜»å¡åœ¨è¿™ä¸ªnilé€šé“ä¸Šã€‚ // å¤„ç†ç›¸å…³goroutineç„¶åå†æ¬¡è¿›è¡Œæ–°ä¸€è½®è°ƒåº¦ã€‚ // æ³¨æ„ï¼šè¿™é‡Œçš„goroutineå°†æ°¸ä¹…ä¸¢å¤±ï¼Œå› ä¸ºè¿™ä¸ªgoroutineæ²¡æœ‰è¢«æ”¾å…¥é˜Ÿåˆ—ä¸­ç­‰å¾…è¢«è°ƒåº¦ï¼Œ // è¿˜æœ‰å°±æ˜¯c \u0026lt;- xè¿™è¡Œä»£ç åçš„æ‰€æœ‰ä»£ç éƒ½ä¸ä¼šåœ¨è¢«æ‰§è¡Œã€‚ gopark(nil, nil, waitReasonChanSendNilChan, traceEvGoStop, 2) throw(\u0026#34;unreachable\u0026#34;) } if debugChan { // debug print(\u0026#34;chansend: chan=\u0026#34;, c, \u0026#34;\\n\u0026#34;) } if raceenabled { racereadpc(c.raceaddr(), callerpc, abi.FuncPCABIInternal(chansend)) } // Fast path: check for failed non-blocking operation without acquiring the lock. // // After observing that the channel is not closed, we observe that the channel is // not ready for sending. Each of these observations is a single word-sized read // (first c.closed and second full()). // Because a closed channel cannot transition from \u0026#39;ready for sending\u0026#39; to // \u0026#39;not ready for sending\u0026#39;, even if the channel is closed between the two observations, // they imply a moment between the two when the channel was both not yet closed // and not ready for sending. We behave as if we observed the channel at that moment, // and report that the send cannot proceed. // // It is okay if the reads are reordered here: if we observe that the channel is not // ready for sending and then observe that it is not closed, that implies that the // channel wasn\u0026#39;t closed during the first observation. However, nothing here // guarantees forward progress. We rely on the side effects of lock release in // chanrecv() and closechan() to update this thread\u0026#39;s view of c.closed and full(). // // Fast path: åœ¨æœªè·å¾—é”çš„æƒ…å†µä¸‹æ£€æŸ¥å¤±è´¥çš„éé˜»å¡æ“ä½œã€‚ // åœ¨è§‚å¯Ÿåˆ°é€šé“æ²¡æœ‰å…³é—­ä¹‹åï¼Œæˆ‘ä»¬è§‚å¯Ÿåˆ°é€šé“è¿˜æ²¡æœ‰å‡†å¤‡å¥½å‘é€ã€‚æ¯ä¸ªè§‚å¯Ÿå€¼éƒ½æ˜¯å•ä¸ªword-sizedçš„è¯»å–(ç¬¬ä¸€ä¸ªæ˜¯c.closedï¼Œç¬¬äºŒä¸ªæ˜¯full())ã€‚ // å› ä¸ºä¸€ä¸ªå°é—­çš„é€šé“ä¸èƒ½ä»\u0026#39;ready for sending\u0026#39;è¿‡æ¸¡åˆ°\u0026#39;not ready for sending\u0026#39;ï¼Œå³ä½¿åœ¨ä¸¤æ¬¡è§‚æµ‹ä¹‹é—´é€šé“æ˜¯å…³é—­çš„ï¼Œ // å®ƒä»¬ä¹Ÿæ„å‘³ç€åœ¨ä¸¤æ¬¡è§‚æµ‹ä¹‹é—´é€šé“æ—¢æ²¡æœ‰å…³é—­ä¹Ÿæ²¡æœ‰å‡†å¤‡å¥½å‘é€çš„æ—¶åˆ»ã€‚ // æˆ‘ä»¬çš„è¡Œä¸ºå°±åƒæˆ‘ä»¬å½“æ—¶è§‚å¯Ÿåˆ°é€šé“ä¸€æ ·ï¼Œå¹¶æŠ¥å‘Šå‘é€æ— æ³•ç»§ç»­ã€‚ // åœ¨è¿™é‡Œï¼Œå¦‚æœè¯»æ“ä½œè¢«é‡æ–°æ’åºæ˜¯å¯ä»¥çš„:å¦‚æœæˆ‘ä»¬è§‚å¯Ÿåˆ°é€šé“è¿˜æ²¡æœ‰å‡†å¤‡å¥½å‘é€ï¼Œç„¶ååˆè§‚å¯Ÿåˆ°å®ƒæ²¡æœ‰å…³é—­ï¼Œè¿™æ„å‘³ç€åœ¨ç¬¬ä¸€æ¬¡è§‚å¯ŸæœŸé—´é€šé“æ²¡æœ‰å…³é—­ã€‚ // ç„¶è€Œï¼Œè¿™é‡Œæ²¡æœ‰ä»»ä½•ä¸œè¥¿èƒ½ä¿è¯å–å¾—è¿›å±•ã€‚æˆ‘ä»¬ä¾èµ–chanrecv()å’Œclosechan()ä¸­é”é‡Šæ”¾çš„å‰¯ä½œç”¨æ¥æ›´æ–°è¿™ä¸ªçº¿ç¨‹çš„c.closedå’Œfull()è§†å›¾ã€‚ if !block \u0026amp;\u0026amp; c.closed == 0 \u0026amp;\u0026amp; full(c) { // selectå—ä¸­ \u0026amp;\u0026amp; chanæœªå…³é—­ \u0026amp;\u0026amp; cå·²æ»¡ // å¦‚æœblockä¸ºfalseä¸”closedä¸º0ï¼Œä¹Ÿå°±æ˜¯åœ¨ä¸æƒ³é˜»å¡ä¸”é€šé“æœªå…³é—­çš„å‰æä¸‹ï¼Œå¦‚æœé€šé“æ»¡äº†ï¼ˆæ— ç¼“å†²ä¸”recvqä¸ºç©ºï¼Œæˆ–è€…æœ‰ç¼“å­˜ä¸”ç¼“å†²å·²ç”¨å°½ï¼‰ï¼Œ // åˆ™ç›´æ¥è¿”å›falseã€‚ // æœ¬æ­¥åˆ¤æ–­æ˜¯åœ¨ä¸åŠ é”çš„æƒ…å†µä¸‹è¿›è¡Œçš„ï¼Œç›®çš„æ˜¯è®©éé˜»å¡sendåœ¨æ— æ³•ç«‹å³å®Œæˆæ—¶èƒ½çœŸæ­£ä¸é˜»å¡ï¼ˆåŠ é”æ“ä½œå¯èƒ½é˜»å¡ï¼‰ã€‚ return false } var t0 int64 if blockprofilerate \u0026gt; 0 { t0 = cputicks() } // 2) å°è¯•è·å– runtime.mutex äº’æ–¥é” // å¯¹hchanåŠ é”ï¼Œå¦‚æœclosedä¸ä¸º0ï¼Œå³é€šé“å·²ç»å…³é—­ï¼Œåˆ™å…ˆè§£é”ï¼Œç„¶åpanicã€‚å› ä¸ºä¸å…è®¸ç”¨å·²å…³é—­çš„é€šé“è¿›è¡Œsendã€‚ lock(\u0026amp;c.lock) // 3) å‘å·²å…³é—­çš„chan å‘é€æ•°æ®ç›´æ¥panic // è¿™é‡Œå­˜åœ¨è·å–runtime.mutexæœŸé—´å…¶ä»–åç¨‹å·²ç»æŠŠcå…³é—­çš„æƒ…å†µï¼Œè¿™é‡Œä¼šç›´æ¥panic // å› æ­¤chançš„å…³é—­æ˜¯è¦ç¡®ä¿æ‰€æœ‰çš„sendæ“ä½œå·²å®Œæˆåå†è¿›è¡Œ if c.closed != 0 { unlock(\u0026amp;c.lock) panic(plainError(\u0026#34;send on closed channel\u0026#34;)) } // 4) ä» recvq ä¸­å»æ‰¾å‡ºä¸€ä¸ªæ­£åœ¨ç­‰å¾…çš„ *sudog // å¦‚æœ recvq ä¸ä¸ºç©ºï¼Œéšå«äº†ç¼“å†²åŒºä¸ºç©ºï¼Œå°±ä»ä¸­å–å‡ºç¬¬1ä¸ªæ’é˜Ÿçš„åç¨‹ï¼Œå°†æ•°æ®ä¼ ç»™è¿™ä¸ªåç¨‹ï¼Œå¹¶å°†è¯¥åç¨‹ç½®ä¸ºreadyçŠ¶æ€ //ï¼ˆæ”¾å…¥run queueï¼Œè¿›è€Œå¾—åˆ°è°ƒåº¦ï¼‰ï¼Œç„¶åè§£é”ï¼Œç„¶åè¿”å›trueã€‚ if sg := c.recvq.dequeue(); sg != nil { // å­˜åœ¨ç­‰å¾…çš„ goroutine ç›´æ¥äº¤æ¢æ•°æ®å³å¯ // Found a waiting receiver. We pass the value we want to send // directly to the receiver, bypassing the channel buffer (if any). // // æ‰¾åˆ°äº†ä¸€ä¸ªç­‰å¾…çš„æ¥æ”¶å™¨ã€‚æˆ‘ä»¬å°†æƒ³è¦ç›´æ¥å‘é€çš„å€¼ä¼ é€’ç»™æ¥æ”¶å™¨ï¼Œç»•è¿‡é€šé“ç¼“å†²åŒº(å¦‚æœæœ‰çš„è¯)ã€‚ send(c, sg, ep, func() { unlock(\u0026amp;c.lock) }, 3) return true } // 5) ç¼“å†²åŒºè¿˜æœ‰ç©ºé—´ï¼Œç›´æ¥æŠŠæ•°æ®æ”¾å…¥å³å¯ // é€šè¿‡æ¯”è¾ƒ qcount å’Œ dataqsiz åˆ¤æ–­ç¼“å­˜åŒºæ˜¯å¦è¿˜æœ‰å‰©ä½™ç©ºé—´ï¼Œåœ¨è¿™é‡Œæ— ç¼“å†²çš„é€šé“è¢«è§†ä¸ºæ²¡æœ‰å‰©ä½™ç©ºé—´ã€‚ // å¦‚æœæœ‰å‰©ä½™ç©ºé—´ï¼Œå°†æ•°æ®è¿½åŠ åˆ°ç¼“å†²åŒºä¸­ï¼Œç›¸åº”åœ°ç§»åŠ¨ sendxï¼Œå¢åŠ  qcountï¼Œç„¶åè§£é”ï¼Œè¿”å›å€¼ä¸º trueã€‚ if c.qcount \u0026lt; c.dataqsiz { // Space is available in the channel buffer. Enqueue the element to send. // // é€šé“ç¼“å†²åŒºä¸­æœ‰å¯ç”¨ç©ºé—´ã€‚å¯¹è¦å‘é€çš„å…ƒç´ è¿›è¡Œæ’é˜Ÿã€‚ qp := chanbuf(c, c.sendx) // ä¸‹ä¸€ä¸ªç©ºé—²æ’æ§½åœ°å€ if raceenabled { racenotify(c, c.sendx, nil) } // æŠŠc \u0026lt;- epè¿™é‡Œçš„epå€¼å¤åˆ¶åˆ°qpè¿™ä¸ªåœ°å€ä¸­ï¼Œå®ç°æŠŠepæ”¾å…¥bufä¸­ typedmemmove(c.elemtype, qp, ep) // å¦‚æœå…ƒç´ å¤§å°ä¸º0ä¸ä¼šæœ‰ä»»ä½•æ“ä½œ c.sendx++ // ä¸‹ä¸€æ¬¡ç©ºé—²ä½ç½® if c.sendx == c.dataqsiz { // åˆ°è¾¾æœ€å¤§ç´¢å¼• c.sendx = 0 } c.qcount++ // å·²å­˜å‚¨çš„æ•°é‡åŠ ä¸€ unlock(\u0026amp;c.lock) return true } // 6) å¦‚æœä¸Šé¢4å’Œ5éƒ½ä¸æ»¡è¶³ï¼Œå¹¶ä¸”æ˜¯åœ¨selectä¸­ï¼Œé‚£ä¹ˆå°±ç›´æ¥è¿”å›falseï¼Œè¡¨ç¤ºå½“å‰åˆ†æ”¯ä¸ä¼šé€‰ä¸­ // è¿è¡Œåˆ°è¿™é‡Œè¡¨æ˜é€šé“å·²æ»¡ï¼Œå¦‚æœblockä¸ºfalseï¼Œå³ä¸æƒ³é˜»å¡ï¼Œåˆ™è§£é”ï¼Œè¿”å›å€¼ä¸ºfalseã€‚ if !block { unlock(\u0026amp;c.lock) return false } // 7) ä¸‹é¢æ˜¯ c \u0026lt;- x å†™æ“ä½œéœ€è¦é˜»å¡çš„æƒ…å†µ // Block on the channel. Some receiver will complete our operation for us. // // åœ¨é€šé“ä¸Šé˜»å¡ã€‚æœ‰äººä¼šæ›¿æˆ‘ä»¬å®Œæˆæˆ‘ä»¬çš„æ“ä½œã€‚ gp := getg() // goroutine // è·å–ä¸€ä¸ªç©ºé—²çš„ *sudog mysg := acquireSudog()\tmysg.releasetime = 0 if t0 != 0 { mysg.releasetime = -1 } // No stack splits between assigning elem and enqueuing mysg // on gp.waiting where copystack can find it. // // åœ¨åˆ†é…elemå’Œåœ¨gpä¸Šæ’é˜Ÿmysgä¹‹é—´æ²¡æœ‰å †æ ˆåˆ†è£‚ã€‚åœ¨æ‹·è´å †èƒ½æ‰¾åˆ°çš„åœ°æ–¹ç­‰å¾…ã€‚ mysg.elem = ep // waitlink åªåœ¨ semapher æˆ– select è¯­å¥ä¸­è¢«ä½¿ç”¨åˆ°ã€‚ // ç”¨æ¥é“¾æ¥å¤šä¸ª sudog mysg.waitlink = nil mysg.g = gp // æ ‡è®°å½“å‰ sudog ä¸æ˜¯æ¥è‡ªselectè¯­å¥ mysg.isSelect = false mysg.c = c // æ ‡è®°goroutineæ­£åœ¨*sudogè¿™ä¸­ç­‰å¾…ï¼ˆä¸€ä¸ªæœ‰æ•ˆçš„elem ptrï¼‰; in lock order gp.waiting = mysg gp.param = nil // æ”¾å…¥ sendq queue ä¸­ç­‰å¾… c.sendq.enqueue(mysg)\t// Signal to anyone trying to shrink our stack that we\u0026#39;re about // to park on a channel. The window between when this G\u0026#39;s status // changes and when we set gp.activeStackChans is not safe for // stack shrinking. // // å‘ä»»ä½•è¯•å›¾ç¼©å°å †æ ˆçš„äººå‘å‡ºä¿¡å·ï¼Œæˆ‘ä»¬å³å°†åœåœ¨ä¸€ä¸ªchannelä¸Šã€‚ // å½“Gçš„çŠ¶æ€æ”¹å˜å’Œæˆ‘ä»¬è®¾ç½®gpä¹‹é—´çš„çª—å£ã€‚activeStackChans å¯¹å †æ ˆæ”¶ç¼©ä¸å®‰å…¨ã€‚ // goroutine.parkingOnChanè¡¨ç¤ºè¯¥goroutineå³å°†åœåœ¨ä¸€ä¸ªchansendæˆ–chanrecvä¸Šã€‚ // ç”¨äºæŒ‡ç¤ºå †æ ˆæ”¶ç¼©çš„ä¸å®‰å…¨ç‚¹ã€‚å®ƒæ˜¯ä¸€ä¸ªå¸ƒå°”å€¼ï¼Œä½†ä¼šè‡ªåŠ¨æ›´æ–°ã€‚ atomic.Store8(\u0026amp;gp.parkingOnChan, 1) // è¡¨ç¤ºè¿™æ®µæ—¶é—´chanæ­£åœ¨parkingä¸­ // goparkâ€”\u0026gt;mcall-\u0026gt;park_m-\u0026gt;schedule() gopark(chanparkcommit, unsafe.Pointer(\u0026amp;c.lock), waitReasonChanSend, traceEvGoBlockSend, 2)\t// è°ƒç¦»å½“å‰gè¿›å…¥è°ƒåº¦å¾ªç¯ // å½“å‰gè¢«å†æ¬¡è°ƒåº¦èµ·æ¥æ—¶ï¼Œç»§ç»­è¿™é‡Œæ‰§è¡Œ // Ensure the value being sent is kept alive until the // receiver copies it out. The sudog has a pointer to the // stack object, but sudogs aren\u0026#39;t considered as roots of the // stack tracer. // // ç¡®ä¿æ­£åœ¨å‘é€çš„å€¼åœ¨æ¥æ”¶æ–¹å¤åˆ¶å‡ºæ¥ä¹‹å‰éƒ½æ˜¯æœ‰æ•ˆçš„ã€‚ // sudogæœ‰ä¸€ä¸ªæŒ‡å‘æ ˆå¯¹è±¡çš„æŒ‡é’ˆï¼Œä½†sudogsä¸è¢«è®¤ä¸ºæ˜¯æ ˆè·Ÿè¸ªå™¨çš„rootsã€‚ // https://zhuanlan.zhihu.com/p/213744309 KeepAlive(ep) // ä¿æŒepæ˜¯æ´»è·ƒçš„ï¼Œå› ä¸ºepæ¥è‡ªç”¨æˆ·ç«¯å¯èƒ½epä¼šè¢«å›æ”¶ // someone woke us up. // // æœ‰äººæŠŠæˆ‘ä»¬å«é†’äº†ï¼Œå¯èƒ½æ˜¯æ­£å¸¸ \u0026lt;-c æˆ–è€… close() å‡½æ•° if mysg != gp.waiting {\t// å½“å‰ gp æ˜¯å¦ç­‰å¾…åœ¨ mysq ä¸Š throw(\u0026#34;G waiting list is corrupted\u0026#34;) } gp.waiting = nil // activeStackChansè¡¨ç¤ºæœ‰æœªé”å®šçš„é€šé“æŒ‡å‘è¿™ä¸ªgoroutineçš„å †æ ˆã€‚ // å¦‚æœä¸ºtrueï¼Œå †æ ˆå¤åˆ¶éœ€è¦è·å¾—é€šé“é”æ¥ä¿æŠ¤å †æ ˆçš„è¿™äº›åŒºåŸŸã€‚ // activeStackChans å­—æ®µåœ¨ gopark ä¸­ chanparkcommit å‡½æ•°ä¸­è¢«è®¾ç½®ä¸ºtrueï¼Œå› æ­¤æ˜¯goè¢«è°ƒç¦»CPUæ—¶å€™è®¾ç½®ä¸ºtrueï¼Œåœ¨å”¤é†’åè®¾ç½®ä¸ºfalseã€‚ // å…·ä½“å‚çœ‹æ ˆ runtime.copystack å‡½æ•°ã€‚ gp.activeStackChans = false // æ¥è‡ªclose()å‡½æ•°å”¤é†’æ—¶ï¼Œclosedä¸ºtrueã€‚ closed := !mysg.success // å¦‚æœæ˜¯æœ‰closeå”¤é†’çš„è¿™é‡Œsuccessä¸ºfalseå¹¶closedä¸º1 gp.param = nil if mysg.releasetime \u0026gt; 0 { blockevent(mysg.releasetime-t0, 2) } mysg.c = nil releaseSudog(mysg)\t// å›æ”¶*sudog // è¿™é‡Œä¹Ÿè§£é‡Šäº†å…³é—­channeléœ€è¦è°¨æ…æ“ä½œã€‚ // ä¸€ä¸ªgoroutineæ­£åœ¨sendï¼Œè€Œå¦å¤–ä¸€ä¸ªgoroutineå´closeäº†ï¼Œè¿™é‡Œå°±ä¼španicã€‚ if closed { // æ¥è‡ªclose()å‡½æ•°å”¤é†’æ—¶closedå­—æ®µåº”è¯¥ä¸º1ã€‚ if c.closed == 0 { throw(\u0026#34;chansend: spurious wakeup\u0026#34;) // chansend è™šå‡å”¤é†’ } // c.closed == 1æ—¶ï¼Œè¿˜å­˜åœ¨sendçš„gå´å…³é—­äº†chanæŠ¥é”™ // å› æ­¤ close() å‡½æ•°ä¸è¦åœ¨è¿˜æœ‰sendæœªå®Œæˆæ—¶è°ƒç”¨ã€‚ panic(plainError(\u0026#34;send on closed channel\u0026#34;)) // send åœ¨å…³é—­çš„ channel ä¸Š } return true } full() full() æŠ¥å‘Šåœ¨ c ä¸Šçš„å‘é€æ˜¯å¦ä¼šé˜»å¡(å³é€šé“å·²æ»¡)ã€‚ å®ƒä½¿ç”¨äº†ä¸€ä¸ªå¯å˜çŠ¶æ€çš„word-sizedçš„è¯»å–ï¼Œå› æ­¤å°½ç®¡ç­”æ¡ˆç«‹å³ä¸ºtrueï¼Œä½†åœ¨è°ƒç”¨å‡½æ•°æ”¶åˆ°è¿”å›å€¼æ—¶ï¼Œæ­£ç¡®çš„ç­”æ¡ˆå¯èƒ½å·²ç»æ”¹å˜äº†ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // full reports whether a send on c would block (that is, the channel is full). // It uses a single word-sized read of mutable state, so although // the answer is instantaneously true, the correct answer may have changed // by the time the calling function receives the return value. func full(c *hchan) bool { // c.dataqsiz is immutable (never written after the channel is created) // so it is safe to read at any time during channel operation. // // c.dataqsizæ˜¯ä¸å¯å˜çš„(åœ¨é€šé“åˆ›å»ºåæ°¸ä¸å†™å…¥)ï¼Œå› æ­¤åœ¨é€šé“æ“ä½œæœŸé—´çš„ä»»ä½•æ—¶å€™è¯»å–éƒ½æ˜¯å®‰å…¨çš„ã€‚ if c.dataqsiz == 0 { // Assumes that a pointer read is relaxed-atomic. // // å‡å®šæŒ‡é’ˆè¯»å–æ˜¯relaxed-atomicçš„ã€‚ return c.recvq.first == nil } // Assumes that a uint read is relaxed-atomic. // // å‡è®¾uint readæ˜¯relax-atomicã€‚ return c.qcount == c.dataqsiz } send() äº¤æ¢æ•°æ®ï¼Œå¹¶è°ƒç”¨goreadyæŠŠç­‰å¾…çš„Gæ”¾å…¥pä¸­ç­‰å¾…è°ƒåº¦ã€‚ send å¤„ç†ç©ºé€šé“ c ä¸Šçš„å‘é€æ“ä½œã€‚ å‘é€ç«¯å‘é€çš„å€¼ ep è¢«å¤åˆ¶åˆ°æ¥æ”¶ç«¯sgã€‚ç„¶åï¼Œæ¥æ”¶è€…è¢«å”¤é†’ï¼Œç»§ç»­å®ƒçš„å¿«ä¹ä¹‹è·¯ã€‚ é€šé“cå¿…é¡»æ˜¯ç©ºçš„å¹¶è¢«é”å®šã€‚ç”¨unlockfå‘é€è§£é”cã€‚sgå¿…é¡»å·²ç»ä»cä¸­é€€å‡ºé˜Ÿåˆ—ã€‚ epå¿…é¡»æ˜¯éç©ºå€¼ï¼Œå¹¶ä¸”æŒ‡å‘å †æˆ–è°ƒç”¨è€…çš„å †æ ˆã€‚ å‚æ•°ï¼š c *hchanï¼šhchan ç»“æ„ä½“æŒ‡é’ˆã€‚ sg *sudogï¼šæ˜¯ç­‰å¾… ep \u0026lt;- c çš„ gã€‚ ep unsafe.Pointerï¼šæ˜¯ c \u0026lt;- ep çš„æ•°æ®åœ°å€ã€‚ unlockf func()ï¼šé—­åŒ…å‡½æ•°è§£é” c.lockã€‚ skip intï¼šskip è·³è¿‡æ­¥éª¤ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 // send processes a send operation on an empty channel c. // The value ep sent by the sender is copied to the receiver sg. // The receiver is then woken up to go on its merry way. // Channel c must be empty and locked. send unlocks c with unlockf. // sg must already be dequeued from c. // ep must be non-nil and point to the heap or the caller\u0026#39;s stack. func send(c *hchan, sg *sudog, ep unsafe.Pointer, unlockf func(), skip int) { if raceenabled { if c.dataqsiz == 0 { racesync(c, sg) } else { // Pretend we go through the buffer, even though // we copy directly. Note that we need to increment // the head/tail locations only when raceenabled. racenotify(c, c.recvx, nil) racenotify(c, c.recvx, sg) c.recvx++ if c.recvx == c.dataqsiz { c.recvx = 0 } c.sendx = c.recvx // c.sendx = (c.sendx+1) % c.dataqsiz } } // sg.elem æ˜¯ç­‰å¾…è¯»çš„åœ°å€ï¼Œä¹Ÿå°±æ˜¯ep \u0026lt;- cè¿™é‡Œçš„epåœ°å€ if sg.elem != nil { // æŠŠepå¤åˆ¶åˆ°sg.elemä¸­ï¼Œè¿™æ ·å°±å®Œæˆäº†chançš„æ•°æ®äº¤æ¢ sendDirect(c.elemtype, sg, ep) sg.elem = nil } gp := sg.g // å–å‡ºå‡†å¤‡æ¢å¤çš„g // æŠŠ hchan è§£é”ã€‚ unlockf() // å”¤é†’æ—¶ä¼ é€’çš„å‚æ•°ã€‚ä¸»è¦ç”¨ä¸ select è¯­å¥å”¤é†’åä½¿ç”¨ã€‚ // select æ‹¿ç€è¿™ä¸ªå‚æ•°çš„å€¼åšæ¯”å¯¹ï¼Œæ˜¯å“ªä¸ª case å°±ç»ªäº†ã€‚ gp.param = unsafe.Pointer(sg) // g.param = *sudog // æŠŠsg.successæ ‡è®°ä¸ºtrueè¡¨ç¤ºæ•°æ®å·²ç»äº¤æ¢æˆåŠŸ sg.success = true if sg.releasetime != 0 { sg.releasetime = cputicks() } goready(gp, skip+1) } sendDirect() ä» src -\u0026gt; sg.elemã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 func sendDirect(t *_type, sg *sudog, src unsafe.Pointer) { // src is on our stack, dst is a slot on another stack. // // srcåœ¨æˆ‘ä»¬çš„å †æ ˆä¸Šï¼Œdstæ˜¯å¦ä¸€ä¸ªå †æ ˆä¸Šçš„æ’æ§½ã€‚ // Once we read sg.elem out of sg, it will no longer // be updated if the destination\u0026#39;s stack gets copied (shrunk). // So make sure that no preemption points can happen between read \u0026amp; use. // // ä¸€æ—¦æˆ‘ä»¬ä»sgä¸­è¯»å…¥sg.elemï¼Œå¦‚æœç›®æ ‡å †æ ˆè¢«å¤åˆ¶(æ”¶ç¼©)ï¼Œå®ƒå°†ä¸å†è¢«æ›´æ–°ã€‚ // å› æ­¤ï¼Œè¯·ç¡®ä¿åœ¨è¯»å–å’Œä½¿ç”¨ä¹‹é—´ä¸ä¼šå‘ç”ŸæŠ¢å ç‚¹ã€‚ dst := sg.elem // typeBitsBulkBarrierå¯¹memmoveä½¿ç”¨ç±»å‹ä½å›¾å®šä½æŒ‡é’ˆæ§½å°†[src, src+size)å¤åˆ¶åˆ°[dst, dst+size)çš„æ¯ä¸ªæŒ‡é’ˆæ‰§è¡Œå†™å±éšœã€‚ // ç±»å‹typå¿…é¡»ç²¾ç¡®å¯¹åº”äº[src, src+size)å’Œ[dst, dst+size)ã€‚dstã€srcå’Œsizeå¿…é¡»æ˜¯æŒ‡é’ˆå¯¹é½çš„ã€‚ typeBitsBulkBarrier(t, uintptr(dst), uintptr(src), t.size) // No need for cgo write barrier checks because dst is always // Go memory. // // ä¸éœ€è¦cgoå†™å±éšœæ£€æŸ¥ï¼Œå› ä¸ºdstæ€»æ˜¯Goå†…å­˜ã€‚ memmove(dst, src, t.size)\t// src -\u0026gt; dst } goready() æ¢å¤gpä¹Ÿå°±æ˜¯goroutineå‰è¿›è¡Œæ ˆåˆ‡æ¢åˆ°g0æ ˆã€‚ 1 2 3 4 5 func goready(gp *g, traceskip int) { systemstack(func() {\t// åˆ‡æ¢åˆ°g0æ ˆ ready(gp, traceskip, true) }) } ready() æ¢å¤gpä¹Ÿå°±æ˜¯è¿™ä¸ªgoroutineç›¸å…³çš„çŠ¶æ€ï¼Œç„¶åæ”¾å…¥Pä¸­ç­‰å¾…è¢«è°ƒåº¦ã€‚ æ ‡è®° gp å‡†å¤‡è¿è¡Œã€‚ å‚æ•°ï¼š gp *gï¼šå½“å‰éœ€è¦æ¢å¤çš„goroutine traceskip intï¼šæ£€æŸ¥è·³è¿‡æ­¥éª¤ next boolï¼šnextä¸ºtrueæ—¶ï¼Œåˆ™å°†gpæ”¾å…¥åˆ°_p_.runnextä¸­ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 // Mark gp ready to run. func ready(gp *g, traceskip int, next bool) { if trace.enabled { traceGoUnpark(gp, traceskip) } // è·å–å½“å‰gpè¿™ä¸ªgoroutineçš„çŠ¶æ€ status := readgstatus(gp) // Mark runnable. _g_ := getg() // å½“å‰æ­£åœ¨è¿è¡Œçš„gè¿™é‡Œæ˜¯g0 // ç¦ç”¨æŠ¢å ï¼Œå› ä¸ºå®ƒå¯ä»¥åœ¨æœ¬åœ°å˜é‡ä¸­æŒæœ‰p mp := acquirem() // disable preemption because it can be holding p in a local var if status\u0026amp;^_Gscan != _Gwaiting { dumpgstatus(gp) throw(\u0026#34;bad g-\u0026gt;status in ready\u0026#34;) } // status is Gwaiting or Gscanwaiting, make Grunnable and put on runq casgstatus(gp, _Gwaiting, _Grunnable) // åˆ‡æ¢gpçš„çŠ¶æ€ // gpæ”¾å…¥pçš„æœ¬åœ°é˜Ÿåˆ—ï¼Œè¿™é‡Œnextæ˜¯trueæ—¶ï¼Œä¼šæ”¾å…¥nextå­—æ®µä¼šä¼˜å…ˆè°ƒåº¦èµ·æ¥ runqput(_g_.m.p.ptr(), gp, next) // å› ä¸ºæœ‰goroutineæ”¾å…¥é˜Ÿåˆ—ä¸­ï¼Œå°è¯•å”¤é†’å…¶ä»–å·¥ä½œçº¿ç¨‹èµ·æ¥å·¥ä½œ wakep() // æœ‰goroutineè¢«æ”¾å›é˜Ÿåˆ—è¯¥å‡½æ•°å°±ä¼šç´§æ¥ç€è¢«è°ƒç”¨ releasem(mp) } chanbuf() chanbuf(c, i) æ˜¯æŒ‡å‘ç¼“å†²åŒºç¬¬ i ä¸ªæ§½çš„æŒ‡é’ˆã€‚ 1 2 3 4 // chanbuf(c, i) is pointer to the i\u0026#39;th slot in the buffer. func chanbuf(c *hchan, i uint) unsafe.Pointer { return add(c.buf, uintptr(i)*uintptr(c.elemsize)) } ep \u0026lt;- c ä» c ä¸­è¯»å–æ•°æ®ã€‚ ç¼–è¯‘åä»£ç ä¸­ \u0026lt;- c çš„å…¥å£ç‚¹ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 // // ep \u0026lt;- c // // as // // chanrecv1(c, \u0026amp;ep) // // entry points for \u0026lt;- c from compiled code // //go:nosplit func chanrecv1(c *hchan, elem unsafe.Pointer) { chanrecv(c, elem, true) } chanrecv() chanrecv åœ¨é€šé“ c æ¥æ”¶æ•°æ®ï¼Œå¹¶å°†æ¥æ”¶åˆ°çš„æ•°æ®å†™å…¥ epã€‚ epå¯ä»¥æ˜¯nilï¼Œåœ¨è¿™ç§æƒ…å†µä¸‹æ¥æ”¶åˆ°çš„æ•°æ®å°†è¢«å¿½ç•¥ã€‚ å¦‚æœblock == falseä¸”æ²¡æœ‰å…ƒç´ å¯ç”¨ï¼Œåˆ™è¿”å›(false, false)ã€‚å¦åˆ™ï¼Œå¦‚æœcæ˜¯å…³é—­çš„ï¼Œåˆ™*epè®¾ç½®æˆé›¶å€¼å¹¶è¿”å›(true, false)ã€‚å¦åˆ™ï¼Œç”¨ä¸€ä¸ªå…ƒç´ å¡«å……*epå¹¶è¿”å›(true, true)ã€‚ énilçš„epå¿…é¡»æŒ‡å‘å †æˆ–è°ƒç”¨è€…çš„å †æ ˆã€‚ å‚æ•°ï¼š c *hchanï¼šhchanç»“æ„ä½“æŒ‡é’ˆï¼Œä¹Ÿå°±æ˜¯ ep \u0026lt;- c ä¸­ c çš„ç»“æ„ä½“æŒ‡é’ˆã€‚æŒ‡å‘è¦ä»recvæ•°æ®çš„channelã€‚ ep unsafe.Pointerï¼šæ¥æ”¶å˜é‡åœ°å€ï¼Œä¹Ÿå°±æ˜¯ ep \u0026lt;- c ä¸­epå˜é‡çš„åœ°å€ã€‚æ˜¯ä¸€ä¸ªæŒ‡é’ˆï¼ŒæŒ‡å‘ç”¨æ¥æ¥æ”¶æ•°æ®çš„å†…å­˜ï¼Œæ•°æ®ç±»å‹è¦å’Œcçš„å…ƒç´ ç±»å‹ä¸€è‡´ã€‚ block boolï¼štrue.è¡¨ç¤ºå¦‚æœrecvæ“ä½œä¸èƒ½ç«‹å³å®Œæˆï¼Œæ˜¯å¦æƒ³è¦é˜»å¡ç­‰å¾…ã€‚true.ä¸èƒ½ç«‹å³å®Œæˆåˆ™é˜»å¡ï¼Œfalse.ä¸èƒ½ç«‹å³å®Œæˆä¸é˜»å¡ï¼Œç”¨äºselect{case: default:}å½¢å¼ã€‚ è¿”å›å€¼ï¼šè¿™ä¸¤ä¸ªå‚æ•°éƒ½æ˜¯ç”¨äº select{case: default:}å½¢å¼çš„ã€‚selectedè¡¨ç¤ºå½“å‰caseè¢«é€‰ä¸­ã€‚receivedè¡¨ç¤ºæ•°æ®æœ‰æ²¡äº¤æ¢æˆåŠŸã€‚ selected boolï¼štrue.è¡¨ç¤ºæ“ä½œå®Œæˆï¼ˆå¯èƒ½å› ä¸ºé€šé“å·²ç»å…³é—­ï¼‰ã€‚false.è¡¨ç¤ºç›®å‰ä¸èƒ½ç«‹å³å®Œæˆrecvï¼Œä½†å› ä¸ºä¸æƒ³é˜»å¡ï¼ˆblockä¸ºfalseï¼‰è€Œè¿”å›ã€‚ received boolï¼štrue.è¡¨ç¤ºæ•°æ®ç¡®å®æ˜¯ä»é€šé“ä¸­æ¥æ”¶çš„ï¼Œä¸æ˜¯å› ä¸ºé€šé“å…³é—­è€Œå¾—åˆ°çš„é›¶å€¼ã€‚false.å¯èƒ½æ˜¯å› ä¸ºé€šé“å…³é—­è€Œå¾—åˆ°çš„é›¶å€¼ï¼ˆselectedä¸ºtrueï¼‰ï¼Œæˆ–è€…å› ä¸ºä¸æƒ³é˜»å¡è€Œè¿”å›ï¼ˆselectedä¸ºfalseï¼‰ã€‚ è¿”å›å€¼çš„ç»„æˆï¼š (true, true)ï¼šæ“ä½œå·²å®Œæˆï¼Œç¡®å®æ˜¯ä»channelä¸­æ¥æ”¶çš„ï¼ˆä¸æ˜¯å› ä¸ºchannelå…³é—­è€Œå¾—åˆ°çš„é›¶å€¼ï¼‰ã€‚ï¼ˆå½“å‰åˆ†æ”¯è¢«é€‰ä¸­ï¼Œæ•°æ®ä¹Ÿäº¤æ¢æˆåŠŸäº†ï¼‰ (false, false)ï¼šç›®å‰ä¸èƒ½ç«‹å³å®Œæˆï¼Œå› ä¸ºä¸æƒ³é˜»å¡è€Œè¿”å›ã€‚ï¼ˆå½“å‰åˆ†æ”¯æ²¡è¢«é€‰ä¸­ï¼Œèµ°defaultå§ï¼‰ (true, false)ï¼šæ“ä½œå·²å®Œæˆï¼Œå› ä¸ºé€šé“å…³é—­è€Œè¿”å›é›¶å€¼ã€‚ï¼ˆå½“å‰åˆ†æ”¯è¢«é€‰ä¸­ï¼Œå› closeè€Œè¿”å›é»˜è®¤é›¶å€¼ï¼‰ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 // chanrecv receives on channel c and writes the received data to ep. // ep may be nil, in which case received data is ignored. // If block == false and no elements are available, returns (false, false). // Otherwise, if c is closed, zeros *ep and returns (true, false). // Otherwise, fills in *ep with an element and returns (true, true). // A non-nil ep must point to the heap or the caller\u0026#39;s stack. func chanrecv(c *hchan, ep unsafe.Pointer, block bool) (selected, received bool) { // raceenabled: don\u0026#39;t need to check ep, as it is always on the stack // or is new memory allocated by reflect. // // Raceenabled:ä¸éœ€è¦æ£€æŸ¥epï¼Œå› ä¸ºå®ƒæ€»æ˜¯åœ¨å †æ ˆä¸Šæˆ–ç”±reflectåˆ†é…æ–°çš„å†…å­˜ã€‚ if debugChan { // debug print(\u0026#34;chanrecv: chan=\u0026#34;, c, \u0026#34;\\n\u0026#34;) } // 1) chanæœªåˆå§‹åŒ–æ—¶ï¼Œæ¯”å¦‚ var c chan int if c == nil { if !block { // æ¥è‡ªselect{case: default:}å— return // false, false } // \u0026lt;- nil // è¿™é‡Œåœ¨nilçš„chanä¸­è¯»å–æ•°æ®ï¼Œç›´æ¥åˆ‡æ¢åˆ°è°ƒåº¦å¾ªç¯è¿›è¡Œæ–°ä¸€è½®è°ƒåº¦ // è¿™ä¸ªGåé¢çš„ä»£ç å°†ä¸ä¼šå¾—åˆ°æ‰§è¡Œï¼Œåº”è¯¥å½“å‰Gæ—¢æ²¡æœ‰åŠ å…¥åˆ°Pä¸­ç­‰å¾…è°ƒåº¦ï¼Œä¹Ÿæ²¡æœ‰åœ¨chanä¸­ï¼Œæ°¸ä¹…ä¸¢å¤±äº† gopark(nil, nil, waitReasonChanReceiveNilChan, traceEvGoStop, 2) throw(\u0026#34;unreachable\u0026#34;) } // 2) Fast pathï¼šåœ¨æœªåŠ é”ä¸‹ï¼Œåˆ¤æ–­blockä¸ºfalseæ—¶ï¼Œsendä¸ºç©ºæ—¶ã€‚ // Fast path: check for failed non-blocking operation without acquiring the lock. // // Fast path: æ£€æŸ¥æœªè·å¾—é”çš„å¤±è´¥çš„éé˜»å¡æ“ä½œã€‚ if !block \u0026amp;\u0026amp; empty(c) { // select{case: default:}å—ï¼Œcä¸ºç©º // After observing that the channel is not ready for receiving, we observe whether the // channel is closed. // // Reordering of these checks could lead to incorrect behavior when racing with a close. // For example, if the channel was open and not empty, was closed, and then drained, // reordered reads could incorrectly indicate \u0026#34;open and empty\u0026#34;. To prevent reordering, // we use atomic loads for both checks, and rely on emptying and closing to happen in // separate critical sections under the same lock. This assumption fails when closing // an unbuffered channel with a blocked send, but that is an error condition anyway. // // åœ¨è§‚å¯Ÿåˆ°é€šé“è¿˜æ²¡æœ‰å‡†å¤‡å¥½æ¥æ”¶ä¹‹åï¼Œæˆ‘ä»¬è§‚å¯Ÿé€šé“æ˜¯å¦å…³é—­ã€‚ // // åœ¨ä¸closeç«äº‰æ—¶ï¼Œè¿™äº›æ£€æŸ¥çš„é‡æ–°æ’åºå¯èƒ½ä¼šå¯¼è‡´é”™è¯¯çš„è¡Œä¸ºã€‚ // ä¾‹å¦‚ï¼Œå¦‚æœchannelæ˜¯æ‰“å¼€çš„ä¸”ä¸æ˜¯ç©ºçš„ï¼Œè¢«å…³é—­ï¼Œç„¶åå…¨éƒ¨å–å‡ºï¼Œé‡æ–°æ’åºçš„è¯»æ•°å¯èƒ½ä¼šé”™è¯¯åœ°æŒ‡ç¤º\u0026#34;open and empty\u0026#34;ã€‚ // ä¸ºäº†é˜²æ­¢é‡æ–°æ’åºï¼Œæˆ‘ä»¬å¯¹è¿™ä¸¤ç§æ£€æŸ¥éƒ½ä½¿ç”¨äº†åŸå­åŠ è½½ï¼Œå¹¶ä¾èµ–äºåœ¨åŒä¸€é”ä¸‹çš„ä¸åŒä¸´ç•ŒåŒºä¸­è¿›è¡Œæ¸…ç©ºå’Œå…³é—­æ“ä½œã€‚ // å½“ä»¥é˜»å¡çš„å‘é€æ–¹å¼å…³é—­æ— ç¼“å†²çš„é€šé“æ—¶ï¼Œè¿™ä¸ªå‡è®¾å°±å¤±è´¥äº†ï¼Œä½†æ— è®ºå¦‚ä½•è¿™éƒ½æ˜¯ä¸€ä¸ªé”™è¯¯æ¡ä»¶ã€‚ if atomic.Load(\u0026amp;c.closed) == 0 { // sendä¸ºç©º å¹¶ closed æœªå…³é—­ï¼Œè¿”å› (false, false) // Because a channel cannot be reopened, the later observation of the channel // being not closed implies that it was also not closed at the moment of the // first observation. We behave as if we observed the channel at that moment // and report that the receive cannot proceed. // // å› ä¸ºchannelä¸èƒ½é‡æ–°æ‰“å¼€ï¼Œæ‰€ä»¥åæ¥è§‚å¯Ÿåˆ°çš„channelæ²¡æœ‰å…³é—­æ„å‘³ç€åœ¨ç¬¬ä¸€æ¬¡è§‚å¯Ÿçš„æ—¶å€™å®ƒä¹Ÿæ²¡æœ‰å…³é—­ã€‚ // æˆ‘ä»¬çš„è¡Œä¸ºå°±åƒæˆ‘ä»¬å½“æ—¶è§‚å¯Ÿåˆ°äº†channelï¼Œå¹¶æŠ¥å‘Šè¯´æ¥æ”¶æ— æ³•ç»§ç»­ã€‚ return } // The channel is irreversibly closed. Re-check whether the channel has any pending data // to receive, which could have arrived between the empty and closed checks above. // Sequential consistency is also required here, when racing with such a send. // // channelæ˜¯ä¸å¯é€†å…³é—­çš„ã€‚é‡æ–°æ£€æŸ¥ä¿¡é“æ˜¯å¦æœ‰å¾…å¤„ç†çš„æ•°æ®è¦æ¥æ”¶ï¼Œè¿™äº›æ•°æ®å¯èƒ½æ˜¯åœ¨ä¸Šé¢çš„ç©ºæ£€æŸ¥å’Œå…³é—­æ£€æŸ¥ä¹‹é—´åˆ°è¾¾çš„ã€‚ // å½“ä½¿ç”¨è¿™æ ·çš„å‘é€æ–¹å¼æ¯”èµ›æ—¶ï¼Œé¡ºåºçš„ä¸€è‡´æ€§ä¹Ÿæ˜¯å¿…éœ€çš„ã€‚ if empty(c) { // sendä¸ºç©º å¹¶ä¸” closed å·²å…³é—­ï¼Œè¿”å› (true, false) // The channel is irreversibly closed and empty. if raceenabled { raceacquire(c.raceaddr()) } if ep != nil { typedmemclr(c.elemtype, ep) } return true, false } } var t0 int64 if blockprofilerate \u0026gt; 0 { t0 = cputicks() } // 3) åŠ é”æƒ…å†µä¸‹å»åˆ¤æ–­ send å’Œ sendq æ˜¯å¦æœ‰ç­‰å¾… send çš„æ•°æ®ã€‚ lock(\u0026amp;c.lock) // è·å–runtime.mutex // channel å·²å…³é—­ if c.closed != 0 {\t// send bufç¼“å†²åŒºæ²¡æ•°æ® if c.qcount == 0 {\tif raceenabled { raceacquire(c.raceaddr()) } unlock(\u0026amp;c.lock) // æ‹·è´å¯¹åº”ç±»å‹çš„é›¶å€¼ if ep != nil { // Typedmemclræ¸…é™¤ç±»å‹ä¸ºtypçš„ptrçš„ç±»å‹åŒ–å†…å­˜ã€‚ typedmemclr(c.elemtype, ep) // ep èµ‹å€¼chanå…ƒç´ ç±»å‹çš„é»˜è®¤å€¼ } return true, false } // The channel has been closed, but the channel\u0026#39;s buffer have data. // // channel å·²ç»å…³é—­ï¼Œä½†é€šé“çš„ç¼“å†²åŒºæœ‰æ•°æ®ã€‚ } else { // channel æœªå…³é—­ // Just found waiting sender with not closed. // // åˆšåˆšå‘ç°ç­‰å¾…sendæœªå…³é—­ã€‚å–å‡ºfirstä¸Šçš„ç¬¬ä¸€ä¸ª*sudogï¼Œè¿™ä¸ªéœ€è¦å¤„ç† // è¿™é‡Œéšå«äº† buf ç¼“å­˜åŒºä¸ºç©ºçš„æƒ…å†µã€‚ if sg := c.sendq.dequeue(); sg != nil { // Found a waiting sender. If buffer is size 0, receive value // directly from sender. Otherwise, receive from head of queue // and add sender\u0026#39;s value to the tail of the queue (both map to // the same buffer slot because the queue is full). // // å‘ç°ä¸€ä¸ªç­‰å¾…å‘é€è€…ã€‚å¦‚æœç¼“å†²åŒºå¤§å°æ˜¯0ï¼Œæ¥æ”¶å€¼ç›´æ¥ä»å‘é€æ–¹ã€‚ // å¦åˆ™ï¼Œä»é˜Ÿåˆ—çš„å¤´éƒ¨æ¥æ”¶å¹¶å°†å‘é€æ–¹çš„å€¼æ·»åŠ åˆ°é˜Ÿåˆ—çš„å°¾éƒ¨(ä¸¤è€…æ˜ å°„åˆ°ç›¸åŒçš„ç¼“å†²æ§½ï¼Œå› ä¸ºé˜Ÿåˆ—å·²æ»¡)ã€‚ recv(c, sg, ep, func() { unlock(\u0026amp;c.lock) }, 3) return true, true } } // buf ç¼“å†²åŒºæœ‰æ•°æ® if c.qcount \u0026gt; 0 { // Receive directly from queue // ç›´æ¥ä»ç¼“å­˜åŒºé˜Ÿåˆ—ä¸­æ¥æ”¶æ•°æ® qp := chanbuf(c, c.recvx) if raceenabled { racenotify(c, c.recvx, nil) } // äº¤æ¢æ•°æ® if ep != nil { typedmemmove(c.elemtype, ep, qp) // ep = qp } typedmemclr(c.elemtype, qp) // æ¸…é™¤ qp c.recvx++ if c.recvx == c.dataqsiz { c.recvx = 0 } c.qcount-- // ç¼“å­˜åŒºå…ƒç´ ä¸ªæ•° unlock(\u0026amp;c.lock) return true, true } // ä¸‹é¢ä»£ç æ˜¯éœ€è¦è¢«é˜»å¡çš„æƒ…å†µï¼Œå½“å‰goroutineè¢«åŠ¨æ‰§è¡Œè°ƒåº¦åˆ°c.sendqä¸­å»ç­‰å¾… // block ä¸º falseï¼Œä¸æƒ³é˜»å¡è€Œè¿”å›ã€‚ if !block { unlock(\u0026amp;c.lock) return false, false } // 4) send bufå–æ²¡æœ‰æ•°æ®æˆ–sendqä¸­æ²¡æœ‰ç­‰å¾…çš„goroutineæ—¶ã€‚ // no sender available: block on this channel. // æ²¡æœ‰å¯ç”¨çš„å‘é€è€…:åœ¨æ­¤é€šé“ä¸Šé˜»å¡ã€‚ gp := getg() // g mysg := acquireSudog() // è·å–ä¸€ä¸ªç©ºé—²çš„ *sudog mysg.releasetime = 0 if t0 != 0 { mysg.releasetime = -1 } // No stack splits between assigning elem and enqueuing mysg // on gp.waiting where copystack can find it. // åœ¨åˆ†é…elemå’Œåœ¨gp.waitingä¸Šå¯¹mysgè¿›è¡Œæ’é˜Ÿä¹‹é—´æ²¡æœ‰æ ˆæ‹†åˆ†ï¼Œå› ä¸ºåœ¨gp.waitingä¸Šcopystackå¯ä»¥æ‰¾åˆ°å®ƒã€‚ mysg.elem = ep mysg.waitlink = nil gp.waiting = mysg mysg.g = gp mysg.isSelect = false // æ ‡è®°ä¸æ˜¯åœ¨selectå—ä¸­æ¥çš„ mysg.c = c gp.param = nil c.recvq.enqueue(mysg) // åŠ å…¥ recvq é˜Ÿåˆ—ä¸­ // Signal to anyone trying to shrink our stack that we\u0026#39;re about // to park on a channel. The window between when this G\u0026#39;s status // changes and when we set gp.activeStackChans is not safe for // stack shrinking. // å‘ä»»ä½•è¯•å›¾ç¼©å°å †æ ˆçš„äººå‘å‡ºä¿¡å·ï¼Œæˆ‘ä»¬å³å°†åœåœ¨ä¸€ä¸ªchannelä¸Šã€‚ // å½“Gçš„çŠ¶æ€æ”¹å˜å’Œæˆ‘ä»¬è®¾ç½®gpä¹‹é—´çš„çª—å£ã€‚activeStackChans å¯¹å †æ ˆæ”¶ç¼©ä¸å®‰å…¨ã€‚ // goroutine.parkingOnChanè¡¨ç¤ºè¯¥goroutineå³å°†åœåœ¨ä¸€ä¸ªchansendæˆ–chanrecvä¸Šã€‚ç”¨äºæŒ‡ç¤ºå †æ ˆæ”¶ç¼©çš„ä¸å®‰å…¨ç‚¹ã€‚å®ƒæ˜¯ä¸€ä¸ªå¸ƒå°”å€¼ï¼Œä½†ä¼šè‡ªåŠ¨æ›´æ–°ã€‚ atomic.Store8(\u0026amp;gp.parkingOnChan, 1) // gopark ä¿å­˜å½“å‰goroutineçº¿ç¨‹; è°ƒç”¨ releasem(mp) è§£é™¤å½“å‰må’ŒPçš„ç»‘å®š // è°ƒç”¨mcall(park_m) mcallåˆ‡æ¢æ ˆåˆ°g0 park_m è§£é™¤må’Œgçš„å…³è” è°ƒç”¨scheduleå†æ¬¡å¼€å¯è°ƒåº¦å¾ªç¯ gopark(chanparkcommit, unsafe.Pointer(\u0026amp;c.lock), waitReasonChanReceive, traceEvGoBlockRecv, 2) // someone woke us up if mysg != gp.waiting { throw(\u0026#34;G waiting list is corrupted\u0026#34;) } gp.waiting = nil gp.activeStackChans = false if mysg.releasetime \u0026gt; 0 { blockevent(mysg.releasetime-t0, 2) } success := mysg.success gp.param = nil mysg.c = nil releaseSudog(mysg) // å›æ”¶ sudog return true, success } empty() EmptyæŠ¥å‘Šä»cè¯»å–æ•°æ®æ˜¯å¦ä¼šé˜»å¡(å³channelæ˜¯ç©ºçš„)ã€‚å®ƒä½¿ç”¨å•ä¸ªåŸå­è¯»å–å¯å˜çŠ¶æ€ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 // empty reports whether a read from c would block (that is, the channel is // empty). It uses a single atomic read of mutable state. func empty(c *hchan) bool { // c.dataqsiz is immutable. // // c.dataqsiz æ˜¯ä¸å¯å˜çš„ if c.dataqsiz == 0 { // æ˜¯å¦æœ‰ç­‰å¾… send çš„ goroutine return atomic.Loadp(unsafe.Pointer(\u0026amp;c.sendq.first)) == nil } // ç¼“å­˜åŒºæ˜¯å¦æœ‰æ•°æ® return atomic.Loaduint(\u0026amp;c.qcount) == 0 } recv() recv åœ¨ä¸€ä¸ªæ»¡çš„ç¼“å­˜åŒºçš„channel cä¸Šå¤„ç†æ¥æ”¶æ“ä½œ æœ‰ä»¥ä¸‹ä¸¤éƒ¨åˆ†ï¼š å‘é€æ”¾sgå‘é€çš„å€¼è¢«æ”¾å…¥channelï¼Œå‘é€æ–¹è¢«å”¤é†’ æ¥æ”¶ç«¯æ¥æ”¶åˆ°çš„å€¼(å½“å‰G)è¢«å†™å…¥ep å¯¹äºåŒæ­¥channelï¼Œè¿™ä¸¤ä¸ªå€¼æ˜¯ç›¸åŒçš„ å¯¹äºå¼‚æ­¥channelï¼Œæ¥æ”¶æ–¹ä»é€šé“ç¼“å†²åŒºè·å–æ•°æ®ï¼Œå‘é€æ–¹çš„æ•°æ®æ”¾åœ¨é€šé“ç¼“å†²åŒºä¸­ã€‚ é€šé“cå¿…é¡»å·²æ»¡ä¸”å·²é”å®šã€‚recvç”¨unlockfè§£é”cã€‚sgå¿…é¡»å·²ç»ä»cä¸­é€€å‡ºé˜Ÿåˆ—ã€‚ énilçš„epå¿…é¡»æŒ‡å‘å †æˆ–è°ƒç”¨è€…çš„å †æ ˆã€‚ å‚æ•°ï¼š c *hchanï¼šå½“å‰ chan sg *sudogï¼šä» recvq ä¸­çš„firstå–å‡ºçš„ç¬¬ä¸€ä¸ª *sudog ep unsafe.Pointerï¼šv \u0026lt;- c ä¸­çš„våœ°å€ unlockf func()ï¼šè§£é” runtime.mutex çš„é—­åŒ…å‡½æ•° skip intï¼šè°ƒè¯•ç›¸å…³ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 // recv processes a receive operation on a full channel c. // There are 2 parts: // 1. The value sent by the sender sg is put into the channel // and the sender is woken up to go on its merry way. // 2. The value received by the receiver (the current G) is // written to ep. // // For synchronous channels, both values are the same. // For asynchronous channels, the receiver gets its data from // the channel buffer and the sender\u0026#39;s data is put in the // channel buffer. // Channel c must be full and locked. recv unlocks c with unlockf. // sg must already be dequeued from c. // A non-nil ep must point to the heap or the caller\u0026#39;s stack. func recv(c *hchan, sg *sudog, ep unsafe.Pointer, unlockf func(), skip int) { if c.dataqsiz == 0 { // æ— ç¼“å†² chan if raceenabled { racesync(c, sg) } if ep != nil { // copy data from sender // ä»å‘é€æ–¹å¤åˆ¶æ•°æ® recvDirect(c.elemtype, sg, ep) // ep = sg } } else { // æœ‰ç¼“å†² chan // Queue is full. Take the item at the // head of the queue. Make the sender enqueue // its item at the tail of the queue. Since the // queue is full, those are both the same slot. // é˜Ÿåˆ—å·²æ»¡ã€‚ä»¥é˜Ÿåˆ—æœ€å‰é¢çš„é¡¹ä¸ºä¾‹ã€‚ // è®©å‘é€æ–¹åœ¨é˜Ÿåˆ—çš„å°¾éƒ¨å°†å…¶é¡¹ç›®å…¥é˜Ÿã€‚ // å› ä¸ºé˜Ÿåˆ—å·²ç»æ»¡äº†ï¼Œæ‰€ä»¥å®ƒä»¬æ˜¯åŒä¸€ä¸ªæ§½ã€‚ // ä»¥ä¸Šæ„æ€æ˜¯ä»sendq.firstå–å‡ºçš„*sudogéœ€è¦æ¢å¤è¿™ä¸ªgå¹¶æŠŠæ•°æ®æ”¾å…¥ç¼“å­˜åŒºï¼Œä»ç¼“å­˜åŒºå–å‡ºä¸‹ä¸€ä¸ªæ•°æ®äº¤æ¢ qp := chanbuf(c, c.recvx) // æ•°æ®åŒºçš„ä¸‹ä¸€ä¸ªéœ€è¦äº¤æ¢çš„æ•°æ® if raceenabled { racenotify(c, c.recvx, nil) racenotify(c, c.recvx, sg) } // copy data from queue to receiver // å°†æ•°æ®ä»é˜Ÿåˆ—å¤åˆ¶åˆ°æ¥æ”¶å™¨ if ep != nil { typedmemmove(c.elemtype, ep, qp) // ep = qp } // copy data from sender to queue // ä»å‘é€ç«¯å¤åˆ¶æ•°æ®åˆ°é˜Ÿåˆ— typedmemmove(c.elemtype, qp, sg.elem) // qp = sg.elem c.recvx++\t// ä¸‹ä¸€æ¬¡recvæ•°æ®ç´¢å¼• if c.recvx == c.dataqsiz {\t// å¦‚æœè¶…è¿‡æœ€å¤§é‡ç½®ä¸º0 c.recvx = 0 } // è®¾ç½®ç¼“å­˜åŒºæ˜¯æ»¡çš„ï¼Œå› ä¸ºè¿™ç§æƒ…å†µç¼“å­˜åŒºä¸€å®šæ˜¯full // æ­¤æ—¶éœ€è¦è°ƒæ•´ sendx çš„å€¼ï¼Œå› ä¸ºä¹‹å‰å°±æ˜¯æ»¡çš„ è¯´æ˜ä¹‹å‰ c.sendx == c.recvx c.sendx = c.recvx // c.sendx = (c.sendx+1) % c.dataqsiz } // sg ä¸­çš„ *sudog çš„géœ€è¦è¢«æ¢å¤è®©å…¶ä»æ–°è¢«è°ƒåº¦ sg.elem = nil // æ•°æ®å·²è¢«æ”¾å…¥ç¼“å­˜åŒºï¼Œæƒ…å†µå³å¯ gp := sg.g // éœ€è¦æ¢å¤çš„g unlockf() // runtime.mutex è§£é” // å½“ä¸€ä¸ªchannelæ“ä½œå”¤é†’ä¸€ä¸ªè¢«é˜»å¡çš„goroutineæ—¶ï¼Œå®ƒå°†paramè®¾ç½®ä¸ºæŒ‡å‘å·²å®Œæˆé˜»å¡æ“ä½œçš„sudogã€‚ // select æ‹¿ç€è¿™ä¸ªå‚æ•°çš„å€¼åšæ¯”å¯¹ï¼Œæ˜¯å“ªä¸ª case å°±ç»ªäº†ã€‚ gp.param = unsafe.Pointer(sg) // ä¸»è¦ç”¨ä¸ select è¯­å¥å”¤é†’åä½¿ç”¨ã€‚ sg.success = true // success æ ‡è®°äº† trueï¼Œäº¤æ¢æ•°æ®æˆåŠŸ if sg.releasetime != 0 { sg.releasetime = cputicks() } goready(gp, skip+1)\t// æ”¾å…¥é˜Ÿåˆ—ä¸­ç­‰å¾…å”¤é†’g } goready() æ¢å¤gpä¹Ÿå°±æ˜¯goroutineå‰è¿›è¡Œæ ˆåˆ‡æ¢åˆ°g0æ ˆã€‚ 1 2 3 4 5 func goready(gp *g, traceskip int) { systemstack(func() { // åˆ‡æ¢åˆ° g0 æ ˆ ready(gp, traceskip, true) }) } ready() æ ‡è®°gpå‡†å¤‡è¿è¡Œã€‚ å‚æ•°ï¼š gp *gï¼šå‡†å¤‡æ¢å¤çš„ goroutine traceskip intï¼šæµ‹è¯•ç›¸å…³ next boolï¼štrue.ä¸‹æ¬¡è°ƒåº¦ä¼˜å…ˆè°ƒåº¦å½“å‰goroutine 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 // Mark gp ready to run. func ready(gp *g, traceskip int, next bool) { if trace.enabled { traceGoUnpark(gp, traceskip) } // goroutine çŠ¶æ€ status := readgstatus(gp) // Mark runnable. _g_ := getg() // å½“å‰g0 // ç¦æ­¢å½“å‰mè¢«æŠ¢å ï¼Œå› ä¸ºå³å°†æŠŠgpæ”¾å…¥må…³è”çš„æœ¬åœ°Pä¸­å» mp := acquirem() // disable preemption because it can be holding p in a local var // å¦‚æœå½“å‰gpçŠ¶æ€å¤„ç†åä¸ç­‰äº_Gwaitingç­‰å¾…ä¸­ï¼Œé‚£è¯´æ˜è¿™ä¸ªgpæ˜¯æœ‰é—®é¢˜çš„ if status\u0026amp;^_Gscan != _Gwaiting { dumpgstatus(gp) throw(\u0026#34;bad g-\u0026gt;status in ready\u0026#34;) } // status is Gwaiting or Gscanwaiting, make Grunnable and put on runq // æŠŠå½“å‰gpè¿™ä¸ªgoroutineçŠ¶æ€ä»_Gwaitingç­‰å¾…ä¸­ä¿®æ”¹ä¸º_Grunnableå¯ä»¥è¿è¡Œçš„çŠ¶æ€ casgstatus(gp, _Gwaiting, _Grunnable) // ç„¶åæŠŠgpæ”¾å…¥mçš„æœ¬åœ°å…³è”Pä¸­ï¼Œnextä¸ºtrueè¡¨ç¤ºæ”¾å…¥å‰é¢ runqput(_g_.m.p.ptr(), gp, next) wakep() // å°è¯•å”¤é†’å…¶ä»–çº¿ç¨‹ releasem(mp) // è§£é™¤å‰é¢çš„ acquirem() å‡½æ•°çš„æŠ¢å ï¼Œå¹¶åˆ¤æ–­æ˜¯å¦æœ‰æŠ¢å å‘ç”Ÿ } runqput() runqput è¯•å›¾å°†gæ”¾åˆ°æœ¬åœ°å¯è¿è¡Œé˜Ÿåˆ—ä¸Šã€‚ å¦‚æœ next ä¸º false, runqput å°† g æ·»åŠ åˆ°å¯è¿è¡Œé˜Ÿåˆ—çš„å°¾éƒ¨ã€‚ å¦‚æœ next ä¸º true, runqput å°† g æ”¾å…¥_p_.runnextä½ç½®ã€‚ å¦‚æœå°±ç»ªé˜Ÿåˆ—å·²æ»¡ï¼Œrunnext å°† g æ”¾ç½®åˆ°å…¨å±€é˜Ÿåˆ—ä¸­ã€‚ ä»…ç”±æ‰€æœ‰è€…Pæ‰§è¡Œã€‚ å‚æ•°ï¼š _p_ *pï¼šå½“å‰å·¥ä½œçº¿ç¨‹ç»‘å®šçš„ P gp *gï¼šéœ€è¦å¤„ç†çš„ goroutine next boolï¼štrue.ä¸‹æ¬¡è°ƒåº¦ä¼˜å…ˆè°ƒåº¦å½“å‰goroutine 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 // runqput tries to put g on the local runnable queue. // If next is false, runqput adds g to the tail of the runnable queue. // If next is true, runqput puts g in the _p_.runnext slot. // If the run queue is full, runnext puts g on the global queue. // Executed only by the owner P. func runqput(_p_ *p, gp *g, next bool) { // è¿™é‡Œæ˜¯ä¸ºäº†æµ‹è¯•ç”¨ä¾‹å¢åŠ éšæœºæ€§çš„ä»£ç  // randomizeScheduleråœ¨æµ‹è¯•ä»£ç ä¸­è¿™é‡Œä¼šè®¾ç½®ä¸ºtrueï¼Œæ­£å¸¸æ˜¯false if randomizeScheduler \u0026amp;\u0026amp; next \u0026amp;\u0026amp; fastrandn(2) == 0 { next = false } // next=trueï¼Œå°†gpæ·»åŠ åˆ°_p_.runnextä¸­ã€‚_p_.runnext å¦‚æœæ˜¯énilï¼Œæ˜¯ä¸€ä¸ªå¯è¿è¡Œçš„G // å¦‚æœåœ¨è¿è¡Œ G çš„æ—¶é—´ç‰‡ä¸­æœ‰å‰©ä½™æ—¶é—´ï¼Œé‚£ä¹ˆåº”è¯¥è¿è¡Œä¸‹ä¸€ä¸ªè€Œä¸æ˜¯ runq ä¸­çš„å†…å®¹ if next { retryNext: oldnext := _p_.runnext // åŸå­äº¤æ¢ if !_p_.runnext.cas(oldnext, guintptr(unsafe.Pointer(gp))) { goto retryNext } if oldnext == 0 { return } // Kick the old runnext out to the regular run queue. // æŠŠæ—§çš„runnextè¸¢åˆ°å¸¸è§„çš„runé˜Ÿåˆ—ã€‚ gp = oldnext.ptr() } retry: // _p_çš„runqæ˜¯ä¸€ä¸ª256å¤§å°çš„å¾ªç¯æ•°ç»„ï¼ŒrunqheadæŒ‡å‘å¼€å§‹ï¼ŒrunqtailæŒ‡å‘å°¾éƒ¨ h := atomic.LoadAcq(\u0026amp;_p_.runqhead) // load-acquire, synchronize with consumers t := _p_.runqtail // è¿™é‡Œä¹‹æ‰€ä»¥æ²¡æœ‰ä½¿ç”¨é”ï¼Œæ˜¯ç”±äºè¿™ä¸ªrunqtailåœ¨å…¶ä»–åœ°æ–¹ä¸ä¼šè¢«ä¿®æ”¹ // å¦‚æœt-hå°äºæ€»runqçš„å¤§å°ï¼Œè¯´æ˜è¿˜æ²¡æœ‰å­˜æ»¡ if t-h \u0026lt; uint32(len(_p_.runq)) { // è¿™é‡Œä½¿ç”¨t%uint32(len(_p_.runq))æ˜¯ç”±äºå¯èƒ½å‡ºç°h \u0026gt; tçš„æƒ…å†µï¼Œé‚£ä¹ˆéœ€è¦å§‹ç»ˆæ”¾åœ¨tçš„åé¢ _p_.runq[t%uint32(len(_p_.runq))].set(gp) atomic.StoreRel(\u0026amp;_p_.runqtail, t+1) // store-release, makes the item available for consumption return } // å¦‚æœæœ¬åœ°På·²ç»å­˜æ»¡ï¼Œé‚£ä¹ˆéœ€è¦å»å…¨å±€é‡Œé¢å­˜æ•°æ® if runqputslow(_p_, gp, h, t) { return } // the queue is not full, now the put above must succeed // å¦‚æœä¸Šé¢éƒ½æ²¡æœ‰å­˜å‚¨æˆåŠŸï¼Œé‚£ä¹ˆè·³è½¬åˆ°retryæ ‡ç­¾ç»§ç»­å­˜å‚¨æ•°æ®ï¼Œç›´åˆ°æˆåŠŸ goto retry } runqputslow() æŠŠgpåŠ_p_ä¸­çš„ä¸€åŠçš„Gå°è¯•åŠ å…¥å…¨å±€Gä¸­å» å°†gå’Œä¸€æ‰¹æ¥è‡ªæœ¬åœ°å¯è¿è¡Œé˜Ÿåˆ—çš„å·¥ä½œæ”¾åˆ°å…¨å±€é˜Ÿåˆ—ä¸Šã€‚ ä»…ç”±æ‰€æœ‰è€…Pæ‰§è¡Œã€‚ å‚æ•°ï¼š _p_ *pï¼šå½“å‰å·¥ä½œçº¿ç¨‹ç»‘å®šçš„P gp *gï¼šå½“å‰éœ€è¦å¤„ç†çš„ goroutine h, t uint32ï¼š_p_çš„runqæ˜¯ä¸€ä¸ª256å¤§å°çš„å¾ªç¯æ•°ç»„ï¼ŒrunqheadæŒ‡å‘å¼€å§‹ï¼ŒrunqtailæŒ‡å‘å°¾éƒ¨ è¿”å›å€¼ï¼š boolï¼štrue.æ”¾å…¥æˆåŠŸï¼Œfalse.æ”¾å…¥å¤±è´¥ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 // Put g and a batch of work from local runnable queue on global queue. // Executed only by the owner P. func runqputslow(_p_ *p, gp *g, h, t uint32) bool { // é¦–å…ˆå®šä¹‰batchæ•°ç»„ï¼Œè¿™æ˜¯éœ€è¦å–å‡ºçš„Gæ”¾å…¥çš„æ•°ç»„ // è¿™é‡Œçš„len(_p_.runq)/2 + 1æ˜¯æŠŠgpæ”¾å…¥è¿™ä¸ª+1è¿™é‡Œç®—åœ¨ä¸€èµ·çš„ var batch [len(_p_.runq)/2 + 1]*g // ä¸´æ—¶å®¹å™¨ // First, grab a batch from local queue. // é¦–å…ˆï¼Œä»æœ¬åœ°é˜Ÿåˆ—ä¸­è·å–ä¸€ä¸ªæ‰¹ã€‚ n := t - h n = n / 2 // å–ä¸€åŠ if n != uint32(len(_p_.runq)/2) { throw(\u0026#34;runqputslow: queue is not full\u0026#34;) } // å–å‡ºä¸€åŠæ”¾å…¥å®¹å™¨ for i := uint32(0); i \u0026lt; n; i++ { batch[i] = _p_.runq[(h+i)%uint32(len(_p_.runq))].ptr() } // åŸå­äº¤æ¢headç´¢å¼•å€¼ if !atomic.CasRel(\u0026amp;_p_.runqhead, h, h+n) { // cas-release, commits consume return false } batch[n] = gp // gp æ”¾å…¥æœ€åä¸€ä½ // è¿™é‡Œå¦‚æœå¼€å§‹èµ·äº†éšæœºæ€§ï¼Œé‚£ä¹ˆä¼šæŠŠbatché¡ºåºæ‰“ä¹± if randomizeScheduler { for i := uint32(1); i \u0026lt;= n; i++ { j := fastrandn(i + 1) // fastrand() % (i+1) batch[i], batch[j] = batch[j], batch[i] } } // Link the goroutines. // æŠŠbatchä¸­çš„æ‰€æœ‰Gå½¢æˆä¸€ä¸ªé“¾è¡¨é“¾æ¥èµ·æ¥ for i := uint32(0); i \u0026lt; n; i++ { batch[i].schedlink.set(batch[i+1]) } // æ˜¯ä¸€ä¸ªåŒå‘é“¾è¡¨ï¼Œheadå’Œtailåˆ†åˆ«è¡¨ç¤ºæ­£åºå’Œå€’å™ var q gQueue q.head.set(batch[0]) // æŠŠbatch[0]æŒ‡å‘q.head q.tail.set(batch[n]) // æŠŠbatch[n]æŒ‡å‘q.tail // Now put the batch on global queue. // ç°åœ¨å°†batchæ”¾åˆ°å…¨å±€é˜Ÿåˆ—ä¸­ã€‚ lock(\u0026amp;sched.lock) // è·å– sched ä¸Šçš„ runtime.mutex // æŠŠè®¾ç½®å¥½çš„Gé“¾è¡¨é“¾æ¥æ‹¿åˆ°shced.runqä¸Šå» globrunqputbatch(\u0026amp;q, int32(n+1)) unlock(\u0026amp;sched.lock) // è§£é” return true } globrunqputbatch() æŠŠè®¾ç½®å¥½çš„Gé“¾è¡¨é“¾æ¥æ‹¿åˆ°shced.runqä¸Šå» å°†ä¸€æ‰¹å¯è¿è¡Œçš„ goroutines æ”¾åˆ°å…¨å±€å¯è¿è¡Œé˜Ÿåˆ—ä¸­ã€‚æ¸…é™¤ *batchã€‚ sched.lock å¿…é¡»è¢«æŒæœ‰ã€‚. å¯èƒ½åœ¨STWæœŸé—´è¿è¡Œï¼Œå› æ­¤ä¸å…è®¸å†™å…¥éšœç¢ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // Put a batch of runnable goroutines on the global runnable queue. // This clears *batch. // sched.lock must be held. // May run during STW, so write barriers are not allowed. // //go:nowritebarrierrec func globrunqputbatch(batch *gQueue, n int32) { // åˆ¤æ–­ sched.lock é”æ˜¯å¦æŒæœ‰ assertLockHeld(\u0026amp;sched.lock) // æŠŠè®¾ç½®å¥½çš„Gé“¾è¡¨é“¾æ¥åˆ°sched.runqä¸Šå» sched.runq.pushBackAll(*batch) sched.runqsize += n // æŠŠå…¨å±€é“¾è¡¨æ€»æ•°é‡åŠ ä¸Šn *batch = gQueue{} // æ¸…ç©ºè¿™ä¸ªbatchï¼Œå‡è½»GCå‹åŠ› } v, ok := \u0026lt;-c ç¼–è¯‘åæ˜¯é€šè¿‡è°ƒç”¨ chanrecv2 å‡½æ•°ã€‚ okï¼štrue.ç¡®å®ä»channelä¸­æ¥æ”¶çš„å€¼ï¼ˆä¸æ˜¯å› ä¸ºchannelå…³é—­è€Œå¾—åˆ°çš„é›¶å€¼ï¼‰ã€‚false.å› ä¸ºchannelå…³é—­è€Œè¿”å›çš„é›¶å€¼ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 // é€šè¿‡ç¼–è¯‘åï¼š // // if v, ok := \u0026lt;-c; ok { // ... foo // } // // as // // if _, ok = chanrecv2(c, \u0026amp;v); ok { // ... foo // } //go:nosplit func chanrecv2(c *hchan, elem unsafe.Pointer) (received bool) { // 1. (_, true)ï¼šæ•°æ®äº¤æ¢æˆåŠŸï¼Œå¾—åˆ°å¯¹åº”äº¤æ¢çš„æ•°æ®ã€‚ // 2. (_, false)ï¼šå› closeå¯¼è‡´è·å–åˆ°äº†é›¶å€¼æ•°æ®ã€‚ _, received = chanrecv(c, elem, true) return } gopark() å°†å½“å‰ä¾‹ç¨‹ç½®äºç­‰å¾…çŠ¶æ€å¹¶è°ƒç”¨ç³»ç»Ÿå †æ ˆä¸Šçš„ unlockã€‚ å¦‚æœ unlock è¿”å› falseï¼Œåˆ™ç»§ç»­æ‰§è¡Œè¯¥ goroutineã€‚ unlockf ä¸èƒ½è®¿é—®è¿™ä¸ª G çš„å †æ ˆï¼Œå› ä¸ºå®ƒå¯èƒ½åœ¨è°ƒç”¨ gopark å’Œè°ƒç”¨ unlockf ä¹‹é—´ç§»åŠ¨ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 // Puts the current goroutine into a waiting state and calls unlockf on the // system stack. // // If unlockf returns false, the goroutine is resumed. // // unlockf must not access this G\u0026#39;s stack, as it may be moved between // the call to gopark and the call to unlockf. // // Note that because unlockf is called after putting the G into a waiting // state, the G may have already been readied by the time unlockf is called // unless there is external synchronization preventing the G from being // readied. If unlockf returns false, it must guarantee that the G cannot be // externally readied. // // Reason explains why the goroutine has been parked. It is displayed in stack // traces and heap dumps. Reasons should be unique and descriptive. Do not // re-use reasons, add new ones. func gopark(unlockf func(*g, unsafe.Pointer) bool, lock unsafe.Pointer, reason waitReason, traceEv byte, traceskip int) { // const waitReasonSleep = 19 // ç­‰å¾…åŸå› ä¸æ˜¯å› ä¸ºsleepæ—¶ï¼ŒæŒ‰éœ€è°ƒç”¨checkTimeouts()ï¼Œæ£€æŸ¥timerã€‚ if reason != waitReasonSleep { // timeouts å¯èƒ½ä¼šåœ¨ä¸¤ä¸ªgoroutineä½¿è°ƒåº¦ç¨‹åºç¹å¿™æ—¶è¿‡æœŸã€‚ // æ£€æŸ¥ p.timers åœ¨è°ƒåº¦å¾ªç¯æ—¶æˆ– goroutine è¢«è°ƒç¦»CPU æˆ– sysmon ç›‘æ§çº¿ç¨‹ä¸­éƒ½ä¼šè½®è¯¢æŸ¥çœ‹ã€‚ checkTimeouts() // timeouts may expire while two goroutines keep the scheduler busy } mp := acquirem() gp := mp.curg // å½“å‰gp status := readgstatus(gp) // è·å–çŠ¶æ€ if status != _Grunning \u0026amp;\u0026amp; status != _Gscanrunning { throw(\u0026#34;gopark: bad g status\u0026#34;) } mp.waitlock = lock // ç­‰å¾…çš„é”ï¼Œunlockfçš„ç¬¬äºŒä¸ªå‚æ•° mp.waitunlockf = unlockf// è°ƒç¦»å‰éœ€è¦æ‰§è¡Œçš„é—­åŒ… gp.waitreason = reason mp.waittraceev = traceEv mp.waittraceskip = traceskip releasem(mp) // can\u0026#39;t do anything that might move the G between Ms here. mcall(park_m) // mcallä¿å­˜ç°åœºå¹¶åˆ‡æ¢g0è°ƒç”¨park_må‡½æ•°ã€‚ } park_m() è¯¥å‡½æ•°åœ¨g0ä¸Šã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 // park continuation on g0. func park_m(gp *g) { mp := getg().m if trace.enabled { traceGoPark(mp.waittraceev, mp.waittraceskip) } // N.B. Not using casGToWaiting here because the waitreason is // set by park_m\u0026#39;s caller. casgstatus(gp, _Grunning, _Gwaiting) // åˆ‡æ¢gpçš„çŠ¶æ€ dropg() // è§£é™¤mä¸gpçš„ç»‘å®š if fn := mp.waitunlockf; fn != nil { ok := fn(gp, mp.waitlock) // è°ƒç”¨waitunlockf mp.waitunlockf = nil mp.waitlock = nil // è¿”å›falseæ—¶ï¼Œå†æ¬¡è¿è¡Œgp if !ok { if trace.enabled { traceGoUnpark(gp, 2) } casgstatus(gp, _Gwaiting, _Grunnable) execute(gp, true) // Schedule it back, never returns. } } schedule() // è°ƒåº¦å¾ªç¯ } close() å…³é—­ hchanã€‚ å‡ ç§å…³é—­ channel çš„æƒ…å†µï¼š close å…³é—­æ—¶ï¼Œsendq ä¸Šæœ‰ç­‰å¾…çš„ goroutineï¼Œä¼š panicã€‚ã€\u0026ldquo;panic: send on closed channel\u0026rdquo;ã€‘ã€‚ close å…³é—­æ—¶ï¼Œå†æœ‰ send æ“ä½œï¼Œä¼š panicã€‚ã€\u0026ldquo;panic: send on closed channel\u0026rdquo;ã€‘ã€‚ close å…³é—­æ—¶ï¼Œbuf ä¸­æœ‰æ•°æ®ï¼Œä¸ä¼š panicï¼Œrecv å¯ä»¥è¯»å–å®ƒä»¬ã€‚ å‘ nil çš„ channelï¼Œsend æˆ– recv æ—¶å½“å‰ goroutine ä¼španicã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 func closechan(c *hchan) { // 1) nil çš„ chan æ˜¯ä¸å…è®¸è¢« close çš„ if c == nil {\tpanic(plainError(\u0026#34;close of nil channel\u0026#34;)) } lock(\u0026amp;c.lock) // å°è¯•è·å– runtime.mutex // 2) å·²ç»å…³é—­çš„ chan ä¸èƒ½å†æ¬¡å…³é—­ if c.closed != 0 {\tunlock(\u0026amp;c.lock) panic(plainError(\u0026#34;close of closed channel\u0026#34;)) } if raceenabled { callerpc := getcallerpc() racewritepc(c.raceaddr(), callerpc, abi.FuncPCABIInternal(closechan)) racerelease(c.raceaddr()) } // 3) è·å–åˆ°äº’æ–¥é”åé¦–å…ˆæ ‡è®°closedå­—æ®µ c.closed = 1 // æ ‡è®°chançŠ¶æ€ä¸ºå…³é—­ 0.æœªå…³é—­ 1.å·²å…³é—­ // gListæ˜¯ä¸€ä¸ªgoroutineçš„é“¾è¡¨ // å½“å‰è¦å…³é—­çš„cè¿˜æœªå¤„ç†çš„goroutine var glist gList // 4) å¤„ç† recvq ä¸Šçš„ goroutine // release all readers for { // å¦‚æœåŒä¸€ä¸ªgoroutineåœ¨å¤šä¸ªchannelä¸Šæ—¶ï¼ˆè¿™ç§æƒ…å†µå‘ç”Ÿåœ¨goselectæ—¶ï¼‰ // dequeue() å‡½æ•°æœ‰ç›¸å…³çš„æ’é‡ï¼ŒCASæ“ä½œã€‚ sg := c.recvq.dequeue() if sg == nil { break } if sg.elem != nil { typedmemclr(c.elemtype, sg.elem) sg.elem = nil } if sg.releasetime != 0 { sg.releasetime = cputicks() } gp := sg.g // ä¸»è¦ç”¨ä¸ select è¯­å¥å”¤é†’åä½¿ç”¨ã€‚ gp.param = unsafe.Pointer(sg) // g.param = *sudog sg.success = false if raceenabled { raceacquireg(gp, c.raceaddr()) } glist.push(gp) } // 5) å¤„ç† sendq ä¸Šçš„ goroutineï¼Œè¿™äº›goroutineå¾—åˆ°è¿è¡Œåä¼š panicã€‚ // å› ä¸ºä¸èƒ½å‘closeçš„channelæœ‰sendæ“ä½œï¼Œå…¶ä¸­ä¸€ç§æƒ…å†µä½“ç°åœ¨è¿™é‡Œã€‚ // release all writers (they will panic) for { sg := c.sendq.dequeue() if sg == nil { break } sg.elem = nil if sg.releasetime != 0 { sg.releasetime = cputicks() } gp := sg.g // ä¸»è¦ç”¨ä¸ select è¯­å¥å”¤é†’åä½¿ç”¨ã€‚ gp.param = unsafe.Pointer(sg) // g.param = *sudog sg.success = false if raceenabled { raceacquireg(gp, c.raceaddr()) } glist.push(gp) } unlock(\u0026amp;c.lock) // 6) å°†è¿™äº› goroutine æ”¾å›ç­‰å¾…é˜Ÿåˆ—ä¸­ // Ready all Gs now that we\u0026#39;ve dropped the channel lock. for !glist.empty() { gp := glist.pop() gp.schedlink = 0 // å°†gpæ”¾å…¥æœ¬åœ°Pçš„é˜Ÿåˆ—ä¸­ goready(gp, 3) } } type guintptr uintptr 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 // A guintptr holds a goroutine pointer, but typed as a uintptr // to bypass write barriers. It is used in the Gobuf goroutine state // and in scheduling lists that are manipulated without a P. // // The Gobuf.g goroutine pointer is almost always updated by assembly code. // In one of the few places it is updated by Go code - func save - it must be // treated as a uintptr to avoid a write barrier being emitted at a bad time. // Instead of figuring out how to emit the write barriers missing in the // assembly manipulation, we change the type of the field to uintptr, // so that it does not require write barriers at all. // // Goroutine structs are published in the allg list and never freed. // That will keep the goroutine structs from being collected. // There is never a time that Gobuf.g\u0026#39;s contain the only references // to a goroutine: the publishing of the goroutine in allg comes first. // Goroutine pointers are also kept in non-GC-visible places like TLS, // so I can\u0026#39;t see them ever moving. If we did want to start moving data // in the GC, we\u0026#39;d need to allocate the goroutine structs from an // alternate arena. Using guintptr doesn\u0026#39;t make that problem any worse. // Note that pollDesc.rg, pollDesc.wg also store g in uintptr form, // so they would need to be updated too if g\u0026#39;s start moving. type guintptr uintptr //go:nosplit func (gp guintptr) ptr() *g { return (*g)(unsafe.Pointer(gp)) } //go:nosplit func (gp *guintptr) set(g *g) { *gp = guintptr(unsafe.Pointer(g)) } //go:nosplit func (gp *guintptr) cas(old, new guintptr) bool { return atomic.Casuintptr((*uintptr)(unsafe.Pointer(gp)), uintptr(old), uintptr(new)) } type gList struct 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 // A gList is a list of Gs linked through g.schedlink. A G can only be // on one gQueue or gList at a time. type gList struct { head guintptr } // empty reports whether l is empty. func (l *gList) empty() bool { return l.head == 0 } // push adds gp to the head of l. func (l *gList) push(gp *g) { gp.schedlink = l.head l.head.set(gp) } // pushAll prepends all Gs in q to l. func (l *gList) pushAll(q gQueue) { if !q.empty() { q.tail.ptr().schedlink = l.head l.head = q.head } } // pop removes and returns the head of l. If l is empty, it returns nil. func (l *gList) pop() *g { gp := l.head.ptr() if gp != nil { l.head = gp.schedlink } return gp } len() è·å– chan çš„å…ƒç´ ä¸ªæ•°ã€‚ï¼ˆè·å–çš„æ˜¯ç¼“å­˜åŒºçš„ä¸ªæ•°ï¼Œæ²¡æœ‰æŒ‚åœ¨é“¾è¡¨ä¸­çš„æ•°é‡ï¼‰ 1 2 3 4 5 6 7 //go:linkname reflect_chanlen reflect.chanlen func reflect_chanlen(c *hchan) int { if c == nil { return 0 } return int(c.qcount) } 1 2 3 4 5 6 7 //go:linkname reflectlite_chanlen internal/reflectlite.chanlen func reflectlite_chanlen(c *hchan) int { if c == nil { return 0 } return int(c.qcount) } cap() è¿”å›å€¼å’Œlen()å‡½æ•°ä¸€è‡´ã€‚ 1 2 3 4 5 6 7 //go:linkname reflect_chancap reflect.chancap func reflect_chancap(c *hchan) int { if c == nil { return 0 } return int(c.dataqsiz) } select default ä»¥ä¸‹æ˜¯å­˜åœ¨ default é»˜è®¤åˆ†æ”¯æƒ…å†µã€‚æ„æ€ç±»ä¼¼äº tryLock å‡½æ•°ï¼Œå°è¯•ä¸€æ¬¡ã€‚ ä»¥ä¸‹åªæ˜¯ç‰¹ä¾‹ï¼Œç¼–è¯‘å™¨ä¸é‡‡ç”¨ goselect() å‡½æ•°æ—¶ã€‚éƒ½æ˜¯ select {case: default:} è¿™ç§å½¢å¼ã€‚ select ä¸­ c \u0026lt;- v 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 // compiler implements // //\tselect { //\tcase c \u0026lt;- v: //\t... foo //\tdefault: //\t... bar //\t} // // as // //\tif selectnbsend(c, v) { //\t... foo //\t} else { //\t... bar //\t} func selectnbsend(c *hchan, elem unsafe.Pointer) (selected bool) { // true. æ•°æ®sendå®Œæˆã€‚ // false. è¡¨ç¤ºç›®å‰ä¸èƒ½å‘é€ï¼Œå› ä¸ºä¸æƒ³é˜»å¡(blockä¸ºfalse)è€Œè¿”å›ã€‚ // falseåªåœ¨è¿™é‡Œè¢«ä¼ å…¥ä½¿ç”¨ã€‚ return chansend(c, elem, false, getcallerpc()) } éªŒè¯ä¸Šé¢ä»£ç ã€‚ 1 2 3 4 5 6 7 8 9 10 11 func chanTs() { ch := make(chan int) a, b := 1, 2 select { case ch \u0026lt;- a: a = b default: b = a } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 TEXT main.chanTs(SB) G:/workspace/hello/main.go func chanTs() { 0x490ae0 493b6610 CMPQ 0x10(R14), SP 0x490ae4 0f8685000000 JBE 0x490b6f 0x490aea 4883ec40 SUBQ $0x40, SP 0x490aee 48896c2438 MOVQ BP, 0x38(SP) 0x490af3 488d6c2438 LEAQ 0x38(SP), BP ch := make(chan int) 0x490af8 488d05419b0000 LEAQ runtime.rodata+30272(SB), AX 0x490aff 31db XORL BX, BX 0x490b01 e8da3cf7ff CALL runtime.makechan(SB) 0x490b06 4889442428 MOVQ AX, 0x28(SP) a, b := 1, 2 0x490b0b 48c744241801000000 MOVQ $0x1, 0x18(SP) 0x490b14 48c744241002000000 MOVQ $0x2, 0x10(SP) case ch \u0026lt;- a: 0x490b1d 488b4c2428 MOVQ 0x28(SP), CX 0x490b22 48894c2430 MOVQ CX, 0x30(SP) 0x490b27 488b4c2418 MOVQ 0x18(SP), CX 0x490b2c 48894c2420 MOVQ CX, 0x20(SP) 0x490b31 488b442430 MOVQ 0x30(SP), AX # å‚æ•° c 0x490b36 488d5c2420 LEAQ 0x20(SP), BX # å‚æ•° elem 0x490b3b 0f1f440000 NOPL 0(AX)(AX*1) 0x490b40 e89b55f7ff CALL runtime.selectnbsend(SB) # è°ƒç”¨selectnbsend 0x490b45 84c0 TESTL AL, AL 0x490b47 7502 JNE 0x490b4b 0x490b49 eb0c JMP 0x490b57 a = b 0x490b4b 488b442410 MOVQ 0x10(SP), AX 0x490b50 4889442418 MOVQ AX, 0x18(SP) 0x490b55 eb0c JMP 0x490b63 b = a 0x490b57 488b442418 MOVQ 0x18(SP), AX 0x490b5c 4889442410 MOVQ AX, 0x10(SP) 0x490b61 eb00 JMP 0x490b63 case ch \u0026lt;- a: 0x490b63 eb00 JMP 0x490b65 } 0x490b65 488b6c2438 MOVQ 0x38(SP), BP 0x490b6a 4883c440 ADDQ $0x40, SP 0x490b6e c3 RET func chanTs() { 0x490b6f e8ecb4fcff CALL runtime.morestack_noctxt.abi0(SB) 0x490b74 e967ffffff JMP main.chanTs(SB) 0x490b79 cc INT $0x3 0x490b7a cc INT $0x3 0x490b7b cc INT $0x3 0x490b7c cc INT $0x3 0x490b7d cc INT $0x3 0x490b7e cc INT $0x3 0x490b7f cc INT $0x3 select ä¸­ v \u0026lt;- c åœ¨ go1.18ç‰ˆæœ¬å‰ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 // compiler implements // // select { // case v = \u0026lt;-c: // ... foo // default: // ... bar // } // // as // // if selectnbrecv(\u0026amp;v, c) { // ... foo // } else { // ... bar // } // func selectnbrecv(elem unsafe.Pointer, c *hchan) (selected bool) { // selectedï¼šè¡¨ç¤ºå½“å‰åˆ†æ”¯æ˜¯å¦é€‰ä¸­ selected, _ = chanrecv(c, elem, false) return } select ä¸­ v, ok = \u0026lt;- c åœ¨ go1.18ç‰ˆæœ¬å‰ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 // compiler implements // // select { // case v, ok = \u0026lt;-c: // ... foo // default: // ... bar // } // // as // // if c != nil \u0026amp;\u0026amp; selectnbrecv2(\u0026amp;v, \u0026amp;ok, c) { // ... foo // } else { // ... bar // } // func selectnbrecv2(elem unsafe.Pointer, received *bool, c *hchan) (selected bool) { // TODO(khr): just return 2 values from this function, now that it is in Go. // selectedï¼šè¡¨ç¤ºå½“å‰åˆ†æ”¯æ˜¯å¦é€‰ä¸­ // receivedï¼šè¡¨ç¤ºå½“å‰æ˜¯å¦å› ä¸º close è€Œå…³é—­çš„é›¶å€¼ selected, *received = chanrecv(c, elem, false) return } å…¶ä»–ç‰ˆæœ¬ åœ¨go1.19.3ä¸­ï¼Œ\u0026lt;-c æœ‰æ‰€æ”¹å˜ä½†æ˜¯åŸç†éƒ½ä¸€æ ·ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 // compiler implements // // select { // case v, ok = \u0026lt;-c: // ... foo // default: // ... bar // } // // as // // if selected, ok = selectnbrecv(\u0026amp;v, c); selected { // ... foo // } else { // ... bar // } func selectnbrecv(elem unsafe.Pointer, c *hchan) (selected, received bool) { // selectedï¼šè¡¨ç¤ºå½“å‰åˆ†æ”¯æ˜¯å¦é€‰ä¸­ // receivedï¼šè¡¨ç¤ºå½“å‰æ˜¯å¦å› ä¸º close è€Œå…³é—­çš„é›¶å€¼ return chanrecv(c, elem, false) } // // select { // case v = \u0026lt;-c: // ... foo // default: // ... bar // } // // as // // if selected, _ = selectnbrecv(\u0026amp;v, c); selected { // ... foo // } else { // ... bar // } éªŒè¯ä¸Šé¢ä»£ç ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 func chanTs() { ch := make(chan int) a, b := 1, 2 var ok bool select { case a, ok = \u0026lt;-ch: b = a if ok { b = 100 } default: a = b } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 TEXT main.chanTs(SB) G:/workspace/hello/main.go func chanTs() { 0x490ae0 493b6610 CMPQ 0x10(R14), SP 0x490ae4 0f86aa000000 JBE 0x490b94 0x490aea 4883ec48 SUBQ $0x48, SP 0x490aee 48896c2440 MOVQ BP, 0x40(SP) 0x490af3 488d6c2440 LEAQ 0x40(SP), BP ch := make(chan int) 0x490af8 488d05419b0000 LEAQ runtime.rodata+30272(SB), AX 0x490aff 31db XORL BX, BX 0x490b01 e8da3cf7ff CALL runtime.makechan(SB) 0x490b06 4889442430 MOVQ AX, 0x30(SP) a, b := 1, 2 0x490b0b 48c744242001000000 MOVQ $0x1, 0x20(SP) 0x490b14 48c744241802000000 MOVQ $0x2, 0x18(SP) var ok bool 0x490b1d c644241500 MOVB $0x0, 0x15(SP) case a, ok = \u0026lt;-ch: 0x490b22 488b5c2430 MOVQ 0x30(SP), BX 0x490b27 48895c2438 MOVQ BX, 0x38(SP) 0x490b2c 488d442428 LEAQ 0x28(SP), AX 0x490b31 e8aa55f7ff CALL runtime.selectnbrecv(SB) # selectnbrecv 0x490b36 88442416 MOVB AL, 0x16(SP) 0x490b3a 885c2417 MOVB BL, 0x17(SP) 0x490b3e 807c241600 CMPB $0x0, 0x16(SP) if ok { 0x490b64 807c241500 CMPB $0x0, 0x15(SP) 0x490b69 7502 JNE 0x490b6d 0x490b6b eb0b JMP 0x490b78 b = 100 0x490b6d 48c744241864000000 MOVQ $0x64, 0x18(SP) 0x490b76 eb02 JMP 0x490b7a if ok { 0x490b78 eb00 JMP 0x490b7a case a, ok = \u0026lt;-ch: 0x490b7a eb0c JMP 0x490b88 a = b 0x490b7c 488b442418 MOVQ 0x18(SP), AX 0x490b81 4889442420 MOVQ AX, 0x20(SP) 0x490b86 eb00 JMP 0x490b88 case a, ok = \u0026lt;-ch: 0x490b88 eb00 JMP 0x490b8a } 0x490b8a 488b6c2440 MOVQ 0x40(SP), BP 0x490b8f 4883c448 ADDQ $0x48, SP 0x490b93 c3 RET func chanTs() { 0x490b94 e8c7b4fcff CALL runtime.morestack_noctxt.abi0(SB) 0x490b99 e942ffffff JMP main.chanTs(SB) 0x490b9e cc INT $0x3 0x490b9f cc INT $0x3 for range å‚è€ƒ æµç¨‹æ§åˆ¶(rangeè¿­ä»£)ã€‚ æ€»ç»“ å‘(æ²¡åœ¨selectå—ä¸­) nil çš„ channel ä¸­ sendã€recv ä¼š panicã€‚åœ¨selectå—ä¸­ nil çš„ channel ä¼šè¢«ä¸¢å¼ƒã€‚ send æ€»æ˜¯å…ˆåˆ¤æ–­çš„ closeï¼ˆpanicï¼‰ï¼Œå†åˆ¤æ–­çš„æ•°æ®èƒ½å¦äº¤æ¢(selectä¸­çš„ä¹Ÿä¸€æ ·)ã€‚recv ä¹Ÿæ˜¯å…ˆåˆ¤æ–­ close ä½†æ˜¯ä¸ä¼španicï¼Œå†åˆ¤æ–­ buf æœ‰æ²¡æ•°æ®ï¼Œæœ‰åˆ™å–å‡ºï¼Œä¸ä¼šå» sendq ä¸­æŸ¥çœ‹æŒ‚èµ·çš„ sudogã€‚ nil çš„ channel ä¸å…è®¸ close æ“ä½œï¼Œä¼š panicã€‚close å·²ç» close çš„ channel ä¼š panicã€‚ å‚è€ƒ https://mp.weixin.qq.com/s/6ZEGtXRGKm2qP5b-rGLyVg https://mp.weixin.qq.com/s?__biz=Mzg5NjIwNzIxNQ==\u0026mid=2247484471\u0026idx=2\u0026sn=49af599b9c3796857459a14d040586fd\u0026scene=19#wechat_redirect ","permalink":"https://heliu.site/posts/golang/channel/theory/","summary":"Golang channelæºç èµ°è¯»ã€‚","title":"Channel(åŸç†)"},{"content":" æ–‡ä»¶ä½ç½®ï¼šgo1.19.3/src/runtime/select.goã€‚ select çš„ä½¿ç”¨æ–‡æ¡£å‚è€ƒ select(ä½¿ç”¨)ã€‚ Constants const debugSelect = false // è°ƒè¯•æ¨¡å¼ Variables 1 2 3 4 5 var ( // å‡½æ•°chansendçš„PCå…¥å£ chansendpc = abi.FuncPCABIInternal(chansend) chanrecvpc = abi.FuncPCABIInternal(chanrecv) ) type scase struct Select case æè¿°ç¬¦ã€‚ç¼–è¯‘å™¨å·²çŸ¥ã€‚ è¿™é‡Œä¿®æ”¹å¿…é¡»å» src/cmd/compile/internal/walk/select.go\u0026rsquo;s scasetypeã€‚ scase ç»“æ„æ˜¯ä¸€ä¸ª case çš„ channel ç»“æ„ã€‚ 1 2 3 4 5 6 7 // Select case descriptor. // Known to compiler. // Changes here must also be made in src/cmd/compile/internal/walk/select.go\u0026#39;s scasetype. type scase struct { c *hchan // chan elem unsafe.Pointer // data element } selectå…³é”®å­— selectgo å®ç°äº† select è¯­å¥ã€‚ cas0 æŒ‡å‘ç±»å‹ä¸º [ncases]scase çš„æ•°ç»„ï¼Œorder0 æŒ‡å‘ç±»å‹ä¸º [2*ncases]uint16 çš„æ•°ç»„ï¼Œå…¶ä¸­ ncases å¿…é¡» \u0026lt;= 65536ã€‚ ä¸¤è€…éƒ½å­˜åœ¨äº goroutine çš„æ ˆä¸­ï¼ˆä¸ç®¡ selectgo ä¸­çš„ä»»ä½•è½¬ä¹‰ï¼‰ã€‚ å¯¹äº race çš„æ„å»ºï¼Œpc0 æŒ‡å‘ä¸€ä¸ªç±»å‹ä¸º [ncases]uintptr çš„æ•°ç»„ï¼ˆä¹Ÿåœ¨è¿™ä¸ªæ ˆä¸Šï¼‰ï¼›å¯¹äºå…¶ä»–æ„å»ºï¼Œå®ƒè¢«è®¾ç½®ä¸ºnilã€‚ selectgo è¿”å›æ‰€é€‰åˆ†æ”¯çš„ç´¢å¼•ï¼Œå®ƒä¸å„è‡ªçš„ select{recv,send,default} è°ƒç”¨çš„é¡ºåºä½ç½®åŒ¹é…ã€‚ æ­¤å¤–ï¼Œå¦‚æœé€‰æ‹©çš„ scase æ˜¯ä¸€ä¸ª receive æ¥æ”¶ç±»å‹æ“ä½œï¼Œå®ƒä¼šæŠ¥å‘Šæ˜¯å¦æ”¶åˆ°äº†å€¼ã€‚ å‚æ•°ï¼š cas0 *scaseï¼šæŒ‡å‘ä¸€ä¸ªæ•°ç»„ï¼Œæ•°ç»„é‡Œè£…çš„æ˜¯selectä¸­æ‰€æœ‰çš„caseåˆ†æ”¯ï¼ŒæŒ‰ç…§sendåœ¨å‰recvåœ¨åçš„é¡ºåºã€‚ä¸åŒ…å«defaultåˆ†æ”¯ã€‚ order0 *uint16ï¼šæŒ‡å‘ä¸€ä¸ªå¤§å°ç­‰äºcaseåˆ†æ”¯æ•°é‡ä¸¤å€çš„uint16æ•°ç»„(2*(nsends+nrecvs))ï¼Œå®é™…ä¸Šæ˜¯ä½œä¸ºä¸¤ä¸ªå¤§å°ç›¸ç­‰çš„æ•°ç»„æ¥ç”¨çš„ã€‚å‰ä¸€ä¸ªç”¨æ¥å¯¹æ‰€æœ‰caseä¸­channelçš„è½®è¯¢è¿›è¡Œä¹±åºï¼Œåä¸€ä¸ªç”¨æ¥å¯¹æ‰€æœ‰caseä¸­channelçš„åŠ é”æ“ä½œè¿›è¡Œæ’åºã€‚ pc0 *uintptrï¼šrace ç›¸å…³ã€‚ nsends intï¼šsend æ“ä½œçš„åˆ†æ”¯æ•°é‡ã€‚ nrecvs intï¼šrecv æ“ä½œçš„åˆ†æ”¯æ•°é‡ã€‚ block boolï¼šè¡¨ç¤ºæ˜¯å¦æƒ³è¦é˜»å¡ç­‰å¾…ã€‚æœ‰defaultåˆ†æ”¯çš„ä¸é˜»å¡ï¼Œåä¹‹åˆ™ä¼šé˜»å¡ã€‚ è¿”å›å€¼ï¼š intï¼šè¡¨ç¤ºæœ€ç»ˆå“ªä¸ªcaseåˆ†æ”¯è¢«æ‰§è¡Œäº†ï¼Œå¯¹åº”case0æ•°ç»„çš„ä¸‹æ ‡ã€‚å¦‚æœå› ä¸ºä¸æƒ³é˜»å¡è€Œè¿”å›ï¼Œåˆ™è¿™ä¸ªå€¼ä¸º-1ã€‚ boolï¼šè¡¨ç¤ºåœ¨å¯¹åº”çš„caseåˆ†æ”¯æ‰§è¡Œçš„æ˜¯recvæ“ä½œæ—¶ï¼Œç”¨æ¥è¡¨ç¤ºå®é™…æ¥æ”¶åˆ°ä¸€ä¸ªå€¼ï¼Œè€Œä¸æ˜¯å› ä¸ºé€šé“å…³é—­å¾—åˆ°çš„é›¶å€¼ã€‚ selectgo() å‡½æ•°æµç¨‹ï¼š å…ˆéšæœºæ‰“ä¹±cas0é›†ç”¨äºè½®è¯¢éå†ã€‚åœ¨æŒ‰ç…§channelåœ°å€å‡åºæ’åºç”¨äºå…¨éƒ¨çš„channelåŠ é”å’Œè§£é”ã€‚ all channel lockåéå†æ‰“ä¹±çš„caseé›†æ£€æŸ¥æ˜¯å¦èƒ½ç«‹å³å®Œæˆï¼Œå¦‚æœå¯ä»¥åˆ™äº¤æ¢æ•°æ®åå…¨éƒ¨è§£é”ã€‚å¦åˆ™åˆ¤æ–­blockæ˜¯å¦éœ€è¦é˜»å¡ã€‚ å…¨éƒ¨éœ€è¦é˜»å¡æ—¶ï¼Œå°†å½“å‰goroutineå°è£…æˆsudogå½¢æˆä¸€ä¸ªé“¾è¡¨æŒ‚åœ¨æ‰€æœ‰çš„channelä¸Šå»ç­‰å¾…ã€‚ å½“å†æ¬¡è§¦å‘æ—¶ï¼Œå…ˆè·å–æ¸…all channel lockï¼Œé™¤æŒ‚åœ¨è¿™äº›ä¸Šé¢çš„sudogï¼Œè§£é”åè¿”å›ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 // selectgo implements the select statement. // // cas0 points to an array of type [ncases]scase, and order0 points to // an array of type [2*ncases]uint16 where ncases must be \u0026lt;= 65536. // Both reside on the goroutine\u0026#39;s stack (regardless of any escaping in // selectgo). // // For race detector builds, pc0 points to an array of type // [ncases]uintptr (also on the stack); for other builds, it\u0026#39;s set to // nil. // // selectgo returns the index of the chosen scase, which matches the // ordinal position of its respective select{recv,send,default} call. // Also, if the chosen scase was a receive operation, it reports whether // a value was received. func selectgo(cas0 *scase, order0 *uint16, pc0 *uintptr, nsends, nrecvs int, block bool) (int, bool) { if debugSelect { print(\u0026#34;select: cas0=\u0026#34;, cas0, \u0026#34;\\n\u0026#34;) } // NOTE: In order to maintain a lean stack size, the number of scases // is capped at 65536. cas1 := (*[1 \u0026lt;\u0026lt; 16]scase)(unsafe.Pointer(cas0)) order1 := (*[1 \u0026lt;\u0026lt; 17]uint16)(unsafe.Pointer(order0)) // send + recv æ•°é‡å’Œ ncases := nsends + nrecvs // cases é›†ï¼ŒæŒ‰ç…§ send + recv é¡ºåºç»„æˆçš„ scases := cas1[:ncases:ncases] // select caseé›† // è½®è¯¢é›†,è®°å½•çš„æ˜¯scasesçš„ä¸‹æ ‡,ç°åœ¨æ˜¯ç©ºçš„ã€‚åé¢ä¹±åºå¡«å…¥ pollorder := order1[:ncases:ncases] // lockorder ç”¨äºæŒ‰channelåœ°å€å‡åºæ’åºï¼Œæ‰€ä»¥æ–¹ä¾¿Lock channelçš„ä½œç”¨ã€‚ lockorder := order1[ncases:][:ncases:ncases] // locké›†,ç°åœ¨æ˜¯ç©ºçš„ // NOTE: pollorder/lockorder\u0026#39;s underlying array was not zero-initialized by compiler. // Even when raceenabled is true, there might be select // statements in packages compiled without -race (e.g., // ensureSigM in runtime/signal_unix.go). var pcs []uintptr if raceenabled \u0026amp;\u0026amp; pc0 != nil { pc1 := (*[1 \u0026lt;\u0026lt; 16]uintptr)(unsafe.Pointer(pc0)) pcs = pc1[:ncases:ncases] } casePC := func(casi int) uintptr { if pcs == nil { return 0 } return pcs[casi] } var t0 int64 if blockprofilerate \u0026gt; 0 { t0 = cputicks() } // The compiler rewrites selects that statically have // only 0 or 1 cases plus default into simpler constructs. // The only way we can end up with such small sel.ncase // values here is for a larger select in which most channels // have been nilled out. The general code handles those // cases correctly, and they are rare enough not to bother // optimizing (and needing to test). // 1) ä¹±åº pollorderï¼Œä¸ºåé¢selectçš„éšæœºæ€§å·¦å‡†å¤‡ // generate permuted order // // ç”Ÿæˆæ’åˆ—çš„ orderã€‚ norder := 0 // æœ‰æ•ˆçš„æ•°é‡ // éšæœºæ‰“ä¹± scases å¹¶æŠŠæ‰“ä¹±ç»“æœä¸‹æ ‡å­˜å…¥ pollorder ä¸­ã€‚ // å‚çœ‹ä¸‹é¢çš„ã€å›¾ä¸€ã€‘ for i := range scases { cas := \u0026amp;scases[i] // Omit cases without channels from the poll and lock orders. // // ä» poll å’Œ lock orders ä¸­çœç•¥æ²¡æœ‰ channels çš„æƒ…å†µã€‚ // nil çš„ channel ä¼šè¢«ä¸¢å¼ƒã€‚ if cas.c == nil { cas.elem = nil // allow GC continue } // ç”Ÿæˆéšæœºæ•° [0, norder + 1] j := fastrandn(uint32(norder + 1)) pollorder[norder] = pollorder[j] pollorder[j] = uint16(i) norder++ } pollorder = pollorder[:norder] // æ­¤æ—¶pollorderæ˜¯æ‰“ä¹±çš„è½®è¯¢é›† lockorder = lockorder[:norder] // 2) lockorder æŒ‰ channel åœ°å€æ’åºï¼Œä¸ºäº†åé¢ all lock å‡†å¤‡ // æŒ‰ç…§åœ°å€å‡åºæ’åºæœ‰åŠ©äºåˆ¤æ–­åŒä¸€ä¸ªchannelåœ¨å¤šä¸ª case ä¸­çš„æƒ…å†µ // sort the cases by Hchan address to get the locking order. // simple heap sort, to guarantee n log n time and constant stack footprint. // // å°†casesæŒ‰ç…§Hchanåœ°å€æ’åºå¾—åˆ° locking orderã€‚ // ç®€å•çš„å †æ’åºï¼Œä¿è¯ n log n æ—¶é—´å’Œæ’å®šçš„æ ˆå ç”¨ã€‚ // å‚çœ‹ä¸‹é¢çš„ã€å›¾ä¸€ã€‘ for i := range lockorder { // æŒ‰ç…§channelåœ°å€æ’åºå¹¶è®°å½•åœ¨lockorderä¸­å‡åºã€‚ j := i // Start with the pollorder to permute cases on the same channel. c := scases[pollorder[i]].c // æŒ‰ç…§ channel çš„åœ°å€æ’åº for j \u0026gt; 0 \u0026amp;\u0026amp; scases[lockorder[(j-1)/2]].c.sortkey() \u0026lt; c.sortkey() { k := (j - 1) / 2 lockorder[j] = lockorder[k] j = k } lockorder[j] = pollorder[i] } for i := len(lockorder) - 1; i \u0026gt;= 0; i-- { o := lockorder[i] c := scases[o].c lockorder[i] = lockorder[0] j := 0 for { k := j*2 + 1 if k \u0026gt;= i { break } if k+1 \u0026lt; i \u0026amp;\u0026amp; scases[lockorder[k]].c.sortkey() \u0026lt; scases[lockorder[k+1]].c.sortkey() { k++ } if c.sortkey() \u0026lt; scases[lockorder[k]].c.sortkey() { lockorder[j] = lockorder[k] j = k continue } break } lockorder[j] = o } if debugSelect { for i := 0; i+1 \u0026lt; len(lockorder); i++ { if scases[lockorder[i]].c.sortkey() \u0026gt; scases[lockorder[i+1]].c.sortkey() { print(\u0026#34;i=\u0026#34;, i, \u0026#34; x=\u0026#34;, lockorder[i], \u0026#34; y=\u0026#34;, lockorder[i+1], \u0026#34;\\n\u0026#34;) throw(\u0026#34;select: broken sort\u0026#34;) } } } // 3) æ‰€æœ‰çš„ sendã€recv è·å– lock // lock all the channels involved in the select // // é”å®šselectä¸­æ¶‰åŠçš„æ‰€æœ‰channelsã€‚ sellock(scases, lockorder) // lock channel var ( gp *g // æ‰¾åˆ°çš„goroutine sg *sudog c *hchan // channel k *scase sglist *sudog sgnext *sudog qp unsafe.Pointer nextp **sudog ) // pass 1 - look for something already waiting // pass 1 - å¯»æ‰¾å·²ç»åœ¨ç­‰å¾…çš„ var casi int var cas *scase\tvar caseSuccess bool var caseReleaseTime int64 = -1 var recvOK bool // è½®åº order for _, casei := range pollorder { casi = int(casei) // é€‰ä¸­ä¸‹æ ‡ cas = \u0026amp;scases[casi] c = cas.c // channel // recv æ“ä½œ if casi \u0026gt;= nsends { // æ³¨æ„ recv å…ˆåˆ¤æ–­çš„èƒ½å¦æˆåŠŸï¼Œå†åˆ¤æ–­çš„ close sg = c.sendq.dequeue() // sendqä¸­å¯»æ‰¾ if sg != nil { goto recv // æ‰¾åˆ°ï¼Œå»recv } // send buf ä¸­æœ‰æ•°æ®ï¼Œå»bufrecv if c.qcount \u0026gt; 0 { goto bufrecv } // å½“å‰recvæ“ä½œæ²¡å®Œæˆï¼Œcloseå…³é—­äº†ï¼Œå»rclose if c.closed != 0 { goto rclose } } else { // send æ“ä½œã€‚æ³¨æ„ send å…ˆåˆ¤æ–­çš„ closeï¼Œå†åˆ¤æ–­èƒ½å¦æˆåŠŸ if raceenabled { racereadpc(c.raceaddr(), casePC(casi), chansendpc) } // channel å·²ç»å…³é—­ if c.closed != 0 { goto sclose } sg = c.recvq.dequeue() // recvqä¸­å¯»æ‰¾ if sg != nil { goto send } // buf ä¸­è¿˜æœ‰å®¹é‡ if c.qcount \u0026lt; c.dataqsiz { goto bufsend } } } // 4) ä»¥ä¸Šéƒ½æ²¡æœ‰èƒ½ç«‹å³å®Œæˆæ—¶ã€‚å¯ä»¥èµ°defaultåˆ†æ”¯ä¸ï¼Ÿ // block ä¸ºfalseæ—¶å­˜åœ¨defaultåˆ†æ”¯ï¼Œä¸æƒ³é˜»å¡ã€‚ // block ä¸ºtrueæ—¶ä¸å­˜åœ¨defaultåˆ†æ”¯ï¼Œé˜»å¡ã€‚ if !block { selunlock(scases, lockorder) // all channel unlock casi = -1 // -1 æ²¡æ‰¾åˆ° goto retc } // 5) æŠŠå½“å‰ goroutine æŒ‚åœ¨æ‰€æœ‰ channel ç­‰å¾…ã€‚ // pass 2 - enqueue on all chans // pass 2 - å¯¹æ‰€æœ‰chanè¿›è¡Œæ’é˜Ÿ gp = getg() // g if gp.waiting != nil { throw(\u0026#34;gp.waiting != nil\u0026#34;) } nextp = \u0026amp;gp.waiting // éå† lockorderï¼Œè¿™é‡Œå½“å‰goroutineè¢«åŠ å…¥åˆ°å¤šä¸ªchannelä¸­ for _, casei := range lockorder { casi = int(casei) cas = \u0026amp;scases[casi] c = cas.c // channel sg := acquireSudog() // å¯»æ‰¾ä¸€ä¸ª*sudog sg.g = gp // è®°å½•å½“å‰goroutine sg.isSelect = true // æ ‡è®°æ˜¯åœ¨select // No stack splits between assigning elem and enqueuing // sg on gp.waiting where copystack can find it. sg.elem = cas.elem sg.releasetime = 0 if t0 != 0 { sg.releasetime = -1 } sg.c = c // Construct waiting list in lock order. // æ‰€æœ‰çš„ sudog ç»„æˆä¸ªé“¾è¡¨ï¼Œæœ‰ä¸¤ä¸ªä½œç”¨ï¼šã€å‚çœ‹ä¸‹é¢å›¾ç‰‡ã€‘ // 1. åç»­selparkcommitå‡½æ•°é€šè¿‡sudog.cè§£é”æ‰€æœ‰çš„ channelã€‚ // 2. å°±ç»ªåç”¨äºåˆ¤æ–­æ˜¯é‚£ä¸ª case å°±ç»ªäº†ã€‚ *nextp = sg // é€šè¿‡ waitlink é“¾æ¥ nextp = \u0026amp;sg.waitlink // åŠ å…¥é˜Ÿåˆ—ä¸­ if casi \u0026lt; nsends { c.sendq.enqueue(sg) } else { c.recvq.enqueue(sg) } } // wait for someone to wake us up // ç­‰ç€æœ‰äººå«é†’æˆ‘ä»¬ gp.param = nil // åœ¨è¢«å”¤é†’æ—¶ä¼šç»™paramå‚æ•°ä¸Šèµ‹å€¼ // Signal to anyone trying to shrink our stack that we\u0026#39;re about // to park on a channel. The window between when this G\u0026#39;s status // changes and when we set gp.activeStackChans is not safe for // stack shrinking. // å‚çœ‹ channel æ–‡æ¡£ atomic.Store8(\u0026amp;gp.parkingOnChan, 1) // parkingOnChan = 1 // æŒ‚èµ·ï¼Œè¿›å…¥è°ƒåº¦å¾ªç¯ã€‚ gopark(selparkcommit, nil, waitReasonSelect, traceEvGoBlockSelect, 1) // 6) å†æ¬¡è¢«å”¤é†’æ—¶ï¼Œ... ... gp.activeStackChans = false // å…¨éƒ¨channelsé”ä½ sellock(scases, lockorder) // all channel lock // æ ‡è®°ä¸º0ï¼Œè¡¨ç¤ºselectå·²å®Œæˆã€‚æ­¤æ—¶æ‰€æœ‰çš„channelséƒ½é”ä½äº†ã€‚ gp.selectDone = 0 // è¢«å”¤é†’çš„goroutineçš„*sudogæ”¾åœ¨paramä¸Š // ç›´æ¥è·å–ä½¿ç”¨ï¼Œå…³äº gp.param çš„éƒ¨åˆ†èµ‹å€¼ä»£ç åœ¨ chan sendå’Œrecvä¸Š sg = (*sudog)(gp.param) gp.param = nil // pass 3 - dequeue from unsuccessful chans // otherwise they stack up on quiet channels // record the successful case, if any. // We singly-linked up the SudoGs in lock order. casi = -1 cas = nil caseSuccess = false // åœ¨ waiting ä¸Šç­‰å¾…ç€å¾ˆå¤šgoroutine sglist = gp.waiting // Clear all elem before unlinking from gp.waiting. // åœ¨ä»gp.waitingæ–­å¼€è¿æ¥å‰æ¸…é™¤æ‰€æœ‰elemã€‚ for sg1 := gp.waiting; sg1 != nil; sg1 = sg1.waitlink { sg1.isSelect = false sg1.elem = nil sg1.c = nil } gp.waiting = nil // 7) éå† lockorderï¼Œå¯»æ‰¾æ˜¯å“ªä¸ªcaseå°±ç»ªäº† for _, casei := range lockorder { k = \u0026amp;scases[casei] if sg == sglist { // æ‰¾åˆ°å°±ç»ªçš„ case // sg has already been dequeued by the G that woke us up. casi = int(casei) // æ‰¾åˆ°å°±ç»ªçš„ case cas = k caseSuccess = sglist.success if sglist.releasetime \u0026gt; 0 { caseReleaseTime = sglist.releasetime } } else { // ç§»é™¤æ²¡å°±ç»ªçš„ c = k.c // ä» channel ä¸­ç§»é™¤ sglist // å› ä¸ºå…¶ä»– channel ä¸­è¿˜æŒ‚èµ·çš„å‘¢ï¼Œè¦ç§»é™¤ if int(casei) \u0026lt; nsends { c.sendq.dequeueSudoG(sglist) } else { c.recvq.dequeueSudoG(sglist) } } sgnext = sglist.waitlink // æ¢ä¸‹ä¸€ä¸ª sglist.waitlink = nil releaseSudog(sglist) // å›æ”¶*sudog sglist = sgnext } if cas == nil { throw(\u0026#34;selectgo: bad wakeup\u0026#34;) } c = cas.c // channel if debugSelect { print(\u0026#34;wait-return: cas0=\u0026#34;, cas0, \u0026#34; c=\u0026#34;, c, \u0026#34; cas=\u0026#34;, cas, \u0026#34; send=\u0026#34;, casi \u0026lt; nsends, \u0026#34;\\n\u0026#34;) } // send æ“ä½œ if casi \u0026lt; nsends { // caseSuccess = trueæˆåŠŸï¼Œfalseç”±äºclosedå‡½æ•°å…³é—­è§¦å‘ã€‚ if !caseSuccess { goto sclose } } else { // recv æ“ä½œ recvOK = caseSuccess } if raceenabled { if casi \u0026lt; nsends { raceReadObjectPC(c.elemtype, cas.elem, casePC(casi), chansendpc) } else if cas.elem != nil { raceWriteObjectPC(c.elemtype, cas.elem, casePC(casi), chanrecvpc) } } if msanenabled { if casi \u0026lt; nsends { msanread(cas.elem, c.elemtype.size) } else if cas.elem != nil { msanwrite(cas.elem, c.elemtype.size) } } if asanenabled { if casi \u0026lt; nsends { asanread(cas.elem, c.elemtype.size) } else if cas.elem != nil { asanwrite(cas.elem, c.elemtype.size) } } selunlock(scases, lockorder) // all channel unlock goto retc bufrecv: // buf ä¸­æœ‰æ•°æ®, recvæ“ä½œã€ep \u0026lt;- cã€‘ // can receive from buffer if raceenabled { if cas.elem != nil { raceWriteObjectPC(c.elemtype, cas.elem, casePC(casi), chanrecvpc) } racenotify(c, c.recvx, nil) } if msanenabled \u0026amp;\u0026amp; cas.elem != nil { msanwrite(cas.elem, c.elemtype.size) } if asanenabled \u0026amp;\u0026amp; cas.elem != nil { asanwrite(cas.elem, c.elemtype.size) } recvOK = true // æ•°æ®äº¤æ¢æˆåŠŸæ ‡è¯† qp = chanbuf(c, c.recvx) if cas.elem != nil { // æ•°æ®ç»™åˆ°ç­‰å¾…çš„å˜é‡ typedmemmove(c.elemtype, cas.elem, qp) } typedmemclr(c.elemtype, qp) // å¤„ç† buf çš„ä¸‹æ ‡ c.recvx++ if c.recvx == c.dataqsiz { c.recvx = 0 } c.qcount-- selunlock(scases, lockorder) // all channel unlock goto retc bufsend: // buf ä¸­è¿˜æœ‰å®¹é‡ï¼Œsendæ“ä½œã€c \u0026lt;- epã€‘ // can send to buffer if raceenabled { racenotify(c, c.sendx, nil) raceReadObjectPC(c.elemtype, cas.elem, casePC(casi), chansendpc) } if msanenabled { msanread(cas.elem, c.elemtype.size) } if asanenabled { asanread(cas.elem, c.elemtype.size) } // æ•°æ®è¿ç§» typedmemmove(c.elemtype, chanbuf(c, c.sendx), cas.elem) // å¤„ç†ä¸‹æ ‡ c.sendx++ if c.sendx == c.dataqsiz { c.sendx = 0 } c.qcount++ selunlock(scases, lockorder) goto retc recv: // sendq ä¸­è·å–åˆ° sg goroutine // can receive from sleeping sender (sg) // æ•°æ®åœ¨æŒ‚èµ·çš„ send çš„ goroutine é‡Œé¢ï¼Œè°ƒç”¨recvå–äº¤æ¢æ•°æ®ã€‚ recv(c, sg, cas.elem, func() { selunlock(scases, lockorder) }, 2) // æ¢å¤å¹¶è§£é”all channel if debugSelect { print(\u0026#34;syncrecv: cas0=\u0026#34;, cas0, \u0026#34; c=\u0026#34;, c, \u0026#34;\\n\u0026#34;) } recvOK = true // recvæ“ä½œæˆåŠŸ goto retc rclose: // channel å·²ç»å…³é—­, recv æ“ä½œæ—¶ // read at end of closed channel selunlock(scases, lockorder) // all channel unlock recvOK = false // channel å…³é—­çš„ recv if cas.elem != nil { // æ¥å—å€¼è®¾ç½®æˆé»˜è®¤é›¶å€¼ï¼Œå› ä¸ºcloseäº† typedmemclr(c.elemtype, cas.elem) } if raceenabled { raceacquire(c.raceaddr()) } goto retc send: // recvq ä¸­æœ‰ç­‰å¾… sg goroutineã€‚ // can send to a sleeping receiver (sg) if raceenabled { raceReadObjectPC(c.elemtype, cas.elem, casePC(casi), chansendpc) } if msanenabled { msanread(cas.elem, c.elemtype.size) } if asanenabled { asanread(cas.elem, c.elemtype.size) } // æ•°æ®åœ¨æŒ‚èµ·çš„ recv çš„ goroutine é‡Œé¢ï¼Œè°ƒç”¨ send å»äº¤æ¢æ•°æ®ã€‚ send(c, sg, cas.elem, func() { selunlock(scases, lockorder) }, 2) if debugSelect { print(\u0026#34;syncsend: cas0=\u0026#34;, cas0, \u0026#34; c=\u0026#34;, c, \u0026#34;\\n\u0026#34;) } goto retc retc: if caseReleaseTime \u0026gt; 0 { blockevent(caseReleaseTime-t0, 1) } return casi, recvOK sclose: // channel å·²ç»å…³é—­ï¼Œsend æ“ä½œæ—¶ // send on closed channel selunlock(scases, lockorder) panic(plainError(\u0026#34;send on closed channel\u0026#34;)) } sellock() æ‰€æœ‰ case çš„ sendã€recv æ“ä½œçš„è·å– hmap.lock äº’æ–¥é”ã€‚ 1 2 3 4 5 6 7 8 9 10 11 func sellock(scases []scase, lockorder []uint16) { var c *hchan // æŒ‰ç…§lockorderéå†ï¼Œå› ä¸ºæ˜¯å‡åºï¼Œæ‰€ä»¥ç›¸åŒçš„channelåœ¨ä¸€èµ· for _, o := range lockorder { c0 := scases[o].c if c0 != c { // å¦‚æœæ˜¯åŒä¸€ä¸ª channel è·³è¿‡å®ƒ c = c0 lock(\u0026amp;c.lock) // mutex lock } } } selunlock() æ‰€æœ‰ case çš„ sendã€recv æ“ä½œçš„é‡Šæ”¾ hmap.lock äº’æ–¥é”ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 func selunlock(scases []scase, lockorder []uint16) { // We must be very careful here to not touch sel after we have unlocked // the last lock, because sel can be freed right after the last unlock. // Consider the following situation. // First M calls runtimeÂ·park() in runtimeÂ·selectgo() passing the sel. // Once runtimeÂ·park() has unlocked the last lock, another M makes // the G that calls select runnable again and schedules it for execution. // When the G runs on another M, it locks all the locks and frees sel. // Now if the first M touches sel, it will access freed memory. for i := len(lockorder) - 1; i \u0026gt;= 0; i-- { c := scases[lockorder[i]].c // å¦‚æœæ˜¯åŒä¸€ä¸ª channel è·³è¿‡å®ƒ if i \u0026gt; 0 \u0026amp;\u0026amp; c == scases[lockorder[i-1]].c { continue // will unlock it on the next iteration } unlock(\u0026amp;c.lock) } } selparkcommit() å½“å‰ select æ²¡æœ‰å°±ç»ª case å¯¼è‡´å½“å‰ goroutine è¢«æŒ‚èµ·å‰æ‰§è¡Œçš„å‡½æ•°ã€‚ func selparkcommit(gp *g, _ unsafe.Pointer) bool { // There are unlocked sudogs that point into gp\u0026#39;s stack. Stack // copying must lock the channels of those sudogs. // Set activeStackChans here instead of before we try parking // because we could self-deadlock in stack growth on a // channel lock. gp.activeStackChans = true // å‚çœ‹channelæ–‡æ¡£ // Mark that it\u0026#39;s safe for stack shrinking to occur now, // because any thread acquiring this G\u0026#39;s stack for shrinking // is guaranteed to observe activeStackChans after this store. atomic.Store8(\u0026amp;gp.parkingOnChan, 0) // å‚çœ‹channelæ–‡æ¡£ // Make sure we unlock after setting activeStackChans and // unsetting parkingOnChan. The moment we unlock any of the // channel locks we risk gp getting readied by a channel operation // and so gp could continue running before everything before the // unlock is visible (even to gp itself). // This must not access gp\u0026#39;s stack (see gopark). In // particular, it must not access the *hselect. That\u0026#39;s okay, // because by the time this is called, gp.waiting has all // channels in lock order. var lastc *hchan // ä¾æ¬¡channelè§£é” for sg := gp.waiting; sg != nil; sg = sg.waitlink { if sg.c != lastc \u0026amp;\u0026amp; lastc != nil { // As soon as we unlock the channel, fields in // any sudog with that channel may change, // including c and waitlink. Since multiple // sudogs may have the same channel, we unlock // only after we\u0026#39;ve passed the last instance // of a channel. unlock(\u0026amp;lastc.lock) } lastc = sg.c } if lastc != nil { unlock(\u0026amp;lastc.lock) } return true } selectgo å‚æ•°ç»„æˆ ä»¥ä¸‹éƒ½æ˜¯ä»‹ç»selectgo()å‚æ•°çš„ç»„æˆï¼Œå¯¹äºç†è§£goselectå¢åŠ å¸®åŠ©ã€‚\ntype runtimeSelect struct runtimeSelect æ˜¯ä¼ é€’ç»™ rselect çš„ä¸€ä¸ª caseã€‚ å¿…é¡»åŒ¹é… ../reflect/value.go:/runtimeSelectã€‚ è¯¥ç»“æ„ç†è§£ä¸ºselect caseä¸­çš„æ‰€æœ‰caseç»„æˆçš„é›†åˆã€‚ 1 2 3 4 5 6 7 8 9 10 11 // A runtimeSelect is a single case passed to rselect. // This must match ../reflect/value.go:/runtimeSelect type runtimeSelect struct { // channel ç±»å‹ï¼ŒåŒ…å«ï¼šsendã€recvã€default ä¸‰ç§ dir selectDir typ unsafe.Pointer // channel type (not used here) // å½“å‰ case æ“ä½œæ‰€å±çš„ channel ch *hchan // channel // send æˆ– recv æ“ä½œæ—¶æ•°æ®çš„åœ°å€ val unsafe.Pointer // ptr to data (SendDir) or ptr to receive buffer (RecvDir) } type selectDir int 1 2 3 4 5 6 7 8 9 // These values must match ../reflect/value.go:/SelectDir. type selectDir int const ( _ selectDir = iota selectSend // case Chan \u0026lt;- Send selectRecv // case \u0026lt;-Chan: selectDefault // default ) reflect_rselect() reflect_rselectæ˜¯selectå…³é”®å­—ç›¸å…³ä»£ç ã€‚ å¯¹äºä»£ç select {}ï¼Œå½“å‰goroutineä¼šä¸¢å¤±å†ä¹Ÿä¸ä¼šè¢«è°ƒåº¦ã€‚ å‚æ•°cases []runtimeSelectï¼šselectçš„æ‰€æœ‰åˆ†æ”¯æ•°æ®ä¿¡æ¯ã€‚ è¿”å›å€¼intï¼šè¿”å›é€‰ä¸­çš„åˆ†æ”¯ä¸‹æ ‡ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 //go:linkname reflect_rselect reflect.rselect func reflect_rselect(cases []runtimeSelect) (int, bool) { // æ²¡æœ‰ case åˆ†æ”¯ // å¯¹äº `select {}` å½“å‰goroutineä¼šç›´æ¥ä¸¢å¤± if len(cases) == 0 { block() // gopark } // len(cases) = send + recv + default sel := make([]scase, len(cases)) // scase é›† orig := make([]int, len(cases)) // selä¸‹æ ‡å’Œcasesçš„å¯¹åº”å…³ç³» // ä¸´æ—¶å˜é‡ç”¨äºä¿å­˜ send å’Œ recv nsends, nrecvs := 0, 0 // send And recv // æ ‡è®°selectä¸­é»˜è®¤defaultåˆ†æ”¯ä¸‹æ ‡ dflt := -1 // é»˜è®¤å€¼-1è¡¨ç¤ºæ²¡æœ‰é»˜è®¤defaultåˆ†æ”¯ // éå†selectçš„æ‰€æœ‰caseï¼ŒåŒ…æ‹¬defaultåˆ†æ”¯ // ä½¿ç”¨ dflt æ ‡è®° default åˆ†æ”¯çš„ä¸‹æ ‡ // sel æ•´ç†å­˜å‚¨ä¸º send + recv // orig å­˜å‚¨selå’Œcasesçš„æ˜ å°„å…³ç³»ã€å‚çœ‹ä¸Šé¢\u0026#34;å›¾ä¸€\u0026#34;ã€‘ for i, rc := range cases { // ä¸´æ—¶å˜é‡ï¼Œç”¨äºè®¡ç®—å½“å‰caseåº”è¯¥æ”¾å…¥çš„ä½ç½® var j int switch rc.dir { // defaultåˆ†æ”¯ case selectDefault: dflt = i continue // send åˆ†æ”¯ï¼šc \u0026lt;- ep case selectSend: // ä»å‰å‘åï¼Œä¾æ¬¡æ”¾å…¥ j = nsends nsends++ // recv åˆ†æ”¯ï¼š\u0026lt;- c case selectRecv: // ä»åå‘å‰ï¼Œä¾æ¬¡æ”¾å…¥ nrecvs++ j = len(cases) - nrecvs } // ä¿å­˜å¯¹åº”å…³ç³» sel[j] = scase{c: rc.ch, elem: rc.val} orig[j] = i } // for range å®Œåï¼Œsel ä¿å­˜ send + recv // orig ä¿å­˜ sel å’Œ cases å¯¹åº”å…³ç³» // Only a default case. // // ä»…ä»…åªæœ‰ä¸€ä¸ª default caseã€‚ // å› ä¸ºå¦‚æœä¸€ä¸ªåˆ†æ”¯éƒ½æ²¡æœ‰ï¼Œæœ€å‰é¢å°±è¿”å›äº† // select {default:} if nsends+nrecvs == 0 { return dflt, false } // Compact sel and orig if necessary. // // å¦‚æœæœ‰å¿…è¦ä½¿sel å’Œ origç´§å‡‘ã€‚ã€å‚çœ‹ä¸Šé¢\u0026#34;å›¾äºŒ\u0026#34;ã€‘ if nsends+nrecvs \u0026lt; len(cases) { // å­˜åœ¨defultæ—¶ copy(sel[nsends:], sel[len(cases)-nrecvs:]) copy(orig[nsends:], orig[len(cases)-nrecvs:]) } // order é•¿åº¦æ˜¯ 2*(nsends+nrecvs) order := make([]uint16, 2*(nsends+nrecvs)) var pc0 *uintptr if raceenabled { pcs := make([]uintptr, nsends+nrecvs) for i := range pcs { selectsetpc(\u0026amp;pcs[i]) } pc0 = \u0026amp;pcs[0] } // \u0026amp;sel[0]ï¼šæ˜¯send+recv // \u0026amp;order[0]ï¼šæ˜¯ç©ºçš„ï¼Œdflt true.ä¸å­˜åœ¨defalutåˆ†æ”¯ false.å­˜åœ¨defaultåˆ†æ”¯ // chosenï¼šè¡¨ç¤ºé€‰æ‹©çš„caseä¸‹æ ‡ï¼Œå¦‚æœä¸º-1æ—¶ä¸ºé»˜è®¤defaultåˆ†æ”¯ // recvOKï¼šè¡¨ç¤ºæ•°æ®æ˜¯å¦äº¤æ¢æˆåŠŸï¼Œtrue.æˆåŠŸ false.å¤±è´¥ // ä»caseåˆ†æ”¯ä¸­é€‰æ‹©ä¸€ä¸ªå°±ç»ªçš„channel chosen, recvOK := selectgo(\u0026amp;sel[0], \u0026amp;order[0], pc0, nsends, nrecvs, dflt == -1) // Translate chosen back to caller\u0026#39;s ordering. // // chosen \u0026lt; 0 é€‰ä¸­é»˜è®¤åˆ†æ”¯ if chosen \u0026lt; 0 { chosen = dflt // é»˜è®¤default } else { chosen = orig[chosen] // case } return chosen, recvOK } block() 1 2 3 4 func block() { // æ³¨æ„ï¼šè¿™é‡Œç¬¬ä¸€å’Œç¬¬äºŒä¸ªå‚æ•°éƒ½ä¸ºnilï¼Œè¡¨æ˜å½“å‰goroutineè¢«ä¸¢å¼ƒäº†ã€‚ gopark(nil, nil, waitReasonSelectNoCases, traceEvGoStop, 1) // forever } æ±‡ç¼–éªŒè¯ 1 2 3 4 5 6 7 8 9 10 11 12 13 package main func main() { ch1 := make(chan int) ch2 := make(chan int) select { case v := \u0026lt;-ch1: println(v) case ch2 \u0026lt;- 10: default: } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 TEXT main.main(SB) /mnt/GoProject/small/tt1.go func main() { 0x459580 4c8d6424c8 LEAQ -0x38(SP), R12 0x459585 4d3b6610 CMPQ 0x10(R14), R12 0x459589 0f8632010000 JBE 0x4596c1 0x45958f 4881ecb8000000 SUBQ $0xb8, SP 0x459596 4889ac24b0000000 MOVQ BP, 0xb0(SP) 0x45959e 488dac24b0000000 LEAQ 0xb0(SP), BP ch1 := make(chan int) 0x4595a6 488d0513490000 LEAQ 0x4913(IP), AX 0x4595ad 31db XORL BX, BX 0x4595af e8eca6faff CALL runtime.makechan(SB) 0x4595b4 4889442468 MOVQ AX, 0x68(SP) ch2 := make(chan int) 0x4595b9 488d0500490000 LEAQ 0x4900(IP), AX 0x4595c0 31db XORL BX, BX 0x4595c2 e8d9a6faff CALL runtime.makechan(SB) 0x4595c7 4889442460 MOVQ AX, 0x60(SP) case v := \u0026lt;-ch1: 0x4595cc 488b4c2468 MOVQ 0x68(SP), CX #CX=\u0026amp;ch1 0x4595d1 48894c2478 MOVQ CX, 0x78(SP) case ch2 \u0026lt;- 10: 0x4595d6 488b4c2460 MOVQ 0x60(SP), CX 0x4595db 48894c2470 MOVQ CX, 0x70(SP) 0x4595e0 48c74424500a000000 MOVQ $0xa, 0x50(SP) select { 0x4595e9 440f11bc2490000000 MOVUPS X15, 0x90(SP) 0x4595f2 440f11bc24a0000000 MOVUPS X15, 0xa0(SP) case v := \u0026lt;-ch1: 0x4595fb 488b4c2478 MOVQ 0x78(SP), CX 0x459600 48898c24a0000000 MOVQ CX, 0xa0(SP) 0x459608 488d4c2458 LEAQ 0x58(SP), CX 0x45960d 48898c24a8000000 MOVQ CX, 0xa8(SP) case ch2 \u0026lt;- 10: 0x459615 488b4c2470 MOVQ 0x70(SP), CX 0x45961a 48898c2490000000 MOVQ CX, 0x90(SP) 0x459622 488d4c2450 LEAQ 0x50(SP), CX 0x459627 48898c2498000000 MOVQ CX, 0x98(SP) select { 0x45962f 488d8c2490000000 LEAQ 0x90(SP), CX 0x459637 48898c2488000000 MOVQ CX, 0x88(SP) 0x45963f 488d5c2448 LEAQ 0x48(SP), BX 0x459644 48899c2480000000 MOVQ BX, 0x80(SP) 0x45964c 488b842488000000 MOVQ 0x88(SP), AX 0x459654 31c9 XORL CX, CX 0x459656 bf01000000 MOVL $0x1, DI 0x45965b 4889fe MOVQ DI, SI 0x45965e 4531c0 XORL R8, R8 0x459661 e89a57feff CALL runtime.selectgo(SB) 0x459666 4889442440 MOVQ AX, 0x40(SP) 0x45966b 885c2437 MOVB BL, 0x37(SP) default: 0x45966f 48837c244000 CMPQ $0x0, 0x40(SP) 0x459675 7c02 JL 0x459679 0x459677 eb02 JMP 0x45967b 0x459679 eb36 JMP 0x4596b1 case ch2 \u0026lt;- 10: 0x45967b 48837c244000 CMPQ $0x0, 0x40(SP) 0x459681 7402 JE 0x459685 0x459683 eb02 JMP 0x459687 0x459685 eb2a JMP 0x4596b1 case v := \u0026lt;-ch1: 0x459687 488b442458 MOVQ 0x58(SP), AX 0x45968c 4889442438 MOVQ AX, 0x38(SP) println(v) 0x459691 e86a5cfdff CALL runtime.printlock(SB) 0x459696 488b442438 MOVQ 0x38(SP), AX 0x45969b 0f1f440000 NOPL 0(AX)(AX*1) 0x4596a0 e85b63fdff CALL runtime.printint(SB) 0x4596a5 e8b65efdff CALL runtime.printnl(SB) 0x4596aa e8d15cfdff CALL runtime.printunlock(SB) case v := \u0026lt;-ch1: 0x4596af eb00 JMP 0x4596b1 } 0x4596b1 488bac24b0000000 MOVQ 0xb0(SP), BP 0x4596b9 4881c4b8000000 ADDQ $0xb8, SP 0x4596c0 c3 RET func main() { 0x4596c1 e8dacbffff CALL runtime.morestack_noctxt.abi0(SB) 0x4596c6 e9b5feffff JMP main.main(SB) æ€»ç»“ select {} ä¼šå¯¼è‡´å½“å‰ goroutine ç›´æ¥ä¸¢å¼ƒï¼Œå†ä¹Ÿä¸ä¼šè¢«è°ƒç”¨ã€‚ select {default:} ç›´æ¥è·³è¿‡ä»€ä¹ˆéƒ½ä¸ä¼šåšã€‚ select case ä¸­å­˜åœ¨ channel ä¸º nilï¼Œè¯¥ case ä¼šè¢«ä¸¢å¼ƒã€‚ select ä¸­ä¹Ÿä¸€æ ·ï¼Œå‘å…³é—­çš„channelï¼Œsendä¼španicï¼Œrecvä¼šå¾—åˆ°é»˜è®¤çš„é›¶å€¼ã€‚ select ä¸­ï¼Œå‘ nil çš„ channelï¼Œsend æˆ– recv ä¸ä¼š panicï¼ˆchannelä¼šè¢«ä¸¢å¼ƒï¼‰ã€‚è€Œæ²¡åœ¨ select ä¸­å…¨éƒ¨éƒ½ä¼š panicã€‚ æ³¨æ„ï¼šåœ¨ select ä¸­ close çš„ channel æƒ…å†µï¼š recv å…ˆåˆ¤æ–­çš„èƒ½å¦æˆåŠŸï¼Œå†åˆ¤æ–­çš„ closeã€‚ send å…ˆåˆ¤æ–­çš„ closeï¼Œå†åˆ¤æ–­èƒ½å¦æˆåŠŸã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 package main import ( \u0026#34;fmt\u0026#34; ) func main() { c := make(chan int, 2) c \u0026lt;- 1 close(c) select { case v, ok := \u0026lt;-c: fmt.Printf(\u0026#34;received %d, ok = %v\\n\u0026#34;, v, ok) default: fmt.Printf(\u0026#34;default\u0026#34;) } // Output: // received 1, ok = true } ","permalink":"https://heliu.site/posts/golang/channel/select/","summary":"Golang selectå…³é”®å­—ä»‹ç»ã€‚","title":"select(åŸç†)"},{"content":"epollæè¿° é€‚ç”¨èŒƒå›´ï¼šè¿æ¥æ•°é‡å¤šï¼Œä½†æ´»åŠ¨è¿æ¥è¾ƒå°‘çš„æƒ…å†µã€‚ epollé«˜æ•ˆçš„å¥¥ç§˜ï¼šepollç²¾å·§çš„ä½¿ç”¨3ä¸ªæ–¹æ³•å®ç°selectæ–¹æ³•è¦åšçš„äº‹ï¼š epoll_create()ï¼šåˆ›å»ºä¸€ä¸ªepollæ–‡ä»¶æè¿°ç¬¦ã€‚ æ‰§è¡Œä¸€æ¬¡epoll_create()å‡½æ•°å°±ä¼šåˆ›å»ºä¸€ä¸ªepollæ± ï¼Œå› æ­¤åˆå§‹åŒ–æ‰§è¡Œä¸€æ¬¡å³å¯ã€‚ epoll_createå‡½æ•°ä¼šè¿”å›ä¸€ä¸ªepollæ–‡ä»¶æè¿°ç¬¦ã€‚ epoll_ctrl()ï¼šæ·»åŠ /ä¿®æ”¹/åˆ é™¤éœ€è¦ä¾¦å¬çš„æ–‡ä»¶æè¿°ç¬¦åŠå…¶äº‹ä»¶ã€‚ ä¸€ä¸ªsocketåªéœ€è°ƒç”¨è¯¥å‡½æ•°ä¸€æ¬¡æ³¨å†Œå½“å‰æ–‡ä»¶æè¿°ç¬¦ã€‚ è¯¥å‡½æ•°æ³¨å†Œæ—¶å¯ä»¥æ·»åŠ å…·ä½“çš„ä¾¦å¬çš„äº‹ä»¶å’Œç”¨æˆ·æ•°æ®ï¼Œå½“å‰äº‹ä»¶è§¦å‘æ—¶å¯ä»¥æ ¹æ®epoll_waitå‡½æ•°è·å–äº‹ä»¶ã€‚ è¿”å›æ³¨å†ŒæˆåŠŸå’Œå¤±è´¥ç»“æœã€‚ epoll_wait()ï¼šæ¥æ”¶å‘ç”Ÿåœ¨è¢«ä¾¦å¬çš„æè¿°ç¬¦ä¸Šçš„ï¼Œç”¨æˆ·æ„Ÿå…´è¶£çš„IOäº‹ä»¶ï¼Œè¿”å›å·²å°±ç»ªçš„äº‹ä»¶é›†ã€‚ æŸ¥è¯¢ç³»ç»Ÿæœ€å¤§æ”¯æŒFDæ•°ç›®ï¼šcat /proc/sys/fs/file-maxã€‚ ç†è§£epollçš„å…³é”®è¦ç´ ï¼šçº¢é»‘æ ‘ã€é“¾è¡¨ã€‚ çº¢é»‘æ ‘ï¼šå­˜å‚¨epollæ‰€ç›‘å¬çš„å¥—æ¥å­—ã€‚epollåœ¨å®ç°ä¸Šé‡‡ç”¨çº¢é»‘æ ‘å»å­˜å‚¨æ‰€æœ‰å¥—æ¥å­—ï¼Œå½“æ·»åŠ æˆ–è€…åˆ é™¤ä¸€ä¸ªå¥—æ¥å­—æ—¶ï¼ˆepoll_ctlï¼‰ï¼Œéƒ½åœ¨çº¢é»‘æ ‘ä¸Šå»å¤„ç†ï¼Œçº¢é»‘æ ‘æœ¬èº«æ’å…¥å’Œåˆ é™¤æ€§èƒ½æ¯”è¾ƒå¥½ï¼Œæ—¶é—´å¤æ‚åº¦O(logN)ã€‚ é€šè¿‡epoll_ctlå‡½æ•°æ·»åŠ è¿›æ¥çš„äº‹ä»¶éƒ½ä¼šè¢«æ”¾åœ¨çº¢é»‘æ ‘çš„æŸä¸ªèŠ‚ç‚¹å†…ï¼Œæ‰€ä»¥é‡å¤æ·»åŠ æ˜¯æ²¡æœ‰ç”¨çš„ã€‚å½“æŠŠäº‹ä»¶æ·»åŠ è¿›æ¥çš„æ—¶å€™æ—¶å€™ä¼šå®Œæˆå…³é”®çš„ä¸€æ­¥ï¼Œé‚£å°±æ˜¯è¯¥äº‹ä»¶éƒ½ä¼šä¸ç›¸åº”çš„è®¾å¤‡ï¼ˆç½‘å¡ï¼‰é©±åŠ¨ç¨‹åºå»ºç«‹å›è°ƒå…³ç³»ï¼Œå½“ç›¸åº”çš„äº‹ä»¶å‘ç”Ÿåï¼Œå°±ä¼šè°ƒç”¨è¿™ä¸ªå›è°ƒå‡½æ•°ï¼Œè¯¥å›è°ƒå‡½æ•°åœ¨å†…æ ¸ä¸­è¢«ç§°ä¸ºï¼šep_poll_callbackï¼Œè¿™ä¸ªå›è°ƒå‡½æ•°å…¶å®å°±æ‰€æŠŠè¿™ä¸ªäº‹ä»¶æ·»åŠ åˆ°rdllistè¿™ä¸ªåŒå‘é“¾è¡¨ä¸­ã€‚ä¸€æ—¦æœ‰äº‹ä»¶å‘ç”Ÿï¼Œepollå°±ä¼šå°†è¯¥äº‹ä»¶æ·»åŠ åˆ°åŒå‘é“¾è¡¨ä¸­ã€‚é‚£ä¹ˆå½“æˆ‘ä»¬è°ƒç”¨epoll_waitæ—¶ï¼Œepoll_waitåªéœ€è¦æ£€æŸ¥rdliståŒå‘é“¾è¡¨ä¸­æ˜¯å¦æœ‰å­˜åœ¨æ³¨å†Œçš„äº‹ä»¶ï¼Œæ•ˆç‡éå¸¸å¯è§‚ã€‚è¿™é‡Œä¹Ÿéœ€è¦å°†å‘ç”Ÿäº†çš„äº‹ä»¶å¤åˆ¶åˆ°ç”¨æˆ·æ€å†…å­˜ä¸­å³å¯ã€‚ä¸­æ–­ç¨‹åºè¿˜æœ‰ä¸€ä¸ªé‡è¦ä½œç”¨æ˜¯å°†é˜»å¡çš„è¿›ç¨‹å”¤é†’èµ·æ¥æ‰§è¡Œã€‚ æ€»ç»“ï¼š çº¢é»‘æ ‘çš„ä½œç”¨ï¼šå½“æœ‰äº‹ä»¶å‘ç”Ÿæ—¶ï¼Œå¯ä»¥å¿«é€Ÿæ ¹æ®fdæŸ¥æ‰¾epitemï¼ˆæ‰¾åˆ°å¾—epitermä¼šç»„æˆé“¾è¡¨ä¼ é€’ç»™ç”¨æˆ·ç©ºé—´åšè¿›ä¸€æ­¥å¤„ç†ï¼‰ï¼Œæ¯”éå†é“¾è¡¨å¿«å¤šäº†ï¼ å†…æ ¸ä¸­é“¾è¡¨é€‚ç”¨çš„åœºæ™¯ï¼šç”¨æ¥åšé˜Ÿåˆ—æˆ–æ ˆï¼Œå­˜å‚¨çš„æ¯ä¸ªèŠ‚ç‚¹éƒ½è¦å¤„ç†ï¼ˆè¯´ç™½äº†å°±æ˜¯éœ€è¦éå†ï¼‰ï¼Œä¸å­˜åœ¨æŸ¥æ‰¾çš„éœ€æ±‚åœºæ™¯ï¼ epolläº‹ä»¶åº•å±‚æœ€ç»ˆæ˜¯ä¸­æ–­è§¦å‘çš„ï¼šå½“ç½‘å¡æ”¶åˆ°æ•°æ®åï¼Œé€šè¿‡ä¸­æ–­é€šçŸ¥æ“ä½œç³»ç»Ÿæ¥å–æ•°æ®ï¼Œè¿›è€Œè§¦å‘epolläº‹ä»¶ï¼ epoll_create() åœ¨epollæ—©æœŸçš„å®ç°ä¸­ï¼Œå¯¹äºç›‘æ§æ–‡ä»¶æè¿°ç¬¦çš„ç»„ç»‡å¹¶ä¸æ˜¯ä½¿ç”¨çº¢é»‘æ ‘ï¼Œè€Œæ˜¯hashè¡¨ã€‚æ‰€ä»¥åœ¨epoll_createçš„å‚æ•°sizeæ²¡æœ‰ä»€ä¹ˆæ„ä¹‰ã€‚ epoll_createï¼šè¯¥å‡½æ•°åˆå§‹åŒ–æ—¶åªæ‰§è¡Œä¸€æ¬¡ã€‚ 1 2 3 4 5 6 7 // åˆ›å»ºä¸€ä¸ªepollå¥æŸ„ // åˆ›å»ºä¸€ä¸ªepollçš„å¥æŸ„ï¼Œsizeç”¨æ¥å‘Šè¯‰å†…æ ¸è¿™ä¸ªç›‘å¬çš„æ•°ç›®ä¸€å…±æœ‰å¤šå¤§ï¼Œåœ¨çº¢é»‘æ ‘ä¸­è¯¥å‚æ•°sizeæ— æ•ˆ int epoll_create(int size);\t// è¿”å›å€¼ï¼š //\tEINVAL å¤§å°ä¸æ˜¯æ­£æ•°ã€‚ // ENFILE å·²è¾¾åˆ°ç³»ç»Ÿå¯¹æ‰“å¼€æ–‡ä»¶æ€»æ•°çš„é™åˆ¶ã€‚ // ENOMEM æ²¡æœ‰è¶³å¤Ÿçš„å†…å­˜æ¥åˆ›å»ºå†…æ ¸å¯¹è±¡ã€‚ epoll_ctl() 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 // æ·»åŠ æ–‡ä»¶æè¿°ç¬¦åˆ°çº¢é»‘æ ‘ä¸­ int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event); // epfdï¼šä¸ºepoll_createåˆ›å»ºçš„fd // opï¼šæŒ‡å®šæ“ä½œç±»å‹ // EPOLL_CTL_ADDï¼š\tå°†ç›®æ ‡æ–‡ä»¶æè¿°ç¬¦fdæ·»åŠ åˆ°epollæè¿°ç¬¦epfdä¸­ï¼Œå¹¶å°†äº‹ä»¶eventä¸fdé“¾æ¥çš„å†…éƒ¨æ–‡ä»¶å…³è”èµ·æ¥ã€‚ // EPOLL_CTL_MODï¼š\tæ›´æ”¹ä¸ç›®æ ‡æ–‡ä»¶æè¿°ç¬¦fdå…³è”çš„äº‹ä»¶eventã€‚ // EPOLL_CTL_DELï¼š\tä»epollæ–‡ä»¶æè¿°ç¬¦epfdä¸­åˆ é™¤ç›®æ ‡æ–‡ä»¶æè¿°ç¬¦fdã€‚è¯¥äº‹ä»¶è¢«å¿½ç•¥ï¼Œå¯ä»¥ä¸ºNULLã€‚ // fdï¼šè¦æ“ä½œçš„æ–‡ä»¶æè¿°ç¬¦ï¼Œä¹Ÿå°±æ˜¯æˆ‘ä»¬è¦åŠ å…¥çš„fdï¼Œå¯ä»¥æ˜¯åˆ›å»ºçš„socketæˆ–å…¶ä»–æ–‡ä»¶å¥æŸ„ã€‚ // eventï¼šæŒ‡å®šäº‹ä»¶ï¼Œå®ƒæ˜¯epoll_eventç»“æ„æŒ‡é’ˆç±»å‹ // epoll_event å®šä¹‰ï¼š // eventsï¼šæè¿°äº‹ä»¶ç±»å‹ï¼Œå’Œpollæ”¯æŒçš„äº‹ä»¶ç±»å‹åŸºæœ¬ç›¸åŒï¼ˆä¸¤ä¸ªé¢å¤–çš„äº‹ä»¶ï¼šEPOLLETå’ŒEPOLLONESHOTï¼Œé«˜æ•ˆè¿ä½œçš„å…³é”®ï¼‰ // eventså¯ä»¥æ˜¯ä»¥ä¸‹å‡ ä¸ªå®çš„é›†åˆï¼š // EPOLLIN ï¼šè¡¨ç¤ºå¯¹åº”çš„æ–‡ä»¶æè¿°ç¬¦å¯ä»¥è¯»ï¼ˆåŒ…æ‹¬å¯¹ç«¯SOCKETæ­£å¸¸å…³é—­ï¼‰ã€‚å…³è”æ–‡ä»¶æè¿°ç¬¦çš„read()æ“ä½œ // EPOLLOUTï¼šè¡¨ç¤ºå¯¹åº”çš„æ–‡ä»¶æè¿° ç¬¦å¯ä»¥å†™ï¼Œå…³è”æ–‡ä»¶æè¿°ç¬¦çš„write()æ“ä½œã€‚ // EPOLLPRIï¼šè¡¨ç¤ºå¯¹åº”çš„æ–‡ä»¶æè¿°ç¬¦æœ‰ç´§æ€¥çš„æ•°æ®å¯è¯»ï¼ˆè¿™é‡Œåº”è¯¥è¡¨ç¤ºæœ‰å¸¦å¤–æ•°æ®åˆ°æ¥ï¼‰ // EPOLLERRï¼šæè¿°ç¬¦äº§ç”Ÿé”™è¯¯æ—¶è§¦å‘ï¼Œé»˜è®¤æ£€æµ‹äº‹ä»¶ // EPOLLHUPï¼šæœ¬ç«¯æè¿°ç¬¦äº§ç”Ÿä¸€ä¸ªæŒ‚æ–­äº‹ä»¶ï¼Œé»˜è®¤ç›‘æµ‹äº‹ä»¶ // EPOLLRDHUPï¼šå¯¹ç«¯æè¿°ç¬¦äº§ç”Ÿä¸€ä¸ªæŒ‚æ–­äº‹ä»¶ // EPOLLETï¼š å°†EPOLLè®¾ä¸ºè¾¹ç¼˜è§¦å‘(Edge Triggered)æ¨¡å¼ï¼Œè¿™æ˜¯ç›¸å¯¹äºæ°´å¹³è§¦å‘(Level Triggered)æ¥è¯´çš„ // EPOLLONESHOTï¼šåªç›‘å¬ä¸€æ¬¡äº‹ä»¶ï¼Œå½“ç›‘å¬å®Œè¿™æ¬¡äº‹ä»¶ä¹‹åï¼Œå¦‚æœè¿˜éœ€è¦ç»§ç»­ç›‘å¬è¿™ä¸ªsocketçš„è¯ï¼Œéœ€è¦å†æ¬¡æŠŠè¿™ä¸ªsocketåŠ å…¥åˆ°EPOLLé˜Ÿåˆ—é‡Œ // dataï¼šå­˜å‚¨ç”¨æˆ·æ•°æ®ï¼Œè¯¥å­—æ®µæ˜¯ä¸€ä¸ªæŒ‡é’ˆç±»å‹å› æ­¤åœ¨waitå‡½æ•°ä¸­æˆ‘ä»¬å¯ä»¥æ‹¿åˆ°è¯¥æ•°æ®è¿›è¡Œç›¸å…³æ“ä½œ // eventæ˜¯æˆ‘ä»¬æ‰€å…³å¿ƒçš„äº‹ä»¶ç±»å‹ï¼Œæ³¨æ„åªæœ‰æˆ‘ä»¬æ³¨å†Œçš„äº‹ä»¶æ‰ä¼šåœ¨epoll_waitè¢«å”¤é†’åä¼ é€’åˆ°ç”¨æˆ·ç©ºé—´ï¼Œå¦åˆ™è™½ç„¶å†…æ ¸å¯ä»¥æ”¶åˆ°ä½†ä¸ä¼šä¼ é€’ epoll_wait() 1 2 3 4 5 6 7 8 9 10 11 // æˆåŠŸæ—¶è¿”å›å°±ç»ªçš„æ–‡ä»¶æè¿°ç¬¦çš„ä¸ªæ•°ï¼Œå¤±è´¥æ—¶è¿”å›-1å¹¶è®¾ç½®errno int epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout); // timeoutï¼šæŒ‡å®šepollçš„è¶…æ—¶æ—¶é—´ï¼Œå•ä½æ˜¯æ¯«ç§’ // å½“timeoutä¸º-1æ—¶ï¼Œepoll_waitè°ƒç”¨å°†æ°¸ä¹…é˜»å¡ï¼Œç›´åˆ°æŸä¸ªäº‹ä»¶å‘ç”Ÿ // å½“timeoutä¸º0æ—¶ï¼Œepoll_waitè°ƒç”¨å°†ç«‹å³è¿”å› // å½“timeoutå¤§äº0æ—¶ï¼Œepoll_waité˜»å¡timeoutäº‹ä»¶åè¿”å› // maxeventsï¼šæŒ‡å®šæœ€å¤šç›‘å¬å¤šå°‘ä¸ªäº‹ä»¶ï¼Œæ„æ€æ˜¯ä¸€æ¬¡è¿”å›æœ€å¤§çš„å°±ç»ªäº‹ä»¶æ•°é‡ // eventsï¼šæ£€æµ‹åˆ°äº‹ä»¶ï¼Œå°†æ‰€æœ‰å°±ç»ªçš„äº‹ä»¶ä»å†…æ ¸äº‹ä»¶è¡¨ä¸­å¤åˆ¶åˆ°å®ƒçš„ç¬¬äºŒä¸ªå‚æ•°eventsæŒ‡å‘çš„æ•°ç»„ä¸­ // è¯¥å‚æ•°è·å–ä»å†…æ ¸å¾—åˆ°çš„äº‹ä»¶çš„é›†åˆï¼Œæ‹¿åˆ°å‰é¢å‡½æ•°æ³¨å†Œçš„ç”¨æˆ·æ•°æ®è¿›è¡Œæ ‡è®° // è¿”å›å€¼intï¼Œè¡¨ç¤ºéœ€è¦å¤„ç†çš„äº‹ä»¶æ•°ç›®ï¼Œå¦‚æœè¿”å›0è¡¨ç¤ºå·²è¶…æ—¶ selectã€pollã€epoll ç³»ç»Ÿè°ƒç”¨ select poll epoll äº‹ä»¶é›†åˆ é€šè¿‡ä¼ å…¥3ä¸ªå‚æ•°å¯è¯»ã€å¯å†™ã€å¼‚å¸¸äº‹ä»¶å†…æ ¸é€šè¿‡å¯¹è¿™äº›å‚æ•°åœ¨çº¿ä¿®æ”¹æ¥åé¦ˆå…¶ä¸­çš„å°±ç»ªäº‹ä»¶ï¼Œè¿™ä½¿å¾—ç”¨æˆ·æ¯æ¬¡è°ƒç”¨selectéƒ½è¦é‡ç½®è¿™3ä¸ªå‚æ•° ç»Ÿä¸€å¤„ç†æ‰€æœ‰äº‹ä»¶ç±»å‹ï¼Œå› æ­¤åªéœ€è¦ä¸€ä¸ªäº‹ä»¶é›†å‚æ•°ã€‚ç”¨æˆ·é€šè¿‡pollfd.eventsä¼ å…¥æ„Ÿå…´è¶£çš„äº‹ä»¶ï¼Œå†…æ ¸é€šè¿‡ä¿®æ”¹pollfd.reventsåé¦ˆå…¶ä¸­å°±ç»ªçš„äº‹ä»¶ å†…æ ¸é€šè¿‡ä¸€ä¸ªäº‹ä»¶è¡¨ç›´æ¥ç®¡ç†ç”¨æˆ·æ„Ÿå…´è¶£çš„æ‰€æœ‰äº‹ä»¶ã€‚å› æ­¤æ¯æ¬¡è°ƒç”¨epoll_waitæ—¶ï¼Œæ— éœ€åå¤ä¼ å…¥ç”¨æˆ·æ„Ÿå…´è¶£çš„äº‹ä»¶ã€‚epoll_waitç³»ç»Ÿè°ƒç”¨çš„å‚æ•°eventsä»…ç”¨æ¥åé¦ˆå°±ç»ªçš„äº‹ä»¶ åº”ç”¨ç¨‹åºç´¢å¼•å°±ç»ªæ–‡ä»¶æè¿°ç¬¦çš„æ—¶é—´å¤æ‚åº¦ O(n) O(n) O(1) æœ€å¤§æ”¯æŒæ–‡ä»¶æè¿°ç¬¦æ•° ä¸€èˆ¬æœ‰æœ€å¤§å€¼é™åˆ¶ 65535 65535 å·¥ä½œæ¨¡å¼ LT LT æ”¯æŒETé«˜æ•ˆæ¨¡å¼ å†…æ ¸å®ç°å’Œå·¥ä½œæ•ˆç‡ é‡‡ç”¨è½®è¯¢æ–¹å¼æ£€æµ‹å°±ç»ªäº‹ä»¶ï¼Œæ—¶é—´å¤æ‚åº¦ï¼šO(n) é‡‡ç”¨è½®è¯¢æ–¹å¼æ£€æµ‹å°±ç»ªäº‹ä»¶ï¼Œæ—¶é—´å¤æ‚åº¦ï¼šO(n) é‡‡ç”¨å›è°ƒæ–¹å¼æ£€æµ‹å°±ç»ªäº‹ä»¶ï¼Œæ—¶é—´å¤æ‚åº¦ï¼šO(1) socket() åˆ›å»ºä¸€ä¸ªsocketï¼Œä¸ºä¸€ä¸ªsocketæ•°æ®ç»“æ„åˆ†é…å­˜å‚¨ç©ºé—´ã€‚ ä¸¤ä¸ªç½‘ç»œç¨‹åºä¹‹é—´çš„ä¸€ä¸ªç½‘ç»œè¿æ¥åŒ…æ‹¬äº”ç§ä¿¡æ¯ï¼šã€é€šä¿¡åè®®ã€‘ã€ã€æœ¬åœ°åè®®åœ°å€ã€‘ã€ã€æœ¬åœ°ä¸»æœºç«¯å£ã€‘ã€ã€è¿œç«¯ä¸»æœºåœ°å€ã€‘å’Œã€è¿œç«¯åè®®ç«¯å£ã€‘ã€‚ è¯¥å‡½æ•°ä¸ä¼šé˜»å¡ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 int socket(int domain, int type, int protocol); // 1) domain å‚æ•°ï¼šäº’è”ç½‘åè®®æ—ï¼Œå¸¸ç”¨çš„æœ‰ä»¥ä¸‹ // AF_INETï¼š è¡¨ç¤ºé€šè¿‡IPv4,é€šä¿¡æ–¹å¼(é€šè¿‡IPv4ç½‘ç»œè¿æ¥èµ·æ¥çš„ä¸»æœº),åº”ç”¨ç¨‹åºé—´çš„é€šä¿¡(32ä½IPv4åœ°å€+16ä½ç«¯å£å·),åœ°å€ç»“æ„(sockaddr_in) // AF_INET6ï¼šè¡¨ç¤ºé€šè¿‡IPv6,é€šä¿¡æ–¹å¼(é€šè¿‡IPv6ç½‘ç»œè¿æ¥èµ·æ¥çš„ä¸»æœº),åº”ç”¨ç¨‹åºé—´çš„é€šä¿¡(128ä½Ipv6åœ°å€+16ä½ç«¯å£å·),åœ°å€ç»“æ„(sockaddr_in6) // AF_UNIXï¼š å†…æ ¸ä¸­,åŒä¸€ä¸»æœºé—´é€šä¿¡,åœ°å€æ ¼å¼(è·¯å¾„å),åœ°å€ç»“æ„(sockaddr_un) // AF_ROUTEï¼šè·¯ç”±å¥—æ¥å­— // AF_KEYï¼šå¯†é’¥å¥—æ¥å­— // AF_UNSPECï¼šæœªæŒ‡å®š // AFï¼šæ˜¯â€œAddress Familyâ€çš„ç®€å†™ï¼ŒINETæ˜¯â€œInetnetâ€çš„ç®€å†™ // 2) type å‚æ•°ï¼šè¡¨ç¤º æ•°æ®ä¼ è¾“æ–¹å¼/å¥—æ¥å­—ç±»å‹ // SOCK_STREAMï¼šè¡¨ç¤ºä½¿ç”¨ \u0026#34;æµæ ¼å¼å¥—æ¥å­—/é¢å‘è¿æ¥çš„å¥—æ¥å­—\u0026#34;ï¼Œæœ‰åºçš„ã€é¢å‘è¿æ¥çš„ã€å¯é çš„åŒå‘é€šä¿¡çš„å­—èŠ‚æµé€šä¿¡ // SOCK_DGRAMï¼š è¡¨ç¤ºä½¿ç”¨ \u0026#34;æ•°æ®æŠ¥å¥—æ¥å­—/æ— è¿æ¥çš„å¥—æ¥å­—\u0026#34;ï¼Œä¸è¿æ¥ã€ä¸å¯é ã€å›ºå®šé•¿åº¦çš„æ•°æ®æŠ¥é€šä¿¡ // SOCK_NONBLOCKï¼šå°†socketå‡½æ•°è¿”å›çš„æ–‡ä»¶æè¿°ç¬¦æŒ‡å®šä¸ºéé˜»å¡ï¼Œå¯ä»¥å’Œä¸Šé¢çš„å®ä½¿ç”¨â€™|â€™è¿ç®—ï¼ˆå¦‚é‡‡ç”¨SOCK_STREAM | SOCK_NONBLOCKè¡¨ç¤ºä½¿ç”¨TCPåè®®ä¸”æ˜¯éé˜»å¡ï¼‰ï¼Œé»˜è®¤æ˜¯é˜»å¡æ¨¡å¼ // SOCK_RDMï¼šè¡¨ç¤ºæƒ³ä½¿ç”¨åŸå§‹ç½‘ç»œé€šä¿¡ï¼ˆå¦‚å½“domainå‚æ•°è®¾ç½®ä¸ºPF_INETæ—¶å°±è¡¨ç¤ºç›´æ¥ä½¿ç”¨TCP/IPåè®®æ—ä¸­çš„ipåè®®ï¼‰ // SOCK_CLOEXECï¼šä¸€æ—¦è¿›ç¨‹execæ‰§è¡Œæ–°ç¨‹åºæ—¶ï¼Œè‡ªåŠ¨å…³é—­socketè¿”å›çš„å¥—æ¥å­—æ–‡ä»¶æè¿°ç¬¦ï¼Œä¹Ÿå°±æ˜¯forkçš„ç¨‹åºä¸èƒ½å…±ç”¨ä¸€ä¸ªsocket // 3) protocol å‚æ•°ï¼šè¡¨ç¤ºä¼ è¾“åè®®ï¼Œå¸¸ç”¨çš„æœ‰ä»¥ä¸‹ // IPPROTO_TCPï¼š è¡¨ç¤ºTCPä¼ è¾“åè®® // IPPTOTO_UDPï¼š è¡¨ç¤ºUDPä¼ è¾“åè®® // IPPROTO_SCTPï¼šè¡¨ç¤ºSCTPä¼ è¾“åè®® // IPPROTO_TIPCï¼šè¡¨ç¤ºTIPCä¼ è¾“åè®® // ä¸€èˆ¬è¯¥å‚æ•°é»˜è®¤ä¼ å…¥0ï¼Œsocketç¨‹åºæ ¹æ®å‰ä¸¤ä¸ªå‚æ•°è‡ªåŠ¨æ¨æ–­ç±»å‹ // è¿”å›å€¼ï¼šæˆåŠŸæ—¶è¿”å›åˆ›å»ºçš„socketçš„æ–‡ä»¶æè¿°ç¬¦;å¤±è´¥æ—¶è¿”å›-1ï¼Œå¹¶è®¾ç½®errnoé”™è¯¯ä¿¡æ¯ // æœ‰äº†åœ°å€ç±»å‹å’Œæ•°æ®ä¼ è¾“æ–¹å¼ï¼Œè¿˜ä¸è¶³ä»¥å†³å®šé‡‡ç”¨å“ªç§åè®®å—ï¼Ÿä¸ºä»€ä¹ˆè¿˜éœ€è¦ç¬¬ä¸‰ä¸ªå‚æ•°å‘¢ï¼Ÿ // 1. ä¸€èˆ¬æƒ…å†µä¸‹æœ‰äº†å‰ä¸¤ä¸ªå‚æ•°å°±å¯ä»¥åˆ›å»ºsocketï¼Œæ“ä½œç³»ç»Ÿä¼šè‡ªåŠ¨æ¨æ¼”å‡ºåè®®ç±»å‹ // 2. é™¤éé‡åˆ°è¿™æ ·çš„æƒ…å†µï¼šæœ‰ä¸¤ç§ä¸åŒçš„åè®®æ”¯æŒåŒä¸€ç§åœ°å€ç±»å‹å’Œæ•°æ®ä¼ è¾“ç±»å‹ // 3. å¦‚æœæˆ‘ä»¬ä¸æŒ‡æ˜ä½¿ç”¨å“ªç§åè®®ï¼Œæ“ä½œç³»ç»Ÿæ˜¯æ²¡åŠæ³•è‡ªåŠ¨æ¨æ¼”çš„ // int tcp_socket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); // æ»¡è¶³å‰é¢ä¸¤ä¸ªå‚æ•°çš„åªæœ‰TCPåè®®ï¼Œå› æ­¤å¯ä»¥å†™æˆå¦‚ä¸‹ // int tcp_socket = socket(AF_INET, SOCK_STREAM, 0); // int udp_socket = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP); // æ»¡è¶³å‰é¢ä¸¤ä¸ªå‚æ•°çš„åªæœ‰UDPåè®®ï¼Œå› æ­¤å¯ä»¥å†™æˆå¦‚ä¸‹ // int udp_socket = socket(AF_INET, SOCK_DGRAM, 0); bind() Bindå‡½æ•°å°†socketä¸æœ¬æœºä¸Šçš„ä¸€ä¸ªç«¯å£ç›¸å…³è”ï¼Œéšåä½ å°±å¯ä»¥åœ¨è¯¥ç«¯å£ç›‘å¬æœåŠ¡è¯·æ±‚ ç»™socketç»‘å®šä¸€ä¸ªåœ°å€ï¼Œè¿™æ ·clientå¯¹è¿™ä¸ªåœ°å€çš„ç›¸åº”æ”¶å‘æ•°æ®å°±èƒ½å’Œsocketç›¸å…³è” æœåŠ¡ç«¯: å¿…é¡»è¦è°ƒç”¨bindè¿›è¡Œç»‘å®šï¼Œbind æ˜¯ç»‘å®šæœ¬åœ°åœ°å€ï¼Œå®ƒä¸è´Ÿè´£å¯¹ç«¯åœ°å€ï¼Œä¸€èˆ¬ç”¨äºæœåŠ¡å™¨ç«¯ï¼Œå®¢æˆ·ç«¯æ˜¯ç³»ç»ŸæŒ‡å®šçš„ã€‚ å®¢æˆ·ç«¯: éå¿…é¡»è°ƒç”¨ï¼Œå¦‚ä¸è°ƒç”¨ï¼Œåˆ™ç³»ç»Ÿè‡ªåŠ¨åˆ†é…ä¸€ä¸ªç«¯å£å’Œæœ¬åœ°åœ°å€æ¥è¿›è¡Œå’Œsocketç»‘å®š socketå‡½æ•°å¹¶æ²¡æœ‰ä¸ºå¥—æ¥å­—ç»‘å®šæœ¬åœ°åœ°å€å’Œç«¯å£å·ï¼Œå¯¹äºæœåŠ¡å™¨ç«¯åˆ™å¿…é¡»æ˜¾æ€§ç»‘å®šåœ°å€å’Œç«¯å£å·ï¼Œbindå‡½æ•°ä¸»è¦æ˜¯æœåŠ¡å™¨ç«¯ä½¿ç”¨ï¼ŒæŠŠä¸€ä¸ªæœ¬åœ°åè®®åœ°å€èµ‹äºˆå¥—æ¥å­— è¯¥å‡½æ•°ä¸ä¼šé˜»å¡ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen); // sockfdï¼šå‚æ•°æ˜¯è°ƒç”¨socketå‡½æ•°è¿”å›çš„socketæè¿°ç¬¦ // addrï¼šå‚æ•°æ˜¯ä¸€ä¸ªæŒ‡å‘åŒ…å«æœ‰æœ¬æœºIPåœ°å€åŠç«¯å£å·ç­‰ä¿¡æ¯çš„sockaddrç±»å‹çš„æŒ‡é’ˆ // æ—©æœŸçš„sockaddr // struct sockaddr { // sa_family_t sa_faily;\t// åœ°å€æ—,AF_XXX // char sa_data[14];\t// å­—ç¬¦æ•°ç»„ï¼Œå­˜æ”¾ipå’Œç«¯å£ // } // åé¢å‡ºç°äº†IPv4å’ŒIPv6ï¼Œå› æ­¤æŠŠsockaddrç»“æ„æ›´è¯¦ç»†ç»†åˆ†,ä¸‹é¢ç»“æ„éƒ½èƒ½ä¸sockaddrè¿›è¡Œè½¬æ¢ // ipv4 // struct sockaddr_in { // __kernel_sa_family_t sin_family; // åœ°å€æ— // __be16 sin_port; // ç«¯å£ // struct in_addr sin_addr; // Internetåœ°å€ // // å ä½,ä»¥æ»¡è¶³sockaddr_inæ‰€å å¤§å°ä¸sockaddrç›¸åŒ // unsigned char __pad[__SOCK_SIZE__ - sizeof(short int) - sizeof(unsigned short int) - sizeof(struct in_addr)]; // } // // Internetåœ°å€ // struct in_addr { // __be32 s_addr; // 32ä¸ºæ— ç¬¦å·æ•´å‹æ•°æ®ï¼Œæ­£å¥½å­˜å‚¨IPåœ°å€ // }; // ipv6 // struct sockaddr_in6 { // unsigned short int sin6_family; // AF_INET6 // __be16 sin6_port; // ä¼ è¾“å±‚ç«¯å£ // __be32 sin6_flowinfo; // IPv6 æµä¿¡æ¯ // struct in6_addr sin6_addr; // IPv6 åœ°å€ // __u32 sin6_scope_id; // scope id (new in RFC2553) // }; // unix addr // #define UNIX_PATH_MAX 108 // struct sockaddr_un { // __kernel_sa_family_t sun_family; // AF_UNIX // char sun_path[UNIX_PATH_MAX]; // }; // addrlenï¼šå‚æ•°æ˜¯åœ°å€å‚æ•°çš„é•¿åº¦sizeof(addr) // è¿”å›å€¼ï¼šæˆåŠŸè¿”å›0ï¼Œå¤±è´¥è¿”å›-1, å¹¶ä¸”è®¾ç½®errno // æ¯”å¦‚ç»‘å®šä¸€ä¸ªipv4åœ°å€ struct sockaddr_in addr; // å®šä¹‰ç»“æ„ä½“å˜é‡ addr.sin_family = AF_INET; // æŒ‡å®šåè®®æ—ä¸ºIPv4 addr.sin_port = htons(5006);// æŒ‡å®šç«¯å£å· addr.sin_addr.s_addr = inet_addr(\u0026#34;192.168.1.10\u0026#34;); // æŒ‡å®šIP // è¿›è¡Œå¥—æ¥å­—æ–‡ä»¶ ip/ç«¯å£çš„ç»‘å®š ret = bind(sockfd, (struct sockaddr*)\u0026amp;addr, sizeof(addr)); // å…¶ä»–ç›¸å…³å‡½æ•° // htonl() æŠŠ32ä½å€¼ä»ä¸»æœºå­—èŠ‚åºè½¬æ¢æˆç½‘ç»œå­—èŠ‚åº // htons() æŠŠ16ä½å€¼ä»ä¸»æœºå­—èŠ‚åºè½¬æ¢æˆç½‘ç»œå­—èŠ‚åº // ntohl() æŠŠ32ä½å€¼ä»ç½‘ç»œå­—èŠ‚åºè½¬æ¢æˆä¸»æœºå­—èŠ‚åº // ntohs() æŠŠ16ä½å€¼ä»ç½‘ç»œå­—èŠ‚åºè½¬æ¢æˆä¸»æœºå­—èŠ‚åº // inet_addr() å­—ç¬¦ä¸²å½¢å¼çš„ip,ç”¨äºå°†ç‚¹åˆ†åè¿›åˆ¶IPè½¬æ¢ä¸ºIPV4çš„32ä½æ— ç¬¦å·æ•´å‹IP listen() ä»…ä¾›æœåŠ¡å™¨ç«¯è°ƒç”¨ï¼ŒæŠŠä¸€ä¸ªæœªè¿æ¥çš„å¥—æ¥å­—è½¬æ¢ä¸ºä¸€ä¸ªè¢«åŠ¨å¥—æ¥å­—ï¼ŒæŒ‡ç¤ºå†…æ ¸åº”è¯¥æ¥å—æŒ‡å‘è¯¥å¥—æ¥å­—çš„è¿æ¥è¯·æ±‚ã€‚ å…¶å†…éƒ¨å®ç°å½’æ ¹ç»“åº•å°±æ˜¯è®¾ç½®sockç»“æ„çš„çŠ¶æ€ï¼Œè®¾ç½®å…¶ä¸ºTCP_LISTENã€‚ è¯¥å‡½æ•°ä¸ä¼šé˜»å¡ã€‚ listenå‡½æ•°æŠŠä¸€ä¸ªæœªè¿æ¥çš„å¥—æ¥å­—è½¬æ¢ä¸ºä¸€ä¸ªè¢«åŠ¨å¥—æ¥å­—ï¼ŒæŒ‡ç¤ºå†…æ ¸åº”æ¥å—æŒ‡å‘è¯¥å¥—æ¥å­—çš„è¿æ¥è¯·æ±‚ï¼Œå…¶å†…éƒ¨å®ç°å½’æ ¹åˆ°åº•å°±æ˜¯è®¾ç½®sockç»“æ„çš„çŠ¶æ€ï¼Œè®¾ç½®å…¶ä¸ºTCP_LISTENã€‚ è¿™ä¸ªå‡½æ•°ä¹Ÿæ˜¯æœåŠ¡å™¨ç«¯è°ƒç”¨ï¼Œå…¶å¥—æ¥å­—çš„åœ°å€ä¿¡æ¯çŠ¶æ€å’Œbindå‡½æ•°æ‰§è¡Œä¹‹åæ˜¯ä¸€æ ·çš„ï¼Œåªç»‘å®šäº†æœ¬åœ°åœ°å€ä¿¡æ¯ï¼Œä¸çŸ¥é“å¯¹ç«¯çš„åœ°å€ä¿¡æ¯ã€‚ 1 2 3 4 5 6 int listen(int sockfd, int backlog); // sockfdï¼šsocket()æ‰€åˆ›å»ºçš„fd // backlogï¼šåœ¨tcpä¸‰æ¬¡æ¡æ‰‹çš„æ—¶å€™ï¼Œç¬¬ä¸€æ¬¡æ¡æ‰‹å‘é€SYN=1ï¼Œserverç«¯æ¥æ”¶åˆ°ä¹‹åï¼Œåœ¨å›å¤äº†Ack=1ä¹‹åï¼Œ // ä¼šæŠŠè¿™ä¸ªè¿˜æœªå®Œæˆ3æ¬¡æ¡æ‰‹çš„è¿æ¥æ”¾å…¥åˆ°ä¸€ä¸ªé˜Ÿåˆ—ä¸­ï¼Œè¿™ä¸ªé˜Ÿåˆ—éœ€è¦æŒ‡å®šä¸€ä¸ªé•¿åº¦ï¼Œè¯¥å‚æ•°å°±æ˜¯ç”¨æ¥æŒ‡å®šè¿™ä¸ªåŠè¿æ¥é˜Ÿåˆ—é•¿åº¦çš„ // åœ¨linuxä¸­è¯¥å‚æ•°é»˜è®¤å€¼ç”±cat /proc/sys/net/ipv4/tcp_max_syn_backlogå†³å®šï¼Œé»˜è®¤1024 accept() è¯¥å‡½æ•°è¿”å›ä¸€ä¸ªå·²å»ºç«‹é“¾æ¥çš„å¯ç”¨ æ•°æ®é€šä¿¡ çš„å¥—æ¥å­— å½“socketæ¨¡å¼è®¾ç½®ä¸ºé˜»å¡ï¼Œacceptå‡½æ•°çš„åŠŸèƒ½æ˜¯é˜»å¡ç­‰å¾…clientå‘èµ·ä¸‰æ¬¡æ¡æ‰‹ï¼Œå½“3æ¬¡æ¡æ‰‹å®Œæˆçš„æ—¶å€™ï¼Œacceptè§£é™¤é˜»å¡ï¼Œå¹¶ä»å…¨è¿æ¥é˜Ÿåˆ—ä¸­å–å‡ºä¸€ä¸ªsocketï¼Œå°±å¯ä»¥å¯¹è¿™ä¸ªsocketè¿æ¥è¿›è¡Œè¯»å†™æ“ä½œ è¯¥å‡½æ•°ä¼šé˜»å¡ç­‰å¾…é“¾æ¥ã€‚ 1 2 3 4 5 int accept(int sockfd, struct sockaddr *cliaddr, socklen_t *addrlen); // è¿”å›å€¼ï¼šéè´Ÿæ•°æˆåŠŸï¼Œè¿”å›ä¸€ä¸ªæ–°çš„fdï¼Œè¿™ä¸ªfdç”¨æ¥å’Œå¯¹ç«¯è¿›è¡Œé€šä¿¡ï¼Œ-1 å‡ºé”™ // sockfdï¼šç›‘å¬åçš„å¥—æ¥å­—ï¼Œä¹Ÿå°±æ˜¯listenå‡½æ•°è¿”å›çš„fd // cliaddrï¼šç”¨æ¥æ¥æ”¶å¯¹ç«¯çš„è¿æ¥åœ°å€ä¿¡æ¯ï¼Œå¦‚æœå¯¹å®¢æˆ·ç«¯ä¿¡æ¯ä¸æ„Ÿå…´è¶£å¯ä»¥æŠŠè¯¥å€¼è®¾ç½®æˆç©ºNULL // addrlenï¼šcliaddrçš„é•¿åº¦ accept4() accept4()æœ‰ç¬¬å››ä¸ªå‚æ•°flagsï¼Œè¿™ä¸ªå‚æ•°å¦‚æœä¸º0ï¼Œå°±è·Ÿaccept()ä¸€æ ·ã€‚ é¢å¤–æ·»åŠ çš„flagså‚æ•°å¯ä»¥ä¸ºæ–°è¿æ¥æè¿°ç¬¦è®¾ç½® O_NONBLOCK | O_CLOEXEC (æ‰§è¡Œexecåå…³é—­)è¿™ä¸¤ä¸ªæ ‡è®°ã€‚ SOCK_NONBLOCK: ä¸ºæ–°æ‰“å¼€çš„æ–‡ä»¶æè¿°ç¬¦è®¾ç½®O_NONBLOCKæ ‡å¿—ä½ï¼Œè¿™è·Ÿç”¨fcntl()è®¾ç½®çš„æ•ˆæœæ˜¯ä¸€æ ·çš„ï¼ŒåŒºåˆ«å°±æ˜¯ç”¨fcntl()çš„è¯éœ€è¦å¤šè°ƒç”¨ä¸ªå‡½æ•°ã€‚ SOCK_CLOEXEC: ä¸ºæ–°æ‰“å¼€çš„æ–‡ä»¶æè¿°ç¬¦è®¾ç½®FD_CLOEXECæ ‡å¿—ä½ï¼Œè¯¥æ ‡å¿—ä½çš„ä½œç”¨æ˜¯åœ¨è¿›ç¨‹ä½¿ç”¨fork()åŠ ä¸Šexecve()çš„æ—¶å€™è‡ªåŠ¨å…³é—­æ‰“å¼€çš„æ–‡ä»¶æè¿°ç¬¦ã€‚ 1 int accept4(int sockfd, struct sockaddr *addr,socklen_t *addrlen, int flags); connect() TCPå®¢æˆ·ç”¨connectå‡½æ•°æ¥å»ºç«‹ä¸TCPæœåŠ¡å™¨çš„è¿æ¥ï¼Œå…¶å®æ˜¯å®¢æˆ·åˆ©ç”¨connectå‡½æ•°å‘æœåŠ¡å™¨å‘å‡ºè¿æ¥è¯·æ±‚ç”¨æˆ·å®¢æˆ·ç«¯ã€‚ 1 2 3 int connect(int sockfd, const struct sockaddr *servaddr, socklen_t addrlen); // sockfdï¼šç”±socketå‡½æ•°è¿”å›çš„å¥—æ¥å­—æè¿°ç¬¦ // ç¬¬äºŒã€ä¸‰ä¸ªå‚æ•°åˆ†åˆ«æ˜¯æŒ‡å‘å¥—æ¥å£åœ°å€ç»“æ„çš„æŒ‡é’ˆå’Œè¯¥ç»“æ„çš„å¤§å°ï¼Œå¥—æ¥å£åœ°å€ç»“æ„å¿…é¡»å«æœ‰æœåŠ¡å™¨çš„IPåœ°å€å’Œç«¯å£å· read() ä»æ‰“å¼€æ–‡ä»¶ä¸­è¯»å–æ•°æ®ã€‚ 1 2 3 4 5 ssize_t read(int fd, void *buf, size_t count); // fdï¼šsocketçš„æ–‡ä»¶æè¿°ç¬¦ // bufï¼šè¯»å–åˆ°çš„å®¹å™¨ // countï¼šbufçš„å¤§å° // è¿”å›å€¼ï¼šä¸ºå®é™…è¯»å–åˆ°çš„å­—èŠ‚æ•°ï¼Œå¦‚æœè¿”å›0ï¼Œè¡¨ç¤ºå·²è¾¾åˆ°æ–‡ä»¶å°¾æˆ–æ˜¯æ— å¯è¯»çš„æ•°æ® ","permalink":"https://heliu.site/posts/golang/netpoll/linux/","summary":"Linux epollå‡½æ•°ç®€ä»‹ã€‚","title":"Linux epoll"},{"content":" ä»¥ä¸‹æ¥è‡ªgo1.19.3/src/runtime/netpoll_epoll.goæ–‡ä»¶ã€‚ æœ¬ç¯‡æ–‡ç« æ˜¯é’ˆå¯¹netpoll_epoll.goæ–‡ä»¶çš„æºç èµ°è¯»ã€‚ variables 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 var ( // epoll æè¿°ç¬¦, epollcreate å‡½æ•°åˆ›å»ºè¿”å›çš„æ–‡ä»¶æè¿°ç¬¦ epfd int32 = -1 // epoll descriptor // ä¿å­˜çš„æ˜¯pipe2()æˆ–pip()å‡½æ•°åˆ›å»ºçš„è¯»å†™æè¿°ç¬¦ï¼Œpip2()æˆ–pip()å‡½æ•°åˆ›å»ºçš„readå’Œwriteï¼Œåªè¦ä»»æ„ä¸€æ–¹æ“ä½œå¦ä¸€æ–¹èƒ½è·å–åˆ°æ•°æ® // netpollBreakRdä¼šè¢«æ³¨å†Œåˆ°epollä¸­ï¼Œå½“å†™æè¿°ç¬¦å‘é‡Œå†™æ•°æ®æ—¶ä¼šè§¦å‘waitç›‘å¬å‡½æ•°è¿”å›å°±ç»ªçš„äº‹ä»¶é›† // è¿™å¯¹è¯»å†™æè¿°ç¬¦çš„ä½œç”¨åœ¨äºé€šä¿¡ï¼Œå½“æœ‰å…¶ä»–åç¨‹åœ¨waité˜»å¡ç­‰å¾…æ—¶ï¼Œå¯ä»¥é€šè¿‡å†™æè¿°ç¬¦å†™å…¥æ•°æ®è®©ç­‰å¾…çš„åç¨‹è¿”å› // ä¸»è¦é’ˆå¯¹ epoll_wait() å‡½æ•°é˜»å¡çš„çº¿ç¨‹ï¼Œé€šè¿‡è¿™é‡Œçš„äº‹ä»¶ä½¿è°ƒç”¨ epoll_wait() å‡½æ•°çš„çº¿ç¨‹é™·å…¥å†…æ ¸è¿”å›ã€‚ // å¯¹äº epoll_wait() çš„ timeout å‚æ•°ä¸º0çš„æƒ…å†µï¼Œè¿™é‡Œçš„äº‹ä»¶ä¼šè¢«å¿½ç•¥ netpollBreakRd, netpollBreakWr uintptr // for netpollBreak // ç”¨äºé¿å…é‡å¤è°ƒç”¨ netpollBreak() // åœ¨å‘netpollBreakWrä¸­å†™å…¥æ•°æ®æ—¶ï¼Œè¯¥å€¼ä¼šä»0å˜æˆ1ï¼Œæ§åˆ¶åªå†™ä¸€æ¬¡æ ‡å¿—ç¬¦å· // è¯¥å‚æ•°æ˜¯åŸå­æ€§çš„ netpollWakeSig uint32 // used to avoid duplicate calls of netpollBreak ) netpollGenericInit() åˆå§‹åŒ–netpollã€‚go1.19.3/src/runtime/netpoll.goæ–‡ä»¶ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 func netpollGenericInit() { // var netpollInited uint32 // æ˜¯å¦å·²åˆå§‹åŒ–epollæ ‡å¿— 0.æœªåˆå§‹åŒ– 1.å·²åˆå§‹åŒ– if atomic.Load(\u0026amp;netpollInited) == 0 { // var netpollInitLock mutex åˆå§‹åŒ– lockInit(\u0026amp;netpollInitLock, lockRankNetpollInit) lock(\u0026amp;netpollInitLock) // è¿™é‡Œéœ€è¦åˆ¤æ–­ netpollInited == 0ï¼›åŸå› åœ¨äºå¯èƒ½å­˜åœ¨å¤šä¸ªåç¨‹å¹¶å‘åœ¨ç­‰å¾…åˆå§‹åŒ–epoll // å½“è¿™äº›åç¨‹è·å–çš„é”æƒé™æ—¶ï¼Œè¿™é‡Œçš„netpollInitedå·²è¢«è®¾ç½®æˆ1äº†ï¼Œå·²ç»è¢«åˆå§‹åŒ–äº† if netpollInited == 0 { netpollinit() // åˆå§‹åŒ–netpoll atomic.Store(\u0026amp;netpollInited, 1)\t// netpollInited } unlock(\u0026amp;netpollInitLock) } } netpollinit() go1.19.3/src/runtime/netpoll_epoll.goã€‚ è°ƒç”¨epollcreateåˆ›å»ºnetpollerã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 func netpollinit() { // epollcreate å‡½æ•°å†…ä¼šè°ƒç”¨ epollcreate1 // _EPOLL_CLOEXECï¼šå½“å‰è¿›ç¨‹forkå‡ºæ¥çš„ä»»ä½•å­è¿›ç¨‹åœ¨æ‰§è¡Œå‰éƒ½ä¼šå…³é—­epollæè¿°ç¬¦ï¼Œä¹Ÿå› æ­¤ï¼Œå­è¿›ç¨‹ä¸èƒ½å¤Ÿè®¿é—®epollå®ä¾‹ epfd = epollcreate1(_EPOLL_CLOEXEC) // å°äº0è¡¨ç¤ºåˆ›å»ºå‡ºé”™ï¼Œå¤§äº0è¡¨ç¤ºè¿”å›çš„åˆ›å»ºåçš„æ–‡ä»¶å¥æŸ„ID if epfd \u0026lt; 0 {\tepfd = epollcreate(1024) if epfd \u0026lt; 0 { println(\u0026#34;runtime: epollcreate failed with\u0026#34;, -epfd) throw(\u0026#34;runtime: netpollinit failed\u0026#34;) } // ç³»ç»Ÿè°ƒç”¨ fcntl è®¾ç½® FD_CLOEXECï¼Œå‚çœ‹ epollcreate1 å‡½æ•°å‚æ•° // fcntlï¼šfd, F_SETFD, FD_CLOEXEC closeonexec(epfd) } // åˆ›å»ºä¸€ä¸ªç”¨äºé€šä¿¡çš„ç®¡é“,è¿”å›è¯»å†™,ä¸»è¦ç”¨äºé‚£äº›ç­‰å¾…åœ¨IOè½®è¯¢ä¸­çš„çº¿ç¨‹é€šä¿¡ // åˆ›å»ºä¸€ä¸ªéé˜»å¡å¼pipeï¼Œç”¨æ¥å”¤é†’é˜»å¡ä¸­çš„ netpollerã€‚ // pipe2(_O_NONBLOCK | _O_CLOEXEC) r, w, errno := nonblockingPipe() // ä¸»è¦ç”¨äºBreakç›¸å…³çš„å‡½æ•°ï¼Œä¸»è¦ç”¨äºç½‘ç»œè½®è¯¢å”¤é†’ä¿¡å· if errno != 0 { println(\u0026#34;runtime: pipe failed with\u0026#34;, -errno) throw(\u0026#34;runtime: pipe failed\u0026#34;) } // epollevent æ˜¯äº‹ä»¶ç±»å‹ // type epollevent struct { //\tevents uint32 // äº‹ä»¶ç±»å‹ //\tdata [8]byte // å­˜å‚¨ç”¨æˆ·æ•°æ®ï¼Œåˆšå¥½æ˜¯ä¸€ä¸ªæŒ‡é’ˆå­˜å‚¨çš„å¤§å°ï¼Œè¯¥æ•°æ®ç”¨æˆ·æ˜¯å¯ä»¥ä¿®æ”¹çš„ // } ev := epollevent{ // æ³¨æ„ï¼šè¿™é‡Œé»˜è®¤æ³¨å†Œçš„æ˜¯æ°´å¹³è§¦å‘ï¼Œå› æ­¤ä¼šä¸€ç›´è§¦å‘ events: _EPOLLIN, // EPOLLIN è¡¨ç¤ºå¯¹åº”çš„æ–‡ä»¶æè¿°ç¬¦å¯ä»¥è¯»ï¼ˆåŒ…æ‹¬å¯¹ç«¯SOCKETæ­£å¸¸å…³é—­ï¼‰ } // var netpollBreakRd uintptr *(**uintptr)(unsafe.Pointer(\u0026amp;ev.data)) = \u0026amp;netpollBreakRd // ev.data = \u0026amp;netpollBreakRd // å°†è¯»å–æ•°æ®çš„æ–‡ä»¶æè¿°ç¬¦åŠ å…¥ç›‘å¬ï¼Œå½“ä½¿ç”¨wå†™æ•°æ®æ—¶ï¼Œè¯¥rä¼šè¢«è§¦å‘ // func epollctl(epfd, op, fd int32, ev *epollevent) int32 // _EPOLL_CTL_ADD å°†ç›®æ ‡æ–‡ä»¶æè¿°ç¬¦fdæ·»åŠ åˆ°epollæè¿°ç¬¦epfdä¸­ï¼Œå¹¶å°†äº‹ä»¶eventä¸fdé“¾æ¥çš„å†…éƒ¨æ–‡ä»¶å…³è”èµ·æ¥ã€‚ errno = epollctl(epfd, _EPOLL_CTL_ADD, r, \u0026amp;ev) // r è¢«æ·»åŠ åˆ°epollä¸­ if errno != 0 { println(\u0026#34;runtime: epollctl failed with\u0026#34;, -errno) throw(\u0026#34;runtime: epollctl failed\u0026#34;) } // netpollBreakRdã€netpollBreakWr æ˜¯éé˜»å¡ç®¡é“ä¸¤ç«¯çš„æ–‡ä»¶æè¿°ç¬¦ï¼Œåˆ†åˆ«è¢«ç”¨ä½œè¯»å–ç«¯å’Œå†™å…¥ç«¯ã€‚ // è¯»å–ç«¯ netpollBreakRd è¢«æ·»åŠ åˆ° epoll ä¸­ç›‘å¬ _EPOLLIN äº‹ä»¶ï¼Œåç»­ä»å†™å…¥ç«¯netpollBreakWr // å†™å…¥æ•°æ®å°±èƒ½å”¤é†’é˜»å¡ä¸­çš„ pollerã€‚ netpollBreakRd = uintptr(r) // netpollBreakRdä¿å­˜pip2çš„read netpollBreakWr = uintptr(w) // netpollBreakRdä¿å­˜pip2çš„write } netpollopen() æŠŠè¦ç›‘å¬çš„æ–‡ä»¶æè¿°ç¬¦fdå’Œä¸ä¹‹å…³è”çš„pollDescç»“æ„æ·»åŠ åˆ°pollerå®ä¾‹ä¸­ã€‚ è¯¥æ–¹æ³•å¯¹äºä¸€ä¸ªsocketåªéœ€è°ƒç”¨ä¸€æ¬¡å³å¯ï¼Œè¡¨ç¤ºæ³¨å†Œfdåˆ°epollä¸­ã€‚ å‚æ•°ï¼š fd uintptrï¼šæ–‡ä»¶æè¿°ç¬¦ã€‚ pd *pollDescï¼šç”¨æˆ·æ•°æ®ã€‚ è¿”å›å€¼ï¼šint32ï¼š0-æ³¨å†ŒæˆåŠŸã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 func netpollopen(fd uintptr, pd *pollDesc) int32 { // type epollevent struct { // events uint32 // äº‹ä»¶ç±»å‹ // data [8]byte // å­˜å‚¨ç”¨æˆ·æ•°æ®ï¼Œåˆšå¥½æ˜¯ä¸€ä¸ªæŒ‡é’ˆå­˜å‚¨çš„å¤§å°ï¼Œè¯¥æ•°æ®ç”¨æˆ·æ˜¯å¯ä»¥ä¿®æ”¹çš„ // } var ev epollevent // EPOLLINï¼šè¡¨ç¤ºå¯¹åº”çš„æ–‡ä»¶æè¿°ç¬¦å¯ä»¥è¯»ï¼ˆåŒ…æ‹¬å¯¹ç«¯SOCKETæ­£å¸¸å…³é—­ï¼‰ // EPOLLOUTï¼šè¡¨ç¤ºå¯¹åº”çš„æ–‡ä»¶æè¿°ç¬¦å¯ä»¥å†™ // EPOLLRDHUPï¼šå¯¹ç«¯æè¿°ç¬¦äº§ç”Ÿä¸€ä¸ªæŒ‚æ–­äº‹ä»¶ï¼Œæ¯”å¦‚æ¥è‡ªå¯¹ç«¯çš„socketæŒ‚æ–­äº‹ä»¶ç­‰ // EPOLLETï¼šå°†EPOLLè®¾ä¸ºè¾¹ç¼˜è§¦å‘(Edge Triggered)æ¨¡å¼ï¼Œè¿™æ˜¯ç›¸å¯¹äºæ°´å¹³è§¦å‘(Level Triggered)æ¥è¯´çš„ // pollDescï¼šç±»å‹çš„æ•°æ®ç»“æ„pdä½œä¸ºä¸fdå…³è”çš„è‡ªå®šæ•°æ®ä¼šè¢«ä¸€åŒæ·»åŠ åˆ°epollä¸­ã€‚ ev.events = _EPOLLIN | _EPOLLOUT | _EPOLLRDHUP | _EPOLLET // epollevent æ˜¯ç”±eventså’Œdataç»„æˆï¼Œdataæ¥è‡ªç”¨æˆ·ç©ºé—´ä¼ å…¥çš„æ•°æ® *(**pollDesc)(unsafe.Pointer(\u0026amp;ev.data)) = pd // ev.data = pd // _EPOLL_CTL_ADD å°†ç›®æ ‡æ–‡ä»¶æè¿°ç¬¦fdæ·»åŠ åˆ°epollæè¿°ç¬¦epfdä¸­ï¼Œå¹¶å°†äº‹ä»¶eventä¸fdé“¾æ¥çš„å†…éƒ¨æ–‡ä»¶å…³è”èµ·æ¥ã€‚ return -epollctl(epfd, _EPOLL_CTL_ADD, int32(fd), \u0026amp;ev) } è§¦å‘æ¨¡å¼LT\\ ETï¼š æ°´å¹³è§¦å‘ï¼šLT å¯¹äºè¯»æ“ä½œï¼Œåªè¦ç¼“å†²å†…å®¹ä¸ä¸ºç©ºï¼ŒLTæ¨¡å¼è¿”å›è¯»å°±ç»ªã€‚ å¯¹äºå†™æ“ä½œï¼Œåªè¦ç¼“å†²åŒºè¿˜ä¸æ»¡ï¼ŒLTæ¨¡å¼ä¼šè¿”å›å†™å°±ç»ªã€‚ æ°´å¹³è§¦å‘æè¿°ï¼š å½“è¢«ç›‘æ§çš„æ–‡ä»¶æè¿°ç¬¦ä¸Šæœ‰å¯è¯»å†™äº‹ä»¶å‘ç”Ÿæ—¶ï¼Œepoll_wait()ä¼šé€šçŸ¥å¤„ç†ç¨‹åºå»è¯»å†™ã€‚ å¦‚æœè¿™æ¬¡æ²¡æœ‰æŠŠæ•°æ®ä¸€æ¬¡æ€§å…¨éƒ¨è¯»å†™å®Œ(å¦‚è¯»å†™ç¼“å†²åŒºå¤ªå°)ï¼Œé‚£ä¹ˆä¸‹æ¬¡è°ƒç”¨ epoll_wait()æ—¶ï¼Œå®ƒè¿˜ä¼šé€šçŸ¥ä½ åœ¨ä¸Šæ²¡è¯»å†™å®Œçš„æ–‡ä»¶æè¿°ç¬¦ä¸Šç»§ç»­è¯»å†™ï¼Œå½“ç„¶å¦‚æœä½ ä¸€ç›´ä¸å»è¯»å†™ï¼Œå®ƒä¼šä¸€ç›´é€šçŸ¥ä½ ã€‚ å¦‚æœç³»ç»Ÿä¸­æœ‰å¤§é‡ä½ ä¸éœ€è¦è¯»å†™çš„å°±ç»ªæ–‡ä»¶æè¿°ç¬¦ï¼Œè€Œå®ƒä»¬æ¯æ¬¡éƒ½ä¼šè¿”å›ï¼Œè¿™æ ·ä¼šå¤§å¤§é™ä½å¤„ç†ç¨‹åºæ£€ç´¢è‡ªå·±å…³å¿ƒçš„å°±ç»ªæ–‡ä»¶æè¿°ç¬¦çš„æ•ˆç‡ã€‚ è¾¹ç¼˜è§¦å‘ï¼šET å¯¹äºè¯»æ“ä½œï¼š å½“ç¼“å†²åŒºç”±ä¸å¯è¯»å˜ä¸ºå¯è¯»çš„æ—¶å€™ï¼Œå³ç¼“å†²åŒºç”±ç©ºå˜ä¸ºä¸ç©ºçš„æ—¶å€™ã€‚ å½“æœ‰æ–°æ•°æ®åˆ°è¾¾æ—¶ï¼Œå³ç¼“å†²åŒºä¸­çš„å¾…è¯»æ•°æ®å˜å¤šçš„æ—¶å€™ã€‚ å½“ç¼“å†²åŒºæœ‰æ•°æ®å¯è¯»ï¼Œä¸”åº”ç”¨è¿›ç¨‹å¯¹ç›¸åº”çš„æè¿°ç¬¦è¿›è¡ŒEPOLL_CTL_MODä¿®æ”¹EPOLLINäº‹ä»¶æ—¶ã€‚ å¯¹äºå†™æ“ä½œï¼š å½“ç¼“å†²åŒºç”±ä¸å¯å†™å˜ä¸ºå¯å†™æ—¶ã€‚ å½“æœ‰æ—§æ•°æ®è¢«å‘é€èµ°ï¼Œå³ç¼“å†²åŒºä¸­çš„å†…å®¹å˜å°‘çš„æ—¶å€™ã€‚ å½“ç¼“å†²åŒºæœ‰ç©ºé—´å¯å†™ï¼Œä¸”åº”ç”¨è¿›ç¨‹å¯¹ç›¸åº”çš„æè¿°ç¬¦è¿›è¡ŒEPOLL_CTL_MODä¿®æ”¹EPOLLOUTäº‹ä»¶æ—¶ã€‚ è¾¹ç¼˜è§¦å‘æè¿°ï¼š å½“è¢«ç›‘æ§çš„æ–‡ä»¶æè¿°ç¬¦ä¸Šæœ‰å¯è¯»å†™äº‹ä»¶å‘ç”Ÿæ—¶ï¼Œepoll_wait()ä¼šé€šçŸ¥å¤„ç†ç¨‹åºå»è¯»å†™ã€‚ å¦‚æœè¿™æ¬¡æ²¡æœ‰æŠŠæ•°æ®å…¨éƒ¨è¯»å†™å®Œ(å¦‚è¯»å†™ç¼“å†²åŒºå¤ªå°)ï¼Œé‚£ä¹ˆä¸‹æ¬¡è°ƒç”¨ epoll_wait()æ—¶ï¼Œå®ƒä¸ä¼šé€šçŸ¥ä½ ï¼Œä¹Ÿå°±æ˜¯å®ƒåªä¼šé€šçŸ¥ä½ ä¸€æ¬¡ï¼Œç›´åˆ°è¯¥æ–‡ä»¶æè¿°ç¬¦ä¸Šå‡ºç°ç¬¬äºŒæ¬¡å¯è¯»å†™äº‹ä»¶æ‰ä¼šé€šçŸ¥ä½ ã€‚ è¿™ç§æ¨¡å¼æ¯”æ°´å¹³è§¦å‘æ•ˆç‡é«˜ï¼Œç³»ç»Ÿä¸ä¼šå……æ–¥å¤§é‡ä½ ä¸å…³å¿ƒçš„å°±ç»ªæ–‡ä»¶æè¿°ç¬¦ã€‚ åœ¨ETæ¨¡å¼ä¸‹ï¼Œç¼“å†²åŒºä»ä¸å¯è¯»å˜æˆå¯è¯»ï¼Œä¼šå”¤é†’åº”ç”¨è¿›ç¨‹ï¼Œç¼“å†²åŒºæ•°æ®å˜å°‘çš„æƒ…å†µï¼Œåˆ™ä¸ä¼šå†å”¤é†’åº”ç”¨è¿›ç¨‹ã€‚ ä¸¾ä¾‹ï¼š ä¸¾ä¾‹1ï¼š è¯»ç¼“å†²åŒºåˆšå¼€å§‹æ˜¯ç©ºçš„ è¯»ç¼“å†²åŒºå†™å…¥2KBæ•°æ® æ°´å¹³è§¦å‘å’Œè¾¹ç¼˜è§¦å‘æ¨¡å¼æ­¤æ—¶éƒ½ä¼šå‘å‡ºå¯è¯»ä¿¡å· æ”¶åˆ°ä¿¡å·é€šçŸ¥åï¼Œè¯»å–äº†1KBçš„æ•°æ®ï¼Œè¯»ç¼“å†²åŒºè¿˜å‰©ä½™1KBæ•°æ® æ°´å¹³è§¦å‘ä¼šå†æ¬¡è¿›è¡Œé€šçŸ¥ï¼Œè€Œè¾¹ç¼˜è§¦å‘ä¸ä¼šå†è¿›è¡Œé€šçŸ¥ ä¸¾ä¾‹2ï¼š æ°´å¹³è§¦å‘ï¼š0ä¸ºæ— æ•°æ®ï¼Œ1ä¸ºæœ‰æ•°æ®ã€‚ç¼“å†²åŒºæœ‰æ•°æ®åˆ™ä¸€ç›´ä¸º1ï¼Œåˆ™ä¸€ç›´è§¦å‘ã€‚ è¾¹ç¼˜è§¦å‘ï¼š0ä¸ºæ— æ•°æ®ï¼Œ1ä¸ºæœ‰æ•°æ®ï¼Œåªè¦åœ¨0å˜åˆ°1çš„ä¸Šå‡æ²¿æ‰è§¦å‘ã€‚ netpollclose() æŠŠæ–‡ä»¶æè¿°ç¬¦fdä»pollerå®ä¾‹ä¸­ç§»é™¤ï¼Œä¹Ÿå°±æ˜¯ä»epollä¸­åˆ é™¤ã€‚ 1 2 3 4 5 6 func netpollclose(fd uintptr) int32 { var ev epollevent // _EPOLL_CTL_DEL ä»epollæ–‡ä»¶æè¿°ç¬¦epfdä¸­åˆ é™¤ç›®æ ‡æ–‡ä»¶æè¿°ç¬¦fdã€‚ // è¯¥äº‹ä»¶è¢«å¿½ç•¥ï¼Œå¯ä»¥ä¸ºNULLã€‚ return -epollctl(epfd, _EPOLL_CTL_DEL, int32(fd), \u0026amp;ev)\t} netpollIsPollDescriptor() åˆ¤æ–­æ˜¯å¦æ˜¯é¡¶å±‚pollï¼Œä»¥åŠæ˜¯pip2åˆ›å»ºçš„è¯»å’Œå†™æ–‡ä»¶æè¿°ç¬¦ã€‚ åˆ¤æ–­æ–‡ä»¶æè¿°ç¬¦æ˜¯å¦è¢«pollerä½¿ç”¨ã€‚epfdã€netpollBreakRdã€netpollBreakWrå±äºè¢«pollerä½¿ç”¨çš„æè¿°ç¬¦ã€‚ 1 2 3 func netpollIsPollDescriptor(fd uintptr) bool { return fd == uintptr(epfd) || fd == netpollBreakRd || fd == netpollBreakWr } netpollBreak() ç”¨æ¥å”¤é†’é˜»å¡ä¸­çš„netpollï¼Œå®ƒå®é™…ä¸Šå°±æ˜¯å‘netpollBreakWræè¿°ç¬¦ä¸­å†™å…¥æ•°æ®ï¼Œè¿™æ ·ä¸€æ¥epollå°±ä¼šç›‘å¬åˆ°ã€‚ netpollBreakRdçš„EPOLLINäº‹ä»¶(EPOLLINè¡¨ç¤ºå¯¹åº”çš„æ–‡ä»¶æè¿°ç¬¦å¯ä»¥è¯»ï¼ˆåŒ…æ‹¬å¯¹ç«¯SOCKETæ­£å¸¸å…³é—­ï¼‰)ã€‚netpollBreakä¸­æ–­epollwaitã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 // netpollBreak interrupts an epollwait. func netpollBreak() { // netpollWakeSigä¿¡å·ä¸»è¦ç”¨äºæœ¬è½®å·²ç»é€šçŸ¥è¿‡IOè½®è¯¢ï¼Œä½†æ˜¯è¿˜æ²¡å¤„ç†æœ‰å…¶ä»–çš„è°ƒç”¨æ­¤æ–¹æ³•æ—¶ // ä½¿ç”¨åŸå­æ“ä½œå°†netpollWakeSigç”±0å˜æˆ1ï¼Œè¡¨ç¤ºæ­£åœ¨å”¤é†’epollã€‚ if atomic.Cas(\u0026amp;netpollWakeSig, 0, 1) {\tfor { var b byte // å‘netpollBreakWrä¸­å†™å…¥æ•°æ®ï¼Œä¼šå¯¼è‡´é‚£äº›é˜»å¡åœ¨netpollå‡½æ•°ä¸­çš„çº¿ç¨‹ç›´æ¥è¿”å›å»æ‰§è¡Œåé¢ä»£ç  // netpollBreakWråœ¨pipe2å‡½æ•°ä¸­æ³¨å†Œæ—¶å·²ç»è®¾ç½®äº†éé˜»å¡ã€‚å› æ­¤è¿™é‡Œä¸ä¼šé˜»å¡ã€‚ n := write(netpollBreakWr, unsafe.Pointer(\u0026amp;b), 1) // å†™å…¥æˆåŠŸ if n == 1 { break } // åœ¨å†™å…¥ä»»ä½•æ•°æ®ä¹‹å‰ï¼Œè°ƒç”¨è¢«ä¿¡å·ä¸­æ–­ã€‚ if n == -_EINTR { continue // é‡è¯•ã€‚ } // å·²ä½¿ç”¨ O_NONBLOCK é€‰æ‹©äº†éé˜»å¡ I/Oï¼Œå¹¶ä¸”å†™å…¥å°†é˜»å¡ã€‚ // _EAGAINï¼šè¡¨ç¤ºç›®å‰æ²¡æœ‰å¯ç”¨çš„æ•°æ® if n == -_EAGAIN { return } println(\u0026#34;runtime: netpollBreak write failed with\u0026#34;, -n) throw(\u0026#34;runtime: netpollBreak write failed\u0026#34;) } } } netpoll() netpollæ£€æŸ¥å‡†å¤‡å°±ç»ªçš„ç½‘ç»œè¿æ¥ã€‚è¿”å›å¯è¿è¡Œçš„goroutineåˆ—è¡¨ã€‚ å‚æ•°ï¼š delay \u0026lt; 0ï¼šæ— é™æœŸé˜»å¡ã€‚ delay == 0ï¼šä¸é˜»å¡ï¼Œç«‹å³è¿”å›ã€‚ delay \u0026gt; 0ï¼šé˜»å¡é•¿è¾¾delayçº³ç§’ã€‚ è¿”å›å€¼ï¼šgListï¼šä¸€ç»„å°±ç»ªçš„goroutineã€‚ æ ¹æ®å…¥å‚delayè®¾ç½®è°ƒç”¨epoll_waitçš„timeoutå€¼ï¼Œè°ƒç”¨epoll_waitä»epollçš„eventpoll.rdlliståŒå‘åˆ—è¡¨ä¸­è·å–IOå°±ç»ªçš„fdåˆ—è¡¨ï¼Œéå†epoll_waitè¿”å›çš„fdåˆ—è¡¨ï¼Œ æ ¹æ®è°ƒç”¨epoll_ctlæ³¨å†Œfdæ—¶å°è£…çš„ä¸Šä¸‹æ–‡ä¿¡æ¯ç»„è£…å¯è¿è¡Œçš„goroutineå¹¶è¿”å›ã€‚ æ‰§è¡Œå®Œnetpollä¹‹åï¼Œä¼šè¿”å›ä¸€ä¸ªå°±ç»ªfdåˆ—è¡¨å¯¹åº”çš„goroutineåˆ—è¡¨ï¼Œæ¥ä¸‹æ¥å°†å°±ç»ªçš„goroutineåŠ å…¥åˆ°è°ƒåº¦é˜Ÿåˆ—ä¸­ï¼Œç­‰å¾…è°ƒåº¦è¿è¡Œã€‚ netpollçš„è°ƒç”¨æ—¶æœºï¼š åœ¨è°ƒåº¦å™¨ä¸­æ‰§è¡Œruntime.schedule()ï¼Œè¯¥æ–¹æ³•ä¸­ä¼šæ‰§è¡Œruntime.findrunnable()å‡½æ•°ä¸­è°ƒç”¨äº†runtime.netpollè·å–å¾…æ‰§è¡Œçš„goroutineã€‚ Go runtimeåœ¨ç¨‹åºå¯åŠ¨çš„æ—¶å€™ä¼šåˆ›å»ºä¸€ä¸ªç‹¬ç«‹çš„sysmonç›‘æ§çº¿ç¨‹ï¼Œsysmonæ¯20us~10msè¿è¡Œä¸€æ¬¡ï¼Œæ¯æ¬¡è¿è¡Œä¼šæ£€æŸ¥è·ç¦»ä¸Šä¸€æ¬¡æ‰§è¡Œnetpollæ˜¯å¦è¶…è¿‡10msï¼Œå¦‚æœæ˜¯åˆ™ä¼šè°ƒç”¨ä¸€æ¬¡runtime.netpollã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 // netpoll checks for ready network connections. // Returns list of goroutines that become runnable. // // delay \u0026lt; 0: blocks indefinitely;\t// delay == 0: does not block, just polls; // delay \u0026gt; 0: block for up to that many nanoseconds; func netpoll(delay int64) gList { // 1) epollæ²¡æœ‰åˆå§‹åŒ– if epfd == -1 {\treturn gList{} } // 2) ä¸‹é¢æŠŠçº³ç§’çº§çš„ delay è½¬æ¢æˆæ¯«ç§’çº§çš„ waitmsã€‚ var waitms int32 if delay \u0026lt; 0 { waitms = -1 // æ°¸ä¹…é˜»å¡ï¼Œç›´åˆ°äº‹ä»¶å°±ç»ªè¿”å› } else if delay == 0 { waitms = 0 // ä¸é˜»å¡ï¼Œç«‹å³è¿”å› } else if delay \u0026lt; 1e6 { // å°äº1æ¯«ç§’ï¼Œä¿®æ”¹ä¸ºé˜»å¡1æ¯«ç§’ waitms = 1 // é˜»å¡1æ¯«ç§’ } else if delay \u0026lt; 1e15 { // å°äº 11.5 day // 1e6 è¡¨ç¤º 1æ¯«ç§’ waitms = int32(delay / 1e6) // é˜»å¡æŒ‡å®šæ¯«ç§’ } else { // An arbitrary cap on how long to wait for a timer. // 1e9 ms == ~11.5 days. waitms = 1e9 // æœ€é•¿ 11.5å¤© } // 3) é€šè¿‡epollwaitå‡½æ•°ç­‰å¾…IOäº‹ä»¶ï¼Œç¼“å†²åŒºå¤§å°ä¸º128ä¸ªepolleventã€‚ // è¶…æ—¶æ—¶é—´æ˜¯ waitms æ¯«ç§’ã€‚å¦‚æœ epollwaitå‡½æ•°è¢«ä¸­æ–­æ‰“æ–­ï¼Œå°±é€šè¿‡gotoæ¥é‡è¯•ã€‚ // waitms å¤§äº0æ—¶ä¸ä¼šé‡è¯•ï¼Œå› ä¸ºéœ€è¦è¿”å›è°ƒç”¨è€…ä¸­å»é‡æ–°è®¡ç®—è¶…æ—¶æ—¶é—´ã€‚ // ä¸‹é¢ä¼ å…¥epollwaitçš„æ•°é‡æ˜¯128ï¼Œè¡¨ç¤ºä¸€æ¬¡æœ€å¤§å°±ç»ª128ä¸ªäº‹ä»¶ // è¿™æ ·å¯èƒ½å­˜åœ¨æ­¤æ¬¡å¤§äº128æ•°é‡æ—¶ï¼Œéœ€è¦ç­‰åˆ°ä¸‹ä¸€ä¸ªIOè½®è¯¢æ—¶é—´çª—å£ // type epollevent struct { // events uint32 // äº‹ä»¶ç±»å‹ // data [8]byte // å­˜å‚¨ç”¨æˆ·æ•°æ®ï¼Œåˆšå¥½æ˜¯ä¸€ä¸ªæŒ‡é’ˆå­˜å‚¨çš„å¤§å°ï¼Œè¯¥æ•°æ®ç”¨æˆ·æ˜¯å¯ä»¥ä¿®æ”¹çš„ // } var events [128]epollevent // ç”¨äºå­˜å‚¨å·²ç»å‡†å¤‡å¥½çš„æè¿°ç¬¦çš„äº‹ä»¶æ•°æ® retry: // è°ƒç”¨epollwaitç­‰å¾…æ–‡ä»¶æè¿°ç¬¦è½¬æ¢æˆå¯å†™æˆ–å¯è¯»ï¼Œå¦‚æœæ²¡æœ‰epollwaitä¼šé˜»å¡ n := epollwait(epfd, \u0026amp;events[0], int32(len(events)), waitms) // è¿”å›æ´»è·ƒçš„æ•°é‡n if n \u0026lt; 0 { // EBADFï¼šepfd ä¸æ˜¯æœ‰æ•ˆçš„æ–‡ä»¶æè¿°ç¬¦ã€‚ // EFAULTï¼šäº‹ä»¶æŒ‡å‘çš„å†…å­˜åŒºåŸŸæ— æ³•ç”¨å†™æƒé™è®¿é—®ã€‚ // EINVALï¼šepfd ä¸æ˜¯epollæ–‡ä»¶æè¿°ç¬¦ï¼Œæˆ–è€…maxevents(ç¬¬ä¸‰ä¸ªå‚æ•°)å°äºç­‰äº0ã€‚ if n != -_EINTR { // EINTR è¢«CPUä¸­æ–­ println(\u0026#34;runtime: epollwait on fd\u0026#34;, epfd, \u0026#34;failed with\u0026#34;, -n) throw(\u0026#34;runtime: netpoll failed\u0026#34;) } // If a timed sleep was interrupted, just return to // recalculate how long we should sleep now. // // å¦‚æœå®šæ—¶ç¡çœ è¢«ä¸­æ–­ï¼Œåªéœ€è¿”å›é‡æ–°è®¡ç®—æˆ‘ä»¬ç°åœ¨åº”è¯¥ç¡å¤šä¹…ã€‚ // _EINTR: åœ¨ä»»ä½•è¯·æ±‚çš„äº‹ä»¶å‘ç”Ÿæˆ–è¶…æ—¶åˆ°æœŸä¹‹å‰ï¼Œè¯¥è°ƒç”¨è¢«ä¿¡å·å¤„ç†ç¨‹åºä¸­æ–­ã€‚ if waitms \u0026gt; 0 { return gList{} } // è¢«ä¸­æ–­ AND waitms \u0026lt;= 0 æƒ…å†µé‡è¯• goto retry } // type gList struct { head guintptr } var toRun gList // æ„å‘³ç€è¢«ç›‘æ§çš„æ–‡ä»¶æè¿°ç¬¦å‡ºç°äº†å¾…å¤„ç†çš„äº‹ä»¶ for i := int32(0); i \u0026lt; n; i++ { // å°±ç»ªçš„IOäº‹ä»¶é›† ev := \u0026amp;events[i] // å½“å‰å°±ç»ªæè¿°ç¬¦æ²¡æœ‰äº‹ä»¶ç±»å‹ï¼Œç›´æ¥è·³è¿‡ if ev.events == 0 { continue } // äº‹ä»¶æ¥æºæ˜¯å¦æ˜¯netpollBreakRdï¼Œè¯¥æè¿°ç¬¦æ¥ä¹‹pipe2å‡½æ•°åˆ›å»º // æ¥è‡ªpipe2å‡½æ•°åˆ›å»ºçš„é€šä¿¡ï¼ŒnetpollBreakRdæ˜¯LTæ°´å¹³è§¦å‘å¦‚æœä¸è¯»å–ä¼šä¸€ç›´è§¦å‘ // è¯¥äº‹ä»¶æ¥è‡ª netpollBreak() æ–¹æ³•ï¼Œè¯¥æ–¹æ³•åªä¼šåœ¨åˆ›å»ºtimeræ—¶å’ŒfindRunnable()å‡½æ•°ä¸­è¢«è°ƒç”¨ã€‚ if *(**uintptr)(unsafe.Pointer(\u0026amp;ev.data)) == \u0026amp;netpollBreakRd { // å¯¹äºæ–‡ä»¶æè¿°ç¬¦ netpollBreakRd è€Œè¨€ï¼Œåªæœ‰ _EPOLLIN äº‹ä»¶æ˜¯æ­£å¸¸çš„ï¼Œå…¶ä»–éƒ½ä¼šè¢«è§†ä¸ºå¼‚å¸¸ã€‚ if ev.events != _EPOLLIN { println(\u0026#34;runtime: netpoll: break fd ready for\u0026#34;, ev.events) throw(\u0026#34;runtime: netpoll: break fd ready for something unexpected\u0026#34;) } // è¿™ç§æƒ…å†µä¸‹åªå¤„ç†ä¸æ˜¯ç«‹å³è¿”å›æƒ…å†µä¸‹ï¼Œå¦‚æœæ˜¯ç«‹å³è¿”å›æƒ…å†µæ—¶ï¼Œæ•°æ®å¹¶æœªè¢«è¯»å–ï¼Œä¸‹æ¬¡è¿˜ä¼šè§¦å‘è¯¥ä¿¡å· // è¿™ç§æƒ…å†µä¸‹åªåœ¨runtime.findrunnable()å‡½æ•°ä¸­å­˜åœ¨ï¼Œçº¿ç¨‹åœ¨å¯»æ‰¾gæ— æœæ—¶ï¼Œæœ€ååªèƒ½åœ¨IOè½®è¯¢å¤„ç­‰å¾… // åªæœ‰åœ¨ delay ä¸ä¸º0ï¼Œä¹Ÿå°±æ˜¯é˜»å¡å¼netpollæ—¶ï¼Œæ‰è¯»å–netpollBreakRdä¸­çš„æ•°æ®ã€‚ if delay != 0 { // netpollBreakRd çš„æœ¬æ„ä¹Ÿæ˜¯åªå”¤é†’delay != 0çš„netpollï¼Œå› ä¸ºè¿™äº›åœ¨é˜»å¡éœ€è¦è¿”å› // netpollBreak could be picked up by a // nonblocking poll. Only read the byte // if blocking. // netpollBreak å¯ä»¥é€šè¿‡éé˜»å¡è½®è¯¢æ¥è·å–ã€‚ ä»…åœ¨é˜»å¡æ—¶è¯»å–å­—èŠ‚ã€‚ var tmp [16]byte // æŠŠå†™å…¥çš„æ•°æ®è¯»å–è®©ç¼“å­˜åŒºä¸ºç©º read(int32(netpollBreakRd), noescape(unsafe.Pointer(\u0026amp;tmp[0])), int32(len(tmp)))\t// å°†netpollWakeSigç”±1å˜æˆ0ï¼Œè¡¨ç¤ºå½“å‰äº‹ä»¶å·²è¢«è¯»å– atomic.Store(\u0026amp;netpollWakeSig, 0)\t} continue } // æ ¹æ®epollè¿”å›çš„IOäº‹ä»¶æ ‡å¿—ä½ä¸ºmodeèµ‹å€¼ // r è¡¨ç¤ºå¯è¯»ï¼Œw è¡¨ç¤ºå¯å†™ï¼Œr+w è¡¨ç¤ºæ—¢å¯è¯»åˆå¯å†™ã€‚ // æ£€æµ‹IOäº‹ä»¶ä¸­çš„é”™è¯¯æ ‡å¿—ä½ï¼Œå¹¶ç›¸åº”çš„ä¸ºpd.everrèµ‹å€¼ã€‚ // åˆ¤æ–­å‘ç”Ÿçš„äº‹ä»¶ç±»å‹,è¯»ç±»å‹æˆ–è€…å†™ç±»å‹ var mode int32\t// å­˜å‚¨å½“å‰ç±»å‹ // EPOLLIN ï¼šè¡¨ç¤ºå¯¹åº”çš„æ–‡ä»¶æè¿°ç¬¦å¯ä»¥è¯»ï¼ˆåŒ…æ‹¬å¯¹ç«¯SOCKETæ­£å¸¸å…³é—­ï¼‰ // EPOLLRDHUPï¼šå¯¹ç«¯æè¿°ç¬¦äº§ç”Ÿä¸€ä¸ªæŒ‚æ–­äº‹ä»¶ // EPOLLHUPï¼šæœ¬ç«¯æè¿°ç¬¦äº§ç”Ÿä¸€ä¸ªæŒ‚æ–­äº‹ä»¶ï¼Œé»˜è®¤ç›‘æµ‹äº‹ä»¶ // EPOLLERRï¼šè¡¨ç¤ºå¯¹åº”çš„æ–‡ä»¶æè¿°ç¬¦å‘ç”Ÿé”™è¯¯ if ev.events\u0026amp;(_EPOLLIN|_EPOLLRDHUP|_EPOLLHUP|_EPOLLERR) != 0 { mode += \u0026#39;r\u0026#39; } // EPOLLOUTï¼šè¡¨ç¤ºå¯¹åº”çš„æ–‡ä»¶æè¿°ç¬¦å¯ä»¥å†™ // EPOLLHUPï¼šæœ¬ç«¯æè¿°ç¬¦äº§ç”Ÿä¸€ä¸ªæŒ‚æ–­äº‹ä»¶ï¼Œé»˜è®¤ç›‘æµ‹äº‹ä»¶ // EPOLLERRï¼šè¡¨ç¤ºå¯¹åº”çš„æ–‡ä»¶æè¿°ç¬¦å‘ç”Ÿé”™è¯¯ if ev.events\u0026amp;(_EPOLLOUT|_EPOLLHUP|_EPOLLERR) != 0 { mode += \u0026#39;w\u0026#39; } // modeä¸ä¸º0ï¼Œè¡¨ç¤ºæœ‰IOäº‹ä»¶ï¼Œéœ€è¦ä»ev.dataå­—æ®µå¾—åˆ°ä¸IOäº‹ä»¶å…³è”çš„pollDescã€‚ if mode != 0 { // å–å‡ºä¿å­˜åœ¨ epollevent é‡Œçš„pollDescï¼Œå› ä¸ºè¦æ ¹æ®è¿™ä¸ªå†…å®¹å»æ¢å¤gå¦‚æœgå·²è¢«æŒ‚èµ·æ—¶ pd := *(**pollDesc)(unsafe.Pointer(\u0026amp;ev.data)) // *pollDesc // å¯¹åº”çš„_EPOLLERRæ–‡ä»¶æè¿°ç¬¦å‡ºç°é”™è¯¯æ—¶ï¼Œæ ‡è®°é”™è¯¯ pd.setEventErr(ev.events == _EPOLLERR)\t// è®¾ç½®pollDescçš„EpollErré”™è¯¯ä½ï¼Œå¦‚æœæ˜¯è¿™ç§çŠ¶æ€ netpollready(\u0026amp;toRun, pd, mode)\t// å¤„ç†å°±ç»ªçš„æè¿°ç¬¦ } } return toRun } netpollready() go1.19.3/src/runtime/runtime/netpoll.goã€‚ netpollreadyç”±ç‰¹å®šäºå¹³å°çš„netpollå‡½æ•°è°ƒç”¨ã€‚å®ƒå£°æ˜ä¸pdç›¸å…³çš„fdå·²ç»ä¸ºI/Oåšå¥½äº†å‡†å¤‡ã€‚ toRunå‚æ•°ç”¨äºæ„å»ºä¸€ä¸ªä»netpollè¿”å›çš„goroutinesåˆ—è¡¨ã€‚modeå‚æ•°æ˜¯'r'ã€'w'æˆ–'r'+'w'ï¼Œè¡¨ç¤ºfdæ˜¯å¦å‡†å¤‡å¥½è¯»ã€å†™æˆ–åŒæ—¶è¯»å’Œå†™ã€‚ è¿™å¯èƒ½ä¼šåœ¨æ•´ä¸ªç³»ç»Ÿåœæ­¢æ—¶è¿è¡Œï¼Œå› æ­¤ä¸å…è®¸è®¾ç½®å†™å±éšœã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 // netpollready is called by the platform-specific netpoll function. // It declares that the fd associated with pd is ready for I/O. // The toRun argument is used to build a list of goroutines to return // from netpoll. The mode argument is \u0026#39;r\u0026#39;, \u0026#39;w\u0026#39;, or \u0026#39;r\u0026#39;+\u0026#39;w\u0026#39; to indicate // whether the fd is ready for reading or writing or both. // // This may run while the world is stopped, so write barriers are not allowed. //go:nowritebarrier func netpollready(toRun *gList, pd *pollDesc, mode int32) { var rg, wg *g if mode == \u0026#39;r\u0026#39; || mode == \u0026#39;r\u0026#39;+\u0026#39;w\u0026#39; { // netpollunblock å¯èƒ½è¿”å› goroutine æˆ– nil rg = netpollunblock(pd, \u0026#39;r\u0026#39;, true) } if mode == \u0026#39;w\u0026#39; || mode == \u0026#39;r\u0026#39;+\u0026#39;w\u0026#39; { wg = netpollunblock(pd, \u0026#39;w\u0026#39;, true) } if rg != nil { // å¹¶å…¥ toRun ä¸­ï¼Œè¿™éƒ¨åˆ† goroutine ç­‰å¾…æ”¾å…¥è°ƒåº¦æ± ä¸­ toRun.push(rg) } if wg != nil { toRun.push(wg) } } netpollunblock() go1.19.3/src/runtime/runtime/netpoll.goã€‚ netpollunblockè§£é™¤é˜»å¡ã€‚ å‚æ•°ï¼š pd *pollDescï¼špollDescã€‚ mode int32ï¼šè¯»ræˆ–å†™wã€‚ ioready boolï¼štrue-I/Oè¯»ï¼ˆç”¨äºä»pollDescä¸­è·å– goroutineï¼‰ï¼Œfalse-è¯»å†™è¶…æ—¶ä»pollDescä¸­è·å–goroutineã€‚ è¿”å›å€¼ï¼š*gè¿”å›å°±ç»ªçš„goroutineï¼Œå¯èƒ½æ˜¯nilã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 func netpollunblock(pd *pollDesc, mode int32, ioready bool) *g { // æ ¹æ® mode ä»rgæˆ–wgå–å‡º goroutineã€‚ gpp := \u0026amp;pd.rg if mode == \u0026#39;w\u0026#39; { gpp = \u0026amp;pd.wg } for { // åŸå­è¯»å– old := gpp.Load() // pdReadyï¼šè¡¨ç¤ºfdçš„æ•°æ®å·²ç»å°±ç»ªï¼Œå¯ä¾›è¯»å–æˆ–å†™ã€‚è¯¥å€¼ä»gä¿®æ”¹pdReadyã€‚ // è¿™ç§æƒ…å†µå¯èƒ½ goroutine å·²ç»è¢«è¿”å›ç»™è°ƒç”¨è€…äº†ã€‚ä»€ä¹ˆéƒ½ä¸åšç›´æ¥è¿”å›ã€‚ if old == pdReady { return nil } // nilï¼šæ²¡æœ‰ä»€ä¹ˆå¯åšçš„ if old == 0 \u0026amp;\u0026amp; !ioready { // Only set pdReady for ioready. runtime_pollWait // will check for timeout/cancel before waiting. // // åªåœ¨ioreadyä¸­è®¾ç½®pdReadyã€‚runtime_pollWaitå°†åœ¨ç­‰å¾…ä¹‹å‰æ£€æŸ¥ timeout/cancelã€‚ return nil } // oldæ˜¯0ã€goroutineã€pdWaitè¿™ä¸‰ç§æƒ…å†µã€‚ var new uintptr if ioready { // ä¿®æ”¹ä¸ºpdReadyï¼Œè¡¨ç¤ºæ•°æ®å·²å°±ç»ªæˆ–å†™ new = pdReady } // CAS äº¤æ¢ if gpp.CompareAndSwap(old, new) { // pdWaitï¼šè¡¨ç¤ºæŸä¸ªgoroutineå³å°†æŒ‚èµ·å¹¶ç­‰å¾…fdçš„å¯è¯»å¯å†™äº‹ä»¶ã€‚ if old == pdWait { old = 0 // nil } return (*g)(unsafe.Pointer(old)) // nil æˆ– *g } } } wakeNetPoller() è¯¥å‡½æ•°åœ¨timeæºç ä¸­è¢«è°ƒç”¨ï¼Œç”¨äºåˆ¤æ–­æ˜¯å¦éœ€è¦å‘èµ·I/Oç½‘ç»œè½®è¯¢ã€‚ è¯¥æ–¹æ³•æ˜¯ä¸ºäº†é˜²æ­¢å®šæ—¶å™¨è§¦å‘æ—¶é—´åˆ°äº†æ²¡æœ‰çº¿ç¨‹èƒ½è§¦å‘çš„æƒ…å†µï¼Œå½“åªå‰©é˜»å¡åœ¨netpollçš„çº¿ç¨‹æˆ–æ‰€æœ‰çš„çº¿ç¨‹éƒ½å¤„äºç­‰å¾…ä¸­æ—¶ï¼Œtimerå¯èƒ½ä¸èƒ½æŒ‰æ—¶è§¦å‘çš„æƒ…å†µã€‚ wakeenetpollerå”¤é†’åœ¨ç½‘ç»œè½®è¯¢å™¨(network poller)ä¸­ç¡çœ çš„çº¿ç¨‹ï¼Œå¦‚æœå®ƒä¸æ‰“ç®—åœ¨whenå‚æ•°ä¹‹å‰è¢«å”¤é†’; æˆ–è€…å”¤é†’ä¸€ä¸ªç©ºé—²çš„Pæ¥æœåŠ¡è®¡æ—¶å™¨(timers)å’Œç½‘ç»œè½®è¯¢å™¨(network poller)(å¦‚æœè¿˜æ²¡æœ‰çš„è¯)ã€‚ when int64ï¼šè¡¨ç¤ºæœ€è¿‘çš„timerè§¦å‘çš„æ—¶é—´ç‚¹ï¼Œå› æ­¤ä¸ºäº†é¿å…å½“å‰æœ€è¿‘çš„timeråˆ°æ—¶é—´èƒ½å‡†æ—¶è§¦å‘ï¼Œéœ€è¦è°ƒæ•´netpollçš„é˜»å¡äº‹ä»¶ç‚¹ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 // wakeNetPoller wakes up the thread sleeping in the network poller if it isn\u0026#39;t // going to wake up before the when argument; or it wakes an idle P to service // timers and the network poller if there isn\u0026#39;t one already. func wakeNetPoller(when int64) { // sched.lastpollï¼šè®°å½•çš„æ˜¯ä¸Šæ¬¡æ‰§è¡Œnetpollçš„æ—¶é—´ï¼Œå¦‚æœç­‰äº0ï¼Œåˆ™è¡¨ç¤ºæŸä¸ªçº¿ç¨‹æ­£åœ¨é˜»å¡å¼åœ°æ‰§è¡Œnetpollã€‚ // sched.lastpoll è¢«è®¾ç½®ä¸º0åªä¼šåœ¨ findrunnable å‡½æ•°ä¸­ã€‚ if atomic.Load64(\u0026amp;sched.lastpoll) == 0 { // In findrunnable we ensure that when polling the pollUntil // field is either zero or the time to which the current // poll is expected to run. This can have a spurious wakeup // but should never miss a wakeup. // // åœ¨ findrunnable ä¸­ï¼Œæˆ‘ä»¬è¦ç¡®ä¿è½®è¯¢æ—¶ pollUntil å­—æ®µè¦ä¹ˆæ˜¯0ï¼Œè¦ä¹ˆä¸ºå½“å‰pollé¢„æœŸè¿è¡Œçš„æ—¶é—´ã€‚ // è¿™é‡Œå¯èƒ½ä¼šæ˜¯ä¸€ä¸ªè™šå‡çš„å”¤é†’ï¼Œä½†ä¸åº”è¯¥é”™è¿‡å”¤é†’ã€‚ // sched.pollUntilï¼šè¡¨ç¤ºé˜»å¡å¼åœ°netpollå°†åœ¨ä½•æ—¶è¢«å”¤é†’ã€‚è¯¥å€¼åœ¨ findrunnable å‡½æ•°ä¸­è¢«è®¾ç½®ã€‚ // sched.pollUntil å€¼å¤§äº0æ—¶ï¼Œè¡¨ç¤ºæœ€è¿‘çš„timerè§¦å‘æ—¶é—´æ®µã€‚ pollerPollUntil := int64(atomic.Load64(\u0026amp;sched.pollUntil)) // pollerPollUntil \u0026gt; whenï¼šå­˜åœ¨æœ€æ–°çš„è®¡æ—¶å™¨è¢«åŠ å…¥whenæ—¶é—´æ®µåè§¦å‘ if pollerPollUntil == 0 || pollerPollUntil \u0026gt; when { netpollBreak() } } else { // There are no threads in the network poller, try to get // one there so it can handle new timers. if GOOS != \u0026#34;plan9\u0026#34; { // Temporary workaround - see issue #42303. wakep() // å°è¯•å”¤é†’ä¸€ä¸ªç©ºé—²çš„Pèµ·æ¥æœåŠ¡timerå’Œnetwork pollerã€‚ } } } netpollarm() è¯¥å‡½æ•°åœ¨linuxä¸Šä¸ä¼šè°ƒç”¨ï¼Œå……å½“ä¸€ä¸ªå ä½ä½œç”¨ã€‚ 1 2 3 func netpollarm(pd *pollDesc, mode int) { throw(\u0026#34;runtime: unused\u0026#34;) // runtime: æœªä½¿ç”¨çš„ } å‚è€ƒ è¯¦è§£Goè¯­è¨€I/Oå¤šè·¯å¤ç”¨netpolleræ¨¡å‹ epollè¯¦è§£ epollæºç è§£æ(1) epoll_create ","permalink":"https://heliu.site/posts/golang/netpoll/epoll/","summary":"Golang å°è£…çš„åº•å±‚epollä»£ç ã€‚","title":"Golang epoll"},{"content":" Let's Encrypt å‚è€ƒè‡ª å¤é“è½»é£ã€‚ Let\u0026rsquo;s Encrypt æ˜¯ä¸€ä¸ªç”±éè¥åˆ©æ€§ç»„ç»‡ äº’è”ç½‘å®‰å…¨ç ”ç©¶å°ç»„ï¼ˆISRGï¼‰æä¾›çš„å…è´¹ã€è‡ªåŠ¨åŒ–å’Œå¼€æ”¾çš„è¯ä¹¦é¢å‘æœºæ„ï¼ˆCAï¼‰ã€‚ acme.sh å‚è€ƒå®˜æ–¹ github æ•™ç¨‹ã€‚ acme.sh å®ç°äº† acme åè®®, å¯ä»¥ä» letsencrypt ç”Ÿæˆå…è´¹çš„è¯ä¹¦ã€‚ æœ¬ç¯‡æ–‡ç« ä¸»è¦æ˜¯æ ¹æ®acme.shé…ç½®å®‰è£…çš„ï¼Œè®°å½•acme.shé…ç½®çš„ä¸€äº›æ­§ä¹‰åœ°æ–¹ã€‚ å®‰è£… acme.sh å®‰è£… acme.shã€‚ # åˆ›å»º .acme.sh ç›®å½• mkdir ~/.acme.sh # åˆ‡æ¢åˆ° .acme.sh cd ~/.acme.sh # æ‰§è¡Œå®‰è£…å‘½ä»¤ï¼Œæ³¨æ„é‚®ç®±æ”¹æˆè‡ªå·±çš„ curl https://get.acme.sh | sh -s email=my@example.com æ·»åŠ åˆ«åã€‚ vi ~/.bashrc # æŠŠä¸‹é¢è¿™è¡ŒåŠ å…¥åˆ°æœ€å # alias acme.sh=~/.acme.sh/acme.sh # æœ€åæ‰§è¡Œï¼Œä½¿é…ç½®ç”Ÿæ•ˆ source ~/.bashrc ç”Ÿæˆè¯ä¹¦ å› ä¸ºæˆ‘çš„nginxåœ¨dockeré‡Œï¼Œä¸ç¡®å®šnginxçš„æ–¹å¼èƒ½å¦å¯è¡Œã€‚ æ‰€ä»¥é‡‡ç”¨çš„æ‰‹åŠ¨ dns éªŒè¯ã€‚æˆ‘ç”¨çš„åä¸ºäº‘å‚è€ƒhttps://github.com/acmesh-official/acme.sh/wiki/dnsapi2#dns_huaweicloudã€‚ # é…ç½®ç¯å¢ƒå˜é‡ export HUAWEICLOUD_Username=\u0026#34;\u0026lt;Your IAM Username\u0026gt;\u0026#34; export HUAWEICLOUD_Password=\u0026#34;\u0026lt;Your Password\u0026gt;\u0026#34; export HUAWEICLOUD_DomainName=\u0026#34;\u0026lt;Your DomainName\u0026gt;\u0026#34; # å†æ‰§è¡Œ acme.sh --issue --dns dns_huaweicloud -d example.com -d *.example.com å®‰è£…è¯ä¹¦ acme.sh --install-cert -d example.com \\ --key-file /path/to/keyfile/in/nginx/key.pem \\ --fullchain-file /path/to/fullchain/nginx/cert.pem \\ --reloadcmd \u0026#34;docker exec -it nginx nginx -s reload\u0026#34; æ›´æ–°è¯ä¹¦ $ crontab -l 44 6 * * * \u0026#34;/root/.acme.sh\u0026#34;/acme.sh --cron --home \u0026#34;/root/.acme.sh\u0026#34; \u0026gt; /dev/null ","permalink":"https://heliu.site/posts/ssl/acme/","summary":"acme.sh å®ç°äº† acme åè®®, å¯ä»¥ä» letsencrypt ç”Ÿæˆå…è´¹çš„è¯ä¹¦ã€‚","title":"acme.sh"},{"content":"å®‰è£…å‰å‡†å¤‡ æŸ¥çœ‹æœåŠ¡å™¨ä¿¡æ¯ã€‚ 1 2 3 4 5 # æŸ¥çœ‹æœåŠ¡å™¨ç³»ç»Ÿå†…æ ¸ $ cat /etc/redhat-release # æŸ¥çœ‹æœåŠ¡å™¨å†…æ ¸ç‰ˆæœ¬ $ uname -r å¸è½½æ—§ç‰ˆæœ¬ï¼š 1 2 3 4 5 6 7 8 9 $ yum remove docker \\ docker-client \\ docker-client-latest \\ docker-common \\ docker-latest \\ docker-latest-logrotate \\ docker-logrotate \\ docker-engine \\ docker-selinux å®‰è£… yum å·¥å…·ã€‚ 1 $ yum install -y yum-utils device-mapper-persistent-data lvm2 é…ç½® docker çš„ yum æºï¼ˆæ›´æ–°ä¸ºé˜¿é‡Œæºï¼‰ã€‚ 1 2 3 $ yum-config-manager --add-repo https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo $ sed -i \u0026#39;s+download.docker.com+mirrors.aliyun.com/docker-ce+\u0026#39; /etc/yum.repos.d/docker-ce.repo æ›´æ–° yumï¼Œå»ºç«‹ç¼“å­˜ã€‚ 1 yum makecache fast å®‰è£… docker Docker ä» 17.03 ç‰ˆæœ¬ä¹‹ååˆ†ä¸ºä¸¤ä¸ªç‰ˆæœ¬ï¼šç¤¾åŒºç‰ˆï¼ˆCommunity Editionï¼Œç¼©å†™ CEï¼‰å’Œä¼ä¸šç‰ˆï¼ˆEnterprise Editionï¼Œç¼©å†™ EEï¼‰ã€‚ä¼ä¸šç‰ˆåŒ…å«äº†ä¸€äº›æ”¶è´¹æœåŠ¡ï¼Œä¸ªäººå¼€å‘è€…ä¸€èˆ¬ç”¨ä¸åˆ°ï¼Œæ‰€ä»¥æˆ‘ä»¬åªéœ€è¦å®‰è£…ç¤¾åŒºç‰ˆdocker-ceç‰ˆæœ¬ã€‚\nå®‰è£… Dockerã€‚ 1 $ install -y docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin å¯åŠ¨ docker 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 # å¯åŠ¨Docker systemctl start docker # åœæ­¢Docker systemctl stop docker # é‡å¯ systemctl restart docker # è®¾ç½®å¼€æœºè‡ªå¯ systemctl enable docker # æŸ¥çœ‹Dockerç‰ˆæœ¬ docker version # æ‰§è¡Œdocker pså‘½ä»¤ï¼Œå¦‚æœä¸æŠ¥é”™ï¼Œè¯´æ˜å®‰è£…å¯åŠ¨æˆåŠŸ docker ps é…ç½®é•œåƒåŠ é€Ÿ ä»¥é˜¿é‡Œäº‘é•œåƒåŠ é€Ÿä¸ºä¾‹ã€‚https://cr.console.aliyun.com/cn-hangzhou/instances/mirrors 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # åˆ›å»ºç›®å½• mkdir -p /etc/docker # å¤åˆ¶å†…å®¹ï¼Œæ³¨æ„æŠŠå…¶ä¸­çš„é•œåƒåŠ é€Ÿåœ°å€æ”¹æˆä½ è‡ªå·±çš„ tee /etc/docker/daemon.json \u0026lt;\u0026lt;-\u0026#39;EOF\u0026#39; { \u0026#34;registry-mirrors\u0026#34;: [\u0026#34;https://xxxx.mirror.aliyuncs.com\u0026#34;] } EOF # é‡æ–°åŠ è½½é…ç½® systemctl daemon-reload # é‡å¯Docker systemctl restart docker ","permalink":"https://heliu.site/posts/docker/install/","summary":"centos7 å®‰è£… dockerã€‚","title":"linux å®‰è£… docker"},{"content":" ä»“åº“ï¼ˆrepositoryï¼‰ï¼šdockerä»“åº“æ˜¯ç”¨æ¥ä¿å­˜é•œåƒçš„åœ°æ–¹ã€‚é•œåƒæ„å»ºå®Œæˆåï¼Œå¯ä»¥ç›´æ¥åœ¨å½“å‰å®¿ä¸»æœºä¸Šè¿è¡Œï¼Œä½†æ˜¯ä½†æ˜¯å¦‚æœéœ€è¦åœ¨å…¶ä»–æœåŠ¡å™¨ä¸Šä½¿ç”¨è¿™ä¸ªé•œåƒï¼Œå°±éœ€è¦ä¸€ä¸ªé›†ä¸­å­˜å‚¨ã€åˆ†å‘é•œåƒçš„æœåŠ¡ï¼Œdockerä»“åº“å°±æ˜¯è¿™æ ·çš„ä¸€ä¸ªæœåŠ¡ã€‚ é•œåƒï¼ˆimageï¼‰ï¼šä¿å­˜äº†åº”ç”¨å’Œéœ€è¦çš„ä¾èµ–ç¯å¢ƒï¼Œæ¯”å¦‚è¿è¡Œçš„runtimeå’Œwebappç­‰ã€‚ å®¹å™¨ï¼ˆContainerï¼‰ï¼šé•œåƒçš„å®ä¾‹ã€‚ä¸€ä¸ªå®¹å™¨ä»£è¡¨ä¸€ä¸ªæ­£åœ¨è¿è¡Œçš„åº”ç”¨ç¨‹åºã€è¿›ç¨‹æˆ–æœåŠ¡ã€‚ Dockerå®˜æ–¹æä¾›äº†ä¸€ä¸ªä¸“é—¨ç®¡ç†ã€å­˜å‚¨é•œåƒçš„ç½‘ç«™ï¼Œå¹¶å¯¹å¤–å¼€æ”¾äº†é•œåƒä¸Šä¼ ã€ä¸‹è½½çš„æƒåˆ©ã€‚https://hub.docker.com/ å¿«é€Ÿå…¥é—¨ Docker å¿«é€Ÿçš„å®‰è£…äº† mysqlã€‚ docker run -d ï¼šåˆ›å»ºå¹¶è¿è¡Œä¸€ä¸ªå®¹å™¨ï¼Œ-d åˆ™æ˜¯è®©å®¹å™¨ä»¥åå°è¿›ç¨‹è¿è¡Œã€‚ \u0026ndash;name mysql : ç»™å®¹å™¨èµ·ä¸ªåå­—å«mysqlï¼Œå¯ä»¥æ˜¯å…¶ä»–åç§°ã€‚ -p 3306:3306 : è®¾ç½®ç«¯å£æ˜ å°„ã€‚ å®¹å™¨æ˜¯éš”ç¦»ç¯å¢ƒï¼Œå¤–ç•Œä¸å¯è®¿é—®ã€‚ä½†æ˜¯å¯ä»¥å°†å®¿ä¸»æœºç«¯å£æ˜ å°„å®¹å™¨å†…åˆ°ç«¯å£ï¼Œå½“è®¿é—®å®¿ä¸»æœºæŒ‡å®šç«¯å£æ—¶ï¼Œå°±æ˜¯åœ¨è®¿é—®å®¹å™¨å†…çš„ç«¯å£äº†ã€‚ å®¹å™¨å†…ç«¯å£å¾€å¾€æ˜¯ç”±å®¹å™¨å†…çš„è¿›ç¨‹å†³å®šï¼Œä¾‹å¦‚MySQLè¿›ç¨‹é»˜è®¤ç«¯å£æ˜¯3306ï¼Œå› æ­¤å®¹å™¨å†…ç«¯å£ä¸€å®šæ˜¯3306ï¼›è€Œå®¿ä¸»æœºç«¯å£åˆ™å¯ä»¥ä»»æ„æŒ‡å®šï¼Œä¸€èˆ¬ä¸å®¹å™¨å†…ä¿æŒä¸€è‡´ã€‚ æ ¼å¼ï¼š -p å®¿ä¸»æœºç«¯å£:å®¹å™¨å†…ç«¯å£ï¼Œç¤ºä¾‹ä¸­å°±æ˜¯å°†å®¿ä¸»æœºçš„3306æ˜ å°„åˆ°å®¹å™¨å†…çš„3306ç«¯å£ã€‚ -e TZ=Asia/Shanghai : é…ç½®å®¹å™¨å†…è¿›ç¨‹è¿è¡Œæ—¶çš„ä¸€äº›å‚æ•°ã€‚ æ ¼å¼ï¼š-e KEY=VALUEï¼ŒKEYå’ŒVALUEéƒ½ç”±å®¹å™¨å†…è¿›ç¨‹å†³å®šã€‚ æ¡ˆä¾‹ä¸­ï¼ŒTZ=Asia/Shanghaiæ˜¯è®¾ç½®æ—¶åŒºï¼›MYSQL_ROOT_PASSWORD=123æ˜¯è®¾ç½®MySQLé»˜è®¤å¯†ç ã€‚ mysql : è®¾ç½®é•œåƒåç§°ï¼ŒDocker ä¼šæ ¹æ®è¿™ä¸ªåå­—æœç´¢å¹¶ä¸‹è½½é•œåƒã€‚ æ ¼å¼ï¼šREPOSITORY:TAGï¼Œä¾‹å¦‚ mysql:8.0ï¼Œå…¶ä¸­ REPOSITORY å¯ä»¥ç†è§£ä¸ºé•œåƒåï¼ŒTAG æ˜¯ç‰ˆæœ¬å·ã€‚ åœ¨æœªæŒ‡å®šTAGçš„æƒ…å†µä¸‹ï¼Œé»˜è®¤æ˜¯æœ€æ–°ç‰ˆæœ¬ï¼Œä¹Ÿå°±æ˜¯ mysql:latestã€‚ 1 2 3 4 5 6 $ docker run -d \\ --name mysql \\ -p 3306:3306 \\ -e TZ=Asia/Shanghai \\ -e MYSQL_ROOT_PASSWORD=123 \\ mysql docker åŸºç¡€ å¸¸è§å‘½ä»¤ \u0026mdash;\u0026mdash;\u0026ndash; å‘½ä»¤ \u0026mdash;\u0026mdash;\u0026ndash; è¯´æ˜ docker pull æ‹‰å–é•œåƒ docker push æ¨é€é•œåƒåˆ°DockerRegistry docker images æŸ¥çœ‹æœ¬åœ°é•œåƒ docker rmi åˆ é™¤æœ¬åœ°é•œåƒ docker run åˆ›å»ºå¹¶è¿è¡Œå®¹å™¨ï¼ˆä¸èƒ½é‡å¤åˆ›å»ºï¼‰ docker stop åœæ­¢æŒ‡å®šå®¹å™¨ docker start é‡æ–°å¯åŠ¨å®¹å™¨ docker rm åˆ é™¤æŒ‡å®šå®¹å™¨ docker ps æŸ¥çœ‹å®¹å™¨ docker logs æŸ¥çœ‹å®¹å™¨è¿è¡Œæ—¥å¿— docker exec è¿›å…¥å®¹å™¨ docker save ä¿å­˜é•œåƒåˆ°æœ¬åœ°å‹ç¼©æ–‡ä»¶ docker load åŠ è½½æœ¬åœ°å‹ç¼©æ–‡ä»¶åˆ°é•œåƒ docker inspect æŸ¥çœ‹å®¹å™¨è¯¦ç»†ä¿¡æ¯ é»˜è®¤æƒ…å†µä¸‹ï¼Œæ¯æ¬¡é‡å¯è™šæ‹Ÿæœºæˆ‘ä»¬éƒ½éœ€è¦æ‰‹åŠ¨å¯åŠ¨Dockerå’ŒDockerä¸­çš„å®¹å™¨ã€‚é€šè¿‡å‘½ä»¤å¯ä»¥å®ç°å¼€æœºè‡ªå¯ï¼š 1 2 3 4 5 # Dockerå¼€æœºè‡ªå¯ systemctl enable docker # Dockerå®¹å™¨å¼€æœºè‡ªå¯ docker update --restart=always [å®¹å™¨å/å®¹å™¨id] ä½¿ç”¨ç¤ºä¾‹ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 # ç¬¬1æ­¥ï¼Œå»DockerHubæŸ¥çœ‹nginxé•œåƒä»“åº“åŠç›¸å…³ä¿¡æ¯ # ç¬¬2æ­¥ï¼Œæ‹‰å–Nginxé•œåƒ docker pull nginx # ç¬¬3æ­¥ï¼ŒæŸ¥çœ‹é•œåƒ docker images # ç»“æœå¦‚ä¸‹ï¼š REPOSITORY TAG IMAGE ID CREATED SIZE nginx latest 605c77e624dd 16 months ago 141MB mysql latest 3218b38490ce 17 months ago 516MB # ç¬¬4æ­¥ï¼Œåˆ›å»ºå¹¶å…è®¸Nginxå®¹å™¨ docker run -d --name nginx -p 80:80 nginx # ç¬¬5æ­¥ï¼ŒæŸ¥çœ‹è¿è¡Œä¸­å®¹å™¨ docker ps # ä¹Ÿå¯ä»¥åŠ æ ¼å¼åŒ–æ–¹å¼è®¿é—®ï¼Œæ ¼å¼ä¼šæ›´åŠ æ¸…çˆ½ docker ps --format \u0026#34;table {{.ID}}\\t{{.Image}}\\t{{.Ports}}\\t{{.Status}}\\t{{.Names}}\u0026#34; # ç¬¬6æ­¥ï¼Œè®¿é—®ç½‘é¡µï¼Œåœ°å€ï¼šhttp://è™šæ‹Ÿæœºåœ°å€ # ç¬¬7æ­¥ï¼Œåœæ­¢å®¹å™¨ docker stop nginx # ç¬¬8æ­¥ï¼ŒæŸ¥çœ‹æ‰€æœ‰å®¹å™¨ docker ps -a --format \u0026#34;table {{.ID}}\\t{{.Image}}\\t{{.Ports}}\\t{{.Status}}\\t{{.Names}}\u0026#34; # ç¬¬9æ­¥ï¼Œå†æ¬¡å¯åŠ¨nginxå®¹å™¨ docker start nginx # ç¬¬10æ­¥ï¼Œå†æ¬¡æŸ¥çœ‹å®¹å™¨ docker ps --format \u0026#34;table {{.ID}}\\t{{.Image}}\\t{{.Ports}}\\t{{.Status}}\\t{{.Names}}\u0026#34; # ç¬¬11æ­¥ï¼ŒæŸ¥çœ‹å®¹å™¨è¯¦ç»†ä¿¡æ¯ docker inspect nginx # ç¬¬12æ­¥ï¼Œè¿›å…¥å®¹å™¨,æŸ¥çœ‹å®¹å™¨å†…ç›®å½• docker exec -it nginx bash # æˆ–è€…ï¼Œå¯ä»¥è¿›å…¥MySQL docker exec -it mysql mysql -uroot -p # ç¬¬13æ­¥ï¼Œåˆ é™¤å®¹å™¨ docker rm nginx # å‘ç°æ— æ³•åˆ é™¤ï¼Œå› ä¸ºå®¹å™¨è¿è¡Œä¸­ï¼Œå¼ºåˆ¶åˆ é™¤å®¹å™¨ docker rm -f nginx å‘½ååˆ«å ç»™å¸¸ç”¨Dockerå‘½ä»¤èµ·åˆ«åï¼Œæ–¹ä¾¿æˆ‘ä»¬è®¿é—®ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 # ä¿®æ”¹/root/.bashrcæ–‡ä»¶ vi /root/.bashrc å†…å®¹å¦‚ä¸‹ï¼š # .bashrc # User specific aliases and functions alias rm=\u0026#39;rm -i\u0026#39; alias cp=\u0026#39;cp -i\u0026#39; alias mv=\u0026#39;mv -i\u0026#39; alias dps=\u0026#39;docker ps --format \u0026#34;table {{.ID}}\\t{{.Image}}\\t{{.Ports}}\\t{{.Status}}\\t{{.Names}}\u0026#34;\u0026#39; alias dis=\u0026#39;docker images\u0026#39; # Source global definitions if [ -f /etc/bashrc ]; then . /etc/bashrc fi # æ‰§è¡Œå‘½ä»¤ä½¿åˆ«åç”Ÿæ•ˆ source /root/.bashrc æ•°æ®å· å®¹å™¨æ˜¯éš”ç¦»ç¯å¢ƒï¼Œå®¹å™¨å†…ç¨‹åºçš„æ–‡ä»¶ã€é…ç½®ã€è¿è¡Œæ—¶äº§ç”Ÿçš„å®¹å™¨éƒ½åœ¨å®¹å™¨å†…éƒ¨ï¼Œæˆ‘ä»¬è¦è¯»å†™å®¹å™¨å†…çš„æ–‡ä»¶éå¸¸ä¸æ–¹ä¾¿ã€‚\nç®€ä»‹ æ•°æ®å·ï¼ˆvolumeï¼‰æ˜¯ä¸€ä¸ªè™šæ‹Ÿç›®å½•ï¼Œæ˜¯å®¹å™¨å†…ç›®å½•ä¸å®¿ä¸»æœºç›®å½•ä¹‹é—´æ˜ å°„çš„æ¡¥æ¢ã€‚ æ•°æ®å·ï¼ˆvolumeï¼‰æ˜¯ä¸€ä¸ªè™šæ‹Ÿç›®å½•ï¼Œæ˜¯å®¹å™¨å†…ç›®å½•ä¸å®¿ä¸»æœºç›®å½•ä¹‹é—´æ˜ å°„çš„æ¡¥æ¢ã€‚ htmlï¼šæ”¾ç½®ä¸€äº›é™æ€èµ„æº confï¼šæ”¾ç½®é…ç½®æ–‡ä»¶ å¦‚æœæˆ‘ä»¬è¦è®©Nginxä»£ç†æˆ‘ä»¬çš„é™æ€èµ„æºï¼Œæœ€å¥½æ˜¯æ”¾åˆ°htmlç›®å½•ï¼›å¦‚æœæˆ‘ä»¬è¦ä¿®æ”¹Nginxçš„é…ç½®ï¼Œæœ€å¥½æ˜¯æ‰¾åˆ°confä¸‹çš„nginx.confæ–‡ä»¶ã€‚ ä½†é—æ†¾çš„æ˜¯ï¼Œå®¹å™¨è¿è¡Œçš„Nginxæ‰€æœ‰çš„æ–‡ä»¶éƒ½åœ¨å®¹å™¨å†…éƒ¨ã€‚æ‰€ä»¥æˆ‘ä»¬å¿…é¡»åˆ©ç”¨æ•°æ®å·å°†ä¸¤ä¸ªç›®å½•ä¸å®¿ä¸»æœºç›®å½•å…³è”ï¼Œæ–¹ä¾¿æˆ‘ä»¬æ“ä½œã€‚ å¸¸è§å‘½ä»¤ \u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash; å‘½ä»¤ \u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash; è¯´æ˜ docker volume create åˆ›å»ºæ•°æ®å· docker volume ls æŸ¥çœ‹æ‰€æœ‰æ•°æ®å· docker volume rm åˆ é™¤æŒ‡å®šæ•°æ®å· docker volume inspect æŸ¥çœ‹æŸä¸ªæ•°æ®å·çš„è¯¦æƒ… docker volume prune æ¸…é™¤æ•°æ®å· æ³¨æ„ï¼šå®¹å™¨ä¸æ•°æ®å·çš„æŒ‚è½½è¦åœ¨åˆ›å»ºå®¹å™¨æ—¶é…ç½®ï¼Œå¯¹äºåˆ›å»ºå¥½çš„å®¹å™¨ï¼Œæ˜¯ä¸èƒ½è®¾ç½®æ•°æ®å·çš„ã€‚è€Œä¸”åˆ›å»ºå®¹å™¨çš„è¿‡ç¨‹ä¸­ï¼Œæ•°æ®å·ä¼šè‡ªåŠ¨åˆ›å»ºã€‚\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 # 1.é¦–å…ˆåˆ›å»ºå®¹å™¨å¹¶æŒ‡å®šæ•°æ®å·ï¼Œæ³¨æ„é€šè¿‡ -v å‚æ•°æ¥æŒ‡å®šæ•°æ®å· docker run -d --name nginx -p 80:80 -v html:/usr/share/nginx/html nginx # 2.ç„¶åæŸ¥çœ‹æ•°æ®å· docker volume ls # ç»“æœ DRIVER VOLUME NAME local 29524ff09715d3688eae3f99803a2796558dbd00ca584a25a4bbc193ca82459f local html # 3.æŸ¥çœ‹æ•°æ®å·è¯¦æƒ… docker volume inspect html # ç»“æœ [ { \u0026#34;CreatedAt\u0026#34;: \u0026#34;2024-05-17T19:57:08+08:00\u0026#34;, \u0026#34;Driver\u0026#34;: \u0026#34;local\u0026#34;, \u0026#34;Labels\u0026#34;: null, \u0026#34;Mountpoint\u0026#34;: \u0026#34;/var/lib/docker/volumes/html/_data\u0026#34;, \u0026#34;Name\u0026#34;: \u0026#34;html\u0026#34;, \u0026#34;Options\u0026#34;: null, \u0026#34;Scope\u0026#34;: \u0026#34;local\u0026#34; } ] # 4.æŸ¥çœ‹/var/lib/docker/volumes/html/_dataç›®å½• ll /var/lib/docker/volumes/html/_data # å¯ä»¥çœ‹åˆ°ä¸nginxçš„htmlç›®å½•å†…å®¹ä¸€æ ·ï¼Œç»“æœå¦‚ä¸‹ï¼š æ€»ç”¨é‡ 8 -rw-r--r--. 1 root root 497 12æœˆ 28 2021 50x.html -rw-r--r--. 1 root root 615 12æœˆ 28 2021 index.html # 5.è¿›å…¥è¯¥ç›®å½•ï¼Œå¹¶éšæ„ä¿®æ”¹index.htmlå†…å®¹ cd /var/lib/docker/volumes/html/_data vi index.html # 6.æ‰“å¼€é¡µé¢ï¼ŒæŸ¥çœ‹æ•ˆæœ # 7.è¿›å…¥å®¹å™¨å†…éƒ¨ï¼ŒæŸ¥çœ‹/usr/share/nginx/htmlç›®å½•å†…çš„æ–‡ä»¶æ˜¯å¦å˜åŒ– docker exec -it nginx bash æŒ‚è½½ç›®å½•æˆ–æ–‡ä»¶ å¯ä»¥å‘ç°ï¼Œæ•°æ®å·çš„ç›®å½•ç»“æ„è¾ƒæ·±ï¼Œå¦‚æœæˆ‘ä»¬å»æ“ä½œæ•°æ®å·ç›®å½•ä¼šä¸å¤ªæ–¹ä¾¿ã€‚åœ¨å¾ˆå¤šæƒ…å†µä¸‹ï¼Œæˆ‘ä»¬ä¼šç›´æ¥å°†å®¹å™¨ç›®å½•ä¸å®¿ä¸»æœºæŒ‡å®šç›®å½•æŒ‚è½½ã€‚æŒ‚è½½è¯­æ³•ä¸æ•°æ®å·ç±»ä¼¼ï¼š 1 2 3 4 # æŒ‚è½½æœ¬åœ°ç›®å½• -v æœ¬åœ°ç›®å½•:å®¹å™¨å†…ç›®å½• # æŒ‚è½½æœ¬åœ°æ–‡ä»¶ -v æœ¬åœ°æ–‡ä»¶:å®¹å™¨å†…æ–‡ä»¶ æ³¨æ„ï¼šæœ¬åœ°ç›®å½•æˆ–æ–‡ä»¶å¿…é¡»ä»¥ / æˆ– ./å¼€å¤´ï¼Œå¦‚æœç›´æ¥ä»¥åå­—å¼€å¤´ï¼Œä¼šè¢«è¯†åˆ«ä¸ºæ•°æ®å·åè€Œéæœ¬åœ°ç›®å½•åã€‚\nä¾‹å¦‚ï¼š 1 2 -v mysql:/var/lib/mysql # ä¼šè¢«è¯†åˆ«ä¸ºä¸€ä¸ªæ•°æ®å·å«mysqlï¼Œè¿è¡Œæ—¶ä¼šè‡ªåŠ¨åˆ›å»ºè¿™ä¸ªæ•°æ®å· -v ./mysql:/var/lib/mysql # ä¼šè¢«è¯†åˆ«ä¸ºå½“å‰ç›®å½•ä¸‹çš„mysqlç›®å½•ï¼Œè¿è¡Œæ—¶å¦‚æœä¸å­˜åœ¨ä¼šåˆ›å»ºç›®å½• é•œåƒ Dockerfile è¿™ç§è®°å½•é•œåƒç»“æ„çš„æ–‡ä»¶å°±ç§°ä¸ºDockerfileï¼Œå…¶å¯¹åº”çš„è¯­æ³•å¯ä»¥å‚è€ƒå®˜æ–¹æ–‡æ¡£ï¼šhttps://docs.docker.com/engine/reference/builder/ å‘½ä»¤ è¯´æ˜ ç¤ºä¾‹ FROM æŒ‡å®šåŸºç¡€é•œåƒ FROM centos:6 ENV è®¾ç½®ç¯å¢ƒå˜é‡ï¼Œå¯åœ¨åé¢æŒ‡ä»¤ä½¿ç”¨ ENV key value COPY æ‹·è´æœ¬åœ°æ–‡ä»¶åˆ°é•œåƒçš„æŒ‡å®šç›®å½• COPY ./xx.jar /tmp/app.jar RUN æ‰§è¡ŒLinuxçš„shellå‘½ä»¤ï¼Œä¸€èˆ¬æ˜¯å®‰è£…è¿‡ç¨‹çš„å‘½ä»¤ RUN yum install gcc EXPOSE æŒ‡å®šå®¹å™¨è¿è¡Œæ—¶ç›‘å¬çš„ç«¯å£ï¼Œæ˜¯ç»™é•œåƒä½¿ç”¨è€…çœ‹çš„ EXPOSE 8080 ENTRYPOINT é•œåƒä¸­åº”ç”¨çš„å¯åŠ¨å‘½ä»¤ï¼Œå®¹å™¨è¿è¡Œæ—¶è°ƒç”¨ ENTRYPOINT java -jar xx.jar 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 FROM golang:1.22-alpine AS builder LABEL stage=gobuilder ENV CGO_ENABLED 0 ENV GOPROXY https://goproxy.cn,direct RUN sed -i \u0026#39;s/dl-cdn.alpinelinux.org/mirrors.aliyun.com/g\u0026#39; /etc/apk/repositories RUN apk update --no-cache \u0026amp;\u0026amp; apk add --no-cache tzdata WORKDIR /build ADD go.mod . ADD go.sum . RUN go mod download COPY . . COPY greet/api/etc /app/etc RUN go build -ldflags=\u0026#34;-s -w\u0026#34; -o /app/greet-api greet/api/greet.go FROM scratch COPY --from=builder /etc/ssl/certs/ca-certificates.crt /etc/ssl/certs/ca-certificates.crt COPY --from=builder /usr/share/zoneinfo/Asia/Shanghai /usr/share/zoneinfo/Asia/Shanghai ENV TZ Asia/Shanghai WORKDIR /app COPY --from=builder /app/greet-api /app/greet-api COPY --from=builder /app/etc /app/etc EXPOSE 8888 CMD [\u0026#34;./greet-api\u0026#34;, \u0026#34;-f\u0026#34;, \u0026#34;etc/greet.yaml\u0026#34;] æ„å»ºé•œåƒ å½“Dockerfileæ–‡ä»¶å†™å¥½ä»¥åï¼Œå°±å¯ä»¥åˆ©ç”¨å‘½ä»¤æ¥æ„å»ºé•œåƒäº†ã€‚ docker build : å°±æ˜¯æ„å»ºä¸€ä¸ªdockeré•œåƒã€‚ -t docker-demo:1.0 ï¼š-tå‚æ•°æ˜¯æŒ‡å®šé•œåƒçš„åç§°ï¼ˆrepositoryå’Œtagï¼‰ã€‚ . : æœ€åçš„ç‚¹æ˜¯æŒ‡æ„å»ºæ—¶Dockerfileæ‰€åœ¨è·¯å¾„ï¼Œç”±äºæˆ‘ä»¬è¿›å…¥äº†demoç›®å½•ï¼Œæ‰€ä»¥æŒ‡å®šçš„æ˜¯.ä»£è¡¨å½“å‰ç›®å½•ï¼Œä¹Ÿå¯ä»¥ç›´æ¥æŒ‡å®šDockerfileç›®å½•ï¼š 1 2 # ç›´æ¥æŒ‡å®šDockerfileç›®å½• docker build -t docker-demo:1.0 /root/demo ç½‘ç»œ \u0026mdash;\u0026mdash;\u0026ndash; å‘½ä»¤ \u0026mdash;\u0026mdash;\u0026ndash; è¯´æ˜ docker network create åˆ›å»ºä¸€ä¸ªç½‘ç»œ docker network ls æŸ¥çœ‹æ‰€æœ‰ç½‘ç»œ docker network rm åˆ é™¤æŒ‡å®šç½‘ç»œ docker network prune æ¸…é™¤æœªä½¿ç”¨çš„ç½‘ç»œ docker network connect ä½¿æŒ‡å®šå®¹å™¨è¿æ¥åŠ å…¥æŸç½‘ç»œ docker network disconnect ä½¿æŒ‡å®šå®¹å™¨è¿æ¥ç¦»å¼€æŸç½‘ç»œ docker network inspect æŸ¥çœ‹ç½‘ç»œè¯¦ç»†ä¿¡æ¯ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 # 1.é¦–å…ˆé€šè¿‡å‘½ä»¤åˆ›å»ºä¸€ä¸ªç½‘ç»œ docker network create hmall # 2.ç„¶åæŸ¥çœ‹ç½‘ç»œ docker network ls # ç»“æœï¼š NETWORK ID NAME DRIVER SCOPE 639bc44d0a87 bridge bridge local 403f16ec62a2 hmall bridge local 0dc0f72a0fbb host host local cd8d3e8df47b none null local # å…¶ä¸­ï¼Œé™¤äº†hmallä»¥å¤–ï¼Œå…¶å®ƒéƒ½æ˜¯é»˜è®¤çš„ç½‘ç»œ # 3.è®©ddå’Œmysqléƒ½åŠ å…¥è¯¥ç½‘ç»œï¼Œæ³¨æ„ï¼Œåœ¨åŠ å…¥ç½‘ç»œæ—¶å¯ä»¥é€šè¿‡--aliasç»™å®¹å™¨èµ·åˆ«å # è¿™æ ·è¯¥ç½‘ç»œå†…çš„å…¶å®ƒå®¹å™¨å¯ä»¥ç”¨åˆ«åäº’ç›¸è®¿é—®ï¼ # 3.1.mysqlå®¹å™¨ï¼ŒæŒ‡å®šåˆ«åä¸ºdbï¼Œå¦å¤–æ¯ä¸€ä¸ªå®¹å™¨éƒ½æœ‰ä¸€ä¸ªåˆ«åæ˜¯å®¹å™¨å docker network connect hmall mysql --alias db # 3.2.dbå®¹å™¨ï¼Œä¹Ÿå°±æ˜¯æˆ‘ä»¬çš„javaé¡¹ç›® docker network connect hmall dd # 4.è¿›å…¥ddå®¹å™¨ï¼Œå°è¯•åˆ©ç”¨åˆ«åè®¿é—®db # 4.1.è¿›å…¥å®¹å™¨ docker exec -it dd bash # 4.2.ç”¨dbåˆ«åè®¿é—® ping db # ç»“æœ PING db (172.18.0.2) 56(84) bytes of data. 64 bytes from mysql.hmall (172.18.0.2): icmp_seq=1 ttl=64 time=0.070 ms 64 bytes from mysql.hmall (172.18.0.2): icmp_seq=2 ttl=64 time=0.056 ms # 4.3.ç”¨å®¹å™¨åè®¿é—® ping mysql # ç»“æœï¼š PING mysql (172.18.0.2) 56(84) bytes of data. 64 bytes from mysql.hmall (172.18.0.2): icmp_seq=1 ttl=64 time=0.044 ms 64 bytes from mysql.hmall (172.18.0.2): icmp_seq=2 ttl=64 time=0.054 ms å‚è€ƒ https://b11et3un53m.feishu.cn/wiki/MWQIw4Zvhil0I5ktPHwcoqZdnec ","permalink":"https://heliu.site/posts/docker/use/","summary":"docker å¸¸ç”¨å‘½ä»¤ã€‚","title":"docker ç”¨æ³•"},{"content":"FROM FROM æŒ‡ä»¤ç”¨äºæŒ‡å®šå…¶åæ„å»ºæ–°é•œåƒæ‰€ä½¿ç”¨çš„åŸºç¡€é•œåƒã€‚ FROM æŒ‡ä»¤å¿…æ˜¯ Dockerfile æ–‡ä»¶ä¸­çš„é¦–æ¡å‘½ä»¤ï¼Œå¯åŠ¨æ„å»ºæµç¨‹åï¼ŒDocker å°†ä¼šåŸºäºè¯¥é•œåƒæ„å»ºæ–°é•œåƒï¼ŒFROM åçš„å‘½ä»¤ä¹Ÿä¼šåŸºäºè¿™ä¸ªåŸºç¡€é•œåƒã€‚æ„å‘³ç€æ¥ä¸‹æ¥æ‰€å†™çš„æŒ‡ä»¤å°†ä½œä¸ºé•œåƒçš„ç¬¬ä¸€å±‚å¼€å§‹ã€‚ è¯­æ³•ï¼š ä¸‰ç§å†™æ³•ï¼Œå…¶ä¸­\u0026lt;tag\u0026gt;å’Œ\u0026lt;digest\u0026gt;æ˜¯å¯é€‰é¡¹ï¼Œå¦‚æœæ²¡æœ‰é€‰æ‹©ï¼Œé‚£ä¹ˆé»˜è®¤å€¼ä¸º latestã€‚ FROM å¿…é¡» æ˜¯ Dockerfile ä¸­ç¬¬ä¸€æ¡éæ³¨é‡Šå‘½ä»¤ã€‚ åœ¨ä¸€ä¸ª Dockerfile æ–‡ä»¶ä¸­åˆ›å»ºå¤šä¸ªé•œåƒæ—¶ï¼ŒFROM å¯ä»¥å¤šæ¬¡å‡ºç°ã€‚åªéœ€åœ¨æ¯ä¸ªæ–°å‘½ä»¤ FROM ä¹‹å‰ï¼Œè®°å½•æäº¤ä¸Šæ¬¡çš„é•œåƒ IDã€‚ FROM \u0026lt;image\u0026gt; FROM \u0026lt;image\u0026gt;:\u0026lt;tag\u0026gt; FROM \u0026lt;image\u0026gt;:\u0026lt;digest\u0026gt; ç¤ºä¾‹ï¼š FROM nginx FROM mysql:5.6.0 RUN åœ¨é•œåƒçš„æ„å»ºè¿‡ç¨‹ä¸­æ‰§è¡Œç‰¹å®šçš„å‘½ä»¤ï¼Œå¹¶ç”Ÿæˆä¸€ä¸ªä¸­é—´é•œåƒã€‚ æ ¼å¼ï¼š # shellæ ¼å¼ã€‚åœ¨linuxæ“ä½œç³»ç»Ÿä¸Šé»˜è®¤\u0026#39;/bin/sh -c\u0026#39;ï¼›åœ¨windowsæ“ä½œç³»ç»Ÿä¸Šé»˜è®¤\u0026#39;cmd /S /C\u0026#39;ã€‚ RUN \u0026lt;command\u0026gt; # execæ ¼å¼ã€‚ç±»ä¼¼äºå‡½æ•°è°ƒç”¨ã€‚å¯å°†executableç†è§£æˆä¸ºå¯æ‰§è¡Œæ–‡ä»¶ï¼Œåé¢å°±æ˜¯ä¸¤ä¸ªå‚æ•°ã€‚ RUN [\u0026#34;executable\u0026#34;, \u0026#34;param1\u0026#34;, \u0026#34;param2\u0026#34;] RUN æŒ‡ä»¤åˆ›å»ºçš„ä¸­é—´é•œåƒä¼šè¢«ç¼“å­˜ï¼Œå¹¶ä¼šåœ¨ä¸‹æ¬¡æ„å»ºä¸­ä½¿ç”¨ã€‚å¦‚æœä¸æƒ³ä½¿ç”¨è¿™äº›ç¼“å­˜é•œåƒï¼Œå¯ä»¥åœ¨æ„å»ºæ—¶æŒ‡å®š \u0026ndash;no-cache å‚æ•°ï¼Œå¦‚ï¼šdocker build \u0026ndash;no-cacheã€‚\nç¤ºä¾‹ï¼š\nRUN /bin/bash -c \u0026#39;source $HOME/.bashrc; echo $HOME\u0026#39; RUN [\u0026#34;/bin/bash\u0026#34;, \u0026#34;-c\u0026#34;, \u0026#34;echo hello\u0026#34;] æ³¨æ„ï¼šå¤šè¡Œå‘½ä»¤ä¸è¦å†™å¤šä¸ª RUNï¼ŒåŸå› æ˜¯ Dockerfile ä¸­æ¯ä¸€ä¸ªæŒ‡ä»¤éƒ½ä¼šå»ºç«‹ä¸€å±‚ã€‚å¤šå°‘ä¸ªRUNå°±æ„å»ºäº†å¤šå°‘å±‚é•œåƒï¼Œä¼šé€ æˆé•œåƒçš„è‡ƒè‚¿ã€å¤šå±‚ï¼Œä¸ä»…ä»…å¢åŠ äº†æ„ä»¶éƒ¨ç½²çš„æ—¶é—´ï¼Œè¿˜å®¹æ˜“å‡ºé”™ã€‚RUNä¹¦å†™æ—¶çš„æ¢è¡Œç¬¦æ˜¯ \\ã€‚ CMD CMD ç”¨äºæŒ‡å®šåœ¨å®¹å™¨å¯åŠ¨æ—¶æ‰€è¦æ‰§è¡Œçš„å‘½ä»¤ã€‚ CMD æœ‰ä¸‰ç§æ ¼å¼ï¼š # å¯æ‰§è¡Œæ–‡ä»¶åŠ ä¸Šå‚æ•°çš„å½¢å¼ CMD [\u0026#34;executable\u0026#34;,\u0026#34;param1\u0026#34;,\u0026#34;param2\u0026#34;] # çœç•¥å¯æ‰§è¡Œæ–‡ä»¶çš„ exec æ ¼å¼ï¼Œè¿™ç§å†™æ³•ä½¿ CMD ä¸­çš„å‚æ•°å½“åš ENTRYPOINT çš„é»˜è®¤å‚æ•° # é…åˆ ENTRYPOINT CMD [\u0026#34;param1\u0026#34;,\u0026#34;param2\u0026#34;] # shell æ ¼å¼ CMD command param1 param2 ç¤ºä¾‹ï¼š è¿™é‡Œè¾¹åŒ…æ‹¬å‚æ•°çš„ä¸€å®šè¦ç”¨åŒå¼•å·ï¼Œå°±æ˜¯\u0026quot;,ä¸èƒ½æ˜¯å•å¼•å·ã€‚åƒä¸‡ä¸èƒ½å†™æˆå•å¼•å·ã€‚ åŸå› æ˜¯å‚æ•°ä¼ é€’åï¼Œdockerè§£æçš„æ˜¯ä¸€ä¸ªJSON arrayã€‚ CMD [ \u0026#34;sh\u0026#34;, \u0026#34;-c\u0026#34;, \u0026#34;echo $HOME\u0026#34; ] CMD [ \u0026#34;echo\u0026#34;, \u0026#34;$HOME\u0026#34; ] ä¸ RUN æŒ‡ä»¤çš„åŒºåˆ«ï¼šRUN åœ¨æ„å»ºçš„æ—¶å€™æ‰§è¡Œï¼Œå¹¶ç”Ÿæˆä¸€ä¸ªæ–°çš„é•œåƒï¼ŒCMD åœ¨å®¹å™¨è¿è¡Œçš„æ—¶å€™æ‰§è¡Œï¼Œåœ¨æ„å»ºæ—¶ä¸è¿›è¡Œä»»ä½•æ“ä½œã€‚ ENTRYPOINT ENTRYPOINT ç”¨äºç»™å®¹å™¨é…ç½®ä¸€ä¸ªå¯æ‰§è¡Œç¨‹åºã€‚(å¯åŠ¨æ—¶çš„é»˜è®¤å‘½ä»¤) æ¯æ¬¡ä½¿ç”¨é•œåƒåˆ›å»ºå®¹å™¨æ—¶ï¼Œé€šè¿‡ ENTRYPOINT æŒ‡å®šçš„ç¨‹åºéƒ½ä¼šè¢«è®¾ç½®ä¸ºé»˜è®¤ç¨‹åºã€‚ Dockerfile ä¸­åªå…è®¸æœ‰ä¸€ä¸ª ENTRYPOINT å‘½ä»¤ï¼Œå¤šæŒ‡å®šæ—¶ä¼šè¦†ç›–å‰é¢çš„è®¾ç½®ï¼Œè€Œåªæ‰§è¡Œæœ€åçš„ ENTRYPOINT æŒ‡ä»¤ã€‚ ENTRYPOINT æœ‰ä»¥ä¸‹ä¸¤ç§æ ¼å¼ï¼š # å¯æ‰§è¡Œæ–‡ä»¶åŠ å‚æ•° ENTRYPOINT [\u0026#34;executable\u0026#34;, \u0026#34;param1\u0026#34;, \u0026#34;param2\u0026#34;] # shell æ ¼å¼ ENTRYPOINT command param1 param2 ä¸CMDæ¯”è¾ƒã€‚\nç›¸åŒç‚¹ï¼šåªèƒ½å†™ä¸€æ¡ï¼Œå¦‚æœå†™äº†å¤šæ¡ï¼Œé‚£ä¹ˆåªæœ‰æœ€åä¸€æ¡ç”Ÿæ•ˆï¼›å®¹å™¨å¯åŠ¨æ—¶æ‰è¿è¡Œï¼Œè¿è¡Œæ—¶æœºç›¸åŒã€‚ ä¸åŒç‚¹ï¼šENTRYPOINT ä¸ä¼šè¢«è¿è¡Œçš„ command è¦†ç›–ï¼Œè€Œ CMD åˆ™ä¼šè¢«è¦†ç›–ã€‚å¦‚æœæˆ‘ä»¬åœ¨Dockerfileç§åŒæ—¶å†™äº†ENTRYPOINTå’ŒCMDï¼Œå¹¶ä¸”CMDæŒ‡ä»¤ä¸æ˜¯ä¸€ä¸ªå®Œæ•´çš„å¯æ‰§è¡Œå‘½ä»¤ï¼Œé‚£ä¹ˆCMDæŒ‡å®šçš„å†…å®¹å°†ä¼šä½œä¸ºENTRYPOINTçš„å‚æ•°ã€‚ ç¤ºä¾‹ï¼š\nFROM ubuntu # æœ€ç»ˆæ‰§è¡Œ top -b -c ENTRYPOINT [\u0026#34;top\u0026#34;, \u0026#34;-b\u0026#34;] CMD [\u0026#34;-c\u0026#34;] å¦‚æœæˆ‘ä»¬åœ¨Dockerfileç§åŒæ—¶å†™äº†ENTRYPOINTå’ŒCMDï¼Œå¹¶ä¸”CMDæ˜¯ä¸€ä¸ªå®Œæ•´çš„æŒ‡ä»¤ï¼Œé‚£ä¹ˆå®ƒä»¬ä¸¤ä¸ªä¼šäº’ç›¸è¦†ç›–ï¼Œè°åœ¨æœ€åè°ç”Ÿæ•ˆã€‚ FROM ubuntu # é‚£ä¹ˆå°†æ‰§è¡Œls -al ,top -bä¸ä¼šæ‰§è¡Œã€‚ ENTRYPOINT [\u0026#34;top\u0026#34;, \u0026#34;-b\u0026#34;] CMD ls -al Docker å®˜æ–¹å…³äº ENTRYPOINT å’ŒCMDä¸åŒç»„åˆçš„æ‰§è¡Œæƒ…å†µã€‚ No ENTRYPOINT ENTRYPOINT exec_entry p1_entry ENTRYPOINT [\u0026ldquo;exec_entry\u0026rdquo;, \u0026ldquo;p1_entry\u0026rdquo;] No CMD error,not allowed /bin/sh -c exec_entry p1_entry exec_entry p1_entry CMD [\u0026ldquo;exec_cmd\u0026rdquo;, \u0026ldquo;p1_cmd\u0026rdquo;] exec_cmd p1_cmd /bin/sh -c exec_entry p1_entry exec_entry p1_entry; exec_cmd p1_cmd CMD [\u0026ldquo;p1_cmd\u0026rdquo;, \u0026ldquo;p2_cmd\u0026rdquo;] p1_cmd p2_cmd /bin/sh -c exec_entry p1_entry exec_entry p1_entry p1_cmd p2_cmd CMD exec_cmd p1_cmd /bin/sh -c exec_cmd p1_cmd /bin/sh -c exec_entry p1_entry exec_entry p1_entry /bin/sh -c exec_cmd p1_cmd COPY COPY æŒ‡ä»¤å°†ä»æ„å»ºä¸Šä¸‹æ–‡ç›®å½•ä¸­\u0026lt;src\u0026gt;çš„æ–‡ä»¶/ç›®å½•å¤åˆ¶åˆ°æ–°çš„ä¸€å±‚çš„é•œåƒå†…çš„\u0026lt;dest\u0026gt;ä½ç½®ã€‚ã€‚ è¯­æ³•ï¼š # ç±»ä¼¼äºå‘½ä»¤è¡Œã€‚ä» src åˆ° destã€‚ COPY \u0026lt;src\u0026gt;... \u0026lt;dest\u0026gt; # ç±»ä¼¼äºå‡½æ•°è°ƒç”¨ã€‚ä» src åˆ° destã€‚ COPY [\u0026#34;\u0026lt;src\u0026gt;\u0026#34;,... \u0026#34;\u0026lt;dest\u0026gt;\u0026#34;] ç¤ºä¾‹ï¼š # æ‹·è´æ„å»ºä¸Šä¸‹æ–‡çš„ package.json æ–‡ä»¶åˆ°å®¹å™¨ /usr/src/app/ COPY package.json /usr/src/app/ \u0026lt;src\u0026gt;å¯ä»¥æ˜¯å¤šä¸ªï¼Œç”šè‡³å¯ä»¥æ˜¯é€šé…ç¬¦ï¼Œå…¶é€šé…ç¬¦è§„åˆ™è¦æ»¡è¶³ Go çš„ filepath.Match è§„åˆ™ã€‚ COPY hom* /mydir/ COPY hom?.txt /mydir/ \u0026lt;dest\u0026gt;å¯ä»¥æ˜¯å®¹å™¨å†…çš„ç»å¯¹è·¯å¾„ï¼Œä¹Ÿå¯ä»¥æ˜¯ç›¸å¯¹äºå·¥ä½œç›®å½•çš„ç›¸å¯¹è·¯å¾„ï¼ˆå·¥ä½œç›®å½•å¯ä»¥ç”¨ WORKDIR æŒ‡ä»¤æ¥æŒ‡å®šï¼‰ã€‚\u0026lt;dest\u0026gt;ä¸éœ€è¦äº‹å…ˆåˆ›å»ºï¼Œå¦‚æœç›®å½•ä¸å­˜åœ¨ä¼šåœ¨å¤åˆ¶æ–‡ä»¶å‰å…ˆè¡Œåˆ›å»ºç¼ºå¤±ç›®å½•ã€‚ ä½¿ç”¨ COPY æŒ‡ä»¤ï¼Œæºæ–‡ä»¶çš„å„ç§å…ƒæ•°æ®éƒ½ä¼šä¿ç•™ã€‚æ¯”å¦‚è¯»ã€å†™ã€æ‰§è¡Œæƒé™ã€æ–‡ä»¶å˜æ›´æ—¶é—´ç­‰ã€‚ ADD ADD æŒ‡ä»¤å’Œ COPY çš„æ ¼å¼å’Œæ€§è´¨åŸºæœ¬ä¸€è‡´ã€‚ä½†æ˜¯åœ¨ COPY åŸºç¡€ä¸Šå¢åŠ äº†ä¸€äº›åŠŸèƒ½ã€‚ æ¯”å¦‚\u0026lt;src\u0026gt;å¯ä»¥æ˜¯ä¸€ä¸ª URLï¼Œè¿™ç§æƒ…å†µä¸‹ï¼ŒDocker å¼•æ“ä¼šè¯•å›¾å»ä¸‹è½½è¿™ä¸ªé“¾æ¥çš„æ–‡ä»¶æ”¾åˆ°\u0026lt;dest\u0026gt;å»ã€‚ï¼ˆç±»ä¼¼äºwgetå‘½ä»¤ï¼‰ \u0026lt;src\u0026gt;å¯ä»¥æ˜¯ä¸€ä¸ªæœ¬åœ°æ–‡ä»¶æˆ–è€…æ˜¯ä¸€ä¸ªæœ¬åœ°å‹ç¼©æ–‡ä»¶ï¼Œè¿˜å¯ä»¥æ˜¯ä¸€ä¸ªurlã€‚ è¯­æ³•ï¼š # ç±»ä¼¼äºå‘½ä»¤è¡Œã€‚ä» src åˆ° destã€‚ ADD \u0026lt;src\u0026gt;... \u0026lt;dest\u0026gt; # ç±»ä¼¼äºå‡½æ•°è°ƒç”¨ã€‚ä» src åˆ° destã€‚ ADD [\u0026#34;\u0026lt;src\u0026gt;\u0026#34;,... \u0026#34;\u0026lt;dest\u0026gt;\u0026#34;] ç¤ºä¾‹ï¼š ADD test relativeDir/ ADD test /relativeDir ADD http://example.com/foobar / å°½é‡ä¸è¦æŠŠ\u0026lt;scr\u0026gt;å†™æˆä¸€ä¸ªæ–‡ä»¶å¤¹ï¼Œå¦‚æœ\u0026lt;src\u0026gt;æ˜¯ä¸€ä¸ªæ–‡ä»¶å¤¹äº†ï¼Œå¤åˆ¶æ•´ä¸ªç›®å½•çš„å†…å®¹,åŒ…æ‹¬æ–‡ä»¶ç³»ç»Ÿå…ƒæ•°æ®ã€‚ å¦‚æœ docker å‘ç°æ–‡ä»¶å†…å®¹è¢«æ”¹å˜ï¼Œåˆ™æ¥ä¸‹æ¥çš„æŒ‡ä»¤éƒ½ä¸ä¼šå†ä½¿ç”¨ç¼“å­˜ã€‚ LABEL LABEL ç”¨äºä¸ºé•œåƒæ·»åŠ å…ƒæ•°æ®ï¼Œå…ƒæ•°ä»¥é”®å€¼å¯¹çš„å½¢å¼æŒ‡å®šï¼š ä½¿ç”¨LABELæŒ‡å®šå…ƒæ•°æ®æ—¶ï¼Œä¸€æ¡LABELæŒ‡å®šå¯ä»¥æŒ‡å®šä¸€æˆ–å¤šæ¡å…ƒæ•°æ®ï¼ŒæŒ‡å®šå¤šæ¡å…ƒæ•°æ®æ—¶ä¸åŒå…ƒæ•°æ®ä¹‹é—´é€šè¿‡ç©ºæ ¼åˆ†éš”ï¼ˆæˆ–**\\**ï¼‰ã€‚ æ¨èå°†æ‰€æœ‰çš„å…ƒæ•°æ®é€šè¿‡ä¸€æ¡LABELæŒ‡ä»¤æŒ‡å®šï¼Œä»¥å…ç”Ÿæˆè¿‡å¤šçš„ä¸­é—´é•œåƒã€‚ LABEL \u0026lt;key\u0026gt;=\u0026lt;value\u0026gt; \u0026lt;key\u0026gt;=\u0026lt;value\u0026gt; \u0026lt;key\u0026gt;=\u0026lt;value\u0026gt; ... LABELä¼šç»§æ‰¿åŸºç¡€é•œåƒç§çš„LABELï¼Œå¦‚é‡åˆ°keyç›¸åŒï¼Œåˆ™å€¼è¦†ç›–ã€‚ ç¤ºä¾‹ï¼š LABEL version=\u0026#34;1.0\u0026#34; description=\u0026#34;web\u0026#34; bx=\u0026#34;it\u0026#34; æŒ‡å®šåå¯ä»¥é€šè¿‡docker inspectæŸ¥çœ‹ï¼š $ docker inspect itbilu/test \u0026#34;Labels\u0026#34;: { \u0026#34;version\u0026#34;: \u0026#34;1.0\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;web\u0026#34;, \u0026#34;bx\u0026#34;: \u0026#34;it\u0026#34; }, MAINTAINER æŒ‡å®šä½œè€…ã€‚è¯­æ³•ï¼š MAINTAINER \u0026lt;name\u0026gt; EXPOSE ä¸ºæ„å»ºçš„é•œåƒè®¾ç½®ç›‘å¬ç«¯å£ï¼Œä½¿å®¹å™¨åœ¨è¿è¡Œæ—¶ç›‘å¬ã€‚æ ¼å¼ï¼š EXPOSE \u0026lt;port\u0026gt; [\u0026lt;port\u0026gt;...] EXPOSE æŒ‡ä»¤å¹¶ä¸ä¼šè®©å®¹å™¨ç›‘å¬ host çš„ç«¯å£ï¼Œå¦‚æœéœ€è¦ï¼Œéœ€è¦åœ¨ docker run æ—¶ä½¿ç”¨ -pã€-P å‚æ•°æ¥å‘å¸ƒå®¹å™¨ç«¯å£åˆ° host çš„æŸä¸ªç«¯å£ä¸Šã€‚ ENV è¿™ä¸ªæŒ‡ä»¤å¾ˆç®€å•ï¼Œå°±æ˜¯è®¾ç½®ç¯å¢ƒå˜é‡è€Œå·²ï¼Œæ— è®ºæ˜¯åé¢çš„å…¶å®ƒæŒ‡ä»¤ï¼Œå¦‚ RUNï¼Œè¿˜æ˜¯è¿è¡Œæ—¶çš„åº”ç”¨ï¼Œéƒ½å¯ä»¥ç›´æ¥ä½¿ç”¨è¿™é‡Œå®šä¹‰çš„ç¯å¢ƒå˜é‡ã€‚ è¯­æ³•æœ‰ä¸¤ç§ï¼šä¸¤è€…çš„åŒºåˆ«å°±æ˜¯ç¬¬ä¸€ç§æ˜¯ä¸€æ¬¡è®¾ç½®ä¸€ä¸ªï¼Œç¬¬äºŒç§æ˜¯ä¸€æ¬¡è®¾ç½®å¤šä¸ªã€‚ ENV \u0026lt;key\u0026gt; \u0026lt;value\u0026gt; ENV \u0026lt;key\u0026gt;=\u0026lt;value\u0026gt; ... ç¤ºä¾‹ï¼š ENV VERSION=1.0 DEBUG=on \\ NAME=\u0026#34;Ht\u0026#34; USER è®¾ç½®å¯åŠ¨å®¹å™¨çš„ç”¨æˆ·ï¼Œå¯ä»¥æ˜¯ç”¨æˆ·åæˆ–UIDï¼Œæ‰€ä»¥ï¼Œåªæœ‰ä¸‹é¢çš„ä¸¤ç§å†™æ³•æ˜¯æ­£ç¡®çš„ã€‚ æ³¨æ„ï¼šå¦‚æœè®¾ç½®äº†å®¹å™¨ä»¥daemonç”¨æˆ·å»è¿è¡Œï¼Œé‚£ä¹ˆRUN, CMD å’Œ ENTRYPOINT éƒ½ä¼šä»¥è¿™ä¸ªç”¨æˆ·å»è¿è¡Œã€‚ é•œåƒæ„å»ºå®Œæˆåï¼Œé€šè¿‡ docker run è¿è¡Œå®¹å™¨æ—¶ï¼Œå¯ä»¥é€šè¿‡ -u å‚æ•°æ¥è¦†ç›–æ‰€æŒ‡å®šçš„ç”¨æˆ·ã€‚ USER daemo USER UID ä½¿ç”¨USERæŒ‡å®šç”¨æˆ·æ—¶ï¼Œå¯ä»¥ä½¿ç”¨ç”¨æˆ·åã€UID æˆ– GIDï¼Œæˆ–æ˜¯ä¸¤è€…çš„ç»„åˆã€‚ä»¥ä¸‹éƒ½æ˜¯åˆæ³•çš„æŒ‡å®šè¯•ï¼š USER user USER user:group USER uid USER uid:gid USER user:gid USER uid:group ARG ARGç”¨äºæŒ‡å®šä¼ é€’ç»™æ„å»ºè¿è¡Œæ—¶çš„å˜é‡ï¼š ARG \u0026lt;name\u0026gt;[=\u0026lt;default value\u0026gt;] å¦‚ï¼Œé€šè¿‡ARGæŒ‡å®šä¸¤ä¸ªå˜é‡ï¼š ARG site ARG build_user=it ä»¥ä¸Šæˆ‘ä»¬æŒ‡å®šäº† site å’Œ build_user ä¸¤ä¸ªå˜é‡ï¼Œå…¶ä¸­ build_user æŒ‡å®šäº†é»˜è®¤å€¼ã€‚åœ¨ä½¿ç”¨ docker build æ„å»ºé•œåƒæ—¶ï¼Œå¯ä»¥é€šè¿‡ --build-arg \u0026lt;varname\u0026gt;=\u0026lt;value\u0026gt; å‚æ•°æ¥æŒ‡å®šæˆ–é‡è®¾ç½®è¿™äº›å˜é‡çš„å€¼ã€‚ docker build --build-arg site=xxx.com -t itbilu/test . è¿™æ ·æˆ‘ä»¬æ„å»ºäº† itbilu/test é•œåƒï¼Œå…¶ä¸­siteä¼šè¢«è®¾ç½®ä¸º itbilu.comï¼Œç”±äºæ²¡æœ‰æŒ‡å®š build_userï¼Œå…¶å€¼å°†æ˜¯é»˜è®¤å€¼ itã€‚ ONBUILD ONBUILDç”¨äºè®¾ç½®é•œåƒè§¦å‘å™¨ï¼šè¿™ä¸ªå‘½ä»¤åªå¯¹å½“å‰é•œåƒçš„å­é•œåƒç”Ÿæ•ˆã€‚ ONBUILD [INSTRUCTION] æ¯”å¦‚å½“å‰é•œåƒä¸ºAï¼Œåœ¨Dockerfileç§æ·»åŠ ï¼šONBUILD RUN ls -alï¼Œè¿™ä¸ª ls -al å‘½ä»¤ä¸ä¼šåœ¨Aé•œåƒæ„å»ºæˆ–å¯åŠ¨çš„æ—¶å€™æ‰§è¡Œï¼Œæ­¤æ—¶æœ‰ä¸€ä¸ªé•œåƒBæ˜¯åŸºäºAé•œåƒæ„å»ºçš„ï¼Œé‚£ä¹ˆè¿™ä¸ªls -al å‘½ä»¤ä¼šåœ¨Bé•œåƒæ„å»ºçš„æ—¶å€™è¢«æ‰§è¡Œã€‚ STOPSIGNAL STOPSIGNALç”¨äºè®¾ç½®åœæ­¢å®¹å™¨æ‰€è¦å‘é€çš„ç³»ç»Ÿè°ƒç”¨ä¿¡å·ï¼š STOPSIGNAL signal æ‰€ä½¿ç”¨çš„ä¿¡å·å¿…é¡»æ˜¯å†…æ ¸ç³»ç»Ÿè°ƒç”¨è¡¨ä¸­çš„åˆæ³•çš„å€¼ï¼Œå¦‚ï¼šSIGKILLã€‚ WORKDIR WORKDIRç”¨äºåœ¨å®¹å™¨å†…è®¾ç½®ä¸€ä¸ªå·¥ä½œç›®å½•ï¼š WORKDIR /path/to/workdir é€šè¿‡WORKDIRè®¾ç½®å·¥ä½œç›®å½•åï¼ŒDockerfile ä¸­å…¶åçš„å‘½ä»¤ RUNã€CMDã€ENTRYPOINTã€ADDã€COPY ç­‰å‘½ä»¤éƒ½ä¼šåœ¨è¯¥ç›®å½•ä¸‹æ‰§è¡Œã€‚ ä¾‹å¦‚ï¼š WORKDIR /a WORKDIR b WORKDIR c # pwdæ‰§è¡Œçš„ç»“æœæ˜¯/a/b/c RUN pwd WORKDIRä¹Ÿå¯ä»¥è§£æç¯å¢ƒå˜é‡ã€‚ ENV DIRPATH /path WORKDIR $DIRPATH/$DIRNAME # pwdçš„æ‰§è¡Œç»“æœæ˜¯/path/$DIRNAME RUN pwd VOLUME VOLUMEç”¨äºåˆ›å»ºæŒ‚è½½ç‚¹ï¼Œå³å‘åŸºäºæ‰€æ„å»ºé•œåƒåˆ›å§‹çš„å®¹å™¨æ·»åŠ å·ï¼š VOLUME [\u0026#34;/data\u0026#34;] ä¸€ä¸ªå·å¯ä»¥å­˜åœ¨äºä¸€ä¸ªæˆ–å¤šä¸ªå®¹å™¨çš„æŒ‡å®šç›®å½•ï¼Œè¯¥ç›®å½•å¯ä»¥ç»•è¿‡è”åˆæ–‡ä»¶ç³»ç»Ÿï¼Œå¹¶å…·æœ‰ä»¥ä¸‹åŠŸèƒ½ï¼š å·å¯ä»¥å®¹å™¨é—´å…±äº«å’Œé‡ç”¨ å®¹å™¨å¹¶ä¸ä¸€å®šè¦å’Œå…¶å®ƒå®¹å™¨å…±äº«å· ä¿®æ”¹å·åä¼šç«‹å³ç”Ÿæ•ˆ å¯¹å·çš„ä¿®æ”¹ä¸ä¼šå¯¹é•œåƒäº§ç”Ÿå½±å“ å·ä¼šä¸€ç›´å­˜åœ¨ï¼Œç›´åˆ°æ²¡æœ‰ä»»ä½•å®¹å™¨åœ¨ä½¿ç”¨å®ƒ VOLUME è®©æˆ‘ä»¬å¯ä»¥å°†æºä»£ç ã€æ•°æ®æˆ–å…¶å®ƒå†…å®¹æ·»åŠ åˆ°é•œåƒä¸­ï¼Œè€Œåˆä¸å¹¶æäº¤åˆ°é•œåƒä¸­ï¼Œå¹¶ä½¿æˆ‘ä»¬å¯ä»¥å¤šä¸ªå®¹å™¨é—´å…±äº«è¿™äº›å†…å®¹ã€‚ [\u0026quot;/data\u0026quot;]å¯ä»¥æ˜¯ä¸€ä¸ªJsonArray ï¼Œä¹Ÿå¯ä»¥æ˜¯å¤šä¸ªå€¼ã€‚æ‰€ä»¥å¦‚ä¸‹å‡ ç§å†™æ³•éƒ½æ˜¯æ­£ç¡®çš„ VOLUME [\u0026#34;/var/log/\u0026#34;] VOLUME /var/log VOLUME /var/log /var/db ä¸€èˆ¬çš„ä½¿ç”¨åœºæ™¯ä¸ºéœ€è¦æŒä¹…åŒ–å­˜å‚¨æ•°æ®æ—¶ã€‚å®¹å™¨ä½¿ç”¨çš„æ˜¯AUFSï¼Œè¿™ç§æ–‡ä»¶ç³»ç»Ÿä¸èƒ½æŒä¹…åŒ–æ•°æ®ï¼Œå½“å®¹å™¨å…³é—­åï¼Œæ‰€æœ‰çš„æ›´æ”¹éƒ½ä¼šä¸¢å¤±ã€‚æ‰€ä»¥å½“æ•°æ®éœ€è¦æŒä¹…åŒ–æ—¶ç”¨è¿™ä¸ªå‘½ä»¤ã€‚ Dockerfile ç¤ºä¾‹ æ„å»º nginx è¿è¡Œç¯å¢ƒã€‚ # æŒ‡å®šåŸºç¡€é•œåƒ FROM sameersbn/ubuntu:14.04.20161014 # ç»´æŠ¤è€…ä¿¡æ¯ MAINTAINER sameer@damagehead.com # è®¾ç½®ç¯å¢ƒ ENV RTMP_VERSION=1.1.10 \\ NPS_VERSION=1.11.33.4 \\ LIBAV_VERSION=11.8 \\ NGINX_VERSION=1.10.1 \\ NGINX_USER=www-data \\ NGINX_SITECONF_DIR=/etc/nginx/sites-enabled \\ NGINX_LOG_DIR=/var/log/nginx \\ NGINX_TEMP_DIR=/var/lib/nginx \\ NGINX_SETUP_DIR=/var/cache/nginx # è®¾ç½®æ„å»ºæ—¶å˜é‡ï¼Œé•œåƒå»ºç«‹å®Œæˆåå°±å¤±æ•ˆ ARG BUILD_LIBAV=false ARG WITH_DEBUG=false ARG WITH_PAGESPEED=true ARG WITH_RTMP=true # å¤åˆ¶æœ¬åœ°æ–‡ä»¶åˆ°å®¹å™¨ç›®å½•ä¸­ COPY setup/ ${NGINX_SETUP_DIR}/ RUN bash ${NGINX_SETUP_DIR}/install.sh # å¤åˆ¶æœ¬åœ°é…ç½®æ–‡ä»¶åˆ°å®¹å™¨ç›®å½•ä¸­ COPY nginx.conf /etc/nginx/nginx.conf COPY entrypoint.sh /sbin/entrypoint.sh # è¿è¡ŒæŒ‡ä»¤ RUN chmod 755 /sbin/entrypoint.sh # å…è®¸æŒ‡å®šçš„ç«¯å£ EXPOSE 80/tcp 443/tcp 1935/tcp # æŒ‡å®šç½‘ç«™ç›®å½•æŒ‚è½½ç‚¹ VOLUME [\u0026#34;${NGINX_SITECONF_DIR}\u0026#34;] ENTRYPOINT [\u0026#34;/sbin/entrypoint.sh\u0026#34;] CMD [\u0026#34;/usr/sbin/nginx\u0026#34;] ","permalink":"https://heliu.site/posts/docker/file/","summary":"dockerfile å‘½ä»¤ã€‚","title":"Dockerfile"},{"content":" github ç›¸å…³ docker-compose åœ°å€ https://github.com/docker/compose/tagsã€‚ docker-compose ä¾èµ– Dockerï¼Œè¯·å…ˆå®‰è£… Dockerã€‚ å®‰è£… docker-compose éœ€è¦æ³¨æ„ä¸ docker çš„ç‰ˆæœ¬åŒ¹é…ï¼Œæ›´å¤šå‚çœ‹å…·ä½“ç‰ˆæœ¬è¯¦æƒ…ã€‚ curl ä¸‹è½½å®‰è£… ä¸‹è½½ docker-compose 1 2 # æ³¨æ„æ›¿æ¢æˆè‡ªå·±æƒ³è¦çš„ç‰ˆæœ¬å·ï¼Œç”±äºæ˜¯è®¿é—®githubçš„èµ„æºï¼Œä¸‹è½½é€Ÿåº¦æœ‰æ—¶å€™å¯èƒ½ä¼šéå¸¸æ…¢ $ sudo curl -L \u0026#34;https://github.com/docker/compose/releases/download/v2.18.0/docker-compose-$(uname -s)-$(uname -m)\u0026#34; -o /usr/local/bin/docker-compose æˆäºˆæƒé™ã€‚ 1 $ sudo chmod +x /usr/local/bin/docker-compose æµ‹è¯•å®‰è£…ç»“æœã€‚ 1 $ docker-compose --version æ‰‹åŠ¨å®‰è£… è¿›å…¥ docker-compose çš„ github å‘å¸ƒé¡µï¼Œé€‰æ‹©åˆé€‚çš„ç‰ˆæœ¬ã€‚ æŠŠä¸‹è½½çš„æ–‡ä»¶ä¸Šä¼ åˆ° linuxã€‚ docker-composeäºŒè¿›åˆ¶æ–‡ä»¶ä¸Šä¼ åˆ°æœåŠ¡å™¨ç›®å½•åï¼Œéœ€è¦å°†äºŒè¿›åˆ¶æ–‡ä»¶æ‹·è´åˆ°/usr/local/binç›®å½•ä¸‹ï¼Œå¹¶ä¸”æ›´æ”¹åå­—ä¸ºdocker-composeã€‚ # æ‹·è´æ–‡ä»¶åˆ°/usr/local/binï¼Œå¦‚æœæ–‡ä»¶å·²ç»åœ¨/usr/local/binç›®å½•ï¼Œå¿½ç•¥æ­¤æ­¥éª¤ # å‡å¦‚äºŒè¿›åˆ¶æ–‡ä»¶docker-compose-linux-x86_64ä¸Šä¼ çš„ç›®å½•æ˜¯ï¼š/opt/docker cp /opt/docker/docker-compose-linux-x86_64 /usr/local/bin # æ›´æ”¹äºŒè¿›åˆ¶æ–‡ä»¶åå­— mv docker-compose-linux-x86_64 docker-compose æˆäºˆæƒé™ã€‚ 1 $ sudo chmod +x /usr/local/bin/docker-compose æµ‹è¯•å®‰è£…ç»“æœã€‚ 1 $ docker-compose --version ","permalink":"https://heliu.site/posts/docker/compose-install/","summary":"centos7 å®‰è£… docker-compose","title":"linux å®‰è£… docker-compose"},{"content":" Docker-Compose é¡¹ç›®æ˜¯Dockerå®˜æ–¹çš„å¼€æºé¡¹ç›®ï¼Œè´Ÿè´£å®ç°å¯¹Dockerå®¹å™¨é›†ç¾¤çš„å¿«é€Ÿç¼–æ’ã€‚ Docker-Compose é¡¹ç›®ç”± Python ç¼–å†™ï¼Œè°ƒç”¨ Docker æœåŠ¡æä¾›çš„APIæ¥å¯¹å®¹å™¨è¿›è¡Œç®¡ç†ã€‚å› æ­¤ï¼Œåªè¦æ‰€æ“ä½œçš„å¹³å°æ”¯æŒ Docker APIï¼Œå°±å¯ä»¥åœ¨å…¶ä¸Šåˆ©ç”¨å®ƒæ¥è¿›è¡Œç¼–æ’ç®¡ç†ã€‚ å…è®¸ç”¨æˆ·é€šè¿‡ä¸€ä¸ªdocker-compose.ymlæ¨¡æ¿æ–‡ä»¶ï¼ˆYAML æ ¼å¼ï¼‰æ¥å®šä¹‰ä¸€ç»„ç›¸å…³è”çš„åº”ç”¨å®¹å™¨ä¸ºä¸€ä¸ªé¡¹ç›®ï¼ˆprojectï¼‰ã€‚ æ¨¡æ¿æ–‡ä»¶é»˜è®¤è·¯å¾„æ˜¯å½“å‰ç›®å½•ä¸‹çš„docker-compose.ymlï¼Œå¯ä»¥ä½¿ç”¨.ymlæˆ–.yamlä½œä¸ºæ–‡ä»¶æ‰©å±•åã€‚ æ ‡å‡†æ¨¡æ¿æ–‡ä»¶åº”è¯¥åŒ…å«versionã€servicesã€networks ä¸‰å¤§éƒ¨åˆ†ï¼Œæœ€å…³é”®çš„æ˜¯serviceså’Œnetworksä¸¤ä¸ªéƒ¨åˆ†ã€‚ docker-compose.yml version æŒ‡å®šæœ¬ yml ä¾ä»çš„ compose å“ªä¸ªç‰ˆæœ¬åˆ¶å®šçš„ã€‚ services image æŒ‡å®šé•œåƒåç§°æˆ–é•œåƒIDã€‚ å¦‚æœé•œåƒä¸å­˜åœ¨ï¼Œå°†å°è¯•ä»äº’è”ç½‘æ‹‰å–è¿™ä¸ªé•œåƒï¼Œä¾‹å¦‚ï¼šimage: ubuntuã€image: a4bc65fdã€‚ æŒ‡å®šæœåŠ¡çš„é•œåƒåï¼Œè‹¥æœ¬åœ°ä¸å­˜åœ¨ï¼Œåˆ™ä¼šå»ä»“åº“æ‹‰å–è¿™ä¸ªé•œåƒã€‚ services: redis6: image: redis:6.2.3 build æŒ‡å®š Dockerfile æ‰€åœ¨æ–‡ä»¶å¤¹çš„è·¯å¾„ã€‚ å®ƒä¼šåˆ©ç”¨ä»–è‡ªåŠ¨æ„å»ºè¿™ä¸ªé•œåƒï¼Œç„¶åä½¿ç”¨è¿™ä¸ªé•œåƒã€‚ services: redis6: # ç»å¯¹è·¯å¾„ build: /path/to/build/dir services: redis6: # ç›¸å¯¹è·¯å¾„ï¼Œåªè¦ä¸Šä¸‹æ–‡ç¡®å®šå°±å¯ä»¥è¯»å–åˆ°Dockerfileã€‚ build: ./dir è®¾å®šä¸Šä¸‹æ–‡æ ¹ç›®å½•ï¼Œç„¶åä»¥è¯¥ç›®å½•ä¸ºå‡†æŒ‡å®šDockerfileã€‚ services: redis6: # ç›¸å¯¹è·¯å¾„ï¼Œåªè¦ä¸Šä¸‹æ–‡ç¡®å®šå°±å¯ä»¥è¯»å–åˆ°Dockerfileã€‚ build: context: ../ dockerfile: path/of/Dockerfile buildéƒ½æ˜¯ä¸€ä¸ªç›®å½•ï¼Œå¦‚æœè¦æŒ‡å®šDockerfileæ–‡ä»¶éœ€è¦åœ¨buildæ ‡ç­¾çš„å­çº§æ ‡ç­¾ä¸­ä½¿ç”¨dockerfileæ ‡ç­¾æŒ‡å®šã€‚ å¦‚æœåŒæ—¶æŒ‡å®šimageå’Œbuildä¸¤ä¸ªæ ‡ç­¾ï¼Œé‚£ä¹ˆComposeä¼šæ„å»ºé•œåƒå¹¶ä¸”æŠŠé•œåƒå‘½åä¸ºimageå€¼æŒ‡å®šçš„åå­—ã€‚ context contexté€‰é¡¹å¯ä»¥æ˜¯Dockerfileçš„æ–‡ä»¶è·¯å¾„ï¼Œä¹Ÿå¯ä»¥æ˜¯åˆ°é“¾æ¥åˆ°gitä»“åº“çš„urlï¼Œå½“æä¾›çš„å€¼æ˜¯ç›¸å¯¹è·¯å¾„æ—¶ï¼Œè¢«è§£æä¸ºç›¸å¯¹äºæ’°å†™æ–‡ä»¶çš„è·¯å¾„ï¼Œæ­¤ç›®å½•ä¹Ÿæ˜¯å‘é€åˆ°Dockerå®ˆæŠ¤è¿›ç¨‹çš„contextã€‚ services: redis6: # ç›¸å¯¹è·¯å¾„ï¼Œåªè¦ä¸Šä¸‹æ–‡ç¡®å®šå°±å¯ä»¥è¯»å–åˆ°Dockerfileã€‚ build: context: ./dir dockerfile ä½¿ç”¨dockerfileæ–‡ä»¶æ¥æ„å»ºï¼Œå¿…é¡»æŒ‡å®šæ„å»ºè·¯å¾„ã€‚ services: redis6: # ç›¸å¯¹è·¯å¾„ï¼Œåªè¦ä¸Šä¸‹æ–‡ç¡®å®šå°±å¯ä»¥è¯»å–åˆ°Dockerfileã€‚ build: context: . dockerfile: Dockerfile-alternate command è¦†ç›–å®¹å™¨å¯åŠ¨åé»˜è®¤æ‰§è¡Œçš„å‘½ä»¤ã€‚ services: redis6: image: redis:6.2.3 command: redis-server /etc/redis/redis.conf ports portsç”¨äºæ˜ å°„ç«¯å£çš„æ ‡ç­¾ã€‚ ä½¿ç”¨ HOST:CONTAINER æ ¼å¼æˆ–è€…åªæ˜¯æŒ‡å®šå®¹å™¨çš„ç«¯å£ï¼Œå®¿ä¸»æœºä¼šéšæœºæ˜ å°„ç«¯å£ã€‚ å½“ä½¿ç”¨ HOST:CONTAINER æ ¼å¼æ¥æ˜ å°„ç«¯å£æ—¶ï¼Œå¦‚æœä½¿ç”¨çš„å®¹å™¨ç«¯å£å°äº60å¯èƒ½ä¼šå¾—åˆ°é”™è¯¯å¾—ç»“æœï¼Œå› ä¸ºYAMLå°†ä¼šè§£æxx:yyè¿™ç§æ•°å­—æ ¼å¼ä¸º60è¿›åˆ¶ã€‚æ‰€ä»¥å»ºè®®é‡‡ç”¨å­—ç¬¦ä¸²æ ¼å¼ã€‚ services: redis6: ports: - \u0026#34;3000\u0026#34; - \u0026#34;8000:8000\u0026#34; - \u0026#34;49100:22\u0026#34; - \u0026#34;127.0.0.1:8001:8001\u0026#34; container_name å®¹å™¨åç§°æ ¼å¼æ˜¯ï¼š\u0026lt;é¡¹ç›®åç§°\u0026gt;\u0026lt;æœåŠ¡åç§°\u0026gt;\u0026lt;åºå·\u0026gt;ã€‚ å¯ä»¥è‡ªå®šä¹‰é¡¹ç›®åç§°ã€æœåŠ¡åç§°ï¼Œä½†å¦‚æœæƒ³å®Œå…¨æ§åˆ¶å®¹å™¨çš„å‘½åï¼Œå¯ä»¥ä½¿ç”¨æ ‡ç­¾æŒ‡å®šï¼š services: redis6: image: redis:6.2.3 container_name: redis6 depends_on ä¸€èˆ¬é¡¹ç›®å®¹å™¨å¯åŠ¨çš„é¡ºåºæ˜¯æœ‰è¦æ±‚çš„ï¼Œå¦‚æœç›´æ¥ä»ä¸Šåˆ°ä¸‹å¯åŠ¨å®¹å™¨ï¼Œå¿…ç„¶ä¼šå› ä¸ºå®¹å™¨ä¾èµ–é—®é¢˜è€Œå¯åŠ¨å¤±è´¥ã€‚ ä¾‹å¦‚åœ¨æ²¡å¯åŠ¨æ•°æ®åº“å®¹å™¨çš„æ—¶å€™å¯åŠ¨åº”ç”¨å®¹å™¨ï¼Œåº”ç”¨å®¹å™¨ä¼šå› ä¸ºæ‰¾ä¸åˆ°æ•°æ®åº“è€Œé€€å‡ºã€‚ depends_onæ ‡ç­¾ç”¨äºè§£å†³å®¹å™¨çš„ä¾èµ–ã€å¯åŠ¨å…ˆåçš„é—®é¢˜ã€‚ version: \u0026#39;2\u0026#39; services: web: build: . depends_on: - db - redis redis: image: redis db: image: postgres ä¸Šè¿°YAMLæ–‡ä»¶å®šä¹‰çš„å®¹å™¨ä¼šå…ˆå¯åŠ¨rediså’Œdbä¸¤ä¸ªæœåŠ¡ï¼Œæœ€åæ‰å¯åŠ¨ web æœåŠ¡ã€‚ PID å°†PIDæ¨¡å¼è®¾ç½®ä¸ºä¸»æœºPIDæ¨¡å¼ï¼Œè·Ÿä¸»æœºç³»ç»Ÿå…±äº«è¿›ç¨‹å‘½åç©ºé—´ã€‚å®¹å™¨ä½¿ç”¨pidæ ‡ç­¾å°†èƒ½å¤Ÿè®¿é—®å’Œæ“çºµå…¶ä»–å®¹å™¨å’Œå®¿ä¸»æœºçš„åç§°ç©ºé—´ã€‚ pid: \u0026#34;host\u0026#34; extra_hosts æ·»åŠ ä¸»æœºåçš„æ ‡ç­¾ï¼Œä¼šåœ¨/etc/hostsæ–‡ä»¶ä¸­æ·»åŠ ä¸€äº›è®°å½•ã€‚ extra_hosts: - \u0026#34;somehost:162.242.195.82\u0026#34; - \u0026#34;otherhost:50.31.209.229\u0026#34; å¯åŠ¨åæŸ¥çœ‹å®¹å™¨å†…éƒ¨hostsï¼š 162.242.195.82 somehost 50.31.209.229 otherhost volumes æŒ‚è½½ä¸€ä¸ªç›®å½•æˆ–è€…ä¸€ä¸ªå·²å­˜åœ¨çš„æ•°æ®å·å®¹å™¨ï¼Œå¯ä»¥ç›´æ¥ä½¿ç”¨ [HOST:CONTAINER] æ ¼å¼ï¼Œæˆ–è€…ä½¿ç”¨ [HOST:CONTAINER:ro] æ ¼å¼ï¼Œåè€…å¯¹äºå®¹å™¨æ¥è¯´ï¼Œæ•°æ®å·æ˜¯åªè¯»çš„ï¼Œå¯ä»¥æœ‰æ•ˆä¿æŠ¤å®¿ä¸»æœºçš„æ–‡ä»¶ç³»ç»Ÿã€‚ æ•°æ®å·æŒ‡å®šè·¯å¾„å¯ä»¥æ˜¯ç›¸å¯¹è·¯å¾„ï¼Œä½¿ç”¨ . æˆ–è€… .. æ¥æŒ‡å®šç›¸å¯¹ç›®å½•ã€‚ volumes: // åªæ˜¯æŒ‡å®šä¸€ä¸ªè·¯å¾„ï¼ŒDocker ä¼šè‡ªåŠ¨åœ¨åˆ›å»ºä¸€ä¸ªæ•°æ®å·ï¼ˆè¿™ä¸ªè·¯å¾„æ˜¯å®¹å™¨å†…éƒ¨çš„ï¼‰ã€‚ - /var/lib/mysql // ä½¿ç”¨ç»å¯¹è·¯å¾„æŒ‚è½½æ•°æ®å· - /opt/data:/var/lib/mysql // ä»¥ Compose é…ç½®æ–‡ä»¶ä¸ºä¸­å¿ƒçš„ç›¸å¯¹è·¯å¾„ä½œä¸ºæ•°æ®å·æŒ‚è½½åˆ°å®¹å™¨ã€‚ - ./cache:/tmp/cache // ä½¿ç”¨ç”¨æˆ·çš„ç›¸å¯¹è·¯å¾„ï¼ˆ~/ è¡¨ç¤ºçš„ç›®å½•æ˜¯ /home/\u0026lt;ç”¨æˆ·ç›®å½•\u0026gt;/ æˆ–è€… /root/ï¼‰ã€‚ - ~/configs:/etc/configs/:ro // å·²ç»å­˜åœ¨çš„å‘½åçš„æ•°æ®å·ã€‚ - datavolume:/var/lib/mysql å¦‚æœä¸ä½¿ç”¨å®¿ä¸»æœºçš„è·¯å¾„ï¼Œå¯ä»¥æŒ‡å®šä¸€ä¸ªvolume_driverã€‚ volumes_from ä»å¦ä¸€ä¸ªæœåŠ¡æˆ–å®¹å™¨æŒ‚è½½å…¶æ•°æ®å·ï¼š volumes_from: - service_name - container_name dns è‡ªå®šä¹‰DNSæœåŠ¡å™¨ã€‚å¯ä»¥æ˜¯ä¸€ä¸ªå€¼ï¼Œä¹Ÿå¯ä»¥æ˜¯ä¸€ä¸ªåˆ—è¡¨ã€‚ dnsï¼š8.8.8.8 dnsï¼š - 8.8.8.8 - 9.9.9.9 expose æš´éœ²ç«¯å£ï¼Œä½†ä¸æ˜ å°„åˆ°å®¿ä¸»æœºï¼Œåªå…è®¸èƒ½è¢«è¿æ¥çš„æœåŠ¡è®¿é—®ã€‚ä»…å¯ä»¥æŒ‡å®šå†…éƒ¨ç«¯å£ä¸ºå‚æ•°ï¼Œå¦‚ä¸‹æ‰€ç¤ºï¼š expose: - \u0026#34;3000\u0026#34; - \u0026#34;8000\u0026#34; links é“¾æ¥åˆ°å…¶å®ƒæœåŠ¡ä¸­çš„å®¹å™¨ã€‚ä½¿ç”¨æœåŠ¡åç§°ï¼ˆåŒæ—¶ä½œä¸ºåˆ«åï¼‰ï¼Œæˆ–è€…æœåŠ¡åç§°:æœåŠ¡åˆ«åï¼ˆå¦‚ SERVICE:ALIASï¼‰ï¼Œä¾‹å¦‚ links: - db - db:database - redis ç¤ºä¾‹ version: \u0026#39;3.9\u0026#39; services: redis6: image: redis:6.2.3 container_name: redis6 privileged: true restart: unless-stopped command: redis-server /etc/redis/redis.conf #ports: # - \u0026#34;6379:6379\u0026#34; volumes: - /app/docker/redis7/data:/data - ./docker/redis/redis.conf:/etc/redis/redis.conf - /etc/localtime:/etc/localtime:ro logging: driver: \u0026#34;json-file\u0026#34; options: max-size: \u0026#34;20m\u0026#34; max-file: \u0026#34;3\u0026#34; healthcheck: test: [ \u0026#34;CMD\u0026#34;, \u0026#34;redis-cli\u0026#34;, \u0026#34;ping\u0026#34; ] interval: 10s timeout: 1s retries: 3 network_mode: \u0026#34;container:nginx20\u0026#34; depends_on: - nginx20 mysql8: image: mysql:8.0.19 container_name: mysql8 privileged: true restart: unless-stopped environment: TZ: Asia/Shanghai MYSQL_ROOT_PASSWORD: 123456 MYSQL_DATABASE: test character-set-server: utf8mb4 collation-server: utf8mb4_general_ci default-authentication-plugin: mysql_native_password volumes: - ./docker/mysql/initdb:/docker-entrypoint-initdb.d - ./docker/mysql/my.cnf:/etc/mysql/conf.d/my.cnf - /app/docker/mysql8/data:/var/lib/mysql - /etc/localtime:/etc/localtime:ro #ports: # - \u0026#34;3306:3306\u0026#34; logging: driver: \u0026#34;json-file\u0026#34; options: max-size: \u0026#34;20m\u0026#34; max-file: \u0026#34;3\u0026#34; healthcheck: test: [ \u0026#34;CMD\u0026#34;, \u0026#34;mysqladmin\u0026#34; ,\u0026#34;ping\u0026#34;, \u0026#34;-h\u0026#34;, \u0026#34;localhost\u0026#34;, \u0026#34;--silent\u0026#34; ] interval: 10s timeout: 10s retries: 3 network_mode: \u0026#34;container:nginx20\u0026#34; depends_on: - nginx20 nginx20: image: nginx:${NGINX_VERSION:-1.20.2} container_name: nginx20 privileged: true restart: unless-stopped ports: - \u0026#34;80:80\u0026#34; - \u0026#34;443:443\u0026#34; - \u0026#34;3306:3306\u0026#34; - \u0026#34;6379:6379\u0026#34; - \u0026#34;8080:8080\u0026#34; - \u0026#34;8888:8888\u0026#34; volumes: - ./docker/nginx/html:/usr/share/nginx/html - ./docker/nginx/cert:/etc/nginx/cert - ./docker/nginx/nginx.conf:/etc/nginx/nginx.conf - ./docker/nginx/conf.d:/etc/nginx/conf.d - /app/docker/nginx/logs:/var/log/nginx environment: - TZ=Asia/Shanghai healthcheck: test: [ \u0026#34;CMD\u0026#34;, \u0026#34;curl\u0026#34;, \u0026#34;-f\u0026#34;, \u0026#34;http://localhost\u0026#34; ] interval: 30s timeout: 10s retries: 3 networks: - default_net api: container_name: greet-api build: context: ./greet/api dockerfile: Dockerfile privileged: true command: [ \u0026#34;/app/wait-for-it.sh\u0026#34;, \u0026#34;localhost:3306\u0026#34;, \u0026#34;-t\u0026#34;, \u0026#34;30\u0026#34;, \u0026#34;--\u0026#34;, \u0026#34;/app/wait-for-it.sh\u0026#34;, \u0026#34;localhost:6379\u0026#34;, \u0026#34;-t\u0026#34;, \u0026#34;30\u0026#34;, \u0026#34;--\u0026#34;, \u0026#34;/app/main\u0026#34; ] depends_on: - nginx20 - mysql8 - redis6 #ports: # - \u0026#34;8888:8888\u0026#34; network_mode: \u0026#34;container:nginx20\u0026#34; networks: default_net: driver: bridge ","permalink":"https://heliu.site/posts/docker/compose/","summary":"docker-compose ä»‹ç»ã€‚","title":"docker-compose"},{"content":"epoll æœåŠ¡å™¨å¯åŠ¨ä»¥åï¼ŒæœåŠ¡ç«¯ä¼šå»è°ƒç”¨epoll_createï¼Œåˆ›å»ºä¸€ä¸ªepollå®ä¾‹ï¼Œepollå®ä¾‹ä¸­åŒ…å«ä¸¤ä¸ªæ•°æ®ã€‚ çº¢é»‘æ ‘ï¼ˆä¸ºç©ºï¼‰ï¼šrb_root ç”¨æ¥å»è®°å½•éœ€è¦è¢«ç›‘å¬çš„FDã€‚ é“¾è¡¨ï¼ˆä¸ºç©ºï¼‰ï¼šlist_headï¼Œç”¨æ¥å­˜æ”¾å·²ç»å°±ç»ªçš„FDã€‚ åˆ›å»ºå¥½äº†ä¹‹åï¼Œä¼šå»è°ƒç”¨epoll_ctlå‡½æ•°ï¼Œæ­¤å‡½æ•°ä¼šä¼šå°†éœ€è¦ç›‘å¬çš„æ•°æ®æ·»åŠ åˆ°rb_rootä¸­å»ï¼Œå¹¶ä¸”å¯¹å½“å‰è¿™äº›å­˜åœ¨äºçº¢é»‘æ ‘çš„èŠ‚ç‚¹è®¾ç½®å›è°ƒå‡½æ•°ï¼Œå½“è¿™äº›è¢«ç›‘å¬çš„æ•°æ®ä¸€æ—¦å‡†å¤‡å®Œæˆï¼Œå°±ä¼šè¢«è°ƒç”¨ï¼Œè€Œè°ƒç”¨çš„ç»“æœå°±æ˜¯å°†çº¢é»‘æ ‘çš„fdæ·»åŠ åˆ°list_headä¸­å»(ä½†æ˜¯æ­¤æ—¶å¹¶æ²¡æœ‰å®Œæˆ)ã€‚ å½“ç¬¬äºŒæ­¥å®Œæˆåï¼Œå°±ä¼šè°ƒç”¨epoll_waitå‡½æ•°ï¼Œè¿™ä¸ªå‡½æ•°ä¼šå»æ ¡éªŒæ˜¯å¦æœ‰æ•°æ®å‡†å¤‡å®Œæ¯•ï¼ˆå› ä¸ºæ•°æ®ä¸€æ—¦å‡†å¤‡å°±ç»ªï¼Œå°±ä¼šè¢«å›è°ƒå‡½æ•°æ·»åŠ åˆ°list_headä¸­ï¼‰ï¼Œåœ¨ç­‰å¾…äº†ä¸€æ®µæ—¶é—´å(å¯ä»¥è¿›è¡Œé…ç½®)ï¼Œå¦‚æœç­‰å¤Ÿäº†è¶…æ—¶æ—¶é—´ï¼Œåˆ™è¿”å›æ²¡æœ‰æ•°æ®ï¼Œå¦‚æœæœ‰ï¼Œåˆ™è¿›ä¸€æ­¥åˆ¤æ–­å½“å‰æ˜¯ä»€ä¹ˆäº‹ä»¶ï¼Œå¦‚æœæ˜¯å»ºç«‹è¿æ¥æ—¶é—´ï¼Œåˆ™è°ƒç”¨accept() æ¥å—å®¢æˆ·ç«¯socketï¼Œæ‹¿åˆ°å»ºç«‹è¿æ¥çš„socketï¼Œç„¶åå»ºç«‹èµ·æ¥è¿æ¥ï¼Œå¦‚æœæ˜¯å…¶ä»–äº‹ä»¶ï¼Œåˆ™æŠŠæ•°æ®è¿›è¡Œå†™å‡ºã€‚ redis æµç¨‹ redis å•çº¿ç¨‹ç½‘ç»œæ¨¡å‹æµç¨‹ã€‚ redis å¤šçº¿ç¨‹ç½‘ç»œæ¨¡å‹æµç¨‹ã€‚ redis æ€è€ƒ Redisåˆ°åº•æ˜¯å•çº¿ç¨‹è¿˜æ˜¯å¤šçº¿ç¨‹ï¼Ÿ å¦‚æœä»…ä»…èŠRedisçš„æ ¸å¿ƒä¸šåŠ¡éƒ¨åˆ†ï¼ˆå‘½ä»¤å¤„ç†ï¼‰ï¼Œç­”æ¡ˆæ˜¯å•çº¿ç¨‹ å¦‚æœæ˜¯èŠæ•´ä¸ªRedisï¼Œé‚£ä¹ˆç­”æ¡ˆå°±æ˜¯å¤šçº¿ç¨‹ åœ¨Redisç‰ˆæœ¬è¿­ä»£è¿‡ç¨‹ä¸­ï¼Œåœ¨ä¸¤ä¸ªé‡è¦çš„æ—¶é—´èŠ‚ç‚¹ä¸Šå¼•å…¥äº†å¤šçº¿ç¨‹çš„æ”¯æŒï¼š Redis v4.0ï¼šå¼•å…¥å¤šçº¿ç¨‹å¼‚æ­¥å¤„ç†ä¸€äº›è€—æ—¶è¾ƒæ—§çš„ä»»åŠ¡ï¼Œä¾‹å¦‚å¼‚æ­¥åˆ é™¤å‘½ä»¤unlinkã€‚ Redis v6.0ï¼šåœ¨æ ¸å¿ƒç½‘ç»œæ¨¡å‹ä¸­å¼•å…¥å¤šçº¿ç¨‹ï¼Œè¿›ä¸€æ­¥æé«˜å¯¹äºå¤šæ ¸CPUçš„åˆ©ç”¨ç‡ã€‚ å› æ­¤ï¼Œå¯¹äºRedisçš„æ ¸å¿ƒç½‘ç»œæ¨¡å‹ï¼Œåœ¨Redis 6.0ä¹‹å‰ç¡®å®éƒ½æ˜¯å•çº¿ç¨‹ã€‚æ˜¯åˆ©ç”¨epollï¼ˆLinuxç³»ç»Ÿï¼‰è¿™æ ·çš„IOå¤šè·¯å¤ç”¨æŠ€æœ¯åœ¨äº‹ä»¶å¾ªç¯ä¸­ä¸æ–­å¤„ç†å®¢æˆ·ç«¯æƒ…å†µã€‚ ä¸ºä»€ä¹ˆRedisè¦é€‰æ‹©å•çº¿ç¨‹ï¼Ÿ æŠ›å¼€æŒä¹…åŒ–ä¸è°ˆï¼ŒRedisæ˜¯çº¯å†…å­˜æ“ä½œï¼Œæ‰§è¡Œé€Ÿåº¦éå¸¸å¿«ï¼Œå®ƒçš„æ€§èƒ½ç“¶é¢ˆæ˜¯ç½‘ç»œå»¶è¿Ÿè€Œä¸æ˜¯æ‰§è¡Œé€Ÿåº¦ï¼Œå› æ­¤å¤šçº¿ç¨‹å¹¶ä¸ä¼šå¸¦æ¥å·¨å¤§çš„æ€§èƒ½æå‡ã€‚ å¤šçº¿ç¨‹ä¼šå¯¼è‡´è¿‡å¤šçš„ä¸Šä¸‹æ–‡åˆ‡æ¢ï¼Œå¸¦æ¥ä¸å¿…è¦çš„å¼€é”€ã€‚ å¼•å…¥å¤šçº¿ç¨‹ä¼šé¢ä¸´çº¿ç¨‹å®‰å…¨é—®é¢˜ï¼Œå¿…ç„¶è¦å¼•å…¥çº¿ç¨‹é”è¿™æ ·çš„å®‰å…¨æ‰‹æ®µï¼Œå®ç°å¤æ‚åº¦å¢é«˜ï¼Œè€Œä¸”æ€§èƒ½ä¹Ÿä¼šå¤§æ‰“æŠ˜æ‰£ã€‚ ","permalink":"https://heliu.site/posts/redis/theory/","summary":"redis IOå¤šè·¯å¤ç”¨ã€‚","title":"redis ç½‘ç»œæ¨¡å‹"},{"content":"è¿‡æœŸ key Redisä¹‹æ‰€ä»¥æ€§èƒ½å¼ºï¼Œæœ€ä¸»è¦çš„åŸå› å°±æ˜¯åŸºäºå†…å­˜å­˜å‚¨ã€‚ç„¶è€Œå•èŠ‚ç‚¹çš„Rediså…¶å†…å­˜å¤§å°ä¸å®œè¿‡å¤§ï¼Œä¼šå½±å“æŒä¹…åŒ–æˆ–ä¸»ä»åŒæ­¥æ€§èƒ½ã€‚ æˆ‘ä»¬å¯ä»¥é€šè¿‡ä¿®æ”¹é…ç½®æ–‡ä»¶æ¥è®¾ç½®Redisçš„æœ€å¤§å†…å­˜ï¼š # æ ¼å¼ # maxmemory \u0026lt;bytes\u0026gt; # è®¾ç½®redisæœ€å¤§å†…å­˜ä¸º 1GB maxmemory 1gb å½“å†…å­˜ä½¿ç”¨è¾¾åˆ°ä¸Šé™æ—¶ï¼Œå°±æ— æ³•å­˜å‚¨æ›´å¤šæ•°æ®äº†ã€‚Redisæä¾›äº†ä¸€äº›ç­–ç•¥å®ç°å†…å­˜å›æ”¶ã€‚ æ¯”å¦‚é€šè¿‡expireå‘½ä»¤ç»™Redisçš„keyè®¾ç½®TTLï¼ˆå­˜æ´»æ—¶é—´ï¼‰ã€‚ å½“keyçš„TTLåˆ°æœŸä»¥åï¼Œå†æ¬¡è®¿é—®nameè¿”å›çš„æ˜¯nilï¼Œè¯´æ˜è¿™ä¸ªkeyå·²ç»ä¸å­˜åœ¨äº†ï¼Œå¯¹åº”çš„å†…å­˜ä¹Ÿå¾—åˆ°é‡Šæ”¾ã€‚ä»è€Œèµ·åˆ°å†…å­˜å›æ”¶çš„ç›®çš„ã€‚ Redisæœ¬èº«æ˜¯ä¸€ä¸ªå…¸å‹çš„key-valueå†…å­˜å­˜å‚¨æ•°æ®åº“ï¼Œå› æ­¤æ‰€æœ‰çš„keyã€valueéƒ½ä¿å­˜åœ¨Dictï¼ˆå­—å…¸ï¼‰ç»“æ„ä¸­ã€‚ä¸è¿‡æœ‰ä¸¤ä¸ªDictï¼šä¸€ä¸ªç”¨æ¥è®°å½•key-valueï¼›å¦ä¸€ä¸ªç”¨æ¥è®°å½•key-TTLã€‚ Redisæ˜¯å¦‚ä½•çŸ¥é“ä¸€ä¸ªkeyæ˜¯å¦è¿‡æœŸå‘¢ï¼Ÿ åˆ©ç”¨ä¸¤ä¸ªDictåˆ†åˆ«è®°å½•key-valueå¯¹åŠkey-ttlå¯¹ã€‚ æ˜¯ä¸æ˜¯TTLåˆ°æœŸå°±ç«‹å³åˆ é™¤äº†å‘¢ï¼Ÿ ä¸æ˜¯ï¼Œredisæœ‰ä¸¤ç§ç­–ç•¥ï¼Œæƒ°æ€§åˆ é™¤ã€å‘¨æœŸæ€§åˆ é™¤ã€‚ æƒ°æ€§åˆ é™¤ ä¸æ˜¯åœ¨TTLåˆ°æœŸåå°±ç«‹åˆ»åˆ é™¤ï¼Œè€Œæ˜¯åœ¨è®¿é—®ä¸€ä¸ªkeyçš„æ—¶å€™ï¼Œæ£€æŸ¥è¯¥keyçš„å­˜æ´»æ—¶é—´ï¼Œå¦‚æœå·²ç»è¿‡æœŸæ‰æ‰§è¡Œåˆ é™¤ã€‚ å‘¨æœŸæ€§åˆ é™¤ é€šè¿‡ä¸€ä¸ªå®šæ—¶ä»»åŠ¡ï¼Œå‘¨æœŸæ€§çš„æŠ½æ ·éƒ¨åˆ†è¿‡æœŸçš„keyï¼Œç„¶åæ‰§è¡Œåˆ é™¤ã€‚ æ‰§è¡Œå‘¨æœŸæœ‰ä¸¤ç§ï¼šSLOWã€FASTæ¨¡å¼ã€‚ SLOW æ¨¡å¼ï¼šRedisæœåŠ¡åˆå§‹åŒ–å‡½æ•°initServer()ä¸­è®¾ç½®å®šæ—¶ä»»åŠ¡ï¼ŒæŒ‰ç…§server.hzï¼ˆé»˜è®¤10ï¼‰çš„é¢‘ç‡æ¥æ‰§è¡Œè¿‡æœŸkeyæ¸…ç†ã€‚ æ‰§è¡Œé¢‘ç‡å—server.hzå½±å“ï¼Œé»˜è®¤ä¸º10ï¼Œå³æ¯ç§’æ‰§è¡Œ10æ¬¡ï¼Œæ¯ä¸ªæ‰§è¡Œå‘¨æœŸ100msã€‚ æ‰§è¡Œæ¸…ç†è€—æ—¶ä¸è¶…è¿‡ä¸€æ¬¡æ‰§è¡Œå‘¨æœŸçš„25%ï¼Œé»˜è®¤slowæ¨¡å¼è€—æ—¶ä¸è¶…è¿‡25msã€‚ é€ä¸ªéå†dbï¼Œé€ä¸ªéå†dbä¸­çš„bucketï¼ŒæŠ½å–20ä¸ªkeyåˆ¤æ–­æ˜¯å¦è¿‡æœŸã€‚ å¦‚æœæ²¡è¾¾åˆ°æ—¶é—´ä¸Šé™ï¼ˆ25msï¼‰å¹¶ä¸”è¿‡æœŸkeyæ¯”ä¾‹å¤§äº10%ï¼Œå†è¿›è¡Œä¸€æ¬¡æŠ½æ ·ï¼Œå¦åˆ™ç»“æŸã€‚ FAST æ¨¡å¼ï¼šRedisçš„æ¯ä¸ªäº‹ä»¶å¾ªç¯å‰ä¼šè°ƒç”¨beforeSleep()å‡½æ•°ï¼Œæ‰§è¡Œè¿‡æœŸkeyæ¸…ç†ã€‚ï¼ˆè¿‡æœŸkeyæ¯”ä¾‹å°äº10%ä¸æ‰§è¡Œ ï¼‰ æ‰§è¡Œé¢‘ç‡å—beforeSleep()è°ƒç”¨é¢‘ç‡å½±å“ï¼Œä½†ä¸¤æ¬¡FASTæ¨¡å¼é—´éš”ä¸ä½äº2msã€‚ æ‰§è¡Œæ¸…ç†è€—æ—¶ä¸è¶…è¿‡1msã€‚ é€ä¸ªéå†dbï¼Œé€ä¸ªéå†dbä¸­çš„bucketï¼ŒæŠ½å–20ä¸ªkeyåˆ¤æ–­æ˜¯å¦è¿‡æœŸï¼Œå¦‚æœæ²¡è¾¾åˆ°æ—¶é—´ä¸Šé™ï¼ˆ1msï¼‰å¹¶ä¸”è¿‡æœŸkeyæ¯”ä¾‹å¤§äº10%ï¼Œå†è¿›è¡Œä¸€æ¬¡æŠ½æ ·ï¼Œå¦åˆ™ç»“æŸã€‚ æ€»ç»“ RedisKeyçš„TTLè®°å½•æ–¹å¼ï¼š åœ¨RedisDBä¸­é€šè¿‡ä¸€ä¸ªDictè®°å½•æ¯ä¸ªKeyçš„TTLæ—¶é—´ã€‚ è¿‡æœŸkeyçš„åˆ é™¤ç­–ç•¥ï¼š æƒ°æ€§æ¸…ç†ï¼šæ¯æ¬¡æŸ¥æ‰¾keyæ—¶åˆ¤æ–­æ˜¯å¦è¿‡æœŸï¼Œå¦‚æœè¿‡æœŸåˆ™åˆ é™¤ã€‚ å®šæœŸæ¸…ç†ï¼šå®šæœŸæŠ½æ ·éƒ¨åˆ†keyï¼Œåˆ¤æ–­æ˜¯å¦è¿‡æœŸï¼Œå¦‚æœè¿‡æœŸåˆ™åˆ é™¤ã€‚ å®šæœŸæ¸…ç†çš„ä¸¤ç§æ¨¡å¼ï¼š SLOWæ¨¡å¼æ‰§è¡Œé¢‘ç‡é»˜è®¤ä¸º10ï¼Œæ¯æ¬¡ä¸è¶…è¿‡25msã€‚ FASTæ¨¡å¼æ‰§è¡Œé¢‘ç‡ä¸å›ºå®šï¼Œä½†ä¸¤æ¬¡é—´éš”ä¸ä½äº2msï¼Œæ¯æ¬¡è€—æ—¶ä¸è¶…è¿‡1msã€‚ å†…å­˜æ·˜æ±°ç­–ç•¥ å½“Rediså†…å­˜ä½¿ç”¨è¾¾åˆ°è®¾ç½®çš„ä¸Šé™æ—¶ï¼Œä¸»åŠ¨æŒ‘é€‰éƒ¨åˆ†keyåˆ é™¤ä»¥é‡Šæ”¾æ›´å¤šå†…å­˜çš„æµç¨‹ã€‚ Redisæ”¯æŒ8ç§ä¸åŒç­–ç•¥æ¥é€‰æ‹©è¦åˆ é™¤çš„keyï¼š noevictionï¼š ä¸æ·˜æ±°ä»»ä½•keyï¼Œä½†æ˜¯å†…å­˜æ»¡æ—¶ä¸å…è®¸å†™å…¥æ–°æ•°æ®ï¼Œé»˜è®¤å°±æ˜¯è¿™ç§ç­–ç•¥ã€‚ volatile-ttlï¼š å¯¹è®¾ç½®äº†TTLçš„keyï¼Œæ¯”è¾ƒkeyçš„å‰©ä½™TTLå€¼ï¼ŒTTLè¶Šå°è¶Šå…ˆè¢«æ·˜æ±°ã€‚ allkeys-randomï¼šå¯¹å…¨ä½“keyï¼Œéšæœºè¿›è¡Œæ·˜æ±°ã€‚ä¹Ÿå°±æ˜¯ç›´æ¥ä»db-\u0026gt;dictä¸­éšæœºæŒ‘é€‰ã€‚ volatile-randomï¼šå¯¹è®¾ç½®äº†TTLçš„keyï¼Œéšæœºè¿›è¡Œæ·˜æ±°ã€‚ä¹Ÿå°±æ˜¯ä»db-\u0026gt;expiresä¸­éšæœºæŒ‘é€‰ã€‚ allkeys-lruï¼š å¯¹å…¨ä½“keyï¼ŒåŸºäºLRUç®—æ³•è¿›è¡Œæ·˜æ±°ã€‚ volatile-lruï¼š å¯¹è®¾ç½®äº†TTLçš„keyï¼ŒåŸºäºLRUç®—æ³•è¿›è¡Œæ·˜æ±°ã€‚ allkeys-lfuï¼š å¯¹å…¨ä½“keyï¼ŒåŸºäºLFUç®—æ³•è¿›è¡Œæ·˜æ±°ã€‚ volatile-lfuï¼š å¯¹è®¾ç½®äº†TTLçš„keyï¼ŒåŸºäºLFIç®—æ³•è¿›è¡Œæ·˜æ±°ã€‚ LRUï¼ˆLeast Recently Usedï¼‰ï¼Œæœ€å°‘æœ€è¿‘ä½¿ç”¨ã€‚ç”¨å½“å‰æ—¶é—´å‡å»æœ€åä¸€æ¬¡è®¿é—®æ—¶é—´ï¼Œè¿™ä¸ªå€¼è¶Šå¤§åˆ™æ·˜æ±°ä¼˜å…ˆçº§è¶Šé«˜ã€‚ LFUï¼ˆLeast Frequently Usedï¼‰ï¼Œæœ€å°‘é¢‘ç‡ä½¿ç”¨ã€‚ä¼šç»Ÿè®¡æ¯ä¸ªkeyçš„è®¿é—®é¢‘ç‡ï¼Œå€¼è¶Šå°æ·˜æ±°ä¼˜å…ˆçº§è¶Šé«˜ã€‚ # redisè¿‡æœŸkeyçš„ç§»é™¤ç­–ç•¥ maxmemory-policy noeviction ","permalink":"https://heliu.site/posts/redis/memory/","summary":"redis å†…å­˜å›æ”¶ç­–ç•¥ã€‚","title":"redis å†…å­˜å›æ”¶"},{"content":" redis æ”¯æŒä¸¤ç§æŒä¹…åŒ–æ–¹æ¡ˆï¼šRDBã€AOFæŒä¹…åŒ–ã€‚ RDB æŒä¹…åŒ– RDBå…¨ç§°Redis Database Backup fileï¼ˆRedisæ•°æ®å¤‡ä»½æ–‡ä»¶ï¼‰ï¼Œä¹Ÿè¢«å«åšRedisæ•°æ®å¿«ç…§ã€‚ç®€å•æ¥è¯´å°±æ˜¯æŠŠå†…å­˜ä¸­çš„æ‰€æœ‰æ•°æ®éƒ½è®°å½•åˆ°ç£ç›˜ä¸­ã€‚ å½“Rediså®ä¾‹æ•…éšœé‡å¯åï¼Œä»ç£ç›˜è¯»å–å¿«ç…§æ–‡ä»¶ï¼Œæ¢å¤æ•°æ®ã€‚å¿«ç…§æ–‡ä»¶ç§°ä¸ºRDBæ–‡ä»¶ï¼Œé»˜è®¤æ˜¯ä¿å­˜åœ¨å½“å‰è¿è¡Œç›®å½•ã€‚ æ‰§è¡Œæ—¶æœº RDBæŒä¹…åŒ–åœ¨å››ç§æƒ…å†µä¸‹ä¼šæ‰§è¡Œï¼š æ‰§è¡Œsaveå‘½ä»¤ã€‚ æ‰§è¡Œbgsaveå‘½ä»¤ã€‚ Redisåœæœºæ—¶ã€‚ è§¦å‘RDBæ¡ä»¶æ—¶ã€‚ save å‘½ä»¤ æ‰§è¡Œä¸‹saveå‘½ä»¤ï¼Œå¯ä»¥ç«‹å³æ‰§è¡Œä¸€æ¬¡RDBã€‚ saveå‘½ä»¤ä¼šå¯¼è‡´ä¸»è¿›ç¨‹æ‰§è¡ŒRDBï¼Œè¿™ä¸ªè¿‡ç¨‹ä¸­å…¶å®ƒæ‰€æœ‰å‘½ä»¤éƒ½ä¼šè¢«é˜»å¡ã€‚åªæœ‰åœ¨æ•°æ®è¿ç§»æ—¶å¯èƒ½ç”¨åˆ°ã€‚ $ save ok bgsave å‘½ä»¤ bgsave å‘½ä»¤å¯ä»¥å¼‚æ­¥æ‰§è¡ŒRDBã€‚ bgsave å‘½ä»¤æ‰§è¡Œåä¼šå¼€å¯ç‹¬ç«‹è¿›ç¨‹å®ŒæˆRDBï¼Œä¸»è¿›ç¨‹å¯ä»¥æŒç»­å¤„ç†ç”¨æˆ·è¯·æ±‚ï¼Œä¸å—å½±å“ã€‚ $ bgsave Background saving started åœæœºæ—¶ Redisåœæœºæ—¶ä¼šæ‰§è¡Œä¸€æ¬¡saveå‘½ä»¤ï¼Œå®ç°RDBæŒä¹…åŒ–ã€‚ è§¦å‘RDBæ¡ä»¶ Rediså†…éƒ¨æœ‰è§¦å‘RDBçš„æœºåˆ¶ï¼Œå¯ä»¥åœ¨redis.confæ–‡ä»¶ä¸­æ‰¾åˆ°ï¼Œæ ¼å¼å¦‚ä¸‹ï¼š # å¦‚æœæ˜¯save \u0026#34;\u0026#34; åˆ™è¡¨ç¤ºç¦ç”¨RDB # 900ç§’å†…ï¼Œå¦‚æœè‡³å°‘æœ‰1ä¸ªkeyè¢«ä¿®æ”¹ï¼Œåˆ™æ‰§è¡Œbgsave save 900 1 # 300ç§’å†…ï¼Œå¦‚æœè‡³å°‘æœ‰10ä¸ªkeyè¢«ä¿®æ”¹ï¼Œåˆ™æ‰§è¡Œbgsave save 300 10 # 60ç§’å†…ï¼Œå¦‚æœè‡³å°‘æœ‰10000ä¸ªkeyè¢«ä¿®æ”¹ï¼Œåˆ™æ‰§è¡Œbgsave save 60 10000 RDBçš„å…¶å®ƒé…ç½®ä¹Ÿå¯ä»¥åœ¨redis.confæ–‡ä»¶ä¸­è®¾ç½®ã€‚ # æ˜¯å¦å‹ç¼© ,å»ºè®®ä¸å¼€å¯ # å‹ç¼©ä¹Ÿä¼šæ¶ˆè€—cpuï¼Œç£ç›˜çš„è¯ä¸å€¼é’± rdbcompression yes # å¤‡ä»½çš„RDBæ–‡ä»¶åç§° dbfilename dump.rdb # å¤‡ä»½æ–‡ä»¶ä¿å­˜çš„è·¯å¾„ç›®å½• dir ./ RDB åŸç† bgsaveå¼€å§‹æ—¶ä¼šforkä¸»è¿›ç¨‹å¾—åˆ°å­è¿›ç¨‹ï¼Œå­è¿›ç¨‹å…±äº«ä¸»è¿›ç¨‹çš„å†…å­˜æ•°æ®ã€‚å®Œæˆforkåè¯»å–å†…å­˜æ•°æ®å¹¶å†™å…¥ RDB æ–‡ä»¶ã€‚ forké‡‡ç”¨çš„æ˜¯copy-on-writeæŠ€æœ¯ï¼š å½“ä¸»è¿›ç¨‹æ‰§è¡Œè¯»æ“ä½œæ—¶ï¼Œè®¿é—®å…±äº«å†…å­˜ã€‚ å½“ä¸»è¿›ç¨‹æ‰§è¡Œå†™æ“ä½œæ—¶ï¼Œåˆ™ä¼šæ‹·è´ä¸€ä»½æ•°æ®ï¼Œæ‰§è¡Œå†™æ“ä½œã€‚ æ€»ç»“ RDBæ–¹å¼bgsaveçš„åŸºæœ¬æµç¨‹ï¼Ÿ forkä¸»è¿›ç¨‹å¾—åˆ°ä¸€ä¸ªå­è¿›ç¨‹ï¼Œå…±äº«å†…å­˜ç©ºé—´ã€‚ å­è¿›ç¨‹è¯»å–å†…å­˜æ•°æ®å¹¶å†™å…¥æ–°çš„RDBæ–‡ä»¶ã€‚ ç”¨æ–°RDBæ–‡ä»¶æ›¿æ¢æ—§çš„RDBæ–‡ä»¶ã€‚ RDBä¼šåœ¨ä»€ä¹ˆæ—¶å€™æ‰§è¡Œï¼Ÿsave 60 1000ä»£è¡¨ä»€ä¹ˆå«ä¹‰ï¼Ÿ é»˜è®¤æ˜¯æœåŠ¡åœæ­¢æ—¶ã€‚ ä»£è¡¨60ç§’å†…è‡³å°‘æ‰§è¡Œ1000æ¬¡ä¿®æ”¹åˆ™è§¦å‘RDBã€‚ RDBçš„ç¼ºç‚¹ï¼Ÿ RDBæ‰§è¡Œé—´éš”æ—¶é—´é•¿ï¼Œä¸¤æ¬¡RDBä¹‹é—´å†™å…¥æ•°æ®æœ‰ä¸¢å¤±çš„é£é™©ã€‚ forkå­è¿›ç¨‹ã€å‹ç¼©ã€å†™å‡ºRDBæ–‡ä»¶éƒ½æ¯”è¾ƒè€—æ—¶ã€‚ AOF æŒä¹…åŒ– AOF åŸç† AOFå…¨ç§°ä¸ºAppend Only Fileï¼ˆè¿½åŠ æ–‡ä»¶ï¼‰ã€‚Rediså¤„ç†çš„æ¯ä¸€ä¸ªå†™å‘½ä»¤éƒ½ä¼šè®°å½•åœ¨AOFæ–‡ä»¶ï¼Œå¯ä»¥çœ‹åšæ˜¯å‘½ä»¤æ—¥å¿—æ–‡ä»¶ã€‚ AOF é…ç½® AOFé»˜è®¤æ˜¯å…³é—­çš„ï¼Œéœ€è¦ä¿®æ”¹redis.confé…ç½®æ–‡ä»¶æ¥å¼€å¯AOFã€‚ # æ˜¯å¦å¼€å¯AOFåŠŸèƒ½ï¼Œé»˜è®¤æ˜¯no appendonly yes # AOFæ–‡ä»¶çš„åç§° appendfilename \u0026#34;appendonly.aof\u0026#34; AOFçš„å‘½ä»¤è®°å½•çš„é¢‘ç‡ä¹Ÿå¯ä»¥é€šè¿‡redis.confæ–‡ä»¶æ¥é…ã€‚ # è¡¨ç¤ºæ¯æ‰§è¡Œä¸€æ¬¡å†™å‘½ä»¤ï¼Œç«‹å³è®°å½•åˆ°AOFæ–‡ä»¶ appendfsync always # å†™å‘½ä»¤æ‰§è¡Œå®Œå…ˆæ”¾å…¥AOFç¼“å†²åŒºï¼Œç„¶åè¡¨ç¤ºæ¯éš”1ç§’å°†ç¼“å†²åŒºæ•°æ®å†™åˆ°AOFæ–‡ä»¶ï¼Œæ˜¯é»˜è®¤æ–¹æ¡ˆ appendfsync everysec # å†™å‘½ä»¤æ‰§è¡Œå®Œå…ˆæ”¾å…¥AOFç¼“å†²åŒºï¼Œç”±æ“ä½œç³»ç»Ÿå†³å®šä½•æ—¶å°†ç¼“å†²åŒºå†…å®¹å†™å›ç£ç›˜ appendfsync no ä¸‰ç§ç­–ç•¥å¯¹æ¯”ã€‚ é…ç½® åˆ·ç›˜æ—¶æœº ä¼˜ç‚¹ ç¼ºç‚¹ always åŒæ­¥åˆ·ç›˜ å¯é æ€§é«˜ï¼Œå‡ ä¹ä¸ä¸¢æ•°æ® æ€§èƒ½å½±å“å¤§ everysec æ¯ç§’åˆ·ç›˜ æ€§èƒ½é€‚ä¸­ æœ€å¤šä¸¢å¤±1ç§’æ•°æ® no æ“ä½œç³»ç»Ÿæ§åˆ¶ æ€§èƒ½æœ€å¥½ å¯é æ€§è¾ƒå·®ï¼Œå¯èƒ½ä¸¢å¤±å¤§é‡æ•°æ® AOF æ–‡ä»¶é‡å†™ å› ä¸ºæ˜¯è®°å½•å‘½ä»¤ï¼ŒAOFæ–‡ä»¶ä¼šæ¯”RDBæ–‡ä»¶å¤§çš„å¤šã€‚è€Œä¸”AOFä¼šè®°å½•å¯¹åŒä¸€ä¸ªkeyçš„å¤šæ¬¡å†™æ“ä½œï¼Œä½†åªæœ‰æœ€åä¸€æ¬¡å†™æ“ä½œæ‰æœ‰æ„ä¹‰ã€‚ é€šè¿‡æ‰§è¡Œbgrewriteaofå‘½ä»¤ï¼Œå¯ä»¥è®©AOFæ–‡ä»¶æ‰§è¡Œé‡å†™åŠŸèƒ½ï¼Œç”¨æœ€å°‘çš„å‘½ä»¤è¾¾åˆ°ç›¸åŒæ•ˆæœã€‚ AOFåŸæœ¬æœ‰ä¸‰ä¸ªå‘½ä»¤ï¼Œä½†æ˜¯set count 20 å’Œ set count 12 éƒ½æ˜¯å¯¹numçš„æ“ä½œï¼Œç¬¬äºŒæ¬¡ä¼šè¦†ç›–ç¬¬ä¸€æ¬¡çš„å€¼ï¼Œå› æ­¤ç¬¬ä¸€ä¸ªå‘½ä»¤è®°å½•ä¸‹æ¥æ²¡æœ‰æ„ä¹‰ã€‚ æ‰€ä»¥é‡å†™å‘½ä»¤åï¼ŒAOFæ–‡ä»¶å†…å®¹å°±æ˜¯ï¼šmset count 12 age 18ã€‚ Redisä¹Ÿä¼šåœ¨è§¦å‘é˜ˆå€¼æ—¶è‡ªåŠ¨å»é‡å†™AOFæ–‡ä»¶ã€‚é˜ˆå€¼ä¹Ÿå¯ä»¥åœ¨redis.confä¸­é…ç½®ã€‚ # AOFæ–‡ä»¶æ¯”ä¸Šæ¬¡æ–‡ä»¶ å¢é•¿è¶…è¿‡å¤šå°‘ç™¾åˆ†æ¯”åˆ™è§¦å‘é‡å†™ auto-aof-rewrite-percentage 100 # AOFæ–‡ä»¶ä½“ç§¯æœ€å°å¤šå¤§ä»¥ä¸Šæ‰è§¦å‘é‡å†™ auto-aof-rewrite-min-size 64mb RDB ä¸ AOF å¯¹æ¯” RDBå’ŒAOFå„æœ‰è‡ªå·±çš„ä¼˜ç¼ºç‚¹ï¼Œå¦‚æœå¯¹æ•°æ®å®‰å…¨æ€§è¦æ±‚è¾ƒé«˜ï¼Œåœ¨å®é™…å¼€å‘ä¸­å¾€å¾€ä¼šç»“åˆä¸¤è€…æ¥ä½¿ç”¨ã€‚ RDB AOF æŒä¹…åŒ–æ–¹å¼ å®šæ—¶å¯¹æ•´ä¸ªå†…å­˜åšå¿«ç…§ è®°å½•æ¯ä¸€æ¬¡æ‰§è¡Œçš„å‘½ä»¤ æ•°æ®å®Œæ•´æ€§ ä¸å®Œæ•´ï¼Œä¸¤æ¬¡å¤‡ä»½ä¹‹é—´ä¼šä¸¢å¤± ç›¸å¯¹å®Œæ•´ï¼Œå–å†³äºåˆ·ç›˜ç­–ç•¥ æ–‡ä»¶å¤§å° ä¼šæœ‰å‹ç¼©ï¼Œæ–‡ä»¶ä½“ç§¯å° è®°å½•å‘½ä»¤ï¼Œæ–‡ä»¶ä½“ç§¯å¾ˆå¤§ å®•æœºæ¢å¤é€Ÿåº¦ å¾ˆå¿« æ…¢ æ•°æ®æ¢å¤ä¼˜å…ˆçº§ ä½ï¼Œå› ä¸ºæ•°æ®å®Œæ•´æ€§ä¸å¦‚AOF é«˜ï¼Œå› ä¸ºæ•°æ®å®Œæ•´æ€§æ›´é«˜ ç³»ç»Ÿèµ„æºå ç”¨ é«˜ï¼Œå¤§é‡CPUå’Œå†…å­˜æ¶ˆè€— ä½ï¼Œä¸»è¦æ—¶ç£ç›˜IOèµ„æºï¼Œä½†AOFé‡å†™æ—¶ä¼šå ç”¨å¤§é‡CPUå’Œå†…å­˜èµ„æº ä½¿ç”¨åœºæ™¯ å¯ä»¥å®¹å¿æ•°åˆ†é’Ÿçš„æ•°æ®ä¸¢å¤±ï¼Œè¿½æ±‚æ›´å¿«çš„å¯åŠ¨é€Ÿåº¦ å¯¹æ•°æ®å®‰å…¨æ€§è¦æ±‚è¾ƒé«˜å¸¸è§ ","permalink":"https://heliu.site/posts/redis/persistence/","summary":"redis æ•°æ®æŒä¹…åŒ–ã€‚","title":"redis æŒä¹…åŒ–"},{"content":"ä¸»ä»æ¶æ„ å•èŠ‚ç‚¹ Redis çš„å¹¶å‘èƒ½åŠ›æ˜¯æœ‰ä¸Šé™çš„ï¼Œè¦è¿›ä¸€æ­¥æé«˜ Redis çš„å¹¶å‘èƒ½åŠ›ï¼Œå°±éœ€è¦æ­å»ºä¸»ä»é›†ç¾¤ï¼Œå®ç°è¯»å†™åˆ†ç¦»ã€‚ åŒæ­¥åŸç† å…¨é‡åŒæ­¥ ä¸»ä»ç¬¬ä¸€æ¬¡å»ºç«‹è¿æ¥æ—¶ï¼Œä¼šæ‰§è¡Œå…¨é‡åŒæ­¥ï¼Œå°†masterèŠ‚ç‚¹çš„æ‰€æœ‰æ•°æ®éƒ½æ‹·è´ç»™slaveèŠ‚ç‚¹ã€‚ replication id å’Œ offsetã€‚ Replication Idï¼šç®€ç§°replidï¼Œæ˜¯æ•°æ®é›†çš„æ ‡è®°ï¼Œidä¸€è‡´åˆ™è¯´æ˜æ˜¯åŒä¸€æ•°æ®é›†ã€‚æ¯ä¸€ä¸ªmasteréƒ½æœ‰å”¯ä¸€çš„replidï¼Œslaveåˆ™ä¼šç»§æ‰¿masterèŠ‚ç‚¹çš„replidã€‚ offsetï¼šåç§»é‡ï¼Œéšç€è®°å½•åœ¨repl_baklogä¸­çš„æ•°æ®å¢å¤šè€Œé€æ¸å¢å¤§ã€‚slaveå®ŒæˆåŒæ­¥æ—¶ä¹Ÿä¼šè®°å½•å½“å‰åŒæ­¥çš„offsetã€‚å¦‚æœslaveçš„offsetå°äºmasterçš„offsetï¼Œè¯´æ˜slaveæ•°æ®è½åäºmasterï¼Œéœ€è¦æ›´æ–°ã€‚ masterå¦‚ä½•å¾—çŸ¥salveæ˜¯ç¬¬ä¸€æ¬¡æ¥è¿æ¥ï¼Ÿ slaveåšæ•°æ®åŒæ­¥ï¼Œå¿…é¡»å‘masterå£°æ˜è‡ªå·±çš„replication idå’Œoffsetï¼Œmasteræ‰å¯ä»¥åˆ¤æ–­åˆ°åº•éœ€è¦åŒæ­¥å“ªäº›æ•°æ®ã€‚ slaveåŸæœ¬ä¹Ÿæ˜¯ä¸€ä¸ªmasterï¼Œæœ‰è‡ªå·±çš„replidå’Œoffsetï¼Œå½“ç¬¬ä¸€æ¬¡å˜æˆslaveï¼Œä¸masterå»ºç«‹è¿æ¥æ—¶ï¼Œå‘é€çš„replidå’Œoffsetæ˜¯è‡ªå·±çš„replidå’Œoffsetã€‚ masteråˆ¤æ–­å‘ç°slaveå‘é€æ¥çš„replidä¸è‡ªå·±çš„ä¸ä¸€è‡´ï¼Œè¯´æ˜è¿™æ˜¯ä¸€ä¸ªå…¨æ–°çš„slaveï¼Œå°±çŸ¥é“è¦åšå…¨é‡åŒæ­¥äº†ã€‚ masterä¼šå°†è‡ªå·±çš„replidå’Œoffsetéƒ½å‘é€ç»™è¿™ä¸ªslaveï¼Œslaveä¿å­˜è¿™äº›ä¿¡æ¯ã€‚ä»¥åslaveçš„replidå°±ä¸masterä¸€è‡´äº†ã€‚ å› æ­¤ï¼Œmasteråˆ¤æ–­ä¸€ä¸ªèŠ‚ç‚¹æ˜¯å¦æ˜¯ç¬¬ä¸€æ¬¡åŒæ­¥çš„ä¾æ®ï¼Œå°±æ˜¯çœ‹replidæ˜¯å¦ä¸€è‡´ã€‚ å®Œæ•´æµç¨‹æè¿°ï¼š slaveèŠ‚ç‚¹è¯·æ±‚å¢é‡åŒæ­¥ã€‚ masterèŠ‚ç‚¹åˆ¤æ–­replidï¼Œå‘ç°ä¸ä¸€è‡´ï¼Œæ‹’ç»å¢é‡åŒæ­¥ã€‚ masterå°†å®Œæ•´å†…å­˜æ•°æ®ç”ŸæˆRDBï¼Œå‘é€RDBåˆ°slaveã€‚ slaveæ¸…ç©ºæœ¬åœ°æ•°æ®ï¼ŒåŠ è½½masterçš„RDBã€‚ masterå°†RDBæœŸé—´çš„å‘½ä»¤è®°å½•åœ¨repl_baklogï¼Œå¹¶æŒç»­å°†logä¸­çš„å‘½ä»¤å‘é€ç»™slaveã€‚ slaveæ‰§è¡Œæ¥æ”¶åˆ°çš„å‘½ä»¤ï¼Œä¿æŒä¸masterä¹‹é—´çš„åŒæ­¥ã€‚ å¢é‡åŒæ­¥ å…¨é‡åŒæ­¥éœ€è¦å…ˆåšRDBï¼Œç„¶åå°†RDBæ–‡ä»¶é€šè¿‡ç½‘ç»œä¼ è¾“ä¸ªslaveï¼Œæˆæœ¬å¤ªé«˜äº†ã€‚å› æ­¤é™¤äº†ç¬¬ä¸€æ¬¡åšå…¨é‡åŒæ­¥ï¼Œå…¶å®ƒå¤§å¤šæ•°æ—¶å€™slaveä¸masteréƒ½æ˜¯åšå¢é‡åŒæ­¥ã€‚ ä»€ä¹ˆæ˜¯å¢é‡åŒæ­¥ï¼Ÿå°±æ˜¯åªæ›´æ–°slaveä¸masterå­˜åœ¨å·®å¼‚çš„éƒ¨åˆ†æ•°æ®ã€‚ repl_backlog repl_backlog æ–‡ä»¶æ˜¯ä¸€ä¸ªå›ºå®šå¤§å°çš„æ•°ç»„ï¼Œåªä¸è¿‡æ•°ç»„æ˜¯ç¯å½¢ï¼Œä¹Ÿå°±æ˜¯è¯´è§’æ ‡åˆ°è¾¾æ•°ç»„æœ«å°¾åï¼Œä¼šå†æ¬¡ä»0å¼€å§‹è¯»å†™ï¼Œè¿™æ ·æ•°ç»„å¤´éƒ¨çš„æ•°æ®å°±ä¼šè¢«è¦†ç›–ã€‚ repl_baklogä¸­ä¼šè®°å½•Rediså¤„ç†è¿‡çš„å‘½ä»¤æ—¥å¿—åŠoffsetï¼ŒåŒ…æ‹¬masterå½“å‰çš„offsetï¼Œå’Œslaveå·²ç»æ‹·è´åˆ°çš„offsetã€‚ éšç€ä¸æ–­æœ‰æ•°æ®å†™å…¥ï¼Œmasterçš„offseté€æ¸å˜å¤§ï¼Œslaveä¹Ÿä¸æ–­çš„æ‹·è´ï¼Œè¿½èµ¶masterçš„offsetã€‚ ä½†æ˜¯ï¼Œå¦‚æœslaveå‡ºç°ç½‘ç»œé˜»å¡ï¼Œå¯¼è‡´masterçš„offsetè¿œè¿œè¶…è¿‡äº†slaveçš„offsetã€‚ æ£•è‰²æ¡†ä¸­çš„çº¢è‰²éƒ¨åˆ†ï¼Œå°±æ˜¯å°šæœªåŒæ­¥ï¼Œä½†æ˜¯å´å·²ç»è¢«è¦†ç›–çš„æ•°æ®ã€‚æ­¤æ—¶å¦‚æœslaveæ¢å¤ï¼Œéœ€è¦åŒæ­¥ï¼Œå´å‘ç°è‡ªå·±çš„offsetéƒ½æ²¡æœ‰äº†ï¼Œæ— æ³•å®Œæˆå¢é‡åŒæ­¥äº†ã€‚åªèƒ½åšå…¨é‡åŒæ­¥ã€‚ æ³¨æ„ï¼šrepl_backlog æ–‡ä»¶å¤§å°æ˜¯æœ‰ä¸Šçº¿çš„ï¼Œå†™æ»¡åä¼šè¦†ç›–æœ€æ—©çš„æ•°æ®ã€‚å¦‚æœslaveæ–­å¼€æ—¶é—´å¤ªä¹…ï¼Œå¯¼è‡´å°šæœªå¤‡ä»½çš„æ•°æ®è¢«è¦†ç›–ï¼Œåˆ™æ— æ³•åŸºäºlogåšå¢é‡åŒæ­¥ï¼Œåªèƒ½å†æ¬¡å…¨é‡åŒæ­¥ã€‚ ä¼˜åŒ– ä¸»ä»åŒæ­¥å¯ä»¥ä¿è¯ä¸»ä»æ•°æ®çš„ä¸€è‡´æ€§ï¼Œéå¸¸é‡è¦ã€‚ å¯ä»¥ä»ä»¥ä¸‹å‡ ä¸ªæ–¹é¢æ¥ä¼˜åŒ–Redisä¸»ä»å°±é›†ç¾¤ï¼š åœ¨masterä¸­é…ç½®repl-diskless-sync yeså¯ç”¨æ— ç£ç›˜å¤åˆ¶ï¼Œé¿å…å…¨é‡åŒæ­¥æ—¶çš„ç£ç›˜IOã€‚ Rediså•èŠ‚ç‚¹ä¸Šçš„å†…å­˜å ç”¨ä¸è¦å¤ªå¤§ï¼Œå‡å°‘RDBå¯¼è‡´çš„è¿‡å¤šç£ç›˜IOã€‚ é€‚å½“æé«˜repl_baklogçš„å¤§å°ï¼Œå‘ç°slaveå®•æœºæ—¶å°½å¿«å®ç°æ•…éšœæ¢å¤ï¼Œå°½å¯èƒ½é¿å…å…¨é‡åŒæ­¥ã€‚ é™åˆ¶ä¸€ä¸ªmasterä¸Šçš„slaveèŠ‚ç‚¹æ•°é‡ï¼Œå¦‚æœå®åœ¨æ˜¯å¤ªå¤šslaveï¼Œåˆ™å¯ä»¥é‡‡ç”¨ä¸»-ä»-ä»é“¾å¼ç»“æ„ï¼Œå‡å°‘masterå‹åŠ›ã€‚ æ€»ç»“ å…¨é‡åŒæ­¥å’Œå¢é‡åŒæ­¥åŒºåˆ«ï¼Ÿ å…¨é‡åŒæ­¥ï¼šmasterå°†å®Œæ•´å†…å­˜æ•°æ®ç”ŸæˆRDBï¼Œå‘é€RDBåˆ°slaveã€‚åç»­å‘½ä»¤åˆ™è®°å½•åœ¨repl_baklogï¼Œé€ä¸ªå‘é€ç»™slaveã€‚ å¢é‡åŒæ­¥ï¼šslaveæäº¤è‡ªå·±çš„offsetåˆ°masterï¼Œmasterè·å–repl_baklogä¸­ä»offsetä¹‹åçš„å‘½ä»¤ç»™slaveã€‚ ä»€ä¹ˆæ—¶å€™æ‰§è¡Œå…¨é‡åŒæ­¥ï¼Ÿ slaveèŠ‚ç‚¹ç¬¬ä¸€æ¬¡è¿æ¥masterèŠ‚ç‚¹æ—¶ã€‚ slaveèŠ‚ç‚¹æ–­å¼€æ—¶é—´å¤ªä¹…ï¼Œrepl_baklogä¸­çš„offsetå·²ç»è¢«è¦†ç›–æ—¶ã€‚ ä»€ä¹ˆæ—¶å€™æ‰§è¡Œå¢é‡åŒæ­¥ï¼Ÿ slaveèŠ‚ç‚¹æ–­å¼€åˆæ¢å¤ï¼Œå¹¶ä¸”åœ¨repl_baklogä¸­èƒ½æ‰¾åˆ°offsetæ—¶ã€‚ ä¼˜ç‚¹ è§£å†³äº†å•æœºç‰ˆå¹¶å‘é‡å¤§ï¼Œå¯¼è‡´äº²æ±‚å»¶è¿Ÿæˆ–è€…rediså®•æœºæœåŠ¡åœæ­¢çš„é—®é¢˜ã€‚ ä»æ•°æ®åº“åˆ†æ‹…ä¸»æ•°æ®åº“çš„è¯»å‹åŠ›ï¼Œè‹¥æ˜¯ä¸»æ•°æ®åº“åªæ˜¯å†™æ¨¡å¼ï¼Œé‚£ä¹ˆå®ç°è¯»å†™åˆ†ç¦»ï¼Œä¸»æ•°æ®åº“å°±æ²¡æœ‰è¯»å‹åŠ›äº†ã€‚ è§£å†³äº†å•æœºç‰ˆå•ç‚¹æ•…éšœçš„é—®é¢˜ï¼Œè‹¥æ˜¯ä¸»æ•°æ®åº“æŒ‚äº†ï¼Œé‚£ä¹ˆä»æ•°æ®åº“å¯ä»¥éšæ—¶é¡¶ä¸Šæ¥ã€‚ ç¼ºç‚¹ æ•°æ®çš„ä¸€è‡´æ€§é—®é¢˜ï¼Œå‡å¦‚ä¸»æ•°æ®åº“å†™æ“ä½œå®Œæˆï¼Œé‚£ä¹ˆä»–çš„æ•°æ®ä¼šè¢«å¤åˆ¶åˆ°ä»æ•°æ®åº“ï¼Œè‹¥æ˜¯è¿˜æ²¡æœ‰åŠæ—¶å¤åˆ¶åˆ°ä»æ•°æ®åº“ï¼Œè¯»è¯·æ±‚åˆæ¥äº†ï¼Œæ­¤æ—¶è¯»å–çš„æ•°æ®å°±ä¸æ˜¯æœ€æ–°çš„æ•°æ®ã€‚ ä¸»ä»åŒæ­¥çš„è¿‡ç¨‹ç½‘ç»œå‡ºæ•…éšœäº†ï¼Œå¯¼è‡´ä¸»ä»åŒæ­¥å¤±è´¥ï¼Œä¹Ÿä¼šå‡ºç°æ•°æ®ä¸€è‡´æ€§çš„é—®é¢˜ã€‚ ä¸å…·å¤‡è‡ªåŠ¨å®¹é”™å’Œæ¢å¤çš„åŠŸèƒ½ï¼Œä¸€æ—¦ä¸»æ•°æ®åº“æŒ‚æ‰ï¼Œä»èŠ‚ç‚¹æ™‹å‡ä¸ºä¸»æ•°æ®åº“çš„è¿‡ç¨‹éœ€è¦äººä¸ºæ“ä½œï¼Œç»´æŠ¤çš„æˆæœ¬å°±ä¼šå‡é«˜ï¼Œå¹¶ä¸”ä¸»èŠ‚ç‚¹çš„å†™èƒ½åŠ›ï¼Œå­˜å‚¨èƒ½åŠ›éƒ½ä¼šå—åˆ°é™åˆ¶ã€‚ ä¸»ä»é›†ç¾¤æ­å»º å‡†å¤‡ä¸‰å°redisï¼Œä¸€å°masterï¼Œä¸¤å°slaveã€‚ å¼€å¯ä¸»ä»å…³ç³»å‘½ä»¤ã€‚é…ç½®ä¸»ä»å¯ä»¥ä½¿ç”¨ replicaof æˆ–è€… slaveofï¼ˆ5.0ä»¥å‰ï¼‰å‘½ä»¤ã€‚ æœ‰ä¸´æ—¶å’Œæ°¸ä¹…ä¸¤ç§æ¨¡å¼ï¼š ä¿®æ”¹é…ç½®æ–‡ä»¶ï¼ˆæ°¸ä¹…ç”Ÿæ•ˆï¼‰ï¼šåœ¨redis.confä¸­æ·»åŠ ä¸€è¡Œé…ç½® slaveof \u0026lt;masterip\u0026gt; \u0026lt;masterport\u0026gt;ã€‚ ä½¿ç”¨redis-cliå®¢æˆ·ç«¯è¿æ¥åˆ°redisæœåŠ¡ï¼Œæ‰§è¡Œslaveofå‘½ä»¤ï¼ˆé‡å¯åå¤±æ•ˆï¼‰ï¼šslaveof \u0026lt;masterip\u0026gt; \u0026lt;masterport\u0026gt;ã€‚ æ³¨æ„ï¼šåœ¨5.0ä»¥åæ–°å¢å‘½ä»¤replicaofï¼Œä¸salveofæ•ˆæœä¸€è‡´ã€‚ åœ¨ä»æœåŠ¡å™¨ä¸Šæ‰§è¡Œ slaveof \u0026lt;masterip\u0026gt; \u0026lt;masterport\u0026gt; å‘½ä»¤ï¼Œmasterip ä¸»ipï¼Œmasterport ä¸»ç«¯å£ã€‚ åœ¨ä¸»èŠ‚ç‚¹ä¸ŠæŸ¥çœ‹é›†ç¾¤ä¿¡æ¯å‘½ä»¤ï¼Œinfo replicationã€‚ slave é…ç½® slave èŠ‚ç‚¹ redis.conf é…ç½®æ–‡ä»¶ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 # ç›‘å¬æ¥è‡ªä»»æ„ç½‘ç»œæ¥å£çš„è¿æ¥ bind 0.0.0.0 # å…³é—­ä¿æŠ¤æ¨¡å¼ï¼Œæ¥æ”¶è¿œç¨‹è¿æ¥ protected-mode no # ç›‘å¬ç«¯å£ port 6379 # æŒ‡å®šå®¢æˆ·ç«¯ç©ºé—²å¤šå°‘ç§’åå…³é—­è¿æ¥ # è®¾ç½®ä¸º 0ï¼Œåˆ™ä¸ä¼šå› ä¸ºå®¢æˆ·ç«¯ç©ºé—²è€Œå…³é—­è¿æ¥ # è®¾ç½®ä¸ºæ­£æ•´æ•°ï¼Œè¡¨ç¤ºå®¢æˆ·ç«¯åœ¨æŒ‡å®šçš„æ—¶é—´å†…æ²¡æœ‰å‘é€ä»»ä½•æŒ‡ä»¤ï¼Œè¿æ¥å°†è¢«å…³é—­ time 0 # é»˜è®¤æ•°æ®åº“æ•°é‡ databases 1 #ç”¨å®ˆæŠ¤çº¿ç¨‹çš„æ–¹å¼å¯åŠ¨ daemonize no # yes : RDBå¿«ç…§ä¿å­˜å¤±è´¥å å®¢æˆ·ç«¯ä¸å¯å†™å…¥redisï¼Œåªå¯è¯»ã€‚ # no : ç¦ç”¨æ­¤åŠŸèƒ½ stop-writes-on-bgsave-error yes # æ˜¯å¦æ£€æŸ¥rdbå¿«ç…§çš„å®Œæ•´æ€§ï¼ŒæŸå¤±å¤§æ¦‚ ç™¾åˆ†ä¹‹å çš„æ€§èƒ½ rdbchecksum yes #æ‚¨å¯ä»¥é…ç½®å‰¯æœ¬å®ä¾‹ä»¥æ¥å—æˆ–ä¸æ¥å—å†™å…¥ã€‚ #å°±æ˜¯ä¸»ä»å¤åˆ¶ä¸­ï¼ŒslaveèŠ‚ç‚¹æ˜¯å¦å¯ä»¥å†™å…¥æ•°æ®ï¼ˆyesï¼šä¸èƒ½å†™å…¥ï¼›noï¼šå¯ä»¥å†™å…¥ï¼‰ replica-read-only yes # é…ç½®RDBæŒä¹…åŒ–æ¨¡å¼ # 900så†…è‡³å°‘ä¸€æ¬¡å†™æ“ä½œåˆ™æ‰§è¡Œbgsaveè¿›è¡ŒRDBæŒä¹…åŒ– # asve \u0026#34;\u0026#34; save 900 1 save 300 10 save 60 10000 # RDBæ˜¯å¦å‹ç¼© ,å»ºè®®ä¸å¼€å¯ # å‹ç¼©ä¹Ÿä¼šæ¶ˆè€—cpuï¼Œç£ç›˜çš„è¯ä¸å€¼é’± rdbcompression no # å¤‡ä»½çš„RDBæ–‡ä»¶åç§° dbfilename dump.rdb # å¤‡ä»½æ–‡ä»¶ä¿å­˜çš„è·¯å¾„ç›®å½• dir ./ # å¼€å¯ AOF æŒä¹…åŒ– appendonly yes # AOF æ¯ç§’åˆ·ç›˜ appendfsync everysec # AOFæ–‡ä»¶çš„åç§° appendfilename \u0026#34;appendonly.aof\u0026#34; # èŠ‚ç‚¹ç™»å½•å£ä»¤ requirepass 12345678 # é…ç½®ä¸»ä»ï¼Œå½“å‰ä»èŠ‚ç‚¹åŠ å…¥ä¸»èŠ‚ç‚¹ slaveof redis-master 6379 # ä¸»èŠ‚ç‚¹å£ä»¤ masterauth 12345678 master é…ç½® master èŠ‚ç‚¹ redis.conf é…ç½®æ–‡ä»¶ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 # ç›‘å¬æ¥è‡ªä»»æ„ç½‘ç»œæ¥å£çš„è¿æ¥ bind 0.0.0.0 # å…³é—­ä¿æŠ¤æ¨¡å¼ï¼Œæ¥æ”¶è¿œç¨‹è¿æ¥ protected-mode no # ç›‘å¬ç«¯å£ port 6379 # æŒ‡å®šå®¢æˆ·ç«¯ç©ºé—²å¤šå°‘ç§’åå…³é—­è¿æ¥ # è®¾ç½®ä¸º 0ï¼Œåˆ™ä¸ä¼šå› ä¸ºå®¢æˆ·ç«¯ç©ºé—²è€Œå…³é—­è¿æ¥ # è®¾ç½®ä¸ºæ­£æ•´æ•°ï¼Œè¡¨ç¤ºå®¢æˆ·ç«¯åœ¨æŒ‡å®šçš„æ—¶é—´å†…æ²¡æœ‰å‘é€ä»»ä½•æŒ‡ä»¤ï¼Œè¿æ¥å°†è¢«å…³é—­ time 0 # é»˜è®¤æ•°æ®åº“æ•°é‡ databases 1 #ç”¨å®ˆæŠ¤çº¿ç¨‹çš„æ–¹å¼å¯åŠ¨ daemonize no #yes : RDBå¿«ç…§ä¿å­˜å¤±è´¥å å®¢æˆ·ç«¯ä¸å¯å†™å…¥redisï¼Œåªå¯è¯»ã€‚ #no : ç¦ç”¨æ­¤åŠŸèƒ½ stop-writes-on-bgsave-error yes # æ˜¯å¦æ£€æŸ¥rdbå¿«ç…§çš„å®Œæ•´æ€§ï¼ŒæŸå¤±å¤§æ¦‚ ç™¾åˆ†ä¹‹å çš„æ€§èƒ½ rdbchecksum yes #å½“ä½¿ç”¨æ— ç›˜å¤åˆ¶æ—¶ï¼Œmaster åœ¨å¼€å§‹ä¼ è¾“ä¹‹å‰ç­‰å¾…ä¸€æ®µå¯é…ç½®çš„æ—¶é—´ï¼ˆä»¥ç§’ä¸ºå•ä½ï¼‰ï¼Œ #å¸Œæœ›å¤šä¸ªå‰¯æœ¬åˆ°è¾¾å¹¶ä¸”ä¼ è¾“å¯ä»¥å¹¶è¡ŒåŒ–ã€‚å¯¹äºæ…¢é€Ÿç£ç›˜å’Œå¿«é€Ÿï¼ˆå¤§å¸¦å®½ï¼‰ç½‘ç»œï¼Œæ— ç›˜å¤åˆ¶æ•ˆæœæ›´å¥½ã€‚ repl-diskless-sync yes #æ‚¨å¯ä»¥é…ç½®å‰¯æœ¬å®ä¾‹ä»¥æ¥å—æˆ–ä¸æ¥å—å†™å…¥ã€‚ #å°±æ˜¯ä¸»ä»å¤åˆ¶ä¸­ï¼ŒslaveèŠ‚ç‚¹æ˜¯å¦å¯ä»¥å†™å…¥æ•°æ®ï¼ˆyesï¼šä¸èƒ½å†™å…¥ï¼›noï¼šå¯ä»¥å†™å…¥ï¼‰ replica-read-only yes # é…ç½®RDBæŒä¹…åŒ–æ¨¡å¼ # 900så†…è‡³å°‘ä¸€æ¬¡å†™æ“ä½œåˆ™æ‰§è¡Œbgsaveè¿›è¡ŒRDBæŒä¹…åŒ– # asve \u0026#34;\u0026#34; save 900 1 save 300 10 save 60 10000 # RDBæ˜¯å¦å‹ç¼© ,å»ºè®®ä¸å¼€å¯ # å‹ç¼©ä¹Ÿä¼šæ¶ˆè€—cpuï¼Œç£ç›˜çš„è¯ä¸å€¼é’± rdbcompression no # å¤‡ä»½çš„RDBæ–‡ä»¶åç§° dbfilename dump.rdb # å¤‡ä»½æ–‡ä»¶ä¿å­˜çš„è·¯å¾„ç›®å½• dir ./ # å¼€å¯ AOF æŒä¹…åŒ– appendonly yes # AOF æ¯ç§’åˆ·ç›˜ appendfsync everysec # AOFæ–‡ä»¶çš„åç§° appendfilename \u0026#34;appendonly.aof\u0026#34; # èŠ‚ç‚¹ç™»å½•å£ä»¤ requirepass 12345678 docker-compose.yml redis.conf é…ç½®æ–‡ä»¶å¯ä»¥åˆ° github å–ä¸‹è½½ï¼Œhttps://github.com/redis/redis/tree/6.2.3ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 version: \u0026#39;3\u0026#39; services: redis-master: container_name: redis-master image: redis:6.2.3 privileged: true restart: unless-stopped command: redis-server /etc/redis/redis.conf ports: - \u0026#34;7001:6379\u0026#34; volumes: - /app/docker/redis/master/data:/data - ./docker/redis/master/redis.conf:/etc/redis/redis.conf - /etc/localtime:/etc/localtime:ro logging: driver: \u0026#34;json-file\u0026#34; options: max-size: \u0026#34;20m\u0026#34; max-file: \u0026#34;3\u0026#34; healthcheck: test: [ \u0026#34;CMD\u0026#34;, \u0026#34;redis-cli\u0026#34;, \u0026#34;ping\u0026#34; ] interval: 10s timeout: 1s retries: 3 networks: redis-network: ipv4_address: 172.30.1.2 redis-slave1: container_name: redis-slave1 image: redis:6.2.3 privileged: true restart: unless-stopped command: redis-server /etc/redis/redis.conf ports: - \u0026#34;7002:6379\u0026#34; volumes: - /app/docker/redis/slave1/data:/data - ./docker/redis/slave1/redis.conf:/etc/redis/redis.conf - /etc/localtime:/etc/localtime:ro logging: driver: \u0026#34;json-file\u0026#34; options: max-size: \u0026#34;20m\u0026#34; max-file: \u0026#34;3\u0026#34; healthcheck: test: [ \u0026#34;CMD\u0026#34;, \u0026#34;redis-cli\u0026#34;, \u0026#34;ping\u0026#34; ] interval: 10s timeout: 1s retries: 3 networks: redis-network: ipv4_address: 172.30.1.3 redis-slave2: container_name: redis-slave2 image: redis:6.2.3 privileged: true restart: unless-stopped command: redis-server /etc/redis/redis.conf ports: - \u0026#34;7003:6379\u0026#34; volumes: - /app/docker/redis/slave2/data:/data - ./docker/redis/slave2/redis.conf:/etc/redis/redis.conf - /etc/localtime:/etc/localtime:ro logging: driver: \u0026#34;json-file\u0026#34; options: max-size: \u0026#34;20m\u0026#34; max-file: \u0026#34;3\u0026#34; healthcheck: test: [ \u0026#34;CMD\u0026#34;, \u0026#34;redis-cli\u0026#34;, \u0026#34;ping\u0026#34; ] interval: 10s timeout: 1s retries: 3 networks: redis-network: ipv4_address: 172.30.1.4 networks: redis-network: driver: bridge ipam: driver: default config: - subnet: 172.30.1.0/24 ä½¿ç”¨ docker-compose å¯åŠ¨æœåŠ¡ã€‚ $ docker-compose -p redis-cluster up -d ","permalink":"https://heliu.site/posts/redis/slave/","summary":"redis ä¸»ä»åŒæ­¥ã€‚","title":"redis ä¸»ä»åŒæ­¥"},{"content":"å“¨å…µç»“æ„ å“¨å…µçš„ä½œç”¨å¦‚ä¸‹ï¼š ç›‘æ§ï¼šSentinel ä¼šä¸æ–­æ£€æŸ¥æ‚¨çš„masterå’Œslaveæ˜¯å¦æŒ‰é¢„æœŸå·¥ä½œã€‚ è‡ªåŠ¨æ•…éšœæ¢å¤ï¼šå¦‚æœmasteræ•…éšœï¼ŒSentinelä¼šå°†ä¸€ä¸ªslaveæå‡ä¸ºmasterã€‚å½“æ•…éšœå®ä¾‹æ¢å¤åä¹Ÿä»¥æ–°çš„masterä¸ºä¸»ã€‚ é€šçŸ¥ï¼šSentinelå……å½“Rediså®¢æˆ·ç«¯çš„æœåŠ¡å‘ç°æ¥æºï¼Œå½“é›†ç¾¤å‘ç”Ÿæ•…éšœè½¬ç§»æ—¶ï¼Œä¼šå°†æœ€æ–°ä¿¡æ¯æ¨é€ç»™Redisçš„å®¢æˆ·ç«¯ã€‚ ç›‘æ§é›†ç¾¤åŸç† SentinelåŸºäºå¿ƒè·³æœºåˆ¶ç›‘æµ‹æœåŠ¡çŠ¶æ€ï¼Œæ¯éš”1ç§’å‘é›†ç¾¤çš„æ¯ä¸ªå®ä¾‹å‘é€pingå‘½ä»¤ï¼š ä¸»è§‚ä¸‹çº¿ï¼šå¦‚æœæŸsentinelèŠ‚ç‚¹å‘ç°æŸå®ä¾‹æœªåœ¨è§„å®šæ—¶é—´å“åº”ï¼Œåˆ™è®¤ä¸ºè¯¥å®ä¾‹ä¸»è§‚ä¸‹çº¿ã€‚ å®¢è§‚ä¸‹çº¿ï¼šè‹¥è¶…è¿‡æŒ‡å®šæ•°é‡ï¼ˆquorumï¼‰çš„sentineléƒ½è®¤ä¸ºè¯¥å®ä¾‹ä¸»è§‚ä¸‹çº¿ï¼Œåˆ™è¯¥å®ä¾‹å®¢è§‚ä¸‹çº¿ã€‚quorumå€¼æœ€å¥½è¶…è¿‡Sentinelå®ä¾‹æ•°é‡çš„ä¸€åŠã€‚ é›†ç¾¤æ•…éšœæ¢å¤ ä¸€æ—¦å‘ç°masteræ•…éšœï¼Œsentineléœ€è¦åœ¨salveä¸­é€‰æ‹©ä¸€ä¸ªä½œä¸ºæ–°çš„masterï¼Œé€‰æ‹©ä¾æ®æ˜¯è¿™æ ·çš„ï¼š é¦–å…ˆä¼šåˆ¤æ–­slaveèŠ‚ç‚¹ä¸masterèŠ‚ç‚¹æ–­å¼€æ—¶é—´é•¿çŸ­ï¼Œå¦‚æœè¶…è¿‡æŒ‡å®šå€¼ï¼ˆdown-after-milliseconds * 10ï¼‰åˆ™ä¼šæ’é™¤è¯¥slaveèŠ‚ç‚¹ã€‚ ç„¶ååˆ¤æ–­slaveèŠ‚ç‚¹çš„slave-priorityå€¼ï¼Œè¶Šå°ä¼˜å…ˆçº§è¶Šé«˜ï¼Œå¦‚æœæ˜¯0åˆ™æ°¸ä¸å‚ä¸é€‰ä¸¾ã€‚ å¦‚æœslave-prorityä¸€æ ·ï¼Œåˆ™åˆ¤æ–­slaveèŠ‚ç‚¹çš„offsetå€¼ï¼Œè¶Šå¤§è¯´æ˜æ•°æ®è¶Šæ–°ï¼Œä¼˜å…ˆçº§è¶Šé«˜ã€‚ æœ€åæ˜¯åˆ¤æ–­slaveèŠ‚ç‚¹çš„è¿è¡Œidå¤§å°ï¼Œè¶Šå°ä¼˜å…ˆçº§è¶Šé«˜ã€‚ å½“é€‰å‡ºä¸€ä¸ªæ–°çš„masteråï¼Œåˆ‡æ¢æµç¨‹ï¼š sentinelç»™å¤‡é€‰çš„slave1èŠ‚ç‚¹å‘é€slaveof no oneå‘½ä»¤ï¼Œè®©è¯¥èŠ‚ç‚¹æˆä¸ºmasterã€‚ sentinelç»™æ‰€æœ‰å…¶å®ƒslaveå‘é€slaveof 192.168.150.101 7002å‘½ä»¤ï¼Œè®©è¿™äº›slaveæˆä¸ºæ–°masterçš„ä»èŠ‚ç‚¹ï¼Œå¼€å§‹ä»æ–°çš„masterä¸ŠåŒæ­¥æ•°æ®ã€‚ æœ€åï¼Œsentinelå°†æ•…éšœèŠ‚ç‚¹æ ‡è®°ä¸ºslaveï¼Œå½“æ•…éšœèŠ‚ç‚¹æ¢å¤åä¼šè‡ªåŠ¨æˆä¸ºæ–°çš„masterçš„slaveèŠ‚ç‚¹ã€‚ æ€»ç»“ Sentinelçš„ä¸‰ä¸ªä½œç”¨æ˜¯ï¼šç›‘æ§ã€æ•…éšœè½¬ç§»ã€é€šçŸ¥ã€‚ Sentinelåˆ¤æ–­ä¸€ä¸ªrediså®ä¾‹æ˜¯å¦å¥åº·ï¼š æ¯éš”1ç§’å‘é€ä¸€æ¬¡pingå‘½ä»¤ï¼Œå¦‚æœè¶…è¿‡ä¸€å®šæ—¶é—´æ²¡æœ‰ç›¸å‘åˆ™è®¤ä¸ºæ˜¯ä¸»è§‚ä¸‹çº¿ã€‚ å¦‚æœå¤§å¤šæ•°sentineléƒ½è®¤ä¸ºå®ä¾‹ä¸»è§‚ä¸‹çº¿ï¼Œåˆ™åˆ¤å®šæœåŠ¡ä¸‹çº¿ã€‚ æ•…éšœè½¬ç§»æ­¥éª¤ï¼š é¦–å…ˆé€‰å®šä¸€ä¸ªslaveä½œä¸ºæ–°çš„masterï¼Œæ‰§è¡Œslaveof no oneã€‚ ç„¶åè®©æ‰€æœ‰èŠ‚ç‚¹éƒ½æ‰§è¡Œslaveof æ–°masterã€‚ ä¿®æ”¹æ•…éšœèŠ‚ç‚¹é…ç½®ï¼Œæ·»åŠ slaveof æ–°masterã€‚ æ­å»º ä»¥å‰ä¸€ç¯‡ä¸»ä»æ­å»ºä¸ºåŸºç¡€ã€‚ é…ç½® sentinel.conf æ–‡ä»¶ï¼Œgithubä¸‹è½½å¯¹åº”ç‰ˆæœ¬ã€‚ ä¿®æ”¹ä»¥ä¸‹å†…å®¹ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 # sentinel1.conf # dockerå¯¹å¤–å¼€æ”¾çš„ç«¯å£ port 37376 requirepass 12345678 # æœåŠ¡åå°è¿è¡Œ # å› ä¸ºä½¿ç”¨dockerå¯åŠ¨æ—¶ä½¿ç”¨äº†-då‚æ•°ï¼Œæ‰€ä»¥éœ€è¦è®¾ç½®ä¸ºno, édockerè®¾ç½®ä¸ºyes daemonize no dir /tmp # è¿™é‡Œé…ç½®çš„æ˜¯ç›‘æ§çš„redisçš„åœ°å€ï¼Œmymasterä¸ºé»˜è®¤çš„ä¸»èŠ‚ç‚¹åå­— # åé¢çš„2ä¸ºå®¢è§‚æ‰çº¿çš„ç¥¨æ•°ï¼Œä¸€èˆ¬ä¸ºé›†ç¾¤æ•°é™¤äºŒ # mymasterrï¼šä¸»èŠ‚ç‚¹åç§°ï¼Œè‡ªå®šä¹‰ï¼Œä»»æ„å†™ # 172.30.1.2 7001ï¼šä¸»èŠ‚ç‚¹çš„ipå’Œç«¯å£ # 2ï¼šé€‰ä¸¾masteræ—¶çš„quorumå€¼ sentinel monitor mymaster 172.30.1.2 7001 2 sentinel auth-pass mymaster 12345678 # # è¶…è¿‡30ç§’masterè¿˜æ²¡æœ‰è¿æ¥ä¸Šï¼Œåˆ™è®¤ä¸ºmasterå·²ç»åœæ­¢ï¼Œ30000msï¼Œé»˜è®¤30ç§’ sentinel down-after-milliseconds mymaster 30000 sentinel parallel-syncs mymaster 1 # æ•…éšœè½¬ç§»è¶…æ—¶æ—¶é—´ é»˜è®¤3åˆ†é’Ÿ sentinel failover-timeout mymaster 180000 sentinel deny-scripts-reconfig yes 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 # sentinel2.conf # dockerå¯¹å¤–å¼€æ”¾çš„ç«¯å£ port 37377 requirepass 12345678 # æœåŠ¡åå°è¿è¡Œ # å› ä¸ºä½¿ç”¨dockerå¯åŠ¨æ—¶ä½¿ç”¨äº†-då‚æ•°ï¼Œæ‰€ä»¥éœ€è¦è®¾ç½®ä¸ºno, édockerè®¾ç½®ä¸ºyes daemonize no dir /tmp # è¿™é‡Œé…ç½®çš„æ˜¯ç›‘æ§çš„redisçš„åœ°å€ï¼Œmymasterä¸ºé»˜è®¤çš„ä¸»èŠ‚ç‚¹åå­— # åé¢çš„2ä¸ºå®¢è§‚æ‰çº¿çš„ç¥¨æ•°ï¼Œä¸€èˆ¬ä¸ºé›†ç¾¤æ•°é™¤äºŒ # mymasterrï¼šä¸»èŠ‚ç‚¹åç§°ï¼Œè‡ªå®šä¹‰ï¼Œä»»æ„å†™ # 172.30.1.2 7001ï¼šä¸»èŠ‚ç‚¹çš„ipå’Œç«¯å£ # 2ï¼šé€‰ä¸¾masteræ—¶çš„quorumå€¼ sentinel monitor mymaster 172.30.1.2 7001 2 sentinel auth-pass mymaster 12345678 # # è¶…è¿‡30ç§’masterè¿˜æ²¡æœ‰è¿æ¥ä¸Šï¼Œåˆ™è®¤ä¸ºmasterå·²ç»åœæ­¢ï¼Œ30000msï¼Œé»˜è®¤30ç§’ sentinel down-after-milliseconds mymaster 30000 sentinel parallel-syncs mymaster 1 # æ•…éšœè½¬ç§»è¶…æ—¶æ—¶é—´ é»˜è®¤3åˆ†é’Ÿ sentinel failover-timeout mymaster 180000 sentinel deny-scripts-reconfig yes 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 # sentinel3.conf # dockerå¯¹å¤–å¼€æ”¾çš„ç«¯å£ port 37378 requirepass 12345678 # æœåŠ¡åå°è¿è¡Œ # å› ä¸ºä½¿ç”¨dockerå¯åŠ¨æ—¶ä½¿ç”¨äº†-då‚æ•°ï¼Œæ‰€ä»¥éœ€è¦è®¾ç½®ä¸ºno, édockerè®¾ç½®ä¸ºyes daemonize no dir /tmp # è¿™é‡Œé…ç½®çš„æ˜¯ç›‘æ§çš„redisçš„åœ°å€ï¼Œmymasterä¸ºé»˜è®¤çš„ä¸»èŠ‚ç‚¹åå­— # åé¢çš„2ä¸ºå®¢è§‚æ‰çº¿çš„ç¥¨æ•°ï¼Œä¸€èˆ¬ä¸ºé›†ç¾¤æ•°é™¤äºŒ # mymasterrï¼šä¸»èŠ‚ç‚¹åç§°ï¼Œè‡ªå®šä¹‰ï¼Œä»»æ„å†™ # 172.30.1.2 7001ï¼šä¸»èŠ‚ç‚¹çš„ipå’Œç«¯å£ # 2ï¼šé€‰ä¸¾masteræ—¶çš„quorumå€¼ sentinel monitor mymaster 172.30.1.2 7001 2 sentinel auth-pass mymaster 12345678 # # è¶…è¿‡30ç§’masterè¿˜æ²¡æœ‰è¿æ¥ä¸Šï¼Œåˆ™è®¤ä¸ºmasterå·²ç»åœæ­¢ï¼Œ30000msï¼Œé»˜è®¤30ç§’ sentinel down-after-milliseconds mymaster 30000 sentinel parallel-syncs mymaster 1 # æ•…éšœè½¬ç§»è¶…æ—¶æ—¶é—´ é»˜è®¤3åˆ†é’Ÿ sentinel failover-timeout mymaster 180000 sentinel deny-scripts-reconfig yes docker-compose.yml 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 version: \u0026#39;3\u0026#39; services: redis-sentinel1: image: redis:6.2.3 container_name: redis-sentinel1 restart: always ports: - 37376:37376 command: redis-sentinel /usr/local/etc/redis/sentinel.conf volumes: - /home/redis/config/sentinel1.conf:/usr/local/etc/redis/sentinel.conf # - ./data/redis-sentinel:/data sysctls: # å¿…è¦çš„å†…æ ¸å‚æ•° net.core.somaxconn: \u0026#39;511\u0026#39; redis-sentinel2: image: redis:6.2.3 container_name: redis-sentinel2 restart: always ports: - 37377:37377 command: redis-sentinel /usr/local/etc/redis/sentinel.conf volumes: - /home/redis/config/sentinel2.conf:/usr/local/etc/redis/sentinel.conf # - ./data/redis-sentinel:/data sysctls: # å¿…è¦çš„å†…æ ¸å‚æ•° net.core.somaxconn: \u0026#39;511\u0026#39; redis-sentinel3: image: redis:6.2.3 container_name: redis-sentinel3 restart: always ports: - 37378:37378 command: redis-sentinel /usr/local/etc/redis/sentinel.conf volumes: - /home/redis/config/sentinel3.conf:/usr/local/etc/redis/sentinel.conf # - ./data/redis-sentinel:/data sysctls: # å¿…è¦çš„å†…æ ¸å‚æ•° net.core.somaxconn: \u0026#39;511\u0026#39; $ docker-compose -f docker-sentinel.yml up -d å‚è€ƒ https://www.cnblogs.com/coolxin1024/p/17182557.html ","permalink":"https://heliu.site/posts/redis/sentinel/","summary":"redis å“¨å…µæœºåˆ¶ã€‚","title":"redis å“¨å…µ"},{"content":"ç®€ä»‹ ä¸»ä»å’Œå“¨å…µå¯ä»¥è§£å†³é«˜å¯ç”¨ã€é«˜å¹¶å‘è¯»çš„é—®é¢˜ã€‚ä½†æ˜¯ä¾ç„¶æœ‰ä¸¤ä¸ªé—®é¢˜æ²¡æœ‰è§£å†³ï¼š æµ·é‡æ•°æ®å­˜å‚¨é—®é¢˜ã€é«˜å¹¶å‘å†™çš„é—®é¢˜ã€‚ ä½¿ç”¨åˆ†ç‰‡é›†ç¾¤å¯ä»¥è§£å†³ä¸Šè¿°é—®é¢˜ï¼Œå¦‚å›¾: åˆ†ç‰‡é›†ç¾¤ç‰¹å¾ï¼š é›†ç¾¤ä¸­æœ‰å¤šä¸ªmasterï¼Œæ¯ä¸ªmasterä¿å­˜ä¸åŒæ•°æ®ã€‚ æ¯ä¸ªmasteréƒ½å¯ä»¥æœ‰å¤šä¸ªslaveèŠ‚ç‚¹ã€‚ masterä¹‹é—´é€šè¿‡pingç›‘æµ‹å½¼æ­¤å¥åº·çŠ¶æ€ã€‚ å®¢æˆ·ç«¯è¯·æ±‚å¯ä»¥è®¿é—®é›†ç¾¤ä»»æ„èŠ‚ç‚¹ï¼Œæœ€ç»ˆéƒ½ä¼šè¢«è½¬å‘åˆ°æ­£ç¡®èŠ‚ç‚¹ã€‚ æ•£åˆ—æ’æ§½ æ’æ§½åŸç† Redisä¼šæŠŠæ¯ä¸€ä¸ªmasterèŠ‚ç‚¹æ˜ å°„åˆ°0~16383å…±16384ä¸ªæ’æ§½ï¼ˆhash slotï¼‰ä¸Šï¼ŒæŸ¥çœ‹é›†ç¾¤ä¿¡æ¯æ—¶å°±èƒ½çœ‹åˆ°ã€‚ M: xxxxxxxxxxxxxxxxxxxxxxxx 172.30.1.2:7001 slots:[0-5460] (5461 slots) master M: xxxxxxxxxxxxxxxxxxxxxxxx 172.30.1.2:7002 slots:[5461-10922] (5462 slots) master M: xxxxxxxxxxxxxxxxxxxxxxxx 172.30.1.2:7003 slots:[10923-16383] (5461 slots) master æ•°æ®keyä¸æ˜¯ä¸èŠ‚ç‚¹ç»‘å®šï¼Œè€Œæ˜¯ä¸æ’æ§½ç»‘å®šã€‚redisä¼šæ ¹æ®keyçš„æœ‰æ•ˆéƒ¨åˆ†è®¡ç®—æ’æ§½å€¼ï¼Œåˆ†ä¸¤ç§æƒ…å†µï¼š keyä¸­åŒ…å« \u0026quot;{}\u0026quot;ï¼Œä¸” \u0026quot;{}\u0026quot; ä¸­è‡³å°‘åŒ…å«1ä¸ªå­—ç¬¦ï¼Œ\u0026quot;{}\u0026quot; ä¸­çš„éƒ¨åˆ†æ˜¯æœ‰æ•ˆéƒ¨åˆ†ã€‚ keyä¸­ä¸åŒ…å« \u0026quot;{}\u0026quot;ï¼Œæ•´ä¸ªkeyéƒ½æ˜¯æœ‰æ•ˆéƒ¨åˆ†ã€‚ ä¾‹å¦‚ï¼škeyæ˜¯numï¼Œé‚£ä¹ˆå°±æ ¹æ®numè®¡ç®—ï¼Œå¦‚æœæ˜¯{itcast}numï¼Œåˆ™æ ¹æ®itcastè®¡ç®—ã€‚è®¡ç®—æ–¹å¼æ˜¯åˆ©ç”¨CRC16ç®—æ³•å¾—åˆ°ä¸€ä¸ªhashå€¼ï¼Œç„¶åå¯¹16384å–ä½™ï¼Œå¾—åˆ°çš„ç»“æœå°±æ˜¯slotå€¼ã€‚ åœ¨7001è¿™ä¸ªèŠ‚ç‚¹æ‰§è¡Œset a 1æ—¶ï¼Œå¯¹aåšhashè¿ç®—ï¼Œå¯¹16384å–ä½™ï¼Œå¾—åˆ°çš„ç»“æœæ˜¯15495ï¼Œå› æ­¤è¦å­˜å‚¨åˆ°7003èŠ‚ç‚¹ã€‚ åˆ°äº†7003åï¼Œæ‰§è¡Œget numæ—¶ï¼Œå¯¹numåšhashè¿ç®—ï¼Œå¯¹16384å–ä½™ï¼Œå¾—åˆ°çš„ç»“æœæ˜¯2765ï¼Œå› æ­¤éœ€è¦åˆ‡æ¢åˆ°7001èŠ‚ç‚¹ã€‚ $ set a 1 -\u0026gt; Redirected to slot [15495] located at 172.30.1.2:7003 OK $ get num -\u0026gt; Redirected to slot [2765] located at 172.30.1.2:7001 Rediså¦‚ä½•åˆ¤æ–­æŸä¸ªkeyåº”è¯¥åœ¨å“ªä¸ªå®ä¾‹ï¼š å°†16384ä¸ªæ’æ§½åˆ†é…åˆ°ä¸åŒçš„å®ä¾‹ã€‚ æ ¹æ®keyçš„æœ‰æ•ˆéƒ¨åˆ†è®¡ç®—å“ˆå¸Œå€¼ï¼Œå¯¹16384å–ä½™ã€‚ ä½™æ•°ä½œä¸ºæ’æ§½ï¼Œå¯»æ‰¾æ’æ§½æ‰€åœ¨å®ä¾‹å³å¯ã€‚ å¦‚ä½•å°†åŒä¸€ç±»æ•°æ®å›ºå®šçš„ä¿å­˜åœ¨åŒä¸€ä¸ªRediså®ä¾‹ï¼šè¿™ä¸€ç±»æ•°æ®ä½¿ç”¨ç›¸åŒçš„æœ‰æ•ˆéƒ¨åˆ†ï¼Œä¾‹å¦‚keyéƒ½ä»¥{typeId}ä¸ºå‰ç¼€ã€‚ é›†ç¾¤ä¼¸ç¼© redis-cli \u0026ndash;cluster æä¾›äº†å¾ˆå¤šæ“ä½œé›†ç¾¤çš„å‘½ä»¤ï¼Œå¯ä»¥é€šè¿‡ä¸‹é¢æ–¹å¼æŸ¥çœ‹ï¼š $ redis-cli --cluster help æ·»åŠ æ–°èŠ‚ç‚¹åˆ°é›†ç¾¤ $ redis-cli --cluster add-node 192.168.150.101:7004 192.168.150.101:7001 æŸ¥çœ‹é›†ç¾¤çŠ¶æ€ã€‚ $ redis-cli -p 7001 cluster nodes è½¬ç§»æ’æ§½ è½¬ç§»æ’æ§½å‘½ä»¤ï¼šredis-cli \u0026ndash;cluster reshard host:portã€‚ host:port ä»è¿™ä¸ªä½ç½®è½¬ç§»åˆ°å…¶ä»–ä½ç½®ã€‚ æ•…éšœè½¬ç§» è‡ªåŠ¨æ•…éšœè½¬ç§» redis é›†ç¾¤ä¼šè‡ªåŠ¨æ•…éšœè½¬ç§»ã€‚ æ‰‹åŠ¨æ•…éšœè½¬ç§» åˆ©ç”¨cluster failoverå‘½ä»¤å¯ä»¥æ‰‹åŠ¨è®©é›†ç¾¤ä¸­çš„æŸä¸ªmasterå®•æœºï¼Œåˆ‡æ¢åˆ°æ‰§è¡Œcluster failoverå‘½ä»¤çš„è¿™ä¸ªslaveèŠ‚ç‚¹ï¼Œå®ç°æ— æ„ŸçŸ¥çš„æ•°æ®è¿ç§»ã€‚ failoverå‘½ä»¤å¯ä»¥æŒ‡å®šä¸‰ç§æ¨¡å¼ï¼š \u0026ldquo;\u0026quot;ï¼šé»˜è®¤çš„æµç¨‹ï¼Œå¦‚å›¾1~6æ­©ã€‚ forceï¼šçœç•¥äº†å¯¹offsetçš„ä¸€è‡´æ€§æ ¡éªŒã€‚ takeoverï¼šç›´æ¥æ‰§è¡Œç¬¬5æ­©ï¼Œå¿½ç•¥æ•°æ®ä¸€è‡´æ€§ã€å¿½ç•¥masterçŠ¶æ€å’Œå…¶å®ƒmasterçš„æ„è§ã€‚ åœ¨ä»èŠ‚ç‚¹æ‰§è¡Œï¼š $ CLUSTER FAILOVER æ­å»ºé›†ç¾¤ åˆ†ç‰‡é›†ç¾¤éœ€è¦çš„èŠ‚ç‚¹æ•°é‡è¾ƒå¤šï¼Œè¿™é‡Œæˆ‘ä»¬æ­å»ºä¸€ä¸ªæœ€å°çš„åˆ†ç‰‡é›†ç¾¤ï¼ŒåŒ…å«3ä¸ªmasterèŠ‚ç‚¹ï¼Œæ¯ä¸ªmasteråŒ…å«ä¸€ä¸ªslaveèŠ‚ç‚¹ã€‚ IP PORT è§’è‰² 172.30.2.11 7001 master 172.30.2.12 7002 master 172.30.2.13 7003 master 172.30.2.21 8001 slave 172.30.2.22 8002 slave 172.30.2.23 8003 slave redis.conf redis.conf æ–‡ä»¶å‡†å¤‡ã€‚github å®˜ç½‘ä¸‹è½½ redis ç›¸åº”ç‰ˆæœ¬çš„é…ç½®æ–‡ä»¶ã€‚ å¯¹æ¯ä¸ªredis.conféƒ½åšä»¥ä¸‹ä¿®æ”¹ã€‚åˆ†ç‰‡é›†ç¾¤çš„redisä¸»ä»çš„redis.confç›®å‰éƒ½æ˜¯ä¸€æ ·çš„ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 port 6379 # å¼€å¯é›†ç¾¤åŠŸèƒ½ cluster-enabled yes # é›†ç¾¤çš„é…ç½®æ–‡ä»¶åç§°ï¼Œä¸éœ€è¦æˆ‘ä»¬åˆ›å»ºï¼Œç”±redisè‡ªå·±ç»´æŠ¤ cluster-config-file /data/nodes.conf # èŠ‚ç‚¹å¿ƒè·³å¤±è´¥çš„è¶…æ—¶æ—¶é—´ cluster-node-timeout 5000 # æŒä¹…åŒ–æ–‡ä»¶å­˜æ”¾ç›®å½• dir /data # ç»‘å®šåœ°å€ bind 0.0.0.0 # no éåå°å®ˆæŠ¤è¿è¡Œ daemonize no # ä¿æŠ¤æ¨¡å¼ protected-mode no # æ•°æ®åº“æ•°é‡ databases 1 # æ—¥å¿— logfile /data/run.log docker-compose.yml 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 version: \u0026#39;3.8\u0026#39; networks: redis-sharding: driver: bridge ipam: driver: default config: - subnet: 172.30.2.0/24 services: master1: container_name: master1 image: redis:6.2.3 volumes: - ./master1/conf:/usr/local/etc/redis ports: - \u0026#34;7001:6379\u0026#34; command: [\u0026#34;redis-server\u0026#34;, \u0026#34;/usr/local/etc/redis/redis.conf\u0026#34;] networks: redis-sharding: ipv4_address: 172.30.2.11 master2: container_name: master2 image: redis:6.2.3 volumes: - ./master2/conf:/usr/local/etc/redis ports: - \u0026#34;7002:6379\u0026#34; command: [ \u0026#34;redis-server\u0026#34;, \u0026#34;/usr/local/etc/redis/redis.conf\u0026#34; ] networks: redis-sharding: ipv4_address: 172.30.2.12 master3: container_name: master3 image: redis:6.2.3 volumes: - ./master3/conf:/usr/local/etc/redis ports: - \u0026#34;7003:6379\u0026#34; command: [ \u0026#34;redis-server\u0026#34;, \u0026#34;/usr/local/etc/redis/redis.conf\u0026#34; ] networks: redis-sharding: ipv4_address: 172.30.2.13 replica1: container_name: replica1 image: redis:6.2.3 volumes: - ./replica1/conf:/usr/local/etc/redis ports: - \u0026#34;8001:6379\u0026#34; command: [ \u0026#34;redis-server\u0026#34;, \u0026#34;/usr/local/etc/redis/redis.conf\u0026#34; ] networks: redis-sharding: ipv4_address: 172.30.2.21 replica2: container_name: replica2 image: redis:6.2.3 volumes: - ./replica2/conf:/usr/local/etc/redis ports: - \u0026#34;8002:6379\u0026#34; command: [ \u0026#34;redis-server\u0026#34;, \u0026#34;/usr/local/etc/redis/redis.conf\u0026#34; ] networks: redis-sharding: ipv4_address: 172.30.2.22 replica3: container_name: replica3 image: redis:6.2.3 volumes: - ./replica3/conf:/usr/local/etc/redis ports: - \u0026#34;8003:6379\u0026#34; command: [ \u0026#34;redis-server\u0026#34;, \u0026#34;/usr/local/etc/redis/redis.conf\u0026#34; ] networks: redis-sharding: ipv4_address: 172.30.2.23 $ docker-compose -p redis-sharding up -d æ„å»ºé›†ç¾¤ ä¸‹é¢çš„å‘½ä»¤éƒ½åœ¨ master1 å®¹å™¨é‡Œæ‰§è¡Œã€‚\nè‡ªåŠ¨åˆ†é…ä¸»ä»å…³ç³» åˆ›å»ºäº†ä¸€ä¸ªé›†ç¾¤ï¼ŒåŒ…æ‹¬ä¸‰ä¸ªä¸»èŠ‚ç‚¹å’Œä¸‰ä¸ªä»èŠ‚ç‚¹ï¼Œæ¯ä¸ªä¸»èŠ‚ç‚¹åˆ†é…ä¸€ä¸ªä»èŠ‚ç‚¹ä½œä¸ºå‰¯æœ¬ï¼Œå‰3ä¸ªipä¸ºä¸»èŠ‚ç‚¹ï¼Œå3ä¸ªä¸ºä»èŠ‚ç‚¹ï¼Œä¸»èŠ‚ç‚¹çš„ä»èŠ‚ç‚¹éšæœºåˆ†é…ã€‚ $ redis-cli --cluster create 172.30.2.11:6379 172.30.2.12:6379 172.30.2.13:6379 172.30.2.21:6379 172.30.2.22:6379 172.30.2.23:6379 --cluster-replicas 1 æ‰‹åŠ¨åˆ†é…ä¸»ä»å…³ç³» åˆ†é… master é›†ç¾¤ã€‚ $ redis-cli --cluster create 172.30.2.11:6379 172.30.2.12:6379 172.30.2.13:6379 --cluster-replicas 0 æŸ¥çœ‹3ä¸ªä¸»èŠ‚ç‚¹çš„IDã€‚ $ redis-cli -h 172.30.2.11 -p 6379 cluster nodes å°†3ä¸ªä»èŠ‚ç‚¹åŠ å…¥é›†ç¾¤ä¸­ï¼Œå…¶ä¸­172.30.2.11å¯ä»¥æ˜¯ä¸‰ä¸ªä¸»èŠ‚ç‚¹çš„ä»»æ„ä¸€ä¸ªã€‚ $ redis-cli -h 172.30.2.21 -p 6379 cluster meet 172.30.2.11 6379 $ redis-cli -h 172.30.2.22 -p 6379 cluster meet 172.30.2.11 6379 $ redis-cli -h 172.30.2.23 -p 6379 cluster meet 172.30.2.11 6379 ä¸ºæ¯ä¸ªä»èŠ‚ç‚¹æŒ‡å®šä¸»èŠ‚ç‚¹ã€‚ $ redis-cli -h 172.30.2.21 -p 6379 cluster replicate \u0026lt;master-ID\u0026gt; $ redis-cli -h 172.30.2.22 -p 6379 cluster replicate \u0026lt;master-ID\u0026gt; $ redis-cli -h 172.30.2.23 -p 6379 cluster replicate \u0026lt;master-ID\u0026gt; éªŒè¯ é€šè¿‡ä»¥ä¸‹å‘½ä»¤æŸ¥çœ‹é›†ç¾¤ä¸­æ¯ä¸ªèŠ‚ç‚¹çš„idã€è§’è‰²ã€ipã€portã€æ’æ§½èŒƒå›´ç­‰ä¿¡æ¯ã€‚ $ redis-cli -h 172.30.2.11 -p 6379 cluster nodes å¾€é›†ç¾¤å­˜å…¥4ä¸ªé”®å€¼ã€‚ $ redis-cli -c -h 172.30.2.11 -p 6379 set key1 value1 $ redis-cli -c -h 172.30.2.11 -p 6379 set key2 value2 $ redis-cli -c -h 172.30.2.11 -p 6379 set key3 value3 $ redis-cli -c -h 172.30.2.11 -p 6379 set key4 value4 æŸ¥çœ‹æ¯ä¸ªä¸»èŠ‚ç‚¹ç°æœ‰çš„é”®å€¼ï¼Œä¼šå‘ç°æ¯ä¸ªèŠ‚ç‚¹åªæœ‰ä¸€éƒ¨åˆ†é”®å€¼ã€‚ $ redis-cli -h 172.30.2.11 -p 6379 --scan $ redis-cli -h 172.30.2.12 -p 6379 --scan $ redis-cli -h 172.30.2.13 -p 6379 --scan ","permalink":"https://heliu.site/posts/redis/cluster/","summary":"redis åˆ†ç‰‡é›†ç¾¤åŸç†å’Œæ­å»ºã€‚","title":"redis åˆ†ç‰‡é›†ç¾¤"},{"content":" rediså®˜æ–¹ç½‘ç«™ï¼šhttps://redis.io/ rediså®˜æ–¹å‘½ä»¤æ–‡æ¡£ï¼šhttps://redis.io/docs/latest/commands/ redisæ˜¯ NoSql æ•°æ®åº“ï¼Œä»¥é”®å€¼å¯¹çš„å½¢å¼å­˜å‚¨ã€‚ redis å‘½ä»¤è¡Œå®¢æˆ·ç«¯ Redis å®‰è£…å®Œæˆåå°±è‡ªå¸¦äº†å‘½ä»¤è¡Œå®¢æˆ·ç«¯ï¼šredis-cliï¼Œä½¿ç”¨æ–¹å¼å¦‚ä¸‹ï¼š redis-cli [options] [commonds] å…¶ä¸­å¸¸è§çš„ options æœ‰ï¼š -h 127.0.0.1ï¼šæŒ‡å®šè¦è¿æ¥çš„ redis èŠ‚ç‚¹çš„ IP åœ°å€ï¼Œé»˜è®¤æ˜¯ 127.0.0.1ã€‚ -p 6379ï¼šæŒ‡å®šè¦è¿æ¥çš„ redis èŠ‚ç‚¹çš„ç«¯å£ï¼Œé»˜è®¤æ˜¯ 6379ã€‚ -a 123456ï¼šæŒ‡å®šredisçš„è®¿é—®å¯†ç ã€‚ commonds å°±æ˜¯ Redis çš„æ“ä½œå‘½ä»¤ï¼Œä¾‹å¦‚ï¼š pingï¼šä¸redisæœåŠ¡ç«¯åšå¿ƒè·³æµ‹è¯•ï¼ŒæœåŠ¡ç«¯æ­£å¸¸ä¼šè¿”å›pongã€‚ ä¸æŒ‡å®šcommondæ—¶ï¼Œä¼šè¿›å…¥redis-cliçš„äº¤äº’æ§åˆ¶å°ã€‚ Redis é»˜è®¤æœ‰16ä¸ªä»“åº“ï¼Œç¼–å·ä»0è‡³15ã€‚é€šè¿‡é…ç½®æ–‡ä»¶å¯ä»¥è®¾ç½®ä»“åº“æ•°é‡ï¼Œä½†æ˜¯ä¸è¶…è¿‡16ï¼Œå¹¶ä¸”ä¸èƒ½è‡ªå®šä¹‰ä»“åº“åç§°ã€‚(å»ºè®®åªè®¾ç½®ä¸€ä¸ªæ•°æ®åº“) å¦‚æœæ˜¯åŸºäº redis-cli è¿æ¥ Redis æœåŠ¡ï¼Œå¯ä»¥é€šè¿‡ select å‘½ä»¤æ¥é€‰æ‹©æ•°æ®åº“ï¼šselect 0ã€‚ redis é€šç”¨å‘½ä»¤ é€šç”¨æŒ‡ä»¤æ˜¯éƒ¨åˆ†æ•°æ®ç±»å‹çš„ï¼Œéƒ½å¯ä»¥ä½¿ç”¨çš„æŒ‡ä»¤ã€‚ å®˜ç½‘åœ°å€ï¼šhttps://redis.io/docs/latest/commands/?group=generic rediså®¢æˆ·ç«¯æŸ¥è¯¢å‘½ä»¤ï¼šhelp @genericã€‚ COPY å°†ä¸€ä¸ªkeyçš„å€¼å¤åˆ¶åˆ°ä¸€ä¸ªæ–°keyã€‚\nè¯­æ³•ï¼š\nCOPY source destination [DB destination-db] [REPLACE] ä½¿ç”¨ç¤ºä¾‹ï¼š # è®¾ç½®key/value SET dolly \u0026#34;sheep\u0026#34; # å…‹éš†dolly COPY dolly clone GET clone DEL åˆ é™¤ä¸€ä¸ªæˆ–å¤šä¸ªkeyã€‚\nè¯­æ³•ï¼š\nDEL key [key ...] ä½¿ç”¨ç¤ºä¾‹ï¼š redis\u0026gt; SET key1 \u0026#34;Hello\u0026#34; \u0026#34;OK\u0026#34; redis\u0026gt; SET key2 \u0026#34;World\u0026#34; \u0026#34;OK\u0026#34; redis\u0026gt; DEL key1 key2 key3 (integer) 2 DUMP è¿”å›å­˜å‚¨åœ¨é”®ä¸­çš„å€¼çš„åºåˆ—åŒ–è¡¨ç¤ºå½¢å¼ã€‚\nè¯­æ³•ï¼š\nDUMP key ä½¿ç”¨ç¤ºä¾‹ï¼š \u0026gt; SET mykey 10 OK \u0026gt; DUMP mykey \u0026#34;\\x00\\xc0\\n\\n\\x00n\\x9fWE\\x0e\\xaec\\xbb\u0026#34; EXISTS ç¡®å®šæ˜¯å¦å­˜åœ¨ä¸€ä¸ªæˆ–å¤šä¸ªkeyã€‚\nè¯­æ³•ï¼š\nEXISTS key [key ...] ç¤ºä¾‹ï¼š redis\u0026gt; SET key1 \u0026#34;Hello\u0026#34; \u0026#34;OK\u0026#34; redis\u0026gt; EXISTS key1 (integer) 1 redis\u0026gt; EXISTS nosuchkey (integer) 0 redis\u0026gt; SET key2 \u0026#34;World\u0026#34; \u0026#34;OK\u0026#34; redis\u0026gt; EXISTS key1 key2 nosuchkey (integer) 2 EXPIRE ä»¥ç§’ä¸ºå•ä½è®¾ç½®å¯†é’¥çš„è¿‡æœŸæ—¶é—´ï¼ˆå•ä½/ç§’ï¼‰ã€‚ è¯­æ³•ï¼š NX - ä»…å½“keyæ²¡æœ‰è¿‡æœŸæ—¶é—´æ—¶æœ‰æ•ˆã€‚ XX - ä»…å½“keyæœ‰è¿‡æœŸæ—¶é—´æ—¶æœ‰æ•ˆã€‚ GT - ä»…å½“æ–°è¿‡æœŸæ—¶é—´å¤§äºå½“å‰è¿‡æœŸæ—¶é—´æ—¶æœ‰æ•ˆã€‚ LT - ä»…å½“æ–°è¿‡æœŸæ—¶é—´å°äºå½“å‰è¿‡æœŸæ—¶é—´æ—¶æœ‰æ•ˆã€‚ EXPIRE key seconds [NX | XX | GT | LT] ç¤ºä¾‹ï¼š redis\u0026gt; SET mykey \u0026#34;Hello\u0026#34; \u0026#34;OK\u0026#34; redis\u0026gt; EXPIRE mykey 10 (integer) 1 redis\u0026gt; TTL mykey (integer) 10 redis\u0026gt; SET mykey \u0026#34;Hello World\u0026#34; \u0026#34;OK\u0026#34; redis\u0026gt; TTL mykey (integer) -1 redis\u0026gt; EXPIRE mykey 10 XX (integer) 0 redis\u0026gt; TTL mykey (integer) -1 redis\u0026gt; EXPIRE mykey 10 NX (integer) 1 redis\u0026gt; TTL mykey (integer) 10 EXPIREAT å°†keyçš„è¿‡æœŸæ—¶é—´è®¾ç½®ä¸ºUnixæ—¶é—´æˆ³ã€‚ è¯­æ³•ï¼š NX - ä»…å½“keyæ²¡æœ‰è¿‡æœŸæ—¶é—´æ—¶æœ‰æ•ˆã€‚ XX - ä»…å½“keyæœ‰è¿‡æœŸæ—¶é—´æ—¶æœ‰æ•ˆã€‚ GT - ä»…å½“æ–°è¿‡æœŸæ—¶é—´å¤§äºå½“å‰è¿‡æœŸæ—¶é—´æ—¶æœ‰æ•ˆã€‚ LT - ä»…å½“æ–°è¿‡æœŸæ—¶é—´å°äºå½“å‰è¿‡æœŸæ—¶é—´æ—¶æœ‰æ•ˆã€‚ EXPIREAT key unix-time-seconds [NX | XX | GT | LT] ç¤ºä¾‹ï¼š redis\u0026gt; SET mykey \u0026#34;Hello\u0026#34; \u0026#34;OK\u0026#34; redis\u0026gt; EXISTS mykey (integer) 1 redis\u0026gt; EXPIREAT mykey 1293840000 (integer) 1 redis\u0026gt; EXISTS mykey (integer) 0 EXPIRETIME ä»¥Unixæ—¶é—´æˆ³å½¢å¼è¿”å›keyçš„è¿‡æœŸæ—¶é—´ã€‚ è¯­æ³•ï¼š PEXPIRETIME key ç¤ºä¾‹ï¼š redis\u0026gt; SET mykey \u0026#34;Hello\u0026#34; \u0026#34;OK\u0026#34; redis\u0026gt; PEXPIREAT mykey 33177117420000 (integer) 1 redis\u0026gt; PEXPIRETIME mykey (integer) 33177117420000 KEYS è¿”å›ä¸æ¨¡å¼åŒ¹é…çš„æ‰€æœ‰keyåã€‚ï¼ˆæ­£å¼ç¯å¢ƒä¸­ä¸å»ºè®®ä½¿ç”¨ï¼‰\nè¯­æ³•ï¼š\nKEYS pattern æ”¯æŒçš„å…¨å±€æ ·å¼æ¨¡å¼: h?llo matches hello, hallo and hxllo h*llo matches hllo and heeeello h[ae]llo matches hello and hallo, but not hillo h[^e]llo matches hallo, hbllo, \u0026hellip; but not hello h[a-b]llo matches hallo and hbllo æœè¦é€å­—åŒ¹é…ç‰¹æ®Šå­—ç¬¦ï¼Œè¯·ä½¿ç”¨\\æ¥è½¬ä¹‰å®ƒä»¬ã€‚\nç¤ºä¾‹ï¼š # è®¾ç½®firstname Jackã€lastname Stuntmanã€age 35 redis\u0026gt; MSET firstname Jack lastname Stuntman age 35 \u0026#34;OK\u0026#34; redis\u0026gt; KEYS *name* 1) \u0026#34;lastname\u0026#34; 2) \u0026#34;firstname\u0026#34; redis\u0026gt; KEYS a?? 1) \u0026#34;age\u0026#34; redis\u0026gt; KEYS * 1) \u0026#34;lastname\u0026#34; 2) \u0026#34;firstname\u0026#34; 3) \u0026#34;age\u0026#34; MIGRATE è‡ªåŠ¨å°†å¯†é’¥ä»ä¸€ä¸ªRediså®ä¾‹ä¼ è¾“åˆ°å¦ä¸€ä¸ªRediså®ä¾‹ã€‚ è¯­æ³•ï¼š MIGRATE host port \u0026lt;key | \u0026#34;\u0026#34;\u0026gt; destination-db timeout [COPY] [REPLACE] [AUTH password | AUTH2 username password] [KEYS key [key ...]] ç¤ºä¾‹ï¼š MIGRATE 192.168.1.34 6379 \u0026#34;\u0026#34; 0 5000 KEYS key1 key2 key3 MOVE å°†keyç§»åŠ¨åˆ°å¦ä¸€ä¸ªæ•°æ®åº“ã€‚ è¯­æ³•ï¼š MOVE key db OBJECT ENCODING è¿”å›Rediså¯¹è±¡çš„å†…éƒ¨ç¼–ç ã€‚ï¼ˆæŸ¥çœ‹keyçš„æ•°æ®ç»“æ„ï¼‰ è¯­æ³•ï¼š OBJECT ENCODING key OBJECT FREQ è¿”å›ä¸€ä¸ªRediså¯¹è±¡çš„å¯¹æ•°è®¿é—®é¢‘ç‡è®¡æ•°å™¨ã€‚ è¯­æ³•ï¼š OBJECT FREQ key OBJECT IDLETIME è¿”å›ä¸Šä¸€æ¬¡è®¿é—®Rediså¯¹è±¡åçš„æ—¶é—´ï¼ˆç§’ï¼‰ã€‚ è¯­æ³•ï¼š OBJECT IDLETIME key ç¤ºä¾‹ï¼š # è·ç¦»ä¸Šä¸€æ¬¡è®¿é—®nameç»è¿‡äº†å¤šå°‘ç§’ 127.0.0.1:6379\u0026gt; OBJECT idletime name (integer) 141 127.0.0.1:6379\u0026gt; OBJECT idletime name (integer) 147 127.0.0.1:6379\u0026gt; OBJECT idletime name (integer) 149 OBJECT REFCOUNT è¿”å›keyå€¼çš„å¼•ç”¨è®¡æ•°ã€‚ è¯­æ³•ï¼š OBJECT REFCOUNT key ç¤ºä¾‹ï¼š 127.0.0.1:6379\u0026gt; OBJECT REFCOUNT name (integer) 1 PERSIST åˆ é™¤keyçš„è¿‡æœŸæ—¶é—´ã€‚ è¯­æ³•ï¼š PERSIST key ç¤ºä¾‹ï¼š redis\u0026gt; SET mykey \u0026#34;Hello\u0026#34; \u0026#34;OK\u0026#34; redis\u0026gt; EXPIRE mykey 10 (integer) 1 redis\u0026gt; TTL mykey (integer) 10 redis\u0026gt; PERSIST mykey (integer) 1 redis\u0026gt; TTL mykey (integer) -1 PEXPIRE ä»¥æ¯«ç§’ä¸ºå•ä½è®¾ç½®keyçš„è¿‡æœŸæ—¶é—´ã€‚ è¯­æ³•ï¼š PEXPIRE key milliseconds [NX | XX | GT | LT] NX - ä»…å½“keyæ²¡æœ‰è¿‡æœŸæ—¶é—´æ—¶æœ‰æ•ˆã€‚\nXX - ä»…å½“keyæœ‰è¿‡æœŸæ—¶é—´æ—¶æœ‰æ•ˆã€‚\nGT - ä»…å½“æ–°è¿‡æœŸæ—¶é—´å¤§äºå½“å‰è¿‡æœŸæ—¶é—´æ—¶æœ‰æ•ˆã€‚\nLT - ä»…å½“æ–°è¿‡æœŸæ—¶é—´å°äºå½“å‰è¿‡æœŸæ—¶é—´æ—¶æœ‰æ•ˆã€‚\nç¤ºä¾‹ï¼š redis\u0026gt; SET mykey \u0026#34;Hello\u0026#34; \u0026#34;OK\u0026#34; redis\u0026gt; PEXPIRE mykey 1500 (integer) 1 redis\u0026gt; TTL mykey (integer) 2 redis\u0026gt; PTTL mykey (integer) 1499 redis\u0026gt; PEXPIRE mykey 1000 XX (integer) 1 redis\u0026gt; TTL mykey (integer) 1 redis\u0026gt; PEXPIRE mykey 1000 NX (integer) 0 redis\u0026gt; TTL mykey (integer) 1 PEXPIREAT å°†keyçš„è¿‡æœŸæ—¶é—´è®¾ç½®ä¸ºUnixæ¯«ç§’æ—¶é—´æˆ³ã€‚ è¯­æ³•ï¼š PEXPIREAT key unix-time-milliseconds [NX | XX | GT | LT] NX - ä»…å½“keyæ²¡æœ‰è¿‡æœŸæ—¶é—´æ—¶æœ‰æ•ˆã€‚\nXX - ä»…å½“keyæœ‰è¿‡æœŸæ—¶é—´æ—¶æœ‰æ•ˆã€‚\nGT - ä»…å½“æ–°è¿‡æœŸæ—¶é—´å¤§äºå½“å‰è¿‡æœŸæ—¶é—´æ—¶æœ‰æ•ˆã€‚\nLT - ä»…å½“æ–°è¿‡æœŸæ—¶é—´å°äºå½“å‰è¿‡æœŸæ—¶é—´æ—¶æœ‰æ•ˆã€‚\nç¤ºä¾‹ï¼š redis\u0026gt; SET mykey \u0026#34;Hello\u0026#34; \u0026#34;OK\u0026#34; redis\u0026gt; PEXPIREAT mykey 1555555555005 (integer) 1 redis\u0026gt; TTL mykey (integer) -2 redis\u0026gt; PTTL mykey (integer) -2 PEXPIRETIME ä»¥Unixæ¯«ç§’æ—¶é—´æˆ³çš„å½¢å¼è¿”å›keyçš„è¿‡æœŸæ—¶é—´ã€‚\nè¯­æ³•ï¼š\nPEXPIRETIME key ç¤ºä¾‹ï¼š redis\u0026gt; SET mykey \u0026#34;Hello\u0026#34; \u0026#34;OK\u0026#34; redis\u0026gt; PEXPIREAT mykey 33177117420000 (integer) 1 redis\u0026gt; PEXPIRETIME mykey (integer) 33177117420000 PTTL ä»¥æ¯«ç§’ä¸ºå•ä½è¿”å›keyçš„è¿‡æœŸæ—¶é—´ã€‚\nè¯­æ³•ï¼š\nPTTL key ç¤ºä¾‹ï¼š redis\u0026gt; SET mykey \u0026#34;Hello\u0026#34; \u0026#34;OK\u0026#34; redis\u0026gt; EXPIRE mykey 1 (integer) 1 redis\u0026gt; PTTL mykey (integer) 999 RANDOMKEY ä»æ•°æ®åº“è¿”å›ä¸€ä¸ªéšæœºçš„keyåã€‚\nè¯­æ³•ï¼š\nRANDOMKEY ç¤ºä¾‹ï¼š [root@hcss-ecs-7943 ~]# docker exec -it redis redis-cli 127.0.0.1:6379\u0026gt; RANDOMKEY \u0026#34;name\u0026#34; RENAME é‡å‘½åkeyå¹¶è¦†ç›–ç›®æ ‡ã€‚\nè¯­æ³•ï¼š\nRENAME key newkey ç¤ºä¾‹ï¼š redis\u0026gt; SET mykey \u0026#34;Hello\u0026#34; \u0026#34;OK\u0026#34; redis\u0026gt; RENAME mykey myotherkey \u0026#34;OK\u0026#34; redis\u0026gt; GET myotherkey \u0026#34;Hello\u0026#34; RENAMENX ä»…å½“ç›®æ ‡keyåï¼ˆnewkeyï¼‰ä¸å­˜åœ¨æ—¶æ‰é‡å‘½åkeyã€‚\nè¯­æ³•ï¼š\nRENAMENX key newkey ç¤ºä¾‹ï¼š redis\u0026gt; SET mykey \u0026#34;Hello\u0026#34; \u0026#34;OK\u0026#34; redis\u0026gt; SET myotherkey \u0026#34;World\u0026#34; \u0026#34;OK\u0026#34; redis\u0026gt; RENAMENX mykey myotherkey (integer) 0 redis\u0026gt; GET myotherkey \u0026#34;World\u0026#34; RESTORE ä»å€¼çš„åºåˆ—åŒ–è¡¨ç¤ºåˆ›å»ºkeyã€‚\nè¯­æ³•ï¼š\nRESTORE key ttl serialized-value [REPLACE] [ABSTTL] [IDLETIME seconds] [FREQ frequency] ç¤ºä¾‹ï¼š redis\u0026gt; DEL mykey 0 redis\u0026gt; RESTORE mykey 0 \u0026#34;\\n\\x17\\x17\\x00\\x00\\x00\\x12\\x00\\x00\\x00\\x03\\x00\\ x00\\xc0\\x01\\x00\\x04\\xc0\\x02\\x00\\x04\\xc0\\x03\\x00\\ xff\\x04\\x00u#\u0026lt;\\xc0;.\\xe9\\xdd\u0026#34; OK redis\u0026gt; TYPE mykey list redis\u0026gt; LRANGE mykey 0 -1 1) \u0026#34;1\u0026#34; 2) \u0026#34;2\u0026#34; 3) \u0026#34;3\u0026#34; SCAN éå†æ•°æ®åº“ä¸­çš„keyåã€‚\nè¯­æ³•ï¼š\nSCAN cursor [MATCH pattern] [COUNT count] [TYPE type] ç¤ºä¾‹ï¼š redis 127.0.0.1:6379\u0026gt; scan 0 1) \u0026#34;17\u0026#34; 2) 1) \u0026#34;key:12\u0026#34; 2) \u0026#34;key:8\u0026#34; 3) \u0026#34;key:4\u0026#34; 4) \u0026#34;key:14\u0026#34; 5) \u0026#34;key:16\u0026#34; 6) \u0026#34;key:17\u0026#34; 7) \u0026#34;key:15\u0026#34; 8) \u0026#34;key:10\u0026#34; 9) \u0026#34;key:3\u0026#34; 10) \u0026#34;key:7\u0026#34; 11) \u0026#34;key:1\u0026#34; redis 127.0.0.1:6379\u0026gt; scan 17 1) \u0026#34;0\u0026#34; 2) 1) \u0026#34;key:5\u0026#34; 2) \u0026#34;key:18\u0026#34; 3) \u0026#34;key:0\u0026#34; 4) \u0026#34;key:2\u0026#34; 5) \u0026#34;key:19\u0026#34; 6) \u0026#34;key:13\u0026#34; 7) \u0026#34;key:6\u0026#34; 8) \u0026#34;key:9\u0026#34; 9) \u0026#34;key:11\u0026#34; SORT å¯¹åˆ—è¡¨ã€é›†åˆæˆ–å·²æ’åºé›†åˆä¸­çš„å…ƒç´ è¿›è¡Œæ’åºï¼Œå¹¶å¯é€‰æ‹©å­˜å‚¨ç»“æœã€‚\nè¯­æ³•ï¼š\nSORT key [BY pattern] [LIMIT offset count] [GET pattern [GET pattern ...]] [ASC | DESC] [ALPHA] [STORE destination] SORT_RO è¿”å›åˆ—è¡¨ã€é›†åˆæˆ–å·²æ’åºé›†åˆçš„å·²æ’åºå…ƒç´ ã€‚\nè¯­æ³•ï¼š\nSORT_RO key [BY pattern] [LIMIT offset count] [GET pattern [GET pattern ...]] [ASC | DESC] [ALPHA] ç¤ºä¾‹ï¼š SORT_RO mylist BY weight_*-\u0026gt;fieldname GET object_*-\u0026gt;fieldname TOUCH åœ¨æ›´æ–°æœ€åä¸€æ¬¡è®¿é—®keyçš„æ—¶é—´åï¼Œè¿”å›æŒ‡å®šé”®ä¸­ç°æœ‰keyçš„ä¸ªæ•°ã€‚\nè¯­æ³•ï¼š\nTOUCH key [key ...] ç¤ºä¾‹ï¼š redis\u0026gt; SET key1 \u0026#34;Hello\u0026#34; \u0026#34;OK\u0026#34; redis\u0026gt; SET key2 \u0026#34;World\u0026#34; \u0026#34;OK\u0026#34; redis\u0026gt; TOUCH key1 key2 (integer) 2 TTL ä»¥ç§’ä¸ºå•ä½è¿”å›keyçš„è¿‡æœŸæ—¶é—´ã€‚\nè¯­æ³•ï¼š\nTTL key ç¤ºä¾‹ï¼š redis\u0026gt; SET mykey \u0026#34;Hello\u0026#34; \u0026#34;OK\u0026#34; redis\u0026gt; EXPIRE mykey 10 (integer) 1 redis\u0026gt; TTL mykey (integer) 10 TYPE ç¡®å®šå­˜å‚¨åœ¨keyä¸­çš„å€¼çš„ç±»å‹ã€‚\nè¯­æ³•ï¼š\nTYPE key ç¤ºä¾‹ï¼š redis\u0026gt; SET key1 \u0026#34;value\u0026#34; \u0026#34;OK\u0026#34; redis\u0026gt; LPUSH key2 \u0026#34;value\u0026#34; (integer) 1 redis\u0026gt; SADD key3 \u0026#34;value\u0026#34; (integer) 1 redis\u0026gt; TYPE key1 \u0026#34;string\u0026#34; redis\u0026gt; TYPE key2 \u0026#34;list\u0026#34; redis\u0026gt; TYPE key3 \u0026#34;set\u0026#34; UNLINK å¼‚æ­¥åˆ é™¤ä¸€ä¸ªæˆ–å¤šä¸ªkeyã€‚\nè¯­æ³•ï¼š\nUNLINK key [key ...] ç¤ºä¾‹ï¼š redis\u0026gt; SET key1 \u0026#34;Hello\u0026#34; \u0026#34;OK\u0026#34; redis\u0026gt; SET key2 \u0026#34;World\u0026#34; \u0026#34;OK\u0026#34; redis\u0026gt; UNLINK key1 key2 key3 (integer) 2 WAIT é˜»å¡ï¼Œç›´åˆ°è¿æ¥å‘é€çš„ä¸Šè¿°æ‰€æœ‰å†™å‘½ä»¤çš„å¼‚æ­¥å¤åˆ¶å®Œæˆã€‚\nè¯­æ³•ï¼š\nWAIT numreplicas timeout ç¤ºä¾‹ï¼š \u0026gt; SET foo bar OK \u0026gt; WAIT 1 0 (integer) 1 \u0026gt; WAIT 2 1000 (integer) 1 WAITAOF é˜»å¡ï¼Œç›´åˆ°è¿æ¥å‘é€çš„æ‰€æœ‰ä¸Šè¿°å†™å‘½ä»¤éƒ½è¢«å†™å…¥ä¸»æœåŠ¡å™¨å’Œ/æˆ–å‰¯æœ¬çš„ä»…è¿½åŠ æ–‡ä»¶ã€‚\nè¯­æ³•ï¼š\nWAITAOF numlocal numreplicas timeout ç¤ºä¾‹ï¼š \u0026gt; SET foo bar OK \u0026gt; WAITAOF 1 0 0 1) (integer) 1 2) (integer) 0 \u0026gt; WAITAOF 0 1 1000 1) (integer) 1 2) (integer) 0 ","permalink":"https://heliu.site/posts/redis/command/","summary":"redis å‘½ä»¤ä»‹ç»ã€‚","title":"redis é€šç”¨å‘½ä»¤"},{"content":" å®˜ç½‘å‘½ä»¤åœ°å€ï¼šhttps://redis.io/commands/?group=stringã€‚ rediså®¢æˆ·ç«¯æŸ¥è¯¢å‘½ä»¤ï¼šhelp @string string stringç±»å‹ï¼Œä¹Ÿå°±æ˜¯å­—ç¬¦ä¸²ç±»å‹ï¼Œæ˜¯Redisä¸­æœ€ç®€å•çš„å­˜å‚¨ç±»å‹ã€‚ å…¶valueæ˜¯å­—ç¬¦ä¸²ï¼Œä¸è¿‡æ ¹æ®å­—ç¬¦ä¸²çš„æ ¼å¼ä¸åŒï¼Œåˆå¯ä»¥åˆ†ä¸º3ç±»ï¼š stringï¼šæ™®é€šå­—ç¬¦ä¸²ã€‚ intï¼šæ•´æ•°ç±»å‹ï¼Œå¯ä»¥åšè‡ªå¢ï¼Œè‡ªå‡æ“ä½œã€‚ floatï¼šæµ®ç‚¹ç±»å‹ï¼Œå¯ä»¥åšè‡ªå¢.è‡ªå‡æ“ä½œã€‚ KEY Value message hello world number 18 score 87.6 APPEND å°†å­—ç¬¦ä¸²é™„åŠ åˆ°keyçš„å€¼ã€‚å¦‚æœkeyä¸å­˜åœ¨ï¼Œåˆ™åˆ›å»ºè¯¥keyã€‚\nè¯­æ³•ï¼š\nAPPEND key value ç¤ºä¾‹ï¼š redis\u0026gt; EXISTS mykey (integer) 0 redis\u0026gt; APPEND mykey \u0026#34;Hello\u0026#34; (integer) 5 redis\u0026gt; APPEND mykey \u0026#34; World\u0026#34; (integer) 11 redis\u0026gt; GET mykey \u0026#34;Hello World\u0026#34; DECR å°†keyçš„æ•´æ•°å€¼å‡1ã€‚å¦‚æœkeyä¸å­˜åœ¨ï¼Œåˆ™ä½¿ç”¨0ä½œä¸ºåˆå§‹å€¼ã€‚\nè¯­æ³•ï¼š\nDECR key ç¤ºä¾‹ï¼š redis\u0026gt; SET mykey \u0026#34;10\u0026#34; \u0026#34;OK\u0026#34; redis\u0026gt; DECR mykey (integer) 9 redis\u0026gt; SET mykey \u0026#34;234293482390480948029348230948\u0026#34; \u0026#34;OK\u0026#34; redis\u0026gt; DECR mykey (error) value is not an integer or out of range DECRBY ä»keyçš„æ•´æ•°å€¼ä¸­å‡å»ä¸€ä¸ªæ•°å­—ã€‚å¦‚æœkeyä¸å­˜åœ¨ï¼Œåˆ™ä½¿ç”¨0ä½œä¸ºåˆå§‹å€¼ã€‚\nè¯­æ³•ï¼š\nDECRBY key decrement ç¤ºä¾‹ï¼š redis\u0026gt; SET mykey \u0026#34;10\u0026#34; \u0026#34;OK\u0026#34; redis\u0026gt; DECRBY mykey 3 (integer) 7 GET è¿”å›keyçš„å­—ç¬¦ä¸²å€¼ã€‚\nè¯­æ³•ï¼š\nGET key ç¤ºä¾‹ï¼š redis\u0026gt; GET nonexisting (nil) redis\u0026gt; SET mykey \u0026#34;Hello\u0026#34; \u0026#34;OK\u0026#34; redis\u0026gt; GET mykey \u0026#34;Hello\u0026#34; Goä»£ç ï¼š 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 package example_commands_test import ( \u0026#34;context\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;github.com/redis/go-redis/v9\u0026#34; ) func ExampleClient_Set_and_get() { ctx := context.Background() rdb := redis.NewClient(\u0026amp;redis.Options{ Addr: \u0026#34;localhost:6379\u0026#34;, Password: \u0026#34;\u0026#34;, // no password docs DB: 0, // use default DB }) err := rdb.Set(ctx, \u0026#34;bike:1\u0026#34;, \u0026#34;Process 134\u0026#34;, 0).Err() if err != nil { panic(err) } fmt.Println(\u0026#34;OK\u0026#34;) value, err := rdb.Get(ctx, \u0026#34;bike:1\u0026#34;).Result() if err != nil { panic(err) } fmt.Printf(\u0026#34;The name of the bike is %s\u0026#34;, value) } GETDEL åœ¨åˆ é™¤keyåè¿”å›keyçš„å­—ç¬¦ä¸²å€¼ã€‚\nè¯­æ³•ï¼š\nGETDEL key ç¤ºä¾‹ï¼š redis\u0026gt; SET mykey \u0026#34;Hello\u0026#34; \u0026#34;OK\u0026#34; redis\u0026gt; GETDEL mykey \u0026#34;Hello\u0026#34; redis\u0026gt; GET mykey (nil) GETEX åœ¨è®¾ç½®keyçš„è¿‡æœŸæ—¶é—´åè¿”å›keyçš„å­—ç¬¦ä¸²å€¼ã€‚\nè¯­æ³•ï¼š\nGETEX key [EX seconds | PX milliseconds | EXAT unix-time-seconds | PXAT unix-time-milliseconds | PERSIST] EX seconds \u0026ndash; è®¾ç½®æŒ‡å®šçš„è¿‡æœŸæ—¶é—´ï¼Œä»¥ç§’ä¸ºå•ä½ã€‚ PX milliseconds \u0026ndash; è®¾ç½®æŒ‡å®šçš„è¿‡æœŸæ—¶é—´ï¼Œä»¥æ¯«ç§’ä¸ºå•ä½ã€‚ EXAT timestamp-seconds \u0026ndash; è®¾ç½®keyåˆ°æœŸçš„æŒ‡å®šUnixæ—¶é—´ï¼Œä»¥ç§’ä¸ºå•ä½ã€‚ PXAT timestamp-milliseconds \u0026ndash; è®¾ç½®keyåˆ°æœŸçš„æŒ‡å®šUnixæ—¶é—´ï¼Œä»¥æ¯«ç§’ä¸ºå•ä½ã€‚ PERSIST \u0026ndash; åˆ é™¤ä¸è¯¥keyå…³è”çš„ç”Ÿå­˜æ—¶é—´ã€‚ ç¤ºä¾‹ï¼š redis\u0026gt; SET mykey \u0026#34;Hello\u0026#34; \u0026#34;OK\u0026#34; redis\u0026gt; GETEX mykey \u0026#34;Hello\u0026#34; redis\u0026gt; TTL mykey (integer) -1 redis\u0026gt; GETEX mykey EX 60 \u0026#34;Hello\u0026#34; redis\u0026gt; TTL mykey (integer) 60 GETRANGE è¿”å›å­˜å‚¨åœ¨keyä¸­çš„å­—ç¬¦ä¸²çš„å­å­—ç¬¦ä¸²ã€‚\nè¯­æ³•ï¼š\nGETRANGE key start end ç¤ºä¾‹ï¼š redis\u0026gt; SET mykey \u0026#34;This is a string\u0026#34; \u0026#34;OK\u0026#34; redis\u0026gt; GETRANGE mykey 0 3 \u0026#34;This\u0026#34; redis\u0026gt; GETRANGE mykey -3 -1 \u0026#34;ing\u0026#34; redis\u0026gt; GETRANGE mykey 0 -1 \u0026#34;This is a string\u0026#34; redis\u0026gt; GETRANGE mykey 10 100 \u0026#34;string\u0026#34; GETSET å°†keyè®¾ç½®ä¸ºæ–°å€¼åè¿”å›keyçš„å‰ä¸€ä¸ªå­—ç¬¦ä¸²å€¼ã€‚\nè¯­æ³•ï¼š\nGETSET key value ç¤ºä¾‹ï¼š redis\u0026gt; INCR mycounter (integer) 1 redis\u0026gt; GETSET mycounter \u0026#34;0\u0026#34; \u0026#34;1\u0026#34; redis\u0026gt; GET mycounter \u0026#34;0\u0026#34; INCR å°†keyçš„æ•´æ•°å€¼åŠ 1ã€‚å¦‚æœkeyä¸å­˜åœ¨ï¼Œåˆ™ä½¿ç”¨0ä½œä¸ºåˆå§‹å€¼ã€‚\nè¯­æ³•ï¼š\nINCR key ç¤ºä¾‹ï¼š redis\u0026gt; SET mykey \u0026#34;10\u0026#34; \u0026#34;OK\u0026#34; redis\u0026gt; INCR mykey (integer) 11 redis\u0026gt; GET mykey \u0026#34;11\u0026#34; INCRBY å°†keyçš„æ•´æ•°å€¼å¢åŠ ä¸€ä¸ªæ•°å­—ã€‚å¦‚æœkeyä¸å­˜åœ¨ï¼Œåˆ™ä½¿ç”¨0ä½œä¸ºåˆå§‹å€¼ã€‚\nè¯­æ³•ï¼š\nINCRBY key increment ç¤ºä¾‹ï¼š redis\u0026gt; SET mykey \u0026#34;10\u0026#34; \u0026#34;OK\u0026#34; redis\u0026gt; INCRBY mykey 5 (integer) 15 INCRBYFLOAT å°†keyçš„æµ®ç‚¹å€¼å¢åŠ ä¸€ä¸ªæ•°å­—ã€‚å¦‚æœkeyä¸å­˜åœ¨ï¼Œåˆ™ä½¿ç”¨0ä½œä¸ºåˆå§‹å€¼ã€‚\nè¯­æ³•ï¼š\nINCRBYFLOAT key increment ç¤ºä¾‹ï¼š redis\u0026gt; SET mykey 10.50 \u0026#34;OK\u0026#34; redis\u0026gt; INCRBYFLOAT mykey 0.1 \u0026#34;10.6\u0026#34; redis\u0026gt; INCRBYFLOAT mykey -5 \u0026#34;5.6\u0026#34; redis\u0026gt; SET mykey 5.0e3 \u0026#34;OK\u0026#34; redis\u0026gt; INCRBYFLOAT mykey 2.0e2 \u0026#34;5200\u0026#34; LCS æŸ¥æ‰¾æœ€é•¿çš„å…¬å…±å­å­—ç¬¦ä¸²ã€‚\nè¯­æ³•ï¼š\nLCS key1 key2 [LEN] [IDX] [MINMATCHLEN min-match-len] [WITHMATCHLEN] ç¤ºä¾‹ï¼š \u0026gt; MSET key1 ohmytext key2 mynewtext OK \u0026gt; LCS key1 key2 \u0026#34;mytext\u0026#34; \u0026gt; LCS key1 key2 LEN (integer) 6 \u0026gt; LCS key1 key2 IDX 1) \u0026#34;matches\u0026#34; 2) 1) 1) 1) (integer) 4 1) (integer) 7 1) 1) (integer) 5 1) (integer) 8 2) 1) 1) (integer) 2 2) (integer) 3 1) 1) (integer) 0 1) (integer) 1 3) \u0026#34;len\u0026#34; 4) (integer) 6 MGET è‡ªåŠ¨è¿”å›ä¸€ä¸ªæˆ–å¤šä¸ªkeyçš„å­—ç¬¦ä¸²å€¼ã€‚\nè¯­æ³•ï¼š\nMGET key [key ...] ç¤ºä¾‹ï¼š redis\u0026gt; SET key1 \u0026#34;Hello\u0026#34; \u0026#34;OK\u0026#34; redis\u0026gt; SET key2 \u0026#34;World\u0026#34; \u0026#34;OK\u0026#34; redis\u0026gt; MGET key1 key2 nonexisting 1) \u0026#34;Hello\u0026#34; 2) \u0026#34;World\u0026#34; 3) (nil) MSET è‡ªåŠ¨åˆ›å»ºæˆ–ä¿®æ”¹ä¸€ä¸ªæˆ–å¤šä¸ªkeyçš„å­—ç¬¦ä¸²å€¼ã€‚\nè¯­æ³•ï¼š\nMSET key value [key value ...] ç¤ºä¾‹ï¼š redis\u0026gt; MSET key1 \u0026#34;Hello\u0026#34; key2 \u0026#34;World\u0026#34; \u0026#34;OK\u0026#34; redis\u0026gt; GET key1 \u0026#34;Hello\u0026#34; redis\u0026gt; GET key2 \u0026#34;World\u0026#34; MSETNX ä»…åœ¨ä¸å­˜åœ¨æ‰€æœ‰keyæ—¶æ‰è‡ªåŠ¨ä¿®æ”¹ä¸€ä¸ªæˆ–å¤šä¸ªkeyçš„å­—ç¬¦ä¸²å€¼ã€‚ï¼ˆä»…å½“keyä¸å­˜åœ¨æ—¶æ‰ä¼šè®¾ç½®valueï¼‰\nè¯­æ³•ï¼š\nMSETNX key value [key value ...] ç¤ºä¾‹ï¼š redis\u0026gt; MSETNX key1 \u0026#34;Hello\u0026#34; key2 \u0026#34;there\u0026#34; (integer) 1 redis\u0026gt; MSETNX key2 \u0026#34;new\u0026#34; key3 \u0026#34;world\u0026#34; (integer) 0 redis\u0026gt; MGET key1 key2 key3 1) \u0026#34;Hello\u0026#34; 2) \u0026#34;there\u0026#34; 3) (nil) PSETEX è®¾ç½®keyçš„å­—ç¬¦ä¸²å€¼å’Œè¿‡æœŸæ—¶é—´(ä»¥æ¯«ç§’ä¸ºå•ä½)ã€‚å¦‚æœkeyä¸å­˜åœ¨ï¼Œåˆ™åˆ›å»ºè¯¥keyã€‚\nè¯­æ³•ï¼š\nPSETEX key milliseconds value ç¤ºä¾‹ï¼š redis\u0026gt; PSETEX mykey 1000 \u0026#34;Hello\u0026#34; \u0026#34;OK\u0026#34; redis\u0026gt; PTTL mykey (integer) 998 redis\u0026gt; GET mykey \u0026#34;Hello\u0026#34; SET è®¾ç½®keyçš„å­—ç¬¦ä¸²å€¼ï¼Œå¿½ç•¥å…¶ç±»å‹ã€‚å¦‚æœkeyä¸å­˜åœ¨ï¼Œåˆ™åˆ›å»ºè¯¥keyã€‚\nè¯­æ³•ï¼š\nSET key value [NX | XX] [GET] [EX seconds | PX milliseconds | EXAT unix-time-seconds | PXAT unix-time-milliseconds | KEEPTTL] EX seconds \u0026ndash; è®¾ç½®æŒ‡å®šçš„è¿‡æœŸæ—¶é—´ï¼Œå•ä½ä¸ºç§’(æ­£æ•´æ•°)ã€‚ PX milliseconds \u0026ndash; è®¾ç½®æŒ‡å®šçš„è¿‡æœŸæ—¶é—´ï¼Œå•ä½ä¸ºæ¯«ç§’(æ­£æ•´æ•°)ã€‚ EXAT timestamp-seconds \u0026ndash; è®¾ç½®keyåˆ°æœŸçš„æŒ‡å®šUnixæ—¶é—´ï¼Œä»¥ç§’ä¸ºå•ä½(ä¸€ä¸ªæ­£æ•´æ•°)ã€‚ PXAT timestamp-milliseconds \u0026ndash; è®¾ç½®keyåˆ°æœŸçš„æŒ‡å®šUnixæ—¶é—´ï¼Œä»¥æ¯«ç§’ä¸ºå•ä½(æ­£æ•´æ•°)ã€‚ NX \u0026ndash; ä»…åœ¨keyä¸å­˜åœ¨æ—¶è®¾ç½®è¯¥keyã€‚ XX \u0026ndash; åªæœ‰å½“keyå·²ç»å­˜åœ¨æ—¶æ‰è®¾ç½®å®ƒã€‚ KEEPTTL \u0026ndash; ä¿ç•™ä¸è¯¥keyå…³è”çš„ç”Ÿå­˜æ—¶é—´ã€‚ GET \u0026ndash; è¿”å›å­˜å‚¨åœ¨keyå¤„çš„æ—§å­—ç¬¦ä¸²ï¼Œå¦‚æœkeyä¸å­˜åœ¨åˆ™è¿”å›nilã€‚å¦‚æœå­˜å‚¨åœ¨keyå¤„çš„å€¼ä¸æ˜¯å­—ç¬¦ä¸²ï¼Œåˆ™è¿”å›é”™è¯¯å¹¶ç»ˆæ­¢\u0026rsquo; SET \u0026lsquo;ã€‚ æ³¨æ„:ç”±äºSETå‘½ä»¤é€‰é¡¹å¯ä»¥å–ä»£SETNX, SETEX, PSETEX, GETSETï¼Œåœ¨Redisçš„æœªæ¥ç‰ˆæœ¬ä¸­ï¼Œè¿™äº›å‘½ä»¤å¯èƒ½ä¼šè¢«å¼ƒç”¨å¹¶æœ€ç»ˆè¢«åˆ é™¤ã€‚\nç¤ºä¾‹ï¼š\nredis\u0026gt; SET mykey \u0026#34;Hello\u0026#34; \u0026#34;OK\u0026#34; redis\u0026gt; GET mykey \u0026#34;Hello\u0026#34; redis\u0026gt; SET anotherkey \u0026#34;will expire in a minute\u0026#34; EX 60 \u0026#34;OK\u0026#34; Goä»£ç ï¼š 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 package example_commands_test import ( \u0026#34;context\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;github.com/redis/go-redis/v9\u0026#34; ) func ExampleClient_Set_and_get() { ctx := context.Background() rdb := redis.NewClient(\u0026amp;redis.Options{ Addr: \u0026#34;localhost:6379\u0026#34;, Password: \u0026#34;\u0026#34;, // no password docs DB: 0, // use default DB }) err := rdb.Set(ctx, \u0026#34;bike:1\u0026#34;, \u0026#34;Process 134\u0026#34;, 0).Err() if err != nil { panic(err) } fmt.Println(\u0026#34;OK\u0026#34;) value, err := rdb.Get(ctx, \u0026#34;bike:1\u0026#34;).Result() if err != nil { panic(err) } fmt.Printf(\u0026#34;The name of the bike is %s\u0026#34;, value) } SETEX è®¾ç½®keyçš„å­—ç¬¦ä¸²å€¼å’Œè¿‡æœŸæ—¶é—´ã€‚å¦‚æœkeyä¸å­˜åœ¨ï¼Œåˆ™åˆ›å»ºè¯¥keyã€‚\nè¯­æ³•ï¼šç­‰ä»·äºSET key value EX seconds\nSETEX key seconds value ç¤ºä¾‹ï¼š redis\u0026gt; SETEX mykey 10 \u0026#34;Hello\u0026#34; \u0026#34;OK\u0026#34; redis\u0026gt; TTL mykey (integer) 10 redis\u0026gt; GET mykey \u0026#34;Hello\u0026#34; SETNX ä»…å½“keyä¸å­˜åœ¨æ—¶æ‰è®¾ç½®è¯¥keyçš„å­—ç¬¦ä¸²å€¼ã€‚\nè¯­æ³•ï¼š\nSETNX key value ç¤ºä¾‹ï¼š redis\u0026gt; SETNX mykey \u0026#34;Hello\u0026#34; (integer) 1 redis\u0026gt; SETNX mykey \u0026#34;World\u0026#34; (integer) 0 redis\u0026gt; GET mykey \u0026#34;Hello\u0026#34; SETRANGE å°†å­—ç¬¦ä¸²å€¼çš„ä¸€éƒ¨åˆ†ä»¥åç§»é‡è¦†ç›–å¦ä¸€éƒ¨åˆ†ã€‚å¦‚æœkeyä¸å­˜åœ¨ï¼Œåˆ™åˆ›å»ºè¯¥keyã€‚\nè¯­æ³•ï¼š\nSETRANGE key offset value ç¤ºä¾‹ï¼š redis\u0026gt; SET key1 \u0026#34;Hello World\u0026#34; \u0026#34;OK\u0026#34; redis\u0026gt; SETRANGE key1 6 \u0026#34;Redis\u0026#34; (integer) 11 redis\u0026gt; GET key1 \u0026#34;Hello Redis\u0026#34; redis\u0026gt; SETRANGE key2 6 \u0026#34;Redis\u0026#34; (integer) 11 redis\u0026gt; GET key2 \u0026#34;Redis\u0026#34; STRLEN è¿”å›å­—ç¬¦ä¸²å€¼çš„é•¿åº¦ã€‚\nè¯­æ³•ï¼š\nSTRLEN key ç¤ºä¾‹ï¼š redis\u0026gt; SET mykey \u0026#34;Hello world\u0026#34; \u0026#34;OK\u0026#34; redis\u0026gt; STRLEN mykey (integer) 11 redis\u0026gt; STRLEN nonexisting (integer) 0 SUBSTR ä»å­—ç¬¦ä¸²å€¼è¿”å›å­å­—ç¬¦ä¸²ã€‚\nè¯­æ³•ï¼š\nSUBSTR key start end ç¤ºä¾‹ï¼š redis\u0026gt; SET mykey \u0026#34;This is a string\u0026#34; \u0026#34;OK\u0026#34; redis\u0026gt; GETRANGE mykey 0 3 \u0026#34;This\u0026#34; redis\u0026gt; GETRANGE mykey -3 -1 \u0026#34;ing\u0026#34; redis\u0026gt; GETRANGE mykey 0 -1 \u0026#34;This is a string\u0026#34; redis\u0026gt; GETRANGE mykey 10 100 \u0026#34;string\u0026#34; ","permalink":"https://heliu.site/posts/redis/string/","summary":"redis stringä»‹ç»ã€‚","title":"redis string"},{"content":" å®˜ç½‘å‘½ä»¤åœ°å€ï¼šhttps://redis.io/commands/?group=hash rediså®¢æˆ·ç«¯æŸ¥è¯¢å‘½ä»¤ï¼šhelp @hash hash Hashç±»å‹ï¼Œä¹Ÿå«æ•£åˆ—ï¼Œå…¶valueæ˜¯ä¸€ä¸ªæ— åºå­—å…¸ï¼Œç±»ä¼¼äºgoä¸­çš„mapç»“æ„ã€‚ Stringç»“æ„æ˜¯å°†å¯¹è±¡åºåˆ—åŒ–ä¸ºJSONå­—ç¬¦ä¸²åå­˜å‚¨ï¼Œå½“éœ€è¦ä¿®æ”¹å¯¹è±¡æŸä¸ªå­—æ®µæ—¶å¾ˆä¸æ–¹ä¾¿ã€‚ KEY Value re:user:1001 {name:\u0026ldquo;JK\u0026rdquo;, age: 18} re:user:1002 {name:\u0026ldquo;Re\u0026rdquo;, age: 14} Hashç»“æ„å¯ä»¥å°†å¯¹è±¡ä¸­çš„æ¯ä¸ªå­—æ®µç‹¬ç«‹å­˜å‚¨ï¼Œå¯ä»¥é’ˆå¯¹å•ä¸ªå­—æ®µåšCRUDã€‚ HDEL ä»hashä¸­åˆ é™¤ä¸€ä¸ªæˆ–å¤šä¸ªå­—æ®µåŠå…¶å€¼ã€‚å¦‚æœæ²¡æœ‰å­—æ®µä¿ç•™ï¼Œåˆ™åˆ é™¤hashã€‚\nè¯­æ³•ï¼š\nHDEL key field [field ...] ç¤ºä¾‹ï¼š redis\u0026gt; HSET myhash field1 \u0026#34;foo\u0026#34; (integer) 1 redis\u0026gt; HDEL myhash field1 (integer) 1 redis\u0026gt; HDEL myhash field2 (integer) 0 HEXISTS ç¡®å®šä¸€ä¸ªå­—æ®µæ˜¯å¦å­˜åœ¨äºhashä¸­ã€‚\nè¯­æ³•ï¼š\nHEXISTS key field ç¤ºä¾‹ï¼š redis\u0026gt; HSET myhash field1 \u0026#34;foo\u0026#34; (integer) 1 redis\u0026gt; HEXISTS myhash field1 (integer) 1 redis\u0026gt; HEXISTS myhash field2 (integer) 0 HGET è¿”å›hashä¸­æŸä¸ªå­—æ®µçš„å€¼ã€‚\nè¯­æ³•ï¼š\nHGET key field ç¤ºä¾‹ï¼š redis\u0026gt; HSET myhash field1 \u0026#34;foo\u0026#34; (integer) 1 redis\u0026gt; HGET myhash field1 \u0026#34;foo\u0026#34; redis\u0026gt; HGET myhash field2 (nil) HGETALL è¿”å›hashä¸­çš„æ‰€æœ‰å­—æ®µå’Œå€¼ã€‚\nè¯­æ³•ï¼š\nHGETALL key è¯­æ³•ï¼š redis\u0026gt; HSET myhash field1 \u0026#34;Hello\u0026#34; (integer) 1 redis\u0026gt; HSET myhash field2 \u0026#34;World\u0026#34; (integer) 1 redis\u0026gt; HGETALL myhash 1) \u0026#34;field1\u0026#34; 2) \u0026#34;Hello\u0026#34; 3) \u0026#34;field2\u0026#34; 4) \u0026#34;World\u0026#34; HINCRBY å°†hashä¸­å­—æ®µçš„æ•´æ•°å€¼å¢åŠ ä¸€ä¸ªæ•°å­—ã€‚å¦‚æœå­—æ®µä¸å­˜åœ¨ï¼Œåˆ™ä½¿ç”¨0ä½œä¸ºåˆå§‹å€¼ã€‚\nè¯­æ³•ï¼š\nHINCRBY key field increment ç¤ºä¾‹ï¼š redis\u0026gt; HSET myhash field 5 (integer) 1 redis\u0026gt; HINCRBY myhash field 1 (integer) 6 redis\u0026gt; HINCRBY myhash field -1 (integer) 5 redis\u0026gt; HINCRBY myhash field -10 (integer) -5 HINCRBYFLOAT å°†å­—æ®µçš„æµ®ç‚¹å€¼å¢åŠ ä¸€ä¸ªæ•°å­—ã€‚å¦‚æœå­—æ®µä¸å­˜åœ¨ï¼Œåˆ™ä½¿ç”¨0ä½œä¸ºåˆå§‹å€¼ã€‚\nè¯­æ³•ï¼š\nHINCRBYFLOAT key field increment ç¤ºä¾‹ï¼š redis\u0026gt; HSET mykey field 10.50 (integer) 1 redis\u0026gt; HINCRBYFLOAT mykey field 0.1 \u0026#34;10.6\u0026#34; redis\u0026gt; HINCRBYFLOAT mykey field -5 \u0026#34;5.6\u0026#34; redis\u0026gt; HSET mykey field 5.0e3 (integer) 0 redis\u0026gt; HINCRBYFLOAT mykey field 2.0e2 \u0026#34;5200\u0026#34; HKEYS ä»¥hashå½¢å¼è¿”å›æ‰€æœ‰å­—æ®µã€‚\nè¯­æ³•ï¼š\nHKEYS key ç¤ºä¾‹ï¼š redis\u0026gt; HSET myhash field1 \u0026#34;Hello\u0026#34; (integer) 1 redis\u0026gt; HSET myhash field2 \u0026#34;World\u0026#34; (integer) 1 redis\u0026gt; HKEYS myhash 1) \u0026#34;field1\u0026#34; 2) \u0026#34;field2\u0026#34; HLEN è¿”å›hashä¸­çš„å­—æ®µæ•°ã€‚\nè¯­æ³•ï¼š\nHLEN key ç¤ºä¾‹ï¼š redis\u0026gt; HSET myhash field1 \u0026#34;Hello\u0026#34; (integer) 1 redis\u0026gt; HSET myhash field2 \u0026#34;World\u0026#34; (integer) 1 redis\u0026gt; HLEN myhash (integer) 2 HMGET è¿”å›hashä¸­æ‰€æœ‰å­—æ®µçš„å€¼ã€‚\nè¯­æ³•ï¼š\nHMGET key field [field ...] ç¤ºä¾‹ï¼š redis\u0026gt; HSET myhash field1 \u0026#34;Hello\u0026#34; (integer) 1 redis\u0026gt; HSET myhash field2 \u0026#34;World\u0026#34; (integer) 1 redis\u0026gt; HMGET myhash field1 field2 nofield 1) \u0026#34;Hello\u0026#34; 2) \u0026#34;World\u0026#34; 3) (nil) HMSET è®¾ç½®å¤šä¸ªå­—æ®µçš„å€¼ã€‚\nè¯­æ³•ï¼š\nHMSET key field value [field value ...] ç¤ºä¾‹ï¼š redis\u0026gt; HMSET myhash field1 \u0026#34;Hello\u0026#34; field2 \u0026#34;World\u0026#34; \u0026#34;OK\u0026#34; redis\u0026gt; HGET myhash field1 \u0026#34;Hello\u0026#34; redis\u0026gt; HGET myhash field2 \u0026#34;World\u0026#34; HRANDFIELD ä»hashä¸­è¿”å›ä¸€ä¸ªæˆ–å¤šä¸ªéšæœºå­—æ®µã€‚\nè¯­æ³•ï¼š\nHRANDFIELD key [count [WITHVALUES]] ç¤ºä¾‹ï¼š redis\u0026gt; HSET coin heads obverse tails reverse edge null (integer) 3 redis\u0026gt; HRANDFIELD coin \u0026#34;heads\u0026#34; redis\u0026gt; HRANDFIELD coin \u0026#34;heads\u0026#34; redis\u0026gt; HRANDFIELD coin -5 WITHVALUES 1) \u0026#34;tails\u0026#34; 2) \u0026#34;reverse\u0026#34; 3) \u0026#34;edge\u0026#34; 4) \u0026#34;null\u0026#34; 5) \u0026#34;heads\u0026#34; 6) \u0026#34;obverse\u0026#34; 7) \u0026#34;heads\u0026#34; 8) \u0026#34;obverse\u0026#34; 9) \u0026#34;tails\u0026#34; 10) \u0026#34;reverse\u0026#34; HSCAN éå†hashçš„å­—æ®µå’Œå€¼ã€‚\nè¯­æ³•ï¼š\nHSCAN key cursor [MATCH pattern] [COUNT count] HSET åˆ›å»ºæˆ–ä¿®æ”¹hashä¸­æŸä¸ªå­—æ®µçš„å€¼ã€‚\nè¯­æ³•ï¼š\nHSET key field value [field value ...] ç¤ºä¾‹ï¼š redis\u0026gt; HSET myhash field1 \u0026#34;Hello\u0026#34; (integer) 1 redis\u0026gt; HGET myhash field1 \u0026#34;Hello\u0026#34; redis\u0026gt; HSET myhash field2 \u0026#34;Hi\u0026#34; field3 \u0026#34;World\u0026#34; (integer) 2 redis\u0026gt; HGET myhash field2 \u0026#34;Hi\u0026#34; redis\u0026gt; HGET myhash field3 \u0026#34;World\u0026#34; redis\u0026gt; HGETALL myhash 1) \u0026#34;field1\u0026#34; 2) \u0026#34;Hello\u0026#34; 3) \u0026#34;field2\u0026#34; 4) \u0026#34;Hi\u0026#34; 5) \u0026#34;field3\u0026#34; 6) \u0026#34;World\u0026#34; HSETNX ä»…å½“å­—æ®µä¸å­˜åœ¨æ—¶ï¼Œæ‰åœ¨hashä¸­è®¾ç½®å­—æ®µçš„å€¼ã€‚\nè¯­æ³•ï¼š\nHSETNX key field value ç¤ºä¾‹ï¼š redis\u0026gt; HSETNX myhash field \u0026#34;Hello\u0026#34; (integer) 1 redis\u0026gt; HSETNX myhash field \u0026#34;World\u0026#34; (integer) 0 redis\u0026gt; HGET myhash field \u0026#34;Hello\u0026#34; HSTRLEN è¿”å›å­—æ®µå€¼çš„é•¿åº¦ã€‚\nè¯­æ³•ï¼š\nHSTRLEN key field ç¤ºä¾‹ï¼š redis\u0026gt; HSET myhash f1 HelloWorld f2 99 f3 -256 (integer) 3 redis\u0026gt; HSTRLEN myhash f1 (integer) 10 redis\u0026gt; HSTRLEN myhash f2 (integer) 2 redis\u0026gt; HSTRLEN myhash f3 (integer) 4 HVALS è¿”å›hashä¸­çš„æ‰€æœ‰å€¼ã€‚\nè¯­æ³•ï¼š\nHVALS key ç¤ºä¾‹ï¼š redis\u0026gt; HSET myhash field1 \u0026#34;Hello\u0026#34; (integer) 1 redis\u0026gt; HSET myhash field2 \u0026#34;World\u0026#34; (integer) 1 redis\u0026gt; HVALS myhash 1) \u0026#34;Hello\u0026#34; 2) \u0026#34;World\u0026#34; ","permalink":"https://heliu.site/posts/redis/hash/","summary":"redis hashä»‹ç»ã€‚","title":"redis hash"},{"content":" å®˜æ–¹æ–‡æ¡£åœ°å€ï¼šhttps://redis.io/commands/?group=list rediså®¢æˆ·ç«¯æŸ¥è¯¢å‘½ä»¤ï¼šhelp @list list Redisä¸­çš„Listç±»å‹æ˜¯ä¸€ä¸ªåŒå‘é“¾è¡¨ç»“æ„ã€‚æ—¢å¯ä»¥æ”¯æŒæ­£å‘æ£€ç´¢å’Œä¹Ÿå¯ä»¥æ”¯æŒåå‘æ£€ç´¢ã€‚ ç‰¹ç‚¹æ˜¯ï¼šæœ‰åºã€å…ƒç´ å¯ä»¥é‡å¤ã€æ’å…¥å’Œåˆ é™¤å¿«ã€æŸ¥è¯¢é€Ÿåº¦ä¸€èˆ¬ã€‚ å¸¸ç”¨æ¥å­˜å‚¨ä¸€ä¸ªæœ‰åºæ•°æ®ï¼Œä¾‹å¦‚ï¼šæœ‹å‹åœˆç‚¹èµåˆ—è¡¨ï¼Œè¯„è®ºåˆ—è¡¨ç­‰ã€‚ BLMOVE ä»listä¸­å¼¹å‡ºä¸€ä¸ªå…ƒç´ ï¼Œå°†å…¶æ¨å…¥å¦ä¸€ä¸ªlistå¹¶è¿”å›ã€‚é˜»å¡ï¼Œç›´åˆ°å…ƒç´ å¯ç”¨ä¸ºæ­¢ã€‚å¦‚æœæœ€åä¸€ä¸ªå…ƒç´ è¢«ç§»åŠ¨ï¼Œåˆ™åˆ é™¤listã€‚\nè¯­æ³•ï¼š\nBLMOVE source destination \u0026lt;LEFT | RIGHT\u0026gt; \u0026lt;LEFT | RIGHT\u0026gt; timeout BLMPOP ä»å¤šä¸ªlistä¸­å¼¹å‡ºç¬¬ä¸€ä¸ªå…ƒç´ ã€‚é˜»å¡ï¼Œç›´åˆ°å…ƒç´ å¯ç”¨ä¸ºæ­¢ã€‚å¦‚æœå¼¹å‡ºæœ€åä¸€ä¸ªå…ƒç´ ï¼Œåˆ™åˆ é™¤listã€‚\nè¯­æ³•ï¼š\nBLMPOP timeout numkeys key [key ...] \u0026lt;LEFT | RIGHT\u0026gt; [COUNT count] BLPOP ç§»é™¤å¹¶è¿”å›listä¸­çš„ç¬¬ä¸€ä¸ªå…ƒç´ ã€‚é˜»å¡ï¼Œç›´åˆ°å…ƒç´ å¯ç”¨ä¸ºæ­¢ã€‚å¦‚æœå¼¹å‡ºæœ€åä¸€ä¸ªå…ƒç´ ï¼Œåˆ™åˆ é™¤listã€‚\nè¯­æ³•ï¼š\nBLPOP key [key ...] timeout ç¤ºä¾‹ï¼š redis\u0026gt; DEL list1 list2 (integer) 0 redis\u0026gt; RPUSH list1 a b c (integer) 3 redis\u0026gt; BLPOP list1 list2 0 1) \u0026#34;list1\u0026#34; 2) \u0026#34;a\u0026#34; BRPOP ç§»é™¤å¹¶è¿”å›listä¸­çš„æœ€åä¸€ä¸ªå…ƒç´ ã€‚é˜»å¡ï¼Œç›´åˆ°å…ƒç´ å¯ç”¨ä¸ºæ­¢ã€‚å¦‚æœå¼¹å‡ºæœ€åä¸€ä¸ªå…ƒç´ ï¼Œåˆ™åˆ é™¤listã€‚\nè¯­æ³•ï¼š\nBRPOP key [key ...] timeout ç¤ºä¾‹ï¼š redis\u0026gt; DEL list1 list2 (integer) 0 redis\u0026gt; RPUSH list1 a b c (integer) 3 redis\u0026gt; BRPOP list1 list2 0 1) \u0026#34;list1\u0026#34; 2) \u0026#34;c\u0026#34; BRPOPLPUSH ä»listä¸­å¼¹å‡ºä¸€ä¸ªå…ƒç´ ï¼Œå°†å…¶æ¨å…¥å¦ä¸€ä¸ªlistå¹¶è¿”å›ã€‚é˜»å¡ï¼Œç›´åˆ°å…ƒç´ å¯ç”¨ä¸ºæ­¢ã€‚å¦‚æœå¼¹å‡ºæœ€åä¸€ä¸ªå…ƒç´ ï¼Œåˆ™åˆ é™¤listã€‚\nè¯­æ³•ï¼š\nBRPOPLPUSH source destination timeout LINDEX æ ¹æ®ç´¢å¼•ä»listä¸­è¿”å›ä¸€ä¸ªå…ƒç´ ã€‚\nè¯­æ³•ï¼š\nLINDEX key index ç¤ºä¾‹ï¼š redis\u0026gt; LPUSH mylist \u0026#34;World\u0026#34; (integer) 1 redis\u0026gt; LPUSH mylist \u0026#34;Hello\u0026#34; (integer) 2 redis\u0026gt; LINDEX mylist 0 \u0026#34;Hello\u0026#34; redis\u0026gt; LINDEX mylist -1 \u0026#34;World\u0026#34; redis\u0026gt; LINDEX mylist 3 (nil) LINSERT å°†ä¸€ä¸ªå…ƒç´ æ’å…¥listä¸­å¦ä¸€ä¸ªå…ƒç´ ä¹‹å‰æˆ–ä¹‹åã€‚\nè¯­æ³•ï¼š\nLINSERT key \u0026lt;BEFORE | AFTER\u0026gt; pivot element ç¤ºä¾‹ï¼š redis\u0026gt; RPUSH mylist \u0026#34;Hello\u0026#34; (integer) 1 redis\u0026gt; RPUSH mylist \u0026#34;World\u0026#34; (integer) 2 redis\u0026gt; LINSERT mylist BEFORE \u0026#34;World\u0026#34; \u0026#34;There\u0026#34; (integer) 3 redis\u0026gt; LRANGE mylist 0 -1 1) \u0026#34;Hello\u0026#34; 2) \u0026#34;There\u0026#34; 3) \u0026#34;World\u0026#34; LLEN Returns the length of a list.\nè¿”å›listçš„é•¿åº¦ã€‚\nè¯­æ³•ï¼š\nLLEN key ç¤ºä¾‹ï¼š redis\u0026gt; LPUSH mylist \u0026#34;World\u0026#34; (integer) 1 redis\u0026gt; LPUSH mylist \u0026#34;Hello\u0026#34; (integer) 2 redis\u0026gt; LLEN mylist (integer) 2 LMOVE ä»ä¸€ä¸ªlistä¸­å¼¹å‡ºå…ƒç´ å¹¶å°†å…¶å‹å…¥å¦ä¸€ä¸ªliståè¿”å›è¯¥å…ƒç´ ã€‚å¦‚æœæœ€åä¸€ä¸ªå…ƒç´ è¢«ç§»åŠ¨ï¼Œåˆ™åˆ é™¤listã€‚\nè¯­æ³•ï¼š\nLMOVE source destination \u0026lt;LEFT | RIGHT\u0026gt; \u0026lt;LEFT | RIGHT\u0026gt; ç¤ºä¾‹ï¼š redis\u0026gt; RPUSH mylist \u0026#34;one\u0026#34; (integer) 1 redis\u0026gt; RPUSH mylist \u0026#34;two\u0026#34; (integer) 2 redis\u0026gt; RPUSH mylist \u0026#34;three\u0026#34; (integer) 3 redis\u0026gt; LMOVE mylist myotherlist RIGHT LEFT \u0026#34;three\u0026#34; redis\u0026gt; LMOVE mylist myotherlist LEFT RIGHT \u0026#34;one\u0026#34; redis\u0026gt; LRANGE mylist 0 -1 1) \u0026#34;two\u0026#34; redis\u0026gt; LRANGE myotherlist 0 -1 1) \u0026#34;three\u0026#34; 2) \u0026#34;one\u0026#34; LMPOP ä»listä¸­åˆ é™¤å¤šä¸ªå…ƒç´ åè¿”å›å®ƒä»¬ã€‚å¦‚æœå¼¹å‡ºæœ€åä¸€ä¸ªå…ƒç´ ï¼Œåˆ™åˆ é™¤listã€‚\nè¯­æ³•ï¼š\nLMPOP numkeys key [key ...] \u0026lt;LEFT | RIGHT\u0026gt; [COUNT count] ç¤ºä¾‹ï¼š redis\u0026gt; LMPOP 2 non1 non2 LEFT COUNT 10 (error) object of type \u0026#39;NoneType\u0026#39; has no len() redis\u0026gt; LPUSH mylist \u0026#34;one\u0026#34; \u0026#34;two\u0026#34; \u0026#34;three\u0026#34; \u0026#34;four\u0026#34; \u0026#34;five\u0026#34; (integer) 5 redis\u0026gt; LMPOP 1 mylist LEFT 1) \u0026#34;mylist\u0026#34; 2) 1) \u0026#34;five\u0026#34; redis\u0026gt; LRANGE mylist 0 -1 1) \u0026#34;four\u0026#34; 2) \u0026#34;three\u0026#34; 3) \u0026#34;two\u0026#34; 4) \u0026#34;one\u0026#34; redis\u0026gt; LMPOP 1 mylist RIGHT COUNT 10 1) \u0026#34;mylist\u0026#34; 2) 1) \u0026#34;one\u0026#34; 2) \u0026#34;two\u0026#34; 3) \u0026#34;three\u0026#34; 4) \u0026#34;four\u0026#34; redis\u0026gt; LPUSH mylist \u0026#34;one\u0026#34; \u0026#34;two\u0026#34; \u0026#34;three\u0026#34; \u0026#34;four\u0026#34; \u0026#34;five\u0026#34; (integer) 5 redis\u0026gt; LPUSH mylist2 \u0026#34;a\u0026#34; \u0026#34;b\u0026#34; \u0026#34;c\u0026#34; \u0026#34;d\u0026#34; \u0026#34;e\u0026#34; (integer) 5 redis\u0026gt; LMPOP 2 mylist mylist2 right count 3 1) \u0026#34;mylist\u0026#34; 2) 1) \u0026#34;one\u0026#34; 2) \u0026#34;two\u0026#34; 3) \u0026#34;three\u0026#34; redis\u0026gt; LRANGE mylist 0 -1 1) \u0026#34;five\u0026#34; 2) \u0026#34;four\u0026#34; redis\u0026gt; LMPOP 2 mylist mylist2 right count 5 1) \u0026#34;mylist\u0026#34; 2) 1) \u0026#34;four\u0026#34; 2) \u0026#34;five\u0026#34; redis\u0026gt; LMPOP 2 mylist mylist2 right count 10 1) \u0026#34;mylist2\u0026#34; 2) 1) \u0026#34;a\u0026#34; 2) \u0026#34;b\u0026#34; 3) \u0026#34;c\u0026#34; 4) \u0026#34;d\u0026#34; 5) \u0026#34;e\u0026#34; redis\u0026gt; EXISTS mylist mylist2 (integer) 0 LPOP Returns the first elements in a list after removing it. Deletes the list if the last element was popped.\nè¿”å›åˆ é™¤liståçš„ç¬¬ä¸€ä¸ªå…ƒç´ ã€‚å¦‚æœå¼¹å‡ºæœ€åä¸€ä¸ªå…ƒç´ ï¼Œåˆ™åˆ é™¤listã€‚\nè¯­æ³•ï¼š\nLPOP key [count] ç¤ºä¾‹ï¼š redis\u0026gt; RPUSH mylist \u0026#34;one\u0026#34; \u0026#34;two\u0026#34; \u0026#34;three\u0026#34; \u0026#34;four\u0026#34; \u0026#34;five\u0026#34; (integer) 5 redis\u0026gt; LPOP mylist \u0026#34;one\u0026#34; redis\u0026gt; LPOP mylist 2 1) \u0026#34;two\u0026#34; 2) \u0026#34;three\u0026#34; redis\u0026gt; LRANGE mylist 0 -1 1) \u0026#34;four\u0026#34; 2) \u0026#34;five\u0026#34; LPOS è¿”å›listä¸­åŒ¹é…å…ƒç´ çš„ç´¢å¼•ã€‚ è¯­æ³•ï¼š LPOS key element [RANK rank] [COUNT num-matches] [MAXLEN len] ç¤ºä¾‹ï¼š redis\u0026gt; RPUSH mylist a b c d 1 2 3 4 3 3 3 (integer) 11 redis\u0026gt; LPOS mylist 3 (integer) 6 redis\u0026gt; LPOS mylist 3 COUNT 0 RANK 2 1) (integer) 8 2) (integer) 9 3) (integer) 10 LPUSH å°†ä¸€ä¸ªæˆ–å¤šä¸ªå…ƒç´ æ·»åŠ åˆ°listä¸­ã€‚å¦‚æœé”®ä¸å­˜åœ¨ï¼Œåˆ™åˆ›å»ºè¯¥é”®ã€‚\nè¯­æ³•ï¼š\nLPUSH key element [element ...] ç¤ºä¾‹ï¼š redis\u0026gt; LPUSH mylist \u0026#34;world\u0026#34; (integer) 1 redis\u0026gt; LPUSH mylist \u0026#34;hello\u0026#34; (integer) 2 redis\u0026gt; LRANGE mylist 0 -1 1) \u0026#34;hello\u0026#34; 2) \u0026#34;world\u0026#34; LPUSHX ä»…å½“listå­˜åœ¨æ—¶ï¼Œå°†ä¸€ä¸ªæˆ–å¤šä¸ªå…ƒç´ æ·»åŠ åˆ°listä¸­ã€‚\nè¯­æ³•ï¼š\nLPUSHX key element [element ...] ç¤ºä¾‹ï¼š redis\u0026gt; LPUSH mylist \u0026#34;World\u0026#34; (integer) 1 redis\u0026gt; LPUSHX mylist \u0026#34;Hello\u0026#34; (integer) 2 redis\u0026gt; LPUSHX myotherlist \u0026#34;Hello\u0026#34; (integer) 0 redis\u0026gt; LRANGE mylist 0 -1 1) \u0026#34;Hello\u0026#34; 2) \u0026#34;World\u0026#34; redis\u0026gt; LRANGE myotherlist 0 -1 (empty array) LRANGE è¿”å›listä¸­çš„å…ƒç´ èŒƒå›´ã€‚\nè¯­æ³•ï¼š\nLRANGE key start stop ç¤ºä¾‹ï¼š redis\u0026gt; RPUSH mylist \u0026#34;one\u0026#34; (integer) 1 redis\u0026gt; RPUSH mylist \u0026#34;two\u0026#34; (integer) 2 redis\u0026gt; RPUSH mylist \u0026#34;three\u0026#34; (integer) 3 redis\u0026gt; LRANGE mylist 0 0 1) \u0026#34;one\u0026#34; redis\u0026gt; LRANGE mylist -3 2 1) \u0026#34;one\u0026#34; 2) \u0026#34;two\u0026#34; 3) \u0026#34;three\u0026#34; redis\u0026gt; LRANGE mylist -100 100 1) \u0026#34;one\u0026#34; 2) \u0026#34;two\u0026#34; 3) \u0026#34;three\u0026#34; redis\u0026gt; LRANGE mylist 5 10 (empty array) LREM ä»listä¸­åˆ é™¤å…ƒç´ ã€‚å¦‚æœæœ€åä¸€ä¸ªå…ƒç´ è¢«åˆ é™¤ï¼Œåˆ™åˆ é™¤listã€‚\nè¯­æ³•ï¼š\nLREM key count element ç¤ºä¾‹ï¼š redis\u0026gt; RPUSH mylist \u0026#34;hello\u0026#34; (integer) 1 redis\u0026gt; RPUSH mylist \u0026#34;hello\u0026#34; (integer) 2 redis\u0026gt; RPUSH mylist \u0026#34;foo\u0026#34; (integer) 3 redis\u0026gt; RPUSH mylist \u0026#34;hello\u0026#34; (integer) 4 redis\u0026gt; LREM mylist -2 \u0026#34;hello\u0026#34; (integer) 2 redis\u0026gt; LRANGE mylist 0 -1 1) \u0026#34;hello\u0026#34; 2) \u0026#34;foo\u0026#34; LSET æ ¹æ®listä¸­å…ƒç´ çš„ç´¢å¼•è®¾ç½®å…ƒç´ çš„å€¼ã€‚\nè¯­æ³•ï¼š\nLSET key index element ç¤ºä¾‹ï¼š redis\u0026gt; RPUSH mylist \u0026#34;one\u0026#34; (integer) 1 redis\u0026gt; RPUSH mylist \u0026#34;two\u0026#34; (integer) 2 redis\u0026gt; RPUSH mylist \u0026#34;three\u0026#34; (integer) 3 redis\u0026gt; LSET mylist 0 \u0026#34;four\u0026#34; \u0026#34;OK\u0026#34; redis\u0026gt; LSET mylist -2 \u0026#34;five\u0026#34; \u0026#34;OK\u0026#34; redis\u0026gt; LRANGE mylist 0 -1 1) \u0026#34;four\u0026#34; 2) \u0026#34;five\u0026#34; 3) \u0026#34;three\u0026#34; LTRIM ä»listä¸¤ç«¯ç§»é™¤å…ƒç´ ã€‚å¦‚æœæ‰€æœ‰å…ƒç´ éƒ½è¢«ä¿®å‰ªï¼Œåˆ™åˆ é™¤listã€‚\nè¯­æ³•ï¼š\nLTRIM key start stop ç¤ºä¾‹ï¼š redis\u0026gt; RPUSH mylist \u0026#34;one\u0026#34; (integer) 1 redis\u0026gt; RPUSH mylist \u0026#34;two\u0026#34; (integer) 2 redis\u0026gt; RPUSH mylist \u0026#34;three\u0026#34; (integer) 3 redis\u0026gt; LTRIM mylist 1 -1 \u0026#34;OK\u0026#34; redis\u0026gt; LRANGE mylist 0 -1 1) \u0026#34;two\u0026#34; 2) \u0026#34;three\u0026#34; RPOP è¿”å›å¹¶åˆ é™¤listçš„æœ€åä¸€ä¸ªå…ƒç´ ã€‚å¦‚æœå¼¹å‡ºæœ€åä¸€ä¸ªå…ƒç´ ï¼Œåˆ™åˆ é™¤listã€‚\nè¯­æ³•ï¼š\nRPOP key [count] ç¤ºä¾‹ï¼š redis\u0026gt; RPUSH mylist \u0026#34;one\u0026#34; \u0026#34;two\u0026#34; \u0026#34;three\u0026#34; \u0026#34;four\u0026#34; \u0026#34;five\u0026#34; (integer) 5 redis\u0026gt; RPOP mylist \u0026#34;five\u0026#34; redis\u0026gt; RPOP mylist 2 1) \u0026#34;four\u0026#34; 2) \u0026#34;three\u0026#34; redis\u0026gt; LRANGE mylist 0 -1 1) \u0026#34;one\u0026#34; 2) \u0026#34;two\u0026#34; RPOPLPUSH å°†listçš„æœ€åä¸€ä¸ªå…ƒç´ ç§»é™¤å¹¶å‹å…¥å¦ä¸€ä¸ªliståè¿”å›è¯¥å…ƒç´ ã€‚å¦‚æœå¼¹å‡ºæœ€åä¸€ä¸ªå…ƒç´ ï¼Œåˆ™åˆ é™¤listã€‚\nè¯­æ³•ï¼š\nRPOPLPUSH source destination ç¤ºä¾‹ï¼š redis\u0026gt; RPUSH mylist \u0026#34;one\u0026#34; (integer) 1 redis\u0026gt; RPUSH mylist \u0026#34;two\u0026#34; (integer) 2 redis\u0026gt; RPUSH mylist \u0026#34;three\u0026#34; (integer) 3 redis\u0026gt; RPOPLPUSH mylist myotherlist \u0026#34;three\u0026#34; redis\u0026gt; LRANGE mylist 0 -1 1) \u0026#34;one\u0026#34; 2) \u0026#34;two\u0026#34; redis\u0026gt; LRANGE myotherlist 0 -1 1) \u0026#34;three\u0026#34; RPUSH å°†ä¸€ä¸ªæˆ–å¤šä¸ªå…ƒç´ é™„åŠ åˆ°listä¸­ã€‚å¦‚æœé”®ä¸å­˜åœ¨ï¼Œåˆ™åˆ›å»ºè¯¥é”®ã€‚\nè¯­æ³•ï¼š\nRPUSH key element [element ...] ç¤ºä¾‹ï¼š redis\u0026gt; RPUSH mylist \u0026#34;hello\u0026#34; (integer) 1 redis\u0026gt; RPUSH mylist \u0026#34;world\u0026#34; (integer) 2 redis\u0026gt; LRANGE mylist 0 -1 1) \u0026#34;hello\u0026#34; 2) \u0026#34;world\u0026#34; RPUSHX ä»…å½“listå­˜åœ¨æ—¶æ‰å°†å…ƒç´ è¿½åŠ åˆ°listã€‚\nè¯­æ³•ï¼š\nRPUSHX key element [element ...] ç¤ºä¾‹ï¼š redis\u0026gt; RPUSH mylist \u0026#34;Hello\u0026#34; (integer) 1 redis\u0026gt; RPUSHX mylist \u0026#34;World\u0026#34; (integer) 2 redis\u0026gt; RPUSHX myotherlist \u0026#34;World\u0026#34; (integer) 0 redis\u0026gt; LRANGE mylist 0 -1 1) \u0026#34;Hello\u0026#34; 2) \u0026#34;World\u0026#34; redis\u0026gt; LRANGE myotherlist 0 -1 (empty array) ","permalink":"https://heliu.site/posts/redis/list/","summary":"redis listä»‹ç»ã€‚","title":"redis list"},{"content":" å®˜æ–¹å‘½ä»¤åœ°å€ï¼šhttps://redis.io/commands/?group=set å®¢æˆ·ç«¯æŸ¥çœ‹å‘½ä»¤ï¼šhelp @set set set ç±»ä¼¼goçš„mapï¼Œä½†æ˜¯valueå€¼æ˜¯struct{}ã€‚å®ƒå…·å¤‡ä»¥ä¸‹ç‰¹å¾ï¼š æ— åºã€å…ƒç´ ä¸å¯é‡å¤ã€æŸ¥æ‰¾å¿«ã€æ”¯æŒäº¤é›†.å¹¶é›†.å·®é›†ç­‰åŠŸèƒ½ SADD å‘setæ·»åŠ ä¸€ä¸ªæˆ–å¤šä¸ªæˆå‘˜ã€‚å¦‚æœkeyä¸å­˜åœ¨ï¼Œåˆ™åˆ›å»ºè¯¥keyã€‚\nè¯­æ³•ï¼š\nSADD key member [member ...] ç¤ºä¾‹ï¼š redis\u0026gt; SADD myset \u0026#34;Hello\u0026#34; (integer) 1 redis\u0026gt; SADD myset \u0026#34;World\u0026#34; (integer) 1 redis\u0026gt; SADD myset \u0026#34;World\u0026#34; (integer) 0 redis\u0026gt; SMEMBERS myset 1) \u0026#34;Hello\u0026#34; 2) \u0026#34;World\u0026#34; SCARD è¿”å›setä¸­æˆå‘˜çš„æ•°ç›®ã€‚\nè¯­æ³•ï¼š\nSCARD key ç¤ºä¾‹ï¼š redis\u0026gt; SADD myset \u0026#34;Hello\u0026#34; (integer) 1 redis\u0026gt; SADD myset \u0026#34;World\u0026#34; (integer) 1 redis\u0026gt; SCARD myset (integer) 2 SDIFF è¿”å›å¤šä¸ªsetçš„å·®å€¼ã€‚\nè¯­æ³•ï¼š\nSDIFF key [key ...] ç¤ºä¾‹ï¼š redis\u0026gt; SADD key1 \u0026#34;a\u0026#34; (integer) 1 redis\u0026gt; SADD key1 \u0026#34;b\u0026#34; (integer) 1 redis\u0026gt; SADD key1 \u0026#34;c\u0026#34; (integer) 1 redis\u0026gt; SADD key2 \u0026#34;c\u0026#34; (integer) 1 redis\u0026gt; SADD key2 \u0026#34;d\u0026#34; (integer) 1 redis\u0026gt; SADD key2 \u0026#34;e\u0026#34; (integer) 1 redis\u0026gt; SDIFF key1 key2 1) \u0026#34;a\u0026#34; 2) \u0026#34;b\u0026#34; SDIFFSTORE å°†å¤šä¸ªsetçš„å·®å¼‚å­˜å‚¨åœ¨ä¸€ä¸ªé”®ä¸­ã€‚\nè¯­æ³•ï¼š\nSDIFFSTORE destination key [key ...] ç¤ºä¾‹ï¼š redis\u0026gt; SADD key1 \u0026#34;a\u0026#34; (integer) 1 redis\u0026gt; SADD key1 \u0026#34;b\u0026#34; (integer) 1 redis\u0026gt; SADD key1 \u0026#34;c\u0026#34; (integer) 1 redis\u0026gt; SADD key2 \u0026#34;c\u0026#34; (integer) 1 redis\u0026gt; SADD key2 \u0026#34;d\u0026#34; (integer) 1 redis\u0026gt; SADD key2 \u0026#34;e\u0026#34; (integer) 1 redis\u0026gt; SDIFFSTORE key key1 key2 (integer) 2 redis\u0026gt; SMEMBERS key 1) \u0026#34;a\u0026#34; 2) \u0026#34;b\u0026#34; SINTER è¿”å›å¤šä¸ªsetçš„äº¤ç‚¹ã€‚\nè¯­æ³•ï¼š\nSINTER key [key ...] ç¤ºä¾‹ï¼š redis\u0026gt; SADD key1 \u0026#34;a\u0026#34; (integer) 1 redis\u0026gt; SADD key1 \u0026#34;b\u0026#34; (integer) 1 redis\u0026gt; SADD key1 \u0026#34;c\u0026#34; (integer) 1 redis\u0026gt; SADD key2 \u0026#34;c\u0026#34; (integer) 1 redis\u0026gt; SADD key2 \u0026#34;d\u0026#34; (integer) 1 redis\u0026gt; SADD key2 \u0026#34;e\u0026#34; (integer) 1 redis\u0026gt; SINTER key1 key2 1) \u0026#34;c\u0026#34; SINTERCARD è¿”å›å¤šä¸ªsetç›¸äº¤çš„æˆå‘˜æ•°ã€‚\nè¯­æ³•ï¼š\nSINTERCARD numkeys key [key ...] [LIMIT limit] ç¤ºä¾‹ï¼š redis\u0026gt; SADD key1 \u0026#34;a\u0026#34; (integer) 1 redis\u0026gt; SADD key1 \u0026#34;b\u0026#34; (integer) 1 redis\u0026gt; SADD key1 \u0026#34;c\u0026#34; (integer) 1 redis\u0026gt; SADD key1 \u0026#34;d\u0026#34; (integer) 1 redis\u0026gt; SADD key2 \u0026#34;c\u0026#34; (integer) 1 redis\u0026gt; SADD key2 \u0026#34;d\u0026#34; (integer) 1 redis\u0026gt; SADD key2 \u0026#34;e\u0026#34; (integer) 1 redis\u0026gt; SINTER key1 key2 1) \u0026#34;c\u0026#34; 2) \u0026#34;d\u0026#34; redis\u0026gt; SINTERCARD 2 key1 key2 (integer) 2 redis\u0026gt; SINTERCARD 2 key1 key2 LIMIT 1 (integer) 1 SINTERSTORE åœ¨ä¸€ä¸ªkeyä¸­å­˜å‚¨å¤šä¸ªsetçš„ç›¸äº¤ã€‚\nè¯­æ³•ï¼š\nSINTERSTORE destination key [key ...] ç¤ºä¾‹ï¼š redis\u0026gt; SADD key1 \u0026#34;a\u0026#34; (integer) 1 redis\u0026gt; SADD key1 \u0026#34;b\u0026#34; (integer) 1 redis\u0026gt; SADD key1 \u0026#34;c\u0026#34; (integer) 1 redis\u0026gt; SADD key2 \u0026#34;c\u0026#34; (integer) 1 redis\u0026gt; SADD key2 \u0026#34;d\u0026#34; (integer) 1 redis\u0026gt; SADD key2 \u0026#34;e\u0026#34; (integer) 1 redis\u0026gt; SINTERSTORE key key1 key2 (integer) 1 redis\u0026gt; SMEMBERS key 1) \u0026#34;c\u0026#34; SISMEMBER ç¡®å®šæˆå‘˜æ˜¯å¦å±äºsetã€‚\nè¯­æ³•ï¼š\nSISMEMBER key member ç¤ºä¾‹ï¼š redis\u0026gt; SADD myset \u0026#34;one\u0026#34; (integer) 1 redis\u0026gt; SISMEMBER myset \u0026#34;one\u0026#34; (integer) 1 redis\u0026gt; SISMEMBER myset \u0026#34;two\u0026#34; (integer) 0 SMEMBERS è¿”å›setçš„æ‰€æœ‰æˆå‘˜ã€‚\nè¯­æ³•ï¼š\nSMEMBERS key ç¤ºä¾‹ï¼š redis\u0026gt; SADD myset \u0026#34;Hello\u0026#34; (integer) 1 redis\u0026gt; SADD myset \u0026#34;World\u0026#34; (integer) 1 redis\u0026gt; SMEMBERS myset 1) \u0026#34;Hello\u0026#34; 2) \u0026#34;World\u0026#34; SMISMEMBER ç¡®å®šå¤šä¸ªæˆå‘˜æ˜¯å¦å±äºä¸€ä¸ªsetã€‚\nè¯­æ³•ï¼š\nSMISMEMBER key member [member ...] ç¤ºä¾‹ï¼š redis\u0026gt; SADD myset \u0026#34;one\u0026#34; (integer) 1 redis\u0026gt; SADD myset \u0026#34;one\u0026#34; (integer) 0 redis\u0026gt; SMISMEMBER myset \u0026#34;one\u0026#34; \u0026#34;notamember\u0026#34; 1) (integer) 1 2) (integer) 0 SMOVE å°†ä¸€ä¸ªæˆå‘˜ä»ä¸€ä¸ªsetç§»åŠ¨åˆ°å¦ä¸€ä¸ªsetã€‚\nè¯­æ³•ï¼š\nSMOVE source destination member ç¤ºä¾‹ï¼š redis\u0026gt; SADD myset \u0026#34;one\u0026#34; (integer) 1 redis\u0026gt; SADD myset \u0026#34;two\u0026#34; (integer) 1 redis\u0026gt; SADD myotherset \u0026#34;three\u0026#34; (integer) 1 redis\u0026gt; SMOVE myset myotherset \u0026#34;two\u0026#34; (integer) 1 redis\u0026gt; SMEMBERS myset 1) \u0026#34;one\u0026#34; redis\u0026gt; SMEMBERS myotherset 2) \u0026#34;three\u0026#34; 3) \u0026#34;two\u0026#34; SPOP ä»setä¸­åˆ é™¤ä¸€ä¸ªæˆ–å¤šä¸ªéšæœºæˆå‘˜åè¿”å›å®ƒä»¬ã€‚å¦‚æœæœ€åä¸€ä¸ªæˆå‘˜è¢«å¼¹å‡ºï¼Œåˆ™åˆ é™¤è¯¥setã€‚\nè¯­æ³•ï¼š\nSPOP key [count] ç¤ºä¾‹ï¼š redis\u0026gt; SADD myset \u0026#34;one\u0026#34; (integer) 1 redis\u0026gt; SADD myset \u0026#34;two\u0026#34; (integer) 1 redis\u0026gt; SADD myset \u0026#34;three\u0026#34; (integer) 1 redis\u0026gt; SPOP myset \u0026#34;one\u0026#34; redis\u0026gt; SMEMBERS myset 1) \u0026#34;two\u0026#34; 2) \u0026#34;three\u0026#34; redis\u0026gt; SADD myset \u0026#34;four\u0026#34; (integer) 1 redis\u0026gt; SADD myset \u0026#34;five\u0026#34; (integer) 1 redis\u0026gt; SPOP myset 3 3) \u0026#34;two\u0026#34; 4) \u0026#34;three\u0026#34; 5) \u0026#34;four\u0026#34; redis\u0026gt; SMEMBERS myset 6) \u0026#34;five\u0026#34; SRANDMEMER ä»setä¸­è·å–ä¸€ä¸ªæˆ–å¤šä¸ªéšæœºæˆå‘˜\nè¯­æ³•ï¼š\nSRANDMEMBER key [count] ç¤ºä¾‹ï¼š redis\u0026gt; SADD myset one two three (integer) 3 redis\u0026gt; SRANDMEMBER myset \u0026#34;two\u0026#34; redis\u0026gt; SRANDMEMBER myset 2 1) \u0026#34;two\u0026#34; 2) \u0026#34;three\u0026#34; redis\u0026gt; SRANDMEMBER myset -5 3) \u0026#34;three\u0026#34; 4) \u0026#34;one\u0026#34; 5) \u0026#34;three\u0026#34; 6) \u0026#34;two\u0026#34; 7) \u0026#34;three\u0026#34; SREM ä»setä¸­åˆ é™¤ä¸€ä¸ªæˆ–å¤šä¸ªæˆå‘˜ã€‚å¦‚æœæœ€åä¸€ä¸ªæˆå‘˜è¢«åˆ é™¤ï¼Œåˆ™åˆ é™¤è¯¥setã€‚\nè¯­æ³•ï¼š\nSREM key member [member ...] ç¤ºä¾‹ï¼š redis\u0026gt; SADD myset \u0026#34;one\u0026#34; (integer) 1 redis\u0026gt; SADD myset \u0026#34;two\u0026#34; (integer) 1 redis\u0026gt; SADD myset \u0026#34;three\u0026#34; (integer) 1 redis\u0026gt; SREM myset \u0026#34;one\u0026#34; (integer) 1 redis\u0026gt; SREM myset \u0026#34;four\u0026#34; (integer) 0 redis\u0026gt; SMEMBERS myset 1) \u0026#34;two\u0026#34; 2) \u0026#34;three\u0026#34; SSCAN éå†setçš„æˆå‘˜ã€‚\nè¯­æ³•ï¼š\nSSCAN key cursor [MATCH pattern] [COUNT count] SUNION è¿”å›å¤šä¸ªsetçš„å¹¶é›†ã€‚\nè¯­æ³•ï¼š\nSUNION key [key ...] ç¤ºä¾‹ï¼š redis\u0026gt; SADD key1 \u0026#34;a\u0026#34; (integer) 1 redis\u0026gt; SADD key1 \u0026#34;b\u0026#34; (integer) 1 redis\u0026gt; SADD key1 \u0026#34;c\u0026#34; (integer) 1 redis\u0026gt; SADD key2 \u0026#34;c\u0026#34; (integer) 1 redis\u0026gt; SADD key2 \u0026#34;d\u0026#34; (integer) 1 redis\u0026gt; SADD key2 \u0026#34;e\u0026#34; (integer) 1 redis\u0026gt; SUNION key1 key2 1) \u0026#34;a\u0026#34; 2) \u0026#34;b\u0026#34; 3) \u0026#34;c\u0026#34; 4) \u0026#34;d\u0026#34; 5) \u0026#34;e\u0026#34; SUNIONSTORE å°†å¤šä¸ªsetçš„å¹¶é›†å­˜å‚¨åœ¨ä¸€ä¸ªkeyä¸­ã€‚\nè¯­æ³•ï¼š\nSUNIONSTORE destination key [key ...] ç¤ºä¾‹ï¼š redis\u0026gt; SADD key1 \u0026#34;a\u0026#34; (integer) 1 redis\u0026gt; SADD key1 \u0026#34;b\u0026#34; (integer) 1 redis\u0026gt; SADD key1 \u0026#34;c\u0026#34; (integer) 1 redis\u0026gt; SADD key2 \u0026#34;c\u0026#34; (integer) 1 redis\u0026gt; SADD key2 \u0026#34;d\u0026#34; (integer) 1 redis\u0026gt; SADD key2 \u0026#34;e\u0026#34; (integer) 1 redis\u0026gt; SUNIONSTORE key key1 key2 (integer) 5 redis\u0026gt; SMEMBERS key 1) \u0026#34;a\u0026#34; 2) \u0026#34;b\u0026#34; 3) \u0026#34;c\u0026#34; 4) \u0026#34;d\u0026#34; 5) \u0026#34;e\u0026#34; ","permalink":"https://heliu.site/posts/redis/set/","summary":"redis setä»‹ç»ã€‚","title":"redis set"},{"content":" å®˜æ–¹å‘½ä»¤åœ°å€ï¼šhttps://redis.io/commands/?group=sorted-set sortSet sortedSetæ˜¯ä¸€ä¸ªå¯æ’åºçš„seté›†åˆã€‚ SortedSetä¸­çš„æ¯ä¸€ä¸ªå…ƒç´ éƒ½å¸¦æœ‰ä¸€ä¸ªscoreå±æ€§ï¼Œå¯ä»¥åŸºäºscoreå±æ€§å¯¹å…ƒç´ æ’åºï¼Œåº•å±‚çš„å®ç°æ˜¯ä¸€ä¸ªè·³è¡¨ï¼ˆSkipListï¼‰åŠ  hashè¡¨ã€‚ SortedSetå…·å¤‡ä¸‹åˆ—ç‰¹æ€§ï¼šå¯æ’åºã€å…ƒç´ ä¸é‡å¤ã€æŸ¥è¯¢é€Ÿåº¦å¿«ã€‚ å› ä¸ºSortedSetçš„å¯æ’åºç‰¹æ€§ï¼Œç»å¸¸è¢«ç”¨æ¥å®ç°æ’è¡Œæ¦œè¿™æ ·çš„åŠŸèƒ½ã€‚ ZADD å‘sortSetæ·»åŠ ä¸€ä¸ªæˆ–å¤šä¸ªæˆå‘˜ï¼Œæˆ–æ›´æ–°å…¶åˆ†æ•°ã€‚å¦‚æœkeyä¸å­˜åœ¨ï¼Œåˆ™åˆ›å»ºè¯¥keyã€‚\nè¯­æ³•ï¼š\nZADD key [NX | XX] [GT | LT] [CH] [INCR] score member [score member ...] XX: åªæ›´æ–°å·²ç»å­˜åœ¨çš„å…ƒç´ ã€‚ä¸è¦æ·»åŠ æ–°å…ƒç´ ã€‚ NX: åªæ·»åŠ æ–°å…ƒç´ ã€‚ä¸è¦æ›´æ–°å·²ç»å­˜åœ¨çš„å…ƒç´ ã€‚ LT: åªæœ‰å½“æ–°scoreå°äºå½“å‰åˆ†æ•°æ—¶æ‰æ›´æ–°ç°æœ‰å…ƒç´ ã€‚è¿™ä¸ªæ ‡å¿—ä¸ä¼šé˜»æ­¢æ·»åŠ æ–°å…ƒç´ ã€‚ GT: åªæœ‰å½“æ–°scoreå¤§äºå½“å‰åˆ†æ•°æ—¶æ‰æ›´æ–°ç°æœ‰å…ƒç´ ã€‚è¿™ä¸ªæ ‡å¿—ä¸ä¼šé˜»æ­¢æ·»åŠ æ–°å…ƒç´ ã€‚ CH: å°†è¿”å›å€¼ä»æ·»åŠ çš„æ–°å…ƒç´ æ•°ä¿®æ”¹ä¸ºæ›´æ”¹çš„å…ƒç´ æ€»æ•°(CHæ˜¯changedçš„ç¼©å†™)ã€‚æ›´æ”¹çš„å…ƒç´ æ˜¯æ–°æ·»åŠ çš„å…ƒç´ å’Œå·²ç»å­˜åœ¨çš„å…ƒç´ æ›´æ–°çš„åˆ†æ•°ã€‚å› æ­¤ï¼Œåœ¨å‘½ä»¤è¡Œä¸­æŒ‡å®šçš„å…·æœ‰ä¸è¿‡å»ç›¸åŒåˆ†æ•°çš„å…ƒç´ ä¸ä¼šè¢«è®¡ç®—åœ¨å†…ã€‚æ³¨æ„:é€šå¸¸\u0026rsquo; ZADD \u0026lsquo;çš„è¿”å›å€¼åªè®¡ç®—æ·»åŠ çš„æ–°å…ƒç´ çš„æ•°é‡ã€‚ INCR: å½“æŒ‡å®šè¯¥é€‰é¡¹æ—¶ï¼Œ\u0026lsquo;ZADD\u0026rsquo;çš„è¡Œä¸ºç±»ä¼¼äº\u0026lsquo;ZINCRBY\u0026rsquo;ã€‚åœ¨è¿™ç§æ¨¡å¼ä¸‹åªèƒ½æŒ‡å®šä¸€ä¸ªåˆ†æ•°-å…ƒç´ å¯¹ã€‚\nç¤ºä¾‹ï¼š redis\u0026gt; ZADD myzset 1 \u0026#34;one\u0026#34; (integer) 1 redis\u0026gt; ZADD myzset 1 \u0026#34;uno\u0026#34; (integer) 1 redis\u0026gt; ZADD myzset 2 \u0026#34;two\u0026#34; 3 \u0026#34;three\u0026#34; (integer) 2 redis\u0026gt; ZRANGE myzset 0 -1 WITHSCORES 1) \u0026#34;one\u0026#34; 2) \u0026#34;1\u0026#34; 3) \u0026#34;uno\u0026#34; 4) \u0026#34;1\u0026#34; 5) \u0026#34;two\u0026#34; 6) \u0026#34;2\u0026#34; 7) \u0026#34;three\u0026#34; 8) \u0026#34;3\u0026#34; ZCARD è¿”å›å·²sortSetä¸­æˆå‘˜çš„æ•°ç›®ã€‚\nè¯­æ³•ï¼š\nZCARD key ç¤ºä¾‹ï¼š redis\u0026gt; ZADD myzset 1 \u0026#34;one\u0026#34; (integer) 1 redis\u0026gt; ZADD myzset 2 \u0026#34;two\u0026#34; (integer) 1 redis\u0026gt; ZCARD myzset (integer) 2 ZCOUNT è¿”å›æ’åºé›†ä¸­åˆ†æ•°åœ¨ä¸€å®šèŒƒå›´å†…çš„æˆå‘˜çš„è®¡æ•°ã€‚\nè¯­æ³•ï¼š\nZCOUNT key min max ç¤ºä¾‹ï¼š redis\u0026gt; ZADD myzset 1 \u0026#34;one\u0026#34; (integer) 1 redis\u0026gt; ZADD myzset 2 \u0026#34;two\u0026#34; (integer) 1 redis\u0026gt; ZADD myzset 3 \u0026#34;three\u0026#34; (integer) 1 redis\u0026gt; ZCOUNT myzset -inf +inf (integer) 3 redis\u0026gt; ZCOUNT myzset (1 3 (integer) 2 ZDIFF è¿”å›å¤šä¸ªæ’åºé›†ä¹‹é—´çš„å·®å€¼ã€‚\nè¯­æ³•ï¼š\nZDIFF numkeys key [key ...] [WITHSCORES] ç¤ºä¾‹ï¼š redis\u0026gt; ZADD zset1 1 \u0026#34;one\u0026#34; (integer) 1 redis\u0026gt; ZADD zset1 2 \u0026#34;two\u0026#34; (integer) 1 redis\u0026gt; ZADD zset1 3 \u0026#34;three\u0026#34; (integer) 1 redis\u0026gt; ZADD zset2 1 \u0026#34;one\u0026#34; (integer) 1 redis\u0026gt; ZADD zset2 2 \u0026#34;two\u0026#34; (integer) 1 redis\u0026gt; ZDIFF 2 zset1 zset2 1) \u0026#34;three\u0026#34; redis\u0026gt; ZDIFF 2 zset1 zset2 WITHSCORES 2) \u0026#34;three\u0026#34; 3) \u0026#34;3\u0026#34; ZDIFFSTORE å°†å¤šä¸ªæ’åºé›†çš„å·®å€¼å­˜å‚¨åœ¨ä¸€ä¸ªé”®ä¸­ã€‚\nè¯­æ³•ï¼š\nZDIFFSTORE destination numkeys key [key ...] ç¤ºä¾‹ï¼š redis\u0026gt; ZADD zset1 1 \u0026#34;one\u0026#34; (integer) 1 redis\u0026gt; ZADD zset1 2 \u0026#34;two\u0026#34; (integer) 1 redis\u0026gt; ZADD zset1 3 \u0026#34;three\u0026#34; (integer) 1 redis\u0026gt; ZADD zset2 1 \u0026#34;one\u0026#34; (integer) 1 redis\u0026gt; ZADD zset2 2 \u0026#34;two\u0026#34; (integer) 1 redis\u0026gt; ZDIFFSTORE out 2 zset1 zset2 (integer) 1 redis\u0026gt; ZRANGE out 0 -1 WITHSCORES 1) \u0026#34;three\u0026#34; 2) \u0026#34;3\u0026#34; ZINCRBY å¢åŠ å·²sortSetä¸­æˆå‘˜çš„åˆ†æ•°ã€‚\nè¯­æ³•ï¼š\nZINCRBY key increment member ç¤ºä¾‹ï¼š redis\u0026gt; ZADD myzset 1 \u0026#34;one\u0026#34; (integer) 1 redis\u0026gt; ZADD myzset 2 \u0026#34;two\u0026#34; (integer) 1 redis\u0026gt; ZINCRBY myzset 2 \u0026#34;one\u0026#34; \u0026#34;3\u0026#34; redis\u0026gt; ZRANGE myzset 0 -1 WITHSCORES 1) \u0026#34;two\u0026#34; 2) \u0026#34;2\u0026#34; 3) \u0026#34;one\u0026#34; 4) \u0026#34;3\u0026#34; ZINTER è¿”å›å¤šä¸ªæ’åºé›†çš„ç›¸äº¤ã€‚\nè¯­æ³•ï¼š\nZINTER numkeys key [key ...] [WEIGHTS weight [weight ...]] [AGGREGATE \u0026lt;SUM | MIN | MAX\u0026gt;] [WITHSCORES] ç¤ºä¾‹ï¼š redis\u0026gt; ZADD zset1 1 \u0026#34;one\u0026#34; (integer) 1 redis\u0026gt; ZADD zset1 2 \u0026#34;two\u0026#34; (integer) 1 redis\u0026gt; ZADD zset2 1 \u0026#34;one\u0026#34; (integer) 1 redis\u0026gt; ZADD zset2 2 \u0026#34;two\u0026#34; (integer) 1 redis\u0026gt; ZADD zset2 3 \u0026#34;three\u0026#34; (integer) 1 redis\u0026gt; ZINTER 2 zset1 zset2 1) \u0026#34;one\u0026#34; 2) \u0026#34;two\u0026#34; redis\u0026gt; ZINTER 2 zset1 zset2 WITHSCORES 3) \u0026#34;one\u0026#34; 4) \u0026#34;2\u0026#34; 5) \u0026#34;two\u0026#34; 6) \u0026#34;4\u0026#34; ZINTERCARD è¿”å›å¤šä¸ªæ’åºé›†ç›¸äº¤çš„æˆå‘˜æ•°ã€‚\nè¯­æ³•ï¼š\nZINTERCARD numkeys key [key ...] [LIMIT limit] ç¤ºä¾‹ï¼š redis\u0026gt; ZADD zset1 1 \u0026#34;one\u0026#34; (integer) 1 redis\u0026gt; ZADD zset1 2 \u0026#34;two\u0026#34; (integer) 1 redis\u0026gt; ZADD zset2 1 \u0026#34;one\u0026#34; (integer) 1 redis\u0026gt; ZADD zset2 2 \u0026#34;two\u0026#34; (integer) 1 redis\u0026gt; ZADD zset2 3 \u0026#34;three\u0026#34; (integer) 1 redis\u0026gt; ZINTER 2 zset1 zset2 1) \u0026#34;one\u0026#34; 2) \u0026#34;two\u0026#34; redis\u0026gt; ZINTERCARD 2 zset1 zset2 (integer) 2 redis\u0026gt; ZINTERCARD 2 zset1 zset2 LIMIT 1 (integer) 1 ZINTERSTORE å°†å¤šä¸ªæ’åºé›†çš„ç›¸äº¤å­˜å‚¨åœ¨ä¸€ä¸ªé”®ä¸­ã€‚\nè¯­æ³•ï¼š\nZINTERSTORE destination numkeys key [key ...] [WEIGHTS weight [weight ...]] [AGGREGATE \u0026lt;SUM | MIN | MAX\u0026gt;] è¯­æ³•ï¼š redis\u0026gt; ZADD zset1 1 \u0026#34;one\u0026#34; (integer) 1 redis\u0026gt; ZADD zset1 2 \u0026#34;two\u0026#34; (integer) 1 redis\u0026gt; ZADD zset2 1 \u0026#34;one\u0026#34; (integer) 1 redis\u0026gt; ZADD zset2 2 \u0026#34;two\u0026#34; (integer) 1 redis\u0026gt; ZADD zset2 3 \u0026#34;three\u0026#34; (integer) 1 redis\u0026gt; ZINTERSTORE out 2 zset1 zset2 WEIGHTS 2 3 (integer) 2 redis\u0026gt; ZRANGE out 0 -1 WITHSCORES 1) \u0026#34;one\u0026#34; 2) \u0026#34;5\u0026#34; 3) \u0026#34;two\u0026#34; 4) \u0026#34;10\u0026#34; ZLEXCOUNT è¿”å›å­—å…¸é¡ºåºèŒƒå›´å†…å·²sortSetä¸­çš„æˆå‘˜æ•°ã€‚\nè¯­æ³•ï¼š\nZLEXCOUNT key min max ç¤ºä¾‹ï¼š redis\u0026gt; ZADD myzset 0 a 0 b 0 c 0 d 0 e (integer) 5 redis\u0026gt; ZADD myzset 0 f 0 g (integer) 2 redis\u0026gt; ZLEXCOUNT myzset - + (integer) 7 redis\u0026gt; ZLEXCOUNT myzset [b [f (integer) 5 ZMPOP ä»ä¸€ä¸ªæˆ–å¤šä¸ªå·²æ’åºçš„é›†åˆä¸­è¿”å›åˆ é™¤åå¾—åˆ†æœ€é«˜æˆ–æœ€ä½çš„æˆå‘˜ã€‚å¦‚æœå¼¹å‡ºæœ€åä¸€ä¸ªæˆå‘˜ï¼Œåˆ™åˆ é™¤æ’åºé›†ã€‚\nè¯­æ³•ï¼š\nZMPOP numkeys key [key ...] \u0026lt;MIN | MAX\u0026gt; [COUNT count] ç¤ºä¾‹ï¼š redis\u0026gt; ZMPOP 1 notsuchkey MIN (error) object of type \u0026#39;NoneType\u0026#39; has no len() redis\u0026gt; ZADD myzset 1 \u0026#34;one\u0026#34; 2 \u0026#34;two\u0026#34; 3 \u0026#34;three\u0026#34; (integer) 3 redis\u0026gt; ZMPOP 1 myzset MIN 1) \u0026#34;myzset\u0026#34; 2) 1) 1) \u0026#34;one\u0026#34; 1) \u0026#34;1\u0026#34; redis\u0026gt; ZRANGE myzset 0 -1 WITHSCORES 3) \u0026#34;two\u0026#34; 4) \u0026#34;2\u0026#34; 5) \u0026#34;three\u0026#34; 6) \u0026#34;3\u0026#34; redis\u0026gt; ZMPOP 1 myzset MAX COUNT 10 7) \u0026#34;myzset\u0026#34; 8) 1) 1) \u0026#34;three\u0026#34; 2) \u0026#34;3\u0026#34; 2) 1) \u0026#34;two\u0026#34; 1) \u0026#34;2\u0026#34; redis\u0026gt; ZADD myzset2 4 \u0026#34;four\u0026#34; 5 \u0026#34;five\u0026#34; 6 \u0026#34;six\u0026#34; (integer) 3 redis\u0026gt; ZMPOP 2 myzset myzset2 MIN COUNT 10 9) \u0026#34;myzset2\u0026#34; 10) 1) 1) \u0026#34;four\u0026#34; 1) \u0026#34;4\u0026#34; 1) 1) \u0026#34;five\u0026#34; 1) \u0026#34;5\u0026#34; 2) 1) \u0026#34;six\u0026#34; 1) \u0026#34;6\u0026#34; redis\u0026gt; ZRANGE myzset 0 -1 WITHSCORES (empty array) redis\u0026gt; ZMPOP 2 myzset myzset2 MAX COUNT 10 (error) object of type \u0026#39;NoneType\u0026#39; has no len() redis\u0026gt; ZRANGE myzset2 0 -1 WITHSCORES (empty array) redis\u0026gt; EXISTS myzset myzset2 (integer) 0 ZMSCORE è¿”å›å·²sortSetä¸­ä¸€ä¸ªæˆ–å¤šä¸ªæˆå‘˜çš„åˆ†æ•°ã€‚\nè¯­æ³•ï¼š\nZMSCORE key member [member ...] ç¤ºä¾‹ï¼š redis\u0026gt; ZADD myzset 1 \u0026#34;one\u0026#34; (integer) 1 redis\u0026gt; ZADD myzset 2 \u0026#34;two\u0026#34; (integer) 1 redis\u0026gt; ZMSCORE myzset \u0026#34;one\u0026#34; \u0026#34;two\u0026#34; \u0026#34;nofield\u0026#34; 1) \u0026#34;1\u0026#34; 2) \u0026#34;2\u0026#34; 3) (nil) ZPOPMAX ä»å·²æ’åºçš„é›†åˆä¸­åˆ é™¤å¾—åˆ†æœ€é«˜çš„æˆå‘˜åè¿”å›å®ƒä»¬ã€‚å¦‚æœå¼¹å‡ºæœ€åä¸€ä¸ªæˆå‘˜ï¼Œåˆ™åˆ é™¤æ’åºé›†ã€‚ ZPOPMAX key [count] ç¤ºä¾‹ï¼š redis\u0026gt; ZADD myzset 1 \u0026#34;one\u0026#34; (integer) 1 redis\u0026gt; ZADD myzset 2 \u0026#34;two\u0026#34; (integer) 1 redis\u0026gt; ZADD myzset 3 \u0026#34;three\u0026#34; (integer) 1 redis\u0026gt; ZPOPMAX myzset 1) \u0026#34;three\u0026#34; 2) \u0026#34;3\u0026#34; ZPOPMIN ä»å·²æ’åºçš„é›†åˆä¸­åˆ é™¤å¾—åˆ†æœ€ä½çš„æˆå‘˜åè¿”å›å®ƒä»¬ã€‚å¦‚æœå¼¹å‡ºæœ€åä¸€ä¸ªæˆå‘˜ï¼Œåˆ™åˆ é™¤æ’åºé›†ã€‚\nè¯­æ³•ï¼š\nZPOPMIN key [count] ç¤ºä¾‹ï¼š redis\u0026gt; ZADD myzset 1 \u0026#34;one\u0026#34; (integer) 1 redis\u0026gt; ZADD myzset 2 \u0026#34;two\u0026#34; (integer) 1 redis\u0026gt; ZADD myzset 3 \u0026#34;three\u0026#34; (integer) 1 redis\u0026gt; ZPOPMIN myzset 1) \u0026#34;one\u0026#34; 2) \u0026#34;1\u0026#34; ZRANDMEMBER ä»å·²æ’åºçš„é›†åˆä¸­è¿”å›ä¸€ä¸ªæˆ–å¤šä¸ªéšæœºæˆå‘˜ã€‚\nè¯­æ³•ï¼š\nZRANDMEMBER key [count [WITHSCORES]] ç¤ºä¾‹ï¼š redis\u0026gt; ZADD dadi 1 uno 2 due 3 tre 4 quattro 5 cinque 6 sei (integer) 6 redis\u0026gt; ZRANDMEMBER dadi \u0026#34;quattro\u0026#34; redis\u0026gt; ZRANDMEMBER dadi \u0026#34;due\u0026#34; redis\u0026gt; ZRANDMEMBER dadi -5 WITHSCORES 1) \u0026#34;uno\u0026#34; 2) \u0026#34;1\u0026#34; 3) \u0026#34;tre\u0026#34; 4) \u0026#34;3\u0026#34; 5) \u0026#34;quattro\u0026#34; 6) \u0026#34;4\u0026#34; 7) \u0026#34;cinque\u0026#34; 8) \u0026#34;5\u0026#34; 9) \u0026#34;cinque\u0026#34; 10) \u0026#34;5\u0026#34; ZRANGE è¿”å›ç´¢å¼•èŒƒå›´å†…å·²sortSetä¸­çš„æˆå‘˜ã€‚\nè¯­æ³•ï¼š\nZRANGE key start stop [BYSCORE | BYLEX] [REV] [LIMIT offset count] [WITHSCORES] ç¤ºä¾‹ï¼š redis\u0026gt; ZADD myzset 1 \u0026#34;one\u0026#34; 2 \u0026#34;two\u0026#34; 3 \u0026#34;three\u0026#34; (integer) 3 redis\u0026gt; ZRANGE myzset 0 -1 1) \u0026#34;one\u0026#34; 2) \u0026#34;two\u0026#34; 3) \u0026#34;three\u0026#34; redis\u0026gt; ZRANGE myzset 2 3 4) \u0026#34;three\u0026#34; redis\u0026gt; ZRANGE myzset -2 -1 5) \u0026#34;two\u0026#34; 6) \u0026#34;three\u0026#34; ZRANGEBYLEX è¿”å›å­—å…¸é¡ºåºèŒƒå›´å†…å·²sortSetä¸­çš„æˆå‘˜ã€‚\nè¯­æ³•ï¼š\nZRANGEBYLEX key min max [LIMIT offset count] ç¤ºä¾‹ï¼š redis\u0026gt; ZADD myzset 0 a 0 b 0 c 0 d 0 e 0 f 0 g (integer) 7 redis\u0026gt; ZRANGEBYLEX myzset - [c 1) \u0026#34;a\u0026#34; 2) \u0026#34;b\u0026#34; 3) \u0026#34;c\u0026#34; redis\u0026gt; ZRANGEBYLEX myzset - (c 4) \u0026#34;a\u0026#34; 5) \u0026#34;b\u0026#34; redis\u0026gt; ZRANGEBYLEX myzset [aaa (g 6) \u0026#34;b\u0026#34; 7) \u0026#34;c\u0026#34; 8) \u0026#34;d\u0026#34; 9) \u0026#34;e\u0026#34; 10) \u0026#34;f\u0026#34; ZRANGEBYSCORE Returns members in a sorted set within a range of scores. ZRANGESTORE tores a range of members from sorted set in a key. ZRANK Returns the index of a member in a sorted set ordered by ascending scores. ZREM Removes one or more members from a sorted set. Deletes the sorted set if all members were removed. ZREMRANGEBYLEX Removes members in a sorted set within a lexicographical range. Deletes the sorted set if all members were removed. ZREMRANGEBYRANK Removes members in a sorted set within a range of indexes. Deletes the sorted set if all members were removed. ZREMRANGEBYSCORE Removes members in a sorted set within a range of scores. Deletes the sorted set if all members were removed. ZREVRANGE Returns members in a sorted set within a range of indexes in reverse order. ZREVRANGEBYLEX Returns members in a sorted set within a lexicographical range in reverse order. ZREVRANGEBYSCORE Returns members in a sorted set within a range of scores in reverse order. ZREVRANK Returns the index of a member in a sorted set ordered by descending scores. ZSCAN Iterates over members and scores of a sorted set. ZSCORE Returns the score of a member in a sorted set. ZUNION Returns the union of multiple sorted sets. ZUNIONSTORE Stores the union of multiple sorted sets in a key. BZMPOP Removes and returns a member by score from one or more sorted sets. Blocks until a member is available otherwise. Deletes the sorted set if the last element was popped. BZPOPMAX Removes and returns the member with the highest score from one or more sorted sets. Blocks until a member available otherwise. Deletes the sorted set if the last element was popped. BZPOPMIN Removes and returns the member with the lowest score from one or more sorted sets. Blocks until a member is available otherwise. Deletes the sorted set if the last element was popped. ","permalink":"https://heliu.site/posts/redis/sortset/","summary":"redis sortSetä»‹ç»ã€‚","title":"redis sortSet"},{"content":" å®˜ç½‘å‘½ä»¤åœ°å€ï¼šhttps://redis.io/commands/?group=bitmap rediså®¢æˆ·ç«¯æŸ¥è¯¢å‘½ä»¤ï¼šhelp @string bitmap BITCOUNT å¯¹å­—ç¬¦ä¸²ä¸­è®¾ç½®çš„ä½æ•°(æ€»ä½“è®¡æ•°)è¿›è¡Œè®¡æ•°ã€‚ï¼ˆè®¡æ•°1çš„æ•°é‡ï¼‰\nè¯­æ³•ï¼š\nBITCOUNT key [start end [BYTE | BIT]] ç¤ºä¾‹ï¼š redis\u0026gt; SET mykey \u0026#34;foobar\u0026#34; \u0026#34;OK\u0026#34; redis\u0026gt; BITCOUNT mykey (integer) 26 redis\u0026gt; BITCOUNT mykey 0 0 (integer) 4 redis\u0026gt; BITCOUNT mykey 1 1 (integer) 6 redis\u0026gt; BITCOUNT mykey 1 1 BYTE (integer) 6 redis\u0026gt; BITCOUNT mykey 5 30 BIT (integer) 17 BITFIELD å¯¹å­—ç¬¦ä¸²æ‰§è¡Œä»»æ„ä½åŸŸæ•´æ•°æ“ä½œã€‚\nè¯­æ³•ï¼š\nBITFIELD key [GET encoding offset | [OVERFLOW \u0026lt;WRAP | SAT | FAIL\u0026gt;] \u0026lt;SET encoding offset value | INCRBY encoding offset increment\u0026gt; [GET encoding offset | [OVERFLOW \u0026lt;WRAP | SAT | FAIL\u0026gt;] \u0026lt;SET encoding offset value | INCRBY encoding offset increment\u0026gt; ...]] ç”¨æ³•ï¼š \u0026gt; BITFIELD mykey INCRBY i5 100 1 GET u4 0 1) (integer) 1 2) (integer) 0 \u0026gt; BITFIELD mykey incrby u2 100 1 OVERFLOW SAT incrby u2 102 1 3) (integer) 1 4) (integer) 1 \u0026gt; BITFIELD mykey incrby u2 100 1 OVERFLOW SAT incrby u2 102 1 5) (integer) 2 6) (integer) 2 \u0026gt; BITFIELD mykey incrby u2 100 1 OVERFLOW SAT incrby u2 102 1 7) (integer) 3 2) (integer) 3 \u0026gt; BITFIELD mykey incrby u2 100 1 OVERFLOW SAT incrby u2 102 1 3) (integer) 0 4) (integer) 3 BITFIELD_RO å¯¹å­—ç¬¦ä¸²æ‰§è¡Œä»»æ„åªè¯»ä½åŸŸæ•´æ•°æ“ä½œã€‚\nè¯­æ³•ï¼š\nBITFIELD_RO key [GET encoding offset [GET encoding offset ...]] ç¤ºä¾‹ï¼š BITFIELD_RO hello GET i8 16 BITOP å¯¹å¤šä¸ªå­—ç¬¦ä¸²æ‰§è¡ŒæŒ‰ä½æ“ä½œï¼Œå¹¶å­˜å‚¨ç»“æœã€‚\nè¯­æ³•ï¼š\nBITOP \u0026lt;AND | OR | XOR | NOT\u0026gt; destkey key [key ...] ç”¨æ³•ï¼š redis\u0026gt; SET key1 \u0026#34;foobar\u0026#34; \u0026#34;OK\u0026#34; redis\u0026gt; SET key2 \u0026#34;abcdef\u0026#34; \u0026#34;OK\u0026#34; redis\u0026gt; BITOP AND dest key1 key2 (integer) 6 redis\u0026gt; GET dest \u0026#34;`bc`ab\u0026#34; BITPOS æŸ¥æ‰¾å­—ç¬¦ä¸²ä¸­çš„ç¬¬ä¸€ä¸ªset(1)æˆ–clear(0)ä½ã€‚\nè¯­æ³•ï¼š\nBITPOS key bit [start [end [BYTE | BIT]]] ç”¨æ³•ï¼š redis\u0026gt; SET mykey \u0026#34;\\xff\\xf0\\x00\u0026#34; \u0026#34;OK\u0026#34; redis\u0026gt; BITPOS mykey 0 (integer) 0 redis\u0026gt; SET mykey \u0026#34;\\x00\\xff\\xf0\u0026#34; \u0026#34;OK\u0026#34; redis\u0026gt; BITPOS mykey 1 0 (integer) 1 redis\u0026gt; BITPOS mykey 1 2 (integer) 18 redis\u0026gt; BITPOS mykey 1 2 -1 BYTE (integer) 18 redis\u0026gt; BITPOS mykey 1 7 15 BIT (integer) 9 redis\u0026gt; set mykey \u0026#34;\\x00\\x00\\x00\u0026#34; \u0026#34;OK\u0026#34; redis\u0026gt; BITPOS mykey 1 (integer) 1 redis\u0026gt; BITPOS mykey 1 7 -3 BIT (integer) 9 GETBIT æŒ‰åç§»é‡è¿”å›ä½å€¼ã€‚\nè¯­æ³•ï¼š\nGETBIT key offset ç¤ºä¾‹ï¼š redis\u0026gt; SETBIT mykey 7 1 (integer) 0 redis\u0026gt; GETBIT mykey 0 (integer) 0 redis\u0026gt; GETBIT mykey 7 (integer) 1 redis\u0026gt; GETBIT mykey 100 (integer) 0 SETBIT è®¾ç½®æˆ–æ¸…é™¤å­—ç¬¦ä¸²å€¼çš„åç§»ä½ã€‚å¦‚æœkeyä¸å­˜åœ¨ï¼Œåˆ™åˆ›å»ºè¯¥keyã€‚\nè¯­æ³•ï¼š\nSETBIT key offset value ç¤ºä¾‹ï¼š redis\u0026gt; SETBIT mykey 7 1 (integer) 0 redis\u0026gt; SETBIT mykey 7 0 (integer) 1 redis\u0026gt; GET mykey \u0026#34;\u0026#34; ","permalink":"https://heliu.site/posts/redis/bitmap/","summary":"redis bitmapå‘½ä»¤ä»‹ç»ã€‚","title":"redis bitmap"},{"content":"åŸºç¡€ç»“æ„ åŠ¨æ€å­—ç¬¦ä¸²SDS å­—ç¬¦ä¸²æ˜¯redisä¸­æ¯”è¾ƒå¸¸è§çš„æœ‰ä¸€ç§ç»“æ„ï¼Œæ¯”å¦‚stringç±»å‹çš„keyå’Œvalueéƒ½æ˜¯å­—ç¬¦ä¸²ã€‚ Redisæ„å»ºäº†ä¸€ç§æ–°çš„å­—ç¬¦ä¸²ç»“æ„ï¼Œç§°ä¸ºç®€å•åŠ¨æ€å­—ç¬¦ä¸²ï¼ˆSimple Dynamic Stringï¼‰ï¼Œç®€ç§°SDSã€‚ Redisæ˜¯Cè¯­è¨€å®ç°çš„ï¼Œå…¶ä¸­SDSæ˜¯ä¸€ä¸ªç»“æ„ä½“ã€‚ SDSä¹‹æ‰€ä»¥å«åšåŠ¨æ€å­—ç¬¦ä¸²ï¼Œæ˜¯å› ä¸ºå®ƒå…·å¤‡åŠ¨æ€æ‰©å®¹çš„èƒ½åŠ›ã€‚ å¦‚æœæ–°å­—ç¬¦ä¸²å°äº1Mï¼Œåˆ™æ–°ç©ºé—´ä¸ºæ‰©å±•åå­—ç¬¦ä¸²é•¿åº¦çš„ä¸¤å€+1ã€‚ å¦‚æœæ–°å­—ç¬¦ä¸²å¤§äº1Mï¼Œåˆ™æ–°ç©ºé—´ä¸ºæ‰©å±•åå­—ç¬¦ä¸²é•¿åº¦+1M+1ã€‚ç§°ä¸ºå†…å­˜é¢„åˆ†é…ã€‚ redisä¸æ¨èé”®å€¼å¯¹å­˜å‚¨éŸ³é¢‘è§†é¢‘è¿™ç§å¤§å†…å­˜æ•°æ®ã€‚ æ•´æ•°é›†åˆIntset IntSetæ˜¯Redisä¸­seté›†åˆçš„ä¸€ç§å®ç°æ–¹å¼ï¼ŒåŸºäºæ•´æ•°æ•°ç»„æ¥å®ç°ï¼Œå¹¶ä¸”å…·å¤‡é•¿åº¦å¯å˜ã€æœ‰åºç­‰ç‰¹å¾ã€‚ ä¸ºäº†æ–¹ä¾¿æŸ¥æ‰¾ï¼ŒRedisä¼šå°†intsetä¸­æ‰€æœ‰çš„æ•´æ•°æŒ‰ç…§å‡åºä¾æ¬¡ä¿å­˜åœ¨contentsæ•°ç»„ä¸­ã€‚ Intsetå¯ä»¥çœ‹åšæ˜¯ç‰¹æ®Šçš„æ•´æ•°æ•°ç»„ï¼Œå…·å¤‡ä¸€äº›ç‰¹ç‚¹ï¼š Redisä¼šç¡®ä¿Intsetä¸­çš„å…ƒç´ å”¯ä¸€ã€æœ‰åºã€‚ å…·å¤‡ç±»å‹å‡çº§æœºåˆ¶ï¼Œå¯ä»¥èŠ‚çœå†…å­˜ç©ºé—´ã€‚ åº•å±‚é‡‡ç”¨äºŒåˆ†æŸ¥æ‰¾æ–¹å¼æ¥æŸ¥è¯¢ã€‚ å­—å…¸Dict Redisæ˜¯ä¸€ä¸ªé”®å€¼å‹ï¼ˆKey-Value Pairï¼‰çš„æ•°æ®åº“ï¼Œæˆ‘ä»¬å¯ä»¥æ ¹æ®é”®å®ç°å¿«é€Ÿçš„å¢åˆ æ”¹æŸ¥ã€‚è€Œé”®ä¸å€¼çš„æ˜ å°„å…³ç³»æ­£æ˜¯é€šè¿‡Dictæ¥å®ç°çš„ã€‚ Dictç”±ä¸‰éƒ¨åˆ†ç»„æˆï¼Œåˆ†åˆ«æ˜¯ï¼šå“ˆå¸Œè¡¨ï¼ˆDictHashTableï¼‰ã€å“ˆå¸ŒèŠ‚ç‚¹ï¼ˆDictEntryï¼‰ã€å­—å…¸ï¼ˆDictï¼‰ã€‚ å½“æˆ‘ä»¬å‘Dictæ·»åŠ é”®å€¼å¯¹æ—¶ï¼ŒRedisé¦–å…ˆæ ¹æ®keyè®¡ç®—å‡ºhashå€¼ï¼ˆhï¼‰ï¼Œç„¶ååˆ©ç”¨ h \u0026amp; sizemaskæ¥è®¡ç®—å…ƒç´ åº”è¯¥å­˜å‚¨åˆ°æ•°ç»„ä¸­çš„å“ªä¸ªç´¢å¼•ä½ç½®ã€‚ æˆ‘ä»¬å­˜å‚¨k1=v1ï¼Œå‡è®¾k1çš„å“ˆå¸Œå€¼h =1ï¼Œåˆ™1\u0026amp;3 =1ï¼Œå› æ­¤k1=v1è¦å­˜å‚¨åˆ°æ•°ç»„è§’æ ‡1ä½ç½®ã€‚ åŒç«¯é“¾è¡¨ZipList ZipList æ˜¯ä¸€ç§ç‰¹æ®Šçš„â€œåŒç«¯é“¾è¡¨â€ ï¼Œç”±ä¸€ç³»åˆ—ç‰¹æ®Šç¼–ç çš„è¿ç»­å†…å­˜å—ç»„æˆã€‚ å¯ä»¥åœ¨ä»»æ„ä¸€ç«¯è¿›è¡Œå‹å…¥/å¼¹å‡ºæ“ä½œ, å¹¶ä¸”è¯¥æ“ä½œçš„æ—¶é—´å¤æ‚åº¦ä¸º O(1)ã€‚ å±æ€§ ç±»å‹ é•¿åº¦ ç”¨é€” zlbytes uint32_t 4 å­—èŠ‚ è®°å½•æ•´ä¸ªå‹ç¼©åˆ—è¡¨å ç”¨çš„å†…å­˜å­—èŠ‚æ•° zltail uint32_t 4 å­—èŠ‚ è®°å½•å‹ç¼©åˆ—è¡¨è¡¨å°¾èŠ‚ç‚¹è·ç¦»å‹ç¼©åˆ—è¡¨çš„èµ·å§‹åœ°å€æœ‰å¤šå°‘å­—èŠ‚ï¼Œé€šè¿‡è¿™ä¸ªåç§»é‡ï¼Œå¯ä»¥ç¡®å®šè¡¨å°¾èŠ‚ç‚¹çš„åœ°å€ã€‚ zllen uint16_t 2 å­—èŠ‚ è®°å½•äº†å‹ç¼©åˆ—è¡¨åŒ…å«çš„èŠ‚ç‚¹æ•°é‡ã€‚ æœ€å¤§å€¼ä¸ºUINT16_MAX ï¼ˆ65534ï¼‰ï¼Œå¦‚æœè¶…è¿‡è¿™ä¸ªå€¼ï¼Œæ­¤å¤„ä¼šè®°å½•ä¸º65535ï¼Œä½†èŠ‚ç‚¹çš„çœŸå®æ•°é‡éœ€è¦éå†æ•´ä¸ªå‹ç¼©åˆ—è¡¨æ‰èƒ½è®¡ç®—å¾—å‡ºã€‚ entry åˆ—è¡¨èŠ‚ç‚¹ ä¸å®š å‹ç¼©åˆ—è¡¨åŒ…å«çš„å„ä¸ªèŠ‚ç‚¹ï¼ŒèŠ‚ç‚¹çš„é•¿åº¦ç”±èŠ‚ç‚¹ä¿å­˜çš„å†…å®¹å†³å®šã€‚ zlend uint8_t 1 å­—èŠ‚ ç‰¹æ®Šå€¼ 0xFF ï¼ˆåè¿›åˆ¶ 255 ï¼‰ï¼Œç”¨äºæ ‡è®°å‹ç¼©åˆ—è¡¨çš„æœ«ç«¯ã€‚ ZipList ä¸­çš„Entryå¹¶ä¸åƒæ™®é€šé“¾è¡¨é‚£æ ·è®°å½•å‰åèŠ‚ç‚¹çš„æŒ‡é’ˆï¼Œå› ä¸ºè®°å½•ä¸¤ä¸ªæŒ‡é’ˆè¦å ç”¨16ä¸ªå­—èŠ‚ï¼Œæµªè´¹å†…å­˜ã€‚è€Œæ˜¯é‡‡ç”¨äº†ä¸‹é¢çš„ç»“æ„ï¼š previous_entry_lengthï¼šå‰ä¸€èŠ‚ç‚¹çš„é•¿åº¦ï¼Œå 1ä¸ªæˆ–5ä¸ªå­—èŠ‚ã€‚ å¦‚æœå‰ä¸€èŠ‚ç‚¹çš„é•¿åº¦å°äº254å­—èŠ‚ï¼Œåˆ™é‡‡ç”¨1ä¸ªå­—èŠ‚æ¥ä¿å­˜è¿™ä¸ªé•¿åº¦å€¼ã€‚ å¦‚æœå‰ä¸€èŠ‚ç‚¹çš„é•¿åº¦å¤§äº254å­—èŠ‚ï¼Œåˆ™é‡‡ç”¨5ä¸ªå­—èŠ‚æ¥ä¿å­˜è¿™ä¸ªé•¿åº¦å€¼ï¼Œç¬¬ä¸€ä¸ªå­—èŠ‚ä¸º0xfeï¼Œåå››ä¸ªå­—èŠ‚æ‰æ˜¯çœŸå®é•¿ encodingï¼šç¼–ç å±æ€§ï¼Œè®°å½•contentçš„æ•°æ®ç±»å‹ï¼ˆå­—ç¬¦ä¸²è¿˜æ˜¯æ•´æ•°ï¼‰ä»¥åŠé•¿åº¦ï¼Œå ç”¨1ä¸ªã€2ä¸ªæˆ–5ä¸ªå­—èŠ‚ã€‚ contentsï¼šè´Ÿè´£ä¿å­˜èŠ‚ç‚¹çš„æ•°æ®ï¼Œå¯ä»¥æ˜¯å­—ç¬¦ä¸²æˆ–æ•´æ•°ã€‚ ZipListEntryä¸­çš„encodingç¼–ç åˆ†ä¸ºå­—ç¬¦ä¸²å’Œæ•´æ•°ä¸¤ç§ï¼šå­—ç¬¦ä¸²ï¼šå¦‚æœencodingæ˜¯ä»¥â€œ00â€ã€â€œ01â€æˆ–è€…â€œ10â€å¼€å¤´ï¼Œåˆ™è¯æ˜contentæ˜¯å­—ç¬¦ä¸²ã€‚ ç¼–ç  ç¼–ç é•¿åº¦ å­—ç¬¦ä¸²å¤§å° |00pppppp| 1 bytes \u0026lt;= 63 bytes |01pppppp|qqqqqqqq| 2 bytes \u0026lt;= 16383 bytes |10000000|qqqqqqqq|rrrrrrrr|ssssssss|tttttttt| 5 bytes \u0026lt;= 4294967295 bytes æ•´æ•°ï¼šå¦‚æœencodingæ˜¯ä»¥â€œ11â€å¼€å§‹ï¼Œåˆ™è¯æ˜contentæ˜¯æ•´æ•°ï¼Œä¸”encodingå›ºå®šåªå ç”¨1ä¸ªå­—èŠ‚ ç¼–ç  ç¼–ç é•¿åº¦ æ•´æ•°ç±»å‹ 11000000 1 int16_tï¼ˆ2 bytesï¼‰ 11010000 1 int32_tï¼ˆ4 bytesï¼‰ 11100000 1 int64_tï¼ˆ8 bytesï¼‰ 11110000 1 24ä½æœ‰ç¬¦æ•´æ•°(3 bytes) 11111110 1 8ä½æœ‰ç¬¦æ•´æ•°(1 bytes) 1111xxxx 1 ç›´æ¥åœ¨xxxxä½ç½®ä¿å­˜æ•°å€¼ï¼ŒèŒƒå›´ä»0001~1101ï¼Œå‡1åç»“æœä¸ºå®é™…å€¼ åŒç«¯é“¾è¡¨QuickList ZipListè™½ç„¶èŠ‚çœå†…å­˜ï¼Œä½†ç”³è¯·å†…å­˜å¿…é¡»æ˜¯è¿ç»­ç©ºé—´ï¼Œå¦‚æœå†…å­˜å ç”¨è¾ƒå¤šï¼Œç”³è¯·å†…å­˜æ•ˆç‡å¾ˆä½ã€‚ ä¸ºäº†é¿å…QuickListä¸­çš„æ¯ä¸ªZipListä¸­entryè¿‡å¤šï¼ŒRedisæä¾›äº†ä¸€ä¸ªé…ç½®é¡¹ï¼šlist-max-ziplist-sizeæ¥é™åˆ¶ã€‚å¦‚æœå€¼ä¸ºæ­£ï¼Œåˆ™ä»£è¡¨ZipListçš„å…è®¸çš„entryä¸ªæ•°çš„æœ€å¤§å€¼ã€‚å¦‚æœå€¼ä¸ºè´Ÿï¼Œåˆ™ä»£è¡¨ZipListçš„æœ€å¤§å†…å­˜å¤§å°ï¼Œåˆ†5ç§æƒ…å†µï¼š -1ï¼šæ¯ä¸ªZipListçš„å†…å­˜å ç”¨ä¸èƒ½è¶…è¿‡4kb -2ï¼šæ¯ä¸ªZipListçš„å†…å­˜å ç”¨ä¸èƒ½è¶…è¿‡8kb -3ï¼šæ¯ä¸ªZipListçš„å†…å­˜å ç”¨ä¸èƒ½è¶…è¿‡16kb -4ï¼šæ¯ä¸ªZipListçš„å†…å­˜å ç”¨ä¸èƒ½è¶…è¿‡32kb -5ï¼šæ¯ä¸ªZipListçš„å†…å­˜å ç”¨ä¸èƒ½è¶…è¿‡64kb è·³è¡¨SkipList SkipListï¼ˆè·³è¡¨ï¼‰é¦–å…ˆæ˜¯é“¾è¡¨ï¼Œä½†ä¸ä¼ ç»Ÿé“¾è¡¨ç›¸æ¯”æœ‰å‡ ç‚¹å·®å¼‚ï¼šå…ƒç´ æŒ‰ç…§å‡åºæ’åˆ—å­˜å‚¨ã€èŠ‚ç‚¹å¯èƒ½åŒ…å«å¤šä¸ªæŒ‡é’ˆï¼ŒæŒ‡é’ˆè·¨åº¦ä¸åŒã€‚ SkipListçš„ç‰¹ç‚¹ï¼š è·³è·ƒè¡¨æ˜¯ä¸€ä¸ªåŒå‘é“¾è¡¨ï¼Œæ¯ä¸ªèŠ‚ç‚¹éƒ½åŒ…å«scoreå’Œeleå€¼ èŠ‚ç‚¹æŒ‰ç…§scoreå€¼æ’åºï¼Œscoreå€¼ä¸€æ ·åˆ™æŒ‰ç…§eleå­—å…¸æ’åº æ¯ä¸ªèŠ‚ç‚¹éƒ½å¯ä»¥åŒ…å«å¤šå±‚æŒ‡é’ˆï¼Œå±‚æ•°æ˜¯1åˆ°32ä¹‹é—´çš„éšæœºæ•° ä¸åŒå±‚æŒ‡é’ˆåˆ°ä¸‹ä¸€ä¸ªèŠ‚ç‚¹çš„è·¨åº¦ä¸åŒï¼Œå±‚çº§è¶Šé«˜ï¼Œè·¨åº¦è¶Šå¤§ å¢åˆ æ”¹æŸ¥æ•ˆç‡ä¸çº¢é»‘æ ‘åŸºæœ¬ä¸€è‡´ï¼Œå®ç°å´æ›´ç®€å• RedisObject Redisä¸­çš„ä»»æ„æ•°æ®ç±»å‹çš„é”®å’Œå€¼éƒ½ä¼šè¢«å°è£…ä¸ºä¸€ä¸ªRedisObjectï¼Œä¹Ÿå«åšRediså¯¹è±¡ã€‚ Redisä¸­ä¼šæ ¹æ®å­˜å‚¨çš„æ•°æ®ç±»å‹ä¸åŒï¼Œé€‰æ‹©ä¸åŒçš„ç¼–ç æ–¹å¼ï¼Œå…±åŒ…å«11ç§ä¸åŒç±»å‹ã€‚ ç¼–å· ç¼–ç æ–¹å¼ è¯´æ˜ 0 OBJ_ENCODING_RAW rawç¼–ç åŠ¨æ€å­—ç¬¦ä¸² 1 OBJ_ENCODING_INT longç±»å‹çš„æ•´æ•°çš„å­—ç¬¦ä¸² 2 OBJ_ENCODING_HT hashè¡¨ï¼ˆå­—å…¸dictï¼‰ 3 OBJ_ENCODING_ZIPMAP å·²åºŸå¼ƒ 4 OBJ_ENCODING_LINKEDLIST åŒç«¯é“¾è¡¨ 5 OBJ_ENCODING_ZIPLIST å‹ç¼©åˆ—è¡¨ 6 OBJ_ENCODING_INTSET æ•´æ•°é›†åˆ 7 OBJ_ENCODING_SKIPLIST è·³è¡¨ 8 OBJ_ENCODING_EMBSTR embstrçš„åŠ¨æ€å­—ç¬¦ä¸² 9 OBJ_ENCODING_QUICKLIST å¿«é€Ÿåˆ—è¡¨ 10 OBJ_ENCODING_STREAM Streamæµ Redisä¸­ä¼šæ ¹æ®å­˜å‚¨çš„æ•°æ®ç±»å‹ä¸åŒï¼Œé€‰æ‹©ä¸åŒçš„ç¼–ç æ–¹å¼ã€‚ æ•°æ®ç±»å‹ ç¼–ç æ–¹å¼ OBJ_STRING intã€embstrã€raw OBJ_LIST LinkedListå’ŒZipList(3.2ä»¥å‰)ã€QuickListï¼ˆ3.2ä»¥åï¼‰ OBJ_SET intsetã€HT OBJ_ZSET ZipListã€HTã€SkipList OBJ_HASH ZipListã€HT String Stringæ˜¯Redisä¸­æœ€å¸¸è§çš„æ•°æ®å­˜å‚¨ç±»å‹ï¼šå…¶åŸºæœ¬ç¼–ç æ–¹å¼æ˜¯RAWï¼ŒåŸºäºç®€å•åŠ¨æ€å­—ç¬¦ä¸²ï¼ˆSDSï¼‰å®ç°ï¼Œå­˜å‚¨ä¸Šé™ä¸º512mbã€‚ å¦‚æœå­˜å‚¨çš„SDSé•¿åº¦å°äº44å­—èŠ‚ï¼Œåˆ™ä¼šé‡‡ç”¨EMBSTRç¼–ç ï¼Œæ­¤æ—¶object headä¸SDSæ˜¯ä¸€æ®µè¿ç»­ç©ºé—´ã€‚ç”³è¯·å†…å­˜æ—¶åªéœ€è¦è°ƒç”¨ä¸€æ¬¡å†…å­˜åˆ†é…å‡½æ•°ï¼Œæ•ˆç‡æ›´é«˜ã€‚ å¦‚æœå­˜å‚¨çš„å­—ç¬¦ä¸²æ˜¯æ•´æ•°å€¼ï¼Œå¹¶ä¸”å¤§å°åœ¨LONG_MAXèŒƒå›´å†…ï¼Œåˆ™ä¼šé‡‡ç”¨INTç¼–ç ï¼šç›´æ¥å°†æ•°æ®ä¿å­˜åœ¨RedisObjectçš„ptræŒ‡é’ˆä½ç½®ï¼ˆåˆšå¥½8å­—èŠ‚ï¼‰ï¼Œä¸å†éœ€è¦SDSäº†ã€‚ Set Setæ˜¯Redisä¸­çš„å•åˆ—é›†åˆï¼Œæ»¡è¶³ä¸‹åˆ—ç‰¹ç‚¹ï¼šä¸ä¿è¯æœ‰åºæ€§ã€ä¿è¯å…ƒç´ å”¯ä¸€ã€æ±‚äº¤é›†ï¼Œå¹¶é›†ï¼Œå·®é›†ã€‚ List Redisçš„Listç»“æ„ç±»ä¼¼ä¸€ä¸ªåŒç«¯é“¾è¡¨ï¼Œå¯ä»¥ä»é¦–ã€å°¾æ“ä½œåˆ—è¡¨ä¸­çš„å…ƒç´ ã€‚ Hash åº•å±‚å®ç°æ–¹å¼ï¼šå‹ç¼©åˆ—è¡¨ziplist æˆ–è€… å­—å…¸dictã€‚ å½“Hashä¸­æ•°æ®é¡¹æ¯”è¾ƒå°‘çš„æƒ…å†µä¸‹ï¼ŒHashåº•å±‚æ‰â½¤å‹ç¼©åˆ—è¡¨ziplistè¿›â¾å­˜å‚¨æ•°æ®ï¼Œå½“æ•°æ®é‡è¾ƒå¤§æ—¶ï¼ŒHashç»“æ„ä¼šè½¬ä¸ºHTç¼–ç ï¼Œä¹Ÿå°±æ˜¯Dictï¼Œè§¦å‘æ¡ä»¶æœ‰ä¸¤ä¸ªï¼š ZipListä¸­çš„å…ƒç´ æ•°é‡è¶…è¿‡äº†hash-max-ziplist-entriesï¼ˆé»˜è®¤512ï¼‰ ZipListä¸­çš„ä»»æ„entryå¤§å°è¶…è¿‡äº†hash-max-ziplist-valueï¼ˆé»˜è®¤64å­—èŠ‚ï¼‰ Redisçš„hashä¹‹æ‰€ä»¥è¿™æ ·è®¾è®¡ï¼Œæ˜¯å› ä¸ºå½“ziplistå˜å¾—å¾ˆâ¼¤çš„æ—¶å€™ï¼Œå®ƒæœ‰å¦‚ä¸‹å‡ ä¸ªç¼ºç‚¹ï¼š æ¯æ¬¡æ’â¼Šæˆ–ä¿®æ”¹å¼•å‘çš„reallocæ“ä½œä¼šæœ‰æ›´â¼¤çš„æ¦‚ç‡é€ æˆå†…å­˜æ‹·è´ï¼Œä»è€Œé™ä½æ€§èƒ½ã€‚ â¼€æ—¦å‘ç”Ÿå†…å­˜æ‹·è´ï¼Œå†…å­˜æ‹·è´çš„æˆæœ¬ä¹Ÿç›¸åº”å¢åŠ ï¼Œå› ä¸ºè¦æ‹·è´æ›´â¼¤çš„â¼€å—æ•°æ®ã€‚ å½“ziplistæ•°æ®é¡¹è¿‡å¤šçš„æ—¶å€™ï¼Œåœ¨å®ƒä¸Šâ¾¯æŸ¥æ‰¾æŒ‡å®šçš„æ•°æ®é¡¹å°±ä¼šæ€§èƒ½å˜å¾—å¾ˆä½ï¼Œå› ä¸ºziplistä¸Šçš„æŸ¥æ‰¾éœ€è¦è¿›è¡Œéå†ã€‚ æ€»ä¹‹ï¼Œziplistæœ¬æ¥å°±è®¾è®¡ä¸ºå„ä¸ªæ•°æ®é¡¹æŒ¨åœ¨â¼€èµ·ç»„æˆè¿ç»­çš„å†…å­˜ç©ºé—´ï¼Œè¿™ç§ç»“æ„å¹¶ä¸æ“…é•¿åšä¿®æ”¹æ“ä½œã€‚â¼€æ—¦æ•°æ®å‘â½£æ”¹åŠ¨ï¼Œå°±ä¼šå¼•å‘å†…å­˜reallocï¼Œå¯èƒ½å¯¼è‡´å†…å­˜æ‹·è´ã€‚ ZSet ZSetä¹Ÿå°±æ˜¯SortedSetï¼Œå…¶ä¸­æ¯ä¸€ä¸ªå…ƒç´ éƒ½éœ€è¦æŒ‡å®šä¸€ä¸ªscoreå€¼å’Œmemberå€¼ï¼š å¯ä»¥æ ¹æ®scoreå€¼æ’åºå memberå¿…é¡»å”¯ä¸€ å¯ä»¥æ ¹æ®memberæŸ¥è¯¢åˆ†æ•° å› æ­¤ï¼Œzsetåº•å±‚æ•°æ®ç»“æ„å¿…é¡»æ»¡è¶³é”®å€¼å­˜å‚¨ã€é”®å¿…é¡»å”¯ä¸€ã€å¯æ’åºè¿™å‡ ä¸ªéœ€æ±‚ã€‚ä¹‹å‰å­¦ä¹ çš„å“ªç§ç¼–ç ç»“æ„å¯ä»¥æ»¡è¶³ï¼Ÿ SkipListï¼šå¯ä»¥æ’åºï¼Œå¹¶ä¸”å¯ä»¥åŒæ—¶å­˜å‚¨scoreå’Œeleå€¼ï¼ˆmemberï¼‰ HTï¼ˆDictï¼‰ï¼šå¯ä»¥é”®å€¼å­˜å‚¨ï¼Œå¹¶ä¸”å¯ä»¥æ ¹æ®keyæ‰¾value å½“å…ƒç´ æ•°é‡ä¸å¤šæ—¶ï¼ŒHTå’ŒSkipListçš„ä¼˜åŠ¿ä¸æ˜æ˜¾ï¼Œè€Œä¸”æ›´è€—å†…å­˜ã€‚å› æ­¤zsetè¿˜ä¼šé‡‡ç”¨ZipListç»“æ„æ¥èŠ‚çœå†…å­˜ï¼Œä¸è¿‡éœ€è¦åŒæ—¶æ»¡è¶³ä¸¤ä¸ªæ¡ä»¶ï¼š å…ƒç´ æ•°é‡å°äºzset_max_ziplist_entriesï¼Œé»˜è®¤å€¼128 æ¯ä¸ªå…ƒç´ éƒ½å°äºzset_max_ziplist_valueå­—èŠ‚ï¼Œé»˜è®¤å€¼64 ziplistæœ¬èº«æ²¡æœ‰æ’åºåŠŸèƒ½ï¼Œè€Œä¸”æ²¡æœ‰é”®å€¼å¯¹çš„æ¦‚å¿µï¼Œå› æ­¤éœ€è¦æœ‰zseté€šè¿‡ç¼–ç å®ç°ï¼š ZipListæ˜¯è¿ç»­å†…å­˜ï¼Œå› æ­¤scoreå’Œelementæ˜¯ç´§æŒ¨åœ¨ä¸€èµ·çš„ä¸¤ä¸ªentryï¼Œ elementåœ¨å‰ï¼Œscoreåœ¨å scoreè¶Šå°è¶Šæ¥è¿‘é˜Ÿé¦–ï¼Œscoreè¶Šå¤§è¶Šæ¥è¿‘é˜Ÿå°¾ï¼ŒæŒ‰ç…§scoreå€¼å‡åºæ’åˆ— ","permalink":"https://heliu.site/posts/redis/struct/","summary":"redis æ•°æ®ç»“æ„ä»‹ç»ã€‚","title":"redis æ•°æ®ç»“æ„"},{"content":"ç¼“å­˜ç©¿é€ ç¼“å­˜ç©¿é€ï¼šç¼“å­˜ç©¿é€æ˜¯æŒ‡å®¢æˆ·ç«¯è¯·æ±‚çš„æ•°æ®åœ¨ç¼“å­˜ä¸­å’Œæ•°æ®åº“ä¸­éƒ½ä¸å­˜åœ¨ï¼Œè¿™æ ·ç¼“å­˜æ°¸è¿œä¸ä¼šç”Ÿæ•ˆï¼Œè¿™äº›è¯·æ±‚éƒ½ä¼šæ‰“åˆ°æ•°æ®åº“ã€‚ å¸¸è§çš„è§£å†³æ–¹æ¡ˆæœ‰ä¸¤ç§ï¼š ç¼“å­˜ç©ºå¯¹è±¡ ä¼˜ç‚¹ï¼šå®ç°ç®€å•ï¼Œç»´æŠ¤æ–¹ä¾¿ã€‚ ç¼ºç‚¹ï¼šé¢å¤–çš„å†…å­˜æ¶ˆè€—ã€å¯èƒ½é€ æˆçŸ­æœŸçš„ä¸ä¸€è‡´ã€‚ å¸ƒéš†è¿‡æ»¤ ä¼˜ç‚¹ï¼šå†…å­˜å ç”¨è¾ƒå°‘ï¼Œæ²¡æœ‰å¤šä½™keyã€‚ å®ç°å¤æ‚ã€å­˜åœ¨è¯¯åˆ¤å¯èƒ½ã€ä¸èƒ½æ›´æ”¹å¦åˆ™å…¨éƒ¨é‡æ–°ç¼“å­˜ã€‚ ç¼“å­˜ç©ºå¯¹è±¡ï¼š å½“æˆ‘ä»¬å®¢æˆ·ç«¯è®¿é—®ä¸å­˜åœ¨çš„æ•°æ®æ—¶ï¼Œå…ˆè¯·æ±‚redisï¼Œä½†æ˜¯æ­¤æ—¶redisä¸­æ²¡æœ‰æ•°æ®ï¼Œæ­¤æ—¶ä¼šè®¿é—®åˆ°æ•°æ®åº“ï¼Œä½†æ˜¯æ•°æ®åº“ä¸­ä¹Ÿæ²¡æœ‰æ•°æ®ï¼Œè¿™ä¸ªæ•°æ®ç©¿é€äº†ç¼“å­˜ ç›´å‡»æ•°æ®åº“ï¼Œæˆ‘ä»¬éƒ½çŸ¥é“æ•°æ®åº“èƒ½å¤Ÿæ‰¿è½½çš„å¹¶å‘ä¸å¦‚redisè¿™ä¹ˆé«˜ï¼Œå¦‚æœå¤§é‡çš„è¯·æ±‚åŒæ—¶è¿‡æ¥è®¿é—®è¿™ç§ä¸å­˜åœ¨çš„æ•°æ®ï¼Œè¿™äº›è¯·æ±‚å°±éƒ½ä¼šè®¿é—®åˆ°æ•°æ®åº“ ç®€å•çš„è§£å†³æ–¹æ¡ˆå°±æ˜¯å“ªæ€•è¿™ä¸ªæ•°æ®åœ¨æ•°æ®åº“ä¸­ä¹Ÿä¸å­˜åœ¨ï¼Œæˆ‘ä»¬ä¹ŸæŠŠè¿™ä¸ªæ•°æ®å­˜å…¥åˆ°redisä¸­å»ï¼Œè¿™æ ·ï¼Œä¸‹æ¬¡ç”¨æˆ·è¿‡æ¥è®¿é—®è¿™ä¸ªä¸å­˜åœ¨çš„æ•°æ®ï¼Œé‚£ä¹ˆåœ¨redisä¸­ä¹Ÿèƒ½æ‰¾åˆ°è¿™ä¸ªæ•°æ®å°±ä¸ä¼šè¿›å…¥åˆ°ç¼“å­˜äº† å¸ƒéš†è¿‡æ»¤ï¼š å¸ƒéš†è¿‡æ»¤å™¨å…¶å®é‡‡ç”¨çš„æ˜¯å“ˆå¸Œæ€æƒ³æ¥è§£å†³è¿™ä¸ªé—®é¢˜ï¼Œé€šè¿‡ä¸€ä¸ªåºå¤§çš„äºŒè¿›åˆ¶æ•°ç»„ï¼Œèµ°å“ˆå¸Œæ€æƒ³å»åˆ¤æ–­å½“å‰è¿™ä¸ªè¦æŸ¥è¯¢çš„è¿™ä¸ªæ•°æ®æ˜¯å¦å­˜åœ¨ï¼Œå¦‚æœå¸ƒéš†è¿‡æ»¤å™¨åˆ¤æ–­å­˜åœ¨ï¼Œåˆ™æ”¾è¡Œ è¿™ä¸ªè¯·æ±‚ä¼šå»è®¿é—®redisï¼Œå“ªæ€•æ­¤æ—¶redisä¸­çš„æ•°æ®è¿‡æœŸäº†ï¼Œä½†æ˜¯æ•°æ®åº“ä¸­ä¸€å®šå­˜åœ¨è¿™ä¸ªæ•°æ®ï¼Œåœ¨æ•°æ®åº“ä¸­æŸ¥è¯¢å‡ºæ¥è¿™ä¸ªæ•°æ®åï¼Œå†å°†å…¶æ”¾å…¥åˆ°redisä¸­ï¼Œå‡è®¾å¸ƒéš†è¿‡æ»¤å™¨åˆ¤æ–­è¿™ä¸ªæ•°æ®ä¸å­˜åœ¨ï¼Œåˆ™ç›´æ¥è¿”å› è¿™ç§æ–¹å¼ä¼˜ç‚¹åœ¨äºèŠ‚çº¦å†…å­˜ç©ºé—´ï¼Œå­˜åœ¨è¯¯åˆ¤ï¼Œè¯¯åˆ¤åŸå› åœ¨äºï¼šå¸ƒéš†è¿‡æ»¤å™¨èµ°çš„æ˜¯å“ˆå¸Œæ€æƒ³ï¼Œåªè¦å“ˆå¸Œæ€æƒ³ï¼Œå°±å¯èƒ½å­˜åœ¨å“ˆå¸Œå†²çª ç¼“å­˜é›ªå´© ç¼“å­˜é›ªå´©ï¼šæ˜¯æŒ‡åœ¨åŒä¸€æ—¶æ®µå¤§é‡çš„ç¼“å­˜keyåŒæ—¶å¤±æ•ˆæˆ–è€…RedisæœåŠ¡å®•æœºï¼Œå¯¼è‡´å¤§é‡è¯·æ±‚åˆ°è¾¾æ•°æ®åº“ï¼Œå¸¦æ¥å·¨å¤§å‹åŠ›ã€‚ è§£å†³æ–¹æ¡ˆï¼šç»™ä¸åŒçš„Keyçš„TTLæ·»åŠ éšæœºå€¼ã€åˆ©ç”¨Redisé›†ç¾¤æé«˜æœåŠ¡çš„å¯ç”¨æ€§ã€ç»™ç¼“å­˜ä¸šåŠ¡æ·»åŠ é™çº§é™æµç­–ç•¥ã€ç»™ä¸šåŠ¡æ·»åŠ å¤šçº§ç¼“å­˜ã€‚ ç¼“å­˜å‡»ç©¿ ç¼“å­˜å‡»ç©¿ï¼šé—®é¢˜ä¹Ÿå«çƒ­ç‚¹Keyé—®é¢˜ï¼Œå°±æ˜¯ä¸€ä¸ªè¢«é«˜å¹¶å‘è®¿é—®å¹¶ä¸”ç¼“å­˜é‡å»ºä¸šåŠ¡è¾ƒå¤æ‚çš„keyçªç„¶å¤±æ•ˆäº†ï¼Œæ— æ•°çš„è¯·æ±‚è®¿é—®ä¼šåœ¨ç¬é—´ç»™æ•°æ®åº“å¸¦æ¥å·¨å¤§çš„å†²å‡»ã€‚ å¸¸è§çš„è§£å†³æ–¹æ¡ˆæœ‰ä¸¤ç§ï¼šäº’æ–¥é”ã€é€»è¾‘è¿‡æœŸã€‚ é€»è¾‘åˆ†æï¼šå‡è®¾çº¿ç¨‹1åœ¨æŸ¥è¯¢ç¼“å­˜ä¹‹åï¼Œæœ¬æ¥åº”è¯¥å»æŸ¥è¯¢æ•°æ®åº“ï¼Œç„¶åæŠŠè¿™ä¸ªæ•°æ®é‡æ–°åŠ è½½åˆ°ç¼“å­˜çš„ï¼Œæ­¤æ—¶åªè¦çº¿ç¨‹1èµ°å®Œè¿™ä¸ªé€»è¾‘ï¼Œå…¶ä»–çº¿ç¨‹å°±éƒ½èƒ½ä»ç¼“å­˜ä¸­åŠ è½½è¿™äº›æ•°æ®äº†ï¼Œä½†æ˜¯å‡è®¾åœ¨çº¿ç¨‹1æ²¡æœ‰èµ°å®Œçš„æ—¶å€™ï¼Œåç»­çš„çº¿ç¨‹2ï¼Œçº¿ç¨‹3ï¼Œçº¿ç¨‹4åŒæ—¶è¿‡æ¥è®¿é—®å½“å‰è¿™ä¸ªæ–¹æ³•ï¼Œ é‚£ä¹ˆè¿™äº›çº¿ç¨‹éƒ½ä¸èƒ½ä»ç¼“å­˜ä¸­æŸ¥è¯¢åˆ°æ•°æ®ï¼Œé‚£ä¹ˆä»–ä»¬å°±ä¼šåŒä¸€æ—¶åˆ»æ¥è®¿é—®æŸ¥è¯¢ç¼“å­˜ï¼Œéƒ½æ²¡æŸ¥åˆ°ï¼Œæ¥ç€åŒä¸€æ—¶é—´å»è®¿é—®æ•°æ®åº“ï¼ŒåŒæ—¶çš„å»æ‰§è¡Œæ•°æ®åº“ä»£ç ï¼Œå¯¹æ•°æ®åº“è®¿é—®å‹åŠ›è¿‡å¤§ã€‚ é‡‡ç”¨äº’æ–¥é”æ–¹æ¡ˆï¼š é€»è¾‘è¿‡æœŸï¼šæˆ‘ä»¬ä¹‹æ‰€ä»¥ä¼šå‡ºç°è¿™ä¸ªç¼“å­˜å‡»ç©¿é—®é¢˜ï¼Œä¸»è¦åŸå› æ˜¯åœ¨äºæˆ‘ä»¬å¯¹keyè®¾ç½®äº†è¿‡æœŸæ—¶é—´ï¼Œå‡è®¾æˆ‘ä»¬ä¸è®¾ç½®è¿‡æœŸæ—¶é—´ï¼Œå…¶å®å°±ä¸ä¼šæœ‰ç¼“å­˜å‡»ç©¿çš„é—®é¢˜ï¼Œä½†æ˜¯ä¸è®¾ç½®è¿‡æœŸæ—¶é—´ï¼Œè¿™æ ·æ•°æ®ä¸å°±ä¸€ç›´å ç”¨æˆ‘ä»¬å†…å­˜äº†å—ï¼Œæˆ‘ä»¬å¯ä»¥é‡‡ç”¨é€»è¾‘è¿‡æœŸæ–¹æ¡ˆã€‚ æˆ‘ä»¬æŠŠè¿‡æœŸæ—¶é—´è®¾ç½®åœ¨ redisçš„valueä¸­ï¼Œæ³¨æ„ï¼šè¿™ä¸ªè¿‡æœŸæ—¶é—´å¹¶ä¸ä¼šç›´æ¥ä½œç”¨äºredisï¼Œè€Œæ˜¯æˆ‘ä»¬åç»­é€šè¿‡é€»è¾‘å»å¤„ç†ã€‚å‡è®¾çº¿ç¨‹1å»æŸ¥è¯¢ç¼“å­˜ï¼Œç„¶åä»valueä¸­åˆ¤æ–­å‡ºæ¥å½“å‰çš„æ•°æ®å·²ç»è¿‡æœŸäº†ï¼Œæ­¤æ—¶çº¿ç¨‹1å»è·å¾—äº’æ–¥é”ï¼Œé‚£ä¹ˆå…¶ä»–çº¿ç¨‹ä¼šè¿›è¡Œé˜»å¡ï¼Œè·å¾—äº†é”çš„çº¿ç¨‹ä»–ä¼šå¼€å¯ä¸€ä¸ª çº¿ç¨‹å»è¿›è¡Œ ä»¥å‰çš„é‡æ„æ•°æ®çš„é€»è¾‘ï¼Œç›´åˆ°æ–°å¼€çš„çº¿ç¨‹å®Œæˆè¿™ä¸ªé€»è¾‘åï¼Œæ‰é‡Šæ”¾é”ï¼Œ è€Œçº¿ç¨‹1ç›´æ¥è¿›è¡Œè¿”å›ï¼Œå‡è®¾ç°åœ¨çº¿ç¨‹3è¿‡æ¥è®¿é—®ï¼Œç”±äºçº¿ç¨‹çº¿ç¨‹2æŒæœ‰ç€é”ï¼Œæ‰€ä»¥çº¿ç¨‹3æ— æ³•è·å¾—é”ï¼Œçº¿ç¨‹3ä¹Ÿç›´æ¥è¿”å›æ•°æ®ï¼Œåªæœ‰ç­‰åˆ°æ–°å¼€çš„çº¿ç¨‹2æŠŠé‡å»ºæ•°æ®æ„å»ºå®Œåï¼Œå…¶ä»–çº¿ç¨‹æ‰èƒ½èµ°è¿”å›æ­£ç¡®çš„æ•°æ®ã€‚ è¿™ç§æ–¹æ¡ˆå·§å¦™åœ¨äºï¼Œå¼‚æ­¥çš„æ„å»ºç¼“å­˜ï¼Œç¼ºç‚¹åœ¨äºåœ¨æ„å»ºå®Œç¼“å­˜ä¹‹å‰ï¼Œè¿”å›çš„éƒ½æ˜¯è„æ•°æ®ã€‚ **äº’æ–¥é”æ–¹æ¡ˆï¼š**ç”±äºä¿è¯äº†äº’æ–¥æ€§ï¼Œæ‰€ä»¥æ•°æ®ä¸€è‡´ï¼Œä¸”å®ç°ç®€å•ï¼Œå› ä¸ºä»…ä»…åªéœ€è¦åŠ ä¸€æŠŠé”è€Œå·²ï¼Œä¹Ÿæ²¡å…¶ä»–çš„äº‹æƒ…éœ€è¦æ“å¿ƒï¼Œæ‰€ä»¥æ²¡æœ‰é¢å¤–çš„å†…å­˜æ¶ˆè€—ï¼Œç¼ºç‚¹åœ¨äºæœ‰é”å°±æœ‰æ­»é”é—®é¢˜çš„å‘ç”Ÿï¼Œä¸”åªèƒ½ä¸²è¡Œæ‰§è¡Œæ€§èƒ½è‚¯å®šå—åˆ°å½±å“ é€»è¾‘è¿‡æœŸæ–¹æ¡ˆï¼š çº¿ç¨‹è¯»å–è¿‡ç¨‹ä¸­ä¸éœ€è¦ç­‰å¾…ï¼Œæ€§èƒ½å¥½ï¼Œæœ‰ä¸€ä¸ªé¢å¤–çš„çº¿ç¨‹æŒæœ‰é”å»è¿›è¡Œé‡æ„æ•°æ®ï¼Œä½†æ˜¯åœ¨é‡æ„æ•°æ®å®Œæˆå‰ï¼Œå…¶ä»–çš„çº¿ç¨‹åªèƒ½è¿”å›ä¹‹å‰çš„æ•°æ®ï¼Œä¸”å®ç°èµ·æ¥éº»çƒ¦ ","permalink":"https://heliu.site/posts/redis/use/","summary":"redis ä½¿ç”¨åœºæ™¯ã€‚","title":"redis åœºæ™¯"},{"content":" SQLè¯­å¥å¯ä»¥å•è¡Œæˆ–å¤šè¡Œä¹¦å†™ï¼Œä»¥åˆ†å·ç»“å°¾ã€‚ SQLè¯­å¥å¯ä»¥ä½¿ç”¨ç©ºæ ¼/ç¼©è¿›æ¥å¢å¼ºè¯­å¥çš„å¯è¯»æ€§ã€‚ MySQLæ•°æ®åº“çš„SQLè¯­å¥ä¸åŒºåˆ†å¤§å°å†™ï¼Œå…³é”®å­—å»ºè®®ä½¿ç”¨å¤§å†™ã€‚ æ³¨é‡Šï¼š å•è¡Œæ³¨é‡Šï¼š\u0026ndash; æ³¨é‡Šå†…å®¹ æˆ– # æ³¨é‡Šå†…å®¹ å¤šè¡Œæ³¨é‡Šï¼š/* æ³¨é‡Šå†…å®¹ */ SQLåˆ†ç±» SQLè¯­å¥ï¼Œæ ¹æ®å…¶åŠŸèƒ½ï¼Œä¸»è¦åˆ†ä¸ºå››ç±»ï¼šDDLã€DMLã€DQLã€DCLã€‚ DDLï¼ˆData Definition Languageï¼‰ï¼šæ•°æ®å®šä¹‰è¯­è¨€ï¼Œç”¨æ¥å®šä¹‰æ•°æ®åº“å¯¹è±¡(æ•°æ®åº“ï¼Œè¡¨ï¼Œå­—æ®µ)ã€‚ DMLï¼ˆData Manipulation Languageï¼‰ï¼šæ•°æ®æ“ä½œè¯­è¨€ï¼Œç”¨æ¥å¯¹æ•°æ®åº“è¡¨ä¸­çš„æ•°æ®è¿›è¡Œå¢åˆ ã€‚ DQLï¼ˆData Query Languageï¼‰ï¼šæ•°æ®æŸ¥è¯¢è¯­è¨€ï¼Œç”¨æ¥æŸ¥è¯¢æ•°æ®åº“ä¸­è¡¨çš„è®°å½•ã€‚ DCLï¼ˆData Control Languageï¼‰ï¼šæ•°æ®æ§åˆ¶è¯­è¨€ï¼Œç”¨æ¥åˆ›å»ºæ•°æ®åº“ç”¨æˆ·ã€æ§åˆ¶æ•°æ®åº“çš„è®¿é—®æƒé™ã€‚ DDL æ•°æ®å®šä¹‰è¯­è¨€ï¼Œç”¨æ¥å®šä¹‰æ•°æ®åº“å¯¹è±¡(æ•°æ®åº“ï¼Œè¡¨ï¼Œå­—æ®µ)ã€‚ æ•°æ®åº“æ“ä½œ æŸ¥è¯¢æ‰€æœ‰æ•°æ®åº“ã€‚ show databases; æŸ¥è¯¢å½“å‰æ•°æ®åº“ã€‚ select database(); åˆ›å»ºæ•°æ®åº“ã€‚ create database [ if not exists ] æ•°æ®åº“å [ default charset å­—ç¬¦é›† ] [ collate æ’åºè§„åˆ™ ]; åˆ é™¤æ•°æ®åº“ã€‚ drop database [ if exists ] æ•°æ®åº“å; åˆ‡æ¢æ•°æ®åº“ã€‚ use æ•°æ®åº“å; è¡¨æ“ä½œ æŸ¥è¯¢å½“å‰æ•°æ®åº“æ‰€æœ‰è¡¨ã€‚ show tables; æŸ¥çœ‹æŒ‡å®šè¡¨ç»“æ„ã€‚ desc è¡¨å; æŸ¥è¯¢æŒ‡å®šè¡¨çš„å»ºè¡¨è¯­å¥ã€‚ show create table è¡¨å; åˆ›å»ºè¡¨ç»“æ„ã€‚ CREATE TABLE è¡¨å( å­—æ®µ1 å­—æ®µ1ç±»å‹ [COMMENT å­—æ®µ1æ³¨é‡Š ], å­—æ®µ2 å­—æ®µ2ç±»å‹ [COMMENT å­—æ®µ2æ³¨é‡Š ], å­—æ®µ3 å­—æ®µ3ç±»å‹ [COMMENT å­—æ®µ3æ³¨é‡Š ], ...... å­—æ®µn å­—æ®µnç±»å‹ [COMMENT å­—æ®µnæ³¨é‡Š ] ) [ COMMENT è¡¨æ³¨é‡Š ]; -- æ³¨æ„: [...] å†…ä¸ºå¯é€‰å‚æ•°ï¼Œæœ€åä¸€ä¸ªå­—æ®µåé¢æ²¡æœ‰é€—å· create table emp( id int comment \u0026#39;ç¼–å·\u0026#39;, workno varchar(10) comment \u0026#39;å·¥å·\u0026#39;, name varchar(10) comment \u0026#39;å§“å\u0026#39;, gender char(1) comment \u0026#39;æ€§åˆ«\u0026#39;, age tinyint unsigned comment \u0026#39;å¹´é¾„\u0026#39;, idcard char(18) comment \u0026#39;èº«ä»½è¯å·\u0026#39;, entrydate date comment \u0026#39;å…¥èŒæ—¶é—´\u0026#39; ) comment \u0026#39;å‘˜å·¥è¡¨\u0026#39;; æ·»åŠ å­—æ®µã€‚ ALTER TABLE è¡¨å ADD å­—æ®µå ç±»å‹ (é•¿åº¦) [ COMMENT æ³¨é‡Š ] [ çº¦æŸ ]; -- ä¸ºempè¡¨å¢åŠ ä¸€ä¸ªæ–°çš„å­—æ®µâ€æ˜µç§°â€ä¸ºnicknameï¼Œç±»å‹ä¸ºvarchar(20) ALTER TABLE emp ADD nickname varchar(20) COMMENT \u0026#39;æ˜µç§°\u0026#39;; ä¿®æ”¹æ•°æ®ç±»å‹ã€‚ ALTER TABLE è¡¨å MODIFY å­—æ®µå æ–°æ•°æ®ç±»å‹ (é•¿åº¦); ä¿®æ”¹å­—æ®µåå’Œå­—æ®µç±»å‹ã€‚ ALTER TABLE è¡¨å CHANGE æ—§å­—æ®µå æ–°å­—æ®µå ç±»å‹ (é•¿åº¦) [ COMMENT æ³¨é‡Š ] [ çº¦æŸ ]; -- å°†empè¡¨çš„nicknameå­—æ®µä¿®æ”¹ä¸ºusernameï¼Œç±»å‹ä¸ºvarchar(30) ALTER TABLE emp CHANGE nickname username varchar(30) COMMENT \u0026#39;æ˜µç§°\u0026#39;; åˆ é™¤å­—æ®µã€‚ ALTER TABLE è¡¨å DROP å­—æ®µå; -- å°†empè¡¨çš„å­—æ®µusernameåˆ é™¤ ALTER TABLE emp DROP username; ä¿®æ”¹è¡¨åã€‚ ALTER TABLE è¡¨å RENAME TO æ–°è¡¨å; -- å°†empè¡¨çš„è¡¨åä¿®æ”¹ä¸º employee ALTER TABLE emp RENAME TO employee; åˆ é™¤è¡¨ï¼šå¯é€‰é¡¹ IF EXISTS ä»£è¡¨ï¼Œåªæœ‰è¡¨åå­˜åœ¨æ—¶æ‰ä¼šåˆ é™¤è¯¥è¡¨ï¼Œè¡¨åä¸å­˜åœ¨ï¼Œåˆ™ä¸æ‰§è¡Œåˆ é™¤æ“ä½œ(å¦‚æœä¸ åŠ è¯¥å‚æ•°é¡¹ï¼Œåˆ é™¤ä¸€å¼ ä¸å­˜åœ¨çš„è¡¨ï¼Œæ‰§è¡Œå°†ä¼šæŠ¥é”™)ã€‚ DROP TABLE [ IF EXISTS ] è¡¨å; -- å¦‚æœtb_userè¡¨å­˜åœ¨ï¼Œåˆ™åˆ é™¤tb_userè¡¨ DROP TABLE IF EXISTS tb_user; åˆ é™¤æŒ‡å®šè¡¨, å¹¶é‡æ–°åˆ›å»ºè¡¨ã€‚ -- æ³¨æ„: åœ¨åˆ é™¤è¡¨çš„æ—¶å€™ï¼Œè¡¨ä¸­çš„å…¨éƒ¨æ•°æ®ä¹Ÿéƒ½ä¼šè¢«åˆ é™¤ã€‚ TRUNCATE TABLE è¡¨å; DML DMLè‹±æ–‡å…¨ç§°æ˜¯Data Manipulation Language(æ•°æ®æ“ä½œè¯­è¨€)ï¼Œç”¨æ¥å¯¹æ•°æ®åº“ä¸­è¡¨çš„æ•°æ®è®°å½•è¿›è¡Œå¢ã€åˆ ã€æ”¹æ“ä½œã€‚ æ·»åŠ æ•°æ®(INSERT) ç»™æŒ‡å®šå­—æ®µæ·»åŠ æ•°æ®ã€‚ INSERT INTO è¡¨å (å­—æ®µå1, å­—æ®µå2, ...) VALUES (å€¼1, å€¼2, ...); -- ç»™employeeè¡¨æ‰€æœ‰çš„å­—æ®µæ·»åŠ æ•°æ® insert into employee(id,workno,name,gender,age,idcard,entrydate) values(1,\u0026#39;1\u0026#39;,\u0026#39;Itcast\u0026#39;,\u0026#39;ç”·\u0026#39;,10,\u0026#39;123456789012345678\u0026#39;,\u0026#39;2000-01-01\u0026#39;); ç»™å…¨éƒ¨å­—æ®µæ·»åŠ æ•°æ®ã€‚ INSERT INTO è¡¨å VALUES (å€¼1, å€¼2, ...); insert into employee values(2,\u0026#39;2\u0026#39;,\u0026#39;å¼ æ— å¿Œ\u0026#39;,\u0026#39;ç”·\u0026#39;,18,\u0026#39;123456789012345670\u0026#39;,\u0026#39;2005-01-01\u0026#39;); æ‰¹é‡æ·»åŠ æ•°æ®ã€‚ INSERT INTO è¡¨å (å­—æ®µå1, å­—æ®µå2, ...) VALUES (å€¼1, å€¼2, ...), (å€¼1, å€¼2, ...), (å€¼1, å€¼2, ...); INSERT INTO è¡¨å VALUES (å€¼1, å€¼2, ...), (å€¼1, å€¼2, ...), (å€¼1, å€¼2, ...); -- æ‰¹é‡æ’å…¥æ•°æ®åˆ°employeeè¡¨ -- æ’å…¥æ•°æ®æ—¶ï¼ŒæŒ‡å®šçš„å­—æ®µé¡ºåºéœ€è¦ä¸å€¼çš„é¡ºåºæ˜¯ä¸€ä¸€å¯¹åº”çš„ã€‚ -- å­—ç¬¦ä¸²å’Œæ—¥æœŸå‹æ•°æ®åº”è¯¥åŒ…å«åœ¨å¼•å·ä¸­ã€‚ -- æ’å…¥çš„æ•°æ®å¤§å°ï¼Œåº”è¯¥åœ¨å­—æ®µçš„è§„å®šèŒƒå›´å†… insert into employee values(3,\u0026#39;3\u0026#39;,\u0026#39;éŸ¦\u0026#39;,\u0026#39;ç”·\u0026#39;,38,\u0026#39;123456789012345670\u0026#39;,\u0026#39;2005-01-01\u0026#39;), (4,\u0026#39;4\u0026#39;,\u0026#39;èµµ\u0026#39;,\u0026#39;å¥³\u0026#39;,18,\u0026#39;123456789012345670\u0026#39;,\u0026#39;2005-01-01\u0026#39;); ä¿®æ”¹æ•°æ®(UPDATE) ä¿®æ”¹æ•°æ®çš„å…·ä½“è¯­æ³•ã€‚ UPDATE è¡¨å SET å­—æ®µå1 = å€¼1 , å­—æ®µå2 = å€¼2 , .... [ WHERE æ¡ä»¶ ] ; -- ä¿®æ”¹idä¸º1çš„æ•°æ®ï¼Œå°†nameä¿®æ”¹ä¸ºia update employee set name = \u0026#39;ia\u0026#39; where id = 1; -- ä¿®æ”¹idä¸º1çš„æ•°æ®, å°†nameä¿®æ”¹ä¸ºx, genderä¿®æ”¹ä¸º å¥³ update employee set name = \u0026#39;x\u0026#39; , gender = \u0026#39;å¥³\u0026#39; where id = 1; -- å°†æ‰€æœ‰çš„å‘˜å·¥å…¥èŒæ—¥æœŸä¿®æ”¹ä¸º 2008-01-01 update employee set entrydate = \u0026#39;2008-01-01\u0026#39;; æ³¨æ„ï¼šä¿®æ”¹è¯­å¥çš„æ¡ä»¶å¯ä»¥æœ‰ï¼Œä¹Ÿå¯ä»¥æ²¡æœ‰ï¼Œå¦‚æœæ²¡æœ‰æ¡ä»¶ï¼Œåˆ™ä¼šä¿®æ”¹æ•´å¼ è¡¨çš„æ‰€æœ‰æ•°æ®ã€‚ åˆ é™¤æ•°æ®(DELETE) åˆ é™¤æ•°æ®çš„å…·ä½“è¯­æ³•ã€‚ DELETE FROM è¡¨å [ WHERE æ¡ä»¶ ]; -- åˆ é™¤genderä¸ºå¥³çš„å‘˜å·¥ delete from employee where gender = \u0026#39;å¥³\u0026#39;; -- åˆ é™¤æ‰€æœ‰å‘˜å·¥ delete from employee; æ³¨æ„äº‹é¡¹ï¼š DELETE è¯­å¥çš„æ¡ä»¶å¯ä»¥æœ‰ï¼Œä¹Ÿå¯ä»¥æ²¡æœ‰ï¼Œå¦‚æœæ²¡æœ‰æ¡ä»¶ï¼Œåˆ™ä¼šåˆ é™¤æ•´å¼ è¡¨çš„æ‰€æœ‰æ•°æ®ã€‚ DELETE è¯­å¥ä¸èƒ½åˆ é™¤æŸä¸€ä¸ªå­—æ®µçš„å€¼(å¯ä»¥ä½¿ç”¨UPDATEï¼Œå°†è¯¥å­—æ®µå€¼ç½®ä¸ºNULLå³å¯)ã€‚ DQL DQLè‹±æ–‡å…¨ç§°æ˜¯Data Query Language(æ•°æ®æŸ¥è¯¢è¯­è¨€)ï¼Œæ•°æ®æŸ¥è¯¢è¯­è¨€ï¼Œç”¨æ¥æŸ¥è¯¢æ•°æ®åº“ä¸­è¡¨çš„è®°å½•ã€‚ DQLæŸ¥è¯¢è¯­å¥ï¼Œè¯­æ³•ç»“æ„å¦‚ä¸‹ï¼š SELECT å­—æ®µåˆ—è¡¨ FROM è¡¨ååˆ—è¡¨ WHERE æ¡ä»¶åˆ—è¡¨ GROUP BY åˆ†ç»„å­—æ®µåˆ—è¡¨ HAVING åˆ†ç»„åæ¡ä»¶åˆ—è¡¨ ORDER BY æ’åºå­—æ®µåˆ—è¡¨ LIMIT åˆ†é¡µå‚æ•° åŸºç¡€æŸ¥è¯¢ åœ¨åŸºæœ¬æŸ¥è¯¢çš„DQLè¯­å¥ä¸­ï¼Œä¸å¸¦ä»»ä½•çš„æŸ¥è¯¢æ¡ä»¶ï¼ŒæŸ¥è¯¢çš„è¯­æ³•å¦‚ä¸‹ï¼š\næŸ¥è¯¢å¤šä¸ªå­—æ®µ SELECT å­—æ®µ1, å­—æ®µ2, å­—æ®µ3 ... FROM è¡¨å; -- * å·ä»£è¡¨æŸ¥è¯¢æ‰€æœ‰å­—æ®µï¼Œåœ¨å®é™…å¼€å‘ä¸­å°½é‡å°‘ç”¨ï¼ˆä¸ç›´è§‚ã€å½±å“æ•ˆç‡ï¼‰ã€‚ SELECT * FROM è¡¨å; å­—æ®µè®¾ç½®åˆ«å SELECT å­—æ®µ1 [ AS åˆ«å1 ] , å­—æ®µ2 [ AS åˆ«å2 ] ... FROM è¡¨å; SELECT å­—æ®µ1 [ åˆ«å1 ] , å­—æ®µ2 [ åˆ«å2 ] ... FROM è¡¨å; å»é™¤é‡å¤è®°å½• SELECT DISTINCT å­—æ®µåˆ—è¡¨ FROM è¡¨å; -- æŸ¥è¯¢å…¬å¸å‘˜å·¥çš„ä¸Šç­åœ°å€æœ‰å“ªäº›(ä¸è¦é‡å¤) select distinct workaddress \u0026#39;å·¥ä½œåœ°å€\u0026#39; from emp; æ¡ä»¶æŸ¥è¯¢ SELECT å­—æ®µåˆ—è¡¨ FROM è¡¨å WHERE æ¡ä»¶åˆ—è¡¨ ; å¸¸ç”¨çš„æ¯”è¾ƒè¿ç®—ç¬¦å¦‚ä¸‹ï¼š \u0026mdash;\u0026mdash;\u0026mdash;-æ¯”è¾ƒè¿ç®—ç¬¦\u0026mdash;\u0026mdash;\u0026mdash;- åŠŸèƒ½ \u0026gt; å¤§äº \u0026gt;= å¤§äºç­‰äº \u0026lt; å°äº \u0026lt;= å°äºç­‰äº = ç­‰äº \u0026lt;\u0026gt; æˆ– != ä¸ç­‰äº BETWEEN \u0026hellip; AND \u0026hellip; åœ¨æŸä¸ªèŒƒå›´ä¹‹å†…(å«æœ€å°ã€æœ€å¤§å€¼) IN(\u0026hellip;) åœ¨inä¹‹åçš„åˆ—è¡¨ä¸­çš„å€¼ï¼Œå¤šé€‰ LIKE å ä½ç¬¦ æ¨¡ç³ŠåŒ¹é…(_åŒ¹é…å•ä¸ªå­—ç¬¦, %åŒ¹é…ä»»æ„ä¸ªå­—ç¬¦) IS NULL æ˜¯NULL å¸¸ç”¨çš„é€»è¾‘è¿ç®—ç¬¦å¦‚ä¸‹ï¼š \u0026mdash;\u0026mdash;\u0026mdash;-æ¯”è¾ƒè¿ç®—ç¬¦\u0026mdash;\u0026mdash;\u0026mdash;- åŠŸèƒ½ AND æˆ– \u0026amp;\u0026amp; å¹¶ä¸” (å¤šä¸ªæ¡ä»¶åŒæ—¶æˆç«‹) OR æˆ– || æˆ–è€… (å¤šä¸ªæ¡ä»¶ä»»æ„ä¸€ä¸ªæˆç«‹) NOT æˆ– ! é , ä¸æ˜¯ èšåˆå‡½æ•° å°†ä¸€åˆ—æ•°æ®ä½œä¸ºä¸€ä¸ªæ•´ä½“ï¼Œè¿›è¡Œçºµå‘è®¡ç®—ã€‚ å¸¸è§çš„èšåˆå‡½æ•°ã€‚ å‡½æ•° åŠŸèƒ½ count ç»Ÿè®¡æ•°é‡ max æœ€å¤§å€¼ min æœ€å°å€¼ avg å¹³å‡å€¼ sum æ±‚å’Œ è¯­æ³•ï¼š SELECT èšåˆå‡½æ•°(å­—æ®µåˆ—è¡¨) FROM è¡¨å ; æ³¨æ„: NULLå€¼æ˜¯ä¸å‚ä¸æ‰€æœ‰èšåˆå‡½æ•°è¿ç®—çš„ã€‚ åˆ†ç»„æŸ¥è¯¢ SELECT å­—æ®µåˆ—è¡¨ FROM è¡¨å [ WHERE æ¡ä»¶ ] GROUP BY åˆ†ç»„å­—æ®µå [ HAVING åˆ†ç»„åè¿‡æ»¤æ¡ä»¶ ]; whereä¸havingåŒºåˆ«ï¼š æ‰§è¡Œæ—¶æœºä¸åŒï¼šwhereæ˜¯åˆ†ç»„ä¹‹å‰è¿›è¡Œè¿‡æ»¤ï¼Œä¸æ»¡è¶³whereæ¡ä»¶ï¼Œä¸å‚ä¸åˆ†ç»„ï¼›è€Œhavingæ˜¯åˆ†ç»„ä¹‹åå¯¹ç»“æœè¿›è¡Œè¿‡æ»¤ã€‚ åˆ¤æ–­æ¡ä»¶ä¸åŒï¼šwhereä¸èƒ½å¯¹èšåˆå‡½æ•°è¿›è¡Œåˆ¤æ–­ï¼Œè€Œhavingå¯ä»¥ã€‚ æ³¨æ„äº‹é¡¹: åˆ†ç»„ä¹‹åï¼ŒæŸ¥è¯¢çš„å­—æ®µä¸€èˆ¬ä¸ºèšåˆå‡½æ•°å’Œåˆ†ç»„å­—æ®µï¼ŒæŸ¥è¯¢å…¶ä»–å­—æ®µæ— ä»»ä½•æ„ä¹‰ã€‚ æ‰§è¡Œé¡ºåº: where \u0026gt; èšåˆå‡½æ•° \u0026gt; having ã€‚ æ”¯æŒå¤šå­—æ®µåˆ†ç»„, å…·ä½“è¯­æ³•ä¸º : group by columnA,columnBã€‚ æ’åºæŸ¥è¯¢ SELECT å­—æ®µåˆ—è¡¨ FROM è¡¨å ORDER BY å­—æ®µ1 æ’åºæ–¹å¼1 , å­—æ®µ2 æ’åºæ–¹å¼2 ; æ’åºæ–¹å¼ï¼šASC-å‡åº(é»˜è®¤å€¼)ã€DESC-é™åºã€‚ æ³¨æ„äº‹é¡¹ï¼š å¦‚æœæ˜¯å‡åº, å¯ä»¥ä¸æŒ‡å®šæ’åºæ–¹å¼ASC; å¦‚æœæ˜¯å¤šå­—æ®µæ’åºï¼Œå½“ç¬¬ä¸€ä¸ªå­—æ®µå€¼ç›¸åŒæ—¶ï¼Œæ‰ä¼šæ ¹æ®ç¬¬äºŒä¸ªå­—æ®µè¿›è¡Œæ’åº; åˆ†é¡µæŸ¥è¯¢ SELECT å­—æ®µåˆ—è¡¨ FROM è¡¨å LIMIT èµ·å§‹ç´¢å¼•, æŸ¥è¯¢è®°å½•æ•°; æ³¨æ„äº‹é¡¹ï¼š èµ·å§‹ç´¢å¼•ä»0å¼€å§‹ï¼Œèµ·å§‹ç´¢å¼• = ï¼ˆæŸ¥è¯¢é¡µç  - 1ï¼‰* æ¯é¡µæ˜¾ç¤ºè®°å½•æ•°ã€‚ åˆ†é¡µæŸ¥è¯¢æ˜¯æ•°æ®åº“çš„æ–¹è¨€ï¼Œä¸åŒçš„æ•°æ®åº“æœ‰ä¸åŒçš„å®ç°ï¼ŒMySQLä¸­æ˜¯LIMITã€‚ å¦‚æœæŸ¥è¯¢çš„æ˜¯ç¬¬ä¸€é¡µæ•°æ®ï¼Œèµ·å§‹ç´¢å¼•å¯ä»¥çœç•¥ï¼Œç›´æ¥ç®€å†™ä¸º limit 10ã€‚ æ‰§è¡Œé¡ºåº DQLè¯­å¥åœ¨æ‰§è¡Œæ—¶çš„æ‰§è¡Œé¡ºåºï¼Œä¹Ÿå°±æ˜¯å…ˆæ‰§è¡Œé‚£ä¸€éƒ¨åˆ†ï¼Œåæ‰§è¡Œé‚£ä¸€éƒ¨åˆ†ã€‚ DCL DCLè‹±æ–‡å…¨ç§°æ˜¯Data Control Language(æ•°æ®æ§åˆ¶è¯­è¨€)ï¼Œç”¨æ¥é—®æƒé™ã€‚\nç®¡ç†ç”¨æˆ· æŸ¥è¯¢ç”¨æˆ·ã€‚ -- Hostä»£è¡¨å½“å‰ç”¨æˆ·è®¿é—®çš„ä¸»æœº, å¦‚æœä¸ºlocalhost, ä»…ä»£è¡¨åªèƒ½å¤Ÿåœ¨å½“å‰æœ¬æœºè®¿é—®ï¼Œæ˜¯ä¸å¯ä»¥è¿œç¨‹è®¿é—®çš„ -- Userä»£è¡¨çš„æ˜¯è®¿é—®è¯¥æ•°æ®åº“çš„ç”¨æˆ·åã€‚åœ¨MySQLä¸­éœ€è¦é€šè¿‡Hostå’ŒUseræ¥å”¯ä¸€æ ‡è¯†ä¸€ä¸ªç”¨æˆ·ã€‚ select * from mysql.user; åˆ›å»ºç”¨æˆ·ã€‚ CREATE USER \u0026#39;ç”¨æˆ·å\u0026#39;@\u0026#39;ä¸»æœºå\u0026#39; IDENTIFIED BY \u0026#39;å¯†ç \u0026#39;; -- åˆ›å»ºç”¨æˆ·ic, åªèƒ½å¤Ÿåœ¨å½“å‰ä¸»æœºlocalhostè®¿é—®, å¯†ç 123456 create user \u0026#39;ic\u0026#39;@\u0026#39;localhost\u0026#39; identified by \u0026#39;123456\u0026#39;; -- åˆ›å»ºç”¨æˆ·hl, å¯ä»¥åœ¨ä»»æ„ä¸»æœºè®¿é—®è¯¥æ•°æ®åº“, å¯†ç 123456 create user \u0026#39;hl\u0026#39;@\u0026#39;%\u0026#39; identified by \u0026#39;123456\u0026#39;; ä¿®æ”¹ç”¨æˆ·å¯†ç ã€‚ ALTER USER \u0026#39;ç”¨æˆ·å\u0026#39;@\u0026#39;ä¸»æœºå\u0026#39; IDENTIFIED WITH mysql_native_password BY \u0026#39;æ–°å¯†ç \u0026#39;; -- ä¿®æ”¹ç”¨æˆ·hlçš„è®¿é—®å¯†ç ä¸º1234 alter user \u0026#39;hl\u0026#39;@\u0026#39;%\u0026#39; identified with mysql_native_password by \u0026#39;1234\u0026#39;; åˆ é™¤ç”¨æˆ·ã€‚ DROP USER \u0026#39;ç”¨æˆ·å\u0026#39;@\u0026#39;ä¸»æœºå\u0026#39;; -- åˆ é™¤ hl@localhost ç”¨æˆ· drop user \u0026#39;hl\u0026#39;@\u0026#39;localhost\u0026#39;; æ³¨æ„äº‹é¡¹ï¼š åœ¨MySQLä¸­éœ€è¦é€šè¿‡ç”¨æˆ·å@ä¸»æœºåçš„æ–¹å¼ï¼Œæ¥å”¯ä¸€æ ‡è¯†ä¸€ä¸ªç”¨æˆ·ã€‚ ä¸»æœºåå¯ä»¥ä½¿ç”¨ % é€šé…ã€‚ è¿™ç±»SQLå¼€å‘äººå‘˜æ“ä½œçš„æ¯”è¾ƒå°‘ï¼Œä¸»è¦æ˜¯DBAï¼ˆ Database Administrator æ•°æ®åº“ç®¡ç†å‘˜ï¼‰ä½¿ç”¨ã€‚ æƒé™æ§åˆ¶ MySQLä¸­å®šä¹‰äº†å¾ˆå¤šç§æƒé™ï¼Œä½†æ˜¯å¸¸ç”¨çš„å°±ä»¥ä¸‹å‡ ç§ï¼š æƒé™ è¯´æ˜ ALL, ALL PRIVILEGES æ‰€æœ‰æƒé™ SELECT æŸ¥è¯¢æ•°æ® INSERT æ’å…¥æ•°æ® UPDATE ä¿®æ”¹æ•°æ® DELETE åˆ é™¤æ•°æ® ALTER ä¿®æ”¹è¡¨ DROP åˆ é™¤æ•°æ®åº“/è¡¨/è§†å›¾ CREATE åˆ›å»ºæ•°æ®åº“/è¡¨ æŸ¥è¯¢æƒé™ã€‚ SHOW GRANTS FOR \u0026#39;ç”¨æˆ·å\u0026#39;@\u0026#39;ä¸»æœºå\u0026#39; ; æˆäºˆæƒé™ã€‚ GRANT æƒé™åˆ—è¡¨ ON æ•°æ®åº“å.è¡¨å TO \u0026#39;ç”¨æˆ·å\u0026#39;@\u0026#39;ä¸»æœºå\u0026#39;; æ’¤é”€æƒé™ã€‚ REVOKE æƒé™åˆ—è¡¨ ON æ•°æ®åº“å.è¡¨å FROM \u0026#39;ç”¨æˆ·å\u0026#39;@\u0026#39;ä¸»æœºå\u0026#39;; æ³¨æ„ï¼š å¤šä¸ªæƒé™ä¹‹é—´ï¼Œä½¿ç”¨é€—å·åˆ†éš” æˆæƒæ—¶ï¼Œ æ•°æ®åº“åå’Œè¡¨åå¯ä»¥ä½¿ç”¨ * è¿›è¡Œé€šé…ï¼Œä»£è¡¨æ‰€æœ‰ å‡½æ•° å­—ç¬¦ä¸²å‡½æ•° å‡½æ•° åŠŸèƒ½ CONCAT(S1,S2,\u0026hellip;Sn) å­—ç¬¦ä¸²æ‹¼æ¥ï¼Œå°†S1ï¼ŒS2ï¼Œ\u0026hellip; Snæ‹¼æ¥æˆä¸€ä¸ªå­—ç¬¦ä¸² LOWER(str) å°†å­—ç¬¦ä¸²strå…¨éƒ¨è½¬ä¸ºå°å†™ UPPER(str) å°†å­—ç¬¦ä¸²strå…¨éƒ¨è½¬ä¸ºå¤§å†™ LPAD(str,n,pad) å·¦å¡«å……ï¼Œç”¨å­—ç¬¦ä¸²padå¯¹strçš„å·¦è¾¹è¿›è¡Œå¡«å……ï¼Œè¾¾åˆ°nä¸ªå­—ç¬¦ä¸²é•¿åº¦ RPAD(str,n,pad) å³å¡«å……ï¼Œç”¨å­—ç¬¦ä¸²padå¯¹strçš„å³è¾¹è¿›è¡Œå¡«å……ï¼Œè¾¾åˆ°nä¸ªå­—ç¬¦ä¸²é•¿åº¦ TRIM(str) å»æ‰å­—ç¬¦ä¸²å¤´éƒ¨å’Œå°¾éƒ¨çš„ç©ºæ ¼ SUBSTRING(str,start,len) è¿”å›ä»å­—ç¬¦ä¸²strä»startä½ç½®èµ·çš„lenä¸ªé•¿åº¦çš„å­—ç¬¦ä¸² æ•°å€¼å‡½æ•° å‡½æ•° åŠŸèƒ½ CEIL(x) å‘ä¸Šå–æ•´ FLOOR(x) å‘ä¸‹å–æ•´ MOD(x,y) è¿”å›x/yçš„æ¨¡ RAND() è¿”å›0~1å†…çš„éšæœºæ•° ROUND(x,y) æ±‚å‚æ•°xçš„å››èˆäº”å…¥çš„å€¼ï¼Œä¿ç•™yä½å°æ•° æ—¥æœŸå‡½æ•° å‡½æ•° åŠŸèƒ½ CURDATE() è¿”å›å½“å‰æ—¥æœŸ CURTIME() è¿”å›å½“å‰æ—¶é—´ NOW() è¿”å›å½“å‰æ—¥æœŸå’Œæ—¶é—´ YEAR(date) è·å–æŒ‡å®šdateçš„å¹´ä»½ MONTH(date) è·å–æŒ‡å®šdateçš„æœˆä»½ DAY(date) è·å–æŒ‡å®šdateçš„æ—¥æœŸ DATE_ADD(date, INTERVAL expr type) è¿”å›ä¸€ä¸ªæ—¥æœŸ/æ—¶é—´å€¼åŠ ä¸Šä¸€ä¸ªæ—¶é—´é—´éš”expråçš„æ—¶é—´å€¼ DATEDIFF(date1,date2) è¿”å›èµ·å§‹æ—¶é—´date1 å’Œ ç»“æŸæ—¶é—´date2ä¹‹é—´çš„å¤©æ•° æµç¨‹å‡½æ•° \u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;å‡½æ•°\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash; åŠŸèƒ½ IF(value , t , f) å¦‚æœvalueä¸ºtrueï¼Œåˆ™è¿”å›tï¼Œå¦åˆ™è¿”å› f IFNULL(value1 , value2) å¦‚æœvalue1ä¸ä¸ºç©ºï¼Œè¿”å›value1ï¼Œå¦åˆ™è¿”å›value2 CASE WHEN [ val1 ] THEN [res1] \u0026hellip; ELSE [ default ] END å¦‚æœval1ä¸ºtrueï¼Œè¿”å›res1ï¼Œ\u0026hellip; å¦åˆ™è¿”å›defaulté»˜è®¤å€¼ CASE [ expr ] WHEN [ val1 ] THEN [res1] \u0026hellip; ELSE [ default ] END å¦‚æœexprçš„å€¼ç­‰äºval1è¿”å›res1ï¼Œ\u0026hellip; å¦åˆ™è¿”å›defaulté»˜è®¤å€¼ çº¦æŸ çº¦æŸæ˜¯ä½œç”¨äºè¡¨ä¸­å­—æ®µä¸Šçš„è§„åˆ™ï¼Œç”¨äºé™åˆ¶å­˜å‚¨åœ¨è¡¨ä¸­çš„æ•°æ®ã€‚ ä¿è¯æ•°æ®åº“ä¸­æ•°æ®çš„æ­£ç¡®ã€æœ‰æ•ˆæ€§å’Œå®Œæ•´æ€§ã€‚ çº¦æŸæ˜¯ä½œç”¨äºè¡¨ä¸­å­—æ®µä¸Šçš„ï¼Œå¯ä»¥åœ¨åˆ›å»ºè¡¨/ä¿®æ”¹è¡¨çš„æ—¶å€™æ·»åŠ çº¦æŸã€‚ çº¦æŸ æè¿° å…³é”®å­— éç©ºçº¦æŸ é™åˆ¶è¯¥å­—æ®µçš„æ•°æ®ä¸èƒ½ä¸ºnull NOT NULL å”¯ä¸€çº¦æŸ ä¿è¯è¯¥å­—æ®µçš„æ‰€æœ‰æ•°æ®éƒ½æ˜¯å”¯ä¸€ã€ä¸é‡å¤çš„ UNIQUE ä¸»é”®çº¦æŸ ä¸»é”®æ˜¯ä¸€è¡Œæ•°æ®çš„å”¯ä¸€æ ‡è¯†ï¼Œè¦æ±‚éç©ºä¸”å”¯ä¸€ PRIMARY KEY é»˜è®¤çº¦æŸ ä¿å­˜æ•°æ®æ—¶ï¼Œå¦‚æœæœªæŒ‡å®šè¯¥å­—æ®µçš„å€¼ï¼Œåˆ™é‡‡ç”¨é»˜è®¤å€¼ DEFAULT æ£€æŸ¥çº¦æŸ(8.0.16ç‰ˆæœ¬ä¹‹å) ä¿è¯å­—æ®µå€¼æ»¡è¶³æŸä¸€ä¸ªæ¡ä»¶ CHECK å¤–é”®çº¦æŸ ç”¨æ¥è®©ä¸¤å¼ è¡¨çš„æ•°æ®ä¹‹é—´å»ºç«‹è¿æ¥ï¼Œä¿è¯æ•°æ®çš„ä¸€è‡´æ€§å’Œå®Œæ•´æ€§ FOREIGN KEY ç¤ºä¾‹ï¼š å­—æ®µå å­—æ®µå«ä¹‰ å­—æ®µç±»å‹ çº¦æŸæ¡ä»¶ çº¦æŸå…³é”®å­— id IDå”¯ä¸€æ ‡è¯† int ä¸»é”®ï¼Œå¹¶ä¸”è‡ªåŠ¨å¢é•¿ PRIMARY KEY, AUTO_INCREMENT name å§“å varchar(10) ä¸ä¸ºç©ºï¼Œå¹¶ä¸”å”¯ä¸€ NOT NULL, UNIQUE age å¹´é¾„ int å¤§äº0ï¼Œå¹¶ä¸”å°äºç­‰äº120 CHECK status çŠ¶æ€ char(1) å¦‚æœæ²¡æœ‰æŒ‡å®šè¯¥å€¼ï¼Œé»˜è®¤ä¸º1 DEFAULT gender æ€§åˆ« char(1) æ—  å¯¹åº”çš„å»ºè¡¨è¯­å¥ä¸ºï¼š CREATE TABLE tb_user( id int AUTO_INCREMENT PRIMARY KEY COMMENT \u0026#39;IDå”¯ä¸€æ ‡è¯†\u0026#39;, name varchar(10) NOT NULL UNIQUE COMMENT \u0026#39;å§“å\u0026#39; , age int check (age \u0026gt; 0 \u0026amp;\u0026amp; age \u0026lt;= 120) COMMENT \u0026#39;å¹´é¾„\u0026#39; , status char(1) default \u0026#39;1\u0026#39; COMMENT \u0026#39;çŠ¶æ€\u0026#39;, gender char(1) COMMENT \u0026#39;æ€§åˆ«\u0026#39; ) å¤–é”®çº¦æŸ å¤–é”®ï¼šç”¨æ¥è®©ä¸¤å¼ è¡¨çš„æ•°æ®ä¹‹é—´å»ºç«‹è¿æ¥ï¼Œä»è€Œä¿è¯æ•°æ®çš„ä¸€è‡´æ€§å’Œå®Œæ•´æ€§ã€‚ æ·»åŠ å¤–é”®ã€‚ CREATE TABLE è¡¨å( å­—æ®µå æ•°æ®ç±»å‹, ... [CONSTRAINT] [å¤–é”®åç§°] FOREIGN KEY (å¤–é”®å­—æ®µå) REFERENCES ä¸»è¡¨ (ä¸»è¡¨åˆ—å) ); ALTER TABLE è¡¨å ADD CONSTRAINT å¤–é”®åç§° FOREIGN KEY (å¤–é”®å­—æ®µå) REFERENCES ä¸»è¡¨ (ä¸»è¡¨åˆ—å) ; åˆ é™¤å¤–é”®ã€‚ ALTER TABLE è¡¨å DROP FOREIGN KEY å¤–é”®åç§°; æ·»åŠ äº†å¤–é”®ä¹‹åï¼Œå†åˆ é™¤çˆ¶è¡¨æ•°æ®æ—¶äº§ç”Ÿçš„çº¦æŸè¡Œä¸ºï¼Œæˆ‘ä»¬å°±ç§°ä¸ºåˆ é™¤/æ›´æ–°è¡Œä¸ºã€‚å…·ä½“çš„åˆ é™¤/æ›´æ–°è¡Œä¸ºæœ‰ä»¥ä¸‹å‡ ç§ï¼š\nè¡Œä¸º è¯´æ˜ NO ACTION å½“åœ¨çˆ¶è¡¨ä¸­åˆ é™¤/æ›´æ–°å¯¹åº”è®°å½•æ—¶ï¼Œé¦–å…ˆæ£€æŸ¥è¯¥è®°å½•æ˜¯å¦æœ‰å¯¹åº”å¤–é”®ï¼Œå¦‚æœæœ‰åˆ™ä¸å…è®¸åˆ é™¤/æ›´æ–°ã€‚ (ä¸ RESTRICT ä¸€è‡´) é»˜è®¤è¡Œä¸º RESTRICT å½“åœ¨çˆ¶è¡¨ä¸­åˆ é™¤/æ›´æ–°å¯¹åº”è®°å½•æ—¶ï¼Œé¦–å…ˆæ£€æŸ¥è¯¥è®°å½•æ˜¯å¦æœ‰å¯¹åº”å¤–é”®ï¼Œå¦‚æœæœ‰åˆ™ä¸å…è®¸åˆ é™¤/æ›´æ–°ã€‚ (ä¸ NO ACTION ä¸€è‡´) é»˜è®¤è¡Œä¸º CASCADE å½“åœ¨çˆ¶è¡¨ä¸­åˆ é™¤/æ›´æ–°å¯¹åº”è®°å½•æ—¶ï¼Œé¦–å…ˆæ£€æŸ¥è¯¥è®°å½•æ˜¯å¦æœ‰å¯¹åº”å¤–é”®ï¼Œå¦‚æœæœ‰ï¼Œåˆ™ä¹Ÿåˆ é™¤/æ›´æ–°å¤–é”®åœ¨å­è¡¨ä¸­çš„è®°å½• SET NULL å½“åœ¨çˆ¶è¡¨ä¸­åˆ é™¤å¯¹åº”è®°å½•æ—¶ï¼Œé¦–å…ˆæ£€æŸ¥è¯¥è®°å½•æ˜¯å¦æœ‰å¯¹åº”å¤–é”®ï¼Œå¦‚æœæœ‰åˆ™è®¾ç½®å­è¡¨ä¸­è¯¥å¤–é”®å€¼ä¸ºnullï¼ˆè¿™å°±è¦æ±‚è¯¥å¤–é”®å…è®¸å–nullï¼‰ SET DEFAULT çˆ¶è¡¨æœ‰å˜æ›´æ—¶ï¼Œå­è¡¨å°†å¤–é”®åˆ—è®¾ç½®æˆä¸€ä¸ªé»˜è®¤çš„å€¼ (Innodbä¸æ”¯æŒ) å…·ä½“è¯­æ³•ï¼š\nALTER TABLE è¡¨å ADD CONSTRAINT å¤–é”®åç§° FOREIGN KEY (å¤–é”®å­—æ®µ) REFERENCES ä¸»è¡¨å (ä¸»è¡¨å­—æ®µå) ON UPDATE CASCADE ON DELETE CASCADE; æ•°æ®ç±»å‹ æ•°å€¼ç±»å‹ ç±»å‹ å¤§å°/bytes æœ‰ç¬¦å·èŒƒå›´ æ— ç¬¦å·èŒƒå›´(unsigned) æè¿° TINYINT 1 (-128, 127) (0, 255) 1å­—èŠ‚æ•´æ•° SMALLINT 2 (-32768, 32767) (0, 65535) 2å­—èŠ‚æ•´æ•° MEDIUMINT 3 (-8388608, 8388607) (0, 16777215) 3å­—èŠ‚æ•´æ•° INT/INTEGER 4 (-2147483648, 2147483647) (0, 4294967295) 4å­—èŠ‚æ•´æ•° BIGINT 8 (-2^63, 2^63-1) (0, 2^64-1) 8å­—èŠ‚æ•´æ•° FLOAT 4 (-3.402823466 E+38, 3.402823466351 E+38) (1.175494351 E-38, 3.402823466 E+38) ä¸ 0 å•ç²¾åº¦æµ®ç‚¹æ•° DOUBLE 8 (-1.7976931348623157 E+308, 1.7976931348623157 E+308) (2.2250738585072014 E-308, 1.7976931348623157 E+308) ä¸ 0 åŒç²¾åº¦æµ®ç‚¹æ•° DECIMAL ä¾èµ–äºM(ç²¾åº¦)å’ŒD(æ ‡åº¦)çš„å€¼ ä¾èµ–äºM(ç²¾åº¦)å’ŒD(æ ‡åº¦)çš„å€¼ å°æ•°å€¼(ç²¾ç¡®ç‚¹æ•°) å­—ç¬¦ä¸²ç±»å‹ char ä¸ varchar éƒ½å¯ä»¥æè¿°å­—ç¬¦ä¸²ï¼Œcharæ˜¯å®šé•¿å­—ç¬¦ä¸²ï¼ŒæŒ‡å®šé•¿åº¦å¤šé•¿ï¼Œå°±å ç”¨å¤šå°‘ä¸ªå­—ç¬¦ï¼Œå’Œå­—æ®µå€¼çš„é•¿åº¦æ— å…³ã€‚ è€Œvarcharæ˜¯å˜é•¿å­—ç¬¦ä¸²ï¼ŒæŒ‡å®šçš„é•¿åº¦ä¸ºæœ€å¤§å ç”¨é•¿åº¦ ã€‚ç›¸å¯¹æ¥è¯´ï¼Œcharçš„æ€§èƒ½ä¼šæ›´é«˜äº›ã€‚ ç±»å‹ å¤§å°/bytes æè¿° CHAR 0-255 å®šé•¿å­—ç¬¦ä¸²(éœ€è¦æŒ‡å®šé•¿åº¦) VARCHAR 0-65535 å˜é•¿å­—ç¬¦ä¸²(éœ€è¦æŒ‡å®šé•¿åº¦) TINYBLOB 0-255 ä¸è¶…è¿‡255ä¸ªå­—ç¬¦çš„äºŒè¿›åˆ¶æ•°æ® TINYTEXT 0-255 çŸ­æ–‡æœ¬å­—ç¬¦ä¸² BLOB 0-65535 äºŒè¿›åˆ¶å½¢å¼çš„é•¿æ–‡æœ¬æ•°æ® TEXT 0-65535 é•¿æ–‡æœ¬æ•°æ® MEDIUMBLOB 0-16777215 äºŒè¿›åˆ¶å½¢å¼çš„ä¸­ç­‰é•¿åº¦æ–‡æœ¬æ•°æ® MEDIUMTEXT 0-16777215 ä¸­ç­‰é•¿åº¦æ–‡æœ¬æ•°æ® LONGBLOB 0-4294967295 äºŒè¿›åˆ¶å½¢å¼çš„æå¤§æ–‡æœ¬æ•°æ® LONGTEXT 0-4294967295 æå¤§æ–‡æœ¬æ•°æ® æ—¥æœŸæ—¶é—´ç±»å‹ ç±»å‹ å¤§å°/bytes èŒƒå›´ æ ¼å¼ æè¿° DATE 3 1000-01-01 è‡³ 9999-12-31 YYYY-MM-DD æ—¥æœŸå€¼ TIME 3 -838:59:59 è‡³ 838:59:59 HH:MM:SS æ—¶é—´å€¼æˆ–æŒç»­æ—¶é—´ YEAR 1 1901 è‡³ 2155 YYYY å¹´ä»½å€¼ DATETIME 8 1000-01-01 00:00:00 è‡³ 9999-12-31 23:59:59 YYYY-MM-DD HH:MM:SS æ··åˆæ—¥æœŸå’Œæ—¶é—´å€¼ TIMESTAMP 4 1970-01-01 00:00:01 è‡³ 2038-01-19 03:14:07 YYYY-MM-DD HH:MM:SS æ··åˆæ—¥æœŸå’Œæ—¶é—´å€¼ ","permalink":"https://heliu.site/posts/mysql/use/","summary":"DDLã€DCLã€DQLã€DML","title":"mysql è¯­æ³•"},{"content":"å¤šè¡¨å…³ç³» ä¸€å¯¹å¤šï¼šä¸€ä¸ªéƒ¨é—¨å¯¹åº”å¤šä¸ªå‘˜å·¥ã€‚ å¤šå¯¹å¤šï¼šä¸€ä¸ªå­¦ç”Ÿå¯ä»¥é€‰ä¿®å¤šé—¨è¯¾ç¨‹ï¼Œä¸€é—¨è¯¾ç¨‹ä¹Ÿå¯ä»¥ä¾›å¤šä¸ªå­¦ç”Ÿé€‰æ‹©ã€‚ ä¸€å¯¹ä¸€ï¼šä¸€å¯¹ä¸€å…³ç³»ï¼Œå¤šç”¨äºå•è¡¨æ‹†åˆ†ï¼Œå°†ä¸€å¼ è¡¨çš„åŸºç¡€å­—æ®µæ”¾åœ¨ä¸€å¼ è¡¨ä¸­ï¼Œå…¶ä»–è¯¦æƒ…å­—æ®µæ”¾åœ¨å¦ä¸€å¼ è¡¨ä¸­ï¼Œä»¥æå‡æ“ä½œæ•ˆç‡ã€‚ å†…è¿æ¥ å†…è¿æ¥æŸ¥è¯¢çš„æ˜¯ä¸¤å¼ è¡¨äº¤é›†éƒ¨åˆ†çš„æ•°æ®ã€‚ å†…è¿æ¥çš„è¯­æ³•åˆ†ä¸ºä¸¤ç§: éšå¼å†…è¿æ¥ã€æ˜¾å¼å†…è¿æ¥ã€‚ éšå¼å†…è¿æ¥ï¼š SELECT å­—æ®µåˆ—è¡¨ FROM è¡¨1 , è¡¨2 WHERE æ¡ä»¶ ... ; æ˜¾å¼å†…è¿æ¥ï¼š SELECT å­—æ®µåˆ—è¡¨ FROM è¡¨1 [ INNER ] JOIN è¡¨2 ON è¿æ¥æ¡ä»¶ ... ; å¤–è¿æ¥ å¤–è¿æ¥åˆ†ä¸ºä¸¤ç§ï¼Œåˆ†åˆ«æ˜¯ï¼šå·¦å¤–è¿æ¥å’Œå³å¤–è¿æ¥ã€‚ å·¦å¤–è¿æ¥ï¼šå·¦å¤–è¿æ¥ç›¸å½“äºæŸ¥è¯¢è¡¨1(å·¦è¡¨)çš„æ‰€æœ‰æ•°æ®ï¼Œå½“ç„¶ä¹ŸåŒ…å«è¡¨1å’Œè¡¨2äº¤é›†éƒ¨åˆ†çš„æ•°æ®ã€‚ SELECT å­—æ®µåˆ—è¡¨ FROM è¡¨1 LEFT [ OUTER ] JOIN è¡¨2 ON æ¡ä»¶ ... ; å³å¤–è¿æ¥ï¼šå³å¤–è¿æ¥ç›¸å½“äºæŸ¥è¯¢è¡¨2(å³è¡¨)çš„æ‰€æœ‰æ•°æ®ï¼Œå½“ç„¶ä¹ŸåŒ…å«è¡¨1å’Œè¡¨2äº¤é›†éƒ¨åˆ†çš„æ•°æ®ã€‚ SELECT å­—æ®µåˆ—è¡¨ FROM è¡¨1 RIGHT [ OUTER ] JOIN è¡¨2 ON æ¡ä»¶ ... ; æ³¨æ„äº‹é¡¹ï¼šå·¦å¤–è¿æ¥å’Œå³å¤–è¿æ¥æ˜¯å¯ä»¥ç›¸äº’æ›¿æ¢çš„ï¼Œåªéœ€è¦è°ƒæ•´åœ¨è¿æ¥æŸ¥è¯¢æ—¶SQLä¸­ï¼Œè¡¨ç»“æ„çš„å…ˆåé¡ºåºå°±å¯ä»¥äº†ã€‚è€Œæˆ‘ä»¬åœ¨æ—¥å¸¸å¼€å‘ä½¿ç”¨æ—¶ï¼Œæ›´åå‘äºå·¦å¤–è¿æ¥ã€‚ è‡ªè¿æ¥ è‡ªè¿æ¥æŸ¥è¯¢ï¼šè‡ªå·±è¿æ¥è‡ªå·±ï¼Œä¹Ÿå°±æ˜¯æŠŠä¸€å¼ è¡¨è¿æ¥æŸ¥è¯¢å¤šæ¬¡ã€‚ è€Œå¯¹äºè‡ªè¿æ¥æŸ¥è¯¢ï¼Œå¯ä»¥æ˜¯å†…è¿æ¥æŸ¥è¯¢ï¼Œä¹Ÿå¯ä»¥æ˜¯å¤–è¿æ¥æŸ¥è¯¢ã€‚ SELECT å­—æ®µåˆ—è¡¨ FROM è¡¨A åˆ«åA JOIN è¡¨A åˆ«åB ON æ¡ä»¶ ... ; å¯¹äºunionæŸ¥è¯¢ï¼Œå°±æ˜¯æŠŠå¤šæ¬¡æŸ¥è¯¢çš„ç»“æœåˆå¹¶èµ·æ¥ï¼Œå½¢æˆä¸€ä¸ªæ–°çš„æŸ¥è¯¢ç»“æœé›†ã€‚ å¯¹äºè”åˆæŸ¥è¯¢çš„å¤šå¼ è¡¨çš„åˆ—æ•°å¿…é¡»ä¿æŒä¸€è‡´ï¼Œå­—æ®µç±»å‹ä¹Ÿéœ€è¦ä¿æŒä¸€è‡´ã€‚ union all ä¼šå°†å…¨éƒ¨çš„æ•°æ®ç›´æ¥åˆå¹¶åœ¨ä¸€èµ·ï¼Œunion ä¼šå¯¹åˆå¹¶ä¹‹åçš„æ•°æ®å»é‡ã€‚ SELECT å­—æ®µåˆ—è¡¨ FROM è¡¨A ... UNION [ ALL ] SELECT å­—æ®µåˆ—è¡¨ FROM è¡¨B ....; å­æŸ¥è¯¢ SQLè¯­å¥ä¸­åµŒå¥—SELECTè¯­å¥ï¼Œç§°ä¸ºåµŒå¥—æŸ¥è¯¢ï¼Œåˆç§°å­æŸ¥è¯¢ã€‚ å­æŸ¥è¯¢å¤–éƒ¨çš„è¯­å¥å¯ä»¥æ˜¯INSERT / UPDATE / DELETE / SELECT çš„ä»»ä½•ä¸€ä¸ªã€‚ SELECT * FROM t1 WHERE column1 = ( SELECT column1 FROM t2 ); æ ‡é‡å­æŸ¥è¯¢ å­æŸ¥è¯¢è¿”å›çš„ç»“æœæ˜¯å•ä¸ªå€¼ï¼ˆæ•°å­—ã€å­—ç¬¦ä¸²ã€æ—¥æœŸç­‰ï¼‰ï¼Œæœ€ç®€å•çš„å½¢å¼ï¼Œè¿™ç§å­æŸ¥è¯¢ç§°ä¸ºæ ‡é‡å­æŸ¥è¯¢ã€‚ å¸¸ç”¨çš„æ“ä½œç¬¦ï¼š=ã€\u0026lt;\u0026gt;ã€\u0026gt;ã€\u0026gt;=ã€\u0026lt;ã€\u0026lt;=ã€‚ -- æŸ¥è¯¢æŒ‡å®šå…¥èŒæ—¥æœŸä¹‹åå…¥èŒçš„å‘˜å·¥ä¿¡æ¯ select * from emp where entrydate \u0026gt; (select entrydate from emp where name = \u0026#39;å¼ ä¸‰\u0026#39;); åˆ—å­æŸ¥è¯¢ å­æŸ¥è¯¢è¿”å›çš„ç»“æœæ˜¯ä¸€åˆ—ï¼ˆå¯ä»¥æ˜¯å¤šè¡Œï¼‰ï¼Œè¿™ç§å­æŸ¥è¯¢ç§°ä¸ºåˆ—å­æŸ¥è¯¢ã€‚ å¸¸ç”¨çš„æ“ä½œç¬¦ï¼šINã€NOT INã€ANYã€SOMEã€ALLã€‚ | æ“ä½œç¬¦ | æè¿° | | IN | åœ¨æŒ‡å®šçš„é›†åˆèŒƒå›´ä¹‹å†…ï¼Œå¤šé€‰ä¸€ | | NOT IN | ä¸åœ¨æŒ‡å®šçš„é›†åˆèŒƒå›´ä¹‹å†… | | ANY | å­æŸ¥è¯¢è¿”å›åˆ—è¡¨ä¸­ï¼Œæœ‰ä»»æ„ä¸€ä¸ªæ»¡è¶³å³å¯ | | SOME | ä¸ANYç­‰åŒï¼Œä½¿ç”¨SOMEçš„åœ°æ–¹éƒ½å¯ä»¥ä½¿ç”¨ANY | | ALL | å­æŸ¥è¯¢è¿”å›åˆ—è¡¨çš„æ‰€æœ‰å€¼éƒ½å¿…é¡»æ»¡è¶³ |\n-- æ ¹æ®éƒ¨é—¨ID, æŸ¥è¯¢å‘˜å·¥ä¿¡æ¯ select * from emp where dept_id in ( select id from dept where name = \u0026#39;é”€å”®éƒ¨\u0026#39; orname = \u0026#39;å¸‚åœºéƒ¨\u0026#39; ); -- æ¯” è´¢åŠ¡éƒ¨ æ‰€æœ‰äººå·¥èµ„éƒ½é«˜çš„å‘˜å·¥ä¿¡æ¯ select * from emp where salary \u0026gt; all ( select salary from emp where dept_id = (select id from dept where name = \u0026#39;è´¢åŠ¡éƒ¨\u0026#39;) ); -- æ¯”ç ”å‘éƒ¨å…¶ä¸­ä»»æ„ä¸€äººå·¥èµ„é«˜çš„å‘˜å·¥ä¿¡æ¯ select * from emp where salary \u0026gt; any ( select salary from emp where dept_id = (select id from dept where name = \u0026#39;ç ”å‘éƒ¨\u0026#39;) ); è¡Œå­æŸ¥è¯¢ å­æŸ¥è¯¢è¿”å›çš„ç»“æœæ˜¯ä¸€è¡Œï¼ˆå¯ä»¥æ˜¯å¤šåˆ—ï¼‰ï¼Œè¿™ç§å­æŸ¥è¯¢ç§°ä¸ºè¡Œå­æŸ¥è¯¢ã€‚ å¸¸ç”¨çš„æ“ä½œç¬¦ï¼š= ã€\u0026lt;\u0026gt; ã€IN ã€NOT INã€‚ select * from emp where (salary,managerid) = ( select salary, managerid from emp where name = \u0026#39;å¼ æ— å¿Œ\u0026#39; ); è¡¨å­æŸ¥è¯¢ å­æŸ¥è¯¢è¿”å›çš„ç»“æœæ˜¯å¤šè¡Œå¤šåˆ—ï¼Œè¿™ç§å­æŸ¥è¯¢ç§°ä¸ºè¡¨å­æŸ¥è¯¢ã€‚ å¸¸ç”¨çš„æ“ä½œç¬¦ï¼šIN select * from emp where (job,salary) in ( select job, salary from emp where name =\u0026#39;XS\u0026#39; or name = \u0026#39;DS\u0026#39; ); ","permalink":"https://heliu.site/posts/mysql/join/","summary":"mysql Join è¯­æ³•ã€‚","title":"mysql å¤šè¡¨æŸ¥è¯¢"},{"content":" äº‹åŠ¡ï¼šæ˜¯ä¸€ç»„æ“ä½œçš„é›†åˆï¼Œå®ƒæ˜¯ä¸€ä¸ªä¸å¯åˆ†å‰²çš„å·¥ä½œå•ä½ï¼Œäº‹åŠ¡ä¼šæŠŠæ‰€æœ‰çš„æ“ä½œä½œä¸ºä¸€ä¸ªæ•´ä½“ä¸€èµ·å‘ç³»ç»Ÿæäº¤æˆ–æ’¤é”€æ“ä½œè¯·æ±‚ï¼Œå³è¿™äº›æ“ä½œè¦ä¹ˆåŒæ—¶æˆåŠŸï¼Œè¦ä¹ˆåŒæ—¶å¤±è´¥ã€‚ é»˜è®¤MySQLçš„äº‹åŠ¡æ˜¯è‡ªåŠ¨æäº¤çš„ï¼Œä¹Ÿå°±æ˜¯è¯´ï¼Œå½“æ‰§è¡Œå®Œä¸€æ¡DMLè¯­å¥æ—¶ï¼ŒMySQLä¼šç«‹å³éšå¼çš„æäº¤äº‹åŠ¡ã€‚ æ§åˆ¶äº‹åŠ¡ æŸ¥çœ‹/è®¾ç½®äº‹åŠ¡æäº¤ã€‚ -- æŸ¥çœ‹äº‹åŠ¡è®¾ç½® SELECT @@autocommit; -- è®¾ç½®äº‹åŠ¡æäº¤è§„åˆ™ SET @@autocommit = 0 ; å¼€å¯äº‹åŠ¡ã€‚ START TRANSACTION; -- æˆ– BEGIN; æäº¤äº‹åŠ¡ã€‚ COMMIT; å›æ»šäº‹åŠ¡ã€‚ ROLLBACK; äº‹åŠ¡å››å¤§ç‰¹æ€§ åŸå­æ€§ï¼ˆAtomicityï¼‰ï¼šäº‹åŠ¡æ˜¯ä¸å¯åˆ†å‰²çš„æœ€å°æ“ä½œå•å…ƒï¼Œè¦ä¹ˆå…¨éƒ¨æˆåŠŸï¼Œè¦ä¹ˆå…¨éƒ¨å¤±è´¥ã€‚ ä¸€è‡´æ€§ï¼ˆConsistencyï¼‰ï¼šäº‹åŠ¡å®Œæˆæ—¶ï¼Œå¿…é¡»ä½¿æ‰€æœ‰çš„æ•°æ®éƒ½ä¿æŒä¸€è‡´çŠ¶æ€ã€‚ éš”ç¦»æ€§ï¼ˆIsolationï¼‰ï¼šæ•°æ®åº“ç³»ç»Ÿæä¾›çš„éš”ç¦»æœºåˆ¶ï¼Œä¿è¯äº‹åŠ¡åœ¨ä¸å—å¤–éƒ¨å¹¶å‘æ“ä½œå½±å“çš„ç‹¬ç«‹ç¯å¢ƒä¸‹è¿è¡Œã€‚ æŒä¹…æ€§ï¼ˆDurabilityï¼‰ï¼šäº‹åŠ¡ä¸€æ—¦æäº¤æˆ–å›æ»šï¼Œå®ƒå¯¹æ•°æ®åº“ä¸­çš„æ•°æ®çš„æ”¹å˜å°±æ˜¯æ°¸ä¹…çš„ã€‚ å¹¶å‘äº‹åŠ¡é—®é¢˜ èµƒè¯»ï¼šä¸€ä¸ªäº‹åŠ¡è¯»åˆ°å¦å¤–ä¸€ä¸ªäº‹åŠ¡è¿˜æ²¡æœ‰æäº¤çš„æ•°æ®ã€‚ ä¸å¯é‡å¤è¯»ï¼šä¸€ä¸ªäº‹åŠ¡å…ˆåè¯»å–åŒä¸€æ¡è®°å½•ï¼Œä½†ä¸¤æ¬¡è¯»å–çš„æ•°æ®ä¸åŒï¼Œç§°ä¹‹ä¸ºä¸å¯é‡å¤è¯»ã€‚ å¹»è¯»ï¼šä¸€ä¸ªäº‹åŠ¡æŒ‰ç…§æ¡ä»¶æŸ¥è¯¢æ•°æ®æ—¶ï¼Œæ²¡æœ‰å¯¹åº”çš„æ•°æ®è¡Œï¼Œä½†æ˜¯åœ¨æ’å…¥æ•°æ®æ—¶ï¼Œåˆå‘ç°è¿™è¡Œæ•°æ®å·²ç»å­˜åœ¨ï¼Œå¥½åƒå‡ºç°äº† \u0026ldquo;å¹»å½±\u0026rdquo;ã€‚ äº‹åŠ¡éš”ç¦»çº§åˆ« ä¸ºäº†è§£å†³å¹¶å‘äº‹åŠ¡æ‰€å¼•å‘çš„é—®é¢˜ï¼Œåœ¨æ•°æ®åº“ä¸­å¼•å…¥äº†äº‹åŠ¡éš”ç¦»çº§åˆ«ã€‚ \u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;éš”ç¦»çº§åˆ«\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash; è„è¯» ä¸å¯é‡å¤è¯» å¹»è¯» Read uncommitted âˆš âˆš âˆš Read committed Ã— âˆš âˆš Repeatable Read(é»˜è®¤) Ã— Ã— âˆš Serializable Ã— Ã— Ã— æŸ¥çœ‹äº‹åŠ¡éš”ç¦»çº§åˆ«ã€‚ SELECT @@TRANSACTION_ISOLATION; è®¾ç½®äº‹åŠ¡éš”ç¦»çº§åˆ«ã€‚ SET [ SESSION | GLOBAL ] TRANSACTION ISOLATION LEVEL { READ UNCOMMITTED | READ COMMITTED | REPEATABLE READ | SERIALIZABLE } ","permalink":"https://heliu.site/posts/mysql/transaction/","summary":"mysql äº‹åŠ¡ã€‚","title":"mysql äº‹åŠ¡"},{"content":"B+Tree æ‰€æœ‰çš„æ•°æ®éƒ½ä¼šå‡ºç°åœ¨å¶å­èŠ‚ç‚¹ã€‚ å¶å­èŠ‚ç‚¹å½¢æˆä¸€ä¸ªå•å‘é“¾è¡¨ã€‚ éå¶å­èŠ‚ç‚¹ä»…ä»…èµ·åˆ°ç´¢å¼•æ•°æ®ä½œç”¨ï¼Œå…·ä½“çš„æ•°æ®éƒ½æ˜¯åœ¨å¶å­èŠ‚ç‚¹å­˜æ”¾çš„ã€‚ MySQLç´¢å¼•æ•°æ®ç»“æ„å¯¹ç»å…¸çš„B+Treeè¿›è¡Œäº†ä¼˜åŒ–ã€‚åœ¨åŸB+Treeçš„åŸºç¡€ä¸Šï¼Œå¢åŠ ä¸€ä¸ªæŒ‡å‘ç›¸é‚»å¶å­èŠ‚ç‚¹ çš„é“¾è¡¨æŒ‡é’ˆï¼Œå°±å½¢æˆäº†å¸¦æœ‰é¡ºåºæŒ‡é’ˆçš„B+Treeï¼Œæé«˜åŒºé—´è®¿é—®çš„æ€§èƒ½ï¼Œåˆ©äºæ’åºã€‚ ç´¢å¼•åˆ†ç±» åœ¨MySQLæ•°æ®åº“ï¼Œå°†ç´¢å¼•çš„å…·ä½“ç±»å‹ä¸»è¦åˆ†ä¸ºä»¥ä¸‹å‡ ç±»ï¼šä¸»é”®ç´¢å¼•ã€å”¯ä¸€ç´¢å¼•ã€å¸¸è§„ç´¢å¼•ã€å…¨æ–‡ç´¢å¼•ã€‚ åˆ†ç±» å«ä¹‰ ç‰¹ç‚¹ å…³é”®å­— ä¸»é”®ç´¢å¼• é’ˆå¯¹äºè¡¨ä¸­ä¸»é”®åˆ›å»ºçš„ç´¢å¼• é»˜è®¤è‡ªåŠ¨åˆ›å»º, åªèƒ½æœ‰ä¸€ä¸ª PRIMARY å”¯ä¸€ç´¢å¼• é¿å…åŒä¸€ä¸ªè¡¨ä¸­æŸæ•°æ®åˆ—ä¸­çš„å€¼é‡å¤ å¯ä»¥æœ‰å¤šä¸ª UNIQUE å¸¸è§„ç´¢å¼• å¿«é€Ÿå®šä½ç‰¹å®šæ•°æ® å¯ä»¥æœ‰å¤šä¸ª å…¨æ–‡ç´¢å¼• å…¨æ–‡ç´¢å¼•æŸ¥æ‰¾çš„æ˜¯æ–‡æœ¬ä¸­çš„å…³é”®è¯ï¼Œè€Œä¸æ˜¯æ¯”è¾ƒç´¢å¼•ä¸­çš„å€¼ å¯ä»¥æœ‰å¤šä¸ª FULLTEXT è€Œåœ¨InnoDBå­˜å‚¨å¼•æ“ä¸­ï¼Œæ ¹æ®ç´¢å¼•çš„å­˜å‚¨å½¢å¼ï¼Œåˆå¯ä»¥åˆ†ä¸ºä»¥ä¸‹ä¸¤ç§ï¼š \u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;åˆ†ç±»\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash; å«ä¹‰ ç‰¹ç‚¹ èšé›†ç´¢å¼•(Clustered Index) å°†æ•°æ®å­˜å‚¨ä¸ç´¢å¼•æ”¾åˆ°äº†ä¸€å—ï¼Œç´¢å¼•ç»“æ„çš„å¶å­èŠ‚ç‚¹ä¿å­˜äº†è¡Œæ•°æ® å¿…é¡»æœ‰,è€Œä¸”åªæœ‰ä¸€ä¸ª äºŒçº§ç´¢å¼•(Secondary Index) å°†æ•°æ®ä¸ç´¢å¼•åˆ†å¼€å­˜å‚¨ï¼Œç´¢å¼•ç»“æ„çš„å¶å­èŠ‚ç‚¹å…³è”çš„æ˜¯å¯¹åº”çš„ä¸»é”® å¯ä»¥å­˜åœ¨å¤šä¸ª èšé›†ç´¢å¼•é€‰å–è§„åˆ™ï¼š å¦‚æœå­˜åœ¨ä¸»é”®ï¼Œä¸»é”®ç´¢å¼•å°±æ˜¯èšé›†ç´¢å¼•ã€‚ å¦‚æœä¸å­˜åœ¨ä¸»é”®ï¼Œå°†ä½¿ç”¨ç¬¬ä¸€ä¸ªå”¯ä¸€ï¼ˆUNIQUEï¼‰ç´¢å¼•ä½œä¸ºèšé›†ç´¢å¼•ã€‚ å¦‚æœè¡¨æ²¡æœ‰ä¸»é”®ï¼Œæˆ–æ²¡æœ‰åˆé€‚çš„å”¯ä¸€ç´¢å¼•ï¼Œåˆ™InnoDBä¼šè‡ªåŠ¨ç”Ÿæˆä¸€ä¸ªrowidä½œä¸ºéšè—çš„èšé›†ç´¢å¼•ã€‚ èšé›†ç´¢å¼•å’ŒäºŒçº§ç´¢å¼•çš„å…·ä½“ç»“æ„å¦‚ä¸‹ï¼š èšé›†ç´¢å¼•çš„å¶å­èŠ‚ç‚¹ä¸‹æŒ‚çš„æ˜¯è¿™ä¸€è¡Œçš„æ•°æ®ã€‚ äºŒçº§ç´¢å¼•çš„å¶å­èŠ‚ç‚¹ä¸‹æŒ‚çš„æ˜¯è¯¥å­—æ®µå€¼å¯¹åº”çš„ä¸»é”®å€¼ã€‚ InnoDBä¸»é”®ç´¢å¼•çš„B+treeé«˜åº¦ä¸ºå¤šé«˜å‘¢? ä¸€è¡Œæ•°æ®å¤§å°ä¸º1kï¼Œä¸€é¡µä¸­å¯ä»¥å­˜å‚¨16è¡Œè¿™æ ·çš„æ•°æ®ã€‚InnoDBçš„æŒ‡é’ˆå ç”¨6ä¸ªå­—èŠ‚çš„ç©ºé—´ï¼Œä¸»é”®å³ä½¿ä¸ºbigintï¼Œå ç”¨å­—èŠ‚æ•°ä¸º8ã€‚ å¦‚æœæ ‘çš„é«˜åº¦ä¸º2ï¼Œåˆ™å¯ä»¥å­˜å‚¨ 18000 å¤šæ¡è®°å½•ã€‚ å¦‚æœæ ‘çš„é«˜åº¦ä¸º3ï¼Œåˆ™å¯ä»¥å­˜å‚¨ 2200w å·¦å³çš„è®°å½•ã€‚ ç´¢å¼•è¯­æ³• åˆ›å»ºç´¢å¼•ã€‚ CREATE [ UNIQUE | FULLTEXT ] INDEX index_name ON table_name (index_col_name,... ); -- nameå­—æ®µä¸ºå§“åå­—æ®µï¼Œè¯¥å­—æ®µçš„å€¼å¯èƒ½ä¼šé‡å¤ï¼Œä¸ºè¯¥å­—æ®µåˆ›å»ºç´¢å¼•ã€‚ CREATE INDEX idx_user_name ON tb_user(name); -- phoneæ‰‹æœºå·å­—æ®µçš„å€¼ï¼Œæ˜¯éç©ºï¼Œä¸”å”¯ä¸€çš„ï¼Œä¸ºè¯¥å­—æ®µåˆ›å»ºå”¯ä¸€ç´¢å¼•ã€‚ CREATE UNIQUE INDEX idx_user_phone ON tb_user(phone); -- ä¸ºprofessionã€ageã€statusåˆ›å»ºè”åˆç´¢å¼•ã€‚ CREATE INDEX idx_user_pro_age_sta ON tb_user(profession,age,status); -- ä¸ºemailå»ºç«‹åˆé€‚çš„ç´¢å¼•æ¥æå‡æŸ¥è¯¢æ•ˆç‡ã€‚ CREATE INDEX idx_email ON tb_user(email); æŸ¥çœ‹ç´¢å¼•ã€‚ SHOW INDEX FROM table_name; åˆ é™¤ç´¢å¼•ã€‚ DROP INDEX index_name ON table_name; SQLæ€§èƒ½åˆ†æ SQLæ‰§è¡Œé¢‘ç‡ MySQL å®¢æˆ·ç«¯è¿æ¥æˆåŠŸåï¼Œé€šè¿‡ show [session|global] status å‘½ä»¤å¯ä»¥æä¾›æœåŠ¡å™¨çŠ¶æ€ä¿¡æ¯ã€‚ é€šè¿‡å¦‚ä¸‹æŒ‡ä»¤ï¼Œå¯ä»¥æŸ¥çœ‹å½“å‰æ•°æ®åº“çš„INSERTã€UPDATEã€DELETEã€SELECTçš„è®¿é—®é¢‘æ¬¡ï¼š -- session æ˜¯æŸ¥çœ‹å½“å‰ä¼šè¯; -- global æ˜¯æŸ¥è¯¢å…¨å±€æ•°æ®; SHOW GLOBAL STATUS LIKE \u0026#39;Com_______\u0026#39;; -- Com_delete: åˆ é™¤æ¬¡æ•° -- Com_insert: æ’å…¥æ¬¡æ•° -- Com_select: æŸ¥è¯¢æ¬¡æ•° -- Com_update: æ›´æ–°æ¬¡æ•° æ…¢æŸ¥è¯¢æ—¥å¿— æ…¢æŸ¥è¯¢æ—¥å¿—è®°å½•äº†æ‰€æœ‰æ‰§è¡Œæ—¶é—´è¶…è¿‡æŒ‡å®šå‚æ•°ï¼ˆlong_query_timeï¼Œå•ä½ï¼šç§’ï¼Œé»˜è®¤10ç§’ï¼‰çš„æ‰€æœ‰SQLè¯­å¥çš„æ—¥å¿—ã€‚ MySQLçš„æ…¢æŸ¥è¯¢æ—¥å¿—é»˜è®¤æ²¡æœ‰å¼€å¯ï¼Œæˆ‘ä»¬å¯ä»¥æŸ¥çœ‹ä¸€ä¸‹ç³»ç»Ÿå˜é‡ slow_query_logã€‚ show variables like \u0026#39;slow_query_log\u0026#39;; -- OFF-å…³é—­ ON-å¼€å¯ å¦‚æœè¦å¼€å¯æ…¢æŸ¥è¯¢æ—¥å¿—ï¼Œéœ€è¦åœ¨MySQLçš„é…ç½®æ–‡ä»¶ï¼ˆ/etc/my.cnfï¼‰ä¸­é…ç½®å¦‚ä¸‹ä¿¡æ¯ï¼š(é‡å¯mysql) # å¼€å¯MySQLæ…¢æ—¥å¿—æŸ¥è¯¢å¼€å…³ slow_query_log=1 # è®¾ç½®æ…¢æ—¥å¿—çš„æ—¶é—´ä¸º2ç§’ï¼ŒSQLè¯­å¥æ‰§è¡Œæ—¶é—´è¶…è¿‡2ç§’ï¼Œå°±ä¼šè§†ä¸ºæ…¢æŸ¥è¯¢ï¼Œè®°å½•æ…¢æŸ¥è¯¢æ—¥å¿— long_query_time=2 æ£€æŸ¥æ…¢æŸ¥è¯¢æ—¥å¿—ï¼šæ…¢æ—¥å¿—æ–‡ä»¶æ˜¯ localhost-slow.logã€‚ $ tail -f localhost-slow.log profileè¯¦æƒ… show profiles èƒ½å¤Ÿåœ¨åšSQLä¼˜åŒ–æ—¶å¸®åŠ©æˆ‘ä»¬äº†è§£æ—¶é—´éƒ½è€—è´¹åˆ°å“ªé‡Œå»äº†ã€‚ é€šè¿‡have_profilingå‚æ•°ï¼Œèƒ½å¤Ÿçœ‹åˆ°å½“å‰MySQLæ˜¯å¦æ”¯æŒprofileæ“ä½œã€‚ SELECT @@have_profiling; -- Yes-æ”¯æŒ SELECT @@profiling; -- 0-å…³é—­ -- å¼€å¯ï¼Œsession/globalçº§åˆ«å¼€å¯profiling SET profiling = 1; æŸ¥çœ‹æ¯ä¸€æ¡sqlè€—æ—¶æƒ…å†µï¼š -- æŸ¥çœ‹æ‰€æœ‰sql show profiles; -- æŸ¥çœ‹æŒ‡å®šsqlï¼ŒQuery_ID show profile for query 12; explain EXPLAIN æˆ–è€… DESCå‘½ä»¤è·å– MySQL å¦‚ä½•æ‰§è¡Œ SELECT è¯­å¥çš„ä¿¡æ¯ï¼ŒåŒ…æ‹¬åœ¨ SELECT è¯­å¥æ‰§è¡Œè¿‡ç¨‹ä¸­è¡¨å¦‚ä½•è¿æ¥å’Œè¿æ¥çš„é¡ºåºã€‚ -- ç›´æ¥åœ¨selectè¯­å¥ä¹‹å‰åŠ ä¸Šå…³é”®å­— explain / desc EXPLAIN SELECT å­—æ®µåˆ—è¡¨ FROM è¡¨å WHERE æ¡ä»¶ ; Explain æ‰§è¡Œè®¡åˆ’ä¸­å„ä¸ªå­—æ®µçš„å«ä¹‰: å­—æ®µ å«ä¹‰ id selectæŸ¥è¯¢çš„åºåˆ—å·ï¼Œè¡¨ç¤ºæŸ¥è¯¢ä¸­æ‰§è¡Œselectå­å¥æˆ–è€…æ˜¯æ“ä½œè¡¨çš„é¡ºåº(idç›¸åŒï¼Œæ‰§è¡Œé¡ºåºä»ä¸Šåˆ°ä¸‹ï¼›idä¸åŒï¼Œå€¼è¶Šå¤§ï¼Œè¶Šå…ˆæ‰§è¡Œ) select_type è¡¨ç¤º SELECT çš„ç±»å‹ï¼Œå¸¸è§çš„å–å€¼æœ‰ SIMPLEï¼ˆç®€å•è¡¨ï¼Œå³ä¸ä½¿ç”¨è¡¨è¿æ¥æˆ–è€…å­æŸ¥è¯¢ï¼‰ã€PRIMARYï¼ˆä¸»æŸ¥è¯¢ï¼Œå³å¤–å±‚çš„æŸ¥è¯¢ï¼‰ã€UNIONï¼ˆUNION ä¸­çš„ç¬¬äºŒä¸ªæˆ–è€…åé¢çš„æŸ¥è¯¢è¯­å¥ï¼‰ã€SUBQUERYï¼ˆSELECT/WHEREä¹‹ååŒ…å«äº†å­æŸ¥è¯¢ï¼‰ç­‰ type è¡¨ç¤ºè¿æ¥ç±»å‹ï¼Œæ€§èƒ½ç”±å¥½åˆ°å·®çš„è¿æ¥ç±»å‹ä¸ºNULLã€systemã€constã€eq_refã€refã€rangeã€indexã€all possible_key æ˜¾ç¤ºå¯èƒ½åº”ç”¨åœ¨è¿™å¼ è¡¨ä¸Šçš„ç´¢å¼•ï¼Œä¸€ä¸ªæˆ–å¤šä¸ª key å®é™…ä½¿ç”¨çš„ç´¢å¼•ï¼Œå¦‚æœä¸ºNULLï¼Œåˆ™æ²¡æœ‰ä½¿ç”¨ç´¢å¼• key_len è¡¨ç¤ºç´¢å¼•ä¸­ä½¿ç”¨çš„å­—èŠ‚æ•°ï¼Œè¯¥å€¼ä¸ºç´¢å¼•å­—æ®µæœ€å¤§å¯èƒ½é•¿åº¦ï¼Œå¹¶éå®é™…ä½¿ç”¨é•¿åº¦ï¼Œåœ¨ä¸æŸå¤±ç²¾ç¡®æ€§çš„å‰æä¸‹ï¼Œé•¿åº¦è¶ŠçŸ­è¶Šå¥½ rows MySQLè®¤ä¸ºå¿…é¡»è¦æ‰§è¡ŒæŸ¥è¯¢çš„è¡Œæ•°ï¼Œåœ¨innodbå¼•æ“çš„è¡¨ä¸­ï¼Œæ˜¯ä¸€ä¸ªä¼°è®¡å€¼ï¼Œå¯èƒ½å¹¶ä¸æ€»æ˜¯å‡†ç¡®çš„ filtered è¡¨ç¤ºè¿”å›ç»“æœçš„è¡Œæ•°å éœ€è¯»å–è¡Œæ•°çš„ç™¾åˆ†æ¯”ï¼Œ filteredçš„å€¼è¶Šå¤§è¶Šå¥½ ç´¢å¼•ä½¿ç”¨ æœ€å·¦å‰ç¼€æ³•åˆ™ å¦‚æœç´¢å¼•äº†å¤šåˆ—ï¼ˆè”åˆç´¢å¼•ï¼‰ï¼Œè¦éµå®ˆæœ€å·¦å‰ç¼€æ³•åˆ™ã€‚ æœ€å·¦å‰ç¼€æ³•åˆ™æŒ‡çš„æ˜¯æŸ¥è¯¢ä»ç´¢å¼•çš„æœ€å·¦åˆ—å¼€å§‹ï¼Œå¹¶ä¸”ä¸è·³è¿‡ç´¢å¼•ä¸­çš„åˆ—ã€‚ å¦‚æœè·³è·ƒæŸä¸€åˆ—ï¼Œç´¢å¼•å°†ä¼šéƒ¨åˆ†å¤±æ•ˆ(åé¢çš„å­—æ®µç´¢å¼•å¤±æ•ˆ)ã€‚ æ³¨æ„ï¼šæœ€å·¦å‰ç¼€æ³•åˆ™ä¸­æŒ‡çš„æœ€å·¦è¾¹çš„åˆ—ï¼Œæ˜¯æŒ‡åœ¨æŸ¥è¯¢æ—¶ï¼Œè”åˆç´¢å¼•çš„æœ€å·¦è¾¹çš„å­—æ®µ(å³æ˜¯ç¬¬ä¸€ä¸ªå­—æ®µ)å¿…é¡»å­˜åœ¨ï¼Œä¸æˆ‘ä»¬ç¼–å†™SQLæ—¶ï¼Œæ¡ä»¶ç¼–å†™çš„å…ˆåé¡ºåºæ— å…³ã€‚ èŒƒå›´æŸ¥è¯¢ è”åˆç´¢å¼•ä¸­ï¼Œå‡ºç°èŒƒå›´æŸ¥è¯¢(\u0026gt;,\u0026lt;)ï¼ŒèŒƒå›´æŸ¥è¯¢å³ä¾§çš„åˆ—ç´¢å¼•å¤±æ•ˆã€‚ -- tb_user è¡¨å­˜åœ¨è”åˆç´¢å¼• (profession, age, status) -- ä¸‹é¢sqlä¸­ageä½¿ç”¨äº†\u0026gt;ç¬¦å·å¯¼è‡´statusç´¢å¼•å¤±æ•ˆï¼Œä½†æ˜¯profession, ageç´¢å¼•è¿˜æ˜¯æœ‰ç”¨ explain select * from tb_user where profession = \u0026#39;è½¯ä»¶å·¥ç¨‹\u0026#39; and age \u0026gt; 30 and status = \u0026#39;0\u0026#39;; åœ¨ä¸šåŠ¡å…è®¸çš„æƒ…å†µä¸‹ï¼Œå°½å¯èƒ½çš„ä½¿ç”¨ç±»ä¼¼äº \u0026gt;= æˆ– \u0026lt;= è¿™ç±»çš„èŒƒå›´æŸ¥è¯¢ï¼Œè€Œé¿å…ä½¿ç”¨ \u0026gt; æˆ– \u0026lt;ã€‚ -- è¿™ç§æƒ…å†µä¸‹ï¼Œæ‰€æœ‰ç´¢å¼•éƒ½ç”Ÿæ•ˆäº† explain select * from tb_user where profession = \u0026#39;è½¯ä»¶å·¥ç¨‹\u0026#39; and age \u0026gt;= 30 and status = \u0026#39;0\u0026#39;; ç´¢å¼•å¤±æ•ˆ ç´¢å¼•åˆ—è¿ç®— ä¸è¦åœ¨ç´¢å¼•åˆ—ä¸Šè¿›è¡Œè¿ç®—æ“ä½œï¼Œç´¢å¼•å°†å¤±æ•ˆã€‚ -- tb_userè¡¨phoneæ˜¯å•å­—æ®µç´¢å¼•ï¼Œå› ä¸ºä½¿ç”¨äº†å‡½æ•°å¯¼è‡´å¤±æ•ˆ explain select * from tb_user where substring(phone,10,2) = \u0026#39;15\u0026#39;; å­—ç¬¦ä¸²ä¸åŠ å¼•å· å­—ç¬¦ä¸²ç±»å‹å­—æ®µä½¿ç”¨æ—¶ï¼Œä¸åŠ å¼•å·ï¼Œç´¢å¼•å°†å¤±æ•ˆã€‚ å¦‚æœå­—ç¬¦ä¸²ä¸åŠ å•å¼•å·ï¼Œå¯¹äºæŸ¥è¯¢ç»“æœï¼Œæ²¡ä»€ä¹ˆå½±å“ï¼Œä½†æ˜¯æ•°æ®åº“å­˜åœ¨éšå¼ç±»å‹è½¬æ¢ï¼Œç´¢å¼•å°†å¤±æ•ˆã€‚ -- tb_userè¡¨phoneæ˜¯å•å­—æ®µç´¢å¼•ï¼Œç±»å‹æ˜¯varchar explain select * from tb_user where phone = \u0026#39;17799990015\u0026#39;; -- æ²¡åŠ å¼•å·ï¼Œç´¢å¼•å¤±æ•ˆ explain select * from tb_user where phone = 17799990015; æ¨¡ç³ŠæŸ¥è¯¢ å¦‚æœä»…ä»…æ˜¯å°¾éƒ¨æ¨¡ç³ŠåŒ¹é…ï¼Œç´¢å¼•ä¸ä¼šå¤±æ•ˆã€‚å¦‚æœæ˜¯å¤´éƒ¨æ¨¡ç³ŠåŒ¹é…ï¼Œç´¢å¼•å¤±æ•ˆã€‚ -- profession ç´¢å¼•ç”Ÿæ•ˆ explain select * from tb_user where profession like \u0026#39;è½¯ä»¶%\u0026#39;; -- profession ç´¢å¼•å¤±æ•ˆ explain select * from tb_user where profession like \u0026#39;%å·¥ç¨‹\u0026#39;; -- profession ç´¢å¼•å¤±æ•ˆ explain select * from tb_user where profession like \u0026#39;%å·¥%\u0026#39;; orè¿æ¥æ¡ä»¶ ç”¨oråˆ†å‰²å¼€çš„æ¡ä»¶ï¼Œ å¦‚æœorå‰çš„æ¡ä»¶ä¸­çš„åˆ—æœ‰ç´¢å¼•ï¼Œè€Œåé¢çš„åˆ—ä¸­æ²¡æœ‰ç´¢å¼•ï¼Œé‚£ä¹ˆæ¶‰åŠçš„ç´¢å¼•éƒ½ä¸ä¼šè¢«ç”¨åˆ°ã€‚ å½“orè¿æ¥çš„æ¡ä»¶ï¼Œå·¦å³ä¸¤ä¾§å­—æ®µéƒ½æœ‰ç´¢å¼•æ—¶ï¼Œç´¢å¼•æ‰ä¼šç”Ÿæ•ˆã€‚ -- idæ˜¯ä¸»é”®ï¼Œageæ²¡æœ‰ç´¢å¼•ï¼Œè¯¥sqlä¸ä¼šä½¿ç”¨ä»»ä½•ç´¢å¼• explain select * from tb_user where id = 10 or age = 23; -- phoneæ˜¯æ™®é€šç´¢å¼•ï¼Œageæ²¡æœ‰ç´¢å¼•ï¼Œè¯¥sqlä¸ä¼šä½¿ç”¨ä»»ä½•ç´¢å¼• explain select * from tb_user where phone = \u0026#39;17799990017\u0026#39; or age = 23; æ•°æ®åˆ†å¸ƒå½±å“ å¦‚æœMySQLè¯„ä¼°ä½¿ç”¨ç´¢å¼•æ¯”å…¨è¡¨æ›´æ…¢ï¼Œåˆ™ä¸ä½¿ç”¨ç´¢å¼•ã€‚ -- ä¸ä¼šä½¿ç”¨ phone ç´¢å¼•ï¼Œå› ä¸ºå…¨è¡¨æ‰«ææ›´å¿« select * from tb_user where phone \u0026gt;= \u0026#39;17799990005\u0026#39;; -- ä¼šä½¿ç”¨ phone ç´¢å¼• select * from tb_user where phone \u0026gt;= \u0026#39;17799990015\u0026#39;; å› ä¸ºMySQLåœ¨æŸ¥è¯¢æ—¶ï¼Œä¼šè¯„ä¼°ä½¿ç”¨ç´¢å¼•çš„æ•ˆç‡ä¸èµ°å…¨è¡¨æ‰«æçš„æ•ˆç‡ï¼Œå¦‚æœèµ°å…¨è¡¨æ‰«ææ›´å¿«ï¼Œåˆ™æ”¾å¼ƒç´¢å¼•ï¼Œèµ°å…¨è¡¨æ‰«æã€‚ å› ä¸ºç´¢å¼•æ˜¯ç”¨æ¥ç´¢å¼•å°‘é‡æ•°æ®çš„ï¼Œå¦‚æœé€šè¿‡ç´¢å¼•æŸ¥è¯¢è¿”å›å¤§æ‰¹é‡çš„æ•°æ®ï¼Œåˆ™è¿˜ä¸å¦‚èµ°å…¨è¡¨æ‰«ææ¥çš„å¿«ï¼Œæ­¤æ—¶ç´¢å¼•å°±ä¼šå¤±æ•ˆã€‚ is null ä¸ is not null æ“ä½œæ˜¯å¦èµ°ç´¢å¼•ï¼Ÿ æŸ¥è¯¢æ—¶MySQLä¼šè¯„ä¼°ï¼Œèµ°ç´¢å¼•å¿«ï¼Œè¿˜æ˜¯å…¨è¡¨æ‰«æå¿«ï¼Œå¦‚æœå…¨è¡¨æ‰«ææ›´å¿«ï¼Œåˆ™æ”¾å¼ƒç´¢å¼•èµ°å…¨è¡¨æ‰«æã€‚ å› æ­¤ï¼Œis null ã€is not nullæ˜¯å¦èµ°ç´¢å¼•ï¼Œå¾—å…·ä½“æƒ…å†µå…·ä½“åˆ†æï¼Œå¹¶ä¸æ˜¯å›ºå®šçš„ã€‚ explain select * from tb_user where profession is null; explain select * from tb_user where profession is not null; SQLæç¤º SQLæç¤ºï¼Œæ˜¯ä¼˜åŒ–æ•°æ®åº“çš„ä¸€ä¸ªé‡è¦æ‰‹æ®µï¼Œç®€å•æ¥è¯´ï¼Œå°±æ˜¯åœ¨SQLè¯­å¥ä¸­åŠ å…¥ä¸€äº›äººä¸ºçš„æç¤ºæ¥è¾¾åˆ°ä¼˜åŒ–æ“ä½œçš„ç›®çš„ã€‚ use index ï¼š å»ºè®®MySQLä½¿ç”¨å“ªä¸€ä¸ªç´¢å¼•å®Œæˆæ­¤æ¬¡æŸ¥è¯¢ï¼ˆä»…ä»…æ˜¯å»ºè®®ï¼Œmysqlå†…éƒ¨è¿˜ä¼šå†æ¬¡è¿›è¡Œè¯„ä¼°ï¼‰ã€‚ explain select * from tb_user use index(idx_user_pro) where profession = \u0026#39;xsss\u0026#39;; ignore indexï¼šå¿½ç•¥æŒ‡å®šçš„ç´¢å¼•ã€‚ explain select * from tb_user ignore index(idx_user_pro) where profession = \u0026#39;xsss\u0026#39;; force indexï¼šå¼ºåˆ¶ä½¿ç”¨ç´¢å¼•ã€‚ explain select * from tb_user force index(idx_user_pro) where profession = \u0026#39;xsss\u0026#39;; è¦†ç›–ç´¢å¼• è¦†ç›–ç´¢å¼•æ˜¯æŒ‡æŸ¥è¯¢ä½¿ç”¨äº†ç´¢å¼•ï¼Œå¹¶ä¸”éœ€è¦è¿”å›çš„åˆ—ï¼Œåœ¨è¯¥ç´¢å¼•ä¸­å·²ç»å…¨éƒ¨èƒ½å¤Ÿæ‰¾åˆ°ã€‚ å°½é‡ä½¿ç”¨è¦†ç›–ç´¢å¼•ï¼Œå‡å°‘select *ã€‚ ä¸€å¼ è¡¨, æœ‰å››ä¸ªå­—æ®µ(id, username, password, status), ç”±äºæ•°æ®é‡å¤§, éœ€è¦å¯¹ä»¥ä¸‹SQLè¯­å¥è¿›è¡Œä¼˜åŒ–, è¯¥å¦‚ä½•è¿›è¡Œæ‰æ˜¯æœ€ä¼˜æ–¹æ¡ˆ: -- é’ˆå¯¹äº username, passwordå»ºç«‹è”åˆç´¢å¼• -- sqlä¸º: create index idx_user_name_pass on tb_user(username,password); select id,username,password from tb_user where username =\u0026#39;st\u0026#39;; å‰ç¼€ç´¢å¼• å½“å­—æ®µç±»å‹ä¸ºå­—ç¬¦ä¸²ï¼ˆvarcharï¼Œtextï¼Œlongtextç­‰ï¼‰æ—¶ï¼Œæœ‰æ—¶å€™éœ€è¦ç´¢å¼•å¾ˆé•¿çš„å­—ç¬¦ä¸²ï¼Œè¿™ä¼šè®©ç´¢å¼•å˜å¾—å¾ˆå¤§ï¼ŒæŸ¥è¯¢æ—¶ï¼Œæµªè´¹å¤§é‡çš„ç£ç›˜IOï¼Œ å½±å“æŸ¥è¯¢æ•ˆç‡ã€‚ æ­¤æ—¶å¯ä»¥åªå°†å­—ç¬¦ä¸²çš„ä¸€éƒ¨åˆ†å‰ç¼€ï¼Œå»ºç«‹ç´¢å¼•ï¼Œè¿™æ ·å¯ä»¥å¤§å¤§èŠ‚çº¦ç´¢å¼•ç©ºé—´ï¼Œä»è€Œæé«˜ç´¢å¼•æ•ˆç‡ã€‚ create index idx_xxxx on table_name(column(n)); -- ä¸ºtb_userè¡¨çš„emailå­—æ®µï¼Œå»ºç«‹é•¿åº¦ä¸º5çš„å‰ç¼€ç´¢å¼• create index idx_email_5 on tb_user(email(5)); å‰ç¼€é•¿åº¦ï¼Œå¯ä»¥æ ¹æ®ç´¢å¼•çš„é€‰æ‹©æ€§æ¥å†³å®šï¼Œè€Œé€‰æ‹©æ€§æ˜¯æŒ‡ä¸é‡å¤çš„ç´¢å¼•å€¼ï¼ˆåŸºæ•°ï¼‰å’Œæ•°æ®è¡¨çš„è®°å½•æ€»æ•°çš„æ¯”å€¼ï¼Œç´¢å¼•é€‰æ‹©æ€§è¶Šé«˜åˆ™æŸ¥è¯¢æ•ˆç‡è¶Šé«˜ï¼Œ å”¯ä¸€ç´¢å¼•çš„é€‰æ‹©æ€§æ˜¯1ï¼Œè¿™æ˜¯æœ€å¥½çš„ç´¢å¼•é€‰æ‹©æ€§ï¼Œæ€§èƒ½ä¹Ÿæ˜¯æœ€å¥½çš„ã€‚ select count(distinct email) / count(*) from tb_user ; select count(distinct substring(email,1,5)) / count(*) from tb_user ; å•åˆ—ç´¢å¼•ä¸è”åˆç´¢å¼• å•åˆ—ç´¢å¼•ï¼šå³ä¸€ä¸ªç´¢å¼•åªåŒ…å«å•ä¸ªåˆ—ã€‚æŸ¥è¯¢æ¡ä»¶ä¸­æœ‰å¤šä¸ªå•åˆ—ç´¢å¼•åªä¼šé€‰æ‹©ä¸€ä¸ªã€‚ è”åˆç´¢å¼•ï¼šå³ä¸€ä¸ªç´¢å¼•åŒ…å«äº†å¤šä¸ªåˆ—ã€‚ åœ¨ä¸šåŠ¡åœºæ™¯ä¸­ï¼Œå¦‚æœå­˜åœ¨å¤šä¸ªæŸ¥è¯¢æ¡ä»¶ï¼Œè€ƒè™‘é’ˆå¯¹äºæŸ¥è¯¢å­—æ®µå»ºç«‹ç´¢å¼•æ—¶ï¼Œå»ºè®®å»ºç«‹è”åˆç´¢å¼•ï¼Œè€Œéå•åˆ—ç´¢å¼•ã€‚ ç´¢å¼•è®¾è®¡åŸåˆ™ é’ˆå¯¹äºæ•°æ®é‡è¾ƒå¤§ï¼Œä¸”æŸ¥è¯¢æ¯”è¾ƒé¢‘ç¹çš„è¡¨å»ºç«‹ç´¢å¼•ã€‚ é’ˆå¯¹äºå¸¸ä½œä¸ºæŸ¥è¯¢æ¡ä»¶ï¼ˆwhereï¼‰ã€æ’åºï¼ˆorder byï¼‰ã€åˆ†ç»„ï¼ˆgroup byï¼‰æ“ä½œçš„å­—æ®µå»ºç«‹ç´¢å¼•ã€‚ å°½é‡é€‰æ‹©åŒºåˆ†åº¦é«˜çš„åˆ—ä½œä¸ºç´¢å¼•ï¼Œå°½é‡å»ºç«‹å”¯ä¸€ç´¢å¼•ï¼ŒåŒºåˆ†åº¦è¶Šé«˜ï¼Œä½¿ç”¨ç´¢å¼•çš„æ•ˆç‡è¶Šé«˜ã€‚ å¦‚æœæ˜¯å­—ç¬¦ä¸²ç±»å‹çš„å­—æ®µï¼Œå­—æ®µçš„é•¿åº¦è¾ƒé•¿ï¼Œå¯ä»¥é’ˆå¯¹äºå­—æ®µçš„ç‰¹ç‚¹ï¼Œå»ºç«‹å‰ç¼€ç´¢å¼•ã€‚ å°½é‡ä½¿ç”¨è”åˆç´¢å¼•ï¼Œå‡å°‘å•åˆ—ç´¢å¼•ï¼ŒæŸ¥è¯¢æ—¶ï¼Œè”åˆç´¢å¼•å¾ˆå¤šæ—¶å€™å¯ä»¥è¦†ç›–ç´¢å¼•ï¼ŒèŠ‚çœå­˜å‚¨ç©ºé—´ï¼Œé¿å…å›è¡¨ï¼Œæé«˜æŸ¥è¯¢æ•ˆç‡ã€‚ è¦æ§åˆ¶ç´¢å¼•çš„æ•°é‡ï¼Œç´¢å¼•å¹¶ä¸æ˜¯å¤šå¤šç›Šå–„ï¼Œç´¢å¼•è¶Šå¤šï¼Œç»´æŠ¤ç´¢å¼•ç»“æ„çš„ä»£ä»·ä¹Ÿå°±è¶Šå¤§ï¼Œä¼šå½±å“å¢åˆ æ”¹çš„æ•ˆç‡ã€‚ å¦‚æœç´¢å¼•åˆ—ä¸èƒ½å­˜å‚¨NULLå€¼ï¼Œè¯·åœ¨åˆ›å»ºè¡¨æ—¶ä½¿ç”¨NOT NULLçº¦æŸå®ƒã€‚å½“ä¼˜åŒ–å™¨çŸ¥é“æ¯åˆ—æ˜¯å¦åŒ…å«NULLå€¼æ—¶ï¼Œå®ƒå¯ä»¥æ›´å¥½åœ°ç¡®å®šå“ªä¸ªç´¢å¼•æœ€æœ‰æ•ˆåœ°ç”¨äºæŸ¥è¯¢ã€‚ ","permalink":"https://heliu.site/posts/mysql/tree/","summary":"mysql B+Treeã€‚","title":"mysql ç´¢å¼•"},{"content":"æ’å…¥æ•°æ® insert å¦‚æœæˆ‘ä»¬éœ€è¦ä¸€æ¬¡æ€§å¾€æ•°æ®åº“è¡¨ä¸­æ’å…¥å¤šæ¡è®°å½•ï¼Œå¯ä»¥ä»ä»¥ä¸‹ä¸‰ä¸ªæ–¹é¢è¿›è¡Œä¼˜åŒ–ã€‚ insert into tb_test values(1,\u0026#39;t\u0026#39;); insert into tb_test values(2,\u0026#39;c\u0026#39;); insert into tb_test values(3,\u0026#39;j\u0026#39;); -- ..... ä¼˜åŒ–æ–¹æ¡ˆä¸€ï¼šæ‰¹é‡æ’å…¥æ•°æ® Insert into tb_test values(1,\u0026#39;t\u0026#39;),(2,\u0026#39;c\u0026#39;),(3,\u0026#39;j\u0026#39;); ä¼˜åŒ–æ–¹æ¡ˆäºŒï¼šæ‰‹åŠ¨æ§åˆ¶äº‹åŠ¡ start transaction; insert into tb_test values(1,\u0026#39;t\u0026#39;),(2,\u0026#39;c\u0026#39;),(3,\u0026#39;j\u0026#39;); insert into tb_test values(4,\u0026#39;t\u0026#39;),(5,\u0026#39;c\u0026#39;),(6,\u0026#39;j\u0026#39;); insert into tb_test values(7,\u0026#39;t\u0026#39;),(8,\u0026#39;c\u0026#39;),(9,\u0026#39;j\u0026#39;); commit; ä¼˜åŒ–æ–¹æ¡ˆä¸‰ï¼šä¸»é”®é¡ºåºæ’å…¥ï¼Œæ€§èƒ½è¦é«˜äºä¹±åºæ’å…¥ ä¸»é”®ä¹±åºæ’å…¥: 8 1 9 21 88 2 4 15 89 5 7 3 ä¸»é”®é¡ºåºæ’å…¥: 1 2 3 4 5 7 8 9 15 21 88 89 å¤§æ‰¹é‡æ’å…¥æ•°æ® å¦‚æœä¸€æ¬¡æ€§éœ€è¦æ’å…¥å¤§æ‰¹é‡æ•°æ®(æ¯”å¦‚: å‡ ç™¾ä¸‡çš„è®°å½•)ï¼Œä½¿ç”¨insertè¯­å¥æ’å…¥æ€§èƒ½è¾ƒä½ï¼Œæ­¤æ—¶å¯ä»¥ä½¿ç”¨MySQLæ•°æ®åº“æä¾›çš„loadæŒ‡ä»¤è¿›è¡Œæ’å…¥ã€‚ å¯ä»¥æ‰§è¡Œå¦‚ä¸‹æŒ‡ä»¤ï¼Œå°†æ•°æ®è„šæœ¬æ–‡ä»¶ä¸­çš„æ•°æ®åŠ è½½åˆ°è¡¨ç»“æ„ä¸­ï¼š -- å®¢æˆ·ç«¯è¿æ¥æœåŠ¡ç«¯æ—¶ï¼ŒåŠ ä¸Šå‚æ•° -â€“local-infile mysql â€“-local-infile -u root -p -- è®¾ç½®å…¨å±€å‚æ•°local_infileä¸º1ï¼Œå¼€å¯ä»æœ¬åœ°åŠ è½½æ–‡ä»¶å¯¼å…¥æ•°æ®çš„å¼€å…³ set global local_infile = 1; -- æ‰§è¡ŒloadæŒ‡ä»¤å°†å‡†å¤‡å¥½çš„æ•°æ®ï¼ŒåŠ è½½åˆ°è¡¨ç»“æ„ä¸­ load data local infile \u0026#39;/root/sql1.log\u0026#39; into table tb_user fields terminated by \u0026#39;,\u0026#39; lines terminated by \u0026#39;\\n\u0026#39; ; ä¸»é”®ä¼˜åŒ– æ»¡è¶³ä¸šåŠ¡éœ€æ±‚çš„æƒ…å†µä¸‹ï¼Œå°½é‡é™ä½ä¸»é”®çš„é•¿åº¦ã€‚ æ’å…¥æ•°æ®æ—¶ï¼Œå°½é‡é€‰æ‹©é¡ºåºæ’å…¥ï¼Œé€‰æ‹©ä½¿ç”¨AUTO_INCREMENTè‡ªå¢ä¸»é”®ã€‚ å°½é‡ä¸è¦ä½¿ç”¨UUIDåšä¸»é”®æˆ–è€…æ˜¯å…¶ä»–è‡ªç„¶ä¸»é”®ï¼Œå¦‚èº«ä»½è¯å·ã€‚ ä¸šåŠ¡æ“ä½œæ—¶ï¼Œé¿å…å¯¹ä¸»é”®çš„ä¿®æ”¹ã€‚ order byä¼˜åŒ– MySQLçš„æ’åºï¼Œæœ‰ä¸¤ç§æ–¹å¼ï¼š Using filesort: é€šè¿‡è¡¨çš„ç´¢å¼•æˆ–å…¨è¡¨æ‰«æï¼Œè¯»å–æ»¡è¶³æ¡ä»¶çš„æ•°æ®è¡Œï¼Œç„¶ååœ¨æ’åºç¼“å†²åŒºsort bufferä¸­å®Œæˆæ’åºæ“ä½œï¼Œæ‰€æœ‰ä¸æ˜¯é€šè¿‡ç´¢å¼•ç›´æ¥è¿”å›æ’åºç»“æœçš„æ’åºéƒ½å« FileSort æ’åºã€‚ Using index: é€šè¿‡æœ‰åºç´¢å¼•é¡ºåºæ‰«æç›´æ¥è¿”å›æœ‰åºæ•°æ®ï¼Œè¿™ç§æƒ…å†µå³ä¸º using indexï¼Œä¸éœ€è¦é¢å¤–æ’åºï¼Œæ“ä½œæ•ˆç‡é«˜ã€‚ å¯¹äºä»¥ä¸Šçš„ä¸¤ç§æ’åºæ–¹å¼ï¼ŒUsing indexçš„æ€§èƒ½é«˜ï¼Œè€ŒUsing filesortçš„æ€§èƒ½ä½ï¼Œæˆ‘ä»¬åœ¨ä¼˜åŒ–æ’åºæ“ä½œæ—¶ï¼Œå°½é‡è¦ä¼˜åŒ–ä¸º Using indexã€‚ order byä¼˜åŒ–åŸåˆ™ï¼š æ ¹æ®æ’åºå­—æ®µå»ºç«‹åˆé€‚çš„ç´¢å¼•ï¼Œå¤šå­—æ®µæ’åºæ—¶ï¼Œä¹Ÿéµå¾ªæœ€å·¦å‰ç¼€æ³•åˆ™ã€‚ å°½é‡ä½¿ç”¨è¦†ç›–ç´¢å¼•ã€‚ å¤šå­—æ®µæ’åº, ä¸€ä¸ªå‡åºä¸€ä¸ªé™åºï¼Œæ­¤æ—¶éœ€è¦æ³¨æ„è”åˆç´¢å¼•åœ¨åˆ›å»ºæ—¶çš„è§„åˆ™ï¼ˆASC/DESCï¼‰ã€‚ å¦‚æœä¸å¯é¿å…çš„å‡ºç°filesortï¼Œå¤§æ•°æ®é‡æ’åºæ—¶ï¼Œå¯ä»¥é€‚å½“å¢å¤§æ’åºç¼“å†²åŒºå¤§å°sort_buffer_size(é»˜è®¤256k)ã€‚ group byä¼˜åŒ– åœ¨åˆ†ç»„æ“ä½œæ—¶ï¼Œå¯ä»¥é€šè¿‡ç´¢å¼•æ¥æé«˜æ•ˆç‡ã€‚ åˆ†ç»„æ“ä½œæ—¶ï¼Œç´¢å¼•çš„ä½¿ç”¨ä¹Ÿæ˜¯æ»¡è¶³æœ€å·¦å‰ç¼€æ³•åˆ™çš„ã€‚ limitä¼˜åŒ– åœ¨æ•°æ®é‡æ¯”è¾ƒå¤§æ—¶ï¼Œå¦‚æœè¿›è¡Œlimitåˆ†é¡µæŸ¥è¯¢ï¼Œåœ¨æŸ¥è¯¢æ—¶ï¼Œè¶Šå¾€åï¼Œåˆ†é¡µæŸ¥è¯¢æ•ˆç‡è¶Šä½ã€‚ å½“åœ¨è¿›è¡Œåˆ†é¡µæŸ¥è¯¢æ—¶ï¼Œå¦‚æœæ‰§è¡Œ limit 2000000,10 ï¼Œæ­¤æ—¶éœ€è¦MySQLæ’åºå‰2000010 è®°å½•ï¼Œä»…ä»…è¿”å› 2000000 - 2000010 çš„è®°å½•ï¼Œå…¶ä»–è®°å½•ä¸¢å¼ƒï¼ŒæŸ¥è¯¢æ’åºçš„ä»£ä»·éå¸¸å¤§ã€‚ ä¸€èˆ¬åˆ†é¡µæŸ¥è¯¢æ—¶ï¼Œé€šè¿‡åˆ›å»º è¦†ç›–ç´¢å¼• èƒ½å¤Ÿæ¯”è¾ƒå¥½åœ°æé«˜æ€§èƒ½ï¼Œå¯ä»¥é€šè¿‡è¦†ç›–ç´¢å¼•åŠ å­æŸ¥è¯¢å½¢å¼è¿›è¡Œä¼˜åŒ–ã€‚ explain select * from tb_sku t , ( select id from tb_sku order by id limit 2000000,10 ) a where t.id = a.id; countä¼˜åŒ– å¦‚æœæ•°æ®é‡å¾ˆå¤§ï¼Œåœ¨æ‰§è¡Œcountæ“ä½œæ—¶ï¼Œæ˜¯éå¸¸è€—æ—¶çš„ã€‚ MyISAM å¼•æ“æŠŠä¸€ä¸ªè¡¨çš„æ€»è¡Œæ•°å­˜åœ¨äº†ç£ç›˜ä¸Šï¼Œå› æ­¤æ‰§è¡Œ count(*) çš„æ—¶å€™ä¼šç›´æ¥è¿”å›è¿™ä¸ªæ•°ï¼Œæ•ˆç‡å¾ˆé«˜ï¼›ä½†æ˜¯å¦‚æœæ˜¯å¸¦æ¡ä»¶çš„countï¼ŒMyISAMä¹Ÿæ…¢ã€‚ InnoDB å¼•æ“å°±éº»çƒ¦äº†ï¼Œå®ƒæ‰§è¡Œ count(*) çš„æ—¶å€™ï¼Œéœ€è¦æŠŠæ•°æ®ä¸€è¡Œä¸€è¡Œåœ°ä»å¼•æ“é‡Œé¢è¯»å‡ºæ¥ï¼Œç„¶åç´¯ç§¯è®¡æ•°ã€‚ select count(*) from tb_user; countç”¨æ³• count() æ˜¯ä¸€ä¸ªèšåˆå‡½æ•°ï¼Œå¯¹äºè¿”å›çš„ç»“æœé›†ï¼Œä¸€è¡Œè¡Œåœ°åˆ¤æ–­ï¼Œå¦‚æœ count å‡½æ•°çš„å‚æ•°ä¸æ˜¯NULLï¼Œç´¯è®¡å€¼å°±åŠ  1ï¼Œå¦åˆ™ä¸åŠ ï¼Œæœ€åè¿”å›ç´¯è®¡å€¼ã€‚ countç”¨æ³• å«ä¹‰ count(ä¸»é”®) InnoDB å¼•æ“ä¼šéå†æ•´å¼ è¡¨ï¼ŒæŠŠæ¯ä¸€è¡Œçš„ä¸»é”®id å€¼éƒ½å–å‡ºæ¥ï¼Œè¿”å›ç»™æœåŠ¡å±‚ã€‚æœåŠ¡å±‚æ‹¿åˆ°ä¸»é”®åï¼Œç›´æ¥æŒ‰è¡Œè¿›è¡Œç´¯åŠ (ä¸»é”®ä¸å¯èƒ½ä¸ºnull) count(å­—æ®µ) æ²¡æœ‰not nullçº¦æŸ: InnoDBå¼•æ“ä¼šéå†æ•´å¼ è¡¨æŠŠæ¯ä¸€è¡Œçš„å­—æ®µå€¼éƒ½å–å‡ºæ¥ï¼Œè¿”å›ç»™æœåŠ¡å±‚ï¼ŒæœåŠ¡å±‚åˆ¤æ–­æ˜¯å¦ä¸ºnullï¼Œä¸ä¸ºnullï¼Œè®¡æ•°ç´¯åŠ ã€‚æœ‰not nullçº¦æŸï¼šInnoDBå¼•æ“ä¼šéå†æ•´å¼ è¡¨æŠŠæ¯ä¸€è¡Œçš„å­—æ®µå€¼éƒ½å–å‡ºæ¥ï¼Œè¿”å›ç»™æœåŠ¡å±‚ï¼Œç›´æ¥æŒ‰è¡Œè¿›è¡Œç´¯åŠ  count(æ•°å­—) InnoDB å¼•æ“éå†æ•´å¼ è¡¨ï¼Œä½†ä¸å–å€¼ã€‚æœåŠ¡å±‚å¯¹äºè¿”å›çš„æ¯ä¸€è¡Œï¼Œæ”¾ä¸€ä¸ªæ•°å­—\u0026quot;1\u0026quot;è¿›å»ï¼Œç›´æ¥æŒ‰è¡Œè¿›è¡Œç´¯åŠ  count(*) InnoDBå¼•æ“å¹¶ä¸ä¼šæŠŠå…¨éƒ¨å­—æ®µå–å‡ºæ¥ï¼Œè€Œæ˜¯ä¸“é—¨åšäº†ä¼˜åŒ–ï¼Œä¸å–å€¼ï¼ŒæœåŠ¡å±‚ç›´æ¥æŒ‰è¡Œè¿›è¡Œç´¯åŠ  æŒ‰ç…§æ•ˆç‡æ’åºçš„è¯ï¼Œcount(å­—æ®µ) \u0026lt; count(ä¸»é”® id) \u0026lt; count(1) â‰ˆ count(*)ï¼Œæ‰€ä»¥å°½é‡ä½¿ç”¨count(*)ã€‚ updateä¼˜åŒ– æˆ‘ä»¬åœ¨æ‰§è¡Œåˆ é™¤çš„SQLè¯­å¥æ—¶ï¼Œä¼šé”å®šidä¸º1è¿™ä¸€è¡Œçš„æ•°æ®ï¼Œç„¶åäº‹åŠ¡æäº¤ä¹‹åï¼Œè¡Œé”é‡Šæ”¾ã€‚ update course set name = \u0026#39;php\u0026#39; where id = 1; å½“æˆ‘ä»¬å¼€å¯å¤šä¸ªäº‹åŠ¡ï¼Œåœ¨æ‰§è¡Œä¸Šè¿°çš„SQLæ—¶ï¼Œæˆ‘ä»¬å‘ç°è¡Œé”å‡çº§ä¸ºäº†è¡¨é”ã€‚ å¯¼è‡´è¯¥updateè¯­å¥çš„æ€§èƒ½å¤§å¤§é™ä½ã€‚ update course set name = \u0026#39;javascript\u0026#39; where name = \u0026#39;PHP\u0026#39;; InnoDBçš„è¡Œé”æ˜¯é’ˆå¯¹ç´¢å¼•åŠ çš„é”ï¼Œä¸æ˜¯é’ˆå¯¹è®°å½•åŠ çš„é” ,å¹¶ä¸”è¯¥ç´¢å¼•ä¸èƒ½å¤±æ•ˆï¼Œå¦åˆ™ä¼šä»è¡Œé”å‡çº§ä¸ºè¡¨é”ã€‚ ","permalink":"https://heliu.site/posts/mysql/sql/","summary":"mysql sqlä¼˜åŒ–ã€‚","title":"mysql sql ä¼˜åŒ–"},{"content":"å…¨å±€é” å…¨å±€é”å°±æ˜¯å¯¹æ•´ä¸ªæ•°æ®åº“å®ä¾‹åŠ é”ï¼ŒåŠ é”åæ•´ä¸ªå®ä¾‹å°±å¤„äºåªè¯»çŠ¶æ€ï¼Œåç»­çš„DMLçš„å†™è¯­å¥ï¼ŒDDLè¯­å¥ï¼Œå·²ç»æ›´æ–°æ“ä½œçš„äº‹åŠ¡æäº¤è¯­å¥éƒ½å°†è¢«é˜»å¡ã€‚ å…¶å…¸å‹çš„ä½¿ç”¨åœºæ™¯æ˜¯åšå…¨åº“çš„é€»è¾‘å¤‡ä»½ï¼Œå¯¹æ‰€æœ‰çš„è¡¨è¿›è¡Œé”å®šï¼Œä»è€Œè·å–ä¸€è‡´æ€§è§†å›¾ï¼Œä¿è¯æ•°æ®çš„å®Œæ€§ã€‚ å¯¹æ•°æ®åº“è¿›è¡Œè¿›è¡Œé€»è¾‘å¤‡ä»½ä¹‹å‰ï¼Œå…ˆå¯¹æ•´ä¸ªæ•°æ®åº“åŠ ä¸Šå…¨å±€é”ï¼Œä¸€æ—¦åŠ äº†å…¨å±€é”ä¹‹åï¼Œå…¶ä»–çš„DDLã€DMLå…¨éƒ¨éƒ½å¤„äºé˜»å¡çŠ¶æ€ï¼Œä½†æ˜¯å¯ä»¥æ‰§è¡ŒDQLè¯­å¥ï¼Œä¹Ÿå°±æ˜¯å¤„äºåªè¯»çŠ¶æ€ï¼Œè€Œæ•°æ®å¤‡ä»½å°±æ˜¯æŸ¥è¯¢æ“ä½œã€‚é‚£ä¹ˆæ•°æ®åœ¨è¿›è¡Œé€»è¾‘å¤‡ä»½çš„è¿‡ç¨‹ä¸­ï¼Œæ•°æ®åº“ä¸­çš„æ•°æ®å°±æ˜¯ä¸ä¼šå‘ç”Ÿå˜åŒ–çš„ï¼Œè¿™æ ·å°±ä¿è¯äº†æ•°æ®çš„ä¸€è‡´æ€§å’Œå®Œæ•´æ€§ã€‚ è¯­æ³• åŠ å…¨å±€é”ã€‚ flush tables with read lock; æ•°æ®å¤‡ä»½ã€‚ mysqldump -uroot â€“p1234 ic \u0026gt; ic.sql é‡Šæ”¾é”ã€‚ unlock tables; ç‰¹ç‚¹ æ•°æ®åº“ä¸­åŠ å…¨å±€é”ï¼Œæ˜¯ä¸€ä¸ªæ¯”è¾ƒé‡çš„æ“ä½œï¼Œå­˜åœ¨ä»¥ä¸‹é—®é¢˜ï¼š å¦‚æœåœ¨ä¸»åº“ä¸Šå¤‡ä»½ï¼Œé‚£ä¹ˆåœ¨å¤‡ä»½æœŸé—´éƒ½ä¸èƒ½æ‰§è¡Œæ›´æ–°ï¼Œä¸šåŠ¡åŸºæœ¬ä¸Šå°±å¾—åœæ‘†ã€‚ å¦‚æœåœ¨ä»åº“ä¸Šå¤‡ä»½ï¼Œé‚£ä¹ˆåœ¨å¤‡ä»½æœŸé—´ä»åº“ä¸èƒ½æ‰§è¡Œä¸»åº“åŒæ­¥è¿‡æ¥çš„äºŒè¿›åˆ¶æ—¥å¿—ï¼ˆbinlogï¼‰ï¼Œä¼šå¯¼è‡´ä¸»ä»å»¶è¿Ÿã€‚ åœ¨InnoDBå¼•æ“ä¸­ï¼Œæˆ‘ä»¬å¯ä»¥åœ¨å¤‡ä»½æ—¶åŠ ä¸Šå‚æ•° \u0026ndash;single-transaction å‚æ•°æ¥å®Œæˆä¸åŠ é”çš„ä¸€è‡´æ€§æ•°æ®å¤‡ä»½ã€‚ mysqldump --single-transaction -uroot â€“p123456 ic \u0026gt; ic.sql è¡¨çº§é” è¡¨çº§é”ï¼Œæ¯æ¬¡æ“ä½œé”ä½æ•´å¼ è¡¨ã€‚é”å®šç²’åº¦å¤§ï¼Œå‘ç”Ÿé”å†²çªçš„æ¦‚ç‡æœ€é«˜ï¼Œå¹¶å‘åº¦æœ€ä½ã€‚åº”ç”¨åœ¨MyISAMã€InnoDBã€BDBç­‰å­˜å‚¨å¼•æ“ä¸­ã€‚ è¡¨é” å¯¹äºè¡¨é”ï¼Œåˆ†ä¸ºä¸¤ç±»ï¼šè¡¨å…±äº«è¯»é”ï¼ˆread lockï¼‰ã€è¡¨ç‹¬å å†™é”ï¼ˆwrite lockï¼‰ã€‚ è¯­æ³•ï¼š -- åŠ é” lock tables è¡¨å read; -- è¯»é” lock tables è¡¨å write; -- å†™é” -- é‡Šæ”¾é” unlock tables; è¯»é”ï¼šå·¦ä¾§ä¸ºå®¢æˆ·ç«¯ä¸€ï¼Œå¯¹æŒ‡å®šè¡¨åŠ äº†è¯»é”ï¼Œä¸ä¼šå½±å“å³ä¾§å®¢æˆ·ç«¯äºŒçš„è¯»ï¼Œä½†æ˜¯ä¼šé˜»å¡å³ä¾§å®¢æˆ·ç«¯çš„å†™ã€‚ å†™é”ï¼šå·¦ä¾§ä¸ºå®¢æˆ·ç«¯ä¸€ï¼Œå¯¹æŒ‡å®šè¡¨åŠ äº†å†™é”ï¼Œä¼šé˜»å¡å³ä¾§å®¢æˆ·ç«¯çš„è¯»å’Œå†™ã€‚ è¯»é”ä¸ä¼šé˜»å¡å…¶ä»–å®¢æˆ·ç«¯çš„è¯»ï¼Œä½†æ˜¯ä¼šé˜»å¡å†™ã€‚å†™é”æ—¢ä¼šé˜»å¡å…¶ä»–å®¢æˆ·ç«¯çš„è¯»ï¼Œåˆä¼šé˜»å¡å…¶ä»–å®¢æˆ·ç«¯çš„å†™ã€‚ å…ƒæ•°æ®é” meta data lockï¼Œå…ƒæ•°æ®é”ï¼Œç®€å†™MDLã€‚ MDLåŠ é”è¿‡ç¨‹æ˜¯ç³»ç»Ÿè‡ªåŠ¨æ§åˆ¶ï¼Œæ— éœ€æ˜¾å¼ä½¿ç”¨ï¼Œåœ¨è®¿é—®ä¸€å¼ è¡¨çš„æ—¶å€™ä¼šè‡ªåŠ¨åŠ ä¸Šã€‚ MDLé”ä¸»è¦ä½œç”¨æ˜¯ç»´æŠ¤è¡¨å…ƒæ•°æ®çš„æ•°æ®ä¸€è‡´æ€§ï¼Œåœ¨è¡¨ä¸Šæœ‰æ´»åŠ¨äº‹åŠ¡çš„æ—¶å€™ï¼Œä¸å¯ä»¥å¯¹å…ƒæ•°æ®è¿›è¡Œå†™å…¥æ“ä½œã€‚ä¸ºäº†é¿å…DMLä¸DDLå†²çªï¼Œä¿è¯è¯»å†™çš„æ­£ç¡®æ€§ã€‚ è¿™é‡Œçš„å…ƒæ•°æ®ï¼Œå¤§å®¶å¯ä»¥ç®€å•ç†è§£ä¸ºå°±æ˜¯ä¸€å¼ è¡¨çš„è¡¨ç»“æ„ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼ŒæŸä¸€å¼ è¡¨æ¶‰åŠåˆ°æœªæäº¤çš„äº‹åŠ¡æ—¶ï¼Œæ˜¯ä¸èƒ½å¤Ÿä¿®æ”¹è¿™å¼ è¡¨çš„è¡¨ç»“æ„çš„ã€‚ åœ¨MySQL5.5ä¸­å¼•å…¥äº†MDLï¼Œå½“å¯¹ä¸€å¼ è¡¨è¿›è¡Œå¢åˆ æ”¹æŸ¥çš„æ—¶å€™ï¼ŒåŠ MDLè¯»é”(å…±äº«)ï¼›å½“å¯¹è¡¨ç»“æ„è¿›è¡Œå˜æ›´æ“ä½œçš„æ—¶å€™ï¼ŒåŠ MDLå†™é”(æ’ä»–)ã€‚ å¸¸è§çš„SQLæ“ä½œæ—¶ï¼Œæ‰€æ·»åŠ çš„å…ƒæ•°æ®é”ï¼š \u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;-å¯¹åº”Sql\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;- é”ç±»å‹ è¯´æ˜ lock tables xxx read/write SHARED_READ_ONLYï¼ˆå¯è¯»ï¼‰/ SHARED_NO_READ_WRITEï¼ˆä¸å¯è¯»å†™ï¼‰ select ã€select \u0026hellip; lock in share mode SHARED_READ(è¯»é”) ä¸SHARED_READã€SHARED_WRITEå…¼å®¹ï¼Œä¸EXCLUSIVEäº’æ–¥ insert ã€updateã€deleteã€select \u0026hellip; for update SHARED_WRITE(å†™é”/æ’ä»–) ä¸SHARED_READã€SHARED_WRITEå…¼å®¹ï¼Œä¸EXCLUSIVEäº’æ–¥ alter table \u0026hellip; EXCLUSIVE ä¸å…¶ä»–çš„MDLéƒ½äº’æ–¥ å½“æ‰§è¡ŒSELECTã€INSERTã€UPDATEã€DELETEç­‰è¯­å¥æ—¶ï¼Œæ·»åŠ çš„æ˜¯å…ƒæ•°æ®å…±äº«é”ï¼ˆSHARED_READ/SHARED_WRITEï¼‰ï¼Œä¹‹é—´æ˜¯å…¼å®¹çš„ã€‚ é€šè¿‡ä¸‹é¢çš„SQLï¼Œæ¥æŸ¥çœ‹æ•°æ®åº“ä¸­çš„å…ƒæ•°æ®é”çš„æƒ…å†µï¼š select object_type,object_schema,object_name,lock_type,lock_duration from performance_schema.metadata_locks; æ„å‘é” ä¸ºäº†é¿å…DMLåœ¨æ‰§è¡Œæ—¶ï¼ŒåŠ çš„è¡Œé”ä¸è¡¨é”çš„å†²çªï¼Œåœ¨InnoDBä¸­å¼•å…¥äº†æ„å‘é”ï¼Œä½¿å¾—è¡¨é”ä¸ç”¨æ£€æŸ¥æ¯è¡Œæ•°æ®æ˜¯å¦åŠ é”ï¼Œä½¿ç”¨æ„å‘é”æ¥å‡å°‘è¡¨é”çš„æ£€æŸ¥ã€‚ æ„å‘å…±äº«é”(IS): ç”±è¯­å¥select \u0026hellip; lock in share modeæ·»åŠ ã€‚ä¸è¡¨é”å…±äº«é”(read)å…¼å®¹ï¼Œä¸è¡¨é”æ’ä»–é”(write)äº’æ–¥ã€‚ æ„å‘æ’ä»–é”(IX): ç”±insertã€updateã€deleteã€select\u0026hellip;for updateæ·»åŠ ã€‚ä¸è¡¨é”å…±äº«é”(read)åŠæ’ä»–é”(write)éƒ½äº’æ–¥ï¼Œæ„å‘é”ä¹‹é—´ä¸ä¼šäº’æ–¥ã€‚ ä¸€æ—¦äº‹åŠ¡æäº¤äº†ï¼Œæ„å‘å…±äº«é”ã€æ„å‘æ’ä»–é”ï¼Œéƒ½ä¼šè‡ªåŠ¨é‡Šæ”¾ã€‚ è¡Œçº§é” è¡Œçº§é”ï¼Œæ¯æ¬¡æ“ä½œé”ä½å¯¹åº”çš„è¡Œæ•°æ®ã€‚é”å®šç²’åº¦æœ€å°ï¼Œå‘ç”Ÿé”å†²çªçš„æ¦‚ç‡æœ€ä½ï¼Œå¹¶å‘åº¦æœ€é«˜ã€‚åº”ç”¨åœ¨InnoDBå­˜å‚¨å¼•æ“ä¸­ã€‚ InnoDBçš„æ•°æ®æ˜¯åŸºäºç´¢å¼•ç»„ç»‡çš„ï¼Œè¡Œé”æ˜¯é€šè¿‡å¯¹ç´¢å¼•ä¸Šçš„ç´¢å¼•é¡¹åŠ é”æ¥å®ç°çš„ï¼Œè€Œä¸æ˜¯å¯¹è®°å½•åŠ çš„é”ã€‚å¯¹äºè¡Œçº§é”ï¼Œä¸»è¦åˆ†ä¸ºä»¥ä¸‹ä¸‰ç±»ï¼š è¡Œé”ï¼ˆRecord Lockï¼‰ï¼šé”å®šå•ä¸ªè¡Œè®°å½•çš„é”ï¼Œé˜²æ­¢å…¶ä»–äº‹åŠ¡å¯¹æ­¤è¡Œè¿›è¡Œupdateå’Œdeleteã€‚åœ¨RCã€RRéš”ç¦»çº§åˆ«ä¸‹éƒ½æ”¯æŒã€‚ é—´éš™é”ï¼ˆGap Lockï¼‰ï¼šé”å®šç´¢å¼•è®°å½•é—´éš™ï¼ˆä¸å«è¯¥è®°å½•ï¼‰ï¼Œç¡®ä¿ç´¢å¼•è®°å½•é—´éš™ä¸å˜ï¼Œé˜²æ­¢å…¶ä»–äº‹åŠ¡åœ¨è¿™ä¸ªé—´éš™è¿›è¡Œinsertï¼Œäº§ç”Ÿå¹»è¯»ã€‚åœ¨RRéš”ç¦»çº§åˆ«ä¸‹éƒ½æ”¯æŒã€‚ ä¸´é”®é”ï¼ˆNext-Key Lockï¼‰ï¼šè¡Œé”å’Œé—´éš™é”ç»„åˆï¼ŒåŒæ—¶é”ä½æ•°æ®ï¼Œå¹¶é”ä½æ•°æ®å‰é¢çš„é—´éš™Gapã€‚åœ¨RRéš”ç¦»çº§åˆ«ä¸‹æ”¯æŒã€‚ è¡Œçº§ InnoDBå®ç°äº†ä»¥ä¸‹ä¸¤ç§ç±»å‹çš„è¡Œé”ï¼š å…±äº«é”ï¼ˆSï¼‰(read)ï¼šå…è®¸ä¸€ä¸ªäº‹åŠ¡å»è¯»ä¸€è¡Œï¼Œé˜»æ­¢å…¶ä»–äº‹åŠ¡è·å¾—ç›¸åŒæ•°æ®é›†çš„æ’å®ƒé”ã€‚ æ’ä»–é”ï¼ˆXï¼‰(write)ï¼šå…è®¸è·å–æ’ä»–é”çš„äº‹åŠ¡æ›´æ–°æ•°æ®ï¼Œé˜»æ­¢å…¶ä»–äº‹åŠ¡è·å¾—ç›¸åŒæ•°æ®é›†çš„å…±äº«é”å’Œæ’ä»–é”ã€‚ å½“å‰é”ç±»å‹\\è¯·æ±‚é”ç±»å‹ S(å…±äº«é”) X(æ’ä»–é”) S(å…±äº«é”) å…¼å®¹ å†²çª X(æ’ä»–é”) å†²çª å†²çª å¸¸è§çš„SQLè¯­å¥ï¼Œåœ¨æ‰§è¡Œæ—¶ï¼Œæ‰€åŠ çš„è¡Œé”å¦‚ä¸‹ï¼š \u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;-SQL\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;- è¡Œé”ç±»å‹ è¯´æ˜ INSERT \u0026hellip; æ’ä»–é” è‡ªåŠ¨åŠ é” UPDATE \u0026hellip; æ’ä»–é” è‡ªåŠ¨åŠ é” DELETE \u0026hellip; æ’ä»–é” è‡ªåŠ¨åŠ é” SELECTï¼ˆæ­£å¸¸ï¼‰ ä¸åŠ ä»»ä½•é” SELECT \u0026hellip; LOCK IN SHARE MODE å…±äº«é” éœ€è¦æ‰‹åŠ¨åœ¨SELECTä¹‹ååŠ LOCK IN SHARE MODE SELECT \u0026hellip; FOR UPDATE æ’ä»–é” éœ€è¦æ‰‹åŠ¨åœ¨SELECTä¹‹ååŠ FOR UPDATE é»˜è®¤æƒ…å†µä¸‹ï¼ŒInnoDBåœ¨ REPEATABLE READäº‹åŠ¡éš”ç¦»çº§åˆ«è¿è¡Œï¼ŒInnoDBä½¿ç”¨next-keyé”è¿›è¡Œæœç´¢å’Œç´¢å¼•æ‰«æï¼Œä»¥é˜²æ­¢å¹»è¯»ã€‚ é’ˆå¯¹å”¯ä¸€ç´¢å¼•è¿›è¡Œæ£€ç´¢æ—¶ï¼Œå¯¹å·²å­˜åœ¨çš„è®°å½•è¿›è¡Œç­‰å€¼åŒ¹é…æ—¶ï¼Œå°†ä¼šè‡ªåŠ¨ä¼˜åŒ–ä¸ºè¡Œé”ã€‚ InnoDBçš„è¡Œé”æ˜¯é’ˆå¯¹äºç´¢å¼•åŠ çš„é”ï¼Œä¸é€šè¿‡ç´¢å¼•æ¡ä»¶æ£€ç´¢æ•°æ®ï¼Œé‚£ä¹ˆInnoDBå°†å¯¹è¡¨ä¸­çš„æ‰€æœ‰è®°å½•åŠ é”ï¼Œæ­¤æ—¶å°±ä¼šå‡çº§ä¸ºè¡¨é”ã€‚(ä¿®æ”¹æ¡ä»¶æ²¡æœ‰ç”¨åˆ°ç´¢å¼•ï¼Œåˆ™ä¼šä½¿ç”¨è¡¨é”) å¯ä»¥é€šè¿‡ä»¥ä¸‹SQLï¼ŒæŸ¥çœ‹æ„å‘é”åŠè¡Œé”çš„åŠ é”æƒ…å†µï¼š select object_schema,object_name,index_name,lock_type,lock_mode,lock_data from performance_schema.data_locks; é—´éš™é”\u0026amp;ä¸´é”®é” é»˜è®¤æƒ…å†µä¸‹ï¼ŒInnoDBåœ¨ REPEATABLE READäº‹åŠ¡éš”ç¦»çº§åˆ«è¿è¡Œï¼ŒInnoDBä½¿ç”¨next-keyé”è¿›è¡Œæœç´¢å’Œç´¢å¼•æ‰«æï¼Œä»¥é˜²æ­¢å¹»è¯»ã€‚ ç´¢å¼•ä¸Šçš„ç­‰å€¼æŸ¥è¯¢(å”¯ä¸€ç´¢å¼•)ï¼Œç»™ä¸å­˜åœ¨çš„è®°å½•åŠ é”æ—¶, ä¼˜åŒ–ä¸ºé—´éš™é”ã€‚ ç´¢å¼•ä¸Šçš„ç­‰å€¼æŸ¥è¯¢(éå”¯ä¸€æ™®é€šç´¢å¼•)ï¼Œå‘å³éå†æ—¶æœ€åä¸€ä¸ªå€¼ä¸æ»¡è¶³æŸ¥è¯¢éœ€æ±‚æ—¶ï¼Œnext-key locké€€åŒ–ä¸ºé—´éš™é”ã€‚ ç´¢å¼•ä¸Šçš„èŒƒå›´æŸ¥è¯¢(å”¯ä¸€ç´¢å¼•)\u0026ndash;ä¼šè®¿é—®åˆ°ä¸æ»¡è¶³æ¡ä»¶çš„ç¬¬ä¸€ä¸ªå€¼ä¸ºæ­¢ã€‚ æ³¨æ„ï¼šé—´éš™é”å”¯ä¸€ç›®çš„æ˜¯é˜²æ­¢å…¶ä»–äº‹åŠ¡æ’å…¥é—´éš™ã€‚é—´éš™é”å¯ä»¥å…±å­˜ï¼Œä¸€ä¸ªäº‹åŠ¡é‡‡ç”¨çš„é—´éš™é”ä¸ä¼šé˜»æ­¢å¦ä¸€ä¸ªäº‹åŠ¡åœ¨åŒä¸€é—´éš™ä¸Šé‡‡ç”¨é—´éš™é”ã€‚ ","permalink":"https://heliu.site/posts/mysql/lock/","summary":"mysql å…¨å±€é”ã€è¡¨é”ã€è¡Œé”ã€‚","title":"mysql é”"},{"content":"mysql å¼•æ“ InnoDB InnoDBæ˜¯ä¸€ç§å…¼é¡¾é«˜å¯é æ€§å’Œé«˜æ€§èƒ½çš„é€šç”¨å­˜å‚¨å¼•æ“ï¼Œåœ¨MySQL 5.5ä¹‹åï¼ŒInnoDBæ˜¯é»˜è®¤çš„MySQLå­˜å‚¨å¼•æ“ã€‚ ç‰¹ç‚¹ï¼š DMLæ“ä½œéµå¾ªACIDæ¨¡å‹ï¼Œæ”¯æŒäº‹åŠ¡ã€‚ è¡Œçº§é”ï¼Œæé«˜å¹¶å‘è®¿é—®æ€§èƒ½ã€‚ æ”¯æŒå¤–é”®FOREIGN KEYçº¦æŸï¼Œä¿è¯æ•°æ®çš„å®Œæ•´æ€§å’Œæ­£ç¡®æ€§ã€‚ xxx.ibdï¼šxxxä»£è¡¨çš„æ˜¯è¡¨åï¼ŒinnoDBå¼•æ“çš„æ¯å¼ è¡¨éƒ½ä¼šå¯¹åº”è¿™æ ·ä¸€ä¸ªè¡¨ç©ºé—´æ–‡ä»¶ï¼Œå­˜å‚¨è¯¥è¡¨çš„è¡¨ç»“æ„ï¼ˆfrm-æ—©æœŸçš„ ã€sdi-æ–°ç‰ˆçš„ï¼‰ã€æ•°æ®å’Œç´¢å¼•ã€‚ å¦‚æœè¯¥å‚æ•°å¼€å¯ï¼Œä»£è¡¨å¯¹äºInnoDBå¼•æ“çš„è¡¨ï¼Œæ¯ä¸€å¼ è¡¨éƒ½å¯¹åº”ä¸€ä¸ªibdæ–‡ä»¶ã€‚ show variables like \u0026#39;innodb_file_per_table\u0026#39;; MyIsam MyISAMæ˜¯MySQLæ—©æœŸçš„é»˜è®¤å­˜å‚¨å¼•æ“ã€‚ ç‰¹ç‚¹ï¼š ä¸æ”¯æŒäº‹åŠ¡ï¼Œä¸æ”¯æŒå¤–é”®ã€‚ æ”¯æŒè¡¨é”ï¼Œä¸æ”¯æŒè¡Œé”ã€‚ è®¿é—®é€Ÿåº¦å¿«ã€‚ æ–‡ä»¶ï¼š xxx.sdiï¼šå­˜å‚¨è¡¨ç»“æ„ä¿¡æ¯ã€‚ xxx.MYD: å­˜å‚¨æ•°æ®ã€‚ xxx.MYI: å­˜å‚¨ç´¢å¼•ã€‚ Memory Memoryå¼•æ“çš„è¡¨æ•°æ®æ—¶å­˜å‚¨åœ¨å†…å­˜ä¸­çš„ï¼Œç”±äºå—åˆ°ç¡¬ä»¶é—®é¢˜ã€æˆ–æ–­ç”µé—®é¢˜çš„å½±å“ï¼Œåªèƒ½å°†è¿™äº›è¡¨ä½œä¸ºä¸´æ—¶è¡¨æˆ–ç¼“å­˜ä½¿ç”¨ã€‚ ç‰¹ç‚¹ï¼šå†…å­˜å­˜æ”¾ã€hashç´¢å¼•ï¼ˆé»˜è®¤ï¼‰ã€‚ æ–‡ä»¶ï¼šxxx.sdiï¼šå­˜å‚¨è¡¨ç»“æ„ä¿¡æ¯ å¯¹æ¯” ç‰¹ç‚¹ InnoDB MyIsam Memory å­˜å‚¨é™åˆ¶ 64TB æœ‰ æœ‰ äº‹åŠ¡å®‰å…¨ æ”¯æŒ - - é”æœºåˆ¶ è¡Œé” è¡¨é” è¡¨é” B+treeç´¢å¼• æ”¯æŒ æ”¯æŒ æ”¯æŒ Hashç´¢å¼• - - æ”¯æŒ å…¨æ–‡ç´¢å¼• æ”¯æŒ(5.6ç‰ˆæœ¬ä¹‹å) æ”¯æŒ - ç©ºé—´ä½¿ç”¨ é«˜ ä½ N/A å†…å­˜ä½¿ç”¨ é«˜ ä½ ä¸­ç­‰ æ‰¹é‡æ’å…¥é€Ÿåº¦ ä½ é«˜ é«˜ æ”¯æŒå¤–é”® æ”¯æŒ - - InnoDBå¼•æ“ä¸MyISAMå¼•æ“çš„åŒºåˆ«ï¼š InnoDBå¼•æ“, æ”¯æŒäº‹åŠ¡, è€ŒMyISAMä¸æ”¯æŒã€‚ InnoDBå¼•æ“, æ”¯æŒè¡Œé”å’Œè¡¨é”, è€ŒMyISAMä»…æ”¯æŒè¡¨é”, ä¸æ”¯æŒè¡Œé”ã€‚ InnoDBå¼•æ“, æ”¯æŒå¤–é”®, è€ŒMyISAMæ˜¯ä¸æ”¯æŒçš„ã€‚ InnoDBå¼•æ“ æ¶æ„ MySQL5.5 ç‰ˆæœ¬å¼€å§‹ï¼Œé»˜è®¤ä½¿ç”¨InnoDBå­˜å‚¨å¼•æ“ï¼Œå®ƒæ“…é•¿äº‹åŠ¡å¤„ç†ï¼Œå…·æœ‰å´©æºƒæ¢å¤ç‰¹æ€§ï¼Œåœ¨æ—¥å¸¸å¼€å‘ä¸­ä½¿ç”¨éå¸¸å¹¿æ³›ã€‚ ä¸‹é¢æ˜¯InnoDBæ¶æ„å›¾ï¼Œå·¦ä¾§ä¸ºå†…å­˜ç»“æ„ï¼Œå³ä¾§ä¸ºç£ç›˜ç»“æ„ã€‚ å†…å­˜ç»“æ„ Buffer Poolï¼šç¼“å†²æ±  Buffer Poolï¼Œæ˜¯ä¸»å†…å­˜ä¸­çš„ä¸€ä¸ªåŒºåŸŸï¼Œé‡Œé¢å¯ä»¥ç¼“å­˜ç£ç›˜ä¸Šç»å¸¸æ“ä½œçš„çœŸå®æ•°æ®ï¼Œåœ¨æ‰§è¡Œå¢åˆ æ”¹æŸ¥æ“ä½œæ—¶ï¼Œå…ˆæ“ä½œç¼“å†²æ± ä¸­çš„æ•°æ®ï¼ˆè‹¥ç¼“å†²æ± æ²¡æœ‰æ•°æ®ï¼Œåˆ™ä»ç£ç›˜åŠ è½½å¹¶ç¼“å­˜ï¼‰ï¼Œç„¶åå†ä»¥ä¸€å®šé¢‘ç‡åˆ·æ–°åˆ°ç£ç›˜ï¼Œä»è€Œå‡å°‘ç£ç›˜IOï¼ŒåŠ å¿«å¤„ç†é€Ÿåº¦ã€‚ åœ¨ä¸“ç”¨æœåŠ¡å™¨ä¸Šï¼Œé€šå¸¸å°†å¤šè¾¾80ï¼…çš„ç‰©ç†å†…å­˜åˆ†é…ç»™ç¼“å†²æ± ã€‚ å‚æ•°è®¾ç½®ï¼šshow variables like \u0026lsquo;innodb_buffer_pool_size\u0026rsquo;ã€‚ Change Bufferï¼šæ›´æ”¹ç¼“å†²åŒºï¼ˆé’ˆå¯¹äºéå”¯ä¸€äºŒçº§ç´¢å¼•é¡µï¼‰ï¼Œåœ¨æ‰§è¡ŒDMLè¯­å¥æ—¶ï¼Œå¦‚æœè¿™äº›æ•°æ®Pageæ²¡æœ‰åœ¨Buffer Poolä¸­ï¼Œä¸ä¼šç›´æ¥æ“ä½œç£ç›˜ï¼Œè€Œä¼šå°†æ•°æ®å˜æ›´å­˜åœ¨æ›´æ”¹ç¼“å†²åŒºChange Bufferä¸­ï¼Œåœ¨æœªæ¥æ•°æ®è¢«è¯»å–æ—¶ï¼Œå†å°†æ•°æ®åˆå¹¶æ¢å¤åˆ°Buffer Poolä¸­ï¼Œå†å°†åˆå¹¶åçš„æ•°æ®åˆ·æ–°åˆ°ç£ç›˜ä¸­ã€‚ Adaptive Hash Indexï¼šè‡ªé€‚åº”hashç´¢å¼•ï¼Œç”¨äºä¼˜åŒ–å¯¹Buffer Poolæ•°æ®çš„æŸ¥è¯¢ã€‚InnoDBå­˜å‚¨å¼•æ“ä¼šç›‘æ§å¯¹è¡¨ä¸Šå„ç´¢å¼•é¡µçš„æŸ¥è¯¢ï¼Œå¦‚æœè§‚å¯Ÿåˆ°åœ¨ç‰¹å®šçš„æ¡ä»¶ä¸‹hashç´¢å¼•å¯ä»¥æå‡é€Ÿåº¦ï¼Œåˆ™å»ºç«‹hashç´¢å¼•ï¼Œç§°ä¹‹ä¸ºè‡ªé€‚åº”hashç´¢å¼•ã€‚ Log Bufferï¼šæ—¥å¿—ç¼“å†²åŒºï¼Œç”¨æ¥ä¿å­˜è¦å†™å…¥åˆ°ç£ç›˜ä¸­çš„logæ—¥å¿—æ•°æ®ï¼ˆredo log ã€undo logï¼‰ï¼Œé»˜è®¤å¤§å°ä¸º 16MBï¼Œæ—¥å¿—ç¼“å†²åŒºçš„æ—¥å¿—ä¼šå®šæœŸåˆ·æ–°åˆ°ç£ç›˜ä¸­ã€‚å¦‚æœéœ€è¦æ›´æ–°ã€æ’å…¥æˆ–åˆ é™¤è®¸å¤šè¡Œçš„äº‹åŠ¡ï¼Œå¢åŠ æ—¥å¿—ç¼“å†²åŒºçš„å¤§å°å¯ä»¥èŠ‚çœç£ç›˜I/Oã€‚å‚æ•°ï¼š innodb_log_buffer_sizeï¼šç¼“å†²åŒºå¤§å° innodb_flush_log_at_trx_commitï¼šæ—¥å¿—åˆ·æ–°åˆ°ç£ç›˜æ—¶æœºï¼Œå–å€¼ä¸»è¦åŒ…å«ä»¥ä¸‹ä¸‰ä¸ªï¼š 1: æ—¥å¿—åœ¨æ¯æ¬¡äº‹åŠ¡æäº¤æ—¶å†™å…¥å¹¶åˆ·æ–°åˆ°ç£ç›˜ï¼Œé»˜è®¤å€¼ã€‚ 0: æ¯ç§’å°†æ—¥å¿—å†™å…¥å¹¶åˆ·æ–°åˆ°ç£ç›˜ä¸€æ¬¡ã€‚ 2: æ—¥å¿—åœ¨æ¯æ¬¡äº‹åŠ¡æäº¤åå†™å…¥ï¼Œå¹¶æ¯ç§’åˆ·æ–°åˆ°ç£ç›˜ä¸€æ¬¡ã€‚ ç£ç›˜ç»“æ„ System Tablespaceï¼šç³»ç»Ÿè¡¨ç©ºé—´æ˜¯æ›´æ”¹ç¼“å†²åŒºçš„å­˜å‚¨åŒºåŸŸã€‚å¦‚æœè¡¨æ˜¯åœ¨ç³»ç»Ÿè¡¨ç©ºé—´è€Œä¸æ˜¯æ¯ä¸ªè¡¨æ–‡ä»¶æˆ–é€šç”¨è¡¨ç©ºé—´ä¸­åˆ›å»ºçš„ï¼Œå®ƒä¹Ÿå¯èƒ½åŒ…å«è¡¨å’Œç´¢å¼•æ•°æ®ã€‚å‚æ•° innodb_data_file_pathã€‚ File-Per-Table Tablespacesï¼šå¦‚æœå¼€å¯äº†innodb_file_per_tableå¼€å…³ ï¼Œåˆ™æ¯ä¸ªè¡¨çš„æ–‡ä»¶è¡¨ç©ºé—´åŒ…å«å•ä¸ªInnoDBè¡¨çš„æ•°æ®å’Œç´¢å¼•ï¼Œå¹¶å­˜å‚¨åœ¨æ–‡ä»¶ç³»ç»Ÿä¸Šçš„å•ä¸ªæ•°æ®æ–‡ä»¶ä¸­ã€‚å¼€å…³å‚æ•° innodb_file_per_table ï¼Œè¯¥å‚æ•°é»˜è®¤å¼€å¯ã€‚ General Tablespacesï¼šé€šç”¨è¡¨ç©ºé—´ï¼Œéœ€è¦é€šè¿‡ CREATE TABLESPACE è¯­æ³•åˆ›å»ºé€šç”¨è¡¨ç©ºé—´ï¼Œåœ¨åˆ›å»ºè¡¨æ—¶ï¼Œå¯ä»¥æŒ‡å®šè¯¥è¡¨ç©ºé—´ã€‚ Undo Tablespacesï¼šæ’¤é”€è¡¨ç©ºé—´ï¼ŒMySQLå®ä¾‹åœ¨åˆå§‹åŒ–æ—¶ä¼šè‡ªåŠ¨åˆ›å»ºä¸¤ä¸ªé»˜è®¤çš„undoè¡¨ç©ºé—´ï¼ˆåˆå§‹å¤§å°16Mï¼‰ï¼Œç”¨äºå­˜å‚¨undo logæ—¥å¿—ã€‚ Temporary Tablespacesï¼šInnoDB ä½¿ç”¨ä¼šè¯ä¸´æ—¶è¡¨ç©ºé—´å’Œå…¨å±€ä¸´æ—¶è¡¨ç©ºé—´ã€‚å­˜å‚¨ç”¨æˆ·åˆ›å»ºçš„ä¸´æ—¶è¡¨ç­‰æ•°æ®ã€‚ Doublewrite Buffer Filesï¼šåŒå†™ç¼“å†²åŒºï¼ŒinnoDBå¼•æ“å°†æ•°æ®é¡µä»Buffer Poolåˆ·æ–°åˆ°ç£ç›˜å‰ï¼Œå…ˆå°†æ•°æ®é¡µå†™å…¥åŒå†™ç¼“å†²åŒºæ–‡ä»¶ä¸­ï¼Œä¾¿äºç³»ç»Ÿå¼‚å¸¸æ—¶æ¢å¤æ•°æ®ã€‚ Redo Logï¼šé‡åšæ—¥å¿—ï¼Œæ˜¯ç”¨æ¥å®ç°äº‹åŠ¡çš„æŒä¹…æ€§ã€‚è¯¥æ—¥å¿—æ–‡ä»¶ç”±ä¸¤éƒ¨åˆ†ç»„æˆï¼šé‡åšæ—¥å¿—ç¼“å†²ï¼ˆredo log bufferï¼‰ä»¥åŠé‡åšæ—¥å¿—æ–‡ä»¶ï¼ˆredo logï¼‰,å‰è€…æ˜¯åœ¨å†…å­˜ä¸­ï¼Œåè€…åœ¨ç£ç›˜ä¸­ã€‚å½“äº‹åŠ¡æäº¤ä¹‹åä¼šæŠŠæ‰€æœ‰ä¿®æ”¹ä¿¡æ¯éƒ½ä¼šå­˜åˆ°è¯¥æ—¥å¿—ä¸­, ç”¨äºåœ¨åˆ·æ–°è„é¡µåˆ°ç£ç›˜æ—¶,å‘ç”Ÿé”™è¯¯æ—¶, è¿›è¡Œæ•°æ®æ¢å¤ä½¿ç”¨ã€‚ åå°çº¿ç¨‹ åœ¨InnoDBçš„åå°çº¿ç¨‹ä¸­ï¼Œåˆ†ä¸º4ç±»ï¼Œåˆ†åˆ«æ˜¯ï¼šMaster Thread ã€IO Threadã€Purge Threadã€Page Cleaner Threadã€‚ Master Threadï¼šæ ¸å¿ƒåå°çº¿ç¨‹ï¼Œè´Ÿè´£è°ƒåº¦å…¶ä»–çº¿ç¨‹ï¼Œè¿˜è´Ÿè´£å°†ç¼“å†²æ± ä¸­çš„æ•°æ®å¼‚æ­¥åˆ·æ–°åˆ°ç£ç›˜ä¸­, ä¿æŒæ•°æ®çš„ä¸€è‡´æ€§ï¼Œè¿˜åŒ…æ‹¬è„é¡µçš„åˆ·æ–°ã€åˆå¹¶æ’å…¥ç¼“å­˜ã€undoé¡µçš„å›æ”¶ã€‚ IO Threadï¼šåœ¨InnoDBå­˜å‚¨å¼•æ“ä¸­å¤§é‡ä½¿ç”¨äº†AIOæ¥å¤„ç†IOè¯·æ±‚, è¿™æ ·å¯ä»¥æå¤§åœ°æé«˜æ•°æ®åº“çš„æ€§èƒ½ï¼Œè€ŒIO Threadä¸»è¦è´Ÿè´£è¿™äº›IOè¯·æ±‚çš„å›è°ƒã€‚é€šè¿‡ show engine innodb status \\G; æŸ¥çœ‹ã€‚ \u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;çº¿ç¨‹ç±»å‹\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash; é»˜è®¤ä¸ªæ•° èŒè´£ Read thread 4 è´Ÿè´£è¯»æ“ä½œ Write thread 4 è´Ÿè´£å†™æ“ä½œ Log thread 1 è´Ÿè´£å°†æ—¥å¿—ç¼“å†²åŒºåˆ·æ–°åˆ°ç£ç›˜ Insert buffer thread 1 è´Ÿè´£å°†å†™ç¼“å†²åŒºå†…å®¹åˆ·æ–°åˆ°ç£ç›˜ Purge Threadï¼šä¸»è¦ç”¨äºå›æ”¶äº‹åŠ¡å·²ç»æäº¤äº†çš„undo logï¼Œåœ¨äº‹åŠ¡æäº¤ä¹‹åï¼Œundo logå¯èƒ½ä¸ç”¨äº†ï¼Œå°±ç”¨å®ƒæ¥å›æ”¶ã€‚ Page Cleaner Threadï¼šååŠ© Master Thread åˆ·æ–°è„é¡µåˆ°ç£ç›˜çš„çº¿ç¨‹ï¼Œå®ƒå¯ä»¥å‡è½» Master Thread çš„å·¥ä½œå‹åŠ›ï¼Œå‡å°‘é˜»å¡ã€‚ äº‹åŠ¡åŸç† äº‹åŠ¡ï¼šæ˜¯ä¸€ç»„æ“ä½œçš„é›†åˆï¼Œå®ƒæ˜¯ä¸€ä¸ªä¸å¯åˆ†å‰²çš„å·¥ä½œå•ä½ï¼Œäº‹åŠ¡ä¼šæŠŠæ‰€æœ‰çš„æ“ä½œä½œä¸ºä¸€ä¸ªæ•´ä½“ä¸€èµ·å‘ç³»ç»Ÿæäº¤æˆ–æ’¤é”€æ“ä½œè¯·æ±‚ï¼Œå³è¿™äº›æ“ä½œè¦ä¹ˆåŒæ—¶æˆåŠŸï¼Œè¦ä¹ˆåŒæ—¶å¤±è´¥ã€‚ ç‰¹æ€§ï¼š åŸå­æ€§ï¼ˆAtomicityï¼‰ï¼šäº‹åŠ¡æ˜¯ä¸å¯åˆ†å‰²çš„æœ€å°æ“ä½œå•å…ƒï¼Œè¦ä¹ˆå…¨éƒ¨æˆåŠŸï¼Œè¦ä¹ˆå…¨éƒ¨å¤±è´¥ã€‚ ä¸€è‡´æ€§ï¼ˆConsistencyï¼‰ï¼šäº‹åŠ¡å®Œæˆæ—¶ï¼Œå¿…é¡»ä½¿æ‰€æœ‰çš„æ•°æ®éƒ½ä¿æŒä¸€è‡´çŠ¶æ€ã€‚ éš”ç¦»æ€§ï¼ˆIsolationï¼‰ï¼šæ•°æ®åº“ç³»ç»Ÿæä¾›çš„éš”ç¦»æœºåˆ¶ï¼Œä¿è¯äº‹åŠ¡åœ¨ä¸å—å¤–éƒ¨å¹¶å‘æ“ä½œå½±å“çš„ç‹¬ç«‹ç¯å¢ƒä¸‹è¿è¡Œã€‚ æŒä¹…æ€§ï¼ˆDurabilityï¼‰ï¼šäº‹åŠ¡ä¸€æ—¦æäº¤æˆ–å›æ»šï¼Œå®ƒå¯¹æ•°æ®åº“ä¸­çš„æ•°æ®çš„æ”¹å˜å°±æ˜¯æ°¸ä¹…çš„ã€‚ è€Œå¯¹äºè¿™å››å¤§ç‰¹æ€§ï¼Œå®é™…ä¸Šåˆ†ä¸ºä¸¤ä¸ªéƒ¨åˆ†ã€‚ å…¶ä¸­çš„åŸå­æ€§ã€ä¸€è‡´æ€§ã€æŒä¹…åŒ–ï¼Œå®é™…ä¸Šæ˜¯ç”±InnoDBä¸­çš„ä¸¤ä»½æ—¥å¿—æ¥ä¿è¯çš„ï¼Œä¸€ä»½æ˜¯redo logæ—¥å¿—ï¼Œä¸€ä»½æ˜¯undo logæ—¥å¿—ã€‚ è€ŒæŒä¹…æ€§æ˜¯é€šè¿‡æ•°æ®åº“çš„é”ï¼ŒåŠ ä¸ŠMVCCæ¥ä¿è¯çš„ã€‚ redo log é‡åšæ—¥å¿—ï¼Œè®°å½•çš„æ˜¯äº‹åŠ¡æäº¤æ—¶æ•°æ®é¡µçš„ç‰©ç†ä¿®æ”¹ï¼Œæ˜¯ç”¨æ¥å®ç°äº‹åŠ¡çš„æŒä¹…æ€§ã€‚ è¯¥æ—¥å¿—æ–‡ä»¶ç”±ä¸¤éƒ¨åˆ†ç»„æˆï¼šé‡åšæ—¥å¿—ç¼“å†²ï¼ˆredo log bufferï¼‰ä»¥åŠé‡åšæ—¥å¿—æ–‡ä»¶ï¼ˆredo log fileï¼‰,å‰è€…æ˜¯åœ¨å†…å­˜ä¸­ï¼Œåè€…åœ¨ç£ç›˜ä¸­ã€‚ å½“äº‹åŠ¡æäº¤ä¹‹åä¼šæŠŠæ‰€æœ‰ä¿®æ”¹ä¿¡æ¯éƒ½å­˜åˆ°è¯¥æ—¥å¿—æ–‡ä»¶ä¸­, ç”¨äºåœ¨åˆ·æ–°è„é¡µåˆ°ç£ç›˜,å‘ç”Ÿé”™è¯¯æ—¶, è¿›è¡Œæ•°æ®æ¢å¤ä½¿ç”¨ã€‚ æœ‰äº†redologä¹‹åï¼Œå½“å¯¹ç¼“å†²åŒºçš„æ•°æ®è¿›è¡Œå¢åˆ æ”¹ä¹‹åï¼Œä¼šé¦–å…ˆå°†æ“ä½œçš„æ•°æ®é¡µçš„å˜åŒ–ï¼Œè®°å½•åœ¨redo log bufferä¸­ã€‚åœ¨äº‹åŠ¡æäº¤æ—¶ï¼Œä¼šå°†redo log bufferä¸­çš„æ•°æ®åˆ·æ–°åˆ°redo logç£ç›˜æ–‡ä»¶ä¸­ã€‚è¿‡ä¸€æ®µæ—¶é—´ä¹‹åï¼Œå¦‚æœåˆ·æ–°ç¼“å†²åŒºçš„è„é¡µåˆ°ç£ç›˜æ—¶ï¼Œå‘ç”Ÿé”™è¯¯ï¼Œæ­¤æ—¶å°±å¯ä»¥å€ŸåŠ©äºredo logè¿›è¡Œæ•°æ®æ¢å¤ï¼Œè¿™æ ·å°±ä¿è¯äº†äº‹åŠ¡çš„æŒä¹…æ€§ã€‚è€Œå¦‚æœè„é¡µæˆåŠŸåˆ·æ–°åˆ°ç£ç›˜æˆ–è€…æ¶‰åŠåˆ°çš„æ•°æ®å·²ç»è½ç›˜ï¼Œæ­¤æ—¶redologå°±æ²¡æœ‰ä½œç”¨äº†ï¼Œå°±å¯ä»¥åˆ é™¤äº†ï¼Œæ‰€ä»¥å­˜åœ¨çš„ä¸¤ä¸ªredologæ–‡ä»¶æ˜¯å¾ªç¯å†™çš„ã€‚ åœ¨ä¸šåŠ¡æ“ä½œä¸­ï¼Œæˆ‘ä»¬æ“ä½œæ•°æ®ä¸€èˆ¬éƒ½æ˜¯éšæœºè¯»å†™ç£ç›˜çš„ï¼Œè€Œä¸æ˜¯é¡ºåºè¯»å†™ç£ç›˜ã€‚ è€Œredo logåœ¨å¾€ç£ç›˜æ–‡ä»¶ä¸­å†™å…¥æ•°æ®ï¼Œç”±äºæ˜¯æ—¥å¿—æ–‡ä»¶ï¼Œæ‰€ä»¥éƒ½æ˜¯é¡ºåºå†™çš„ã€‚é¡ºåºå†™çš„æ•ˆç‡ï¼Œè¦è¿œå¤§äºéšæœºå†™ã€‚ è¿™ç§å…ˆå†™æ—¥å¿—çš„æ–¹å¼ï¼Œç§°ä¹‹ä¸ºWALï¼ˆWrite-Ahead Loggingï¼‰ã€‚ undo log å›æ»šæ—¥å¿—ï¼Œç”¨äºè®°å½•æ•°æ®è¢«ä¿®æ”¹å‰çš„ä¿¡æ¯,ä½œç”¨åŒ…å«ä¸¤ä¸ª: æä¾›å›æ»š(ä¿è¯äº‹åŠ¡çš„åŸå­æ€§)å’ŒMVCC(å¤šç‰ˆæœ¬å¹¶å‘æ§åˆ¶)ã€‚ undo logå’Œredo logè®°å½•ç‰©ç†æ—¥å¿—ä¸ä¸€æ ·ï¼Œå®ƒæ˜¯é€»è¾‘æ—¥å¿—ã€‚å¯ä»¥è®¤ä¸ºå½“deleteä¸€æ¡è®°å½•æ—¶ï¼Œundo logä¸­ä¼šè®°å½•ä¸€æ¡å¯¹åº”çš„insertè®°å½•ï¼Œåä¹‹äº¦ç„¶ï¼Œå½“updateä¸€æ¡è®°å½•æ—¶ï¼Œå®ƒè®°å½•ä¸€æ¡å¯¹åº”ç›¸åçš„updateè®°å½•ã€‚å½“æ‰§è¡Œrollbackæ—¶ï¼Œå°±å¯ä»¥ä»undo logä¸­çš„é€»è¾‘è®°å½•è¯»å–åˆ°ç›¸åº”çš„å†…å®¹å¹¶è¿›è¡Œå›æ»šã€‚ Undo logé”€æ¯ï¼šundo logåœ¨äº‹åŠ¡æ‰§è¡Œæ—¶äº§ç”Ÿï¼Œäº‹åŠ¡æäº¤æ—¶ï¼Œå¹¶ä¸ä¼šç«‹å³åˆ é™¤undo logï¼Œå› ä¸ºè¿™äº›æ—¥å¿—å¯èƒ½è¿˜ç”¨äºMVCCã€‚ Undo logå­˜å‚¨ï¼šundo logé‡‡ç”¨æ®µçš„æ–¹å¼è¿›è¡Œç®¡ç†å’Œè®°å½•ï¼Œå­˜æ”¾åœ¨å‰é¢ä»‹ç»çš„rollback segmentå›æ»šæ®µä¸­ï¼Œå†…éƒ¨åŒ…å«1024ä¸ªundo log segmentã€‚ MVCC åŸºæœ¬æ¦‚å¿µ å½“å‰è¯» è¯»å–çš„æ˜¯è®°å½•çš„æœ€æ–°ç‰ˆæœ¬ï¼Œè¯»å–æ—¶è¿˜è¦ä¿è¯å…¶ä»–å¹¶å‘äº‹åŠ¡ä¸èƒ½ä¿®æ”¹å½“å‰è®°å½•ï¼Œä¼šå¯¹è¯»å–çš„è®°å½•è¿›è¡ŒåŠ é”ã€‚ å¯¹äºæˆ‘ä»¬æ—¥å¸¸çš„æ“ä½œï¼Œå¦‚ï¼š(éƒ½æ˜¯ä¸€ç§å½“å‰è¯») select \u0026hellip; lock in share mode (å…±äº«é”) select \u0026hellip; for updateã€updateã€insertã€delete (æ’ä»–é”) åœ¨é»˜è®¤çš„RRéš”ç¦»çº§åˆ«ä¸‹ï¼Œäº‹åŠ¡Aç¬¬(5)æ­¥èƒ½è¯»å–åˆ°äº‹åŠ¡Bç¬¬(3)æ­¥æäº¤çš„æ•°æ®ã€‚ å› ä¸ºåœ¨æŸ¥è¯¢è¯­å¥åé¢åŠ ä¸Šäº†lock in share modeå…±äº«é”ï¼Œæ­¤æ—¶æ˜¯å½“å‰è¯»æ“ä½œã€‚ å½“ç„¶ï¼Œå½“æˆ‘ä»¬åŠ æ’ä»–é”çš„æ—¶å€™ï¼Œä¹Ÿæ˜¯å½“å‰è¯»æ“ä½œã€‚ å¿«ç…§è¯» ç®€å•çš„selectï¼ˆä¸åŠ é”ï¼‰å°±æ˜¯å¿«ç…§è¯»ï¼Œå¿«ç…§è¯»ï¼Œè¯»å–çš„æ˜¯è®°å½•æ•°æ®çš„å¯è§ç‰ˆæœ¬ï¼Œæœ‰å¯èƒ½æ˜¯å†å²æ•°æ®ï¼Œä¸åŠ é”ï¼Œæ˜¯éé˜»å¡è¯»ã€‚ Read Committed (è¯»å·²æäº¤)ï¼šæ¯æ¬¡selectï¼Œéƒ½ç”Ÿæˆä¸€ä¸ªå¿«ç…§è¯»ã€‚ Repeatable Read (å¯é‡å¤è¯»)ï¼šå¼€å¯äº‹åŠ¡åç¬¬ä¸€ä¸ªselectè¯­å¥æ‰æ˜¯å¿«ç…§è¯»çš„åœ°æ–¹ã€‚ Serializable (ä¸²è¡ŒåŒ–)ï¼šå¿«ç…§è¯»ä¼šé€€åŒ–ä¸ºå½“å‰è¯»ã€‚ MVCC å…¨ç§° Multi-Version Concurrency Controlï¼Œå¤šç‰ˆæœ¬å¹¶å‘æ§åˆ¶ã€‚ æŒ‡ç»´æŠ¤ä¸€ä¸ªæ•°æ®çš„å¤šä¸ªç‰ˆæœ¬ï¼Œä½¿å¾—è¯»å†™æ“ä½œæ²¡æœ‰å†²çªï¼Œå¿«ç…§è¯»ä¸ºMySQLå®ç°MVCCæä¾›äº†ä¸€ä¸ªéé˜»å¡è¯»åŠŸèƒ½ã€‚ MVCCçš„å…·ä½“å®ç°ï¼Œè¿˜éœ€è¦ä¾èµ–äºæ•°æ®åº“è®°å½•ä¸­çš„ä¸‰ä¸ªéšå¼å­—æ®µã€undo logæ—¥å¿—ã€readViewã€‚ éšè—å­—æ®µ å½“æˆ‘ä»¬åˆ›å»ºä¸€å¼ è¡¨æ—¶ï¼Œé™¤äº†æˆ‘ä»¬è‡ªå·±å®šä¹‰çš„å­—æ®µå¤–ï¼ŒInnoDBè¿˜ä¼šè‡ªåŠ¨ç»™æˆ‘ä»¬æ·»åŠ ä¸‰ä¸ªéšè—å­—æ®µã€‚ å‰ä¸¤ä¸ªå­—æ®µæ˜¯è‚¯å®šä¼šæ·»åŠ çš„ï¼Œæ˜¯å¦æ·»åŠ æœ€åä¸€ä¸ªå­—æ®µDB_ROW_IDï¼Œå¾—çœ‹å½“å‰è¡¨æœ‰æ²¡æœ‰ä¸»é”®ï¼Œå¦‚æœæœ‰ä¸»é”®ï¼Œåˆ™ä¸ä¼šæ·»åŠ è¯¥éšè—å­—æ®µã€‚ éšè—å­—æ®µ å«ä¹‰ DB_TRX_ID æœ€è¿‘ä¿®æ”¹äº‹åŠ¡IDï¼Œè®°å½•æ’å…¥è¿™æ¡è®°å½•æˆ–æœ€åä¸€æ¬¡ä¿®æ”¹è¯¥è®°å½•çš„äº‹åŠ¡ID DB_ROLL_PTR å›æ»šæŒ‡é’ˆï¼ŒæŒ‡å‘è¿™æ¡è®°å½•çš„ä¸Šä¸€ä¸ªç‰ˆæœ¬ï¼Œç”¨äºé…åˆundo logï¼ŒæŒ‡å‘ä¸Šä¸€ä¸ªç‰ˆæœ¬ DB_ROW_ID éšè—ä¸»é”®ï¼Œå¦‚æœè¡¨ç»“æ„æ²¡æœ‰æŒ‡å®šä¸»é”®ï¼Œå°†ä¼šç”Ÿæˆè¯¥éšè—å­—æ®µ undo log å›æ»šæ—¥å¿—ï¼Œåœ¨insertã€updateã€deleteçš„æ—¶å€™äº§ç”Ÿçš„ä¾¿äºæ•°æ®å›æ»šçš„æ—¥å¿—ã€‚ å½“insertçš„æ—¶å€™ï¼Œäº§ç”Ÿçš„undo logæ—¥å¿—åªåœ¨å›æ»šæ—¶éœ€è¦ï¼Œåœ¨äº‹åŠ¡æäº¤åï¼Œå¯è¢«ç«‹å³åˆ é™¤ã€‚ è€Œupdateã€deleteçš„æ—¶å€™ï¼Œäº§ç”Ÿçš„undo logæ—¥å¿—ä¸ä»…åœ¨å›æ»šæ—¶éœ€è¦ï¼Œåœ¨å¿«ç…§è¯»æ—¶ä¹Ÿéœ€è¦ï¼Œä¸ä¼šç«‹å³è¢«åˆ é™¤ã€‚ ç‰ˆæœ¬é“¾ æœ‰ä¸€å¼ è¡¨åŸå§‹æ•°æ®ä¸ºï¼š DB_TRX_IDï¼šä»£è¡¨æœ€è¿‘ä¿®æ”¹äº‹åŠ¡IDï¼Œè®°å½•æ’å…¥è¿™æ¡è®°å½•æˆ–æœ€åä¸€æ¬¡ä¿®æ”¹è¯¥è®°å½•çš„äº‹åŠ¡IDï¼Œæ˜¯è‡ªå¢çš„ã€‚ DB_ROLL_PTRï¼šç”±äºè¿™æ¡æ•°æ®æ˜¯æ‰æ’å…¥çš„ï¼Œæ²¡æœ‰è¢«æ›´æ–°è¿‡ï¼Œæ‰€ä»¥è¯¥å­—æ®µå€¼ä¸ºnullã€‚ id age name DB_TRX_ID DB_ROLL_PTR 30 30 A30 1 null ç„¶åï¼Œæœ‰å››ä¸ªå¹¶å‘äº‹åŠ¡åŒæ—¶åœ¨è®¿é—®è¿™å¼ è¡¨ã€‚ \u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;äº‹åŠ¡A\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash; \u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;äº‹åŠ¡B\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash; \u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;äº‹åŠ¡C\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash; \u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;äº‹åŠ¡D\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash; å¼€å§‹äº‹åŠ¡ å¼€å§‹äº‹åŠ¡ å¼€å§‹äº‹åŠ¡ å¼€å§‹äº‹åŠ¡ ä¿®æ”¹idä¸º30è®°å½•ï¼Œageä¸º3 æŸ¥è¯¢idä¸º30çš„è®°å½• å½“äº‹åŠ¡Aæ‰§è¡Œç¬¬ä¸€æ¡ä¿®æ”¹è¯­å¥æ—¶ï¼Œä¼šè®°å½•undo logæ—¥å¿—ï¼Œè®°å½•æ•°æ®å˜æ›´ä¹‹å‰çš„æ ·å­ï¼›ç„¶åæ›´æ–°è®°å½•ï¼Œå¹¶ä¸”è®°å½•æœ¬æ¬¡æ“ä½œçš„äº‹åŠ¡IDï¼Œå›æ»šæŒ‡é’ˆï¼Œå›æ»šæŒ‡é’ˆç”¨æ¥æŒ‡å®šå¦‚æœå‘ç”Ÿå›æ»šï¼Œå›æ»šåˆ°å“ªä¸€ä¸ªç‰ˆæœ¬ã€‚ ç„¶åï¼Œäº‹åŠ¡Aæäº¤äº‹åŠ¡ï¼Œäº‹åŠ¡Bæ›´æ–°è®°å½•ã€‚ \u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;äº‹åŠ¡A\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash; \u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;äº‹åŠ¡B\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash; \u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;äº‹åŠ¡C\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash; \u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;äº‹åŠ¡D\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash; å¼€å§‹äº‹åŠ¡ å¼€å§‹äº‹åŠ¡ å¼€å§‹äº‹åŠ¡ å¼€å§‹äº‹åŠ¡ ä¿®æ”¹idä¸º30è®°å½•ï¼Œageä¸º3 æŸ¥è¯¢idä¸º30çš„è®°å½• æäº¤äº‹åŠ¡ ä¿®æ”¹idä¸º30è®°å½•ï¼Œnameä¸ºA3 å½“äº‹åŠ¡Bæ‰§è¡Œç¬¬ä¸€æ¡ä¿®æ”¹è¯­å¥æ—¶ï¼Œä¹Ÿä¼šè®°å½•undo logæ—¥å¿—ï¼Œè®°å½•æ•°æ®å˜æ›´ä¹‹å‰çš„æ ·å­ï¼›ç„¶åæ›´æ–°è®°å½•ï¼Œå¹¶ä¸”è®°å½•æœ¬æ¬¡æ“ä½œçš„äº‹åŠ¡IDï¼Œå›æ»šæŒ‡é’ˆï¼Œå›æ»šæŒ‡é’ˆç”¨æ¥æŒ‡å®šå¦‚æœå‘ç”Ÿå›æ»šï¼Œå›æ»šåˆ°å“ªä¸€ä¸ªç‰ˆæœ¬ã€‚ ç´§æ¥ç€ï¼Œäº‹åŠ¡Bæäº¤ï¼Œäº‹åŠ¡Cæ›´æ–°è®°å½•ã€‚ \u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;äº‹åŠ¡A\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash; \u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;äº‹åŠ¡B\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash; \u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;äº‹åŠ¡C\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;- \u0026mdash;\u0026mdash;\u0026ndash;äº‹åŠ¡D\u0026mdash;\u0026mdash;\u0026ndash; å¼€å§‹äº‹åŠ¡ å¼€å§‹äº‹åŠ¡ å¼€å§‹äº‹åŠ¡ å¼€å§‹äº‹åŠ¡ ä¿®æ”¹idä¸º30è®°å½•ï¼Œageä¸º3 æŸ¥è¯¢idä¸º30çš„è®°å½• æäº¤äº‹åŠ¡ ä¿®æ”¹idä¸º30è®°å½•ï¼Œnameä¸ºA3 æŸ¥è¯¢idä¸º30çš„è®°å½• æäº¤äº‹åŠ¡ ä¿®æ”¹idä¸º30è®°å½•ï¼Œageä¸º10 æŸ¥è¯¢idä¸º30çš„è®°å½• æŸ¥è¯¢idä¸º30çš„è®°å½• æäº¤äº‹åŠ¡ å½“äº‹åŠ¡Cæ‰§è¡Œç¬¬ä¸€æ¡ä¿®æ”¹è¯­å¥æ—¶ï¼Œä¹Ÿä¼šè®°å½•undo logæ—¥å¿—ï¼Œè®°å½•æ•°æ®å˜æ›´ä¹‹å‰çš„æ ·å­ï¼›ç„¶åæ›´æ–°è®°å½•ï¼Œå¹¶ä¸”è®°å½•æœ¬æ¬¡æ“ä½œçš„äº‹åŠ¡IDï¼Œå›æ»šæŒ‡é’ˆï¼Œå›æ»šæŒ‡é’ˆç”¨æ¥æŒ‡å®šå¦‚æœå‘ç”Ÿå›æ»šï¼Œå›æ»šåˆ°å“ªä¸€ä¸ªç‰ˆæœ¬ã€‚ ä¸åŒäº‹åŠ¡æˆ–ç›¸åŒäº‹åŠ¡å¯¹åŒä¸€æ¡è®°å½•è¿›è¡Œä¿®æ”¹ï¼Œä¼šå¯¼è‡´è¯¥è®°å½•çš„undologç”Ÿæˆä¸€æ¡è®°å½•ç‰ˆæœ¬é“¾è¡¨ï¼Œé“¾è¡¨çš„å¤´éƒ¨æ˜¯æœ€æ–°çš„æ—§è®°å½•ï¼Œé“¾è¡¨å°¾éƒ¨æ˜¯æœ€æ—©çš„æ—§è®°å½•ã€‚ readview ReadViewï¼ˆè¯»è§†å›¾ï¼‰æ˜¯å¿«ç…§è¯»SQLæ‰§è¡Œæ—¶MVCCæå–æ•°æ®çš„ä¾æ®ï¼Œè®°å½•å¹¶ç»´æŠ¤ç³»ç»Ÿå½“å‰æ´»è·ƒçš„äº‹åŠ¡ï¼ˆæœªæäº¤çš„ï¼‰idã€‚ ReadViewä¸­åŒ…å«äº†å››ä¸ªæ ¸å¿ƒå­—æ®µï¼š å­—æ®µ å«ä¹‰ m_ids å½“å‰æ´»è·ƒçš„äº‹åŠ¡IDé›†åˆ min_trx_id æœ€å°æ´»è·ƒäº‹åŠ¡ID max_trx_id é¢„åˆ†é…äº‹åŠ¡IDï¼Œå½“å‰æœ€å¤§äº‹åŠ¡ID+1ï¼ˆå› ä¸ºäº‹åŠ¡IDæ˜¯è‡ªå¢çš„ï¼‰ creator_trx_id ReadViewåˆ›å»ºè€…çš„äº‹åŠ¡ID è€Œåœ¨readviewä¸­å°±è§„å®šäº†ç‰ˆæœ¬é“¾æ•°æ®çš„è®¿é—®è§„åˆ™ï¼štrx_id ä»£è¡¨å½“å‰undologç‰ˆæœ¬é“¾å¯¹åº”äº‹åŠ¡IDã€‚ \u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;-æ¡ä»¶\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;- æ˜¯å¦å¯ä»¥è®¿é—® è¯´æ˜ trx_id == creator_trx_id å¯ä»¥è®¿é—®è¯¥ç‰ˆæœ¬ æ•°æ®æ˜¯å½“å‰è¿™ä¸ª trx_id \u0026lt; min_trx_id å¯ä»¥è®¿é—®è¯¥ç‰ˆæœ¬ æ•°æ®å·²ç»æäº¤äº† trx_id \u0026gt; max_trx_id ä¸å¯ä»¥è®¿é—®è¯¥ç‰ˆæœ¬ è¯¥äº‹åŠ¡æ˜¯åœ¨ReadViewç”Ÿæˆåæ‰å¼€å¯ min_trx_id \u0026lt;= trx_id \u0026lt;= max_trx_id å¦‚æœtrx_idä¸åœ¨m_idsä¸­ï¼Œæ˜¯å¯ä»¥è®¿é—®è¯¥ç‰ˆæœ¬çš„ æ•°æ®å·²ç»æäº¤ ä¸åŒçš„éš”ç¦»çº§åˆ«ï¼Œç”ŸæˆReadViewçš„æ—¶æœºä¸åŒ READ COMMITTED (è¯»å·²æäº¤)ï¼šåœ¨äº‹åŠ¡ä¸­æ¯ä¸€æ¬¡æ‰§è¡Œå¿«ç…§è¯»æ—¶ç”ŸæˆReadViewã€‚ REPEATABLE READ (å¯é‡å¤è¯»)ï¼šä»…åœ¨äº‹åŠ¡ä¸­ç¬¬ä¸€æ¬¡æ‰§è¡Œå¿«ç…§è¯»æ—¶ç”ŸæˆReadViewï¼Œåç»­å¤ç”¨è¯¥ReadViewã€‚ åŸç†åˆ†æ RCéš”ç¦»çº§åˆ« RCéš”ç¦»çº§åˆ«ä¸‹ï¼Œåœ¨äº‹åŠ¡ä¸­æ¯ä¸€æ¬¡æ‰§è¡Œå¿«ç…§è¯»æ—¶ç”ŸæˆReadViewã€‚ åˆ†æäº‹åŠ¡Dä¸­ï¼Œä¸¤æ¬¡å¿«ç…§è¯»è¯»å–æ•°æ®ï¼Œæ˜¯å¦‚ä½•è·å–æ•°æ®çš„ã€‚åœ¨äº‹åŠ¡Dä¸­ï¼ŒæŸ¥è¯¢äº†ä¸¤æ¬¡idä¸º30çš„è®°å½•ï¼Œç”±äºéš”ç¦»çº§åˆ«ä¸ºRead Committedï¼Œæ‰€ä»¥æ¯ä¸€æ¬¡è¿›è¡Œå¿«ç…§è¯»éƒ½ä¼šç”Ÿæˆä¸€ä¸ªReadViewï¼Œé‚£ä¹ˆä¸¤æ¬¡ç”Ÿæˆçš„ReadViewã€‚ å…ˆæ¥çœ‹ç¬¬ä¸€æ¬¡å¿«ç…§è¯»å…·ä½“çš„è¯»å–è¿‡ç¨‹ï¼š å½“trx_id=3ä»£å…¥åˆ¤æ–­è§„åˆ™ä¸­ï¼Œ(1)~(4)éƒ½ä¸æ»¡è¶³ã€‚ å½“trx_id=2ä»£å…¥åˆ¤æ–­è§„åˆ™ä¸­ï¼Œ(1)éƒ½ä¸æ»¡è¶³ï¼Œ(2)æ»¡è¶³ã€‚å› æ­¤è¯»å–çš„æ˜¯è¿™æ¡æ•°æ®ã€‚ ç¬¬äºŒæ¬¡å¿«ç…§è¯»å…·ä½“çš„è¯»å–è¿‡ç¨‹ï¼š å½“trx_id=4ä»£å…¥åˆ¤æ–­è§„åˆ™ä¸­ï¼Œ(1)~(4)éƒ½ä¸æ»¡è¶³ã€‚ å½“trx_id=3ä»£å…¥åˆ¤æ–­è§„åˆ™ä¸­ï¼Œ(1)éƒ½ä¸æ»¡è¶³ï¼Œ(2)æ»¡è¶³ã€‚å› æ­¤è¯»å–çš„æ˜¯è¿™æ¡æ•°æ®ã€‚ RRéš”ç¦»çº§åˆ« RRéš”ç¦»çº§åˆ«ä¸‹ï¼Œä»…åœ¨äº‹åŠ¡ä¸­ç¬¬ä¸€æ¬¡æ‰§è¡Œå¿«ç…§è¯»æ—¶ç”ŸæˆReadViewï¼Œåç»­å¤ç”¨è¯¥ReadViewã€‚ è€ŒRRæ˜¯å¯é‡å¤è¯»ï¼Œåœ¨ä¸€ä¸ªäº‹åŠ¡ä¸­ï¼Œæ‰§è¡Œä¸¤æ¬¡ç›¸åŒçš„selectè¯­å¥ï¼ŒæŸ¥è¯¢åˆ°çš„ç»“æœæ˜¯ä¸€æ ·çš„ã€‚ ç¬¬ä¸€æ¬¡ä¸RCä¸€æ ·ï¼š å½“trx_id=3ä»£å…¥åˆ¤æ–­è§„åˆ™ä¸­ï¼Œ(1)~(4)éƒ½ä¸æ»¡è¶³ã€‚ å½“trx_id=2ä»£å…¥åˆ¤æ–­è§„åˆ™ä¸­ï¼Œ(1)éƒ½ä¸æ»¡è¶³ï¼Œ(2)æ»¡è¶³ã€‚å› æ­¤è¯»å–çš„æ˜¯è¿™æ¡æ•°æ®ã€‚ ç¬¬äºŒæ¬¡å¿«ç…§è¯»å…·ä½“çš„è¯»å–è¿‡ç¨‹ï¼š å½“trx_id=4ä»£å…¥åˆ¤æ–­è§„åˆ™ä¸­ï¼Œ(1)~(4)éƒ½ä¸æ»¡è¶³ã€‚ å½“trx_id=3ä»£å…¥åˆ¤æ–­è§„åˆ™ä¸­ï¼Œ(1)~(4)éƒ½ä¸æ»¡è¶³ã€‚ å½“trx_id=2ä»£å…¥åˆ¤æ–­è§„åˆ™ä¸­ï¼Œ(1)éƒ½ä¸æ»¡è¶³ï¼Œ(2)æ»¡è¶³ã€‚å› æ­¤è¯»å–çš„æ˜¯è¿™æ¡æ•°æ®ã€‚ å¯ä»¥çœ‹å‡ºåŒä¸€ä¸ªäº‹åŠ¡å†…å¤šæ¬¡è¯»ç¡®å®æ˜¯åŒä¸€æ•°æ®ã€‚ æ€»ç»“ MVCCçš„å®ç°åŸç†å°±æ˜¯é€šè¿‡InnoDBè¡¨çš„éšè—å­—æ®µã€UndoLog ç‰ˆæœ¬é“¾ã€ReadViewæ¥å®ç°çš„ã€‚ è€ŒMVCC + é”ï¼Œåˆ™å®ç°äº†äº‹åŠ¡çš„éš”ç¦»æ€§ã€‚ è€Œä¸€è‡´æ€§åˆ™æ˜¯ç”±redologä¸undologä¿è¯ã€‚ ","permalink":"https://heliu.site/posts/mysql/innodb/","summary":"mysql innodbã€MVCCã€‚","title":"mysql innodb"},{"content":"ç³»ç»Ÿæ•°æ®åº“ Mysqlæ•°æ®åº“å®‰è£…å®Œæˆåï¼Œè‡ªå¸¦äº†ä¸€ä¸‹å››ä¸ªæ•°æ®åº“ï¼Œå…·ä½“ä½œç”¨å¦‚ä¸‹ï¼š æ•°æ®åº“ å«ä¹‰ mysql å­˜å‚¨MySQLæœåŠ¡å™¨æ­£å¸¸è¿è¡Œæ‰€éœ€è¦çš„å„ç§ä¿¡æ¯ ï¼ˆæ—¶åŒºã€ä¸»ä»ã€ç”¨æˆ·ã€æƒé™ç­‰ï¼‰ information_schema æä¾›äº†è®¿é—®æ•°æ®åº“å…ƒæ•°æ®çš„å„ç§è¡¨å’Œè§†å›¾ï¼ŒåŒ…å«æ•°æ®åº“ã€è¡¨ã€å­—æ®µç±»å‹åŠè®¿é—®æƒé™ç­‰ performance_schema ä¸ºMySQLæœåŠ¡å™¨è¿è¡Œæ—¶çŠ¶æ€æä¾›äº†ä¸€ä¸ªåº•å±‚ç›‘æ§åŠŸèƒ½ï¼Œä¸»è¦ç”¨äºæ”¶é›†æ•°æ®åº“æœåŠ¡å™¨æ€§èƒ½å‚æ•° sys åŒ…å«äº†ä¸€ç³»åˆ—æ–¹ä¾¿ DBA å’Œå¼€å‘äººå‘˜åˆ©ç”¨ performance_schema æ€§èƒ½æ•°æ®åº“è¿›è¡Œæ€§èƒ½è°ƒä¼˜å’Œè¯Šæ–­çš„è§†å›¾ mysql mysqlä¸æ˜¯æŒ‡mysqlæœåŠ¡ï¼Œè€Œæ˜¯æŒ‡mysqlçš„å®¢æˆ·ç«¯å·¥å…·ã€‚ è¯­æ³•ï¼š mysql [options] [database] é€‰é¡¹ï¼š -u, --user=name # æŒ‡å®šç”¨æˆ·å -p, --password[=name] # æŒ‡å®šå¯†ç  -h, --host=name # æŒ‡å®šæœåŠ¡å™¨IPæˆ–åŸŸå -P, --port=port # æŒ‡å®šè¿æ¥ç«¯å£ -e, --execute=name # æ‰§è¡ŒSQLè¯­å¥å¹¶é€€å‡º -eé€‰é¡¹å¯ä»¥åœ¨Mysqlå®¢æˆ·ç«¯æ‰§è¡ŒSQLè¯­å¥ï¼Œè€Œä¸ç”¨è¿æ¥åˆ°MySQLæ•°æ®åº“å†æ‰§è¡Œï¼Œå¯¹äºä¸€äº›æ‰¹å¤„ç†è„šæœ¬ï¼Œè¿™ç§æ–¹å¼å°¤å…¶æ–¹ä¾¿ã€‚ mysql -uroot â€“p123456 db01 -e \u0026#34;select * from table\u0026#34;; mysqladmin mysqladmin æ˜¯ä¸€ä¸ªæ‰§è¡Œç®¡ç†æ“ä½œçš„å®¢æˆ·ç«¯ç¨‹åºã€‚å¯ä»¥ç”¨å®ƒæ¥æ£€æŸ¥æœåŠ¡å™¨çš„é…ç½®å’Œå½“å‰çŠ¶æ€ã€åˆ›å»ºå¹¶åˆ é™¤æ•°æ®åº“ç­‰ã€‚ -- å¸®åŠ©æ–‡æ¡£ mysqladmin --help è¯­æ³•: mysqladmin [options] command ... é€‰é¡¹: -u, --user=name # æŒ‡å®šç”¨æˆ·å -p, --password[=name] # æŒ‡å®šå¯†ç  -h, --host=name # æŒ‡å®šæœåŠ¡å™¨IPæˆ–åŸŸå -P, --port=port # æŒ‡å®šè¿æ¥ç«¯å£ -- åˆ é™¤åº“test01 mysqladmin -uroot â€“p1234 drop \u0026#39;test01\u0026#39;; -- æŸ¥çœ‹ç‰ˆæœ¬ mysqladmin -uroot â€“p1234 version; mysqlbinlog ç”±äºæœåŠ¡å™¨ç”Ÿæˆçš„äºŒè¿›åˆ¶æ—¥å¿—æ–‡ä»¶ä»¥äºŒè¿›åˆ¶æ ¼å¼ä¿å­˜ï¼Œæ‰€ä»¥å¦‚æœæƒ³è¦æ£€æŸ¥è¿™äº›æ–‡æœ¬çš„æ–‡æœ¬æ ¼å¼ï¼Œå°±ä¼šä½¿ç”¨åˆ°mysqlbinlog æ—¥å¿—ç®¡ç†å·¥å…·ã€‚ è¯­æ³•ï¼š mysqlbinlog [options] log-files1 log-files2 ... é€‰é¡¹ï¼š -d, --database=name # æŒ‡å®šæ•°æ®åº“åç§°ï¼Œåªåˆ—å‡ºæŒ‡å®šçš„æ•°æ®åº“ç›¸å…³æ“ä½œã€‚ -o, --offset=n # å¿½ç•¥æ‰æ—¥å¿—ä¸­çš„å‰nè¡Œå‘½ä»¤ã€‚ -r,--result-file=name # å°†è¾“å‡ºçš„æ–‡æœ¬æ ¼å¼æ—¥å¿—è¾“å‡ºåˆ°æŒ‡å®šæ–‡ä»¶ã€‚ -s, --short-form # æ˜¾ç¤ºç®€å•æ ¼å¼ï¼Œ çœç•¥æ‰ä¸€äº›ä¿¡æ¯ã€‚ --start-datatime=date1 --stop-datetime=date2 # æŒ‡å®šæ—¥æœŸé—´éš”å†…çš„æ‰€æœ‰æ—¥å¿—ã€‚ --start-position=pos1 --stop-position=pos2 # æŒ‡å®šä½ç½®é—´éš”å†…çš„æ‰€æœ‰æ—¥å¿—ã€‚ æŸ¥çœ‹ binlog.000008 è¿™ä¸ªäºŒè¿›åˆ¶æ–‡ä»¶ä¸­çš„æ•°æ®ä¿¡æ¯ã€‚ mysqlbinlog -s binlog.000008 mysqlshow mysqlshow å®¢æˆ·ç«¯å¯¹è±¡æŸ¥æ‰¾å·¥å…·ï¼Œç”¨æ¥å¾ˆå¿«åœ°æŸ¥æ‰¾å­˜åœ¨å“ªäº›æ•°æ®åº“ã€æ•°æ®åº“ä¸­çš„è¡¨ã€è¡¨ä¸­çš„åˆ—æˆ–è€…ç´¢å¼•ã€‚ è¯­æ³•ï¼š mysqlshow [options] [db_name [table_name [col_name]]] é€‰é¡¹ï¼š --count # æ˜¾ç¤ºæ•°æ®åº“åŠè¡¨çš„ç»Ÿè®¡ä¿¡æ¯ï¼ˆæ•°æ®åº“ï¼Œè¡¨ å‡å¯ä»¥ä¸æŒ‡å®šï¼‰ -i # æ˜¾ç¤ºæŒ‡å®šæ•°æ®åº“æˆ–è€…æŒ‡å®šè¡¨çš„çŠ¶æ€ä¿¡æ¯ -- æŸ¥è¯¢teståº“ä¸­æ¯ä¸ªè¡¨ä¸­çš„å­—æ®µä¹¦ï¼ŒåŠè¡Œæ•° mysqlshow -uroot -p2143 test --count -- æŸ¥è¯¢teståº“ä¸­bookè¡¨çš„è¯¦ç»†æƒ…å†µ mysqlshow -uroot -p2143 test book --count -- æŸ¥è¯¢æ¯ä¸ªæ•°æ®åº“çš„è¡¨çš„æ•°é‡åŠè¡¨ä¸­è®°å½•çš„æ•°é‡ mysqlshow -uroot -p1234 --count -- æŸ¥çœ‹æ•°æ®åº“db01çš„ç»Ÿè®¡ä¿¡æ¯ mysqlshow -uroot -p1234 db01 --count -- æŸ¥çœ‹æ•°æ®åº“db01ä¸­çš„courseè¡¨çš„ä¿¡æ¯ mysqlshow -uroot -p1234 db01 course --count -- æŸ¥çœ‹æ•°æ®åº“db01ä¸­çš„courseè¡¨çš„idå­—æ®µçš„ä¿¡æ¯ mysqlshow -uroot -p1234 db01 course id --count mysqldump mysqldump å®¢æˆ·ç«¯å·¥å…·ç”¨æ¥å¤‡ä»½æ•°æ®åº“æˆ–åœ¨ä¸åŒæ•°æ®åº“ä¹‹é—´è¿›è¡Œæ•°æ®è¿ç§»ã€‚å¤‡ä»½å†…å®¹åŒ…å«åˆ›å»ºè¡¨ï¼ŒåŠæ’å…¥è¡¨çš„SQLè¯­å¥ã€‚ è¯­æ³•ï¼š mysqldump [options] db_name [tables] mysqldump [options] --database/-B db1 [db2 db3...] mysqldump [options] --all-databases/-A è¿æ¥é€‰é¡¹ï¼š -u, --user=name # æŒ‡å®šç”¨æˆ·å -p, --password[=name] # æŒ‡å®šå¯†ç  -h, --host=name # æŒ‡å®šæœåŠ¡å™¨ipæˆ–åŸŸå -P, --port= # æŒ‡å®šè¿æ¥ç«¯å£ è¾“å‡ºé€‰é¡¹ï¼š --add-drop-database # åœ¨æ¯ä¸ªæ•°æ®åº“åˆ›å»ºè¯­å¥å‰åŠ ä¸Š drop database è¯­å¥ --add-drop-table # åœ¨æ¯ä¸ªè¡¨åˆ›å»ºè¯­å¥å‰åŠ ä¸Š drop table è¯­å¥ , é»˜è®¤å¼€å¯ ; ä¸å¼€å¯ (--skip-add-drop-table) -n, --no-create-db # ä¸åŒ…å«æ•°æ®åº“çš„åˆ›å»ºè¯­å¥ -t, --no-create-info # ä¸åŒ…å«æ•°æ®è¡¨çš„åˆ›å»ºè¯­å¥ -d --no-data # ä¸åŒ…å«æ•°æ® -T, --tab=name # è‡ªåŠ¨ç”Ÿæˆä¸¤ä¸ªæ–‡ä»¶ï¼šä¸€ä¸ª.sqlæ–‡ä»¶ï¼Œåˆ›å»ºè¡¨ç»“æ„çš„è¯­å¥ï¼›ä¸€ä¸ª.txtæ–‡ä»¶ï¼Œæ•°æ®æ–‡ä»¶ -- å¤‡ä»½db01æ•°æ®åº“ mysqldump -uroot -p1234 db01 \u0026gt; db01.sql -- å¤‡ä»½db01æ•°æ®åº“ä¸­çš„è¡¨æ•°æ®ï¼Œä¸å¤‡ä»½è¡¨ç»“æ„(-t) mysqldump -uroot -p1234 -t db01 \u0026gt; db01.sql -- å°†db01æ•°æ®åº“çš„è¡¨çš„è¡¨ç»“æ„ä¸æ•°æ®åˆ†å¼€å¤‡ä»½(-T) mysqldump -uroot -p1234 -T /root db01 score mysqlimport/source mysqlimport mysqlimport æ˜¯å®¢æˆ·ç«¯æ•°æ®å¯¼å…¥å·¥å…·ï¼Œç”¨æ¥å¯¼å…¥mysqldump åŠ  -T å‚æ•°åå¯¼å‡ºçš„æ–‡æœ¬æ–‡ä»¶ã€‚ è¯­æ³•ï¼š mysqlimport [options] db_name textfile1 [textfile2...] mysqlimport -uroot -p2143 test /tmp/city.txt source å¦‚æœéœ€è¦å¯¼å…¥sqlæ–‡ä»¶,å¯ä»¥ä½¿ç”¨mysqlä¸­çš„sourceæŒ‡ä»¤: è¯­æ³•ï¼š source /root/xxxxx.sql ","permalink":"https://heliu.site/posts/mysql/tool/","summary":"mysql å¸¸ç”¨å·¥å…·ã€‚","title":"mysql å·¥å…·"},{"content":" ä¸»ä»å¤åˆ¶æ˜¯æŒ‡å°†ä¸»æ•°æ®åº“çš„ DDL å’Œ DML æ“ä½œé€šè¿‡äºŒè¿›åˆ¶æ—¥å¿—ä¼ åˆ°ä»åº“æœåŠ¡å™¨ä¸­ï¼Œç„¶ååœ¨ä»åº“ä¸Šå¯¹è¿™äº›æ—¥å¿—é‡æ–°æ‰§è¡Œï¼ˆä¹Ÿå«é‡åšï¼‰ï¼Œä»è€Œä½¿å¾—ä»åº“å’Œä¸»åº“çš„æ•°æ®ä¿æŒåŒæ­¥ã€‚ MySQLæ”¯æŒä¸€å°ä¸»åº“åŒæ—¶å‘å¤šå°ä»åº“è¿›è¡Œå¤åˆ¶ï¼Œä»åº“åŒæ—¶ä¹Ÿå¯ä»¥ä½œä¸ºå…¶ä»–ä»æœåŠ¡å™¨çš„ä¸»åº“ï¼Œå®ç°é“¾çŠ¶å¤åˆ¶ã€‚ MySQLçš„ä¸»ä»å¤åˆ¶å¹¶ä¸æ˜¯æ•°æ®åº“ç£ç›˜ä¸Šçš„æ–‡ä»¶ç›´æ¥æ‹·è´ï¼Œè€Œæ˜¯é€šè¿‡é€»è¾‘çš„ binlog æ—¥å¿—å¤åˆ¶åˆ°è¦åŒæ­¥çš„æœåŠ¡å™¨æœ¬åœ°ï¼Œç„¶åç”±æœ¬åœ°çš„çº¿ç¨‹è¯»å–æ—¥å¿—é‡Œé¢çš„ SQL è¯­å¥ï¼Œé‡æ–°åº”ç”¨åˆ° MySQL æ•°æ®åº“ä¸­ã€‚ MySQL å¤åˆ¶çš„ä¼˜ç‚¹ä¸»è¦åŒ…å«ä»¥ä¸‹ä¸‰ä¸ªæ–¹é¢ï¼š åšæ•°æ®çš„çƒ­å¤‡ï¼Œä¸»åº“å®•æœºåå¤‡åº“èƒ½å¤ŸåŠæ—¶æ›¿æ¢ä¸»åº“ï¼Œä¿è¯ä¸šåŠ¡å¯ç”¨æ€§ï¼Œèƒ½ä¸€å®šç¨‹åº¦é¿å…æ•°æ®ä¸¢å¤±ã€‚ å®ç°è¯»å†™åˆ†ç¦»ï¼Œä¸»åº“å†™ï¼Œä»åº“è¯»ï¼Œå‡å°ä¸»åº“çš„è¯»å†™å‹åŠ›ã€‚å½“ä¸»åº“æ‰§è¡Œå†™è¿‡ç¨‹åŠ é”æ—¶ï¼Œä¸ä¼šå µå¡ä»åº“è¯»æ“ä½œï¼Œä»è€Œæé«˜äº†æ•°æ®çš„æŸ¥è¯¢æ•ˆç‡ã€‚ åº”å¯¹ä¸šåŠ¡é‡è¶Šæ¥è¶Šå¤§ï¼ŒI/O è®¿é—®é¢‘ç‡è¿‡é«˜ï¼Œå•æœºæ— æ³•æ»¡è¶³çš„é—®é¢˜ã€‚å¢åŠ å¤šä¸ªä»åº“åšè´Ÿè½½ï¼Œèƒ½å¤Ÿé™ä½æ•´ä½“ I/O è®¿é—®é¢‘ç‡ï¼Œæé«˜å•ä¸ªæœºå™¨ I/O æ€§èƒ½ã€‚ åŸç† MySQLä¸»ä»å¤åˆ¶çš„æ ¸å¿ƒå°±æ˜¯äºŒè¿›åˆ¶æ—¥å¿—ï¼Œå…·ä½“çš„è¿‡ç¨‹å¦‚ä¸‹ï¼š åŸºäº binlog å¤åˆ¶æ¨¡å¼ MySQL ä¸»ä»å¤åˆ¶é»˜è®¤æ˜¯å¼‚æ­¥çš„æ¨¡å¼ï¼Œå¤åˆ¶åˆ†æˆä¸‰æ­¥ï¼š Master ä¸»åº“åœ¨äº‹åŠ¡æäº¤æ—¶ï¼Œä¼šæŠŠæ•°æ®å˜æ›´ï¼ˆå¢åˆ æ”¹ï¼‰è®°å½•åœ¨äºŒè¿›åˆ¶æ—¥å¿—æ–‡ä»¶ Binlog ä¸­ã€‚ å½“slaveèŠ‚ç‚¹è¿æ¥masteræ—¶ï¼Œä»åº“è¯»å–ä¸»åº“çš„äºŒè¿›åˆ¶æ—¥å¿—æ–‡ä»¶Binlogï¼Œå†™å…¥åˆ°ä»åº“çš„ä¸­ç»§æ—¥å¿— Relay Logã€‚ slaveé‡åšä¸­ç»§æ—¥å¿—ä¸­çš„äº‹ä»¶ï¼Œå°†æ”¹å˜åæ˜ å®ƒè‡ªå·±çš„æ•°æ®ã€‚ GTID å¤åˆ¶æ¨¡å¼ åœ¨ä¼ ç»Ÿçš„å¤åˆ¶é‡Œé¢ï¼Œå½“å‘ç”Ÿæ•…éšœï¼Œéœ€è¦ä¸»ä»åˆ‡æ¢ï¼Œéœ€è¦æ‰¾åˆ° Binlog å’Œ ä½ç‚¹ä¿¡æ¯ï¼Œæ¢å¤å®Œæˆæ•°æ®ä¹‹åå°†ä¸»èŠ‚ç‚¹æŒ‡å‘æ–°çš„ä¸»èŠ‚ç‚¹ã€‚ åœ¨ MySQL 5.6é‡Œé¢ï¼Œæä¾›äº†æ–°çš„æ•°æ®æ¢å¤æ€è·¯ï¼Œåªéœ€è¦çŸ¥é“ä¸»èŠ‚ç‚¹çš„ IPã€ç«¯å£ä»¥åŠè´¦å·å¯†ç å°±è¡Œï¼Œå› ä¸ºå¤åˆ¶æ˜¯è‡ªåŠ¨çš„ï¼ŒMySQLä¼šé€šè¿‡å†…éƒ¨æœºåˆ¶ GTID è‡ªåŠ¨æ‰¾ç‚¹åŒæ­¥ã€‚ GTID æ˜¯ä»€ä¹ˆ GTID æŒ‡çš„æ˜¯å…¨å±€äº‹åŠ¡ IDï¼Œå…¨ç¨‹æ˜¯ Global Transaction Identifierï¼Œåœ¨æ•´ä¸ªäº‹åŠ¡æµç¨‹ä¸­æ¯ä¸€ä¸ªäº‹åŠ¡ ID æ˜¯å…¨å±€å”¯ä¸€çš„ï¼Œä¸”åœ¨æ•´ä¸ªä¸»ä»å¤åˆ¶æ¶æ„ä¸­è¯¥ ID éƒ½ä¸ä¼šç›¸åŒã€‚ GTID ä¸»ä»å¤åˆ¶æ–¹å¼ åŸºäº GTID çš„ä¸»ä»å¤åˆ¶æ–¹å¼çš„å‡ºç°ï¼Œä¸»è¦æ˜¯ç”¨äºæ›¿æ¢ä¼ ç»Ÿçš„æ—¥å¿—ç‚¹ å¤åˆ¶æ–¹å¼ã€‚ é€šè¿‡GTID å¯ä»¥ä¿è¯æ¯ä¸ªä¸»åº“æäº¤çš„äº‹åŠ¡åœ¨é›†ç¾¤ä¸­éƒ½æœ‰å”¯ä¸€çš„ä¸€ä¸ªäº‹åŠ¡ IDã€‚ å¼ºåŒ–äº†æ•°æ®åº“ä¸»ä»çš„ä¸€è‡´æ€§å’Œæ•…éšœæ¢å¤æ•°æ®çš„å®¹é”™èƒ½åŠ›ï¼Œåœ¨ä¸»åº“ å®•æœºå‘ç”Ÿä¸»ä»åˆ‡æ¢ çš„æƒ…å†µä¸‹ï¼ŒGTID æ–¹å¼å¯ä»¥è®©å…¶ä»–ä»åº“è‡ªåŠ¨æ‰¾åˆ°æ–°ä¸»åº“å¤åˆ¶çš„ä½ç½®ã€‚è€Œä¸” GTID å¯ä»¥å¿½ç•¥å·²ç»æ‰§è¡Œè¿‡çš„äº‹åŠ¡ï¼Œå‡å°‘äº†æ•°æ®å‘ç”Ÿé”™è¯¯çš„æ¦‚ç‡ã€‚ GTID çš„ç»„æˆ GTID ç”±server_uuid + tid ç»„æˆï¼Œå…¶ä¸­ï¼š server_uuidï¼š server_uuid æ˜¯åœ¨ Mysql é¦–æ¬¡å¯åŠ¨è¿‡ç¨‹ä¸­è‡ªåŠ¨ç”Ÿæˆçš„ä¸€ä¸ªuuid(128ä½)éšæœºå€¼ï¼Œç”Ÿæˆåä¼šå°†è¯¥å€¼å­˜å‚¨åˆ°æ•°æ®ç›®å½•çš„auto.cnfä¸­ã€‚å› ä¸ºæ˜¯éšæœºå€¼ï¼Œæ‰€ä»¥ä¸åŒæœåŠ¡å™¨çš„ Mysql çš„server_uuid éƒ½æ˜¯ä¸ç›¸åŒçš„ã€‚ tidï¼šä»£è¡¨äº†è¯¥å®ä¾‹ä¸Šå·²ç»æäº¤çš„äº‹åŠ¡æ•°é‡ï¼Œæ˜¯ä¸€ä¸ªæ•´æ•°ï¼Œåˆå§‹å€¼æ˜¯ 1 ï¼Œæ¯æ¬¡æäº¤äº‹åŠ¡çš„æ—¶å€™åˆ†é…ç»™è¿™ä¸ªäº‹åŠ¡å¹¶åŠ 1ã€‚ GTID å¤åˆ¶å·¥ä½œåŸç† å‡è®¾ä»åº“å¼€å¯äº† binlogï¼Œé‚£ä¹ˆæ‰§è¡Œæµç¨‹å¦‚ä¸‹ï¼š ä¸»èŠ‚ç‚¹æ‰§è¡Œäº‹åŠ¡æäº¤å‰ä¼šäº§ç”Ÿä¸€ä¸ª GTID ï¼Œå…¶ä¼šéšç€äº‹åŠ¡ä¸€èµ·è®°å½•åˆ° binlog æ—¥å¿—ä¸­ã€‚ ä»èŠ‚ç‚¹I/O Threadä¼šè¯»å–ä¸»èŠ‚ç‚¹çš„binlogæ—¥å¿—æ–‡ä»¶å¹¶å­˜å‚¨åœ¨ä»èŠ‚ç‚¹çš„relaylogæ—¥å¿—ä¸­ã€‚ä»èŠ‚ç‚¹å°†ä¸»èŠ‚ç‚¹çš„GTIDè¿™ä¸ªå€¼é…ç½®åˆ°gtid_nextä¸­ï¼Œå³ä¸‹ä¸€ä¸ªè¦è¯»å–çš„GTIDå€¼ã€‚ ä»èŠ‚ç‚¹è¯»å–gtid_nextä¸­çš„å€¼ï¼Œç„¶åæŸ¥æ‰¾è‡ªå·±çš„binlogæ—¥å¿—ä¸­æ˜¯å¦æœ‰è¿™ä¸ªGTIDã€‚ å¦‚æœæœ‰è¿™ä¸ªè®°å½•ï¼Œè¯´æ˜è¿™ä¸ªGTIDçš„äº‹åŠ¡å·²ç»æ‰§è¡Œè¿‡äº†ï¼Œå°±å¿½ç•¥æ‰ã€‚ å¦‚æœæ²¡æœ‰è¿™ä¸ªè®°å½•ï¼Œä»èŠ‚ç‚¹å°±ä¼šæ‰§è¡Œè¯¥GTIDäº‹åŠ¡ï¼Œå¹¶è®°å½•åˆ°è‡ªå·±çš„binlogæ—¥å¿—ä¸­ã€‚åœ¨è¯»å–æ‰§è¡Œäº‹åŠ¡å‰ä¼šå…ˆæ£€æŸ¥å…¶ä»–sessionä¸­æ˜¯å¦æŒæœ‰è¯¥GTID ï¼Œç¡®ä¿ä¸è¢«é‡å¤æ‰§è¡Œã€‚ åœ¨è§£æè¿‡ç¨‹ä¸­ä¼šåˆ¤æ–­æ˜¯å¦æœ‰ä¸»é”®ï¼Œå¦‚æœæ²¡æœ‰å°±ç”¨äºŒçº§ç´¢å¼•ï¼Œå¦‚æœæ²¡æœ‰å°±ç”¨å…¨éƒ¨æ‰«æã€‚ GTID ä½¿ç”¨ä¸­çš„é™åˆ¶æ¡ä»¶ GTID å¤åˆ¶æ˜¯é’ˆå¯¹äº‹åŠ¡æ¥è¯´çš„ï¼Œä¸€ä¸ªäº‹åŠ¡åªå¯¹åº”ä¸€ä¸ª GTIDï¼Œå¥½å¤šçš„é™åˆ¶å°±åœ¨äºæ­¤ã€‚å…¶ä¸­ä¸»è¦é™åˆ¶å¦‚ä¸‹ï¼š ä¸èƒ½ä½¿ç”¨create table table_name select * from table_name ã€‚ åœ¨ä¸€ä¸ªäº‹åŠ¡ä¸­æ—¢åŒ…å«äº‹åŠ¡è¡¨ï¼ˆä½¿ç”¨ InnoDB å­˜å‚¨å¼•æ“çš„è¡¨ï¼‰çš„æ“ä½œåˆåŒ…å«éäº‹åŠ¡è¡¨ï¼ˆä½¿ç”¨ MyISAM å­˜å‚¨å¼•æ“çš„è¡¨ï¼‰ã€‚ ä¸æ”¯æŒåˆ›å»ºæˆ–åˆ é™¤ä¸´æ—¶è¡¨æ“ä½œï¼Œå¦‚ CREATE TEMPORARY TABLE or DROP TEMPORARY TABLE è¯­å¥æ“ä½œã€‚ ä½¿ç”¨ GTID å¤åˆ¶ä»åº“è·³è¿‡é”™è¯¯æ—¶ï¼Œä¸æ”¯æŒæ‰§è¡Œè¯¥ ql_slave_skip_counter å‚æ•°çš„è¯­æ³•ã€‚ æ­å»º docker-compose.yml æ–‡ä»¶ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 version: \u0026#39;3.9\u0026#39; services: mysql-master: container_name: mysql-master hostname: mysql-master image: mysql:8.0.19 ports: - 3306:3306 volumes: - ./master/data:/var/lib/mysql - ./master/my.cnf:/etc/mysql/conf.d/my.cnf - ./master/init_db/:/docker-entrypoint-initdb.d/ - /etc/localtime:/etc/localtime:ro environment: TZ: Asia/Shanghai MYSQL_ROOT_PASSWORD: 123456 MYSQL_DATABASE: test character-set-server: utf8mb4 collation-server: utf8mb4_general_ci default-authentication-plugin: mysql_native_password restart: unless-stopped privileged: true healthcheck: test: [ \u0026#34;CMD\u0026#34;, \u0026#34;mysqladmin\u0026#34; ,\u0026#34;ping\u0026#34;, \u0026#34;-h\u0026#34;, \u0026#34;localhost\u0026#34;, \u0026#34;--silent\u0026#34; ] interval: 10s timeout: 10s retries: 3 networks: basenetwork: ipv4_address: 172.16.0.101 mysql-slave1: container_name: mysql-slave1 hostname: mysql-slave1 image: mysql:8.0.19 ports: - 3307:3306 volumes: - ./slave01/data:/var/lib/mysql - ./slave01/my.cnf:/etc/mysql/conf.d/my.cnf - ./slave01/init_db/:/docker-entrypoint-initdb.d/ - /etc/localtime:/etc/localtime:ro environment: TZ: Asia/Shanghai MYSQL_ROOT_PASSWORD: 123456 MYSQL_DATABASE: test character-set-server: utf8mb4 collation-server: utf8mb4_general_ci default-authentication-plugin: mysql_native_password restart: unless-stopped privileged: true healthcheck: test: [ \u0026#34;CMD\u0026#34;, \u0026#34;mysqladmin\u0026#34; ,\u0026#34;ping\u0026#34;, \u0026#34;-h\u0026#34;, \u0026#34;localhost\u0026#34;, \u0026#34;--silent\u0026#34; ] interval: 10s timeout: 10s retries: 3 networks: basenetwork: ipv4_address: 172.16.0.102 mysql-slave2: container_name: mysql-slave2 hostname: mysql-slave2 image: mysql:8.0.19 ports: - 3308:3306 volumes: - ./slave02/data:/var/lib/mysql - ./slave02/my.cnf:/etc/mysql/conf.d/my.cnf - ./slave02/init_db/:/docker-entrypoint-initdb.d/ - /etc/localtime:/etc/localtime:ro environment: TZ: Asia/Shanghai MYSQL_ROOT_PASSWORD: 123456 MYSQL_DATABASE: test character-set-server: utf8mb4 collation-server: utf8mb4_general_ci default-authentication-plugin: mysql_native_password restart: unless-stopped privileged: true healthcheck: test: [ \u0026#34;CMD\u0026#34;, \u0026#34;mysqladmin\u0026#34; ,\u0026#34;ping\u0026#34;, \u0026#34;-h\u0026#34;, \u0026#34;localhost\u0026#34;, \u0026#34;--silent\u0026#34; ] interval: 10s timeout: 10s retries: 3 networks: basenetwork: ipv4_address: 172.16.0.103 networks: basenetwork: driver: bridge ipam: driver: default config: - subnet: 172.16.0.0/24 masteré…ç½® ä¿®æ”¹é…ç½®æ–‡ä»¶ /etc/my.cnfã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 [mysqld] # å¼€å¯ gtid æ¨¡å¼ gtid_mode=on # é…ç½®ä¸å…è®¸ä»»ä½•äº‹åŠ¡è¿å GTID ä¸€è‡´æ€§,ç”¨äºä¿è¯æ•°æ®ä¸€è‡´æ€§ enforce_gtid_consistency=on # å¼€å¯äºŒè¿›åˆ¶æ—¥å¿— binlog log-bin=mysql-bin # mysql æœåŠ¡IDï¼Œä¿è¯æ•´ä¸ªé›†ç¾¤ç¯å¢ƒä¸­å”¯ä¸€ï¼Œå–å€¼èŒƒå›´ï¼š1 â€“ 232-1ï¼Œé»˜è®¤ä¸º1 server-id=1 # ä»èŠ‚ç‚¹ä»ä¸»èŠ‚ç‚¹æ¥æ”¶åˆ°æ›´æ–°ä¸”æ‰§è¡Œï¼Œæ˜¯å¦å°†è®°å½•å­˜åˆ°ä»èŠ‚ç‚¹çš„ binlog æ—¥å¿—ä¸­ï¼ˆå¯é€‰ï¼‰ log-slave-updates=on # å½“ä»æ•°æ®åº“å¯åŠ¨çš„æ—¶å€™ï¼Œä»èŠ‚ç‚¹ä¸ä¼šå¯åŠ¨å¤åˆ¶ï¼ˆå¯é€‰ï¼‰ #skip-slave-start=1 # æ˜¯å¦åªè¯»,1 ä»£è¡¨åªè¯», 0 ä»£è¡¨è¯»å†™ read-only=0 # ä¸éœ€è¦å¤åˆ¶çš„æ•°æ®åº“åï¼ˆmysqlåº“ä¸€èˆ¬ä¸åŒæ­¥ï¼‰ binlog-ignore-db=mysql #binlog-ignore-db=performation_schema #binlog-ignore-db=information_schema # æŒ‡å®šåŒæ­¥çš„æ•°æ®åº“ #binlog-do-db=db01 # åªä¿ç•™7å¤©çš„äºŒè¿›åˆ¶æ—¥å¿—ï¼Œä»¥é˜²ç£ç›˜è¢«æ—¥å¿—å æ»¡(å¯é€‰) #expire-logs-days = 7 # ä¸»ä»å¤åˆ¶çš„æ ¼å¼ï¼ˆmixed,statement,rowï¼Œé»˜è®¤æ ¼å¼æ˜¯statementï¼‰ #binlog_format = mixed # ä¸ºæ¯ä¸ªsession åˆ†é…çš„å†…å­˜ï¼Œåœ¨äº‹åŠ¡è¿‡ç¨‹ä¸­ç”¨æ¥å­˜å‚¨äºŒè¿›åˆ¶æ—¥å¿—çš„ç¼“å­˜ # binlog_cache_size = 1M åˆ›å»ºè¿œç¨‹è¿æ¥è´¦å·å¹¶æˆäºˆä¸»ä»å¤åˆ¶æƒé™ã€‚ 1 2 3 4 5 6 7 8 -- åˆ›å»ºicç”¨æˆ·ï¼Œå¹¶è®¾ç½®å¯†ç ï¼Œè¯¥ç”¨æˆ·å¯åœ¨ä»»æ„ä¸»æœºè¿æ¥è¯¥MySQLæœåŠ¡ CREATE USER \u0026#39;ic\u0026#39;@\u0026#39;%\u0026#39; IDENTIFIED WITH mysql_native_password BY \u0026#39;Root@123456\u0026#39;; -- ä¸º \u0026#39;ic\u0026#39;@\u0026#39;%\u0026#39; ç”¨æˆ·åˆ†é…ä¸»ä»å¤åˆ¶æƒé™ GRANT SELECT, REPLICATION SLAVE, REPLICATION CLIENT ON *.* TO \u0026#39;ic\u0026#39;@\u0026#39;%\u0026#39;; -- åˆ·æ–°æƒé™ FLUSH PRIVILEGES; é€šè¿‡æŒ‡ä»¤ï¼ŒæŸ¥çœ‹äºŒè¿›åˆ¶æ—¥å¿—åæ ‡ï¼šshow master status; fileï¼š ä»å“ªä¸ªæ—¥å¿—æ–‡ä»¶å¼€å§‹æ¨é€æ—¥å¿—æ–‡ä»¶ã€‚(ç”¨äºä»åŒæ­¥) positionï¼šä»å“ªä¸ªä½ç½®å¼€å§‹æ¨é€æ—¥å¿—ã€‚(ç”¨äºä»åŒæ­¥) binlog_ignore_dbï¼šæŒ‡å®šä¸éœ€è¦åŒæ­¥çš„æ•°æ®åº“ã€‚ æŸ¥çœ‹masteræ•°æ®æœ‰é‚£äº›slaveã€‚ select * from information_schema.processlist as p where p.command = \u0026#39;Binlog Dump\u0026#39;; slave é…ç½® slave1çš„my.cnfã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 [mysqld] # å¼€å¯ gtid æ¨¡å¼ gtid_mode=on # é…ç½®ä¸å…è®¸ä»»ä½•äº‹åŠ¡è¿å GTID ä¸€è‡´æ€§,ç”¨äºä¿è¯æ•°æ®ä¸€è‡´æ€§ enforce_gtid_consistency=on # å¼€å¯äºŒè¿›åˆ¶æ—¥å¿— binlog log-bin=mysql-bin # mysql æœåŠ¡IDï¼Œä¿è¯æ•´ä¸ªé›†ç¾¤ç¯å¢ƒä¸­å”¯ä¸€ï¼Œå–å€¼èŒƒå›´ï¼š1 â€“ 232-1ï¼Œé»˜è®¤ä¸º1 server-id=2 # ä»èŠ‚ç‚¹ä»ä¸»èŠ‚ç‚¹æ¥æ”¶åˆ°æ›´æ–°ä¸”æ‰§è¡Œï¼Œæ˜¯å¦å°†è®°å½•å­˜åˆ°ä»èŠ‚ç‚¹çš„ binlog æ—¥å¿—ä¸­ï¼ˆå¯é€‰ï¼‰ log-slave-updates=on # å½“ä»æ•°æ®åº“å¯åŠ¨çš„æ—¶å€™ï¼Œä»èŠ‚ç‚¹ä¸ä¼šå¯åŠ¨å¤åˆ¶ï¼ˆå¯é€‰ï¼‰ #skip-slave-start=1 # æ˜¯å¦åªè¯»,1 ä»£è¡¨åªè¯», 0 ä»£è¡¨è¯»å†™ read-only=1 # ä¸éœ€è¦å¤åˆ¶çš„æ•°æ®åº“åï¼ˆmysqlåº“ä¸€èˆ¬ä¸åŒæ­¥ï¼‰ binlog-ignore-db=mysql # æŒ‡å®šåŒæ­¥çš„æ•°æ®åº“ #binlog-do-db=db01 # åªä¿ç•™7å¤©çš„äºŒè¿›åˆ¶æ—¥å¿—ï¼Œä»¥é˜²ç£ç›˜è¢«æ—¥å¿—å æ»¡(å¯é€‰) #expire-logs-days = 7 # ä¸»ä»å¤åˆ¶çš„æ ¼å¼ï¼ˆmixed,statement,rowï¼Œé»˜è®¤æ ¼å¼æ˜¯statementï¼‰ #binlog_format = mixed # ä¸ºæ¯ä¸ªsession åˆ†é…çš„å†…å­˜ï¼Œåœ¨äº‹åŠ¡è¿‡ç¨‹ä¸­ç”¨æ¥å­˜å‚¨äºŒè¿›åˆ¶æ—¥å¿—çš„ç¼“å­˜ # binlog_cache_size = 1M slave2çš„my.cnfã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 [mysqld] # å¼€å¯ gtid æ¨¡å¼ gtid_mode=on # é…ç½®ä¸å…è®¸ä»»ä½•äº‹åŠ¡è¿å GTID ä¸€è‡´æ€§,ç”¨äºä¿è¯æ•°æ®ä¸€è‡´æ€§ enforce_gtid_consistency=on # å¼€å¯äºŒè¿›åˆ¶æ—¥å¿— binlog log-bin=mysql-bin # mysql æœåŠ¡IDï¼Œä¿è¯æ•´ä¸ªé›†ç¾¤ç¯å¢ƒä¸­å”¯ä¸€ï¼Œå–å€¼èŒƒå›´ï¼š1 â€“ 232-1ï¼Œé»˜è®¤ä¸º1 server-id=3 # ä»èŠ‚ç‚¹ä»ä¸»èŠ‚ç‚¹æ¥æ”¶åˆ°æ›´æ–°ä¸”æ‰§è¡Œï¼Œæ˜¯å¦å°†è®°å½•å­˜åˆ°ä»èŠ‚ç‚¹çš„ binlog æ—¥å¿—ä¸­ï¼ˆå¯é€‰ï¼‰ log-slave-updates=on # å½“ä»æ•°æ®åº“å¯åŠ¨çš„æ—¶å€™ï¼Œä»èŠ‚ç‚¹ä¸ä¼šå¯åŠ¨å¤åˆ¶ï¼ˆå¯é€‰ï¼‰ #skip-slave-start=1 # æ˜¯å¦åªè¯»,1 ä»£è¡¨åªè¯», 0 ä»£è¡¨è¯»å†™ read-only=1 # ä¸éœ€è¦å¤åˆ¶çš„æ•°æ®åº“åï¼ˆmysqlåº“ä¸€èˆ¬ä¸åŒæ­¥ï¼‰ binlog-ignore-db=mysql # æŒ‡å®šåŒæ­¥çš„æ•°æ®åº“ #binlog-do-db=db01 # åªä¿ç•™7å¤©çš„äºŒè¿›åˆ¶æ—¥å¿—ï¼Œä»¥é˜²ç£ç›˜è¢«æ—¥å¿—å æ»¡(å¯é€‰) #expire-logs-days = 7 # ä¸»ä»å¤åˆ¶çš„æ ¼å¼ï¼ˆmixed,statement,rowï¼Œé»˜è®¤æ ¼å¼æ˜¯statementï¼‰ #binlog_format = mixed # ä¸ºæ¯ä¸ªsession åˆ†é…çš„å†…å­˜ï¼Œåœ¨äº‹åŠ¡è¿‡ç¨‹ä¸­ç”¨æ¥å­˜å‚¨äºŒè¿›åˆ¶æ—¥å¿—çš„ç¼“å­˜ # binlog_cache_size = 1M è®¾ç½®ä¸»åº“é…ç½®ã€‚ 1 2 3 4 -- 8.0.23ä¸­çš„è¯­æ³• CHANGE REPLICATION SOURCE TO SOURCE_HOST=\u0026#39;mysql-master\u0026#39;, SOURCE_USER=\u0026#39;ic\u0026#39;, SOURCE_PASSWORD=\u0026#39;Root@123456\u0026#39;, SOURCE_PORT=3306, SOURCE_LOG_FILE=\u0026#39;binlog.000004\u0026#39;, SOURCE_LOG_POS=663; 1 2 3 4 -- mysql8.0.23 ä¹‹å‰çš„ç‰ˆæœ¬ CHANGE MASTER TO MASTER_HOST=\u0026#39;mysql-master\u0026#39;, MASTER_USER=\u0026#39;ic\u0026#39;, MASTER_PASSWORD=\u0026#39;Root@123456\u0026#39;, MASTER_PORT=3306, MASTER_LOG_FILE=\u0026#39;binlog.000004\u0026#39;, MASTER_LOG_POS=663; å‚æ•°å å«ä¹‰ 8.0.23å‰ SOURCE_HOST ä¸»åº“IPåœ°å€ MASTER_HOST SOURCE_USER è¿æ¥ä¸»åº“çš„ç”¨æˆ·å MASTER_USER SOURCE_PASSWORD è¿æ¥ä¸»åº“çš„å¯†ç  MASTER_PASSWORD SOURCE_LOG_FILE binlogæ—¥å¿—æ–‡ä»¶å MASTER_LOG_FILE SOURCE_LOG_POS binlogæ—¥å¿—æ–‡ä»¶ä½ç½® MASTER_LOG_POS SOURCE_CONNECT_RETRY è¿æ¥å¤±è´¥ï¼Œé‡è¯•çš„æ—¶é—´é—´éš”/ç§’ï¼Œé»˜è®¤60ç§’ MASTER_CONNECT_RETRY å¼€å¯åŒæ­¥æ“ä½œã€‚(ä»åº“æ‰§è¡Œ) 1 2 3 4 5 -- mysql8.0.22ç‰ˆæœ¬ä¹‹å start replica; -- mysql8.0.22ç‰ˆæœ¬ä¹‹å‰ start slave; æŸ¥çœ‹ä¸»ä»åŒæ­¥çŠ¶æ€ã€‚(ä»åº“æ‰§è¡Œ) 1 2 3 4 5 -- mysql8.0.22ç‰ˆæœ¬ä¹‹å show replica status; -- mysql8.0.22ç‰ˆæœ¬ä¹‹å‰ show slave status; æµ‹è¯• åœ¨masterè¿è¡Œå¦‚ä¸‹ä»£ç ã€‚ create database db01; use db01; create table tb_user( id int(11) primary key not null auto_increment, name varchar(50) not null, sex varchar(1) )engine=innodb default charset=utf8mb4; insert into tb_user(id,name,sex) values(null,\u0026#39;Tom\u0026#39;, \u0026#39;1\u0026#39;),(null,\u0026#39;Trigger\u0026#39;,\u0026#39;0\u0026#39;),(null,\u0026#39;Dawn\u0026#39;,\u0026#39;1\u0026#39;); åœ¨slave01å’Œslave02ä¸­åˆ†åˆ«éªŒè¯ã€‚ æŸ¥çœ‹masteræ•°æ®æœ‰é‚£äº›slaveã€‚ select * from information_schema.processlist as p where p.command = \u0026#39;Binlog Dump\u0026#39;; æ³¨æ„ CHANGE MASTER åªèƒ½åŒæ­¥åç»­å˜åŒ–æ•°æ®ï¼Œé¦–æ¬¡æ•°æ®éœ€è¦ï¼Œè‡ªå·±æ‰‹åŠ¨åœ¨æ‰€æœ‰slaveä¸Šè¿è¡Œä¸€éã€‚ github å®Œæ•´çš„ä»£ç è¯·å‰å¾€github, https://github.com/helium-chain/master-slaveã€‚ ","permalink":"https://heliu.site/posts/mysql/master/","summary":"mysql ä¸»ä»å¤åˆ¶ã€‚","title":"mysql ä¸»ä»å¤åˆ¶"},{"content":" éšç€äº’è”ç½‘åŠç§»åŠ¨äº’è”ç½‘çš„å‘å±•ï¼Œåº”ç”¨ç³»ç»Ÿçš„æ•°æ®é‡ä¹Ÿæ˜¯æˆæŒ‡æ•°å¼å¢é•¿ï¼Œè‹¥é‡‡ç”¨å•æ•°æ®åº“è¿›è¡Œæ•°æ®å­˜å‚¨ï¼Œå­˜åœ¨ä»¥ä¸‹æ€§èƒ½ç“¶é¢ˆï¼š IOç“¶é¢ˆï¼šçƒ­ç‚¹æ•°æ®å¤ªå¤šï¼Œæ•°æ®åº“ç¼“å­˜ä¸è¶³ï¼Œäº§ç”Ÿå¤§é‡ç£ç›˜IOï¼Œæ•ˆç‡è¾ƒä½ã€‚è¯·æ±‚æ•°æ®å¤ªå¤šï¼Œå¸¦å®½ä¸å¤Ÿï¼Œç½‘ç»œIOç“¶é¢ˆã€‚ CPUç“¶é¢ˆï¼šæ’åºã€åˆ†ç»„ã€è¿æ¥æŸ¥è¯¢ã€èšåˆç»Ÿè®¡ç­‰SQLä¼šè€—è´¹å¤§é‡çš„CPUèµ„æºï¼Œè¯·æ±‚æ•°å¤ªå¤šï¼ŒCPUå‡ºç°ç“¶é¢ˆã€‚ ä¸ºäº†è§£å†³ä¸Šè¿°é—®é¢˜ï¼Œæˆ‘ä»¬éœ€è¦å¯¹æ•°æ®åº“è¿›è¡Œåˆ†åº“åˆ†è¡¨å¤„ç†ã€‚åˆ†åº“åˆ†è¡¨çš„ä¸­å¿ƒæ€æƒ³éƒ½æ˜¯å°†æ•°æ®åˆ†æ•£å­˜å‚¨ï¼Œä½¿å¾—å•ä¸€æ•°æ®åº“/è¡¨çš„æ•°æ®é‡å˜å°æ¥ç¼“è§£å•ä¸€æ•°æ®åº“çš„æ€§èƒ½é—®é¢˜ï¼Œä»è€Œè¾¾åˆ°æå‡æ•°æ®åº“æ€§èƒ½çš„ç›®çš„ã€‚ æ‹†åˆ†ç­–ç•¥ åˆ†åº“åˆ†è¡¨çš„å½¢å¼ï¼Œä¸»è¦æ˜¯ä¸¤ç§ï¼šå‚ç›´æ‹†åˆ†å’Œæ°´å¹³æ‹†åˆ†ã€‚ è€Œæ‹†åˆ†çš„ç²’åº¦ï¼Œä¸€èˆ¬åˆåˆ†ä¸ºåˆ†åº“å’Œåˆ†è¡¨ï¼Œæ‰€ä»¥ç»„æˆçš„æ‹†åˆ†ç­–ç•¥æœ€ç»ˆå¦‚ä¸‹ï¼š \u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;å‚ç›´æ‹†åˆ†\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash; \u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;æ°´å¹³æ‹†åˆ†\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash; å‚ç›´åˆ†åº“ æ°´å¹³åˆ†åº“ å‚ç›´åˆ†è¡¨ æ°´å¹³åˆ†è¡¨ å‚ç›´æ‹†åˆ† å‚ç›´åˆ†åº“ å‚ç›´åˆ†åº“ï¼šä»¥è¡¨ä¸ºä¾æ®ï¼Œæ ¹æ®ä¸šåŠ¡å°†ä¸åŒè¡¨æ‹†åˆ†åˆ°ä¸åŒåº“ä¸­ã€‚ ç‰¹ç‚¹ï¼š æ¯ä¸ªåº“çš„è¡¨ç»“æ„éƒ½ä¸ä¸€æ ·ã€‚ æ¯ä¸ªåº“çš„æ•°æ®ä¹Ÿä¸ä¸€æ ·ã€‚ æ‰€æœ‰åº“çš„å¹¶é›†æ˜¯å…¨é‡æ•°æ®ã€‚ æ¯”è¾ƒå¸¸ç”¨å‚ç›´åˆ†åº“ï¼Œæ¯”å¦‚äº§å“ç»´åº¦åˆ†å•†å“è¡¨åº“å’Œè´­ç‰©è½¦è¡¨åº“ã€‚ å‚ç›´åˆ†è¡¨ å‚ç›´åˆ†è¡¨ï¼šä»¥å­—æ®µä¸ºä¾æ®ï¼Œæ ¹æ®å­—æ®µå±æ€§å°†ä¸åŒå­—æ®µæ‹†åˆ†åˆ°ä¸åŒè¡¨ä¸­ã€‚ ç‰¹ç‚¹ï¼š æ¯ä¸ªè¡¨çš„ç»“æ„éƒ½ä¸ä¸€æ ·ã€‚ æ¯ä¸ªè¡¨çš„æ•°æ®ä¹Ÿä¸ä¸€æ ·ï¼Œä¸€èˆ¬é€šè¿‡ä¸€åˆ—ï¼ˆä¸»é”®/å¤–é”®ï¼‰å…³è”ã€‚ æ‰€æœ‰è¡¨çš„å¹¶é›†æ˜¯å…¨é‡æ•°æ®ã€‚ å½“æˆ‘ä»¬çš„æ•°æ®è¡¨æœ‰å¾ˆå¤šå†—ä½™å­—æ®µæ—¶ï¼Œå¯é‡‡å–å‚ç›´åˆ†è¡¨ï¼Œè¿™æ ·èƒ½æŠŠçƒ­ç‚¹å­—æ®µåˆ†ä¸ºä¸€ä¸ªè¡¨ï¼Œå…¶ä»–å­—æ®µåˆ†ä¸ºä¸€ä¸ªè¡¨ã€‚ æ°´å¹³æ‹†åˆ† æ°´å¹³åˆ†åº“ æ°´å¹³åˆ†åº“ï¼šä»¥å­—æ®µä¸ºä¾æ®ï¼ŒæŒ‰ç…§ä¸€å®šç­–ç•¥ï¼Œå°†ä¸€ä¸ªåº“çš„æ•°æ®æ‹†åˆ†åˆ°å¤šä¸ªåº“ä¸­ã€‚ ç‰¹ç‚¹ï¼š æ¯ä¸ªåº“çš„è¡¨ç»“æ„éƒ½ä¸€æ ·ã€‚ æ¯ä¸ªåº“çš„æ•°æ®éƒ½ä¸ä¸€æ ·ã€‚ æ‰€æœ‰åº“çš„å¹¶é›†æ˜¯å…¨é‡æ•°æ®ã€‚ æ°´å¹³åˆ†åº“å¾ˆå°‘è§ï¼Œä¸æ¨èè¿™ç§ã€‚ æ°´å¹³åˆ†è¡¨ æ°´å¹³åˆ†è¡¨ï¼šä»¥å­—æ®µä¸ºä¾æ®ï¼ŒæŒ‰ç…§ä¸€å®šç­–ç•¥ï¼Œå°†ä¸€ä¸ªè¡¨çš„æ•°æ®æ‹†åˆ†åˆ°å¤šä¸ªè¡¨ä¸­ã€‚ ç‰¹ç‚¹ï¼š æ¯ä¸ªè¡¨çš„è¡¨ç»“æ„éƒ½ä¸€æ ·ã€‚ æ¯ä¸ªè¡¨çš„æ•°æ®éƒ½ä¸ä¸€æ ·ã€‚ æ‰€æœ‰è¡¨çš„å¹¶é›†æ˜¯å…¨é‡æ•°æ®ã€‚ æ°´å¹³åˆ†è¡¨æ¯”è¾ƒå¸¸è§ï¼Œæ¯”å¦‚ä¸€å¼ è¡¨çš„æ•°æ®å¤ªå¤§äº†è¶…åƒä¸‡çº§åˆ«ï¼Œå¯¼è‡´ç´¢å¼•æ£€ç´¢å˜æ…¢ï¼Œå¯ä»¥é‡‡ç”¨æ°´å¹³åˆ†è¡¨ã€‚ ä¸€æ—¦æ¶‰åŠæ°´å¹³åˆ†å¸ƒï¼Œåˆ™éœ€è¦è€ƒè™‘ä¸»é”®ID(é›ªèŠ±ç®—æ³•)ã€åˆ†å¤šå°‘å¼ è¡¨ï¼Œä»¥åŠåé¢æ‰©å®¹é—®é¢˜ã€‚ å¸¸è§çš„å‡ ç§ç­–ç•¥ï¼š hashå–æ¨¡ï¼šå‡è®¾æœ‰ç”¨æˆ·è¡¨userï¼Œå°†å…¶åˆ†æˆ3ä¸ªè¡¨user0,user1,user2ã€‚è·¯ç”±è§„åˆ™æ˜¯å¯¹3å–æ¨¡,å½“uid=1æ—¶,å¯¹åº”åˆ°çš„æ˜¯user1,uid=2æ—¶,å¯¹åº”çš„æ˜¯user2ã€‚å¥½å¤„åœ¨äºè¯´ï¼Œå¯ä»¥å¹³å‡åˆ†é…æ¯ä¸ªåº“çš„æ•°æ®é‡å’Œè¯·æ±‚å‹åŠ›ï¼›åå¤„åœ¨äºè¯´æ‰©å®¹èµ·æ¥æ¯”è¾ƒéº»çƒ¦ï¼Œä¼šæœ‰ä¸€ä¸ªæ•°æ®è¿ç§»çš„è¿‡ç¨‹ï¼Œä¹‹å‰çš„æ•°æ®éœ€è¦é‡æ–°è®¡ç®— hash å€¼é‡æ–°åˆ†é…åˆ°ä¸åŒçš„åº“æˆ–è¡¨ã€‚ èŒƒå›´åˆ†ç‰‡ï¼šä»1-100wä¸€ä¸ªè¡¨,100w-200wä¸€ä¸ªè¡¨ã€‚å¥½å¤„åœ¨äºè¯´ï¼Œæ‰©å®¹çš„æ—¶å€™å¾ˆç®€å•ï¼Œå› ä¸ºä½ åªè¦é¢„å¤‡å¥½ï¼Œç»™æ¯ä¸ªæœˆéƒ½å‡†å¤‡ä¸€ä¸ªåº“å°±å¯ä»¥äº†ï¼Œåˆ°äº†ä¸€ä¸ªæ–°çš„æœˆä»½çš„æ—¶å€™ï¼Œè‡ªç„¶è€Œç„¶å°±ä¼šå†™æ–°çš„åº“äº†ï¼›ç¼ºç‚¹ï¼Œä½†æ˜¯å¤§éƒ¨åˆ†çš„è¯·æ±‚ï¼Œéƒ½æ˜¯è®¿é—®æœ€æ–°çš„æ•°æ®ã€‚ åœ°ç†ä½ç½®åˆ†ç‰‡ï¼šåå—åŒºä¸€ä¸ªè¡¨,ååŒ—ä¸€ä¸ªè¡¨ã€‚æ ¹æ®åœ°åŒºåˆ’åˆ†è¡¨ã€‚ æ—¶é—´åˆ†ç‰‡ï¼šæŒ‰æœˆåˆ†ç‰‡ï¼ŒæŒ‰å­£åº¦åˆ†ç‰‡ç­‰ç­‰,å¯ä»¥åšåˆ°å†·çƒ­æ•°æ®ã€‚ ç›¸å…³ä¸­é—´ä»¶ shardingJDBCï¼šåŸºäºAOPåŸç†ï¼Œåœ¨åº”ç”¨ç¨‹åºä¸­å¯¹æœ¬åœ°æ‰§è¡Œçš„SQLè¿›è¡Œæ‹¦æˆªï¼Œè§£æã€æ”¹å†™ã€è·¯ç”±å¤„ç†ã€‚éœ€è¦è‡ªè¡Œç¼–ç é…ç½®å®ç°ï¼Œåªæ”¯æŒjavaè¯­è¨€ï¼Œæ€§èƒ½è¾ƒé«˜ã€‚ MyCatï¼šæ•°æ®åº“åˆ†åº“åˆ†è¡¨ä¸­é—´ä»¶ï¼Œä¸ç”¨è°ƒæ•´ä»£ç å³å¯å®ç°åˆ†åº“åˆ†è¡¨ï¼Œæ”¯æŒå¤šç§è¯­è¨€ï¼Œæ€§èƒ½ä¸åŠå‰è€…ã€‚ åˆ†åº“åˆ†è¡¨é—®é¢˜ åˆ†å¸ƒå¼äº‹åŠ¡é—®é¢˜ å¦‚æœæˆ‘ä»¬åšäº†å‚ç›´åˆ†åº“æˆ–è€…æ°´å¹³åˆ†åº“ä»¥å,å°±å¿…ç„¶ä¼šæ¶‰åŠåˆ°è·¨åº“æ‰§è¡ŒSQLçš„é—®é¢˜,è¿™æ ·å°±å¼•å‘äº†äº’è”ç½‘ç•Œçš„è€å¤§éš¾é—®é¢˜-â€œåˆ†å¸ƒå¼äº‹åŠ¡â€ã€‚é‚£è¦å¦‚ä½•è§£å†³è¿™ä¸ªé—®é¢˜å‘¢ï¼Ÿ ä½¿ç”¨åˆ†å¸ƒå¼äº‹åŠ¡ä¸­é—´ä»¶ã€‚ ä½¿ç”¨MySQLè‡ªå¸¦çš„é’ˆå¯¹è·¨åº“çš„äº‹åŠ¡ä¸€è‡´æ€§æ–¹æ¡ˆ(XA),ä¸è¿‡æ€§èƒ½è¦æ¯”å•åº“çš„æ…¢10å€å·¦å³ã€‚ èƒ½å¦é¿å…æ‰è·¨åº“æ“ä½œ(æ¯”å¦‚å°†ç”¨æˆ·å’Œå•†å“æ”¾åœ¨åŒä¸€ä¸ªåº“ä¸­) è·¨åº“joinçš„é—®é¢˜ åˆ†åº“åˆ†è¡¨åè¡¨ä¹‹é—´çš„å…³è”æ“ä½œå°†å—åˆ°é™åˆ¶ï¼Œæˆ‘ä»¬æ— æ³•joinä½äºä¸åŒåˆ†åº“çš„è¡¨ï¼Œä¹Ÿæ— æ³•joinåˆ†è¡¨ç²’åº¦ä¸åŒçš„è¡¨ï¼Œç»“æœåŸæœ¬ä¸€æ¬¡æŸ¥è¯¢èƒ½å¤Ÿå®Œæˆçš„ä¸šåŠ¡ï¼Œå¯èƒ½éœ€è¦å¤šæ¬¡æŸ¥è¯¢æ‰èƒ½å®Œæˆã€‚ç²—ç•¥çš„è§£å†³æ–¹æ³•ï¼š å…¨å±€è¡¨ï¼šåŸºç¡€æ•°æ®ï¼Œæ‰€æœ‰åº“éƒ½æ‹·è´ä¸€ä»½ã€‚ å­—æ®µå†—ä½™ï¼šè¿™æ ·æœ‰äº›å­—æ®µå°±ä¸ç”¨joinå»æŸ¥è¯¢äº†ã€‚ ç³»ç»Ÿå±‚ç»„è£…ï¼šåˆ†åˆ«æŸ¥è¯¢å‡ºæ‰€æœ‰ï¼Œç„¶åç»„è£…èµ·æ¥ï¼Œè¾ƒå¤æ‚ã€‚ æ¨ªå‘æ‰©å®¹çš„é—®é¢˜ å½“æˆ‘ä»¬ä½¿ç”¨HASHå–æ¨¡åšåˆ†è¡¨çš„æ—¶å€™,é’ˆå¯¹æ•°æ®é‡çš„é€’å¢,å¯èƒ½éœ€è¦åŠ¨æ€çš„å¢åŠ è¡¨,æ­¤æ—¶å°±éœ€è¦è€ƒè™‘å› ä¸ºreHashå¯¼è‡´æ•°æ®è¿ç§»çš„é—®é¢˜ã€‚ ç»“æœé›†åˆå¹¶ã€æ’åºçš„é—®é¢˜ å› ä¸ºæˆ‘ä»¬æ˜¯å°†æ•°æ®åˆ†æ•£å­˜å‚¨åˆ°ä¸åŒçš„åº“ã€è¡¨é‡Œçš„,å½“æˆ‘ä»¬æŸ¥è¯¢æŒ‡å®šæ•°æ®åˆ—è¡¨æ—¶,æ•°æ®æ¥æºäºä¸åŒçš„å­åº“æˆ–è€…å­è¡¨,å°±å¿…ç„¶ä¼šå¼•å‘ç»“æœé›†åˆå¹¶ã€æ’åºçš„é—®é¢˜ã€‚å¦‚æœæ¯æ¬¡æŸ¥è¯¢éƒ½éœ€è¦æ’åºã€åˆå¹¶ç­‰æ“ä½œ,æ€§èƒ½è‚¯å®šä¼šå—éå¸¸å¤§çš„å½±å“ã€‚èµ°ç¼“å­˜å¯èƒ½ä¸€æ¡è·¯! ","permalink":"https://heliu.site/posts/mysql/table/","summary":"mysql åˆ†åº“åˆ†è¡¨ç­–ç•¥ã€‚","title":"mysql åˆ†åº“åˆ†è¡¨"},{"content":" Mycatæ˜¯å¼€æºçš„ã€æ´»è·ƒçš„ã€åŸºäºJavaè¯­è¨€ç¼–å†™çš„MySQLæ•°æ®åº“ä¸­é—´ä»¶ã€‚å¯ä»¥åƒä½¿ç”¨mysqlä¸€æ ·æ¥ä½¿ç”¨mycatï¼Œå¯¹äºå¼€å‘äººå‘˜æ¥è¯´æ ¹æœ¬æ„Ÿè§‰ä¸åˆ°mycatçš„å­˜åœ¨ã€‚ å¼€å‘äººå‘˜åªéœ€è¦è¿æ¥MyCatå³å¯ï¼Œè€Œå…·ä½“åº•å±‚ç”¨åˆ°å‡ å°æ•°æ®åº“ï¼Œæ¯ä¸€å°æ•°æ®åº“æœåŠ¡å™¨é‡Œé¢å­˜å‚¨äº†ä»€ä¹ˆæ•°æ®ï¼Œéƒ½æ— éœ€å…³å¿ƒã€‚ å®˜ç½‘åœ°å€ï¼šhttp://www.mycat.org.cn/ å®‰è£… å‚çœ‹åé¢ç¤ºä¾‹ã€‚ ç›®å½•ä»‹ç» bin: å­˜æ”¾å¯æ‰§è¡Œæ–‡ä»¶ï¼Œç”¨äºå¯åŠ¨åœæ­¢mycatã€‚ confï¼šå­˜æ”¾mycatçš„é…ç½®æ–‡ä»¶ã€‚ libï¼šå­˜æ”¾mycatçš„é¡¹ç›®ä¾èµ–åŒ…ï¼ˆjarï¼‰ã€‚ logsï¼šå­˜æ”¾mycatçš„æ—¥å¿—æ–‡ä»¶ã€‚ æ¦‚å¿µ åœ¨MyCatçš„æ•´ä½“ç»“æ„ä¸­ï¼Œåˆ†ä¸ºä¸¤ä¸ªéƒ¨åˆ†ï¼šä¸Šé¢çš„é€»è¾‘ç»“æ„ã€ä¸‹é¢çš„ç‰©ç†ç»“æ„ã€‚ åœ¨MyCatçš„é€»è¾‘ç»“æ„ä¸»è¦è´Ÿè´£é€»è¾‘åº“ã€é€»è¾‘è¡¨ã€åˆ†ç‰‡è§„åˆ™ã€åˆ†ç‰‡èŠ‚ç‚¹ç­‰é€»è¾‘ç»“æ„çš„å¤„ç†ï¼Œè€Œå…·ä½“çš„æ•°æ®å­˜å‚¨è¿˜æ˜¯åœ¨ç‰©ç†ç»“æ„ï¼Œä¹Ÿå°±æ˜¯æ•°æ®åº“æœåŠ¡å™¨ä¸­å­˜å‚¨çš„ã€‚ å…¶ä»– 9066 ç«¯å£ï¼Œç”¨äºæŸ¥çœ‹MyCatç›‘æ§ä¿¡æ¯ã€‚ 8066 ç«¯å£ï¼Œç”¨äºä¸mysqlæ•°æ®äº¤æ¢ã€‚ 9066 ç«¯å£æ”¯æŒå‘½ä»¤ã€‚(é€šè¿‡ï¼šmysql -h localhost -uroot -P9066 -p123456 è¿æ¥) ä»¥ä¸‹ä»‹ç»éƒ¨åˆ†å‘½ä»¤ã€‚æ›´å¤šé€šè¿‡ï¼š**show @@help;**æŸ¥çœ‹ \u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;-å‘½ä»¤\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;- ä½œç”¨ show @@server æŸ¥çœ‹æœåŠ¡å™¨çŠ¶æ€ï¼ŒåŒ…æ‹¬å ç”¨å†…å­˜ç­‰ show @@database æŸ¥çœ‹æ•°æ®åº“ show @@heartbeat å‰åç«¯ç‰©ç†åº“çš„å¿ƒè·³æ£€æµ‹æƒ…å†µ,RS_CODEä¸º1è¡¨ç¤ºå¿ƒè·³æ­£å¸¸ show @@datanode æŸ¥çœ‹æ•°æ®èŠ‚ç‚¹ show @@datasource æŸ¥çœ‹æ•°æ®æº show @@connection è¯¥å‘½ä»¤ç”¨äºè·å– Mycat çš„å‰ç«¯è¿æ¥çŠ¶æ€ï¼Œå³åº”ç”¨ä¸ mycat çš„è¿æ¥ show @@backend æŸ¥çœ‹åç«¯è¿æ¥çŠ¶æ€ show @@cache æŸ¥çœ‹ç¼“å­˜ä½¿ç”¨æƒ…å†µï¼ŒSQLRouteCacheï¼šsqlè·¯ç”±ç¼“å­˜ã€‚TableID2DataNodeCacheï¼šç¼“å­˜è¡¨ä¸»é”®ä¸åˆ†ç‰‡å¯¹åº”å…³ç³»ï¼ŒER_SQL2PARENTID ï¼šç¼“å­˜ ER åˆ†ç‰‡ä¸­å­è¡¨ä¸çˆ¶è¡¨å…³ç³» reload @@config é‡æ–°åŠ è½½åŸºæœ¬é…ç½®ï¼Œä½¿ç”¨è¿™ä¸ªå‘½ä»¤æ—¶ mycatæœåŠ¡ä¸å¯ç”¨ show @@sysparam æŸ¥çœ‹å‚æ•° show @@sql.high æ‰§è¡Œé¢‘ç‡é«˜çš„ SQL show @@sql.slow æ…¢ SQL è®¾ç½®æ…¢ SQL çš„å‘½ä»¤ï¼šreload @@sqlslow=5 MyCaté…ç½® schema.xml schema.xmlä½œä¸ºMyCatä¸­æœ€é‡è¦çš„é…ç½®æ–‡ä»¶ä¹‹ä¸€ , æ¶µç›–äº†MyCatçš„é€»è¾‘åº“ã€é€»è¾‘è¡¨ã€åˆ†ç‰‡è§„åˆ™ã€åˆ†ç‰‡èŠ‚ç‚¹åŠæ•°æ®æºçš„é…ç½®ã€‚ \u0026lt;?xml version=\u0026#34;1.0\u0026#34;?\u0026gt; \u0026lt;!DOCTYPE mycat:schema SYSTEM \u0026#34;schema.dtd\u0026#34;\u0026gt; \u0026lt;mycat:schema xmlns:mycat=\u0026#34;http://io.mycat/\u0026#34;\u0026gt; \u0026lt;!-- é€»è¾‘åº“ --\u0026gt; \u0026lt;!-- name: é€»è¾‘åº“åå­— --\u0026gt; \u0026lt;!-- checkSQLschema: å½“è®¾ç½®ä¸ºtrueæ—¶ï¼Œæ¯”å¦‚å‘é€ä¸€æ¡sql:select * from mycat_order.t_orderï¼Œé‚£ä¹ˆMyCatä¼šè‡ªåŠ¨å»æ‰mycat_orderé€»è¾‘åº“åå­—å‰ç¼€ï¼ŒæŠŠsqlå˜ä¸ºï¼šselect * from t_order, è¿™æ ·æœ‰æ•ˆé¿å…æŠ¥è¡¨æˆ–è§†å›¾ä¸å­˜åœ¨é”™è¯¯ã€‚ å¦‚æœä½¿ç”¨select * from test.t_order ï¼Œsqlè¯­å¥ä¸­æ‰€å¸¦çš„é€»è¾‘åº“åå­—è·Ÿschemaæ ‡ç­¾ä¸­çš„nameä¸ä¸€è‡´çš„è¯ï¼ŒMyCatä¸ä¼šè‡ªåŠ¨å»æ‰é€»è¾‘åº“åå­—å‰ç¼€ï¼Œå¦‚æœé€»è¾‘åº“ä¸å­˜åœ¨ï¼Œä»ç„¶ä¼šæŠ¥é”™ã€‚ --\u0026gt; \u0026lt;!-- sqlMaxLimit: å¦‚æœæ¯æ¬¡æ‰§è¡Œçš„sqlè¯­å¥åé¢æ²¡æœ‰è·Ÿä¸Šlimit xxå…³é”®å­—çš„è¯ï¼ŒMyCatä¼šè‡ªåŠ¨åœ¨sqlè¯­å¥çš„åé¢æ‹¼ä¸Šlimit 100 --\u0026gt; \u0026lt;!-- dataNode: ç”¨äºæŒ‡å®šæ²¡æœ‰åˆ†é…åˆ†ç‰‡èŠ‚ç‚¹çš„é‚£äº›è¡¨çš„é»˜è®¤æ•°æ®èŠ‚ç‚¹ --\u0026gt; \u0026lt;schema name=\u0026#34;shopping\u0026#34; checkSQLschema=\u0026#34;false\u0026#34; sqlMaxLimit=\u0026#34;100\u0026#34;\u0026gt; \u0026lt;!-- é€»è¾‘è¡¨ï¼Œä»¥ä¸‹éƒ½æ²¡æœ‰é…ç½®åˆ†ç‰‡è§„åˆ™ruleï¼Œå› ä¸ºå‚ç›´åˆ†è¡¨ä¸éœ€è¦å®ƒ --\u0026gt; \u0026lt;!-- name: é€»è¾‘è¡¨çš„åå­—ï¼ŒåŒä¸€ä¸ªé€»è¾‘åº“schemaä¸­çš„é€»è¾‘è¡¨çš„åç§°åº”è¯¥å”¯ä¸€ --\u0026gt; \u0026lt;!-- dataNode: é…ç½®é€»è¾‘è¡¨åˆ†å¸ƒçš„æ•°æ®èŠ‚ç‚¹ï¼Œåå­—éœ€è¦ä¸dataNodeæ ‡ç­¾çš„nameå¯¹åº”ä¸Š --\u0026gt; \u0026lt;!-- rule: é…ç½®é€»è¾‘è¡¨çš„åˆ†ç‰‡è§„åˆ™,éœ€è¦åœ¨rule.xmlä¸­å£°æ˜çš„è§„åˆ™åå­—å¯¹åº”ä¸Š --\u0026gt; \u0026lt;!-- ruleRequired: æŒ‡å®šåˆ†ç‰‡è§„åˆ™æ˜¯å¦å¿…é¡»ï¼Œå¦‚æœä¸ºtrue,ä½†æ˜¯æ²¡æœ‰æŒ‡å®šruleï¼Œç¨‹åºä¼šæŠ¥é”™ --\u0026gt; \u0026lt;!-- primaryKey: æŒ‡å®šé€»è¾‘è¡¨å¯¹åº”çœŸå®è¡¨çš„ä¸»é”® --\u0026gt; \u0026lt;!-- type: æŒ‡å®šè¯¥é€»è¾‘è¡¨æ˜¯å…¨å±€è¡¨è¿˜æ˜¯æ™®é€šé€»è¾‘è¡¨ã€‚type=\u0026#34;global\u0026#34;è¡¨ç¤ºå…¨å±€è¡¨ --\u0026gt; \u0026lt;!-- autoIncrement: æŒ‡å®šæ˜¯å¦è‡ªå¢é•¿ä¸»é”® --\u0026gt; \u0026lt;!-- needAddLimit: æŒ‡å®šé€»è¾‘è¡¨æ˜¯å¦åœ¨æŸ¥è¯¢çš„æ—¶å€™è‡ªåŠ¨æ·»åŠ limitå»é™åˆ¶è¿”å›çš„ç»“æœé›†è®°å½•æ•°ï¼Œé»˜è®¤ä¸ºtrue,å¦‚æœè¯­å¥ä¸­å·²ç»åŒ…å«äº†limitå…³é”®å­—ï¼Œåˆ™ä¸ä¼šé‡å¤æ·»åŠ  --\u0026gt; \u0026lt;table name=\u0026#34;tb_goods_base\u0026#34; dataNode=\u0026#34;dn1\u0026#34; primaryKey=\u0026#34;id\u0026#34; /\u0026gt; \u0026lt;table name=\u0026#34;tb_goods_brand\u0026#34; dataNode=\u0026#34;dn1\u0026#34; primaryKey=\u0026#34;id\u0026#34; /\u0026gt; \u0026lt;table name=\u0026#34;tb_goods_cat\u0026#34; dataNode=\u0026#34;dn1\u0026#34; primaryKey=\u0026#34;id\u0026#34; /\u0026gt; \u0026lt;table name=\u0026#34;tb_goods_desc\u0026#34; dataNode=\u0026#34;dn1\u0026#34; primaryKey=\u0026#34;goods_id\u0026#34; /\u0026gt; \u0026lt;table name=\u0026#34;tb_goods_item\u0026#34; dataNode=\u0026#34;dn1\u0026#34; primaryKey=\u0026#34;id\u0026#34; /\u0026gt; \u0026lt;table name=\u0026#34;tb_order_item\u0026#34; dataNode=\u0026#34;dn2\u0026#34; primaryKey=\u0026#34;id\u0026#34; /\u0026gt; \u0026lt;table name=\u0026#34;tb_order_master\u0026#34; dataNode=\u0026#34;dn2\u0026#34; primaryKey=\u0026#34;order_id\u0026#34; /\u0026gt; \u0026lt;table name=\u0026#34;tb_order_pay_log\u0026#34; dataNode=\u0026#34;dn2\u0026#34; primaryKey=\u0026#34;out_trade_no\u0026#34; /\u0026gt; \u0026lt;table name=\u0026#34;tb_user\u0026#34; dataNode=\u0026#34;dn3\u0026#34; primaryKey=\u0026#34;id\u0026#34; /\u0026gt; \u0026lt;table name=\u0026#34;tb_user_address\u0026#34; dataNode=\u0026#34;dn3\u0026#34; primaryKey=\u0026#34;id\u0026#34; /\u0026gt; \u0026lt;!-- å…¨å±€è¡¨ --\u0026gt; \u0026lt;table name=\u0026#34;tb_areas_provinces\u0026#34; dataNode=\u0026#34;dn1,dn2,dn3\u0026#34; primaryKey=\u0026#34;id\u0026#34; type=\u0026#34;global\u0026#34;/\u0026gt; \u0026lt;table name=\u0026#34;tb_areas_city\u0026#34; dataNode=\u0026#34;dn1,dn2,dn3\u0026#34; primaryKey=\u0026#34;id\u0026#34; type=\u0026#34;global\u0026#34;/\u0026gt; \u0026lt;table name=\u0026#34;tb_areas_region\u0026#34; dataNode=\u0026#34;dn1,dn2,dn3\u0026#34; primaryKey=\u0026#34;id\u0026#34; type=\u0026#34;global\u0026#34;/\u0026gt; \u0026lt;!-- \u0026lt;table name=\u0026#34;t_order\u0026#34; dataNode=\u0026#34;dn1,dn2\u0026#34; rule=\u0026#34;mod-long\u0026#34;\u0026gt; # å®šä¹‰E-Råˆ†ç‰‡çš„å­è¡¨ï¼Œé€šè¿‡æ ‡ç­¾ä¸Šçš„å±æ€§ä¸çˆ¶è¡¨è¿›è¡Œå…³è” # nameï¼šå­è¡¨çš„åç§°t_order_detail # primaryKeyï¼šå­è¡¨çš„ä¸»é”® # joinKeyï¼šæ–°å¢å­è¡¨è®°å½•çš„æ—¶å€™ï¼Œä¼šæ ¹æ®è¯¥å€¼æŸ¥è¯¢çˆ¶è¡¨åœ¨å“ªä¸ªåˆ†ç‰‡èŠ‚ç‚¹ä¸Šã€‚ï¼ˆå­è¡¨ä¸­å­—æ®µçš„åç§°order_i # parentKeyå±æ€§ï¼šä¸çˆ¶è¡¨å»ºç«‹å…³è”å…³ç³»çš„åˆ—ï¼Œç»“åˆjoinKeyç¡®å®šå¥½å­è¡¨è®°å½•å­˜æ”¾çš„åˆ†ç‰‡èŠ‚ç‚¹ï¼Œæ’å…¥å­è¡¨è®°å½•æ—¶ç›´æ¥æ’å…¥åˆ°è¯¥åˆ†ç‰‡èŠ‚ç‚¹ä¸Šã€‚ï¼ˆçˆ¶è¡¨ä¸­å­—æ®µåç§°order_idï¼‰ # needAddLimitå±æ€§ï¼š æŒ‡å®šé€»è¾‘è¡¨æ˜¯å¦åœ¨æŸ¥è¯¢çš„æ—¶å€™è‡ªåŠ¨æ·»åŠ limitå»é™åˆ¶è¿”å›çš„ç»“æœé›†è®°å½•æ•°ï¼Œé»˜è®¤ä¸ºtrue,å¦‚æœè¯­å¥ä¸­å·²ç»åŒ…å«äº†limitå…³é”®å­—ï¼Œåˆ™ä¸ä¼šé‡å¤æ·»åŠ  \u0026lt;childTable name=\u0026#34;t_order_detail\u0026#34; primaryKey=\u0026#34;od_id\u0026#34; joinKey=\u0026#34;order_id\u0026#34; parentKey=\u0026#34;order_id\u0026#34;\u0026gt;\u0026lt;/childTable\u0026gt; \u0026lt;/table\u0026gt; --\u0026gt; \u0026lt;/schema\u0026gt; \u0026lt;!-- æ•°æ®èŠ‚ç‚¹ --\u0026gt; \u0026lt;!-- name: æŒ‡å®šåˆ†ç‰‡èŠ‚ç‚¹çš„åç§°ï¼Œä¸å£°æ˜é€»è¾‘è¡¨tableæ ‡ç­¾ä¸­çš„dataNodeåå­—å¯¹åº”ä¸Š --\u0026gt; \u0026lt;!-- dataHost: æŒ‡å®šåˆ†ç‰‡èŠ‚ç‚¹æ‰€åœ¨çš„èŠ‚ç‚¹ä¸»æœºï¼ˆæ•°æ®åº“å®ä¾‹ï¼‰ï¼Œä¸dataHostæ ‡ç­¾å£°æ˜çš„nameå¯¹åº” --\u0026gt; \u0026lt;!-- database: çœŸå®æ•°æ®åº“åç§° --\u0026gt; \u0026lt;dataNode name=\u0026#34;dn1\u0026#34; dataHost=\u0026#34;dhost1\u0026#34; database=\u0026#34;shopping\u0026#34; /\u0026gt; \u0026lt;dataNode name=\u0026#34;dn2\u0026#34; dataHost=\u0026#34;dhost2\u0026#34; database=\u0026#34;shopping\u0026#34; /\u0026gt; \u0026lt;dataNode name=\u0026#34;dn3\u0026#34; dataHost=\u0026#34;dhost3\u0026#34; database=\u0026#34;shopping\u0026#34; /\u0026gt; \u0026lt;!-- å…·ä½“æ•°æ®åº“å®ä¾‹ --\u0026gt; \u0026lt;dataHost name=\u0026#34;dhost1\u0026#34; maxCon=\u0026#34;1000\u0026#34; minCon=\u0026#34;10\u0026#34; balance=\u0026#34;0\u0026#34; writeType=\u0026#34;0\u0026#34; dbType=\u0026#34;mysql\u0026#34; dbDriver=\u0026#34;native\u0026#34; switchType=\u0026#34;1\u0026#34; slaveThreshold=\u0026#34;100\u0026#34;\u0026gt; \u0026lt;!--å¿ƒè·³æ£€æµ‹ --\u0026gt; \u0026lt;heartbeat\u0026gt;select user()\u0026lt;/heartbeat\u0026gt; \u0026lt;!-- å†™æœåŠ¡å™¨ï¼Œå¦‚æœè¦é…ç½®è¯»å†™ï¼Œæ·»åŠ readHostæ ‡ç­¾å³å¯ --\u0026gt; \u0026lt;writeHost host=\u0026#34;M1\u0026#34; url=\u0026#34;172.16.0.101:3306\u0026#34; user=\u0026#34;root\u0026#34; password=\u0026#34;123456\u0026#34;\u0026gt; \u0026lt;/writeHost\u0026gt; \u0026lt;/dataHost\u0026gt; \u0026lt;dataHost name=\u0026#34;dhost2\u0026#34; maxCon=\u0026#34;1000\u0026#34; minCon=\u0026#34;10\u0026#34; balance=\u0026#34;0\u0026#34; writeType=\u0026#34;0\u0026#34; dbType=\u0026#34;mysql\u0026#34; dbDriver=\u0026#34;native\u0026#34; switchType=\u0026#34;1\u0026#34; slaveThreshold=\u0026#34;100\u0026#34;\u0026gt; \u0026lt;!--å¿ƒè·³æ£€æµ‹ --\u0026gt; \u0026lt;heartbeat\u0026gt;select user()\u0026lt;/heartbeat\u0026gt; \u0026lt;!-- å†™æœåŠ¡å™¨ï¼Œå¦‚æœè¦é…ç½®è¯»å†™ï¼Œæ·»åŠ readHostæ ‡ç­¾å³å¯ --\u0026gt; \u0026lt;writeHost host=\u0026#34;M2\u0026#34; url=\u0026#34;172.16.0.102:3306\u0026#34; user=\u0026#34;root\u0026#34; password=\u0026#34;123456\u0026#34;\u0026gt; \u0026lt;/writeHost\u0026gt; \u0026lt;/dataHost\u0026gt; \u0026lt;!-- name: æŒ‡å®šåˆ†ç‰‡ä¸»æœºçš„åç§°ï¼Œä¾›dataNodeæ ‡ç­¾ä½¿ç”¨ --\u0026gt; \u0026lt;!-- maxCon: æŒ‡å®šè¯»å†™å®ä¾‹çš„è¿æ¥æ± çš„æœ€å¤§è¿æ¥æ•°é‡ --\u0026gt; \u0026lt;!-- minCon: æŒ‡å®šè¯»å†™å®ä¾‹çš„è¿æ¥æ± çš„æœ€å°è¿æ¥æ•°é‡ï¼Œåˆå§‹åŒ–è¿æ¥æ± çš„å¤§å° --\u0026gt; \u0026lt;!-- balance: æŒ‡å®šè´Ÿè½½å‡è¡¡çš„ç±»å‹ balance = â€œ0â€ : ä¸å¼€å¯è¯»å†™åˆ†ç¦»ï¼Œæ‰€æœ‰çš„è¯»è¯·æ±‚éƒ½å‘é€åˆ°å¯ç”¨çš„writeHostå†™èŠ‚ç‚¹ä¸Šï¼ˆä¸ä¼šå‘readHostï¼‰ balance = â€œ1â€ : å…¨éƒ¨çš„readHostä¸stand by writeHostå‚ä¸selectè¯­å¥çš„è´Ÿè½½å‡è¡¡ï¼Œ balance = â€œ2â€ : è¯»æ“ä½œä¼šéšæœºå‘å¾€writeHostä»¥åŠ readHostï¼Œç†è®ºä¸Šå®ç°çš„æ˜¯è´Ÿè½½å‡è¡¡ balance = â€œ3â€ : é…ç½®äº†readHostæ—¶è¯»æ“ä½œä¼šéšæœºå‘å¾€readHostï¼ˆä¸ä¼šå‘writeHostï¼‰ï¼Œè€Œæ²¡æœ‰é…ç½®readHostæ—¶è¯»æ“ä½œä¼šå‘å¾€ç¬¬ä¸€ä¸ªwriteHostã€‚ --\u0026gt; \u0026lt;!-- writeType: writeType=\u0026#34;0\u0026#34;: æ‰€æœ‰å†™æ“ä½œå‘é€åˆ°é…ç½®çš„ç¬¬ä¸€ä¸ªwriteHostï¼Œå½“ç¬¬ä¸€ä¸ªwriteHostå®•æœºæ—¶ï¼Œåˆ‡æ¢åˆ°ç¬¬äºŒä¸ªwriteHostï¼Œé‡æ–°å¯åŠ¨åä»¥åˆ‡æ¢åçš„ä¸ºå‡†ï¼Œåˆ‡æ¢è®°å½•åœ¨é…ç½®æ–‡ä»¶ï¼šdnindex.propertiesä¸­ writeType=\u0026#34;1\u0026#34;: æ‰€æœ‰å†™æ“ä½œéƒ½éšå‘é€åˆ°é…ç½®çš„writeHost --\u0026gt; \u0026lt;!-- dbType: æŒ‡å®šåç«¯æ•°æ®åº“ç±»å‹ï¼Œæ”¯æŒmysqlã€oracleç­‰ --\u0026gt; \u0026lt;!-- dbDriver: æŒ‡å®šåç«¯æ•°æ®åº“è¿æ¥é©±åŠ¨ä¿¡æ¯ï¼Œæ”¯æŒnativeå’Œjdbc --\u0026gt; \u0026lt;!-- switchType: æŒ‡å®šåˆ‡æ¢æ–¹å¼ switchType = -1ï¼šä¸è‡ªåŠ¨åˆ‡æ¢ switchType = 1ï¼šè‡ªåŠ¨åˆ‡æ¢ï¼ˆé»˜è®¤ï¼‰ switchType = 2ï¼šåŸºäºMySqlä¸»ä»åŒæ­¥çš„çŠ¶æ€æ¥å†³å®šæ˜¯å¦åˆ‡æ¢ï¼Œå¿ƒè·³è¯­å¥: show slave status switchType = 3: åŸºäºmysql galary clusterçš„åˆ‡æ¢æœºåˆ¶ï¼Œå¿ƒè·³è¯­å¥ï¼š show status like \u0026#39;wsrep%\u0026#39; --\u0026gt; \u0026lt;!-- slaveThreshold: --\u0026gt; \u0026lt;dataHost name=\u0026#34;dhost3\u0026#34; maxCon=\u0026#34;1000\u0026#34; minCon=\u0026#34;10\u0026#34; balance=\u0026#34;0\u0026#34; writeType=\u0026#34;0\u0026#34; dbType=\u0026#34;mysql\u0026#34; dbDriver=\u0026#34;native\u0026#34; switchType=\u0026#34;1\u0026#34; slaveThreshold=\u0026#34;100\u0026#34;\u0026gt; \u0026lt;!--å¿ƒè·³æ£€æµ‹ï¼ŒæŒ‡å®šåç«¯æ•°æ®åº“è¿›è¡Œå¿ƒè·³æ£€æŸ¥çš„è¯­å¥ --\u0026gt; \u0026lt;heartbeat\u0026gt;select user()\u0026lt;/heartbeat\u0026gt; \u0026lt;!-- å†™æœåŠ¡å™¨ï¼Œå¦‚æœè¦é…ç½®è¯»å†™ï¼Œæ·»åŠ readHostæ ‡ç­¾å³å¯ --\u0026gt; \u0026lt;!-- host: ç”¨äºæ ‡è¯†ä¸åŒå®ä¾‹ï¼Œä¸€èˆ¬ writeHost æˆ‘ä»¬ä½¿ç”¨M1ï¼ŒreadHost æˆ‘ä»¬ç”¨S1 --\u0026gt; \u0026lt;!-- url: åç«¯å®ä¾‹è¿æ¥åœ°å€ï¼Œå¦‚æœæ˜¯ä½¿ç”¨ native çš„ dbDriverï¼Œåˆ™ä¸€èˆ¬ä¸º address:port è¿™ç§å½¢å¼,ç”¨ JDBC æˆ–å…¶ä»–çš„ dbDriverï¼Œåˆ™éœ€è¦ç‰¹æ®ŠæŒ‡å®šï¼Œä½¿ç”¨ JDBC æ—¶åˆ™å¯ä»¥è¿™ä¹ˆå†™ï¼šjdbc:mysql://localhost:3306/ --\u0026gt; \u0026lt;!-- user: åç«¯å­˜å‚¨å®ä¾‹éœ€è¦çš„ç”¨æˆ·å --\u0026gt; \u0026lt;!-- password: åç«¯å­˜å‚¨å®ä¾‹éœ€è¦çš„å¯†ç  --\u0026gt; \u0026lt;!-- weight: æƒé‡ é…ç½®åœ¨ readhost ä¸­ä½œä¸ºè¯»èŠ‚ç‚¹çš„æƒé‡ --\u0026gt; \u0026lt;!-- usingDecrypt: æ˜¯å¦å¯¹å¯†ç åŠ å¯†é»˜è®¤ 0 å¦ å¦‚éœ€è¦å¼€å¯é…ç½® 1ï¼ŒåŒæ—¶ä½¿ç”¨åŠ å¯†ç¨‹åºå¯¹å¯†ç åŠ å¯† --\u0026gt; \u0026lt;writeHost host=\u0026#34;M3\u0026#34; url=\u0026#34;172.16.0.103:3306\u0026#34; user=\u0026#34;root\u0026#34; password=\u0026#34;123456\u0026#34;\u0026gt; \u0026lt;/writeHost\u0026gt; \u0026lt;/dataHost\u0026gt; \u0026lt;/mycat:schema\u0026gt; schemaæ ‡ç­¾ schemaæ ‡ç­¾ç”¨äºå®šä¹‰MyCatå®ä¾‹ä¸­çš„é€»è¾‘åº“, ä¸€ä¸ªMyCatå®ä¾‹ä¸­, å¯ä»¥æœ‰å¤šä¸ªé€»è¾‘åº“, å¯ä»¥é€šè¿‡schemaæ ‡ç­¾æ¥åˆ’åˆ†ä¸åŒçš„é€»è¾‘åº“ã€‚ MyCatä¸­çš„é€»è¾‘åº“çš„æ¦‚å¿µï¼Œç­‰åŒäºMySQLä¸­çš„databaseæ¦‚å¿µï¼Œéœ€è¦æ“ä½œæŸä¸ªé€»è¾‘åº“ä¸‹çš„è¡¨æ—¶ï¼Œä¹Ÿéœ€è¦åˆ‡æ¢é€»è¾‘åº“(use xxx)ã€‚ \u0026lt;!-- å®šä¹‰é€»è¾‘åº“ --\u0026gt; \u0026lt;schema name=\u0026#34;DB01\u0026#34; checkSQLschema=\u0026#34;true\u0026#34; sqlMaxLimit=\u0026#34;100\u0026#34;\u0026gt; \u0026lt;!-- å®šä¹‰é€»è¾‘è¡¨ --\u0026gt; \u0026lt;table name=\u0026#34;TB_ORDER\u0026#34; dataNode=\u0026#34;dn1,dn2,dn3\u0026#34; rule=\u0026#34;auto-sharding-long\u0026#34;/\u0026gt; \u0026lt;/schema\u0026gt; schema å±æ€§ï¼š nameï¼šæŒ‡å®šè‡ªå®šä¹‰çš„é€»è¾‘åº“åº“åã€‚ checkSQLschemaï¼šåœ¨SQLè¯­å¥æ“ä½œæ—¶æŒ‡å®šäº†æ•°æ®åº“åç§°ï¼Œæ‰§è¡Œæ—¶æ˜¯å¦è‡ªåŠ¨å»é™¤ï¼›trueï¼šè‡ªåŠ¨å»é™¤ï¼Œfalseï¼šä¸è‡ªåŠ¨å»é™¤ã€‚ sqlMaxLimitï¼šå¦‚æœæœªæŒ‡å®šlimitè¿›è¡ŒæŸ¥è¯¢ï¼Œåˆ—è¡¨æŸ¥è¯¢æ¨¡å¼æŸ¥è¯¢å¤šå°‘æ¡è®°å½•ã€‚ tableæ ‡ç­¾å®šä¹‰äº†MyCatä¸­é€»è¾‘åº“schemaä¸‹çš„é€»è¾‘è¡¨ï¼Œæ‰€æœ‰éœ€è¦æ‹†åˆ†çš„è¡¨éƒ½éœ€è¦åœ¨tableæ ‡ç­¾ä¸­å®šä¹‰ã€‚ schema.table å±æ€§ï¼š nameï¼šå®šä¹‰é€»è¾‘è¡¨è¡¨åï¼Œåœ¨è¯¥é€»è¾‘åº“ä¸‹å”¯ä¸€ã€‚ dataNodeï¼šå®šä¹‰é€»è¾‘è¡¨æ‰€å±çš„dataNodeï¼Œè¯¥å±æ€§éœ€è¦ä¸dataNodeæ ‡ç­¾ä¸­nameå¯¹åº”ï¼›å¤šä¸ªdataNodeé€—å·åˆ†éš”ã€‚ ruleï¼šåˆ†ç‰‡è§„åˆ™çš„åå­—ï¼Œåˆ†ç‰‡è§„åˆ™åå­—æ˜¯åœ¨rule.xmlä¸­å®šä¹‰çš„ã€‚ primaryKeyï¼šé€»è¾‘è¡¨å¯¹åº”çœŸå®è¡¨çš„ä¸»é”®ã€‚ typeï¼šé€»è¾‘è¡¨çš„ç±»å‹ï¼Œç›®å‰é€»è¾‘è¡¨åªæœ‰å…¨å±€è¡¨å’Œæ™®é€šè¡¨ï¼Œå¦‚æœæœªé…ç½®å°±æ˜¯æ™®é€šè¡¨ï¼›å…¨å±€è¡¨é…ç½®ä¸ºglobalã€‚ datanodeæ ‡ç­¾ è¯¥æ ‡ç­¾ç”¨äºå®šä¹‰èŠ‚ç‚¹ã€‚ \u0026lt;dataNode name=\u0026#34;dn1\u0026#34; dataHost=\u0026#34;dhost1\u0026#34; database=\u0026#34;db01\u0026#34; /\u0026gt; \u0026lt;dataNode name=\u0026#34;dn2\u0026#34; dataHost=\u0026#34;dhost2\u0026#34; database=\u0026#34;db01\u0026#34; /\u0026gt; \u0026lt;dataNode name=\u0026#34;dn3\u0026#34; dataHost=\u0026#34;dhost3\u0026#34; database=\u0026#34;db01\u0026#34; /\u0026gt; dataNode å±æ€§ï¼š nameï¼šå®šä¹‰æ•°æ®èŠ‚ç‚¹åç§°ã€‚ dataHostï¼šæ•°æ®åº“å®ä¾‹ä¸»æœºåç§°ï¼Œå¼•ç”¨è‡ªdataHostæ ‡ç­¾ä¸­nameå±æ€§ã€‚ databaseï¼šå®šä¹‰åˆ†ç‰‡æ‰€å±æ•°æ®åº“ã€‚ datahostæ ‡ç­¾ è¯¥æ ‡ç­¾åœ¨MyCaté€»è¾‘åº“ä¸­ä½œä¸ºåº•å±‚æ ‡ç­¾å­˜åœ¨, ç›´æ¥å®šä¹‰äº†å…·ä½“çš„æ•°æ®åº“å®ä¾‹ã€è¯»å†™åˆ†ç¦»ã€å¿ƒè·³è¯­å¥ã€‚ \u0026lt;dataHost name=\u0026#34;dhost1\u0026#34; maxCon=\u0026#34;1000\u0026#34; minCon=\u0026#34;10\u0026#34; balance=\u0026#34;0\u0026#34; writeType=\u0026#34;0\u0026#34; dbType=\u0026#34;mysql\u0026#34; dbDriver=\u0026#34;jdbc\u0026#34; switchType=\u0026#34;1\u0026#34; slaveThreshold=\u0026#34;100\u0026#34;\u0026gt; \u0026lt;heartbeat\u0026gt;select user()\u0026lt;/heartbeat\u0026gt; \u0026lt;writeHost host=\u0026#34;master\u0026#34; url=\u0026#34;jdbc:mysql://192.168.200.210:3306? useSSL=false\u0026amp;amp;serverTimezone=Asia/Shanghai\u0026amp;amp;characterEncoding=utf8\u0026#34; user=\u0026#34;root\u0026#34; password=\u0026#34;1234\u0026#34; /\u0026gt; \u0026lt;/dataHost\u0026gt; dataNode å±æ€§ï¼š nameï¼šå”¯ä¸€æ ‡è¯†ï¼Œä¾›ä¸Šå±‚æ ‡ç­¾ä½¿ç”¨ã€‚ maxCon/minConï¼šæœ€å¤§è¿æ¥æ•°/æœ€å°è¿æ¥æ•°ã€‚ balanceï¼šè´Ÿè½½å‡è¡¡ç­–ç•¥ï¼Œå–å€¼ 0,1,2,3ã€‚ writeTypeï¼šå†™æ“ä½œåˆ†å‘æ–¹å¼ï¼ˆ0ï¼šå†™æ“ä½œè½¬å‘åˆ°ç¬¬ä¸€ä¸ªwriteHostï¼Œç¬¬ä¸€ä¸ªæŒ‚äº†ï¼Œåˆ‡æ¢åˆ°ç¬¬äºŒä¸ªï¼›1ï¼šå†™æ“ä½œéšæœºåˆ†å‘åˆ°é…ç½®çš„writeHostï¼‰ã€‚ dbDriverï¼šæ•°æ®åº“é©±åŠ¨ï¼Œæ”¯æŒ nativeã€jdbcã€‚ rule.xml rule.xmlä¸­å®šä¹‰æ‰€æœ‰æ‹†åˆ†è¡¨çš„è§„åˆ™, åœ¨ä½¿ç”¨è¿‡ç¨‹ä¸­å¯ä»¥çµæ´»çš„ä½¿ç”¨åˆ†ç‰‡ç®—æ³•, æˆ–è€…å¯¹åŒä¸€ä¸ªåˆ†ç‰‡ç®—æ³•ä½¿ç”¨ä¸åŒçš„å‚æ•°, å®ƒè®©åˆ†ç‰‡è¿‡ç¨‹å¯é…ç½®åŒ–ã€‚ä¸»è¦åŒ…å«ä¸¤ç±»æ ‡ç­¾ï¼štableRuleã€Functionã€‚ \u0026lt;tableRule name=\u0026#34;auto-sharding-long\u0026#34;\u0026gt; \u0026lt;rule\u0026gt; \u0026lt;columns\u0026gt;id\u0026lt;/columns\u0026gt; \u0026lt;algorithm\u0026gt;rang-long\u0026lt;/algorithm\u0026gt; \u0026lt;/rule\u0026gt; \u0026lt;/tableRule\u0026gt; \u0026lt;function name=\u0026#34;rang-long\u0026#34; class=\u0026#34;io.mycat.route.function.AutoPartitionByLong\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;mapFile\u0026#34;\u0026gt;autopartition-long.txt\u0026lt;/property\u0026gt; \u0026lt;/function\u0026gt; autopartition-long.txt # range start-end, data node index # K=1000,M=10000 0-500M=0 500M-1000M=1 1000M-1500M=2 server.xml server.xmlé…ç½®æ–‡ä»¶åŒ…å«äº†MyCatçš„ç³»ç»Ÿé…ç½®ä¿¡æ¯ï¼Œä¸»è¦æœ‰ä¸¤ä¸ªé‡è¦çš„æ ‡ç­¾ï¼šsystemã€userã€‚ \u0026lt;user name=\u0026#34;root\u0026#34; defaultAccount=\u0026#34;true\u0026#34;\u0026gt; \u0026lt;!-- ç”¨æˆ·å¯†ç  --\u0026gt; \u0026lt;property name=\u0026#34;password\u0026#34;\u0026gt;123456\u0026lt;/property\u0026gt; \u0026lt;!-- ç”¨æˆ·å¯è®¿é—®çš„é€»è¾‘æ•°æ®åº“æœ‰ï¼Œå¤šä¸ªé€»è¾‘åº“ä½¿ç”¨è‹±æ–‡é€—å·åˆ†éš”å¼€ --\u0026gt; \u0026lt;property name=\u0026#34;schemas\u0026#34;\u0026gt;DB01\u0026lt;/property\u0026gt; \u0026lt;!-- è¡¨çº§ DML æƒé™è®¾ç½® --\u0026gt; \u0026lt;!-- \u0026lt;privileges check=\u0026#34;true\u0026#34;\u0026gt; \u0026lt;schema name=\u0026#34;DB01\u0026#34; dml=\u0026#34;0110\u0026#34; \u0026gt; \u0026lt;table name=\u0026#34;TB_ORDER\u0026#34; dml=\u0026#34;1110\u0026#34;\u0026gt;\u0026lt;/table\u0026gt; \u0026lt;/schema\u0026gt; \u0026lt;/privileges\u0026gt; --\u0026gt; \u0026lt;/user\u0026gt; \u0026lt;user name=\u0026#34;user\u0026#34;\u0026gt; \u0026lt;!-- ç”¨æˆ·å¯†ç  --\u0026gt; \u0026lt;property name=\u0026#34;password\u0026#34;\u0026gt;123456\u0026lt;/property\u0026gt; \u0026lt;!-- ç”¨æˆ·å¯è®¿é—®çš„é€»è¾‘æ•°æ®åº“æœ‰ï¼Œå¤šä¸ªé€»è¾‘åº“ä½¿ç”¨è‹±æ–‡é€—å·åˆ†éš”å¼€ --\u0026gt; \u0026lt;property name=\u0026#34;schemas\u0026#34;\u0026gt;DB01\u0026lt;/property\u0026gt; \u0026lt;!-- ç”¨æˆ·çš„è¯»å†™æƒé™ --\u0026gt; \u0026lt;property name=\u0026#34;readOnly\u0026#34;\u0026gt;true\u0026lt;/property\u0026gt; \u0026lt;!-- é™åˆ¶å‰ç«¯çš„è¿æ¥æ•°é‡ï¼Œå¦‚æœä¸º0æˆ–è€…æ²¡æœ‰é…ç½®è¡¨ç¤ºä¸é™åˆ¶ --\u0026gt; \u0026lt;property name=\u0026#34;benchmark\u0026#34;\u0026gt;1000\u0026lt;/property\u0026gt; \u0026lt;!-- å¼€å¯å¯†ç åŠ å¯†åŠŸèƒ½ é»˜è®¤å€¼ä¸º0ï¼Œè¡¨ç¤ºä¸è¿›è¡ŒåŠ å¯† --\u0026gt; \u0026lt;property name=\u0026#34;usingDecrypt\u0026#34;\u0026gt;1\u0026lt;/property\u0026gt; \u0026lt;/user\u0026gt; ä¸»è¦é…ç½®MyCatä¸­çš„ç³»ç»Ÿé…ç½®(system)ä¿¡æ¯ï¼Œå¯¹åº”çš„ç³»ç»Ÿé…ç½®é¡¹åŠå…¶å«ä¹‰ï¼Œå¦‚ä¸‹ï¼š å±æ€§ å–å€¼ å«ä¹‰ charset utf8 è®¾ç½®Mycatçš„å­—ç¬¦é›†, å­—ç¬¦é›†éœ€è¦ä¸MySQLçš„å­—ç¬¦é›†ä¿æŒä¸€è‡´ nonePasswordLogin 0,1 0ä¸ºéœ€è¦å¯†ç ç™»é™†ã€1ä¸ºä¸éœ€è¦å¯†ç ç™»é™† ,é»˜è®¤ä¸º0ï¼Œè®¾ç½®ä¸º1åˆ™éœ€è¦æŒ‡å®šé»˜è®¤è´¦æˆ· useHandshakeV10 0,1 ä½¿ç”¨è¯¥é€‰é¡¹ä¸»è¦çš„ç›®çš„æ˜¯ä¸ºäº†èƒ½å¤Ÿå…¼å®¹é«˜ç‰ˆæœ¬çš„jdbcé©±åŠ¨, æ˜¯å¦é‡‡ç”¨HandshakeV10Packetæ¥ä¸clientè¿›è¡Œé€šä¿¡, 1:æ˜¯, 0:å¦ useSqlStat 0,1 å¼€å¯SQLå®æ—¶ç»Ÿè®¡, 1 ä¸ºå¼€å¯ , 0 ä¸ºå…³é—­ ;å¼€å¯ä¹‹å, MyCatä¼šè‡ªåŠ¨ç»Ÿè®¡SQLè¯­å¥çš„æ‰§è¡Œæƒ…å†µ ; mysql -h 127.0.0.1 -P 9066-u root -p æŸ¥çœ‹MyCatæ‰§è¡Œçš„SQL, æ‰§è¡Œæ•ˆç‡æ¯”è¾ƒä½çš„SQL , SQLçš„æ•´ä½“æ‰§è¡Œæƒ…å†µã€è¯»å†™æ¯”ä¾‹ç­‰ ; show @@sql ; show @@sql.slow ; show @@sql.sum useGlobleTableCheck 0,1 æ˜¯å¦å¼€å¯å…¨å±€è¡¨çš„ä¸€è‡´æ€§æ£€æµ‹ã€‚1ä¸ºå¼€å¯ ï¼Œ0ä¸ºå…³é—­ sqlExecuteTimeout 1000 SQLè¯­å¥æ‰§è¡Œçš„è¶…æ—¶æ—¶é—´ , å•ä½ä¸º s sequnceHandlerType 0,1,2 ç”¨æ¥æŒ‡å®šMycatå…¨å±€åºåˆ—ç±»å‹ï¼Œ0 ä¸ºæœ¬åœ°æ–‡ä»¶ï¼Œ1 ä¸ºæ•°æ®åº“æ–¹å¼ï¼Œ2 ä¸ºæ—¶é—´æˆ³åˆ—æ–¹å¼ï¼Œé»˜è®¤ä½¿ç”¨æœ¬åœ°æ–‡ä»¶æ–¹å¼ï¼Œæ–‡ä»¶æ–¹å¼ä¸»è¦ç”¨äºæµ‹è¯• sequnceHandlerPattern æ­£åˆ™è¡¨è¾¾å¼ å¿…é¡»å¸¦æœ‰MYCATSEQæˆ–è€… mycatseqè¿›å…¥åºåˆ—åŒ¹é…æµç¨‹ æ³¨æ„MYCATSEQ_æœ‰ç©ºæ ¼çš„æƒ…å†µ subqueryRelationshipCheck true,false å­æŸ¥è¯¢ä¸­å­˜åœ¨å…³è”æŸ¥è¯¢çš„æƒ…å†µä¸‹,æ£€æŸ¥å…³è”å­—æ®µä¸­æ˜¯å¦æœ‰åˆ†ç‰‡å­—æ®µ .é»˜è®¤ false useCompression 0,1 å¼€å¯mysqlå‹ç¼©åè®® , 0 : å…³é—­, 1 : å¼€å¯ fakeMySQLVersion 5.5,5.6 è®¾ç½®æ¨¡æ‹Ÿçš„MySQLç‰ˆæœ¬å· defaultSqlParser ç”±äºMyCatçš„æœ€åˆç‰ˆæœ¬ä½¿ç”¨äº†FoundationDBçš„SQLè§£æå™¨, åœ¨MyCat1.3åå¢åŠ äº†Druidè§£æå™¨, æ‰€ä»¥è¦è®¾ç½®defaultSqlParserå±æ€§æ¥æŒ‡å®šé»˜è®¤çš„è§£æå™¨; è§£æå™¨æœ‰ä¸¤ä¸ª :druidparser å’Œ fdbparser, åœ¨MyCat1.4ä¹‹å,é»˜è®¤æ˜¯druidparser,fdbparserå·²ç»åºŸé™¤äº† processors 1,2\u0026hellip;. æŒ‡å®šç³»ç»Ÿå¯ç”¨çš„çº¿ç¨‹æ•°é‡, é»˜è®¤å€¼ä¸ºCPUæ ¸å¿ƒx æ¯ä¸ªæ ¸å¿ƒè¿è¡Œçº¿ç¨‹æ•°é‡; processors ä¼šå½±å“processorBufferPool,processorBufferLocalPercent,processorExecutorå±æ€§, æ‰€æœ‰, åœ¨æ€§èƒ½è°ƒä¼˜æ—¶, å¯ä»¥é€‚å½“åœ°ä¿®æ”¹processorså€¼ processorBufferChunk æŒ‡å®šæ¯æ¬¡åˆ†é…Socket Direct Bufferé»˜è®¤å€¼ä¸º4096å­—èŠ‚, ä¹Ÿä¼šå½±å“BufferPoolé•¿åº¦,å¦‚æœä¸€æ¬¡æ€§è·å–å­—èŠ‚è¿‡å¤šè€Œå¯¼è‡´bufferä¸å¤Ÿç”¨, åˆ™ä¼šå‡ºç°è­¦å‘Š, å¯ä»¥è°ƒå¤§è¯¥å€¼ processorExecutor æŒ‡å®šNIOProcessorä¸Šå…±äº«businessExecutorå›ºå®šçº¿ç¨‹æ± çš„å¤§å°;MyCatæŠŠå¼‚æ­¥ä»»åŠ¡äº¤ç»™ businessExecutorçº¿ç¨‹æ± ä¸­, åœ¨æ–°ç‰ˆæœ¬çš„MyCatä¸­è¿™ä¸ªè¿æ¥æ± ä½¿ç”¨é¢‘æ¬¡ä¸é«˜, å¯ä»¥é€‚å½“åœ°æŠŠè¯¥å€¼è°ƒå° packetHeaderSize æŒ‡å®šMySQLåè®®ä¸­çš„æŠ¥æ–‡å¤´é•¿åº¦, é»˜è®¤4ä¸ªå­—èŠ‚ maxPacketSize æŒ‡å®šMySQLåè®®å¯ä»¥æºå¸¦çš„æ•°æ®æœ€å¤§å¤§å°, é»˜è®¤å€¼ä¸º16M idleTimeout 30 æŒ‡å®šè¿æ¥çš„ç©ºé—²æ—¶é—´çš„è¶…æ—¶é•¿åº¦;å¦‚æœè¶…æ—¶,å°†å…³é—­èµ„æºå¹¶å›æ”¶, é»˜è®¤30åˆ†é’Ÿ txIsolation 1,2,3,4 åˆå§‹åŒ–å‰ç«¯è¿æ¥çš„äº‹åŠ¡éš”ç¦»çº§åˆ«,é»˜è®¤ä¸ºREPEATED_READ , å¯¹åº”æ•°å­—ä¸º3READ_UNCOMMITED=1;READ_COMMITTED=2; REPEATED_READ=3;SERIALIZABLE=4 sqlExecuteTimeout 300 æ‰§è¡ŒSQLçš„è¶…æ—¶æ—¶é—´, å¦‚æœSQLè¯­å¥æ‰§è¡Œè¶…æ—¶,å°†å…³é—­è¿æ¥; é»˜è®¤300ç§’; serverPort 8066 å®šä¹‰MyCatçš„ä½¿ç”¨ç«¯å£, é»˜è®¤8066 managerPort 9066 å®šä¹‰MyCatçš„ç®¡ç†ç«¯å£, é»˜è®¤9066 MyCatåˆ†ç‰‡ å‚ç›´æ‹†åˆ† åœ¨ä¸šåŠ¡ç³»ç»Ÿä¸­ï¼Œæ¶‰åŠä»¥ä¸‹è¡¨ç»“æ„ï¼Œä½†æ˜¯ç”±äºç”¨æˆ·ä¸è®¢å•æ¯å¤©éƒ½ä¼šäº§ç”Ÿå¤§é‡çš„æ•°æ®ï¼Œå•å°æœåŠ¡å™¨çš„æ•°æ®å­˜å‚¨åŠå¤„ç†èƒ½åŠ›æ˜¯æœ‰é™çš„ï¼Œå¯ä»¥å¯¹æ•°æ®åº“è¡¨è¿›è¡Œæ‹†åˆ†ï¼ŒåŸæœ‰çš„æ•°æ®åº“è¡¨å¦‚ä¸‹ã€‚ ç°åœ¨è€ƒè™‘å°†å…¶è¿›è¡Œå‚ç›´åˆ†åº“æ“ä½œï¼Œå°†å•†å“ç›¸å…³çš„è¡¨æ‹†åˆ†åˆ°ä¸€ä¸ªæ•°æ®åº“æœåŠ¡å™¨ï¼Œè®¢å•è¡¨æ‹†åˆ†çš„ä¸€ä¸ªæ•°æ®åº“æœåŠ¡å™¨ï¼Œç”¨æˆ·åŠçœå¸‚åŒºè¡¨æ‹†åˆ†åˆ°ä¸€ä¸ªæœåŠ¡å™¨ã€‚ åç§° IP ç«¯å£ MyCat 172.16.0.10 8066,9066 mysql1 172.16.0.101 3306 mysql2 172.16.0.102 3307 mysql3 172.16.0.103 3308 schema.xml \u0026lt;?xml version=\u0026#34;1.0\u0026#34;?\u0026gt; \u0026lt;!DOCTYPE mycat:schema SYSTEM \u0026#34;schema.dtd\u0026#34;\u0026gt; \u0026lt;mycat:schema xmlns:mycat=\u0026#34;http://io.mycat/\u0026#34;\u0026gt; \u0026lt;!-- é€»è¾‘åº“ --\u0026gt; \u0026lt;!-- name: é€»è¾‘åº“åå­— --\u0026gt; \u0026lt;!-- checkSQLschema: å½“è®¾ç½®ä¸ºtrueæ—¶ï¼Œæ¯”å¦‚å‘é€ä¸€æ¡sql:select * from mycat_order.t_orderï¼Œé‚£ä¹ˆMyCatä¼šè‡ªåŠ¨å»æ‰mycat_orderé€»è¾‘åº“åå­—å‰ç¼€ï¼ŒæŠŠsqlå˜ä¸ºï¼šselect * from t_order, è¿™æ ·æœ‰æ•ˆé¿å…æŠ¥è¡¨æˆ–è§†å›¾ä¸å­˜åœ¨é”™è¯¯ã€‚ å¦‚æœä½¿ç”¨select * from test.t_order ï¼Œsqlè¯­å¥ä¸­æ‰€å¸¦çš„é€»è¾‘åº“åå­—è·Ÿschemaæ ‡ç­¾ä¸­çš„nameä¸ä¸€è‡´çš„è¯ï¼ŒMyCatä¸ä¼šè‡ªåŠ¨å»æ‰é€»è¾‘åº“åå­—å‰ç¼€ï¼Œå¦‚æœé€»è¾‘åº“ä¸å­˜åœ¨ï¼Œä»ç„¶ä¼šæŠ¥é”™ã€‚ --\u0026gt; \u0026lt;!-- sqlMaxLimit: å¦‚æœæ¯æ¬¡æ‰§è¡Œçš„sqlè¯­å¥åé¢æ²¡æœ‰è·Ÿä¸Šlimit xxå…³é”®å­—çš„è¯ï¼ŒMyCatä¼šè‡ªåŠ¨åœ¨sqlè¯­å¥çš„åé¢æ‹¼ä¸Šlimit 100 --\u0026gt; \u0026lt;!-- dataNode: ç”¨äºæŒ‡å®šæ²¡æœ‰åˆ†é…åˆ†ç‰‡èŠ‚ç‚¹çš„é‚£äº›è¡¨çš„é»˜è®¤æ•°æ®èŠ‚ç‚¹ --\u0026gt; \u0026lt;schema name=\u0026#34;shopping\u0026#34; checkSQLschema=\u0026#34;false\u0026#34; sqlMaxLimit=\u0026#34;100\u0026#34;\u0026gt; \u0026lt;!-- é€»è¾‘è¡¨ï¼Œä»¥ä¸‹éƒ½æ²¡æœ‰é…ç½®åˆ†ç‰‡è§„åˆ™ruleï¼Œå› ä¸ºå‚ç›´åˆ†è¡¨ä¸éœ€è¦å®ƒ --\u0026gt; \u0026lt;!-- name: é€»è¾‘è¡¨çš„åå­—ï¼ŒåŒä¸€ä¸ªé€»è¾‘åº“schemaä¸­çš„é€»è¾‘è¡¨çš„åç§°åº”è¯¥å”¯ä¸€ --\u0026gt; \u0026lt;!-- dataNode: é…ç½®é€»è¾‘è¡¨åˆ†å¸ƒçš„æ•°æ®èŠ‚ç‚¹ï¼Œåå­—éœ€è¦ä¸dataNodeæ ‡ç­¾çš„nameå¯¹åº”ä¸Š --\u0026gt; \u0026lt;!-- rule: é…ç½®é€»è¾‘è¡¨çš„åˆ†ç‰‡è§„åˆ™,éœ€è¦åœ¨rule.xmlä¸­å£°æ˜çš„è§„åˆ™åå­—å¯¹åº”ä¸Š --\u0026gt; \u0026lt;!-- ruleRequired: æŒ‡å®šåˆ†ç‰‡è§„åˆ™æ˜¯å¦å¿…é¡»ï¼Œå¦‚æœä¸ºtrue,ä½†æ˜¯æ²¡æœ‰æŒ‡å®šruleï¼Œç¨‹åºä¼šæŠ¥é”™ --\u0026gt; \u0026lt;!-- primaryKey: æŒ‡å®šé€»è¾‘è¡¨å¯¹åº”çœŸå®è¡¨çš„ä¸»é”® --\u0026gt; \u0026lt;!-- type: æŒ‡å®šè¯¥é€»è¾‘è¡¨æ˜¯å…¨å±€è¡¨è¿˜æ˜¯æ™®é€šé€»è¾‘è¡¨ã€‚type=\u0026#34;global\u0026#34;è¡¨ç¤ºå…¨å±€è¡¨ --\u0026gt; \u0026lt;!-- autoIncrement: æŒ‡å®šæ˜¯å¦è‡ªå¢é•¿ä¸»é”® --\u0026gt; \u0026lt;!-- needAddLimit: æŒ‡å®šé€»è¾‘è¡¨æ˜¯å¦åœ¨æŸ¥è¯¢çš„æ—¶å€™è‡ªåŠ¨æ·»åŠ limitå»é™åˆ¶è¿”å›çš„ç»“æœé›†è®°å½•æ•°ï¼Œé»˜è®¤ä¸ºtrue,å¦‚æœè¯­å¥ä¸­å·²ç»åŒ…å«äº†limitå…³é”®å­—ï¼Œåˆ™ä¸ä¼šé‡å¤æ·»åŠ  --\u0026gt; \u0026lt;table name=\u0026#34;tb_goods_base\u0026#34; dataNode=\u0026#34;dn1\u0026#34; primaryKey=\u0026#34;id\u0026#34; /\u0026gt; \u0026lt;table name=\u0026#34;tb_goods_brand\u0026#34; dataNode=\u0026#34;dn1\u0026#34; primaryKey=\u0026#34;id\u0026#34; /\u0026gt; \u0026lt;table name=\u0026#34;tb_goods_cat\u0026#34; dataNode=\u0026#34;dn1\u0026#34; primaryKey=\u0026#34;id\u0026#34; /\u0026gt; \u0026lt;table name=\u0026#34;tb_goods_desc\u0026#34; dataNode=\u0026#34;dn1\u0026#34; primaryKey=\u0026#34;goods_id\u0026#34; /\u0026gt; \u0026lt;table name=\u0026#34;tb_goods_item\u0026#34; dataNode=\u0026#34;dn1\u0026#34; primaryKey=\u0026#34;id\u0026#34; /\u0026gt; \u0026lt;table name=\u0026#34;tb_order_item\u0026#34; dataNode=\u0026#34;dn2\u0026#34; primaryKey=\u0026#34;id\u0026#34; /\u0026gt; \u0026lt;table name=\u0026#34;tb_order_master\u0026#34; dataNode=\u0026#34;dn2\u0026#34; primaryKey=\u0026#34;order_id\u0026#34; /\u0026gt; \u0026lt;table name=\u0026#34;tb_order_pay_log\u0026#34; dataNode=\u0026#34;dn2\u0026#34; primaryKey=\u0026#34;out_trade_no\u0026#34; /\u0026gt; \u0026lt;table name=\u0026#34;tb_user\u0026#34; dataNode=\u0026#34;dn3\u0026#34; primaryKey=\u0026#34;id\u0026#34; /\u0026gt; \u0026lt;table name=\u0026#34;tb_user_address\u0026#34; dataNode=\u0026#34;dn3\u0026#34; primaryKey=\u0026#34;id\u0026#34; /\u0026gt; \u0026lt;!-- å…¨å±€è¡¨ --\u0026gt; \u0026lt;table name=\u0026#34;tb_areas_provinces\u0026#34; dataNode=\u0026#34;dn1,dn2,dn3\u0026#34; primaryKey=\u0026#34;id\u0026#34; type=\u0026#34;global\u0026#34;/\u0026gt; \u0026lt;table name=\u0026#34;tb_areas_city\u0026#34; dataNode=\u0026#34;dn1,dn2,dn3\u0026#34; primaryKey=\u0026#34;id\u0026#34; type=\u0026#34;global\u0026#34;/\u0026gt; \u0026lt;table name=\u0026#34;tb_areas_region\u0026#34; dataNode=\u0026#34;dn1,dn2,dn3\u0026#34; primaryKey=\u0026#34;id\u0026#34; type=\u0026#34;global\u0026#34;/\u0026gt; \u0026lt;!-- \u0026lt;table name=\u0026#34;t_order\u0026#34; dataNode=\u0026#34;dn1,dn2\u0026#34; rule=\u0026#34;mod-long\u0026#34;\u0026gt; # å®šä¹‰E-Råˆ†ç‰‡çš„å­è¡¨ï¼Œé€šè¿‡æ ‡ç­¾ä¸Šçš„å±æ€§ä¸çˆ¶è¡¨è¿›è¡Œå…³è” # nameï¼šå­è¡¨çš„åç§°t_order_detail # primaryKeyï¼šå­è¡¨çš„ä¸»é”® # joinKeyï¼šæ–°å¢å­è¡¨è®°å½•çš„æ—¶å€™ï¼Œä¼šæ ¹æ®è¯¥å€¼æŸ¥è¯¢çˆ¶è¡¨åœ¨å“ªä¸ªåˆ†ç‰‡èŠ‚ç‚¹ä¸Šã€‚ï¼ˆå­è¡¨ä¸­å­—æ®µçš„åç§°order_i # parentKeyå±æ€§ï¼šä¸çˆ¶è¡¨å»ºç«‹å…³è”å…³ç³»çš„åˆ—ï¼Œç»“åˆjoinKeyç¡®å®šå¥½å­è¡¨è®°å½•å­˜æ”¾çš„åˆ†ç‰‡èŠ‚ç‚¹ï¼Œæ’å…¥å­è¡¨è®°å½•æ—¶ç›´æ¥æ’å…¥åˆ°è¯¥åˆ†ç‰‡èŠ‚ç‚¹ä¸Šã€‚ï¼ˆçˆ¶è¡¨ä¸­å­—æ®µåç§°order_idï¼‰ # needAddLimitå±æ€§ï¼š æŒ‡å®šé€»è¾‘è¡¨æ˜¯å¦åœ¨æŸ¥è¯¢çš„æ—¶å€™è‡ªåŠ¨æ·»åŠ limitå»é™åˆ¶è¿”å›çš„ç»“æœé›†è®°å½•æ•°ï¼Œé»˜è®¤ä¸ºtrue,å¦‚æœè¯­å¥ä¸­å·²ç»åŒ…å«äº†limitå…³é”®å­—ï¼Œåˆ™ä¸ä¼šé‡å¤æ·»åŠ  \u0026lt;childTable name=\u0026#34;t_order_detail\u0026#34; primaryKey=\u0026#34;od_id\u0026#34; joinKey=\u0026#34;order_id\u0026#34; parentKey=\u0026#34;order_id\u0026#34;\u0026gt;\u0026lt;/childTable\u0026gt; \u0026lt;/table\u0026gt; --\u0026gt; \u0026lt;/schema\u0026gt; \u0026lt;!-- æ•°æ®èŠ‚ç‚¹ --\u0026gt; \u0026lt;!-- name: æŒ‡å®šåˆ†ç‰‡èŠ‚ç‚¹çš„åç§°ï¼Œä¸å£°æ˜é€»è¾‘è¡¨tableæ ‡ç­¾ä¸­çš„dataNodeåå­—å¯¹åº”ä¸Š --\u0026gt; \u0026lt;!-- dataHost: æŒ‡å®šåˆ†ç‰‡èŠ‚ç‚¹æ‰€åœ¨çš„èŠ‚ç‚¹ä¸»æœºï¼ˆæ•°æ®åº“å®ä¾‹ï¼‰ï¼Œä¸dataHostæ ‡ç­¾å£°æ˜çš„nameå¯¹åº” --\u0026gt; \u0026lt;!-- database: çœŸå®æ•°æ®åº“åç§° --\u0026gt; \u0026lt;dataNode name=\u0026#34;dn1\u0026#34; dataHost=\u0026#34;dhost1\u0026#34; database=\u0026#34;shopping\u0026#34; /\u0026gt; \u0026lt;dataNode name=\u0026#34;dn2\u0026#34; dataHost=\u0026#34;dhost2\u0026#34; database=\u0026#34;shopping\u0026#34; /\u0026gt; \u0026lt;dataNode name=\u0026#34;dn3\u0026#34; dataHost=\u0026#34;dhost3\u0026#34; database=\u0026#34;shopping\u0026#34; /\u0026gt; \u0026lt;!-- å…·ä½“æ•°æ®åº“å®ä¾‹ --\u0026gt; \u0026lt;dataHost name=\u0026#34;dhost1\u0026#34; maxCon=\u0026#34;1000\u0026#34; minCon=\u0026#34;10\u0026#34; balance=\u0026#34;0\u0026#34; writeType=\u0026#34;0\u0026#34; dbType=\u0026#34;mysql\u0026#34; dbDriver=\u0026#34;native\u0026#34; switchType=\u0026#34;1\u0026#34; slaveThreshold=\u0026#34;100\u0026#34;\u0026gt; \u0026lt;!--å¿ƒè·³æ£€æµ‹ --\u0026gt; \u0026lt;heartbeat\u0026gt;select user()\u0026lt;/heartbeat\u0026gt; \u0026lt;!-- å†™æœåŠ¡å™¨ï¼Œå¦‚æœè¦é…ç½®è¯»å†™ï¼Œæ·»åŠ readHostæ ‡ç­¾å³å¯ --\u0026gt; \u0026lt;writeHost host=\u0026#34;M1\u0026#34; url=\u0026#34;172.16.0.101:3306\u0026#34; user=\u0026#34;root\u0026#34; password=\u0026#34;123456\u0026#34;\u0026gt; \u0026lt;/writeHost\u0026gt; \u0026lt;/dataHost\u0026gt; \u0026lt;dataHost name=\u0026#34;dhost2\u0026#34; maxCon=\u0026#34;1000\u0026#34; minCon=\u0026#34;10\u0026#34; balance=\u0026#34;0\u0026#34; writeType=\u0026#34;0\u0026#34; dbType=\u0026#34;mysql\u0026#34; dbDriver=\u0026#34;native\u0026#34; switchType=\u0026#34;1\u0026#34; slaveThreshold=\u0026#34;100\u0026#34;\u0026gt; \u0026lt;!--å¿ƒè·³æ£€æµ‹ --\u0026gt; \u0026lt;heartbeat\u0026gt;select user()\u0026lt;/heartbeat\u0026gt; \u0026lt;!-- å†™æœåŠ¡å™¨ï¼Œå¦‚æœè¦é…ç½®è¯»å†™ï¼Œæ·»åŠ readHostæ ‡ç­¾å³å¯ --\u0026gt; \u0026lt;writeHost host=\u0026#34;M2\u0026#34; url=\u0026#34;172.16.0.102:3306\u0026#34; user=\u0026#34;root\u0026#34; password=\u0026#34;123456\u0026#34;\u0026gt; \u0026lt;/writeHost\u0026gt; \u0026lt;/dataHost\u0026gt; \u0026lt;!-- name: æŒ‡å®šåˆ†ç‰‡ä¸»æœºçš„åç§°ï¼Œä¾›dataNodeæ ‡ç­¾ä½¿ç”¨ --\u0026gt; \u0026lt;!-- maxCon: æŒ‡å®šè¯»å†™å®ä¾‹çš„è¿æ¥æ± çš„æœ€å¤§è¿æ¥æ•°é‡ --\u0026gt; \u0026lt;!-- minCon: æŒ‡å®šè¯»å†™å®ä¾‹çš„è¿æ¥æ± çš„æœ€å°è¿æ¥æ•°é‡ï¼Œåˆå§‹åŒ–è¿æ¥æ± çš„å¤§å° --\u0026gt; \u0026lt;!-- balance: æŒ‡å®šè´Ÿè½½å‡è¡¡çš„ç±»å‹ balance = â€œ0â€ : ä¸å¼€å¯è¯»å†™åˆ†ç¦»ï¼Œæ‰€æœ‰çš„è¯»è¯·æ±‚éƒ½å‘é€åˆ°å¯ç”¨çš„writeHostå†™èŠ‚ç‚¹ä¸Šï¼ˆä¸ä¼šå‘readHostï¼‰ balance = â€œ1â€ : å…¨éƒ¨çš„readHostä¸stand by writeHostå‚ä¸selectè¯­å¥çš„è´Ÿè½½å‡è¡¡ï¼Œ balance = â€œ2â€ : è¯»æ“ä½œä¼šéšæœºå‘å¾€writeHostä»¥åŠ readHostï¼Œç†è®ºä¸Šå®ç°çš„æ˜¯è´Ÿè½½å‡è¡¡ balance = â€œ3â€ : é…ç½®äº†readHostæ—¶è¯»æ“ä½œä¼šéšæœºå‘å¾€readHostï¼ˆä¸ä¼šå‘writeHostï¼‰ï¼Œè€Œæ²¡æœ‰é…ç½®readHostæ—¶è¯»æ“ä½œä¼šå‘å¾€ç¬¬ä¸€ä¸ªwriteHostã€‚ --\u0026gt; \u0026lt;!-- writeType: writeType=\u0026#34;0\u0026#34;: æ‰€æœ‰å†™æ“ä½œå‘é€åˆ°é…ç½®çš„ç¬¬ä¸€ä¸ªwriteHostï¼Œå½“ç¬¬ä¸€ä¸ªwriteHostå®•æœºæ—¶ï¼Œåˆ‡æ¢åˆ°ç¬¬äºŒä¸ªwriteHostï¼Œé‡æ–°å¯åŠ¨åä»¥åˆ‡æ¢åçš„ä¸ºå‡†ï¼Œåˆ‡æ¢è®°å½•åœ¨é…ç½®æ–‡ä»¶ï¼šdnindex.propertiesä¸­ writeType=\u0026#34;1\u0026#34;: æ‰€æœ‰å†™æ“ä½œéƒ½éšå‘é€åˆ°é…ç½®çš„writeHost --\u0026gt; \u0026lt;!-- dbType: æŒ‡å®šåç«¯æ•°æ®åº“ç±»å‹ï¼Œæ”¯æŒmysqlã€oracleç­‰ --\u0026gt; \u0026lt;!-- dbDriver: æŒ‡å®šåç«¯æ•°æ®åº“è¿æ¥é©±åŠ¨ä¿¡æ¯ï¼Œæ”¯æŒnativeå’Œjdbc --\u0026gt; \u0026lt;!-- switchType: æŒ‡å®šåˆ‡æ¢æ–¹å¼ switchType = -1ï¼šä¸è‡ªåŠ¨åˆ‡æ¢ switchType = 1ï¼šè‡ªåŠ¨åˆ‡æ¢ï¼ˆé»˜è®¤ï¼‰ switchType = 2ï¼šåŸºäºMySqlä¸»ä»åŒæ­¥çš„çŠ¶æ€æ¥å†³å®šæ˜¯å¦åˆ‡æ¢ï¼Œå¿ƒè·³è¯­å¥: show slave status switchType = 3: åŸºäºmysql galary clusterçš„åˆ‡æ¢æœºåˆ¶ï¼Œå¿ƒè·³è¯­å¥ï¼š show status like \u0026#39;wsrep%\u0026#39; --\u0026gt; \u0026lt;!-- slaveThreshold: --\u0026gt; \u0026lt;dataHost name=\u0026#34;dhost3\u0026#34; maxCon=\u0026#34;1000\u0026#34; minCon=\u0026#34;10\u0026#34; balance=\u0026#34;0\u0026#34; writeType=\u0026#34;0\u0026#34; dbType=\u0026#34;mysql\u0026#34; dbDriver=\u0026#34;native\u0026#34; switchType=\u0026#34;1\u0026#34; slaveThreshold=\u0026#34;100\u0026#34;\u0026gt; \u0026lt;!--å¿ƒè·³æ£€æµ‹ï¼ŒæŒ‡å®šåç«¯æ•°æ®åº“è¿›è¡Œå¿ƒè·³æ£€æŸ¥çš„è¯­å¥ --\u0026gt; \u0026lt;heartbeat\u0026gt;select user()\u0026lt;/heartbeat\u0026gt; \u0026lt;!-- å†™æœåŠ¡å™¨ï¼Œå¦‚æœè¦é…ç½®è¯»å†™ï¼Œæ·»åŠ readHostæ ‡ç­¾å³å¯ --\u0026gt; \u0026lt;!-- host: ç”¨äºæ ‡è¯†ä¸åŒå®ä¾‹ï¼Œä¸€èˆ¬ writeHost æˆ‘ä»¬ä½¿ç”¨M1ï¼ŒreadHost æˆ‘ä»¬ç”¨S1 --\u0026gt; \u0026lt;!-- url: åç«¯å®ä¾‹è¿æ¥åœ°å€ï¼Œå¦‚æœæ˜¯ä½¿ç”¨ native çš„ dbDriverï¼Œåˆ™ä¸€èˆ¬ä¸º address:port è¿™ç§å½¢å¼,ç”¨ JDBC æˆ–å…¶ä»–çš„ dbDriverï¼Œåˆ™éœ€è¦ç‰¹æ®ŠæŒ‡å®šï¼Œä½¿ç”¨ JDBC æ—¶åˆ™å¯ä»¥è¿™ä¹ˆå†™ï¼šjdbc:mysql://localhost:3306/ --\u0026gt; \u0026lt;!-- user: åç«¯å­˜å‚¨å®ä¾‹éœ€è¦çš„ç”¨æˆ·å --\u0026gt; \u0026lt;!-- password: åç«¯å­˜å‚¨å®ä¾‹éœ€è¦çš„å¯†ç  --\u0026gt; \u0026lt;!-- weight: æƒé‡ é…ç½®åœ¨ readhost ä¸­ä½œä¸ºè¯»èŠ‚ç‚¹çš„æƒé‡ --\u0026gt; \u0026lt;!-- usingDecrypt: æ˜¯å¦å¯¹å¯†ç åŠ å¯†é»˜è®¤ 0 å¦ å¦‚éœ€è¦å¼€å¯é…ç½® 1ï¼ŒåŒæ—¶ä½¿ç”¨åŠ å¯†ç¨‹åºå¯¹å¯†ç åŠ å¯† --\u0026gt; \u0026lt;writeHost host=\u0026#34;M3\u0026#34; url=\u0026#34;172.16.0.103:3306\u0026#34; user=\u0026#34;root\u0026#34; password=\u0026#34;123456\u0026#34;\u0026gt; \u0026lt;/writeHost\u0026gt; \u0026lt;/dataHost\u0026gt; \u0026lt;/mycat:schema\u0026gt; server.xml \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;!DOCTYPE mycat:server SYSTEM \u0026#34;server.dtd\u0026#34;\u0026gt; \u0026lt;mycat:server xmlns:mycat=\u0026#34;http://io.mycat/\u0026#34;\u0026gt; \u0026lt;system\u0026gt; \u0026lt;!-- å­—ç¬¦é›†ï¼Œéœ€è¦ä¿è¯MyCatå­—ç¬¦é›†ä¸æ•°æ®åº“å­—ç¬¦é›†ä¸€è‡´ --\u0026gt; \u0026lt;property name=\u0026#34;charset\u0026#34;\u0026gt;utf8mb4\u0026lt;/property\u0026gt; \u0026lt;!-- SQLè§£æå™¨ --\u0026gt; \u0026lt;property name=\u0026#34;defaultSqlParser\u0026#34;\u0026gt;druidparser\u0026lt;/property\u0026gt; \u0026lt;!-- MyCatç³»ç»Ÿå¯ç”¨çš„çº¿ç¨‹æ•°é‡ --\u0026gt; \u0026lt;property name=\u0026#34;processors\u0026#34;\u0026gt;1\u0026lt;/property\u0026gt; \u0026lt;!-- æŒ‡å®šMyCatå…¨å±€åºåˆ—çš„ç±»å‹ï¼Œ0è¡¨ç¤ºæœ¬åœ°æ–‡ä»¶æ–¹å¼ 1è¡¨ç¤ºæ•°æ®åº“æ–¹å¼ 2è¡¨ç¤ºæ—¶é—´æˆ³æ–¹å¼ --\u0026gt; \u0026lt;property name=\u0026#34;sequenceHandlerType\u0026#34;\u0026gt;0\u0026lt;/property\u0026gt; \u0026lt;!-- 1ä¸ºå¼€å¯å®æ—¶ç»Ÿè®¡ã€0ä¸ºå…³é—­ --\u0026gt; \u0026lt;property name=\u0026#34;useSqlStat\u0026#34;\u0026gt;0\u0026lt;/property\u0026gt; \u0026lt;!-- 1ä¸ºå¼€å¯å…¨å±€è¡¨ä¸€è‡´æ€§æ£€æµ‹ã€0ä¸ºå…³é—­ --\u0026gt; \u0026lt;property name=\u0026#34;useGlobleTableCheck\u0026#34;\u0026gt;0\u0026lt;/property\u0026gt; \u0026lt;!-- MyCatçš„ç«¯å£ï¼Œé»˜è®¤ä¸º8066 --\u0026gt; \u0026lt;property name=\u0026#34;serverPort\u0026#34;\u0026gt;8066\u0026lt;/property\u0026gt; \u0026lt;!-- MyCatç®¡ç†ç«¯å£ï¼Œé»˜è®¤ä¸º9066 --\u0026gt; \u0026lt;property name=\u0026#34;managerPort\u0026#34;\u0026gt;9066\u0026lt;/property\u0026gt; \u0026lt;!-- æœåŠ¡ç›‘å¬çš„IPåœ°å€ï¼Œé»˜è®¤ä¸º0.0.0.0 --\u0026gt; \u0026lt;property name=\u0026#34;bindIp\u0026#34;\u0026gt;0.0.0.0\u0026lt;/property\u0026gt; \u0026lt;!-- æŒ‡å®šè¿æ¥çš„ç©ºé—²æ—¶é—´çš„è¶…æ—¶é•¿åº¦ï¼Œå¦‚æœæŸä¸ªè¿æ¥çš„ç©ºé—²æ—¶é—´è¶…æ—¶é•¿åº¦å¤§äºidleTimeoutï¼Œåˆ™è¯¥è¿æ¥ä¼šè¢«å›æ”¶ï¼Œé»˜è®¤30åˆ†é’Ÿ --\u0026gt; \u0026lt;property name=\u0026#34;idleTimeout\u0026#34;\u0026gt;300000\u0026lt;/property\u0026gt; \u0026lt;!--åˆ†å¸ƒå¼äº‹åŠ¡å¼€å…³ï¼Œ0ä¸ºä¸è¿‡æ»¤åˆ†å¸ƒå¼äº‹åŠ¡ï¼Œ1ä¸ºè¿‡æ»¤åˆ†å¸ƒå¼äº‹åŠ¡ï¼ˆå¦‚æœåˆ†å¸ƒå¼äº‹åŠ¡å†…åªæ¶‰åŠå…¨å±€è¡¨ï¼Œåˆ™ä¸è¿‡æ»¤ï¼‰ï¼Œ2ä¸ºä¸è¿‡æ»¤åˆ†å¸ƒå¼äº‹åŠ¡,ä½†æ˜¯è®°å½•åˆ†å¸ƒå¼äº‹åŠ¡æ—¥å¿—--\u0026gt; \u0026lt;property name=\u0026#34;handleDistributedTransactions\u0026#34;\u0026gt;0\u0026lt;/property\u0026gt; \u0026lt;!-- é…ç½®æ˜¯å¦å¯ç”¨éå †å†…å­˜å¤„ç†è·¨åˆ†ç‰‡ç»“æœé›†ã€‚ 1å¼€å¯ 0å…³é—­ --\u0026gt; \u0026lt;property name=\u0026#34;useOffHeapForMerge\u0026#34;\u0026gt;1\u0026lt;/property\u0026gt; \u0026lt;!--æ˜¯å¦é‡‡ç”¨zookeeperåè°ƒåˆ‡æ¢ --\u0026gt; \u0026lt;property name=\u0026#34;useZKSwitch\u0026#34;\u0026gt;true\u0026lt;/property\u0026gt; \u0026lt;/system\u0026gt; \u0026lt;user name=\u0026#34;root\u0026#34; defaultAccount=\u0026#34;true\u0026#34;\u0026gt; \u0026lt;!-- ç”¨æˆ·å¯†ç  --\u0026gt; \u0026lt;property name=\u0026#34;password\u0026#34;\u0026gt;123456\u0026lt;/property\u0026gt; \u0026lt;!-- ç”¨æˆ·å¯è®¿é—®çš„é€»è¾‘æ•°æ®åº“æœ‰ï¼Œå¤šä¸ªé€»è¾‘åº“ä½¿ç”¨è‹±æ–‡é€—å·åˆ†éš”å¼€ --\u0026gt; \u0026lt;property name=\u0026#34;schemas\u0026#34;\u0026gt;shopping\u0026lt;/property\u0026gt; \u0026lt;!-- è¡¨çº§ DML æƒé™è®¾ç½® --\u0026gt; \u0026lt;privileges check=\u0026#34;false\u0026#34;\u0026gt; \u0026lt;schema name=\u0026#34;shopping\u0026#34; dml=\u0026#34;0110\u0026#34; \u0026gt; \u0026lt;table name=\u0026#34;tb_goods_base\u0026#34; dml=\u0026#34;1111\u0026#34;\u0026gt;\u0026lt;/table\u0026gt; \u0026lt;/schema\u0026gt; \u0026lt;/privileges\u0026gt; \u0026lt;/user\u0026gt; \u0026lt;user name=\u0026#34;user\u0026#34;\u0026gt; \u0026lt;!-- ç”¨æˆ·å¯†ç  --\u0026gt; \u0026lt;property name=\u0026#34;password\u0026#34;\u0026gt;123456\u0026lt;/property\u0026gt; \u0026lt;!-- ç”¨æˆ·å¯è®¿é—®çš„é€»è¾‘æ•°æ®åº“æœ‰ï¼Œå¤šä¸ªé€»è¾‘åº“ä½¿ç”¨è‹±æ–‡é€—å·åˆ†éš”å¼€ --\u0026gt; \u0026lt;property name=\u0026#34;schemas\u0026#34;\u0026gt;shopping\u0026lt;/property\u0026gt; \u0026lt;!-- ç”¨æˆ·çš„è¯»å†™æƒé™ --\u0026gt; \u0026lt;property name=\u0026#34;readOnly\u0026#34;\u0026gt;true\u0026lt;/property\u0026gt; \u0026lt;/user\u0026gt; \u0026lt;/mycat:server\u0026gt; github å®Œæ•´ä»£ç å‚çœ‹githubã€‚https://github.com/helium-chain/mycat-vertical æ°´å¹³åˆ†ç‰‡ åœ¨ä¸šåŠ¡ç³»ç»Ÿä¸­,æœ‰ä¸€å¼ è¡¨(æ—¥å¿—è¡¨),ä¸šåŠ¡ç³»ç»Ÿæ¯å¤©éƒ½ä¼šäº§ç”Ÿå¤§é‡çš„æ—¥å¿—æ•°æ®,å•å°æœåŠ¡å™¨çš„æ•°æ®å­˜å‚¨åŠå¤„ç†èƒ½åŠ›æ˜¯æœ‰é™çš„,å¯ä»¥å¯¹æ•°æ®åº“è¡¨è¿›è¡Œæ‹†åˆ†ã€‚ åç§° IP ç«¯å£ MyCat 172.16.0.10 8066,9066 mysql1 172.16.0.101 3306 mysql2 172.16.0.102 3307 mysql3 172.16.0.103 3308 schema.xml \u0026lt;?xml version=\u0026#34;1.0\u0026#34;?\u0026gt; \u0026lt;!DOCTYPE mycat:schema SYSTEM \u0026#34;schema.dtd\u0026#34;\u0026gt; \u0026lt;mycat:schema xmlns:mycat=\u0026#34;http://io.mycat/\u0026#34;\u0026gt; \u0026lt;!-- é€»è¾‘åº“ --\u0026gt; \u0026lt;!-- name: é€»è¾‘åº“åå­— --\u0026gt; \u0026lt;!-- checkSQLschema: å½“è®¾ç½®ä¸ºtrueæ—¶ï¼Œæ¯”å¦‚å‘é€ä¸€æ¡sql:select * from mycat_order.t_orderï¼Œé‚£ä¹ˆMyCatä¼šè‡ªåŠ¨å»æ‰mycat_orderé€»è¾‘åº“åå­—å‰ç¼€ï¼ŒæŠŠsqlå˜ä¸ºï¼šselect * from t_order, è¿™æ ·æœ‰æ•ˆé¿å…æŠ¥è¡¨æˆ–è§†å›¾ä¸å­˜åœ¨é”™è¯¯ã€‚ å¦‚æœä½¿ç”¨select * from test.t_order ï¼Œsqlè¯­å¥ä¸­æ‰€å¸¦çš„é€»è¾‘åº“åå­—è·Ÿschemaæ ‡ç­¾ä¸­çš„nameä¸ä¸€è‡´çš„è¯ï¼ŒMyCatä¸ä¼šè‡ªåŠ¨å»æ‰é€»è¾‘åº“åå­—å‰ç¼€ï¼Œå¦‚æœé€»è¾‘åº“ä¸å­˜åœ¨ï¼Œä»ç„¶ä¼šæŠ¥é”™ã€‚ --\u0026gt; \u0026lt;!-- sqlMaxLimit: å¦‚æœæ¯æ¬¡æ‰§è¡Œçš„sqlè¯­å¥åé¢æ²¡æœ‰è·Ÿä¸Šlimit xxå…³é”®å­—çš„è¯ï¼ŒMyCatä¼šè‡ªåŠ¨åœ¨sqlè¯­å¥çš„åé¢æ‹¼ä¸Šlimit 100 --\u0026gt; \u0026lt;!-- dataNode: ç”¨äºæŒ‡å®šæ²¡æœ‰åˆ†é…åˆ†ç‰‡èŠ‚ç‚¹çš„é‚£äº›è¡¨çš„é»˜è®¤æ•°æ®èŠ‚ç‚¹ --\u0026gt; \u0026lt;schema name=\u0026#34;shopping\u0026#34; checkSQLschema=\u0026#34;false\u0026#34; sqlMaxLimit=\u0026#34;100\u0026#34;\u0026gt; \u0026lt;!-- é€»è¾‘è¡¨ï¼Œä»¥ä¸‹éƒ½æ²¡æœ‰é…ç½®åˆ†ç‰‡è§„åˆ™ruleï¼Œå› ä¸ºå‚ç›´åˆ†è¡¨ä¸éœ€è¦å®ƒ --\u0026gt; \u0026lt;!-- name: é€»è¾‘è¡¨çš„åå­—ï¼ŒåŒä¸€ä¸ªé€»è¾‘åº“schemaä¸­çš„é€»è¾‘è¡¨çš„åç§°åº”è¯¥å”¯ä¸€ --\u0026gt; \u0026lt;!-- dataNode: é…ç½®é€»è¾‘è¡¨åˆ†å¸ƒçš„æ•°æ®èŠ‚ç‚¹ï¼Œåå­—éœ€è¦ä¸dataNodeæ ‡ç­¾çš„nameå¯¹åº”ä¸Š --\u0026gt; \u0026lt;!-- rule: é…ç½®é€»è¾‘è¡¨çš„åˆ†ç‰‡è§„åˆ™,éœ€è¦åœ¨rule.xmlä¸­å£°æ˜çš„è§„åˆ™åå­—å¯¹åº”ä¸Š --\u0026gt; \u0026lt;!-- ruleRequired: æŒ‡å®šåˆ†ç‰‡è§„åˆ™æ˜¯å¦å¿…é¡»ï¼Œå¦‚æœä¸ºtrue,ä½†æ˜¯æ²¡æœ‰æŒ‡å®šruleï¼Œç¨‹åºä¼šæŠ¥é”™ --\u0026gt; \u0026lt;!-- primaryKey: æŒ‡å®šé€»è¾‘è¡¨å¯¹åº”çœŸå®è¡¨çš„ä¸»é”® --\u0026gt; \u0026lt;!-- type: æŒ‡å®šè¯¥é€»è¾‘è¡¨æ˜¯å…¨å±€è¡¨è¿˜æ˜¯æ™®é€šé€»è¾‘è¡¨ã€‚type=\u0026#34;global\u0026#34;è¡¨ç¤ºå…¨å±€è¡¨ --\u0026gt; \u0026lt;!-- autoIncrement: æŒ‡å®šæ˜¯å¦è‡ªå¢é•¿ä¸»é”® --\u0026gt; \u0026lt;!-- needAddLimit: æŒ‡å®šé€»è¾‘è¡¨æ˜¯å¦åœ¨æŸ¥è¯¢çš„æ—¶å€™è‡ªåŠ¨æ·»åŠ limitå»é™åˆ¶è¿”å›çš„ç»“æœé›†è®°å½•æ•°ï¼Œé»˜è®¤ä¸ºtrue,å¦‚æœè¯­å¥ä¸­å·²ç»åŒ…å«äº†limitå…³é”®å­—ï¼Œåˆ™ä¸ä¼šé‡å¤æ·»åŠ  --\u0026gt; \u0026lt;table name=\u0026#34;tb_goods_base\u0026#34; dataNode=\u0026#34;dn1\u0026#34; primaryKey=\u0026#34;id\u0026#34; /\u0026gt; \u0026lt;table name=\u0026#34;tb_goods_brand\u0026#34; dataNode=\u0026#34;dn1\u0026#34; primaryKey=\u0026#34;id\u0026#34; /\u0026gt; \u0026lt;table name=\u0026#34;tb_goods_cat\u0026#34; dataNode=\u0026#34;dn1\u0026#34; primaryKey=\u0026#34;id\u0026#34; /\u0026gt; \u0026lt;table name=\u0026#34;tb_goods_desc\u0026#34; dataNode=\u0026#34;dn1\u0026#34; primaryKey=\u0026#34;goods_id\u0026#34; /\u0026gt; \u0026lt;table name=\u0026#34;tb_goods_item\u0026#34; dataNode=\u0026#34;dn1\u0026#34; primaryKey=\u0026#34;id\u0026#34; /\u0026gt; \u0026lt;table name=\u0026#34;tb_order_item\u0026#34; dataNode=\u0026#34;dn2\u0026#34; primaryKey=\u0026#34;id\u0026#34; /\u0026gt; \u0026lt;table name=\u0026#34;tb_order_master\u0026#34; dataNode=\u0026#34;dn2\u0026#34; primaryKey=\u0026#34;order_id\u0026#34; /\u0026gt; \u0026lt;table name=\u0026#34;tb_order_pay_log\u0026#34; dataNode=\u0026#34;dn2\u0026#34; primaryKey=\u0026#34;out_trade_no\u0026#34; /\u0026gt; \u0026lt;table name=\u0026#34;tb_user\u0026#34; dataNode=\u0026#34;dn3\u0026#34; primaryKey=\u0026#34;id\u0026#34; /\u0026gt; \u0026lt;table name=\u0026#34;tb_user_address\u0026#34; dataNode=\u0026#34;dn3\u0026#34; primaryKey=\u0026#34;id\u0026#34; /\u0026gt; \u0026lt;!-- å…¨å±€è¡¨ --\u0026gt; \u0026lt;table name=\u0026#34;tb_areas_provinces\u0026#34; dataNode=\u0026#34;dn1,dn2,dn3\u0026#34; primaryKey=\u0026#34;id\u0026#34; type=\u0026#34;global\u0026#34;/\u0026gt; \u0026lt;table name=\u0026#34;tb_areas_city\u0026#34; dataNode=\u0026#34;dn1,dn2,dn3\u0026#34; primaryKey=\u0026#34;id\u0026#34; type=\u0026#34;global\u0026#34;/\u0026gt; \u0026lt;table name=\u0026#34;tb_areas_region\u0026#34; dataNode=\u0026#34;dn1,dn2,dn3\u0026#34; primaryKey=\u0026#34;id\u0026#34; type=\u0026#34;global\u0026#34;/\u0026gt; \u0026lt;!-- \u0026lt;table name=\u0026#34;t_order\u0026#34; dataNode=\u0026#34;dn1,dn2\u0026#34; rule=\u0026#34;mod-long\u0026#34;\u0026gt; # å®šä¹‰E-Råˆ†ç‰‡çš„å­è¡¨ï¼Œé€šè¿‡æ ‡ç­¾ä¸Šçš„å±æ€§ä¸çˆ¶è¡¨è¿›è¡Œå…³è” # nameï¼šå­è¡¨çš„åç§°t_order_detail # primaryKeyï¼šå­è¡¨çš„ä¸»é”® # joinKeyï¼šæ–°å¢å­è¡¨è®°å½•çš„æ—¶å€™ï¼Œä¼šæ ¹æ®è¯¥å€¼æŸ¥è¯¢çˆ¶è¡¨åœ¨å“ªä¸ªåˆ†ç‰‡èŠ‚ç‚¹ä¸Šã€‚ï¼ˆå­è¡¨ä¸­å­—æ®µçš„åç§°order_i # parentKeyå±æ€§ï¼šä¸çˆ¶è¡¨å»ºç«‹å…³è”å…³ç³»çš„åˆ—ï¼Œç»“åˆjoinKeyç¡®å®šå¥½å­è¡¨è®°å½•å­˜æ”¾çš„åˆ†ç‰‡èŠ‚ç‚¹ï¼Œæ’å…¥å­è¡¨è®°å½•æ—¶ç›´æ¥æ’å…¥åˆ°è¯¥åˆ†ç‰‡èŠ‚ç‚¹ä¸Šã€‚ï¼ˆçˆ¶è¡¨ä¸­å­—æ®µåç§°order_idï¼‰ # needAddLimitå±æ€§ï¼š æŒ‡å®šé€»è¾‘è¡¨æ˜¯å¦åœ¨æŸ¥è¯¢çš„æ—¶å€™è‡ªåŠ¨æ·»åŠ limitå»é™åˆ¶è¿”å›çš„ç»“æœé›†è®°å½•æ•°ï¼Œé»˜è®¤ä¸ºtrue,å¦‚æœè¯­å¥ä¸­å·²ç»åŒ…å«äº†limitå…³é”®å­—ï¼Œåˆ™ä¸ä¼šé‡å¤æ·»åŠ  \u0026lt;childTable name=\u0026#34;t_order_detail\u0026#34; primaryKey=\u0026#34;od_id\u0026#34; joinKey=\u0026#34;order_id\u0026#34; parentKey=\u0026#34;order_id\u0026#34;\u0026gt;\u0026lt;/childTable\u0026gt; \u0026lt;/table\u0026gt; --\u0026gt; \u0026lt;/schema\u0026gt; \u0026lt;schema name=\u0026#34;logs\u0026#34; checkSQLschema=\u0026#34;false\u0026#34; sqlMaxLimit=\u0026#34;100\u0026#34;\u0026gt; \u0026lt;!-- æ°´å¹³åˆ†ç‰‡ --\u0026gt; \u0026lt;!-- ruleï¼šåˆ†ç‰‡è§„åˆ™ --\u0026gt; \u0026lt;table name=\u0026#34;tb_log\u0026#34; dataNode=\u0026#34;dn4,dn5,dn6\u0026#34; primaryKey=\u0026#34;id\u0026#34; rule=\u0026#34;mod-long\u0026#34; /\u0026gt; \u0026lt;/schema\u0026gt; \u0026lt;!-- æ•°æ®èŠ‚ç‚¹ --\u0026gt; \u0026lt;!-- name: æŒ‡å®šåˆ†ç‰‡èŠ‚ç‚¹çš„åç§°ï¼Œä¸å£°æ˜é€»è¾‘è¡¨tableæ ‡ç­¾ä¸­çš„dataNodeåå­—å¯¹åº”ä¸Š --\u0026gt; \u0026lt;!-- dataHost: æŒ‡å®šåˆ†ç‰‡èŠ‚ç‚¹æ‰€åœ¨çš„èŠ‚ç‚¹ä¸»æœºï¼ˆæ•°æ®åº“å®ä¾‹ï¼‰ï¼Œä¸dataHostæ ‡ç­¾å£°æ˜çš„nameå¯¹åº” --\u0026gt; \u0026lt;!-- database: çœŸå®æ•°æ®åº“åç§° --\u0026gt; \u0026lt;dataNode name=\u0026#34;dn1\u0026#34; dataHost=\u0026#34;dhost1\u0026#34; database=\u0026#34;shopping\u0026#34; /\u0026gt; \u0026lt;dataNode name=\u0026#34;dn2\u0026#34; dataHost=\u0026#34;dhost2\u0026#34; database=\u0026#34;shopping\u0026#34; /\u0026gt; \u0026lt;dataNode name=\u0026#34;dn3\u0026#34; dataHost=\u0026#34;dhost3\u0026#34; database=\u0026#34;shopping\u0026#34; /\u0026gt; \u0026lt;dataNode name=\u0026#34;dn4\u0026#34; dataHost=\u0026#34;dhost1\u0026#34; database=\u0026#34;logs\u0026#34; /\u0026gt; \u0026lt;dataNode name=\u0026#34;dn5\u0026#34; dataHost=\u0026#34;dhost2\u0026#34; database=\u0026#34;logs\u0026#34; /\u0026gt; \u0026lt;dataNode name=\u0026#34;dn6\u0026#34; dataHost=\u0026#34;dhost3\u0026#34; database=\u0026#34;logs\u0026#34; /\u0026gt; \u0026lt;!-- å…·ä½“æ•°æ®åº“å®ä¾‹ --\u0026gt; \u0026lt;dataHost name=\u0026#34;dhost1\u0026#34; maxCon=\u0026#34;1000\u0026#34; minCon=\u0026#34;10\u0026#34; balance=\u0026#34;0\u0026#34; writeType=\u0026#34;0\u0026#34; dbType=\u0026#34;mysql\u0026#34; dbDriver=\u0026#34;native\u0026#34; switchType=\u0026#34;1\u0026#34; slaveThreshold=\u0026#34;100\u0026#34;\u0026gt; \u0026lt;!--å¿ƒè·³æ£€æµ‹ --\u0026gt; \u0026lt;heartbeat\u0026gt;select user()\u0026lt;/heartbeat\u0026gt; \u0026lt;!-- å†™æœåŠ¡å™¨ï¼Œå¦‚æœè¦é…ç½®è¯»å†™ï¼Œæ·»åŠ readHostæ ‡ç­¾å³å¯ --\u0026gt; \u0026lt;writeHost host=\u0026#34;M1\u0026#34; url=\u0026#34;172.16.0.101:3306\u0026#34; user=\u0026#34;root\u0026#34; password=\u0026#34;123456\u0026#34;\u0026gt; \u0026lt;/writeHost\u0026gt; \u0026lt;/dataHost\u0026gt; \u0026lt;dataHost name=\u0026#34;dhost2\u0026#34; maxCon=\u0026#34;1000\u0026#34; minCon=\u0026#34;10\u0026#34; balance=\u0026#34;0\u0026#34; writeType=\u0026#34;0\u0026#34; dbType=\u0026#34;mysql\u0026#34; dbDriver=\u0026#34;native\u0026#34; switchType=\u0026#34;1\u0026#34; slaveThreshold=\u0026#34;100\u0026#34;\u0026gt; \u0026lt;!--å¿ƒè·³æ£€æµ‹ --\u0026gt; \u0026lt;heartbeat\u0026gt;select user()\u0026lt;/heartbeat\u0026gt; \u0026lt;!-- å†™æœåŠ¡å™¨ï¼Œå¦‚æœè¦é…ç½®è¯»å†™ï¼Œæ·»åŠ readHostæ ‡ç­¾å³å¯ --\u0026gt; \u0026lt;writeHost host=\u0026#34;M2\u0026#34; url=\u0026#34;172.16.0.102:3306\u0026#34; user=\u0026#34;root\u0026#34; password=\u0026#34;123456\u0026#34;\u0026gt; \u0026lt;/writeHost\u0026gt; \u0026lt;/dataHost\u0026gt; \u0026lt;!-- name: æŒ‡å®šåˆ†ç‰‡ä¸»æœºçš„åç§°ï¼Œä¾›dataNodeæ ‡ç­¾ä½¿ç”¨ --\u0026gt; \u0026lt;!-- maxCon: æŒ‡å®šè¯»å†™å®ä¾‹çš„è¿æ¥æ± çš„æœ€å¤§è¿æ¥æ•°é‡ --\u0026gt; \u0026lt;!-- minCon: æŒ‡å®šè¯»å†™å®ä¾‹çš„è¿æ¥æ± çš„æœ€å°è¿æ¥æ•°é‡ï¼Œåˆå§‹åŒ–è¿æ¥æ± çš„å¤§å° --\u0026gt; \u0026lt;!-- balance: æŒ‡å®šè´Ÿè½½å‡è¡¡çš„ç±»å‹ balance = â€œ0â€ : ä¸å¼€å¯è¯»å†™åˆ†ç¦»ï¼Œæ‰€æœ‰çš„è¯»è¯·æ±‚éƒ½å‘é€åˆ°å¯ç”¨çš„writeHostå†™èŠ‚ç‚¹ä¸Šï¼ˆä¸ä¼šå‘readHostï¼‰ balance = â€œ1â€ : å…¨éƒ¨çš„readHostä¸stand by writeHostå‚ä¸selectè¯­å¥çš„è´Ÿè½½å‡è¡¡ï¼Œ balance = â€œ2â€ : è¯»æ“ä½œä¼šéšæœºå‘å¾€writeHostä»¥åŠ readHostï¼Œç†è®ºä¸Šå®ç°çš„æ˜¯è´Ÿè½½å‡è¡¡ balance = â€œ3â€ : é…ç½®äº†readHostæ—¶è¯»æ“ä½œä¼šéšæœºå‘å¾€readHostï¼ˆä¸ä¼šå‘writeHostï¼‰ï¼Œè€Œæ²¡æœ‰é…ç½®readHostæ—¶è¯»æ“ä½œä¼šå‘å¾€ç¬¬ä¸€ä¸ªwriteHostã€‚ --\u0026gt; \u0026lt;!-- writeType: writeType=\u0026#34;0\u0026#34;: æ‰€æœ‰å†™æ“ä½œå‘é€åˆ°é…ç½®çš„ç¬¬ä¸€ä¸ªwriteHostï¼Œå½“ç¬¬ä¸€ä¸ªwriteHostå®•æœºæ—¶ï¼Œåˆ‡æ¢åˆ°ç¬¬äºŒä¸ªwriteHostï¼Œé‡æ–°å¯åŠ¨åä»¥åˆ‡æ¢åçš„ä¸ºå‡†ï¼Œåˆ‡æ¢è®°å½•åœ¨é…ç½®æ–‡ä»¶ï¼šdnindex.propertiesä¸­ writeType=\u0026#34;1\u0026#34;: æ‰€æœ‰å†™æ“ä½œéƒ½éšå‘é€åˆ°é…ç½®çš„writeHost --\u0026gt; \u0026lt;!-- dbType: æŒ‡å®šåç«¯æ•°æ®åº“ç±»å‹ï¼Œæ”¯æŒmysqlã€oracleç­‰ --\u0026gt; \u0026lt;!-- dbDriver: æŒ‡å®šåç«¯æ•°æ®åº“è¿æ¥é©±åŠ¨ä¿¡æ¯ï¼Œæ”¯æŒnativeå’Œjdbc --\u0026gt; \u0026lt;!-- switchType: æŒ‡å®šåˆ‡æ¢æ–¹å¼ switchType = -1ï¼šä¸è‡ªåŠ¨åˆ‡æ¢ switchType = 1ï¼šè‡ªåŠ¨åˆ‡æ¢ï¼ˆé»˜è®¤ï¼‰ switchType = 2ï¼šåŸºäºMySqlä¸»ä»åŒæ­¥çš„çŠ¶æ€æ¥å†³å®šæ˜¯å¦åˆ‡æ¢ï¼Œå¿ƒè·³è¯­å¥: show slave status switchType = 3: åŸºäºmysql galary clusterçš„åˆ‡æ¢æœºåˆ¶ï¼Œå¿ƒè·³è¯­å¥ï¼š show status like \u0026#39;wsrep%\u0026#39; --\u0026gt; \u0026lt;!-- slaveThreshold: --\u0026gt; \u0026lt;dataHost name=\u0026#34;dhost3\u0026#34; maxCon=\u0026#34;1000\u0026#34; minCon=\u0026#34;10\u0026#34; balance=\u0026#34;0\u0026#34; writeType=\u0026#34;0\u0026#34; dbType=\u0026#34;mysql\u0026#34; dbDriver=\u0026#34;native\u0026#34; switchType=\u0026#34;1\u0026#34; slaveThreshold=\u0026#34;100\u0026#34;\u0026gt; \u0026lt;!--å¿ƒè·³æ£€æµ‹ï¼ŒæŒ‡å®šåç«¯æ•°æ®åº“è¿›è¡Œå¿ƒè·³æ£€æŸ¥çš„è¯­å¥ --\u0026gt; \u0026lt;heartbeat\u0026gt;select user()\u0026lt;/heartbeat\u0026gt; \u0026lt;!-- å†™æœåŠ¡å™¨ï¼Œå¦‚æœè¦é…ç½®è¯»å†™ï¼Œæ·»åŠ readHostæ ‡ç­¾å³å¯ --\u0026gt; \u0026lt;!-- host: ç”¨äºæ ‡è¯†ä¸åŒå®ä¾‹ï¼Œä¸€èˆ¬ writeHost æˆ‘ä»¬ä½¿ç”¨M1ï¼ŒreadHost æˆ‘ä»¬ç”¨S1 --\u0026gt; \u0026lt;!-- url: åç«¯å®ä¾‹è¿æ¥åœ°å€ï¼Œå¦‚æœæ˜¯ä½¿ç”¨ native çš„ dbDriverï¼Œåˆ™ä¸€èˆ¬ä¸º address:port è¿™ç§å½¢å¼,ç”¨ JDBC æˆ–å…¶ä»–çš„ dbDriverï¼Œåˆ™éœ€è¦ç‰¹æ®ŠæŒ‡å®šï¼Œä½¿ç”¨ JDBC æ—¶åˆ™å¯ä»¥è¿™ä¹ˆå†™ï¼šjdbc:mysql://localhost:3306/ --\u0026gt; \u0026lt;!-- user: åç«¯å­˜å‚¨å®ä¾‹éœ€è¦çš„ç”¨æˆ·å --\u0026gt; \u0026lt;!-- password: åç«¯å­˜å‚¨å®ä¾‹éœ€è¦çš„å¯†ç  --\u0026gt; \u0026lt;!-- weight: æƒé‡ é…ç½®åœ¨ readhost ä¸­ä½œä¸ºè¯»èŠ‚ç‚¹çš„æƒé‡ --\u0026gt; \u0026lt;!-- usingDecrypt: æ˜¯å¦å¯¹å¯†ç åŠ å¯†é»˜è®¤ 0 å¦ å¦‚éœ€è¦å¼€å¯é…ç½® 1ï¼ŒåŒæ—¶ä½¿ç”¨åŠ å¯†ç¨‹åºå¯¹å¯†ç åŠ å¯† --\u0026gt; \u0026lt;writeHost host=\u0026#34;M3\u0026#34; url=\u0026#34;172.16.0.103:3306\u0026#34; user=\u0026#34;root\u0026#34; password=\u0026#34;123456\u0026#34;\u0026gt; \u0026lt;/writeHost\u0026gt; \u0026lt;/dataHost\u0026gt; \u0026lt;/mycat:schema\u0026gt; server.xml \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;!DOCTYPE mycat:server SYSTEM \u0026#34;server.dtd\u0026#34;\u0026gt; \u0026lt;mycat:server xmlns:mycat=\u0026#34;http://io.mycat/\u0026#34;\u0026gt; \u0026lt;system\u0026gt; \u0026lt;!-- å­—ç¬¦é›†ï¼Œéœ€è¦ä¿è¯MyCatå­—ç¬¦é›†ä¸æ•°æ®åº“å­—ç¬¦é›†ä¸€è‡´ --\u0026gt; \u0026lt;property name=\u0026#34;charset\u0026#34;\u0026gt;utf8mb4\u0026lt;/property\u0026gt; \u0026lt;!-- SQLè§£æå™¨ --\u0026gt; \u0026lt;property name=\u0026#34;defaultSqlParser\u0026#34;\u0026gt;druidparser\u0026lt;/property\u0026gt; \u0026lt;!-- MyCatç³»ç»Ÿå¯ç”¨çš„çº¿ç¨‹æ•°é‡ --\u0026gt; \u0026lt;property name=\u0026#34;processors\u0026#34;\u0026gt;1\u0026lt;/property\u0026gt; \u0026lt;!-- æŒ‡å®šMyCatå…¨å±€åºåˆ—çš„ç±»å‹ï¼Œ0è¡¨ç¤ºæœ¬åœ°æ–‡ä»¶æ–¹å¼ 1è¡¨ç¤ºæ•°æ®åº“æ–¹å¼ 2è¡¨ç¤ºæ—¶é—´æˆ³æ–¹å¼ --\u0026gt; \u0026lt;property name=\u0026#34;sequenceHandlerType\u0026#34;\u0026gt;0\u0026lt;/property\u0026gt; \u0026lt;!-- 1ä¸ºå¼€å¯å®æ—¶ç»Ÿè®¡ã€0ä¸ºå…³é—­ --\u0026gt; \u0026lt;property name=\u0026#34;useSqlStat\u0026#34;\u0026gt;0\u0026lt;/property\u0026gt; \u0026lt;!-- 1ä¸ºå¼€å¯å…¨å±€è¡¨ä¸€è‡´æ€§æ£€æµ‹ã€0ä¸ºå…³é—­ --\u0026gt; \u0026lt;property name=\u0026#34;useGlobleTableCheck\u0026#34;\u0026gt;0\u0026lt;/property\u0026gt; \u0026lt;!-- MyCatçš„ç«¯å£ï¼Œé»˜è®¤ä¸º8066 --\u0026gt; \u0026lt;property name=\u0026#34;serverPort\u0026#34;\u0026gt;8066\u0026lt;/property\u0026gt; \u0026lt;!-- MyCatç®¡ç†ç«¯å£ï¼Œé»˜è®¤ä¸º9066 --\u0026gt; \u0026lt;property name=\u0026#34;managerPort\u0026#34;\u0026gt;9066\u0026lt;/property\u0026gt; \u0026lt;!-- æœåŠ¡ç›‘å¬çš„IPåœ°å€ï¼Œé»˜è®¤ä¸º0.0.0.0 --\u0026gt; \u0026lt;property name=\u0026#34;bindIp\u0026#34;\u0026gt;0.0.0.0\u0026lt;/property\u0026gt; \u0026lt;!-- æŒ‡å®šè¿æ¥çš„ç©ºé—²æ—¶é—´çš„è¶…æ—¶é•¿åº¦ï¼Œå¦‚æœæŸä¸ªè¿æ¥çš„ç©ºé—²æ—¶é—´è¶…æ—¶é•¿åº¦å¤§äºidleTimeoutï¼Œåˆ™è¯¥è¿æ¥ä¼šè¢«å›æ”¶ï¼Œé»˜è®¤30åˆ†é’Ÿ --\u0026gt; \u0026lt;property name=\u0026#34;idleTimeout\u0026#34;\u0026gt;300000\u0026lt;/property\u0026gt; \u0026lt;!--åˆ†å¸ƒå¼äº‹åŠ¡å¼€å…³ï¼Œ0ä¸ºä¸è¿‡æ»¤åˆ†å¸ƒå¼äº‹åŠ¡ï¼Œ1ä¸ºè¿‡æ»¤åˆ†å¸ƒå¼äº‹åŠ¡ï¼ˆå¦‚æœåˆ†å¸ƒå¼äº‹åŠ¡å†…åªæ¶‰åŠå…¨å±€è¡¨ï¼Œåˆ™ä¸è¿‡æ»¤ï¼‰ï¼Œ2ä¸ºä¸è¿‡æ»¤åˆ†å¸ƒå¼äº‹åŠ¡,ä½†æ˜¯è®°å½•åˆ†å¸ƒå¼äº‹åŠ¡æ—¥å¿—--\u0026gt; \u0026lt;property name=\u0026#34;handleDistributedTransactions\u0026#34;\u0026gt;0\u0026lt;/property\u0026gt; \u0026lt;!-- é…ç½®æ˜¯å¦å¯ç”¨éå †å†…å­˜å¤„ç†è·¨åˆ†ç‰‡ç»“æœé›†ã€‚ 1å¼€å¯ 0å…³é—­ --\u0026gt; \u0026lt;property name=\u0026#34;useOffHeapForMerge\u0026#34;\u0026gt;1\u0026lt;/property\u0026gt; \u0026lt;!--æ˜¯å¦é‡‡ç”¨zookeeperåè°ƒåˆ‡æ¢ --\u0026gt; \u0026lt;property name=\u0026#34;useZKSwitch\u0026#34;\u0026gt;true\u0026lt;/property\u0026gt; \u0026lt;/system\u0026gt; \u0026lt;user name=\u0026#34;root\u0026#34; defaultAccount=\u0026#34;true\u0026#34;\u0026gt; \u0026lt;!-- ç”¨æˆ·å¯†ç  --\u0026gt; \u0026lt;property name=\u0026#34;password\u0026#34;\u0026gt;123456\u0026lt;/property\u0026gt; \u0026lt;!-- ç”¨æˆ·å¯è®¿é—®çš„é€»è¾‘æ•°æ®åº“æœ‰ï¼Œå¤šä¸ªé€»è¾‘åº“ä½¿ç”¨è‹±æ–‡é€—å·åˆ†éš”å¼€ --\u0026gt; \u0026lt;property name=\u0026#34;schemas\u0026#34;\u0026gt;shopping,logs\u0026lt;/property\u0026gt; \u0026lt;!-- è¡¨çº§ DML æƒé™è®¾ç½® --\u0026gt; \u0026lt;privileges check=\u0026#34;false\u0026#34;\u0026gt; \u0026lt;schema name=\u0026#34;shopping\u0026#34; dml=\u0026#34;0110\u0026#34; \u0026gt; \u0026lt;table name=\u0026#34;tb_goods_base\u0026#34; dml=\u0026#34;1111\u0026#34;\u0026gt;\u0026lt;/table\u0026gt; \u0026lt;/schema\u0026gt; \u0026lt;/privileges\u0026gt; \u0026lt;/user\u0026gt; \u0026lt;user name=\u0026#34;user\u0026#34;\u0026gt; \u0026lt;!-- ç”¨æˆ·å¯†ç  --\u0026gt; \u0026lt;property name=\u0026#34;password\u0026#34;\u0026gt;123456\u0026lt;/property\u0026gt; \u0026lt;!-- ç”¨æˆ·å¯è®¿é—®çš„é€»è¾‘æ•°æ®åº“æœ‰ï¼Œå¤šä¸ªé€»è¾‘åº“ä½¿ç”¨è‹±æ–‡é€—å·åˆ†éš”å¼€ --\u0026gt; \u0026lt;property name=\u0026#34;schemas\u0026#34;\u0026gt;shopping,logs\u0026lt;/property\u0026gt; \u0026lt;!-- ç”¨æˆ·çš„è¯»å†™æƒé™ --\u0026gt; \u0026lt;property name=\u0026#34;readOnly\u0026#34;\u0026gt;true\u0026lt;/property\u0026gt; \u0026lt;/user\u0026gt; \u0026lt;/mycat:server\u0026gt; rule.xml \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;!DOCTYPE mycat:rule SYSTEM \u0026#34;rule.dtd\u0026#34;\u0026gt; \u0026lt;mycat:rule xmlns:mycat=\u0026#34;http://io.mycat/\u0026#34;\u0026gt; \u0026lt;!-- name: è§„åˆ™åç§° --\u0026gt; \u0026lt;tableRule name=\u0026#34;mod-long\u0026#34;\u0026gt; \u0026lt;rule\u0026gt; \u0026lt;!-- columns: æ ‡è¯†å°†è¦åˆ†ç‰‡çš„è¡¨å­—æ®µ --\u0026gt; \u0026lt;columns\u0026gt;id\u0026lt;/columns\u0026gt; \u0026lt;!-- algorithm: æŒ‡å®šåˆ†ç‰‡å‡½æ•°ä¸functionçš„å¯¹åº”å…³ç³» --\u0026gt; \u0026lt;algorithm\u0026gt;mod-long\u0026lt;/algorithm\u0026gt; \u0026lt;/rule\u0026gt; \u0026lt;/tableRule\u0026gt; \u0026lt;!-- åˆ†ç‰‡å¯¹åº”å‡½æ•° --\u0026gt; \u0026lt;!-- name: å¯¹åº”tableRuleçš„algorithmæ ‡ç­¾ --\u0026gt; \u0026lt;!-- class: æŒ‡å®šè¯¥åˆ†ç‰‡ç®—æ³•å¯¹åº”çš„ç±» --\u0026gt; \u0026lt;function name=\u0026#34;mod-long\u0026#34; class=\u0026#34;io.mycat.route.function.PartitionByMod\u0026#34;\u0026gt; \u0026lt;!-- count: æ•°æ®èŠ‚ç‚¹çš„æ•°é‡ --\u0026gt; \u0026lt;property name=\u0026#34;count\u0026#34;\u0026gt;3\u0026lt;/property\u0026gt; \u0026lt;/function\u0026gt; \u0026lt;/mycat:rule\u0026gt; github å®Œæ•´ä»£ç å‚çœ‹githubã€‚https://github.com/helium-chain/mycat-vertical-horizontal åˆ†ç‰‡è§„åˆ™ èŒƒå›´åˆ†ç‰‡ æ ¹æ®æŒ‡å®šçš„å­—æ®µåŠå…¶é…ç½®çš„èŒƒå›´ä¸æ•°æ®èŠ‚ç‚¹çš„å¯¹åº”æƒ…å†µï¼Œæ¥å†³å®šè¯¥æ•°æ®å±äºå“ªä¸€ä¸ªåˆ†ç‰‡ã€‚ schema.xmlé€»è¾‘è¡¨é…ç½®ï¼š \u0026lt;table name=\u0026#34;TB_ORDER\u0026#34; dataNode=\u0026#34;dn1,dn2,dn3\u0026#34; rule=\u0026#34;auto-sharding-long\u0026#34; /\u0026gt; rule.xmlåˆ†ç‰‡è§„åˆ™é…ç½®ï¼š \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;!DOCTYPE mycat:rule SYSTEM \u0026#34;rule.dtd\u0026#34;\u0026gt; \u0026lt;mycat:rule xmlns:mycat=\u0026#34;http://io.mycat/\u0026#34;\u0026gt; \u0026lt;!-- name: è§„åˆ™åç§° --\u0026gt; \u0026lt;tableRule name=\u0026#34;auto-sharding-long\u0026#34;\u0026gt; \u0026lt;rule\u0026gt; \u0026lt;!-- columns: æ ‡è¯†å°†è¦åˆ†ç‰‡çš„è¡¨å­—æ®µ --\u0026gt; \u0026lt;columns\u0026gt;id\u0026lt;/columns\u0026gt; \u0026lt;!-- æŒ‡å®šåˆ†ç‰‡å‡½æ•°ä¸functionçš„å¯¹åº”å…³ç³» --\u0026gt; \u0026lt;algorithm\u0026gt;rang-long\u0026lt;/algorithm\u0026gt; \u0026lt;/rule\u0026gt; \u0026lt;/tableRule\u0026gt; \u0026lt;!-- åˆ†ç‰‡å¯¹åº”å‡½æ•° --\u0026gt; \u0026lt;!-- name: å¯¹åº”tableRuleçš„algorithmæ ‡ç­¾ --\u0026gt; \u0026lt;!-- class: æŒ‡å®šè¯¥åˆ†ç‰‡ç®—æ³•å¯¹åº”çš„ç±» --\u0026gt; \u0026lt;function name=\u0026#34;rang-long\u0026#34; class=\u0026#34;io.mycat.route.function.AutoPartitionByLong\u0026#34;\u0026gt; \u0026lt;!-- mapFile: å¯¹åº”çš„å¤–éƒ¨é…ç½®æ–‡ä»¶ --\u0026gt; \u0026lt;property name=\u0026#34;mapFile\u0026#34;\u0026gt;autopartition-long.txt\u0026lt;/property\u0026gt; \u0026lt;!-- type: é»˜è®¤å€¼ä¸º0 ; 0 è¡¨ç¤ºInteger , 1 è¡¨ç¤ºString --\u0026gt; \u0026lt;property name=\u0026#34;type\u0026#34;\u0026gt;0\u0026lt;/property\u0026gt; \u0026lt;!-- defaultNode: é»˜è®¤èŠ‚ç‚¹ é»˜è®¤èŠ‚ç‚¹çš„æ‰€ç”¨:æšä¸¾åˆ†ç‰‡æ—¶,å¦‚æœç¢°åˆ°ä¸è¯†åˆ«çš„æšä¸¾å€¼, å°±è®©å®ƒè·¯ç”±åˆ°é»˜è®¤èŠ‚ç‚¹, å¦‚æœæ²¡æœ‰é»˜è®¤å€¼,ç¢°åˆ°ä¸è¯†åˆ«çš„åˆ™æŠ¥é”™ --\u0026gt; \u0026lt;property name=\u0026#34;defaultNode\u0026#34;\u0026gt;0\u0026lt;/property\u0026gt; \u0026lt;/function\u0026gt; \u0026lt;/mycat:rule\u0026gt; åœ¨rule.xmlä¸­é…ç½®åˆ†ç‰‡è§„åˆ™æ—¶ï¼Œå…³è”äº†ä¸€ä¸ªæ˜ å°„é…ç½®æ–‡ä»¶ autopartition-long.txtï¼Œè¯¥é…ç½®æ–‡ä»¶çš„é…ç½®å¦‚ä¸‹ï¼š # range start-end ,data node index # K=1000,M=10000. # 0-500ä¸‡ä¹‹é—´çš„å€¼ï¼Œå­˜å‚¨åœ¨0å·æ•°æ®èŠ‚ç‚¹ 0-500M=0 # 500ä¸‡-1000ä¸‡ä¹‹é—´çš„æ•°æ®å­˜å‚¨åœ¨1å·æ•°æ®èŠ‚ç‚¹ 500M-1000M=1 # 1000ä¸‡-1500ä¸‡çš„æ•°æ®èŠ‚ç‚¹å­˜å‚¨åœ¨2å·èŠ‚ç‚¹ 1000M-1500M=2 è¯¥åˆ†ç‰‡è§„åˆ™ï¼Œä¸»è¦æ˜¯é’ˆå¯¹äºæ•°å­—ç±»å‹çš„å­—æ®µé€‚ç”¨ã€‚ å–æ¨¡åˆ†ç‰‡ æ ¹æ®æŒ‡å®šçš„å­—æ®µå€¼ä¸èŠ‚ç‚¹æ•°é‡è¿›è¡Œæ±‚æ¨¡è¿ç®—ï¼Œæ ¹æ®è¿ç®—ç»“æœï¼Œ æ¥å†³å®šè¯¥æ•°æ®å±äºå“ªä¸€ä¸ªåˆ†ç‰‡ã€‚ schema.xmlé€»è¾‘è¡¨é…ç½®ï¼š \u0026lt;table name=\u0026#34;tb_log\u0026#34; dataNode=\u0026#34;dn4,dn5,dn6\u0026#34; primaryKey=\u0026#34;id\u0026#34; rule=\u0026#34;mod-long\u0026#34; /\u0026gt; rule.xmlåˆ†ç‰‡è§„åˆ™é…ç½®ï¼š \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;!DOCTYPE mycat:rule SYSTEM \u0026#34;rule.dtd\u0026#34;\u0026gt; \u0026lt;mycat:rule xmlns:mycat=\u0026#34;http://io.mycat/\u0026#34;\u0026gt; \u0026lt;!-- name: è§„åˆ™åç§° --\u0026gt; \u0026lt;tableRule name=\u0026#34;mod-long\u0026#34;\u0026gt; \u0026lt;rule\u0026gt; \u0026lt;!-- columns: æ ‡è¯†å°†è¦åˆ†ç‰‡çš„è¡¨å­—æ®µ --\u0026gt; \u0026lt;columns\u0026gt;id\u0026lt;/columns\u0026gt; \u0026lt;!-- algorithm: æŒ‡å®šåˆ†ç‰‡å‡½æ•°ä¸functionçš„å¯¹åº”å…³ç³» --\u0026gt; \u0026lt;algorithm\u0026gt;mod-long\u0026lt;/algorithm\u0026gt; \u0026lt;/rule\u0026gt; \u0026lt;/tableRule\u0026gt; \u0026lt;!-- åˆ†ç‰‡å¯¹åº”å‡½æ•° --\u0026gt; \u0026lt;!-- name: å¯¹åº”tableRuleçš„algorithmæ ‡ç­¾ --\u0026gt; \u0026lt;!-- class: æŒ‡å®šè¯¥åˆ†ç‰‡ç®—æ³•å¯¹åº”çš„ç±» --\u0026gt; \u0026lt;function name=\u0026#34;mod-long\u0026#34; class=\u0026#34;io.mycat.route.function.PartitionByMod\u0026#34;\u0026gt; \u0026lt;!-- count: æ•°æ®èŠ‚ç‚¹çš„æ•°é‡ --\u0026gt; \u0026lt;property name=\u0026#34;count\u0026#34;\u0026gt;3\u0026lt;/property\u0026gt; \u0026lt;/function\u0026gt; \u0026lt;/mycat:rule\u0026gt; è¯¥åˆ†ç‰‡è§„åˆ™ï¼Œä¸»è¦æ˜¯é’ˆå¯¹äºæ•°å­—ç±»å‹çš„å­—æ®µé€‚ç”¨ã€‚ ä¸€è‡´æ€§hashåˆ†ç‰‡ æ‰€è°“ä¸€è‡´æ€§å“ˆå¸Œï¼Œç›¸åŒçš„å“ˆå¸Œå› å­è®¡ç®—å€¼æ€»æ˜¯è¢«åˆ’åˆ†åˆ°ç›¸åŒçš„åˆ†åŒºè¡¨ä¸­ï¼Œä¸ä¼šå› ä¸ºåˆ†åŒºèŠ‚ç‚¹çš„å¢åŠ è€Œæ”¹å˜åŸæ¥æ•°æ®çš„åˆ†åŒºä½ç½®ï¼Œæœ‰æ•ˆçš„è§£å†³äº†åˆ†å¸ƒå¼æ•°æ®çš„æ‹“å®¹é—®é¢˜ã€‚ schema.xmlä¸­é€»è¾‘è¡¨é…ç½®ï¼š \u0026lt;table name=\u0026#34;tb_order\u0026#34; dataNode=\u0026#34;dn4,dn5,dn6\u0026#34; rule=\u0026#34;sharding-by-murmur\u0026#34; /\u0026gt; rule.xmlä¸­åˆ†ç‰‡è§„åˆ™é…ç½®ï¼š \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;!DOCTYPE mycat:rule SYSTEM \u0026#34;rule.dtd\u0026#34;\u0026gt; \u0026lt;mycat:rule xmlns:mycat=\u0026#34;http://io.mycat/\u0026#34;\u0026gt; \u0026lt;!-- name: è§„åˆ™åç§° --\u0026gt; \u0026lt;tableRule name=\u0026#34;sharding-by-murmur\u0026#34;\u0026gt; \u0026lt;rule\u0026gt; \u0026lt;!-- columns: æ ‡è¯†å°†è¦åˆ†ç‰‡çš„è¡¨å­—æ®µ --\u0026gt; \u0026lt;columns\u0026gt;id\u0026lt;/columns\u0026gt; \u0026lt;!-- algorithm: æŒ‡å®šåˆ†ç‰‡å‡½æ•°ä¸functionçš„å¯¹åº”å…³ç³» --\u0026gt; \u0026lt;algorithm\u0026gt;murmur\u0026lt;/algorithm\u0026gt; \u0026lt;/rule\u0026gt; \u0026lt;/tableRule\u0026gt; \u0026lt;!-- åˆ†ç‰‡å¯¹åº”å‡½æ•° --\u0026gt; \u0026lt;!-- name: å¯¹åº”tableRuleçš„algorithmæ ‡ç­¾ --\u0026gt; \u0026lt;!-- class: æŒ‡å®šè¯¥åˆ†ç‰‡ç®—æ³•å¯¹åº”çš„ç±» --\u0026gt; \u0026lt;function name=\u0026#34;murmur\u0026#34; class=\u0026#34;io.mycat.route.function.PartitionByMurmurHash\u0026#34;\u0026gt; \u0026lt;!-- seed: åˆ›å»ºmurmur_hashå¯¹è±¡çš„ç§å­ï¼Œé»˜è®¤0 --\u0026gt; \u0026lt;property name=\u0026#34;seed\u0026#34;\u0026gt;0\u0026lt;/property\u0026gt;\u0026lt;!-- é»˜è®¤æ˜¯0 --\u0026gt; \u0026lt;!-- count: è¦åˆ†ç‰‡çš„æ•°æ®åº“èŠ‚ç‚¹æ•°é‡ï¼Œå¿…é¡»æŒ‡å®šï¼Œå¦åˆ™æ²¡æ³•åˆ†ç‰‡ --\u0026gt; \u0026lt;property name=\u0026#34;count\u0026#34;\u0026gt;3\u0026lt;/property\u0026gt; \u0026lt;!-- virtualBucketTimes: ä¸€ä¸ªå®é™…çš„æ•°æ®åº“èŠ‚ç‚¹è¢«æ˜ å°„ä¸ºè¿™ä¹ˆå¤šè™šæ‹ŸèŠ‚ç‚¹ï¼Œé»˜è®¤æ˜¯160å€ï¼Œä¹Ÿå°±æ˜¯è™šæ‹ŸèŠ‚ç‚¹æ•°æ˜¯ç‰©ç†èŠ‚ç‚¹æ•°çš„160 å€;virtualBucketTimes*countå°±æ˜¯è™šæ‹Ÿç»“ç‚¹æ•°é‡ ; --\u0026gt; \u0026lt;property name=\u0026#34;virtualBucketTimes\u0026#34;\u0026gt;160\u0026lt;/property\u0026gt; \u0026lt;!-- weightMapFile: èŠ‚ç‚¹çš„æƒé‡ï¼Œæ²¡æœ‰æŒ‡å®šæƒé‡çš„èŠ‚ç‚¹é»˜è®¤æ˜¯1ã€‚ä»¥propertiesæ–‡ä»¶çš„ æ ¼å¼å¡«å†™ï¼Œä»¥ä»0å¼€å§‹åˆ°count-1çš„æ•´æ•°å€¼ä¹Ÿå°±æ˜¯èŠ‚ç‚¹ç´¢å¼•ä¸ºkeyï¼Œ ä»¥èŠ‚ç‚¹æƒé‡å€¼ä¸ºå€¼ã€‚æ‰€æœ‰æƒé‡å€¼å¿…é¡»æ˜¯æ­£æ•´æ•°ï¼Œå¦åˆ™ä»¥1ä»£æ›¿ --\u0026gt; \u0026lt;!-- bucketMapPath: ç”¨äºæµ‹è¯•æ—¶è§‚å¯Ÿå„ç‰©ç†èŠ‚ç‚¹ä¸è™šæ‹ŸèŠ‚ç‚¹çš„åˆ†å¸ƒæƒ…å†µï¼Œå¦‚æœæŒ‡å®šäº†è¿™ä¸ª å±æ€§ï¼Œä¼šæŠŠè™šæ‹ŸèŠ‚ç‚¹çš„murmur hashå€¼ä¸ç‰©ç†èŠ‚ç‚¹çš„æ˜ å°„æŒ‰è¡Œè¾“å‡º åˆ°è¿™ä¸ªæ–‡ä»¶ï¼Œæ²¡æœ‰é»˜è®¤å€¼ï¼Œå¦‚æœä¸æŒ‡å®šï¼Œå°±ä¸ä¼šè¾“å‡ºä»»ä½•ä¸œè¥¿ --\u0026gt; \u0026lt;/function\u0026gt; \u0026lt;/mycat:rule\u0026gt; æšä¸¾åˆ†ç±» é€šè¿‡åœ¨é…ç½®æ–‡ä»¶ä¸­é…ç½®å¯èƒ½çš„æšä¸¾å€¼, æŒ‡å®šæ•°æ®åˆ†å¸ƒåˆ°ä¸åŒæ•°æ®èŠ‚ç‚¹ä¸Š, æœ¬è§„åˆ™é€‚ç”¨äºæŒ‰ç…§çœä»½ã€æ€§åˆ«ã€çŠ¶æ€æ‹†åˆ†æ•°æ®ç­‰ä¸šåŠ¡ã€‚ schema.xmlä¸­é€»è¾‘è¡¨é…ç½®ï¼š \u0026lt;table name=\u0026#34;tb_user\u0026#34; dataNode=\u0026#34;dn4,dn5,dn6\u0026#34; rule=\u0026#34;sharding-by-intfile-enumstatus\u0026#34;/\u0026gt; rule.xmlä¸­åˆ†ç‰‡è§„åˆ™é…ç½®ï¼š \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;!DOCTYPE mycat:rule SYSTEM \u0026#34;rule.dtd\u0026#34;\u0026gt; \u0026lt;mycat:rule xmlns:mycat=\u0026#34;http://io.mycat/\u0026#34;\u0026gt; \u0026lt;!-- name: è§„åˆ™åç§° --\u0026gt; \u0026lt;tableRule name=\u0026#34;sharding-by-intfile\u0026#34;\u0026gt; \u0026lt;rule\u0026gt; \u0026lt;!-- columns: æ ‡è¯†å°†è¦åˆ†ç‰‡çš„è¡¨å­—æ®µ --\u0026gt; \u0026lt;columns\u0026gt;sharding_id\u0026lt;/columns\u0026gt; \u0026lt;!-- algorithm: æŒ‡å®šåˆ†ç‰‡å‡½æ•°ä¸functionçš„å¯¹åº”å…³ç³» --\u0026gt; \u0026lt;algorithm\u0026gt;hash-int\u0026lt;/algorithm\u0026gt; \u0026lt;/rule\u0026gt; \u0026lt;/tableRule\u0026gt; \u0026lt;!-- è‡ªå·±å¢åŠ  tableRule --\u0026gt; \u0026lt;tableRule name=\u0026#34;sharding-by-intfile-enumstatus\u0026#34;\u0026gt; \u0026lt;rule\u0026gt; \u0026lt;columns\u0026gt;status\u0026lt;/columns\u0026gt; \u0026lt;algorithm\u0026gt;hash-int\u0026lt;/algorithm\u0026gt; \u0026lt;/rule\u0026gt; \u0026lt;/tableRule\u0026gt; \u0026lt;!-- åˆ†ç‰‡å¯¹åº”å‡½æ•° --\u0026gt; \u0026lt;!-- name: å¯¹åº”tableRuleçš„algorithmæ ‡ç­¾ --\u0026gt; \u0026lt;!-- class: æŒ‡å®šè¯¥åˆ†ç‰‡ç®—æ³•å¯¹åº”çš„ç±» --\u0026gt; \u0026lt;function name=\u0026#34;mod-long\u0026#34; class=\u0026#34;io.mycat.route.function.PartitionByFileMap\u0026#34;\u0026gt; \u0026lt;!-- defaultNodeï¼š é»˜è®¤èŠ‚ç‚¹; å°äº0 æ ‡è¯†ä¸è®¾ç½®é»˜è®¤èŠ‚ç‚¹, å¤§äºç­‰äº0ä»£è¡¨è®¾ç½®é»˜è®¤èŠ‚ç‚¹; é»˜è®¤èŠ‚ç‚¹çš„æ‰€ç”¨:æšä¸¾åˆ†ç‰‡æ—¶,å¦‚æœç¢°åˆ°ä¸è¯†åˆ«çš„æšä¸¾å€¼, å°±è®©å®ƒè·¯ç”±åˆ°é»˜è®¤èŠ‚ç‚¹; å¦‚æœæ²¡æœ‰é»˜è®¤å€¼,ç¢°åˆ°ä¸è¯†åˆ«çš„åˆ™æŠ¥é”™ --\u0026gt; \u0026lt;property name=\u0026#34;defaultNode\u0026#34;\u0026gt;2\u0026lt;/property\u0026gt; \u0026lt;!-- mapFile: å¯¹åº”çš„å¤–éƒ¨æ–‡ä»¶ --\u0026gt; \u0026lt;property name=\u0026#34;mapFile\u0026#34;\u0026gt;partition-hash-int.txt\u0026lt;/property\u0026gt; \u0026lt;!-- type: é»˜è®¤å€¼ä¸º0 ; 0 è¡¨ç¤ºInteger , 1 è¡¨ç¤ºString --\u0026gt; \u0026lt;/function\u0026gt; \u0026lt;/mycat:rule\u0026gt; partition-hash-int.txtï¼Œå†…å®¹å¦‚ä¸‹ï¼š 1=0 2=1 3=2 åº”ç”¨æŒ‡å®šç®—æ³• è¿è¡Œé˜¶æ®µç”±åº”ç”¨è‡ªä¸»å†³å®šè·¯ç”±åˆ°é‚£ä¸ªåˆ†ç‰‡ , ç›´æ¥æ ¹æ®å­—ç¬¦å­ä¸²ï¼ˆå¿…é¡»æ˜¯æ•°å­—ï¼‰è®¡ç®—åˆ†ç‰‡å·ã€‚ schema.xmlä¸­é€»è¾‘è¡¨é…ç½®ï¼š \u0026lt;table name=\u0026#34;tb_app\u0026#34; dataNode=\u0026#34;dn4,dn5,dn6\u0026#34; rule=\u0026#34;sharding-by-substring\u0026#34; /\u0026gt; rule.xmlä¸­åˆ†ç‰‡è§„åˆ™é…ç½®ï¼š \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;!DOCTYPE mycat:rule SYSTEM \u0026#34;rule.dtd\u0026#34;\u0026gt; \u0026lt;mycat:rule xmlns:mycat=\u0026#34;http://io.mycat/\u0026#34;\u0026gt; \u0026lt;!-- name: è§„åˆ™åç§° --\u0026gt; \u0026lt;tableRule name=\u0026#34;sharding-by-substrin\u0026#34;\u0026gt; \u0026lt;rule\u0026gt; \u0026lt;!-- columns: æ ‡è¯†å°†è¦åˆ†ç‰‡çš„è¡¨å­—æ®µ --\u0026gt; \u0026lt;columns\u0026gt;id\u0026lt;/columns\u0026gt; \u0026lt;!-- algorithm: æŒ‡å®šåˆ†ç‰‡å‡½æ•°ä¸functionçš„å¯¹åº”å…³ç³» --\u0026gt; \u0026lt;algorithm\u0026gt;sharding-by-substring\u0026lt;/algorithm\u0026gt; \u0026lt;/rule\u0026gt; \u0026lt;/tableRule\u0026gt; \u0026lt;!-- åˆ†ç‰‡å¯¹åº”å‡½æ•° --\u0026gt; \u0026lt;!-- name: å¯¹åº”tableRuleçš„algorithmæ ‡ç­¾ --\u0026gt; \u0026lt;!-- class: æŒ‡å®šè¯¥åˆ†ç‰‡ç®—æ³•å¯¹åº”çš„ç±» --\u0026gt; \u0026lt;function name=\u0026#34;sharding-by-substring\u0026#34; class=\u0026#34;io.mycat.route.function.PartitionDirectBySubString\u0026#34;\u0026gt; \u0026lt;!-- startIndex: å­—ç¬¦å­ä¸²èµ·å§‹ç´¢å¼• --\u0026gt; \u0026lt;property name=\u0026#34;startIndex\u0026#34;\u0026gt;0\u0026lt;/property\u0026gt; \u0026lt;!-- zero-based --\u0026gt; \u0026lt;!-- size: å­—ç¬¦é•¿åº¦ --\u0026gt; \u0026lt;property name=\u0026#34;size\u0026#34;\u0026gt;2\u0026lt;/property\u0026gt; \u0026lt;!-- partitionCount: åˆ†åŒº(åˆ†ç‰‡)æ•°é‡ --\u0026gt; \u0026lt;property name=\u0026#34;partitionCount\u0026#34;\u0026gt;3\u0026lt;/property\u0026gt; \u0026lt;!-- defaultPartition: é»˜è®¤åˆ†ç‰‡(åœ¨åˆ†ç‰‡æ•°é‡å®šä¹‰æ—¶, å­—ç¬¦æ ‡ç¤ºçš„åˆ†ç‰‡ç¼–å·ä¸åœ¨åˆ†ç‰‡æ•°é‡å†…æ—¶,ä½¿ç”¨é»˜è®¤åˆ†ç‰‡) --\u0026gt; \u0026lt;property name=\u0026#34;defaultPartition\u0026#34;\u0026gt;0\u0026lt;/property\u0026gt; \u0026lt;/function\u0026gt; \u0026lt;/mycat:rule\u0026gt; ç¤ºä¾‹è¯´æ˜ï¼š id=05-100000002 , åœ¨æ­¤é…ç½®ä¸­ä»£è¡¨æ ¹æ®idä¸­ä» startIndex=0ï¼Œå¼€å§‹ï¼Œæˆªå–siz=2ä½æ•°å­—å³ 05ï¼Œ05å°±æ˜¯è·å–çš„åˆ†åŒºã€‚ å¦‚æœæ²¡æ‰¾åˆ°å¯¹åº”çš„åˆ†ç‰‡åˆ™é»˜è®¤åˆ†é…åˆ°defaultPartitionã€‚ å›ºå®šåˆ†ç‰‡hashç®—æ³• è¯¥ç®—æ³•ç±»ä¼¼äºåè¿›åˆ¶çš„æ±‚æ¨¡è¿ç®—ï¼Œä½†æ˜¯ä¸ºäºŒè¿›åˆ¶çš„æ“ä½œï¼Œä¾‹å¦‚å– id çš„äºŒè¿›åˆ¶ä½ 10 ä½ ä¸ 1111111111 è¿›è¡Œä½ \u0026amp; è¿ç®—ï¼Œä½ä¸è¿ç®—æœ€å°å€¼ä¸º 0000000000ï¼Œæœ€å¤§å€¼ä¸º1111111111ï¼Œè½¬æ¢ä¸ºåè¿›åˆ¶ï¼Œä¹Ÿå°±æ˜¯ä½äº0-1023ä¹‹é—´ã€‚ ç‰¹ç‚¹ï¼š å¦‚æœæ˜¯æ±‚æ¨¡ï¼Œè¿ç»­çš„å€¼ï¼Œåˆ†åˆ«åˆ†é…åˆ°å„ä¸ªä¸åŒçš„åˆ†ç‰‡ï¼›ä½†æ˜¯æ­¤ç®—æ³•ä¼šå°†è¿ç»­çš„å€¼å¯èƒ½åˆ†é…åˆ°ç›¸åŒçš„åˆ†ç‰‡ï¼Œé™ä½äº‹åŠ¡å¤„ç†çš„éš¾åº¦ã€‚ å¯ä»¥å‡åŒ€åˆ†é…ï¼Œä¹Ÿå¯ä»¥éå‡åŒ€åˆ†é…ã€‚ åˆ†ç‰‡å­—æ®µå¿…é¡»ä¸ºæ•°å­—ç±»å‹ã€‚ schema.xmlä¸­é€»è¾‘è¡¨é…ç½®ï¼š \u0026lt;table name=\u0026#34;tb_longhash\u0026#34; dataNode=\u0026#34;dn4,dn5,dn6\u0026#34; rule=\u0026#34;sharding-by-long-hash\u0026#34; /\u0026gt; rule.xmlä¸­åˆ†ç‰‡è§„åˆ™é…ç½®ï¼š \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;!DOCTYPE mycat:rule SYSTEM \u0026#34;rule.dtd\u0026#34;\u0026gt; \u0026lt;mycat:rule xmlns:mycat=\u0026#34;http://io.mycat/\u0026#34;\u0026gt; \u0026lt;!-- name: è§„åˆ™åç§° --\u0026gt; \u0026lt;tableRule name=\u0026#34;sharding-by-long-hash\u0026#34;\u0026gt; \u0026lt;rule\u0026gt; \u0026lt;!-- columns: æ ‡è¯†å°†è¦åˆ†ç‰‡çš„è¡¨å­—æ®µ --\u0026gt; \u0026lt;columns\u0026gt;id\u0026lt;/columns\u0026gt; \u0026lt;!-- algorithm: æŒ‡å®šåˆ†ç‰‡å‡½æ•°ä¸functionçš„å¯¹åº”å…³ç³» --\u0026gt; \u0026lt;algorithm\u0026gt;sharding-by-long-hash\u0026lt;/algorithm\u0026gt; \u0026lt;/rule\u0026gt; \u0026lt;/tableRule\u0026gt; \u0026lt;!-- åˆ†ç‰‡å¯¹åº”å‡½æ•° --\u0026gt; \u0026lt;!-- name: å¯¹åº”tableRuleçš„algorithmæ ‡ç­¾ --\u0026gt; \u0026lt;!-- class: æŒ‡å®šè¯¥åˆ†ç‰‡ç®—æ³•å¯¹åº”çš„ç±» --\u0026gt; \u0026lt;function name=\u0026#34;sharding-by-long-hash\u0026#34; class=\u0026#34;io.mycat.route.function.PartitionByLong\u0026#34;\u0026gt; \u0026lt;!-- partitionCount: åˆ†ç‰‡ä¸ªæ•°åˆ—è¡¨ --\u0026gt; \u0026lt;property name=\u0026#34;partitionCount\u0026#34;\u0026gt;2,1\u0026lt;/property\u0026gt; \u0026lt;!-- partitionLength: åˆ†ç‰‡èŒƒå›´åˆ—è¡¨ --\u0026gt; \u0026lt;property name=\u0026#34;partitionLength\u0026#34;\u0026gt;256,512\u0026lt;/property\u0026gt; \u0026lt;/function\u0026gt; \u0026lt;/mycat:rule\u0026gt; çº¦æŸï¼š åˆ†ç‰‡é•¿åº¦ : é»˜è®¤æœ€å¤§2^10,ä¸º 1024 ; count, lengthçš„æ•°ç»„é•¿åº¦å¿…é¡»æ˜¯ä¸€è‡´çš„; å­—ç¬¦ä¸²hashè§£æç®—æ³• æˆªå–å­—ç¬¦ä¸²ä¸­çš„æŒ‡å®šä½ç½®çš„å­å­—ç¬¦ä¸², è¿›è¡Œhashç®—æ³•ï¼Œç®—å‡ºåˆ†ç‰‡ã€‚ schema.xmlä¸­é€»è¾‘è¡¨é…ç½®ï¼š \u0026lt;table name=\u0026#34;tb_strhash\u0026#34; dataNode=\u0026#34;dn4,dn5\u0026#34; rule=\u0026#34;sharding-by-stringhash\u0026#34; /\u0026gt; rule.xmlä¸­åˆ†ç‰‡è§„åˆ™é…ç½®ï¼š \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;!DOCTYPE mycat:rule SYSTEM \u0026#34;rule.dtd\u0026#34;\u0026gt; \u0026lt;mycat:rule xmlns:mycat=\u0026#34;http://io.mycat/\u0026#34;\u0026gt; \u0026lt;!-- name: è§„åˆ™åç§° --\u0026gt; \u0026lt;tableRule name=\u0026#34;sharding-by-stringhash\u0026#34;\u0026gt; \u0026lt;rule\u0026gt; \u0026lt;!-- columns: æ ‡è¯†å°†è¦åˆ†ç‰‡çš„è¡¨å­—æ®µ --\u0026gt; \u0026lt;columns\u0026gt;name\u0026lt;/columns\u0026gt; \u0026lt;!-- algorithm: æŒ‡å®šåˆ†ç‰‡å‡½æ•°ä¸functionçš„å¯¹åº”å…³ç³» --\u0026gt; \u0026lt;algorithm\u0026gt;sharding-by-stringhash\u0026lt;/algorithm\u0026gt; \u0026lt;/rule\u0026gt; \u0026lt;/tableRule\u0026gt; \u0026lt;!-- åˆ†ç‰‡å¯¹åº”å‡½æ•° --\u0026gt; \u0026lt;!-- name: å¯¹åº”tableRuleçš„algorithmæ ‡ç­¾ --\u0026gt; \u0026lt;!-- class: æŒ‡å®šè¯¥åˆ†ç‰‡ç®—æ³•å¯¹åº”çš„ç±» --\u0026gt; \u0026lt;function name=\u0026#34;sharding-by-stringhash\u0026#34; class=\u0026#34;io.mycat.route.function.PartitionByString\u0026#34;\u0026gt; \u0026lt;!-- partitionLength: hashæ±‚æ¨¡åŸºæ•° ; length*count=1024 (å‡ºäºæ€§èƒ½è€ƒè™‘) --\u0026gt; \u0026lt;property name=\u0026#34;partitionLength\u0026#34;\u0026gt;512\u0026lt;/property\u0026gt; \u0026lt;!-- zero-based --\u0026gt; \u0026lt;!-- partitionCount: åˆ†åŒºæ•° --\u0026gt; \u0026lt;property name=\u0026#34;partitionCount\u0026#34;\u0026gt;2\u0026lt;/property\u0026gt; \u0026lt;!-- hashSlice: hashè¿ç®—ä½ , æ ¹æ®å­å­—ç¬¦ä¸²çš„hashè¿ç®— 0 ä»£è¡¨ str.length() -1 ä»£è¡¨ str.length()-1 å¤§äº0åªä»£è¡¨æ•°å­—è‡ªèº« å¯ä»¥ç†è§£ä¸ºsubstringï¼ˆstartï¼Œendï¼‰ï¼Œstartä¸º0åˆ™åªè¡¨ç¤º0 --\u0026gt; \u0026lt;property name=\u0026#34;hashSlice\u0026#34;\u0026gt;0:2\u0026lt;/property\u0026gt; \u0026lt;/function\u0026gt; \u0026lt;/mycat:rule\u0026gt; æŒ‰å¤©åˆ†ç‰‡ç®—æ³• æŒ‰ç…§æ—¥æœŸåŠå¯¹åº”çš„æ—¶é—´å‘¨æœŸæ¥åˆ†ç‰‡ã€‚ schema.xmlä¸­é€»è¾‘è¡¨é…ç½®ï¼š \u0026lt;table name=\u0026#34;tb_datepart\u0026#34; dataNode=\u0026#34;dn4,dn5,dn6\u0026#34; rule=\u0026#34;sharding-by-date\u0026#34; /\u0026gt; rule.xmlä¸­åˆ†ç‰‡è§„åˆ™é…ç½®ï¼š \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;!DOCTYPE mycat:rule SYSTEM \u0026#34;rule.dtd\u0026#34;\u0026gt; \u0026lt;mycat:rule xmlns:mycat=\u0026#34;http://io.mycat/\u0026#34;\u0026gt; \u0026lt;!-- name: è§„åˆ™åç§° --\u0026gt; \u0026lt;tableRule name=\u0026#34;sharding-by-date\u0026#34;\u0026gt; \u0026lt;rule\u0026gt; \u0026lt;!-- columns: æ ‡è¯†å°†è¦åˆ†ç‰‡çš„è¡¨å­—æ®µ --\u0026gt; \u0026lt;columns\u0026gt;create_time\u0026lt;/columns\u0026gt; \u0026lt;!-- algorithm: æŒ‡å®šåˆ†ç‰‡å‡½æ•°ä¸functionçš„å¯¹åº”å…³ç³» --\u0026gt; \u0026lt;algorithm\u0026gt;sharding-by-dat\u0026lt;/algorithm\u0026gt; \u0026lt;/rule\u0026gt; \u0026lt;/tableRule\u0026gt; \u0026lt;!-- åˆ†ç‰‡å¯¹åº”å‡½æ•° --\u0026gt; \u0026lt;!-- name: å¯¹åº”tableRuleçš„algorithmæ ‡ç­¾ --\u0026gt; \u0026lt;!-- class: æŒ‡å®šè¯¥åˆ†ç‰‡ç®—æ³•å¯¹åº”çš„ç±» --\u0026gt; \u0026lt;function name=\u0026#34;sharding-by-dat\u0026#34; class=\u0026#34;io.mycat.route.function.PartitionByDate\u0026#34;\u0026gt; \u0026lt;!-- dateFormat: æ—¥æœŸæ ¼å¼ --\u0026gt; \u0026lt;property name=\u0026#34;dateFormat\u0026#34;\u0026gt;yyyy-MM-dd\u0026lt;/property\u0026gt; \u0026lt;!-- sBeginDate: å¼€å§‹æ—¥æœŸ --\u0026gt; \u0026lt;property name=\u0026#34;sBeginDate\u0026#34;\u0026gt;2022-01-01\u0026lt;/property\u0026gt; \u0026lt;!-- sEndDate: ç»“æŸæ—¥æœŸï¼Œå¦‚æœé…ç½®äº†ç»“æŸæ—¥æœŸï¼Œåˆ™ä»£ç æ•°æ®åˆ°è¾¾äº†è¿™ä¸ªæ—¥æœŸçš„åˆ†ç‰‡åï¼Œä¼šé‡å¤ä»å¼€å§‹åˆ†ç‰‡æ’å…¥ --\u0026gt; \u0026lt;property name=\u0026#34;sEndDate\u0026#34;\u0026gt;2022-01-30\u0026lt;/property\u0026gt; \u0026lt;!-- sPartionDay: åˆ†åŒºå¤©æ•°ï¼Œé»˜è®¤å€¼ 10 ï¼Œä»å¼€å§‹æ—¥æœŸç®—èµ·ï¼Œæ¯ä¸ª10å¤©ä¸€ä¸ªåˆ†åŒº --\u0026gt; \u0026lt;property name=\u0026#34;sPartionDay\u0026#34;\u0026gt;10\u0026lt;/property\u0026gt; \u0026lt;/function\u0026gt; \u0026lt;/mycat:rule\u0026gt; è‡ªç„¶æœˆåˆ†ç‰‡ ä½¿ç”¨åœºæ™¯ä¸ºæŒ‰ç…§æœˆä»½æ¥åˆ†ç‰‡, æ¯ä¸ªè‡ªç„¶æœˆä¸ºä¸€ä¸ªåˆ†ç‰‡ã€‚ schema.xmlä¸­é€»è¾‘è¡¨é…ç½®ï¼š \u0026lt;table name=\u0026#34;tb_monthpart\u0026#34; dataNode=\u0026#34;dn4,dn5,dn6\u0026#34; rule=\u0026#34;sharding-by-month\u0026#34; /\u0026gt; rule.xmlä¸­åˆ†ç‰‡è§„åˆ™é…ç½®ï¼š \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;!DOCTYPE mycat:rule SYSTEM \u0026#34;rule.dtd\u0026#34;\u0026gt; \u0026lt;mycat:rule xmlns:mycat=\u0026#34;http://io.mycat/\u0026#34;\u0026gt; \u0026lt;!-- name: è§„åˆ™åç§° --\u0026gt; \u0026lt;tableRule name=\u0026#34;sharding-by-month\u0026#34;\u0026gt; \u0026lt;rule\u0026gt; \u0026lt;!-- columns: æ ‡è¯†å°†è¦åˆ†ç‰‡çš„è¡¨å­—æ®µ --\u0026gt; \u0026lt;columns\u0026gt;create_time\u0026lt;/columns\u0026gt; \u0026lt;!-- algorithm: æŒ‡å®šåˆ†ç‰‡å‡½æ•°ä¸functionçš„å¯¹åº”å…³ç³» --\u0026gt; \u0026lt;algorithm\u0026gt;partbymonth\u0026lt;/algorithm\u0026gt; \u0026lt;/rule\u0026gt; \u0026lt;/tableRule\u0026gt; \u0026lt;!-- åˆ†ç‰‡å¯¹åº”å‡½æ•° --\u0026gt; \u0026lt;!-- name: å¯¹åº”tableRuleçš„algorithmæ ‡ç­¾ --\u0026gt; \u0026lt;!-- class: æŒ‡å®šè¯¥åˆ†ç‰‡ç®—æ³•å¯¹åº”çš„ç±» --\u0026gt; \u0026lt;function name=\u0026#34;partbymonth\u0026#34; class=\u0026#34;io.mycat.route.function.PartitionByMonth\u0026#34;\u0026gt; \u0026lt;!-- dateFormat: æ—¥æœŸæ ¼å¼ --\u0026gt; \u0026lt;property name=\u0026#34;dateFormat\u0026#34;\u0026gt;yyyy-MM-dd\u0026lt;/property\u0026gt; \u0026lt;!-- sBeginDate: å¼€å§‹æ—¥æœŸ --\u0026gt; \u0026lt;property name=\u0026#34;sBeginDate\u0026#34;\u0026gt;2022-01-01\u0026lt;/property\u0026gt; \u0026lt;!-- sEndDate: ç»“æŸæ—¥æœŸï¼Œå¦‚æœé…ç½®äº†ç»“æŸæ—¥æœŸï¼Œåˆ™ä»£ç æ•°æ®åˆ°è¾¾äº†è¿™ä¸ªæ—¥æœŸçš„åˆ†ç‰‡åï¼Œä¼šé‡å¤ä»å¼€å§‹åˆ†ç‰‡æ’å…¥ --\u0026gt; \u0026lt;property name=\u0026#34;sEndDate\u0026#34;\u0026gt;2022-03-31\u0026lt;/property\u0026gt; \u0026lt;/function\u0026gt; \u0026lt;!-- ä»å¼€å§‹æ—¶é—´å¼€å§‹ï¼Œä¸€ä¸ªæœˆä¸ºä¸€ä¸ªåˆ†ç‰‡ï¼Œåˆ°è¾¾ç»“æŸæ—¶é—´ä¹‹åï¼Œä¼šé‡å¤å¼€å§‹åˆ†ç‰‡æ’å…¥ é…ç½®è¡¨çš„ dataNode çš„åˆ†ç‰‡ï¼Œå¿…é¡»å’Œåˆ†ç‰‡è§„åˆ™æ•°é‡ä¸€è‡´ï¼Œä¾‹å¦‚ 2022-01-01 åˆ° 2022-12-31 ï¼Œä¸€å…±éœ€è¦12ä¸ªåˆ†ç‰‡ã€‚ --\u0026gt; \u0026lt;/mycat:rule\u0026gt; åŒä¸»åŒä¸›è¯»å†™åˆ†ç¦» ä¸€ä¸ªä¸»æœº Master1 ç”¨äºå¤„ç†æ‰€æœ‰å†™è¯·æ±‚ï¼Œå®ƒçš„ä»æœº Slave1 å’Œå¦ä¸€å°ä¸»æœº Master2 è¿˜æœ‰å®ƒçš„ä»æœº Slave2 è´Ÿè´£æ‰€æœ‰è¯»è¯·æ±‚ã€‚ å½“ Master1 ä¸»æœºå®•æœºåï¼ŒMaster2 ä¸»æœºè´Ÿè´£å†™è¯·æ±‚ï¼ŒMaster1ã€Master2 äº’ä¸ºå¤‡æœºã€‚ åç§° IP ç«¯å£ MyCat 172.16.0.10 8066,9066 M1 172.16.0.101 3306 M2 172.16.0.102 3307 S1 172.16.0.103 3308 S2 172.16.0.104 3309 master01 ä¿®æ”¹é…ç½®æ–‡ä»¶ /etc/my.cnfã€‚ #mysql æœåŠ¡IDï¼Œä¿è¯æ•´ä¸ªé›†ç¾¤ç¯å¢ƒä¸­å”¯ä¸€ï¼Œå–å€¼èŒƒå›´ï¼š1 â€“ 2^32-1ï¼Œé»˜è®¤ä¸º1 server-id=1 #æŒ‡å®šåŒæ­¥çš„æ•°æ®åº“ binlog-do-db=db01 binlog-do-db=db02 binlog-do-db=db03 # åœ¨ä½œä¸ºä»æ•°æ®åº“çš„æ—¶å€™ï¼Œæœ‰å†™å…¥æ“ä½œä¹Ÿè¦æ›´æ–°äºŒè¿›åˆ¶æ—¥å¿—æ–‡ä»¶ log-slave-updates åˆ›å»ºè´¦æˆ·å¹¶æˆæƒã€‚ -- åˆ›å»ºitcastç”¨æˆ·ï¼Œå¹¶è®¾ç½®å¯†ç ï¼Œè¯¥ç”¨æˆ·å¯åœ¨ä»»æ„ä¸»æœºè¿æ¥è¯¥MySQLæœåŠ¡ CREATE USER \u0026#39;masterSlave\u0026#39;@\u0026#39;%\u0026#39; IDENTIFIED WITH mysql_native_password BY \u0026#39;123456\u0026#39;; -- ä¸º \u0026#39;master\u0026#39;@\u0026#39;%\u0026#39; ç”¨æˆ·åˆ†é…ä¸»ä»å¤åˆ¶æƒé™ GRANT REPLICATION SLAVE ON *.* TO \u0026#39;masterSlave\u0026#39;@\u0026#39;%\u0026#39;; æŸ¥çœ‹äºŒè¿›åˆ¶æ—¥å¿—åæ ‡ï¼š show master status; master02 ä¿®æ”¹é…ç½®æ–‡ä»¶ /etc/my.cnfã€‚ #mysql æœåŠ¡IDï¼Œä¿è¯æ•´ä¸ªé›†ç¾¤ç¯å¢ƒä¸­å”¯ä¸€ï¼Œå–å€¼èŒƒå›´ï¼š1 â€“ 2^32-1ï¼Œé»˜è®¤ä¸º1 server-id=2 #æŒ‡å®šåŒæ­¥çš„æ•°æ®åº“ binlog-do-db=db01 binlog-do-db=db02 binlog-do-db=db03 # åœ¨ä½œä¸ºä»æ•°æ®åº“çš„æ—¶å€™ï¼Œæœ‰å†™å…¥æ“ä½œä¹Ÿè¦æ›´æ–°äºŒè¿›åˆ¶æ—¥å¿—æ–‡ä»¶ log-slave-updates åˆ›å»ºè´¦æˆ·å¹¶æˆæƒã€‚ -- åˆ›å»ºitcastç”¨æˆ·ï¼Œå¹¶è®¾ç½®å¯†ç ï¼Œè¯¥ç”¨æˆ·å¯åœ¨ä»»æ„ä¸»æœºè¿æ¥è¯¥MySQLæœåŠ¡ CREATE USER \u0026#39;masterSlave\u0026#39;@\u0026#39;%\u0026#39; IDENTIFIED WITH mysql_native_password BY \u0026#39;123456\u0026#39;; -- ä¸º \u0026#39;master\u0026#39;@\u0026#39;%\u0026#39; ç”¨æˆ·åˆ†é…ä¸»ä»å¤åˆ¶æƒé™ GRANT REPLICATION SLAVE ON *.* TO \u0026#39;masterSlave\u0026#39;@\u0026#39;%\u0026#39;; æŸ¥çœ‹äºŒè¿›åˆ¶æ—¥å¿—åæ ‡ï¼š show master status; salve01 ä¿®æ”¹é…ç½®æ–‡ä»¶ /etc/my.cnfã€‚ #mysql æœåŠ¡IDï¼Œä¿è¯æ•´ä¸ªé›†ç¾¤ç¯å¢ƒä¸­å”¯ä¸€ï¼Œå–å€¼èŒƒå›´ï¼š1 â€“ 2^32-1ï¼Œé»˜è®¤ä¸º1 server-id=3 salve02 ä¿®æ”¹é…ç½®æ–‡ä»¶ /etc/my.cnfã€‚ #mysql æœåŠ¡IDï¼Œä¿è¯æ•´ä¸ªé›†ç¾¤ç¯å¢ƒä¸­å”¯ä¸€ï¼Œå–å€¼èŒƒå›´ï¼š1 â€“ 2^32-1ï¼Œé»˜è®¤ä¸º1 server-id=4 ä»åº“å…³è”ä¸»åº“ åœ¨ slave01/slave02ä¸Šæ‰§è¡Œï¼š CHANGE MASTER TO MASTER_HOST=\u0026#39;mysql-master01\u0026#39;, MASTER_USER=\u0026#39;masterSlave\u0026#39;, MASTER_PASSWORD=\u0026#39;Root@123456\u0026#39;, MASTER_LOG_FILE=\u0026#39;binlog.000002\u0026#39;, MASTER_LOG_POS=663; -- å¼€å¯ä¸»ä»å¤åˆ¶ start slave; -- æŸ¥çœ‹åŒæ­¥çŠ¶æ€ï¼Œä¸»åº“S1/S2ä¸­æŸ¥çœ‹ã€‚ show slave status \\G; -- Slave_IO_Running: Yes -- Slave_SQL_Running: Yes ä¸¤ä¸»åº“ç›¸äº’å¤åˆ¶ M2 å¤åˆ¶ M1ï¼ŒM1 å¤åˆ¶ M2ã€‚ åœ¨M1/M2ä¸Šæ‰§è¡Œï¼š -- M1ä¸Šæ‰§è¡Œ CHANGE MASTER TO MASTER_HOST=\u0026#39;mysql-master02\u0026#39;, MASTER_USER=\u0026#39;masterSlave\u0026#39;, MASTER_PASSWORD=\u0026#39;123456\u0026#39;, MASTER_LOG_FILE=\u0026#39;mysql-bin.000003\u0026#39;, MASTER_LOG_POS=194; start slave; show slave status \\G; -- M2ä¸Šæ‰§è¡Œ CHANGE MASTER TO MASTER_HOST=\u0026#39;mysql-master01\u0026#39;, MASTER_USER=\u0026#39;masterSlave\u0026#39;, MASTER_PASSWORD=\u0026#39;123456\u0026#39;, MASTER_LOG_FILE=\u0026#39;mysql-bin.000003\u0026#39;, MASTER_LOG_POS=194; start slave; show slave status \\G; æµ‹è¯• åˆ†åˆ«åœ¨ä¸¤å°ä¸»åº“M1ã€M2ä¸Šæ‰§è¡ŒDDLã€DMLè¯­å¥ï¼ŒæŸ¥çœ‹æ¶‰åŠåˆ°çš„æ•°æ®åº“æœåŠ¡å™¨çš„æ•°æ®åŒæ­¥æƒ…å†µã€‚ -- M1æ‰§è¡Œ create table tb_user( id int(11) not null primary key , name varchar(50) not null, sex varchar(1) )engine=innodb default charset=utf8mb4; insert into tb_user(id,name,sex) values(1,\u0026#39;Tom\u0026#39;,\u0026#39;1\u0026#39;); insert into tb_user(id,name,sex) values(2,\u0026#39;Trigger\u0026#39;,\u0026#39;0\u0026#39;); insert into tb_user(id,name,sex) values(3,\u0026#39;Dawn\u0026#39;,\u0026#39;1\u0026#39;); insert into tb_user(id,name,sex) values(4,\u0026#39;Jack Ma\u0026#39;,\u0026#39;1\u0026#39;); insert into tb_user(id,name,sex) values(5,\u0026#39;Coco\u0026#39;,\u0026#39;0\u0026#39;); insert into tb_user(id,name,sex) values(6,\u0026#39;Jerry\u0026#39;,\u0026#39;1\u0026#39;); é…ç½®è¯»å†™åˆ†ç¦» \u0026lt;?xml version=\u0026#34;1.0\u0026#34;?\u0026gt; \u0026lt;!DOCTYPE mycat:schema SYSTEM \u0026#34;schema.dtd\u0026#34;\u0026gt; \u0026lt;mycat:schema xmlns:mycat=\u0026#34;http://io.mycat/\u0026#34;\u0026gt; \u0026lt;!-- é€»è¾‘åº“ --\u0026gt; \u0026lt;!-- name: é€»è¾‘åº“åå­— --\u0026gt; \u0026lt;!-- checkSQLschema: å½“è®¾ç½®ä¸ºtrueæ—¶ï¼Œæ¯”å¦‚å‘é€ä¸€æ¡sql:select * from mycat_order.t_orderï¼Œé‚£ä¹ˆMyCatä¼šè‡ªåŠ¨å»æ‰mycat_orderé€»è¾‘åº“åå­—å‰ç¼€ï¼ŒæŠŠsqlå˜ä¸ºï¼šselect * from t_order, è¿™æ ·æœ‰æ•ˆé¿å…æŠ¥è¡¨æˆ–è§†å›¾ä¸å­˜åœ¨é”™è¯¯ã€‚ å¦‚æœä½¿ç”¨select * from test.t_order ï¼Œsqlè¯­å¥ä¸­æ‰€å¸¦çš„é€»è¾‘åº“åå­—è·Ÿschemaæ ‡ç­¾ä¸­çš„nameä¸ä¸€è‡´çš„è¯ï¼ŒMyCatä¸ä¼šè‡ªåŠ¨å»æ‰é€»è¾‘åº“åå­—å‰ç¼€ï¼Œå¦‚æœé€»è¾‘åº“ä¸å­˜åœ¨ï¼Œä»ç„¶ä¼šæŠ¥é”™ã€‚ --\u0026gt; \u0026lt;!-- sqlMaxLimit: å¦‚æœæ¯æ¬¡æ‰§è¡Œçš„sqlè¯­å¥åé¢æ²¡æœ‰è·Ÿä¸Šlimit xxå…³é”®å­—çš„è¯ï¼ŒMyCatä¼šè‡ªåŠ¨åœ¨sqlè¯­å¥çš„åé¢æ‹¼ä¸Šlimit 100 --\u0026gt; \u0026lt;!-- dataNode: ç”¨äºæŒ‡å®šæ²¡æœ‰åˆ†é…åˆ†ç‰‡èŠ‚ç‚¹çš„é‚£äº›è¡¨çš„é»˜è®¤æ•°æ®èŠ‚ç‚¹ --\u0026gt; \u0026lt;schema name=\u0026#34;shopping\u0026#34; checkSQLschema=\u0026#34;false\u0026#34; sqlMaxLimit=\u0026#34;100\u0026#34; dataNode=\u0026#34;dn1\u0026#34;\u0026gt; \u0026lt;!-- é€»è¾‘è¡¨ï¼Œä»¥ä¸‹éƒ½æ²¡æœ‰é…ç½®åˆ†ç‰‡è§„åˆ™ruleï¼Œå› ä¸ºå‚ç›´åˆ†è¡¨ä¸éœ€è¦å®ƒ --\u0026gt; \u0026lt;!-- name: é€»è¾‘è¡¨çš„åå­—ï¼ŒåŒä¸€ä¸ªé€»è¾‘åº“schemaä¸­çš„é€»è¾‘è¡¨çš„åç§°åº”è¯¥å”¯ä¸€ --\u0026gt; \u0026lt;!-- dataNode: é…ç½®é€»è¾‘è¡¨åˆ†å¸ƒçš„æ•°æ®èŠ‚ç‚¹ï¼Œåå­—éœ€è¦ä¸dataNodeæ ‡ç­¾çš„nameå¯¹åº”ä¸Š --\u0026gt; \u0026lt;!-- rule: é…ç½®é€»è¾‘è¡¨çš„åˆ†ç‰‡è§„åˆ™,éœ€è¦åœ¨rule.xmlä¸­å£°æ˜çš„è§„åˆ™åå­—å¯¹åº”ä¸Š --\u0026gt; \u0026lt;!-- ruleRequired: æŒ‡å®šåˆ†ç‰‡è§„åˆ™æ˜¯å¦å¿…é¡»ï¼Œå¦‚æœä¸ºtrue,ä½†æ˜¯æ²¡æœ‰æŒ‡å®šruleï¼Œç¨‹åºä¼šæŠ¥é”™ --\u0026gt; \u0026lt;!-- primaryKey: æŒ‡å®šé€»è¾‘è¡¨å¯¹åº”çœŸå®è¡¨çš„ä¸»é”® --\u0026gt; \u0026lt;!-- type: æŒ‡å®šè¯¥é€»è¾‘è¡¨æ˜¯å…¨å±€è¡¨è¿˜æ˜¯æ™®é€šé€»è¾‘è¡¨ã€‚type=\u0026#34;global\u0026#34;è¡¨ç¤ºå…¨å±€è¡¨ --\u0026gt; \u0026lt;!-- autoIncrement: æŒ‡å®šæ˜¯å¦è‡ªå¢é•¿ä¸»é”® --\u0026gt; \u0026lt;!-- needAddLimit: æŒ‡å®šé€»è¾‘è¡¨æ˜¯å¦åœ¨æŸ¥è¯¢çš„æ—¶å€™è‡ªåŠ¨æ·»åŠ limitå»é™åˆ¶è¿”å›çš„ç»“æœé›†è®°å½•æ•°ï¼Œé»˜è®¤ä¸ºtrue,å¦‚æœè¯­å¥ä¸­å·²ç»åŒ…å«äº†limitå…³é”®å­—ï¼Œåˆ™ä¸ä¼šé‡å¤æ·»åŠ  --\u0026gt; \u0026lt;table name=\u0026#34;tb_user\u0026#34; primaryKey=\u0026#34;id\u0026#34; /\u0026gt; \u0026lt;!-- \u0026lt;table name=\u0026#34;t_order\u0026#34; dataNode=\u0026#34;dn1,dn2\u0026#34; rule=\u0026#34;mod-long\u0026#34;\u0026gt; # å®šä¹‰E-Råˆ†ç‰‡çš„å­è¡¨ï¼Œé€šè¿‡æ ‡ç­¾ä¸Šçš„å±æ€§ä¸çˆ¶è¡¨è¿›è¡Œå…³è” # nameï¼šå­è¡¨çš„åç§°t_order_detail # primaryKeyï¼šå­è¡¨çš„ä¸»é”® # joinKeyï¼šæ–°å¢å­è¡¨è®°å½•çš„æ—¶å€™ï¼Œä¼šæ ¹æ®è¯¥å€¼æŸ¥è¯¢çˆ¶è¡¨åœ¨å“ªä¸ªåˆ†ç‰‡èŠ‚ç‚¹ä¸Šã€‚ï¼ˆå­è¡¨ä¸­å­—æ®µçš„åç§°order_i # parentKeyå±æ€§ï¼šä¸çˆ¶è¡¨å»ºç«‹å…³è”å…³ç³»çš„åˆ—ï¼Œç»“åˆjoinKeyç¡®å®šå¥½å­è¡¨è®°å½•å­˜æ”¾çš„åˆ†ç‰‡èŠ‚ç‚¹ï¼Œæ’å…¥å­è¡¨è®°å½•æ—¶ç›´æ¥æ’å…¥åˆ°è¯¥åˆ†ç‰‡èŠ‚ç‚¹ä¸Šã€‚ï¼ˆçˆ¶è¡¨ä¸­å­—æ®µåç§°order_idï¼‰ # needAddLimitå±æ€§ï¼š æŒ‡å®šé€»è¾‘è¡¨æ˜¯å¦åœ¨æŸ¥è¯¢çš„æ—¶å€™è‡ªåŠ¨æ·»åŠ limitå»é™åˆ¶è¿”å›çš„ç»“æœé›†è®°å½•æ•°ï¼Œé»˜è®¤ä¸ºtrue,å¦‚æœè¯­å¥ä¸­å·²ç»åŒ…å«äº†limitå…³é”®å­—ï¼Œåˆ™ä¸ä¼šé‡å¤æ·»åŠ  \u0026lt;childTable name=\u0026#34;t_order_detail\u0026#34; primaryKey=\u0026#34;od_id\u0026#34; joinKey=\u0026#34;order_id\u0026#34; parentKey=\u0026#34;order_id\u0026#34;\u0026gt;\u0026lt;/childTable\u0026gt; \u0026lt;/table\u0026gt; --\u0026gt; \u0026lt;/schema\u0026gt; \u0026lt;!-- æ•°æ®èŠ‚ç‚¹ --\u0026gt; \u0026lt;!-- name: æŒ‡å®šåˆ†ç‰‡èŠ‚ç‚¹çš„åç§°ï¼Œä¸å£°æ˜é€»è¾‘è¡¨tableæ ‡ç­¾ä¸­çš„dataNodeåå­—å¯¹åº”ä¸Š --\u0026gt; \u0026lt;!-- dataHost: æŒ‡å®šåˆ†ç‰‡èŠ‚ç‚¹æ‰€åœ¨çš„èŠ‚ç‚¹ä¸»æœºï¼ˆæ•°æ®åº“å®ä¾‹ï¼‰ï¼Œä¸dataHostæ ‡ç­¾å£°æ˜çš„nameå¯¹åº” --\u0026gt; \u0026lt;!-- database: çœŸå®æ•°æ®åº“åç§° --\u0026gt; \u0026lt;dataNode name=\u0026#34;dn1\u0026#34; dataHost=\u0026#34;dhost1\u0026#34; database=\u0026#34;shopping\u0026#34; /\u0026gt; \u0026lt;!-- å…·ä½“æ•°æ®åº“å®ä¾‹ --\u0026gt; \u0026lt;dataHost name=\u0026#34;dhost1\u0026#34; maxCon=\u0026#34;1000\u0026#34; minCon=\u0026#34;10\u0026#34; balance=\u0026#34;1\u0026#34; writeType=\u0026#34;0\u0026#34; dbType=\u0026#34;mysql\u0026#34; dbDriver=\u0026#34;native\u0026#34; switchType=\u0026#34;1\u0026#34; slaveThreshold=\u0026#34;100\u0026#34;\u0026gt; \u0026lt;!--å¿ƒè·³æ£€æµ‹ --\u0026gt; \u0026lt;heartbeat\u0026gt;select user()\u0026lt;/heartbeat\u0026gt; \u0026lt;!-- å†™æœåŠ¡å™¨ï¼Œå¦‚æœè¦é…ç½®è¯»å†™ï¼Œæ·»åŠ readHostæ ‡ç­¾å³å¯ --\u0026gt; \u0026lt;writeHost host=\u0026#34;M1\u0026#34; url=\u0026#34;172.16.0.101:3306\u0026#34; user=\u0026#34;root\u0026#34; password=\u0026#34;123456\u0026#34;\u0026gt; \u0026lt;!-- è¯»æœåŠ¡å™¨ --\u0026gt; \u0026lt;readhost host=\u0026#34;S1\u0026#34; url=\u0026#34;172.16.0.103:3308\u0026#34; user=\u0026#34;root\u0026#34; password=\u0026#34;123456\u0026#34; /\u0026gt; \u0026lt;/writeHost\u0026gt; \u0026lt;!-- å†™æœåŠ¡å™¨ï¼Œå¦‚æœè¦é…ç½®è¯»å†™ï¼Œæ·»åŠ readHostæ ‡ç­¾å³å¯ --\u0026gt; \u0026lt;writeHost host=\u0026#34;M2\u0026#34; url=\u0026#34;172.16.0.102:3306\u0026#34; user=\u0026#34;root\u0026#34; password=\u0026#34;123456\u0026#34;\u0026gt; \u0026lt;!-- è¯»æœåŠ¡å™¨ --\u0026gt; \u0026lt;readhost host=\u0026#34;S2\u0026#34; url=\u0026#34;172.16.0.104:3309\u0026#34; user=\u0026#34;root\u0026#34; password=\u0026#34;123456\u0026#34; /\u0026gt; \u0026lt;/writeHost\u0026gt; \u0026lt;/dataHost\u0026gt; \u0026lt;!-- name: æŒ‡å®šåˆ†ç‰‡ä¸»æœºçš„åç§°ï¼Œä¾›dataNodeæ ‡ç­¾ä½¿ç”¨ --\u0026gt; \u0026lt;!-- maxCon: æŒ‡å®šè¯»å†™å®ä¾‹çš„è¿æ¥æ± çš„æœ€å¤§è¿æ¥æ•°é‡ --\u0026gt; \u0026lt;!-- minCon: æŒ‡å®šè¯»å†™å®ä¾‹çš„è¿æ¥æ± çš„æœ€å°è¿æ¥æ•°é‡ï¼Œåˆå§‹åŒ–è¿æ¥æ± çš„å¤§å° --\u0026gt; \u0026lt;!-- balance: æŒ‡å®šè´Ÿè½½å‡è¡¡çš„ç±»å‹ balance = â€œ0â€ : ä¸å¼€å¯è¯»å†™åˆ†ç¦»ï¼Œæ‰€æœ‰çš„è¯»è¯·æ±‚éƒ½å‘é€åˆ°å¯ç”¨çš„writeHostå†™èŠ‚ç‚¹ä¸Šï¼ˆä¸ä¼šå‘readHostï¼‰ balance = â€œ1â€ : å…¨éƒ¨çš„readHostä¸stand by writeHostå‚ä¸selectè¯­å¥çš„è´Ÿè½½å‡è¡¡ï¼Œ balance = â€œ2â€ : è¯»æ“ä½œä¼šéšæœºå‘å¾€writeHostä»¥åŠ readHostï¼Œç†è®ºä¸Šå®ç°çš„æ˜¯è´Ÿè½½å‡è¡¡ balance = â€œ3â€ : é…ç½®äº†readHostæ—¶è¯»æ“ä½œä¼šéšæœºå‘å¾€readHostï¼ˆä¸ä¼šå‘writeHostï¼‰ï¼Œè€Œæ²¡æœ‰é…ç½®readHostæ—¶è¯»æ“ä½œä¼šå‘å¾€ç¬¬ä¸€ä¸ªwriteHostã€‚ --\u0026gt; \u0026lt;!-- writeType: writeType=\u0026#34;0\u0026#34;: æ‰€æœ‰å†™æ“ä½œå‘é€åˆ°é…ç½®çš„ç¬¬ä¸€ä¸ªwriteHostï¼Œå½“ç¬¬ä¸€ä¸ªwriteHostå®•æœºæ—¶ï¼Œåˆ‡æ¢åˆ°ç¬¬äºŒä¸ªwriteHostï¼Œé‡æ–°å¯åŠ¨åä»¥åˆ‡æ¢åçš„ä¸ºå‡†ï¼Œåˆ‡æ¢è®°å½•åœ¨é…ç½®æ–‡ä»¶ï¼šdnindex.propertiesä¸­ writeType=\u0026#34;1\u0026#34;: æ‰€æœ‰å†™æ“ä½œéƒ½éšå‘é€åˆ°é…ç½®çš„writeHost --\u0026gt; \u0026lt;!-- dbType: æŒ‡å®šåç«¯æ•°æ®åº“ç±»å‹ï¼Œæ”¯æŒmysqlã€oracleç­‰ --\u0026gt; \u0026lt;!-- dbDriver: æŒ‡å®šåç«¯æ•°æ®åº“è¿æ¥é©±åŠ¨ä¿¡æ¯ï¼Œæ”¯æŒnativeå’Œjdbc --\u0026gt; \u0026lt;!-- switchType: æŒ‡å®šåˆ‡æ¢æ–¹å¼ switchType = -1ï¼šä¸è‡ªåŠ¨åˆ‡æ¢ switchType = 1ï¼šè‡ªåŠ¨åˆ‡æ¢ï¼ˆé»˜è®¤ï¼‰ switchType = 2ï¼šåŸºäºMySqlä¸»ä»åŒæ­¥çš„çŠ¶æ€æ¥å†³å®šæ˜¯å¦åˆ‡æ¢ï¼Œå¿ƒè·³è¯­å¥: show slave status switchType = 3: åŸºäºmysql galary clusterçš„åˆ‡æ¢æœºåˆ¶ï¼Œå¿ƒè·³è¯­å¥ï¼š show status like \u0026#39;wsrep%\u0026#39; --\u0026gt; \u0026lt;!-- slaveThreshold: --\u0026gt; \u0026lt;!--\u0026lt;dataHost name=\u0026#34;dhost3\u0026#34; maxCon=\u0026#34;1000\u0026#34; minCon=\u0026#34;10\u0026#34; balance=\u0026#34;0\u0026#34; writeType=\u0026#34;0\u0026#34; dbType=\u0026#34;mysql\u0026#34; dbDriver=\u0026#34;native\u0026#34; switchType=\u0026#34;1\u0026#34; slaveThreshold=\u0026#34;100\u0026#34;\u0026gt;--\u0026gt; \u0026lt;!--å¿ƒè·³æ£€æµ‹ï¼ŒæŒ‡å®šåç«¯æ•°æ®åº“è¿›è¡Œå¿ƒè·³æ£€æŸ¥çš„è¯­å¥ --\u0026gt; \u0026lt;!--\u0026lt;heartbeat\u0026gt;select user()\u0026lt;/heartbeat\u0026gt;--\u0026gt; \u0026lt;!-- å†™æœåŠ¡å™¨ï¼Œå¦‚æœè¦é…ç½®è¯»å†™ï¼Œæ·»åŠ readHostæ ‡ç­¾å³å¯ --\u0026gt; \u0026lt;!-- host: ç”¨äºæ ‡è¯†ä¸åŒå®ä¾‹ï¼Œä¸€èˆ¬ writeHost æˆ‘ä»¬ä½¿ç”¨M1ï¼ŒreadHost æˆ‘ä»¬ç”¨S1 --\u0026gt; \u0026lt;!-- url: åç«¯å®ä¾‹è¿æ¥åœ°å€ï¼Œå¦‚æœæ˜¯ä½¿ç”¨ native çš„ dbDriverï¼Œåˆ™ä¸€èˆ¬ä¸º address:port è¿™ç§å½¢å¼,ç”¨ JDBC æˆ–å…¶ä»–çš„ dbDriverï¼Œåˆ™éœ€è¦ç‰¹æ®ŠæŒ‡å®šï¼Œä½¿ç”¨ JDBC æ—¶åˆ™å¯ä»¥è¿™ä¹ˆå†™ï¼šjdbc:mysql://localhost:3306/ --\u0026gt; \u0026lt;!-- user: åç«¯å­˜å‚¨å®ä¾‹éœ€è¦çš„ç”¨æˆ·å --\u0026gt; \u0026lt;!-- password: åç«¯å­˜å‚¨å®ä¾‹éœ€è¦çš„å¯†ç  --\u0026gt; \u0026lt;!-- weight: æƒé‡ é…ç½®åœ¨ readhost ä¸­ä½œä¸ºè¯»èŠ‚ç‚¹çš„æƒé‡ --\u0026gt; \u0026lt;!-- usingDecrypt: æ˜¯å¦å¯¹å¯†ç åŠ å¯†é»˜è®¤ 0 å¦ å¦‚éœ€è¦å¼€å¯é…ç½® 1ï¼ŒåŒæ—¶ä½¿ç”¨åŠ å¯†ç¨‹åºå¯¹å¯†ç åŠ å¯† --\u0026gt; \u0026lt;!--\u0026lt;writeHost host=\u0026#34;M3\u0026#34; url=\u0026#34;172.16.0.103:3306\u0026#34; user=\u0026#34;root\u0026#34; password=\u0026#34;123456\u0026#34;\u0026gt; \u0026lt;/writeHost\u0026gt;--\u0026gt; \u0026lt;/dataHost\u0026gt; \u0026lt;/mycat:schema\u0026gt; github å®Œæ•´ä»£ç å‚çœ‹ githubã€‚https://github.com/helium-chain/mycat-tow å‚çœ‹å…¶ä»–ï¼šhttps://github.com/baojingyu/docker-mycat-mysql ","permalink":"https://heliu.site/posts/mysql/mycat/","summary":"mysql mycat åˆ†åº“åˆ†è¡¨ä¸­é—´ä»¶ã€‚","title":"mycat åˆ†åº“åˆ†è¡¨ä¸­é—´ä»¶"},{"content":"nginx æ¶æ„ nginxé‡‡ç”¨çš„æ˜¯å¤šè¿›ç¨‹çš„æ–¹å¼å·¥ä½œçš„ã€‚ nginxåå°è¿›ç¨‹ä¸­åŒ…å«ä¸€ä¸ªmasterè¿›ç¨‹å’Œå¤šä¸ªworkerè¿›ç¨‹ï¼Œmasterè¿›ç¨‹ä¸»è¦ç”¨æ¥ç®¡ç†workerè¿›ç¨‹ï¼ŒåŒ…å«æ¥æ”¶å¤–ç•Œçš„ä¿¡æ¯ã€‚ å°†æ¥æ”¶åˆ°çš„ä¿¡å·å‘é€ç»™å„ä¸ªworkerè¿›ç¨‹ï¼Œç›‘æ§workerè¿›ç¨‹çš„çŠ¶æ€ï¼Œå½“workerè¿›ç¨‹å‡ºç°å¼‚å¸¸é€€å‡ºåï¼Œä¼šè‡ªåŠ¨é‡æ–°å¯åŠ¨æ–°çš„workerè¿›ç¨‹ã€‚ workerè¿›ç¨‹åˆ™æ˜¯ä¸“é—¨ç”¨æ¥å¤„ç†ç”¨æˆ·è¯·æ±‚çš„ï¼Œå„ä¸ªworkerè¿›ç¨‹ä¹‹é—´æ˜¯å¹³ç­‰çš„å¹¶ä¸”ç›¸äº’ç‹¬ç«‹ï¼Œå¤„ç†è¯·æ±‚çš„æœºä¼šä¹Ÿæ˜¯ä¸€æ ·çš„ã€‚ å¯ä»¥é€šè¿‡ ps -ef | grep nginx æŸ¥çœ‹nginxè¿›ç¨‹ä¿¡æ¯ã€‚ nginx ç›®å½•ç»“æ„ conf ç›®å½•æ˜¯nginxæ‰€æœ‰é…ç½®æ–‡ä»¶ç›®å½•ã€‚ æ–‡ä»¶ è¯´æ˜ fastcgi.conf fastcgiç›¸å…³é…ç½®æ–‡ä»¶ fastcgi.conf.default fastcgi.confçš„å¤‡ä»½æ–‡ä»¶ fastcgi_params fastcgiçš„å‚æ•°æ–‡ä»¶ fastcgi_params.default fastcgiçš„å‚æ•°å¤‡ä»½æ–‡ä»¶ scgi_params scgiçš„å‚æ•°æ–‡ä»¶ scgi_params.default scgiçš„å‚æ•°å¤‡ä»½æ–‡ä»¶ uwsgi_params uwsgiçš„å‚æ•°æ–‡ä»¶ uwsgi_params.default uwsgiçš„å‚æ•°å¤‡ä»½æ–‡ä»¶ mime.types è®°å½•çš„æ˜¯HTTPåè®®ä¸­çš„Content-Typeçš„å€¼å’Œæ–‡ä»¶åç¼€åçš„å¯¹åº”å…³ç³» mime.types.default mime.typesçš„å¤‡ä»½æ–‡ä»¶ nginx.conf è¿™ä¸ªæ˜¯Nginxçš„æ ¸å¿ƒé…ç½®æ–‡ä»¶ nginx.conf.default nginx.confçš„å¤‡ä»½æ–‡ä»¶ koi-utfã€koi-winã€win-utf è¿™ä¸‰ä¸ªæ–‡ä»¶éƒ½æ˜¯ä¸ç¼–ç è½¬æ¢æ˜ å°„ç›¸å…³çš„é…ç½®æ–‡ä»¶ï¼Œç”¨æ¥å°†ä¸€ç§ç¼–ç è½¬æ¢æˆå¦ä¸€ç§ç¼–ç  html ç›®å½•æ˜¯nginxå­˜æ”¾è‡ªå¸¦çš„ä¸¤ä¸ªé™æ€çš„Htmlé¡µé¢ç›®å½• æ–‡ä»¶ è¯´æ˜ 50x.html 50x å¤±è´¥åçš„å¤±è´¥é¡µé¢ index.html æˆåŠŸè®¿é—®çš„é»˜è®¤é¦–é¡µ logs ç›®å½•ç”¨äºè®°å½•nginxæœåŠ¡å¯åŠ¨åçš„æ—¥å¿—æ–‡ä»¶ã€‚ æ–‡ä»¶ è¯´æ˜ access.log è¯·æ±‚æ—¥å¿—æ–‡ä»¶ error.log é”™è¯¯æ—¥å¿—æ–‡ä»¶ nginx.pid è®°å½• nginx PID sbin ç›®å½•ç”¨äºå­˜æ”¾æ‰§è¡Œç¨‹åºæ–‡ä»¶ç›®å½•ã€‚ æ–‡ä»¶ è¯´æ˜ nginx æ§åˆ¶Nginxçš„å¯åŠ¨å’Œåœæ­¢å‘½ä»¤çš„å¯æ‰§è¡Œæ–‡ä»¶ nginx å‘½ä»¤ ä¿¡å·æ§åˆ¶ æŸ¥çœ‹masterè¿›ç¨‹çš„è¿›ç¨‹å·IDï¼š\nps -ef | grep nginx å‘½ä»¤ã€‚ é€šè¿‡ logs/nginx.pid æ–‡ä»¶ã€‚ ä¿¡å·ï¼šè°ƒç”¨å‘½ä»¤ kill -signal PID\nä¿¡å· è¯´æ˜ ä¸¾ä¾‹ TERM/INT ç«‹å³å…³é—­æ•´ä¸ªæœåŠ¡ kill -INT PID / kill -INT `cat /usr/local/nginx/logs/nginx.pid` QUIT \u0026ldquo;ä¼˜é›…\u0026quot;åœ°å…³é—­æ•´ä¸ªæœåŠ¡ kill -QUIT PID / kill -TERM `cat /usr/local/nginx/logs/nginx.pid` HUP é‡è¯»é…ç½®æ–‡ä»¶å¹¶ä½¿ç”¨æœåŠ¡å¯¹æ–°é…ç½®é¡¹ç”Ÿæ•ˆ kill -HUP PID / kill -TERM `cat /usr/local/nginx/logs/nginx.pid` USR1 é‡æ–°æ‰“å¼€æ—¥å¿—æ–‡ä»¶ï¼Œå¯ä»¥ç”¨æ¥è¿›è¡Œæ—¥å¿—åˆ‡å‰² kill -USR1 PID / kill -TERM `cat /usr/local/nginx/logs/nginx.pid` USR2 å¹³æ»‘å‡çº§åˆ°æœ€æ–°ç‰ˆçš„nginx kill -USR2 PID / kill -USR2 `cat /usr/local/nginx/logs/nginx.pid` WINCH æ‰€æœ‰å­è¿›ç¨‹ä¸åœ¨æ¥æ”¶å¤„ç†æ–°è¿æ¥ï¼Œç›¸å½“äºç»™workè¿›ç¨‹å‘é€QUITæŒ‡ä»¤ kill -WINCH PID /kill -WINCH `cat /usr/local/nginx/logs/nginx.pid` å‘½ä»¤è¡Œ é€šè¿‡ nginx -h æŸ¥çœ‹æ”¯æŒé‚£äº›å‚æ•°ã€‚ å‚æ•° è¯´æ˜ ä¸¾ä¾‹ -?,-h æ˜¾ç¤ºå¸®åŠ©ä¿¡æ¯ nginx -h -v æ‰“å°ç‰ˆæœ¬å·ä¿¡æ¯å¹¶é€€å‡º nginx -v -V æ‰“å°ç‰ˆæœ¬å·ä¿¡æ¯å’Œé…ç½®ä¿¡æ¯å¹¶é€€ nginx -V -t æµ‹è¯•nginxçš„é…ç½®æ–‡ä»¶è¯­æ³•æ˜¯å¦æ­£ç¡®å¹¶é€€å‡º(å¸¸ç”¨) nginx -t -T æµ‹è¯•nginxçš„é…ç½®æ–‡ä»¶è¯­æ³•æ˜¯å¦æ­£ç¡®å¹¶åˆ—å‡ºç”¨åˆ°çš„é…ç½®æ–‡ä»¶ä¿¡æ¯ç„¶åé€€å‡º nginx -T -s ä¿¡å·(å¸¸ç”¨) nginx -s reload stop[å¿«é€Ÿå…³é—­ï¼Œç±»ä¼¼äºTERM/INTä¿¡å·çš„ä½œç”¨] nginx -s stop quit[ä¼˜é›…çš„å…³é—­ï¼Œç±»ä¼¼äºQUITä¿¡å·çš„ä½œç”¨] nginx -s quit reopen[é‡æ–°æ‰“å¼€æ—¥å¿—æ–‡ä»¶ç±»ä¼¼äºUSR1ä¿¡å·çš„ä½œç”¨] nginx -s reopen reload[ç±»ä¼¼äºHUPä¿¡å·çš„ä½œç”¨] nginx -s reload -p æŒ‡å®šNginxçš„prefixè·¯å¾„ï¼Œ(é»˜è®¤ä¸º: /usr/local/nginx/) å¸¸ç”¨æŒ‡å®šè‡ªå®šä¹‰ç›®å½• -c æŒ‡å®šNginxçš„é…ç½®æ–‡ä»¶è·¯å¾„,(é»˜è®¤ä¸º: conf/nginx.conf) å¸¸ç”¨æŒ‡å®šè‡ªå®šä¹‰æ–‡ä»¶ -g ç”¨æ¥è¡¥å……Nginxé…ç½®æ–‡ä»¶ï¼Œå‘NginxæœåŠ¡æŒ‡å®šå¯åŠ¨æ—¶åº”ç”¨å…¨å±€çš„é…ç½® å®‰è£… docker-compose.yml version: \u0026#39;3.9\u0026#39; services: nginx: image: nginx:1.20.2 container_name: nginx privileged: true restart: unless-stopped ports: - \u0026#34;80:80\u0026#34; - \u0026#34;443:443\u0026#34; volumes: #- ./docker/nginx/html:/usr/share/nginx/html #- ./docker/nginx/cert:/etc/nginx/cert #- ./docker/nginx/nginx.conf:/etc/nginx/nginx.conf #- ./docker/nginx/conf.d:/etc/nginx/conf.d #- /app/docker/nginx/logs:/var/log/nginx environment: - TZ=Asia/Shanghai healthcheck: test: [ \u0026#34;CMD\u0026#34;, \u0026#34;curl\u0026#34;, \u0026#34;-f\u0026#34;, \u0026#34;http://localhost\u0026#34; ] interval: 30s timeout: 10s retries: 3 networks: - default_net networks: default_net: driver: bridge å¯åŠ¨å‘½ä»¤ã€‚ $ docker-compose -p nginx up -d ","permalink":"https://heliu.site/posts/nginx/install/","summary":"nginx æ¶æ„ã€ç›®å½•ç»“æ„ã€ç›¸å…³å‘½ä»¤ã€‚","title":"nginx å®‰è£…éƒ¨ç½²"},{"content":" Nginxçš„æ ¸å¿ƒé…ç½®æ–‡ä»¶é»˜è®¤æ˜¯æ”¾åœ¨ /usr/local/nginx/conf/nginx.confã€‚ Nginxè‡ªå¸¦çš„Nginxé…ç½®æ–‡ä»¶ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 # å…¨å±€å— worker_processes 1; # eventså— events { worker_connections 1024; } # httpå— http { include mime.types; default_type application/octet-stream; sendfile on; keepalive_timeout 65; # httpå—ä¸­å¯ä»¥é…ç½®å¤šä¸ªserverå— # æ¯ä¸ªserverå—åˆå¯ä»¥é…ç½®å¤šä¸ªlocationå— server { listen 80; server_name localhost; location / { root html; index index.html index.htm; } error_page 500 502 503 504 /50x.html; location = /50x.html { root html; } } } å…¨å±€å— useræŒ‡ä»¤ ç”¨äºé…ç½®è¿è¡ŒNginxæœåŠ¡å™¨çš„workerè¿›ç¨‹çš„ç”¨æˆ·å’Œç”¨æˆ·ç»„ã€‚ è®¾ç½®äº†è¯¥æŒ‡ä»¤ï¼Œnginxåªèƒ½è®¿é—®ç›¸å…³ç”¨æˆ·å’Œç”¨æˆ·çš„èµ„æºï¼Œå…¶ä»–çš„è®¿é—®ä¸åˆ°ã€‚ \u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;è¯­æ³•\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash; é»˜è®¤å€¼ ç¤ºä¾‹ user user [group] nobody user www master_processæŒ‡ä»¤ æŒ‡å®šæ˜¯å¦å¼€å¯å·¥ä½œè¿›ç¨‹ã€‚ \u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;è¯­æ³•\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash; é»˜è®¤å€¼ ç¤ºä¾‹ master_process on/off on master_process on worker_processesæŒ‡ä»¤ é…ç½®Nginxç”Ÿæˆå·¥ä½œè¿›ç¨‹çš„æ•°é‡ï¼Œè¿™ä¸ªæ˜¯NginxæœåŠ¡å™¨å®ç°å¹¶å‘å¤„ç†æœåŠ¡çš„å…³é”®æ‰€åœ¨ã€‚ ç†è®ºä¸Šæ¥è¯´workder processçš„å€¼è¶Šå¤§ï¼Œå¯ä»¥æ”¯æŒçš„å¹¶å‘å¤„ç†é‡ä¹Ÿè¶Šå¤šï¼Œä½†äº‹å®ä¸Šè¿™ä¸ªå€¼çš„è®¾å®šæ˜¯éœ€è¦å—åˆ°æ¥è‡ªæœåŠ¡å™¨è‡ªèº«çš„é™åˆ¶ï¼Œå»ºè®®å°†è¯¥å€¼å’ŒæœåŠ¡å™¨CPUçš„å†…æ ¸æ•°ä¿å­˜ä¸€è‡´ã€‚ \u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;è¯­æ³•\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash; é»˜è®¤å€¼ ç¤ºä¾‹ worker_processes num/auto 1 worker_processes auto daemonæŒ‡ä»¤ è®¾å®šNginxæ˜¯å¦ä»¥å®ˆæŠ¤è¿›ç¨‹çš„æ–¹å¼å¯åŠ¨ã€‚ å®ˆæŠ¤å¼è¿›ç¨‹æ˜¯linuxåå°æ‰§è¡Œçš„ä¸€ç§æœåŠ¡è¿›ç¨‹ï¼Œç‰¹ç‚¹æ˜¯ç‹¬ç«‹äºæ§åˆ¶ç»ˆç«¯ï¼Œä¸ä¼šéšç€ç»ˆç«¯å…³é—­è€Œåœæ­¢ã€‚ \u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;è¯­æ³•\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash; é»˜è®¤å€¼ ç¤ºä¾‹ daemon on/off on daemon on pidæŒ‡ä»¤ é…ç½®Nginxå½“å‰masterè¿›ç¨‹çš„è¿›ç¨‹å·IDå­˜å‚¨çš„æ–‡ä»¶è·¯å¾„ã€‚ è¯¥å±æ€§å¯ä»¥é€šè¿‡./configure --pid-path=PATHæ¥æŒ‡å®šã€‚ \u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;è¯­æ³•\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash; é»˜è®¤å€¼ ç¤ºä¾‹ pid file /usr/local/nginx/logs/nginx.pid pid /home/nginx/logs/nginx.pid error_logæŒ‡ä»¤ é…ç½®Nginxçš„é”™è¯¯æ—¥å¿—å­˜æ”¾è·¯å¾„ã€‚ è¯¥å±æ€§å¯ä»¥é€šè¿‡./configure --error-log-path=PATHæ¥æŒ‡å®šã€‚ æ—¥å¿—çº§åˆ«çš„å€¼æœ‰ï¼šdebug|info|notice|warn|error|crit|alert|emergã€‚è®¾ç½®çš„æ—¶å€™ä¸è¦è®¾ç½®æˆinfoä»¥ä¸‹çš„ç­‰çº§ï¼Œå› ä¸ºä¼šå¸¦æ¥å¤§é‡çš„ç£ç›˜I/Oæ¶ˆè€—ï¼Œå½±å“Nginxçš„æ€§èƒ½ã€‚ å¯ä»¥å‡ºç°åœ¨ï¼šå…¨å±€å—ã€httpã€serverã€locationã€‚ \u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;è¯­æ³•\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash; é»˜è®¤å€¼ ç¤ºä¾‹ error_log file [æ—¥å¿—çº§åˆ«] logs/error.log error error_log logs/error.log error includeæŒ‡ä»¤ å¼•å…¥å…¶ä»–é…ç½®æ–‡ä»¶ï¼Œä½¿Nginxçš„é…ç½®æ›´åŠ çµæ´»ã€‚ å¯ä»¥å‡ºç°åœ¨ä»»ä½•ä½ç½®ã€‚ \u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;è¯­æ³•\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash; é»˜è®¤å€¼ ç¤ºä¾‹ include file include conf.d/* eventså— accept_mutexæŒ‡ä»¤ è®¾ç½®Nginxç½‘ç»œè¿æ¥åºåˆ—åŒ–ã€‚ä¸»è¦ç”¨æ¥è§£å†³å¸¸è¯´çš„\u0026quot;æƒŠç¾¤\u0026quot;é—®é¢˜ã€‚ ç½®ä¸ºon(å¼€å¯çŠ¶æ€)ï¼Œå°†ä¼šå¯¹å¤šä¸ªNginxè¿›ç¨‹æ¥æ”¶è¿æ¥è¿›è¡Œåºåˆ—å·ï¼Œä¸€ä¸ªä¸ªæ¥å”¤é†’æ¥æ”¶ï¼Œå°±é˜²æ­¢äº†å¤šä¸ªè¿›ç¨‹å¯¹è¿æ¥çš„äº‰æŠ¢ã€‚ \u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;è¯­æ³•\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash; é»˜è®¤å€¼ ç¤ºä¾‹ accept_mutex on/off on accept_mutex on multi_acceptæŒ‡ä»¤ è®¾ç½®æ˜¯å¦å…è®¸åŒæ—¶æ¥æ”¶å¤šä¸ªç½‘ç»œè¿æ¥ã€‚ å¦‚æœmulti_acceptè¢«ç¦æ­¢äº†ï¼Œnginxä¸€ä¸ªå·¥ä½œè¿›ç¨‹åªèƒ½åŒæ—¶æ¥å—ä¸€ä¸ªæ–°çš„è¿æ¥ã€‚å¦åˆ™ï¼Œä¸€ä¸ªå·¥ä½œè¿›ç¨‹å¯ä»¥åŒæ—¶æ¥å—æ‰€æœ‰çš„æ–°è¿æ¥ã€‚ \u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;è¯­æ³•\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash; é»˜è®¤å€¼ ç¤ºä¾‹ multi_accept on/off off multi_accept off worker_connectionsæŒ‡ä»¤ é…ç½®å•ä¸ªworkerè¿›ç¨‹æœ€å¤§çš„è¿æ¥æ•°ã€‚ è¿™é‡Œçš„è¿æ¥æ•°ä¸ä»…ä»…åŒ…æ‹¬å’Œå‰ç«¯ç”¨æˆ·å»ºç«‹çš„è¿æ¥æ•°ï¼Œè€Œæ˜¯åŒ…æ‹¬æ‰€æœ‰å¯èƒ½çš„è¿æ¥æ•°ã€‚numberå€¼ä¸èƒ½å¤§äºæ“ä½œç³»ç»Ÿæ”¯æŒæ‰“å¼€çš„æœ€å¤§æ–‡ä»¶å¥æŸ„æ•°é‡ã€‚ \u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;è¯­æ³•\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash; é»˜è®¤å€¼ ç¤ºä¾‹ worker_connections number 512 worker_commections 512 useæŒ‡ä»¤ è®¾ç½®NginxæœåŠ¡å™¨é€‰æ‹©å“ªç§äº‹ä»¶é©±åŠ¨æ¥å¤„ç†ç½‘ç»œæ¶ˆæ¯ã€‚ methodçš„å¯é€‰å€¼æœ‰select/poll/epoll/kqueueç­‰ã€‚ ä¹Ÿå¯ä»¥åœ¨ç¼–è¯‘çš„æ—¶å€™ä½¿ç”¨--with-select_moduleã€--without-select_moduleã€--with-poll_moduleã€--without-poll_moduleæ¥è®¾ç½®ã€‚ \u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;è¯­æ³•\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash; é»˜è®¤å€¼ ç¤ºä¾‹ use method æ ¹æ®æ“ä½œç³»ç»Ÿå®š use epoll httpå— Mime-Type æµè§ˆå™¨ä¸­å¯ä»¥æ˜¾ç¤ºçš„å†…å®¹æœ‰HTMLã€XMLã€GIFç­‰ç§ç±»ç¹å¤šçš„æ–‡ä»¶ã€åª’ä½“ç­‰èµ„æºï¼Œæµè§ˆå™¨ä¸ºäº†åŒºåˆ†è¿™äº›èµ„æºï¼Œå°±éœ€è¦ä½¿ç”¨MIME Typeã€‚ MIME Typeæ˜¯ç½‘ç»œèµ„æºçš„åª’ä½“ç±»å‹ã€‚Nginxä½œä¸ºwebæœåŠ¡å™¨ï¼Œä¹Ÿéœ€è¦èƒ½å¤Ÿè¯†åˆ«å‰ç«¯è¯·æ±‚çš„èµ„æºç±»å‹ã€‚ Nginxçš„é…ç½®æ–‡ä»¶ä¸­ï¼Œé»˜è®¤æœ‰ä¸¤è¡Œé…ç½®ï¼š # æŠŠmime.typesæ–‡ä»¶ä¸­MIMTç±»å‹ä¸ç›¸å…³ç±»å‹æ–‡ä»¶çš„æ–‡ä»¶åç¼€åçš„å¯¹åº”å…³ç³»åŠ å…¥åˆ°å½“å‰çš„é…ç½®æ–‡ä»¶ä¸­ include mime.types; default_type application/octet-stream; default_typeæŒ‡ä»¤ default_type:ç”¨æ¥é…ç½®Nginxå“åº”å‰ç«¯è¯·æ±‚é»˜è®¤çš„MIMEç±»å‹ã€‚ å¯ä»¥åœ¨ httpã€serverã€location ä¸­ã€‚ \u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;è¯­æ³•\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash; é»˜è®¤å€¼ ç¤ºä¾‹ default_type mime-type text/plain default_type text/plain æœ‰äº›æ—¶å€™è¯·æ±‚æŸäº›æ¥å£çš„æ—¶å€™éœ€è¦è¿”å›æŒ‡å®šçš„æ–‡æœ¬å­—ç¬¦ä¸²æˆ–è€…jsonå­—ç¬¦ä¸²ï¼Œå¦‚æœé€»è¾‘éå¸¸ç®€å•æˆ–è€…å¹²è„†æ˜¯å›ºå®šçš„å­—ç¬¦ä¸²ï¼Œé‚£ä¹ˆå¯ä»¥ä½¿ç”¨nginxå¿«é€Ÿå®ç°ï¼Œè¿™æ ·å°±ä¸ç”¨ç¼–å†™ç¨‹åºå“åº”è¯·æ±‚äº†ï¼Œå¯ä»¥å‡å°‘æœåŠ¡å™¨èµ„æºå ç”¨å¹¶ä¸”å“åº”æ€§èƒ½éå¸¸å¿«ã€‚ location /get_text { #è¿™é‡Œä¹Ÿå¯ä»¥è®¾ç½®æˆtext/plain default_type text/html; return 200 \u0026#34;This is nginx\u0026#39;s text\u0026#34;; } location /get_json{ default_type application/json; return 200 \u0026#39;{\u0026#34;name\u0026#34;:\u0026#34;TOM\u0026#34;,\u0026#34;age\u0026#34;:18}\u0026#39;; } æ—¥å¿— Nginxä¸­æ—¥å¿—çš„ç±»å‹åˆ†access.logã€error.logã€‚ access.log:ç”¨æ¥è®°å½•ç”¨æˆ·æ‰€æœ‰çš„è®¿é—®è¯·æ±‚ã€‚ error.log:è®°å½•nginxæœ¬èº«è¿è¡Œæ—¶çš„é”™è¯¯ä¿¡æ¯ï¼Œä¸ä¼šè®°å½•ç”¨æˆ·çš„è®¿é—®è¯·æ±‚ã€‚ NginxæœåŠ¡å™¨æ”¯æŒå¯¹æœåŠ¡æ—¥å¿—çš„æ ¼å¼ã€å¤§å°ã€è¾“å‡ºç­‰è¿›è¡Œè®¾ç½®ï¼Œéœ€è¦ä½¿ç”¨åˆ°ä¸¤ä¸ªæŒ‡ä»¤ï¼Œåˆ†åˆ«æ˜¯access_logå’Œlog_formatæŒ‡ä»¤ã€‚ access_logæŒ‡ä»¤ è®¾ç½®ç”¨æˆ·è®¿é—®æ—¥å¿—çš„ç›¸å…³å±æ€§ã€‚ ä½ç½®å¯ä»¥åœ¨ http, server, locationã€‚ \u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;è¯­æ³•\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash; é»˜è®¤å€¼ ç¤ºä¾‹ access_log path[format[buffer=size]] logs/access.log combined access_log logs/access.log combined log_formatæŒ‡ä»¤ æŒ‡å®šæ—¥å¿—çš„è¾“å‡ºæ ¼å¼ã€‚ \u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;è¯­æ³•\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash; é»˜è®¤å€¼ ç¤ºä¾‹ log_format name [escape=default|json|none] string\u0026hellip;. combined \u0026ldquo;\u0026hellip;\u0026rdquo; log_format combined \u0026ldquo;\u0026hellip;\u0026rdquo; sendfileæŒ‡ä»¤ è®¾ç½®NginxæœåŠ¡å™¨æ˜¯å¦ä½¿ç”¨sendfile()ä¼ è¾“æ–‡ä»¶ï¼Œè¯¥å±æ€§å¯ä»¥å¤§å¤§æé«˜Nginxå¤„ç†é™æ€èµ„æºçš„æ€§èƒ½ã€‚ å¯ä»¥åœ¨ httpã€serverã€location ä¸­ã€‚ \u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;è¯­æ³•\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash; é»˜è®¤å€¼ ç¤ºä¾‹ sendfile on/off off sendfile off keepalive_timeoutæŒ‡ä»¤ è®¾ç½®é•¿è¿æ¥çš„è¶…æ—¶æ—¶é—´ã€‚ å¯ä»¥åœ¨ httpã€serverã€location ä¸­ã€‚ \u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;è¯­æ³•\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash; é»˜è®¤å€¼ ç¤ºä¾‹ keepalive_timeout time 75s keepalive_timeout 75 keepalive_requestsæŒ‡ä»¤ è®¾ç½®ä¸€ä¸ªkeep-aliveè¿æ¥ä½¿ç”¨çš„æ¬¡æ•°ã€‚ å¯ä»¥åœ¨ httpã€serverã€location ä¸­ã€‚ \u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;è¯­æ³•\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash; é»˜è®¤å€¼ ç¤ºä¾‹ keepalive_requests number 100 keepalive_requests 100 ","permalink":"https://heliu.site/posts/nginx/conf/","summary":"nginx å…¨å±€å—ã€eventså—ã€httpå—æŒ‡ä»¤ä»‹ç»ã€‚","title":"nginx nginx.cnf"},{"content":"serverå— listenæŒ‡ä»¤ ç”¨æ¥é…ç½®ç›‘å¬ç«¯å£ã€‚ è¯­æ³•ï¼šé»˜è®¤ listen *:80 | *:8000 listen address[:port] [default_server]...; listen port [default_server]...; ç¤ºä¾‹ï¼š # listen localhost:8000 ç›‘å¬æŒ‡å®šçš„IPå’Œç«¯å£ listen 127.0.0.1:8000; # ç›‘å¬æŒ‡å®šIPçš„æ‰€æœ‰ç«¯å£ listen 127.0.0.1; # ç›‘å¬æŒ‡å®šç«¯å£ä¸Šçš„è¿æ¥(å¸¸ç”¨) listen 8000 # ç›‘å¬æŒ‡å®šç«¯å£ä¸Šçš„è¿æ¥ listen *:8000; default_serverå±æ€§æ˜¯æ ‡è¯†ç¬¦ï¼Œç”¨æ¥å°†æ­¤è™šæ‹Ÿä¸»æœºè®¾ç½®æˆé»˜è®¤ä¸»æœºã€‚ æ‰€è°“çš„é»˜è®¤ä¸»æœºæŒ‡çš„æ˜¯å¦‚æœæ²¡æœ‰åŒ¹é…åˆ°å¯¹åº”çš„address:portï¼Œåˆ™ä¼šé»˜è®¤æ‰§è¡Œçš„ã€‚å¦‚æœä¸æŒ‡å®šé»˜è®¤ä½¿ç”¨çš„æ˜¯ç¬¬ä¸€ä¸ªserverã€‚ server{ listen 8080; server_name 127.0.0.1; location /{ root html; index index.html; } } server{ # default_server è®¾ç½®é»˜è®¤ä¸»æœº listen 8080 default_server; server_name localhost; default_type text/plain; return 444 \u0026#39;This is a error request\u0026#39;; } server_nameæŒ‡ä»¤ è®¾ç½®è™šæ‹Ÿä¸»æœºæœåŠ¡åç§°ã€‚å¸¸ç”¨ 127.0.0.1ã€localhostã€www.heliu.siteã€heliu.siteã€‚ è¯­æ³•ï¼šserver_name name \u0026hellip;;ï¼Œnameå¯ä»¥æä¾›å¤šä¸ªä¸­é—´ç”¨ç©ºæ ¼åˆ†éš”ã€‚ server_nameçš„é…ç½®æ–¹å¼æœ‰ä¸‰ç§ï¼Œåˆ†åˆ«æ˜¯ï¼šç²¾ç¡®åŒ¹é…ã€é€šé…ç¬¦åŒ¹é…ã€æ­£åˆ™è¡¨è¾¾å¼åŒ¹é…ã€‚ åŒ¹é…é¡ºåºï¼š é¦–å…ˆåŒ¹é…ï¼Œç²¾ç¡®åŒ¹é…server_nameã€‚ å…¶æ¬¡åŒ¹é…ï¼Œé€šé…ç¬¦åœ¨å¼€å§‹æ—¶åŒ¹é…server_nameã€‚ ç„¶ååŒ¹é…ï¼Œé€šé…ç¬¦åœ¨ç»“æŸæ—¶åŒ¹é…server_nameã€‚ æ¥ç€åŒ¹é…ï¼Œæ­£åˆ™è¡¨è¾¾å¼åŒ¹é…server_nameã€‚ æœ€ååŒ¹é…ï¼Œé»˜è®¤çš„default_serverå¤„ç†ï¼Œå¦‚æœæ²¡æœ‰æŒ‡å®šé»˜è®¤æ‰¾ç¬¬ä¸€ä¸ªserverã€‚ ç²¾ç¡®åŒ¹é… server { listen 80; server_name heliu.site www.heliu.site; } é€šé…ç¬¦é…ç½® server_nameä¸­æ”¯æŒé€šé…ç¬¦\u0026quot;*\u0026quot;,ä½†éœ€è¦æ³¨æ„çš„æ˜¯é€šé…ç¬¦ä¸èƒ½å‡ºç°åœ¨åŸŸåçš„ä¸­é—´ï¼Œåªèƒ½å‡ºç°åœ¨é¦–æ®µæˆ–å°¾æ®µã€‚ server { listen 80; server_name *.heliu.site www.heliu.*; } æ­£åˆ™è¡¨è¾¾å¼åŒ¹é… server_nameä¸­å¯ä»¥ä½¿ç”¨æ­£åˆ™è¡¨è¾¾å¼ï¼Œå¹¶ä¸”ä½¿ç”¨~ä½œä¸ºæ­£åˆ™è¡¨è¾¾å¼å­—ç¬¦ä¸²çš„å¼€å§‹æ ‡è®°ã€‚ å¸¸è§æ­£åˆ™è¡¨è¾¾å¼ï¼š ä»£ç  è¯´æ˜ ^ åŒ¹é…æœç´¢å­—ç¬¦ä¸²å¼€å§‹ä½ç½® $ åŒ¹é…æœç´¢å­—ç¬¦ä¸²ç»“æŸä½ç½® . åŒ¹é…é™¤æ¢è¡Œç¬¦\\nä¹‹å¤–çš„ä»»ä½•å•ä¸ªå­—ç¬¦ \\ è½¬ä¹‰å­—ç¬¦ï¼Œå°†ä¸‹ä¸€ä¸ªå­—ç¬¦æ ‡è®°ä¸ºç‰¹æ®Šå­—ç¬¦ [xyz] å­—ç¬¦é›†ï¼Œä¸ä»»æ„ä¸€ä¸ªæŒ‡å®šå­—ç¬¦åŒ¹é… [a-z] å­—ç¬¦èŒƒå›´ï¼ŒåŒ¹é…æŒ‡å®šèŒƒå›´å†…çš„ä»»ä½•å­—ç¬¦ \\w ä¸ä»¥ä¸‹ä»»æ„å­—ç¬¦åŒ¹é… A-Z a-z 0-9 å’Œä¸‹åˆ’çº¿,ç­‰æ•ˆäº[A-Za-z0-9_] \\d æ•°å­—å­—ç¬¦åŒ¹é…ï¼Œç­‰æ•ˆäº[0-9] {n} æ­£å¥½åŒ¹é…næ¬¡ {n,} è‡³å°‘åŒ¹é…næ¬¡ {n,m} åŒ¹é…è‡³å°‘næ¬¡è‡³å¤šmæ¬¡ * é›¶æ¬¡æˆ–å¤šæ¬¡ï¼Œç­‰æ•ˆäº{0,} + ä¸€æ¬¡æˆ–å¤šæ¬¡ï¼Œç­‰æ•ˆäº{1,} ? é›¶æ¬¡æˆ–ä¸€æ¬¡ï¼Œç­‰æ•ˆäº{0,1} server{ listen 80; # ~åé¢ä¸èƒ½åŠ ç©ºæ ¼ï¼Œæ‹¬å·å¯ä»¥å–å€¼ server_name ~^www\\.(\\w+)\\.com$; default_type text/plain; return 200 $1 $2 ..; } locationæŒ‡ä»¤ è®¾ç½®è¯·æ±‚çš„URIã€‚ è¯­æ³•ï¼šlocation [ = | ~ | ~* | ^~ | @ ] uri{...} uriå˜é‡æ˜¯å¾…åŒ¹é…çš„è¯·æ±‚å­—ç¬¦ä¸²ï¼Œå¯ä»¥ä¸åŒ…å«æ­£åˆ™è¡¨è¾¾å¼ï¼Œä¹Ÿå¯ä»¥åŒ…å«æ­£åˆ™è¡¨è¾¾å¼ï¼Œé‚£ä¹ˆnginxæœåŠ¡å™¨åœ¨æœç´¢åŒ¹é…locationçš„æ—¶å€™ï¼Œæ˜¯å…ˆä½¿ç”¨ä¸åŒ…å«æ­£åˆ™è¡¨è¾¾å¼è¿›è¡ŒåŒ¹é…ï¼Œæ‰¾åˆ°ä¸€ä¸ªåŒ¹é…åº¦æœ€é«˜çš„ä¸€ä¸ªï¼Œç„¶ååœ¨é€šè¿‡åŒ…å«æ­£åˆ™è¡¨è¾¾å¼çš„è¿›è¡ŒåŒ¹é…ï¼Œå¦‚æœèƒ½åŒ¹é…åˆ°ç›´æ¥è®¿é—®ï¼ŒåŒ¹é…ä¸åˆ°ï¼Œå°±ä½¿ç”¨åˆšæ‰åŒ¹é…åº¦æœ€é«˜çš„é‚£ä¸ªlocationæ¥å¤„ç†è¯·æ±‚ã€‚ location åŒ¹é… ä¸å¸¦ç¬¦å· è¦æ±‚å¿…é¡»ä»¥æŒ‡å®šæ¨¡å¼å¼€å§‹ã€‚ server { listen 80; server_name 127.0.0.1; location /abc{ default_type text/plain; return 200 \u0026#34;access success\u0026#34;; } } # ä»¥ä¸‹éƒ½èƒ½åŒ¹é…åˆ° # http://192.168.200.133/abc # http://192.168.200.133/abc?p1=TOM # http://192.168.200.133/abc/ # http://192.168.200.133/abcdef = å‰ç¼€ ç”¨äºä¸åŒ…å«æ­£åˆ™è¡¨è¾¾å¼çš„uriå‰ï¼Œå¿…é¡»ä¸æŒ‡å®šçš„æ¨¡å¼ç²¾ç¡®åŒ¹é…ã€‚ server { listen 80; server_name 127.0.0.1; location =/abc{ default_type text/plain; return 200 \u0026#34;access success\u0026#34;; } } # å¯ä»¥åŒ¹é…åˆ° # http://192.168.200.133/abc # http://192.168.200.133/abc?p1=TOM # åŒ¹é…ä¸åˆ° # http://192.168.200.133/abc/ # http://192.168.200.133/abcdef ~ å’Œ ~* å‰ç¼€ ~ ï¼š ç”¨äºè¡¨ç¤ºå½“å‰uriä¸­åŒ…å«äº†æ­£åˆ™è¡¨è¾¾å¼ï¼Œå¹¶ä¸”åŒºåˆ†å¤§å°å†™ã€‚ ~*ï¼šç”¨äºè¡¨ç¤ºå½“å‰uriä¸­åŒ…å«äº†æ­£åˆ™è¡¨è¾¾å¼ï¼Œå¹¶ä¸”ä¸åŒºåˆ†å¤§å°å†™ã€‚ å¦‚æœuriåŒ…å«äº†æ­£åˆ™è¡¨è¾¾å¼ï¼Œéœ€è¦ç”¨ä¸Šè¿°ä¸¤ä¸ªç¬¦åˆæ¥æ ‡è¯†ã€‚ server { listen 80; server_name 127.0.0.1; location ~^/abc\\w${ default_type text/plain; return 200 \u0026#34;access success\u0026#34;; } } server { listen 80; server_name 127.0.0.1; location ~*^/abc\\w${ default_type text/plain; return 200 \u0026#34;access success\u0026#34;; } } ^~ å‰ç¼€ ç”¨äºä¸åŒ…å«æ­£åˆ™è¡¨è¾¾å¼çš„uriå‰ï¼ŒåŠŸèƒ½å’Œä¸åŠ ç¬¦å·çš„ä¸€è‡´ï¼Œå”¯ä¸€ä¸åŒçš„æ˜¯ï¼Œå¦‚æœæ¨¡å¼åŒ¹é…ï¼Œé‚£ä¹ˆå°±åœæ­¢æœç´¢å…¶ä»–æ¨¡å¼äº†ã€‚ server { listen 80; server_name 127.0.0.1; location ^~/abc{ default_type text/plain; return 200 \u0026#34;access success\u0026#34;; } } @ å‰ç¼€ ä½¿ç”¨locationçš„@ç¬¦åˆå®Œæˆé”™è¯¯ä¿¡æ¯å±•ç¤ºã€‚ server{ error_page 404 @jump_to_error; location @jump_to_error { default_type text/plain; return 404 \u0026#39;Not Found Page...\u0026#39;; } } rootæŒ‡ä»¤ è®¾ç½®è¯·æ±‚çš„æ ¹ç›®å½•ã€‚ å¯ä»¥åœ¨ httpã€serverã€location ä¸­ã€‚ \u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;è¯­æ³•\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash; é»˜è®¤å€¼ ç¤ºä¾‹ root path html root html path ä¸ºNginxæœåŠ¡å™¨æ¥æ”¶åˆ°è¯·æ±‚ä»¥åæŸ¥æ‰¾èµ„æºçš„æ ¹ç›®å½•è·¯å¾„ã€‚ aliasæŒ‡ä»¤ æ›´æ”¹locationçš„URIã€‚ \u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;è¯­æ³•\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash; é»˜è®¤å€¼ ç¤ºä¾‹ alias path alias /usr/local/nginx/htm pathä¸ºä¿®æ”¹åçš„æ ¹è·¯å¾„ã€‚ rootå’ŒaliasæŒ‡ä»¤çš„åŒºåˆ« åœ¨/usr/local/nginx/htmlç›®å½•ä¸‹åˆ›å»ºä¸€ä¸ª imagesç›®å½•,å¹¶åœ¨ç›®å½•ä¸‹æ”¾å…¥ä¸€å¼ å›¾ç‰‡mv.pngå›¾ç‰‡ã€‚ location /images { root /usr/local/nginx/html; } # è®¿é—®å›¾ç‰‡çš„è·¯å¾„ä¸º: http://127.0.0.1/images/mv.png èƒ½æˆåŠŸ å¦‚æœæŠŠrootæ”¹ä¸ºaliasã€‚ location /images { alias /usr/local/nginx/html; } # å†æ¬¡è®¿é—®ä¸Šè¿°åœ°å€ï¼Œé¡µé¢ä¼šå‡ºç°404çš„é”™è¯¯ï¼Œå› ä¸ºåœ°å€ä¸å¯¹ ootçš„å¤„ç†ç»“æœæ˜¯: rootè·¯å¾„+locationè·¯å¾„ï¼Œ/usr/local/nginx/html/images/mv.pngã€‚ aliasçš„å¤„ç†ç»“æœæ˜¯:ä½¿ç”¨aliasè·¯å¾„æ›¿æ¢locationè·¯å¾„ï¼Œ/usr/local/nginx/html/mv.pngã€‚ ä¿®æ”¹æˆè¿™æ ·ï¼Œalias /usr/local/nginx/html/images;å°±èƒ½è®¿é—®åˆ°ã€‚ å¦‚æœlocationè·¯å¾„æ˜¯ä»¥/ç»“å°¾,åˆ™aliasä¹Ÿå¿…é¡»æ˜¯ä»¥/ç»“å°¾ï¼Œrootæ²¡æœ‰è¦æ±‚ã€‚ location /images/ { alias /usr/local/nginx/html/images; } # è®¿é—®å°±ä¼šå‡ºé—®é¢˜ï¼ŒæŸ¥çœ‹é”™è¯¯æ—¥å¿—è¿˜æ˜¯è·¯å¾„ä¸å¯¹ï¼Œæ‰€ä»¥éœ€è¦æŠŠaliasåé¢åŠ ä¸Š / indexæŒ‡ä»¤ è®¾ç½®ç½‘ç«™çš„é»˜è®¤é¦–é¡µã€‚ å¯ä»¥åœ¨ httpã€serverã€location ä¸­ã€‚ \u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;è¯­æ³•\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash; é»˜è®¤å€¼ ç¤ºä¾‹ index file \u0026hellip; index.html index index.html indexåé¢å¯ä»¥è·Ÿå¤šä¸ªè®¾ç½®ï¼Œå¦‚æœè®¿é—®çš„æ—¶å€™æ²¡æœ‰æŒ‡å®šå…·ä½“è®¿é—®çš„èµ„æºï¼Œåˆ™ä¼šä¾æ¬¡è¿›è¡ŒæŸ¥æ‰¾ï¼Œæ‰¾åˆ°ç¬¬ä¸€ä¸ªä¸ºæ­¢ã€‚ location / { root /usr/local/nginx/html; index index.html index.htm; } # è®¿é—®è¯¥locationçš„æ—¶å€™ï¼Œå¯ä»¥é€šè¿‡ http://ip:port/ï¼Œ # åœ°å€åé¢å¦‚æœä¸æ·»åŠ ä»»ä½•å†…å®¹ï¼Œåˆ™é»˜è®¤ä¾æ¬¡è®¿é—®index.htmlå’Œindex.htmï¼Œ # æ‰¾åˆ°ç¬¬ä¸€ä¸ªæ¥è¿›è¡Œè¿”å› error_pageæŒ‡ä»¤ è®¾ç½®ç½‘ç«™çš„é”™è¯¯é¡µé¢ã€‚å¯ä»¥åœ¨ httpã€serverã€location ä¸­ã€‚ è¯­æ³•ï¼šerror_page code \u0026hellip; [=[response]] uriã€‚ å¯ä»¥æŒ‡å®šå…·ä½“è·³è½¬çš„åœ°å€ã€‚ server { error_page 404 http://www.baidu.cn; } æŒ‡å®šé‡å®šå‘åœ°å€ã€‚ server{ error_page 404 /50x.html; error_page 500 502 503 504 /50x.html; location =/50x.html{ root html; } } ä½¿ç”¨locationçš„@ç¬¦åˆå®Œæˆé”™è¯¯ä¿¡æ¯å±•ç¤ºã€‚ server{ error_page 404 @jump_to_error; location @jump_to_error { default_type text/plain; return 404 \u0026#39;Not Found Page...\u0026#39;; } } =[response]çš„ä½œç”¨æ˜¯ç”¨æ¥å°†ç›¸åº”ä»£ç æ›´æ”¹ä¸ºå¦å¤–ä¸€ä¸ªã€‚ server{ error_page 404 =200 /50x.html; location =/50x.html{ root html; } } ","permalink":"https://heliu.site/posts/nginx/server/","summary":"nginx serverå—ä»‹ç»ã€‚","title":"nginx serverå—"},{"content":"èµ„æºä¼˜åŒ– sendfileæŒ‡ä»¤ ç”¨æ¥å¼€å¯é«˜æ•ˆçš„æ–‡ä»¶ä¼ è¾“æ¨¡å¼ã€‚ å¯ä»¥åœ¨ httpã€serverã€location ä½ç½®ã€‚ è¯­æ³•ï¼šsendfile on/offã€‚é»˜è®¤å€¼ sendfile offã€‚ sendfileæŒ‡ä»¤èƒ½é¿å…é™æ€èµ„æºæ–‡ä»¶ä»å†…æ ¸ç¼“å†²åŒºæ‹·è´åˆ°ç”¨æˆ·ç¼“å†²åŒºï¼Œåˆä»ç”¨æˆ·ç¼“å†²åŒºæ‹·è´åˆ°Socketç¼“å†²åŒºã€‚ server { listen 80; server_name localhostï¼› sendfile on; location / { root html; index index.html; } } tcp_nopushæŒ‡ä»¤ è¯¥æŒ‡ä»¤å¿…é¡»åœ¨sendfileæ‰“å¼€çš„çŠ¶æ€ä¸‹æ‰ä¼šç”Ÿæ•ˆï¼Œä¸»è¦æ˜¯ç”¨æ¥æå‡ç½‘ç»œåŒ…çš„ä¼ è¾“\u0026rsquo;æ•ˆç‡\u0026rsquo;ã€‚ è¯¥æŒ‡ä»¤å¼€å¯åªè¦ç¼“å†²åŒºæœ‰æ•°æ®å°±ä¼šå‘é€ç»™å®¢æˆ·ç«¯ï¼Œè€Œä¸éœ€è¦ç­‰å¾…ç¼“å†²åŒºæ»¡äº†æ‰å‘é€ã€‚ å¯ä»¥åœ¨ httpã€serverã€location ä½ç½®ã€‚ è¯­æ³•ï¼štcp_nopush on/offã€‚é»˜è®¤å€¼ tcp_nopush offã€‚ server { listen 80; server_name localhostï¼› sendfile on; tcp_nopush on; location / { root html; index index.html; } } tcp_nodelayæŒ‡ä»¤ è¯¥æŒ‡ä»¤å¿…é¡»åœ¨keep-aliveè¿æ¥å¼€å¯çš„æƒ…å†µä¸‹æ‰ç”Ÿæ•ˆï¼Œæ¥æé«˜ç½‘ç»œåŒ…ä¼ è¾“çš„\u0026rsquo;å®æ—¶æ€§\u0026rsquo;ã€‚ å¯ä»¥åœ¨ httpã€serverã€location ä½ç½®ã€‚ è¯¥æŒ‡ä»¤å¼€å¯æ—¶æ•°æ®æ˜¯å…ˆå­˜åœ¨ç¼“å†²åŒºçš„ï¼Œç­‰å¾…ç¼“å†²åŒºæ»¡äº†å†å‘é€ç»™å®¢æˆ·ç«¯ã€‚ è¯­æ³•ï¼štcp_nodelay on/offã€‚é»˜è®¤å€¼ tcp_nodelay onã€‚ server { listen 80; server_name localhostï¼› sendfile on; tcp_nopush on; tcp_nodelay on; location / { root html; index index.html; } } èµ„æºå‹ç¼© ä»¥ä¸‹æŒ‡ä»¤éƒ½æ¥è‡ªngx_http_gzip_moduleæ¨¡å—ï¼Œè¯¥æ¨¡å—ä¼šåœ¨nginxå®‰è£…çš„æ—¶å€™å†…ç½®åˆ°nginxçš„å®‰è£…ç¯å¢ƒä¸­ã€‚ gzipæŒ‡ä»¤ ç”¨äºå¼€å¯æˆ–è€…å…³é—­gzipåŠŸèƒ½ã€‚ å¯ä»¥åœ¨ httpã€serverã€location ä½ç½®ã€‚ è¯­æ³•ï¼šgzip on/offã€‚é»˜è®¤å€¼ gzip offã€‚ server { listen 80; server_name localhostï¼› gzip on; location / { root html; index index.html; } } gzip_typesæŒ‡ä»¤ è¯¥æŒ‡ä»¤å¯ä»¥æ ¹æ®å“åº”é¡µçš„MIMEç±»å‹é€‰æ‹©æ€§åœ°å¼€å¯Gzipå‹ç¼©åŠŸèƒ½ã€‚ å¯ä»¥åœ¨ httpã€serverã€location ä½ç½®ã€‚ è¯­æ³•ï¼šgzip_types mime-type \u0026hellip;ã€‚é»˜è®¤å€¼ gzip_types text/htmlã€‚ æ‰€é€‰æ‹©çš„å€¼å¯ä»¥ä»mime.typesæ–‡ä»¶ä¸­è¿›è¡ŒæŸ¥æ‰¾ï¼Œä¹Ÿå¯ä»¥ä½¿ç”¨\u0026quot;*\u0026ldquo;ä»£è¡¨æ‰€æœ‰ã€‚ server { listen 80; server_name localhostï¼› gzip on; # å¤šä¸ªä½¿ç”¨ç©ºæ ¼éš”å¼€ gzip_types text/plain text/css application/json application/javascript text/xml; location / { root html; index index.html; } } gzip_comp_levelæŒ‡ä»¤ è¯¥æŒ‡ä»¤ç”¨äºè®¾ç½®Gzipå‹ç¼©ç¨‹åº¦ï¼Œçº§åˆ«ä»1-9,1è¡¨ç¤ºè¦æ˜¯ç¨‹åº¦æœ€ä½ï¼Œè¦æ˜¯æ•ˆç‡æœ€é«˜ï¼Œ9åˆšå¥½ç›¸åï¼Œå‹ç¼©ç¨‹åº¦æœ€é«˜ï¼Œä½†æ˜¯æ•ˆç‡æœ€ä½æœ€è´¹æ—¶é—´ã€‚ å¯ä»¥åœ¨ httpã€serverã€location ä½ç½®ã€‚ è¯­æ³•ï¼šgzip_comp_level levelã€‚é»˜è®¤å€¼ gzip_comp_level 1ã€‚ server { listen 80; server_name localhostï¼› gzip on; # å¤šä¸ªä½¿ç”¨ç©ºæ ¼éš”å¼€ gzip_types text/plain text/css application/json application/javascript text/xml; gzip_comp_level 6; # 6æ˜¯ä¸ªä¸é”™çš„ä¸­é—´å€¼ location / { root html; index index.html; } } gzip_varyæŒ‡ä»¤ è¯¥æŒ‡ä»¤ç”¨äºè®¾ç½®ä½¿ç”¨Gzipè¿›è¡Œå‹ç¼©å‘é€æ˜¯å¦æºå¸¦â€œVary:Accept-Encodingâ€å¤´åŸŸçš„å“åº”å¤´éƒ¨ã€‚ä¸»è¦æ˜¯å‘Šè¯‰æ¥æ”¶æ–¹ï¼Œæ‰€å‘é€çš„æ•°æ®ç»è¿‡äº†Gzipå‹ç¼©å¤„ç†ã€‚ å¯ä»¥åœ¨ httpã€serverã€location ä½ç½®ã€‚ è¯­æ³•ï¼šgzip_vary on/offã€‚é»˜è®¤å€¼ gzip_vary offã€‚ server { listen 80; server_name localhostï¼› gzip on; # å¤šä¸ªä½¿ç”¨ç©ºæ ¼éš”å¼€ gzip_types text/plain text/css application/json application/javascript text/xml; gzip_comp_level 6; # 6æ˜¯ä¸ªä¸é”™çš„ä¸­é—´å€¼ gzip_vary on; location / { root html; index index.html; } } gzip_buffersæŒ‡ä»¤ è¯¥æŒ‡ä»¤ç”¨äºå¤„ç†è¯·æ±‚å‹ç¼©çš„ç¼“å†²åŒºæ•°é‡å’Œå¤§å°ã€‚ å¯ä»¥åœ¨ httpã€serverã€location ä½ç½®ã€‚ è¯­æ³•ï¼šgzip_buffers number sizeã€‚é»˜è®¤å€¼ gzip_buffers 32 4k|16 8kã€‚ å…¶ä¸­number:æŒ‡å®šNginxæœåŠ¡å™¨å‘ç³»ç»Ÿç”³è¯·ç¼“å­˜ç©ºé—´ä¸ªæ•°ï¼ŒsizeæŒ‡çš„æ˜¯æ¯ä¸ªç¼“å­˜ç©ºé—´çš„å¤§å°ã€‚ ä¸»è¦å®ç°çš„æ˜¯ç”³è¯·numberä¸ªæ¯ä¸ªå¤§å°ä¸ºsizeçš„å†…å­˜ç©ºé—´ã€‚ server { listen 80; server_name localhostï¼› gzip on; # å¤šä¸ªä½¿ç”¨ç©ºæ ¼éš”å¼€ gzip_types text/plain text/css application/json application/javascript text/xml; gzip_comp_level 6; # 6æ˜¯ä¸ªä¸é”™çš„ä¸­é—´å€¼ gzip_vary on; gzip_buffers 16 8k; location / { root html; index index.html; } } gzip_disableæŒ‡ä»¤ é’ˆå¯¹ä¸åŒç§ç±»å®¢æˆ·ç«¯å‘èµ·çš„è¯·æ±‚ï¼Œå¯ä»¥é€‰æ‹©æ€§åœ°å¼€å¯å’Œå…³é—­GzipåŠŸèƒ½ã€‚ å¯ä»¥åœ¨ httpã€serverã€location ä½ç½®ã€‚ è¯­æ³•ï¼šgzip_disable regex \u0026hellip;ã€‚ regex:æ ¹æ®å®¢æˆ·ç«¯çš„æµè§ˆå™¨æ ‡å¿—(user-agent)æ¥è®¾ç½®ï¼Œæ”¯æŒä½¿ç”¨æ­£åˆ™è¡¨è¾¾å¼ã€‚æŒ‡å®šçš„æµè§ˆå™¨æ ‡å¿—ä¸ä½¿ç”¨Gzip.è¯¥æŒ‡ä»¤ä¸€èˆ¬æ˜¯ç”¨æ¥æ’é™¤ä¸€äº›æ˜æ˜¾ä¸æ”¯æŒGzipçš„æµè§ˆå™¨ã€‚ server { listen 80; server_name localhostï¼› gzip on; # å¤šä¸ªä½¿ç”¨ç©ºæ ¼éš”å¼€ gzip_types text/plain text/css application/json application/javascript text/xml; gzip_comp_level 6; # 6æ˜¯ä¸ªä¸é”™çš„ä¸­é—´å€¼ gzip_vary on; gzip_buffers 16 8k; gzip_disable \u0026#34;msie6\u0026#34;; # ç¦ç”¨IE6çš„gzipå‹ç¼©ï¼Œå› ä¸ºå®ƒæœ‰bug location / { root html; index index.html; } } gzip_http_versionæŒ‡ä»¤ é’ˆå¯¹ä¸åŒçš„HTTPåè®®ç‰ˆæœ¬ï¼Œå¯ä»¥é€‰æ‹©æ€§åœ°å¼€å¯å’Œå…³é—­GzipåŠŸèƒ½ã€‚ å¯ä»¥åœ¨ httpã€serverã€location ä½ç½®ã€‚ è¯­æ³•ï¼šgzip_http_version 1.0|1.1ã€‚é»˜è®¤å€¼ gzip_http_version 1.1ã€‚ è¯¥æŒ‡ä»¤æ˜¯æŒ‡å®šä½¿ç”¨Gzipçš„HTTPæœ€ä½ç‰ˆæœ¬ï¼Œè¯¥æŒ‡ä»¤ä¸€èˆ¬é‡‡ç”¨é»˜è®¤å€¼å³å¯ã€‚ server { listen 80; server_name localhostï¼› gzip on; # å¤šä¸ªä½¿ç”¨ç©ºæ ¼éš”å¼€ gzip_types text/plain text/css application/json application/javascript text/xml; gzip_comp_level 6; # 6æ˜¯ä¸ªä¸é”™çš„ä¸­é—´å€¼ gzip_vary on; gzip_buffers 16 8k; gzip_disable \u0026#34;msie6\u0026#34;; # ç¦ç”¨IE6çš„gzipå‹ç¼©ï¼Œå› ä¸ºå®ƒæœ‰bug gzip_http_version 1.1; location / { root html; index index.html; } } gzip_min_lengthæŒ‡ä»¤ è¯¥æŒ‡ä»¤é’ˆå¯¹ä¼ è¾“æ•°æ®çš„å¤§å°ï¼Œå¯ä»¥é€‰æ‹©æ€§åœ°å¼€å¯å’Œå…³é—­GzipåŠŸèƒ½ã€‚ å¯ä»¥åœ¨ httpã€serverã€location ä½ç½®ã€‚ è¯­æ³•ï¼šgzip_min_length lengthã€‚é»˜è®¤å€¼ gzip_min_length 20ã€‚ Gzipå‹ç¼©åŠŸèƒ½å¯¹å¤§æ•°æ®çš„å‹ç¼©æ•ˆæœæ˜æ˜¾ï¼Œä½†æ˜¯å¦‚æœè¦å‹ç¼©çš„æ•°æ®æ¯”è¾ƒå°çš„åŒ–ï¼Œå¯èƒ½å‡ºç°è¶Šå‹ç¼©æ•°æ®é‡è¶Šå¤§çš„æƒ…å†µï¼Œå› æ­¤æˆ‘ä»¬éœ€è¦æ ¹æ®å“åº”å†…å®¹çš„å¤§å°æ¥å†³å®šæ˜¯å¦ä½¿ç”¨GzipåŠŸèƒ½ã€‚å»ºè®®è®¾ç½®ä¸º1Kæˆ–ä»¥ä¸Šã€‚å•ä½ï¼šbytes[å­—èŠ‚] / kb[åƒå­—èŠ‚] / M[å…†]ã€‚ server { listen 80; server_name localhostï¼› gzip on; # å¤šä¸ªä½¿ç”¨ç©ºæ ¼éš”å¼€ gzip_types text/plain text/css application/json application/javascript text/xml; gzip_comp_level 6; # 6æ˜¯ä¸ªä¸é”™çš„ä¸­é—´å€¼ gzip_vary on; gzip_buffers 16 8k; gzip_disable \u0026#34;msie6\u0026#34;; # ç¦ç”¨IE6çš„gzipå‹ç¼©ï¼Œå› ä¸ºå®ƒæœ‰bug gzip_http_version 1.1; gzip_min_length 2M; location / { root html; index index.html; } } gzip_proxiedæŒ‡ä»¤ è¯¥æŒ‡ä»¤è®¾ç½®æ˜¯å¦å¯¹æœåŠ¡ç«¯è¿”å›çš„ç»“æœè¿›è¡ŒGzipå‹ç¼©ã€‚ å¯ä»¥åœ¨ httpã€serverã€location ä½ç½®ã€‚ è¯­æ³•ï¼šgzip_proxied off|expired|no-cache|no-store|private|no_last_modified|no_etag|auth|anyã€‚ é»˜è®¤å€¼ï¼šgzip_proxied offã€‚ off - å…³é—­NginxæœåŠ¡å™¨å¯¹åå°æœåŠ¡å™¨è¿”å›ç»“æœçš„Gzipå‹ç¼© expired - å¯ç”¨å‹ç¼©ï¼Œå¦‚æœheaderå¤´ä¸­åŒ…å« \u0026ldquo;Expires\u0026rdquo; å¤´ä¿¡æ¯ no-cache - å¯ç”¨å‹ç¼©ï¼Œå¦‚æœheaderå¤´ä¸­åŒ…å« \u0026ldquo;Cache-Control:no-cache\u0026rdquo; å¤´ä¿¡æ¯ no-store - å¯ç”¨å‹ç¼©ï¼Œå¦‚æœheaderå¤´ä¸­åŒ…å« \u0026ldquo;Cache-Control:no-store\u0026rdquo; å¤´ä¿¡æ¯ private - å¯ç”¨å‹ç¼©ï¼Œå¦‚æœheaderå¤´ä¸­åŒ…å« \u0026ldquo;Cache-Control:private\u0026rdquo; å¤´ä¿¡æ¯ no_last_modified - å¯ç”¨å‹ç¼©,å¦‚æœheaderå¤´ä¸­ä¸åŒ…å« \u0026ldquo;Last-Modified\u0026rdquo; å¤´ä¿¡æ¯ no_etag - å¯ç”¨å‹ç¼© ,å¦‚æœheaderå¤´ä¸­ä¸åŒ…å« \u0026ldquo;ETag\u0026rdquo; å¤´ä¿¡æ¯ auth - å¯ç”¨å‹ç¼© , å¦‚æœheaderå¤´ä¸­åŒ…å« \u0026ldquo;Authorization\u0026rdquo; å¤´ä¿¡æ¯ any - æ— æ¡ä»¶å¯ç”¨å‹ç¼© server { listen 80; server_name localhostï¼› gzip on; # å¤šä¸ªä½¿ç”¨ç©ºæ ¼éš”å¼€ gzip_types text/plain text/css application/json application/javascript text/xml; gzip_comp_level 6; # 6æ˜¯ä¸ªä¸é”™çš„ä¸­é—´å€¼ gzip_vary on; gzip_buffers 16 8k; gzip_disable \u0026#34;msie6\u0026#34;; # ç¦ç”¨IE6çš„gzipå‹ç¼©ï¼Œå› ä¸ºå®ƒæœ‰bug gzip_http_version 1.1; gzip_min_length 2M; gzip_proxied off; location / { root html; index index.html; } } å°ç»“ è¿™äº›é…ç½®åœ¨å¾ˆå¤šåœ°æ–¹å¯èƒ½éƒ½ä¼šç”¨åˆ°ï¼Œæ‰€ä»¥æˆ‘ä»¬å¯ä»¥å°†è¿™äº›å†…å®¹æŠ½å–åˆ°ä¸€ä¸ªé…ç½®æ–‡ä»¶ä¸­ï¼Œç„¶åé€šè¿‡includeæŒ‡ä»¤æŠŠé…ç½®æ–‡ä»¶å†æ¬¡åŠ è½½åˆ°nginx.confé…ç½®æ–‡ä»¶ä¸­ã€‚ include nginx_gzip.conf å¼€å¯sendfileä»¥åï¼Œåœ¨è¯»å–ç£ç›˜ä¸Šçš„é™æ€èµ„æºæ–‡ä»¶çš„æ—¶å€™ï¼Œå¯ä»¥å‡å°‘æ‹·è´çš„æ¬¡æ•°ï¼Œå¯ä»¥ä¸ç»è¿‡ç”¨æˆ·è¿›ç¨‹å°†é™æ€æ–‡ä»¶é€šè¿‡ç½‘ç»œè®¾å¤‡å‘é€å‡ºå»ï¼Œä½†æ˜¯Gzipè¦æƒ³å¯¹èµ„æºå‹ç¼©ï¼Œæ˜¯éœ€è¦ç»è¿‡ç”¨æˆ·è¿›ç¨‹è¿›è¡Œæ“ä½œçš„ã€‚å¯ä»¥ä½¿ç”¨ngx_http_gzip_static_moduleæ¨¡å—(æ‰‹åŠ¨åŠ è½½)çš„gzip_staticæŒ‡ä»¤æ¥è§£å†³ã€‚å‹ç¼©æ–‡ä»¶ä¹Ÿéœ€è¦æˆ‘ä»¬æ‰‹åŠ¨å‹ç¼©å¥½ã€‚ è¯­æ³•ï¼šgzip_static on | off | alwaysã€‚ èµ„æºç¼“å­˜ ç¼“å­˜çš„ä¼˜ç‚¹ï¼šå‡å°‘ç½‘ç»œå¸¦å®½æ¶ˆè€—ã€é™ä½æœåŠ¡å™¨å‹åŠ›ã€å‡å°‘ç½‘ç»œå»¶è¿Ÿï¼ŒåŠ å¿«é¡µé¢æ‰“å¼€é€Ÿåº¦ã€‚ HTTPåè®®ä¸­å’Œé¡µé¢ç¼“å­˜ç›¸å…³çš„å­—æ®µã€‚ \u0026mdash;\u0026mdash;\u0026ndash;header\u0026mdash;\u0026mdash;\u0026ndash; è¯´æ˜ Expires ç¼“å­˜è¿‡æœŸçš„æ—¥æœŸå’Œæ—¶é—´ Cache-Control è®¾ç½®å’Œç¼“å­˜ç›¸å…³çš„é…ç½®ä¿¡æ¯ Last-Modified è¯·æ±‚èµ„æºæœ€åä¿®æ”¹æ—¶é—´ ETag è¯·æ±‚å˜é‡çš„å®ä½“æ ‡ç­¾çš„å½“å‰å€¼ï¼Œæ¯”å¦‚æ–‡ä»¶çš„MD5å€¼ expiresæŒ‡ä»¤ è¯¥æŒ‡ä»¤ç”¨æ¥æ§åˆ¶é¡µé¢ç¼“å­˜çš„ä½œç”¨ã€‚å¯ä»¥é€šè¿‡è¯¥æŒ‡ä»¤æ§åˆ¶HTTPåº”ç­”ä¸­çš„â€œExpires\u0026quot;å’Œâ€Cache-Control\u0026rdquo;ã€‚ å¯ä»¥åœ¨ httpã€serverã€location ä½ç½®ã€‚ è¯­æ³•ï¼šé»˜è®¤å€¼ expires offã€‚ epoch: æŒ‡å®šExpiresçš„å€¼ä¸º'1 January,1970,00:00:01 GMT\u0026rsquo;(1970-01-01 00:00:00)ï¼ŒCache-Controlçš„å€¼no-cache epoch: æŒ‡å®šExpiresçš„å€¼ä¸º'1 January,1970,00:00:01 GMT\u0026rsquo;(1970-01-01 00:00:00)ï¼ŒCache-Controlçš„å€¼no-cache max:æŒ‡å®šExpiresçš„å€¼ä¸º'31 December2037 23:59:59GMT\u0026rsquo; (2037-12-31 23:59:59) ï¼ŒCache-Controlçš„å€¼ä¸º10å¹´ off:é»˜è®¤ä¸ç¼“å­˜ã€‚ expires [modified] time expires epoch|max|off; server { listen 80; server_name localhostï¼› location ~* \\.(jpg|jpeg|png|gif|ico|css|js)$ { expires 30d; # ç¼“å­˜30å¤© add_header Cache-Control \u0026#34;public, no-transform\u0026#34;; # æ·»åŠ ç¼“å­˜æ§åˆ¶å¤´ } } add_headeræŒ‡ä»¤ ç”¨æ¥æ·»åŠ æŒ‡å®šçš„å“åº”å¤´å’Œå“åº”å€¼ã€‚ å¯ä»¥åœ¨ httpã€serverã€location ä½ç½®ã€‚ è¯­æ³•ï¼šadd_header name value [always]ã€‚ server { listen 80; server_name localhostï¼› location ~* \\.(jpg|jpeg|png|gif|ico|css|js)$ { expires 30d; # ç¼“å­˜30å¤© add_header Cache-Control \u0026#34;public, no-transform\u0026#34;; # æ·»åŠ ç¼“å­˜æ§åˆ¶å¤´ } } è·¨åŸŸ åŒæºç­–ç•¥ï¼šæ˜¯ä¸€ç§çº¦å®šï¼Œæ˜¯æµè§ˆå™¨æœ€æ ¸å¿ƒä¹Ÿæ˜¯æœ€åŸºæœ¬çš„å®‰å…¨åŠŸèƒ½ï¼Œå¦‚æœæµè§ˆå™¨å°‘äº†åŒæºç­–ç•¥ï¼Œåˆ™æµè§ˆå™¨çš„æ­£å¸¸åŠŸèƒ½å¯èƒ½éƒ½ä¼šå—åˆ°å½±å“ã€‚ æœ‰ä¸¤å°æœåŠ¡å™¨åˆ†åˆ«ä¸ºA,B,å¦‚æœä»æœåŠ¡å™¨Açš„é¡µé¢å‘é€å¼‚æ­¥è¯·æ±‚åˆ°æœåŠ¡å™¨Bè·å–æ•°æ®ï¼Œå¦‚æœæœåŠ¡å™¨Aå’ŒæœåŠ¡å™¨Bä¸æ»¡è¶³åŒæºç­–ç•¥ï¼Œåˆ™å°±ä¼šå‡ºç°è·¨åŸŸé—®é¢˜ã€‚ åŒæºï¼šåè®®ã€åŸŸå(IP)ã€ç«¯å£ç›¸åŒå³ä¸ºåŒæºã€‚ http://192.168.200.131/user/1 https://192.168.200.131/user/1 ä¸åŒæº http://192.168.200.131/user/1 http://192.168.200.132/user/1 ä¸åŒæº http://192.168.200.131/user/1 http://192.168.200.131:8080/user/1 ä¸åŒæº http://www.nginx.com/user/1 http://www.nginx.org/user/1 ä¸åŒæº http://192.168.200.131/user/1 http://192.168.200.131:8080/user/1 ä¸åŒæº http://www.nginx.org:80/user/1 http://www.nginx.org/user/1 åŒæº add_header æŒ‡ä»¤ï¼Œæ·»åŠ å…è®¸è·¨åŸŸæ ‡è¯†ã€‚ Access-Control-Allow-Origin**: ç›´è¯‘è¿‡æ¥æ˜¯å…è®¸è·¨åŸŸè®¿é—®çš„æºåœ°å€ä¿¡æ¯ï¼Œå¯ä»¥é…ç½®å¤šä¸ª(å¤šä¸ªç”¨é€—å·åˆ†éš”)ï¼Œä¹Ÿå¯ä»¥ä½¿ç”¨*ä»£è¡¨æ‰€æœ‰æºã€‚ Access-Control-Allow-Methods:ç›´è¯‘è¿‡æ¥æ˜¯å…è®¸è·¨åŸŸè®¿é—®çš„è¯·æ±‚æ–¹å¼ï¼Œå€¼å¯ä»¥ä¸º GET POST PUT DELETE\u0026hellip;,å¯ä»¥å…¨éƒ¨è®¾ç½®ï¼Œä¹Ÿå¯ä»¥æ ¹æ®éœ€è¦è®¾ç½®ï¼Œå¤šä¸ªç”¨é€—å·åˆ†éš”ã€‚ location /getUser{ add_header Access-Control-Allow-Origin *; add_header Access-Control-Allow-Methods GET,POST,PUT,DELETE; default_type application/json; return 200 \u0026#39;{\u0026#34;id\u0026#34;:1,\u0026#34;name\u0026#34;:\u0026#34;TOM\u0026#34;,\u0026#34;age\u0026#34;:18}\u0026#39;; } é˜²ç›—é“¾ HTTPçš„å¤´ä¿¡æ¯Referer,å½“æµè§ˆå™¨å‘webæœåŠ¡å™¨å‘é€è¯·æ±‚çš„æ—¶å€™ï¼Œä¸€èˆ¬éƒ½ä¼šå¸¦ä¸ŠReferer,æ¥å‘Šè¯‰æµè§ˆå™¨è¯¥ç½‘é¡µæ˜¯ä»å“ªä¸ªé¡µé¢é“¾æ¥è¿‡æ¥çš„ã€‚ åå°æœåŠ¡å™¨å¯ä»¥æ ¹æ®è·å–åˆ°çš„è¿™ä¸ªRefererä¿¡æ¯æ¥åˆ¤æ–­æ˜¯å¦ä¸ºè‡ªå·±ä¿¡ä»»çš„ç½‘ç«™åœ°å€ï¼Œå¦‚æœæ˜¯åˆ™æ”¾è¡Œç»§ç»­è®¿é—®ï¼Œå¦‚æœä¸æ˜¯åˆ™å¯ä»¥è¿”å›403(æœåŠ¡ç«¯æ‹’ç»è®¿é—®)çš„çŠ¶æ€ä¿¡æ¯ã€‚ valid_referers æŒ‡ä»¤ nginxä¼šé€šå°±è¿‡æŸ¥çœ‹refererè‡ªåŠ¨å’Œvalid_referersåé¢çš„å†…å®¹è¿›è¡ŒåŒ¹é…ï¼Œå¦‚æœåŒ¹é…åˆ°äº†å°±å°†$invalid_refererå˜é‡ç½®0ï¼Œå¦‚æœæ²¡æœ‰åŒ¹é…åˆ°ï¼Œåˆ™å°†$invalid_refererå˜é‡ç½®ä¸º1ï¼ŒåŒ¹é…çš„è¿‡ç¨‹ä¸­ä¸åŒºåˆ†å¤§å°å†™ã€‚ å¯ä»¥åœ¨ serverã€location ä¸­ã€‚ è¯­æ³•ï¼švalid_referers none|blocked|server_names|string\u0026hellip;ã€‚ none: å¦‚æœHeaderä¸­çš„Refererä¸ºç©ºï¼Œå…è®¸è®¿é—®ã€‚ blocked:åœ¨Headerä¸­çš„Refererä¸ä¸ºç©ºï¼Œä½†æ˜¯è¯¥å€¼è¢«é˜²ç«å¢™æˆ–ä»£ç†è¿›è¡Œä¼ªè£…è¿‡ï¼Œå¦‚ä¸å¸¦\u0026quot;http://\u0026quot; ã€\u0026ldquo;https://\u0026ldquo;ç­‰åè®®å¤´çš„èµ„æºå…è®¸è®¿é—®ã€‚ server_names:æŒ‡å®šå…·ä½“çš„åŸŸåæˆ–è€…IPã€‚ string: å¯ä»¥æ”¯æŒæ­£åˆ™è¡¨è¾¾å¼å’Œ*çš„å­—ç¬¦ä¸²ã€‚å¦‚æœæ˜¯æ­£åˆ™è¡¨è¾¾å¼ï¼Œéœ€è¦ä»¥~å¼€å¤´è¡¨ç¤ºï¼Œä¾‹å¦‚ # é˜²ç›—é“¾é…ç½® location ~* \\.(jpg|jpeg|png|gif)$ { # è®¾ç½®ä¸€ä¸ªreferrerç™½åå•ï¼Œåªæœ‰referreræ˜¯ä»¥ä¸‹åŸŸåä¹‹ä¸€çš„è¯·æ±‚æ‰ä¼šè¢«å…è®¸ valid_referers none blocked heliu.site *.heliu.site; # å¦‚æœreferrerä¸åœ¨ç™½åå•ä¸­ï¼Œè¿”å›ä¸€ä¸ªé”™è¯¯å›¾ç‰‡æˆ–è€…é‡å®šå‘ if ($invalid_referer) { # è¿”å›ä¸€ä¸ªé”™è¯¯å›¾ç‰‡ return 403; # æˆ–è€…ä½ å¯ä»¥é€‰æ‹©é‡å®šå‘åˆ°ä¸€ä¸ªé”™è¯¯é¡µé¢æˆ–è€…å›¾ç‰‡ # rewrite ^/ http://yourdomain.com/403.jpg last; } # å¦‚æœreferreræœ‰æ•ˆï¼Œæ­£å¸¸æœåŠ¡é™æ€æ–‡ä»¶ try_files $uri /helium.png; } location ~*\\.(png|jpg|gif){ valid_referers none blocked www.baidu.com 192.168.1.222 *.example.com example.* www.example.org ~\\.google\\.; if ($invalid_referer){ return 403; } root /usr/local/nginx/html; } é’ˆå¯¹ç›®å½•è¿›è¡Œé˜²ç›—é“¾ã€‚ # images ç›®å½• location /images { valid_referers none blocked www.baidu.com 192.168.200.222 *.example.com example.* www.example.org ~\\.google\\.; if ($invalid_referer){ return 403; } root /usr/local/nginx/html; } æ›´ä¸¥æ ¼çš„é˜²ç›—é“¾å‚çœ‹nginxç¬¬ä¸‰æ–¹æ¨¡å—ngx_http_accesskey_moduleã€‚ ","permalink":"https://heliu.site/posts/nginx/static/","summary":"nginx é™æ€èµ„æºç¼“å­˜ã€å‹ç¼©ã€é˜²ç›—é“¾ã€‚","title":"nginx é™æ€èµ„æºä¼˜åŒ–"},{"content":" Nginxä½¿ç”¨çš„æ˜¯ngx_http_rewrite_moduleæ¨¡å—æ¥è§£æå’Œå¤„ç†RewriteåŠŸèƒ½çš„ç›¸å…³é…ç½®ã€‚ Rewriteå¸¸ç”¨å…¨å±€å˜é‡ï¼š å˜é‡ è¯´æ˜ $args å˜é‡ä¸­å­˜æ”¾äº†è¯·æ±‚URLä¸­çš„è¯·æ±‚å‚æ•°ã€‚æ¯”å¦‚http://192.168.200.133/server?arg1=value1\u0026amp;args2=value2ä¸­çš„\u0026quot;arg1=value1\u0026amp;arg2=value2\u0026quot;ï¼ŒåŠŸèƒ½å’Œ$query_stringä¸€æ · $http_user_agent å˜é‡å­˜å‚¨çš„æ˜¯ç”¨æˆ·è®¿é—®æœåŠ¡çš„ä»£ç†ä¿¡æ¯(å¦‚æœé€šè¿‡æµè§ˆå™¨è®¿é—®ï¼Œè®°å½•çš„æ˜¯æµè§ˆå™¨çš„ç›¸å…³ç‰ˆæœ¬ä¿¡æ¯) $host å˜é‡å­˜å‚¨çš„æ˜¯è®¿é—®æœåŠ¡å™¨çš„server_nameå€¼ $document_uri å˜é‡å­˜å‚¨çš„æ˜¯å½“å‰è®¿é—®åœ°å€çš„URIã€‚æ¯”å¦‚http://192.168.200.133/server?id=10\u0026amp;name=zhangsanä¸­çš„\u0026quot;/server\u0026quot;ï¼ŒåŠŸèƒ½å’Œ$uriä¸€æ · $document_root å˜é‡å­˜å‚¨çš„æ˜¯å½“å‰è¯·æ±‚å¯¹åº”locationçš„rootå€¼ï¼Œå¦‚æœæœªè®¾ç½®ï¼Œé»˜è®¤æŒ‡å‘Nginxè‡ªå¸¦htmlç›®å½•æ‰€åœ¨ä½ç½® $content_length å˜é‡å­˜å‚¨çš„æ˜¯è¯·æ±‚å¤´ä¸­çš„Content-Lengthçš„å€¼ $content_type å˜é‡å­˜å‚¨çš„æ˜¯è¯·æ±‚å¤´ä¸­çš„Content-Typeçš„å€¼ $http_cookie å˜é‡å­˜å‚¨çš„æ˜¯å®¢æˆ·ç«¯çš„cookieä¿¡æ¯ï¼Œå¯ä»¥é€šè¿‡add_header Set-Cookie \u0026lsquo;cookieName=cookieValue\u0026rsquo;æ¥æ·»åŠ cookieæ•°æ® $limit_rate å˜é‡ä¸­å­˜å‚¨çš„æ˜¯NginxæœåŠ¡å™¨å¯¹ç½‘ç»œè¿æ¥é€Ÿç‡çš„é™åˆ¶ï¼Œä¹Ÿå°±æ˜¯Nginxé…ç½®ä¸­å¯¹limit_rateæŒ‡ä»¤è®¾ç½®çš„å€¼ï¼Œé»˜è®¤æ˜¯0ï¼Œä¸é™åˆ¶ã€‚ $remote_addr å˜é‡ä¸­å­˜å‚¨çš„æ˜¯å®¢æˆ·ç«¯çš„IPåœ°å€ $remote_port å˜é‡ä¸­å­˜å‚¨äº†å®¢æˆ·ç«¯ä¸æœåŠ¡ç«¯å»ºç«‹è¿æ¥çš„ç«¯å£å· $remote_user å˜é‡ä¸­å­˜å‚¨äº†å®¢æˆ·ç«¯çš„ç”¨æˆ·åï¼Œéœ€è¦æœ‰è®¤è¯æ¨¡å—æ‰èƒ½è·å– $scheme å˜é‡ä¸­å­˜å‚¨äº†è®¿é—®åè®® $server_addr å˜é‡ä¸­å­˜å‚¨äº†æœåŠ¡ç«¯çš„åœ°å€ $server_name å˜é‡ä¸­å­˜å‚¨äº†å®¢æˆ·ç«¯è¯·æ±‚åˆ°è¾¾çš„æœåŠ¡å™¨çš„åç§° $server_port å˜é‡ä¸­å­˜å‚¨äº†å®¢æˆ·ç«¯è¯·æ±‚åˆ°è¾¾æœåŠ¡å™¨çš„ç«¯å£å· $server_protocol å˜é‡ä¸­å­˜å‚¨äº†å®¢æˆ·ç«¯è¯·æ±‚åè®®çš„ç‰ˆæœ¬ï¼Œæ¯”å¦‚\u0026quot;HTTP/1.1\u0026quot; $request_body_file å˜é‡ä¸­å­˜å‚¨äº†å‘ç»™åç«¯æœåŠ¡å™¨çš„æœ¬åœ°æ–‡ä»¶èµ„æºçš„åç§° $request_method å˜é‡ä¸­å­˜å‚¨äº†å®¢æˆ·ç«¯çš„è¯·æ±‚æ–¹å¼ï¼Œæ¯”å¦‚\u0026quot;GET\u0026quot;,\u0026ldquo;POST\u0026quot;ç­‰ $request_filename å˜é‡ä¸­å­˜å‚¨äº†å½“å‰è¯·æ±‚çš„èµ„æºæ–‡ä»¶çš„è·¯å¾„å $request_uri å˜é‡ä¸­å­˜å‚¨äº†å½“å‰è¯·æ±‚çš„URIï¼Œå¹¶ä¸”æºå¸¦è¯·æ±‚å‚æ•°ï¼Œæ¯”å¦‚http://192.168.200.133/server?id=10\u0026amp;name=zhangsanä¸­çš„\u0026rdquo;/server?id=10\u0026amp;name=zhangsan\u0026quot; ç›¸å…³æŒ‡ä»¤ setæŒ‡ä»¤ è®¾ç½®ä¸€ä¸ªæ–°çš„å˜é‡ã€‚ variable:å˜é‡çš„åç§°ï¼Œè¯¥å˜é‡åç§°è¦ç”¨\u0026quot;$\u0026ldquo;ä½œä¸ºå˜é‡çš„ç¬¬ä¸€ä¸ªå­—ç¬¦ï¼Œä¸”ä¸è¦ä¸NginxæœåŠ¡å™¨é¢„è®¾çš„å…¨å±€å˜é‡åŒåã€‚ value:å˜é‡çš„å€¼ï¼Œå¯ä»¥æ˜¯å­—ç¬¦ä¸²ã€å…¶ä»–å˜é‡æˆ–è€…å˜é‡çš„ç»„åˆç­‰ã€‚ è¯­æ³• set $variable value; é»˜è®¤å€¼ â€” ä½ç½® serverã€locationã€if ifæŒ‡ä»¤ ç”¨æ¥æ”¯æŒæ¡ä»¶åˆ¤æ–­ï¼Œå¹¶æ ¹æ®æ¡ä»¶åˆ¤æ–­ç»“æœé€‰æ‹©ä¸åŒçš„Nginxé…ç½®ã€‚ è¯­æ³• if (condition){\u0026hellip;} é»˜è®¤å€¼ â€” ä½ç½® serverã€location # 1) $param ä¸ºç©ºå­—ç¬¦ä¸²æˆ–\u0026#34;0\u0026#34;ï¼Œiféƒ½åˆ¤æ–­ä¸ºfalse if ($param){} # 2) \u0026#34;=\u0026#34;å’Œ\u0026#34;!=\u0026#34;æ¯”è¾ƒå˜é‡å’Œå­—ç¬¦ä¸²æ˜¯å¦ç›¸ç­‰ï¼Œæ»¡è¶³æ¡ä»¶ä¸ºtrueï¼Œæ³¨æ„=å‰åç©ºæ ¼ if ($request_method = POST){} # 3) æ­£åˆ™è¡¨è¾¾å¼å¯¹å˜é‡è¿›è¡ŒåŒ¹é…ï¼ŒåŒ¹é…æˆåŠŸè¿”å›trueï¼Œå¦åˆ™è¿”å›falseã€‚ # - \u0026#34;~\u0026#34;ä»£è¡¨åŒ¹é…æ­£åˆ™è¡¨è¾¾å¼è¿‡ç¨‹ä¸­åŒºåˆ†å¤§å°å†™ # - \u0026#34;~\\*\u0026#34;ä»£è¡¨åŒ¹é…æ­£åˆ™è¡¨è¾¾å¼è¿‡ç¨‹ä¸­ä¸åŒºåˆ†å¤§å°å†™ # - \u0026#34;!~\u0026#34;å’Œ\u0026#34;!~\\*\u0026#34;åˆšå¥½å’Œä¸Šé¢å–ç›¸åå€¼ï¼Œå¦‚æœåŒ¹é…ä¸Šè¿”å›false,åŒ¹é…ä¸ä¸Šè¿”å›true # æ­£åˆ™è¡¨è¾¾å¼å­—ç¬¦ä¸²ä¸€èˆ¬ä¸éœ€è¦åŠ å¼•å·ï¼Œä½†æ˜¯å¦‚æœå­—ç¬¦ä¸²ä¸­åŒ…å«\u0026#34;}\u0026#34;æˆ–è€…æ˜¯\u0026#34;;\u0026#34;ç­‰å­—ç¬¦æ—¶ï¼Œå°±éœ€è¦æŠŠå¼•å·åŠ ä¸Šã€‚ if ($http_user_agent ~ MSIE){} # $http_user_agentçš„å€¼ä¸­æ˜¯å¦åŒ…å«MSIEå­—ç¬¦ä¸²ï¼Œå¦‚æœåŒ…å«è¿”å›true # 4) åˆ¤æ–­è¯·æ±‚çš„æ–‡ä»¶æ˜¯å¦å­˜åœ¨ä½¿ç”¨\u0026#34;-f\u0026#34;å’Œ\u0026#34;!-f\u0026#34; if (-f $request_filename){} # åˆ¤æ–­è¯·æ±‚çš„æ–‡ä»¶æ˜¯å¦å­˜åœ¨ if (!-f $request_filename){} # åˆ¤æ–­è¯·æ±‚çš„æ–‡ä»¶æ˜¯å¦ä¸å­˜åœ¨ # 5) åˆ¤æ–­è¯·æ±‚çš„ç›®å½•æ˜¯å¦å­˜åœ¨ä½¿ç”¨\u0026#34;-d\u0026#34;å’Œ\u0026#34;!-d\u0026#34; if (-d $request_dir){} # 6) åˆ¤æ–­è¯·æ±‚çš„ç›®å½•æˆ–è€…æ–‡ä»¶æ˜¯å¦å­˜åœ¨ä½¿ç”¨\u0026#34;-e\u0026#34;å’Œ\u0026#34;!-e\u0026#34; # 7) åˆ¤æ–­è¯·æ±‚çš„æ–‡ä»¶æ˜¯å¦å¯æ‰§è¡Œä½¿ç”¨\u0026#34;-x\u0026#34;å’Œ\u0026#34;!-x\u0026#34; breakæŒ‡ä»¤ ç”¨äºä¸­æ–­å½“å‰ç›¸åŒä½œç”¨åŸŸä¸­çš„å…¶ä»–Nginxé…ç½®ã€‚ ä¸è¯¥æŒ‡ä»¤å¤„äºåŒä¸€ä½œç”¨åŸŸçš„Nginxé…ç½®ä¸­ï¼Œä½äºå®ƒå‰é¢çš„æŒ‡ä»¤é…ç½®ç”Ÿæ•ˆï¼Œä½äºåé¢çš„æŒ‡ä»¤é…ç½®æ— æ•ˆã€‚ å¹¶ä¸”breakè¿˜æœ‰å¦å¤–ä¸€ä¸ªåŠŸèƒ½å°±æ˜¯ç»ˆæ­¢å½“å‰çš„åŒ¹é…å¹¶æŠŠå½“å‰çš„URIåœ¨æœ¬locationè¿›è¡Œé‡å®šå‘è®¿é—®å¤„ç†ã€‚ è¯­æ³• break; é»˜è®¤å€¼ â€” ä½ç½® serverã€locationã€if location /testbreak{ default_type text/plain; set $username TOM; if ($args){ Set $username JERRY; break; set $username ROSE; } add_header username $username; return 200 $username; } returnæŒ‡ä»¤ ç”¨äºå®Œæˆå¯¹è¯·æ±‚çš„å¤„ç†ï¼Œç›´æ¥å‘å®¢æˆ·ç«¯è¿”å›ã€‚åœ¨returnåçš„æ‰€æœ‰Nginxé…ç½®éƒ½æ˜¯æ— æ•ˆçš„ã€‚ code:ä¸ºè¿”å›ç»™å®¢æˆ·ç«¯çš„HTTPçŠ¶æ€ä»£ç†ã€‚å¯ä»¥è¿”å›çš„çŠ¶æ€ä»£ç ä¸º0~999çš„ä»»æ„HTTPçŠ¶æ€ä»£ç†ã€‚ text:ä¸ºè¿”å›ç»™å®¢æˆ·ç«¯çš„å“åº”ä½“å†…å®¹ï¼Œæ”¯æŒå˜é‡çš„ä½¿ç”¨ã€‚ URL:ä¸ºè¿”å›ç»™å®¢æˆ·ç«¯çš„URLåœ°å€ã€‚ è¯­æ³• return code [text]; | return code URL; | return URL; é»˜è®¤å€¼ â€” ä½ç½® serverã€locationã€if location /testreturn { return 200 success; } location /testreturn { return https://www.baidu.com; # 302é‡å®šå‘åˆ°ç™¾åº¦ } location /testreturn { return 302 https://www.baidu.com; } location /testreturn { return 302 www.baidu.com; # ä¸å…è®¸è¿™ä¹ˆå†™ } rewriteæŒ‡ä»¤ é€šè¿‡æ­£åˆ™è¡¨è¾¾å¼çš„ä½¿ç”¨æ¥æ”¹å˜URIã€‚å¯ä»¥åŒæ—¶å­˜åœ¨ä¸€ä¸ªæˆ–è€…å¤šä¸ªæŒ‡ä»¤ï¼ŒæŒ‰ç…§é¡ºåºä¾æ¬¡å¯¹URLè¿›è¡ŒåŒ¹é…å’Œå¤„ç†ã€‚ è¯­æ³• rewrite regex replacement [flag]; é»˜è®¤å€¼ â€” ä½ç½® serverã€locationã€if regexå‚æ•°ï¼šç”¨æ¥åŒ¹é…URIçš„æ­£åˆ™è¡¨è¾¾å¼ã€‚ replacementå‚æ•°ï¼šåŒ¹é…æˆåŠŸåï¼Œç”¨äºæ›¿æ¢URIä¸­è¢«æˆªå–å†…å®¹çš„å­—ç¬¦ä¸²ã€‚å¦‚æœè¯¥å­—ç¬¦ä¸²æ˜¯ä»¥\u0026quot;http://\u0026ldquo;æˆ–è€…\u0026quot;https://\u0026ldquo;å¼€å¤´çš„ï¼Œåˆ™ä¸ä¼šç»§ç»­å‘ä¸‹å¯¹URIè¿›è¡Œå…¶ä»–å¤„ç†ï¼Œè€Œæ˜¯ç›´æ¥è¿”å›é‡å†™åçš„URIç»™å®¢æˆ·ç«¯ã€‚ location rewrite { rewrite ^/rewrite/url\\w*$ https://www.baidu.com; rewrite ^/rewrite/(test)\\w*$ /$1; rewrite ^/rewrite/(demo)\\w*$ /$1; } location /test{ default_type text/plain; return 200 test_success; } location /demo{ default_type text/plain; return 200 demo_success; } flag:ç”¨æ¥è®¾ç½®rewriteå¯¹URIçš„å¤„ç†è¡Œä¸ºï¼š lastã€breakã€redirectã€permanent last:ç»ˆæ­¢ç»§ç»­åœ¨æœ¬locationå—ä¸­å¤„ç†æ¥æ”¶åˆ°çš„URIï¼Œå¹¶å°†æ­¤å¤„é‡å†™çš„URIä½œä¸ºä¸€ä¸ªæ–°çš„URIï¼Œä½¿ç”¨å„locationå—è¿›è¡Œå¤„ç†ã€‚è¯¥æ ‡å¿—å°†é‡å†™åçš„URIé‡å†™åœ¨serverå—ä¸­æ‰§è¡Œï¼Œä¸ºé‡å†™åçš„URIæä¾›äº†è½¬å…¥åˆ°å…¶ä»–locationå—çš„æœºä¼šã€‚ location rewrite { rewrite ^/rewrite/(test)\\w*$ /$1 last; rewrite ^/rewrite/(demo)\\w*$ /$1 last; } # http://localhost/rewrite/testabc èƒ½å‘½ä¸­è¿™ location /test{ default_type text/plain; return 200 test_success; } location /demo{ default_type text/plain; return 200 demo_success; } breakï¼šå°†æ­¤å¤„é‡å†™çš„URIä½œä¸ºä¸€ä¸ªæ–°çš„URI,åœ¨æœ¬å—ä¸­ç»§ç»­è¿›è¡Œå¤„ç†ã€‚è¯¥æ ‡å¿—å°†é‡å†™åçš„åœ°å€åœ¨å½“å‰çš„locationå—ä¸­æ‰§è¡Œï¼Œä¸ä¼šå°†æ–°çš„URIè½¬å‘å…¶ä»–çš„locationå—ã€‚ # http://localhost/rewrite/demoabc æŠ¥é”™ location rewrite { #/test /usr/local/nginx/html/test/index.html rewrite ^/rewrite/(test)\\w*$ /$1 break; rewrite ^/rewrite/(demo)\\w*$ /$1 break; } location /test{ default_type text/plain; return 200 test_success; } location /demo{ default_type text/plain; return 200 demo_success; } redirectï¼šå°†é‡å†™åçš„URIè¿”å›ç»™å®¢æˆ·ç«¯ï¼ŒçŠ¶æ€ç ä¸º302ï¼ŒæŒ‡æ˜æ˜¯ä¸´æ—¶é‡å®šå‘URI,ä¸»è¦ç”¨åœ¨replacementå˜é‡ä¸æ˜¯ä»¥\u0026quot;http://\u0026ldquo;æˆ–è€…\u0026quot;https://\u0026ldquo;å¼€å¤´çš„æƒ…å†µã€‚ # http://localhost/rewrite/testabc`è¯·æ±‚ä¼šè¢«ä¸´æ—¶é‡å®šå‘ï¼Œæµè§ˆå™¨åœ°å€ä¹Ÿä¼šå‘ç”Ÿæ”¹å˜ location rewrite { rewrite ^/rewrite/(test)\\w*$ /$1 redirect; rewrite ^/rewrite/(demo)\\w*$ /$1 redirect; } location /test{ default_type text/plain; return 200 test_success; } location /demo{ default_type text/plain; return 200 demo_success; } permanentï¼šå°†é‡å†™åçš„URIè¿”å›ç»™å®¢æˆ·ç«¯ï¼ŒçŠ¶æ€ç ä¸º301ï¼ŒæŒ‡æ˜æ˜¯æ°¸ä¹…é‡å®šå‘URI,ä¸»è¦ç”¨åœ¨replacementå˜é‡ä¸æ˜¯ä»¥\u0026quot;http://\u0026ldquo;æˆ–è€…\u0026quot;https://\u0026ldquo;å¼€å¤´çš„æƒ…å†µã€‚ # http://localhost/rewrite/testabc`è¯·æ±‚ä¼šè¢«æ°¸ä¹…é‡å®šå‘ï¼Œæµè§ˆå™¨åœ°å€ä¹Ÿä¼šå‘ç”Ÿæ”¹å˜ location rewrite { rewrite ^/rewrite/(test)\\w*$ /$1 permanent; rewrite ^/rewrite/(demo)\\w*$ /$1 permanent; } location /test{ default_type text/plain; return 200 test_success; } location /demo{ default_type text/plain; return 200 demo_success; } rewrite_logæŒ‡ä»¤ è¯¥æŒ‡ä»¤é…ç½®æ˜¯å¦å¼€å¯URLé‡å†™æ—¥å¿—çš„è¾“å‡ºåŠŸèƒ½ã€‚ è¯­æ³• rewrite_log on|off; é»˜è®¤å€¼ rewrite_log off; ä½ç½® httpã€serverã€locationã€if å¼€å¯åï¼ŒURLé‡å†™çš„ç›¸å…³æ—¥å¿—å°†ä»¥noticeçº§åˆ«è¾“å‡ºåˆ°error_logæŒ‡ä»¤é…ç½®çš„æ—¥å¿—æ–‡ä»¶æ±‡æ€»ã€‚ rewrite_log on; error_log logs/error.log notice; åŸŸåè·³è½¬ å°† www.it.cnã€www.it.vip è·³è½¬åˆ° www.ix.comã€‚ server { listen 80; server_name www.it.cn www.it.vip; # (.*)æ•è·è¯·æ±‚çš„URIå’Œç›¸å…³å‚æ•° rewrite ^(.*) http://www.ix.com$1ï¼› } ç‹¬ç«‹åŸŸå ä¸€ä¸ªå®Œæ•´çš„é¡¹ç›®åŒ…å«å¤šä¸ªæ¨¡å—ï¼Œæ¯”å¦‚è´­ç‰©ç½‘ç«™æœ‰å•†å“æœç´¢æ¨¡å—ã€å•†å“è¯¦æƒ…æ¨¡å—å’Œè´­ç‰©è½¦æ¨¡å—ç­‰ï¼Œé‚£ä¹ˆæˆ‘ä»¬å¦‚ä½•ä¸ºæ¯ä¸€ä¸ªæ¨¡å—è®¾ç½®ç‹¬ç«‹çš„åŸŸåã€‚ http://search.xxss.com:81 è®¿é—®å•†å“æœç´¢æ¨¡å— http://item.xxss.com:82\tè®¿é—®å•†å“è¯¦æƒ…æ¨¡å— http://cart.xxss.com:83\tè®¿é—®å•†å“è´­ç‰©è½¦æ¨¡å— server{ listen 81; server_name search.xxss.com; rewrite ^(.*) http://www.xxss.cn/search$1; } server{ listen 82; server_name item.xxss.com; rewrite ^(.*) http://www.xxss.cn/item$1; } server{ listen 83; server_name cart.xxss.com; rewrite ^(.*) http://www.xxss.cn/cart$1; } é˜²ç›—é“¾ å½“å‡ºç°é˜²ç›—é“¾çš„æƒ…å†µï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨rewriteå°†è¯·æ±‚è½¬å‘åˆ°è‡ªå®šä¹‰çš„ä¸€å¼ å›¾ç‰‡å’Œé¡µé¢ï¼Œç»™ç”¨æˆ·æ¯”è¾ƒå¥½çš„æç¤ºä¿¡æ¯ã€‚ location /images { root html; valid_referers none blocked www.baidu.com; if ($invalid_referer){ #return 403; rewrite ^/ /images/forbidden.png break; } } ","permalink":"https://heliu.site/posts/nginx/rewrite/","summary":"nginx é‡å†™åœ°å€ã€‚","title":"nginx Rewrite"},{"content":" Nginxåå‘ä»£ç†æ¨¡å—çš„æŒ‡ä»¤æ˜¯ç”±ngx_http_proxy_moduleæ¨¡å—è¿›è¡Œè§£æï¼Œè¯¥æ¨¡å—åœ¨å®‰è£…Nginxçš„æ—¶å€™å·²ç»è‡ªå·±åŠ è£…åˆ°Nginxä¸­ã€‚ æŒ‡ä»¤ proxy_passæŒ‡ä»¤ è¯¥æŒ‡ä»¤ç”¨æ¥è®¾ç½®è¢«ä»£ç†æœåŠ¡å™¨åœ°å€ï¼Œå¯ä»¥æ˜¯ä¸»æœºåç§°ã€IPåœ°å€åŠ ç«¯å£å·å½¢å¼ã€‚ è¯­æ³• proxy_pass URL; é»˜è®¤å€¼ â€” ä½ç½® location URL:ä¸ºè¦è®¾ç½®çš„è¢«ä»£ç†æœåŠ¡å™¨åœ°å€ï¼ŒåŒ…å«ä¼ è¾“åè®®(http,https://)ã€ä¸»æœºåç§°æˆ–IPåœ°å€åŠ ç«¯å£å·ã€URIç­‰è¦ç´ ã€‚ server { listen 80; server_name localhost; location / { # å®¢æˆ·ç«¯è®¿é—® http://localhost/index.html æ•ˆæœä¸€æ ·æ²¡åŒºåˆ« #proxy_pass http://192.168.200.146; #proxy_pass http://192.168.200.146/; } } server{ listen 80; server_name localhost; location /server{ # å®¢æˆ·ç«¯è®¿é—® http://localhost/server/index.html åœ°å€ä¸å˜ #proxy_pass http://192.168.200.146; # å®¢æˆ·ç«¯è®¿é—® http://localhost/server/index.html # åœ°å€å˜ä¸º http://localhost/index.html #proxy_pass http://192.168.200.146/; } } proxy_set_headeræŒ‡ä»¤ è¯¥æŒ‡ä»¤å¯ä»¥æ›´æ”¹NginxæœåŠ¡å™¨æ¥æ”¶åˆ°çš„å®¢æˆ·ç«¯è¯·æ±‚çš„è¯·æ±‚å¤´ä¿¡æ¯ï¼Œç„¶åå°†æ–°çš„è¯·æ±‚å¤´å‘é€ç»™ä»£ç†çš„æœåŠ¡å™¨ã€‚ è¯­æ³• proxy_set_header field value; é»˜è®¤å€¼ proxy_set_header Host $proxy_host; | proxy_set_header Connection close; ä½ç½® httpã€serverã€location server { listen 8080; server_name localhost; location /server { proxy_pass http://192.168.200.146:8080/; proxy_set_header username TOM; } } proxy_redirectæŒ‡ä»¤ è¯¥æŒ‡ä»¤æ˜¯ç”¨æ¥é‡ç½®å¤´ä¿¡æ¯ä¸­çš„\u0026quot;Location\u0026quot;å’Œ\u0026quot;Refresh\u0026quot;çš„å€¼ã€‚ è¯­æ³• proxy_redirect redirect replacement; | proxy_redirect default; | proxy_redirect off; é»˜è®¤å€¼ proxy_redirect default; ä½ç½® httpã€serverã€location server { listen 8081; server_name localhost; location / { proxy_pass http://192.168.1.146:8081/; # http://192.168.1.146 ä»£ç çš„åœ°å€ # http://192.168.1.133 æ¥æºçš„åœ°å€ proxy_redirect http://192.168.1.146 http://192.168.1.133; } } proxy_redirect redirect replacementï¼š redirect:ç›®æ ‡,Locationçš„å€¼ replacement:è¦æ›¿æ¢çš„å€¼ proxy_redirect defaultï¼š å°†locationå—çš„uriå˜é‡ä½œä¸ºreplacement proxy_redirect offï¼šå…³é—­proxy_redirectçš„åŠŸèƒ½ã€‚ ç¤ºä¾‹ nginx ä»£ç†ä¸‰å°å†…å®¹ä¸ä¸€çš„æœåŠ¡å™¨ã€‚ server { listen 8082; server_name localhost; location /server1 { proxy_pass http://192.168.1.146:9001/; } location /server2 { proxy_pass http://192.168.1.146:9002/; } location /server3 { proxy_pass http://192.168.1.146:9003/; } } ","permalink":"https://heliu.site/posts/nginx/proxy/","summary":"nginx åå‘ä»£ç†åŠSSLã€‚","title":"nginx åå‘ä»£ç†"},{"content":"æ­£å‘ç´¢å¼• mysql å°±æ˜¯é‡‡ç”¨çš„æ­£å‘ç´¢å¼•ã€‚ å€’æ’ç´¢å¼• å€’æ’ç´¢å¼•é‡è¦æ¦‚å¿µï¼š æ–‡æ¡£ï¼ˆDocumentï¼‰ï¼šç”¨æ¥æœç´¢çš„æ•°æ®ï¼Œå…¶ä¸­çš„æ¯ä¸€æ¡æ•°æ®å°±æ˜¯ä¸€ä¸ªæ–‡æ¡£ã€‚ä¾‹å¦‚ä¸€ä¸ªç½‘é¡µã€ä¸€ä¸ªå•†å“ä¿¡æ¯ã€‚ è¯æ¡ï¼ˆTermï¼‰ï¼šå¯¹æ–‡æ¡£æ•°æ®æˆ–ç”¨æˆ·æœç´¢æ•°æ®ï¼Œåˆ©ç”¨æŸç§ç®—æ³•åˆ†è¯ï¼Œå¾—åˆ°çš„å…·å¤‡å«ä¹‰çš„è¯è¯­å°±æ˜¯è¯æ¡ã€‚ä¾‹å¦‚ï¼šæˆ‘æ˜¯ä¸­å›½äººï¼Œå°±å¯ä»¥åˆ†ä¸ºï¼šæˆ‘ã€æ˜¯ã€ä¸­å›½äººã€ä¸­å›½ã€å›½äººè¿™æ ·çš„å‡ ä¸ªè¯æ¡ã€‚ åˆ›å»ºå€’æ’ç´¢å¼•æ˜¯å¯¹æ­£å‘ç´¢å¼•çš„ä¸€ç§ç‰¹æ®Šå¤„ç†ï¼š å°†æ¯ä¸€ä¸ªæ–‡æ¡£çš„æ•°æ®åˆ©ç”¨ç®—æ³•åˆ†è¯ï¼Œå¾—åˆ°ä¸€ä¸ªä¸ªè¯æ¡ã€‚ åˆ›å»ºè¡¨ï¼Œæ¯è¡Œæ•°æ®åŒ…æ‹¬è¯æ¡ã€è¯æ¡æ‰€åœ¨æ–‡æ¡£idã€ä½ç½®ç­‰ä¿¡æ¯ã€‚ å› ä¸ºè¯æ¡å”¯ä¸€æ€§ï¼Œå¯ä»¥ç»™è¯æ¡åˆ›å»ºç´¢å¼•ï¼Œä¾‹å¦‚hashè¡¨ç»“æ„ç´¢å¼•ã€‚ æœç´¢æµç¨‹ï¼š è™½ç„¶è¦å…ˆæŸ¥è¯¢å€’æ’ç´¢å¼•ï¼Œå†æŸ¥è¯¢å€’æ’ç´¢å¼•ï¼Œä½†æ˜¯æ— è®ºæ˜¯è¯æ¡ã€è¿˜æ˜¯æ–‡æ¡£idéƒ½å»ºç«‹äº†ç´¢å¼•ï¼ŒæŸ¥è¯¢é€Ÿåº¦éå¸¸å¿«ï¼æ— éœ€å…¨è¡¨æ‰«æã€‚ æ­£å‘å’Œå€’æ’ æ­£å‘ç´¢å¼•æ˜¯æœ€ä¼ ç»Ÿçš„ï¼Œæ ¹æ®idç´¢å¼•çš„æ–¹å¼ã€‚ä½†æ ¹æ®è¯æ¡æŸ¥è¯¢æ—¶ï¼Œå¿…é¡»å…ˆé€æ¡è·å–æ¯ä¸ªæ–‡æ¡£ï¼Œç„¶ååˆ¤æ–­æ–‡æ¡£ä¸­æ˜¯å¦åŒ…å«æ‰€éœ€è¦çš„è¯æ¡ï¼Œæ˜¯æ ¹æ®æ–‡æ¡£æ‰¾è¯æ¡çš„è¿‡ç¨‹ã€‚ å€’æ’ç´¢å¼•åˆ™ç›¸åï¼Œæ˜¯å…ˆæ‰¾åˆ°ç”¨æˆ·è¦æœç´¢çš„è¯æ¡ï¼Œæ ¹æ®è¯æ¡å¾—åˆ°ä¿æŠ¤è¯æ¡çš„æ–‡æ¡£çš„idï¼Œç„¶åæ ¹æ®idè·å–æ–‡æ¡£ã€‚æ˜¯æ ¹æ®è¯æ¡æ‰¾æ–‡æ¡£çš„è¿‡ç¨‹ã€‚ æ­£å‘ç´¢å¼•ä¼˜ç¼ºç‚¹ï¼š ä¼˜ç‚¹ï¼šå¯ä»¥ç»™å¤šä¸ªå­—æ®µåˆ›å»ºç´¢å¼•ï¼›æ ¹æ®ç´¢å¼•å­—æ®µæœç´¢ã€æ’åºé€Ÿåº¦éå¸¸å¿«ã€‚ ç¼ºç‚¹ï¼šæ ¹æ®éç´¢å¼•å­—æ®µï¼Œæˆ–è€…ç´¢å¼•å­—æ®µä¸­çš„éƒ¨åˆ†è¯æ¡æŸ¥æ‰¾æ—¶ï¼Œåªèƒ½å…¨è¡¨æ‰«æã€‚ å€’æ’ç´¢å¼•ä¼˜ç¼ºç‚¹ï¼š ä¼˜ç‚¹ï¼šæ ¹æ®è¯æ¡æœç´¢ã€æ¨¡ç³Šæœç´¢æ—¶ï¼Œé€Ÿåº¦éå¸¸å¿«ã€‚ åªèƒ½ç»™è¯æ¡åˆ›å»ºç´¢å¼•ï¼Œè€Œä¸æ˜¯å­—æ®µï¼›æ— æ³•æ ¹æ®å­—æ®µåšæ’åºã€‚ ","permalink":"https://heliu.site/posts/elasticsearch/desc/","summary":"es æ­£å‘ç´¢å¼•å’Œå€’æ’ç´¢å¼•ç®€ä»‹ã€‚","title":"æ­£å‘ç´¢å¼•å’Œå€’æ’ç´¢å¼•"},{"content":"æ–‡æ¡£å’Œå­—æ®µ elasticsearchæ˜¯é¢å‘æ–‡æ¡£ï¼ˆDocumentï¼‰å­˜å‚¨çš„ï¼Œå¯ä»¥æ˜¯æ•°æ®åº“ä¸­çš„ä¸€æ¡å•†å“æ•°æ®ï¼Œä¸€ä¸ªè®¢å•ä¿¡æ¯ã€‚æ–‡æ¡£æ•°æ®ä¼šè¢«åºåˆ—åŒ–ä¸ºjsonæ ¼å¼åå­˜å‚¨åœ¨elasticsearchä¸­ã€‚ è€ŒJsonæ–‡æ¡£ä¸­å¾€å¾€åŒ…å«å¾ˆå¤šçš„å­—æ®µï¼ˆFieldï¼‰ï¼Œç±»ä¼¼äºæ•°æ®åº“ä¸­çš„åˆ—ã€‚ ç´¢å¼•å’Œæ˜ å°„ ç´¢å¼•ï¼ˆIndexï¼‰ï¼Œå°±æ˜¯ç›¸åŒç±»å‹çš„æ–‡æ¡£çš„é›†åˆã€‚ æ‰€æœ‰ç”¨æˆ·æ–‡æ¡£ï¼Œå°±å¯ä»¥ç»„ç»‡åœ¨ä¸€èµ·ï¼Œç§°ä¸ºç”¨æˆ·çš„ç´¢å¼•ã€‚ æ‰€æœ‰å•†å“çš„æ–‡æ¡£ï¼Œå¯ä»¥ç»„ç»‡åœ¨ä¸€èµ·ï¼Œç§°ä¸ºå•†å“çš„ç´¢å¼•ã€‚ æ‰€æœ‰è®¢å•çš„æ–‡æ¡£ï¼Œå¯ä»¥ç»„ç»‡åœ¨ä¸€èµ·ï¼Œç§°ä¸ºè®¢å•çš„ç´¢å¼•ã€‚ å› æ­¤ï¼Œæˆ‘ä»¬å¯ä»¥æŠŠç´¢å¼•å½“åšæ˜¯æ•°æ®åº“ä¸­çš„è¡¨ã€‚ æ•°æ®åº“çš„è¡¨ä¼šæœ‰çº¦æŸä¿¡æ¯ï¼Œç”¨æ¥å®šä¹‰è¡¨çš„ç»“æ„ã€å­—æ®µçš„åç§°ã€ç±»å‹ç­‰ä¿¡æ¯ã€‚å› æ­¤ï¼Œç´¢å¼•åº“ä¸­å°±æœ‰æ˜ å°„ï¼ˆmappingï¼‰ï¼Œæ˜¯ç´¢å¼•ä¸­æ–‡æ¡£çš„å­—æ®µçº¦æŸä¿¡æ¯ï¼Œç±»ä¼¼è¡¨çš„ç»“æ„çº¦æŸã€‚ mysqlä¸elasticsearch MySQL Elasticsearch è¯´æ˜ Table Index ç´¢å¼•(index)ï¼Œå°±æ˜¯æ–‡æ¡£çš„é›†åˆï¼Œç±»ä¼¼æ•°æ®åº“çš„è¡¨(table) Row Document æ–‡æ¡£ï¼ˆDocumentï¼‰ï¼Œå°±æ˜¯ä¸€æ¡æ¡çš„æ•°æ®ï¼Œç±»ä¼¼æ•°æ®åº“ä¸­çš„è¡Œï¼ˆRowï¼‰ï¼Œæ–‡æ¡£éƒ½æ˜¯JSONæ ¼å¼ Column Field å­—æ®µï¼ˆFieldï¼‰ï¼Œå°±æ˜¯JSONæ–‡æ¡£ä¸­çš„å­—æ®µï¼Œç±»ä¼¼æ•°æ®åº“ä¸­çš„åˆ—ï¼ˆColumnï¼‰ Schema Mapping Mappingï¼ˆæ˜ å°„ï¼‰æ˜¯ç´¢å¼•ä¸­æ–‡æ¡£çš„çº¦æŸï¼Œä¾‹å¦‚å­—æ®µç±»å‹çº¦æŸã€‚ç±»ä¼¼æ•°æ®åº“çš„è¡¨ç»“æ„ï¼ˆSchemaï¼‰ SQL DSL DSLæ˜¯elasticsearchæä¾›çš„JSONé£æ ¼çš„è¯·æ±‚è¯­å¥ï¼Œç”¨æ¥æ“ä½œelasticsearchï¼Œå®ç°CRUD åœ¨å®é™…åº”ç”¨ä¸­å¾€å¾€æ˜¯ä¸¤è€…ç»“åˆä½¿ç”¨ï¼š å¯¹å®‰å…¨æ€§è¦æ±‚è¾ƒé«˜çš„å†™æ“ä½œï¼Œä½¿ç”¨mysqlå®ç° å¯¹æŸ¥è¯¢æ€§èƒ½è¦æ±‚è¾ƒé«˜çš„æœç´¢éœ€æ±‚ï¼Œä½¿ç”¨elasticsearchå®ç° ä¸¤è€…å†åŸºäºæŸç§æ–¹å¼ï¼Œå®ç°æ•°æ®çš„åŒæ­¥ï¼Œä¿è¯ä¸€è‡´æ€§ ","permalink":"https://heliu.site/posts/elasticsearch/intro/","summary":"es æ–‡æ¡£å’Œç´¢å¼•ç®€ä»‹ã€‚","title":"æ–‡æ¡£å’Œç´¢å¼•"},{"content":"å®‰è£…ES æ‹·è´ESé…ç½®æ–‡ä»¶ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 # 1)åˆ›å»ºç½‘ç»œ docker network create es-net # 2)è·å–é•œåƒåˆ—è¡¨ docker search elasticsearch # 3)æ‹‰å–é•œåƒ docker pull elasticsearch:8.12.0 # 4)æŸ¥çœ‹é•œåƒ docker images # 5)å¯åŠ¨å®¹å™¨ docker run -d \\ --name es \\ -e \u0026#34;ES_JAVA_OPTS=-Xms512m -Xmx512m\u0026#34; \\ -e \u0026#34;discovery.type=single-node\u0026#34; \\ --network es-net \\ -p 9200:9200 \\ -p 9300:9300 \\ elasticsearch:8.12.0 # 6)å¤åˆ¶å®¹å™¨å¯¹åº”æ–‡ä»¶ mkdir -p /home/elasticsearch/{data,plugins,config} docker cp es:/usr/share/elasticsearch/config /home/elasticsearch docker cp es:/usr/share/elasticsearch/plugins /home/elasticsearch # 7)ç§»é™¤nginxå®¹å™¨ docker rm -f es # 8)ç»™ä¸ç›®å½•æƒé™ chmod -R 777 /home/elasticsearch # 9)æŒ‚è½½ç›®å½• pluginsã€dataã€logsã€config/ docker run -d \\ --name es \\ -e \u0026#34;ES_JAVA_OPTS=-Xms512m -Xmx512m\u0026#34; \\ -e \u0026#34;discovery.type=single-node\u0026#34; \\ -v /home/elasticsearch/data:/usr/share/elasticsearch/data \\ -v /home/elasticsearch/plugins:/usr/share/elasticsearch/plugins \\ -v /home/elasticsearch/config:/usr/share/elasticsearch/config \\ --privileged \\ --network es-net \\ -p 9200:9200 \\ -p 9300:9300 \\ elasticsearch:8.12.0 ç›¸å…³å‚æ•°è§£é‡Šï¼š\n-e \u0026quot;cluster.name=es-docker-cluster\u0026quot;ï¼šè®¾ç½®é›†ç¾¤åç§°ã€‚ -e \u0026quot;http.host=0.0.0.0\u0026quot;ï¼šç›‘å¬çš„åœ°å€ï¼Œå¯ä»¥å¤–ç½‘è®¿é—®ã€‚ -e \u0026quot;ES_JAVA_OPTS=-Xms512m -Xmx512m\u0026quot;ï¼šå†…å­˜å¤§å°ã€‚ -e \u0026quot;discovery.type=single-node\u0026quot;ï¼šéé›†ç¾¤æ¨¡å¼ã€‚ -v es-data:/usr/share/elasticsearch/dataï¼šæŒ‚è½½é€»è¾‘å·ï¼Œç»‘å®šesçš„æ•°æ®ç›®å½•ã€‚ -v es-logs:/usr/share/elasticsearch/logsï¼šæŒ‚è½½é€»è¾‘å·ï¼Œç»‘å®šesçš„æ—¥å¿—ç›®å½•ã€‚ -v es-plugins:/usr/share/elasticsearch/pluginsï¼šæŒ‚è½½é€»è¾‘å·ï¼Œç»‘å®šesçš„æ’ä»¶ç›®å½•ã€‚ --privilegedï¼šæˆäºˆé€»è¾‘å·è®¿é—®æƒã€‚ --network es-net ï¼šåŠ å…¥ä¸€ä¸ªåä¸ºes-netçš„ç½‘ç»œä¸­ã€‚ -p 9200:9200ï¼šç«¯å£æ˜ å°„é…ç½®ã€‚ ESçš„9200ç«¯å£ç”¨äºæ•°æ®çš„äº¤äº’ï¼Œ9300ç«¯å£ç”¨äºé›†ç¾¤çš„é€šä¿¡ã€‚\néªŒè¯ï¼šæµè§ˆå™¨è¾“å…¥http://localhost:9200ã€‚\nå®‰è£…kibana kibanaç»™æˆ‘ä»¬æä¾›ä¸€ä¸ªelasticsearchçš„å¯è§†åŒ–ç•Œé¢ã€‚ 1 2 3 4 5 6 7 8 9 10 # 1)æ‹‰å–é•œåƒ docker pull kibana:8.12.0 # 2)å®‰è£… docker run -d \\ --name kibana \\ -e ELASTICSEARCH_HOSTS=http://es:9200 \\ --network=es-net \\ -p 5601:5601 \\ kibana:7.12.1 ç›¸å…³å‚æ•°è§£é‡Šï¼š --network es-net ï¼šåŠ å…¥ä¸€ä¸ªåä¸ºes-netçš„ç½‘ç»œä¸­ï¼Œä¸elasticsearchåœ¨åŒä¸€ä¸ªç½‘ç»œä¸­ã€‚ -e ELASTICSEARCH_HOSTS=http://es:9200\u0026quot;ï¼šè®¾ç½®elasticsearchçš„åœ°å€ï¼Œå› ä¸ºkibanaå·²ç»ä¸elasticsearchåœ¨ä¸€ä¸ªç½‘ç»œï¼Œå› æ­¤å¯ä»¥ç”¨å®¹å™¨åç›´æ¥è®¿é—®elasticsearchã€‚ -p 5601:5601ï¼šç«¯å£æ˜ å°„é…ç½®ã€‚ dockeræŸ¥çœ‹å¯åŠ¨æ—¥å¿—çœ‹æ˜¯å¦å¯åŠ¨æˆåŠŸï¼šdocker logs -f kibanaã€‚ æµè§ˆå™¨è¾“å…¥ï¼šhttp://localhost:5601ã€‚ ESå®‰è£…IKåˆ†è¯å™¨ åœ¨çº¿å®‰è£… 1 2 3 4 5 6 7 8 9 10 11 # 1) è¿›å…¥ESå®¹å™¨ docker exec -it es /bin/bash # 2) åœ¨çº¿ä¸‹è½½å¹¶å®‰è£… ./bin/elasticsearch-plugin install https://github.com/medcl/elasticsearch-analysis-ik/releases/download/v7.12.1/elasticsearch-analysis-ik-7.12.1.zip # 3) æ¨å‡ºå®¹å™¨ exit # 4) é‡å¯ES docker restart es ç¦»çº¿å®‰è£… æŸ¥çœ‹æ•°æ®å·ç›®å½•ï¼šdocker volume inspect es-pluginsã€‚ æŠŠä¸‹è½½çš„7.12.1ç‰ˆæœ¬åŒ…æ”¾å…¥ã€‚é‡å¯ESã€‚ IKåˆ†è¯å™¨ IKåˆ†è¯å™¨åŒ…å«ä¸¤ç§æ¨¡å¼ï¼š ik_smartï¼šæœ€å°‘åˆ‡åˆ†ã€‚ ik_max_wordï¼šæœ€ç»†åˆ‡åˆ†ã€‚ æµ‹è¯•ä¸¤ç§åˆ†è¯ã€‚ 1 2 3 4 5 GET /_analyze { \u0026#34;analyzer\u0026#34;: \u0026#34;ik_smart\u0026#34;, \u0026#34;text\u0026#34;: \u0026#34;ç¾å¥½çš„ä¸€å¤©ä»æ¸…æ™¨å¼€å§‹ã€‚\u0026#34; } { \u0026#34;tokens\u0026#34;: [ { \u0026#34;token\u0026#34;: \u0026#34;ç¾å¥½\u0026#34;, \u0026#34;start_offset\u0026#34;: 0, \u0026#34;end_offset\u0026#34;: 2, \u0026#34;type\u0026#34;: \u0026#34;CN_WORD\u0026#34;, \u0026#34;position\u0026#34;: 0 }, { \u0026#34;token\u0026#34;: \u0026#34;çš„\u0026#34;, \u0026#34;start_offset\u0026#34;: 2, \u0026#34;end_offset\u0026#34;: 3, \u0026#34;type\u0026#34;: \u0026#34;CN_CHAR\u0026#34;, \u0026#34;position\u0026#34;: 1 }, { \u0026#34;token\u0026#34;: \u0026#34;ä¸€å¤©\u0026#34;, \u0026#34;start_offset\u0026#34;: 3, \u0026#34;end_offset\u0026#34;: 5, \u0026#34;type\u0026#34;: \u0026#34;CN_WORD\u0026#34;, \u0026#34;position\u0026#34;: 2 }, { \u0026#34;token\u0026#34;: \u0026#34;ä»\u0026#34;, \u0026#34;start_offset\u0026#34;: 5, \u0026#34;end_offset\u0026#34;: 6, \u0026#34;type\u0026#34;: \u0026#34;CN_CHAR\u0026#34;, \u0026#34;position\u0026#34;: 3 }, { \u0026#34;token\u0026#34;: \u0026#34;æ¸…æ™¨\u0026#34;, \u0026#34;start_offset\u0026#34;: 6, \u0026#34;end_offset\u0026#34;: 8, \u0026#34;type\u0026#34;: \u0026#34;CN_WORD\u0026#34;, \u0026#34;position\u0026#34;: 4 }, { \u0026#34;token\u0026#34;: \u0026#34;å¼€å§‹\u0026#34;, \u0026#34;start_offset\u0026#34;: 8, \u0026#34;end_offset\u0026#34;: 10, \u0026#34;type\u0026#34;: \u0026#34;CN_WORD\u0026#34;, \u0026#34;position\u0026#34;: 5 } ] } 1 2 3 4 5 GET /_analyze { \u0026#34;analyzer\u0026#34;: \u0026#34;ik_max_word\u0026#34;, \u0026#34;text\u0026#34;: \u0026#34;ç¾å¥½çš„ä¸€å¤©ä»æ¸…æ™¨å¼€å§‹ã€‚\u0026#34; } { \u0026#34;tokens\u0026#34;: [ { \u0026#34;token\u0026#34;: \u0026#34;ç¾å¥½\u0026#34;, \u0026#34;start_offset\u0026#34;: 0, \u0026#34;end_offset\u0026#34;: 2, \u0026#34;type\u0026#34;: \u0026#34;CN_WORD\u0026#34;, \u0026#34;position\u0026#34;: 0 }, { \u0026#34;token\u0026#34;: \u0026#34;çš„\u0026#34;, \u0026#34;start_offset\u0026#34;: 2, \u0026#34;end_offset\u0026#34;: 3, \u0026#34;type\u0026#34;: \u0026#34;CN_CHAR\u0026#34;, \u0026#34;position\u0026#34;: 1 }, { \u0026#34;token\u0026#34;: \u0026#34;ä¸€å¤©\u0026#34;, \u0026#34;start_offset\u0026#34;: 3, \u0026#34;end_offset\u0026#34;: 5, \u0026#34;type\u0026#34;: \u0026#34;CN_WORD\u0026#34;, \u0026#34;position\u0026#34;: 2 }, { \u0026#34;token\u0026#34;: \u0026#34;ä¸€\u0026#34;, \u0026#34;start_offset\u0026#34;: 3, \u0026#34;end_offset\u0026#34;: 4, \u0026#34;type\u0026#34;: \u0026#34;TYPE_CNUM\u0026#34;, \u0026#34;position\u0026#34;: 3 }, { \u0026#34;token\u0026#34;: \u0026#34;å¤©\u0026#34;, \u0026#34;start_offset\u0026#34;: 4, \u0026#34;end_offset\u0026#34;: 5, \u0026#34;type\u0026#34;: \u0026#34;COUNT\u0026#34;, \u0026#34;position\u0026#34;: 4 }, { \u0026#34;token\u0026#34;: \u0026#34;ä»\u0026#34;, \u0026#34;start_offset\u0026#34;: 5, \u0026#34;end_offset\u0026#34;: 6, \u0026#34;type\u0026#34;: \u0026#34;CN_CHAR\u0026#34;, \u0026#34;position\u0026#34;: 5 }, { \u0026#34;token\u0026#34;: \u0026#34;æ¸…æ™¨\u0026#34;, \u0026#34;start_offset\u0026#34;: 6, \u0026#34;end_offset\u0026#34;: 8, \u0026#34;type\u0026#34;: \u0026#34;CN_WORD\u0026#34;, \u0026#34;position\u0026#34;: 6 }, { \u0026#34;token\u0026#34;: \u0026#34;å¼€å§‹\u0026#34;, \u0026#34;start_offset\u0026#34;: 8, \u0026#34;end_offset\u0026#34;: 10, \u0026#34;type\u0026#34;: \u0026#34;CN_WORD\u0026#34;, \u0026#34;position\u0026#34;: 7 } ] } æ‰©å±•/åœç”¨è¯å…¸ æ‰¾åˆ° plugins/IK/config/IKAnalyzer.cfg.xml æ–‡ä»¶ï¼Œæ·»åŠ å¦‚ä¸‹å†…å®¹ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;!DOCTYPE properties SYSTEM \u0026#34;http://java.sun.com/dtd/properties.dtd\u0026#34;\u0026gt; \u0026lt;properties\u0026gt; \u0026lt;comment\u0026gt;IK Analyzer æ‰©å±•é…ç½®\u0026lt;/comment\u0026gt; \u0026lt;!--ç”¨æˆ·å¯ä»¥åœ¨è¿™é‡Œé…ç½®è‡ªå·±çš„æ‰©å±•å­—å…¸ --\u0026gt; \u0026lt;entry key=\u0026#34;ext_dict\u0026#34;\u0026gt;ext.dic\u0026lt;/entry\u0026gt; \u0026lt;!--ç”¨æˆ·å¯ä»¥åœ¨è¿™é‡Œé…ç½®è‡ªå·±çš„æ‰©å±•åœæ­¢è¯å­—å…¸--\u0026gt; \u0026lt;entry key=\u0026#34;ext_stopwords\u0026#34;\u0026gt;stopword.dic\u0026lt;/entry\u0026gt; \u0026lt;!--ç”¨æˆ·å¯ä»¥åœ¨è¿™é‡Œé…ç½®è¿œç¨‹æ‰©å±•å­—å…¸ --\u0026gt; \u0026lt;!-- \u0026lt;entry key=\u0026#34;remote_ext_dict\u0026#34;\u0026gt;words_location\u0026lt;/entry\u0026gt; --\u0026gt; \u0026lt;!--ç”¨æˆ·å¯ä»¥åœ¨è¿™é‡Œé…ç½®è¿œç¨‹æ‰©å±•åœæ­¢è¯å­—å…¸--\u0026gt; \u0026lt;!-- \u0026lt;entry key=\u0026#34;remote_ext_stopwords\u0026#34;\u0026gt;words_location\u0026lt;/entry\u0026gt; --\u0026gt; \u0026lt;/properties\u0026gt; åœ¨ plugins/IK/config/ ç›®å½•ä¸‹æ·»åŠ  ext.dic å’Œ stopword.dic æ–‡ä»¶ã€‚é‡å¯ESã€‚ ä¸€é”®éƒ¨ç½² docker-compose.ymlã€‚\nå¯åŠ¨å‘½ä»¤ï¼šdocker-compose -p es-node up -dã€‚\nå®Œæ•´ä»£ç å‚çœ‹ githubã€‚https://github.com/helium-chain/ex-kibana-single-node\n","permalink":"https://heliu.site/posts/elasticsearch/install/","summary":"elasticsearchã€kibanaå®‰è£…ç®€ä»‹ã€‚","title":"å®‰è£…"},{"content":" mappingæ˜¯å¯¹ç´¢å¼•åº“ä¸­æ–‡æ¡£çš„çº¦æŸã€‚ Mapping å±æ€§ type å­—æ®µç±»å‹ï¼Œå¸¸ç”¨çš„æœ‰ textã€keywordã€integerç­‰ã€‚ index å­—æ®µæ˜¯å¦å»ºç«‹å€’æ’ç´¢å¼•ï¼Œé»˜è®¤ä¸ºtrueã€‚ falseæƒ…å†µä¸‹ä¸èƒ½è¢«æœç´¢ï¼Œä½†æ”¯æŒé›†åˆåˆ†æã€‚ indexå±æ€§ç”¨äºæ§åˆ¶å­—æ®µå€¼æ˜¯å¦åº”è¯¥è¢«ç´¢å¼•ï¼Œå³æ˜¯å¦å¯ä»¥åœ¨æœç´¢æ—¶ä½¿ç”¨è¿™äº›å€¼ã€‚è¿™ä¸ªå±æ€§é€šå¸¸ä¸å­—æ®µç±»å‹å®šä¹‰ä¸€èµ·ä½¿ç”¨ï¼Œç‰¹åˆ«æ˜¯åœ¨åˆ›å»ºæˆ–æ›´æ–°ç´¢å¼•çš„æ˜ å°„ï¼ˆmappingï¼‰æ—¶ã€‚ ä½œç”¨ï¼š ç´¢å¼•ï¼šå¦‚æœå­—æ®µè¢«è®¾ç½®ä¸ºindex: trueï¼ˆé»˜è®¤å€¼ï¼‰ï¼Œé‚£ä¹ˆElasticsearchä¼šä¸ºè¯¥å­—æ®µåˆ›å»ºå€’æ’ç´¢å¼•ï¼Œè¿™ä½¿å¾—ä½ å¯ä»¥é€šè¿‡è¯¥å­—æ®µè¿›è¡Œæœç´¢ã€‚ ä¸ç´¢å¼•ï¼šå¦‚æœå­—æ®µè¢«è®¾ç½®ä¸ºindex: falseï¼Œé‚£ä¹ˆElasticsearchä¸ä¼šä¸ºè¯¥å­—æ®µåˆ›å»ºå€’æ’ç´¢å¼•ï¼Œå› æ­¤ä½ æ— æ³•é€šè¿‡è¯¥å­—æ®µè¿›è¡Œæœç´¢ï¼Œä½†æ˜¯è¯¥å­—æ®µçš„å€¼ä»ç„¶ä¼šå­˜å‚¨åœ¨ _source ä¸­ã€‚ ä½¿ç”¨åœºæ™¯ï¼š å½“ä½ æœ‰ä¸€ä¸ªå­—æ®µï¼Œå®ƒçš„å€¼ä¸éœ€è¦è¢«æœç´¢ï¼Œä½†æ˜¯ä½ å¸Œæœ›å°†å…¶å€¼å­˜å‚¨åœ¨ _source ä¸­ä»¥ä¾›åç»­ä½¿ç”¨ï¼Œå¯ä»¥å°†indexå±æ€§è®¾ç½®ä¸ºfalseã€‚ å¦‚æœä½ å¸Œæœ›åŠ å¿«ç´¢å¼•çš„é€Ÿåº¦å¹¶å‡å°‘ç´¢å¼•çš„å¤§å°ï¼Œå¯ä»¥é€‰æ‹©æ€§åœ°ç´¢å¼•æŸäº›å­—æ®µã€‚ ä¸enabledå±æ€§ä¸åŒï¼Œindexå±æ€§å¯ä»¥ç”¨æ¥æ§åˆ¶å­—æ®µæ˜¯å¦å¯æœç´¢ï¼Œè€Œenabledå±æ€§åˆ™å¯ä»¥å®Œå…¨ç¦ç”¨å­—æ®µçš„ç´¢å¼•å’Œå­˜å‚¨ã€‚ ç¤ºä¾‹ï¼š PUT /my_index { \u0026#34;mappings\u0026#34;: { \u0026#34;properties\u0026#34;: { \u0026#34;field1\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;text\u0026#34;, \u0026#34;index\u0026#34;: true // é»˜è®¤å€¼ï¼Œå¯çœç•¥ }, \u0026#34;field2\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;keyword\u0026#34;, \u0026#34;index\u0026#34;: false // ä¸å¯æœç´¢ï¼Œä½†å­˜åœ¨äº _source ä¸­ } } } } enable å­—æ®µæ˜¯å¦å»ºç«‹å€’æ’ç´¢å¼•ä»¥åŠdoc valueï¼Œenabledå±æ€§æ˜¯ç”¨æ¥æ§åˆ¶å­—æ®µæ˜¯å¦ä¼šè¢«ç´¢å¼•å’Œæœç´¢çš„ã€‚ å¯ä»¥ä¸ºæ¯ä¸ªå­—æ®µè®¾ç½®enabledå±æ€§ã€‚ ä½œç”¨ï¼š ç´¢å¼•ï¼šå¦‚æœå­—æ®µè¢«è®¾ç½®ä¸ºenabled: trueï¼ˆé»˜è®¤å€¼ï¼‰ï¼Œé‚£ä¹ˆè¯¥å­—æ®µçš„å€¼ä¼šè¢«ç´¢å¼•ï¼Œå¹¶ä¸”å¯ä»¥åœ¨æœç´¢æ—¶ä½¿ç”¨ã€‚ æœç´¢ï¼šå¦‚æœå­—æ®µè¢«è®¾ç½®ä¸ºenabled: falseï¼Œé‚£ä¹ˆè¯¥å­—æ®µçš„å€¼ä¸ä¼šè¢«ç´¢å¼•ï¼Œå› æ­¤ä¸èƒ½åœ¨æœç´¢æ—¶ä½¿ç”¨ï¼Œä½†æ˜¯ä»ç„¶å¯ä»¥åœ¨æ–‡æ¡£çš„æºå­—æ®µä¸­çœ‹åˆ°ã€‚ ä½¿ç”¨åœºæ™¯ï¼š å½“ä½ æœ‰ä¸€ä¸ªå­—æ®µï¼Œå®ƒçš„æ•°æ®é‡éå¸¸å¤§ï¼Œä½†ä½ åˆä¸å¸Œæœ›åœ¨æœç´¢æ—¶ä½¿ç”¨å®ƒï¼Œå¯ä»¥å°†å…¶enabledå±æ€§è®¾ç½®ä¸ºfalseæ¥èŠ‚çœç´¢å¼•ç©ºé—´ã€‚ åœ¨æŸäº›æƒ…å†µä¸‹ï¼Œä½ å¯èƒ½å¸Œæœ›åªå­˜å‚¨æŸäº›ä¿¡æ¯è€Œä¸è¿›è¡Œåˆ†ææˆ–æœç´¢ï¼Œè¿™æ—¶å€™ä¹Ÿå¯ä»¥å°†å­—æ®µçš„enabledå±æ€§è®¾ç½®ä¸ºfalseã€‚ ä½¿ç”¨ç¤ºä¾‹ï¼š PUT /my_index { \u0026#34;mappings\u0026#34;: { \u0026#34;properties\u0026#34;: { \u0026#34;field1\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;text\u0026#34;, \u0026#34;enabled\u0026#34;: true // é»˜è®¤å€¼ï¼Œå¯çœç•¥ }, \u0026#34;field2\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;keyword\u0026#34;, \u0026#34;enabled\u0026#34;: false // æ—¢ä¸å¯æœç´¢ä¹Ÿä¸å­˜åœ¨äº _source ä¸­ } } } } ä¸indexåŒºåˆ«ï¼š ç´¢å¼•ä¸å­˜å‚¨ï¼šindexæ§åˆ¶å­—æ®µæ˜¯å¦å¯æœç´¢ï¼Œä½†ä¸å½±å“å­—æ®µæ˜¯å¦å­˜å‚¨åœ¨ _source ä¸­ã€‚enabledæ§åˆ¶å­—æ®µæ˜¯å¦è¢«ç´¢å¼•å’Œå­˜å‚¨ã€‚ å½±å“ï¼šè®¾ç½®index: falseï¼Œå­—æ®µä»ç„¶å­˜å‚¨åœ¨ _source ä¸­ï¼Œä½†ä¸å‚ä¸æœç´¢ã€‚è®¾ç½®enabled: falseï¼Œå­—æ®µæ—¢ä¸ç´¢å¼•ä¹Ÿä¸å­˜å‚¨ã€‚ ä½¿ç”¨åœºæ™¯ï¼šå¦‚æœä½ å¸Œæœ›å­—æ®µä¸å‚ä¸æœç´¢ä½†ä»ç„¶æƒ³ä¿ç•™å…¶åŸå§‹å€¼ï¼Œä½¿ç”¨index: falseã€‚å¦‚æœä½ ä¸å¸Œæœ›å­—æ®µä»¥ä»»ä½•å½¢å¼å‡ºç°åœ¨Elasticsearchä¸­ï¼Œä½¿ç”¨enabled: falseã€‚ store é»˜è®¤falseï¼Œå­—æ®µæ˜¯å¦é¢å¤–å­˜å‚¨ï¼Œå¦‚æœéœ€è¦æŸ¥è¯¢è·å–çš„å­—æ®µåªæ˜¯æ–‡æ¡£ä¸­çš„å°æ•°æ®ï¼Œè¿™äº›å­—æ®µå¯ä»¥storeï¼Œå‡å°‘IOã€‚è€Œä¸”è¿™ä¸ªå­˜å‚¨æ˜¯ç‹¬äº _source çš„å­˜å‚¨çš„ã€‚ storeå±æ€§ç”¨äºæ§åˆ¶å­—æ®µå€¼æ˜¯å¦åº”è¯¥è¢«ç‹¬ç«‹å­˜å‚¨ï¼Œè¿™æ„å‘³ç€å­—æ®µå€¼å¯ä»¥è¢«å•ç‹¬æ£€ç´¢ï¼Œè€Œä¸éœ€è¦ä»æ•´ä¸ªæ–‡æ¡£çš„ _source å­—æ®µä¸­æå–ã€‚ ä½œç”¨ï¼š ç‹¬ç«‹å­˜å‚¨ï¼šå¦‚æœå­—æ®µè¢«è®¾ç½®ä¸ºstore: trueï¼Œé‚£ä¹ˆè¯¥å­—æ®µçš„å€¼ä¼šè¢«ç‹¬ç«‹å­˜å‚¨åœ¨Elasticsearchä¸­ï¼Œè¿™æ„å‘³ç€ä½ å¯ä»¥é€šè¿‡å•ç‹¬çš„å­—æ®µæ£€ç´¢æ¥è·å–å®ƒçš„å€¼ã€‚ ä¸ç‹¬ç«‹å­˜å‚¨ï¼šå¦‚æœå­—æ®µè¢«è®¾ç½®ä¸ºstore: falseï¼ˆé»˜è®¤å€¼ï¼‰ï¼Œé‚£ä¹ˆè¯¥å­—æ®µçš„å€¼ä¸ä¼šç‹¬ç«‹å­˜å‚¨ï¼Œä½†å®ƒä»ç„¶ä¼šä½œä¸º _source çš„ä¸€éƒ¨åˆ†è¢«å­˜å‚¨ã€‚ ä½¿ç”¨åœºæ™¯ï¼š å½“ä½ ç»å¸¸éœ€è¦ä»Elasticsearchä¸­æ£€ç´¢ç‰¹å®šå­—æ®µçš„å€¼ï¼Œè€Œä¸éœ€è¦æ£€ç´¢æ•´ä¸ªæ–‡æ¡£æ—¶ï¼Œå°†storeå±æ€§è®¾ç½®ä¸ºtrueå¯ä»¥æé«˜æ£€ç´¢æ•ˆç‡ã€‚ å¦‚æœæ–‡æ¡£éå¸¸å¤§ï¼Œè€Œä½ åªéœ€è¦è®¿é—®å…¶ä¸­çš„å‡ ä¸ªå­—æ®µï¼Œé‚£ä¹ˆç‹¬ç«‹å­˜å‚¨è¿™äº›å­—æ®µå¯ä»¥èŠ‚çœç£ç›˜ç©ºé—´ï¼Œå› ä¸ºä½ ä¸éœ€è¦å­˜å‚¨æ•´ä¸ª _sourceã€‚ ç¤ºä¾‹ï¼š PUT /my_index { \u0026#34;mappings\u0026#34;: { \u0026#34;properties\u0026#34;: { \u0026#34;field1\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;text\u0026#34;, \u0026#34;store\u0026#34;: true // ç‹¬ç«‹å­˜å‚¨å­—æ®µå€¼ }, \u0026#34;field2\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;keyword\u0026#34;, \u0026#34;store\u0026#34;: false // é»˜è®¤å€¼ï¼Œä¸ç‹¬ç«‹å­˜å‚¨å­—æ®µå€¼ } } } } æ³¨æ„äº‹é¡¹ï¼š è®¾ç½®store: trueä¼šå¢åŠ Elasticsearchçš„å­˜å‚¨éœ€æ±‚ï¼Œå› ä¸ºæ¯ä¸ªå­—æ®µå€¼éƒ½éœ€è¦é¢å¤–å­˜å‚¨ã€‚ å³ä½¿å°†storeè®¾ç½®ä¸ºtrueï¼Œå¦‚æœindexè®¾ç½®ä¸ºfalseï¼Œè¯¥å­—æ®µä»ç„¶ä¸ä¼šè¢«ç´¢å¼•ï¼Œå› æ­¤æ— æ³•ç”¨äºæœç´¢ã€‚ å¦‚æœä½ ä¸éœ€è¦ä» _source ä¸­æ£€ç´¢æ•´ä¸ªæ–‡æ¡£ï¼Œè€Œæ˜¯åªéœ€è¦ç‰¹å®šçš„å‡ ä¸ªå­—æ®µï¼Œé‚£ä¹ˆç‹¬ç«‹å­˜å‚¨è¿™äº›å­—æ®µå¯ä»¥å‡å°‘ç½‘ç»œä¼ è¾“çš„æ•°æ®é‡ã€‚ doc_values é»˜è®¤trueï¼Œä¼˜åŒ–å­—æ®µæ’åºèšåˆè„šæœ¬è®¿é—®ï¼Œè€—ç”¨ç£ç›˜ç©ºé—´ã€‚ fields å¤šå­—æ®µç‰¹æ€§ã€‚è®©ä¸€ä¸ªå­—æ®µæ‹¥æœ‰å¤šä¸ªå­å­—æ®µç±»å‹ï¼Œä½¿å¾—ä¸€ä¸ªå­—æ®µèƒ½å¤Ÿè¢«å¤šä¸ªä¸åŒçš„ç´¢å¼•æ–¹å¼è¿›è¡Œç´¢å¼•ã€‚ norms é»˜è®¤ä¸ºtrueï¼Œæ˜¯å¦æ”¯æŒè¯„åˆ†ï¼Œå¦‚æœå­—æ®µåªç”¨æ¥è¿‡æ»¤å’Œèšåˆåˆ†æï¼Œè€Œä¸éœ€è¦è¢«è¯„åˆ†ï¼Œé‚£ä¹ˆå¯ä»¥è®¾ç½®ä¸ºfalseï¼› type ä¸º text æ—¶ï¼Œé»˜è®¤ä¸º trueï¼›è€Œ type ä¸º keyword æ—¶ï¼Œé»˜è®¤ä¸º falseã€‚ analyzer æŒ‡å®šç´¢å¼•å’Œæœç´¢æ—¶çš„åˆ†æå™¨ï¼Œå¦‚æœåŒæ—¶æŒ‡å®š search_analyzer åˆ™æœç´¢æ—¶ä¼šä¼˜å…ˆä½¿ç”¨ search_analyzerã€‚ search_analyzer æŒ‡å®šæœç´¢æ—¶çš„åˆ†æå™¨ï¼Œæœç´¢æ—¶çš„ä¼˜å…ˆçº§æœ€é«˜ã€‚ fielddata é»˜è®¤falseï¼Œé’ˆå¯¹textç±»å‹æ’åºã€èšåˆã€è„šæœ¬è®¿é—®ä¼˜åŒ–ï¼Œå°½é‡é¿å…ï¼Œæ“ä½œæ˜‚è´µã€‚ index_options ç”¨äºè®¾ç½®å€’æ’ï¼ˆç´¢å¼•ï¼‰åˆ—è¡¨åŒ…å«çš„ä¿¡æ¯ï¼Œè¿™äº›ä¿¡æ¯ç”¨äºæœç´¢ï¼ˆSearchï¼‰å’Œé«˜äº®æ˜¾ç¤ºï¼š docsï¼šåªç´¢å¼•æ–‡æ¡£ç¼–å·(Doc Number)ï¼› freqsï¼šç´¢å¼•æ–‡æ¡£ç¼–å·å’Œè¯é¢‘ç‡ï¼ˆterm frequencyï¼‰ï¼› positionsï¼šç´¢å¼•æ–‡æ¡£ç¼–å·ï¼Œè¯é¢‘ç‡å’Œè¯ä½ç½®ï¼ˆåºå·ï¼‰ï¼› offsetsï¼šç´¢å¼•æ–‡æ¡£ç¼–å·ï¼Œè¯é¢‘ç‡ï¼Œè¯åç§»é‡ï¼ˆå¼€å§‹å’Œç»“æŸä½ç½®ï¼‰å’Œè¯ä½ç½®ï¼ˆåºå·ï¼‰ã€‚ é»˜è®¤æƒ…å†µä¸‹ï¼Œè¢«åˆ†è¯çš„å­—ç¬¦ä¸²ï¼ˆanalyzed stringï¼‰å­—æ®µä½¿ç”¨ positionsï¼Œå…¶ä»–å­—æ®µé»˜è®¤ä½¿ç”¨ docsã€‚ æ­¤å¤–ï¼Œéœ€è¦æ³¨æ„çš„æ˜¯ index_option æ˜¯ elasticsearch ç‰¹æœ‰çš„è®¾ç½®å±æ€§ï¼›ä¸´è¿‘æœç´¢å’ŒçŸ­è¯­æŸ¥è¯¢æ—¶ï¼Œindex_option å¿…é¡»è®¾ç½®ä¸º offsetsï¼ŒåŒæ—¶é«˜äº®ä¹Ÿå¯ä½¿ç”¨ postings highlighterã€‚è®°å½•å†…å®¹è¶Šå¤šï¼Œå ç”¨å­˜å‚¨ç©ºé—´è¶Šå¤§ã€‚ type å­—ç¬¦ä¸²ç±»å‹ text ä¼šåšåˆ†è¯å¤„ç†ï¼Œå¦‚æœä¸€ä¸ªå­—æ®µè¦è¢«å…¨æ–‡æœç´¢ï¼Œåº”è¯¥ä½¿ç”¨textç±»å‹ã€‚ è®¾ç½® text ç±»å‹åï¼Œå­—æ®µå†…å®¹ä¼šè¢«åˆ†æï¼Œåœ¨ç”Ÿæˆå€’æ’ç´¢å¼•å‰ï¼Œå­—ç¬¦ä¸²ä¼šè¢«åˆ†è¯å™¨åˆ†æˆä¸€ä¸ªä¸ªè¯æ¡ã€‚ textç±»å‹çš„å­—æ®µä¸ç”¨äºæ’åºï¼Œä¸”å¾ˆå°‘ç”¨äºèšåˆ(Terms Aggregationé™¤å¤–)ã€‚ keyword ä¸ä¼šåšåˆ†è¯å¤„ç†ï¼Œåªèƒ½é€šè¿‡ç²¾ç¡®å€¼æœç´¢åˆ°ã€‚ è¯¥ç±»å‹é€‚ç”¨äºç´¢å¼•ç»“æ„åŒ–çš„å­—æ®µï¼Œé€šå¸¸ç”¨äºè¿‡æ»¤ã€æ’åºã€èšåˆã€‚ æ³¨æ„ï¼šES5ä»¥åï¼Œä¸æ¨èä½¿ç”¨stringç±»å‹ã€‚ æ•°å­—ç±»å‹ å¯¹äºæ•°å­—ç±»å‹çš„å­—æ®µï¼Œåœ¨æ»¡è¶³éœ€æ±‚æƒ…å†µä¸‹ï¼Œå°½é‡é€‰æ‹©èŒƒå›´å°çš„æ•°æ®ç±»å‹ã€‚ å­—æ®µçš„é•¿åº¦è¶ŠçŸ­ï¼Œæœå› å’Œæœç´¢çš„æ•ˆç‡è¶Šé«˜ã€‚ å¯¹äºæµ®ç‚¹æ•°æ¥è¯´, ä¼˜å…ˆè€ƒè™‘ä½¿ç”¨ scaled_float ç±»å‹ã€‚ scaled_float æ˜¯é€šè¿‡ç¼©æ”¾å› å­æŠŠæµ®ç‚¹æ•°å˜æˆ long ç±»å‹ï¼Œæ¯”å¦‚ä»·æ ¼åªéœ€è¦ç²¾ç¡®åˆ°åˆ†ï¼Œprice å­—æ®µçš„å–å€¼ä¸º 57.34ï¼Œè®¾ç½®æ”¾å¤§å› å­ä¸º 100ï¼Œå­˜å‚¨èµ·æ¥å°±æ˜¯ 5734ã€‚ æ‰€æœ‰çš„ API éƒ½ä¼šæŠŠ price çš„å–å€¼å½“ä½œæµ®ç‚¹æ•°ï¼Œäº‹å®ä¸Š Elasticsearch åº•å±‚å­˜å‚¨çš„æ˜¯æ•´æ•°ç±»å‹ï¼Œå› ä¸ºå‹ç¼©æ•´æ•°æ¯”å‹ç¼©æµ®ç‚¹æ•°æ›´åŠ èŠ‚çœå­˜å‚¨ç©ºé—´ \u0026mdash;\u0026mdash;-ç±»å‹\u0026mdash;\u0026mdash;- \u0026mdash;\u0026mdash;-å–å€¼èŒƒå›´\u0026mdash;\u0026mdash;- è¯´æ˜ byte -128 ~ 127 æ— ç¬¦å·1å­—èŠ‚ short -32768 ~ 32767 æ— ç¬¦å·2å­—èŠ‚ integer -2^31 ~ 2^31-1 æ— ç¬¦å·4å­—èŠ‚ long -2^63 ~ 2^63-1 æ— ç¬¦å·8å­—èŠ‚ double 64ä½åŒç²¾åº¦IEE754æµ®ç‚¹ç±»å‹ åŒç²¾åº¦æµ®ç‚¹8å­—èŠ‚ float 32ä½å•ç²¾åº¦IEE754æµ®ç‚¹ç±»å‹ å•ç²¾åº¦æµ®ç‚¹4å­—èŠ‚ half_float 16ä½åŠç²¾åº¦IEE754æµ®ç‚¹ç±»å‹ 2å­—èŠ‚ scaled_float ç¼©æ”¾ç±»å‹æµ®ç‚¹æ•° 8å­—èŠ‚ æ—¥æœŸç±»å‹ date åœ¨ ES ä¸­çš„æ—¥æœŸå¯ä»¥æ˜¯ä»¥ä¸‹å‡ ç§å½¢å¼ï¼š æ ¼å¼åŒ–æ—¥æœŸçš„å­—ç¬¦ä¸²ï¼Œå¦‚ â€œ2015-01-01â€ æˆ– â€œ2015/01/01 12:10:30â€ æ¯«ç§’æ—¶é—´æˆ³ ç§’çº§æ—¶é—´æˆ³ éœ€è¦æ³¨æ„çš„æ˜¯ï¼ŒESå†…éƒ¨ä¼šæŠŠæ—¥æœŸè½¬æ¢ä¸º UTCï¼ˆä¸–ç•Œæ ‡å‡†æ—¶é—´ï¼‰ï¼Œå¹¶å°†å…¶å­˜å‚¨ä¸ºæ¯«ç§’æ—¶é—´æˆ³ï¼Œè¿™æ ·åšçš„åŸå› æ˜¯å’Œå­—ç¬¦ä¸²ç›¸æ¯”ï¼Œæ•°å€¼åœ¨å­˜å‚¨å’Œå¤„ç†æ—¶æ›´å¿«ã€‚ å¸ƒå°”ç±»å‹ boolean å¦‚æœä¸€ä¸ªå­—æ®µæ˜¯å¸ƒå°”ç±»å‹ï¼Œå¯æ¥å—çš„å€¼ä¸º trueã€falseã€‚ Elasticsearch 5.4 ç‰ˆæœ¬ä»¥å‰ï¼Œå¯ä»¥æ¥å—è¢«è§£é‡Šä¸º true æˆ– false çš„å­—ç¬¦ä¸²å’Œæ•°å­—ï¼Œ5.4 ç‰ˆæœ¬ä»¥ååªæ¥å— trueã€falseã€â€trueâ€ã€â€falseâ€ã€‚ äºŒè¿›åˆ¶ç±»å‹ binary binary ç±»å‹æ•°æ®æ ¼å¼ä¸ºbase64 ç¼–ç çš„å­—ç¬¦ä¸²ï¼Œé»˜è®¤ã€Œä¸é¢å¤–å­˜å‚¨ï¼Œä¹Ÿä¸å¯æœç´¢ã€ã€‚ èŒƒå›´ç±»å‹ range integer_range -2^31 è‡³ 2^31-1 long_range -2^63 è‡³ 2^63-1 float_range 32-bit IEEE 754 double_range 64-bit IEEE 754 date_range 64 ä½æ•´æ•°ï¼Œæ¯«ç§’è®¡æ—¶ æ•°ç»„ç±»å‹ ESä¸­æ²¡æœ‰ä¸“ç”¨çš„æ•°ç»„ç±»å‹ï¼Œé»˜è®¤æƒ…å†µä¸‹ä»»ä½•å­—æ®µéƒ½å¯ä»¥åŒ…å«0ä¸ªæˆ–è€…å¤šä¸ªå€¼ï¼Œä½†æ˜¯ä¸€ä¸ªæ•°ç»„ä¸­çš„å€¼å¿…é¡»æ˜¯åŒä¸€ç§ç±»å‹ã€‚ æ•´å‹æ•°ç»„ï¼š[1,3] åµŒå¥—æ•°ç»„ï¼š[1,[2,3]]ï¼Œç­‰ä»·äº [1,2,3] å¯¹è±¡æ•°ç»„: [{\u0026ldquo;name\u0026rdquo;: \u0026ldquo;lili\u0026rdquo;, \u0026ldquo;age\u0026rdquo;: \u0026ldquo;18\u0026rdquo;}, {\u0026ldquo;name\u0026rdquo;: \u0026ldquo;liming\u0026rdquo;, \u0026ldquo;age\u0026rdquo;: \u0026ldquo;20\u0026rdquo;} ] åŠ¨æ€æ·»åŠ æ•°æ®æ—¶ï¼Œæ•°ç»„çš„ç¬¬ä¸€ä¸ªå€¼çš„ç±»å‹å†³å®šæ•´ä¸ªæ•°ç»„çš„ç±»å‹ã€‚æ··åˆæ•°ç»„ç±»å‹æ˜¯ä¸æ”¯æŒçš„ï¼Œæ¯”å¦‚ï¼š[1ï¼Œâ€abcâ€]ã€‚ æ•°ç»„å¯ä»¥åŒ…å« null å€¼ï¼Œç©ºæ•°ç»„[ ]ä¼šè¢«å½“ä½œ missing field å¯¹å¾…ã€‚åœ¨æ–‡æ¡£ä¸­ä½¿ç”¨ array ç±»å‹ä¸éœ€è¦æå‰åšä»»ä½•é…ç½®ï¼Œé»˜è®¤æ”¯æŒ å¯¹è±¡ç±»å‹ å¯¹è±¡ç±»å‹å¾ˆå¥½ç†è§£ï¼Œå³JSONå¯¹è±¡ï¼Œéœ€è¦æ³¨æ„çš„æ˜¯ï¼Œesä¸­ä¼šå¯¹åµŒå¥—çš„JSONå¯¹è±¡åšæ‰å¹³åŒ–å¤„ç†ã€‚ ä¾‹å¦‚å¦‚ä¸‹æ•°æ®: { \u0026#34;name\u0026#34;:\u0026#34;lili\u0026#34;, \u0026#34;friend\u0026#34;:[ \u0026#34;name\u0026#34;:\u0026#34;xiaohong\u0026#34; ] } // å­˜å‚¨çš„æ—¶å€™å˜æˆè¿™æ ·: { \u0026#34;name\u0026#34;:\u0026#34;lili\u0026#34;, \u0026#34;friend.name\u0026#34;:\u0026#34;xiaohong\u0026#34; } åµŒå¥—ç±»å‹ åµŒå¥—ç±»å‹æ˜¯ä¸€ç§ç‰¹æ®Šçš„å¯¹è±¡ç±»å‹ï¼Œesæœ¬èº«ä¼šå¯¹å¯¹è±¡ç±»å‹å­—æ®µåšæ‰å¹³åŒ–å¤„ç†ï¼Œé‚£ä¹ˆå½“å­˜å‚¨çš„å¯¹è±¡ç±»å‹ä¸ºå¯¹è±¡æ•°ç»„æ—¶ï¼Œä¼šå‡ºç°å…³è”å…³ç³»å¤±æ•ˆçš„æƒ…å†µã€‚ { \u0026#34;name\u0026#34;:\u0026#34;lili\u0026#34;, \u0026#34;friends\u0026#34;:[ { \u0026#34;name\u0026#34;:\u0026#34;xiaohong\u0026#34;, \u0026#34;age\u0026#34;: 18 }, { \u0026#34;name\u0026#34;:\u0026#34;xiaoming\u0026#34;, \u0026#34;age\u0026#34;: 20 } ] } // å¤„ç†å: { \u0026#34;name\u0026#34;:\u0026#34;lili\u0026#34;, \u0026#34;friends.name\u0026#34;:[\u0026#34;xiaohong\u0026#34;,\u0026#34;xiaoming\u0026#34;], \u0026#34;friend.age\u0026#34;:[18, 20] } IPç±»å‹ ip ç±»å‹çš„å­—æ®µç”¨äºå­˜å‚¨ IPv4 æˆ–è€… IPv6 çš„åœ°å€ã€‚å¦‚â€192.168.1.1â€æˆ–â€192.168.0.0/16â€ã€‚ ä»¤ç‰Œè®¡æ•°ç±»å‹ (token_count) token_count ç”¨äºç»Ÿè®¡textåˆ†è¯åçš„è¯æ¡ä¸ªæ•°ï¼Œæœ¬è´¨ä¸Šæ˜¯ä¸€ä¸ªæ•´æ•°å‹å­—æ®µã€‚ä¸¾ä¸ªä¾‹å­ï¼Œæ˜ å°„ä¸­æŒ‡å®š name ä¸º text ç±»å‹ï¼Œå¢åŠ name.length å­—æ®µç”¨äºç»Ÿè®¡åˆ†è¯åè¯é¡¹çš„é•¿åº¦ï¼Œç±»å‹ä¸º token_countï¼Œåˆ†è¯å™¨ä¸ºæ ‡å‡†åˆ†è¯å™¨ï¼Œå‘½ä»¤å¦‚ä¸‹ï¼š { \u0026#34;mappings\u0026#34;: { \u0026#34;my_type\u0026#34;: { \u0026#34;properties\u0026#34;: { \u0026#34;name\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;text\u0026#34;, \u0026#34;fields\u0026#34;: { \u0026#34;length\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;token_count\u0026#34;, \u0026#34;analyzer\u0026#34;: \u0026#34;standard\u0026#34; } } } } } } } ç´¢å¼•åº“çš„CRUD åˆ›å»º åŸºæœ¬è¯­æ³•ï¼š è¯·æ±‚æ–¹æ³•ï¼šPUT è¯·æ±‚è·¯å¾„ï¼š/ç´¢å¼•åç§° è¯·æ±‚å‚æ•°ï¼šmapping æœ‰è¿™æ ·ä¸€æ¡æ–‡æ¡£ï¼Œéœ€è¦åˆ›å»ºç´¢å¼•ã€‚ ageï¼šç±»å‹ä¸º byteï¼›å‚ä¸æœç´¢ï¼Œå› æ­¤éœ€è¦indexä¸ºtrueï¼›æ— éœ€åˆ†è¯å™¨ã€‚ weightï¼šç±»å‹ä¸ºfloatï¼›å‚ä¸æœç´¢ï¼Œå› æ­¤éœ€è¦indexä¸ºtrueï¼›æ— éœ€åˆ†è¯å™¨ã€‚ isMarriedï¼šç±»å‹ä¸ºbooleanï¼›å‚ä¸æœç´¢ï¼Œå› æ­¤éœ€è¦indexä¸ºtrueï¼›æ— éœ€åˆ†è¯å™¨ã€‚ infoï¼šç±»å‹ä¸ºå­—ç¬¦ä¸²ï¼Œéœ€è¦åˆ†è¯ï¼Œå› æ­¤æ˜¯textï¼›å‚ä¸æœç´¢ï¼Œå› æ­¤éœ€è¦indexä¸ºtrueï¼›åˆ†è¯å™¨å¯ä»¥ç”¨ik_smartã€‚ emailï¼šç±»å‹ä¸ºå­—ç¬¦ä¸²ï¼Œä½†æ˜¯ä¸éœ€è¦åˆ†è¯ï¼Œå› æ­¤æ˜¯keywordï¼›ä¸å‚ä¸æœç´¢ï¼Œå› æ­¤éœ€è¦indexä¸ºfalseï¼›æ— éœ€åˆ†è¯å™¨ã€‚ scoreï¼šè™½ç„¶æ˜¯æ•°ç»„ï¼Œä½†æ˜¯æˆ‘ä»¬åªçœ‹å…ƒç´ çš„ç±»å‹ï¼Œç±»å‹ä¸ºfloatï¼›å‚ä¸æœç´¢ï¼Œå› æ­¤éœ€è¦indexä¸ºtrueï¼›æ— éœ€åˆ†è¯å™¨ã€‚ nameï¼šç±»å‹ä¸ºobjectï¼Œéœ€è¦å®šä¹‰å¤šä¸ªå­å±æ€§ name.firstNameï¼›ç±»å‹ä¸ºå­—ç¬¦ä¸²ï¼Œä½†æ˜¯ä¸éœ€è¦åˆ†è¯ï¼Œå› æ­¤æ˜¯keywordï¼›å‚ä¸æœç´¢ï¼Œå› æ­¤éœ€è¦indexä¸ºtrueï¼›æ— éœ€åˆ†è¯å™¨ã€‚ name.lastNameï¼›ç±»å‹ä¸ºå­—ç¬¦ä¸²ï¼Œä½†æ˜¯ä¸éœ€è¦åˆ†è¯ï¼Œå› æ­¤æ˜¯keywordï¼›å‚ä¸æœç´¢ï¼Œå› æ­¤éœ€è¦indexä¸ºtrueï¼›æ— éœ€åˆ†è¯å™¨ã€‚ æ³¨æ„ï¼šæ‰€æœ‰çš„ç´¢å¼•åéƒ½å¿…é¡»è¦å°å†™ã€‚ { \u0026#34;age\u0026#34;:Â 21, \u0026#34;weight\u0026#34;:Â 52.4, \u0026#34;isMarried\u0026#34;:Â false, \u0026#34;info\u0026#34;:Â \u0026#34;ç¾å¥½çš„ä¸€å¤©ä»æ¸…æ™¨å¼€å§‹\u0026#34;, \u0026#34;email\u0026#34;:Â \u0026#34;123456@qq.cn\u0026#34;, \u0026#34;score\u0026#34;:Â [99.1, 95.5, 98.9], \u0026#34;name\u0026#34;:Â { \u0026#34;firstName\u0026#34;:Â \u0026#34;ä¸‰\u0026#34;, \u0026#34;lastName\u0026#34;:Â \u0026#34;å¼ \u0026#34; } } åˆ›å»ºdemoã€‚ PUT /users { \u0026#34;aliases\u0026#34;: { \u0026#34;alias_users\u0026#34;: {} }, \u0026#34;settings\u0026#34;: { \u0026#34;index.number_of_shards\u0026#34;: 1, \u0026#34;index.number_of_replicas\u0026#34;: 0, \u0026#34;index.refresh_interval\u0026#34;: \u0026#34;3s\u0026#34;, \u0026#34;index.max_result_window\u0026#34;: 1000 }, \u0026#34;mappings\u0026#34;: { \u0026#34;properties\u0026#34;: { \u0026#34;age\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;byte\u0026#34; }, \u0026#34;weight\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;float\u0026#34; }, \u0026#34;isMarried\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;boolean\u0026#34; }, \u0026#34;info\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;text\u0026#34;, \u0026#34;analyzer\u0026#34;: \u0026#34;ik_smart\u0026#34;, \u0026#34;search_analyzer\u0026#34;: \u0026#34;ik_max_word\u0026#34; }, \u0026#34;email\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;keyword\u0026#34;, \u0026#34;index\u0026#34;: \u0026#34;false\u0026#34; }, \u0026#34;score\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;float\u0026#34; }, \u0026#34;name\u0026#34;: { \u0026#34;properties\u0026#34;: { \u0026#34;firstName\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;keyword\u0026#34;, \u0026#34;index\u0026#34;: \u0026#34;false\u0026#34; }, \u0026#34;lastName\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;keyword\u0026#34;, \u0026#34;index\u0026#34;: \u0026#34;false\u0026#34; } } } } } } æŸ¥è¯¢ åŸºæœ¬è¯­æ³•ï¼š è¯·æ±‚æ–¹æ³•ï¼šGET è¯·æ±‚è·¯å¾„ï¼š/ç´¢å¼•åç§° è¯·æ±‚å‚æ•°ï¼šæ—  GET /users ä¿®æ”¹ åŸºæœ¬è¯­æ³•ï¼š\nè¯·æ±‚æ–¹æ³•ï¼šPUT è¯·æ±‚è·¯å¾„ï¼š/ç´¢å¼•åç§°/_mapping è¯·æ±‚å‚æ•°ï¼špropertiesã€‚ å€’æ’ç´¢å¼•ç»“æ„è™½ç„¶ä¸å¤æ‚ï¼Œä½†æ˜¯ä¸€æ—¦æ•°æ®ç»“æ„æ”¹å˜ï¼ˆæ¯”å¦‚æ”¹å˜äº†åˆ†è¯å™¨ï¼‰ï¼Œå°±éœ€è¦é‡æ–°åˆ›å»ºå€’æ’ç´¢å¼•ï¼Œè¿™ç®€ç›´æ˜¯ç¾éš¾ã€‚å› æ­¤ç´¢å¼•åº“ä¸€æ—¦åˆ›å»ºï¼Œæ— æ³•ä¿®æ”¹mappingã€‚\nè™½ç„¶æ— æ³•ä¿®æ”¹mappingä¸­å·²æœ‰çš„å­—æ®µï¼Œä½†æ˜¯å´å…è®¸æ·»åŠ æ–°çš„å­—æ®µåˆ°mappingä¸­ï¼Œå› ä¸ºä¸ä¼šå¯¹å€’æ’ç´¢å¼•äº§ç”Ÿå½±å“ã€‚\nPUT /users/_mapping { \u0026#34;properties\u0026#34;: { \u0026#34;score\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;float\u0026#34; } } } åˆ é™¤ åŸºæœ¬è¯­æ³•ï¼š è¯·æ±‚æ–¹æ³•ï¼šDELETE è¯·æ±‚è·¯å¾„ï¼š/ç´¢å¼•åç§° è¯·æ±‚å‚æ•°ï¼šæ—  DELETE /users ","permalink":"https://heliu.site/posts/elasticsearch/mapping/","summary":"ç´¢å¼•çš„åˆ›å»ºã€ä¿®æ”¹ã€åˆ é™¤ã€‚","title":"Mappings"},{"content":" settingå±æ€§ç”¨äºè®¾ç½®å½“å‰ç´¢å¼•çš„åˆ†ç‰‡æ•°ï¼Œå‰¯æœ¬æ•°ç­‰ä¿¡æ¯,å¸¸ç”¨çš„ä¸»è¦æœ‰ï¼š index.number_of_shardsï¼šç´¢å¼•åˆ†ç‰‡æ•°ã€‚ index.number_of_replicasï¼šç´¢å¼•å‰¯æœ¬æ•°ã€‚ index.refresh_intervalï¼šrefreshé¢‘ç‡ï¼Œé»˜è®¤1sã€‚å½“æ•°æ®å¯¹å®æ—¶åˆ·æ–°è¦æ±‚ä¸é‚£ä¹ˆé«˜æ—¶ï¼Œå¯ä»¥é€‚å½“è°ƒå¤§æ”¹å€¼ã€‚å½“å€¼=-1æ—¶ï¼Œä»£è¡¨ä¸ä¼šè¿›è¡Œrefreshæ“ä½œï¼Œä½†æ˜¯è¯·ä¿è¯esçš„è™šæ‹Ÿæœºå†…å­˜è¶³å¤Ÿå¤§ï¼Œä¸ç„¶ä¼šé€ æˆå†…å­˜æº¢å‡º ä½¿ç”¨ç¤ºä¾‹ï¼š 1 2 3 4 5 6 7 8 9 10 PUT class_1 { \u0026#34;settings\u0026#34;: { \u0026#34;index\u0026#34;: { \u0026#34;number_of_shards\u0026#34;: 3, \u0026#34;number_of_replicas\u0026#34;: 1, \u0026#34;refresh_interval\u0026#34;: \u0026#34;3s\u0026#34; } } } ESçš„settingsåˆ†ä¸ºé™æ€è®¾ç½®å’ŒåŠ¨æ€è®¾ç½®ä¸¤ç§ã€‚ å¸¸ç”¨è®¾ç½®æ ‡è®°æˆğŸˆã€‚ é™æ€è®¾ç½® åªèƒ½åœ¨ç´¢å¼•åˆ›å»ºæ—¶è®¾ç½®ï¼Œæˆ–è€…åœ¨å·²å…³é—­çš„ç´¢å¼•ä¸Šè®¾ç½®ã€‚é™æ€è®¾ç½®åœ¨åˆ›å»ºç´¢å¼•æ—¶æŒ‡å®šã€‚ number_of_shardsğŸˆ ç´¢å¼•åº”å…·æœ‰çš„ä¸»åˆ†ç‰‡æ•°ï¼Œé»˜è®¤å€¼ä¸º1ã€‚ESæ”¯æŒçš„æœ€å¤§åˆ†ç‰‡æ•°é»˜è®¤ä¸º1024ï¼Œå¯ä»¥é€šè¿‡ä¿®æ”¹index.max_number_of_shardså±æ€§ä¿®æ”¹ã€‚ è¯¥å€¼ç”¨äºæŒ‡å®šåˆ†ç‰‡æ•°é‡ï¼Œä¹Ÿå°±æ˜¯å½“å‰ç´¢å¼•åˆ›å»ºå‡ ä¸ªä¸»åˆ†ç‰‡ç´¢å¼•ã€‚number_of_shardså€¼ä¸æ¨èè¿‡å¤§ï¼Œæ¨è5~10ã€‚ 1 2 3 4 5 6 PUT /test { \u0026#34;settings\u0026#34;: { \u0026#34;index.number_of_shards\u0026#34;: 1 } } shard.check_on_startup åˆ†ç‰‡åœ¨æ‰“å¼€ä¹‹å‰æ˜¯å¦æ£€æŸ¥è¯¥åˆ†ç‰‡æ˜¯å¦æŸåã€‚å½“æ£€æµ‹åˆ°åˆ†ç‰‡æŸåæ—¶ï¼Œå°†é˜»æ­¢æ‰“å¼€ã€‚ å¯é€‰å€¼ï¼š falseï¼šä¸æ£€æµ‹ï¼Œé»˜è®¤å€¼ã€‚ checksumï¼šåªæ£€æŸ¥ç‰©ç†ç»“æ„ã€‚ trueï¼šæ£€æŸ¥ç‰©ç†ç»“æ„å’Œè·¯åŸºæŸåï¼Œç›¸å¯¹æ¯”è¾ƒæ¶ˆè€—CPUã€‚ fixï¼šç±»åŒfalseï¼Œ7.0ç‰ˆæœ¬åå°†åºŸå¼ƒã€‚ 1 2 3 4 5 6 PUT /test { \u0026#34;settings\u0026#34;: { \u0026#34;index.shard.check_on_startup\u0026#34;: false } } number_of_routing_shards routing_partition_size è·¯ç”±åˆ†åŒºæ•°ï¼Œå¦‚æœè®¾ç½®äº†è¯¥å‚æ•°ï¼Œå…¶è·¯ç”±ç®—æ³•ä¸ºï¼š (hash(_routing) + hash(_id) % index.routing_parttion_size ) % number_of_shards å¦‚æœæ²¡æœ‰è®¾ç½®ï¼Œè·¯ç”±ç®—æ³•ä¸ºï¼š_routingé»˜è®¤å€¼ä¸º_idã€‚ hash(_routing) % number_of_shardings codec æ•°æ®å­˜å‚¨çš„å‹ç¼©ç®—æ³•ï¼Œé»˜è®¤å€¼LZ4ï¼Œå¯é€‰å€¼best_compressionï¼Œæ¯”LZ4å¯ä»¥è·å¾—æ›´å¥½çš„å‹ç¼©æ¯”ä¾‹(å ç”¨è¾ƒå°çš„ç£ç›˜ç©ºé—´ï¼Œä½†æ˜¯å­˜å‚¨æ€§èƒ½æ¯”LZ4ä½)ã€‚ 1 2 3 4 5 6 PUT /test { \u0026#34;settings\u0026#34;: { \u0026#34;index.codec\u0026#34;: \u0026#34;LZ4\u0026#34; } } åŠ¨æ€è®¾ç½® number_of_replicasğŸˆ æ¯ä¸ªä¸»åˆ†ç‰‡çš„å‰¯æœ¬æ•°ï¼Œé»˜è®¤ä¸º 1ï¼Œè¯¥å€¼å¿…é¡»å¤§äºç­‰äº0ï¼Œåˆ›å»ºç´¢å¼•åè¯¥å€¼å¯ä»¥å˜æ›´ã€‚ å‰¯æœ¬çš„æ•°é‡å€¼ä¸å®œè¿‡å¤§ã€‚ 1 2 3 4 5 6 7 PUT /test { \u0026#34;settings\u0026#34;: { \u0026#34;index.number_of_shards\u0026#34;: 5, \u0026#34;index.number_of_replicas\u0026#34;: 2 } } auto_expand_replicas åŸºäºå¯ç”¨èŠ‚ç‚¹çš„æ•°é‡è‡ªåŠ¨åˆ†é…å‰¯æœ¬æ•°é‡,é»˜è®¤ä¸º falseï¼ˆå³ç¦ç”¨æ­¤åŠŸèƒ½ï¼‰,å¯è®¾ç½®ä¸ºï¼š0-allã€‚ 1 2 3 4 5 6 7 8 PUT /test { \u0026#34;settings\u0026#34;: { \u0026#34;index.number_of_shards\u0026#34;: 5, \u0026#34;index.number_of_replicas\u0026#34;: 2, \u0026#34;index.auto_expand_replicas\u0026#34;: false } } refresh_intervalğŸˆ æ‰§è¡Œåˆ·æ–°æ“ä½œçš„é¢‘ç‡ï¼Œè¿™ä½¿å¾—ç´¢å¼•çš„æœ€è¿‘æ›´æ”¹å¯ä»¥è¢«æœç´¢ã€‚é»˜è®¤ä¸º 1sã€‚å¯ä»¥è®¾ç½®ä¸º -1 ä»¥ç¦ç”¨åˆ·æ–°ã€‚ 1 2 3 4 5 6 7 8 PUT /test { \u0026#34;settings\u0026#34;: { \u0026#34;index.number_of_shards\u0026#34;: 5, \u0026#34;index.number_of_replicas\u0026#34;: 2, \u0026#34;index.refresh_interval\u0026#34;: \u0026#34;1s\u0026#34; } } max_result_windowğŸˆ ç”¨äºç´¢å¼•æœç´¢çš„ from+size çš„æœ€å¤§å€¼ã€‚é»˜è®¤ä¸º 10000ã€‚ 1 2 3 4 5 6 7 8 9 PUT /test { \u0026#34;settings\u0026#34;: { \u0026#34;index.number_of_shards\u0026#34;: 5, \u0026#34;index.number_of_replicas\u0026#34;: 2, \u0026#34;index.refresh_interval\u0026#34;: \u0026#34;1s\u0026#34;, \u0026#34;index.max_result_window\u0026#34;: 1000 } } max_inner_result_window ç”¨äºæ§åˆ¶top aggregationsï¼Œé»˜è®¤100ã€‚å†…éƒ¨å‘½ä¸­å’Œé¡¶éƒ¨å‘½ä¸­èšåˆå ç”¨å †å†…å­˜ï¼Œå¹¶ä¸”æ—¶é—´ä¸from+sizeæˆæ­£æ¯”ï¼Œè¿™é™åˆ¶äº†å†…å­˜ã€‚ 1 2 3 4 5 6 7 8 9 10 PUT /test { \u0026#34;settings\u0026#34;: { \u0026#34;index.number_of_shards\u0026#34;: 5, \u0026#34;index.number_of_replicas\u0026#34;: 2, \u0026#34;index.refresh_interval\u0026#34;: \u0026#34;1s\u0026#34;, \u0026#34;index.max_result_window\u0026#34;: 1000, \u0026#34;index.max_inner_result_window\u0026#34;: 100 } } max_rescore_window åœ¨æœç´¢æ­¤ç´¢å¼•ä¸­ rescore çš„ window_size çš„æœ€å¤§å€¼ã€‚ 1 2 3 4 5 6 7 8 9 PUT /test { \u0026#34;settings\u0026#34;: { \u0026#34;index.number_of_shards\u0026#34;: 5, \u0026#34;index.number_of_replicas\u0026#34;: 2, \u0026#34;index.refresh_interval\u0026#34;: \u0026#34;1s\u0026#34;, \u0026#34;index.max_rescore_window\u0026#34;: 100 } } max_docvalue_fields_search ä¸€æ¬¡æŸ¥è¯¢æœ€å¤šåŒ…å«å¼€å¯doc_valueså­—æ®µçš„ä¸ªæ•°ï¼Œé»˜è®¤ä¸º100ã€‚ 1 2 3 4 5 6 7 8 9 PUT /test { \u0026#34;settings\u0026#34;: { \u0026#34;index.number_of_shards\u0026#34;: 5, \u0026#34;index.number_of_replicas\u0026#34;: 2, \u0026#34;index.refresh_interval\u0026#34;: \u0026#34;1s\u0026#34;, \u0026#34;index.max_docvalue_fields_search\u0026#34;: 100 } } max_script_fields æŸ¥è¯¢ä¸­å…è®¸çš„æœ€å¤§script_fieldsæ•°é‡ã€‚é»˜è®¤ä¸º32ã€‚ 1 2 3 4 5 6 7 8 9 PUT /test { \u0026#34;settings\u0026#34;: { \u0026#34;index.number_of_shards\u0026#34;: 5, \u0026#34;index.number_of_replicas\u0026#34;: 2, \u0026#34;index.refresh_interval\u0026#34;: \u0026#34;1s\u0026#34;, \u0026#34;index.max_script_fields\u0026#34;: 32 } } max_ngram_diff NGramTokenizerå’ŒNGramTokenFilterçš„min_gramå’Œmax_gramä¹‹é—´å…è®¸çš„æœ€å¤§å·®å¼‚ã€‚é»˜è®¤ä¸º1ã€‚ 1 2 3 4 5 6 PUT /test { \u0026#34;settings\u0026#34;: { \u0026#34;index.max_ngram_diff\u0026#34;: 1 } } max_shingle_diff å¯¹äºShingleTokenFilter, max_shingle_sizeå’Œmin_shingle_sizeä¹‹é—´å…è®¸çš„æœ€å¤§å·®å¼‚ã€‚é»˜è®¤ä¸º3ã€‚ 1 2 3 4 5 6 PUT /test { \u0026#34;settings\u0026#34;: { \u0026#34;index.max_shingle_diff\u0026#34;: 3 } } blocks.read_only ç´¢å¼•æ•°æ®ã€ç´¢å¼•å…ƒæ•°æ®æ˜¯å¦åªè¯»ï¼Œå¦‚æœè®¾ç½®ä¸ºtrueï¼Œåˆ™ä¸èƒ½ä¿®æ”¹ç´¢å¼•æ•°æ®ï¼Œä¹Ÿä¸èƒ½ä¿®æ”¹ç´¢å¼•å…ƒæ•°æ®ã€‚ï¼Œfalse ä¸ºå…è®¸å†™å…¥å’Œå…ƒæ•°æ®æ›´æ”¹ã€‚ 1 2 3 4 5 6 PUT /test { \u0026#34;settings\u0026#34;: { \u0026#34;index.blocks.read_only\u0026#34;: false } } blocks.read_only_allow_delete ä¸index.blocks.read_onlyåŸºæœ¬ç±»ä¼¼ï¼Œå”¯ä¸€çš„åŒºåˆ«æ˜¯å…è®¸åˆ é™¤åŠ¨ä½œã€‚ 1 2 3 4 5 6 7 PUT /test { \u0026#34;settings\u0026#34;: { \u0026#34;index.blocks.read_only\u0026#34;: false, \u0026#34;index.blocks.read_only_allow_delete\u0026#34;: false } } blocks.read è®¾ç½®ä¸º true å¯ç¦ç”¨å¯¹ç´¢å¼•çš„è¯»å–æ“ä½œã€‚ 1 2 3 4 5 6 PUT /test { \u0026#34;settings\u0026#34;: { \u0026#34;index.blocks.read\u0026#34;: false } } blocks.write è®¾è®¾ç½®ä¸ºtrueä»¥ç¦ç”¨å¯¹ç´¢å¼•æ•°æ®çš„å†™æ“ä½œã€‚ï¼ˆé’ˆå¯¹ç´¢å¼•æ•°æ®ï¼Œè€Œä¸æ˜¯ç´¢å¼•å…ƒæ•°æ®ï¼‰ 1 2 3 4 5 6 PUT /test { \u0026#34;settings\u0026#34;: { \u0026#34;index.blocks.write\u0026#34;: false } } blocks.metadata è®¾ç½®ä¸ºtrueï¼Œè¡¨ç¤ºä¸å…è®¸å¯¹ç´¢å¼•å…ƒæ•°æ®è¿›è¡Œè¯»ä¸å†™ã€‚ 1 2 3 4 5 6 PUT /test { \u0026#34;settings\u0026#34;: { \u0026#34;index.blocks.metadata\u0026#34;: false } } max_refresh_listeners ç´¢å¼•çš„æ¯ä¸ªåˆ†ç‰‡ä¸Šå½“åˆ·æ–°ç´¢å¼•æ—¶æœ€å¤§çš„å¯ç”¨ç›‘å¬å™¨æ•°é‡ã€‚è¿™äº›ä¾¦å¬å™¨ç”¨äºå®ç°refresh=wait_forã€‚ 1 2 3 4 5 6 PUT /test { \u0026#34;settings\u0026#34;: { \u0026#34;index.max_refresh_listeners\u0026#34;: 1 } } highlight.max_analyzed_offset é«˜äº®æ˜¾ç¤ºçš„æœ€å¤§å­—ç¬¦æ•°ã€‚æ­¤è®¾ç½®ä»…åœ¨å¯¹æ²¡æœ‰åç§»æˆ–è¯å‘é‡çš„ç´¢å¼•çš„æ–‡æœ¬ä¸Šé€‚ç”¨ã€‚é»˜è®¤æƒ…å†µä¸‹ï¼Œæ­¤è®¾ç½®åœ¨6.xä¸­æœªè®¾ç½®ï¼Œé»˜è®¤ä¸º-1ã€‚ 1 2 3 4 5 6 PUT /test { \u0026#34;settings\u0026#34;: { \u0026#34;index.max_refresh_listeners\u0026#34;: -1 } } max_terms_count TermæŸ¥è¯¢ä¸­å¯ä»¥ä½¿ç”¨çš„æœ€å¤§Termæ•°ã€‚é»˜è®¤ä¸º65536ã€‚ 1 2 3 4 5 6 PUT /test { \u0026#34;settings\u0026#34;: { \u0026#34;index.max_terms_count\u0026#34;: 65536 } } routing.allocation.enable æ§åˆ¶æ­¤ç´¢å¼•çš„åˆ†ç‰‡åˆ†é…ï¼Œå¯é€‰å€¼ï¼š allï¼šé»˜è®¤ï¼Œå…è®¸åˆ†ç‰‡æ‰€æœ‰çš„åˆ†ç‰‡ primariesï¼šåªå…è®¸åˆ†é…ä¸»åˆ†ç‰‡ new_primariesï¼šä»…å…è®¸åˆ†é…æ–°åˆ›å»ºçš„ä¸»åˆ†ç‰‡ noneï¼šä¸å…è®¸åˆ†é… 1 2 3 4 5 6 PUT /test { \u0026#34;settings\u0026#34;: { \u0026#34;index.routing.allocation.enable\u0026#34;: \u0026#34;all\u0026#34; } } routing.rebalance.enable ä¸ºæ­¤ç´¢å¼•å¯ç”¨åˆ†ç‰‡é‡æ–°å¹³è¡¡ï¼Œå¯é€‰å€¼ï¼š allï¼šé»˜è®¤ï¼Œå…è®¸åˆ†ç‰‡é‡æ–°å¹³è¡¡ primariesï¼šåªå…è®¸ä¸»åˆ†ç‰‡é‡æ–°å¹³è¡¡ replicasï¼šåªå…è®¸å‰¯æœ¬åˆ†ç‰‡é‡æ–°å¹³è¡¡ noneï¼šä¸å…è®¸åˆ†ç‰‡é‡æ–°å¹³è¡¡ 1 2 3 4 5 6 PUT /test { \u0026#34;settings\u0026#34;: { \u0026#34;index.routing.rebalance.enable\u0026#34;: \u0026#34;all\u0026#34; } } gc_deletes å…è®¸å·²åˆ é™¤æ–‡æ¡£çš„ç‰ˆæœ¬å·ï¼Œæ‰”å¯ç”¨äºè¿›ä¸€æ­¥ç‰ˆæœ¬åŒ–æ“ä½œçš„æ—¶é—´é•¿åº¦ã€‚é»˜è®¤60sã€‚ 1 2 3 4 5 6 PUT /test { \u0026#34;settings\u0026#34;: { \u0026#34;index.gc_deletes\u0026#34;: \u0026#34;60s\u0026#34; } } max_regex_length Regexp Queryä¸­å¯ä»¥ä½¿ç”¨çš„æ­£åˆ™è¡¨è¾¾å¼çš„æœ€å¤§é•¿åº¦ï¼Œé»˜è®¤ä¸º1000ã€‚ 1 2 3 4 5 6 PUT /test { \u0026#34;settings\u0026#34;: { \u0026#34;index.max_regex_length\u0026#34;: 1000 } } mapping.coerce trueï¼šé»˜è®¤å€¼ï¼Œå¼ºåˆ¶ç±»å‹è½¬æ¢ï¼ŒæŠŠjsonä¸­çš„å€¼è½¬ä¸ºESä¸­å­—æ®µçš„æ•°æ®ç±»å‹ï¼Œè­¬å¦‚ï¼ŒæŠŠå­—ç¬¦ä¸²\u0026quot;5\u0026quot;è½¬ä¸ºintegerçš„5ã€‚ falseï¼šå½“jsonçš„å€¼ä¸ESå­—æ®µç±»å‹ä¸åŒ¹é…å°†ä¼šæ‹’ç»ã€‚ 1 2 3 4 5 6 PUT /test { \u0026#34;settings\u0026#34;: { \u0026#34;mapping.coerce\u0026#34;: true } } Merging max_thread_count å½“ä¸ªåˆ†ç‰‡èŠ‚ç‚¹åˆå¹¶çš„æœ€å¤§çº¿ç¨‹æ•°ï¼Œé»˜è®¤å€¼**Math.max(1, Math.min(4, Runtime.getRuntime().availableProcessors() / 2))**å¦‚æœæ˜¯éSSDç›˜ï¼Œå»ºè®®è®¾ç½®ä¸º1ã€‚ã€‚ 1 2 3 4 5 6 PUT /test { \u0026#34;settings\u0026#34;: { \u0026#34;index.merge.scheduler.max_thread_count\u0026#34;: 1 } } max_merged_segment æŒ‡å®šå•ä¸ªsegmentçš„æœ€å¤§å®¹é‡ï¼Œé»˜è®¤å€¼5GBï¼Œå¯ä»¥è€ƒè™‘é€‚å½“é™ä½æ­¤å€¼ã€‚ 1 2 3 4 5 6 PUT /test { \u0026#34;settings\u0026#34;: { \u0026#34;index.merge.policy.max_merged_segment\u0026#34;: \u0026#34;5GB\u0026#34; } } segments_per_tier è¯¥å±æ€§æŒ‡å®šäº†æ¯å±‚åˆ†æ®µçš„æ•°é‡ï¼Œå–å€¼è¶Šå°åˆ™segmentè¶Šå°‘ï¼Œå› æ­¤éœ€è¦mergeçš„æ“ä½œæ›´å¤šï¼Œå¯ä»¥è€ƒè™‘é€‚å½“å¢åŠ æ­¤å€¼ã€‚é»˜è®¤ä¸º10ï¼Œå…¶åº”è¯¥å¤§äºç­‰äºindex.merge.poliycy.max_merge_at_onceã€‚ 1 2 3 4 5 6 PUT /test { \u0026#34;settings\u0026#34;: { \u0026#34;index.merge.policy.segments_per_tier\u0026#34;: 10 } } Show Log Search Show Log ESæä¾›åœ¨æŸ¥è¯¢é˜¶æ®µ(Query)å’Œæ•°æ®è·å–é˜¶æ®µ(Fetch)è®¾ç½®é˜ˆå€¼ï¼Œè¶…è¿‡æ”¹é˜ˆå€¼åˆ™è®°å½•æ—¥å¿—ã€‚ æŸ¥è¯¢é˜¶æ®µæ”¯æŒå‚æ•°ï¼Œä»¥ä¸‹å€¼å®šä¹‰æŸ¥è¯¢é˜¶æ®µ(Query)é˜ˆå€¼ï¼Œåˆ†åˆ«è¡¨ç¤ºæ‰§è¡Œè¶…è¿‡10sï¼Œæ‰“å°è­¦å‘Šæ—¥å¿—ã€‚è¶…è¿‡5sæ‰“å°infoæ—¥å¿—ã€‚ 1 2 3 4 index.search.slowlog.threshold.query.warn: 10s index.search.slowlog.threshold.query.info: 5s index.search.slowlog.threshold.query.debug: 2s index.search.slowlog.threshold.query.trace: 500ms æ•°æ®è·å–é˜¶æ®µæ”¯æŒå‚æ•°ï¼Œä»¥ä¸‹å®šä¹‰æ•°æ®è·å–é˜¶æ®µ(Fetch)é˜ˆå€¼ï¼Œåˆ†åˆ«è¡¨ç¤ºæ‰§è¡Œè¶…è¿‡1sï¼Œæ‰“å°è­¦å‘Šæ—¥å¿—ã€‚è¶…è¿‡800msæ‰“å°infoæ—¥å¿—ã€‚ 1 2 3 4 index.search.slowlog.threshold.fetch.warn: 1s index.search.slowlog.threshold.fetch.info: 800ms index.search.slowlog.threshold.fetch.debug: 500ms index.search.slowlog.threshold.fetch.trace: 200ms æ—¥å¿—è¾“å‡ºçº§åˆ«ï¼Œå®šä¹‰æ—¥å¿—è¾“å‡ºçº§åˆ«ä¸ºinfoï¼Œä¸è¾“å‡ºdebugã€traceçº§åˆ«çš„æ—¥å¿—ã€‚æ³¨æ„ï¼šä¸Šè¿°æ—¥å¿—çº§åˆ«ä¸ºåˆ†ç‰‡æ—¥å¿—ã€‚ 1 index.search.slowlog.level: info log4jé…ç½®ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 appender.index_search_slowlog_rolling.type = RollingFile appender.index_search_slowlog_rolling.name = index_search_slowlog_rolling appender.index_search_slowlog_rolling.fileName = ${sys:es.logs}_index_search_slowlog.log appender.index_search_slowlog_rolling.layout.type = PatternLayout appender.index_search_slowlog_rolling.layout.pattern = [%d{ISO8601}][%-5p][%-25c] [%node_name]%marker %.10000m%n appender.index_search_slowlog_rolling.filePattern = ${sys:es.logs}_index_search_slowlog-%d{yyyy-MM-dd}.log #æ–‡ä»¶åˆ‡å‰²æ–¹æ¡ˆï¼Œå±äºlog4jçš„è¯­æ³• appender.index_search_slowlog_rolling.policies.type = Policies #åŸºäºæ—¶é—´åˆ‡å‰²ï¼Œlog4jè¿˜æ”¯æŒæŒ‰å¤§å°åˆ‡å‰²ï¼Œå…¶ç±»ä¸ºSizeBasedTriggeringPolicyã€‚ appender.index_search_slowlog_rolling.policies.time.type = TimeBasedTriggeringPolicy #1å°æ—¶åˆ‡å‰²æˆä¸€ä¸ªæ–‡ä»¶ appender.index_search_slowlog_rolling.policies.time.interval = 1 #æ˜¯å¦ä¿®æ­£æ—¶é—´èŒƒå›´, å¦‚æœè®¾ç½®ä¸ºtrueï¼Œåˆ™ä»0æ—¶å¼€å§‹è®¡æ•° appender.index_search_slowlog_rolling.policies.time.modulate = true logger.index_search_slowlog_rolling.name = index.search.slowlog logger.index_search_slowlog_rolling.level = trace logger.index_search_slowlog_rolling.appenderRef.index_search_slowlog_rolling.ref = index_search_slowlog_rolling logger.index_search_slowlog_rolling.additivity = false Index Show Log ç´¢å¼•æ…¢æ—¥å¿—é…ç½®ã€‚ index.indexing.slowlog.sourceå‚æ•°ç”¨æ¥è®°å½•æ–‡æ¡£ _sourceå­—æ®µå­—ç¬¦çš„ä¸ªæ•°ï¼Œé»˜è®¤1000ï¼Œè¡¨ç¤ºåªè®°å½•_sourceçš„å‰1000ä¸ªå­—ç¬¦ï¼Œå¯ä»¥è®¾ç½®ä¸ºtrueï¼Œè¡¨ç¤ºè¾“å‡º_sourceå­—æ®µå…¨éƒ¨å†…å®¹ï¼Œè®¾ç½®ä¸ºfalseï¼Œè¡¨ç¤ºä¸è®°å½•_sourceå­—æ®µçš„å†…å®¹ã€‚ é»˜è®¤æƒ…å†µä¸‹ï¼Œä¼šå¯¹_sourceå­—æ®µçš„è¾“å‡ºè¿›è¡Œæ ¼å¼åŒ–ï¼Œé€šå¸¸ä½¿ç”¨ä¸€è¡Œè¾“å‡ºï¼Œå¦‚æœæƒ³é˜»æ­¢æ ¼å¼åŒ–ï¼Œå¯ä»¥é€šè¿‡index.indexing.slowlog.reformatè®¾ç½®ä¸ºfalseæ¥é¿å…ã€‚ 1 2 3 4 5 6 index.indexing.slowlog.threshold.index.warn: 10s index.indexing.slowlog.threshold.index.info: 5s index.indexing.slowlog.threshold.index.debug: 2s index.indexing.slowlog.threshold.index.trace: 500ms index.indexing.slowlog.level: info index.indexing.slowlog.source: 1000 åœ¨logg4jé…ç½®æ–‡ä»¶ä¸­å®šä¹‰æ—¥å¿—çš„è¾“å‡ºã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 appender.index_indexing_slowlog_rolling.type = RollingFile appender.index_indexing_slowlog_rolling.name = index_indexing_slowlog_rolling appender.index_indexing_slowlog_rolling.fileName = ${sys:es.logs}_index_indexing_slowlog.log appender.index_indexing_slowlog_rolling.layout.type = PatternLayout appender.index_indexing_slowlog_rolling.layout.pattern = [%d{ISO8601}][%-5p][%-25c] [%node_name]%marker %.-10000m%n appender.index_indexing_slowlog_rolling.filePattern = ${sys:es.logs}_index_indexing_slowlog-%d{yyyy-MM-dd}.log appender.index_indexing_slowlog_rolling.policies.type = Policies appender.index_indexing_slowlog_rolling.policies.time.type = TimeBasedTriggeringPolicy appender.index_indexing_slowlog_rolling.policies.time.interval = 1 appender.index_indexing_slowlog_rolling.policies.time.modulate = true logger.index_indexing_slowlog.name = index.indexing.slowlog.index logger.index_indexing_slowlog.level = trace logger.index_indexing_slowlog.appenderRef.index_indexing_slowlog_rolling.ref = index_indexing_slowlog_rolling logger.index_indexing_slowlog.additivity = false Store index.store.type è¡¨ç¤ºå­˜å‚¨ç±»å‹ï¼Œè¯¥å€¼ä¸ºé™æ€å‚æ•°ï¼Œåœ¨ç´¢å¼•åˆ›å»ºæ—¶æŒ‡å®šï¼Œæ— æ³•æ›´æ”¹ã€‚å¯é€‰å€¼ï¼š fsï¼šé»˜è®¤æ–‡ä»¶ç³»ç»Ÿå®ç°ï¼Œæ ¹æ®å½“å‰æ“ä½œç³»ç»Ÿé€‰æ‹©æœ€ä½³å­˜å‚¨æ–¹å¼ simplefsï¼šç®€å•çš„FSç±»å‹ï¼Œä½¿ç”¨éšæœºè®¿é—®æ–‡ä»¶å®ç°æ–‡ä»¶ç³»ç»Ÿå­˜å‚¨(æ˜ å°„åˆ°Lucene SimpleFsDirectory)ã€‚å¹¶å‘æ€§èƒ½å¾ˆå·®(å¤šçº¿ç¨‹ä¼šå‡ºç°ç“¶é¢ˆ)ã€‚å½“éœ€è¦ç´¢å¼•æŒä¹…æ€§æ—¶ï¼Œé€šå¸¸æœ€å¥½ä½¿ç”¨niofsã€‚ niofsï¼šåŸºäºNIOå®ç°çš„æ–‡ä»¶ç³»ç»Ÿï¼Œè¯¥ç±»å‹ä½¿ç”¨NIOåœ¨æ–‡ä»¶ç³»ç»Ÿä¸Šå­˜å‚¨ç¢ç‰‡ç´¢å¼•(æ˜ å°„åˆ°Lucene NIOFSDirectory)ã€‚å®ƒå…è®¸å¤šä¸ªçº¿ç¨‹åŒæ—¶ä»åŒä¸€ä¸ªæ–‡ä»¶ä¸­è¯»å–æ•°æ®ã€‚ mmapfsï¼šåŸºäºæ–‡ä»¶å†…å­˜æ˜ å°„æœºåˆ¶å®ç°çš„æ–‡ä»¶ç³»ç»Ÿå®ç°ï¼Œè¯¥æ–¹æ³•å°†æ–‡ä»¶æ˜ å°„åˆ°å†…å­˜(MMap)æ¥å­˜å‚¨æ–‡ä»¶ç³»ç»Ÿä¸Šçš„ç¢ç‰‡ç´¢å¼•(æ˜ å°„åˆ°Lucene MMapDirectory)ã€‚å†…å­˜æ˜ å°„ä½¿ç”¨è¿›ç¨‹ä¸­ä¸è¢«æ˜ å°„æ–‡ä»¶å¤§å°ç›¸åŒçš„éƒ¨åˆ†è™šæ‹Ÿå†…å­˜åœ°å€ç©ºé—´ã€‚å¯é€šè¿‡node.store.allow_mmapfså±æ€§æ¥ç¦ç”¨åŸºäºå†…å­˜æ˜ å°„æœºåˆ¶ï¼Œå¦‚æœèŠ‚ç‚¹æ‰€åœ¨çš„æ“ä½œç³»ç»Ÿæ²¡æœ‰å¤§é‡è™šæ‹Ÿå†…å­˜ï¼Œåˆ™å¯ä»¥ä½¿ç”¨è¯¥å±æ€§æ˜ç¡®ç¦æ­¢ä½¿ç”¨è¯¥æ–‡ä»¶å®ç°ã€‚ index.store.preload é¢„åŠ è½½æ•°æ®åˆ°æ–‡ä»¶ç³»ç»Ÿç¼“å­˜ï¼Œå¦‚æœESä¸»æœºé‡å¯ï¼Œåˆ™æ–‡ä»¶ç³»ç»Ÿç¼“å­˜å°†æ¸…ç©ºï¼Œæ­¤æ—¶æœç´¢ä¼šæ¯”è¾ƒæ…¢ï¼Œå¯ä»¥ä½¿ç”¨index.store.preloadè®¾ç½®ï¼Œé€šè¿‡æŒ‡å®šæ–‡ä»¶æ‰©å±•åï¼Œæ˜¾ç¤ºçš„å‘Šè¯‰æ“ä½œç³»ç»Ÿåº”è¯¥å°†å“ªäº›æ–‡ä»¶åŠ è½½åˆ°å†…å­˜ä¸­ã€‚ ä¾‹å¦‚ï¼Œé…ç½®åˆ°elasticsearch.ymlæ–‡ä»¶ä¸­ï¼š 1 index.store.preload: [\u0026#34;nvd\u0026#34;,\u0026#34;dvd\u0026#34;] æˆ–è€…åœ¨åˆ›å»ºç´¢å¼•çš„æ—¶å€™è®¾ç½®ï¼š 1 2 3 4 5 { \u0026#34;settings\u0026#34;:{ \u0026#34;index.store.preload\u0026#34;:[\u0026#34;nvd\u0026#34;,\u0026#34;dvd\u0026#34;] } } Translog ç”±äºLuceneæäº¤çš„å¼€é”€å¾ˆå¤§ï¼Œä¸èƒ½æ¯ä¸ªå˜æ›´å°±æäº¤ä¸€æ¬¡(åˆ·å†™ç£ç›˜)ï¼Œæ‰€ä»¥æ¯ä¸ªåˆ†ç‰‡å¤åˆ¶éƒ½æœ‰ä¸€ä¸ªäº‹åŠ¡æ—¥å¿—ï¼Œç§°ä¸ºtranslogã€‚æ‰€æœ‰ç´¢å¼•å’Œåˆ é™¤æ“ä½œéƒ½æ˜¯åœ¨è¢«å†…éƒ¨Luceneç´¢å¼•å¤„ç†åªä¼šå†™å…¥translogçš„ã€‚åœ¨å‘ç”Ÿå´©æºƒçš„æƒ…å†µä¸‹ï¼Œå½“ç´¢å¼•æ¢å¤çš„æ—¶å€™ï¼Œå¯ä»¥é€šè¿‡å›æ”¾translogä¸­çš„æ•°æ®è¿›è¡Œæ¢å¤ã€‚ index.translog.durability translogåˆ·ç›˜æ–¹å¼ï¼Œå¯é€‰å€¼ï¼šrequestã€asyncã€‚ requestï¼šå³æ¯è¯·æ±‚ä¸€æ¬¡åˆ·ç›˜ï¼Œä¹Ÿå°±æ˜¯å®¢æˆ·ç«¯å‘èµ·ä¸€ä¸ªå¢åˆ æ”¹æ“ä½œæ—¶ï¼Œä¼šåœ¨ä¸»åˆ†ç‰‡å’Œå‰¯æœ¬åˆ†ç‰‡å…¨éƒ¨åˆ·ç›˜æˆåŠŸåï¼Œæ‰ä¼šè¿”å›æˆåŠŸï¼Œæ˜¯ESçš„é»˜è®¤æ¨¡å¼ã€‚ asyncï¼šå¼‚æ­¥åˆ·ç›˜æ¨¡å¼ï¼Œæ­¤æ¨¡å¼é¢‘ç‡ç”±index.translog.sync_intervalè®¾ç½®ï¼Œå…¶é»˜è®¤å€¼ä¸º5sï¼Œè¯¥æ¨¡å¼ä¼šå­˜åœ¨æ•°æ®ä¸¢å¤±çš„å¯èƒ½ã€‚ index.translog.sync_interval å¦‚æœindex.translog.durabilityè®¾ç½®ä¸ºasyncï¼Œç”¨è¯¥å€¼æ¥è®¾ç½®åˆ·ç›˜çš„é¢‘ç‡ï¼Œé»˜è®¤ä¸º5sã€‚ index.translog.flush_threshold_size ESå¼ºåˆ¶åˆ·æ–°çš„å¦å¤–ä¸€ä¸ªç»´åº¦ï¼Œå¦‚æœtranslogçš„å¤§å°è¾¾åˆ°è¯¥å€¼ï¼Œåˆ™å¼ºåˆ¶å°†ä¸ºåˆ·ç›˜çš„æ•°æ®å¼ºåˆ¶åˆ·æ–°åˆ°Luceneä¸­ï¼Œé»˜è®¤512Mã€‚ index.translog.retention.size ä¿å­˜è·¨æ—¥å¿—æ–‡ä»¶çš„æ€»å¤§å°ã€‚ä¹Ÿå°±æ˜¯translogæ—¥å¿—æ–‡ä»¶flushåï¼Œå¹¶ä¸é©¬ä¸Šåˆ é™¤ï¼Œè€Œæ˜¯ä¿ç•™ä¸€æ®µæ—¶é—´ï¼Œä½†æœ€æ–°çš„translogæ–‡ä»¶å·²ç»å­˜å‚¨çš„å†…å®¹ä¸å¾…åˆ é™¤çš„æ–‡ä»¶çš„é—´éš”ä¸è¶…è¿‡æ”¹å‚æ•°è®¾ç½®çš„å€¼ï¼Œé»˜è®¤ä¸º512Mã€‚ index.translog.retention.age ä¿å­˜translogæ–‡ä»¶çš„æœ€å¤§æŒç»­æ—¶é—´ï¼Œé»˜è®¤12hã€‚ å‚è€ƒ https://blog.csdn.net/dwjf321/article/details/103871981 ","permalink":"https://heliu.site/posts/elasticsearch/settings/","summary":"è®¾ç½®å½“å‰ç´¢å¼•çš„åˆ†ç‰‡æ•°ï¼Œå‰¯æœ¬æ•°ç­‰ä¿¡æ¯ã€‚","title":"Settings"},{"content":" ç´¢å¼•åˆ«åæ˜¯ç”¨äºå¼•ç”¨ä¸€ä¸ªæˆ–å¤šä¸ªç°æœ‰ç´¢å¼•çš„è¾…åŠ©åç§°ã€‚å¤§å¤šæ•°ES APIæ¥å—ç´¢å¼•åˆ«åæ¥ä»£æ›¿ç´¢å¼•ã€‚ åˆ«åæ˜¯ä¸€ç»„ç´¢å¼•çš„è¾…åŠ©åç§°ï¼Œä¸€ä¸ªåˆ«åå¯ä»¥æŒ‡å‘å¤šä¸ªç´¢å¼•ï¼Œä¸€ä¸ªç´¢å¼•å¯ä»¥æœ‰å¤šä¸ªåˆ«åã€‚ ä½¿ç”¨åˆ«åˆ«åï¼Œåœ¨é‡å»ºç´¢å¼•æ•°æ®æ—¶ï¼Œæ— éœ€åœæœºæˆ–æ›´æ”¹ç¨‹åºä»£ç ã€‚ åˆ«åç±»ä¼¼Nginxåå‘ä»£ç†çš„æ„Ÿè§‰ï¼Œå½“è®¿é—®åˆ«åæ—¶ï¼Œç›¸å½“äºè®¿é—®çš„å®é™…ç´¢å¼•çš„ä»£ç†ã€‚ ä½¿ç”¨åœºæ™¯ æ»šåŠ¨ç´¢å¼• å­˜å‚¨å¤§é‡æ—¥å¿—æ•°æ®çš„åœºæ™¯ï¼Œæˆ–è€… å­˜å‚¨å‡ äº¿è®¢å•æ•°æ®çš„åœºæ™¯ã€‚ç”±äºESç´¢å¼•çš„å•ä¸ªåˆ†ç‰‡å»ºè®®å¤§å°ä¸º30Gå·¦å³ï¼ŒåŒæ—¶ESçš„åˆ†ç‰‡æ•°é‡ä¹Ÿä¸è¦å¤ªå¤§ï¼Œå»ºè®®1~5ä¹‹é—´ã€‚æ‰€ä»¥ï¼ŒåŠ¿å¿…è¦å»ºç«‹å¤šä¸ªç´¢å¼•å»å­˜å‚¨å¤§é‡æ•°æ®ã€‚æ¯”å¦‚ æŒ‰æ—¥ã€æŒ‰æœˆã€æŒ‰å­£åº¦ã€æŒ‰å¹´ å­˜å‚¨ç­‰ã€‚ æ­¤æ—¶å¦‚æœè¦ä»è¿™äº›ç´¢å¼•é‡Œå»æŸ¥è¯¢æ•°æ®ï¼Œåœ¨ä¸ä½¿ç”¨Aliasçš„æƒ…å†µä¸‹ï¼Œè‚¯å®šè¦åœ¨ä¸šåŠ¡ä»£ç é‡Œå†™ä¸Šä¸€å †å¤æ‚çš„é€»è¾‘ï¼Œç„¶åæ˜¯å…¼å®¹å„ç§åœºæ™¯å’Œå¼‚å¸¸ï¼Œå³ä½¿æ„Ÿè§‰åšçš„æ¯”è¾ƒå®Œå–„äº†ï¼Œå¯èƒ½ä¸Šçº¿åè¿˜æœ‰æœªçŸ¥çš„é—®é¢˜ã€‚ ä½¿ç”¨Aliasåï¼Œä¸šåŠ¡ä»£ç æ— éœ€æ”¹åŠ¨ï¼Œåªéœ€è¦ç»™ç›¸å…³ç´¢å¼•å»ºç«‹åŒæ ·çš„åˆ«åï¼Œç„¶ååˆ©ç”¨AliasæŸ¥è¯¢ï¼ŒESä¼šè‡ªåŠ¨å°†ç›¸å…³çš„ç´¢å¼•æ•°æ®éƒ½æŸ¥å‡ºæ¥ã€‚ æ— ç¼åˆ‡æ¢ æ­£åœ¨ä½¿ç”¨çš„ç´¢å¼•Aå­˜åœ¨éƒ¨åˆ†å¼‚å¸¸æ•°æ®ï¼Œæ­¤æ—¶å¯ä»¥é‡æ–°æ„å»ºç´¢å¼•Bï¼Œç„¶åå°†AliasæŒ‡å‘ç´¢å¼•Bï¼Œè¿™æ ·å¯ä»¥æ— ç¼åˆ‡æ¢ç´¢å¼•ï¼Œå¹¶ä¸”ä¸šåŠ¡å±‚æ— æ„ŸçŸ¥ã€‚ é‡å»ºç´¢å¼• åœ¨ESä¸­æ— æ³•å¯¹ç´¢å¼•çš„ç°æœ‰å­—æ®µåšæ”¹åŠ¨ï¼Œä¸€èˆ¬çš„åšæ³•æ˜¯åˆ›å»ºæ–°çš„ç´¢å¼•ï¼Œç„¶åæŠŠæ–‡æ¡£ä»æ—§çš„ç´¢å¼•å¤åˆ¶åˆ°æ–°çš„ç´¢å¼•é‡Œã€‚é’ˆå¯¹è¿™ç§æƒ…å†µï¼Œåˆ«åçš„ä½¿ç”¨ä¼˜åŠ¿å°±ä½“ç°å‡ºæ¥äº†ï¼Œç´¢å¼•åˆ«åå¯ä»¥å®ç°æ—§ç´¢å¼•åˆ°æ–°ç´¢å¼•çš„å¹³æ»‘è¿ç§»ã€‚ å¸¦è¿‡æ»¤æ¡ä»¶ç´¢å¼• é’ˆå¯¹æŸä¸ªç´¢å¼•ï¼Œæœ‰äº›åœºæ™¯éœ€è¦å›ºåŒ–è§†å›¾æ—¶ï¼Œå°±å¯ä»¥è®¾ç½®åˆ«åæ¥å®ç°ï¼Œè¿™æ ·è°ƒç”¨æ–¹ä½¿ç”¨èµ·æ¥å¾ˆæ–¹ä¾¿ï¼Œæ— éœ€åŠ å…¥é‡å¤çš„æŸ¥è¯¢æ¡ä»¶ã€‚æ¯”å¦‚æœ‰ä¸ª è®¢å•ç´¢å¼•ï¼Œå¤šå¤„éœ€è¦æŸ¥è¯¢ 30å¤©å†…å·²æ”¯ä»˜è®¢å•ï¼Œæ­¤æ—¶å¯ä»¥åˆ©ç”¨Aliasæ„å»ºå‡ºè¿™æ ·çš„è§†å›¾ã€‚ ä½¿ç”¨åˆ«å åˆ›å»ºåˆ«å åˆ›å»ºç´¢å¼•æ—¶æŒ‡å®šåˆ«åï¼Œorderç´¢å¼•æŒ‡å®šalias_1,alias_2åˆ«åã€‚ 1 2 3 4 5 6 7 PUT /order { \u0026#34;aliases\u0026#34;: { \u0026#34;alias_1\u0026#34;: {}, \u0026#34;alias_2\u0026#34;: {} } } åˆ›å»ºç´¢å¼•åæŒ‡å®šåˆ«åã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 POST _aliases { \u0026#34;actions\u0026#34;: [ { \u0026#34;add\u0026#34;: { // order_202201 åˆ«å order_alias \u0026#34;index\u0026#34;: \u0026#34;order_202201\u0026#34;, \u0026#34;alias\u0026#34;: \u0026#34;order_alias\u0026#34; } }, { \u0026#34;add\u0026#34;: { // order_202202 åˆ«å order_alias \u0026#34;index\u0026#34;: \u0026#34;order_202202\u0026#34;, \u0026#34;alias\u0026#34;: \u0026#34;order_alias\u0026#34; } } ] } å½“ç´¢å¼•åˆ«åæŒ‡å‘å¤šä¸ªç´¢å¼•æ—¶ï¼Œè¿›è¡Œå†™æ“ä½œï¼Œå…¶ä¸­çš„ä¸€ä¸ªç´¢å¼•å¿…é¡»è¢«æŒ‡å®šä¸ºå†™ç´¢å¼•ï¼Œå¹¶ä¸”åªèƒ½æŒ‡å®šä¸€ä¸ªï¼Œå¦åˆ™åˆ™æ— æ³•å†™å…¥ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 POST /_aliases { \u0026#34;actions\u0026#34; : [ { \u0026#34;add\u0026#34; : { \u0026#34;index\u0026#34; : \u0026#34;test\u0026#34;, \u0026#34;alias\u0026#34; : \u0026#34;alias1\u0026#34;, \u0026#34;is_write_index\u0026#34; : true } }, { \u0026#34;add\u0026#34; : { \u0026#34;index\u0026#34; : \u0026#34;test2\u0026#34;, \u0026#34;alias\u0026#34; : \u0026#34;alias1\u0026#34; } } ] } ç§»é™¤åˆ«å 1 2 3 4 5 6 7 8 9 10 11 12 POST _aliases { \u0026#34;actions\u0026#34;: [ { // ç§»é™¤ \u0026#34;remove\u0026#34;: { \u0026#34;index\u0026#34;: \u0026#34;order_202201\u0026#34;, \u0026#34;alias\u0026#34;: \u0026#34;order_alias\u0026#34; } } ] } åˆ‡æ¢åˆ«å æŠŠproductç´¢å¼•åˆ«åé‡å‘½åä¸ºproduct_newã€‚(åŸå­æ“ä½œ) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 POST _aliases { \u0026#34;actions\u0026#34;: [ { \u0026#34;remove\u0026#34;: { // ç§»é™¤ \u0026#34;index\u0026#34;: \u0026#34;product\u0026#34;, \u0026#34;alias\u0026#34;: \u0026#34;product_old\u0026#34; } }, { \u0026#34;add\u0026#34;: { // æ·»åŠ  \u0026#34;index\u0026#34;: \u0026#34;product\u0026#34;, \u0026#34;alias\u0026#34;: \u0026#34;product_new\u0026#34; } } ] } åˆ‡æ¢å†™ç´¢å¼•å±æ€§ï¼Œ(åŸå­æ“ä½œ)ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 POST /_aliases { \u0026#34;actions\u0026#34; : [ { \u0026#34;add\u0026#34; : { \u0026#34;index\u0026#34; : \u0026#34;test\u0026#34;, \u0026#34;alias\u0026#34; : \u0026#34;alias1\u0026#34;, \u0026#34;is_write_index\u0026#34; : false } }, { \u0026#34;add\u0026#34; : { \u0026#34;index\u0026#34; : \u0026#34;test2\u0026#34;, \u0026#34;alias\u0026#34; : \u0026#34;alias1\u0026#34;, \u0026#34;is_write_index\u0026#34; : true } } ] } è¿‡æ»¤è§†å›¾ åˆ›å»ºç´¢å¼•åæ·»åŠ åˆ«åå¹¶æŒ‡å®šè¿‡æ»¤æ¡ä»¶ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 POST /_aliases { \u0026#34;actions\u0026#34; : [ { // order_202303ç´¢å¼•åˆ›å»ºorder_aliasåˆ«å // å½“å‰ä½¿ç”¨order_aliasåˆ«åæŸ¥æ‰¾æ•°æ®æ—¶ï¼Œé»˜è®¤å¸¦ä¸ŠæŒ‡å®šçš„è¿‡æ»¤æ¡ä»¶ \u0026#34;add\u0026#34; : { \u0026#34;index\u0026#34; : \u0026#34;order_202303\u0026#34;, \u0026#34;alias\u0026#34; : \u0026#34;order_alias\u0026#34;, \u0026#34;filter\u0026#34;: {\u0026#34;term\u0026#34; : {\u0026#34;pay_state\u0026#34;: 1}} } } ] } æŸ¥è¯¢ç´¢å¼•åˆ«å 1 2 3 4 5 6 7 8 9 10 // æŸ¥è¯¢logs_20162801ç´¢å¼•çš„æ‰€æœ‰åˆ«å GET /logs_20162801/_alias/* // æŸ¥è¯¢åˆ«åä¸º2016çš„æ‰€æœ‰ç´¢å¼• GET /_alias/2016 // æŸ¥è¯¢åˆ«åä¸º20å¼€å¤´çš„æ‰€æœ‰ç´¢å¼• GET /_alias/20* HEAD /_alias/2016 HEAD /_alias/20* HEAD /logs_20162801/_alias/* åˆ›å»ºç´¢å¼•æ—¶æŒ‡å®šåˆ«åå¹¶è®¾ç½®è¿‡æ»¤æ¡ä»¶ã€‚ 1 2 3 4 5 6 7 8 9 10 11 PUT /test { \u0026#34;aliases\u0026#34;: { \u0026#34;alias_1\u0026#34;: {}, \u0026#34;alias_2\u0026#34;: { \u0026#34;filter\u0026#34;: { \u0026#34;user.id\u0026#34;: \u0026#34;kim\u0026#34; } } } } åŒºåˆ«å¯¹æ¯” ä¸ä½¿ç”¨aliasæ–¹æ¡ˆ è¯¥æ–¹æ¡ˆæ— æ³•å®ç°æ— ç¼åˆ‡æ¢ï¼Œå› ä¸ºåœ¨åˆ é™¤æ—§çš„index-Aä¹‹åï¼Œæ–°çš„index-Aè¿˜æ²¡åˆ›å»ºï¼Œè€Œä¸”æ•°æ®è¿˜æ²¡æ‹·è´å®Œæ¯•ã€‚ åŸºäºè¿™ç§æ–¹æ¡ˆè¦æƒ³æ— ç¼åˆ‡æ¢ï¼Œé‚£åªèƒ½æ˜¯å…ˆåˆ›å»ºindex-Bï¼Œé€šè¿‡reindexå°†index-Açš„æ•°æ®æ‹·è´åˆ°index-Bï¼Œç„¶åä¸šåŠ¡ä»£ç æ”¹æˆè®¿é—®index-Bã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 // 1) å°†index_Aæ‹·è´åˆ°å¤‡ä»½index_A_bak POST _reindex { \u0026#34;source\u0026#34;: { \u0026#34;index\u0026#34;: \u0026#34;index_A\u0026#34; }, \u0026#34;dest\u0026#34;: { \u0026#34;index\u0026#34;: \u0026#34;index_A_bak\u0026#34; } } // 2) åˆ é™¤index_A DELETE index_A // 3) åˆ›å»ºæ–°çš„ index_Aï¼Œæ­¤å¤„çœå»åˆ›å»ºæ–°çš„index_Açš„è¿‡ç¨‹ // 4) å°†å¤‡ä»½index_A_bakæ‹·è´åˆ°æ–°çš„index_A POST _reindex { \u0026#34;source\u0026#34;: { \u0026#34;index\u0026#34;: \u0026#34;index_A_bak\u0026#34; }, \u0026#34;dest\u0026#34;: { \u0026#34;index\u0026#34;: \u0026#34;æ–°çš„index_A\u0026#34; } } // 5) åˆ é™¤å¤‡ä»½index_A_bak DELETE index_A_bak ä½¿ç”¨Aliasçš„æ–¹æ¡ˆ è¯¥æ–¹æ¡ˆæ— éœ€æ”¹åŠ¨ä»£ç å³å¯å®ç°æ— ç¼åˆ‡æ¢ã€‚åç»­åˆ‡æ¢ç´¢å¼•åªéœ€è¦æ“ä½œ3ã€4ã€5æ­¥å³å¯ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 // 1) ç»™index_Aæ·»åŠ åˆ«å POST /_aliases { \u0026#34;actions\u0026#34;: [ { \u0026#34;add\u0026#34;: { \u0026#34;index\u0026#34;: \u0026#34;index_A\u0026#34;, \u0026#34;alias\u0026#34;: \u0026#34;index_alias\u0026#34; } } ] } // 2) ä¸šåŠ¡å±‚çš„ä»£ç æ”¹æˆä½¿ç”¨åˆ«åæ“ä½œç´¢å¼• // 3) å°†index_Aæ•°æ®æ‹·è´åˆ°index_B POST _reindex { \u0026#34;source\u0026#34;: { \u0026#34;index\u0026#34;: \u0026#34;index_A\u0026#34; }, \u0026#34;dest\u0026#34;: { \u0026#34;index\u0026#34;: \u0026#34;index_B\u0026#34; } } // 4) åˆ«ååˆ‡æ¢ POST /_aliases { \u0026#34;actions\u0026#34;: [ { \u0026#34;add\u0026#34;: { \u0026#34;index\u0026#34;: \u0026#34;index_A\u0026#34;, \u0026#34;alias\u0026#34;: \u0026#34;index_alias\u0026#34; }, \u0026#34;remove\u0026#34;: { \u0026#34;index\u0026#34;: \u0026#34;index_B\u0026#34;, \u0026#34;alias\u0026#34;: \u0026#34;index_alias\u0026#34; } } ] } // 5) åˆ é™¤ç´¢å¼•index_A DELETE index_A å‚è€ƒ https://mp.weixin.qq.com/s/U6YAN_yW809NvF1JDntBHw ","permalink":"https://heliu.site/posts/elasticsearch/aliases/","summary":"ElasticSearch ç´¢å¼•åˆ«åè®¾ç½®ã€‚","title":"Aliases"},{"content":" routingå‚æ•°æ˜¯ä¸€ä¸ªå¯é€‰å‚æ•°ï¼Œé»˜è®¤ä½¿ç”¨æ–‡æ¡£çš„_idå€¼ï¼Œå¯ä»¥ç”¨åœ¨INDEX, UPDATE,GET, SEARCH, DELETEç­‰å„ç§æ“ä½œä¸­ã€‚ åœ¨å†™å…¥(åŒ…æ‹¬æ›´æ–°)æ—¶ï¼Œç”¨äºè®¡ç®—æ–‡æ¡£æ‰€å±åˆ†ç‰‡ï¼Œåœ¨æŸ¥è¯¢(GETè¯·æ±‚æˆ–æŒ‡å®šäº†routingçš„æŸ¥è¯¢)ä¸­ç”¨äºé™åˆ¶æŸ¥è¯¢èŒƒå›´ï¼Œæé«˜æŸ¥è¯¢é€Ÿåº¦ã€‚ è®¡ç®—æ–¹æ³• ESé€šè¿‡è¿™æ ·ä¸€ä¸ªå…¬å¼ä¿è¯ä½¿ç”¨ç›¸åŒroutingçš„æ–‡æ¡£è¢«åˆ†é…åˆ°åŒä¸€ä¸ªåˆ†ç‰‡ä¸Šï¼Œå½“ç„¶åœ¨é»˜è®¤æƒ…å†µä¸‹ä½¿ç”¨_idä½œä¸ºroutingèµ·åˆ°å°†æ–‡æ¡£å‡åŒ€åˆ†å¸ƒåˆ°å¤šä¸ªåˆ†ç‰‡ä¸Šé˜²æ­¢æ•°æ®å€¾æ–œçš„ä½œç”¨ã€‚ shardId = hash(_routing) % num_primary_shards ä½¿ç”¨äº†routingå‚æ•°å¯ä»¥è®©routingå€¼ç›¸åŒçš„æ–‡æ¡£åˆ†é…åˆ°åŒä¸€ä¸ªåˆ†ç‰‡ä¸Šï¼Œä»è€Œå‡å°‘æŸ¥è¯¢æ—¶éœ€è¦æŸ¥è¯¢çš„shardæ•°ï¼Œæé«˜æŸ¥è¯¢æ•ˆç‡ã€‚ä½†æ˜¯ä½¿ç”¨è¯¥å‚æ•°å®¹æ˜“å¯¼è‡´æ•°æ®å€¾æ–œã€‚ ä¸ºæ­¤ï¼ŒESè¿˜æä¾›äº†ä¸€ä¸ªindex.routing_partition_sizeå‚æ•°ï¼ˆä»…å½“ä½¿ç”¨routingå‚æ•°æ—¶å¯ç”¨ï¼‰ï¼Œç”¨äºå°†routingç›¸åŒçš„æ–‡æ¡£æ˜ å°„åˆ°é›†ç¾¤åˆ†ç‰‡çš„ä¸€ä¸ªå­é›†ä¸Šï¼Œè¿™æ ·ä¸€æ–¹é¢å¯ä»¥å‡å°‘æŸ¥è¯¢çš„åˆ†ç‰‡æ•°ï¼Œå¦ä¸€æ–¹é¢åˆå¯ä»¥åœ¨ä¸€å®šç¨‹åº¦ä¸Šé˜²æ­¢æ•°æ®å€¾æ–œã€‚ shard_num = (hash(_routing) + hash(_id) % routing_partition_size) % num_primary_shards è®¾ç½®routingä¸ºå¿…é€‰ ä½¿ç”¨routingå†™å…¥çš„æ–‡æ¡£ï¼Œåœ¨è¿›è¡ŒGETï¼ŒUPDATEæˆ–DELETEæ“ä½œæ—¶å¦‚æœä¸æŒ‡å®šroutingå‚æ•°ä¼šå‡ºç°å¼‚å¸¸ã€‚ ä¸ºæ­¤ESæä¾›äº†ä¸€ä¸ªç´¢å¼•mappingçº§åˆ«çš„è®¾ç½®ï¼Œ_routing.requiredï¼Œæ¥å¼ºåˆ¶ç”¨æˆ·åœ¨INDEXï¼ŒGETï¼ŒDELETEï¼ŒUPDATAä¸€ä¸ªæ–‡æ¡£æ—¶å¿…é¡»ä½¿ç”¨routingå‚æ•°ã€‚ å½“ç„¶æŸ¥è¯¢æ—¶ä¸å—è¯¥å‚æ•°çš„é™åˆ¶çš„ã€‚è¯¥å‚æ•°çš„è®¾ç½®æ–¹å¼å¦‚ä¸‹ï¼š PUT my_index { \u0026#34;mappings\u0026#34;: { \u0026#34;_doc\u0026#34;: { \u0026#34;_routing\u0026#34;: { \u0026#34;required\u0026#34;: true } } } } ç»“åˆåˆ«å routingå’Œåˆ«åç»“åˆï¼Œå¯ä»¥å¯¹ä½¿ç”¨è€…å±è”½è¯»å†™æ—¶ä½¿ç”¨routingçš„ç»†èŠ‚ï¼Œé™ä½è¯¯æ“ä½œçš„é£é™©ï¼Œæé«˜æ“ä½œçš„æ•ˆç‡ã€‚ POST /_aliases { \u0026#34;actions\u0026#34; : [ { \u0026#34;add\u0026#34; : { \u0026#34;index\u0026#34; : \u0026#34;test\u0026#34;, \u0026#34;alias\u0026#34; : \u0026#34;alias1\u0026#34;, \u0026#34;routing\u0026#34; : \u0026#34;1\u0026#34; } } ] } ","permalink":"https://heliu.site/posts/elasticsearch/routing/","summary":"ElasticSearch è·¯ç”±è§„åˆ™ã€‚","title":"Routing"},{"content":"åˆ›å»º åŸºæœ¬è¯­æ³•ï¼š è¯·æ±‚æ–¹æ³•ï¼šPUT è¯·æ±‚è·¯å¾„ï¼š/ç´¢å¼•åç§° è¯·æ±‚å‚æ•°ï¼šmapping æœ‰è¿™æ ·ä¸€æ¡æ–‡æ¡£ï¼Œéœ€è¦åˆ›å»ºç´¢å¼•ã€‚ ageï¼šç±»å‹ä¸º byteï¼›å‚ä¸æœç´¢ï¼Œå› æ­¤éœ€è¦indexä¸ºtrueï¼›æ— éœ€åˆ†è¯å™¨ã€‚ weightï¼šç±»å‹ä¸ºfloatï¼›å‚ä¸æœç´¢ï¼Œå› æ­¤éœ€è¦indexä¸ºtrueï¼›æ— éœ€åˆ†è¯å™¨ã€‚ isMarriedï¼šç±»å‹ä¸ºbooleanï¼›å‚ä¸æœç´¢ï¼Œå› æ­¤éœ€è¦indexä¸ºtrueï¼›æ— éœ€åˆ†è¯å™¨ã€‚ infoï¼šç±»å‹ä¸ºå­—ç¬¦ä¸²ï¼Œéœ€è¦åˆ†è¯ï¼Œå› æ­¤æ˜¯textï¼›å‚ä¸æœç´¢ï¼Œå› æ­¤éœ€è¦indexä¸ºtrueï¼›åˆ†è¯å™¨å¯ä»¥ç”¨ik_smartã€‚ emailï¼šç±»å‹ä¸ºå­—ç¬¦ä¸²ï¼Œä½†æ˜¯ä¸éœ€è¦åˆ†è¯ï¼Œå› æ­¤æ˜¯keywordï¼›ä¸å‚ä¸æœç´¢ï¼Œå› æ­¤éœ€è¦indexä¸ºfalseï¼›æ— éœ€åˆ†è¯å™¨ã€‚ scoreï¼šè™½ç„¶æ˜¯æ•°ç»„ï¼Œä½†æ˜¯æˆ‘ä»¬åªçœ‹å…ƒç´ çš„ç±»å‹ï¼Œç±»å‹ä¸ºfloatï¼›å‚ä¸æœç´¢ï¼Œå› æ­¤éœ€è¦indexä¸ºtrueï¼›æ— éœ€åˆ†è¯å™¨ã€‚ nameï¼šç±»å‹ä¸ºobjectï¼Œéœ€è¦å®šä¹‰å¤šä¸ªå­å±æ€§ name.firstNameï¼›ç±»å‹ä¸ºå­—ç¬¦ä¸²ï¼Œä½†æ˜¯ä¸éœ€è¦åˆ†è¯ï¼Œå› æ­¤æ˜¯keywordï¼›å‚ä¸æœç´¢ï¼Œå› æ­¤éœ€è¦indexä¸ºtrueï¼›æ— éœ€åˆ†è¯å™¨ã€‚ name.lastNameï¼›ç±»å‹ä¸ºå­—ç¬¦ä¸²ï¼Œä½†æ˜¯ä¸éœ€è¦åˆ†è¯ï¼Œå› æ­¤æ˜¯keywordï¼›å‚ä¸æœç´¢ï¼Œå› æ­¤éœ€è¦indexä¸ºtrueï¼›æ— éœ€åˆ†è¯å™¨ã€‚ æ³¨æ„ï¼šæ‰€æœ‰çš„ç´¢å¼•åéƒ½å¿…é¡»è¦å°å†™ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 { \u0026#34;age\u0026#34;:Â 21, \u0026#34;weight\u0026#34;:Â 52.4, \u0026#34;isMarried\u0026#34;:Â false, \u0026#34;info\u0026#34;:Â \u0026#34;ç¾å¥½çš„ä¸€å¤©ä»æ¸…æ™¨å¼€å§‹\u0026#34;, \u0026#34;email\u0026#34;:Â \u0026#34;123456@qq.cn\u0026#34;, \u0026#34;score\u0026#34;:Â [99.1, 95.5, 98.9], \u0026#34;name\u0026#34;:Â { \u0026#34;firstName\u0026#34;:Â \u0026#34;ä¸‰\u0026#34;, \u0026#34;lastName\u0026#34;:Â \u0026#34;å¼ \u0026#34; } } åˆ›å»ºdemoã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 PUT /users { \u0026#34;aliases\u0026#34;: { \u0026#34;alias_users\u0026#34;: {} }, \u0026#34;settings\u0026#34;: { \u0026#34;index.number_of_shards\u0026#34;: 1, \u0026#34;index.number_of_replicas\u0026#34;: 0, \u0026#34;index.refresh_interval\u0026#34;: \u0026#34;3s\u0026#34;, \u0026#34;index.max_result_window\u0026#34;: 1000 }, \u0026#34;mappings\u0026#34;: { \u0026#34;properties\u0026#34;: { \u0026#34;age\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;byte\u0026#34; }, \u0026#34;weight\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;float\u0026#34; }, \u0026#34;isMarried\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;boolean\u0026#34; }, \u0026#34;info\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;text\u0026#34;, \u0026#34;analyzer\u0026#34;: \u0026#34;ik_smart\u0026#34;, \u0026#34;search_analyzer\u0026#34;: \u0026#34;ik_max_word\u0026#34; }, \u0026#34;email\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;keyword\u0026#34;, \u0026#34;index\u0026#34;: \u0026#34;false\u0026#34; }, \u0026#34;score\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;float\u0026#34; }, \u0026#34;name\u0026#34;: { \u0026#34;properties\u0026#34;: { \u0026#34;firstName\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;keyword\u0026#34;, \u0026#34;index\u0026#34;: \u0026#34;false\u0026#34; }, \u0026#34;lastName\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;keyword\u0026#34;, \u0026#34;index\u0026#34;: \u0026#34;false\u0026#34; } } } } } } æŸ¥è¯¢ åŸºæœ¬è¯­æ³•ï¼š è¯·æ±‚æ–¹æ³•ï¼šGET è¯·æ±‚è·¯å¾„ï¼š/ç´¢å¼•åç§° è¯·æ±‚å‚æ•°ï¼šæ—  GET /users ä¿®æ”¹ åŸºæœ¬è¯­æ³•ï¼š\nè¯·æ±‚æ–¹æ³•ï¼šPUT è¯·æ±‚è·¯å¾„ï¼š/ç´¢å¼•åç§°/_mapping è¯·æ±‚å‚æ•°ï¼špropertiesã€‚ å€’æ’ç´¢å¼•ç»“æ„è™½ç„¶ä¸å¤æ‚ï¼Œä½†æ˜¯ä¸€æ—¦æ•°æ®ç»“æ„æ”¹å˜ï¼ˆæ¯”å¦‚æ”¹å˜äº†åˆ†è¯å™¨ï¼‰ï¼Œå°±éœ€è¦é‡æ–°åˆ›å»ºå€’æ’ç´¢å¼•ï¼Œè¿™ç®€ç›´æ˜¯ç¾éš¾ã€‚å› æ­¤ç´¢å¼•åº“ä¸€æ—¦åˆ›å»ºï¼Œæ— æ³•ä¿®æ”¹mappingã€‚\nè™½ç„¶æ— æ³•ä¿®æ”¹mappingä¸­å·²æœ‰çš„å­—æ®µï¼Œä½†æ˜¯å´å…è®¸æ·»åŠ æ–°çš„å­—æ®µåˆ°mappingä¸­ï¼Œå› ä¸ºä¸ä¼šå¯¹å€’æ’ç´¢å¼•äº§ç”Ÿå½±å“ã€‚\nPUT /users/_mapping { \u0026#34;properties\u0026#34;: { \u0026#34;score\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;float\u0026#34; } } } åˆ é™¤ åŸºæœ¬è¯­æ³•ï¼š è¯·æ±‚æ–¹æ³•ï¼šDELETE è¯·æ±‚è·¯å¾„ï¼š/ç´¢å¼•åç§° è¯·æ±‚å‚æ•°ï¼šæ—  DELETE /users ","permalink":"https://heliu.site/posts/elasticsearch/indexes/","summary":"ç´¢å¼•çš„å¢åˆ æ”¹æŸ¥ã€‚","title":"ç´¢å¼•CURD"},{"content":"æ–°å¢ 1 2 3 4 5 6 7 8 9 10 11 12 POST /alias_users/_doc { \u0026#34;age\u0026#34;: 18, \u0026#34;weight\u0026#34;: 50.0, \u0026#34;info\u0026#34;: \u0026#34;æ›¾å·å¸‚ç¬¬ä¸€ä¸­å­¦é«˜ä¸‰ä¸€ç­å¼ è–›\u0026#34;, \u0026#34;email\u0026#34;: \u0026#34;zhangxue@163.com\u0026#34;, \u0026#34;score\u0026#34;: [92.1, 93.2], \u0026#34;name\u0026#34;: { \u0026#34;firstName\u0026#34;: \u0026#34;è–›\u0026#34;, \u0026#34;lastName\u0026#34;: \u0026#34;å¼ \u0026#34; } } // å“åº”ç»“æœ { \u0026#34;_index\u0026#34;: \u0026#34;users\u0026#34;, \u0026#34;_id\u0026#34;: \u0026#34;orl0ZZEBrAuQs0dUWDfg\u0026#34;, \u0026#34;_version\u0026#34;: 1, \u0026#34;result\u0026#34;: \u0026#34;created\u0026#34;, \u0026#34;_shards\u0026#34;: { \u0026#34;total\u0026#34;: 1, \u0026#34;successful\u0026#34;: 1, \u0026#34;failed\u0026#34;: 0 }, \u0026#34;_seq_no\u0026#34;: 0, \u0026#34;_primary_term\u0026#34;: 1 } 1 2 3 4 5 6 7 8 9 10 11 12 13 POST /alias_users/_doc/2 { \u0026#34;age\u0026#34;: 17, \u0026#34;weight\u0026#34;: 52.4, \u0026#34;isMarried\u0026#34;: true, \u0026#34;info\u0026#34;: \u0026#34;æ›¾å·å¸‚ç¬¬ä¸€ä¸­å­¦é«˜ä¸‰ä¸€ç­è–›é«˜\u0026#34;, \u0026#34;email\u0026#34;: \u0026#34;zhangxue@163.com\u0026#34;, \u0026#34;score\u0026#34;: [96.1, 91.2], \u0026#34;name\u0026#34;: { \u0026#34;firstName\u0026#34;: \u0026#34;é«˜\u0026#34;, \u0026#34;lastName\u0026#34;: \u0026#34;è–›\u0026#34; } } // å“åº”ç»“æœ { \u0026#34;_index\u0026#34;: \u0026#34;users\u0026#34;, \u0026#34;_id\u0026#34;: \u0026#34;2\u0026#34;, \u0026#34;_version\u0026#34;: 1, \u0026#34;result\u0026#34;: \u0026#34;created\u0026#34;, \u0026#34;_shards\u0026#34;: { \u0026#34;total\u0026#34;: 1, \u0026#34;successful\u0026#34;: 1, \u0026#34;failed\u0026#34;: 0 }, \u0026#34;_seq_no\u0026#34;: 1, \u0026#34;_primary_term\u0026#34;: 1 } æŸ¥çœ‹ 1 GET /alias_users/_doc/orl0ZZEBrAuQs0dUWDfg // å“åº”ç»“æœ { \u0026#34;_index\u0026#34;: \u0026#34;users\u0026#34;, \u0026#34;_id\u0026#34;: \u0026#34;orl0ZZEBrAuQs0dUWDfg\u0026#34;, \u0026#34;_version\u0026#34;: 1, \u0026#34;_seq_no\u0026#34;: 0, \u0026#34;_primary_term\u0026#34;: 1, \u0026#34;found\u0026#34;: true, \u0026#34;_source\u0026#34;: { \u0026#34;age\u0026#34;: 18, \u0026#34;weight\u0026#34;: 50, \u0026#34;info\u0026#34;: \u0026#34;æ›¾å·å¸‚ç¬¬ä¸€ä¸­å­¦é«˜ä¸‰ä¸€ç­å¼ è–›\u0026#34;, \u0026#34;email\u0026#34;: \u0026#34;zhangxue@163.com\u0026#34;, \u0026#34;score\u0026#34;: [ 92.1, 93.2 ], \u0026#34;name\u0026#34;: { \u0026#34;firstName\u0026#34;: \u0026#34;è–›\u0026#34;, \u0026#34;lastName\u0026#34;: \u0026#34;å¼ \u0026#34; } } } 1 GET /alias_users/_doc/2 // å“åº”ç»“æœ { \u0026#34;_index\u0026#34;: \u0026#34;users\u0026#34;, \u0026#34;_id\u0026#34;: \u0026#34;2\u0026#34;, \u0026#34;_version\u0026#34;: 1, \u0026#34;_seq_no\u0026#34;: 1, \u0026#34;_primary_term\u0026#34;: 1, \u0026#34;found\u0026#34;: true, \u0026#34;_source\u0026#34;: { \u0026#34;age\u0026#34;: 17, \u0026#34;weight\u0026#34;: 52.4, \u0026#34;isMarried\u0026#34;: true, \u0026#34;info\u0026#34;: \u0026#34;æ›¾å·å¸‚ç¬¬ä¸€ä¸­å­¦é«˜ä¸‰ä¸€ç­è–›é«˜\u0026#34;, \u0026#34;email\u0026#34;: \u0026#34;zhangxue@163.com\u0026#34;, \u0026#34;score\u0026#34;: [ 96.1, 91.2 ], \u0026#34;name\u0026#34;: { \u0026#34;firstName\u0026#34;: \u0026#34;é«˜\u0026#34;, \u0026#34;lastName\u0026#34;: \u0026#34;è–›\u0026#34; } } } åˆ é™¤ DELETE /alias_users/_doc/1 ä¿®æ”¹ ä¿®æ”¹æœ‰ä¸¤ç§æ–¹å¼ï¼š\nå…¨é‡ä¿®æ”¹ï¼šç›´æ¥è¦†ç›–åŸæ¥çš„æ–‡æ¡£ã€‚ å¢é‡ä¿®æ”¹ï¼šä¿®æ”¹æ–‡æ¡£ä¸­çš„éƒ¨åˆ†å­—æ®µã€‚ å…¨é‡ä¿®æ”¹ å…¨é‡ä¿®æ”¹æ˜¯è¦†ç›–åŸæ¥çš„æ–‡æ¡£ï¼Œå…¶æœ¬è´¨æ˜¯ï¼š æ ¹æ®æŒ‡å®šçš„idåˆ é™¤æ–‡æ¡£ã€‚ æ–°å¢ä¸€ä¸ªç›¸åŒidçš„æ–‡æ¡£ã€‚ æ³¨æ„ï¼šå¦‚æœæ ¹æ®idåˆ é™¤æ—¶ï¼Œidä¸å­˜åœ¨ï¼Œç¬¬äºŒæ­¥çš„æ–°å¢ä¹Ÿä¼šæ‰§è¡Œï¼Œä¹Ÿå°±ä»ä¿®æ”¹å˜æˆäº†æ–°å¢æ“ä½œäº†ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 PUT /alias_users/_doc/1 { \u0026#34;age\u0026#34;: 20, \u0026#34;weight\u0026#34;: 50.0, \u0026#34;info\u0026#34;: \u0026#34;æ›¾å·å¸‚ç¬¬ä¸€ä¸­å­¦é«˜ä¸‰ä¸€ç­å¼ è–›\u0026#34;, \u0026#34;email\u0026#34;: \u0026#34;zhangxue@163.com\u0026#34;, \u0026#34;score\u0026#34;: [92.1, 93.2], \u0026#34;name\u0026#34;: { \u0026#34;firstName\u0026#34;: \u0026#34;è–›\u0026#34;, \u0026#34;lastName\u0026#34;: \u0026#34;å¼ \u0026#34; } } å¢é‡ä¿®æ”¹ å¢é‡ä¿®æ”¹æ˜¯åªä¿®æ”¹æŒ‡å®šidåŒ¹é…çš„æ–‡æ¡£ä¸­çš„éƒ¨åˆ†å­—æ®µã€‚ 1 2 3 4 5 6 POST /alias_users/_update/2 { \u0026#34;doc\u0026#34;: { \u0026#34;age\u0026#34;: 20 } } // å“åº”ç»“æœ { \u0026#34;_index\u0026#34;: \u0026#34;users\u0026#34;, \u0026#34;_id\u0026#34;: \u0026#34;2\u0026#34;, \u0026#34;_version\u0026#34;: 2, \u0026#34;result\u0026#34;: \u0026#34;updated\u0026#34;, \u0026#34;_shards\u0026#34;: { \u0026#34;total\u0026#34;: 1, \u0026#34;successful\u0026#34;: 1, \u0026#34;failed\u0026#34;: 0 }, \u0026#34;_seq_no\u0026#34;: 2, \u0026#34;_primary_term\u0026#34;: 1 } ","permalink":"https://heliu.site/posts/elasticsearch/document/","summary":"æ–‡æ¡£å¢åˆ æ”¹æŸ¥ã€‚","title":"æ–‡æ¡£CURD"},{"content":"æŸ¥è¯¢åˆ†ç±» æŸ¥è¯¢æ‰€æœ‰ match_all æŸ¥è¯¢å‡ºæ‰€æœ‰æ•°æ®ï¼Œä¸€èˆ¬æµ‹è¯•ç”¨ã€‚ 1 2 3 4 5 6 GETÂ /indexName/_search { \u0026#34;query\u0026#34;:Â { \u0026#34;match_all\u0026#34;:Â {} } } ç¤ºä¾‹ï¼š 1 2 3 4 5 6 GET /alias_users/_search { \u0026#34;query\u0026#34;: { \u0026#34;match_all\u0026#34;: {} } } { \u0026#34;took\u0026#34;: 5, \u0026#34;timed_out\u0026#34;: false, \u0026#34;_shards\u0026#34;: { \u0026#34;total\u0026#34;: 1, \u0026#34;successful\u0026#34;: 1, \u0026#34;skipped\u0026#34;: 0, \u0026#34;failed\u0026#34;: 0 }, \u0026#34;hits\u0026#34;: { \u0026#34;total\u0026#34;: { \u0026#34;value\u0026#34;: 2, \u0026#34;relation\u0026#34;: \u0026#34;eq\u0026#34; }, \u0026#34;max_score\u0026#34;: 1, \u0026#34;hits\u0026#34;: [ { \u0026#34;_index\u0026#34;: \u0026#34;users\u0026#34;, \u0026#34;_id\u0026#34;: \u0026#34;orl0ZZEBrAuQs0dUWDfg\u0026#34;, \u0026#34;_score\u0026#34;: 1, \u0026#34;_source\u0026#34;: { \u0026#34;age\u0026#34;: 18, \u0026#34;weight\u0026#34;: 50, \u0026#34;info\u0026#34;: \u0026#34;æ›¾å·å¸‚ç¬¬ä¸€ä¸­å­¦é«˜ä¸‰ä¸€ç­å¼ è–›\u0026#34;, \u0026#34;email\u0026#34;: \u0026#34;zhangxue@163.com\u0026#34;, \u0026#34;score\u0026#34;: [ 92.1, 93.2 ], \u0026#34;name\u0026#34;: { \u0026#34;firstName\u0026#34;: \u0026#34;è–›\u0026#34;, \u0026#34;lastName\u0026#34;: \u0026#34;å¼ \u0026#34; } } }, { \u0026#34;_index\u0026#34;: \u0026#34;users\u0026#34;, \u0026#34;_id\u0026#34;: \u0026#34;2\u0026#34;, \u0026#34;_score\u0026#34;: 1, \u0026#34;_source\u0026#34;: { \u0026#34;age\u0026#34;: 20, \u0026#34;weight\u0026#34;: 52.4, \u0026#34;isMarried\u0026#34;: true, \u0026#34;info\u0026#34;: \u0026#34;æ›¾å·å¸‚ç¬¬ä¸€ä¸­å­¦é«˜ä¸‰ä¸€ç­è–›é«˜\u0026#34;, \u0026#34;email\u0026#34;: \u0026#34;zhangxue@163.com\u0026#34;, \u0026#34;score\u0026#34;: [ 96.1, 91.2 ], \u0026#34;name\u0026#34;: { \u0026#34;firstName\u0026#34;: \u0026#34;é«˜\u0026#34;, \u0026#34;lastName\u0026#34;: \u0026#34;è–›\u0026#34; } } } ] } } å…¨æ–‡æ£€ç´¢ åˆ©ç”¨åˆ†è¯å™¨å¯¹ç”¨æˆ·è¾“å…¥å†…å®¹åˆ†è¯ï¼Œç„¶åå»å€’æ’ç´¢å¼•åº“ä¸­åŒ¹é…ã€‚\nmatch matchæŸ¥è¯¢ï¼šå•å­—æ®µæŸ¥è¯¢ï¼Œè¿›è¡Œåˆ†è¯åŒ¹é…æŸ¥è¯¢ã€‚ è¯­æ³•è¯´æ˜ï¼š 1 2 3 4 5 6 7 8 GET /indexName/_search { \u0026#34;query\u0026#34;: { \u0026#34;match\u0026#34;: { \u0026#34;FIELD\u0026#34;:Â \u0026#34;TEXT\u0026#34; } } } ç¤ºä¾‹ï¼š 1 2 3 4 5 6 7 8 9 10 GET /alias_users/_search { \u0026#34;query\u0026#34;: { \u0026#34;match\u0026#34;: { // ik_max_word åˆ†è¯ // å¼ ã€è–›ã€é«˜ä¸‰ã€ä¸‰ã€é«˜ \u0026#34;info\u0026#34;: \u0026#34;å¼ è–›é«˜ä¸‰è–›é«˜\u0026#34; } } } { \u0026#34;took\u0026#34;: 20, \u0026#34;timed_out\u0026#34;: false, \u0026#34;_shards\u0026#34;: { \u0026#34;total\u0026#34;: 1, \u0026#34;successful\u0026#34;: 1, \u0026#34;skipped\u0026#34;: 0, \u0026#34;failed\u0026#34;: 0 }, \u0026#34;hits\u0026#34;: { \u0026#34;total\u0026#34;: { \u0026#34;value\u0026#34;: 2, \u0026#34;relation\u0026#34;: \u0026#34;eq\u0026#34; }, \u0026#34;max_score\u0026#34;: 1.2401118, \u0026#34;hits\u0026#34;: [ { \u0026#34;_index\u0026#34;: \u0026#34;users\u0026#34;, \u0026#34;_id\u0026#34;: \u0026#34;orl0ZZEBrAuQs0dUWDfg\u0026#34;, \u0026#34;_score\u0026#34;: 1.2401118, \u0026#34;_source\u0026#34;: { \u0026#34;age\u0026#34;: 18, \u0026#34;weight\u0026#34;: 50, \u0026#34;info\u0026#34;: \u0026#34;æ›¾å·å¸‚ç¬¬ä¸€ä¸­å­¦é«˜ä¸‰ä¸€ç­å¼ è–›\u0026#34;, \u0026#34;email\u0026#34;: \u0026#34;zhangxue@163.com\u0026#34;, \u0026#34;score\u0026#34;: [ 92.1, 93.2 ], \u0026#34;name\u0026#34;: { \u0026#34;firstName\u0026#34;: \u0026#34;è–›\u0026#34;, \u0026#34;lastName\u0026#34;: \u0026#34;å¼ \u0026#34; } } }, { \u0026#34;_index\u0026#34;: \u0026#34;users\u0026#34;, \u0026#34;_id\u0026#34;: \u0026#34;2\u0026#34;, \u0026#34;_score\u0026#34;: 1.2401118, \u0026#34;_source\u0026#34;: { \u0026#34;age\u0026#34;: 20, \u0026#34;weight\u0026#34;: 52.4, \u0026#34;isMarried\u0026#34;: true, \u0026#34;info\u0026#34;: \u0026#34;æ›¾å·å¸‚ç¬¬ä¸€ä¸­å­¦é«˜ä¸‰ä¸€ç­è–›é«˜\u0026#34;, \u0026#34;email\u0026#34;: \u0026#34;zhangxue@163.com\u0026#34;, \u0026#34;score\u0026#34;: [ 96.1, 91.2 ], \u0026#34;name\u0026#34;: { \u0026#34;firstName\u0026#34;: \u0026#34;é«˜\u0026#34;, \u0026#34;lastName\u0026#34;: \u0026#34;è–›\u0026#34; } } } ] } } multi_match multi_matchæŸ¥è¯¢ï¼šå¤šå­—æ®µæŸ¥è¯¢ï¼Œä»»æ„ä¸€ä¸ªå­—æ®µç¬¦åˆæ¡ä»¶å°±ç®—ç¬¦åˆæŸ¥è¯¢æ¡ä»¶ã€‚ è¯­æ³•è¯´æ˜ï¼š 1 2 3 4 5 6 7 8 9 GETÂ /indexName/_search { \u0026#34;query\u0026#34;:Â { \u0026#34;multi_match\u0026#34;:Â { \u0026#34;query\u0026#34;:Â \u0026#34;TEXT\u0026#34;, \u0026#34;fields\u0026#34;:Â [\u0026#34;FIELD1\u0026#34;,Â \u0026#34; FIELD12\u0026#34;] } } } ç¤ºä¾‹ï¼šmulti_match è¦æ±‚æŸ¥è¯¢æŸ¥è¯¢å­—æ®µç±»å‹ä¸€è‡´ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 GETÂ /alias_users/_search { \u0026#34;query\u0026#34;:Â { \u0026#34;multi_match\u0026#34;:Â { // æŠ¥é”™ failed to create query: For input string: \u0026#34;å¼ è–›20å²\u0026#34; // ik_max_word åˆ†è¯ // å¼ ã€è–›ã€20ã€å² \u0026#34;query\u0026#34;:Â \u0026#34;å¼ è–›20å²\u0026#34;, // æ‚¨é‡åˆ°çš„é”™è¯¯æ˜¯å› ä¸ºmulti_matchæŸ¥è¯¢è¯•å›¾ç›´æ¥å°†æ•´ä¸ªå­—ç¬¦ä¸² // â€œå¼ è–›20å²â€ ä½œä¸ºæ•°å€¼æ¥å¤„ç†ï¼Œå› ä¸ºå®ƒåŒ¹é…åˆ°äº†æ•°å€¼å­—æ®µ â€œageâ€ã€‚ \u0026#34;fields\u0026#34;:Â [\u0026#34;age\u0026#34;,Â \u0026#34;info\u0026#34;] } } } ä½¿ç”¨ä¸åŒçš„æŸ¥è¯¢ç±»å‹ï¼šå¦‚æœæ‚¨æƒ³åœ¨ â€œageâ€ å­—æ®µä¸­æœç´¢æ•°å­—ï¼Œå¹¶ä¸”åœ¨å…¶ä»–å­—æ®µä¸­æœç´¢æ–‡æœ¬ï¼Œæ‚¨åº”è¯¥ä½¿ç”¨ä¸åŒçš„æŸ¥è¯¢ç±»å‹ï¼Œæ¯”å¦‚ bool æŸ¥è¯¢ç»“åˆ term å’Œ match æŸ¥è¯¢ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 GET /alias_users/_search { \u0026#34;query\u0026#34;: { \u0026#34;bool\u0026#34;: { \u0026#34;must\u0026#34;: [ // AND { \u0026#34;match\u0026#34;: { \u0026#34;info\u0026#34;: \u0026#34;å¼ è–›20å²\u0026#34; } } ], \u0026#34;should\u0026#34;: [ // OR { \u0026#34;term\u0026#34;: { \u0026#34;age\u0026#34;: 20 } } ] } } } ç²¾ç¡®æŸ¥è¯¢ æ ¹æ®ç²¾ç¡®è¯æ¡å€¼æŸ¥æ‰¾æ•°æ®ï¼Œä¸€èˆ¬æ˜¯æŸ¥æ‰¾keywordã€æ•°å€¼ã€æ—¥æœŸã€booleanç­‰ç±»å‹å­—æ®µã€‚æ‰€ä»¥ä¸ä¼šå¯¹æœç´¢æ¡ä»¶åˆ†è¯ã€‚ æ³¨æ„ï¼šå¤§å†™å­—æ¯åŒ¹é…ä¸åˆ°ï¼Œä½¿ç”¨å°å†™å­—æ¯ã€‚ term å› ä¸ºç²¾ç¡®æŸ¥è¯¢çš„å­—æ®µæœæ˜¯ä¸åˆ†è¯çš„å­—æ®µï¼Œå› æ­¤æŸ¥è¯¢çš„æ¡ä»¶ä¹Ÿå¿…é¡»æ˜¯ä¸åˆ†è¯çš„è¯æ¡ã€‚ æŸ¥è¯¢æ—¶ï¼Œç”¨æˆ·è¾“å…¥çš„å†…å®¹è·Ÿè‡ªåŠ¨å€¼å®Œå…¨åŒ¹é…æ—¶æ‰è®¤ä¸ºç¬¦åˆæ¡ä»¶ã€‚ å¦‚æœç”¨æˆ·è¾“å…¥çš„å†…å®¹è¿‡å¤šï¼Œåè€Œæœç´¢ä¸åˆ°æ•°æ®ã€‚ è¯­æ³•è¯´æ˜ï¼š 1 2 3 4 5 6 7 8 9 10 GET /indexName/_search { \u0026#34;query\u0026#34;: { \u0026#34;term\u0026#34;: { \u0026#34;FIELD\u0026#34;: { \u0026#34;value\u0026#34;: \u0026#34;Value\u0026#34; } } } } æŸ¥è¯¢ç¤ºä¾‹ï¼š 1 2 3 4 5 6 7 8 9 10 11 GET /alias_users/_search { \u0026#34;query\u0026#34;: { \u0026#34;term\u0026#34;: { // \u0026#34;age\u0026#34;: 20 \u0026#34;age\u0026#34;: { // age = 20 \u0026#34;value\u0026#34;: 20 } } } } { \u0026#34;took\u0026#34;: 60, \u0026#34;timed_out\u0026#34;: false, \u0026#34;_shards\u0026#34;: { \u0026#34;total\u0026#34;: 1, \u0026#34;successful\u0026#34;: 1, \u0026#34;skipped\u0026#34;: 0, \u0026#34;failed\u0026#34;: 0 }, \u0026#34;hits\u0026#34;: { \u0026#34;total\u0026#34;: { \u0026#34;value\u0026#34;: 1, \u0026#34;relation\u0026#34;: \u0026#34;eq\u0026#34; }, \u0026#34;max_score\u0026#34;: 1, \u0026#34;hits\u0026#34;: [ { \u0026#34;_index\u0026#34;: \u0026#34;users\u0026#34;, \u0026#34;_id\u0026#34;: \u0026#34;2\u0026#34;, \u0026#34;_score\u0026#34;: 1, \u0026#34;_source\u0026#34;: { \u0026#34;age\u0026#34;: 20, \u0026#34;weight\u0026#34;: 52.4, \u0026#34;isMarried\u0026#34;: true, \u0026#34;info\u0026#34;: \u0026#34;æ›¾å·å¸‚ç¬¬ä¸€ä¸­å­¦é«˜ä¸‰ä¸€ç­è–›é«˜\u0026#34;, \u0026#34;email\u0026#34;: \u0026#34;zhangxue@163.com\u0026#34;, \u0026#34;score\u0026#34;: [ 96.1, 91.2 ], \u0026#34;name\u0026#34;: { \u0026#34;firstName\u0026#34;: \u0026#34;é«˜\u0026#34;, \u0026#34;lastName\u0026#34;: \u0026#34;è–›\u0026#34; } } } ] } } terms terms æŸ¥è¯¢æ˜¯termçš„æ‰©å±•ï¼Œå¯ä»¥æ”¯æŒå¤šä¸ªvlaueåŒ¹é…ï¼Œåªéœ€è¦ä¸€ä¸ªåŒ¹é…å°±å¯ä»¥äº†ã€‚ 1 2 3 4 5 6 7 8 9 GET /alias_users/_search { \u0026#34;query\u0026#34;: { \u0026#34;terms\u0026#34;: { // age IN (18,20,17) \u0026#34;age\u0026#34;: [18,20,17] } } } { \u0026#34;took\u0026#34;: 1, \u0026#34;timed_out\u0026#34;: false, \u0026#34;_shards\u0026#34;: { \u0026#34;total\u0026#34;: 1, \u0026#34;successful\u0026#34;: 1, \u0026#34;skipped\u0026#34;: 0, \u0026#34;failed\u0026#34;: 0 }, \u0026#34;hits\u0026#34;: { \u0026#34;total\u0026#34;: { \u0026#34;value\u0026#34;: 2, \u0026#34;relation\u0026#34;: \u0026#34;eq\u0026#34; }, \u0026#34;max_score\u0026#34;: 1, \u0026#34;hits\u0026#34;: [ { \u0026#34;_index\u0026#34;: \u0026#34;users\u0026#34;, \u0026#34;_id\u0026#34;: \u0026#34;orl0ZZEBrAuQs0dUWDfg\u0026#34;, \u0026#34;_score\u0026#34;: 1, \u0026#34;_source\u0026#34;: { \u0026#34;age\u0026#34;: 18, \u0026#34;weight\u0026#34;: 50, \u0026#34;info\u0026#34;: \u0026#34;æ›¾å·å¸‚ç¬¬ä¸€ä¸­å­¦é«˜ä¸‰ä¸€ç­å¼ è–›\u0026#34;, \u0026#34;email\u0026#34;: \u0026#34;zhangxue@163.com\u0026#34;, \u0026#34;score\u0026#34;: [ 92.1, 93.2 ], \u0026#34;name\u0026#34;: { \u0026#34;firstName\u0026#34;: \u0026#34;è–›\u0026#34;, \u0026#34;lastName\u0026#34;: \u0026#34;å¼ \u0026#34; } } }, { \u0026#34;_index\u0026#34;: \u0026#34;users\u0026#34;, \u0026#34;_id\u0026#34;: \u0026#34;2\u0026#34;, \u0026#34;_score\u0026#34;: 1, \u0026#34;_source\u0026#34;: { \u0026#34;age\u0026#34;: 20, \u0026#34;weight\u0026#34;: 52.4, \u0026#34;isMarried\u0026#34;: true, \u0026#34;info\u0026#34;: \u0026#34;æ›¾å·å¸‚ç¬¬ä¸€ä¸­å­¦é«˜ä¸‰ä¸€ç­è–›é«˜\u0026#34;, \u0026#34;email\u0026#34;: \u0026#34;zhangxue@163.com\u0026#34;, \u0026#34;score\u0026#34;: [ 96.1, 91.2 ], \u0026#34;name\u0026#34;: { \u0026#34;firstName\u0026#34;: \u0026#34;é«˜\u0026#34;, \u0026#34;lastName\u0026#34;: \u0026#34;è–›\u0026#34; } } } ] } } range èŒƒå›´æŸ¥è¯¢ï¼Œä¸€èˆ¬åº”ç”¨åœ¨å¯¹æ•°å€¼ç±»å‹åšèŒƒå›´è¿‡æ»¤çš„æ—¶å€™ã€‚æ¯”å¦‚åšä»·æ ¼èŒƒå›´è¿‡æ»¤ã€‚ è¯­æ³•è¯´æ˜ï¼šæ”¯æŒå‚æ•° gteï¼šå¤§äºç­‰äºã€‚ gtï¼šå¤§äºã€‚ lteï¼šå°äºç­‰äºã€‚ ltï¼šç­‰äºã€‚ fromï¼šä»å“ªé‡Œå¼€å§‹ã€‚ toï¼šåˆ°å“ªé‡Œç»“æŸã€‚ include_lowerï¼šæ˜¯å¦åŒ…å«èŒƒå›´çš„å·¦è¾¹ç•Œï¼Œé»˜è®¤æ˜¯trueã€‚ include_upperï¼šæ˜¯å¦åŒ…å«èŒƒå›´çš„å³è¾¹ç•Œï¼Œé»˜è®¤æ˜¯trueã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 GET /indexName/_search { \u0026#34;query\u0026#34;: { \u0026#34;range\u0026#34;: { \u0026#34;FIELD\u0026#34;: { // gte -\u0026gt; \u0026gt;= // gt -\u0026gt; \u0026gt; \u0026#34;gte\u0026#34;: 10, // lte -\u0026gt; \u0026lt;= // lt -\u0026gt; \u0026lt; \u0026#34;lte\u0026#34;: 20 } } } } æŸ¥è¯¢ç¤ºä¾‹ï¼š 1 2 3 4 5 6 7 8 9 10 11 12 13 GET /alias_users/_search { \u0026#34;query\u0026#34;: { \u0026#34;range\u0026#34;: { \u0026#34;age\u0026#34;: { // age \u0026gt; 10 \u0026#34;gt\u0026#34;: 10, // age \u0026lt;= 20 \u0026#34;lte\u0026#34;: 20 } } } } { \u0026#34;took\u0026#34;: 16, \u0026#34;timed_out\u0026#34;: false, \u0026#34;_shards\u0026#34;: { \u0026#34;total\u0026#34;: 1, \u0026#34;successful\u0026#34;: 1, \u0026#34;skipped\u0026#34;: 0, \u0026#34;failed\u0026#34;: 0 }, \u0026#34;hits\u0026#34;: { \u0026#34;total\u0026#34;: { \u0026#34;value\u0026#34;: 2, \u0026#34;relation\u0026#34;: \u0026#34;eq\u0026#34; }, \u0026#34;max_score\u0026#34;: 1, \u0026#34;hits\u0026#34;: [ { \u0026#34;_index\u0026#34;: \u0026#34;users\u0026#34;, \u0026#34;_id\u0026#34;: \u0026#34;orl0ZZEBrAuQs0dUWDfg\u0026#34;, \u0026#34;_score\u0026#34;: 1, \u0026#34;_source\u0026#34;: { \u0026#34;age\u0026#34;: 18, \u0026#34;weight\u0026#34;: 50, \u0026#34;info\u0026#34;: \u0026#34;æ›¾å·å¸‚ç¬¬ä¸€ä¸­å­¦é«˜ä¸‰ä¸€ç­å¼ è–›\u0026#34;, \u0026#34;email\u0026#34;: \u0026#34;zhangxue@163.com\u0026#34;, \u0026#34;score\u0026#34;: [ 92.1, 93.2 ], \u0026#34;name\u0026#34;: { \u0026#34;firstName\u0026#34;: \u0026#34;è–›\u0026#34;, \u0026#34;lastName\u0026#34;: \u0026#34;å¼ \u0026#34; } } }, { \u0026#34;_index\u0026#34;: \u0026#34;users\u0026#34;, \u0026#34;_id\u0026#34;: \u0026#34;2\u0026#34;, \u0026#34;_score\u0026#34;: 1, \u0026#34;_source\u0026#34;: { \u0026#34;age\u0026#34;: 20, \u0026#34;weight\u0026#34;: 52.4, \u0026#34;isMarried\u0026#34;: true, \u0026#34;info\u0026#34;: \u0026#34;æ›¾å·å¸‚ç¬¬ä¸€ä¸­å­¦é«˜ä¸‰ä¸€ç­è–›é«˜\u0026#34;, \u0026#34;email\u0026#34;: \u0026#34;zhangxue@163.com\u0026#34;, \u0026#34;score\u0026#34;: [ 96.1, 91.2 ], \u0026#34;name\u0026#34;: { \u0026#34;firstName\u0026#34;: \u0026#34;é«˜\u0026#34;, \u0026#34;lastName\u0026#34;: \u0026#34;è–›\u0026#34; } } } ] } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 GET /alias_users/_search { \u0026#34;query\u0026#34;: { \u0026#34;range\u0026#34;: { // 20 \u0026gt; age \u0026gt;= 18 \u0026#34;age\u0026#34;: { \u0026#34;from\u0026#34;: 18, \u0026#34;to\u0026#34;: 20, \u0026#34;include_lower\u0026#34;: true, \u0026#34;include_upper\u0026#34;: false } } } } { \u0026#34;took\u0026#34;: 9, \u0026#34;timed_out\u0026#34;: false, \u0026#34;_shards\u0026#34;: { \u0026#34;total\u0026#34;: 1, \u0026#34;successful\u0026#34;: 1, \u0026#34;skipped\u0026#34;: 0, \u0026#34;failed\u0026#34;: 0 }, \u0026#34;hits\u0026#34;: { \u0026#34;total\u0026#34;: { \u0026#34;value\u0026#34;: 1, \u0026#34;relation\u0026#34;: \u0026#34;eq\u0026#34; }, \u0026#34;max_score\u0026#34;: 1, \u0026#34;hits\u0026#34;: [ { \u0026#34;_index\u0026#34;: \u0026#34;users\u0026#34;, \u0026#34;_id\u0026#34;: \u0026#34;orl0ZZEBrAuQs0dUWDfg\u0026#34;, \u0026#34;_score\u0026#34;: 1, \u0026#34;_source\u0026#34;: { \u0026#34;age\u0026#34;: 18, \u0026#34;weight\u0026#34;: 50, \u0026#34;info\u0026#34;: \u0026#34;æ›¾å·å¸‚ç¬¬ä¸€ä¸­å­¦é«˜ä¸‰ä¸€ç­å¼ è–›\u0026#34;, \u0026#34;email\u0026#34;: \u0026#34;zhangxue@163.com\u0026#34;, \u0026#34;score\u0026#34;: [ 92.1, 93.2 ], \u0026#34;name\u0026#34;: { \u0026#34;firstName\u0026#34;: \u0026#34;è–›\u0026#34;, \u0026#34;lastName\u0026#34;: \u0026#34;å¼ \u0026#34; } } } ] } } 1 2 3 4 5 6 7 8 9 10 11 12 13 GET /alias_users/_search { \u0026#34;query\u0026#34;: { \u0026#34;range\u0026#34;: { \u0026#34;birthday\u0026#34;: { \u0026#34;from\u0026#34;: \u0026#34;1990-10-10\u0026#34;, \u0026#34;to\u0026#34;: \u0026#34;2000-05-01\u0026#34;, \u0026#34;include_lower\u0026#34;: true, \u0026#34;include_upper\u0026#34;: false } } } } é€šé…ç¬¦ wildcard å…è®¸ä½¿ç”¨é€šé…ç¬¦ * å’Œ ? æ¥æŸ¥è¯¢ã€‚ * ä»£è¡¨0ä¸ªæˆ–å¤šä¸ªå­—ç¬¦ã€‚ ? ä»£è¡¨ä»»æ„ä¸€ä¸ªå­—ç¬¦ã€‚ åœ°ç†åæ ‡ çŸ©å½¢èŒƒå›´ çŸ©å½¢èŒƒå›´æŸ¥è¯¢ï¼Œä¹Ÿå°±æ˜¯geo_bounding_boxæŸ¥è¯¢ï¼ŒæŸ¥è¯¢åæ ‡è½åœ¨æŸä¸ªçŸ©å½¢èŒƒå›´çš„æ‰€æœ‰æ–‡æ¡£ã€‚ æŸ¥è¯¢æ—¶ï¼Œéœ€è¦æŒ‡å®šçŸ©å½¢çš„å·¦ä¸Šã€å³ä¸‹ä¸¤ä¸ªç‚¹çš„åæ ‡ï¼Œç„¶åç”»å‡ºä¸€ä¸ªçŸ©å½¢ï¼Œè½åœ¨è¯¥çŸ©å½¢å†…çš„éƒ½æ˜¯ç¬¦åˆæ¡ä»¶çš„ç‚¹ã€‚ è¯­æ³•è¯´æ˜ï¼š 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 //Â geo_bounding_boxæŸ¥è¯¢ GETÂ /indexName/_search { \u0026#34;query\u0026#34;:Â { \u0026#34;geo_bounding_box\u0026#34;:Â { \u0026#34;FIELD\u0026#34;:Â { \u0026#34;top_left\u0026#34;:Â { // å·¦ä¸Šç‚¹ \u0026#34;lat\u0026#34;:Â 31.1, \u0026#34;lon\u0026#34;:Â 121.5 }, \u0026#34;bottom_right\u0026#34;:Â { // å³ä¸‹ç‚¹ \u0026#34;lat\u0026#34;:Â 30.9, \u0026#34;lon\u0026#34;:Â 121.7 } } } } } é™„è¿‘æŸ¥è¯¢ é™„è¿‘æŸ¥è¯¢ï¼Œä¹Ÿå«åšè·ç¦»æŸ¥è¯¢ï¼ˆgeo_distanceï¼‰ï¼šæŸ¥è¯¢åˆ°æŒ‡å®šä¸­å¿ƒç‚¹å°äºæŸä¸ªè·ç¦»å€¼çš„æ‰€æœ‰æ–‡æ¡£ã€‚ æ¢å¥è¯æ¥è¯´ï¼Œåœ¨åœ°å›¾ä¸Šæ‰¾ä¸€ä¸ªç‚¹ä½œä¸ºåœ†å¿ƒï¼Œä»¥æŒ‡å®šè·ç¦»ä¸ºåŠå¾„ï¼Œç”»ä¸€ä¸ªåœ†ï¼Œè½åœ¨åœ†å†…çš„åæ ‡éƒ½ç®—ç¬¦åˆæ¡ä»¶ã€‚ è¯­æ³•è¯´æ˜ï¼š 1 2 3 4 5 6 7 8 9 10 //Â geo_distance æŸ¥è¯¢ GETÂ /indexName/_search { \u0026#34;query\u0026#34;:Â { \u0026#34;geo_distance\u0026#34;:Â { \u0026#34;distance\u0026#34;:Â \u0026#34;15km\u0026#34;, // åŠå¾„ \u0026#34;FIELD\u0026#34;:Â \u0026#34;31.21,121.5\u0026#34; // åœ†å¿ƒ } } } å¤åˆæŸ¥è¯¢ å¤åˆæŸ¥è¯¢å¯ä»¥å°†å…¶å®ƒç®€å•æŸ¥è¯¢ç»„åˆèµ·æ¥ï¼Œå®ç°æ›´å¤æ‚çš„æœç´¢é€»è¾‘ã€‚å¸¸è§çš„æœ‰ä¸¤ç§ï¼š fuction scoreï¼šç®—åˆ†å‡½æ•°æŸ¥è¯¢ï¼Œå¯ä»¥æ§åˆ¶æ–‡æ¡£ç›¸å…³æ€§ç®—åˆ†ï¼Œæ§åˆ¶æ–‡æ¡£æ’åã€‚ bool queryï¼šå¸ƒå°”æŸ¥è¯¢ï¼Œåˆ©ç”¨é€»è¾‘å…³ç³»ç»„åˆå¤šä¸ªå…¶å®ƒçš„æŸ¥è¯¢ï¼Œå®ç°å¤æ‚æœç´¢ã€‚ ç›¸å…³åº¦ç®—åˆ† å½“æˆ‘ä»¬åˆ©ç”¨matchæŸ¥è¯¢æ—¶ï¼Œæ–‡æ¡£ç»“æœä¼šæ ¹æ®ä¸æœç´¢è¯æ¡çš„å…³è”åº¦æ‰“åˆ†ï¼ˆ_scoreï¼‰ï¼Œè¿”å›ç»“æœæ—¶æŒ‰ç…§åˆ†å€¼é™åºæ’åˆ—ã€‚ åœ¨elasticsearchä¸­ï¼Œæ—©æœŸä½¿ç”¨çš„æ‰“åˆ†ç®—æ³•æ˜¯TF-IDFç®—æ³•ï¼Œåœ¨åæ¥çš„5.1ç‰ˆæœ¬å‡çº§ä¸­ï¼Œelasticsearchå°†ç®—æ³•æ”¹è¿›ä¸ºBM25ç®—æ³•ã€‚ TF-IDFç®—æ³•æœ‰ä¸€å„ç¼ºé™·ï¼Œå°±æ˜¯è¯æ¡é¢‘ç‡è¶Šé«˜ï¼Œæ–‡æ¡£å¾—åˆ†ä¹Ÿä¼šè¶Šé«˜ï¼Œå•ä¸ªè¯æ¡å¯¹æ–‡æ¡£å½±å“è¾ƒå¤§ã€‚è€ŒBM25åˆ™ä¼šè®©å•ä¸ªè¯æ¡çš„ç®—åˆ†æœ‰ä¸€ä¸ªä¸Šé™ï¼Œæ›²çº¿æ›´åŠ å¹³æ»‘ã€‚ ç®—åˆ†å‡½æ•° æ ¹æ®ç›¸å…³åº¦æ‰“åˆ†æ˜¯æ¯”è¾ƒåˆç†çš„éœ€æ±‚ï¼Œä½†åˆç†çš„ä¸ä¸€å®šæ˜¯äº§å“ç»ç†éœ€è¦çš„ã€‚ ä»¥ç™¾åº¦ä¸ºä¾‹ï¼Œä½ æœç´¢çš„ç»“æœä¸­ï¼Œå¹¶ä¸æ˜¯ç›¸å…³åº¦è¶Šé«˜æ’åè¶Šé å‰ï¼Œè€Œæ˜¯è°æçš„é’±å¤šæ’åå°±è¶Šé å‰ã€‚ è¦æƒ³è®¤ä¸ºæ§åˆ¶ç›¸å…³æ€§ç®—åˆ†ï¼Œå°±éœ€è¦åˆ©ç”¨elasticsearchä¸­çš„function score æŸ¥è¯¢äº†ã€‚ è¯­æ³•è¯´æ˜ï¼š function score æŸ¥è¯¢ä¸­åŒ…å«å››éƒ¨åˆ†å†…å®¹ï¼š åŸå§‹æŸ¥è¯¢æ¡ä»¶ï¼šqueryéƒ¨åˆ†ï¼ŒåŸºäºè¿™ä¸ªæ¡ä»¶æœç´¢æ–‡æ¡£ï¼Œå¹¶ä¸”åŸºäºBM25ç®—æ³•ç»™æ–‡æ¡£æ‰“åˆ†ï¼ŒåŸå§‹ç®—åˆ†ï¼ˆquery score)ã€‚ è¿‡æ»¤æ¡ä»¶ï¼šfilteréƒ¨åˆ†ï¼Œç¬¦åˆè¯¥æ¡ä»¶çš„æ–‡æ¡£æ‰ä¼šé‡æ–°ç®—åˆ†ã€‚ ç®—åˆ†å‡½æ•°ï¼šç¬¦åˆfilteræ¡ä»¶çš„æ–‡æ¡£è¦æ ¹æ®è¿™ä¸ªå‡½æ•°åšè¿ç®—ï¼Œå¾—åˆ°çš„å‡½æ•°ç®—åˆ†ï¼ˆfunction scoreï¼‰ï¼Œæœ‰å››ç§å‡½æ•°ï¼š weightï¼šå‡½æ•°ç»“æœæ˜¯å¸¸é‡ã€‚ field_value_factorï¼šä»¥æ–‡æ¡£ä¸­çš„æŸä¸ªå­—æ®µå€¼ä½œä¸ºå‡½æ•°ç»“æœã€‚ random_scoreï¼šä»¥éšæœºæ•°ä½œä¸ºå‡½æ•°ç»“æœã€‚ script_scoreï¼šè‡ªå®šä¹‰ç®—åˆ†å‡½æ•°ç®—æ³•ã€‚ è¿ç®—æ¨¡å¼ï¼šç®—åˆ†å‡½æ•°çš„ç»“æœã€åŸå§‹æŸ¥è¯¢çš„ç›¸å…³æ€§ç®—åˆ†ï¼Œä¸¤è€…ä¹‹é—´çš„è¿ç®—æ–¹å¼ï¼ŒåŒ…æ‹¬ï¼š multiplyï¼šç›¸ä¹˜ã€‚ replaceï¼šç”¨function scoreæ›¿æ¢query scoreã€‚ å…¶å®ƒï¼Œä¾‹å¦‚ï¼šsumã€avgã€maxã€minã€‚ function scoreçš„è¿è¡Œæµç¨‹å¦‚ä¸‹ï¼š 1ï¼‰æ ¹æ®åŸå§‹æ¡ä»¶æŸ¥è¯¢æœç´¢æ–‡æ¡£ï¼Œå¹¶ä¸”è®¡ç®—ç›¸å…³æ€§ç®—åˆ†ï¼Œç§°ä¸ºåŸå§‹ç®—åˆ†ï¼ˆquery scoreï¼‰ 2ï¼‰æ ¹æ®è¿‡æ»¤æ¡ä»¶ï¼Œè¿‡æ»¤æ–‡æ¡£ 3ï¼‰ç¬¦åˆè¿‡æ»¤æ¡ä»¶çš„æ–‡æ¡£ï¼ŒåŸºäºç®—åˆ†å‡½æ•°è¿ç®—ï¼Œå¾—åˆ°å‡½æ•°ç®—åˆ†ï¼ˆfunction scoreï¼‰ 4ï¼‰å°†åŸå§‹ç®—åˆ†ï¼ˆquery scoreï¼‰å’Œå‡½æ•°ç®—åˆ†ï¼ˆfunction scoreï¼‰åŸºäºè¿ç®—æ¨¡å¼åšè¿ç®—ï¼Œå¾—åˆ°æœ€ç»ˆç»“æœï¼Œä½œä¸ºç›¸å…³æ€§ç®—åˆ†ã€‚ å› æ­¤ï¼Œå…¶ä¸­çš„å…³é”®ç‚¹æ˜¯ï¼š è¿‡æ»¤æ¡ä»¶ï¼šå†³å®šå“ªäº›æ–‡æ¡£çš„ç®—åˆ†è¢«ä¿®æ”¹ ç®—åˆ†å‡½æ•°ï¼šå†³å®šå‡½æ•°ç®—åˆ†çš„ç®—æ³• è¿ç®—æ¨¡å¼ï¼šå†³å®šæœ€ç»ˆç®—åˆ†ç»“æœ ç¤ºä¾‹ï¼š éœ€æ±‚ï¼šç»™â€œå¦‚å®¶â€è¿™ä¸ªå“ç‰Œçš„é…’åº—æ’åé å‰ä¸€äº› ç¿»è¯‘ä¸€ä¸‹è¿™ä¸ªéœ€æ±‚ï¼Œè½¬æ¢ä¸ºä¹‹å‰è¯´çš„å››ä¸ªè¦ç‚¹ï¼š åŸå§‹æ¡ä»¶ï¼šä¸ç¡®å®šï¼Œå¯ä»¥ä»»æ„å˜åŒ– è¿‡æ»¤æ¡ä»¶ï¼šbrand = \u0026ldquo;å¦‚å®¶\u0026rdquo; ç®—åˆ†å‡½æ•°ï¼šå¯ä»¥ç®€å•ç²—æš´ï¼Œç›´æ¥ç»™å›ºå®šçš„ç®—åˆ†ç»“æœï¼Œweight è¿ç®—æ¨¡å¼ï¼šæ¯”å¦‚æ±‚å’Œ æœ€ç»ˆçš„DSLè¯­å¥å¦‚ä¸‹ï¼š 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 GETÂ /hotel/_search { \u0026#34;query\u0026#34;:Â { \u0026#34;function_score\u0026#34;:Â { \u0026#34;query\u0026#34;:Â { .... }, // åŸå§‹æŸ¥è¯¢ï¼Œå¯ä»¥æ˜¯ä»»æ„æ¡ä»¶ \u0026#34;functions\u0026#34;:Â [Â //Â ç®—åˆ†å‡½æ•° { \u0026#34;filter\u0026#34;:Â {Â //Â æ»¡è¶³çš„æ¡ä»¶ï¼Œå“ç‰Œå¿…é¡»æ˜¯å¦‚å®¶ \u0026#34;term\u0026#34;:Â { \u0026#34;brand\u0026#34;:Â \u0026#34;å¦‚å®¶\u0026#34; } }, \u0026#34;weight\u0026#34;:Â 2Â //Â ç®—åˆ†æƒé‡ä¸º2 } ], \u0026#34;boost_mode\u0026#34;: \u0026#34;sum\u0026#34; // åŠ æƒæ¨¡å¼ï¼Œæ±‚å’Œ } } } å¸ƒå°”æŸ¥è¯¢ å¸ƒå°”æŸ¥è¯¢æ˜¯ä¸€ä¸ªæˆ–å¤šä¸ªæŸ¥è¯¢å­å¥çš„ç»„åˆï¼Œæ¯ä¸€ä¸ªå­å¥å°±æ˜¯ä¸€ä¸ªå­æŸ¥è¯¢ã€‚å­æŸ¥è¯¢çš„ç»„åˆæ–¹å¼æœ‰ï¼š mustï¼šå¿…é¡»åŒ¹é…æ¯ä¸ªå­æŸ¥è¯¢ï¼Œç±»ä¼¼â€œä¸â€ shouldï¼šé€‰æ‹©æ€§åŒ¹é…å­æŸ¥è¯¢ï¼Œç±»ä¼¼â€œæˆ–â€ must_notï¼šå¿…é¡»ä¸åŒ¹é…ï¼Œä¸å‚ä¸ç®—åˆ†ï¼Œç±»ä¼¼â€œéâ€ filterï¼šå¿…é¡»åŒ¹é…ï¼Œä¸å‚ä¸ç®—åˆ† è¯­æ³•ç¤ºä¾‹ï¼š 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 GETÂ /index1/_search { \u0026#34;query\u0026#34;:Â { \u0026#34;bool\u0026#34;:Â { \u0026#34;must\u0026#34;:Â [ // å¿…é€‰ï¼Œç²¾ç¡®åŒ¹é… city {\u0026#34;term\u0026#34;:Â {\u0026#34;city\u0026#34;:Â \u0026#34;ä¸Šæµ·\u0026#34;Â }} ], \u0026#34;should\u0026#34;:Â [ {\u0026#34;term\u0026#34;:Â {\u0026#34;brand\u0026#34;:Â \u0026#34;çš‡å† å‡æ—¥\u0026#34;Â }}, {\u0026#34;term\u0026#34;:Â {\u0026#34;brand\u0026#34;:Â \u0026#34;åç¾è¾¾\u0026#34;Â }} ], \u0026#34;must_not\u0026#34;:Â [ // å¿…é¡»ä¸åŒ¹é… {Â \u0026#34;range\u0026#34;:Â {Â \u0026#34;price\u0026#34;:Â {Â \u0026#34;lte\u0026#34;:Â 500Â }Â }} ], \u0026#34;filter\u0026#34;:Â [ {Â \u0026#34;range\u0026#34;:Â {\u0026#34;score\u0026#34;:Â {Â \u0026#34;gte\u0026#34;:Â 45Â }Â }} ] } } } æœç´¢ç¤ºä¾‹ï¼š æ¯ä¸€ä¸ªä¸åŒçš„å­—æ®µï¼Œå…¶æŸ¥è¯¢çš„æ¡ä»¶ã€æ–¹å¼éƒ½ä¸ä¸€æ ·ï¼Œå¿…é¡»æ˜¯å¤šä¸ªä¸åŒçš„æŸ¥è¯¢ï¼Œè€Œè¦ç»„åˆè¿™äº›æŸ¥è¯¢ï¼Œå°±å¿…é¡»ç”¨boolæŸ¥è¯¢äº†ã€‚ éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œæœç´¢æ—¶ï¼Œå‚ä¸æ‰“åˆ†çš„å­—æ®µè¶Šå¤šï¼ŒæŸ¥è¯¢çš„æ€§èƒ½ä¹Ÿè¶Šå·®ã€‚å› æ­¤è¿™ç§å¤šæ¡ä»¶æŸ¥è¯¢æ—¶ï¼Œå»ºè®®è¿™æ ·åšï¼š æœç´¢æ¡†çš„å…³é”®å­—æœç´¢ï¼Œæ˜¯å…¨æ–‡æ£€ç´¢æŸ¥è¯¢ï¼Œä½¿ç”¨mustæŸ¥è¯¢ï¼Œå‚ä¸ç®—åˆ†ã€‚ å…¶å®ƒè¿‡æ»¤æ¡ä»¶ï¼Œé‡‡ç”¨filteræŸ¥è¯¢ï¼Œä¸å‚ä¸ç®—åˆ†ã€‚ æœç´¢åå­—åŒ…å«â€œå¦‚å®¶â€ï¼Œä»·æ ¼ä¸é«˜äº400ï¼Œåœ¨åæ ‡31.21,121.5å‘¨å›´10kmèŒƒå›´å†…çš„é…’åº—ã€‚ åç§°æœç´¢ï¼Œå±äºå…¨æ–‡æ£€ç´¢æŸ¥è¯¢ï¼Œåº”è¯¥å‚ä¸ç®—åˆ†ï¼Œæ”¾åˆ°mustä¸­ã€‚ ä»·æ ¼ä¸é«˜äº400ï¼Œç”¨rangeæŸ¥è¯¢ï¼Œå±äºè¿‡æ»¤æ¡ä»¶ï¼Œä¸å‚ä¸ç®—åˆ†ï¼Œæ”¾åˆ°must_notä¸­ã€‚ å‘¨å›´10kmèŒƒå›´å†…ï¼Œç”¨geo_distanceæŸ¥è¯¢ï¼Œå±äºè¿‡æ»¤æ¡ä»¶ï¼Œä¸å‚ä¸ç®—åˆ†ï¼Œæ”¾åˆ°filterä¸­ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 GETÂ /index1/_search { \u0026#34;query\u0026#34;:Â { \u0026#34;bool\u0026#34;:Â { \u0026#34;must\u0026#34;: { \u0026#34;match\u0026#34;: {\u0026#34;name\u0026#34;: \u0026#34;å¦‚å®¶\u0026#34;} }, \u0026#34;must_not\u0026#34;: { \u0026#34;range\u0026#34;: {\u0026#34;price\u0026#34;: {\u0026#34;gt\u0026#34;: 400}} }, \u0026#34;filter\u0026#34;: { \u0026#34;geo_distance\u0026#34;: { \u0026#34;distance\u0026#34;: \u0026#34;10km\u0026#34;, \u0026#34;location\u0026#34;: { \u0026#34;lat\u0026#34;: 31.11, \u0026#34;lon\u0026#34;: 120.21 } } } } } } æœç´¢ç»“æœ æ’åº elasticsearché»˜è®¤æ˜¯æ ¹æ®ç›¸å…³åº¦ç®—åˆ†ï¼ˆ_scoreï¼‰æ¥æ’åºï¼Œä½†æ˜¯ä¹Ÿæ”¯æŒè‡ªå®šä¹‰æ–¹å¼å¯¹æœç´¢ç»“æœæ’åºã€‚ å¯ä»¥æ’åºå­—æ®µç±»å‹æœ‰ï¼škeywordç±»å‹ã€æ•°å€¼ç±»å‹ã€åœ°ç†åæ ‡ç±»å‹ã€æ—¥æœŸç±»å‹ç­‰ã€‚descé™åºï¼Œascå‡åºã€‚ æ™®é€šå­—æ®µ keywordã€æ•°å€¼ã€æ—¥æœŸç±»å‹æ’åºçš„è¯­æ³•åŸºæœ¬ä¸€è‡´ã€‚ è¯­æ³•ï¼š 1 2 3 4 5 6 7 8 9 10 11 12 13 14 GETÂ /indexName/_search { \u0026#34;query\u0026#34;:Â { \u0026#34;match_all\u0026#34;:Â {} }, \u0026#34;sort\u0026#34;:Â [ { \u0026#34;FIELD\u0026#34;:Â \u0026#34;desc\u0026#34;Â //Â æ’åºå­—æ®µã€æ’åºæ–¹å¼ASCã€DESC }, { \u0026#34;FIELD\u0026#34;: \u0026#34;asc\u0026#34; } ] } æ’åºæ¡ä»¶æ˜¯ä¸€ä¸ªæ•°ç»„ï¼Œä¹Ÿå°±æ˜¯å¯ä»¥å†™å¤šä¸ªæ’åºæ¡ä»¶ã€‚æŒ‰ç…§å£°æ˜çš„é¡ºåºï¼Œå½“ç¬¬ä¸€ä¸ªæ¡ä»¶ç›¸ç­‰æ—¶ï¼Œå†æŒ‰ç…§ç¬¬äºŒä¸ªæ¡ä»¶æ’åºï¼Œä»¥æ­¤ç±»æ¨ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 GET /alias_users/_search { \u0026#34;query\u0026#34;: { \u0026#34;match_all\u0026#34;: {} }, \u0026#34;sort\u0026#34;: [ { \u0026#34;age\u0026#34;: \u0026#34;desc\u0026#34; // æ’åºå­—æ®µã€æ’åºæ–¹å¼ASCã€DESC }, { \u0026#34;weight\u0026#34;: \u0026#34;asc\u0026#34; } ] } åœ°ç†åæ ‡ åœ°ç†åæ ‡æ’åºç•¥æœ‰ä¸åŒã€‚ è¯­æ³•è¯´æ˜ï¼š æŒ‡å®šä¸€ä¸ªåæ ‡ï¼Œä½œä¸ºç›®æ ‡ç‚¹ã€‚ è®¡ç®—æ¯ä¸€ä¸ªæ–‡æ¡£ä¸­ï¼ŒæŒ‡å®šå­—æ®µï¼ˆå¿…é¡»æ˜¯geo_pointç±»å‹ï¼‰çš„åæ ‡ åˆ°ç›®æ ‡ç‚¹çš„è·ç¦»æ˜¯å¤šå°‘ã€‚ æ ¹æ®è·ç¦»æ’åºã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 GETÂ /indexName/_search { \u0026#34;query\u0026#34;:Â { \u0026#34;match_all\u0026#34;:Â {} }, \u0026#34;sort\u0026#34;:Â [ { \u0026#34;_geo_distance\u0026#34;Â :Â { // æ–‡æ¡£ä¸­geo_pointç±»å‹çš„å­—æ®µåã€ç›®æ ‡åæ ‡ç‚¹ \u0026#34;FIELD\u0026#34;Â :Â \u0026#34;çº¬åº¦ï¼Œç»åº¦\u0026#34;, // æ’åºæ–¹å¼ \u0026#34;order\u0026#34;Â :Â \u0026#34;asc\u0026#34;, // æ’åºçš„è·ç¦»å•ä½ \u0026#34;unit\u0026#34;Â :Â \u0026#34;km\u0026#34; } } ] } ç¤ºä¾‹ï¼šå®ç°å¯¹é…’åº—æ•°æ®æŒ‰ç…§åˆ°ä½ çš„ä½ç½®åæ ‡çš„è·ç¦»å‡åºæ’åºã€‚ è·å–ä½ çš„ä½ç½®çš„ç»çº¬åº¦çš„æ–¹å¼(é«˜å¾·API)ï¼šhttps://lbs.amap.com/demo/jsapi-v2/example/map/click-to-get-lnglat/ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 GET /alias_users/_search { \u0026#34;query\u0026#34;: { \u0026#34;match_all\u0026#34;: {} }, \u0026#34;sort\u0026#34;: [ { \u0026#34;_geo_distance\u0026#34;: { \u0026#34;location\u0026#34;: { \u0026#34;lat\u0026#34;: 30.12213, \u0026#34;lon\u0026#34;: 120.3221 }, \u0026#34;order\u0026#34;: \u0026#34;asc\u0026#34;, \u0026#34;unit\u0026#34;: \u0026#34;km\u0026#34; } } ] } åˆ†é¡µ elasticsearch é»˜è®¤æƒ…å†µä¸‹åªè¿”å›top10çš„æ•°æ®ã€‚è€Œå¦‚æœè¦æŸ¥è¯¢æ›´å¤šæ•°æ®å°±éœ€è¦ä¿®æ”¹åˆ†é¡µå‚æ•°äº†ã€‚ elasticsearchä¸­é€šè¿‡ä¿®æ”¹fromã€sizeå‚æ•°æ¥æ§åˆ¶è¦è¿”å›çš„åˆ†é¡µç»“æœï¼š fromï¼šä»ç¬¬å‡ ä¸ªæ–‡æ¡£å¼€å§‹ã€‚ sizeï¼šæ€»å…±æŸ¥è¯¢å‡ ä¸ªæ–‡æ¡£ã€‚ ç±»ä¼¼äºmysqlä¸­çš„limit ?, ?ã€‚ åŸºæœ¬åˆ†é¡µ åˆ†é¡µçš„åŸºæœ¬è¯­æ³•å¦‚ä¸‹ï¼š 1 2 3 4 5 6 7 8 9 10 11 GETÂ /hotel/_search { \u0026#34;query\u0026#34;:Â { \u0026#34;match_all\u0026#34;:Â {} }, \u0026#34;from\u0026#34;:Â 0,Â //Â åˆ†é¡µå¼€å§‹çš„ä½ç½®ï¼Œé»˜è®¤ä¸º0 \u0026#34;size\u0026#34;:Â 10,Â //Â æœŸæœ›è·å–çš„æ–‡æ¡£æ€»æ•° \u0026#34;sort\u0026#34;:Â [ {\u0026#34;price\u0026#34;:Â \u0026#34;asc\u0026#34;} ] } æ·±åº¦åˆ†é¡µ ç°åœ¨ï¼Œæˆ‘è¦æŸ¥è¯¢990~1000çš„æ•°æ®ï¼ŒæŸ¥è¯¢é€»è¾‘è¦è¿™ä¹ˆå†™ï¼š 1 2 3 4 5 6 7 8 9 10 11 12 GETÂ /hotel/_search { \u0026#34;query\u0026#34;:Â { \u0026#34;match_all\u0026#34;:Â {} }, // è¿™é‡Œæ˜¯æŸ¥è¯¢990å¼€å§‹çš„æ•°æ®ï¼Œä¹Ÿå°±æ˜¯ç¬¬990~ç¬¬1000æ¡æ•°æ®ã€‚ \u0026#34;from\u0026#34;:Â 990,Â //Â åˆ†é¡µå¼€å§‹çš„ä½ç½®ï¼Œé»˜è®¤ä¸º0 \u0026#34;size\u0026#34;:Â 10,Â //Â æœŸæœ›è·å–çš„æ–‡æ¡£æ€»æ•° \u0026#34;sort\u0026#34;:Â [ {\u0026#34;price\u0026#34;:Â \u0026#34;asc\u0026#34;} ] } å½“æŸ¥è¯¢åˆ†é¡µæ·±åº¦è¾ƒå¤§æ—¶ï¼Œæ±‡æ€»æ•°æ®è¿‡å¤šï¼Œå¯¹å†…å­˜å’ŒCPUä¼šäº§ç”Ÿéå¸¸å¤§çš„å‹åŠ›ï¼Œå› æ­¤elasticsearchä¼šç¦æ­¢from+ size è¶…è¿‡10000çš„è¯·æ±‚ã€‚ é’ˆå¯¹æ·±åº¦åˆ†é¡µï¼ŒESæä¾›äº†ä¸¤ç§è§£å†³æ–¹æ¡ˆï¼Œå®˜æ–¹æ–‡æ¡£ï¼š search afterï¼šåˆ†é¡µæ—¶éœ€è¦æ’åºï¼ŒåŸç†æ˜¯ä»ä¸Šä¸€æ¬¡çš„æ’åºå€¼å¼€å§‹ï¼ŒæŸ¥è¯¢ä¸‹ä¸€é¡µæ•°æ®ã€‚å®˜æ–¹æ¨èä½¿ç”¨çš„æ–¹å¼ã€‚ scrollï¼šåŸç†å°†æ’åºåçš„æ–‡æ¡£idå½¢æˆå¿«ç…§ï¼Œä¿å­˜åœ¨å†…å­˜ã€‚å®˜æ–¹å·²ç»ä¸æ¨èä½¿ç”¨ã€‚ å°ç»“ åˆ†é¡µæŸ¥è¯¢çš„å¸¸è§å®ç°æ–¹æ¡ˆä»¥åŠä¼˜ç¼ºç‚¹ï¼š from + sizeï¼š ä¼˜ç‚¹ï¼šæ”¯æŒéšæœºç¿»é¡µ ç¼ºç‚¹ï¼šæ·±åº¦åˆ†é¡µé—®é¢˜ï¼Œé»˜è®¤æŸ¥è¯¢ä¸Šé™ï¼ˆfrom + sizeï¼‰æ˜¯10000 åœºæ™¯ï¼šç™¾åº¦ã€äº¬ä¸œã€è°·æ­Œã€æ·˜å®è¿™æ ·çš„éšæœºç¿»é¡µæœç´¢ after searchï¼š ä¼˜ç‚¹ï¼šæ²¡æœ‰æŸ¥è¯¢ä¸Šé™ï¼ˆå•æ¬¡æŸ¥è¯¢çš„sizeä¸è¶…è¿‡10000ï¼‰ ç¼ºç‚¹ï¼šåªèƒ½å‘åé€é¡µæŸ¥è¯¢ï¼Œä¸æ”¯æŒéšæœºç¿»é¡µ åœºæ™¯ï¼šæ²¡æœ‰éšæœºç¿»é¡µéœ€æ±‚çš„æœç´¢ï¼Œä¾‹å¦‚æ‰‹æœºå‘ä¸‹æ»šåŠ¨ç¿»é¡µ scrollï¼š ä¼˜ç‚¹ï¼šæ²¡æœ‰æŸ¥è¯¢ä¸Šé™ï¼ˆå•æ¬¡æŸ¥è¯¢çš„sizeä¸è¶…è¿‡10000ï¼‰ ç¼ºç‚¹ï¼šä¼šæœ‰é¢å¤–å†…å­˜æ¶ˆè€—ï¼Œå¹¶ä¸”æœç´¢ç»“æœæ˜¯éå®æ—¶çš„ åœºæ™¯ï¼šæµ·é‡æ•°æ®çš„è·å–å’Œè¿ç§»ã€‚ä»ES7.1å¼€å§‹ä¸æ¨èï¼Œå»ºè®®ç”¨ after searchæ–¹æ¡ˆã€‚ é«˜äº® é«˜äº®åŸç† æˆ‘ä»¬åœ¨ç™¾åº¦ï¼Œäº¬ä¸œæœç´¢æ—¶ï¼Œå…³é”®å­—ä¼šå˜æˆçº¢è‰²ï¼Œæ¯”è¾ƒé†’ç›®ï¼Œè¿™å«é«˜äº®æ˜¾ç¤ºã€‚ é«˜äº®æ˜¾ç¤ºçš„å®ç°åˆ†ä¸ºä¸¤æ­¥ï¼š ç»™æ–‡æ¡£ä¸­çš„æ‰€æœ‰å…³é”®å­—éƒ½æ·»åŠ ä¸€ä¸ªæ ‡ç­¾ï¼Œä¾‹å¦‚\u0026lt;em\u0026gt;æ ‡ç­¾ã€‚ é¡µé¢ç»™\u0026lt;em\u0026gt;æ ‡ç­¾ç¼–å†™CSSæ ·å¼ã€‚ é«˜äº®å®ç° è¯­æ³•è¯´æ˜ï¼š é«˜äº®æ˜¯å¯¹å…³é”®å­—é«˜äº®ï¼Œå› æ­¤æœç´¢æ¡ä»¶å¿…é¡»å¸¦æœ‰å…³é”®å­—ï¼Œè€Œä¸èƒ½æ˜¯èŒƒå›´è¿™æ ·çš„æŸ¥è¯¢ã€‚ é»˜è®¤æƒ…å†µä¸‹ï¼Œé«˜äº®çš„å­—æ®µï¼Œå¿…é¡»ä¸æœç´¢æŒ‡å®šçš„å­—æ®µä¸€è‡´ï¼Œå¦åˆ™æ— æ³•é«˜äº®ã€‚ å¦‚æœè¦å¯¹éæœç´¢å­—æ®µé«˜äº®ï¼Œåˆ™éœ€è¦æ·»åŠ ä¸€ä¸ªå±æ€§ï¼šrequired_field_match=falseã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 GETÂ /hotel/_search { \u0026#34;query\u0026#34;:Â { \u0026#34;match\u0026#34;:Â { // æŸ¥è¯¢æ¡ä»¶ï¼Œé«˜äº®ä¸€å®šè¦ä½¿ç”¨å…¨æ–‡æ£€ç´¢æŸ¥è¯¢ \u0026#34;FIELD\u0026#34;:Â \u0026#34;TEXT\u0026#34; } }, \u0026#34;highlight\u0026#34;:Â { //Â æŒ‡å®šè¦é«˜äº®çš„å­—æ®µ \u0026#34;fields\u0026#34;:Â {Â \u0026#34;FIELD\u0026#34;:Â { //Â ç”¨æ¥æ ‡è®°é«˜äº®å­—æ®µçš„å‰ç½®æ ‡ç­¾ \u0026#34;pre_tags\u0026#34;:Â \u0026#34;\u0026lt;em\u0026gt;\u0026#34;,Â //Â ç”¨æ¥æ ‡è®°é«˜äº®å­—æ®µçš„åç½®æ ‡ç­¾ \u0026#34;post_tags\u0026#34;:Â \u0026#34;\u0026lt;/em\u0026gt;\u0026#34;Â } } } } ç¤ºä¾‹ï¼š 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 GET /hotel/_search { \u0026#34;query\u0026#34;: { \u0026#34;match\u0026#34;: { \u0026#34;name\u0026#34;: \u0026#34;7å¤©\u0026#34; }, \u0026#34;from\u0026#34;: 0, \u0026#34;size\u0026#34;: 20, \u0026#34;sort\u0026#34;: [ {\u0026#34;price\u0026#34;: \u0026#34;asc\u0026#34;}, { \u0026#34;_geo_distance\u0026#34;: { \u0026#34;location\u0026#34;: \u0026#34;30.1231,123.3213\u0026#34;, \u0026#34;order\u0026#34;: \u0026#34;asc\u0026#34;, \u0026#34;unit\u0026#34;: \u0026#34;km\u0026#34; } } ], \u0026#34;highlight\u0026#34;: { \u0026#34;fields\u0026#34;: { \u0026#34;name\u0026#34;: { \u0026#34;pre_tags\u0026#34;:Â \u0026#34;\u0026lt;em\u0026gt;\u0026#34;, \u0026#34;post_tags\u0026#34;:Â \u0026#34;\u0026lt;/em\u0026gt;\u0026#34; } } } } } å–æŒ‡å®šå­—æ®µ å¦‚æœæƒ³å–æŒ‡å®šçš„å­—æ®µä½¿ç”¨_sourceã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 GET /alias_users/_search { \u0026#34;_source\u0026#34;: [\u0026#34;age\u0026#34;, \u0026#34;weight\u0026#34;, \u0026#34;info\u0026#34;, \u0026#34;name\u0026#34;], \u0026#34;query\u0026#34;: { \u0026#34;range\u0026#34;: { \u0026#34;age\u0026#34;: { \u0026#34;gt\u0026#34;: 10, \u0026#34;lte\u0026#34;: 20 } } } } { \u0026#34;took\u0026#34;: 127, \u0026#34;timed_out\u0026#34;: false, \u0026#34;_shards\u0026#34;: { \u0026#34;total\u0026#34;: 1, \u0026#34;successful\u0026#34;: 1, \u0026#34;skipped\u0026#34;: 0, \u0026#34;failed\u0026#34;: 0 }, \u0026#34;hits\u0026#34;: { \u0026#34;total\u0026#34;: { \u0026#34;value\u0026#34;: 2, \u0026#34;relation\u0026#34;: \u0026#34;eq\u0026#34; }, \u0026#34;max_score\u0026#34;: 1, \u0026#34;hits\u0026#34;: [ { \u0026#34;_index\u0026#34;: \u0026#34;users\u0026#34;, \u0026#34;_id\u0026#34;: \u0026#34;orl0ZZEBrAuQs0dUWDfg\u0026#34;, \u0026#34;_score\u0026#34;: 1, \u0026#34;_source\u0026#34;: { \u0026#34;age\u0026#34;: 18, \u0026#34;weight\u0026#34;: 50, \u0026#34;info\u0026#34;: \u0026#34;æ›¾å·å¸‚ç¬¬ä¸€ä¸­å­¦é«˜ä¸‰ä¸€ç­å¼ è–›\u0026#34;, \u0026#34;name\u0026#34;: { \u0026#34;firstName\u0026#34;: \u0026#34;è–›\u0026#34;, \u0026#34;lastName\u0026#34;: \u0026#34;å¼ \u0026#34; } } }, { \u0026#34;_index\u0026#34;: \u0026#34;users\u0026#34;, \u0026#34;_id\u0026#34;: \u0026#34;2\u0026#34;, \u0026#34;_score\u0026#34;: 1, \u0026#34;_source\u0026#34;: { \u0026#34;age\u0026#34;: 20, \u0026#34;weight\u0026#34;: 52.4, \u0026#34;info\u0026#34;: \u0026#34;æ›¾å·å¸‚ç¬¬ä¸€ä¸­å­¦é«˜ä¸‰ä¸€ç­è–›é«˜\u0026#34;, \u0026#34;name\u0026#34;: { \u0026#34;firstName\u0026#34;: \u0026#34;é«˜\u0026#34;, \u0026#34;lastName\u0026#34;: \u0026#34;è–›\u0026#34; } } } ] } } æ˜¾ç¤ºè¦çš„å­—æ®µã€å»é™¤ä¸éœ€è¦çš„å­—æ®µã€å¯ä»¥ä½¿ç”¨é€šé…ç¬¦*ã€‚ 1 2 3 4 5 6 7 8 9 10 GET /alias_users/_search { \u0026#34;_source\u0026#34;:{ // éœ€è¦å­—æ®µ \u0026#34;includes\u0026#34;: \u0026#34;addr*\u0026#34;, // æ’é™¤å­—æ®µ \u0026#34;excludes\u0026#34;: [\u0026#34;name\u0026#34;, \u0026#34;bir*\u0026#34;] }, \u0026#34;query\u0026#34;: {\u0026#34;match_all\u0026#34;: {}} } ç‰ˆæœ¬å· 1 2 3 4 5 6 7 8 9 10 11 12 13 GET /alias_users/_search { \u0026#34;_source\u0026#34;: [\u0026#34;age\u0026#34;, \u0026#34;weight\u0026#34;, \u0026#34;info\u0026#34;, \u0026#34;name\u0026#34;], \u0026#34;version\u0026#34;: true, \u0026#34;query\u0026#34;: { \u0026#34;range\u0026#34;: { \u0026#34;age\u0026#34;: { \u0026#34;gt\u0026#34;: 10, \u0026#34;lte\u0026#34;: 20 } } } } { \u0026#34;took\u0026#34;: 48, \u0026#34;timed_out\u0026#34;: false, \u0026#34;_shards\u0026#34;: { \u0026#34;total\u0026#34;: 1, \u0026#34;successful\u0026#34;: 1, \u0026#34;skipped\u0026#34;: 0, \u0026#34;failed\u0026#34;: 0 }, \u0026#34;hits\u0026#34;: { \u0026#34;total\u0026#34;: { \u0026#34;value\u0026#34;: 2, \u0026#34;relation\u0026#34;: \u0026#34;eq\u0026#34; }, \u0026#34;max_score\u0026#34;: 1, \u0026#34;hits\u0026#34;: [ { \u0026#34;_index\u0026#34;: \u0026#34;users\u0026#34;, \u0026#34;_id\u0026#34;: \u0026#34;orl0ZZEBrAuQs0dUWDfg\u0026#34;, \u0026#34;_version\u0026#34;: 1, \u0026#34;_score\u0026#34;: 1, \u0026#34;_source\u0026#34;: { \u0026#34;age\u0026#34;: 18, \u0026#34;weight\u0026#34;: 50, \u0026#34;info\u0026#34;: \u0026#34;æ›¾å·å¸‚ç¬¬ä¸€ä¸­å­¦é«˜ä¸‰ä¸€ç­å¼ è–›\u0026#34;, \u0026#34;name\u0026#34;: { \u0026#34;firstName\u0026#34;: \u0026#34;è–›\u0026#34;, \u0026#34;lastName\u0026#34;: \u0026#34;å¼ \u0026#34; } } }, { \u0026#34;_index\u0026#34;: \u0026#34;users\u0026#34;, \u0026#34;_id\u0026#34;: \u0026#34;2\u0026#34;, \u0026#34;_version\u0026#34;: 2, \u0026#34;_score\u0026#34;: 1, \u0026#34;_source\u0026#34;: { \u0026#34;age\u0026#34;: 20, \u0026#34;weight\u0026#34;: 52.4, \u0026#34;info\u0026#34;: \u0026#34;æ›¾å·å¸‚ç¬¬ä¸€ä¸­å­¦é«˜ä¸‰ä¸€ç­è–›é«˜\u0026#34;, \u0026#34;name\u0026#34;: { \u0026#34;firstName\u0026#34;: \u0026#34;é«˜\u0026#34;, \u0026#34;lastName\u0026#34;: \u0026#34;è–›\u0026#34; } } } ] } } ","permalink":"https://heliu.site/posts/elasticsearch/query/","summary":"æŸ¥è¯¢æ–‡æ¡£ã€‚","title":"Query"},{"content":" å‚åŠ èšåˆçš„å­—æ®µå¿…é¡»æ˜¯keywordã€æ—¥æœŸã€æ•°å€¼ã€å¸ƒå°”ç±»å‹ã€‚ Bucketèšåˆ è¦ç»Ÿè®¡æ‰€æœ‰æ•°æ®ä¸­çš„é…’åº—å“ç‰Œæœ‰å‡ ç§ï¼Œå…¶å®å°±æ˜¯æŒ‰ç…§å“ç‰Œå¯¹æ•°æ®åˆ†ç»„ã€‚æ­¤æ—¶å¯ä»¥æ ¹æ®é…’åº—å“ç‰Œçš„åç§°åšèšåˆï¼Œä¹Ÿå°±æ˜¯Bucketèšåˆã€‚ èšåˆè¯­æ³•ï¼šBucketèšåˆç”¨æ¥å¯¹æ–‡æ¡£åšåˆ†ç»„ GET /indexName/_search { //Â è®¾ç½®sizeä¸º0ï¼Œç»“æœä¸­ä¸åŒ…å«æ–‡æ¡£ï¼ŒåªåŒ…å«èšåˆç»“æœ \u0026#34;size\u0026#34;: 0, \u0026#34;aggs\u0026#34;:Â {Â //Â å®šä¹‰èšåˆ \u0026#34;brandAgg\u0026#34;:Â {Â //ç»™èšåˆèµ·ä¸ªåå­— \u0026#34;terms\u0026#34;:Â {Â //Â èšåˆçš„ç±»å‹ï¼ŒæŒ‰ç…§å“ç‰Œå€¼èšåˆï¼Œæ‰€ä»¥é€‰æ‹©term \u0026#34;field\u0026#34;:Â \u0026#34;brand\u0026#34;,Â //Â å‚ä¸èšåˆçš„å­—æ®µ \u0026#34;size\u0026#34;:Â 20Â //Â å¸Œæœ›è·å–çš„èšåˆç»“æœæ•°é‡ } } } } èšåˆç»“æœæ’åº é»˜è®¤æƒ…å†µä¸‹ï¼ŒBucketèšåˆä¼šç»Ÿè®¡Bucketå†…çš„æ–‡æ¡£æ•°é‡ï¼Œè®°ä¸º_countï¼Œå¹¶ä¸”æŒ‰ç…§_counté™åºæ’åºã€‚ æˆ‘ä»¬å¯ä»¥æŒ‡å®šorderå±æ€§ï¼Œè‡ªå®šä¹‰èšåˆçš„æ’åºæ–¹å¼ï¼š GETÂ /indexName/_search { \u0026#34;size\u0026#34;:Â 0,Â \u0026#34;aggs\u0026#34;:Â { \u0026#34;brandAgg\u0026#34;:Â { \u0026#34;terms\u0026#34;:Â { \u0026#34;field\u0026#34;:Â \u0026#34;brand\u0026#34;, \u0026#34;order\u0026#34;:Â { \u0026#34;_count\u0026#34;:Â \u0026#34;asc\u0026#34; //Â æŒ‰ç…§_countå‡åºæ’åˆ— }, \u0026#34;size\u0026#34;:Â 20 } } } } é™å®šèšåˆèŒƒå›´ é»˜è®¤æƒ…å†µä¸‹ï¼ŒBucketèšåˆæ˜¯å¯¹ç´¢å¼•åº“çš„æ‰€æœ‰æ–‡æ¡£åšèšåˆï¼Œä½†çœŸå®åœºæ™¯ä¸‹ï¼Œç”¨æˆ·ä¼šè¾“å…¥æœç´¢æ¡ä»¶ï¼Œå› æ­¤èšåˆå¿…é¡»æ˜¯å¯¹æœç´¢ç»“æœèšåˆã€‚é‚£ä¹ˆèšåˆå¿…é¡»æ·»åŠ é™å®šæ¡ä»¶ã€‚ æˆ‘ä»¬å¯ä»¥é™å®šè¦èšåˆçš„æ–‡æ¡£èŒƒå›´ï¼Œåªè¦æ·»åŠ queryæ¡ä»¶å³å¯ï¼š GETÂ /hotel/_search { \u0026#34;query\u0026#34;:Â { \u0026#34;range\u0026#34;:Â { \u0026#34;price\u0026#34;:Â { \u0026#34;lte\u0026#34;:Â 200 // åªå¯¹200å…ƒä»¥ä¸‹çš„æ–‡æ¡£èšåˆ } } },Â \u0026#34;size\u0026#34;:Â 0,Â \u0026#34;aggs\u0026#34;:Â { \u0026#34;brandAgg\u0026#34;:Â { \u0026#34;terms\u0026#34;:Â { \u0026#34;field\u0026#34;:Â \u0026#34;brand\u0026#34;, \u0026#34;size\u0026#34;:Â 20 } } } } Metricèšåˆ æ¡¶èšåˆå¯¹é…’åº—æŒ‰ç…§å“ç‰Œåˆ†ç»„ï¼Œå½¢æˆäº†ä¸€ä¸ªä¸ªæ¡¶ã€‚ç°åœ¨æˆ‘ä»¬éœ€è¦å¯¹æ¡¶å†…çš„é…’åº—åšè¿ç®—ï¼Œè·å–æ¯ä¸ªå“ç‰Œçš„ç”¨æˆ·è¯„åˆ†çš„minã€maxã€avgç­‰å€¼ã€‚ Metricèšåˆï¼Œä¾‹å¦‚statèšåˆï¼šå°±å¯ä»¥è·å–minã€maxã€avgç­‰ç»“æœã€‚ è¿™æ¬¡çš„score_statsèšåˆæ˜¯åœ¨brandAggçš„èšåˆå†…éƒ¨åµŒå¥—çš„å­èšåˆã€‚å› ä¸ºæˆ‘ä»¬éœ€è¦åœ¨æ¯ä¸ªæ¡¶åˆ†åˆ«è®¡ç®—ã€‚ ä½¿ç”¨è¯­æ³•ï¼š GETÂ /hotel/_search { \u0026#34;size\u0026#34;:Â 0,Â \u0026#34;aggs\u0026#34;:Â { \u0026#34;brandAgg\u0026#34;:Â {Â \u0026#34;terms\u0026#34;:Â {Â \u0026#34;field\u0026#34;:Â \u0026#34;brand\u0026#34;,Â \u0026#34;size\u0026#34;:Â 20 }, \u0026#34;aggs\u0026#34;:Â {Â //Â æ˜¯brandsèšåˆçš„å­èšåˆï¼Œä¹Ÿå°±æ˜¯åˆ†ç»„åå¯¹æ¯ç»„åˆ†åˆ«è®¡ç®— \u0026#34;score_stats\u0026#34;:Â {Â //Â èšåˆåç§° \u0026#34;stats\u0026#34;:Â {Â //Â èšåˆç±»å‹ï¼Œè¿™é‡Œstatså¯ä»¥è®¡ç®—minã€maxã€avgç­‰ \u0026#34;field\u0026#34;:Â \u0026#34;score\u0026#34;Â //Â èšåˆå­—æ®µï¼Œè¿™é‡Œæ˜¯score } } } } } } å¦å¤–ï¼Œæˆ‘ä»¬è¿˜å¯ä»¥ç»™èšåˆç»“æœåšä¸ªæ’åºï¼Œä¾‹å¦‚æŒ‰ç…§æ¯ä¸ªæ¡¶çš„é…’åº—å¹³å‡åˆ†åšæ’åºï¼š GETÂ /hotel/_search { \u0026#34;size\u0026#34;:Â 0,Â \u0026#34;aggs\u0026#34;:Â { \u0026#34;brandAgg\u0026#34;:Â {Â \u0026#34;terms\u0026#34;:Â {Â \u0026#34;field\u0026#34;:Â \u0026#34;brand\u0026#34;,Â \u0026#34;size\u0026#34;:Â 20, \u0026#34;order\u0026#34;: { \u0026#34;scoreAgg.avg\u0026#34;: \u0026#34;desc\u0026#34; } }, \u0026#34;aggs\u0026#34;:Â {Â //Â æ˜¯brandsèšåˆçš„å­èšåˆï¼Œä¹Ÿå°±æ˜¯åˆ†ç»„åå¯¹æ¯ç»„åˆ†åˆ«è®¡ç®— \u0026#34;score_stats\u0026#34;:Â {Â //Â èšåˆåç§° \u0026#34;stats\u0026#34;:Â {Â //Â èšåˆç±»å‹ï¼Œè¿™é‡Œstatså¯ä»¥è®¡ç®—minã€maxã€avgç­‰ \u0026#34;field\u0026#34;:Â \u0026#34;score\u0026#34;Â //Â èšåˆå­—æ®µï¼Œè¿™é‡Œæ˜¯score } } } } } } ","permalink":"https://heliu.site/posts/elasticsearch/aggregate/","summary":"æ¡¶èšåˆã€åº¦é‡èšåˆã€ç®¡é“èšåˆç­‰ã€‚","title":"èšåˆ"},{"content":"åŒæ­¥æ–¹æ¡ˆ Mysqlæ•°æ®å‘ç”Ÿæ”¹å˜æ—¶ï¼ŒElasticSearchä¹Ÿå¿…é¡»è·Ÿç€æ”¹å˜ï¼Œè¿™ä¸ªå°±æ˜¯ElasticSearchä¸Mysqlä¹‹é—´çš„æ•°æ®åŒæ­¥ã€‚\nåŒæ­¥è°ƒç”¨ å°±æ˜¯Mysqlæ›´æ–°/æ–°å¢/åˆ é™¤æ•°æ®æ—¶ï¼ŒåŒæ­¥è°ƒç”¨ElasticSearchæ¥å£ã€‚ åŸºæœ¬æ­¥éª¤å¦‚ä¸‹ï¼š hotel-demoå¯¹å¤–æä¾›æ¥å£ï¼Œç”¨æ¥ä¿®æ”¹elasticsearchä¸­çš„æ•°æ®ã€‚ é…’åº—ç®¡ç†æœåŠ¡åœ¨å®Œæˆæ•°æ®åº“æ“ä½œåï¼Œç›´æ¥è°ƒç”¨hotel-demoæä¾›çš„æ¥å£ã€‚ ä¼˜ç‚¹ï¼šå®ç°ç®€å•ï¼Œç²—æš´ï¼›ç¼ºç‚¹ï¼šä¸šåŠ¡è€¦åˆåº¦é«˜ã€‚ å¼‚æ­¥é€šçŸ¥ å°±æ˜¯Mysqlæ›´æ–°/æ–°å¢/åˆ é™¤æ•°æ®æ—¶ï¼ŒæŠŠæ•°æ®æ”¾å…¥MQä¸­ï¼Œæ¶ˆè´¹çº¿ç¨‹å†è°ƒç”¨ElasticSearchæ¥å£ã€‚ åŸºæœ¬æµç¨‹ï¼š hotel-adminå¯¹mysqlæ•°æ®åº“æ•°æ®å®Œæˆå¢ã€åˆ ã€æ”¹åï¼Œå‘é€MQæ¶ˆæ¯ã€‚ hotel-demoç›‘å¬MQï¼Œæ¥æ”¶åˆ°æ¶ˆæ¯åå®Œæˆelasticsearchæ•°æ®ä¿®æ”¹ã€‚ ä¼˜ç‚¹ï¼šä½è€¦åˆï¼Œå®ç°éš¾åº¦ä¸€èˆ¬ï¼›ç¼ºç‚¹ï¼šä¾èµ–mqçš„å¯é æ€§ã€‚ ç›‘å¬binlog ç›‘å¬ Mysql çš„ binlogæ—¥å¿—ï¼š ç»™mysqlå¼€å¯binlogåŠŸèƒ½ã€‚ mysqlå®Œæˆå¢ã€åˆ ã€æ”¹æ“ä½œéƒ½ä¼šè®°å½•åœ¨binlogä¸­ã€‚ hotel-demoåŸºäºcanalç›‘å¬binlogå˜åŒ–ï¼Œå®æ—¶æ›´æ–°elasticsearchä¸­çš„å†…å®¹ã€‚ ä¼˜ç‚¹ï¼šå®Œå…¨è§£é™¤æœåŠ¡é—´è€¦åˆï¼›ç¼ºç‚¹ï¼šå¼€å¯binlogå¢åŠ æ•°æ®åº“è´Ÿæ‹…ã€å®ç°å¤æ‚åº¦é«˜ã€‚ ","permalink":"https://heliu.site/posts/elasticsearch/sync/","summary":"Mysqlæ•°æ®åŒæ­¥ElasticSearchã€‚","title":"æ•°æ®åŒæ­¥"},{"content":" ğŸ”¥å¦‚æœè§‰å¾—æˆ‘çš„æ–‡ç« å¯¹æ‚¨æœ‰ç”¨ï¼Œå¸®æˆ‘ä¹°æ¯â˜•ã€‚æ‚¨çš„æ”¯æŒå°†é¼“åŠ±æˆ‘ç»§ç»­åˆ›ä½œã€‚ğŸ‰ğŸ‰ğŸ‰\nwechat alipay ","permalink":"https://heliu.site/support/","summary":" ğŸ”¥å¦‚æœè§‰å¾—æˆ‘çš„æ–‡ç« å¯¹æ‚¨æœ‰ç”¨ï¼Œå¸®æˆ‘ä¹°æ¯â˜•ã€‚æ‚¨çš„æ”¯æŒå°†é¼“åŠ±æˆ‘ç»§ç»­åˆ›ä½œã€‚ğŸ‰ğŸ‰ğŸ‰\nwechat alipay ","title":"æ‰“èµ"}]