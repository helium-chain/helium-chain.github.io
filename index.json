[{"content":"type Pool struct Pool æ˜¯ä¸€ç»„å¯ä»¥å•ç‹¬ä¿å­˜å’Œæ£€ç´¢çš„ä¸´æ—¶å¯¹è±¡ã€‚ å‚¨å­˜åœ¨ Pool ä¸­çš„ä»»ä½•ç‰©å“éƒ½å¯ä»¥åœ¨ä»»ä½•æ—¶é—´è‡ªåŠ¨ç§»é™¤ï¼Œæ— éœ€é€šçŸ¥ã€‚å¦‚æœåœ¨æ­¤å‘ç”Ÿæ—¶ Pool æŒæœ‰å”¯ä¸€çš„å¼•ç”¨ï¼Œåˆ™å¯èƒ½ä¼šé‡Šæ”¾è¯¥å…ƒç´ ã€‚ Pool å¯ä»¥è¢«å¤šä¸ªgoroutinesåŒæ—¶ä½¿ç”¨ã€‚ Pool's çš„ç›®çš„æ˜¯ç¼“å­˜å·²åˆ†é…ä½†æœªä½¿ç”¨çš„é¡¹ï¼Œä»¥ä¾¿ä»¥åé‡ç”¨ï¼Œå‡è½»åƒåœ¾æ”¶é›†å™¨çš„å‹åŠ›ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œå®ƒä½¿æ„å»ºé«˜æ•ˆçš„ã€çº¿ç¨‹å®‰å…¨çš„ç©ºé—²åˆ—è¡¨å˜å¾—å®¹æ˜“ã€‚ä½†å®ƒå¹¶ä¸é€‚ç”¨äºæ‰€æœ‰ç©ºé—²é“¾è¡¨ã€‚ Pool çš„é€‚å½“ä½¿ç”¨æ˜¯ç®¡ç†ä¸€ç»„åœ¨åŒ…çš„å¹¶å‘ç‹¬ç«‹å®¢æˆ·ç«¯ä¹‹é—´å…±äº«å’Œå¯èƒ½è¢«é‡ç”¨çš„ä¸´æ—¶é¡¹ã€‚Pool æä¾›äº†ä¸€ç§åœ¨å¤šä¸ªå®¢æˆ·ç«¯ä¹‹é—´æ‘Šé”€åˆ†é…å¼€é”€çš„æ–¹æ³•ã€‚ ä¸€ä¸ªè‰¯å¥½ä½¿ç”¨ Pool çš„ä¾‹å­æ˜¯fmtåŒ…ï¼Œå®ƒç»´æŠ¤äº†ä¸€ä¸ªåŠ¨æ€å¤§å°çš„ä¸´æ—¶è¾“å‡ºç¼“å†²åŒºå­˜å‚¨ã€‚storeåœ¨è´Ÿè½½ä¸‹æ‰©å±•(å½“è®¸å¤šgoroutinesæ­£åœ¨ç§¯ææ‰“å°æ—¶)ï¼Œåœ¨é™é»˜æ—¶æ”¶ç¼©ã€‚ å¦ä¸€æ–¹é¢ï¼Œä½œä¸ºç”Ÿå­˜æœŸè¾ƒçŸ­çš„å¯¹è±¡çš„ä¸€éƒ¨åˆ†ç»´æŠ¤çš„ç©ºé—²åˆ—è¡¨ä¸é€‚åˆç”¨äº Poolï¼Œå› ä¸ºåœ¨è¿™ç§æƒ…å†µä¸‹å¼€é”€ä¸èƒ½å¾ˆå¥½åœ°åˆ†æ‘Šã€‚ åœ¨ç¬¬ä¸€æ¬¡ä½¿ç”¨åï¼Œä¸èƒ½å¤åˆ¶æ± ã€‚ sync.Pool æ˜¯åç¨‹å®‰å…¨çš„ï¼Œä½¿ç”¨å‰ï¼Œè®¾ç½®å¥½å¯¹è±¡çš„ New å‡½æ•°ï¼Œç”¨åœ¨ Pool é‡Œæ²¡æœ‰ç¼“å­˜çš„å¯¹è±¡æ—¶ï¼Œåˆ›å»ºä¸€ä¸ªã€‚ä¹‹ååœ¨ç¨‹åºçš„ä»»ä½•åœ°æ–¹ã€ä»»ä½•æ—¶å€™ä»…é€šè¿‡ Get() å’Œ Put() æ–¹æ³•å°±å¯ä»¥å–å’Œè¿˜å¯¹è±¡äº† 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 // A Pool is a set of temporary objects that may be individually saved and // retrieved. // // Any item stored in the Pool may be removed automatically at any time without // notification. If the Pool holds the only reference when this happens, the // item might be deallocated. // // A Pool is safe for use by multiple goroutines simultaneously. // // Pool\u0026#39;s purpose is to cache allocated but unused items for later reuse, // relieving pressure on the garbage collector. That is, it makes it easy to // build efficient, thread-safe free lists. However, it is not suitable for all // free lists. // // An appropriate use of a Pool is to manage a group of temporary items // silently shared among and potentially reused by concurrent independent // clients of a package. Pool provides a way to amortize allocation overhead // across many clients. // // An example of good use of a Pool is in the fmt package, which maintains a // dynamically-sized store of temporary output buffers. The store scales under // load (when many goroutines are actively printing) and shrinks when // quiescent. // // On the other hand, a free list maintained as part of a short-lived object is // not a suitable use for a Pool, since the overhead does not amortize well in // that scenario. It is more efficient to have such objects implement their own // free list. // // A Pool must not be copied after first use. type Pool struct { // ä½¿å¾—å†…åµŒäº†noCopyçš„å¯¹è±¡åœ¨è¿›è¡Œgo veté™æ€æ£€æŸ¥çš„æ—¶å€™ï¼Œå¯ä»¥æ£€æŸ¥å‡ºæ˜¯å¦è¢«å¤åˆ¶ noCopy noCopy // è®¿é—®æ—¶æ ¹æ®Pçš„idå»è®¿é—®å¯¹åº”ä¸‹æ ‡çš„local[pid] // é€šè¿‡è¿™æ ·çš„è®¾è®¡ï¼Œå¤šä¸ªgoroutineä½¿ç”¨åŒä¸€ä¸ªPoolæ—¶ï¼Œå‡å°‘äº†ç«äº‰ï¼Œæå‡äº†æ€§èƒ½ // localå­—æ®µæŒ‡å‘å­˜å‚¨[P]poolloaclæ•°ç»„çš„æŒ‡é’ˆï¼Œç±»å‹ä¸º[P]poolLocal // // local æ˜¯ [P]poolLocal æ•°ç»„çš„é¦–åœ°å€ // P æ˜¯å½“å‰Pçš„æ•°é‡ï¼Œä¸€èˆ¬é»˜è®¤ä¸ºCPUçš„æ ¸æ•° local unsafe.Pointer // local fixed-size per-P pool, actual type is [P]poolLocal // localSize æ˜¯ä¸Šé¢ local æ•°ç»„çš„å¤§å° // æ ¹æ® localSize åˆ¤æ–­æ˜¯å¦åˆå§‹åŒ–ï¼Œpidä¸ºPçš„idæ”¹å€¼æ˜¯ä¸€ä¸ª0çš„é€’å¢å€¼ // 1. localSize ä¸º0æ—¶ï¼Œæ²¡æœ‰åˆå§‹åŒ– // 2. localSize \u0026lt;= pid æ—¶ï¼Œå¯èƒ½æ˜¯æ²¡æœ‰åˆå§‹åŒ–ï¼Œä¹Ÿå¯èƒ½æ˜¯Pçš„æ•°é‡å‘ç”Ÿäº†å˜åŒ–ï¼Œå˜å¤šäº† localSize uintptr // size of the local array // victim å’Œ victimSize ä½œä¸ºæ¬¡çº§ç¼“å­˜ä½¿ç”¨ï¼ŒGCæ—¶å°†å¯¹è±¡æ”¾å…¥å…¶ä¸­ï¼Œä¸‹ä¸€æ¬¡GCæ¥ä¸´ä¹‹å‰å¦‚æœæœ‰Getè°ƒç”¨åˆ™ä¼šä»p.victimä¸­å–ï¼Œç›´åˆ°å†ä¸€æ¬¡GCæ¥æ—¶å›æ”¶ // ä» p.victim ä¸­å–å‡ºå¯¹è±¡ä½¿ç”¨å®Œæ¯•ä¹‹åå¹¶æœªè¿”å› p.victim ä¸­ï¼ˆè€Œæ˜¯æ”¾å›p.localï¼‰ä¸­ï¼Œåœ¨ä¸€å®šç¨‹åº¦ä¸Šä¹Ÿå‡å°äº†ä¸‹ä¸€æ¬¡GCçš„å¼€é”€ // åŸæ¥1æ¬¡GCçš„å¼€é”€è¢«æ‹‰é•¿åˆ°2æ¬¡åˆ‡ä¼šæœ‰ä¸€å®šç¨‹åº¦çš„å¼€é”€å‡å°ï¼Œè¿™å°±æ˜¯ p.victim å¼•å…¥çš„æ„å›¾ // victim å’Œ victimSize ä¼šåœ¨ä¸€è½®GCåˆ°æ¥æ—¶ï¼Œåˆ†åˆ«\u0026#34;æ¥ç®¡\u0026#34; local å’Œ localSize // victim çš„æœºåˆ¶ç”¨äºå‡å°‘GCåå†·å¯åŠ¨å¯¼è‡´çš„æ€§èƒ½æŠ–åŠ¨ï¼Œè®©åˆ†é…å¯¹è±¡æ›´å¹³æ»‘ // sync.Pool å¼•å…¥çš„æ„å›¾åœ¨äºé™ä½GCå‹åŠ›çš„åŒæ—¶æé«˜å‘½ä¸­ç‡ victim unsafe.Pointer // local from previous cycle æ¥è‡ªä¸Šä¸€ä¸ªå‘¨æœŸçš„local victimSize uintptr // size of victims array\tæ¥è‡ªä¸Šä¸€ä¸ªå‘¨æœŸçš„localçš„å¤§å° // New optionally specifies a function to generate // a value when Get would otherwise return nil. // It may not be changed concurrently with calls to Get. // // Newå¯é€‰åœ°æŒ‡å®šä¸€ä¸ªå‡½æ•°ï¼Œç”¨äºåœ¨Getè¿”å›nilæ—¶ç”Ÿæˆä¸€ä¸ªå€¼ã€‚ // å®ƒä¸èƒ½åœ¨è°ƒç”¨Getæ—¶åŒæ—¶æ”¹å˜ã€‚ New func() any\t// æˆ‘ä»¬æŒ‡å®šçš„æ–°å»ºå¯¹è±¡çš„æ–¹æ³• } // \u0026gt; ----------------------------------------------------------------------------------- type poolLocal struct { poolLocalInternal\t// 32 bytes // Prevents false sharing on widespread platforms with // 128 mod (cache line size) = 0 . // // å°†poolLocalè¡¥é½è‡³128å­—èŠ‚ï¼ˆå³ä¸¤ä¸ªcache lineï¼‰çš„å€æ•°ï¼Œé˜²æ­¢false sharingä¼ªå…±äº« // ä»…å ä½ç”¨ï¼Œé˜²æ­¢åœ¨cache lineä¸Šåˆ†é…å¤šä¸ª poolLocalInternal // ç¡®ä¿CPUç¼“å­˜æœºåˆ¶ä¸åŒï¼Œä¸€èˆ¬å»ºè®®ç¡®ä¿æœ‰128å­—èŠ‚è·ç¦» pad [128 - unsafe.Sizeof(poolLocalInternal{})%128]byte\t// ä½¿poolLocalæ€»å…±å 128å­—èŠ‚ // CPU Cache // ç°ä»£cpuä¸­ï¼Œcacheéƒ½åˆ’åˆ†æˆä»¥cache line(cache block)ä¸ºå•ä½ï¼Œåœ¨x86_64ä½“ç³»ä¸‹ä¸€èˆ¬éƒ½æ˜¯64å­—èŠ‚ï¼Œcache lineæ˜¯æ“ä½œçš„æœ€å°å•å…ƒ // ç¨‹åºå³ä½¿åªæƒ³è¯»å†…å­˜ä¸­çš„1ä¸ªå­—èŠ‚æ•°æ®ï¼Œä¹Ÿè¦åŒæ—¶æŠŠé™„è¿‘63èŠ‚å­—åŠ è½½åˆ°cacheä¸­ï¼Œå¦‚æœè¯»å–è¶…ä¸ª64å­—èŠ‚ï¼Œé‚£ä¹ˆå°±è¦åŠ è½½åˆ°å¤šä¸ªcache lineä¸­ // è¿™æ ·ï¼Œè®¿é—®åç»­63å­—èŠ‚æ•°æ®æ—¶å°±å¯ä»¥ç›´æ¥ä»cache lineä¸­è¯»å–ï¼Œæ€§èƒ½æœ‰å¾ˆå¤§æå‡ // false sharing // ä¼ªå…±äº«çš„éæ ‡å‡†å®šä¹‰ä¸ºï¼š // ç¼“å­˜ç³»ç»Ÿä¸­æ˜¯ä»¥ç¼“å­˜è¡Œï¼ˆcache lineï¼‰ä¸ºå•ä½å­˜å‚¨çš„ï¼Œå½“å¤šçº¿ç¨‹ä¿®æ”¹äº’ç›¸ç‹¬ç«‹çš„å˜é‡æ—¶ï¼Œå¦‚æœè¿™äº›å˜é‡å…±äº«åŒä¸€ä¸ªç¼“å­˜è¡Œï¼Œ // å°±ä¼šä»¤æ•´ä¸ª cache line å¤±æ•ˆï¼Œæ— æ„ä¸­å½±å“å½¼æ­¤çš„æ€§èƒ½ï¼Œè¿™å°±æ˜¯ä¼ªå…±äº« // å¦‚æœæ²¡ç”¨padå­—æ®µæ—¶ï¼Œé‚£ä¹ˆå½“éœ€è¦è®¿é—®0å·ç´¢å¼•çš„poolLocalæ—¶ï¼ŒCPUåŒæ—¶ä¼šæŠŠ0å·å’Œ1å·ç´¢å¼•åŒæ—¶åŠ è½½åˆ°cpu cacheï¼Œåœ¨åªä¿®æ”¹0å·ç´¢å¼•çš„æƒ…å†µä¸‹ï¼Œ // ä¼šè®©1å·ç´¢å¼•çš„poolLocalå¤±æ•ˆã€‚è¿™æ ·ï¼Œå½“å…¶ä»–çº¿ç¨‹æƒ³è¦è¯»å–1å·ç´¢å¼•æ—¶ï¼Œå‘ç”Ÿcache missï¼Œè¿˜å¾—é‡æ–°å†åŠ è½½ï¼Œå¯¹æ€§èƒ½æœ‰æŸï¼Œ // å¢åŠ ä¸€ä¸ªpadï¼Œè¡¥é½ç¼“å­˜è¡Œï¼Œè®©ç›¸å…³çš„å­—æ®µèƒ½ç‹¬ç«‹åœ°åŠ è½½åˆ°ç¼“å­˜è¡Œå°±ä¸ä¼šå‡ºç°false shardingäº† } // \u0026gt; ----------------------------------------------------------------------------------- // Local per-P Pool appendix. type poolLocalInternal struct { // privateåªæœ‰å½“å‰Pèƒ½ç”¨ private any // Can be used only by the respective P. // å…¶ä»–Péƒ½å¯ä»¥ç”¨ï¼Œå½“privateæ²¡æœ‰æ—¶ä¼˜å…ˆå»å½“å‰Pçš„local.sharedä¸­å–ï¼Œå¦‚æœè¿˜æ²¡æœ‰å°±å»å…¶ä»–Pä¸­çš„local.sharedä¸­çªƒå–ä¸€ä¸ªæ¥ç”¨ shared poolChain // Local P can pushHead/popHead; any P can popTail. } Variables å…¨å±€å˜é‡ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 var ( allPoolsMu Mutex\t// å…¨å±€äº’æ–¥é” // allPools is the set of pools that have non-empty primary // caches. Protected by either 1) allPoolsMu and pinning or 2) // STW. // // allPools æ˜¯å…·æœ‰éç©ºä¸»é”®ç¼“å­˜çš„ pool é›†åˆ // å—ä»»ä½•ä¸€æ–¹ä¿æŠ¤ 1) allPoolsMu å’Œ pinning 2) STW // åœ¨Getå‡½æ•°ä¸­ï¼Œåˆå§‹åŒ–æ—¶è¢«ä¿å­˜åœ¨è¿™é‡Œ allPools []*Pool\t// ä¿å­˜æ¥è‡ªç”¨æˆ·åˆ›å»ºçš„Poolå®ä¾‹ï¼Œç”¨æˆ·ç«¯å¯èƒ½åˆ›å»ºå¤šä¸ªPoolï¼Œæ¯”å¦‚fmtåŒ…åˆ›å»ºçš„Poolä¹Ÿä¼šä¿å­˜åœ¨è¿™é‡Œ // oldPools is the set of pools that may have non-empty victim // caches. Protected by STW. // // oldPoolsæ˜¯ä¸€ç»„å¯èƒ½å…·æœ‰éç©ºvictim cachesçš„æ± ã€‚å—STWä¿æŠ¤ã€‚ // åœ¨GCå¼€å§‹æ—¶ï¼Œä¿å­˜allPoolsä¸­çš„å€¼ oldPools []*Pool\t// oldPoolsåªæ˜¯ä¿å­˜äº† allPools çš„å€¼ï¼Œå¯è§æ˜¯é˜²æ­¢è¢«GCå›æ”¶ç›¸å…³æ•°æ® ) type poolLocal struct æœ¬åœ° Poolï¼Œå¯¹é½Cache lineçš„å€æ•°ã€‚ 1 2 3 4 5 6 7 8 9 type poolLocal struct { poolLocalInternal // Prevents false sharing on widespread platforms with // 128 mod (cache line size) = 0 . // // ç”¨ 128 mod (cache line size) = 0 é˜²æ­¢åœ¨å¹¿æ³›ä¼ æ’­çš„å¹³å°ä¸Š false sharingã€‚ pad [128 - unsafe.Sizeof(poolLocalInternal{})%128]byte } type poolLocalInternal struct 1 2 3 4 5 6 7 8 9 // Local per-P Pool appendix. type poolLocalInternal struct { // private ç§æœ‰çš„ï¼Œåªèƒ½ç”±ç›¸åº”çš„Pä½¿ç”¨ã€‚ private any // Can be used only by the respective P. // shared å…±äº«çš„ï¼Œlocal P å¯ä»¥ pushHead/popHead; ä»»ä½•På¯ä»¥ popTail // å½“å½“å‰Pçš„privateæ²¡æœ‰ï¼Œé‚£ä¹ˆä¼˜å…ˆä»å½“å‰Pçš„sharedä¸­å–ï¼Œè¿˜æ²¡æœ‰åˆ™ä»å…¶ä»–Pçš„sharedä¸­å–ï¼Œ // è¿˜æ˜¯æ²¡æœ‰å¦‚æœNewå‡½æ•°å­˜åœ¨åˆ™ä½¿ç”¨è¯¥å‡½æ•°ç”Ÿæˆ shared poolChain // Local P can pushHead/popHead; any P can popTail. } type poolChain struct poolChainæ˜¯poolDequeueçš„åŠ¨æ€ç‰ˆæœ¬ã€‚ å‚çœ‹ poolqueue.go æ–‡æ¡£ã€‚ï¼ˆç¬¬äºŒç¯‡ä¸­ä»‹ç»ï¼‰ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // poolChain is a dynamically-sized version of poolDequeue. // // This is implemented as a doubly-linked list queue of poolDequeues // where each dequeue is double the size of the previous one. Once a // dequeue fills up, this allocates a new one and only ever pushes to // the latest dequeue. Pops happen from the other end of the list and // once a dequeue is exhausted, it gets removed from the list. type poolChain struct { // head is the poolDequeue to push to. This is only accessed // by the producer, so doesn\u0026#39;t need to be synchronized. head *poolChainElt // tail is the poolDequeue to popTail from. This is accessed // by consumers, so reads and writes must be atomic. tail *poolChainElt } Pool Methods Get() ä¼˜å…ˆä»å½“å‰ P çš„ local.private ä¸­å–ï¼Œæ²¡æœ‰åˆ™ä»å½“å‰ P çš„ local.shared ä¸­å–ï¼Œè¿˜æ²¡æœ‰åˆ™å»å…¶ä»– P ä¸­ local.shared ä¸­çªƒå–ä¸€ä¸ª è°ƒç”¨è€…ä¸åº”è¯¥è®¤ä¸ºGetçš„è¿”å›å€¼å’Œä¼ é€’ç»™Putå€¼ä¹‹é—´æœ‰ä»»ä½•å…³ç³» å‡å¦‚Getæ–¹æ³•æ²¡æœ‰å–å¾— itemï¼Œå¦‚ p.New é nilï¼ŒGetè¿”å›è°ƒç”¨ p.New çš„ç»“æœï¼›å¦åˆ™è¿”å›nil 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 // Get selects an arbitrary item from the Pool, removes it from the // Pool, and returns it to the caller. // Get may choose to ignore the pool and treat it as empty. // Callers should not assume any relation between values passed to Put and // the values returned by Get. // // If Get would otherwise return nil and p.New is non-nil, Get returns // the result of calling p.New. func (p *Pool) Get() any { if race.Enabled { race.Disable() } l, pid := p.pin()\t// è¿”å›å½“å‰å·¥ä½œçº¿ç¨‹æ‰€åœ¨çš„*poolLocalå’Œpid x := l.private\t// å–å½“å‰privateä¸Šæ•°æ® l.private = nil\t// å¹¶æ¸…é›¶private // å¦‚æœ local private æ²¡æœ‰ if x == nil {\t// Try to pop the head of the local shard. We prefer // the head over the tail for temporal locality of // reuse. // // å°è¯•ä»local shardçš„headå–å‡ºã€‚å¯¹äºé‡å¤ä½¿ç”¨ä¸€æ—¶çš„localityæˆ‘ä»¬æ›´å–œæ¬¢headè€Œä¸æ˜¯tail x, _ = l.shared.popHead()\t// å°è¯•ä»sharedçš„headå¼¹å‡ºä¸€ä¸ªæ•°æ® if x == nil { x = p.getSlow(pid)\t// å¦‚æœä¸Šé¢è¿˜æœªç©ºï¼Œåˆ™å»å…¶ä»–Pä¸­å·å–ï¼Œæˆ–ä»victim cacheå»æ‹¿å» } } runtime_procUnpin()\t// å…è®¸å½“å‰å·¥ä½œçº¿ç¨‹è¢«æŠ¢å  if race.Enabled { race.Enable() if x != nil { race.Acquire(poolRaceAddr(x)) } } // å¦‚æœä¸Šé¢éƒ½æ²¡æœ‰æ‹¿åˆ°æ•°æ®å¹¶ä¸”åˆå®šä¹‰äº†Newæ–¹æ³•è°ƒç”¨è¯¥æ–¹æ³•åˆ›å»ºæ•°æ® if x == nil \u0026amp;\u0026amp; p.New != nil {\tx = p.New() } return x } pin() pin å°†å½“å‰ goroutine å›ºå®šåˆ° Pï¼Œç¦ç”¨æŠ¢å å¹¶ä¸º P å’Œ P çš„idè¿”å› poolLocalæ± ã€‚ è°ƒç”¨è€…åœ¨å¤„ç†æ± æ—¶å¿…é¡»è°ƒç”¨runtime_procUnpin()ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 // pin pins the current goroutine to P, disables preemption and // returns poolLocal pool for the P and the P\u0026#39;s id. // Caller must call runtime_procUnpin() when done with the pool. func (p *Pool) pin() (*poolLocal, int) { // è¯¥å‡½æ•°ä¸»è¦ä½œç”¨æ˜¯åŠ é”Mç¦æ­¢å½“å‰Mè¢«æŠ¢å ï¼Œç„¶åè¿”å›Mæ­£ç»‘å®šçš„Pçš„id pid := runtime_procPin()\t// In pinSlow we store to local and then to localSize, here we load in opposite order. // Since we\u0026#39;ve disabled preemption, GC cannot happen in between. // Thus here we must observe local at least as large localSize. // We can observe a newer/larger local, it is fine (we must observe its zero-initialized-ness). // // åœ¨pinSlowä¸­ï¼Œæˆ‘ä»¬å­˜å‚¨åˆ°localï¼Œç„¶åå­˜å‚¨åˆ°localSizeï¼Œåœ¨è¿™é‡Œæˆ‘ä»¬æŒ‰ç›¸åçš„é¡ºåºåŠ è½½ã€‚ // å› ä¸ºæˆ‘ä»¬å·²ç»ç¦ç”¨äº†æŠ¢å ï¼Œæ‰€ä»¥GCä¸èƒ½åœ¨è¿™ä¸¤è€…ä¹‹é—´å‘ç”Ÿã€‚ // å› æ­¤ï¼Œè¿™é‡Œæˆ‘ä»¬å¿…é¡»æ³¨æ„localè‡³å°‘ä¸ºlarge localSizeã€‚ // æˆ‘ä»¬å¯ä»¥è§‚å¯Ÿåˆ°ä¸€ä¸ª æ›´æ–°/æ›´å¤§ çš„ localï¼Œè¿™æ˜¯æ²¡é—®é¢˜çš„(æˆ‘ä»¬å¿…é¡»è§‚å¯Ÿåˆ°å®ƒçš„é›¶åˆå§‹åŒ–)ã€‚ s := runtime_LoadAcquintptr(\u0026amp;p.localSize) // load-acquire;\tåŸå­è¯»å–p.localSizeå€¼ l := p.local // load-consume;\tå­˜å‚¨æ•°æ®çš„æ•°ç»„åœ°å€ // uintptr(pid) \u0026gt;= s; å¯èƒ½ 1)æ²¡æœ‰åˆå§‹åŒ–è¿‡ 2)Pçš„æ•°é‡å˜å¤šäº† if uintptr(pid) \u0026lt; s { return indexLocal(l, pid), pid } return p.pinSlow()\t// åˆå§‹åŒ–å» } // \u0026gt; --------------------------------------------------------------------------------- // go1.19.3/src/runtime/proc.go //go:linkname sync_runtime_procPin sync.runtime_procPin //go:nosplit func sync_runtime_procPin() int { return procPin() } // \u0026gt; --------------------------------------------------------------------------------- // go1.19.3/src/runtime/proc.go //go:nosplit func procPin() int { _g_ := getg() mp := _g_.m mp.locks++ return int(mp.p.ptr().id) } // \u0026gt; --------------------------------------------------------------------------------- // go1.19.3/src/runtime/proc.go //go:linkname sync_runtime_procUnpin sync.runtime_procUnpin //go:nosplit func sync_runtime_procUnpin() { procUnpin() } // \u0026gt; --------------------------------------------------------------------------------- // go1.19.3/src/runtime/proc.go //go:nosplit func procUnpin() { _g_ := getg() _g_.m.locks-- } // \u0026gt; --------------------------------------------------------------------------------- // go1.19.3/src/sync/pool.go //go:linkname runtime_LoadAcquintptr runtime/internal/atomic.LoadAcquintptr func runtime_LoadAcquintptr(ptr *uintptr) uintptr // \u0026gt; --------------------------------------------------------------------------------- // go1.19.3/src/runtime/proc.go // læ˜¯p.localï¼Œiæ˜¯pid func indexLocal(l unsafe.Pointer, i int) *poolLocal { // è·å–åˆ°iä¸‹æ ‡çš„æ•°æ®åœ°å€ lp := unsafe.Pointer(uintptr(l) + uintptr(i)*unsafe.Sizeof(poolLocal{})) return (*poolLocal)(lp) } pinSlow() pinSlow ä¸»è¦æ˜¯å®Œæˆ pool.local çš„åˆå§‹åŒ–åˆ›å»º 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 func (p *Pool) pinSlow() (*poolLocal, int) { // Retry under the mutex. // Can not lock the mutex while pinned. runtime_procUnpin() allPoolsMu.Lock()\tdefer allPoolsMu.Unlock()\tpid := runtime_procPin()\t// poolCleanup won\u0026#39;t be called while we are pinned. s := p.localSize l := p.local // å†æ¬¡æ£€æŸ¥çš„æ„ä¹‰åœ¨äºï¼Œå¯èƒ½å‡ºç°æ­¤æ—¶Poolå·²ç»è¢«åˆå§‹åŒ– if uintptr(pid) \u0026lt; s { return indexLocal(l, pid), pid } if p.local == nil { // æ–°åˆå§‹åŒ–çš„Poolè®°å½•åˆ°allPools allPools = append(allPools, p)\t// allPoolsæ˜¯å­˜å‚¨[]*Poolåˆ‡ç‰‡ } // If GOMAXPROCS changes between GCs, we re-allocate the array and lose the old one. // å¦‚æœ GOMAXPROCS åœ¨ GC ä¹‹é—´å‘ç”Ÿå˜åŒ–ï¼Œæˆ‘ä»¬å°†é‡æ–°åˆ†é…æ•°ç»„å¹¶ä¸¢å¤±æ—§æ•°ç»„ // runtime.GOMAXPROCS å‡½æ•° å‚æ•°æ˜¯0æˆ–åŸå¤§å°å€¼ç›´æ¥è¿”å›CPUä¸­æ•°é‡ï¼Œå…¶ä»–åˆ™ä¿®æ”¹Pçš„æ•°é‡ size := runtime.GOMAXPROCS(0)\t// è¿”å›Pçš„æ€»æ•°é‡ local := make([]poolLocal, size)\t// åˆ›å»ºpoolLocalç±»å‹åˆ‡ç‰‡ï¼Œé•¿åº¦å’Œå®¹é‡éƒ½ä¸ºsize atomic.StorePointer(\u0026amp;p.local, unsafe.Pointer(\u0026amp;local[0])) // store-release runtime_StoreReluintptr(\u0026amp;p.localSize, uintptr(size)) // store-release return \u0026amp;local[pid], pid } // \u0026gt; --------------------------------------------------------------------------------- //go:linkname runtime_StoreReluintptr runtime/internal/atomic.StoreReluintptr func runtime_StoreReluintptr(ptr *uintptr, val uintptr) uintptr getSlow() ä»å…¶ä»– P çš„ share ä¸­å»å·å–å…ƒç´  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 func (p *Pool) getSlow(pid int) any { // See the comment in pin regarding ordering of the loads. // è¯·å‚é˜…pinä¸­å…³äºè´Ÿè½½æ’åºçš„æ³¨é‡Šã€‚ // åŸå­è¯»å– p.localSize size := runtime_LoadAcquintptr(\u0026amp;p.localSize) // load-acquire locals := p.local // load-consume // Try to steal one element from other procs. // å°è¯•ä»å…¶ä»–è¿›ç¨‹ä¸­çªƒå–ä¸€ä¸ªå…ƒç´ ã€‚ for i := 0; i \u0026lt; int(size); i++ { // å·å–é¡ºåºä»å½“å‰Pçš„ä¸‹ä¸€ä¸ªPå¼€å§‹éå†ä¸€åœˆ l := indexLocal(locals, (pid+i+1)%int(size))\tif x, _ := l.shared.popTail(); x != nil { return x } } // Try the victim cache. We do this after attempting to steal // from all primary caches because we want objects in the // victim cache to age out if at all possible. // // è¯•è¯• victim cacheã€‚æˆ‘ä»¬è¯•å›¾ä»æ‰€æœ‰primary cachesä¸­çªƒå–æ•°æ®åæ‰è¿™æ ·åšï¼Œ // å› ä¸ºæˆ‘ä»¬å¸Œæœ›victim cacheä¸­çš„å¯¹è±¡å°½å¯èƒ½çš„è¿‡æœŸ size = atomic.LoadUintptr(\u0026amp;p.victimSize)\t// åŸå­è¯»å–victimSize if uintptr(pid) \u0026gt;= size { return nil } locals = p.victim l := indexLocal(locals, pid)\t// å–å‡ºpidå¯¹åº”Pool // å…ˆä» private ä¸­å– if x := l.private; x != nil { l.private = nil return x } // ä»å…¶ä»–Pçš„ share ä¸­å– for i := 0; i \u0026lt; int(size); i++ { l := indexLocal(locals, (pid+i)%int(size)) if x, _ := l.shared.popTail(); x != nil { return x } } // Mark the victim cache as empty for future gets don\u0026#39;t bother // with it. // // å°† victim cache æ ‡è®°ä¸ºç©ºï¼Œä»¥ä¾¿å°†æ¥è·å–ï¼Œä¸è¦è´¹å¿ƒå¤„ç†å®ƒã€‚ atomic.StoreUintptr(\u0026amp;p.victimSize, 0) return nil } indexLocal() 1 2 3 4 func indexLocal(l unsafe.Pointer, i int) *poolLocal { lp := unsafe.Pointer(uintptr(l) + uintptr(i)*unsafe.Sizeof(poolLocal{})) return (*poolLocal)(lp) } Put() Putæ–¹æ³•å°†xæ”¾å…¥ pool ä¸­ æŠŠ x æ”¾å…¥æ± å­ä¸­æ—¶ï¼Œå»ºè®®æ¸…é™¤ä¸Šé¢ç›¸å…³æ•°æ® 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 // Put adds x to the pool. func (p *Pool) Put(x any) { if x == nil { return } if race.Enabled { if fastrandn(4) == 0 { // Randomly drop x on floor. return } race.ReleaseMerge(poolRaceAddr(x)) race.Disable() } // è·å– P å¯¹åº”çš„ *poolLocal l, _ := p.pin() // å¦‚æœå½“å‰privateä¸ºnilåˆ™æŠŠè¿™ä¸ªå­˜å‚¨åœ¨è¿™é‡Œï¼Œç­‰å¾…ä¸‹æ¬¡ä¼˜å…ˆè¢«ä½¿ç”¨ if l.private == nil { l.private = x x = nil } if x != nil {\t// è¿™ç§æƒ…å†µæ˜¯privateå·²ç»æœ‰æ•°æ®äº†ï¼Œåˆ™æ”¾å…¥sharedé˜Ÿåˆ—ä¸­ l.shared.pushHead(x) } runtime_procUnpin()\t// å…è®¸å½“å‰å·¥ä½œçº¿ç¨‹è¢«æŠ¢å ï¼ŒåŸå› æ˜¯pinå‡½æ•°é‡Œé¢åŠ äº†é”çš„è¿™é‡Œéœ€è¦è§£é” if race.Enabled { race.Enable() } } init() æ³¨å†Œ poolCleanup å‡½æ•°ï¼Œåœ¨GCå¼€å§‹æ—¶è°ƒç”¨ å¯¹äº Pool è€Œè¨€ï¼Œå¹¶ä¸èƒ½æ— é™æ‰©å±•ï¼Œå¦åˆ™å¯¹è±¡å ç”¨å†…å­˜å¤ªå¤šä¼šå¼•èµ·å†…å­˜æº¢å‡ºï¼ˆå‡ ä¹æ‰€æœ‰çš„æ± æŠ€æœ¯ä¸­éƒ½ä¼šåœ¨æŸä¸ªæ—¶åˆ»æ¸…ç©ºæˆ–æ¸…é™¤éƒ¨åˆ†ç¼“å­˜å¯¹è±¡ã€‚Goå‘ç”Ÿåœ¨GCæ—¶æ¸…é™¤éƒ¨åˆ†å†…å­˜ï¼‰ åœ¨ pool.go æ–‡ä»¶çš„ init å‡½æ•°é‡Œï¼Œæ³¨å†ŒGCå‘ç”Ÿæ—¶ï¼Œå¦‚ä½•æ¸…ç† Pool çš„å‡½æ•° poolCleanup 1 2 3 4 5 6 7 8 9 10 11 12 func init() { runtime_registerPoolCleanup(poolCleanup) } // go1.19.3/src/runtime/mgc.go //go:linkname sync_runtime_registerPoolCleanup sync.runtime_registerPoolCleanup func sync_runtime_registerPoolCleanup(f func()) { poolcleanup = f } // go1.19.3/src/runtime/mgc.go var poolcleanup func() ä½¿ç”¨ç¤ºä¾‹ Poolï¼šæ˜¯ä¸€ä¸ªå¯ä»¥åˆ†åˆ«å­˜å–çš„ä¸´æ—¶å¯¹è±¡çš„é›†åˆ Poolï¼šä¸­ä¿å­˜çš„ä»»ä½• item éƒ½å¯èƒ½éšæ—¶ä¸åšé€šå‘Šçš„é‡Šæ”¾æ‰ å¦‚æœPoolæŒæœ‰è¯¥å¯¹è±¡çš„å”¯ä¸€å¼•ç”¨ï¼Œè¿™ä¸ª item å°±å¯èƒ½è¢«å›æ”¶ Poolï¼šå¯ä»¥å®‰å…¨çš„è¢«å¤šä¸ªçº¿ç¨‹åŒæ—¶ä½¿ç”¨ Poolï¼šçš„ç›®çš„æ˜¯ç¼“å­˜ç”³è¯·ä½†æœªä½¿ç”¨ item ç”¨äºä¹‹åçš„é‡ç”¨ï¼Œå·²å‡è½»GCçš„å‹åŠ› ä¹Ÿå°±æ˜¯è¯´ï¼Œè®©åˆ›å»ºé«˜æ•ˆè€Œçº¿ç¨‹å®‰å…¨çš„ç©ºé—²åˆ—è¡¨æ›´å®¹æ˜“ ä½†Poolå¹¶ä¸é€‚åˆç”¨äºå¤šæœ‰ç©ºé—²åˆ—è¡¨ Poolï¼šçš„åˆç†ç”¨æ³•æ˜¯ç”¨äºç®¡ç†ä¸€ç»„é™é™çš„è¢«å¤šä¸ªç‹¬ç«‹å¹¶å‘çº¿ç¨‹å…±äº«å¹¶å¯èƒ½é‡ç”¨çš„ä¸´æ—¶ item Poolæä¾›äº†è®©å¤šä¸ªçº¿ç¨‹åˆ†æ‘Šå†…å­˜ç”³è¯·æ¶ˆè€—çš„æ–¹æ³• Poolï¼šçš„ä¸€ä¸ªå¥½ä¾‹å­åœ¨fmtåŒ…é‡Œé¢ è¯¥Poolç»´æŠ¤ä¸€ä¸ªåŠ¨æ€å¤§å°çš„ä¸´æ—¶è¾“å‡ºç¼“å­˜ä»“åº“ è¯¥åˆ›åº“ä¼šåœ¨è¿‡è½½ï¼ˆè®¸å¤šçº¿ç¨‹æ´»è·ƒçš„æ‰“å°æ—¶ï¼‰å¢å¤§ï¼Œåœ¨æ²‰å¯‚æ—¶ç¼©å° å¦ä¸€æ–¹é¢ï¼Œç®¡ç†è¿™çŸ­å¯¿å‘½å¯¹è±¡çš„ç©ºé—²åˆ—è¡¨ä¸é€‚åˆä½¿ç”¨Pool å› ä¸ºè¿™ç§æƒ…å†µä¸‹å†…å­˜ç”³è¯·æ¶ˆè€—ä¸èƒ½å¾ˆå¥½çš„åˆ†é… è¿™æ—¶åº”è¯¥ç”±è¿™äº›å¯¹è±¡è‡ªå·±å®ç°ç©ºé—²åˆ—è¡¨ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;sync\u0026#34; ) var pool *sync.Pool type Person struct { Name string } func initPool() { pool = \u0026amp;sync.Pool { New: func() interface{} { fmt.Println(\u0026#34;Creating a new Person\u0026#34;) return new(Person) }, } } func main() { initPool() // pool.Get() è¿”å›interface{} // ç„¶åæ–­è¨€ æ˜¯å¦ä¸º *Person p := pool.Get().(*Person) fmt.Println(\u0026#34;é¦–æ¬¡ä» pool é‡Œè·å–ï¼š\u0026#34;, p) p.Name = \u0026#34;first\u0026#34; fmt.Printf(\u0026#34;è®¾ç½® p.Name = %s\\n\u0026#34;, p.Name) // å°†pæ”¾å›æ± ä¸­ pool.Put(p) fmt.Println(\u0026#34;Pool é‡Œå·²æœ‰ä¸€ä¸ªå¯¹è±¡ï¼š\u0026amp;{first}ï¼Œè°ƒç”¨ Getï¼š\u0026#34;, pool.Get().(*Person)) fmt.Println(\u0026#34;Pool æ²¡æœ‰å¯¹è±¡äº†ï¼Œè°ƒç”¨ Getï¼š\u0026#34;, pool.Get().(*Person)) } Creating a new Person é¦–æ¬¡ä» pool é‡Œè·å–ï¼š \u0026amp;{} è®¾ç½® p.Name = first Pool é‡Œå·²æœ‰ä¸€ä¸ªå¯¹è±¡ï¼š\u0026amp;{first}ï¼Œè°ƒç”¨ Getï¼š \u0026amp;{first} Creating a new Person Pool æ²¡æœ‰å¯¹è±¡äº†ï¼Œè°ƒç”¨ Getï¼š \u0026amp;{} é¦–å…ˆï¼Œéœ€è¦åˆå§‹åŒ– Poolï¼Œå”¯ä¸€éœ€è¦çš„å°±æ˜¯è®¾ç½®å¥½Newå‡½æ•° å½“è°ƒç”¨ Get æ–¹æ³•æ—¶ï¼Œå¦‚æœæ± å­é‡Œç¼“å­˜äº†å¯¹è±¡ï¼Œå°±ç›´æ¥è¿”å›ç¼“å­˜çš„å¯¹è±¡ å¦‚æœæ²¡æœ‰å­˜è´§ï¼Œåˆ™è°ƒç”¨Newå‡½æ•°åˆ›å»ºä¸€ä¸ªæ–°çš„å¯¹è±¡ å¦å¤–ï¼Œæˆ‘ä»¬å‘ç°Getæ–¹æ³•å–å‡ºæ¥çš„å¯¹è±¡å’Œä¸Šæ¬¡Putè¿›å»çš„å¯¹è±¡å®é™…ä¸Šæ˜¯åŒä¸€ä¸ªï¼ŒPoolæ²¡æœ‰åšä»»ä½•â€œæ¸…ç©ºâ€çš„å¤„ç† ä½†æˆ‘ä»¬ä¸åº”å½“å¯¹æ­¤æœ‰ä»»ä½•å‡è®¾ï¼Œå› ä¸ºåœ¨å®é™…çš„å¹¶å‘ä½¿ç”¨åœºæ™¯ä¸­ æ— æ³•ä¿è¯è¿™ç§é¡ºåºï¼Œæœ€å¥½çš„åšæ³•æ˜¯åœ¨Putå‰ï¼Œå°†å¯¹è±¡æ¸…ç©º ","permalink":"https://heliu.site/posts/golang/sync/pool/","summary":"Poolæ˜¯ä¸€ç»„å¯ä»¥å•ç‹¬ä¿å­˜å’Œæ£€ç´¢çš„ä¸´æ—¶å¯¹è±¡ã€‚","title":"sync.Pool"},{"content":"type RWMutex struct ğŸš€ åœ¨runtime/rwmutex.goä¸­æœ‰è¿™ä¸ªæ–‡ä»¶çš„ä¿®æ”¹è¿‡çš„å‰¯æœ¬ã€‚å¦‚æœä½ åœ¨è¿™é‡Œåšäº†ä»»ä½•æ›´æ”¹ï¼Œçœ‹çœ‹æ˜¯å¦åº”è¯¥åœ¨é‚£é‡Œä¹Ÿåšæ›´æ”¹ã€‚ RWMutex æ˜¯ä¸€ç§ è¯»/å†™ äº’æ–¥é”ã€‚è¯¥é”å¯ä»¥ç”±ä»»æ„æ•°é‡çš„è¯»æˆ–å•ä¸ªå†™æŒæœ‰ã€‚ RWMutex çš„é›¶å€¼æ˜¯ä¸€ä¸ªæœªé”å®šçš„äº’æ–¥é”ã€‚RWMutex åœ¨ç¬¬ä¸€æ¬¡ä½¿ç”¨åä¸èƒ½å¤åˆ¶ã€‚ å¦‚æœä¸€ä¸ªgoroutineæŒæœ‰ä¸€ä¸ªç”¨äºè¯»å–çš„RWMutexï¼Œè€Œå¦ä¸€ä¸ªgoroutineå¯èƒ½ä¼šè°ƒç”¨Lockï¼Œ é‚£ä¹ˆä»»ä½•goroutineéƒ½ä¸åº”è¯¥æœŸæœ›èƒ½å¤Ÿè·å¾—ä¸€ä¸ªè¯»é”ï¼Œç›´åˆ°åˆå§‹çš„è¯»é”è¢«é‡Šæ”¾ã€‚ ç‰¹åˆ«æ˜¯ï¼Œè¿™ç¦æ­¢äº†é€’å½’è¯»é”å®šã€‚è¿™æ˜¯ä¸ºäº†ç¡®ä¿é”æœ€ç»ˆå¯ç”¨ã€‚è¢«é˜»å¡çš„é”è°ƒç”¨ä¼šæ’é™¤æ–°çš„è¯»å–å™¨è·å–é”ã€‚ RWMutexï¼šè¯»å†™äº’æ–¥é” 1) è¯¥é”å¯ä»¥è¢«åŒæ—¶å¤šä¸ªè¯»å–è€…æŒæœ‰æˆ–å”¯ä¸€å†™å…¥è€…æŒæœ‰ 2) RWMutexå¯ä»¥åˆ›å»ºä¸ºå…¶ä»–ç»“æ„ä½“çš„å­—æ®µ 3) é›¶å€¼ä¸ºè§£é”çŠ¶æ€ RWMutex ç±»å‹çš„é”ä¹Ÿå’Œçº¿ç¨‹æ— å…³ï¼Œå¯ä»¥ç”±ä¸åŒçš„çº¿ç¨‹åŠ è¯»å–é”/å†™å…¥å’Œè§£è¯»å–é”/å†™å…¥é” 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 // There is a modified copy of this file in runtime/rwmutex.go. // If you make any changes here, see if you should make them there. // A RWMutex is a reader/writer mutual exclusion lock. // The lock can be held by an arbitrary number of readers or a single writer. // The zero value for a RWMutex is an unlocked mutex. // // A RWMutex must not be copied after first use. // // If a goroutine holds a RWMutex for reading and another goroutine might // call Lock, no goroutine should expect to be able to acquire a read lock // until the initial read lock is released. In particular, this prohibits // recursive read locking. This is to ensure that the lock eventually becomes // available; a blocked Lock call excludes new readers from acquiring the // lock. type RWMutex struct { // 1) ä¸€æŠŠäº’æ–¥é”ï¼Œä¿æŠ¤ä»¥ä¸‹å­—æ®µ // æ‰€æœ‰å†™goroutineäº‰æŠ¢sync.Mutexé”çš„goroutineéƒ½è¿™è¿™é‡Œæ’é˜Ÿç­‰å¾… w Mutex // held if there are pending writers // 2) semaphore è¯»å†™ç­‰å¾…æ±  // è·å–åˆ° sync.Mutex é”gorutineï¼Œå¹¶ç­‰å¾…æ­£åœ¨è¿è¡Œ è¯»goroutine æ—¶ï¼Œè¯¥å†™goroutineåœ¨è¿™é‡Œç­‰å¾… // å› æ­¤è¿™é‡Œåªå¯èƒ½æ˜¯åªæœ‰ä¸€ä¸ªå†™goroutineåœ¨ç­‰å¾…æˆ–è€…æ²¡æœ‰ writerSem uint32 // semaphore for writers to wait for completing readers // readerSem è®°å½•ç€æ‰€æœ‰ç­‰å¾…è¯»çš„åç¨‹ï¼Œå½“æœ‰å†™æ“ä½œæ­£åœ¨è¿›è¡Œä¸­ï¼Œåé¢æ¥çš„è¯»æ“ä½œå…¨éƒ¨æ’é˜Ÿç­‰å¾…åœ¨è¿™é‡Œ // ç­‰å¾…æ­£åœ¨è¿›è¡Œä¸­çš„è¯»æ“ä½œå®Œæˆåé‡Šæ”¾writerSemä¸­çš„å†™æ“ä½œå®Œæˆåï¼Œè¿™é‡Œæ’é˜Ÿçš„è¯»åç¨‹å°†è¢«é‡Šæ”¾ readerSem uint32 // semaphore for readers to wait for completing writers // 3) è¯»ç­‰å¾…æ•°é‡ // readerCount è®°å½•çš„æ‰€æœ‰çš„è¯»goroutineæ•°é‡ï¼ˆã€æ­£åœ¨æ‰§è¡Œçš„goroutineã€‘+ã€ç­‰å¾…åœ¨readerSemä¸­çš„goroutineã€‘ï¼‰ï¼Œ // è°ƒç”¨RLockæ–¹æ³•è¯¥å€¼å°±ä¼šåŠ ä¸€ // å½“æœ‰å†™goroutineè·å–åˆ°sync.Mutexæ—¶ï¼Œä¼šå°†è¯¥å€¼åŸå­æ“ä½œå‡å»rwmutexMaxReaderså˜æˆè´Ÿæ•°ï¼Œ // å‘ŠçŸ¥RLockæ–¹æ³•æœ‰å†™æ“ä½œåœ¨è¿›è¡Œï¼Œgoroutineå»readerSemå§ readerCount int32 // number of pending readers // åœ¨è·å–åˆ°Mutexåï¼Œè®°å½•å½“å‰ã€æ­£åœ¨è¿›è¡Œçš„è¯»goroutineæ•°é‡ã€‘ï¼Œä¸åŒ…æ‹¬å­˜åœ¨readerSemæ’é˜Ÿçš„ï¼Œè¿™äº›è¯»goroutineæ­£åœ¨å·¥ä½œçº¿ç¨‹ä¸Šè¿è¡Œ // åœ¨å½“å‰å†™æ“ä½œå¼€å§‹æ—¶ç­‰å¾…æ­£åœ¨è¿è¡Œå…¨éƒ¨è¯»goroutineçš„æ•°é‡ï¼Œæ³¨æ„è¿™é‡Œå¯ä»¥æ˜¯è´Ÿæ•° readerWait int32 // number of departing readers } const 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 // 2^30 = 1,073,741,824\tå®Œå…¨èƒ½æ»¡è¶³è¯»å–çš„æ•°é‡ const rwmutexMaxReaders = 1 \u0026lt;\u0026lt; 30\t// æœ€å¤§è¯»å–æ•°é‡ // Happens-before relationships are indicated to the race detector via: // - Unlock -\u0026gt; Lock: readerSem // - Unlock -\u0026gt; RLock: readerSem // - RUnlock -\u0026gt; Lock: writerSem // // The methods below temporarily disable handling of race synchronization // events in order to provide the more precise model above to the race // detector. // // For example, atomic.AddInt32 in RLock should not appear to provide // acquire-release semantics, which would incorrectly synchronize racing // readers, thus potentially missing races. // // Happens-beforeå…³ç³»é€šè¿‡ä»¥ä¸‹æ–¹å¼æŒ‡ç¤ºç«äº‰æ£€æµ‹å™¨: // Unlock -\u0026gt; Lock: readerSem // Unlock -\u0026gt; RLock: readerSem // RUnlock -\u0026gt; Lock: writerSem // // ä¸‹é¢çš„æ–¹æ³•æš‚æ—¶ç¦ç”¨äº†ç«äº‰åŒæ­¥äº‹ä»¶çš„å¤„ç†ï¼Œä»¥ä¾¿ä¸ºç«äº‰æ£€æµ‹å™¨æä¾›æ›´ç²¾ç¡®çš„æ¨¡å‹ã€‚ // ä¾‹å¦‚ï¼ŒRLockä¸­çš„ atomic.AddInt32 çœ‹èµ·æ¥ä¸åº”è¯¥æä¾› è·å–-é‡Šæ”¾è¯­ä¹‰ï¼Œè¿™å°†ä¸æ­£ç¡®åœ°åŒæ­¥ç«äº‰çš„é˜…è¯»å™¨ï¼Œä»è€Œå¯èƒ½é”™è¿‡ç«äº‰ã€‚ å­—æ®µå’Œæ–¹æ³•æè¿° Lock()ã€Unlock() å†™æ“ä½œæ—¶è°ƒç”¨çš„æ–¹æ³•ï¼Œå¦‚æœé”å·²è¢«readeræˆ–waiteræŒæœ‰ï¼Œé‚£ä¹ˆLockæ–¹æ³•ä¼šä¸€ç›´é˜»å¡ï¼Œç›´åˆ°èƒ½è·å–åˆ°é” å†™æ“ä½œæ—¶ï¼Œå¦‚æœé”è¢«readersæŒæœ‰ï¼Œé‚£ä¹ˆå°†ç­‰å¾…æ‰€æœ‰çš„readerè§£é”ï¼Œè¿”å›å†™æ“ä½œè·å¾—é”ï¼Œè¿™æœŸé—´è¿˜æœ‰æ¥çš„readerå…¨éƒ¨å»æ’é˜Ÿç­‰å¾…ï¼Œç­‰å¾…å†™æ“ä½œè§£é”å†™æ“ä½œè§£é”æœŸé—´å…ˆæŠŠç­‰å¾…åœ¨æ’é˜Ÿçš„å…¨éƒ¨é‡Šæ”¾å‡ºæ¥ï¼Œç„¶åå†å»è§£é”äº’æ–¥é”ã€‚åœ¨äº’æ–¥é”è§£é”å°æ®µæ—¶é—´æ¥çš„è¯»æ“ä½œç›´æ¥è·å–é”ä¸éœ€è¦å»æ’é˜Ÿï¼Œäº’æ–¥é”è§£é”åæ‰å…è®¸æ’é˜Ÿçš„å†™æ“ä½œæˆ–æ­£åœ¨æ¥çš„å†™æ“ä½œå»äº‰æŠ¢äº’æ–¥å†™é” å†™æ“ä½œæ—¶ï¼Œå¦‚æœé”å·²è¢«waiteræŒæœ‰ï¼Œé‚£ä¹ˆå½“å‰å†™æ“ä½œç­‰å¾…åœ¨RWRutex.w.seamä¿¡å·é‡ä¸­ï¼Œç­‰å¾…å‰é¢ä¸€ä¸ªå†™é”å®Œæˆï¼Œæ­¤æ—¶æ¥çš„è¯»æ“ä½œå…¨éƒ¨é˜»å¡èµ·ï¼Œå·²ç»åœ¨è¿›è¡Œçš„è¯»æ“ä½œæ­£å¸¸è¿›è¡Œ Unlockæ–¹æ³•æ˜¯é…å¯¹çš„é‡Šæ”¾é”çš„æ–¹æ³• RLock()ã€RUnlock() è¯»æ“ä½œæ—¶è°ƒç”¨çš„æ–¹æ³•ï¼Œå¦‚æœé”å·²ç»è¢«writeræŒæœ‰çš„è¯ï¼ŒRLockæ–¹æ³•ä¼šä¸€ç›´é˜»å¡ï¼Œç›´åˆ°èƒ½è·å–åˆ°é”ï¼Œå¦åˆ™å°±ç›´æ¥è¿”å› è¯»æ“ä½œæ—¶æ²¡æœ‰waiteræŒæœ‰é”æƒ…å†µï¼Œç›´æ¥è®°å½•readerCountåŠ ä¸€ï¼Œè¿”å›å°±è¿”å›ï¼Œè¡¨ç¤ºè·å–åˆ°é” è¯»æ“ä½œæ—¶å­˜åœ¨waiteræŒæœ‰é”æƒ…å†µï¼Œåˆ™å½“å‰è¯»æ“ä½œæ’é˜Ÿåœ¨readerSemï¼Œç­‰å¾…å½“å‰å†™å®Œæˆ è€ŒRUnlockæ˜¯readeré‡Šæ”¾é”çš„æ–¹æ³• RLocker() è¿™ä¸ªæ–¹æ³•çš„ä½œç”¨æ˜¯ä¸ºè¯»æ“ä½œè¿”å›ä¸€ä¸ªLockeræ¥å£çš„å¯¹è±¡ï¼Œå®ƒçš„Lockæ–¹æ³•ä¼šè°ƒç”¨RWMutexçš„RLockæ–¹æ³•ï¼Œå®ƒçš„Unlockæ–¹æ³•ä¼šè°ƒç”¨RWMutexçš„RUnlockæ–¹æ³• Lock() Lock é”å®š rw ç”¨äºå†™å…¥ã€‚ å¦‚æœé”å·²ç»é”å®šç”¨äºè¯»æˆ–å†™ï¼Œé‚£ä¹ˆé”å°†é˜»å¡ï¼Œç›´åˆ°é”å¯ç”¨ä¸ºæ­¢ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 // Lock locks rw for writing. // If the lock is already locked for reading or writing, // Lock blocks until the lock is available. func (rw *RWMutex) Lock() { if race.Enabled { _ = rw.w.state race.Disable() } // 1) å°è¯•è·å– sync.Mutex é” // First, resolve competition with other writers. // // é¦–å…ˆï¼Œè§£å†³ä¸å…¶ä»– writers çš„ç«äº‰ã€‚ // å¦‚æœå­˜åœ¨å¤šä¸ªå†™gorutineçš„éƒ½åœ¨è°ƒç”¨Lockç«äº‰é”ï¼Œè¿™é‡Œéœ€è¦å…ˆå»ç«äº‰é” rw.w.Lock()\t// sync.Mutex // 2) åŸå­ä¿®æ”¹readerCountå€¼ï¼Œå‘Šè¯‰åé¢è¯»goroutineè°ƒç”¨Rlockå‡½æ•°éœ€è¦å»readerSemä¸­æŒ‚èµ· // ç”±äºåˆšè·å–åˆ°é”ï¼Œå› æ­¤æ­¤æ—¶åªå­˜åœ¨æ­£åœ¨è¿è¡Œè¯»goroutineå’Œç­‰å¾…åœ¨writerSemä¸­å†™goroutineï¼Œä¸å­˜åœ¨ç­‰å¾…åœ¨readerSemä¸­çš„goroutine // å› æ­¤ readerCount å­˜å‚¨çš„æ˜¯æ­£åœ¨è¿è¡Œè¯»goroutineï¼Œåœ¨ä¸‹é¢è¿™è¡ŒåŸå­æ“ä½œæ‰§è¡Œå‰éƒ½è®¤ä¸ºè¯»goroutineæ˜¯ä¸éœ€è¦æŒ‚èµ·çš„ // Announce to readers there is a pending writer. // // é€šè¿‡æŠŠrw.readerCountè®¾ç½®æˆä¸€ä¸ªè´Ÿæ•°ï¼Œæ¥å‘ŠçŸ¥å…¶ä»–è¯»goroutineå½“å‰æœ‰å†™çš„goroutineæ­£åœ¨ç­‰å¾…è¿›å…¥ä¸´ç•ŒåŒº // atomic.AddInt32(\u0026amp;rw.readerCount, -rwmutexMaxReaders); å‘Šè¯‰åé¢æ¥çš„è¯»æ“ä½œå»æ’é˜Ÿç­‰å¾…ï¼Œä½ ä»¬åº”è¯¥åœ¨æœ¬æ¬¡å†™æ“ä½œå®Œåå†å»è¯»å–æ•°æ® // ç”±äºå½“å‰åˆšè·å–åˆ° Mutex,æ‰€ä»¥è¿™é‡Œçš„ r åº”è¯¥è¡¨ç¤ºå½“å‰æ­£åœ¨è¿è¡Œçš„è¯»goroutineçš„æ•°é‡ï¼Œä¸åŒ…å«è¢«æŒ‚èµ·çš„ goroutine r := atomic.AddInt32(\u0026amp;rw.readerCount, -rwmutexMaxReaders) + rwmutexMaxReaders\t// åŸå­æ“ä½œè¡¨ç¤ºå½“å‰æœ‰å†™çš„åç¨‹æ¥äº† // åœ¨ä¸Šé¢è¿™è¡ŒåŸå­æ“ä½œæ‰§è¡Œåï¼Œéƒ½æœ‰æ¥çš„è¯»goroutineåœ¨è°ƒç”¨RLockæ–¹æ³•æ—¶ï¼Œéƒ½ä¼šè¢«æŒ‚èµ·åœ¨readerSemä¸­ // å› æ­¤ r æ˜¯æ‰€æœ‰æ­£åœ¨è¿è¡Œè¯»goroutineçš„æ•°é‡ // ä¸Šé¢çš„åŸå­æ“ä½œä¸RLockå‡½æ•°çš„åŸå­æ“ä½œå½¢æˆä¸€å¯¹ä¸´ç•ŒåŒºåŸŸäº’æ–¥ // Wait for active readers. // // 1. r != 0ï¼šå­˜åœ¨æ­£åœ¨è¿è¡Œçš„è¯»goroutine // 2. atomic.AddInt32(\u0026amp;rw.readerWait, r) != 0ï¼šç»§ç»­åˆ¤æ–­è¿™æ®µæ—¶é—´å‘¢è¿™äº›è¯»goroutineæ˜¯å¦å…¨éƒ¨è¯»å–å®Œï¼Œ // æ²¡æœ‰è¯»å–å®Œè¿™é‡Œéœ€è¦æŠŠå½“å‰å†™goroutineæŒ‚èµ·åœ¨writerSem // è¿™é‡Œçš„åŸå­æ“ä½œä¸RUlockå‡½æ•°çš„ \u0026#34;atomic.AddInt32(\u0026amp;rw.readerWait, -1) == 0\u0026#34; å½¢æˆä¸´ç•ŒåŒºåŸŸäº’æ–¥ if r != 0 \u0026amp;\u0026amp; atomic.AddInt32(\u0026amp;rw.readerWait, r) != 0 {\t// readerWaitè®°å½•ç€æ­£åœ¨è¿è¡Œä¸­ï¼Œè¿˜æ²¡æœ‰è°ƒç”¨RUnlockçš„goroutine // å­˜åœ¨éœ€è¦ç­‰å¾…è¯»çš„åç¨‹ï¼ŒæŠŠå½“å‰åç¨‹åŠ å…¥writerSemå†™ä¿¡æ¯æ±  // falseï¼šè¿™é‡ŒåŠ å…¥çš„æ˜¯å°¾éƒ¨ï¼Œç”±äºwriterSemåªå¯èƒ½å­˜ä¸€ä¸ªå†™goroutine runtime_SemacquireMutex(\u0026amp;rw.writerSem, false, 0)\t} if race.Enabled { race.Enable() race.Acquire(unsafe.Pointer(\u0026amp;rw.readerSem)) race.Acquire(unsafe.Pointer(\u0026amp;rw.writerSem)) } } Unlock() Unlock æ–¹æ³•è§£é™¤rwçš„å†™å…¥é”çŠ¶æ€ã€‚ å¦‚æœ rw åœ¨è¿›å…¥è§£é”æ—¶æ²¡æœ‰é”å®šå†™å…¥ï¼Œè¿™æ˜¯ä¸€ä¸ªè¿è¡Œæ—¶é”™è¯¯ã€‚ ä¸ Mutexes ä¸€æ ·ï¼Œä¸€ä¸ªè¢«é”çš„ RWMutex ä¸ä¸€ä¸ªç‰¹å®šçš„ goroutine æ— å…³ã€‚ ä¸€ä¸ª goroutine å¯ä»¥ RLock(é”å®š)ä¸€ä¸ª RWMutexï¼Œç„¶åå®‰æ’å¦ä¸€ä¸ª goroutine è¿è¡Œ RUnlock(è§£é”)å®ƒã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 // Unlock unlocks rw for writing. It is a run-time error if rw is // not locked for writing on entry to Unlock. // // As with Mutexes, a locked RWMutex is not associated with a particular // goroutine. One goroutine may RLock (Lock) a RWMutex and then // arrange for another goroutine to RUnlock (Unlock) it. func (rw *RWMutex) Unlock() { if race.Enabled { _ = rw.w.state race.Release(unsafe.Pointer(\u0026amp;rw.readerSem)) race.Disable() } // 1) å½“Unlockæ–¹æ³•è¢«è°ƒç”¨ï¼Œä¹Ÿå°±è¯´æ˜æ•°æ®çš„ç›¸å…³å†™æ“ä½œå·²ç»å®Œæˆäº†ï¼Œæ­¤æ—¶å…¶ä»–æ¥è¯»çš„goroutineå¯ä»¥æ­£å¸¸è¯»å–æ–°æ•°æ® // Announce to readers there is no active writer. // // å‘Šè¯‰æ‰€æœ‰RLockçš„åç¨‹ï¼Œæ²¡æœ‰æ­£åœ¨å†™çš„é”ï¼Œæ­¤æ—¶æ¥è¯»çš„åç¨‹ä¸å¿…ç­‰å¾…ç›´æ¥å¯ä»¥è¯»å–åˆ°æ•°æ® // å› ä¸ºç¨‹åºè°ƒç”¨äº†Unlockæ–¹æ³•ä»£è¡¨æˆ‘ä»¬å‰é¢ä»¥æŠŠæ•°æ®æ›´æ–°äº†ï¼Œæ­¤æ—¶åœ¨ä¿¡å·é‡ä¸­ç­‰å¾…è¯»çš„åç¨‹å’Œæ­¤æ—¶åé¢æ¥è¯»çš„åç¨‹éƒ½å¯ä»¥å®‰å…¨è¯»å–æ•°æ®äº† // è¿™é‡Œä¸RLockå‡½æ•°çš„ \u0026#34;atomic.AddInt32(\u0026amp;rw.readerCount, 1) \u0026lt; 0\u0026#34; å½¢æˆä¸´ç•ŒåŒºäº’æ–¥ r := atomic.AddInt32(\u0026amp;rw.readerCount, rwmutexMaxReaders)\t// è¿™é‡Œçš„rå…¨éƒ½æ˜¯ç­‰å¾…åœ¨ä¿¡å·é‡çš„æ•°é‡ // æ²¡æœ‰è°ƒç”¨Lockæ–¹æ³•ï¼Œè€Œæ˜¯ç›´æ¥è°ƒç”¨Unlockæ–¹æ³•è¿™é‡Œä¼šæŠ¥é”™ if r \u0026gt;= rwmutexMaxReaders { race.Enable() throw(\u0026#34;sync: Unlock of unlocked RWMutex\u0026#34;) } // Unblock blocked readers, if any. // // é‡Šæ”¾æ‰ç­‰å¾…åœ¨ä¿¡å·é‡çš„åç¨‹ï¼Œæ³¨æ„è¿™é‡Œæ˜¯é‡Šæ”¾å®Œäº†æ‰æŠŠäº’æ–¥é”è§£é”çš„æ‰å…è®¸å…¶ä»–å†™æ“ä½œè¿›è¡Œ // å› ä¸ºå‰é¢çš„æ•°æ®å·²ç»æ›´æ–°äº†ï¼Œæ‰€ä»¥è¿™é‡Œéœ€è¦æŠŠåœ¨ä¿¡å·é‡ä¸­çš„åç¨‹å…¨éƒ¨æ”¾åœ¨Pæœ¬åœ°é˜Ÿåˆ—æˆ–å…¨å±€é˜Ÿåˆ—ä¸­ç­‰å¾…è°ƒåº¦å™¨è°ƒåº¦å»æ¥è¿è¡Œ // è¿™é‡Œä¹Ÿæ˜¯ä¸ºä»€ä¹ˆå…¶ä»–å†™goroutineè·å–åˆ°Mutexé”æ—¶ï¼Œä¸å­˜åœ¨ç­‰å¾…åœ¨readerSemä¸Šçš„è¯»goroutineçš„åŸå› ï¼Œå› ä¸ºMutexè§£é”åœ¨åé¢ä¸€æ­¥ for i := 0; i \u0026lt; int(r); i++ { runtime_Semrelease(\u0026amp;rw.readerSem, false, 0)\t// å–å‡ºç­‰å¾…åœ¨readerSemçš„å†™goroutine } // Allow other writers to proceed. // // å…è®¸å…¶ä»– writers ç»§ç»­ rw.w.Unlock()\t// sync.Mutex if race.Enabled { race.Enable() } } TryLock() TryLock è¯•å›¾é”å®š rw è¿›è¡Œå†™å…¥ï¼Œå¹¶æŠ¥å‘Šæ˜¯å¦æˆåŠŸã€‚ è¯·æ³¨æ„ï¼Œè™½ç„¶ç¡®å®å­˜åœ¨æ­£ç¡®ä½¿ç”¨ TryLock çš„æƒ…å†µï¼Œä½†å¾ˆå°‘ï¼Œè€Œä¸” TryLock çš„ä½¿ç”¨é€šå¸¸è¡¨æ˜äº’æ–¥é‡çš„ç‰¹å®šä½¿ç”¨ä¸­å­˜åœ¨æ›´æ·±å±‚çš„é—®é¢˜ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 // TryLock tries to lock rw for writing and reports whether it succeeded. // // Note that while correct uses of TryLock do exist, they are rare, // and use of TryLock is often a sign of a deeper problem // in a particular use of mutexes. func (rw *RWMutex) TryLock() bool { if race.Enabled { _ = rw.w.state race.Disable() } // å°è¯•è·å–Mutexé” if !rw.w.TryLock() { if race.Enabled { race.Enable() } return false } // åŸå­äº¤æ¢ readerCount ç”± 0 -\u0026gt; -rwmutexMaxReaders // å¯è§åªæœ‰åœ¨æ²¡æœ‰è¯»goroutineçš„æ—¶å€™ï¼ŒTryLockå‡½æ•°æ‰ä¼šè¿”å›æˆåŠŸ if !atomic.CompareAndSwapInt32(\u0026amp;rw.readerCount, 0, -rwmutexMaxReaders) { // å­˜åœ¨å…¶ä»–æ­£åœ¨è¯»å†™åç¨‹ rw.w.Unlock()\t// è§£é”äº’æ–¥é” if race.Enabled { race.Enable() } return false } if race.Enabled { race.Enable() race.Acquire(unsafe.Pointer(\u0026amp;rw.readerSem)) race.Acquire(unsafe.Pointer(\u0026amp;rw.writerSem)) } return true } RLock() RLockè®¾ç½®rwè¯»é”ã€‚ å®ƒä¸åº”è¯¥ç”¨äºé€’å½’çš„è¯»é”å®š;è¢«é˜»å¡çš„é”è°ƒç”¨ä¼šæ’é™¤æ–°çš„è¯»å–å™¨è·å–é”ã€‚è¯·å‚é˜…RWMutexç±»å‹çš„æ–‡æ¡£ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 // RLock locks rw for reading. // // It should not be used for recursive read locking; a blocked Lock // call excludes new readers from acquiring the lock. See the // documentation on the RWMutex type. func (rw *RWMutex) RLock() { if race.Enabled { _ = rw.w.state race.Disable() } // æŠŠrw.readerCountåŠ ä¸€ï¼Œå¦‚æœè¯¥å€¼å°äº0ï¼Œè¯´æ˜å­˜åœ¨å…¶ä»–goroutineæ­£åœ¨å†™æ“ä½œï¼Œä¹Ÿå°±æ˜¯å‰é¢çš„Lockæ–¹æ³• // è¿™é‡Œä¹Ÿè¡¨æ˜äº†readerCountå­—æ®µæ˜¯è®°å½•æ‰€æœ‰å†™goroutineçš„æ•°é‡ if atomic.AddInt32(\u0026amp;rw.readerCount, 1) \u0026lt; 0 { // A writer is pending, wait for it. // // ä¸€ä¸ªå†™é”æ­£åœ¨ç»§ç»­ï¼Œç­‰å¾…å®ƒå®Œæˆ runtime_SemacquireMutex(\u0026amp;rw.readerSem, false, 0)\t// å°†å½“å‰è¯»goroutineæŒ‚åœ¨readerSemä¸Š } if race.Enabled { race.Enable() race.Acquire(unsafe.Pointer(\u0026amp;rw.readerSem)) } } RUnlock() RUnlock è§£é™¤ä¸€ä¸ª RLock è°ƒç”¨ã€‚ å®ƒä¸ä¼šå½±å“å…¶ä»–åŒæ—¶é˜…è¯»çš„è¯»è€…ã€‚ å¦‚æœrwåœ¨è¿›å…¥RUnlockæ—¶æ²¡æœ‰é”å®šè¯»å–ï¼Œåˆ™æ˜¯ä¸€ä¸ªè¿è¡Œæ—¶é”™è¯¯ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 // RUnlock undoes a single RLock call; // it does not affect other simultaneous readers. // It is a run-time error if rw is not locked for reading // on entry to RUnlock. func (rw *RWMutex) RUnlock() { if race.Enabled { _ = rw.w.state race.ReleaseMerge(unsafe.Pointer(\u0026amp;rw.writerSem)) race.Disable() } // æŠŠå‰é¢è¯»åŠ é”å‡ä¸€ï¼Œå¦‚æœrå°äº0ï¼Œè¯´æ˜æ­£åœ¨è¿›è¡Œå†™æ“ä½œä¸­ // è¿™é‡Œä¹Ÿæœ‰ä¸€ç§å¯èƒ½æ˜¯æ²¡æœ‰å­˜åœ¨å†™æ“ä½œä¸­åˆæ²¡æœ‰è°ƒç”¨Rlockå‡½æ•°è°ƒç”¨äº†RUnlockå‡½æ•°å¯¼è‡´æ€»æœ‰ä¸€ä¸ªgoroutineè¿™é‡Œrw.readerCount=-1 if r := atomic.AddInt32(\u0026amp;rw.readerCount, -1); r \u0026lt; 0 { // Outlined slow-path to allow the fast-path to be inlined // // æœ‰å­˜åœ¨å†™åœ¨è¿›è¡Œï¼Œå› æ­¤éœ€è¦åˆ¤æ–­å½“å‰æ˜¯å¦éœ€è¦å–å‡ºè¯¥å†™goroutine // åŸå› æ˜¯å¯èƒ½å­˜åœ¨è¯»goroutineåœ¨è¿è¡Œä¸­ï¼Œè¯¥å†™goroutineåœ¨writerSemä¸­ç­‰å¾… rw.rUnlockSlow(r)\t} if race.Enabled { race.Enable() } } rUnlockSlow() 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 func (rw *RWMutex) rUnlockSlow(r int32) { // åˆ¤æ–­æ²¡æœ‰è°ƒç”¨RLockå‡½æ•°è°ƒç”¨RUnlockå‡½æ•°æŠ¥é”™ // 1. r+1 == -rwmutexMaxReaders =\u0026gt; r + rwmutexMaxReaders == 1 // 2. r+1 == 0ï¼Œå°±æ˜¯åˆ¤æ–­ä¸Šé¢æ²¡æœ‰è°ƒç”¨RLockå‡½æ•°è°ƒç”¨RUnlockå‡½æ•°æ—¶æƒ…å†µ if r+1 == 0 || r+1 == -rwmutexMaxReaders { race.Enable() throw(\u0026#34;sync: RUnlock of unlocked RWMutex\u0026#34;) } // A writer is pending. // // rw.readerWait è®°å½•ç€å½“å‰æ­£åœ¨è¿è¡Œçš„goroutineæ²¡åœ¨ä¿¡å·æ± çš„æ•°é‡ï¼Œè¿™é‡Œåˆ¤æ–­æ˜¯å¦å·²ç»æ˜¯æœ€åä¸€ä¸ª // è¿™é‡Œçš„åŸå­æ“ä½œå’ŒLockå‡½æ•°ä¸­çš„ \u0026#34;atomic.AddInt32(\u0026amp;rw.readerWait, r) != 0\u0026#34; å½¢æˆä¸´ç•ŒåŒºäº’æ–¥ if atomic.AddInt32(\u0026amp;rw.readerWait, -1) == 0 {\t// å¦‚æœæ˜¯æœ€åä¸€ä¸ªï¼ŒæŠŠç­‰å¾…å†™çš„goroutineå–å‡º // The last reader unblocks the writer. runtime_Semrelease(\u0026amp;rw.writerSem, false, 1)\t// ä»writerSemä¸­å–å‡ºç­‰å¾…åœ¨è¿™é‡Œçš„è¯»goroutine } } TryRLock() å°è¯•è·å–è¯»é”ï¼Œè¯¥æ–¹æ³•åªè¦ä¸å­˜åœ¨å†™åç¨‹éƒ½ä¼šè·å–è¯»é”æˆåŠŸã€‚ TryRLock è¯•å›¾é”å®š rw ä»¥è¿›è¡Œè¯»å–ï¼Œå¹¶æŠ¥å‘Šæ˜¯å¦æˆåŠŸã€‚ è¯·æ³¨æ„ï¼Œè™½ç„¶ç¡®å®å­˜åœ¨å¯¹ TryRLock çš„æ­£ç¡®ä½¿ç”¨ï¼Œä½†å¾ˆå°‘ï¼Œè€Œä¸” TryRLock çš„ä½¿ç”¨é€šå¸¸è¡¨æ˜äº’æ–¥é‡çš„ç‰¹å®šä½¿ç”¨ä¸­å­˜åœ¨æ›´æ·±å±‚çš„é—®é¢˜ã€‚ è¯¥æ–¹æ³•åœ¨æ²¡æœ‰å†™æ“ä½œçš„æƒ…å†µä¸‹æ˜¯ä¸€å®šèƒ½æ‹¿å»åˆ°é”çš„ã€‚å­˜åœ¨å†™æ“ä½œæ—¶æ‰ä¼šè¿”å› falseã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 // TryRLock tries to lock rw for reading and reports whether it succeeded. // // Note that while correct uses of TryRLock do exist, they are rare, // and use of TryRLock is often a sign of a deeper problem // in a particular use of mutexes. func (rw *RWMutex) TryRLock() bool { if race.Enabled { _ = rw.w.state race.Disable() } // TryRLock å‡½æ•°è·å–åˆ°è¯»é”åªèƒ½å‘ç”Ÿåœ¨ readerCount \u0026gt;= 0 çŠ¶æ€ä¸‹ for { c := atomic.LoadInt32(\u0026amp;rw.readerCount)\t// åŸå­è¯»å– readerCount if c \u0026lt; 0 { // å†™æ“ä½œåœ¨è¿›è¡Œä¸­æˆ–è€…åœ¨ç­‰å¾…è¯»å®Œæˆã€‚ if race.Enabled { race.Enable() } return false } // å°è¯•åŸå­äº¤æ¢ readerCount å€¼ // å¦‚æœäº¤æ¢å¤±è´¥å¯èƒ½æœ‰å…¶ä»–è¯»æ“ä½œæˆ–å†™æ“ä½œå‘ç”Ÿï¼Œå†æ¬¡å¾ªç¯ã€‚ if atomic.CompareAndSwapInt32(\u0026amp;rw.readerCount, c, c+1) { if race.Enabled { race.Enable() race.Acquire(unsafe.Pointer(\u0026amp;rw.readerSem)) } return true\t// è·å–åˆ°é”å } } } RLocker() RLocker è¿”å›ä¸€ä¸ª Locker æ¥å£ï¼Œé€šè¿‡è°ƒç”¨ rw å®ç° Lock å’Œ Unlock æ–¹æ³•ã€‚RLock å’Œ rw.RUnlockã€‚ æ„ä¹‰åœ¨äºè¿”å›æ¥å£Lockeré™åˆ¶åªèƒ½è°ƒç”¨æ¥å£çš„ï¼Œæ¯”å¦‚ sync.Cond ä¸­éœ€è¦çš„é” 1 2 3 4 5 // RLocker returns a Locker interface that implements // the Lock and Unlock methods by calling rw.RLock and rw.RUnlock. func (rw *RWMutex) RLocker() Locker { return (*rlocker)(rw) } type Locker interface Lockeræ¥å£ä»£è¡¨ä¸€ä¸ªå¯ä»¥åŠ é”å’Œè§£é”çš„å¯¹è±¡ã€‚ è¯¥æ¥å£å®šä¹‰åœ¨sync/mutex.goæ–‡ä»¶ä¸­ã€‚ 1 2 3 4 type Locker interface { Lock() Unlock() } type rlocker RWMutex 1 type rlocker RWMutex\t// sync.RWMutex Lock() 1 2 3 4 5 6 func (r *rlocker) Lock() { // å› ä¸º rlocker å’Œ RWMutexæ˜¯ä¸¤ä¸ªç±»å‹ï¼Œè™½ç„¶åº•å±‚ä¸€æ · // ä½†æ˜¯ rlocker åªæ”¯æŒ Lock() å’Œ Unlock() æ–¹æ³• // éœ€è¦è½¬æ¢æˆ (*RWMutex) æ‰èƒ½è°ƒç”¨ RLock() æ–¹æ³•ã€‚ (*RWMutex)(r).RLock() } Unlock() 1 2 3 func (r *rlocker) Unlock() { (*RWMutex)(r).RUnlock() } ä½¿ç”¨ç¤ºä¾‹ è¯»å†™é”ï¼šæ˜¯å¤šè¯»å•å†™äº’æ–¥é”ï¼Œåˆ†åˆ«é’ˆå¯¹è¯»æ“ä½œå’Œå†™æ“ä½œè¿›è¡Œé”å®šå’Œè§£é”æ“ä½œ ç»å¸¸ç”¨äºè¯»æ¬¡æ•°è¿œè¿œå¤šäºå†™æ¬¡æ•°çš„åœºåˆ åœ¨Goè¯­è¨€ä¸­ï¼Œè¯»å†™é”ç”±ç»“æ„ä½“ç±»å‹ sync.RWMutex å®ç° åŸºæœ¬éµå®ˆåŸåˆ™ï¼š å†™é”å®šæƒ…å†µä¸‹ï¼Œå¯¹è¯»å†™é”å®šè¿›è¡Œè¯»é”å®šæˆ–å†™é”å®šï¼Œéƒ½å°†é˜»å¡ï¼Œè€Œä¸”è¯»é”ä¸å†™é”ä¹‹é—´æ˜¯äº’æ–¥çš„ è¯»é”å®šæƒ…å†µä¸‹ï¼Œå¯¹è¯»å†™é”è¿›è¡Œå†™é”å®šï¼Œå°†é˜»å¡ åŠ è¯»é”æ—¶ä¸ä¼šé˜»å¡ï¼Œå³å¯å¤šè¯» å¯¹æœªè¢«å†™é”å®šçš„è¯»å†™é”è¿›è¡Œå†™è§£é”ï¼Œä¼šå¼•å‘è¿è¡Œæ—¶å¼‚å¸¸ å¯¹æœªè¢«è¯»è¯»é”å®šçš„è¯»å†™é”è¿›è¡Œè¯»è§£é”æ—¶ä¹Ÿä¼šå¼•å‘è¿è¡Œæ—¶å¼‚å¸¸ å†™è§£é”åœ¨è¿›è¡Œçš„åŒæ—¶ä¼šè¯•å›¾å”¤é†’æ‰€æœ‰å› è¿›è¡Œè¯»é”å®šè€Œè¢«é˜»å¡çš„åç¨‹ è¯»è§£é”åœ¨è¿›è¡Œçš„æ—¶å€™åˆ™ä¼šè¯•å›¾å”¤é†’ä¸€ä¸ªå› è¿›è¡Œå†™é”å®šè€Œè¢«é˜»å¡çš„åç¨‹ ä¸äº’æ–¥é”ç±»å‹ï¼Œsync.RWMutex ç±»å‹çš„é›¶å€¼å°±å·²ç»æ˜¯ç«‹å³å¯ç”¨çš„è¯»å†™é”äº† 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;sync\u0026#34; \u0026#34;time\u0026#34; ) var m *sync.RWMutex func main() { wg := sync.WaitGroup{} wg.Add(20) var rwMutex sync.RWMutex Data := 0 for i := 0; i \u0026lt; 10; i++ { go func(t int) { rwMutex.RLock()\t// è¯»åŠ é” defer rwMutex.RUnlock()\t// è¯»è§£é” fmt.Printf(\u0026#34;è¯»æ•°æ®ï¼š%v %d\\n\u0026#34;, Data, i) wg.Done() time.Sleep(1 * time.Second) // è¿™å¥ä»£ç ç¬¬ä¸€æ¬¡è¿è¡Œåï¼Œè¯»è§£é” // å¾ªç¯åˆ°ç¬¬äºŒä¸ªæ—¶ï¼Œ è¯»é”å®šåï¼Œè¿™ä¸ªgoroutineå°±æ²¡æœ‰é˜»å¡ï¼ŒåŒæ—¶è¯»æˆåŠŸ }(i) go func(t int) { rwMutex.Lock()\t// å†™åŠ é” defer rwMutex.Unlock()\t// å†™è§£é” Data += 1 fmt.Printf(\u0026#34;å†™æ•°æ®ï¼š%v %d\\n\u0026#34;, Data, t) wg.Done() // å¯¹è¯»å†™é”è¿›è¡Œè¯»é”å®šæˆ–è€…å†™é”å®šï¼Œéƒ½å°†é˜»å¡ // å†™é”å®šä¸‹æ˜¯éœ€è¦è§£é”åæ‰èƒ½å†™çš„ time.Sleep(5 * time.Second) }(i) } wg.Wait() } è¯»æ•°æ®ï¼š0 3 å†™æ•°æ®ï¼š1 2 è¯»æ•°æ®ï¼š1 10 è¯»æ•°æ®ï¼š1 10 è¯»æ•°æ®ï¼š1 10 è¯»æ•°æ®ï¼š1 10 è¯»æ•°æ®ï¼š1 10 è¯»æ•°æ®ï¼š1 10 è¯»æ•°æ®ï¼š1 10 è¯»æ•°æ®ï¼š1 10 è¯»æ•°æ®ï¼š1 10 å†™æ•°æ®ï¼š2 1 å†™æ•°æ®ï¼š3 3 å†™æ•°æ®ï¼š4 4 å†™æ•°æ®ï¼š5 5 å†™æ•°æ®ï¼š6 6 å†™æ•°æ®ï¼š7 0 å†™æ•°æ®ï¼š8 9 å†™æ•°æ®ï¼š9 7 å†™æ•°æ®ï¼š10 8 é€šè¿‡ç¨‹åºè¿è¡Œçš„è¾“å‡ºå¯ä»¥çœ‹åˆ°ï¼Œåœ¨å†™é”å®šæƒ…å†µä¸‹ï¼Œå¯¹è¯»å†™é”è¿›è¡Œé”å®šæˆ–è€…å†™é”å®šï¼Œéƒ½å°†é˜»å¡ æŠŠå†™æ•°æ®ä¸­çš„Sleepè®¾ç½®æ›´é•¿æ—¶é—´ï¼Œåœ¨ç¬¬ä¸€æ¬¡å†™é”å®šåï¼Œè¯»æ•°æ®ä¹Ÿæ²¡æœ‰è¿›è¡Œ å†æ¬¡å†™é”å®šæ˜¯åœ¨ rwMutex.Unlock() å®Œæˆåï¼Œæ‰èƒ½è¿›è¡Œ rwMutex.lock() è€Œè¯»æ•°æ®æ—¶åˆ™å¯ä»¥å¤šæ¬¡è¯»ï¼Œä¸ä¸€å®šéœ€è¦ç­‰ rwMutex.RUnlock() å®Œæˆ ","permalink":"https://heliu.site/posts/golang/sync/rwmutex/","summary":"RWMutexæ˜¯ä¸€ç§è¯»å†™äº’æ–¥é”ã€‚","title":"sync.RwMutex"},{"content":"type Once struct ğŸš€ Onceæ˜¯åªæ‰§è¡Œä¸€æ¬¡åŠ¨ä½œçš„å¯¹è±¡ï¼Œåº”ç”¨åœºæ™¯ï¼Œæ¯”å¦‚åŠ è½½é…ç½®æ–‡ä»¶åªéœ€è¦åŠ è½½ä¸€æ¬¡ã€‚ é¦–æ¬¡ä½¿ç”¨Onceåï¼Œä¸èƒ½å¤åˆ¶Onceã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 // Once is an object that will perform exactly one action. // // A Once must not be copied after first use. type Once struct { // done indicates whether the action has been performed. // It is first in the struct because it is used in the hot path. // The hot path is inlined at every call site. // Placing done first allows more compact instructions on some architectures (amd64/386), // and fewer instructions (to calculate offset) on other architectures. // // done è¡¨ç¤ºæ“ä½œæ˜¯å¦å·²ç»æ‰§è¡Œã€‚ // å®ƒåœ¨ç»“æ„ä½“ä¸­ä½äºé¦–ä½ï¼Œå› ä¸ºå®ƒåœ¨ hot path ä¸­ä½¿ç”¨ã€‚ // hot path å†…è”åœ¨æ¯ä¸ªè°ƒç”¨ç‚¹ã€‚ // åœ¨æŸäº›ä½“ç³»ç»“æ„ä¸Š(amd64/386)ï¼Œå°†doneæ”¾åœ¨ç¬¬ä¸€ä½å¯ä»¥è®©æŒ‡ä»¤æ›´ç´§å‡‘ï¼Œè€Œåœ¨å…¶ä»–ä½“ç³»ç»“æ„ä¸Šå¯ä»¥è®©æŒ‡ä»¤æ›´å°‘(ç”¨äºè®¡ç®—åç§»é‡)ã€‚ done uint32\t// 0.æœªè¢«è°ƒç”¨è¿‡ 1.å·²è¢«è°ƒç”¨è¿‡ m Mutex\t// äº’æ–¥é” } // å…¶ä¸­è§£é‡Šäº†ä¸ºä»€ä¹ˆå°† done ç½®ä¸º Once çš„ç¬¬ä¸€ä¸ªå­—æ®µï¼šdone åœ¨çƒ­è·¯å¾„ä¸­ï¼Œdone æ”¾åœ¨ç¬¬ä¸€ä¸ªå­—æ®µï¼Œèƒ½å¤Ÿå‡å°‘ CPU æŒ‡ä»¤ï¼Œä¹Ÿå°±æ˜¯è¯´ï¼Œè¿™æ ·åšèƒ½å¤Ÿæå‡æ€§èƒ½ã€‚ // 1. çƒ­è·¯å¾„(hot path)æ˜¯ç¨‹åºéå¸¸é¢‘ç¹æ‰§è¡Œçš„ä¸€ç³»åˆ—æŒ‡ä»¤ï¼Œsync.Once ç»å¤§éƒ¨åˆ†åœºæ™¯éƒ½ä¼šè®¿é—® o.doneï¼Œåœ¨çƒ­è·¯å¾„ä¸Šæ˜¯æ¯”è¾ƒå¥½ç†è§£çš„ï¼Œ //\tå¦‚æœ hot path ç¼–è¯‘åçš„æœºå™¨ç æŒ‡ä»¤æ›´å°‘ï¼Œæ›´ç›´æ¥ï¼Œå¿…ç„¶æ˜¯èƒ½å¤Ÿæå‡æ€§èƒ½çš„ã€‚ // 2. ä¸ºä»€ä¹ˆæ”¾åœ¨ç¬¬ä¸€ä¸ªå­—æ®µå°±èƒ½å¤Ÿå‡å°‘æŒ‡ä»¤å‘¢ï¼Ÿå› ä¸ºç»“æ„ä½“ç¬¬ä¸€ä¸ªå­—æ®µçš„åœ°å€å’Œç»“æ„ä½“çš„æŒ‡é’ˆæ˜¯ç›¸åŒçš„ï¼Œå¦‚æœæ˜¯ç¬¬ä¸€ä¸ªå­—æ®µï¼Œç›´æ¥å¯¹ç»“æ„ä½“çš„æŒ‡é’ˆè§£å¼•ç”¨å³å¯ã€‚ // å¦‚æœæ˜¯å…¶ä»–çš„å­—æ®µï¼Œé™¤äº†ç»“æ„ä½“æŒ‡é’ˆå¤–ï¼Œè¿˜éœ€è¦è®¡ç®—ä¸ç¬¬ä¸€ä¸ªå€¼çš„åç§»(calculate offset)ã€‚åœ¨æœºå™¨ç ä¸­ï¼Œåç§»é‡æ˜¯éšæŒ‡ä»¤ä¼ é€’çš„é™„åŠ å€¼ï¼Œ // CPU éœ€è¦åšä¸€æ¬¡åç§»å€¼ä¸æŒ‡é’ˆçš„åŠ æ³•è¿ç®—ï¼Œæ‰èƒ½è·å–è¦è®¿é—®çš„å€¼çš„åœ°å€ã€‚å› ä¸ºï¼Œè®¿é—®ç¬¬ä¸€ä¸ªå­—æ®µçš„æœºå™¨ä»£ç æ›´ç´§å‡‘ï¼Œé€Ÿåº¦æ›´å¿«ã€‚ Do() å½“ä¸”ä»…å½“ Do æ˜¯ç¬¬ä¸€æ¬¡ä¸º Once å®ä¾‹è°ƒç”¨å‡½æ•° f æ—¶ï¼ŒDo æ‰ä¼šè°ƒç”¨å‡½æ•° fã€‚ æ¢å¥è¯è¯´ï¼Œç»™å®švar once Onceï¼Œå¦‚æœ once.Do(f) è¢«å¤šæ¬¡è°ƒç”¨ï¼Œåªæœ‰ç¬¬ä¸€æ¬¡è°ƒç”¨ä¼šè°ƒç”¨fï¼Œå³ä½¿æ¯æ¬¡è°ƒç”¨ f çš„å€¼ä¸åŒã€‚ æ¯ä¸ªå‡½æ•°æ‰§è¡Œæ—¶éƒ½éœ€è¦ä¸€ä¸ª Once çš„æ–°å®ä¾‹ã€‚ Do ç”¨äºå¿…é¡»åªè¿è¡Œä¸€æ¬¡çš„åˆå§‹åŒ–ã€‚ ç”±äº f æ˜¯ niladicï¼Œå› æ­¤å¯èƒ½éœ€è¦ä½¿ç”¨å‡½æ•°å­—é¢é‡æ¥æ•è·Doè°ƒç”¨çš„å‡½æ•°çš„å‚æ•°:config.once.Do(func() { config.init(filename) }) niladicï¼šè¢«è§£é‡Šä¸ºä¸å¸¦å‚æ•°çš„é—­åŒ…å‡½æ•°ã€‚ å› ä¸ºåªæœ‰åœ¨å¯¹ f çš„è°ƒç”¨è¿”å›ä¹‹å‰ï¼Œæ‰ä¼šè¿”å›å¯¹ Do çš„è°ƒç”¨ï¼Œå¦‚æœ f å¯¼è‡´Doè¢«è°ƒç”¨ï¼Œå®ƒå°±ä¼šæ­»é”ã€‚ï¼ˆfå‡½æ•°å†…ä¸èƒ½åœ¨è°ƒç”¨å¤–å±‚çš„Doå‡½æ•°ï¼‰ å¦‚æœfå‘ç”Ÿpanicï¼ŒDoè®¤ä¸ºå®ƒå›æ¥äº†;Doçš„åç»­è°ƒç”¨ä¸éœ€è¦è°ƒç”¨fã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 // Do calls the function f if and only if Do is being called for the // first time for this instance of Once. In other words, given // var once Once // if once.Do(f) is called multiple times, only the first call will invoke f, // even if f has a different value in each invocation. A new instance of // Once is required for each function to execute. // // Do is intended for initialization that must be run exactly once. Since f // is niladic, it may be necessary to use a function literal to capture the // arguments to a function to be invoked by Do: // config.once.Do(func() { config.init(filename) }) // // Because no call to Do returns until the one call to f returns, if f causes // Do to be called, it will deadlock. // // If f panics, Do considers it to have returned; future calls of Do return // without calling f. func (o *Once) Do(f func()) { // Note: Here is an incorrect implementation of Do: // //\tif atomic.CompareAndSwapUint32(\u0026amp;o.done, 0, 1) { //\tf() //\t} // // Do guarantees that when it returns, f has finished. // This implementation would not implement that guarantee: // given two simultaneous calls, the winner of the cas would // call f, and the second would return immediately, without // waiting for the first\u0026#39;s call to f to complete. // This is why the slow path falls back to a mutex, and why // the atomic.StoreUint32 must be delayed until after f returns. // // æ³¨æ„:ä¸‹é¢æ˜¯ä¸€ä¸ªä¸æ­£ç¡®çš„Doå®ç°ã€‚ // ä»¥ä¸‹å½¢å¼ä¸èƒ½ä¿è¯Doå‡½æ•°è¿”å›æ—¶få‡½æ•°å·²æ‰§è¡Œå®Œï¼Œå› ä¸ºæˆ‘ä»¬æ˜¯å…ˆæ ‡è®°åæ‰§è¡Œfçš„ã€‚ // if atomic.CompareAndSwapUint32(\u0026amp;o.done, 0, 1) { // f() // } // // Do ä¿è¯å½“å®ƒè¿”å›æ—¶ï¼Œf å·²ç»å®Œæˆ // è¿™ç§å®ç°ä¸ä¼šå®ç°è¿™ç§ä¿è¯:ç»™å®šä¸¤ä¸ªåŒæ—¶è°ƒç”¨ï¼Œcasçš„èµ¢å®¶å°†è°ƒç”¨fï¼Œè€Œç¬¬äºŒä¸ªå°†ç«‹å³è¿”å›ï¼Œè€Œæ— éœ€ç­‰å¾…ç¬¬ä¸€ä¸ªè°ƒç”¨å®Œæˆã€‚ // è¿™å°±æ˜¯æ…¢è·¯å¾„å›é€€åˆ°äº’æ–¥é‡çš„åŸå› ï¼Œä¹Ÿæ˜¯åŸå­æ€§çš„åŸå› ã€‚StoreUint32å¿…é¡»å»¶è¿Ÿåˆ°fè¿”å›ä¹‹åã€‚ // åç»­å¤§éƒ¨åˆ†æƒ…å†µä¼šä»è¿™é‡Œåˆ¤æ–­å¤±è´¥ if atomic.LoadUint32(\u0026amp;o.done) == 0 { // Outlined slow-path to allow inlining of the fast-path. o.doSlow(f) } } doSlow() 1 2 3 4 5 6 7 8 9 10 11 12 func (o *Once) doSlow(f func()) { o.m.Lock() // è·å–é” defer o.m.Unlock() // å»¶è¿Ÿé‡Šæ”¾é” // å½“å‡ºç°å¹¶å‘æ—¶ï¼Œè¿™é‡Œä¼šæ‹¦ä½ç­‰å¾…ç€çš„åç¨‹ if o.done == 0 {\t// åœ¨f()æ‰§è¡Œå®Œåæ‰ä¼šæ ‡è®°doneä¸º1ã€‚ defer atomic.StoreUint32(\u0026amp;o.done, 1) // éœ€è¦ä¿è¯få‡½æ•°ä¸ä¼šå‘ç”Ÿpanic // å¦‚æœå‘ç”Ÿpanicï¼Œåˆ™o.doneä¼šè¢«æ ‡è®°ä¸º1ï¼Œåç»­ä¸ä¼šåœ¨è°ƒç”¨få‡½æ•° f() } } ä½¿ç”¨åœºæ™¯ sync.Once æ˜¯ Go æ ‡å‡†åº“æä¾›çš„ä½¿å‡½æ•°åªæ‰§è¡Œä¸€æ¬¡çš„å®ç°ã€‚ å¸¸åº”ç”¨äºã€å•ä¾‹æ¨¡å¼ã€‘ï¼Œä¾‹å¦‚ã€åˆå§‹åŒ–é…ç½®ã€‘ã€ã€ä¿æŒæ•°æ®åº“è¿æ¥ã€‘ç­‰ã€‚ä½œç”¨ä¸ init å‡½æ•°ç±»ä¼¼ï¼Œä½†æœ‰åŒºåˆ«ã€‚ init å‡½æ•°æ˜¯å½“æ‰€åœ¨çš„ package é¦–æ¬¡è¢«åŠ è½½æ—¶æ‰§è¡Œï¼Œè‹¥è¿Ÿè¿Ÿæœªè¢«ä½¿ç”¨ï¼Œåˆ™æ—¢æµªè´¹äº†å†…å­˜ï¼Œåˆå»¶é•¿äº†ç¨‹åºåŠ è½½æ—¶é—´ã€‚ sync.Once å¯ä»¥åœ¨ä»£ç çš„ä»»æ„ä½ç½®åˆå§‹åŒ–å’Œè°ƒç”¨ï¼Œå› æ­¤å¯ä»¥å»¶è¿Ÿåˆ°ä½¿ç”¨æ—¶å†æ‰§è¡Œï¼Œå¹¶å‘åœºæ™¯ä¸‹æ˜¯çº¿ç¨‹å®‰å…¨çš„ã€‚ åœ¨å¤šæ•°æƒ…å†µä¸‹ï¼Œsync.Once è¢«ç”¨äºæ§åˆ¶å˜é‡çš„åˆå§‹åŒ–ï¼Œè¿™ä¸ªå˜é‡çš„è¯»å†™æ»¡è¶³å¦‚ä¸‹ä¸‰ä¸ªæ¡ä»¶ï¼š å½“ä¸”ä»…å½“ç¬¬ä¸€æ¬¡è®¿é—®æŸä¸ªå˜é‡æ—¶ï¼Œè¿›è¡Œåˆå§‹åŒ–ï¼ˆå†™ï¼‰ã€‚ å˜é‡åˆå§‹åŒ–è¿‡ç¨‹ä¸­ï¼Œæ‰€æœ‰è¯»éƒ½è¢«é˜»å¡ï¼Œç›´åˆ°åˆå§‹åŒ–å®Œæˆã€‚ å˜é‡ä»…åˆå§‹åŒ–ä¸€æ¬¡ï¼Œåˆå§‹åŒ–å®Œæˆåé©»ç•™åœ¨å†…å­˜é‡Œã€‚ sync.Once ä»…æä¾›äº†ä¸€ä¸ªæ–¹æ³• Doï¼Œå‚æ•° f æ˜¯å¯¹è±¡åˆå§‹åŒ–å‡½æ•°ã€‚ func (o *Once) Do(f func())ã€‚ ä½¿ç”¨ç¤ºä¾‹ ç®€å•çš„ç¤ºä¾‹ è€ƒè™‘ä¸€ä¸ªç®€å•çš„åœºæ™¯ï¼Œå‡½æ•° ReadConfig éœ€è¦è¯»å–ç¯å¢ƒå˜é‡ï¼Œå¹¶è½¬æ¢ä¸ºå¯¹åº”çš„é…ç½®ã€‚ ç¯å¢ƒå˜é‡åœ¨ç¨‹åºæ‰§è¡Œå‰å·²ç»ç¡®å®šï¼Œæ‰§è¡Œè¿‡ç¨‹ä¸­ä¸ä¼šå‘ç”Ÿæ”¹å˜ã€‚ ReadConfig å¯èƒ½ä¼šè¢«å¤šä¸ªåç¨‹å¹¶å‘è°ƒç”¨ï¼Œä¸ºäº†æå‡æ€§èƒ½ï¼ˆå‡å°‘æ‰§è¡Œæ—¶é—´å’Œå†…å­˜å ç”¨ï¼‰ï¼Œä½¿ç”¨ sync.Once æ˜¯ä¸€ä¸ªæ¯”è¾ƒå¥½çš„æ–¹å¼ã€‚ åœ¨è¿™ä¸ªä¾‹å­ä¸­ï¼Œå£°æ˜äº† 2 ä¸ªå…¨å±€å˜é‡ï¼Œonce å’Œ configã€‚ config æ˜¯éœ€è¦åœ¨ ReadConfig å‡½æ•°ä¸­åˆå§‹åŒ–çš„(å°†ç¯å¢ƒå˜é‡è½¬æ¢ä¸º Config ç»“æ„ä½“)ï¼ŒReadConfig å¯èƒ½ä¼šè¢«å¹¶å‘è°ƒç”¨ã€‚ å¦‚æœ ReadConfig æ¯æ¬¡éƒ½æ„é€ å‡ºä¸€ä¸ªæ–°çš„ Config ç»“æ„ä½“ï¼Œæ—¢æµªè´¹å†…å­˜ï¼Œåˆæµªè´¹åˆå§‹åŒ–æ—¶é—´ã€‚ å¦‚æœ ReadConfig ä¸­ä¸åŠ é”ï¼Œåˆå§‹åŒ–å…¨å±€å˜é‡ config å°±å¯èƒ½å‡ºç°å¹¶å‘å†²çªã€‚ è¿™ç§æƒ…å†µä¸‹ï¼Œä½¿ç”¨ sync.Once æ—¢èƒ½å¤Ÿä¿è¯å…¨å±€å˜é‡åˆå§‹åŒ–æ—¶æ˜¯çº¿ç¨‹å®‰å…¨çš„ï¼Œåˆèƒ½èŠ‚çœå†…å­˜å’Œåˆå§‹åŒ–æ—¶é—´ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 type Config struct { Server string Port int64 } var ( once sync.Once config *Config ) func ReadConfig() *Config { once.Do(func() { var err error config = \u0026amp;Config{Server: os.Getenv(\u0026#34;TT_SERVER_URL\u0026#34;)} config.Port, err = strconv.ParseInt(os.Getenv(\u0026#34;TT_PORT\u0026#34;), 10, 0) if err != nil { config.Port = 8080 // default port } log.Println(\u0026#34;init config\u0026#34;) }) return config } func main() { for i := 0; i \u0026lt; 10; i++ { go func() { _ = ReadConfig() }() } time.Sleep(time.Second) } æ ‡å‡†åº“ä¸­çš„ä½¿ç”¨ æ¯”å¦‚ package html ä¸­ï¼Œå¯¹è±¡ entity åªè¢«åˆå§‹åŒ–ä¸€æ¬¡ã€‚ å­—å…¸ entity åŒ…å« 2005 ä¸ªé”®å€¼å¯¹ï¼Œè‹¥ä½¿ç”¨ init åœ¨åŒ…åŠ è½½æ—¶åˆå§‹åŒ–ï¼Œè‹¥ä¸è¢«ä½¿ç”¨ï¼Œå°†ä¼šæµªè´¹å¤§é‡å†…å­˜ã€‚ html.UnescapeString(s) å‡½æ•°æ˜¯çº¿ç¨‹å®‰å…¨çš„ï¼Œå¯èƒ½ä¼šè¢«ç”¨æˆ·ç¨‹åºåœ¨å¹¶å‘åœºæ™¯ä¸‹è°ƒç”¨ï¼Œå› æ­¤å¯¹ entity çš„åˆå§‹åŒ–éœ€è¦åŠ é”ï¼Œä½¿ç”¨ sync.Once èƒ½ä¿è¯è¿™ä¸€ç‚¹ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 var populateMapsOnce sync.Once var entity map[string]rune func populateMaps() { entity = map[string]rune{ \u0026#34;AElig;\u0026#34;: \u0026#39;\\U000000C6\u0026#39;, \u0026#34;AMP;\u0026#34;: \u0026#39;\\U00000026\u0026#39;, \u0026#34;Aacute;\u0026#34;: \u0026#39;\\U000000C1\u0026#39;, \u0026#34;Abreve;\u0026#34;: \u0026#39;\\U00000102\u0026#39;, \u0026#34;Acirc;\u0026#34;: \u0026#39;\\U000000C2\u0026#39;, // çœç•¥ 2000 é¡¹ } } func UnescapeString(s string) string { populateMapsOnce.Do(populateMaps) i := strings.IndexByte(s, \u0026#39;\u0026amp;\u0026#39;) if i \u0026lt; 0 { return s } // çœç•¥åç»­çš„å®ç° } æ™®é€šç¤ºä¾‹ å¯¹åªéœ€è¦è¿è¡Œä¸€æ¬¡çš„ä»£ç ï¼Œå¦‚å…¨å±€æ€§çš„åˆå§‹åŒ–æ“ä½œï¼Œæˆ–è€…é˜²æ­¢å¤šæ¬¡é‡å¤æ‰§è¡Œï¼ˆæ¯”å¦‚é‡å¤æäº¤ç­‰ï¼‰éƒ½æœ‰å¾ˆå¥½çš„ä½œç”¨ æ— è®º sync.Once.Do(f func()) é‡Œé¢çš„få‡½æ•°æ˜¯å¦å˜åŒ–ï¼Œåªè¦ Once.Do() è¿è¡Œä¸€æ¬¡å°±æ²¡æœ‰æœºä¼šå†æ¬¡è¿è¡Œäº† Once æ˜¯ä¸€ä¸ªç»“æ„ä½“ï¼Œé€šè¿‡åˆ¤æ–­ done å€¼æ¥ç¡®å®šæ˜¯å¦æ‰§è¡Œä¸‹ä¸€æ­¥ å½“ done ä¸º1æ—¶ç›´æ¥è¿”å›ï¼Œå¦åˆ™é”å®šåæ‰§è¡Œfå‡½æ•°ä»¥åŠç½®doneå€¼ä¸º1 è€Œå¯¹ done çš„å€¼å¾—ä¿®æ”¹ä½¿ç”¨äº† atomic.StoreUint32ï¼ˆåŸå­çº§çš„æ“ä½œï¼‰ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;sync\u0026#34; \u0026#34;time\u0026#34; ) var once sync.Once func onces() { fmt.Println(\u0026#34;once\u0026#34;) } func onced() { fmt.Println(\u0026#34;onced\u0026#34;) } func main() { for i, v := range make([]string, 10){ once.Do(onces) fmt.Println(\u0026#34;v:\u0026#34;, v, \u0026#34;--i:\u0026#34;, i) } for i := 0; i \u0026lt; 10; i++ { go func(i int) { once.Do(onced) fmt.Println(i) }(i) } time.Sleep(3 * time.Second) } once v: --i: 0 v: --i: 1 v: --i: 2 v: --i: 3 v: --i: 4 v: --i: 5 v: --i: 6 v: --i: 7 v: --i: 8 v: --i: 9 0 1 3 4 2 6 5 7 8 9 ","permalink":"https://heliu.site/posts/golang/sync/once/","summary":"Onceæ˜¯åªæ‰§è¡Œä¸€ä¸ªåŠ¨ä½œçš„å¯¹è±¡ã€‚","title":"sync.Once"},{"content":"type Mutex struct ğŸš€ åŒ…è¯´æ˜ï¼š\nsync åŒ…æä¾›äº†åŸºæœ¬çš„åŒæ­¥åŸè¯­ï¼Œå¦‚äº’æ–¥é”ã€‚ é™¤äº† Once å’Œ WaitGroup ç±»å‹ä¹‹å¤–ï¼Œå¤§å¤šæ•°éƒ½ä¾›åº•å±‚åº“ä¾‹ç¨‹ä½¿ç”¨ã€‚ æ›´é«˜å±‚æ¬¡çš„åŒæ­¥æœ€å¥½é€šè¿‡ channels å’Œé€šä¿¡æ¥å®Œæˆã€‚ åŒ…å«åœ¨æ­¤åŒ…ä¸­å®šä¹‰çš„ç±»å‹çš„å€¼ä¸åº”è¢«å¤åˆ¶ã€‚ 1 2 3 4 5 6 7 // Package sync provides basic synchronization primitives such as mutual // exclusion locks. Other than the Once and WaitGroup types, most are intended // for use by low-level library routines. Higher-level synchronization is // better done via channels and communication. // // Values containing the types defined in this package should not be copied. package sync Mutex æ˜¯ä¸€æŠŠäº’æ–¥é”ã€‚äº’æ–¥é”çš„é›¶å€¼æ˜¯æœªé”å®šçš„ã€‚ Mutex åœ¨ç¬¬ä¸€æ¬¡ä½¿ç”¨åä¸èƒ½è¢«å¤åˆ¶ã€‚ åœ¨ Go å†…å­˜æ¨¡å‹çš„æœ¯è¯­ä¸­ï¼Œç¬¬ n æ¬¡è°ƒç”¨ Unlockï¼Œç¬¬ m æ¬¡è°ƒç”¨ Lock åœ¨åŒæ­¥å®Œæˆä»¥å‰ ä»»ä½• n \u0026lt; mã€‚ æˆåŠŸè°ƒç”¨ TryLock ç­‰åŒäºè°ƒç”¨ Lockã€‚è°ƒç”¨ TryLock å¤±è´¥æ ¹æœ¬ä¸ä¼šå»ºç«‹ä»»ä½•å…³ç³» åœ¨åŒæ­¥å®Œæˆä»¥å‰ã€‚ å®ƒæ˜¯ä¸€æŠŠç»“åˆäº†ã€è‡ªæ—‹é”ã€‘å’Œã€ä¿¡å·é‡ã€‘ä¼˜åŒ–è¿‡çš„é”ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 // A Mutex is a mutual exclusion lock. // The zero value for a Mutex is an unlocked mutex. // // A Mutex must not be copied after first use. // // In the terminology of the Go memory model, // the n\u0026#39;th call to Unlock â€œsynchronizes beforeâ€ the m\u0026#39;th call to Lock // for any n \u0026lt; m. // A successful call to TryLock is equivalent to a call to Lock. // A failed call to TryLock does not establish any â€œsynchronizes beforeâ€ // relation at all. type Mutex struct { // Mutex çš„çŠ¶æ€ä¿¡æ¯ state int32\t// åˆå§‹æ—¶ä¸º 0 // semaphore ç›¸å…³å­—æ®µï¼Œè¯¥å­—æ®µä¹Ÿæ˜¯ä¸ºä»€ä¹ˆ Mutex ä¸è®©æ‹·è´çš„åŸå›  sema uint32 // åˆå§‹æ—¶ä¸º 0 } Mutex çš„å†…å­˜å¸ƒå±€ï¼š Mutex æ˜¯ä¸€ä¸ªäº’æ–¥é”ï¼Œå¯ä»¥åˆ›å»ºä¸ºå…¶ä»–ç»“æ„ä½“çš„å­—æ®µï¼Œé›¶å€¼ä¸ºè§£é”çŠ¶æ€ã€‚ Mutex ç±»å‹çš„é”å’Œçº¿ç¨‹æ— å…³ï¼Œå¯ä»¥ç”±ä¸åŒçš„çº¿ç¨‹åŠ é”å’Œè§£é”ã€‚ Mutex ç»“æ„å¸ƒå±€ï¼š state è®°å½• Mutex çš„ç›¸å…³ä¿¡æ¯ã€‚ sema åœ¨ Mutex ä¸­æ²¡æœ‰ä»»ä½•ä½œç”¨ï¼Œä¸»è¦æ˜¯åœ¨ semaphore ä¸­ï¼Œè¯¥å­—æ®µæ˜¯ Mutex ä¸èƒ½è¢«æ‹·è´çš„æ ¹æœ¬åŸå› ï¼Œåœ¨ semaphore ä¸­ä¸»è¦æ ‡è¯†æœ‰ wakeup å‘ç”Ÿã€‚ ã€æ­£å¸¸æ¨¡å¼ã€‘å’Œã€é¥¥é¥¿æ¨¡å¼ã€‘ï¼š æ­£å¸¸æ¨¡å¼ï¼šä¸€ä¸ªå°è¯•åŠ é”çš„ goroutine ä¼šå…ˆè‡ªæ—‹å‡ æ¬¡ï¼Œå°è¯•é€šè¿‡åŸå­æ“ä½œè·å¾—é”ï¼Œè‹¥å‡ æ¬¡è‡ªæ—‹ä¹‹åä»ä¸èƒ½è·å¾—é”ï¼Œåˆ™é€šè¿‡ä¿¡å·é‡ï¼ˆsemaphoreï¼‰æ’é˜Ÿç­‰å¾…ã€‚æ‰€æœ‰çš„ç­‰å¾…è€…ä¼šæŒ‰ç…§å…ˆå…¥å…ˆå‡ºï¼ˆFIFOï¼‰çš„é¡ºåºæ’é˜Ÿï¼Œä½†æ˜¯å½“ä¸€ä¸ªç­‰å¾…è€…è¢«å”¤é†’åå¹¶ä¸ä¼šç›´æ¥æ‹¥æœ‰é”ï¼Œè€Œæ˜¯éœ€è¦å’Œåæ¥è€…ï¼ˆå¤„äºè‡ªæ—‹é˜¶æ®µï¼Œå°šæœªæ’é˜Ÿç­‰å¾…çš„åç¨‹ï¼‰ç«äº‰ã€‚è¿™ç§æƒ…å†µä¸‹åæ¥è€…æ›´æœ‰ä¼˜åŠ¿ï¼Œä¸€æ–¹é¢åŸå› æ˜¯åæ¥è€…æ­£åœ¨CPUä¸Šè¿è¡Œï¼Œè‡ªç„¶æ¯”åˆšå”¤é†’çš„ goroutine æ›´æœ‰ä¼˜åŠ¿ï¼Œå¦ä¸€æ–¹é¢å¤„äºè‡ªæ—‹çŠ¶æ€çš„ goroutine å¯ä»¥æœ‰å¾ˆå¤šï¼Œè€Œè¢«å”¤é†’çš„ goroutine æ¯æ¬¡åªæœ‰ä¸€ä¸ªï¼Œæ‰€ä»¥è¢«å”¤é†’çš„ goroutine æœ‰å¾ˆå¤§æ¦‚ç‡è·å–ä¸åˆ°é”ï¼Œè¿™ç§æƒ…å†µä¸‹å®ƒä¼šè¢«é‡æ–°æ’å…¥é˜Ÿåˆ—çš„å¤´éƒ¨ï¼Œè€Œä¸æ˜¯å°¾éƒ¨ã€‚å½“ä¸€ä¸ª goroutine æœ¬æ¬¡åŠ é”ç­‰å¾…çš„æ—¶é—´è¶…è¿‡äº† 1ms åï¼Œå®ƒä¼šæŠŠå½“å‰ Mutex åˆ‡æ¢è‡³é¥¥é¥¿çŠ¶æ€ã€‚ é¥¥é¥¿æ¨¡å¼ï¼šMutex çš„æ‰€æœ‰æƒä»æ‰§è¡Œ Unlock çš„ goroutine ç›´æ¥ä¼ é€’ç»™ç­‰å¾…é˜Ÿåˆ—å¤´éƒ¨çš„ goroutineã€‚åæ¥è€…ä¸ä¼šè‡ªæ—‹ï¼Œä¹Ÿä¸ä¼šå°è¯•è·å¾—é”ï¼Œå®ƒä»¬ä¼šç›´æ¥ä»é˜Ÿåˆ—çš„å°¾éƒ¨æ’é˜Ÿç­‰å¾…ï¼Œå³ä½¿ Mutex å¤„äº Unlocked çŠ¶æ€ã€‚å½“ä¸€ä¸ªç­‰å¾…è€…è·å¾—äº†é”ä¹‹åï¼Œå®ƒä¼šåœ¨ä»¥ä¸‹ä¸¤ç§æƒ…å†µæ—¶å°† Mutex ç”±é¥¥é¥¿æ¨¡å¼åˆ‡æ¢å›æ­£å¸¸æ¨¡å¼ï¼š(1)å®ƒæ˜¯æœ€åä¸€ä¸ªç­‰å¾…è€…ï¼Œå³ç­‰å¾…é˜Ÿåˆ—ç©ºäº†ã€‚(2)å®ƒçš„ç­‰å¾…æ—¶é—´å°äº1msï¼Œä¹Ÿå°±æ˜¯å®ƒåˆšæ¥ä¸ä¹…ï¼Œåé¢è‡ªç„¶æ›´æ²¡æœ‰é¥¥é¥¿çš„ goroutine äº†ã€‚ æ­£å¸¸æ¨¡å¼ä¸‹ Mutex æœ‰æ›´å¥½çš„æ€§èƒ½ï¼Œä½†æ˜¯é¥¥é¥¿æ¨¡å¼å¯¹äºé˜²æ­¢å°¾ç«¯å»¶é•¿ï¼ˆé˜Ÿåˆ—å°¾ç«¯çš„ goroutine è¿Ÿè¿ŸæŠ¢ä¸åˆ°é”ï¼‰æ¥è®²ç‰¹åˆ«é‡è¦ã€‚ const 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 const ( // æ˜¯å¦ä¸Šé”æ ‡å¿—ä½ï¼›0-æœªä¸Šé”ï¼Œ1-å·²ä¸Šé”ï¼› mutexLocked = 1 \u0026lt;\u0026lt; iota\t// 001 // æ˜¯å¦æœ‰ goroutine ä»é˜»å¡ä¸­è¢«å”¤é†’ï¼›0-æ²¡æœ‰ï¼›1-æœ‰ï¼› // å½“è¯¥æ ‡å¿—ä½è¢«è®¾ç½®æ—¶ï¼ŒUnlock æ“ä½œä¸ä¼šå”¤é†’æ’é˜Ÿçš„ goroutineã€‚ mutexWoken\t// 010 // æ˜¯å¦å¤„äºé¥¥é¥¿æ¨¡å¼ï¼›0-éé¥¥é¥¿ï¼Œ1-é¥¥é¥¿ï¼› mutexStarving\t// 100 // æœ€ä½ä½å­˜åœ¨3ä¸ªbitä½æ ‡è¯†ç‰¹ä¿—ä¿¡æ¯ï¼Œåˆ†åˆ«ä¸ºä¸Šè¿°çš„ mutexLockedã€mutexWokenã€mutexStarving mutexWaiterShift = iota\t// 3 // äº’æ–¥å…¬å¹³ // äº’æ–¥é‡å¯ä»¥æœ‰ä¸¤ç§æ“ä½œæ¨¡å¼:æ­£å¸¸(normal)å’Œé¥¥é¥¿(starvation)ã€‚ // åœ¨æ­£å¸¸æ¨¡å¼(normal mode)ä¸‹ï¼šç­‰å¾…çš„waitersæŒ‰FIFO(å…ˆè¿›å…ˆå‡º)é¡ºåºæ’é˜Ÿï¼Œä½†è¢«å”¤é†’çš„waiterä¸æ‹¥æœ‰äº’æ–¥é”ï¼Œå¹¶ä¸æ–°åˆ°è¾¾çš„goroutinesç«äº‰æ‰€æœ‰æƒã€‚ // æ–°åŠ å…¥çš„goroutinesæœ‰ä¸€ä¸ªä¼˜åŠ¿ï¼Œå®ƒä»¬å·²ç»åœ¨CPUä¸Šè¿è¡Œï¼Œå¹¶ä¸”å¯èƒ½æœ‰å¾ˆå¤šï¼Œæ‰€ä»¥å”¤é†’çš„waiterså¾ˆæœ‰å¯èƒ½ä¼šå¤±è´¥ã€‚ // åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œå®ƒè¢«é‡æ–°å®‰æ’åœ¨ç­‰å¾…é˜Ÿåˆ—çš„å‰é¢ã€‚å¦‚æœwaiterè¶…è¿‡1msæœªèƒ½è·å–äº’æ–¥é”ï¼Œå®ƒå°†äº’æ–¥é”åˆ‡æ¢åˆ°é¥¥é¥¿æ¨¡å¼ã€‚ // åœ¨é¥¥é¥¿æ¨¡å¼(starvation mode)ä¸‹ï¼šäº’æ–¥é”çš„æ‰€æœ‰æƒç›´æ¥ä»æ­£åœ¨è§£é”çš„goroutineç§»äº¤ç»™é˜Ÿåˆ—å‰é¢çš„waiterã€‚ // æ–°åˆ°è¾¾çš„goroutinesä¸ä¼šå°è¯•è·å–äº’æ–¥é”ï¼Œå³ä½¿å®ƒçœ‹èµ·æ¥å·²ç»è§£é”ï¼Œä¹Ÿä¸ä¼šå°è¯•æ—‹è½¬ã€‚ç›¸åï¼Œå®ƒä»¬æŠŠè‡ªå·±æ’åœ¨ç­‰å¾…é˜Ÿåˆ—çš„å°¾éƒ¨ã€‚ // å¦‚æœä¸€ä¸ªwaiteræ”¶åˆ°äº’æ–¥é”çš„æ‰€æœ‰æƒï¼Œå¹¶ä¸”å‘ç° //\t1) å®ƒæ˜¯é˜Ÿåˆ—ä¸­æœ€åä¸€ä¸ªwaiterï¼Œæˆ–è€… //\t2) å®ƒç­‰å¾…çš„æ—¶é—´å°‘äº1æ¯«ç§’ï¼Œå®ƒä¼šå°†äº’æ–¥é”åˆ‡æ¢å›æ­£å¸¸å·¥ä½œæ¨¡å¼ã€‚ // æ™®é€šæ¨¡å¼(Normal mode)å…·æœ‰æ›´å¥½çš„æ€§èƒ½ï¼Œå› ä¸ºgoroutineå¯ä»¥è¿ç»­å¤šæ¬¡è·å–äº’æ–¥é‡ï¼Œå³ä½¿æœ‰é˜»å¡çš„ç­‰å¾…ã€‚ // é¥¥é¥¿æ¨¡å¼(Starvation mode)å¯¹äºé¢„é˜²æœ‰äº›gä¸€å€¼è·å–ä¸åˆ°é”çš„å°¾å»¶è¿Ÿå…·æœ‰é‡è¦æ„ä¹‰ã€‚(è¯¥æ¨¡å¼é˜²æ­¢æœ‰äº›å§‹ç»ˆæ‹¿ä¸åˆ°é”çš„ä¸€ç›´ç­‰å¾…åœ¨ä¿¡å·æ± é‡Œé¢çš„goroutine) // æ­£å¸¸æ¨¡å¼ \u0026lt;-\u0026gt; é¥¥é¥¿æ¨¡å¼ ç›¸äº’è½¬æ¢çš„æ—¶é—´é˜€é—¨ // é¥¥é¥¿æ¨¡å¼ï¼Œå½“å‰ä»semaphoreä¸­wakeupçš„goroutineçš„sleepæ—¶é—´è¶…è¿‡1msï¼Œå†æ¬¡è·å–é”å¤±è´¥æ—¶ä¼šè¢«æ ‡è®°ä¸ºé¥¥é¥¿æ¨¡å¼ // é¥¥é¥¿æ¨¡å¼ä¸‹ï¼šstate å€¼çš„ mutexLockedå’ŒmutexWoken ä½å¯èƒ½ä¸º0æˆ–1ï¼Œè¢«å”¤é†’çš„goroutine mutexLockedå’ŒmutexWoken ä½éƒ½ä¸º0 starvationThresholdNs = 1e6\t// sync.Mutex è¿›å…¥é¥¥é¥¿æ¨¡å¼çš„ç­‰å¾…æ—¶é—´é˜ˆå€¼1msã€‚ ) Lock() Lock é”ä½ mã€‚ å¦‚æœé”å·²ç»è¢«ä½¿ç”¨ï¼Œè°ƒç”¨ goroutine ä¼šé˜»å¡ï¼Œç›´åˆ° mutex å¯ç”¨ã€‚ Lock å’Œ Unlock æ˜¯ä¸€å¯¹æ“ä½œã€‚ è¯¥æ–¹æ³•ä¸»è¦é€šè¿‡ atomic å‡½æ•°å®ç°äº†Fast pathï¼Œç›¸åº”çš„Slow pathè¢«å•ç‹¬æ”¾åœ¨äº†lockSlow()æ–¹æ³•ä¸­ã€‚ æ ¹æ®æºç æ³¨é‡Šçš„è¯´æ³•ï¼Œè¿™æ ·æ˜¯ä¸ºäº†ä¾¿äºç¼–è¯‘å™¨å¯¹ Fast path è¿›è¡Œå†…è”ä¼˜åŒ–ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 // Lock locks m. // If the lock is already in use, the calling goroutine // blocks until the mutex is available. func (m *Mutex) Lock() { // 1) ä½¿ç”¨CASå°è¯•è·å–é” // Fast pathæœŸæœ› Mutex å¤„äº Unlocked çŠ¶æ€ï¼Œæ²¡æœ‰ goroutine åœ¨æ’é˜Ÿï¼Œæ›´ä¸ä¼šé¥¥é¥¿ã€‚ // ç†æƒ³çŠ¶æ€ä¸‹ï¼Œä¸€ä¸ªCASæ“ä½œå°±å¯ä»¥è·å¾—é”ã€‚ // Fast path: grab unlocked mutex. // // å¿«é€Ÿè·¯å¾„ï¼šè·å–è§£é”çš„äº’æ–¥é‡ã€‚ // åŸå­æ“ä½œæ¯”è¾ƒ m.state çš„æ—§å€¼ä¸º 0 å¹¶äº¤æ¢æˆæ–°å€¼ 1ï¼ŒæˆåŠŸåˆ™è¡¨ç¤ºè·å–åˆ°é”ã€‚ // è¿™ç§æƒ…å†µå‘ç”Ÿåœ¨ state=0 æ—¶ï¼Œæ²¡æœ‰ç­‰å¾…çš„goroutineã€‚ if atomic.CompareAndSwapInt32(\u0026amp;m.state, 0, mutexLocked) { if race.Enabled { race.Acquire(unsafe.Pointer(m)) } return } // 2) m.state != 0 æ—¶éƒ½ä¼šèµ° Slow path // CAS æ“ä½œæ²¡èƒ½è·å¾—é”ï¼Œå°±éœ€è¦è¿›å…¥ Slow pathäº†ã€‚ // Slow path (outlined so that the fast path can be inlined) // // å¦‚æœä¸Šé¢å¿«é€Ÿæ–¹å¼æ‹¿å–ä¸åˆ°é”ï¼Œåˆ™å»å’Œå…¶ä»–ç«äº‰ã€‚ä¸Šé¢æƒ…å†µæ‹¿ä¸åˆ°é”ï¼Œå¯èƒ½ï¼š // 1. å­˜åœ¨æœ‰å…¶ä»–goroutineæ­£åœ¨æŒæœ‰é”ã€‚ // 2. ä¸å­˜åœ¨å…¶ä»–goroutineæŒæœ‰é”ï¼Œå­˜åœ¨è¢«å”¤é†’çš„goroutineæˆ–è¿˜æœ‰ç­‰å¾…çš„goroutineã€‚ // å½“å‰å¯èƒ½å¤„äºã€æ­£å¸¸æ¨¡å¼ã€‘æˆ–ã€é¥¥é¥¿æ¨¡å¼ã€‘ m.lockSlow() } lockSlow() å¦‚æœè°ƒç”¨è€…æ‹¿å–ä¸åˆ°é”ï¼Œåˆ™ä¸‹é¢æ“ä½œæµç¨‹æ˜¯å…ˆè‡ªæ—‹è¯•å›¾æ‹¿å»é”ï¼Œå®åœ¨æ‹¿å–ä¸åˆ°é”åˆ™è¿›å…¥ä¿¡å·æ± å»ç­‰å¾…æ‹¿å–é”ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 // ç«äº‰è·å–é” // 1. å…ˆè‡ªæ—‹ç­‰å¾…å…¶ä»–goroutineè§£é”ï¼ˆæ»¡è¶³è‡ªæ—‹æ¡ä»¶æ—¶ï¼‰ // 2. å°è¯•ä¿®æ”¹ state å€¼ç«äº‰é” // 3. ç«äº‰æˆåŠŸï¼Œè·å–é”é€€å‡º // 4. ç«äº‰å¤±è´¥ï¼Œsleep goroutine func (m *Mutex) lockSlow() { // 1. å½“å‰goroutineé¦–æ¬¡è¿›å…¥semaphoreæ± sleepçš„æ—¶é—´/çº³ç§’ï¼Œä¸‹æ¬¡wakeupåç”¨äºåˆ¤æ–­ æ­£å¸¸æ¨¡å¼ \u0026lt;-\u0026gt; é¥¥é¥¿æ¨¡å¼ è½¬æ¢ // 2. queueLifo := waitStartTime != 0; è¿›å…¥ semaphore æ± çš„é¦–æˆ–å°¾ï¼Œfalse.å°¾ true.é¦– var waitStartTime int64\t// mutexæ¨¡å¼ ã€false.æ­£å¸¸æ¨¡å¼ã€‘ ã€true.é¥¥é¥¿æ¨¡å¼ã€‘ // 1. æ­£å¸¸æ¨¡å¼ä¸‹ï¼Œæ–°æ¥è·å–é”çš„goroutineå¦‚æœæ»¡è¶³æ¡ä»¶ä¼šè¿›è¡Œè‡ªæ—‹ç­‰å¾…é”è¢«é‡Šæ”¾ï¼Œå¦‚æœè¿˜æ‹¿å–ä¸åˆ°é”åˆ™å»ä¿¡å·æ± æœ€å‰é¢ç­‰å¾…ã€‚ // 2. é¥¥é¥¿æ¨¡å¼ä¸‹ï¼Œæ–°æ¥è·å–é”çš„goroutineä¸ä¼šè¿›è¡Œè‡ªæ—‹ï¼Œç›´æ¥å»ä¿¡å·æ± çš„æœ«å°¾å»ç­‰å¾…ã€‚ starving := false\t// æ˜¯å¦æœ‰goroutineè¢«å”¤é†’ false.æ²¡æœ‰ // æœ‰è¢«å”¤é†’çš„goroutineæ—¶ï¼Œä¼šè¯•å›¾å»æ‹¿å»é”ï¼Œå¯èƒ½æ˜¯è·Ÿå½“å‰æ­£åœ¨è·å–é”çš„goroutineç«äº‰ // 1. åœ¨è‡ªæ—‹æƒ…å†µä¸‹æ»¡è¶³æ¡ä»¶è®¾ç½® awoke ä¸º true // 2. éé¥¥é¥¿æ¨¡å¼ä¸‹è¢«å”¤é†’çš„goroutine awoke ä¼šè¢«è®¾ç½®ä¸º true // 3. åœ¨é¥¥é¥¿æ¨¡å¼ä¸‹ awoke å˜é‡æ²¡æœ‰ç”¨ awoke := false\t// ç”¨äºåŸå­è®¾ç½® mutexWoken ä½ï¼Œé€šçŸ¥ Unlock å‡½æ•°æœ‰ woken çš„goroutineäº†ï¼Œä¸è¦å»wakeup goroutine // è®°å½•æ—‹è½¬çš„æ¬¡æ•°ï¼Œå½“æ²¡æœ‰è·å–é”æ—¶ï¼Œä¼šå°è¯•4æ¬¡å»è‡ªæ—‹è·å– iter := 0\t// è‡ªæ—‹è®¡æ•°å™¨\t// ä»¥ä¸‹ä»£ç éƒ½æ˜¯ä» old -\u0026gt; new çš„åŸå­æ“ä½œï¼Œå»å°è¯•ä¿®æ”¹ state å€¼ old := m.state\t// æ—§å€¼state // è¯¥å¾ªç¯åªæœ‰åœ¨è·å–åˆ°é”çš„æ—¶å€™æ‰ä¼šé€€å‡ºï¼Œå› æ­¤æ‰€æœ‰æœªè·å–åˆ°é”çš„goroutineéƒ½å°†åœ¨è¿™é‡Œç­‰å¾…è·å–é” for { // 1) é¥¥é¥¿æ¨¡å¼ä¸‹ä¸è¦è‡ªæ—‹ï¼Œå› ä¸ºæ‰€æœ‰æƒæŒ‰ç…§é¡ºåºä¼ é€’ï¼Œè‡ªæ—‹æ²¡æœ‰æ„ä¹‰ã€‚ // æ­£å¸¸æ¨¡å¼ä¸‹é”æ²¡æœ‰è¢«é‡Šæ”¾æ»¡è¶³è‡ªæ—‹æ¡ä»¶éœ€è¦è‡ªæ—‹ã€‚ // Don\u0026#39;t spin in starvation mode, ownership is handed off to waiters // so we won\u0026#39;t be able to acquire the mutex anyway. // // ä¸è¦åœ¨é¥¥é¥¿æ¨¡å¼ä¸‹æ—‹è½¬ï¼Œæ‰€æœ‰æƒå·²ç§»äº¤ç»™waitersï¼Œå› æ­¤æˆ‘ä»¬æ— è®ºå¦‚ä½•éƒ½æ— æ³•è·å¾—äº’æ–¥é” // 1. old\u0026amp;(mutexLocked|mutexStarving) == mutexLocked; Mutexæ²¡æœ‰å¤„äºé¥¥é¥¿æ¨¡å¼å¹¶ä¸”å·²è¢«é”å®šã€‚ // 2. runtime_canSpin(iter); æŠ¥å‘Šå½“å‰æ—‹è½¬è¦æ±‚æ¡ä»¶ã€‚ //\tä¸»åŠ¨æ—‹è½¬æ¡ä»¶ï¼š //\tæ—‹è½¬æ¬¡æ•°å°äº4æ¬¡ å¹¶ä¸” å¤šæ ¸CPUè¿è¡Œ å¹¶ä¸”é™¤äº†å½“å‰Pè¿˜æœ‰å…¶ä»–Pæ­£åœ¨è¿è¡Œï¼ˆä¸æ˜¯ç©ºé—²æˆ–è‡ªæ—‹çŠ¶æ€çš„Pï¼‰å¹¶ä¸” å½“å‰Pæ²¡æœ‰å…¶ä»–gäº† //\tè¿™ç§æƒ…å†µéœ€è¦å»å°è¯•è‡ªæ—‹è·å–ä¸‹é”ï¼Œå…¶ä»–æƒ…å†µåˆ™ä¸éœ€è¦è‡ªæ—‹å»è·å–é” // ä»¥ä¸‹è‡ªæ—‹çš„æ„ä¹‰ï¼Œåœç•™ç‰‡åˆ»ç­‰å¾…å…¶ä»–goroutineè®©å‡ºé”ï¼Œç„¶åæ ‡è®°mutexWokenå­˜åœ¨è¢«å”¤é†’çš„goroutineä½¿è‡ªå·±è·å–é”ä¼˜å…ˆçº§æ›´é«˜ if old\u0026amp;(mutexLocked|mutexStarving) == mutexLocked \u0026amp;\u0026amp; runtime_canSpin(iter) {\t// è‡ªæ—‹åœ¨è¿™é‡Œ // Active spinning makes sense. // Try to set mutexWoken flag to inform Unlock // to not wake other blocked goroutines. // // ä¸»åŠ¨æ—‹è½¬æ˜¯æœ‰é“ç†çš„ã€‚ // å°è¯•è®¾ç½® mutexflag æ¥é€šçŸ¥ Unlock ä¸è¦å”¤é†’å…¶ä»–è¢«é˜»å¡åœ¨ä¿¡å·æ± çš„goroutinesã€‚ // ä»¥ä¸‹é€»è¾‘æ˜¯å¤„äºè‡ªæ—‹ï¼Œè‡ªæ—‹çš„æ„ä¹‰åœ¨äºæ ‡è®°æœ‰æ­£åœ¨è¢«å”¤é†’çš„goroutineï¼Œå…¶ä»–çº¿ç¨‹ä¸è¦å†æ¬¡å”¤é†’å¯¼è‡´è¿‡å¤šgoroutineè¢«å”¤é†’ // // 1. !awoke; ï¼šæ²¡æœ‰æ ‡è®°å½“å‰goroutineè¢«å”¤é†’ // 2. old\u0026amp;mutexWoken == 0; ï¼šæ²¡æœ‰è¢«å”¤é†’çš„goroutineï¼ŒåŒ…æ‹¬å…¶ä»–gå’Œå½“å‰g // 3. old\u0026gt;\u0026gt;mutexWaiterShift != 0; ï¼šå­˜åœ¨ç­‰å¾…æ’é˜Ÿåœ¨ä¿¡å·æ± çš„goroutine // 4. atomic.CompareAndSwapInt32(\u0026amp;m.state, old, old|mutexWoken); //\tè®¾ç½®æ ‡å¿—æœ‰goroutineè¢«å”¤é†’ï¼Œè¿™é‡Œè®¾ç½®æˆåŠŸé‚£unlockåˆ™ä¸ä¼šå†å»å”¤é†’goroutine if !awoke \u0026amp;\u0026amp; old\u0026amp;mutexWoken == 0 \u0026amp;\u0026amp; old\u0026gt;\u0026gt;mutexWaiterShift != 0 \u0026amp;\u0026amp; atomic.CompareAndSwapInt32(\u0026amp;m.state, old, old|mutexWoken) { // æ ‡è®°ä¸ºå”¤é†’çŠ¶æ€ï¼Œä¸»è¦æ˜¯å‘Šè¯‰unlockä¸è¦å†å»å”¤é†’goroutineäº†ï¼Œè¿™é‡Œæœ‰è‡ªæ—‹çš„åœ¨ç­‰å¾… awoke = true } // çŸ­æš‚å»¶è¿Ÿä¸€æ®µæ—¶é—´ï¼Œä¸»è¦æ˜¯ç­‰å¾…å…¶ä»–gè§£é” // å¦‚æœæ­¤æ—¶Unlockäº†ç¬¬ä¸€ä¸ªifåˆ™ä¸ä¼šå†åˆ¤æ–­ä¸ºtrueï¼Œç›´æ¥å»äº‰æŠ¢é”äº† runtime_doSpin()\titer++ old = m.state\t// ä»æ–°èµ‹å€¼ç»™old continue } // 2) é”å¯èƒ½å·²è¢«é‡Šæ”¾å°è¯•ç«äº‰è·å–ï¼Œæˆ–é”è¿˜æœªè§£é™¤å»sleepã€‚ // ä»£ç æ‰§è¡Œåˆ°è¿™é‡Œï¼Œåªå¯èƒ½å¤„äºä»¥ä¸‹å‡ ç§æƒ…å†µ // 1. è‡ªæ—‹æ¬¡æ•°ä»¥å®Œï¼ŒçŠ¶æ€ä¾ç„¶æ˜¯ mutexLockedã€‚ // 2. çŠ¶æ€æ˜¯ mutexStarving å¤„äºé¥¥é¥¿çŠ¶æ€ã€‚ // 3. çŠ¶æ€æ˜¯æœªåŠ é”çŠ¶æ€ï¼Œé”å·²è¢«è§£é™¤ã€‚ // ï¼ˆå¤„äºé¥¥é¥¿æ¨¡å¼ï¼‰ æˆ– ï¼ˆè‡ªæ—‹æ¬¡æ•°è¶…è¿‡4æ¬¡ï¼‰ æˆ– ï¼ˆå½“å‰å…¶ä»–goroutineå·²Unlockï¼‰æˆ– ï¼ˆä¸æ»¡è¶³è‡ªæ—‹æ¡ä»¶ï¼‰ //\tå¦‚æœé”å·²Unlockï¼Œé‚£ä¹ˆå°è¯•å»è·å–é”ï¼›å¦‚æœé”å¤„äºLockï¼Œé‚£ä¹ˆä¹Ÿå°è¯•è·å–ï¼Œå¦åˆ™åŠ å…¥åˆ°ä¿¡å·æ± ä¸­ç­‰å¾… // old æ˜¯æœ¬è½®åŸå­æ“ä½œçš„ state å€¼ // new æ˜¯æœ¬è½®éœ€è¦äº‰æŠ¢é”ä¿®æ”¹åçš„ state å€¼ // æ­£å¸¸æ¨¡å¼ä¸‹: // 1. åœ¨oldæœªæŒæœ‰é”æƒ…å†µä¸‹ï¼Œè°å…ˆåŸå­æ“ä½œä» old ä¿®æ”¹ä¸º new è°å°±å…ˆè·å–åˆ°é” // 2. åœ¨oldæŒæœ‰é”æƒ…å†µä¸‹ï¼Œå½“å‰goroutineéœ€è¦sleep new := old // 2.1) æ­£å¸¸æ¨¡å¼ä¸‹éœ€è¦äº‰æŠ¢é”ï¼Œå› æ­¤éœ€è¦è®¾ç½®mutexLockedçŠ¶æ€ // Don\u0026#39;t try to acquire starving mutex, new arriving goroutines must queue. // // ä¸è¦å°è¯•è·å–å¤„äºé¥¥é¥¿çš„Mutexï¼Œåæ¥çš„goroutineså¿…é¡»æ’é˜Ÿã€‚ // // å¤„äºé¥¥é¥¿æ¨¡å¼ä¸‹ï¼Œä¸ºä»€ä¹ˆä¸éœ€è¦è®¾ç½®mutexLockedæ ‡å¿—å‘¢ï¼Ÿ // 1. å¤„äºé¥¥é¥¿æ¨¡å¼ä¸‹é”çš„æŒæœ‰æƒæ˜¯æ‰‹æŠŠæ‰‹äº¤ç»™åé¢ç­‰å¾…çš„goroutineï¼Œå› æ­¤mutexLockedæ ‡å¿—è®¾ç½®ä¸è®¾ç½®ä¸é‡è¦ // 2. å¯¹äºæ–°æ¥çš„goroutineï¼ŒmutexLockedä½å¯èƒ½ä¸º0æˆ–1ï¼Œä½†æ˜¯å½“å‰goroutineä¸ä¼šå»æŒ£æŠ¢é”ç›´æ¥sleepï¼Œå› æ­¤mutexLockedä½ä¸é‡è¦ // 3. å¯¹äºä»sleepä¸­wakeupçš„goroutineï¼Œä¸€å®šæ˜¯æ¥è‡ªUnlockå‡½æ•°è€Œæ¥è‡ªè¯¥å‡½æ•°mutexLockedä½ä¸€å®šæ˜¯0ï¼Œå·²è¢«è§£é” if old\u0026amp;mutexStarving == 0 {\t// å¤„äºæ­£å¸¸æ¨¡å¼ // newè¡¨ç¤ºæ–°å€¼ä¿®æ”¹çš„çŠ¶æ€ mutexLockedéœ€è¦é”ï¼Œä¸ç®¡å½“å‰æ˜¯Lockæˆ–Unlockå½“å‰éƒ½éœ€è¦è®¾ç½®mutexLockedè¡¨ç¤ºéœ€è¦å»äº‰æŠ¢é” new |= mutexLocked\t} // 2.2) é”è¿˜æœªè¢«é‡Šæ”¾ æˆ– å¤„äºé¥¥é¥¿æ¨¡å¼ä¸‹ è¿™ä¸¤ç§æƒ…å†µä¸‹éƒ½ä¼šå»sleepï¼Œå› æ­¤éœ€è¦åŠ ä¸€ã€‚ // å¦‚æœoldé”æ²¡é‡Šæ”¾ æˆ– å¤„äºé¥¥é¥¿çŠ¶æ€ï¼Œé‚£ä¹ˆå½“å‰çš„goroutineåˆ™æ˜¯éœ€è¦è¢«åŠ å…¥åˆ°ä¿¡å·æ± é‡Œé¢å»çš„ if old\u0026amp;(mutexLocked|mutexStarving) != 0 {\t// å¤„äºLockæˆ–åˆ™é¥¥é¥¿æ¨¡å¼å½“å‰géœ€è¦åŠ å…¥åˆ°ä¿¡å·æ±  new += 1 \u0026lt;\u0026lt; mutexWaiterShift\t// æ•°é‡å¢åŠ 1 } // 2.3) å½“å‰ goroutine å°† mutex åˆ‡æ¢è‡³é¥¥é¥¿æ¨¡å¼ // å¦‚æœ mutex å·²ç»å¤„äº unlocked çŠ¶æ€ï¼Œå°±ä¸è¦åˆ‡æ¢äº†ï¼Œ // å› ä¸º Unlock() å‡½æ•°è®¤ä¸ºå¤„äºé¥¥é¥¿æ¨¡å¼çš„ mutex ç­‰å¾…é˜Ÿåˆ—ä¸ä¸ºç©ºã€‚ // The current goroutine switches mutex to starvation mode. // But if the mutex is currently unlocked, don\u0026#39;t do the switch. // Unlock expects that starving mutex has waiters, which will not // be true in this case. // // å½“å‰çš„ goroutine å°†äº’æ–¥é”åˆ‡æ¢åˆ°é¥¥é¥¿æ¨¡å¼ï¼Œä½†å¦‚æœäº’æ–¥é”å½“å‰å·²è§£é”ï¼Œå°±ä¸è¦åˆ‡æ¢ã€‚ // UnlockæœŸæœ›å¤„äºé¥¥é¥¿çŠ¶æ€çš„äº’æ–¥é”æœ‰waitersï¼Œä½†åœ¨æœ¬ä¾‹ä¸­å¹¶éå¦‚æ­¤ã€‚ // // starving=true å‘ç”Ÿåœ¨ï¼šè¿™ä¸ªgoroutineè¢«åŠ å…¥åˆ°ä¿¡å·æ± åå†åº¦è¢«å”¤é†’å»äº‰æŠ¢é”æ—¶ï¼Œå‘ç°ç­‰å¾…æ—¶é—´å·²ç»è¶…è¿‡1msæ—¶ // old\u0026amp;mutexLocked != 0ï¼Œè¡¨ç¤ºè¿™ä¸ªè¢«å”¤é†’çš„goroutineå†æ¬¡äº‰æŠ¢é”æ—¶é”æ²¡è¢«å…¶ä»–gorutineé‡Šæ”¾ï¼Œè¿™æ¬¡å†äº‰æŠ¢å°†å¤±è´¥åˆ™ä¼šæ ‡è®°æˆé¥¥é¥¿æ¨¡å¼ if starving \u0026amp;\u0026amp; old\u0026amp;mutexLocked != 0 {\t// è¿™ç§æƒ…å†µä¸‹å½“å‰goroutineåŸºæœ¬æ‹¿å»ä¸åˆ°é” new |= mutexStarving // æ ‡è®°æˆé¥¥é¥¿æ¨¡å¼æ—¶ï¼Œé”ä¸€å®šè¢«å…¶ä»–æŒæœ‰ï¼›ä½†æ˜¯å”¤é†’çš„gå¤„äºé¥¥é¥¿æ¨¡å¼æ—¶ï¼Œé”ä¸€å®šæ˜¯UnlockçŠ¶æ€ } // 2.4) å½“å‰goroutineæ˜¯è¢«å”¤é†’çš„ï¼Œæ£€æŸ¥å¹¶æ¸…é™¤æ ‡å¿—ä½ // awoke=true è¡¨ç¤ºæ¥è‡ªè‡ªæ—‹æˆ–è¢«å”¤é†’çš„goroutineä¸¤ç§å½¢å¼ // 1. è‡ªæ—‹çŠ¶æ€ä¸‹ awoke=trueï¼Œstate ä¸­ mutexWoken ä½å·²è¢«è®¾ç½®ä¸º 1 // 2. è¢«å”¤é†’çš„goroutineä¸‹ awoke=true åœ¨æœ¬å‡½æ•°çš„å”¤é†’åè¢«è®¾ç½®ï¼Œè€Œ state ä¸­ mutexWoken ä½åœ¨Unlockå‡½æ•°ä¸­è¢«è®¾ç½® // å› æ­¤ awoke=true å°±ä¸€å®šå­˜åœ¨ state ä¸­ mutexWoken ä½ä¸º1ï¼Œnew\u0026amp;mutexWoken != 0æˆç«‹ if awoke {\t// awokeæœ‰ç­‰å¾…çš„goroutineè¢«å”¤é†’ // The goroutine has been woken from sleep, // so we need to reset the flag in either case. // // goroutine å·²ç»ä»ç¡çœ ä¸­å”¤é†’ï¼Œæ‰€ä»¥æˆ‘ä»¬éœ€è¦åœ¨ä»»ä½•ä¸€ç§æƒ…å†µä¸‹é‡ç½®æ ‡å¿— if new\u0026amp;mutexWoken == 0 {\t// ä¸è®ºæ¥è‡ªè‡ªæ—‹æˆ–è¢«å”¤é†’çš„goroutineè¿™é‡Œéƒ½ä¸èƒ½ä¸º0ï¼Œæ­£å¸¸çŠ¶å†µä¸‹ throw(\u0026#34;sync: inconsistent mutex state\u0026#34;) } new \u0026amp;^= mutexWoken // æ¸…é™¤è¢«å”¤é†’æ ‡å¿—ä½mutexWokenï¼Œå› ä¸ºä¸‹é¢å³å°†å»äº‰æŠ¢é”ï¼Œæˆ–è€…è½½å…¥å»ä¿¡å·æ± ç­‰å¾… } // å°è¯•ä½¿ç”¨åŸå­ä¿®æ”¹stateï¼Œæ‰€æœ‰çš„goroutineéƒ½ä¼šé€šè¿‡è¯¥æ¡ä»¶ï¼Œä½†æ˜¯ä¸€è½®åªèƒ½æˆåŠŸä¸€ä¸ª // è¿™é‡Œä¿®æ”¹m.stateæˆåŠŸäº†ï¼Œå¹¶ä¸ä»£è¡¨ä¸€å®šè·å–åˆ°äº†é”ï¼Œä¹Ÿæœ‰å¯èƒ½æ˜¯å½“å‰géœ€è¦åŠ å…¥åˆ°ä¿¡å·æ± ä¸­å» if atomic.CompareAndSwapInt32(\u0026amp;m.state, old, new) {\t// å¦‚æœä¸Šä¸€ä¸ªæ‹¿å»åˆ°é”çš„stateæ˜¯æ­£å¸¸æ¨¡å¼å¹¶æ²¡æœ‰é”ï¼Œåˆ™è¿™é‡Œç›´æ¥é€€å‡ºï¼Œè¿™é‡Œè¡¨ç¤ºå½“å‰goroutineè·å–åˆ°äº†é”ï¼Œæ­£å¸¸æ¨¡å¼éƒ½æ˜¯ä»è¿™é‡Œé€€å‡ºçš„ // æ­£å¸¸æ¨¡å¼ä¸‹è·å–åˆ°é”çš„æƒ…å†µï¼Œè¿™é‡Œä¸ä¼šå‡ºç°æ ‡è®°æˆé¥¥é¥¿æ¨¡å¼ä½†è¿™é‡Œåˆåˆ¤æ–­ä¸ºtrueé€€å‡ºäº†çš„æƒ…å†µï¼ŒåŸå› æ˜¯æ ‡è®°æˆé¥¥é¥¿æ¨¡å¼çš„å‰ç½®æ¡ä»¶æ˜¯å½“å‰oldæ˜¯Lock if old\u0026amp;(mutexLocked|mutexStarving) == 0 {\t// è°å…ˆæ‹¿åˆ°é”é€€å‡ºï¼Œæ¥åˆ°æ‰§è¡Œgoroutineåé¢ä»£ç  break // locked the mutex with CAS } // åé¢å¤„ç†é€»è¾‘æ˜¯ä¹‹å‰æœ‰é”ï¼Œè¿™ä¸ªgoroutineéœ€è¦å»æ’é˜Ÿæƒ…å†µï¼Œæˆ–å½“å‰æ¨¡å¼å¤„äºé¥¥é¥¿æ¨¡å¼ï¼Œç›´æ¥æŠŠè¯¥goroutineåŠ å…¥åˆ°å°¾éƒ¨ // If we were already waiting before, queue at the front of the queue. // // å¦‚æœæˆ‘ä»¬ä¹‹å‰å·²ç»åœ¨ç­‰å¾…ï¼Œè¯·åœ¨é˜Ÿåˆ—çš„å‰é¢æ’é˜Ÿ // waitStartTimeå¦‚æœä¸ç­‰äº0è¯´æ˜å…ˆå‰å…¥é˜Ÿè¿‡æœ‰è¢«å”¤é†’è¿‡ï¼Œæ­£å¸¸ç¬¬ä¸€æ¬¡å…¥é˜Ÿè¿™é‡Œæ˜¯false // è¢«å”¤é†’ä¹‹åæ²¡æœ‰æŠ¢åˆ°é”ï¼Œéœ€è¦æ’å…¥é˜Ÿåˆ—å¤´éƒ¨ï¼Œè€Œä¸æ˜¯å°¾éƒ¨ã€‚ queueLifo := waitStartTime != 0 // é¦–æ¬¡è¿›å…¥ä¿¡å·æ± å»ç­‰å¾…æ—¶ if waitStartTime == 0 {\t// è¿™é‡Œè¡¨ç¤ºè¿™ä¸ªgoroutineä»ä¿¡å·æ± ä¸­ç¬¬ä¸€æ¬¡è¢«å”¤é†’ä¾ç„¶æ²¡æœ‰è·å–åˆ°é”ï¼Œä»æ–°è®¾ç½®æ—¶é—´ waitStartTime = runtime_nanotime()\t// æ³¨æ„ï¼šé™¤ç¬¬ä¸€æ¬¡å…¥é˜Ÿååé¢æ¯æ¬¡ç¼“å­˜waitStartTimeæ—¶é—´éƒ½ä¸ä¼šè¢«åˆ·æ–° } // è¿™é‡Œå­˜åœ¨è¢«å”¤é†’ä½†æ˜¯è¿˜æ˜¯æ²¡æ‹¿åˆ°é”çš„æƒ…å†µä¼šå†æ¬¡è¢«å…¥é˜Ÿ // runtime_SemacquireMutexçš„queueLifoå‚æ•°ä¸ºtrueåˆ™æ˜¯æ’å…¥çš„ä¿¡å·æ± å¤´éƒ¨ï¼Œfalseæ’å…¥åˆ°å°¾éƒ¨ //\té¦–æ¬¡è¿›å…¥ä¿¡å·æ± ï¼Œåˆ™ç›´æ¥æ’åœ¨å°¾éƒ¨ //\tä»ä¿¡å·æ± ä¸­å‡ºæ¥åˆäº‰æŠ¢å¤±è´¥è¿›å…¥ä¿¡å·æ± æ’åœ¨å¤´éƒ¨ // å¦‚æˆ‘ä»¬å–å‡ºgorutineåˆ™æ˜¯ä»å¤´éƒ¨å¼€å§‹å¾€åå–ï¼Œè¿™ä¹Ÿå°±æ˜¯æˆ‘ä»¬è¯´çš„å…ˆè¿›å…ˆå‡º // å› ä¸ºç¬¬ä¸€æ¬¡åŠ å…¥ä¿¡å·æ± çš„éƒ½æ˜¯æ’å…¥åˆ°å°¾éƒ¨ï¼Œå½“å†è¢«å”¤é†’ä¾ç„¶æ²¡æœ‰è·å–åˆ°é”æ—¶ï¼Œåˆ™æ˜¯è¢«æ”¾å›åˆ°å¤´éƒ¨ // å½“å‰goroutineå»æ’é˜Ÿï¼Œè¿™é‡Œå½“å‰groutineè¢«è°ƒç¦»å·¥ä½œçº¿ç¨‹ç­‰å¾…æŠ¢åˆ°é”åç»§ç»­åé¢æ‰§è¡Œ runtime_SemacquireMutex(\u0026amp;m.sema, queueLifo, 1)\t// è¢«å”¤é†’çš„gï¼Œæ¥åˆ°ä»è¿™é‡Œæ‰§è¡Œå°è¯•å»è·å–é”ï¼›å¯èƒ½å½“å‰å¤„äºé¥¥é¥¿æ¨¡å¼æˆ–å¤„äºæ­£å¸¸æ¨¡å¼ï¼Œå”¤é†’gçš„ç›¸å…³ä»£ç ä½äºUnlockå‡½æ•° // å¦‚æœç­‰å¾…çš„æ—¶é—´å¤§äº1msåˆ™æ ‡è®°æˆé¥¥é¥¿æ¨¡å¼ï¼Œä»¥ä¸‹é€»è¾‘æ˜¯å½“å‰goroutineè¢«å”¤é†’åå†æ¬¡å°è¯•è·å–é” // ç­‰å¾…æ—¶é—´è¶…è¿‡äº†1msï¼Œç­‰å¾…æ—¶é—´å¤ªä¹…éœ€è¦è¢«æ ‡è®°ä¸ºé¥¥é¥¿çŠ¶æ€ starving = starving || runtime_nanotime()-waitStartTime \u0026gt; starvationThresholdNs old = m.state\t// è·å–å½“å‰çš„çŠ¶æ€ // å¦‚æœå¤„äºé¥¥é¥¿æ¨¡å¼ï¼Œå¤„äºé¥¥é¥¿æ¨¡å¼ä¸‹å”¤é†’çš„goroutineç«‹å³è·å–é”ï¼Œå› ä¸ºæ­£å¸¸æ¥æŠ¢çš„goroutineéƒ½ä¼šè¢«å…¥é˜Ÿï¼Œ // ç„¶åä¸€ä¸ªä¸ªæ¥è·å– // æ‰€æœ‰é¥¥é¥¿æ¨¡å¼ä¸‹è·å–é”çš„å‡ºå£éƒ½åœ¨è¿™é‡Œï¼Œè¯¥æ¡ä»¶æ»¡è¶³è¯´æ˜å½“å‰goroutineè·å–åˆ°é”æŒæœ‰æƒ if old\u0026amp;mutexStarving != 0 {\t// If this goroutine was woken and mutex is in starvation mode, // ownership was handed off to us but mutex is in somewhat // inconsistent state: mutexLocked is not set and we are still // accounted as waiter. Fix that. // // å½“å‰ä»£ç ä½ç½®çš„ goroutine è‚¯å®šæ˜¯è¢«å”¤é†’çš„ï¼Œè€Œä¸” Mutex å¤„äºé¥¥é¥¿æ¨¡å¼ // æ‰€æœ‰æƒè¢«ç›´æ¥äº¤ç»™å½“å‰ goroutine // ä½†æ˜¯è¿™ç§æƒ…å†µä¸‹ mutex çš„ state ä¼šä¸å®é™…æƒ…å†µä¸ä¸€è‡´ // mutexLocked æ ‡å¿—ä½æ²¡æœ‰è®¾ç½® // è€Œä¸”ç­‰å¾…è€…è®¡æ•°ä¸­ä¹Ÿæ²¡æœ‰å‡å»å½“å‰ goroutineã€‚éœ€è¦ä¿®å¤ state // æ³¨æ„é¥¥é¥¿æ¨¡å¼ä¸‹ä¼ é€’ mutex æ‰€æœ‰æƒä¸ä¼šè®¾ç½® mutexWoken æ ‡å¿—ï¼Œåªæœ‰æ­£å¸¸æ¨¡å¼ä¸‹å”¤é†’æ‰ä¼š // // é¥¥é¥¿æ¨¡å¼ä¸‹ old\u0026gt;\u0026gt;mutexWaiterShift != 0ï¼Œå½“å‰ä¸€å®šä¸èƒ½æ˜¯æœ€åä¸€ä¸ªï¼Œ // å› ä¸ºä¸‹é¢ old\u0026gt;\u0026gt;mutexWaiterShift == 1 ä¼šé€€å‡ºé¥¥é¥¿æ¨¡å¼ // old\u0026amp;(mutexLocked|mutexWoken) != 0 å› ä¸ºå¤„äºé¥¥é¥¿æ¨¡å¼ä¸‹ï¼Œæ‰€æœ‰çš„goroutineéƒ½ä¼šå»æ’é˜Ÿsleepï¼Œ // è¢«wakeupçš„goroutineä¸€å®šæ¥è‡ªUnlockå‡½æ•°ï¼Œ // æ­¤æ—¶mutexLockedä¸€å®šè§£é”ï¼ŒmutexWokenä¸€å®šæ˜¯è¢«æ¸…é™¤çš„ if old\u0026amp;(mutexLocked|mutexWoken) != 0 || old\u0026gt;\u0026gt;mutexWaiterShift == 0 { // é¥¥é¥¿æ¨¡å¼ä¸‹ï¼ŒmutexLockedå’ŒmutexWokenå¿…å®šä¸º0ï¼Œå‚çœ‹ä¸Šé¢ä»£ç ã€‚ throw(\u0026#34;sync: inconsistent mutex state\u0026#34;) } // +mutexLocked -1\u0026lt;\u0026lt;mutexWaiterShift delta := int32(mutexLocked - 1\u0026lt;\u0026lt;mutexWaiterShift)\t// å°†ç­‰å¾…çš„æ•°é‡å‡ä¸€ // ç­‰å¾…æ—¶é—´å°äº1ms æˆ– å½“å‰goroutineæ˜¯é˜Ÿåˆ—æœ€åä¸€ä¸ªï¼Œåˆ™æ ‡è®°é€€å‡ºé¥¥é¥¿æ¨¡å¼ if !starving || old\u0026gt;\u0026gt;mutexWaiterShift == 1 { // Exit starvation mode. // Critical to do it here and consider wait time. // Starvation mode is so inefficient, that two goroutines // can go lock-step infinitely once they switch mutex // to starvation mode. delta -= mutexStarving\t// é€€å‡ºé¥¥é¥¿æ¨¡å¼ } atomic.AddInt32(\u0026amp;m.state, delta) // ä¿®æ”¹stateï¼Œè¿”å›ç›´æ¥è¿”å›ï¼Œåº”ä¸ºè¯¥goroutine è·å–åˆ°é”äº† break\t// é¥¥é¥¿æ¨¡å¼ä»è¿™é‡Œé€€å‡ºï¼Œå› æ­¤é¥¥é¥¿æ¨¡å¼ä¸‹è¢«å”¤é†’çš„goroutineç›´æ¥ä»è¿™é‡Œé€€å‡º } // æ­£å¸¸æ¨¡å¼ä¸‹ï¼Œè®¾ç½®ä¸ºå”¤é†’å»äº‰æŠ¢é” awoke = true\t// stateçš„mutexWokenä½åœ¨Unlockå‡½æ•°ä¸­è¢«è®¾ç½® iter = 0\t// è‡ªæ—‹æ¬¡æ•°é‡ç½® } else { // ä»old-\u0026gt;new åŸå­è®¾ç½®ï¼Œå¦‚æœè®¾ç½®å¤±è´¥ä»æ–°å†æ¥ old = m.state } } if race.Enabled { race.Acquire(unsafe.Pointer(m)) } } sync_runtime_canSpin() sync.Mutex ä¸»åŠ¨æ—‹è½¬æ¡ä»¶ã€‚ ä¸ä¸»åŠ¨æ—‹è½¬æ¡ä»¶ï¼š ã€æ—‹è½¬æ¬¡æ•°å¤§äºç­‰äº4æ¬¡ã€‘æˆ–ã€å•æ ¸CPUåœ¨è¿è¡Œã€‘ æˆ–ã€é™¤äº†å½“å‰På…¶ä»–Péƒ½å¤„äºç©ºé—²æˆ–è‡ªæ—‹çŠ¶æ€ã€‘ï¼Œä¸éœ€è¦ä¸»åŠ¨å»æ—‹è½¬ç­‰å¾…è·å–é”ã€‚ å¦‚æœå½“å‰Pçš„runqä¸ä¸ºç©ºï¼Œä¹Ÿæ²¡å¿…è¦å»è‡ªæ—‹ï¼Œå› ä¸ºé‡Œé¢çš„gè¿˜ç­‰ç€å»æ‰§è¡Œï¼Œç›´æ¥æŠŠå½“å‰gæŒ‚èµ·ã€‚ ä¸»åŠ¨æ—‹è½¬æ¡ä»¶ï¼š ã€æ—‹è½¬æ¬¡æ•°å°äº4æ¬¡ã€‘å¹¶ä¸”ã€å¤šæ ¸CPUè¿è¡Œã€‘å¹¶ä¸”ã€é™¤äº†å½“å‰Pè¿˜æœ‰å…¶ä»–Pæ­£åœ¨è¿è¡Œã€‘ï¼ˆä¸æ˜¯ç©ºé—²æˆ–è‡ªæ—‹çŠ¶æ€çš„Pï¼‰å¹¶ä¸” ã€å½“å‰Pæ²¡æœ‰å…¶ä»–gäº†ã€‘ã€‚ è¿™ç§æƒ…å†µéœ€è¦å»å°è¯•è‡ªæ—‹è·å–ä¸‹é”ï¼Œå…¶ä»–æƒ…å†µåˆ™ä¸éœ€è¦è‡ªæ—‹å»è·å–é”ã€‚ runtime/proc.goæ–‡ä»¶ä¸­ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 // Active spinning for sync.Mutex. //go:linkname sync_runtime_canSpin sync.runtime_canSpin //go:nosplit func sync_runtime_canSpin(i int) bool { // sync.Mutex is cooperative, so we are conservative with spinning. // Spin only few times and only if running on a multicore machine and // GOMAXPROCS\u0026gt;1 and there is at least one other running P and local runq is empty. // As opposed to runtime mutex we don\u0026#39;t do passive spinning here, // because there can be work on global runq or on other Ps. // // sync.Mutexæ˜¯åˆä½œæ€§çš„ï¼Œæ‰€ä»¥æˆ‘ä»¬å¯¹spinningæ˜¯ä¿å®ˆçš„ã€‚ // åªæ—‹è½¬å‡ æ¬¡ï¼Œä¸”ä»…å½“è¿è¡Œåœ¨å¤šæ ¸è®¡ç®—æœºå’ŒGOMAXPROCS\u0026gt;1ä¸Šï¼Œå¹¶ä¸”è‡³å°‘æœ‰ä¸€ä¸ªå…¶ä»–è¿è¡ŒPä¸”æœ¬åœ°runqä¸ºç©ºæ—¶ã€‚ // ä¸è¿è¡Œæ—¶äº’æ–¥é”ç›¸åï¼Œæˆ‘ä»¬åœ¨è¿™é‡Œä¸åšè¢«åŠ¨æ—‹è½¬ï¼Œå› ä¸ºå¯ä»¥åœ¨å…¨å±€runqæˆ–å…¶ä»–Pä¸Šè¿›è¡Œå·¥ä½œã€‚ // // ä»¥ä¸‹æ¡ä»¶æ»¡è¶³ä¸€é¡¹éƒ½ä¸ä¼šå†æ¬¡è‡ªæ—‹å»è·å–é” // 1. const active_spin = 4; æœ€å¤šå°è¯•4æ¬¡è‡ªæ—‹è·å– // 2. var ncpu int32 \u0026lt;= 1; å¦‚æœæ˜¯å•æ ¸CPU // 3. gomaxprocs \u0026lt;= int32(sched.npidle+sched.nmspinning)+1; // 3.1 gomaxprocsï¼šè¡¨ç¤ºæ€»çš„P // 3.2 sched.npidleç©ºé—²çš„Pæ•°é‡ // 3.3 sched.nmspinningæ­£åœ¨è‡ªæ—‹çš„Mæ•°é‡(è¿™é‡Œé¢å¯èƒ½å­˜åœ¨æ­£åœ¨äº‰æŠ¢é”ï¼Œå¤„åœ¨è‡ªæ—‹éƒ½æ˜¯åªæœ‰ä¸€ä¸ªgçš„æƒ…å†µ) // é™¤äº†å½“å‰På…¶ä»–çš„Péƒ½å¾ˆé—²ï¼Œä¹Ÿä¸å¿…è¦è‡ªæ—‹äº†ã€‚ if i \u0026gt;= active_spin || ncpu \u0026lt;= 1 || gomaxprocs \u0026lt;= int32(sched.npidle+sched.nmspinning)+1 { return false } // è¿™é‡Œä¸åƒ runtime.mutex é‚£æ ·è¿›è¡Œæ¶ˆæè‡ªæ—‹ï¼Œå› ä¸ºå…¨å±€ runq æˆ–å…¶ä»– P ä¸Šæˆ–è®¸è¿˜æœ‰å¯è¿è¡Œçš„ä»»åŠ¡ã€‚ // å½“å‰æœ¬åœ°Pä¸ä¸ºç©ºï¼Œä¹Ÿä¸éœ€è¦è‡ªæ—‹å†å‡ºå»å°è¯•è·å–é”ï¼Œå…¶ä»–goroutineè¿˜ç­‰èµ·çš„ã€‚ if p := getg().m.p.ptr(); !runqempty(p) { return false } return true } sync_runtime_doSpin() çŸ­æš‚çš„å»¶è¿Ÿã€‚ runtime/proc.go æ–‡ä»¶ä¸­ã€‚ 1 2 3 4 5 6 //go:linkname sync_runtime_doSpin sync.runtime_doSpin //go:nosplit func sync_runtime_doSpin() { // å¾ªç¯30æ¬¡ç­‰å¾… procyield(active_spin_cnt)\t// active_spin_cnt=30 } procyield() çŸ­æš‚çš„å»¶è¿Ÿã€‚ 1 2 3 4 5 6 7 8 # runtime/asm_amd.64.s TEXT runtimeÂ·procyield(SB),NOSPLIT,$0-0 MOVL\tcycles+0(FP), AX\t# AX=30 å‚æ•° again: PAUSE # è‡ªæ—‹é™ä½CPUå‘çƒ­å’Œæ€§èƒ½ä¼˜åŒ–ã€‚ SUBL\t$1, AX\t# AX -= 1 JNZ\tagain RET Unlock() Unlockè§£é”mã€‚ å¦‚æœmåœ¨è¿›å…¥è§£é”æ—¶æ²¡æœ‰è¢«é”å®šï¼Œåˆ™æ˜¯ä¸€ä¸ªè¿è¡Œæ—¶é”™è¯¯ã€‚ ä¸€ä¸ªé”å®šçš„äº’æ–¥é‡ä¸ä¸€ä¸ªç‰¹å®šçš„goroutineæ— å…³ã€‚ å…è®¸ä¸€ä¸ªgoroutineé”å®šä¸€ä¸ªäº’æ–¥é‡ï¼Œç„¶åå®‰æ’å¦ä¸€ä¸ªgoroutineè§£é”å®ƒã€‚ è¯¥æ–¹æ³•ä¸»è¦é€šè¿‡ atomic å‡½æ•°å®ç°äº† Fast pathï¼Œç›¸åº”çš„ Slow pathè¢«å•ç‹¬æ”¾åœ¨äº† unlockSlow() æ–¹æ³•ä¸­ã€‚ æ ¹æ®æºç æ³¨é‡Šçš„è¯´æ³•ï¼Œè¿™æ ·æ˜¯ä¸ºäº†ä¾¿äºç¼–è¯‘å™¨å¯¹ Fast path è¿›è¡Œå†…è”ä¼˜åŒ–ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 // Unlock unlocks m. // It is a run-time error if m is not locked on entry to Unlock. // // A locked Mutex is not associated with a particular goroutine. // It is allowed for one goroutine to lock a Mutex and then // arrange for another goroutine to unlock it. func (m *Mutex) Unlock() { if race.Enabled { _ = m.state race.Release(unsafe.Pointer(m)) } // 1) é€šè¿‡åŸå­æ“ä½œä» state ä¸­å‡å» mutexLockedï¼Œä¹Ÿå°±æ˜¯é‡Šæ”¾é” // ç„¶åæ ¹æ® state çš„æ–°å€¼(new)æ¥åˆ¤æ–­æ˜¯å¦éœ€è¦æ‰§è¡Œ Slow pathã€‚ // Fast path: drop lock bit. // // Fast path: ç›´æ¥æŠŠé”æ ‡å¿—ä½æ”¾å¼€ // å¦‚æœä¹‹å‰mutexLockedä½ä¸º1åˆ™ä¿®æ”¹ä¸º0ï¼›å¦‚æœä¹‹å‰mutexLockedä½ä¸º0åˆ™ä¿®æ”¹ä¸º1ï¼› new := atomic.AddInt32(\u0026amp;m.state, -mutexLocked)\t// å¦‚æœåˆ é™¤äº†é”çš„bitä½ï¼Œstateç­‰äº0è¯´æ˜æ²¡æœ‰ç­‰å¾…æŠ¢é”çš„goroutineç›´æ¥è¿”å› // newä¸º0ï¼Œæ„å‘³ç€æ²¡æœ‰å…¶ä»– goroutine åœ¨æ’é˜Ÿï¼Œæ‰€ä»¥ä¸éœ€è¦æ‰§è¡Œé¢å¤–æ“ä½œã€‚ // newä¸ä¸º0ï¼Œåˆ™å¯èƒ½éœ€è¦å”¤é†’æŸä¸ª goroutineã€‚ // Unlock æ‰§è¡Œå®Œåmutex.state!=0 åˆ™å­˜åœ¨ä»¥ä¸‹å¯èƒ½ // æ­£å¸¸æ¨¡å¼ä¸‹ // 1. å½“å‰å­˜åœ¨ç­‰å¾…çš„goroutineå»å”¤é†’å®ƒ //\t2. å½“å‰å­˜åœ¨è‡ªæ—‹ç­‰å¾…çš„goroutineï¼Œåˆ™ä¸å”¤é†’å…¶ä»–ç­‰å¾…çš„goroutine // é¥¥é¥¿æ¨¡å¼ä¸‹ // 1. ç›´æ¥å°†é”äº¤ç»™ç­‰å¾…é˜Ÿåˆ—çš„ç¬¬ä¸€ä¸ªgoroutine if new != 0 {\t// è¿˜å­˜åœ¨å…¶ä»–ç­‰å¾…é˜Ÿåˆ—ä¸­çš„goroutine // Outlined slow path to allow inlining the fast path. // To hide unlockSlow during tracing we skip one extra frame when tracing GoUnblock. // // æ¦‚è¿°äº†æ…¢é€Ÿè·¯å¾„ä»¥å…è®¸å†…è”å¿«é€Ÿè·¯å¾„ // ä¸ºäº†åœ¨è·Ÿè¸ªè¿‡ç¨‹ä¸­éšè— unlockSlowï¼Œæˆ‘ä»¬åœ¨è·Ÿè¸ª GoUnblock æ—¶ä¼šè·³è¿‡ä¸€ä¸ªé¢å¤–çš„å¸§ m.unlockSlow(new) } } unlockSlow() 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 func (m *Mutex) unlockSlow(new int32) { // åˆ¤æ–­æœªåŠ é”çš„æƒ…å†µä¸‹ä¸èƒ½å¤šæ¬¡è°ƒç”¨unlock // æ­£å¸¸é€»è¾‘è¿™é‡Œ new+mutexLocked åº”è¯¥ä¸º1 if (new+mutexLocked)\u0026amp;mutexLocked == 0 {\t// è¿™ç§æƒ…å†µåˆ¤æ–­ä¹‹å‰æ ¹æœ¬å°±æ²¡åŠ è¿‡é”ï¼Œåˆ™å»è§£é”è¿™ä¼šç›´æ¥æŠ¥é”™è¯¯ throw(\u0026#34;sync: unlock of unlocked mutex\u0026#34;) } // æ­£å¸¸æ¨¡å¼ä¸‹ if new\u0026amp;mutexStarving == 0 { // ä» old -\u0026gt; new åŸå­æ“ä½œï¼Œä¸»è¦æ˜¯å”¤é†’goroutine old := new for {\t// ä»¥ä¸‹ä»£ç æ˜¯é€šè¿‡å”¤é†’goroutineå’Œå…¶ä»–æ­£åœ¨è¿è¡Œçš„goroutineå»äº‰æŠ¢é” // If there are no waiters or a goroutine has already // been woken or grabbed the lock, no need to wake anyone. // In starvation mode ownership is directly handed off from unlocking // goroutine to the next waiter. We are not part of this chain, // since we did not observe mutexStarving when we unlocked the mutex above. // So get off the way. // // å¦‚æœæ²¡æœ‰waitersï¼Œæˆ–goroutineå·²ç»è¢«å«é†’æˆ–æŠ¢äº†é”ï¼Œæ²¡æœ‰å¿…è¦å«é†’ä»»ä½•äººã€‚ // åœ¨é¥¥é¥¿æ¨¡å¼ä¸‹ï¼Œæ‰€æœ‰æƒä¼šä»è§£é”goroutineç›´æ¥ç§»äº¤ç»™ä¸‹ä¸€ä¸ªwaiterã€‚ // æˆ‘ä»¬ä¸æ˜¯è¿™ä¸ªé“¾çš„ä¸€éƒ¨åˆ†ï¼Œå› ä¸ºæˆ‘ä»¬åœ¨ä¸Šé¢è§£é”äº’æ–¥é”æ—¶æ²¡æœ‰è§‚å¯Ÿåˆ°mutexStarvingã€‚æ‰€ä»¥åˆ«æŒ¡é“ã€‚ // // æ²¡æœ‰ç­‰å¾…çš„goroutine æˆ– (æœ‰å…¶ä»–çš„goroutineå·²è¿‘è·å¾—é” æˆ– æœ‰è¢«å”¤é†’çš„goroutine æˆ– å½“å‰å¤„äºé¥¥é¥¿æ¨¡å¼ä¸‹) if old\u0026gt;\u0026gt;mutexWaiterShift == 0 || old\u0026amp;(mutexLocked|mutexWoken|mutexStarving) != 0 { return\t// ç›´æ¥è¿”å›ï¼Œä¸éœ€è¦å†å»åç»­å¤„ç† } // Grab the right to wake someone. // // ç­‰åœ¨è¢«å”¤é†’çš„goroutineæ•°é‡å‡ä¸€ï¼Œè®¾ç½®æœ‰è¢«å”¤é†’æ ‡å¿— new = (old - 1\u0026lt;\u0026lt;mutexWaiterShift) | mutexWoken\t// è®¾ç½®éœ€è¦å”¤é†’ä¸€ä¸ªgoroutineçš„æ–°çŠ¶æ€ if atomic.CompareAndSwapInt32(\u0026amp;m.state, old, new) {\t// åŸå­è®¾ç½®æˆåŠŸï¼Œè¯´æ˜æ²¡æœ‰å…¶ä»–æ­£åœ¨äº‰æŠ¢æˆ–å½“å‰äº‰æŠ¢æˆåŠŸ runtime_Semrelease(\u0026amp;m.sema, false, 1)\t// å–å‡ºç­‰å¾…çš„goroutineæ”¾å…¥æœ¬åœ°Pç­‰å¾…è¢«è°ƒåº¦ï¼Œé¥­åè¿”å› return } old = m.state\t// æ²¡æœ‰è·å–æˆåŠŸï¼Œåˆ™ç›´æ¥æ›¿æ¢æ—§stateï¼Œå†æ¬¡å°è¯• } } else {\t// é¥¥é¥¿æ¨¡å¼ä¸‹ // Starving mode: handoff mutex ownership to the next waiter, and yield // our time slice so that the next waiter can start to run immediately. // Note: mutexLocked is not set, the waiter will set it after wakeup. // But mutex is still considered locked if mutexStarving is set, // so new coming goroutines won\u0026#39;t acquire it. // // é¥¥é¥¿æ¨¡å¼ï¼šå°†mutexæ‰€æœ‰æƒç§»äº¤ç»™ä¸‹ä¸€ä¸ªwaiterï¼Œå¹¶è®©å‡ºæˆ‘ä»¬çš„æ—¶é—´ç‰‡ï¼Œä»¥ä¾¿ä¸‹ä¸€ä¸ªwaiterå¯ä»¥ç«‹å³å¼€å§‹è¿è¡Œ // æ³¨æ„ï¼šmutexLocked æ²¡æœ‰è®¾ç½®ï¼Œwaiterä¼šåœ¨å”¤é†’åè®¾ç½® // ä½†æ˜¯å¦‚æœè®¾ç½®äº† mutexStarvingï¼Œmutex ä»ç„¶è¢«è®¤ä¸ºæ˜¯é”å®šçš„ï¼Œæ‰€ä»¥æ–°çš„ goroutines ä¸ä¼šè·å–å®ƒ // å¤„äºé¥¥é¥¿æ¨¡å¼ä¸‹ä»è¿™é‡Œå”¤é†’çš„goroutineï¼Œstateä¸­mutexLockedä½ï¼Œä¸€å®šä¸º0 runtime_Semrelease(\u0026amp;m.sema, true, 1)\t// é¥¥é¥¿æ¨¡å¼ä¸‹åªä»é¦–éƒ¨å–å‡ºgoroutineç­‰å¾…è¢«è°ƒåº¦å³å¯ // è¿™é‡Œåœ¨é¥¥é¥¿æ¨¡å¼ä¸‹ä¸ºç”šä¸åˆ¤æ–­ç­‰å¾…çš„goroutineæ•°é‡ï¼Ÿ // åŸå› æ˜¯ï¼šå¤„äºé¥¥é¥¿æ¨¡å¼ä¸‹ç­‰å¾…çš„goroutineæ•°é‡ä¸€å®šæ˜¯\u0026gt;=1çš„ã€‚ // å› ä¸ºæœ€åä¸€ä¸ªgoroutineä¼šæŠŠæ¨¡å¼åˆ‡æ¢æˆæ­£å¸¸æ¨¡å¼ï¼Œç›¸å…³ä»£ç ä½äºLockå‡½æ•° } } TryLock() TryLockè¯•å›¾é”å®šmå¹¶æŠ¥å‘Šæ˜¯å¦æˆåŠŸã€‚ è¯·æ³¨æ„ï¼Œè™½ç„¶ç¡®å®å­˜åœ¨æ­£ç¡®ä½¿ç”¨TryLockçš„æƒ…å†µï¼Œä½†å¾ˆå°‘ï¼Œè€Œä¸”TryLockçš„ä½¿ç”¨é€šå¸¸è¡¨æ˜äº’æ–¥é‡çš„ç‰¹å®šä½¿ç”¨ä¸­å­˜åœ¨æ›´æ·±å±‚çš„é—®é¢˜ã€‚ TryLock å¯ä»¥ç”¨äºåœ¨ä¸šåŠ¡æ¯”è¾ƒç¹å¿™æ—¶å»å°è¯•è·å–é”ï¼Œå¤±è´¥åˆ™æç¤ºç›¸å…³æ–‡æ¡ˆç­‰ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 // TryLock tries to lock m and reports whether it succeeded. // // Note that while correct uses of TryLock do exist, they are rare, // and use of TryLock is often a sign of a deeper problem // in a particular use of mutexes. func (m *Mutex) TryLock() bool { old := m.state // å½“å‰é”å­˜åœ¨ æˆ– å½“å‰å¤„äºé¥¥é¥¿æ¨¡å¼ if old\u0026amp;(mutexLocked|mutexStarving) != 0 { return false\t// è·å–å¤±è´¥ } // There may be a goroutine waiting for the mutex, but we are // running now and can try to grab the mutex before that // goroutine wakes up. // // å¯èƒ½æœ‰ä¸€ä¸ªgoroutineåœ¨ç­‰å¾…äº’æ–¥é‡ï¼Œä½†æˆ‘ä»¬ç°åœ¨æ­£åœ¨è¿è¡Œï¼Œå¹¶ä¸”å¯ä»¥å°è¯•åœ¨goroutineå”¤é†’ä¹‹å‰è·å–äº’æ–¥é‡ã€‚ // // å°è¯•å»äº‰æŠ¢é”ï¼Œè¿™é‡Œçš„oldä¸€å®šæ˜¯æ²¡åŠ é”å¹¶å¤„äºæ­£å¸¸æ¨¡å¼ä¸‹å»å°è¯•äº‰æŠ¢ if !atomic.CompareAndSwapInt32(\u0026amp;m.state, old, old|mutexLocked) { return false\t// äº‰æŠ¢å¤±è´¥æƒ…å†µ } if race.Enabled { race.Acquire(unsafe.Pointer(m)) } return true\t// äº‰æŠ¢æˆåŠŸ } type Locker interface Lockeræ¥å£ä»£è¡¨ä¸€ä¸ªå¯ä»¥åŠ é”å’Œè§£é”çš„å¯¹è±¡ 1 2 3 4 5 // A Locker represents an object that can be locked and unlocked. type Locker interface { Lock() Unlock() } ä½¿ç”¨ç¤ºä¾‹ sync.Mutex äº’æ–¥é”ï¼šæ˜¯ä¼ ç»Ÿçš„å¹¶å‘ç¨‹åºå¯¹å…±äº«èµ„æºè¿›è¡Œè®¿é—®æ§åˆ¶çš„ä¸»è¦æ‰‹æ®µï¼ŒGoè¯­è¨€ä¸­æ¨èä½¿ç”¨é€šé“(channel)æ¥å®ç°èµ„æºå…±äº«å’Œé€šä¿¡ äº’æ–¥é”ï¼šç”±æ ‡å‡†åº“ sync åŒ…ä¸­åˆ†çš„ Mutex ç»“æ„ä½“ç±»å‹å®ç° åªæœ‰ä¸¤ä¸ªå…¬å¼€æ–¹æ³•ï¼š Lock() ï¼šè·å¾—é” Unlock() ï¼šé‡Šæ”¾é” åŒä¸€ä¸ªåç¨‹ä¸­åŒæ­¥è°ƒç”¨ä½¿ç”¨Lock()åŠ é”åï¼Œä¸èƒ½å†å¯¹å…¶åŠ é”ï¼Œå¦åˆ™ä¼šå¼•å‘è¿è¡Œæ—¶å¼‚å¸¸ï¼Œåªèƒ½åœ¨ Unlock() ä¹‹åå†æ¬¡ Lock() å¤šä¸ªåç¨‹ä¸­å¼‚æ­¥è°ƒç”¨Lock()æ²¡æœ‰é—®é¢˜ï¼Œä½†æ¯ä¸ªåç¨‹åªèƒ½è°ƒç”¨ä¸€æ¬¡Lock()ï¼Œç”±äºå¤šä¸ªåç¨‹ä¹‹é—´äº§ç”Ÿäº†é”ç«äº‰ï¼Œå› æ­¤ä¸ä¼šæœ‰è¿è¡Œæ—¶å¼‚å¸¸ äº’æ–¥é”ï¼šé€‚ç”¨äºåªå…è®¸æœ‰ä¸€ä¸ªè¯»æˆ–è€…å†™çš„åœºæ™¯ï¼Œæ‰€ä»¥è¯¥é”ä¹Ÿå«å…¨å±€é” å¦‚æœåœ¨ä½¿ç”¨ Unlock() å‰æœªåŠ é”ï¼Œå°±ä¼šå¼•èµ·ä¸€ä¸ªè¿è¡Œé”™è¯¯ï¼Œå·²ç»é”å®šçš„ Mutex å¹¶ä¸ä¸ç‰¹å®šçš„åç¨‹ç›¸å…³ï¼Œè¿™æ ·å¯ä»¥åˆ©ç”¨ä¸€ä¸ªåç¨‹å¯¹å…¶åŠ é”ï¼Œåœ¨åˆ©ç”¨å…¶å®ƒåç¨‹å¯¹å…¶è§£é” 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 // LockA() ä¸­æœ‰ Lock() // LockB() ä¸­ä¹Ÿæœ‰ Lock() // LockB() çš„ Lock() è¿è¡Œæ—¶ï¼Œé”è¿˜æ²¡æœ‰ Unlock()ï¼Œç¨‹åºå‘ç”Ÿ panic // è¿™æ˜¯åœ¨åŒæ­¥è°ƒç”¨äº’æ–¥é”ä¸­å¸¸è§çš„é—®é¢˜ï¼Œä¸€èˆ¬åœ¨ä¸€å¯¹äº’æ–¥é”ä¸­é—´ä¸è¦è°ƒç”¨å…¶å®ƒå‡½æ•°ï¼Œå³ä½¿è¦ç”¨ä¹Ÿå°½é‡é‡‡ç”¨å¼‚æ­¥æ–¹å¼ package main import ( \u0026#34;fmt\u0026#34; \u0026#34;sync\u0026#34; \u0026#34;time\u0026#34; ) var mutex sync.Mutex func main() { LockA() time.Sleep(10) } func LockA() { mutex.Lock()\t// åŠ é” fmt.Println(\u0026#34;Lock in A\u0026#34;) LockB() time.Sleep(5) fmt.Println(\u0026#34;Wake up in A\u0026#34;) mutex.Unlock()\t// è§£é” fmt.Println(\u0026#34;Unlock in A\u0026#34;) } func LockB() { fmt.Println(\u0026#34;B\u0026#34;) mutex.Lock()\t// åŠ é”\tmain goroutineåœ¨è¿™é‡Œè¢«é˜»å¡ï¼Œå¯¼è‡´deadlock fmt.Println(\u0026#34;Lock in B\u0026#34;) mutex.Unlock()\t// è§£é” fmt.Println(\u0026#34;Unlock in B\u0026#34;) } /* Lock in A B fatal error: all goroutines are asleep - deadlock! goroutine 1 [semacquire]: sync.runtime_SemacquireMutex(0x593b24, 0x0, 0x1) D:/True-False/Go/src/runtime/sema.go:71 +0x4e sync.(*Mutex).lockSlow(0x593b20) D:/True-False/Go/src/sync/mutex.go:138 +0x103 sync.(*Mutex).Lock(...) D:/True-False/Go/src/sync/mutex.go:81 main.LockB() D:/True-False/WWW/GoLang/src/xuexi/mutex.go:28 +0x194 main.LockA() D:/True-False/WWW/GoLang/src/xuexi/mutex.go:19 +0xa2 main.main() D:/True-False/WWW/GoLang/src/xuexi/mutex.go:12 +0x29 exit status 2 */ æŠŠä¸Šé¢åŒæ­¥æ”¹ä¸ºå¼‚æ­¥ï¼ŒæŠŠLockA()çš„LockB()æ”¹ä¸ºgo LockB() 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;sync\u0026#34; \u0026#34;time\u0026#34; ) var mutex sync.Mutex func main() { LockA() time.Sleep(10) } func LockA() { mutex.Lock()\t// åŠ é” fmt.Println(\u0026#34;Lock in A\u0026#34;) go LockB() time.Sleep(5) fmt.Println(\u0026#34;Wake up in A\u0026#34;) mutex.Unlock()\t// è§£é” fmt.Println(\u0026#34;Unlock in A\u0026#34;) } func LockB() { fmt.Println(\u0026#34;B\u0026#34;) mutex.Lock()\t// åŠ é”\tlockB goroutineç­‰å¾…LockAè§£é”ï¼Œå…ˆè‡ªæ—‹å†æ˜¯è¢«æŒ‚èµ· fmt.Println(\u0026#34;Lock in B\u0026#34;) mutex.Unlock()\t// è§£é” fmt.Println(\u0026#34;Unlock in B\u0026#34;) } /* Lock in A B Wake up in A Unlock in A Lock in B Unlock in B */ å»ºè®®ï¼šåŒä¸€ä¸ªäº’æ–¥é”çš„æˆå¯¹é”å®šå’Œè§£é”æ“ä½œå¯ä»¥æ”¾åœ¨åŒä¸€å±‚æ¬¡çš„ä»£ç å—ä¸­ ç»å…¸ç”¨æ³•å¦‚ä¸‹ï¼š 1 2 3 4 5 6 7 8 var lck sync.Mutex func foo() { lck.Lock()\t// åŠ é” defer lck.Unlock()\t// è§£é” // ... ... } // lck.Lock() ä¼šé˜»å¡ç›´åˆ°è·å–é”ï¼Œç„¶ååˆ©ç”¨deferè¯­å¥åœ¨å‡½æ•°è¿”å›æ—¶è‡ªåŠ¨é‡Šæ”¾é” ç¤ºä¾‹ä»£ç ï¼Œé€šè¿‡ä¸‰ä¸ªåç¨‹æ¥ä½“ç°sync.Mutexå¯¹èµ„æºçš„è®¿é—®æ§åˆ¶ç‰¹å¾ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;sync\u0026#34; \u0026#34;time\u0026#34; ) func main() { //var wg sync.WaitGroup wg := sync.WaitGroup{} var mutex sync.Mutex fmt.Println(\u0026#34;Locking (G0)\u0026#34;) mutex.Lock()\t// åŠ é” fmt.Println(\u0026#34;locked (G0)\u0026#34;) wg.Add(3) for i := 1; i \u0026lt; 4; i++ { go func(i int) { fmt.Printf(\u0026#34;Locking (G%d)\\n\u0026#34;, i) mutex.Lock()\t// åŠ é” fmt.Printf(\u0026#34;Locked (G%d)\\n\u0026#34;, i) time.Sleep(time.Second * 2)\t// å»¶è¿Ÿ2s mutex.Unlock()\t// è§£é” fmt.Printf(\u0026#34;unlocked (G%d)\\n\u0026#34;, i) wg.Done() }(i) } time.Sleep(time.Second * 5) fmt.Println(\u0026#34;ready unlock (G0)\u0026#34;) mutex.Unlock()\t// è§£é” fmt.Printf(\u0026#34;unlocked (G0)\u0026#34;) wg.Wait() } // ç¨‹åºè¿è¡Œç»“æœå¯ä»¥çœ‹å‡ºï¼Œå½“æœ‰é”é‡Šæ”¾æ—¶ï¼Œæ‰èƒ½è¿›è¡ŒåŠ é”åŠ¨ä½œ // è¿è¡Œç»“æœå¦‚ä¸‹ Locking (G0) locked (G0) Locking (G1) Locking (G2) Locking (G3) ready unlock (G0) unlocked (G0)Locked (G1) unlocked (G1) Locked (G2) unlocked (G2) Locked (G3) unlocked (G3) Mutex ä¹Ÿå¯ä»¥ä½œä¸ºç»“æ„ä½“çš„ä¸€éƒ¨åˆ†ï¼Œè¿™æ ·ç»“æ„ä½“åœ¨è¢«å¤šçº¿ç¨‹å¤„ç†æ—¶æ•°æ®å®‰å…¨æ‰æœ‰ä¿éšœ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;sync\u0026#34; \u0026#34;time\u0026#34; ) type Book struct { BookName string L *sync.Mutex } func (bk *Book) SetName(wg *sync.WaitGroup, name string) { defer func() { fmt.Println(\u0026#34;Unlock set name:\u0026#34;, name) bk.L.Unlock()\t// è§£é” wg.Done() }() bk.L.Lock()\t// åŠ é” fmt.Println(\u0026#34;Lock set name:\u0026#34;, name) time.Sleep(1 * time.Second) bk.BookName = name } func main() { bk := Book{} //bk.L = \u0026amp;sync.Mutex{} bk.L = new(sync.Mutex) //wg := new(sync.WaitGroup) wg := \u0026amp;sync.WaitGroup{} books := []string{\u0026#34;\u0026lt;\u0026lt;ä¸‰å›½æ¼”ä¹‰\u0026gt;\u0026gt;\u0026#34;, \u0026#34;\u0026lt;\u0026lt;é“å¾·ç»\u0026gt;\u0026gt;\u0026#34;, \u0026#34;\u0026lt;\u0026lt;è¥¿æ¸¸è®°\u0026gt;\u0026gt;\u0026#34;} for _, book := range books { wg.Add(1) go bk.SetName(wg, book) } wg.Wait() } Lock set name: \u0026lt;\u0026lt;è¥¿æ¸¸è®°\u0026gt;\u0026gt; Unlock set name: \u0026lt;\u0026lt;è¥¿æ¸¸è®°\u0026gt;\u0026gt; Lock set name: \u0026lt;\u0026lt;ä¸‰å›½æ¼”ä¹‰\u0026gt;\u0026gt; Unlock set name: \u0026lt;\u0026lt;ä¸‰å›½æ¼”ä¹‰\u0026gt;\u0026gt; Lock set name: \u0026lt;\u0026lt;é“å¾·ç»\u0026gt;\u0026gt; Unlock set name: \u0026lt;\u0026lt;é“å¾·ç»\u0026gt;\u0026gt; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;sync\u0026#34; \u0026#34;time\u0026#34; ) func main() { var m sync.Mutex go func() { m.Lock() defer m.Unlock() fmt.Println(\u0026#34;1\u0026#34;) m.Lock()\t// è¿™é‡Œå½“å‰goroutineå°†è¢«æ°¸ä¹…ä¿å­˜åˆ°ä¿¡å·æ± ä¸­å¾—ä¸åˆ°è¿è¡Œæœºä¼š fmt.Println(\u0026#34;2\u0026#34;) defer m.Unlock() fmt.Println(\u0026#34;3\u0026#34;) }() time.Sleep(5 * time.Second) // Output: // 1 } æ³¨æ„äº‹é¡¹ Lock() å’Œ UnLock() æ–¹æ³•åº”è¯¥æˆå¯¹å‡ºç°ã€‚ sync.Mutex ä¸å…è®¸è¢«å€¼æ‹·è´ï¼Œæ‹·è´åœ°å€å¯ä»¥ã€‚ ","permalink":"https://heliu.site/posts/golang/sync/mutex/","summary":"Mutexæ˜¯ä¸€ç§äº’æ–¥é”ã€‚","title":"sync.Mutex"},{"content":" å®šä¹‰ç»“æ„ä½“ã€æ¥å£ã€ç±»å‹åˆ«åç­‰ã€‚ å®šä¹‰è‡ªå®šä¹‰ç±»å‹ï¼š è‡ªå®šä¹‰ç±»å‹ç”±ä¸€ç»„å€¼ä»¥åŠä½œç”¨äºè¿™äº›å€¼çš„æ–¹æ³•ç»„æˆã€‚ ç±»å‹ä¸€èˆ¬æœ‰ç±»å‹åˆ«åï¼Œå¾€å¾€ä»ç°æœ‰ç±»å‹ç»„åˆé€šè¿‡typeå…³é”®å­—æ„é€ å‡ºä¸€ä¸ªæ–°çš„ç±»å‹ã€‚ è‡ªå®šä¹‰ç±»å‹ GoåŸºç¡€æ•°æ®ç±»å‹ï¼š boolã€complex64ã€complex128ã€float32ã€float64ã€‚ intã€int8ã€int16ã€int32ã€int64ã€runeã€stringã€‚ uintã€uint8ã€uint16ã€uint32ã€uint64ã€byteã€uintptrã€‚ ä½¿ç”¨typeå…³é”®å­—å¯ä»¥å®šä¹‰è‡ªå·±çš„ç±»å‹ï¼Œå¯ä»¥ä½¿ç”¨typeå®šä¹‰ä¸€ä¸ªæ–°çš„ç»“æ„ä½“ã€‚ ä¹Ÿå¯ä»¥æŠŠä¸€ä¸ªå·²ç»å­˜åœ¨çš„ç±»å‹ä½œä¸ºåŸºç¡€ç±»å‹è€Œå®šä¹‰æ–°ç±»å‹ï¼Œç„¶ååœ¨ä»£ç ä¸­ä½¿ç”¨æ–°çš„ç±»å‹åå­—ã€‚ 1 type IZ int IZæ˜¯ä¸€ç§æ–°ç±»å‹ï¼Œç„¶åå¯ä»¥ä½¿ç”¨ä¸‹é¢æ–¹å¼å£°æ˜å˜é‡ã€‚ 1 var a IZ = 5 å¯ä»¥çœ‹åˆ°intæ˜¯å˜é‡açš„åº•å±‚ç±»å‹ï¼Œè¿™ä¹Ÿä½¿å¾—ä»–ä»¬ä¹‹é—´æˆä¸ºç›¸äº’è½¬åŒ–çš„å¯èƒ½ã€‚ å®šä¹‰å¤šä¸ªç±»å‹å¦‚ä¸‹ï¼š 1 2 3 4 5 type ( IZ int FZ float64 STR string ) åœ¨type IZ intä¸­ï¼ŒIZå°±æ˜¯åœ¨intç±»å‹åŸºç¡€ä¸Šæ„å»ºçš„æ–°åç§°ï¼Œè¿™ç§°ä¸ºè‡ªå®šä¹‰ç±»å‹ï¼Œä½¿ç”¨IZæ¥æ“ä½œintç±»å‹çš„æ•°æ®ã€‚ è¿™ç§æ–¹æ³•å®šä¹‰ä¹‹åçš„ç±»å‹å¯ä»¥æ‹¥æœ‰æ›´å¤šçš„ç‰¹æ€§ï¼Œä½†æ˜¯åœ¨ç±»å‹è½¬æ¢æ—¶å¿…é¡»æ˜¾ç¤ºè½¬æ¢ã€‚ æ¯ä¸ªå€¼éƒ½å¿…é¡»åœ¨ç»è¿‡ç¼–è¯‘åå±äºæŸä¸ªç±»å‹ï¼ˆç¼–è¾‘å™¨å¿…é¡»èƒ½å¤Ÿæ¨æ–­å‡ºæ‰€æœ‰å€¼å¾—ç±»å‹ï¼‰å› ä¸ºGoæ˜¯ä¸€ç§é™æ€ç±»å‹è¯­è¨€ã€‚ åœ¨å¿…è¦ä»¥åŠå¯è¡Œçš„æƒ…å†µä¸‹ï¼Œä¸€ç§ç±»å‹çš„å€¼å¯ä»¥è¢«è½¬æ¢æˆå¦å¤–ä¸€ç§ç±»å‹çš„å€¼ã€‚ Goè¯­è¨€ä¸å­˜åœ¨éšå¼è½¬æ¢ï¼Œå› æ­¤æ‰€æœ‰çš„è½¬æ¢éƒ½å¿…é¡»æ˜¾å¼è¯´æ˜ï¼Œå°±åƒè°ƒç”¨ä¸€ä¸ªå‡½æ•°ä¸€æ ·ï¼ˆç±»å‹åœ¨è¿™é‡Œçš„ä½œç”¨å¯ä»¥çœ‹ä½œæ˜¯ä¸€ç§å‡½æ•°ï¼‰ã€‚ 1 valueOfTypeB = typeB(valueOfTypeA) ç±»å‹Bçš„å€¼ = ç±»å‹B(ç±»å‹Açš„å€¼)ã€‚ type TZ intä¸­ï¼Œæ–°ç±»å‹TZä¸ä¼šæ‹¥æœ‰åŸåŸºç¡€ç±»å‹æ‰€é™„å¸¦çš„æ–¹æ³•ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 package main import ( \u0026#34;fmt\u0026#34; ) type A struct { Face int } func (a A) f () { fmt.Println(\u0026#34;hi \u0026#34;, a.Face) } // è‡ªå®šä¹‰æ–°ç±»å‹Aaã€‚æ²¡æœ‰åŸºç¡€ç±»å‹Açš„æ–¹æ³• type Aa A func main() { var s A = A{Face:9} s.f() // hi 9 var sa Aa = Aa{Face:90} //sa.f() // æ–¹æ³•ä¸å­˜åœ¨ fmt.Println(sa) // {90} } é€šè¿‡typeå…³é”®å­—åœ¨åŸæœ‰ç±»å‹åŸºç¡€ä¸Šæ„é€ å‡ºä¸€ä¸ªæ–°ç±»å‹ï¼Œéœ€è¦é’ˆå¯¹æ–°ç±»å‹æ¥é‡æ–°åˆ›å»ºæ–°æ–¹æ³•ã€‚ ç±»å‹åˆ«å ç±»å‹åˆ«ååœ¨Go1.9ç‰ˆæœ¬ä¸­å®ç°ï¼Œå°†åˆ«åç±»å‹å’ŒåŸç±»å‹è¿™ä¸¤ä¸ªç±»å‹è§†ä¸ºå®Œå…¨ä¸€è‡´ã€‚ 1 type IZ = int ä¸type IZ intä¸åŒï¼Œtype IZ = intåªæ˜¯ä¸ºintå–äº†ä¸ªåˆ«åï¼Œè€Œtype IZ intå´æ˜¯å®šä¹‰äº†æ–°ç±»å‹ã€‚ è‡ªå®šä¹‰ç±»å‹ä¸ä¼šæ‹¥æœ‰åŸç±»å‹é™„å¸¦çš„æ–¹æ³•ï¼Œè€Œåˆ«åæ‹¥æœ‰åŸç±»å‹é™„å¸¦çš„æ–¹æ³•ï¼Œç±»å‹åˆ«åæ‹¥æœ‰åŸç±»å‹å…¨éƒ¨çš„æ–¹æ³•ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 package main import ( \u0026#34;fmt\u0026#34; ) type A struct { Face int } func (a A) f () { fmt.Println(\u0026#34;hi \u0026#34;, a.Face) } // è‡ªå®šä¹‰æ–°ç±»å‹Aaã€‚æ²¡æœ‰åŸºç¡€ç±»å‹Açš„æ–¹æ³• type Aa = A func main() { var s A = A{Face:9} s.f() // hi 9 var sa Aa = Aa{Face:90} sa.f() // hi 90 fmt.Println(sa) // {90} } Goè¯­è¨€ä¸å­˜åœ¨ç±»å‹ç»§æ‰¿ã€‚ å‡½æ•°ä¹Ÿæ˜¯ä¸€ä¸ªç¡®å®šçš„ç±»å‹ï¼Œå°±æ˜¯ä»¥å‡½æ•°ç­¾åä½œä¸ºç±»å‹ï¼Œå‡½æ•°ç­¾åï¼šå‡½æ•°çš„å‚æ•°å’Œè¿”å›å€¼ã€‚ 1 type typeFunc func(int, int) int å¯ä»¥åœ¨å‡½æ•°ä½“ä¸­çš„æŸå¤„è¿”å›ä½¿ç”¨ç±»å‹ä¸ºtypeFuncçš„å˜é‡varfuncã€‚ 1 return varfunc è‡ªå®šä¹‰ç±»å‹ä¸ä¼šç»§æ‰¿åŸæœ‰ç±»å‹çš„æ–¹æ³•ï¼Œä½†æ¥å£æ–¹æ³•æˆ–ç»„åˆç±»å‹çš„å†…åµŒå…ƒç´ åˆ™ä¿ç•™åŸæœ‰çš„æ–¹æ³•ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 package main import ( \u0026#34;fmt\u0026#34; ) // Mutex ç”¨ä¸¤ç§æ–¹æ³•ï¼ŒLockå’ŒUnlock type Mutex struct{} func (m *Mutex) Lock() {} func (m *Mutex) Unlock() {} //NewMutex å’Œ Mutex çš„æ•°æ®ç»“æ„ä¸€æ ·ï¼Œä½†æ˜¯å…¶æ–¹æ³•æ˜¯ç©ºçš„ type NewMutex Mutex // PtrMutex çš„æ–¹æ³•ä¹Ÿæ˜¯ç©ºçš„ type PtrMutex Mutex // PrintableMutex æ‹¥æœ‰Lockå’ŒUnlockæ–¹æ³• type PrintableMutex struct { Mutex\t// ç»„åˆ } func main() {} ","permalink":"https://heliu.site/posts/golang/type/typ/","summary":"Golang typeå…³é”®å­—ç”¨æ³•ä»‹ç»ã€‚","title":"type"},{"content":"Golang è½¯ä»¶å®‰è£… é¦–å…ˆéœ€è¦ä¸‹è½½Goè¯­è¨€å®‰è£…åŒ…ã€‚ ä¸‹è½½åœ°å€ï¼šhttps://golang.org/dl/ã€‚ï¼ˆä¸­å›½å¤§é™†å¯èƒ½è®¿é—®ä¸åˆ°ï¼‰ å›½å†…ä¸‹è½½åœ°å€ï¼šhttps://golang.google.cn/dl/ã€‚ å®˜æ–¹å®‰è£…æ•™ç¨‹ï¼šhttps://golang.google.cn/doc/installã€‚ å®˜æ–¹çš„æ•™ç¨‹å¾ˆè¯¦ç»†ï¼ˆhttps://golang.google.cn/docï¼‰ã€‚ Linux UNIX / Linux / Mac OSå’ŒFreeBSDç³»ç»Ÿå¯ä»¥ä½¿ç”¨å¦‚ä¸‹æºç å®‰è£…æ–¹æ³•ã€‚ Macç³»ç»Ÿä¸‹å¯ä»¥ä½¿ç”¨ä»¥.pkgä¸ºæ‰©å±•åçš„å®‰è£…åŒ…ç›´æ¥åŒå‡»æ¥å®Œæˆå®‰è£…ï¼Œå®‰è£…ç›®å½•åœ¨/usr/local/go/ä¸‹ã€‚ Linuxä¸‹å®‰è£…golangæ­¥éª¤ ä¸‹è½½å®‰è£…åŒ…wget https://golang.google.cn/dl/go1.17.3.linux-amd64.tar.gzã€‚ 32-bit Linuxä¸‹è½½å®‰è£…åŒ… https://golang.google.cn/dl/go1.17.3.linux-386.tar.gzã€‚ 64-bit Linuxä¸‹è½½å®‰è£…åŒ… https://golang.google.cn/dl/go1.17.3.linux-amd64.tar.gzã€‚ åˆ é™¤è€ç‰ˆæœ¬ï¼ˆå¦‚æœå­˜åœ¨åˆ™æ‰§è¡Œï¼Œä¸å­˜åœ¨åˆ™å¿½ç•¥ï¼‰rm -rf /usr/local/goã€‚ è§£å‹å®‰è£…åŒ…sudo tar -xzf go1.17.3.linux-amd64.tar.gz -C /usr/localã€‚ é…ç½®ç¯å¢ƒå˜é‡ï¼šä½¿ç”¨go env -wå‘½ä»¤ä¸€èˆ¬åªæ˜¯æœ¬æ¬¡ç”Ÿæ•ˆã€‚ PATHç¯å¢ƒå˜é‡export PATH=$PATH:/usr/local/go/binGoLangå·¥å…·ä½ç½®ï¼ŒåŒ…å«gofmtå·¥å…·ã€‚ GOROOTå˜é‡export GOROOT=/usr/local/goGoLangå®‰è£…åŒ…ä½ç½®ã€‚ ä½¿ç”¨go env -w GOROOT=/usr/local/goé…ç½®ä¹Ÿæ˜¯å¯ä»¥çš„ã€‚ GOPATHå˜é‡export GOPATH=/var/local/goGoLang 1.11ç‰ˆæœ¬å‰é¡¹ç›®ç®¡ç†åŒ…ä½ç½®ã€‚ ä½¿ç”¨go env -w GOPATH=/var/local/goé…ç½®ä¹Ÿæ˜¯å¯ä»¥çš„ã€‚ æ‰“å°Goç‰ˆæœ¬å·go versionã€‚ å¦‚æœä¸Šé¢(ç¬¬4æ­¥)ç¯å¢ƒå˜é‡é…ç½®ä¸æˆåŠŸï¼Œé‚£ä¹ˆæ‰§è¡Œå¦‚ä¸‹æ­¥éª¤é…ç½®ï¼š sudo vim ~/.bashrcå‘½ä»¤æ‰“å¼€æ–‡ä»¶ã€‚ åœ¨æ–‡ä»¶æœ€åæ·»åŠ ï¼š 1 2 3 4 5 6 7 export GOROOT=/usr/local/go export GOPATH=/var/local/go export PATH=$PATH:$GOROOT/bin:$GOPATH/bin export GOPROXY=\u0026#34;https://goproxy.cn,direct\u0026#34; # åœ¨linuxä¸­è®¾ç½®ä¸´æ—¶ç›®å½•ï¼Œwindowsä¸ç”¨ export TMPDIR=/tmp æœ€åä½¿é…ç½®ç”Ÿæ•ˆ source ~/.bashrcã€‚ Windows ä¸‹è½½ https://golang.google.cn/dl/go1.17.3.windows-amd64.zipï¼Œç›´æ¥è§£å‹åˆ°å®‰è£…ç›®å½•ã€‚ å¦‚D:\\Goï¼Œç„¶åæŠŠD:\\Go\\binç›®å½•æ·»åŠ åˆ°PATHç¯å¢ƒå˜é‡ä¸­ã€‚ è®¾ç½®GOPATHå’ŒGOROOTç¯å¢ƒå˜é‡ï¼š GOPATH=D:\\goprojectã€‚ GOROOT=D:\\GO\\ã€‚ ä¹Ÿå¯ä»¥é€‰æ‹© https://golang.google.cn/dl/go1.17.3.windows-amd64.msiï¼ŒåŒå‡»è¿è¡Œç¨‹åºï¼Œæ ¹æ®æç¤ºæ¥æ“ä½œå®‰è£…ã€‚ GOROOTã€GOPATH GOROOT Goè½¯ä»¶çš„å®‰è£…åŒ…ç»å¯¹è·¯å¾„ï¼Œé»˜è®¤æ˜¯/usr/local/goã€‚ GOPATH $GOPATHå…è®¸æœ‰å¤šä¸ªç›®å½•ï¼Œå½“æœ‰å¤šä¸ªç›®å½•æ—¶ï¼Œè¯·æ³¨æ„åˆ†éš”ç¬¦ï¼ŒWindowsä¸­çš„åˆ†éš”ç¬¦æ˜¯åˆ†å·(;)ã€‚ å½“æœ‰å¤šä¸ªç›®å½•æ—¶é»˜è®¤å°†go getå‘½ä»¤è·å–çš„åŒ…å­˜æ”¾åœ¨ç¬¬ä¸€ä¸ªç›®å½•ä¸‹ï¼Œå½“åœ¨GOPATHæ¨¡å¼ä¸‹è¿è¡Œæ—¶æ˜¯è¿™æ ·å¤„ç†çš„ã€‚ $GOPATHç›®å½•ä¸‹çº¦å®šæœ‰ä¸‰ä¸ªå­ç›®å½•ï¼š srcç›®å½•ï¼šå­˜æ”¾æºä»£ç ï¼ˆå¦‚.goï¼Œ.cï¼Œ.hï¼Œ.sç­‰æ–‡ä»¶ï¼‰ã€‚ æŒ‰ç…§Goé»˜è®¤çº¦å®šï¼Œsrcç›®å½•æ˜¯go runï¼Œgo installç­‰å‘½ä»¤çš„å½“å‰å·¥ä½œè·¯å¾„ï¼ˆå³åœ¨æ­¤è·¯å¾„ä¸‹æ‰§è¡Œä¸Šè¿°å‘½ä»¤ï¼‰ã€‚ srcä¹Ÿæ˜¯ç”¨æˆ·ä»£ç å­˜æ”¾çš„ä¸»è¦ç›®å½•ï¼Œæ‰€æœ‰çš„æºä»£ç éƒ½å­˜æ”¾åœ¨è¿™ä¸ªç›®å½•ä¸‹é¢ï¼Œä¸€èˆ¬ä¸€ä¸ªé¡¹ç›®å’Œä¸€ä¸ªç›®å½•å¯¹åº”ã€‚ å½“åœ¨GOPATHæ¨¡å¼ä¸‹è¿è¡Œæ—¶æ˜¯è¿™æ ·å¤„ç†çš„ï¼Œä½†æ˜¯Goå®˜æ–¹åœ¨Go 1.11ç‰ˆæœ¬åä¸å†æ¨èä½¿ç”¨GOPATHæ¨¡å¼ç¼–å†™Goä»£ç ï¼Œå› æ­¤srcç›®å½•æ— ç”¨å¤„ã€‚ pkgç›®å½•ï¼šå­˜æ”¾ç¼–è¯‘æ—¶ç”Ÿæˆçš„ä¸­é—´æ–‡ä»¶ï¼ˆæ¯”å¦‚ï¼š.aï¼‰ã€‚ binç›®å½•ï¼šå­˜æ”¾ç¼–è¯‘åç”Ÿæˆçš„å¯æ‰§è¡Œæ–‡ä»¶ï¼Œæ¯”å¦‚åé¢å®‰è£…çš„delveæ’ä»¶æˆ–å¤šç‰ˆæœ¬goè½¯ä»¶å°±æ˜¯åœ¨è¿™ä¸ªç›®å½•é‡Œã€‚ ç®¡ç†Goå®‰è£… å®‰è£…å¤šä¸ªGoç‰ˆæœ¬ åœ¨åŒä¸€å°æœºå™¨ä¸Šå®‰è£…å¤šä¸ªGoç‰ˆæœ¬ã€‚ä¾‹å¦‚ï¼Œæˆ‘ä»¬å¯èƒ½å¸Œæœ›åœ¨å¤šä¸ªGoç‰ˆæœ¬ä¸Šæµ‹è¯•ä»£ç ã€‚ æ³¨æ„ï¼šéœ€è¦ä½¿ç”¨è¿™ç§å½¢å¼å®‰è£…éœ€è¦å…ˆå®‰è£…gitã€‚ å¤šç‰ˆæœ¬goå®‰è£…æ­¥éª¤ è¦å®‰è£…å…¶ä»–Goç‰ˆæœ¬ï¼Œè¿è¡Œgo installå‘½ä»¤ï¼ŒæŒ‡å®šè¦å®‰è£…çš„ç‰ˆæœ¬çš„ä¸‹è½½ä½ç½®ã€‚å¦‚ä¸‹ç¤ºä¾‹å®‰è£…ç‰ˆæœ¬1.10.7ï¼š go install golang.org/dl/go1.10.7@latestè¿™é‡Œä½¿ç”¨go installç¼–è¯‘å¹¶å®‰è£…æŒ‡å®šçš„åŒ…æ¥å®ç°å¤šç‰ˆæœ¬goå®‰è£ï¼Œç”Ÿæˆåçš„å¯æ‰§è¡Œæ–‡ä»¶åœ¨binç›®å½•ä¸‹ï¼ˆ$GOPATH/binï¼‰ã€‚ go1.10.7 downloadä¸‹è½½ï¼Œéœ€è¦åˆ‡æ¢åˆ°$GOPATH/binä¸‹å»æ‰§è¡Œï¼Œç”Ÿæˆçš„å®‰è£…è·¯å¾„åœ¨/root/sdk/go1.10.7ã€‚ 1 2 $ go install golang.org/dl/go1.10.7@latest # å®‰è£…å¹¶ç¼–è¯‘go1.10.7ç‰ˆæœ¬ $ go1.10.7 download è¦ä½¿ç”¨æ–°ä¸‹è½½çš„ç‰ˆæœ¬è¿è¡Œå‘½ä»¤ï¼Œå¦‚ä¸‹æ‰€ç¤ºï¼š 1 2 $ go1.10.7 version go version go1.10.7 linux/amd64 å½“ä½ å®‰è£…äº†å¤šä¸ªç‰ˆæœ¬æ—¶ï¼Œå¯ä»¥ä½¿ç”¨å¦‚ä¸‹å‘½ä»¤æŸ¥çœ‹æ¯ä¸ªç‰ˆæœ¬çš„å®‰è£…ä½ç½®ï¼š 1 $ go1.10.7 env GOROOT è¦å¸è½½ä¸‹è½½çš„ç‰ˆæœ¬æ—¶ï¼Œåªéœ€è¦åˆ é™¤å…¶ç”±GOROOTç¯å¢ƒå˜é‡å’Œgo.X.Y.ZäºŒè¿›åˆ¶æ–‡ä»¶æŒ‡å®šçš„å®‰è£…ç›®å½•å³å¯ã€‚ å¸è½½Go ä½¿ç”¨å¦‚ä¸‹æ‰€æè¿°çš„æ­¥éª¤ä»ç³»ç»Ÿä¸­åˆ é™¤Goã€‚ Linux / macOS / FreeBSD åˆ é™¤goç›®å½•ï¼šé€šå¸¸æ˜¯/usr/local/goç›®å½•ã€‚ ä»PATHç¯å¢ƒå˜é‡ä¸­åˆ é™¤Go binç›®å½•ã€‚ åœ¨Linuxå’ŒFreeBSDä¸‹ï¼Œç¼–è¾‘/etc/profileæˆ–$HOME/.profileã€‚ å¦‚æœæ‚¨ä½¿ç”¨macOSè½¯ä»¶åŒ…å®‰è£…äº†Goï¼Œè¯·åˆ é™¤/etc/paths.d/goæ–‡ä»¶ã€‚ Windows åˆ é™¤Goçš„æœ€ç®€å•æ–¹æ³•æ˜¯é€šè¿‡Windowsæ§åˆ¶é¢æ¿ä¸­çš„ Add/Remove ç¨‹åºï¼š åœ¨æ§åˆ¶é¢æ¿ä¸­ï¼ŒåŒå‡»Add/Removeç¨‹åºã€‚ åœ¨Add/Removeç¨‹åºä¸­ï¼Œé€‰æ‹©è¦å¸è½½çš„è½¯ä»¶ï¼Œå•å‡»å¸è½½ï¼Œç„¶åæŒ‰ç…§æç¤ºè¿›è¡Œæ“ä½œã€‚ è¦ä½¿ç”¨å·¥å…·åˆ é™¤Goï¼Œæ‚¨è¿˜å¯ä»¥ä½¿ç”¨å‘½ä»¤è¡Œï¼š é€šè¿‡è¿è¡Œä»¥ä¸‹å‘½ä»¤ä½¿ç”¨å‘½ä»¤è¡Œå¸è½½ï¼šmsiexec /x go{{version}}.windows-{{cpu-arch}}.msi /q æ³¨æ„ï¼šå¯¹ Windows ä½¿ç”¨æ­¤å¸è½½è¿‡ç¨‹å°†è‡ªåŠ¨åˆ é™¤ç”±åŸå§‹å®‰è£…åˆ›å»ºçš„ Windows ç¯å¢ƒå˜é‡ã€‚ ","permalink":"https://heliu.site/posts/golang/install/install/","summary":"Go è½¯ä»¶å®‰è£…ã€‚","title":"Install Golang"},{"content":"type WaitGroup struct ğŸš€ WaitGroup ç­‰å¾… goroutine é›†åˆå®Œæˆã€‚ main goroutine è°ƒç”¨ Add æ¥è®¾ç½®è¦ç­‰å¾…çš„ goroutine çš„æ•°é‡ã€‚ç„¶åæ¯ä¸ª goroutine è¿è¡Œå¹¶åœ¨å®Œæˆæ—¶è°ƒç”¨ Doneã€‚ åŒæ—¶ï¼Œå¯ä»¥ä½¿ç”¨ Wait æ¥é˜»å¡ï¼Œç›´åˆ°æ‰€æœ‰ goroutine å®Œæˆã€‚ WaitGroup åœ¨ç¬¬ä¸€æ¬¡ä½¿ç”¨åä¸èƒ½è¢«å¤åˆ¶ã€‚ WaitGroupï¼šç”¨äºç­‰å¾…ä¸€ç»„çº¿ç¨‹çš„ç»“æŸï¼Œçˆ¶çº¿ç¨‹è°ƒç”¨Addæ–¹æ³•æ¥è®¾å®šåº”ç­‰å¾…çš„çº¿ç¨‹çš„æ•°é‡ã€‚ æ¯ä¸ªè¢«ç­‰å¾…çš„çº¿ç¨‹åœ¨ç»“æŸæ—¶åº”è°ƒç”¨Doneæ–¹æ³•ï¼ŒåŒæ—¶ï¼Œä¸»çº¿ç¨‹é‡Œå¯ä»¥è°ƒç”¨Waitæ–¹æ³•é˜»å¡è‡³æ‰€æœ‰çº¿ç¨‹ç»“æŸã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 // A WaitGroup waits for a collection of goroutines to finish. // The main goroutine calls Add to set the number of // goroutines to wait for. Then each of the goroutines // runs and calls Done when finished. At the same time, // Wait can be used to block until all goroutines have finished. // // A WaitGroup must not be copied after first use. type WaitGroup struct { // WaitGroup é¦–æ¬¡ä½¿ç”¨åä¸èƒ½è¢«æ‹·è´çš„åŸå› ã€æ˜¯ \u0026amp;state2 åœ°å€ä¼šå‘ç”Ÿå˜åŒ–ã€‘ // semaPhore è¦æ±‚ \u0026amp;state2 åœ°å€æ˜¯ä¸€ä¸ªï¼Œä¸ç„¶ä»å…¶ä¸­å”¤é†’ goroutine ä¼šæ‰¾ä¸åˆ° noCopy noCopy\t// ç¼–è¯‘å™¨æ£€æŸ¥WaitGroupå¯¹è±¡æ˜¯å¦è¢«æ‹·è´è¿‡ // 64-bit value: high 32 bits are counter, low 32 bits are waiter count. // 64-bit atomic operations require 64-bit alignment, but 32-bit // compilers only guarantee that 64-bit fields are 32-bit aligned. // For this reason on 32 bit architectures we need to check in state() // if state1 is aligned or not, and dynamically \u0026#34;swap\u0026#34; the field order if // needed. // // 64ä½å€¼: é«˜32ä½æ˜¯ counter è®¡æ•°ï¼Œä½32ä½æ˜¯ waiter è®¡æ•°ã€‚ // 64-bit = ( uint64(counter) \u0026lt;\u0026lt; 32 ) | uint32( waiter ) // ã€64ä½åŸå­æ“ä½œéœ€è¦64ä½å¯¹é½ã€‘ï¼Œä½†æ˜¯32ä½ç¼–è¯‘å™¨åªä¿è¯64ä½å­—æ®µæ˜¯32ä½å¯¹é½çš„ã€‚ // å› æ­¤ï¼Œåœ¨32ä½æ¶æ„ä¸Šï¼Œæˆ‘ä»¬éœ€è¦æ£€æŸ¥åœ¨state()æ˜¯å¦å°†state1å¯¹é½ï¼Œå¹¶åœ¨éœ€è¦æ—¶åŠ¨æ€ â€œäº¤æ¢â€ å­—æ®µé¡ºåºã€‚ // æ„æ€æ˜¯ï¼šåœ¨32ä½æ“ä½œç³»ç»Ÿä¸‹ä½¿ç”¨64ä½åŸå­æ“ä½œæ—¶ï¼Œè¢«æ“ä½œåœ°å€å¿…é¡»æ˜¯64ä½å¯¹é½çš„ï¼Œä¸ç„¶ä¼šå®•æœºã€‚ state1 uint64\t// (uint64(counter) \u0026lt;\u0026lt; 32) | uint32(waiter) state2 uint32 } type noCopy struct noCopy å¯ä»¥åµŒå…¥åˆ°ç¬¬ä¸€æ¬¡ä½¿ç”¨åä¸å¾—å¤åˆ¶çš„ç»“æ„ä¸­. sync/cond.goæ–‡ä»¶ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 // noCopy may be embedded into structs which must not be copied // after the first use. // // See https://golang.org/issues/8005#issuecomment-190753527 // for details. type noCopy struct{} // Lock is a no-op used by -copylocks checker from `go vet`. // // Lock æ˜¯ `go vet` çš„ -copylocks æ£€æŸ¥å™¨ä½¿ç”¨çš„æ— æ“ä½œ func (*noCopy) Lock() {} func (*noCopy) Unlock() {} WaitGroup ç»“æ„å¸ƒå±€ Semaphoreï¼šä¿¡å·é‡ç”¨äºæŒ‚èµ· Wait å‡½æ•°çš„è°ƒç”¨è€…çš„ goroutineã€‚ï¼ˆéœ€è¦ä¸€ä¸ª uint32 ç±»å‹ï¼‰ Counterï¼šç­‰å¾…çš„è¿è¡Œçš„ goroutine æ•°é‡ï¼Œè¯¥å€¼åœ¨ Add å’Œ Done å‡½æ•°ä¸­è¢«æ“ä½œã€‚ Waiterï¼šç­‰å¾…åœ¨ Semaphore ä¸­çš„ goroutine æ•°é‡ã€‚ ä¸ºä»€ä¹ˆéœ€è¦è¿™ä¹ˆè®¾è®¡å‘¢ï¼Ÿå› ä¸º Waiter + Counter æ˜¯ä¸€ä¸ªæ•´ä½“ä½œä¸º64ä½ï¼Œè¢«åŸå­æ“ä½œï¼Œè€Œ64ä½åŸå­æ“ä½œåˆè¦æ±‚å¿…é¡»æ˜¯64ä½å¯¹é½çš„ã€‚ï¼ˆå…·ä½“å‚çœ‹state()æºç ï¼‰ åœ¨1.22ç‰ˆæœ¬ä¸­ï¼Œstate1ä¹Ÿå°±æ˜¯Waiterå’ŒCounterä½¿ç”¨atomic.Uint64æ›¿ä»£äº†ã€‚ä»¥ä¸‹å›¾æ˜¯1.18å‰ç‰ˆæœ¬çš„ã€‚ Semaã€Counterã€Waiter WaitGroup ç»“æ„è®¾è®¡ç›®çš„æ˜¯ç­‰å¾…é›†åˆä¸­çš„goroutineå®Œæˆï¼Œå› æ­¤ main goroutine å°±æ˜¯äº§ç”Ÿè¿™ä¸ªç­‰å¾…é›†åˆçš„ï¼Œå®ƒç­‰å¾…é›†åˆä¸­çš„æ‰€æœ‰goroutineå®Œæˆå†ç»§ç»­åç»­ã€‚ Counter åˆ™æ˜¯è®¡æ•°å½“å‰ç­‰å¾…é›†åˆä¸­çš„goroutineçš„æ•°é‡ï¼Œä¸€ä¸ªgoroutineè¢«åˆ›å»ºæ”¾å…¥é›†åˆæ—¶å°±åº”è¯¥è®¡æ•°Counterå€¼ï¼Œä¸€ä¸ªgoroutineå®Œæˆæ—¶ä¹Ÿåº”è¯¥è®¡æ•°Counterã€‚ å› æ­¤goroutineè¢«åŠ å…¥åˆ°ç­‰å¾…é›†åˆä¸­éƒ½æ˜¯åœ¨main goroutineä¸­æ“ä½œåŒ…æ‹¬Counterçš„è®¡æ•°ï¼Œä¸€ä¸ªgoroutineå®Œæˆè®¡æ•°Counteråº”è¯¥åœ¨è¿™goroutineå®Œæˆæ—¶æ“ä½œã€‚ Semaphore åˆ™æ˜¯ main goroutine åœ¨è°ƒç”¨Wait()å‡½æ•°æ—¶ï¼Œmain goroutineéœ€è¦ç­‰å¾…ç­‰å¾…é›†åˆgoroutineå®Œæˆè€ŒæŒ‚èµ·åœ¨Semaphoreæ± å­é‡Œã€‚ Waiter åˆ™æ˜¯è®°å½•Semaphoreä¸­ç­‰å¾…çš„goroutineçš„æ•°é‡ã€‚ Add() å’Œ Done() å‡½æ•°æ˜¯è®¡æ•°Counterçš„ç›¸å…³æ–¹æ³•ï¼Œåœ¨ç­‰å¾…é›†åˆgoroutineä¸­æœ€åä¸€ä¸ªgoroutineå®Œæˆæ—¶ï¼Œå¦‚æœæœ‰ç­‰å¾…åœ¨Semaphoreçš„goroutineåº”è¯¥å…¨éƒ¨å”¤é†’ã€‚ Wait() å‡½æ•°æ˜¯ç­‰å¾…ç­‰å¾…é›†åˆgoroutineå®Œæˆï¼Œmain goroutineä¸»åŠ¨æŒ‚èµ·è‡ªå·±çš„ç›¸å…³é€»è¾‘ã€‚ state() State è¿”å›æŒ‡å‘å­˜å‚¨åœ¨ wg.state* ä¸­çš„ State å’Œ sema å­—æ®µçš„æŒ‡é’ˆã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 // state returns pointers to the state and sema fields stored within wg.state*. func (wg *WaitGroup) state() (statep *uint64, semap *uint32) { // unsafe.Alignof(wg.state1) == 8ï¼šè¯´æ˜state1å­—æ®µå¯¹é½ä¸º8å­—èŠ‚ï¼Œè¿™ç§æƒ…å†µæ˜¯64ä½å¹³å° // uintptr(unsafe.Pointer(\u0026amp;wg.state1))%8 == 0ï¼šè¯´æ˜wg.state1çš„åœ°å€æŒ‰ç…§8å­—èŠ‚å¯¹é½çš„ï¼Œå¯èƒ½æ˜¯64æˆ–32å¹³å° if unsafe.Alignof(wg.state1) == 8 || uintptr(unsafe.Pointer(\u0026amp;wg.state1))%8 == 0 { // state1 is 64-bit aligned: nothing to do. // state1 æ˜¯ 64 ä½å¯¹é½çš„ï¼šæ— äº‹å¯åš return \u0026amp;wg.state1, \u0026amp;wg.state2\t// state1æ˜¯64ä½å¯¹é½ï¼Œstate1å°±æ˜¯stateï¼Œstate2å°±æ˜¯sema } else { // state1 is 32-bit aligned but not 64-bit aligned: this means that // (\u0026amp;state1)+4 is 64-bit aligned. // // State1æ˜¯32ä½å¯¹é½ï¼Œè€Œä¸æ˜¯64ä½å¯¹é½:è¿™æ„å‘³ç€ (\u0026amp;state1)+4 æ˜¯64ä½å¯¹é½ã€‚ // è¿™ç§æƒ…å†µå¤„ç†å°±æ˜¯ä¸ºäº†æ»¡è¶³åç»­ï¼š64ä½åŸå­æ“ä½œéœ€è¦64ä½å¯¹é½ state := (*[3]uint32)(unsafe.Pointer(\u0026amp;wg.state1))\treturn (*uint64)(unsafe.Pointer(\u0026amp;state[1])), \u0026amp;state[0] } } Add() Add å°† delta (å¯èƒ½æ˜¯è´Ÿæ•°)æ·»åŠ åˆ° WaitGroup counterã€‚ å¦‚æœ counter å˜ä¸º0ï¼Œæ‰€æœ‰åœ¨ç­‰å¾…æ—¶è¢«é˜»å¡çš„ goroutine éƒ½ä¼šè¢«é‡Šæ”¾ã€‚å¦‚æœ counter å˜ä¸ºè´Ÿæ•°ï¼Œåˆ™ä¼š paincã€‚ è¯·æ³¨æ„ï¼Œå½“ counter ä¸º0æ—¶ï¼Œdeltaä¸ºæ­£çš„è°ƒç”¨å¿…é¡»å‘ç”Ÿåœ¨ç­‰å¾…ä¹‹å‰ã€‚ ä½¿ç”¨è´Ÿçš„deltaè°ƒç”¨ï¼Œæˆ–è€…ä» counter å¤§äºé›¶å¼€å§‹ä½¿ç”¨æ­£çš„deltaè°ƒç”¨ï¼Œéƒ½å¯èƒ½åœ¨ä»»ä½•æ—¶å€™å‘ç”Ÿã€‚ é€šå¸¸ï¼Œè¿™æ„å‘³ç€å¯¹Addçš„è°ƒç”¨åº”è¯¥åœ¨åˆ›å»ºgoroutineè¯­å¥æˆ–å…¶ä»–è¦ç­‰å¾…çš„äº‹ä»¶ä¹‹å‰æ‰§è¡Œã€‚ å¦‚æœé‡ç”¨ä¸€ä¸ª WaitGroup æ¥ç­‰å¾…å‡ ä¸ªç‹¬ç«‹çš„äº‹ä»¶é›†ï¼Œé‚£ä¹ˆæ–°çš„Addè°ƒç”¨å¿…é¡»åœ¨æ‰€æœ‰å…ˆå‰çš„waitè°ƒç”¨éƒ½è¿”å›ä¹‹åå‘ç”Ÿã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 // Add adds delta, which may be negative, to the WaitGroup counter. // If the counter becomes zero, all goroutines blocked on Wait are released. // If the counter goes negative, Add panics. // // Note that calls with a positive delta that occur when the counter is zero // must happen before a Wait. Calls with a negative delta, or calls with a // positive delta that start when the counter is greater than zero, may happen // at any time. // Typically this means the calls to Add should execute before the statement // creating the goroutine or other event to be waited for. // If a WaitGroup is reused to wait for several independent sets of events, // new Add calls must happen after all previous Wait calls have returned. // See the WaitGroup example. func (wg *WaitGroup) Add(delta int) { // 1) åŸå­æ“ä½œ statep += delta // statep *uint64ï¼šã€Waiter + Counterã€‘ // semap *uint32ï¼šã€semaphoreã€‘ // *statep = (uint64(counter) \u0026lt;\u0026lt; 32) | uint32(waiter) statep, semap := wg.state() if race.Enabled { _ = *statep // trigger nil deref early if delta \u0026lt; 0 { // Synchronize decrements with Wait. race.ReleaseMerge(unsafe.Pointer(wg)) } race.Disable() defer race.Enable() } // åŸå­æ“ä½œ {counter += delta; state = counter;} delta å¯èƒ½ä¸ºè´Ÿæ•° // è¿™é‡Œçš„64ä½åŸå­æ“ä½œä¹Ÿå°±æ˜¯ä¸ºä»€ä¹ˆéœ€è¦ state å‡½æ•°çš„åŸå›  state := atomic.AddUint64(statep, uint64(delta)\u0026lt;\u0026lt;32) // counter += delta // æ³¨æ„è¿™é‡Œæ˜¯ int32 ç±»å‹ï¼ŒåŸå› æ˜¯ delta æ˜¯æ¥è‡ªç”¨æˆ·ä¼ å…¥ï¼Œå¯èƒ½æœ€åå¯¼è‡´ v \u0026lt; 0 æƒ…å†µå‘ç”Ÿ v := int32(state \u0026gt;\u0026gt; 32)\t// counter é«˜32ä½ w := uint32(state)\t// waiter ä½32ä½ if race.Enabled \u0026amp;\u0026amp; delta \u0026gt; 0 \u0026amp;\u0026amp; v == int32(delta) { // The first increment must be synchronized with Wait. // Need to model this as a read, because there can be // several concurrent wg.counter transitions from 0. race.Read(unsafe.Pointer(semap)) } // 2) counter ä¸èƒ½ä¸ºè´Ÿæ•° // counter ä¸åº”è¯¥å‡ºç°ä¸ºè´Ÿæ•°æƒ…å†µ if v \u0026lt; 0 { panic(\u0026#34;sync: negative WaitGroup counter\u0026#34;) } // 3) Add(\u0026gt;0) å’Œ Wait å‡½æ•°ä¸èƒ½å¹¶å‘è°ƒç”¨ // Add(\u0026gt;0) å’Œ Wait() å‡½æ•°å¹¶å‘è¢«è°ƒç”¨ // 1. w != 0 å­˜åœ¨ç­‰å¾…çš„waiter // 2. delta \u0026gt; 0 æœ¬æ¬¡è°ƒç”¨æ˜¯æ·»åŠ ä¸æ˜¯å‡å°‘ // 3. v == int32(delta) å½“å‰æ·»åŠ çš„æ•°é‡å°±æ˜¯æ€»æ•°é‡ï¼Œä¹‹å‰ä¸º0 if w != 0 \u0026amp;\u0026amp; delta \u0026gt; 0 \u0026amp;\u0026amp; v == int32(delta) { panic(\u0026#34;sync: WaitGroup misuse: Add called concurrently with Wait\u0026#34;) } // 4) if ( v \u0026gt; 0 || (v == 0 \u0026amp;\u0026amp; w == 0) ) return // Counterè®¡æ•°æ•°é‡å¤§äºé›¶ æˆ– æ²¡æœ‰ç­‰å¾…çš„waiterç›´æ¥è¿”å› // 1. v \u0026gt; 0ï¼šä»£è¡¨ä¸æ˜¯æœ€åä¸€ä¸ªï¼Œå› æ­¤ç›´æ¥è¿”å› // 2. v == 0 \u0026amp;\u0026amp; w == 0ï¼šä¹Ÿæ˜¯ç›´æ¥è¿”å› if v \u0026gt; 0 || w == 0 {\t// è¿™é‡Œçš„æ¡ä»¶æ¯”è¾ƒå…³é”® return } // 5) v == 0 \u0026amp;\u0026amp; w \u0026gt; 0 // è¿™ç§æƒ…å†µéœ€è¦å»æŠŠ semap ä¸Šé¢æŒ‚èµ·çš„ goroutine å…¨éƒ¨å”¤é†’ // This goroutine has set counter to 0 when waiters \u0026gt; 0. // Now there can\u0026#39;t be concurrent mutations of state: // - Adds must not happen concurrently with Wait, // - Wait does not increment waiters if it sees counter == 0. // Still do a cheap sanity check to detect WaitGroup misuse. // // å½“ waiters \u0026gt; 0 æ—¶ï¼Œæ­¤ goroutine å°† counter è®¾ç½®ä¸º 0 // ç°åœ¨ä¸èƒ½æœ‰å¹¶å‘çš„ state çªå˜ï¼š // - Add ä¸èƒ½ä¸ Wait åŒæ—¶å‘ç”Ÿ // - å¦‚æœçœ‹åˆ° counter == 0ï¼ŒWait ä¸ä¼šå¢åŠ  waiter // ä»ç„¶è¦åšä¸€ä¸ªå»‰ä»·çš„å¥å…¨æ£€æŸ¥æ¥æ£€æµ‹WaitGroupçš„æ»¥ç”¨ã€‚ // // WaitGroupè¯¯ç”¨:Addä¸Waitå¹¶å‘è°ƒç”¨ // è¿™ç§æƒ…å†µå‘ç”Ÿåœ¨ï¼šæœ€åä¸€ä¸ªgoroutineè¿è¡Œå®Œéœ€è¦å”¤é†’ç­‰å¾…çš„waiteræ­¤æ—¶Addæ–¹æ³•æœ‰è¢«è°ƒç”¨ if *statep != state { panic(\u0026#34;sync: WaitGroup misuse: Add called concurrently with Wait\u0026#34;) } // Reset waiters count to 0. *statep = 0\t// é‡ç½® Counter = 0ï¼ŒWaiter = 0 for ; w != 0; w-- { // falseæ­£å¸¸æ¨¡å¼ // å°†ç­‰å¾…åœ¨ semaphore ä¸­çš„goroutineå–å‡ºç­‰å¾…è°ƒåº¦ runtime_Semrelease(semap, false, 0) } } Done() Done å°† WaitGroup counter å‡1ã€‚ 1 2 3 4 // Done decrements the WaitGroup counter by one. func (wg *WaitGroup) Done() { wg.Add(-1) } Wait() Wait é˜»å¡ï¼Œç›´åˆ° WaitGroup counter ä¸º0ã€‚ Wait å‡½æ•°çš„è°ƒç”¨æœŸé—´ï¼Œå¯èƒ½å¤„äºå¤šä¸ªgoroutineåœ¨è°ƒç”¨ Done å‡½æ•°ã€‚ Wait() å‡½æ•°å…è®¸è¢«å¤šä¸ªçº¿ç¨‹åŒæ—¶è°ƒç”¨ã€‚Wait() å‡½æ•°ä¸€å®šè¦æ‰€æœ‰çš„Counteréƒ½æ ‡è®°å®Œæ¯•åæ‰è°ƒç”¨è¯¥æ–¹æ³•ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 // Wait blocks until the WaitGroup counter is zero. func (wg *WaitGroup) Wait() { // statep *uint64ï¼šã€Waiter + Counterã€‘ // semap *uint32ï¼šã€semaphoreã€‘ // *statep = (uint64(counter) \u0026lt;\u0026lt; 32) | uint32(waiter) statep, semap := wg.state() if race.Enabled { _ = *statep // trigger nil deref early race.Disable() } for { state := atomic.LoadUint64(statep)\t// åŸå­è¯»å– statep v := int32(state \u0026gt;\u0026gt; 32)\t// counter w := uint32(state)\t// waiter // è¿™ç§æƒ…å†µï¼Œæ¯”å¦‚åœ¨è°ƒç”¨Waitå‡½æ•°æ—¶å…ˆè°ƒç”¨sleepç¡çœ å¾ˆé•¿ä¸€æ®µæ—¶é—´ // ä¹Ÿå°±æ˜¯ Wait å‡½æ•°è¿˜æ²¡å¼€å§‹æ‰§è¡Œ å…¶ä»–goroutine å·²ç»æ‰§è¡Œå®Œäº†ï¼Œå› æ­¤ç›´æ¥è¿”å›å³å¯ if v == 0 {\t// Counter is 0, no need to wait. // // è®¡æ•°å™¨ä¸º 0ï¼Œæ— éœ€ç­‰å¾… if race.Enabled { race.Enable() race.Acquire(unsafe.Pointer(wg)) } return } // Increment waiters count. // // å¢åŠ waiteræ•°é‡ï¼Œæ­£å¸¸é€»è¾‘ä¸‹åœ¨è¿™é‡Œç­‰å¾…çš„åªæœ‰main goroutineä¸€ä¸ª // è¿™é‡Œå¯èƒ½ä¼šå¤±è´¥ï¼Œå¯èƒ½æœ‰å¾ˆå¤šgoroutineæ­£åœ¨è°ƒç”¨Addæˆ–Doneæ–¹æ³•ä¿®æ”¹Counterå¯¼è‡´è¿™é‡ŒåŸå­æ“ä½œå¤±è´¥ if atomic.CompareAndSwapUint64(statep, state, state+1) { if race.Enabled \u0026amp;\u0026amp; w == 0 { // Wait must be synchronized with the first Add. // Need to model this is as a write to race with the read in Add. // As a consequence, can do the write only for the first waiter, // otherwise concurrent Waits will race with each other. race.Write(unsafe.Pointer(semap)) } // è¯¥æ–¹æ³•æœ€åä¼šè°ƒç”¨semacquire1ï¼Œæˆ‘ä»¬åœ¨sync.Mutexä¸­å·²ç»è®¨è®ºè¿‡ // è¿™é‡Œä¼šæŠŠå½“å‰goroutineå…¥é˜Ÿï¼Œæ³¨æ„è¿™é‡Œå…¥é˜Ÿçš„æ˜¯main goroutine // runtime_Semacquire å°†å½“å‰ goroutine åŠ å…¥åˆ° semaphore çš„å°¾éƒ¨ runtime_Semacquire(semap)\t// ä¸»çº¿ç¨‹åœ¨è¿™é‡Œè¢«è°ƒç¦»å·¥ä½œçº¿ç¨‹ï¼Œä¸‹æ¬¡æ¢å¤æ—¶ä»è¿™é‡Œæ¥åˆ°æ‰§è¡Œ // å½“å‰goroutineè¢«Doneå‡½æ•°å”¤é†’æ—¶ï¼Œä¸€å®šæ˜¯ *statep == 0ï¼Œä¸ç„¶æµç¨‹æœ‰é—®é¢˜ if *statep != 0 { panic(\u0026#34;sync: WaitGroup is reused before previous Wait has returned\u0026#34;) } if race.Enabled { race.Enable() race.Acquire(unsafe.Pointer(wg)) } return\t// ç›´æ¥è¿”å›åˆ°è°ƒç”¨Waitæ–¹æ³•ä½ç½®å¤„ } } } ä½¿ç”¨ç¤ºä¾‹ WaitGroupï¼šç”¨äºçº¿ç¨‹æ€»åŒæ­¥ï¼Œå®ƒç­‰å¾…ä¸€ç»„çº¿ç¨‹é›†åˆå®Œæˆï¼Œæ‰ä¼šç»§ç»­å‘ä¸‹æ‰§è¡Œã€‚ ä¸»çº¿ç¨‹è°ƒç”¨ Add() æ–¹æ³•æ¥è®¾ç½®ç­‰å¾…çš„åç¨‹æ•°é‡ï¼š ç„¶åæ¯ä¸ªåç¨‹è¿è¡Œï¼Œå¹¶åœ¨å®Œæˆåè°ƒç”¨ Done() æ–¹æ³•ï¼ŒAdd(-1) å’Œ Done() æ•ˆæœä¸€è‡´ï¼Œéƒ½è¡¨ç¤ºç­‰åˆ°çš„åç¨‹æ•°é‡å‡å°‘ä¸€ä¸ªã€‚ åŒæ—¶ï¼ŒWait() æ–¹æ³•ç”¨æ¥é˜»å¡ä¸»çº¿ç¨‹ï¼Œç›´åˆ°æ‰€æœ‰åç¨‹å®Œæˆæ‰ä¼šå‘ä¸‹æ‰§è¡Œã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;sync\u0026#34; ) func main() { var wg sync.WaitGroup wg.Add(10)\t// (\u0026amp;wg).Add(10) -\u0026gt; (*WaitGroup).Add(\u0026amp;wg, 10) for i := 0; i \u0026lt; 10; i++ { //wg.Add(1)\t// (\u0026amp;wg).Add(1)\t-\u0026gt; (*WaitGroup).Add(\u0026amp;wg, 1) go func(i int) { defer wg.Done()\t// (\u0026amp;wg).Done() -\u0026gt; (*WaitGroup).Done(\u0026amp;wg) fmt.Println(i) }(i) } fmt.Println(\u0026#34;æˆ‘åœ¨å¾ªç¯å¤–\u0026#34;) // é˜»å¡ä¸»çº¿ç¨‹ï¼Œç­‰æ‰€æœ‰åç¨‹å®Œæˆ wg.Wait()\t// (\u0026amp;wg).Wait() -\u0026gt; (*WaitGroup).Wait(\u0026amp;wg) // Output: // 1 // 9 // 3 // 4 // æˆ‘åœ¨å¾ªç¯å¤– // 5 // 6 // 7 // 8 // 2 // 0 } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;net/http\u0026#34; \u0026#34;sync\u0026#34; ) func main() { var wg sync.WaitGroup var urls []string = []string{ \u0026#34;http://baidu.com/\u0026#34;, \u0026#34;https://wzapi.myzx.cn/\u0026#34;, } wg.Add(len(urls)) for _, url := range urls { // wg.Add(1) go func(url string) { defer wg.Done() response, err := http.Get(url) fmt.Println(response, err, url) }(url) } wg.Wait() fmt.Println(\u0026#34;over\u0026#34;) // Output: // \u0026amp;{200 OK 200 HTTP/1.1 1 1 map[Accept-Ranges:[bytes] Cache-Control:[max-age=86400] Connection:[Keep-Alive] Content-Length:[81] Content-Type:[text/html] Date:[Thu, 22 Apr 2021 03:19:50 GMT] Etag:[\u0026#34;51-47cf7e6ee8400\u0026#34;] Expires:[Fri, 23 A // pr 2021 03:19:50 GMT] Last-Modified:[Tue, 12 Jan 2010 13:48:00 GMT] Server:[Apache]] 0xc00003a140 81 [] false false map[] 0xc000044000 \u0026lt;nil\u0026gt;} \u0026lt;nil\u0026gt; http://baidu.com/ // \u0026amp;{200 OK 200 HTTP/1.1 1 1 map[Access-Control-Allow-Headers:[Origin, X-Requested-With, Content-Type, Acceptfecshop-uuid, fecshop-lang, fecshop-currency, access-token, x-token, authorization] Access-Control-Allow-Methods:[*] Access-Co // ntrol-Allow-Origin:[*] Cache-Control:[no-cache, private] Connection:[keep-alive] Content-Type:[text/html; charset=UTF-8] Date:[Thu, 22 Apr 2021 03:19:50 GMT] Etag:[W/\u0026#34;be34c7da7adc79dfee6c76195ba1dbdad7b5bc9b\u0026#34;] Server:[MYBWS/1.1] Set // -Cookie:[acw_tc=2760829816190615907855703e97def055d99950b742716bbf6b2d8e6e2288;path=/;HttpOnly;Max-Age=1800 XSRF-TOKEN=eyJpdiI6IjFPZm9TcTYzblc5c0JJMFdSSW5EZ0E9PSIsInZhbHVlIjoiTXhEbHNlbVRXelMwTnR4UE5nY1JsNTRDTEJ4SmUzaFFsQkZTak9nTEtib // m5rczF3VlF6bVE1YitjNU5EbzlXMms4bTZLV0RiRTk4WXZMSFBBMFoxQ0V0OUpuYWxwN1ppYmpydjFFUzRQWXVBbktaNW82dFNVXC9BXC9FOG9Qb094VSIsIm1hYyI6IjNmYTMyZDUyYzk0ZWY0ZjJkNzJjOGY3M2FiYWYzZDYwNTA4YjFmZTBiZTljMzI1ZTI1MzY1MGQyZDAxYjQwN2QifQ%3D%3D; expires // =Thu, 22-Apr-2021 05:19:50 GMT; Max-Age=7200; path=/ laravel_session=eyJpdiI6IlA2cXcxRHVWYVgxa3VZRnNFY09LbkE9PSIsInZhbHVlIjoiK1ptMGIwOTdZbGp5dlwvRlNMK2pWb3hLVVErV0wxOFBQSmp1dVRkWExcL1VZbm1zVFwvUmRGT0dZcXJlcTZSRmhoWk1hdkJxYU9kUUFrNjB // RK3o4cW5TanZVZXZSYjVEN29CNUU2bEVHdHVoUVVESkhJcG1ETDVCS3FSTmtwYkJTcDciLCJtYWMiOiIwMTM3NDg2NTJlNDJkMGFhN2Y0NDA2YzJhYzcyMTQ4MzY1NDU1YzlmMjYwOTUxNjM0ZDJkYjUzYWJmMmMxZTE1In0%3D; expires=Thu, 22-Apr-2021 05:19:50 GMT; Max-Age=7200; path=/ // ; httponly]] 0xc0001220a0 -1 [chunked] false true map[] 0xc00010a000 0xc00004e0b0} \u0026lt;nil\u0026gt; https://wzapi.myzx.cn/ // over } æ€»ç»“ sync.WaitGroup æ›´å¤šæ˜¯ å¤šä¸ªgoroutineé€šçŸ¥ä¸€ä¸ªgoroutine,æ›´åƒæ˜¯main goroutineç­‰å¾…é›†åˆçš„æ‰€æœ‰goroutineå®Œæˆä¸€é¡¹ä»»åŠ¡ï¼Œå¤šå¯¹ä¸€ sync.Cond åˆ™æ›´åƒå¤šä¸ªgoroutineç­‰å¾…main goroutineçš„å·¥ä½œå®Œæˆï¼Œä¸€å¯¹å¤šï¼Œæ›´åƒæ˜¯å¹¿æ’­å½¢å¼ ä½¿ç”¨æ³¨æ„ ä»¥ä¸‹ä½¿ç”¨æ–¹å¼æ˜¯ä¸æ­£ç¡®çš„ã€‚ package main import ( \u0026#34;fmt\u0026#34; \u0026#34;sync\u0026#34; ) func main() { var wg sync.WaitGroup // ã€ä¸èƒ½å¦å¤–å¯åŠ¨åç¨‹å»æ‰§è¡ŒAdd()å’ŒDone()ï¼Œå› ä¸ºmainçš„Wait()ä¸ä¼šé˜»å¡ç­‰å¾…ã€‘ go func() { for i := 0; i \u0026lt; 10; i++ { wg.Add(1)\t// (\u0026amp;wg).Add(1)\t-\u0026gt; (*WaitGroup).Add(\u0026amp;wg, 1) go func(i int) { defer wg.Done()\t// (\u0026amp;wg).Done() -\u0026gt; (*WaitGroup).Done(\u0026amp;wg) fmt.Println(i) }(i) } }() // è¿™é‡Œå¹¶ä¸ä¼šé˜»å¡ç­‰å¾…ï¼Œå› ä¸ºè®¡æ•°å™¨ä¸º0 wg.Wait() // Output: } ","permalink":"https://heliu.site/posts/golang/sync/waitgroup/","summary":"WaitGroupç­‰å¾…ä¸€ç»„goroutineå®Œæˆã€‚","title":"sync.WaitGroup"},{"content":"åŸºæœ¬æ•°æ®ç±»å‹ å¸ƒå°”ç±»å‹ å¸ƒå°”å‹å€¼åªèƒ½æ˜¯å¸¸é‡trueæˆ–falseã€‚ 1 2 3 4 5 // true å’Œ false æ˜¯ä¸¤ä¸ªæ— ç±»å‹çš„å¸ƒå°”å€¼ const ( true = 0 == 0 // æ— ç±»å‹å¸ƒå°”å€¼ false = 0 != 0 // æ— ç±»å‹å¸ƒå°”å€¼ï¼ˆé»˜è®¤å€¼falseï¼‰ ) Goè¯­è¨€ä¸­ä¸å…è®¸å°†æ•´å‹å¼ºåˆ¶è½¬å¸ƒå°”å‹ï¼Œä¹Ÿä¸å…è®¸å°†å¸ƒå°”å‹å¼ºåˆ¶è½¬æ•´å‹ã€‚ å¦‚ï¼šb := (int)(false)ï¼Œa := (bool)(1)è¿™éƒ½æ˜¯é”™è¯¯çš„ã€‚ å¸ƒå°”å‹æ— æ³•å‚ä¸æ•°å€¼è¿ç®—ï¼Œä¹Ÿæ— æ³•ä¸å…¶ä»–ç±»å‹è¿›è¡Œè½¬æ¢ï¼Œå¸ƒå°”ç±»å‹ä»…ç”¨åœ¨æ¡ä»¶åˆ¤æ–­ä¸­ã€‚ é€šè¿‡æŒ‡é’ˆè¿ç®—(unsafe)å¯ä»¥å®ç°0æˆ–1è½¬å¸ƒå°”ç±»å‹ã€‚ boolean å†…å­˜å¸ƒå±€ å¸ƒå°”ç±»å‹å ä¸€å­—èŠ‚ï¼Œä¹Ÿå°±æ˜¯8bitï¼Œå…¶åœ¨å†…å­˜ä¸­å­˜å‚¨çš„å€¼æ˜¯0æˆ–é0ã€‚8bitå…¨æ˜¯0è¡¨ç¤ºfalseï¼Œå…¶ä»–æƒ…å†µè¡¨ç¤ºtrueã€‚ å‡è®¾å®šä¹‰å˜é‡bï¼Œvar b boolï¼Œé»˜è®¤å€¼ä¸ºfalseå…¶å†…å­˜å­˜å‚¨ä¸º0ï¼› ç»™å˜é‡bèµ‹å€¼trueï¼Œb = trueï¼Œå…¶å†…å­˜è®¾ç½®ä¸º1ã€‚ ç»™å˜é‡bèµ‹å€¼falseï¼Œb = falseï¼Œå…¶å†…å­˜è®¾ç½®ä¸º0ã€‚ å¸ƒå°”ç±»å‹ä½œä¸ºæ¡ä»¶åˆ¤æ–­æ—¶ï¼Œå…¶å†…å­˜å€¼ä¸º0ï¼Œåˆ™åˆ¤æ–­ä¸ºtrueï¼›é0åˆ™åˆ¤æ–­ä¸ºfalseã€‚ æ›´å¤šå…³äºå¸ƒå°”ç±»å‹çš„å…ƒç»“æ„ç±»å‹ï¼Œå‚çœ‹_typeç»“æ„ï¼Œè®°å½•ç€å¸ƒå°”å‹çš„ç›¸å…³å‚æ•°ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 // å…³äºå®šä¹‰å¸ƒå°”ç±»å‹ç¤ºä¾‹ var b bool = false // å®šä¹‰å¸ƒå°”ç±»å‹å˜é‡bå¹¶è®¾ç½®å…¶å€¼ä¸ºfalse var a bool // å®šä¹‰å¸ƒå°”ç±»å‹å˜é‡aå¹¶è®¾ç½®å…¶å€¼ä¸ºfalse // --------------------------------------------------------------- // 1) å¸ƒå°”å€¼æ˜¯ä»¥æ€æ ·çš„å½¢å¼ä¿å­˜åœ¨å†…å­˜ä¸­çš„ // ------------------------------------------------------- // falseï¼šåœ¨å†…å­˜ä¸­å­˜å‚¨çš„æ˜¯0b0000_0000ä¹Ÿå°±æ˜¯æ•´å‹0 // trueï¼š åœ¨å†…å­˜ä¸­å­˜å‚¨çš„æ˜¯0b0000_0001ä¹Ÿå°±æ˜¯æ•´å‹1 // ------------------------------------------------------- // ç¤ºä¾‹ä¸­æ˜¯ boolè½¬int8ç±»å‹ï¼Œå½“ç„¶ä¹Ÿèƒ½è½¬å…¶ä»–ç±»å‹ // ------------------------------------------------------- var b0 bool = false // å‡è®¾b0åœ°å€ 0xc000014090 var b1 bool = true // *bool -\u0026gt; *int8 // i1 å­˜å‚¨çš„æ˜¯b0çš„åœ°å€0xc000014090 ç±»å‹ä¸º*int8 // æ³¨æ„åŒºåˆ«ï¼š*(*int8)(unsafe.Pointer(\u0026amp;b0)) å­˜å‚¨çš„æ˜¯b0çš„å€¼ ç±»å‹ä¸ºint8 // æ³¨æ„åŒºåˆ«ï¼š(**int8)(unsafe.Pointer(\u0026amp;b0)) *bool -\u0026gt; **int8 i1 := (*int8)(unsafe.Pointer(\u0026amp;b0)) i2 := (*int8)(unsafe.Pointer(\u0026amp;b1)) fmt.Println(*i1, *i2) // 0 1 // --------------------------------------------------------------- // 2) æ•´æ•°ç±»å‹è½¬æ¢æˆå¸ƒå°”å€¼æ˜¯æ€æ ·ä¸ªæƒ…å†µ // ------------------------------------------------------- // 0b0000_0000 è½¬å¸ƒå°”æ˜¯ falseï¼Œå…¶ä»–å…¨æ˜¯ true // 0ï¼šè½¬å¸ƒå°”æ˜¯ false // 32768ï¼š(2^15)è½¬å¸ƒå°”æ˜¯ false // 1ï¼šè½¬å¸ƒå°”æ˜¯ true // 2ï¼šè½¬å¸ƒå°”æ˜¯ true // -1ï¼šè½¬å¸ƒå°”æ˜¯ true æ³¨æ„è½¬æ¢æ—¶å¸ƒå°”å€¼åªéœ€è¦1å­—èŠ‚é•¿åº¦8bit // ------------------------------------------------------- var b0 int8 = 0 var b1 int8 = 1 i1 := (*bool)(unsafe.Pointer(\u0026amp;b0)) i2 := (*bool)(unsafe.Pointer(\u0026amp;b1)) fmt.Println(*i1, *i2) // false true // -------------------------------------------------------- // 3) ä¸‹é¢æˆ‘ä»¬æŠŠå…¶ä»–ç±»å‹è½¬æ¢æˆå¸ƒå°”å€¼ç„¶åå†è½¬å›ä¹‹å‰çš„ç±»å‹ // -------------------------------------------------------- // ä»¥ä¸‹ä»£ç è¯´æ˜ä½¿ç”¨unsafeè½¬æ¢ä»…ä»…æ˜¯æŠŠç¬¬ä¸€ä¸ªå­—èŠ‚æŒ‡å‘boolåœ°å€ // -------------------------------------------------------- // 3.1) int8 -\u0026gt; bool -\u0026gt; int8 var b0 int8 = 0 var b1 int8 = -125 // 1000 0011 i1 := (*bool)(unsafe.Pointer(\u0026amp;b0)) i2 := (*bool)(unsafe.Pointer(\u0026amp;b1)) fmt.Println(*i1, *i2) // false true i11 := (*int8)(unsafe.Pointer(i1)) i22 := (*int8)(unsafe.Pointer(i2)) fmt.Println(*i11, *i22) // 0 -125 // 3.2) int -\u0026gt; bool -\u0026gt; int var b0 int = 0 var b1 int = 55536 i1 := (*bool)(unsafe.Pointer(\u0026amp;b0)) i2 := (*bool)(unsafe.Pointer(\u0026amp;b1)) fmt.Println(*i1, *i2) // false true i11 := (*int)(unsafe.Pointer(i1)) i22 := (*int)(unsafe.Pointer(i2)) fmt.Println(*i11, *i22) // 0 55536 // 3.3) uint16 -\u0026gt; bool ä¿®æ”¹ -\u0026gt; uint16 var b0 uint16 = 0 var b1 uint16 = 0b10000000_11111111 i1 := (*bool)(unsafe.Pointer(\u0026amp;b0)) i2 := (*bool)(unsafe.Pointer(\u0026amp;b1)) fmt.Println(*i1, *i2) // false true *i2 = false i11 := (*uint16)(unsafe.Pointer(i1)) i22 := (*uint16)(unsafe.Pointer(i2)) // 32768 -\u0026gt; 0b10000000_00000000 fmt.Println(*i11, *i22) // 0 32768 // 4) ä¸Šé¢å‘ç°å°†å¸ƒå°”ç±»å‹èµ‹å€¼ä¸ºfalseä¼šå°†å†…å­˜çš„8ä¸ºbitå…¨éƒ¨è®¾ç½®ä¸º0ï¼Œä¹Ÿå°±æ˜¯85è¡Œä»£ç å¤„ // é‚£ä¹ˆå°†ä¸€ä¸ªæœ¬å°±æ˜¯å¸ƒå°”trueç±»å‹èµ‹å€¼ä¸ºtrueï¼Œå†…å­˜ä¸­æ˜¯å¦è®°å½•çš„å¤§å°ä¸º1ï¼Ÿ var b1 int = 12 bb := (*bool)(unsafe.Pointer(\u0026amp;b1)) *bb = true fmt.Println(*(*int)(unsafe.Pointer(bb))) // 1 // é€šè¿‡ä»£ç æµ‹è¯• å¸ƒå°”çš„èµ‹å€¼å°±æ˜¯æŠŠå†…å­˜ä¸­çš„æ•°å€¼falseæ”¹ä¸º0 trueæ”¹ä¸º1 æ€»ç»“ï¼š Goå†…å­˜å­—æ®µæ’åºæ˜¯ï¼Œä½å­—èŠ‚åœ¨å‰é«˜å­—èŠ‚åœ¨åã€‚ï¼ˆä¸åŒçš„ç¡¬ä»¶è®¾å¤‡å¯èƒ½ä¸åŒï¼‰ã€‚ æ¯”å¦‚33007äºŒè¿›åˆ¶å¦‚10000000_11101111ï¼Œåœ¨å†…å­˜ä¸­æ˜¯ç¬¬ä¸€ä¸ªå­—èŠ‚11101111ç¬¬äºŒä¸ªå­—èŠ‚10000000ã€‚ å¸ƒå°”ç±»å‹å 1å­—èŠ‚ï¼ˆ8bitï¼‰ï¼Œæ‰€æœ‰ä½éƒ½ä¸º0æ—¶è¡¨ç¤ºfalseï¼Œå¦åˆ™è¡¨ç¤ºtrueã€‚ å› æ­¤10000000_00000000è¿™ç§å½¢å¼è½¬boolç¬¬ä¸€ä¸ªå­—èŠ‚æ˜¯00000000è¿”å›falseã€‚ ä½¿ç”¨unsafeè½¬æ¢ç±»å‹ä»…ä»…æ˜¯æŠŠé¦–å­—èŠ‚è½¬boolçš„åœ°å€ã€‚ ä¹Ÿå°±æ˜¯ä¸Šé¢çš„33007ï¼ˆ10000000_11101111ï¼‰è½¬boolï¼ŒæŠŠ11101111è¿™ä¸ªç¬¬ä¸€ä¸ªå­—èŠ‚åœ°å€ç»™å¸ƒå°”å€¼ã€‚ å¸ƒå°”ç±»å‹åœ¨è¢«èµ‹å€¼æ—¶ï¼Œtrueä¼šä¿®æ”¹å†…å­˜å­˜å‚¨å€¼ä¸º1ï¼Œfalseä¼šä¿®æ”¹å­˜å‚¨å€¼ä¸º0ã€‚ æ•´æ•°ç±»å‹ æœ‰ç¬¦å·æ•´å‹ ç±»å‹ é•¿åº¦(B/å­—èŠ‚) èŒƒå›´(ç§‘å­¦è®¡æ•°) èŒƒå›´ é»˜è®¤å€¼ int8 1B (8bit) [-2^7, 2^7-1] [-128, 127] 0 int16 2B (16bit) [-2^15, 2^15-1] [-32768, 32767] 0 int32 4B (32bit) [-2^31, 2^31-1] [-2147483648, 2147483647] 0 int64 8B (64bit) [-2^63, 2^63-1] [-9223372036854775808, 9223372036854775807] 0 int ä¸ç³»ç»Ÿæœ‰å…³ï¼Œ32ä½ä¸‹4å­—èŠ‚ï¼Œ64ä½ä¸‹8å­—èŠ‚ 0 è¡¥ç ä¸æºç  æœ‰ç¬¦å·è´Ÿæ•°ç±»å‹è½¬äºŒè¿›åˆ¶ï¼Œè´Ÿæ•°æ•´å‹æ•°å€¼éƒ½æ˜¯é‡‡ç”¨è¡¥ç å½¢å¼ä¿å­˜ï¼Œå½“ç„¶æ­£æ•°çš„è¡¥ç å°±æ˜¯è‡ªå·±ã€‚ å…ˆæ˜¯å°†å¯¹åº”çš„æ­£æ•´æ•°è½¬æ¢æˆäºŒè¿›åˆ¶åã€‚ å¯¹äºŒè¿›åˆ¶å–åã€‚ ç„¶åå¯¹ç»“æœå†åŠ ä¸€ã€‚ è¡¥ç çš„è¿ç®—ï¼šä¸¤ä¸ªè¡¥ç ç›¸åŠ ï¼Œä¸äºŒè¿›åˆ¶åŠ æ³•ç›¸åŒï¼Œå’Œä»ç„¶æ˜¯è¡¥ç ï¼ˆè¡¥ç è®¡ç®—åå¯èƒ½å­˜åœ¨æº¢å‡ºæƒ…å†µï¼‰ è¡¥ç è½¬æºç ã€‚ æ­£æ•°ï¼šç¬¦å·ä½ä¸º0æ—¶ï¼Œå³è¡¥ç å°±æ˜¯æºç  è´Ÿæ•°ï¼šç¬¦å·ä½ä¸º1æ—¶ï¼Œå³è¡¥ç çš„è¡¥ç å°±æ˜¯æºç  # -42å­˜å‚¨å½¢å¼ï¼šå‡è®¾è¿™é‡Œæ˜¯int8ç±»å‹ 8ä½bitä½ # 1. 42è½¬äºŒè¿›åˆ¶ï¼Œ00101010 # 2. 00101010 å–å 11010101 # 3. 11010101åŠ ä¸€ï¼Œ11010101 + 00000001 = 11010110\tè¡¥ç  # æœ€ç»ˆ-42çš„äºŒè¿›åˆ¶è¡¨ç¤ºå½¢å¼ï¼Œ11010110 # 11010110 è¡¥ç è½¬æºç  # 1. æœ€é«˜ä½ä¸º1è¡¨ç¤ºè´Ÿæ•° # 2. 11010110 å–å 00101001 # 3. 00101001åŠ ä¸€ï¼Œ00101001 + 00000001 = 00101010\tæºç  # æ€»ç»“ï¼š- å·çš„æ“ä½œé€»è¾‘å°±æ˜¯ä¸Šé¢æ­¥éª¤2(å–å)å’Œæ­¥éª¤3(åŠ ä¸€) # æœ€é«˜ä½è¡¨ç¤ºç¬¦å·ä½ 0.æ­£æ•° 1.è´Ÿæ•° # å†…å­˜ä¸­éƒ½æ˜¯é‡‡ç”¨è¡¥ç å½¢å¼å­˜å‚¨çš„ 1 2 3 4 5 6 7 // éªŒè¯ -42 æ˜¯å¦æ˜¯ 11010110 var b0 int8 = -42 // i1 := uint8(b0) i1 := (*uint8)(unsafe.Pointer(\u0026amp;b0)) fmt.Printf(\u0026#34;%.8b\u0026#34;, *i1)\t// 11010110 ä¾‹å¦‚ï¼š-1æ˜¯11111111ï¼Œ127æ˜¯01111111ï¼Œæœ€é«˜ä½bitè¡¨ç¤ºç¬¦å·ä½ï¼Œ0è¡¨ç¤ºæ­£æ•°(+)ï¼Œ1è¡¨ç¤ºè´Ÿæ•°(-)ã€‚ # -1 è½¬äºŒè¿›åˆ¶ # 1 -\u0026gt; 00000001 # ~1 -\u0026gt; 11111110 å–å # +1\t-\u0026gt; 11111111 åŠ ä¸€ # 127 è½¬äºŒè¿›åˆ¶ # 127\t-\u0026gt; 01111111 -å·ï¼šæ“ä½œåœ¨æ•´å‹ä¸­çš„æ“ä½œæ­¥éª¤(å–å)ç„¶å(åŠ ä¸€)ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 // åœ¨time.Durationä¸­çš„String()æ–¹æ³•ä¸­æœ‰è¿™æ ·ä¸€æ®µä»£ç  // d ä¸ºint64ç±»å‹ï¼Œè¿™é‡Œæ­£æ˜¯åˆ©ç”¨äº†-(-42)=42, u=(-42) func (d Duration) String() string { // ... u := uint64(d) // è¿™é‡Œå¦‚æœæ˜¯è´Ÿæ•°ï¼Œåˆ™è½¬æ¢åä¸€å®šæ˜¯ä¸ªå¾ˆå¤§çš„æ•°å­— neg := d \u0026lt; 0 // negä¸ºtrueè¡¨ç¤ºæ˜¯è´Ÿæ•°ï¼Œä¸ºfalseè¡¨ç¤ºæ˜¯æ­£æ•°æˆ–0 if neg { u = -u // è¿™é‡Œå†æ¬¡æŒ‰ç…§è´Ÿæ•°å­˜å‚¨å½¢å¼ï¼Œæ­£æ•°çš„äºŒè¿›åˆ¶å–ååŠ 1ç­‰åˆ°æ­£æ•°ä¹Ÿå°±æ˜¯(-d) } // ... } // æ¯”å¦‚æˆ‘ä»¬ä½¿ç”¨ä¸Šé¢æ–¹æ³•å†™ä¸€ä¸ªabså–ç»å¯¹å€¼å‡½æ•°ï¼Œå¹¶è½¬æ¢æ— ç¬¦å·ç±»å‹ä¸ºæœ‰ç¬¦å·ç±»å‹ type i int64 func (i i) abs() uint64 { if i \u0026gt; 0 { return uint64(i) } return -uint64(i) } æ— ç¬¦å·æ•´å‹(unsigned) ç±»å‹ é•¿åº¦(B/å­—èŠ‚) èŒƒå›´ èŒƒå›´ é»˜è®¤å€¼ uint8 1B (8bit) [0, 2^8-1] [0, 255] 0 uint16 2B (16bit) [0, 2^16-1] [0, 65535] 0 uint32 4B (32bit) [0, 2^32-1] [0, 4294967295] 0 uint64 8B (64bit) [0, 2^64-1] [0, 18446744073709551615] 0 uint ä¸ç³»ç»Ÿæœ‰å…³ï¼Œ32ä½ä¸‹4å­—èŠ‚ï¼Œ64ä½ä¸‹8å­—èŠ‚ 0 æ— ç¬¦å·è½¬äºŒè¿›åˆ¶ é™¤äºŒå–ä½™ï¼Œç„¶åå€’åºæ’åˆ—ï¼Œé«˜ä½è¡¥é›¶ # ç¤ºä¾‹42è½¬äºŒè¿›åˆ¶ï¼Œæ­£æ•´æ•°è½¬äºŒè¿›åˆ¶ é™¤äºŒ æ±‚ä½™ æ’åºæ–¹å‘ åè¿›åˆ¶ 42 || 2 | 42 .... 42/2 ä½™ .... 0 ^ 0*2^0 = 0 |_______ + 2 | 21 .... 21/2 ä½™ .... 1 | 1*2^1 = 2 |_______ + 2 | 10 .... 10/2 ä½™ .... 0 | 0*2^2 = 0 |_______ + 2 | 5 .... 5/2 ä½™ .... 1 | 1*2^3 = 8 |________ + 2 | 2 .... 2/2 ä½™ .... 0 | 0*2^4 = 0 |________ + 1 .... 1/2 ä½™ .... 1 | 1*2^5 = 32 # 42 å¯¹åº”äºŒè¿›åˆ¶ä½ 00101010 -\u0026gt; 0*2^0 + 1*2^1 + 0*2^2 + 1*2^3 + 0*2^4 + 1*2^5 = 42 å…¶ä»–æ•´æ•°ç±»å‹ ç±»å‹ ç­‰ä»·äº é•¿åº¦(B/å­—èŠ‚) å¤‡æ³¨ é»˜è®¤å€¼ byte type byte = uint8 1B å­˜å‚¨ä¸€å­—èŠ‚å†…å®¹ 0 rune type rune = int32 4B å­˜å‚¨ä¸€å­—ç¬¦å†…å®¹(Unciodeç¼–ç ) 0 uintptr uint 4Bæˆ–8B åˆšå¥½èƒ½å­˜å‚¨å˜é‡åœ°å€ 0 1 2 3 4 5 6 7 // type byte = uint8 var b byte // é»˜è®¤å€¼ 0 // type rune = int32 var r rune // é»˜è®¤å€¼ 0 fmt.Printf(\u0026#34;b: %T\\n\u0026#34;, b)\t// b: uint8 fmt.Printf(\u0026#34;r: %T\\n\u0026#34;, r)\t// r: int32 æµ®ç‚¹æ•°ç±»å‹ ç±»å‹ æè¿° é»˜è®¤å€¼ float32 IEEE-754 32ä½æµ®ç‚¹å‹æ•°4å­—èŠ‚ï¼Œå¤§çº¦å­˜å‚¨å°æ•°ä½æ•°7ä½ï¼ˆåè¿›åˆ¶ç§‘å­¦è®¡æ•°æ³•n.xxx*e+10æƒ…å†µä¸‹ï¼‰ï¼Œè¿™é‡Œçš„7ä½æ˜¯xçš„ä½æ•° 0.0 float64 IEEE-754 64ä½æµ®ç‚¹å‹æ•°8å­—èŠ‚ï¼Œå¤§çº¦å­˜å‚¨å°æ•°ä½æ•°16ä½ï¼ˆåè¿›åˆ¶ç§‘å­¦è®¡æ•°æ³•n.xxx*e+10æƒ…å†µä¸‹ï¼‰ï¼Œè¿™é‡Œçš„16ä½æ˜¯xçš„ä½æ•° 0.0 IEEE-754 æµ®ç‚¹æ•°åœ¨å†…å­˜ä¸­å¦‚ä½•å­˜å‚¨ æµ®ç‚¹æ•°éœ€è¦å…ˆè½¬æ¢æˆäºŒè¿›åˆ¶æ‰èƒ½å­˜å‚¨åœ¨å†…å­˜ä¸­ï¼Œå› æ­¤æ‹†åˆ†æˆæ­£æ•°å’Œå°æ•°ï¼š å¯¹äºæ­£æ•°éƒ¨åˆ†ï¼š æŒ‰ç…§æœ‰ç¬¦å·è§„åˆ™è®¡ç®—å³å¯ï¼Œæ¯”å¦‚42æˆ–-42æ˜¯00101010ï¼Œç¬¦å·ä½åé¢å•ç‹¬å¤„ç†ã€‚ å¯¹äºå°æ•°éƒ¨åˆ†ï¼š å¯¹å°æ•°ç‚¹ä»¥åçš„æ•°ä¹˜ä»¥2ï¼Œå–ç»“æœçš„æ•´æ•°éƒ¨åˆ†(ä¸æ˜¯1å°±æ˜¯0)ï¼Œç„¶åå†ç”¨å°æ•°éƒ¨åˆ†å†ä¹˜ä»¥2ï¼Œå†å–ç»“æœçš„æ•´æ•°éƒ¨åˆ†ã€‚ ä»¥æ­¤ç±»æ¨ï¼Œç›´åˆ°å°æ•°éƒ¨åˆ†ä¸º0æˆ–è€…ä½æ•°å·²ç»å¤Ÿäº†å°±ç»“æŸã€‚ ç„¶åæŠŠå–çš„æ•´æ•°éƒ¨åˆ†æŒ‰å…ˆåæ¬¡åºæ’åˆ—ï¼Œå°±æ„æˆäº†äºŒè¿›åˆ¶å°æ•°éƒ¨åˆ†çš„åºåˆ—ã€‚ # å¦‚42.635648ï¼Œå¤„ç†å°æ•°éƒ¨åˆ†å°±æ˜¯0.635648 å°æ•°éƒ¨ä½ä¹˜2 = å–æ­£æ•°ä½ æ’åºæ–¹å‘ åè¿›åˆ¶ 0.6328125 || 0.635648 * 2 = 1.271296 ... å–æ­£æ•°ä½ ... 1 | 2^-1 1/2 0.5 0.271296 * 2 = 0.542592 ... å–æ­£æ•°ä½ ... 0 | 0 + 0.542592 * 2 = 1.085184 ... å–æ­£æ•°ä½ ... 1 | 2^-3 1/2^3 0.125 0.085184 * 2 = 0.170368 ... å–æ­£æ•°ä½ ... 0 | 0 0.170368 * 2 = 0.340736 ... å–æ­£æ•°ä½ ... 0 | 0 + 0.340736 * 2 = 0.681472 ... å–æ­£æ•°ä½ ... 0 | 0 0.681472 * 2 = 1.362944 ... å–æ­£æ•°ä½ ... 1 v 2^-7 1/2^7 0.0078125 ... ... # ç»„æˆäºŒè¿›åˆ¶ 1010001... -\u0026gt; 2^5 + 2^3 + 2^1 + 2^-1 + 2^-3 + 2^-7 # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - # å¦‚-0.1ï¼Œå¤„ç†å°æ•°éƒ¨åˆ†å°±æ˜¯0.1 å°æ•°éƒ¨ä½ä¹˜2 = å–æ­£æ•°ä½ æ’åºæ–¹å‘ åè¿›åˆ¶ 0.099609375 || 0.1 * 2 = 0.2 ... å–æ­£æ•°ä½ ... 0 | 0 0.2 * 2 = 0.4 ... å–æ­£æ•°ä½ ... 0 | 0 0.4 * 2 = 0.8 ... å–æ­£æ•°ä½ ... 0 | 0 0.8 * 2 = 1.6 ... å–æ­£æ•°ä½ ... 1 | 1/2^4 0.0625 0.6 * 2 = 1.2 ... å–æ­£æ•°ä½ ... 1 | 1/2^5 0.03125 0.2 * 2 = 0.4 ... å–æ­£æ•°ä½ ... 0 | 0 + 0.4 * 2 = 0.8 ... å–æ­£æ•°ä½ ... 0 | 0 0.8 * 2 = 1.6 ... å–æ­£æ•°ä½ ... 1 | 1/2^8 0.00390625 0.6 * 2 = 1.2 ... å–æ­£æ•°ä½ ... 1 | 1/2^9 0.001953125 0.2 * 2 = 0.4 ... å–æ­£æ•°ä½ ... 0 v 0 ... ... # ç»„æˆäºŒè¿›åˆ¶ 0001100110... ç„¶åæŠŠæ•´æ•°éƒ¨åˆ†è½¬äºŒè¿›åˆ¶å’Œå°æ•°éƒ¨åˆ†è½¬äºŒè¿›åˆ¶åŠ ä¸€èµ·ï¼Œå¦‚(101010.1010001...)ã€‚ æµ®ç‚¹æ•°æ˜¯å¦‚ä½•å­˜å‚¨åœ¨å†…å­˜ä¸­ æ¯”å¦‚ä¸Šé¢çš„101010.1010001...è½¬æ¢äºŒè¿›åˆ¶ç§‘å­¦è®¡æ•°æ³•è¡¨ç¤º1.010101010001... * 2^5ã€‚ åè¿›åˆ¶ äºŒè¿›åˆ¶ è®¡ç®—æ–¹å¼ äºŒè¿›åˆ¶ç§‘å­¦è®¡æ•°æ³•è¡¨ç¤º 3.5 11.1 3.5 = 2^1 + 2^0 + 2^-1 11.1 = 1.11 * 2^1 10.625 1010.101 10.625 = 2^3 + 2^1 + 2^-1 + 2^-3 1010.101 = 1.010101 * 2^3 0.6 0.10011001.. 0.6 = 2^-1 + 2^-4 + 2^-5 + 2^-8 .. 0.100110011001.. = 1.00110011001.. * 2^-1 ä»ä¸Šé¢å¯ä»¥è§‚å¯Ÿåˆ°ï¼Œå¯¹äºä»»ä½•æ•°æ¥è¯´ï¼Œè¡¨ç¤ºæˆäºŒè¿›åˆ¶ç§‘å­¦è®¡æ•°æ³•åï¼Œéƒ½å¯ä»¥è½¬æ¢æˆ1.xxx * 2^nå½¢å¼ã€‚ å¯¹äºè´Ÿæ•°æ¥è¯´ï¼Œåˆ™å¯ä»¥è¡¨ç¤ºæˆ-1.xxx * 2^nå½¢å¼ã€‚ æµ®ç‚¹æ•°çš„å­˜å‚¨å½¢å¼å¯ä»¥åˆ†ä¸ºä¸‰éƒ¨åˆ†ï¼š ç¬¦å·ä½ï¼ˆSï¼‰ å°¾æ•°(xxx)ï¼ˆMï¼‰ æŒ‡æ•°(n)ï¼ˆEï¼‰ æ ¹æ®æŒ‡æ•°åˆåˆ†ä¸ºä¸‰ç§ç±»å‹ï¼šè§„æ ¼æ•°(normal number)ã€éè§„æ ¼æ•°(subnormal number)ã€ç‰¹æ®Šæ•°(non-number)ã€‚ æŒ‡æ•°ä½ -\u0026gt; å…¨ä¸º0 ä¸å…¨ä¸º0ä¸”ä¸å…¨ä¸º1 å…¨ä¸º1 å¯¹åº”çš„æ•° -\u0026gt; éè§„æ ¼æ•°(subnormal number) è§„æ ¼æ•°(normal number) ç‰¹æ®Šæ•°(non-number) éè§„æ ¼æ•°(subnormal number)ï¼šæŒ‡æ•°ä½å…¨ä¸º0ï¼Œç”¨äºè¡¨ç¤º0æˆ–éå¸¸æ¥è¿‘0çš„æ•°ã€‚ è§„æ ¼æ•°(normal number)ï¼šæŒ‡æ•°ä½ä¸å…¨ä¸º0ä¸”ä¸å…¨ä¸º1ï¼Œç”¨äºè¡¨ç¤ºæ­£å¸¸çš„æ•°å€¼ã€‚ ç‰¹æ®Šæ•°(non-number)ï¼šæŒ‡æ•°ä½å…¨ä¸º1ï¼Œç”¨äºè¡¨ç¤ºÂ±infinityæˆ–NaNã€‚ åç§»é‡ï¼š\n4å­—èŠ‚æµ®ç‚¹æ•°çš„åç§»é‡ä¸º+127ï¼Œfloat32å­—èŠ‚çš„æŒ‡æ•°ä½æ˜¯å 8bitï¼Œæœ€å¤§å€¼255ã€‚ 8å­—èŠ‚æµ®ç‚¹æ•°çš„åç§»é‡ä¸º+1023ï¼Œfloat64å­—èŠ‚çš„æŒ‡æ•°ä½æ˜¯å 11bitï¼Œæœ€å¤§å€¼2047ã€‚ ä¸ºä½•åç§»é‡éƒ½å–ä¸€åŠä½œä¸ºä½¿ç”¨ï¼ŸåŸå› æ˜¯ä½œä¸ºæŒ‡æ•°nå­˜åœ¨è´Ÿæ•°æˆ–æ­£æ•°æƒ…å†µï¼ŒEæ˜¯åœ¨æ­¤åŸºç¡€ä¸ŠåšåŠ æ³•ã€‚ 7 è¡¨ç¤ºä¸º 00000111 0ä¸ºç¬¦å·ä½ï¼Œä»£è¡¨å®ƒæ˜¯ä¸€ä¸ªæ­£æ•°ã€‚ å¦‚æœæŠŠ 7 å’Œ +7 ç»Ÿä¸€åŠ ä¸Šåç§»é‡ 127ï¼Œé‚£ä¹ˆ 7 å°±å˜æˆ 134 ï¼ŒäºŒè¿›åˆ¶è¡¨ç¤ºä¸º 10000110ã€‚ -7å˜æˆ 120 ï¼ŒäºŒè¿›åˆ¶è¡¨ç¤ºä¸º 01111000ã€‚ ä¸¤è€…è¿›è¡Œæ¯”è¾ƒå¤§å°çš„æ—¶å€™ï¼Œè®¡ç®—æœºä¾¿æ— éœ€æ¯”è¾ƒä¸¤è€…çš„ç¬¦å·ä½ã€‚ å°¾æ•°ä½çš„å››ç§èˆå…¥æ–¹å¼ï¼šå› ä¸ºæµ®ç‚¹æ•°å¹¶ä¸èƒ½è¡¨ç¤ºæ‰€æœ‰çš„å®æ•°ï¼Œå› æ­¤ä¸ºäº†å°½é‡çš„é€¼è¿‘çœŸå®æ•°å­—æœ‰å¦‚ä¸‹èˆå…¥æ–¹å¼ã€‚\nå‘å¶èˆå…¥ï¼šè¿™æ˜¯æœ€å¸¸ç”¨çš„èˆå…¥æ–¹å¼ï¼Œä¹Ÿç§°ä¸ºâ€œå››èˆå…­å…¥äº”æˆåŒâ€ã€‚ å‘é›¶èˆå…¥ï¼šå³æœç€æ•°è½´é›¶ç‚¹æ–¹å‘èˆå…¥ï¼Œå³ç›´æ¥æˆªå°¾ã€‚ å‘ä¸Šèˆå…¥ï¼šå‘ç€æ•°è½´è¶Šå¤§çš„æ•°èˆå…¥ã€‚ å‘ä¸‹èˆå…¥ï¼šå‘ç€æ•°è½´è¶Šå°çš„æ•°èˆå…¥ã€‚ ä¸‹é¢ä»¥åè¿›åˆ¶ä¸ºä¾‹ï¼Œåˆ†æå‘å¶èˆå…¥ï¼š 1.40å°¾æ•°\u0026lt;=0.4ï¼Œç›´æ¥èˆå¼ƒï¼Œå€¼ä¸º1ã€‚ 1.60å°¾æ•°\u0026gt;=0.6ï¼Œå…¥ä½ï¼Œå€¼ä¸º2ã€‚ 1.5å°¾æ•°ä¸º0.5ï¼Œå‘å¶èˆå…¥ä¸º2ã€‚ 2.50å°¾æ•°ä¸º0.5ï¼Œå‘å¶èˆå…¥ä¸º2ã€‚ -1.50å°¾æ•°ä¸º0.5ï¼Œå‘å¶èˆå…¥ä¸º-2ã€‚ æ–¹å¼ 1.40 1.60 1.50 2.50 -1.50 å‘å¶èˆå…¥ 1 2 2 2 -2 å‘é›¶èˆå…¥ 1 1 1 2 -1 å‘ä¸‹èˆå…¥ 1 1 1 2 -2 å‘ä¸Šèˆå…¥ 2 2 2 3 -1 ç”¨RR\u0026hellip;RDD\u0026hellip;Dæ¥è¡¨ç¤ºä¸€ä¸ªäºŒè¿›åˆ¶å°æ•°ï¼ŒRè¡¨ç¤ºä¿ç•™ä½ï¼ŒDè¡¨ç¤ºèˆå»ä½ï¼Œé‚£ä¹ˆæœ‰ä»¥ä¸‹è§„åˆ™ï¼š DD\u0026hellip;D \u0026lt; 10\u0026hellip;0 -\u0026gt; ç›´æ¥èˆå» DD\u0026hellip;D \u0026gt; 10\u0026hellip;0 -\u0026gt; å‘ä¸Šèˆå…¥ DD\u0026hellip;D = 10\u0026hellip;0 -\u0026gt; å‘å¶æ•°èˆå…¥ï¼Œç»†åˆ™ï¼š RR\u0026hellip;R = XX\u0026hellip;0ï¼Œç›´æ¥èˆå» RR\u0026hellip;R = XX\u0026hellip;1ï¼Œå‘ä¸Šèˆå…¥ var f float64 = -0.1 è½¬æ¢æˆ 1.100110011001.. * 2^-4ï¼Œå°¾æ•°ä»¥1001é‡å¤ï¼Œå› æ­¤è¿›å…¥åŠ ä¸€ã€‚ æœ€åçš„å°¾æ•°ä¸º1001åŠ ä¸€ä¸º1010 var f float64 = -0.1 è½¬æ¢æˆ 1.100110011001.. * 2^-4ï¼Œå°¾æ•°ä»¥1001é‡å¤ï¼Œå› æ­¤è¿›å…¥åŠ ä¸€ã€‚ æœ€åçš„å°¾æ•°ä¸º1001åŠ ä¸€ä¸º1010 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // éªŒè¯ float32 å­˜å‚¨ 0.6 var b0 float32 = 0.6 i1 := (*uint32)(unsafe.Pointer(\u0026amp;b0)) fmt.Printf(\u0026#34;%b\u0026#34;, *i1)\t// 00111111 00011001 10011001 10011010 // float32æƒ…å†µä¸‹ï¼Œæœ€åä½“ç°äº† 11001 -\u0026gt; 11010 0èˆ1å…¥ // 0.6 -\u0026gt; 00111111000110011001100110011010 //-0.6 -\u0026gt; 10111111000110011001100110011010 // éªŒè¯ float64 å­˜å‚¨ -0.1 var b0 float64 = -0.1 i1 := (*uint64)(unsafe.Pointer(\u0026amp;b0)) // 10111111 10111001 10011001 10011001 10011001 10011001 10011001 10011010 fmt.Printf(\u0026#34;%b\u0026#34;, *i1)\t1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 // math/const.go æ–‡ä»¶ // Floating-point limit values. // Max is the largest finite value representable by the type. // SmallestNonzero is the smallest positive, non-zero value representable by the type. const ( // 2**127 * (2**24 - 1) / 2**23 == 2^128 - 2^104 == (2^127+...+2^0+1) - (2^103+...2^0+1) // 2^127 + 2^126 + ... + 2^104 == 1.11111111_11111111_1111111*2^127\tå®é™…å­˜å‚¨å­˜å‚¨ // 32bitå…¨éƒ¨å­˜å‚¨å¦‚ 0_11111110_11111111111111111111111 // 32ä¸ºè§„èŒƒæ•°çš„æŒ‡æ•°èŒƒå›´åœ¨[-126,127]ï¼Œå› ä¸ºæŒ‡æ•°å…¨é›¶ä¸ºå…¨å£¹è¡¨ç¤ºå…¶ä»–æ•°ï¼Œåç§»é‡127ï¼ŒæŒ‡æ•°æ–¹ä½[1,254] MaxFloat32 = 3.40282346638528859811704183484516925440e+38 // 2**127 * (2**24 - 1) / 2**23 // 1 / 2**(127 - 1 + 23) == 1.0 * 2^-149 == 0.00000000_00000000_0000010 * 2^-127 // 32bitå…¨éƒ¨å­˜å‚¨å¦‚ 0_00000000_00000000000000000000001\tè¿™é‡Œæ˜¯å› ä¸º0.çš„0ä¹Ÿè¢«å­˜å‚¨åˆ°å†…å­˜ä¸­äº†ï¼Œè¿™å°±æ˜¯å½“æŒ‡æ•°ä¸º0æ—¶æ˜¯ä¸€ç§ç‰¹æ®Šæƒ…å†µ // 2^-127 --\u0026gt; 0_00000000_1000000_00000000_00000000 // 2^-128 --\u0026gt; 0_00000000_0100000_00000000_00000000 // 2^-129 --\u0026gt; 0_00000000_0010000_00000000_00000000 // 2^-149 --\u0026gt; 0_00000000_0000000_00000000_00000001\tå½“æŒ‡æ•°å…¨ä¸º0æ—¶ï¼Œç³»æ•°ä»¥ 0. å¼€å¤´ SmallestNonzeroFloat32 = 1.401298464324817070923729583289916131280e-45 // 1 / 2**(127 - 1 + 23) MaxFloat64 = 1.797693134862315708145274237317043567981e+308 // 2**1023 * (2**53 - 1) / 2**52 SmallestNonzeroFloat64 = 4.940656458412465441765687928682213723651e-324 // 1 / 2**(1023 - 1 + 52) ) å¤æ•°ç±»å‹ å¤æ•°æ˜¯åœ¨æµ®ç‚¹æ•°çš„åŸºç¡€ä¸Šè¿›è¡Œå­˜å‚¨çš„ï¼Œé‚£ä¹ˆä¹Ÿå°±å¾ˆå¥½ç†è§£æµ®ç‚¹æ•°çš„å­˜å‚¨å½¢å¼ã€‚ complex64æ˜¯ç”±ä¸¤ä¸ªfloat32æ ¼å¼å½¢å¼ä¿å­˜çš„ï¼Œå› æ­¤å®éƒ¨å’Œè™šéƒ¨éƒ½æ˜¯float32å½¢å¼ä¿å­˜ï¼Œå…±å 8å­—èŠ‚ã€‚ complex128æ˜¯ç”±ä¸¤ä¸ªfloat64æ ¼å¼å½¢å¼ä¿å­˜çš„ï¼Œå› æ­¤å®éƒ¨å’Œè™šéƒ¨éƒ½æ˜¯float64å½¢å¼ä¿å­˜ï¼Œå…±å 16å­—èŠ‚ã€‚ ç±»å‹ é•¿åº¦ å†…å­˜å¯¹é½ complex64 32ä½æµ®ç‚¹æ•°æ„é€ å¤æ•° å 8å­—èŠ‚ 4B complex128 64ä½æµ®ç‚¹æ•°æ„é€ å¤æ•° å 16å­—èŠ‚ 8B 1 2 3 4 5 6 7 8 9 10 11 // complex64 ç­‰ä»·äº type clx64 struct { real float32 // å®æ•° 4Byte imag float32 // è™šæ•° 4Byte } // complex128 ç­‰ä»·äº type clx128 struct { real float64 // å®æ•° 8Byte imag float64 // è™šæ•° 8Byte } å£°æ˜å¤æ•°ï¼Œä»¥åŠreal()å’Œimag()å‡½æ•°ä½¿ç”¨ã€‚ 1 2 3 4 5 6 7 8 9 var c complex128 = 1.0 + 1i // %v ä»¥åŸå½¢å¼è¾“å‡º fmt.Printf(\u0026#34;value %v\u0026#34;, c) // value (1+1i) // complex()å‡½æ•°åˆ›å»º complex128ç±»å‹ cc := complex(2, -3) fmt.Printf(\u0026#34;value %v\u0026#34;, cc) // value (2-3i) // real()è·å–å¤æ•°å®éƒ¨ imag()å‡½æ•°è·å–å¤æ•°è™šéƒ¨ fmt.Println(real(cc), imag(cc))\t// 2 -3 éªŒè¯å¤æ•°çš„å†…å­˜å­˜å‚¨ç»“æ„ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 // complex64 ç±»å‹éªŒè¯ï¼Œæˆ‘ä»¬å‰é¢éªŒè¯è¿‡float32ç±»å‹çš„0.6æ ¼å¼è¿™é‡Œä¹Ÿä½¿ç”¨0.6 var b0 complex64 = 0.6 + 0.6i i1 := (*uint64)(unsafe.Pointer(\u0026amp;b0)) // 11111100011001100110011001101000111111000110011001100110011010 fmt.Printf(\u0026#34;%b\\n\u0026#34;, *i1)\t// 00111111000110011001100110011010 -\u0026gt; 0.6 å®éƒ¨ // 00111111000110011001100110011010 -\u0026gt; 0.6 è™šéƒ¨ // \u0026gt; ------------------------------------------------------------------ // complex128æ˜¯å 16å­—èŠ‚ var b0 complex128 = 0.6 - 0.6i i1 := (*float64)(unsafe.Pointer(\u0026amp;b0)) fmt.Println(*i1) // 0.6 i11 := (*uint64)(unsafe.Pointer(\u0026amp;b0)) // 0011111111100011001100110011001100110011001100110011001100110011 -\u0026gt; 0.6 å®éƒ¨ fmt.Printf(\u0026#34;%64b\\n\u0026#34;, *i11)\ti2 := (*float64)(unsafe.Pointer(uintptr(unsafe.Pointer(\u0026amp;b0)) + unsafe.Sizeof(uint64(0)))) fmt.Println(*i2) // -0.6 i22 := (*uint64)(unsafe.Pointer(uintptr(unsafe.Pointer(\u0026amp;b0)) + unsafe.Sizeof(uint64(0)))) // 1011111111100011001100110011001100110011001100110011001100110011 -\u0026gt; -0.6 è™šéƒ¨ fmt.Printf(\u0026#34;%64b\\n\u0026#34;, *i22)\tå­—ç¬¦ä¸²ç±»å‹ å­—ç¬¦ä¸²æ˜¯ä¸€ä¸²å›ºå®šé•¿åº¦çš„å­—ç¬¦è¿æ¥èµ·æ¥çš„å­—ç¬¦åºåˆ—ï¼Œå­—ç¬¦ä¸²æ˜¯ç”±å•ä¸ªå­—èŠ‚è¿æ¥èµ·æ¥çš„ï¼Œå­—èŠ‚ä½¿ç”¨UTF-8ç¼–ç æ ‡è¯†çš„Unicodeæ–‡æœ¬ã€‚ ç¼–è¯‘é˜¶æ®µå­—ç¬¦ä¸²å­˜å‚¨åœ¨åªè¯»æ•°æ®æ®µï¼Œæ‰€ä»¥å­—ç¬¦ä¸²åœ¨ç¡¬ä»¶åº•å±‚é˜»æ­¢è¢«ä¿®æ”¹ã€‚ ä½†æ˜¯åœ¨è¿è¡Œé˜¶æ®µå­—ç¬¦ä¸²åˆ™æ˜¯è¢«åˆ†é…åœ¨å †ä¸Šä½†æ˜¯ä¹Ÿä¸å…è®¸è¢«ä¿®æ”¹ï¼ŒåŸå› æ˜¯åœ¨è¯­è¨€å±‚é¢è¢«é˜»æ­¢çš„ï¼Œä½†æ˜¯æˆ‘ä»¬å¯ä»¥ä½¿ç”¨unsafeç»•è¿‡è¯­è¨€å±‚é¢è¿›è¡Œä¿®æ”¹ã€‚ é¦–å…ˆå­—ç¬¦ä¸²æ˜¯UTF-8ç¼–ç æ ‡è¯†çš„Unicodeæ–‡æœ¬ï¼Œéœ€è¦å…ˆäº†è§£Unicodeç¼–ç çš„å¤„ç†ï¼Œå†çœ‹Unicodeè½¬UTF-8ã€‚ éœ€è¦è®°ä½å­—ç¬¦çš„å­˜å‚¨å½¢å¼ã€‚ 1 2 3 4 5 6 type StringStruct struct { // å­˜å‚¨è”ç³»å†…å­˜çš„é¦–åœ°å€ï¼Œè¿™é‡Œä¹Ÿå°±æ˜¯[...]byteç±»å‹çš„æ•°ç»„ï¼Œè¿ç»­çš„å­—èŠ‚æ˜¯utf8ç¼–ç çš„æ•°æ® Data unsafe.Pointer // å­—ç¬¦ä¸²é•¿åº¦ Len uintptr } æ›´å¤šå…³äºå­—ç¬¦è®¨è®ºå‚çœ‹åé¢å­—ç¬¦ä¸²æ–‡æ¡£ã€‚ å¤åˆç±»å‹ æŒ‡é’ˆç±»å‹ï¼ˆpointerï¼‰ï¼Œä¹Ÿå°±æ˜¯å¦‚ *intã€*stringç­‰ç±»å‹ï¼Œå­˜å‚¨çš„æ˜¯åŸºç¡€ç±»å‹çš„å¼•ç”¨åœ°å€ã€‚ æ•°ç»„ç±»å‹ï¼ˆarrayï¼‰ï¼Œè¿ç»­å†…å­˜åˆ†å¸ƒå­˜å‚¨çš„ï¼Œå…¶æ•°ç»„é•¿åº¦ä¿å­˜åœ¨ç±»å‹ç»“æ„ä¸­ï¼Œè¿™ä¹Ÿå°±æ˜¯å¯¼è‡´ä¸åŒé•¿åº¦çš„ç›¸åŒç±»å‹çš„æ•°ç»„å±äºä¸åŒç±»å‹çš„åŸå› (ç±»å‹hashä¸åŒ)ã€‚ ç»“æ„ä½“ï¼ˆstructï¼‰ï¼Œè¿ç»­å†…å­˜åˆ†å¸ƒå­˜å‚¨çš„ã€‚ é€šé“ç±»å‹ï¼ˆchanï¼‰ï¼Œhchanç»“æ„ä½“çš„å¼•ç”¨åœ°å€ã€‚ å‡½æ•°ç±»å‹ï¼ˆfunctionï¼‰ï¼Œfuncvalç»“æ„ä½“çš„å¼•ç”¨åœ°å€ã€‚ åˆ‡ç‰‡ç±»å‹ï¼ˆsliceï¼‰ï¼Œç»“æ„ä¸å­—ç¬¦ä¸²çš„ç»“æ„å¤§ä½“ç›¸åŒåªå¤šäº†ä¸ªCapå­—æ®µå­˜å‚¨å®¹é‡ï¼Œå­˜å‚¨å½¢å¼å¤§ä½“ç›¸å½“ã€‚ æ¥å£ç±»å‹ï¼ˆinterfaceï¼‰ï¼Œefaceå’Œifaceç»“æ„ä½“çš„ ï¼Œå­˜å‚¨ç±»å‹å…ƒç´ æ•°æ®ã€åŠ¨æ€ç±»å‹ç›¸å…³ä¿¡æ¯ã€‚ å­—å…¸ç±»å‹ï¼ˆmapï¼‰ï¼Œhmapç»“æ„ä½“çš„å¼•ç”¨åœ°å€ã€‚ é”™è¯¯ç±»å‹ Goè¯­è¨€é¢„å®šä¹‰ç±»å‹ï¼Œä¹Ÿå°±æ˜¯ifaceç»“æ„ä½“ï¼Œéç©ºæ¥å£ç±»å‹ã€‚ é”™è¯¯ç±»å‹æ˜¯æ¥å£ï¼Œnilå€¼è¡¨ç¤ºæ— é”™è¯¯ã€‚ åªè¦å®ç°æ¥å£çš„æ–¹æ³•åŠç»§æ‰¿äº†è¯¥æ¥å£ã€‚ 1 2 3 4 // Erroræ¥å£ type error interface { Error() string } æ€»ç»“ æ•°ç»„(array)å’Œç»“æ„ä½“(struct)éƒ½æ˜¯èšåˆç±»å‹ï¼Œé•¿åº¦å›ºå®šã€‚ åˆ‡ç‰‡(slice)å’Œå­—å…¸(map)éƒ½æ˜¯åŠ¨æ€æ•°æ®ç»“æ„ï¼Œé•¿åº¦å¯å˜ã€‚ å‚è€ƒ æµ®ç‚¹æ•°å­˜å‚¨ ","permalink":"https://heliu.site/posts/golang/basic/type/","summary":"Golang å†…ç½®çš„åŸºæœ¬ç±»å‹ä»‹ç»ã€‚","title":"å†…ç½®ç±»å‹"},{"content":" å˜é‡åè®©ä½ èƒ½å¤ŸæŠŠç¨‹åºä¸­å‡†å¤‡ä½¿ç”¨çš„æ¯ä¸€æ®µæ•°æ®éƒ½èµ‹å€¼ç»™ä¸€ä¸ªç®€çŸ­ã€æ˜“äºè®°å¿†çš„åå­—ã€‚ å˜é‡å£°æ˜åŠä½¿ç”¨ å˜é‡çš„å®šä¹‰ 1 2 // å…³é”®å­— æ ‡è¯†ç¬¦ [ç±»å‹] = å€¼ var identifier [type] = value æ˜¾ç¤ºå£°æ˜å˜é‡ï¼šåœ¨å£°æ˜å˜é‡æ—¶æŒ‡å®šå˜é‡çš„ç±»å‹ã€‚ éšå¼å£°æ˜å˜é‡ï¼šåœ¨å£°æ˜å˜é‡æ—¶å¹¶æœªæŒ‡å®šå˜é‡çš„ç±»å‹ï¼Œè€Œæ˜¯åœ¨ç¼–è¯‘é˜¶æ®µç¼–è¯‘å™¨æ ¹æ®å˜é‡å€¼è‡ªåŠ¨åˆ¤æ–­ç±»å‹ã€‚ æ•´æ•°ç±»å‹(æ­£æ•°æˆ–è´Ÿæ•°ï¼Œåè¿›åˆ¶ã€åå…­è¿›åˆ¶ã€å…«è¿›åˆ¶ã€äºŒè¿›åˆ¶)ï¼šç¼–è¯‘å™¨ä¼šå…¨éƒ¨è¯†åˆ«ä¸ºintç±»å‹ï¼Œå¦‚ï¼švar a = 123ã€‚ å­—ç¬¦ä¸²ï¼šç¼–è¯‘å™¨è¯†åˆ«ä¸ºstringç±»å‹ï¼Œå¦‚ï¼švar b = \u0026quot;a1\u0026quot;ã€‚ æµ®ç‚¹æ•°ï¼šç¼–è¯‘å™¨è¯†åˆ«ä¸ºfloat64ç±»å‹ï¼Œå¦‚ï¼švar c = -1.0ã€‚ å¤æ•°ï¼šç¼–è¯‘å™¨è¯†åˆ«ä¸ºcomplecx128ç±»å‹ï¼Œå¦‚ï¼švar d = 1iã€‚ å­—ç¬¦ç±»å‹ï¼šç¼–è¯‘å™¨è¯†åˆ«ä¸ºrune (int32) ç±»å‹ï¼Œå¦‚ï¼švar e = 'a'ã€‚ å…¶ä»–ç±»å‹æ ¹æ®æƒ…å†µåˆ¤æ–­ï¼Œå¦‚ï¼švar f = map[string]int{}è¿™ä¸€å®šæ˜¯mapï¼Œå…¶ä»–ç±»ä¼¼ã€‚ 1 2 3 4 5 6 7 8 9 10 11 // æ˜¾å¼å£°æ˜ è®¾ç½®å€¼ // ç»“æ„ data=\u0026#34;hello world!\u0026#34; len=12 var name string = \u0026#34;hello world!\u0026#34;\tvar sex uint8 sex = 1 // æ˜¾å¼å£°æ˜ æœªè®¾ç½®å€¼ é»˜è®¤å–å€¼ \u0026#34;\u0026#34; var name string\t// éšå¼å£°æ˜ ç¼–è¾‘å™¨ä¼šè‡ªåŠ¨æ¨æ–­å˜é‡ç±»å‹ï¼Œè€Œå¸¸é‡åˆ™æ˜¯åœ¨ä¸Šä¸‹æ–‡ä¸­è½¬æ¢ var name = \u0026#34;hello\u0026#34;\t// ç³»ç»Ÿé»˜è®¤æ¨å¯¼ä¸ºstringç±»å‹ ç®€å•å£°æ˜ ç®€å•ç”³æ˜ä½¿ç”¨:=ï¼Œå½“å£°æ˜ä¸€ä¸ªå˜é‡æ—¶å½“å‰å˜é‡åœ¨å½“å‰ä½œç”¨åŸŸå†…æœªè¢«å£°æ˜è¿‡æ—¶ã€‚(åªèƒ½ç”¨äºå‡½æ•°å†…) 1 name := \u0026#34;hello\u0026#34; // ç³»ç»Ÿé»˜è®¤æ¨å¯¼string å¤šå˜é‡èµ‹å€¼ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // 1. ä¸åŒæ•°æ®ç±»å‹ // nameå’Œsexå˜é‡ï¼Œç¼–è¾‘å™¨é»˜è®¤æ¨å¯¼ä¸ºstringç±»å‹ // ageå˜é‡ï¼Œç¼–è¾‘å™¨é»˜è®¤æ¨æ–­ä¸ºintç±»å‹ var name, sex, age = \u0026#34;hello\u0026#34;, \u0026#34;ç”·\u0026#34;, 1 // 2. ç›¸åŒæ•°æ®ç±»å‹ï¼Œaã€bã€cå˜é‡éƒ½ä¸ºboolç±»å‹ var a, b, c bool a, b, c = false, true, false // 3. ä¸€èµ·å£°æ˜ var ( aa uint // æ•°å€¼ç±»å‹ é»˜è®¤å€¼ 0 bb string // å­—ç¬¦ä¸²ç±»å‹ é»˜è®¤å€¼ \u0026#34;\u0026#34; cc [3]int // æ•°ç»„ç±»å‹ é»˜è®¤å€¼ [0,0,0] ) // 4. æˆ–è€…åœ¨å‡½æ•°å†… // è¿™ç§å½¢å¼æ¯”è¾ƒç‰¹æ®Šï¼Œå½“å‰nameæˆ–sexæˆ–ageä¸­åªè¦æœ‰ä¸€ä¸ªå˜é‡åœ¨ã€å½“å‰ä½œç”¨åŸŸã€‘ä¸­æœªè¢«å£°æ˜è¿‡æ—¶æ‰èƒ½ä½¿ç”¨ // å…¶ä½™çš„å…¨éƒ¨é€€è¿˜ä¸ºèµ‹å€¼æ“ä½œï¼Œæ¯”è¾ƒå¸¸ç”¨çš„æ˜¯f, err := os.Open(\u0026#34;./t.txt\u0026#34;)è¿™é‡Œçš„errè¢«å¤šæ¬¡ä½¿ç”¨é€€åŒ–ä¸ºèµ‹å€¼æ“ä½œ name, sex, age := \u0026#34;hello\u0026#34;, \u0026#34;ç”·\u0026#34;, 1 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 // åœ¨ifçš„ä½œç”¨åŸŸä¸­æ—¶ï¼ˆè¿™é‡Œçš„bbå’Œerråœ¨è¯¥ä½œç”¨åŸŸä¸­éƒ½æ²¡æœ‰å£°æ˜è¿‡ï¼Œå› æ­¤é»˜è®¤ä¸ºå†…éƒ¨å˜é‡ï¼‰ if bb, err := tt(); err != nil { // bb declared and not used log.Println(err, bb) } // ç­‰ä»·äº { // ifçš„ä½œç”¨åŸŸå†…ï¼Œå£°æ˜bbå’Œerrã€å±€éƒ¨ã€‘å˜é‡ bb, err := tt() if err != nil { log.Println(err, bb) } } // \u0026gt; --------------------------------------------------------------- var bb byte = \u0026#39;a\u0026#39; // ä½œç”¨åŸŸå¤–çš„ bb å˜é‡ // è¿™é‡Œbbåœ¨ifå¤–ï¼Œè€Œerråœ¨ifå†…ä½œç”¨åŸŸï¼Œå› æ­¤ifå†…çš„bbä¼šç”Ÿæˆifå†…çš„å˜é‡è¦†ç›–å¤–å±‚bbå˜é‡ if bb, err := tt(); err != nil { // bb declared and not used log.Println(err, bb) // ä½œç”¨åŸŸå†…çš„ bb å˜é‡ } // ç­‰ä»·äº var bb byte = \u0026#39;a\u0026#39; { // ifçš„ä½œç”¨åŸŸå†…ï¼Œå£°æ˜bbå’Œerrã€å±€éƒ¨ã€‘å˜é‡ï¼Œå› ä¸ºåœ¨è¯¥ä½œç”¨åŸŸå†…éƒ½æ²¡æœ‰bbå’Œerrå˜é‡ bb, err := tt() if err != nil { log.Println(err, bb) } } æ€»ç»“ï¼Œ:=ä¼šåœ¨å½“å‰ä½œç”¨åŸŸå¯»æ‰¾å˜é‡ï¼Œå¦‚æœæ‰¾åˆ°åˆ™ä½¿ç”¨å®ƒï¼Œå¦‚æœæœªæ‰¾åˆ°åˆ™å£°æ˜ä¸€ä¸ªæ–°å˜é‡ã€‚ æ³¨æ„ï¼Œ:=å¿…é¡»è¦æ±‚å·¦è¾¹å­˜åœ¨è‡³å°‘ä¸€ä¸ªæœªå®šä¹‰çš„å˜é‡ã€‚:=åªèƒ½åœ¨å‡½æ•°å†…ä½¿ç”¨ã€‚ å˜é‡äº¤æ¢ 1 2 3 4 5 6 7 8 9 10 var a, b string = \u0026#34;world\u0026#34;, \u0026#34;hello\u0026#34; fmt.Println(a, b) // world hello // 1. äº¤æ¢å˜é‡å€¼ a, b = b, a fmt.Println(a, b) // hello world // 2. å˜é‡äº¤æ¢ç­‰ä»·äº temp := a a = b b = temp æ ‡è¯†ç¬¦ ç”±å­—æ¯ã€æ•°å­—ã€ä¸‹åˆ’çº¿ï¼ˆ_ï¼‰ç»„æˆï¼Œå…¶ä¸­é¦–å­—ç¬¦ä¸èƒ½ä¸ºæ•°å­—ï¼ŒåŒºåˆ†å¤§å°å†™ï¼ˆåŒä¸€å­—æ¯çš„å¤§å°å†™ä»£è¡¨ä¸åŒçš„æ ‡è¯†ï¼‰ã€‚ Goè¯­è¨€è§„èŒƒï¼š æ ‡è¯†ç¬¦ï¼šå‘½åç¨‹åºå®ä½“ï¼Œå¦‚å˜é‡åå’Œç±»å‹åã€‚ æ ‡è¯†ç¬¦æ˜¯ä¸€ä¸ªæˆ–å¤šä¸ªUnicodeå­—æ¯å’Œæ•°å­—çš„åºåˆ—ã€‚ æ ‡è¯†ç¬¦ä¸­çš„ä¸€ä¸ªå­—ç¬¦å¿…é¡»æ˜¯Unicodeå­—æ¯ï¼ˆä¸‹åˆ’çº¿_ä¹Ÿè¢«è®¤ä¸ºæ˜¯å­—æ¯ï¼‰ã€‚ identifiter = letter {letter | unicode_digit} letter = unicode_letter | _ï¼šletter åŒ…å«å­—æ¯ï¼ˆåŒ…æ‹¬é™¤è‹±æ–‡å­—æ¯ä»¥å¤–çš„å­—æ¯ï¼‰å’Œä¸‹åˆ’çº¿ã€‚ unicode_digit = 0 1 2 3 4 5 6 7 8 9ï¼šæ•°å­—ï¼ˆè¿™é‡Œä¹ŸåŒ…æ‹¬é™¤é˜¿æ‹‰ä¼¯æ•°å­—ä»¥å¤–çš„æ•°å­—ï¼‰ã€‚ åœ¨Goè¯­è¨€ä¸­ï¼Œå‘½åæ ‡è¯†ç¬¦æ—¶ï¼Œé€šå¸¸é€‰æ‹©è‹±æ–‡çš„52ä¸ªå¤§å°å†™å­—æ¯ä»¥åŠæ•°å­—0~9å’Œä¸‹åˆ’çº¿æ¥ç»„åˆæˆåˆé€‚çš„æ ‡è¯†ç¬¦ã€‚ 1 2 3 4 5 6 7 8 9 10 // Goè¯­è¨€å˜é‡å£°æ˜ä½¿ç”¨å…³é”®å­— var // ä¸‹é¢è¿™ç§å½¢å¼ å¤šç”¨äºå®šä¹‰å…¨å±€å˜é‡ï¼Œé€šå¸¸åœ¨å‡½æ•°å¤–è¢«å®šä¹‰ var ( a int b bool str string æµ®ç‚¹ float32\t// ä¸­æ–‡ä¹Ÿå¯ä»¥ä½œä¸ºå˜é‡æ ‡è¯†ç¬¦ï¼Œåœ¨Unicodeé‡Œçš„å­—ç¬¦éƒ½èƒ½ ) var a, b int å…³é”®å­— Goè¯­è¨€ä¸­å…³é”®å­—æ˜¯ä¿ç•™å­—ï¼Œä¸èƒ½ä½œä¸ºå˜é‡æ ‡è¯†ç¬¦ï¼Œå…³é”®å­—ä¸€å…±æœ‰25ä¸ªã€‚ Go å…³é”®å­— breakï¼šç”¨äºè·³å‡ºforå¾ªç¯ï¼Œè·³å‡ºswitchå’Œselectå—ã€‚ switchå’Œselectéƒ½é»˜è®¤è‡ªå¸¦breakï¼ˆå¦‚æœå†™äº†breaké»˜è®¤è·³å‡ºå½“å‰å—ï¼‰ã€‚ continueï¼šç”¨äºforå¾ªç¯ï¼Œè¡¨ç¤ºç»“æŸæœ¬æ¬¡å¾ªç¯ç»§ç»­ä¸‹æ¬¡å¾ªç¯ã€‚ defaultï¼šç”¨äºswitchå’Œselectç»“æ„çš„é»˜è®¤åˆ†æ”¯ï¼Œå½“æ‰€æœ‰caseéƒ½ä¸æ»¡è¶³æ—¶æ‰§è¡Œdefaultåˆ†æ”¯ã€‚ funcï¼šç”¨äºå®šä¹‰å‡½æ•°æˆ–æ–¹æ³•æˆ–å‡½æ•°ç±»å‹å˜é‡ã€‚ interfaceï¼šç”¨äºå®šä¹‰æ¥å£ç±»å‹ã€‚ selectï¼šé€‰æ‹©ç»“æ„ï¼Œä¸»è¦ç”¨äºchanç±»å‹åœ¨ï¼Œæ³¨æ„åœ¨selectä¸­ä¸èƒ½ä½¿ç”¨å…³é”®å­—fallthroughã€‚ caseï¼šç”¨äºselectå’Œswitchå…³é”®å­—ä¸­ï¼Œè¡¨ç¤ºä¸€ä¸ªåˆ†æ”¯å—ã€‚ deferï¼šä¸»è¦ç”¨äºfuncå…³é”®å­—å®šä¹‰çš„å‡½æ•°å’Œæ–¹æ³•ä½“ä¸­ï¼Œè¡¨ç¤ºå½“å‰è¯­å¥åœ¨å‡½æ•°é€€å‡ºæ—¶æ‰§è¡Œã€‚ goï¼šä¸»è¦ç”¨äºåˆ›å»ºä¸€ä¸ªgoroutineæ”¾å…¥Pä¸­ç­‰å¾…è¢«çº¿ç¨‹è°ƒç”¨ï¼Œè¿™ä¹Ÿæ˜¯åˆ›å»ºåç¨‹çš„å…³é”®ã€‚ mapï¼šç”¨äºå®šä¹‰å­—å…¸ç±»å‹ã€‚ structï¼šç”¨äºå®šä¹‰ç»“æ„ä½“ç±»å‹ã€‚ chanï¼šç”¨äºå®šä¹‰é€šé“ç±»å‹ï¼Œchançš„ä¸»è¦ä½œç”¨æ˜¯åœ¨å„ä¸ªgoroutineé—´é€šä¿¡çš„é€šé“ã€‚ elseï¼šä¸ifå…³é”®å­—é…åˆä½¿ç”¨ï¼Œå½“ä¸Šé¢æ‰€æœ‰æ¡ä»¶éƒ½ä¸æ»¡è¶³æ—¶é»˜è®¤æ‰§è¡Œelseåˆ†æ”¯çš„ä»£ç å—ã€‚ gotoï¼šè·³è½¬è¯­å¥ï¼Œé…åˆæ ‡ç­¾èƒ½ä»»æ„è·³è½¬åˆ°æŒ‡å®šä»£ç å¤„ï¼Œå¤šåœ¨å‡½æ•°å†…ä½¿ç”¨ã€‚ packageï¼šç”¨äº.goæ–‡ä»¶çš„åŒ…å£°æ˜ï¼Œå¤šç”¨äº.goæ–‡ä»¶çš„ç¬¬ä¸€è¡Œä»£ç ã€‚ switchï¼šé€‰æ‹©åˆ†æ”¯ç»“æ„ï¼Œå¸¸ä¸caseã€defaultã€fallthroughä¸€èµ·ä½¿ç”¨ã€‚ constï¼šç”¨äºå®šä¹‰å¸¸é‡ã€‚ fallthroughï¼šç”¨äºswitchçš„caseå—ä¸­ï¼Œè¡¨ç¤ºç»§ç»­è¿è¡Œä¸‹ä¸€ä¸ªcaseå—ä»£ç è€Œä¸æ£€æŸ¥æ˜¯å¦æ»¡è¶³æ¡ä»¶ã€‚ è¯¥å…³é”®å­—å¤šç”¨äºè¿ç§»å…¶ä»–è¯­è¨€ä»£ç å…¼ç”¨ä½¿ç”¨ï¼Œæ­£å¸¸å¼€å‘ä¸­ä¸å»ºè®®ä½¿ç”¨ã€‚ ifï¼šåˆ†æ”¯é€‰æ‹©ç»“æ„å¤šä¸elseæˆ–else ifä¸€èµ·ä½¿ç”¨ã€‚ rangeï¼šä¸forå…³é”®å­—ä¸€èµ·ä½¿ç”¨ï¼Œä»sliceã€mapã€stringã€arrayã€chanç­‰ä¸­è¿­ä»£å…ƒç´ ã€‚ æ³¨æ„rangeä¼šæ‹·è´sliceã€arrayéœ€è¦è¿­ä»£çš„é›†åˆå‰¯æœ¬ï¼Œä»¥ä¾¿äºåŸé›†åˆåŒºåˆ†ã€‚ typeï¼šå¤šç”¨äºå®šä¹‰ç±»å‹å…³é”®å­—ã€‚ forï¼šç”¨äºå¼€å§‹ä¸€ä¸ªå¾ªç¯ã€‚ importï¼šå¯¼å…¥å…¶ä»–åŒ…æ–‡ä»¶å…³é”®å­—ã€‚ returnï¼šç”¨äºå‡½æ•°æˆ–æ–¹æ³•ä¸­ï¼Œè¡¨ç¤ºç»“æŸå½“å‰å‡½æ•°å¹¶è¿”å›ç»™å®šå€¼ã€‚ åœ¨æ²¡æœ‰è¿”å›å€¼çš„å‡½æ•°ä¸­ä¹Ÿå¯ä»¥ä½¿ç”¨returnæ¥è¿”å›å‡½æ•°ã€‚ varï¼šç”¨äºå®šä¹‰å˜é‡çš„å…³é”®å­—ã€‚ æ³¨æ„äº‹é¡¹ å˜é‡å¿…é¡»å…ˆå®šä¹‰æ‰èƒ½ä½¿ç”¨ï¼Œå˜é‡çš„ç±»å‹å’Œèµ‹å€¼çš„ç±»å‹å¿…é¡»ä¸€è‡´ã€‚ å˜é‡åä¸èƒ½å†²çªï¼ˆåŒä¸€ä¸ªä½œç”¨åŸŸå†…ä¸èƒ½å†²çªï¼‰ã€‚ ç®€çŸ­å®šä¹‰æ–¹å¼ï¼Œåªèƒ½åœ¨å‡½æ•°å†…è¢«å®šä¹‰ã€‚ åŒä¸€ä¸ªä½œç”¨åŸŸä¸­ï¼Œå·²å­˜åœ¨åŒåçš„å˜é‡ï¼Œåˆ™ä¹‹åçš„å£°æ˜åˆå§‹åŒ–ï¼Œåˆ™é€€åŒ–ä¸ºèµ‹å€¼æ“ä½œã€‚ å‰ææ˜¯ï¼Œæœ€å°‘è¦æœ‰ä¸€ä¸ªæ–°çš„å˜é‡è¢«å®šä¹‰ï¼Œä¸”åœ¨åŒä¸€ä½œç”¨åŸŸã€‚ å˜é‡å®šä¹‰äº†å¦‚ä¸ä½¿ç”¨ç¼–è¯‘é€šä¸è¿‡ã€‚ 1 2 3 4 5 6 x := 12 // å®šä¹‰å˜é‡xé»˜è®¤æ¨å¯¼ä¸ºintç±»å‹ x, y = 1, \u0026#34;hello\u0026#34; // å˜é‡xé‡æ–°èµ‹å€¼ä¸º1ï¼Œ å®šä¹‰å˜é‡yé»˜è®¤æ¨å¯¼ä¸ºstringç±»å‹ // è¿™ç§æƒ…å†µç»å¸¸å‡ºç°åœ¨æ¥æ”¶é”™è¯¯æƒ…å†µä¸‹ï¼Œç¬¬äºŒä¸ªerrå˜é‡é€€åŒ–ä¸ºèµ‹å€¼æ“ä½œ file1, err := os.Open(\u0026#34;a.txt\u0026#34;) // åœ¨å½“å‰ä½œç”¨åŸŸå£°æ˜file1å’Œerrå˜é‡ file2, err := os.Open(\u0026#34;b.txt\u0026#34;) // å½“å‰ä½œç”¨åŸŸå·²æœ‰errå˜é‡ç›´æ¥ä½¿ç”¨ï¼Œå£°æ˜file2å˜é‡ ä½œç”¨åŸŸ åœ¨é¡¶å±‚å£°æ˜çš„å¸¸é‡ï¼ˆå¦‚const a int = 1ï¼‰ï¼Œç±»å‹ï¼ˆå¦‚type a intï¼‰ï¼Œå˜é‡ï¼ˆå¦‚var a = 1ï¼‰å‡½æ•°çš„æ ‡è¯†ç¬¦ï¼ˆå¦‚func name() intï¼‰çš„èŒƒå›´æ˜¯åŒ…å—ã€‚ å¯¼å…¥åŒ…åç§°èŒƒå›´æ˜¯åŒ…å«å¯¼å…¥å£°æ˜çš„æ–‡ä»¶çš„æ–‡ä»¶å—ã€‚ å¯¼å…¥åŒ…åç§°èŒƒå›´æ˜¯åŒ…å«å¯¼å…¥å£°æ˜çš„æ–‡ä»¶çš„æ–‡ä»¶å—ã€‚ åœ¨å‡½æ•°å†…å£°æ˜çš„å¸¸é‡æˆ–å˜é‡æ ‡è¯†ç¬¦çš„èŒƒå›´ä»å£°æ˜è¯­å¥çš„æœ«å°¾å¼€å§‹ï¼Œåˆ°æœ€å†…å±‚åŒ…å«å—çš„æœ«å°¾ç»“æŸã€‚ åœ¨å‡½æ•°å†…å£°æ˜çš„ç±»å‹æ ‡è¯†ç¬¦çš„èŒƒå›´ä»æ ‡è¯†ç¬¦å¼€å§‹ï¼Œåˆ°æœ€å†…å±‚åŒ…å«å—çš„æœ«å°¾ç»“æŸã€‚ å—ä¸­å£°æ˜çš„æ ‡è¯†ç¬¦å¯ä»¥åœ¨å†…éƒ¨å—ä¸­é‡æ–°å£°æ˜ã€‚ ä½œç”¨åŸŸå°±ç±»ä¼¼ä¸€æ£µæ ‘ç»“æ„ï¼Œè€Œæ¯ä¸ªæ ‘æç›¸å½“äºå—ï¼Œåœ¨æ ‘å¹²å®šä¹‰çš„å˜é‡èƒ½è¢«è¿™ä¸ªæ ‘å¹²åˆ†æˆå‡ºçš„æ ‘ææˆ–æ ‘æçš„æ ‘æä½¿ç”¨ï¼Œè€Œåœ¨æ ‘æä¸­é‡å¤å®šä¹‰æ ‘å¹²çš„å˜é‡åˆ™ä¼šå±è”½è°ƒæ ‘å¹²å®šä¹‰çš„å˜é‡ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 package main import ( \u0026#34;fmt\u0026#34; ) // å…¨å±€å˜é‡ var x int = 10 // ---------- å‡è®¾å…¨å±€ä½œç”¨åŸŸå°±æ˜¯æ ‘å¹²ç¼–å·SU01 func main() { fmt.Println(x) // 10\t// å±€éƒ¨å˜é‡ x := 1 // ---------- è€Œåœ¨mainå‡½æ•°ä¸­çš„å±€éƒ¨å˜é‡å°±SU01çš„æ ‘æSZ01 fmt.Println(x) // 1 // å±€éƒ¨å— { fmt.Println(x) // 1 // å±€éƒ¨å˜é‡ x := 2 // ---------- è€Œåœ¨SZ01å®šä¹‰çš„å—åŠæ˜¯SZ01çš„æ ‘æSZ02 fmt.Println(x) // 2 } fmt.Println(x) // 1 // Output: // 10 // 1 // 1 // 2 // 1 } æœªä½¿ç”¨çš„å˜é‡ æœªä½¿ç”¨çš„å…¨å±€å˜é‡ç¼–è¯‘ä¸ä¼šæŠ¥é”™ã€‚ å‡½æ•°å†…æœªä½¿ç”¨å®šä¹‰çš„å˜é‡ç¼–è¯‘ä¼šæŠ¥é”™ï¼Œimportå¯¼å…¥çš„åŒ…ï¼Œæœªä½¿ç”¨ç¼–è¯‘ä¼šæŠ¥é”™ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 package main import ( //\u0026#34;fmt\u0026#34; // 1. æœªä½¿ç”¨çš„importåŒ…ï¼Œç¼–è¯‘ä¼šæŠ¥é”™ ) var x int = 10 // æœªä½¿ç”¨çš„å…¨å±€å˜é‡ç¼–è¯‘ä¸ä¼šæŠ¥é”™ func main() { // 2. å‡½æ•°å†…æœªä½¿ç”¨çš„å˜é‡ç¼–è¯‘ä¼šæŠ¥é”™ x := 1\t// 10:2: x declared and not used } ä¸‹åˆ’çº¿ _ ï¼šæ˜¯ç‰¹æ®Šæ ‡è¯†ç¬¦ï¼Œç”¨æ¥å¿½ç•¥ç»“æœã€‚è¯¥å˜é‡æ˜¯åªå†™ï¼Œå¹¶ä¸”æ˜¯ç³»ç»Ÿå®šä¹‰å¥½çš„å˜é‡ï¼Œå¯ä»¥éšæ„ä½¿ç”¨ä¸åˆ†ä½œç”¨åŸŸã€‚ ä¸‹åˆ’çº¿åœ¨importä¸­ importï¼šå¯¼å…¥å…¶ä»–packageåŒ…æ–‡ä»¶ã€‚ å½“å‰ _ ç”¨äº import ä¸­ï¼Œä»…ä»…æ˜¯ä¸ºäº†è°ƒç”¨ init() å‡½æ•°ï¼Œæ‰€ä»¥æ— æ³•é€šè¿‡åŒ…åæ¥è°ƒç”¨åŒ…ä¸­çš„å…¶ä»–å‡½æ•°å’Œå…¨å±€å˜é‡ã€‚ é¡¹ç›®ç›®å½•ç»“æ„å¦‚ä¸‹ï¼š srcç›®å½• | +--- main.go | +--- helloç›®å½• | +--- hello.go 1 2 3 4 5 6 7 8 9 10 11 // ./src/main.go æ–‡ä»¶ package main import _ \u0026#34;./hello\u0026#34; // è¿™é‡Œå¯¼å…¥ä½¿ç”¨ä¸‹åˆ’çº¿ func main() { // hello.Print() // ç¼–è¯‘æŠ¥é”™ï¼š./main.go:6:5: undefined: hello // Output: // imp-init() come here. } 1 2 3 4 5 6 7 8 9 10 11 12 // ./src/hello/hello.go æ–‡ä»¶ package hello import \u0026#34;fmt\u0026#34; func init() { fmt.Println(\u0026#34;imp-init() come here.\u0026#34;) } func Print() { fmt.Println(\u0026#34;Hello!\u0026#34;) } å…¶ä»–ç¤ºä¾‹ 1 2 3 4 5 6 7 import \u0026#34;database/sql\u0026#34; import _ \u0026#34;github.com/go-sql-driver/mysql\u0026#34; // ç¬¬äºŒä¸ªimportå°±æ˜¯ä¸ç›´æ¥ä½¿ç”¨mysqlåŒ… // 1. åªæ˜¯æ‰§è¡Œä¸€ä¸‹è¿™ä¸ªåŒ…çš„initå‡½æ•° // 2. æŠŠmysqlçš„é©±åŠ¨æ³¨å†Œåˆ°sqlåŒ…é‡Œ // 3. ç„¶åç¨‹åºé‡Œå°±å¯ä»¥ä½¿ç”¨sqlåŒ…æ¥è®¿é—®mysqlæ•°æ®åº“äº† ä¸‹åˆ’çº¿å½“åšå˜é‡ä½¿ç”¨ _ ï¼šå½“åšå˜é‡ä½¿ç”¨ï¼Œè¡¨ç¤ºä¸¢å¼ƒï¼Œæ˜¯åªå†™å˜é‡ï¼Œä¸èƒ½è¯»å–ã€‚ ä¸‹åˆ’çº¿ç”¨ä½œåˆ¤æ–­åˆ‡ç‰‡ä¸‹æ ‡æ˜¯å¦è¶Šç•Œæ—¶ï¼Œ_ = a[3]ï¼Œæœ‰åŠ©äºå¸®åŠ©ç¼–è¯‘å™¨è¿›è¡Œè¾¹ç•Œè¶Šç•Œæ£€æŸ¥ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 package main import ( \u0026#34;os\u0026#34; ) func main() { buf := make([]byte, 1024) // os.Open æ‰“å¼€æ–‡ä»¶ è¿”å›æ–‡ä»¶å¥æŸ„ *os.File å’Œé”™è¯¯ç±»å‹ error f, _ := os.Open(\u0026#34;/Users/***/Desktop/text.txt\u0026#34;) // _è¡¨ç¤ºæŠ›å¼ƒå‡½æ•°è¿”å›çš„err defer f.Close() for { n, _ := f.Read(buf) if n == 0 { break } os.Stdout.Write(buf[:n]) } } ä¸‹åˆ’çº¿åœ¨ç¼–è¯‘åŸç†ä¸­ åœ¨ç¼–è¯‘åŸç†ä¸­è¯­æ³•åˆ†æä¸­ï¼Œåˆ†æconst ()å…³é”®å­—åŒºåˆ†ç»„æ—¶å­˜åœ¨è¿™æ ·ç»“æ„ã€‚ 1 2 3 4 // å–åœ°å€ è¡¨ç¤ºä¸€ç±»åˆ†ç»„åœ°å€ type Group struct { _ int } æ€»ç»“ ä¸‹åˆ’çº¿ç”¨åœ¨importä¸­ï¼Œä»…ä»…æ˜¯æ‰§è¡Œå¯¼å…¥åŒ…çš„æ‰€æœ‰init()å‡½æ•°ã€‚ ä¸‹åˆ’çº¿åœ¨å˜é‡ä¸­ï¼Œè¡¨ç¤ºæŠ›å¼ƒè¯¥å€¼ï¼š ä¸å ç”¨å‘½åç©ºé—´ï¼Œä¸ä¼šåˆ†é…å†…å­˜ã€‚ å¤šæ¬¡ä½¿ç”¨ä¸å­˜åœ¨é‡å¤å£°æ˜é—®é¢˜ã€‚ å¾ˆå¤šæ—¶å€™_ç”¨äºå ä½ï¼Œè¡¨ç¤ºå¿½ç•¥å€¼ã€‚ æˆ‘ä»¬å¯ä»¥æŠŠ_å½“åšæ˜¯ä¸€ä¸ªç³»ç»Ÿå·²ç»å£°æ˜çš„å…¨å±€åªå†™å˜é‡ï¼Œç›´æ¥ä½¿ç”¨å³å¯ï¼Œä¸éœ€è¦åƒ_ := aè¿™ç§å½¢å¼ å‚è€ƒ ä¸ºä»€ä¹ˆæŒ‡é’ˆè¢«èª‰ä¸º C è¯­è¨€çµé­‚ï¼Ÿï¼Œå…³äºæŒ‡é’ˆã€‚ ","permalink":"https://heliu.site/posts/golang/basic/variable/","summary":"Golang å˜é‡çš„å£°æ˜åŠä½¿ç”¨ã€‚","title":"å˜é‡"},{"content":"å¸¸é‡çš„å®šä¹‰åŠä½¿ç”¨ å¸¸é‡æ˜¯ä¸€ä¸ªç®€å•çš„æ ‡è¯†ç¬¦ï¼Œè¿è¡Œæ—¶ä¸ä¼šè¢«ä¿®æ”¹ï¼Œæ²¡ä½¿ç”¨çš„å¸¸é‡åœ¨ç¼–è¯‘æ—¶å€™ä¸ä¼šæŠ¥é”™ï¼ˆå…¨å±€å˜é‡æœªä½¿ç”¨ä¹Ÿä¸ä¼šæŠ¥é”™ï¼‰ã€‚ å¸¸é‡åœ¨å…¶ä»–è¯­è¨€ä¸€èˆ¬å»ºè®®ä½¿ç”¨å…¨å¤§å†™å­—æ¯ï¼Œä½†æ˜¯åœ¨ Go ä¸­å¤§å†™å­—æ¯å¼€å¤´çš„è¡¨ç¤ºå¯å¯¼å‡ºã€‚ å¸¸é‡ä¸­çš„æ•°æ®ç±»å‹åªå¯ä»¥æ˜¯å¸ƒå°”å‹(bool)ã€æ•°å€¼å‹ï¼ˆæ•´æ•°å‹ã€æµ®ç‚¹å‹ã€å¤æ•°ï¼‰å’Œå­—ç¬¦ä¸²å‹(string)ï¼Œä¸èƒ½æ˜¯å¤åˆç±»å‹ã€‚ ä¸èƒ½è·å–å¸¸é‡çš„åœ°å€ï¼ˆä¹Ÿæ²¡å¿…è¦ï¼‰ï¼Œå¦‚ \u0026amp;aï¼Œaä¸ºå¸¸é‡ï¼Œå¸¸é‡é€šå¸¸æ˜¯ä¸ä»£ç ä¸€èµ·è¢«ä¿å­˜åœ¨ä»£ç æ®µã€‚ å­—ç¬¦ä¸²å•ä¸ªå­—ç¬¦ä¹Ÿä¸èƒ½å–åœ°å€å¦‚\u0026amp;s[0](sä¸ºstringç±»å‹)ï¼Œå­—ç¬¦ä¸²æ˜¯åªè¯»ç±»å‹ï¼Œåœ¨è¯­è¨€å±‚é¢é˜»æ­¢ã€‚ æ³¨æ„å­—ç¬¦ä¸²\u0026amp;så’Œ\u0026amp;s[0]ä»£è¡¨çš„ä¸æ˜¯åŒä¸€ä¸ªåœ°å€çš„åŒºåˆ«ã€‚ å­—å…¸çš„å•ä¸ªkeyä¹Ÿä¸èƒ½å–åœ°å€\u0026amp;m[\u0026quot;o\u0026quot;](mä¸ºmapç±»å‹)ï¼Œå­—å…¸ä½¿ç”¨å“ˆå¸Œæ¡¶å½¢å¼å­˜å‚¨ï¼Œä¸€ä¸ªæ¡¶å­˜8ä¸ªkey-valueã€‚ å¸¸é‡çš„å®šä¹‰ const identifier [type] = value constï¼šå®šä¹‰å¸¸é‡å…³é”®å­—ã€‚ identifierï¼šå¸¸é‡åç§°æ ‡è¯†ç¬¦ã€‚ [type]ï¼šç±»å‹ï¼Œå¯é€‰ã€‚ valueï¼šå¸¸é‡å€¼ã€‚ 1 2 // å…³é”®å­— æ ‡è¯†ç¬¦ [ç±»å‹] = å€¼ const identifier [type] = value 1 2 3 4 5 // æŒ‡å®šç±»å‹å¸¸é‡ const IDENTIFIER bool = false // æ˜¾å¼ç±»å‹å®šä¹‰ // æ— ç±»å‹å¸¸é‡ï¼Œæ¨æ–­ç±»å‹è¡Œä¸ºbool const IDENTIFIER = true // éšå¼ç±»å‹å®šä¹‰ å®šä¹‰å¤šä¸ªå¸¸é‡ 1 2 // 1. æ¨æ–­ç±»å‹ Aä¸ºbool Bä¸ºint Cä¸ºstring const A, B, C = true, 52, \u0026#34;golang\u0026#34;\t// å¤šé‡èµ‹å€¼ 1 2 3 4 5 6 // 2. const ( UNKNOWN = 0 // æ¨æ–­ä¸ºintç±»å‹ FEMALE = 1 // æ¨æ–­ä¸ºintç±»å‹ MALE = 2 // æ¨æ–­ä¸ºintç±»å‹ ) 1 2 3 4 5 6 7 // åŒæ—¶å£°æ˜å¤šä¸ªå¸¸é‡æ—¶ï¼Œå¦‚æœçœç•¥äº†å€¼åˆ™è¡¨ç¤ºå’Œä¸Šé¢ä¸€è¡Œçš„å€¼ç›¸åŒ const ( A uint16 = 255 // 255 B // 255 C = \u0026#34;hello\u0026#34; // hello D // hello ) æ— ç±»å‹å¸¸é‡ æ²¡æœ‰æŒ‡æ˜å¸¸é‡ç±»å‹çš„å¸¸é‡ã€‚const PI = 3.14159 æ— ç±»å‹å¸¸é‡å…·æœ‰é»˜è®¤ç±»å‹ï¼Œè¯¥ç±»å‹åœ¨éœ€è¦ç±»å‹åŒ–å€¼å¾—ä¸Šä¸‹æ–‡ä¸­éšå¼è½¬æ¢å¸¸é‡çš„ç±»å‹ï¼š åœ¨ç®€å¼å£°æ˜ä¸­ï¼ši := 0 æ²¡æœ‰æ˜¾ç¤ºç±»å‹ï¼Œè¿™ä¸å˜é‡çš„æ— ç±»å‹å£°æ˜ä¸åŒã€‚ æ— ç±»å‹å¸¸é‡çš„é»˜è®¤ç±»å‹åˆ†åˆ«æ˜¯ boolã€runeã€intã€float64ã€comolex128æˆ–stringã€‚ å…·ä½“å†³å®šäºå®ƒæ˜¯å¸ƒå°”å€¼ã€å­—ç¬¦ã€æ•´æ•°ã€æµ®ç‚¹æ•°ã€å¤æ•°è¿˜æ˜¯å­—ç¬¦ä¸²ã€‚ å¸¸é‡çš„å€¼å¿…é¡»æ˜¯åœ¨ç¼–è¯‘æ—¶å°±èƒ½ç¡®å®šçš„ã€‚ å¯ä»¥åœ¨èµ‹å€¼è¡¨è¾¾å¼ä¸­æ¶‰åŠè®¡ç®—è¿‡ç¨‹ï¼Œä½†æ˜¯æ‰€æœ‰ç”¨äºè®¡ç®—çš„å€¼å¿…é¡»åœ¨ç¼–è¯‘æœŸé—´å°±èƒ½è·å¾—ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 package main import ( \u0026#34;fmt\u0026#34; ) func main() { const a = 5 // æ— ç±»å‹å¸¸é‡åœ¨ä½¿ç”¨æ—¶æ ¹æ®ä¸Šä¸‹æ–‡è¯­å¢ƒè½¬æ¢ var intVar int = a var int32Var int32 = a var float64Var float64 = a var complex64Var complex64 = a fmt.Println(intVar, int32Var, float64Var, complex64Var) // 5 5 5 (5+0i) const aa = 5.0 var intVV int = aa // æµ®ç‚¹æ•°ä¸èƒ½é»˜è®¤è½¬intç±»å‹ fmt.Println(intVV) // 5 //const aaa = 5.1 //var intVVV int = aaa // constant 5.1 truncated to integer //fmt.Println(intVVV) } iota ç‰¹æ®Šå¸¸é‡ï¼Œå¯ä»¥è¢«ç¼–è¯‘å™¨ä¿®æ”¹çš„å¸¸é‡ã€‚ æ¯é‡åˆ°constå…³é”®å­—ï¼Œiotaå°†è¢«é‡ç½®ä¸º0ã€‚ æ¯å½“ iota åœ¨æ–°çš„ä¸€è¡Œè¢«ä½¿ç”¨æ—¶ï¼Œiotaä¼šè‡ªåŠ¨åŠ ä¸€ï¼Œiota++ã€‚å…¶å®å¹¶ä¸æ˜¯iotaåœ¨æ–°çš„ä¸€è¡Œä¸­å‡ºç°å°±ä¼šåŠ ä¸€ï¼Œä¸å‡ºç°ä¹Ÿä¼šè‡ªå¢ã€‚ ã€iotaçš„å‡†ç¡®å®šä¹‰æ˜¯ã€‘ï¼šiotaè¡¨ç¤ºconstå£°æ˜å—çš„è¡Œç´¢å¼•ï¼ˆä¸‹æ ‡ä»0å¼€å§‹ï¼‰ï¼Œè§£é‡Šå°±æ˜¯iotaè¡¨ç¤ºå½“å‰constçš„è¡Œå·ï¼Œä¸ç®¡ä½¿ç”¨æ²¡ä½¿ç”¨iotaã€‚ ã€constè¿˜æœ‰ä¸€ä¸ªé‡è¦çš„ç‰¹ç‚¹æ˜¯ã€‘ï¼šç¬¬ä¸€ä¸ªå¸¸é‡å¿…é¡»æŒ‡å®šä¸€ä¸ªè¡¨è¾¾å¼ï¼Œåç»­çš„å¸¸é‡å¦‚æœæ²¡æœ‰è¡¨è¾¾å¼ï¼Œåˆ™ç»§æ‰¿ä¸Šé¢çš„è¡¨è¾¾å¼ã€‚ iotaä½¿ç”¨ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 const ( A = iota // 0 (iota == 0)\tB = iota // 1 (iota == 1) C = iota // 2 (iota == 2) ) const ( AA = iota // 0 (iota == 0) BB // 1 (iota == 1) ç­‰æ•ˆäº BB = iota CC // 2 (iota == 2) ç­‰æ•ˆäº CC = iota ) // ä¸ç®¡contsä¸­æ˜¯å¦æœ‰ä½¿ç”¨iotaï¼Œéƒ½æ˜¯æŒ‰ç…§è¡Œå·é€’å¢çš„ const ( one = 3 // 3 (iota == 0) two = iota // 1 (iota == 1) three = iota // 2 (iota == 2) four // 3 (iota == 3) five // 4 (iota == 4) ) type CAPACITY uint const ( B CAPACITY = 1 \u0026lt;\u0026lt; (iota * 10)// 1 == 2^0 (iota == 0) // ç­‰æ•ˆäº KB CAPACITY = 1 \u0026lt;\u0026lt; (iota * 10) KB // 1024 == 2^10 (iota == 1) // ç­‰æ•ˆäº MB CAPACITY = 1 \u0026lt;\u0026lt; (iota * 10) MB // 1024 * 1024 = 2^20 (iota == 2) ) const ( D1 = iota // 0 (iota == 0) D2 // 1 (iota == 1) ç­‰æ•ˆäº D2 = iota D3 // 2 (iota == 2) ç­‰æ•ˆäº D3 = iota D4 // 3 (iota == 3) ç­‰æ•ˆäº D4 = iota D5 = \u0026#34;HELLO\u0026#34; // HELLO (iota == 4) D6 // HELLO (iota == 5) ç­‰æ•ˆäº D6 = \u0026#34;HELLO\u0026#34; D7 = 23 // 23 (iota == 6)\tD8 // 23 (iota == 7) ç­‰æ•ˆäº D7 = 23 D9 = iota // 8 (iota == 8) D10 // 9 (iota == 9) ç­‰æ•ˆäº D10 = iota ) const ( D1, D2 = 1 \u0026lt;\u0026lt; iota, 1 \u0026lt;\u0026lt; iota - 1 // 1 0 iota == 0\t00000001 \u0026lt;\u0026lt; 0 == 0 , 00000001 \u0026lt;\u0026lt; 0 - 1 == 0 // ç­‰æ•ˆäº D3, D4 = 1 \u0026lt;\u0026lt; iota, 1 \u0026lt;\u0026lt; iota - 1 D3, D4 // 2 1 iota == 1\t00000001 \u0026lt;\u0026lt; 1 == 2 , 00000001 \u0026lt;\u0026lt; 1 - 1 == 1 // ç­‰æ•ˆäº D5, D6 = 1 \u0026lt;\u0026lt; iota, 1 \u0026lt;\u0026lt; iota - 1 D5, D6 // 4 3 iota == 2\t00000001 \u0026lt;\u0026lt; 2 == 4 , 00000001 \u0026lt;\u0026lt; 2 - 1 == 3 ) å‚è€ƒ Goé«˜é˜¶æŒ‡å—05ï¼Œiota å®ç°åŸç† ","permalink":"https://heliu.site/posts/golang/basic/const/","summary":"Golang å¸¸é‡çš„å®šä¹‰åŠä½¿ç”¨ã€‚","title":"å¸¸é‡"},{"content":"åŸºæœ¬è¿ç®—ç¬¦ ç®—æ•°è¿ç®—ç¬¦ é€‚ç”¨äºæ•°å€¼ç±»å‹ï¼Œè¿ç®—ç»“æœç±»å‹ä¸é™¤æ•°ç±»å‹ä¸€è‡´ã€‚ï¼ˆé™¤æ•°æ˜¯æµ®ç‚¹æ•°ç»“æœä¸ºæµ®ç‚¹æ•°ï¼Œé™¤æ•°ä¸ºæ•´æ•°ç»“æœä¸ºæ•´æ•°ï¼‰ æ±‚ä½™ï¼ˆ%ï¼‰è¿ç®—ç»“æœç¬¦å·ä¸é™¤æ•°ç¬¦å·ä¸€è‡´ï¼ˆé™¤æ•°æ˜¯è´Ÿæ•°ç»“æœç¬¦å·ä¸ºè´Ÿæ•°ï¼‰ã€‚ è¿ç®—ç¬¦ æè¿° é€‚ç”¨èŒƒå›´ ç¤ºä¾‹ + åŠ æ³•è¿ç®—ç¬¦æˆ–å­—ç¬¦ä¸²æ‹¼æ¥ç¬¦ é€‚ç”¨äºæ•´æ•°ã€æµ®ç‚¹æ•°ã€å¤æ•°ã€å­—ç¬¦ä¸² 5 + 3 = 8 - å‡æ³•è¿ç®—ç¬¦ é€‚ç”¨äºæ•´æ•°ã€æµ®ç‚¹æ•°ã€å¤æ•° 5 - 3 = 2 * ä¹˜æ³•è¿ç®—ç¬¦ é€‚ç”¨äºæ•´æ•°ã€æµ®ç‚¹æ•°ã€å¤æ•° 5 * 3 = 15 / é™¤æ³•è¿ç®—ç¬¦ é€‚ç”¨äºæ•´æ•°ã€æµ®ç‚¹æ•°ã€å¤æ•° 5 / 2 = 2 % æ±‚ä½™è¿ç®— é€‚ç”¨äºæ•´æ•°ï¼ˆæœ‰ç¬¦å·ã€æ— ç¬¦å·ï¼‰ -5 % 2 = -1ï¼Œ-5 % -2 = -1ï¼Œ5 % 2 = 1 ++ è‡ªå¢ é€‚ç”¨äºæ•´æ•°ï¼ˆæœ‰ç¬¦å·ã€æ— ç¬¦å·ï¼‰ a++ -- è‡ªå‡ é€‚ç”¨äºæ•´æ•°ï¼ˆæœ‰ç¬¦å·ã€æ— ç¬¦å·ï¼‰ a-- å˜é‡ å˜é‡ å•† å–ä½™ x y x/y x%y 5 3 1 2 -5 3 -1 -2 5 -3 -1 2 -5 -3 1 -2 å…³ç³»è¿ç®—ç¬¦ åŒç›®è¿ç®—ç¬¦ä½œæ¯”è¾ƒï¼Œç»“æœä¸ºå¸ƒå°”å€¼ã€‚ è¿ç®—ç¬¦ å«ä¹‰ ç¤ºä¾‹ï¼ˆA å°äº Bï¼‰ == ç­‰äº A == B false != ä¸ç­‰äº A != B true \u0026gt; å¤§äº A \u0026gt; B false \u0026lt; å°äº A \u0026lt; B true \u0026gt;= å¤§äºç­‰äº A \u0026gt;= B false \u0026lt;= å°äºç­‰äº A \u0026lt;= B true é€»è¾‘è¿ç®—ç¬¦ åŒç›®è¿ç®—ç¬¦ï¼Œå¤„ç†å·¦å³å¸ƒå°”å€¼ã€‚ è¿ç®—ç¬¦ æè¿° ç¤ºä¾‹ \u0026amp;\u0026amp; é€»è¾‘ä¸è¿ç®—ç¬¦ï¼ˆå·¦å³ä¸¤è¾¹éƒ½ä¸ºtrueè¿”å›trueï¼Œå¦åˆ™è¿”å›falseï¼‰ (true \u0026amp;\u0026amp; false) == false || é€»è¾‘æˆ–è¿ç®—ç¬¦ï¼ˆå·¦å³ä¸¤è¾¹éƒ½ä¸ºfalseè¿”å›falseï¼Œå¦åˆ™è¿”å›trueï¼‰ (false || false) == false ! é€»è¾‘éè¿ç®—ç¬¦ï¼ˆä¸€ä½è¿ç®—ç¬¦trueå–åä¸ºfalseï¼Œfalseå–åä¸ºtrueï¼‰ !true == false ä½è¿ç®—ç¬¦ æ“ä½œäºŒè¿›åˆ¶æ•°ã€‚ è¿ç®—ç¬¦ å«ä¹‰ \u0026amp; æŒ‰ä¸ºä¸ï¼ŒåŒç›®è¿ç®—ç¬¦ã€‚å‚ä¸è¿ç®—çš„ä¸¤æ•°å„å¯¹åº”çš„ä½ç›¸ä¸ï¼ˆåŒ1å¾—1ï¼‰ | æŒ‰ä¸ºæˆ–ï¼ŒåŒç›®è¿ç®—ç¬¦ã€‚å‚ä¸è¿ç®—çš„ä¸¤æ•°å„å¯¹åº”çš„ä½ç›¸æˆ–ï¼ˆæœ‰1å¾—1ï¼‰ ^ æŒ‰ä¸ºå¼‚æˆ–ï¼ŒåŒç›®è¿ç®—ç¬¦ã€‚å‚ä¸è¿ç®—çš„ä¸¤æ•°å„å¯¹åº”çš„ä½å¼‚æˆ–ï¼ˆç›¸åŒå¾—0ï¼‰æˆ– ^ä½œä¸ºä¸€å…ƒè¿ç®—ç¬¦æ˜¯æŒ‰ä½å–å \u0026laquo; å·¦ç§»è¿ç®—ç¬¦ï¼ŒåŒç›®è¿ç®—ç¬¦ã€‚æŠŠå·¦è¾¹çš„è¿ç®—æ•°çš„å„ä½å…¨éƒ¨å·¦ç§»è‹¥å¹²ä½ï¼Œé«˜ä½ä¸¢å¼ƒï¼Œä½ä½è¡¥0 \u0026raquo; å³ç§»è¿ç®—ç¬¦ï¼ŒåŒç›®è¿ç®—ç¬¦ã€‚æŠŠå³è¾¹çš„è¿ç®—æ•°çš„å„ä½å…¨éƒ¨å·¦ç§»è‹¥å¹²ä½ å˜é‡1 å˜é‡2 ä¸è¿ç®— æˆ–è¿ç®— å¼‚æˆ–è¿ç®— p q p\u0026amp;q p|q p^q 0 0 0 0 0 0 1 0 1 1 1 1 1 1 0 1 0 0 1 1 å˜é‡1 å˜é‡2 å·¦ç§»è¿ç®— å³ç§»è¿ç®— p q p\u0026lt;\u0026lt;q p\u0026gt;\u0026gt;q 00001101 3 01101000 00000001 èµ‹å€¼è¿ç®—ç¬¦ è¿ç®—ç¬¦ å«ä¹‰ ç¤ºä¾‹ = èµ‹å€¼è¿ç®—ç¬¦ += ç›¸åŠ åå†èµ‹å€¼ C += A ç­‰äº C = C + A -= ç›¸å‡åå†èµ‹å€¼ C -= A ç­‰äº C = C - A *= ç›¸ä¹˜åå†èµ‹å€¼ C *= A ç­‰äº C = C * A /= ç›¸é™¤åå†èµ‹å€¼ C /= A ç­‰äº C = C / A %= æ±‚ä½™åå†èµ‹å€¼ C %= A ç­‰äº C = C % A \u0026lt;\u0026lt;= å·¦ç§»åå†èµ‹å€¼ C \u0026lt;\u0026lt;= 2 ç­‰äº C = C \u0026lt;\u0026lt; 2 \u0026gt;\u0026gt;= å³ç§»åå†èµ‹å€¼ C \u0026gt;\u0026gt;= 2 ç­‰äº C = C \u0026gt;\u0026gt; 2 \u0026amp;= æŒ‰ä½ä¸åèµ‹å€¼ C \u0026amp;= 2 ç­‰äº C = C \u0026amp; 2 ^= æŒ‰ä½å¼‚æˆ–åèµ‹å€¼ C ^= 2 ç­‰äº C = C ^ 2 |= æŒ‰ä½æˆ–åèµ‹å€¼ C |= 2 ç­‰äº C = C | 2 æŒ‡é’ˆè¿ç®—ç¬¦ è¿ç®—ç¬¦ å«ä¹‰ å®ä¾‹ \u0026amp; è¿”å›å˜é‡å­˜å‚¨åœ°å€ \u0026amp;a å°†è¾“å‡ºå˜é‡çš„å®é™…åœ°å€ * æŒ‡é’ˆå˜é‡ *a æ˜¯ä¸€ä¸ªæŒ‡é’ˆå˜é‡ Goè¯­è¨€è¿ç®—ç¬¦æ±‡æ€» è¿ç®—ç¬¦ è¿ç®—ç¬¦ è¿ç®—ç¬¦ è¿ç®—ç¬¦ è¿ç®—ç¬¦ + \u0026amp; += \u0026amp;= \u0026amp;\u0026amp; - | -= |= || * ^ *= ^= \u0026lt;- / \u0026laquo; /= \u0026laquo;= ++ % \u0026raquo; || \u0026raquo;= \u0026ndash; == \u0026lt; \u0026gt; = ! != \u0026lt;= \u0026gt;= := \u0026hellip; ( [ { , . ) ] } ; : \u0026amp;^ \u0026amp;^= è¿ç®—ç¬¦ä¼˜å…ˆçº§ ä¸€å…ƒè¿ç®—ç¬¦å…·æœ‰æœ€é«˜ä¼˜å…ˆçº§ã€‚ï¼ˆ++å’Œ--è¿ç®—ç¬¦æ˜¯å½¢æˆè¯­å¥è€Œä¸æ˜¯è¡¨è¾¾å¼ï¼Œæ‰€ä»¥ä»–ä»¬ä¸å±äºè¿ç®—ç¬¦å±‚æ¬¡ç»“æ„ï¼Œè¯­å¥*p++ä¸(*p)++ç›¸åŒï¼‰ äºŒå…ƒè¿ç®—ç¬¦æœ‰äº”ä¸ªå±‚æ¬¡ç»“æ„ï¼Œå¦‚ä¸‹ä¼˜å…ˆçº§æ•°å­—è¶Šå¤§è¡¨ç¤ºä¼˜å…ˆçº§è¶Šé«˜ã€‚ å¯ä»¥ä½¿ç”¨()æ¥ä¸´æ—¶æé«˜ä¼˜å…ˆçº§ã€‚ ä¼˜å…ˆçº§ è¿ç®—ç¬¦ 5 * / % \u0026lt;\u0026lt; \u0026gt;\u0026gt; \u0026amp; \u0026amp;^ 4 + - | ^ 3 == != \u0026lt; \u0026lt;= \u0026gt; \u0026gt;= 2 \u0026amp;\u0026amp; 1 || ç‰¹æ®Šè¿ç®—ç¬¦ ä½æ¸…é™¤ \u0026amp;^ å°†æŒ‡å®šä½ç½®ä¸Šçš„å€¼è®¾ç½®ä¸º0ã€‚å°†è¿ç®—ç¬¦å·¦è¾¹æ•°æ®ç›¸å¼‚çš„ä½ä¿ç•™ï¼Œç›¸åŒä½æ¸…é›¶ã€‚ å¦‚æœYæŸä½ä¸Šçš„æ•°æ˜¯0ï¼Œåˆ™å–Xä¸Šå¯¹åº”ä½ç½®çš„å€¼ã€‚å¦‚æœYæŸä½ä¸Šä¸º1ï¼Œåˆ™ç»“æœä½ä¸Šå–0ã€‚ å¦‚æœå³ä¾§æ˜¯0ï¼Œåˆ™å·¦ä¾§æ•°ä¿æŒä¸å˜ã€‚ å¦‚æœå³ä¾§æ˜¯1ï¼Œåˆ™å·¦ä¾§æ•°ä¸€å®šæ¸…é›¶ã€‚ åŠŸèƒ½ä¸a\u0026amp;(^b)ç›¸åŒã€‚ X = 0b0000_0010 // 0000 0010 Y = 0b0000_0100 // 0000 0100 X \u0026amp;^ Y == X \u0026amp; (^Y) // 0000 0010 1 2 3 4 5 6 7 8 // ç›¸å¼‚çš„ä¿ç•™ï¼Œç›¸åŒä½æ¸…é›¶ // a \u0026amp;^ b // å¦‚æœå³ä¾§(a)ä½æ˜¯0ï¼Œåˆ™å·¦ä¾§æ•°ä¿æŒä¸å˜ // å¦‚æœå³ä¾§(a)ä¸ºæ˜¯1ï¼Œåˆ™å·¦ä¾§æ•°ä¸€å®šæ¸…é›¶ { // æ¸…é™¤açš„ç¬¬7ä½ a \u0026amp;^ (1\u0026lt;\u0026lt;7) // 10000000 128 } ^ å¼‚æˆ–ï¼ˆXORï¼‰ åœ¨Goè¯­è¨€ä¸­XORæ˜¯ä½œä¸ºäºŒå…ƒè¿ç®—ç¬¦å­˜åœ¨ã€‚å¦‚æœä½œä¸ºä¸€å…ƒè¿ç®—ç¬¦å‡ºç°ï¼Œæ„æ€æ˜¯æŒ‰ä½å–åã€‚ ä½œä¸ºäºŒå…ƒè¿ç®—ç¬¦ï¼ŒXORæ˜¯ä¸è¿›ä½åŠ æ³•è®¡ç®—ï¼Œä¹Ÿå°±æ˜¯å¼‚æˆ–è¿ç®—ã€‚ è®¾ç½®ç¬¬nä½ä¸º1 1 2 3 4 5 { var a uint8 a = a | (1 \u0026lt;\u0026lt; 7) // 10000000 } è®¾ç½®ç¬¬nä½ä¸º0 \u0026amp;^ï¼šæ¸…é›¶æŸä½ã€‚ 1 2 3 4 5 { var a uint8 = 0b0010_0001 a = a \u0026amp;^ (1 \u0026lt;\u0026lt; 5) // 1 } ","permalink":"https://heliu.site/posts/golang/basic/operator/","summary":"Golang ç›¸å…³çš„è¿ç®—ç¬¦ä»‹ç»ã€‚","title":"è¿ç®—ç¬¦"},{"content":" å­—é¢é‡æ˜¯æŒ‡ç”±å­—æ¯ã€æ•°å­—ç­‰æ„æˆçš„å­—ç¬¦ä¸²æˆ–æ•°å€¼ï¼Œå®ƒåªèƒ½ä½œä¸ºå³å€¼å‡ºç°ã€‚ æ•´æ•°å­—é¢é‡ è¡¨ç¤ºæ•´æ•°å¸¸é‡çš„æ•°å­—åºåˆ—ã€‚ 42 // åè¿›åˆ¶ 0600 // å…«è¿›åˆ¶ 6*8^2 + 0*8^1 + 0*8^0 oxBadFace // åå…­è¿›åˆ¶ 11*16^6 + 10*16^5 + ... ob11110000 // äºŒè¿›åˆ¶ ob1111_0000 // äºŒè¿›åˆ¶ 1 2 3 4 5 6 7 8 func Example() { var o int = 067 // 6*8+7 var ox int = 0xBa77 // 11*16^3 + 10*16^2 + 7*16 + 7 fmt.Println(o, ox) // Output: // 55 47735 } æµ®ç‚¹æ•°å­—é¢é‡ æµ®ç‚¹å¸¸é‡çš„åè¿›åˆ¶è¡¨ç¤ºã€‚ ç§‘å­¦è®¡æ•°æ³•ï¼šä¸€ä¸ªæ•´æ•°éƒ¨åˆ†ã€ä¸€ä¸ªå°æ•°ç‚¹ã€ä¸€ä¸ªå°æ•°éƒ¨åˆ†å’Œä¸€ä¸ªæŒ‡æ•°éƒ¨åˆ†ã€‚ 0. // 0 72.40 // 72.4 072.40 // 72.4 2.712 1.e+0 6.654e-11 // ç§‘å­¦è®¡æ•°æ³• 6.654 * 10^-11 1E6\t.25 // 0.25 .12345E+5 // 0.12345E+5 1 2 3 4 5 6 7 func Example() { a, b, c, d := 0., 072.40, 1.e+0, .1254E+5 fmt.Println(a, b, c, d) // Output: // 0 72.4 1 12540 } è™šæ•°å­—é¢é‡ è™šæ•°å­—é¢é‡æ˜¯å¤æ•°å¸¸æ•°çš„è™šæ•°çš„åè¿›åˆ¶è¡¨ç¤ºã€‚ 0i 011i // 11i 0.1 2.2454i 1.e+0i 6.67e-11i 1E6i .25i 1 2 3 4 5 6 7 func Example() { a, b, c, d := 0i, 011i, 0.1, 6.67e-11i fmt.Println(a, b, c, d) // Output: // (0+0i) (0+11i) 0.1 (0+6.67e-11i) } Runeå­—é¢é‡ Rune åˆ«å é•¿åº¦ èŒƒå›´ rune int32 4B -2147483648 ~ 2147483647 Runeå­—é¢é‡æ˜¯æ ‡è¯†Unicodeä»£ç ç‚¹çš„æ•´æ•°å€¼ã€‚ï¼ˆUnicodeæ˜¯å®šé•¿ä¸¤ä¸ªå­—èŠ‚ï¼‰ Runeå­—é¢é‡è¡¨ç¤ºç”¨å•å¼•å·æ‹¬èµ·æ¥çš„ä¸€ä¸ªæˆ–å¤šä¸ªå­—ç¬¦ã€‚'x'æˆ–'\\n'ã€‚ å•å¼•å·å­—ç¬¦è¡¨ç¤ºå­—ç¬¦æœ¬èº«çš„Unicodeå€¼ã€‚è€Œä»¥åæ–œæ å¼€å¤´çš„å­—ç¬¦åºåˆ—è¡¨ç¤ºå„ç§æ ¼å¼ç¼–ç å€¼ã€‚ Goæºç æ˜¯ä»¥UTF-8ç¼–ç çš„Unicodeå­—ç¬¦ï¼Œå› æ­¤å¤šä¸ªUTF-8ç¼–ç çš„å­—èŠ‚å¯ä»¥è¡¨ç¤ºå•ä¸ªæ•´æ•°å€¼ã€‚ 'a'è¡¨ç¤ºæ˜¯açš„å•ä¸ªå­—èŠ‚ï¼ŒUnicode U+0061ï¼Œå€¼ä¸º0x61ã€‚ \u0026ldquo;å¥½\u0026rdquo; ç¼–ç 0x597dåŒ…å«ä¸¤ä¸ªå­—èŠ‚ ï¼ŒU+00E4å€¼ä¸º0xe4ã€‚ å°†æ•´æ•°å€¼è¡¨ç¤ºä¸ºæ•°å­—å¸¸é‡ã€‚ \\xåè·Ÿæ°å¥½ä¸¤ä¸ªåå…­è¿›åˆ¶æ•°å­—\\x00 ~ \\xff (0 ~ 255) 1B (2^8)\t1å­—èŠ‚ã€‚ \\uåè·Ÿæ°å¥½å››ä¸ªåå…­è¿›åˆ¶æ•°å­—\\u0000 ~ \\uffff (0 ~ 65535) 2B (2^16) 2å­—èŠ‚ã€‚ \\Uåè·Ÿæ°å¥½å…«ä¸ªåå…­è¿›åˆ¶æ•°å­—\\U00000000 ~ \\Uffffffff (0 ~ 4294967295) 4B 4å­—èŠ‚ã€‚ \\ åè·Ÿæ°å¥½ä¸‰ä¸ªå…«è¿›åˆ¶æ•°å­—\\000 ~ \\777 (0 ~ 511)ã€‚ Unicode æœ€å¤§å€¼ 0x10FFF 69631ã€‚ \u0026#39;a\u0026#39; \u0026#39;ç¬¨\u0026#39; \u0026#39;\\t\u0026#39; \u0026#39;\\000\u0026#39; \u0026#39;\\007\u0026#39; \u0026#39;\\xff\u0026#39; \u0026#39;\\u12e4\u0026#39; \u0026#39;\\U00101234\u0026#39; \u0026#39;aa\u0026#39; // éæ³• å¤šä¸ªå­—ç¬¦ \u0026#39;\\xa\u0026#39; // éæ³• åå…­è¿›åˆ¶æ•°å­—å¤ªå°‘ \u0026#39;\\0\u0026#39; // éæ³•å…«è¿›åˆ¶æ•°å­—ä¸æ­£ç¡® \u0026#39;\\U001000000\u0026#39; // éæ³• æ— æ•ˆçš„Unicodeä»£ç ç‚¹ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 func Example() { // rune = int32 // byte = uint8 var a rune = \u0026#39;\\n\u0026#39; var b rune = \u0026#39;å¥½\u0026#39; var c byte = \u0026#39;\\007\u0026#39; var d rune = \u0026#39;\\xff\u0026#39; var e rune = \u0026#39;\\u12e4\u0026#39; fmt.Println(a, b, c, d, e) fmt.Printf(\u0026#34;%c %c %c %c %c\u0026#34;, a, b, c, d, e) // Output: // 10 22909 7 255 4836 // // å¥½ Ã¿ á‹¤ } å­—ç¬¦ä¸²å­—é¢é‡ åŸå§‹å­—ç¬¦ä¸²å­—é¢é‡ï¼šåå¼•å·ä¹‹é—´çš„å­—ç¬¦åºåˆ—ã€‚ è§£é‡Šçš„å­—ç¬¦ä¸²ï¼šåŒå¼•å·ä¹‹é—´çš„å­—ç¬¦åºåˆ—ã€‚ åœ¨åŒå¼•å·å†…ï¼Œé™¤äº†æ¢è¡Œç¬¦å’Œæœªè½¬ä¹‰çš„åŒå¼•å·å¤–ï¼Œä»»ä½•å­—ç¬¦éƒ½å¯ä»¥å‡ºç°ã€‚ å¼•å·ä¹‹é—´çš„æ–‡æœ¬å½¢æˆæ–‡å­—çš„runeå€¼ï¼Œåæ–œæ è½¬ä¹‰ç¬¦è¢«è§£é‡Šä¸ºç¬¦æ–‡(rune)ã€‚ `abc` // \u0026#34;abc\u0026#34; `\\n \\n` // \u0026#34;\\\\n\\n\\\\n\u0026#34; \u0026#34;\\n\u0026#34;\t\u0026#34;\\\u0026#34;\u0026#34; // `\u0026#34;` \u0026#34;Hello,World!\\n\u0026#34; \u0026#34;æ´’æ°´\u0026#34; \u0026#34;\\u65e5 æœ¬\\U00008a9e\u0026#34; \u0026#34;\\xff\\u00FF\u0026#34; ","permalink":"https://heliu.site/posts/golang/basic/literal/","summary":"Golang ç›¸å…³å­—é¢é‡ä»‹ç»ã€‚","title":"å­—é¢é‡"},{"content":"Go å†…ç½®ç±»å‹çš„é›¶å€¼ å½“ä¸€ä¸ªå˜é‡è¢«varå£°æ˜ä¹‹åï¼Œå¦‚æœæ²¡æœ‰ä¸ºå…¶æ˜ç¡®æŒ‡æ˜åˆå§‹å€¼ï¼ŒGoè¯­è¨€ä¼šè‡ªåŠ¨åˆå§‹åŒ–å…¶å€¼ä¸ºæ­¤ç±»å‹å¯¹åº”çš„é›¶å€¼ã€‚ ç±»å‹ é›¶å€¼ integer æ•´æ•°ç±»å‹ï¼ŒåŒ…æ‹¬çš„byteå’Œrune 0 uintptr æ•´æ•°ç±»å‹ 0 float æµ®ç‚¹æ•°ç±»å‹ 0.0 bool å¸ƒå°”å€¼ç±»å‹ false string å­—ç¬¦ä¸²ç±»å‹ ç©ºå­—ç¬¦ä¸²\u0026quot;\u0026quot; complex å¤æ•°ç±»å‹ 0+0i *T æŒ‡é’ˆç±»å‹ nil interfaceã€errorã€functionã€mapã€sliceã€channel nil uintptrçš„é»˜è®¤å€¼ uintptræ˜¯æ•´æ•°ç±»å‹ä¸æ˜¯æŒ‡é’ˆï¼Œè¯¥ç±»å‹åªæ˜¯ç”¨äºæŒ‡é’ˆåœ°å€åšåç§»è¿ç®—ã€‚ 1 2 3 4 5 6 7 8 9 10 11 package main func main() { var s uintptr // 0 if s == 0 { print(123) } // Output: // 123 } nilé›¶å€¼ 1 2 3 4 5 6 7 8 9 10 11 12 package main import ( //\u0026#34;fmt\u0026#34; ) func main() { // æ­¤å¤„ç¼–è¯‘ä¸é€šè¿‡ï¼Œnilèµ‹å€¼ç»™xï¼Œç¼–è¯‘å™¨åˆ¤æ–­ä¸å‡ºå…·ä½“ç±»å‹ var x = nil\t// use of untyped nil _ = x } åœ¨ä¸€ä¸ªnilçš„åˆ‡ç‰‡ä¸­æ·»åŠ å…ƒç´ æ˜¯æ²¡æœ‰é—®é¢˜çš„ã€‚ å› ä¸ºnilçš„åˆ‡ç‰‡å¹¶æ²¡ç”¨åˆ†é…å†…å­˜ï¼Œä½†æ˜¯æ·»åŠ å…ƒç´ å¿…é¡»ä½¿ç”¨appendå‡½æ•°ï¼Œè¯¥å‡½æ•°ä¼šåˆå§‹åŒ–nilçš„åˆ‡ç‰‡ã€‚ï¼ˆåŸå› æ˜¯ä¼šå¯¼è‡´æ‰©å®¹ä»æ–°åˆ†é…å†…å­˜ï¼‰ ä½†æ˜¯å¯¹ä¸€ä¸ªå­—å…¸åšåŒæ ·çš„äº‹å°†å‘ç”Ÿå¼‚å¸¸ã€‚ nilçš„mapå¹¶æ²¡æœ‰åˆ†é…å†…å­˜ï¼Œmapæ·»åŠ å…ƒç´ æ˜¯ç›´æ¥map[x] = xå½¢å¼ï¼Œæ‰€ä»¥ä¼šæŠ¥é”™è¯¯ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 package main import ( \u0026#34;fmt\u0026#34; ) func main() { // type sliceStruct struct {pointer, len, cap} // data=nil len=0 cap=0 var a []string // nil // æ³¨æ„ ä¸ a := []string{} çš„åŒºåˆ«ï¼Œè¿™ç§æ˜¯å·²ç»åˆå§‹åŒ–è¿‡çš„ä¹Ÿå°±æ˜¯ç³»ç»Ÿé»˜è®¤è°ƒç”¨è¿‡makeæ–¹æ³•å…¶é›¶å€¼ä¸ä¸ºnil // æ›´å¤š var a []string å’Œ a := []string{} å½¢å¼å°†åœ¨åˆ‡ç‰‡ä¸€èŠ‚ä¸­è®¨è®º // append ä¼šåˆå§‹åŒ–a a1 := append(a, \u0026#34;s\u0026#34;) fmt.Println(a, a1) // [] [s] //var m map[string]int //m[\u0026#34;one\u0026#34;] = 1 // panic: assignment to entry in nil map // data len // makeä¼šåˆå§‹åŒ– var m1 map[string]int = make(map[string]int, 2) m1[\u0026#34;one\u0026#34;] = 1 fmt.Println(m1)\t// map[one:1] var ss *string = new(string) *ss = \u0026#34;abc\u0026#34; fmt.Println(ss, *ss) // 0xc000088260 abc // panic: runtime error: invalid memory address or nil pointer dereference //var s *int // æ­¤æ—¶sçš„é»˜è®¤å€¼ä¸ºnilï¼Œ*så¹¶æ²¡æœ‰åˆ†é…å†…å­˜ //*s = 10 // æŠ¥é”™ s å¹¶æ²¡æœ‰åˆ†é…å†…å­˜ç©ºé—´ } æ³¨æ„nilç”¨äºçš„ç±»å‹ï¼š nilæ˜¯ä¸€ä¸ªé¢„å…ˆå£°æ˜çš„æ ‡è¯†ç¬¦ï¼Œè¡¨ç¤ºaçš„é›¶å€¼ pointer, channel, func, interface, map, or slice typeã€‚ ç±»å‹å¿…é¡»æ˜¯ pointer, channel, func, interface, map, or slice type. 1 2 var s string = \u0026#34;hello,world\u0026#34; c := s[0] // cçš„ç±»å‹ä¸º byte ä¹Ÿå°±æ˜¯ uint8 ","permalink":"https://heliu.site/posts/golang/basic/zero/","summary":"Golang ç±»å‹çš„é»˜è®¤é›¶å€¼ã€‚","title":"ç±»å‹é›¶å€¼"},{"content":"å±€éƒ¨å˜é‡ä¸å…¨å±€å˜é‡ å±€éƒ¨å˜é‡ï¼šå‡½æ•°ä½“å†…ã€ä»£ç å—å†…ã€å‚æ•°(å‡½æ•°å‚æ•°å’Œæ¥æ”¶å™¨å‚æ•°)å’Œè¿”å›å€¼å˜é‡ã€‚ åœ¨å‡½æ•°ä½“æˆ–ä»£ç å—å†…å£°æ˜çš„å˜é‡ç§°ä¸ºå±€éƒ¨å˜é‡ï¼Œå®ƒä»¬çš„ä½œç”¨åŸŸåªåœ¨ä»£ç å—å†…ã€‚ å‚æ•°å’Œè¿”å›å€¼å˜é‡ä¹Ÿæ˜¯å±€éƒ¨å˜é‡(æ¥æ”¶å™¨å‚æ•°ä¹Ÿæ˜¯å±€éƒ¨å˜é‡)ã€‚ å…¨å±€å˜é‡ï¼šå‡½æ•°ä½“å¤–å£°æ˜çš„å˜é‡ã€‚ åœ¨å‡½æ•°ä½“å¤–å£°æ˜çš„å˜é‡ç§°ä¸ºå…¨å±€å˜é‡ï¼Œå®ƒä»¬çš„ä½œç”¨åŸŸæ˜¯å…¨å±€çš„ã€‚ï¼ˆåœ¨æœ¬åŒ…èŒƒå›´å†…ï¼‰ å…¨å±€å˜é‡å¯ä»¥åœ¨æ•´ä¸ªåŒ…ç”šè‡³å¤–éƒ¨åŒ…ï¼ˆè¢«å¯¼å‡ºåï¼‰ä½¿ç”¨ï¼Œå…¨å±€å˜é‡å¯ä»¥åœ¨ä»»ä½•å‡½æ•°ä¸­ä½¿ç”¨ã€‚ ç®€å¼å˜é‡ï¼š ä½¿ç”¨ := å£°æ˜çš„å˜é‡ï¼Œä¸€èˆ¬ä¹Ÿæ˜¯å±€éƒ¨å˜é‡ã€‚ï¼ˆå˜é‡å¯èƒ½é€ƒé€¸åˆ°å †é‡Œé¢ï¼‰ å¦‚æœæ–°å±€éƒ¨å˜é‡Gaä¸åŒåå·²å®šä¹‰å˜é‡ï¼ˆå…¨å±€å˜é‡Gaï¼‰ä¸åœ¨åŒä¸€ä¸ªä½œç”¨åŸŸä¸­ï¼ŒGoè¯­è¨€ä¼šåœ¨æ­¤ä½œç”¨åŸŸæ–°å®šä¹‰å±€éƒ¨å˜é‡Gaï¼Œé®ä½å…¨å±€å˜é‡Gaï¼Œå› æ­¤å°½é‡å…¨å±€å˜é‡ä¸å±€éƒ¨å˜é‡ä¸åŒåã€‚ æ˜¾å¼ä¸éšå¼ä»£ç å— Goè¯­è¨€ä¸­çš„æ ‡è¯†ç¬¦ä½œç”¨åŸŸæ˜¯åŸºäºä»£ç å—çš„ï¼Œä»£ç å—æ˜¯åŒ…è£¹åœ¨ä¸€å¯¹èŠ±æ‹¬å·{}å†…éƒ¨çš„å£°æ˜å’Œè¯­å¥ï¼Œå¹¶ä¸”æ˜¯å¯åµŒå¥—çš„ã€‚ ä»£ç å—å¦‚ï¼šå‡½æ•°çš„å‡½æ•°ä½“ã€forå¾ªç¯çš„å¾ªç¯ä½“ç­‰ã€‚ è¿˜æœ‰éšå¼çš„ï¼ˆimplicitï¼‰ä»£ç å—ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 // ä½¿ç”¨æœ€å¤šçš„ifè¯­å¥ç±»å‹åªæœ‰ifè€Œæ²¡æœ‰elseåˆ†æ”¯ if simplestms; expression { ... ... } // åœ¨è¿™ç§ç±»å‹çš„ifè¯­å¥ä¸­ï¼Œæœ‰ä¸¤ä¸ªä»£ç å—ï¼šä¸€ä¸ªéšå¼çš„ä»£ç å—å’Œä¸€ä¸ªæ˜¾ç¤ºçš„ä»£ç å— // ä¸Šé¢ä»£ç ç­‰ä»·äº { // éšå¼çš„ä»£ç å— simplestms if expression { // æ˜¾å¼ä»£ç å— ... ... } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 package main import \u0026#34;fmt\u0026#34; func main() { // è¿™é‡Œéœ€è¦æ³¨æ„å˜é‡å£°æ˜çš„å…ˆåé¡ºåº if a := 1; false { fmt.Println(11) } else if b := 2; false { fmt.Println(22) } else if c := 3; false { fmt.Println(33) } else { fmt.Println(a, b, c) } // ä¸Šé¢ä»£ç  ç­‰ä»·äºå¦‚ä¸‹ä»£ç  å› æ­¤ä¸åŒä½ç½®å®šä¹‰çš„å˜é‡ä½œç”¨åŸŸä¸åŒ { aa := 1 if false { fmt.Println(11) } else { bb := 2 if false { fmt.Println(22) } else { cc := 3 if false { fmt.Println(33) } else { fmt.Println(aa, bb, cc) } } } } // Output: // 1 2 3 // 1 2 3 } å˜é‡è¢«é®ç›– ç›¸åŒåå­—çš„æ ‡è¯†ç¬¦ä¼šé®ä½å‰é¢çš„æ ‡è¯†ç¬¦ï¼Œè¿™ç§æƒ…å†µåªèƒ½æ˜¯åœ¨ä¸åŒçš„å—ä¸­ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;math/rand\u0026#34; ) // Ga å…¨å±€å˜é‡ var ( Ga int = 99 ) // v å…¨å±€å¸¸é‡ const ( v int = 199 ) func main() { // è¦†ç›–å¤–éƒ¨å£°æ˜å˜é‡Ga Ga := \u0026#34;string\u0026#34; fmt.Println(\u0026#34;mainå‡½æ•°ä¸­:\u0026#34;, Ga) // mainå‡½æ•°ä¸­: string b := GetGa() fmt.Println(\u0026#34;mainå‡½æ•°ä¸­ï¼š\u0026#34;, b(), b(), b(), b()) printGVariable() fmt.Println(v) // æ³¨æ„è¿™é‡Œå±è”½äº†å…¨å±€å¸¸é‡v v := 1 { v := 2 fmt.Println(v) { v := 3 fmt.Println(v) } } fmt.Println(v) // Output: // mainå‡½æ•°ä¸­: string // GetGa ifä¸­ï¼š 55 // GetGa å¾ªç¯ä¸­ï¼š 2 // GetGaå‡½æ•°ä¸­: 99 // mainå‡½æ•°ä¸­ï¼š 100 101 102 103 // 103 // 199 // 2 // 3 // 1 } // GetGa è¿”å›å€¼ä¸ºå‡½æ•° func() int func GetGa() func() int { rand1 := rand.Intn(10) // è¿”å›éšæœºæ•° [0,10] ä¹‹é—´ // å±€éƒ¨å˜é‡ Ga if Ga := 55; Ga + rand1 \u0026lt; 60 { fmt.Println(\u0026#34;GetGa ifä¸­ï¼š\u0026#34;, Ga) } // å±€éƒ¨å˜é‡ Ga for Ga := 2; ; { fmt.Println(\u0026#34;GetGa å¾ªç¯ä¸­ï¼š\u0026#34;, Ga) break } // å…¨å±€å˜é‡ Ga fmt.Println(\u0026#34;GetGaå‡½æ•°ä¸­:\u0026#34;, Ga) // å…³äºé—­åŒ…çš„æƒ…å†µå‚çœ‹å‡½æ•°ç« èŠ‚ return func() int { // æ­¤å¤„Gaçš„ä½œç”¨åŸŸè®¤å®šä¸Šä¸‹æ–‡æ˜¯99 Ga += 1 // å…¨å±€å˜é‡Ga return Ga } } func printGVariable() { // å…¨å±€å˜é‡Ga fmt.Println(Ga) } æ€»ç»“ æœ‰èŠ±æ‹¬å·ä¸€èˆ¬éƒ½å­˜åœ¨ä½œç”¨åŸŸã€‚ :=æ ‡è¯†æ–°å£°æ˜ä¸€ä¸ªå˜é‡ï¼Œåœ¨ä¸åŒçš„å—ä¸­å¯èƒ½ä¼šå±è”½æ‰€æœ‰ä¸Šå±‚ä»£ç å—ä¸­çš„ç›¸åŒåç§°çš„å˜é‡ï¼ˆå¸¸é‡ï¼‰ã€‚ åœ¨ifç­‰è¯­å¥ä¸­å­˜åœ¨éšå¼ä»£ç å—ï¼Œéœ€è¦æ³¨æ„ã€‚ é—­åŒ…å‡½æ•°å¯ä»¥ç†è§£ä¸ºä¸€ä¸ªä»£ç å—ï¼Œå¹¶ä¸”å¯ä»¥ä½¿ç”¨åŒ…å«å®ƒçš„å‡½æ•°å†…çš„å˜é‡ã€‚ ç®€å•å£°æ˜(:=)å˜é‡åªèƒ½åœ¨å‡½æ•°å†…éƒ¨å‡ºç°ï¼Œå®ƒä¼šè¦†ç›–å‡½æ•°å¤–çš„åŒåå˜é‡ã€‚ ç®€å•å£°æ˜(:=)å·¦ä¾§åªæœ‰ä¸€ä¸ªå˜é‡çš„æƒ…å†µä¸‹ä¸èƒ½é‡å¤å£°æ˜ä¸€ä¸ªå˜é‡ï¼Œæœ‰å¤šä¸ªå˜é‡æ—¶å…è®¸çš„ï¼Œä½†è¿™äº›å˜é‡ä¸­è‡³å°‘è¦æœ‰ä¸€ä¸ªæ–°çš„å˜é‡ï¼Œç»å¸¸æ˜¯æƒ…å†µæ˜¯file, err := os.Open(\u0026quot;txt.txt\u0026quot;)è¿™é‡Œçš„errå˜é‡æ¥æ”¶é”™è¯¯åœ¨ç›¸åŒå—çš„å¤šä¸ªåœ°æ–¹è¢«ä½¿ç”¨ã€‚ çº¦å®šå’Œæƒ¯ä¾‹ å¯è§æ€§è§„åˆ™ï¼š Goè¯­è¨€ä¸­æ ‡è¯†ç¬¦å¿…é¡»ä»¥ä¸€ä¸ªå¤§å†™å­—æ¯å¼€å¤´ï¼ˆå‚çœ‹Unicodeç¼–ç é›†å®šä¹‰çš„å¤§å†™å­—æ¯é›†ï¼‰ï¼Œæ‰èƒ½è¢«å¤–éƒ¨åŒ…çš„ä»£ç ä½¿ç”¨ï¼Œè¿™ç§°ä¸ºå¯¼å‡ºã€‚ æ ‡è¯†ç¬¦å¦‚æœä»¥å°å†™å­—æ¯å¼€å¤´ï¼Œåˆ™å¯¹åŒ…å¤–æ˜¯ä¸å¯è§çš„ï¼Œä½†æ˜¯ä»–ä»¬åœ¨æ•´ä¸ªåŒ…çš„å†…éƒ¨æ˜¯å¯è§å¹¶ä¸”å¯ç”¨çš„ã€‚ å‘½åè§„èŒƒä»¥åŠè¯­æ³•æƒ¯ä¾‹ï¼š å½“æŸä¸ªå‡½æ•°éœ€è¦è¢«å¤–éƒ¨åŒ…è°ƒç”¨çš„æ—¶å€™éœ€è¦ä»¥å¤§å†™å­—æ¯å¼€å¤´ï¼Œå¹¶éµå®ˆPascalå‘½åæ³•ã€‚ï¼ˆå¤§é©¼å³°å‘½åæ³•ï¼‰ å¦åˆ™å°±éµå®ˆï¼ˆå°é©¼å³°å‘½åæ³•ï¼‰ï¼Œå³ç¬¬ä¸€ä¸ªå•è¯çš„é¦–å­—æ¯å°å†™ï¼Œå…¶ä½™å•è¯çš„é¦–å­—æ¯å¤§å†™ã€‚ å•è¯ä¹‹é—´ä¸ä»¥ç©ºæ ¼æ–­å¼€æˆ–è¿æ¥å·ï¼ˆ-ï¼‰ã€ä¸‹åˆ’çº¿ï¼ˆ_ï¼‰è¿æ¥ï¼Œç¬¬ä¸€ä¸ªå•è¯é¦–å­—æ¯é‡‡ç”¨å¤§å†™å­—æ¯ï¼Œåç»­å•è¯çš„é¦–å­—æ¯ä¹Ÿç”¨å¤§å†™å­—æ¯ï¼ˆFirstNameã€LastNameï¼‰ã€‚ å·¦èŠ±æ‹¬å·{ä¸èƒ½ç‹¬å ä¸€è¡Œï¼Œè¿™æ˜¯ç¼–è¾‘å™¨çš„å¼ºåˆ¶è§„å®šï¼Œå³èŠ±æ‹¬å·}éœ€è¦ç‹¬å ä¸€è¡Œã€‚(è¿™ä¸Goæ²¡æœ‰;ç›¸å…³ï¼Œç¼–è¯‘å™¨ä¼šåŠ ä¸Šé»˜è®¤çš„;) åœ¨å®šä¹‰æ¥å£åæ—¶ä¹Ÿæœ‰æƒ¯ä¾‹ï¼Œä¸€ä¸ªå•æ–¹æ³•æ¥å£ç”±æ–¹æ³•åç§°åŠ ä¸Š-eråç¼€æˆ–è€…-ableåç¼€æ¥å‘½åæˆ–è€…Iå¼€å¤´ã€‚ æ³¨é‡Š è¡Œæ³¨é‡Šï¼š// æ³¨é‡Šã€‚ å—æ³¨é‡Šï¼š/* æ³¨é‡Š */ã€‚ ","permalink":"https://heliu.site/posts/golang/basic/scope/","summary":"Golang ç›¸å…³ä½œç”¨åŸŸä»‹ç»ã€‚","title":"ä½œç”¨åŸŸ"},{"content":" Goè¯­è¨€ä¸­çš„æŒ‡é’ˆä¸èƒ½è¿›è¡Œåç§»å’Œè¿ç®—ï¼Œæ˜¯å®‰å…¨æŒ‡é’ˆã€‚ æŒ‡é’ˆåœ°å€ã€æŒ‡é’ˆç±»å‹å’ŒæŒ‡é’ˆå–å€¼ã€‚ Goè¯­è¨€ä¸­çš„å‡½æ•°ä¼ å‚éƒ½æ˜¯å€¼æ‹·è´ï¼Œå½“æˆ‘ä»¬æƒ³è¦ä¿®æ”¹æŸä¸ªå˜é‡çš„æ—¶å€™ï¼Œæˆ‘ä»¬å¯ä»¥åˆ›å»ºä¸€ä¸ªæŒ‡å‘è¯¥å˜é‡åœ°å€çš„æŒ‡é’ˆå˜é‡ã€‚ ä¼ é€’æ•°æ®ä½¿ç”¨æŒ‡é’ˆï¼Œè€Œæ— é¡»æ‹·è´æ•°æ®ã€‚ ç±»å‹æŒ‡é’ˆä¸èƒ½è¿›è¡Œåç§»å’Œè¿ç®—ã€‚ Goè¯­è¨€ä¸­çš„æŒ‡é’ˆæ“ä½œéå¸¸ç®€å•ï¼Œåªéœ€è¦è®°ä½ä¸¤ä¸ªç¬¦å·ï¼š \u0026amp;ï¼ˆå–åœ°å€ï¼‰ã€*ï¼ˆæ ¹æ®åœ°å€å–å€¼ï¼‰ã€‚ æŒ‡é’ˆåœ°å€ä¸æŒ‡é’ˆç±»å‹ æ¯ä¸ªå˜é‡åœ¨è¿è¡Œæ—¶éƒ½æ‹¥æœ‰ä¸€ä¸ªåœ°å€ï¼Œè¿™ä¸ªåœ°å€ä»£è¡¨å˜é‡åœ¨å†…å­˜ä¸­çš„ä½ç½®ï¼ŒGoè¯­è¨€ä¸­ä½¿ç”¨\u0026amp;å­—ç¬¦æ”¾åœ¨å˜é‡å‰é¢å¯¹å˜é‡è¿›è¡Œ**â€œå–åœ°å€â€**æ“ä½œã€‚ Goè¯­è¨€ä¸­çš„å€¼ç±»å‹ï¼ˆintã€floatã€boolã€stringã€arrayã€structï¼‰ï¼Œå¯¹åº”çš„æŒ‡é’ˆ *intã€*int64ã€*stringç­‰ã€‚ 1 2 3 4 5 6 // å–å˜é‡æŒ‡é’ˆåœ°å€è¯­æ³• ptr := \u0026amp;v // vçš„ç±»å‹ä¸ºT // v: ä»£è¡¨è¢«å–åœ°å€çš„å˜é‡ï¼Œç±»å‹ä¸ºT // ptrï¼šç”¨äºæ¥æ”¶åœ°å€çš„å˜é‡ï¼Œptrçš„ç±»å‹å°±ä¸º*Tï¼Œç§°åšTçš„æŒ‡é’ˆç±»å‹ // * ä»£è¡¨æŒ‡é’ˆ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 package main import \u0026#34;fmt\u0026#34; func main() { a := 10\t// intç±»å‹ b := \u0026amp;a\t// *intç±»å‹ // a:10 ptr:0xc00001a078 type:int fmt.Printf(\u0026#34;a:%d ptr:%p type:%T\\n\u0026#34;, a, \u0026amp;a, a) // b:0xc00001a078 type:*int fmt.Printf(\u0026#34;b:%p type:%T\\n\u0026#34;, b, b) // 0xc00000e018 fmt.Println(\u0026amp;b) } æŒ‡é’ˆå–å€¼ åœ¨å¯¹æ™®é€šå˜é‡ä½¿ç”¨\u0026amp;æ“ä½œç¬¦å–åœ°å€åä¼šè·å¾—è¿™ä¸ªå˜é‡çš„æŒ‡é’ˆï¼Œç„¶åå¯ä»¥å¯¹æŒ‡é’ˆä½¿ç”¨*æ“ä½œï¼Œä¹Ÿå°±æ˜¯æŒ‡é’ˆå–å€¼ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 package main import \u0026#34;fmt\u0026#34; func main() { a := 10 // intç±»å‹ // å–å˜é‡açš„åœ°å€ï¼Œå°†æŒ‡é’ˆä¿å­˜åˆ°bä¸­ b := \u0026amp;a // *intç±»å‹ fmt.Printf(\u0026#34;type of b:%T\\n\u0026#34;, b) // type of b:*int // æŒ‡é’ˆå–å€¼ï¼ˆæ ¹æ®æŒ‡é’ˆå»å†…å­˜å–å€¼ï¼‰ c := *b fmt.Printf(\u0026#34;type of c:%T\\n\u0026#34;, c) // type of c:int fmt.Printf(\u0026#34;value of c:%v\\n\u0026#34;, c)// value of c:10 *b = 11 fmt.Println(a, *b, c) // 11 11 10 } ç©ºæŒ‡é’ˆ å½“ä¸€ä¸ªæŒ‡é’ˆè¢«å®šä¹‰åæ²¡æœ‰åˆ†é…åˆ°ä»»ä½•å˜é‡æ—¶ï¼Œå®ƒçš„å€¼ä¸º nilã€‚ ç©ºæŒ‡é’ˆçš„åˆ¤æ–­ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 package main import \u0026#34;fmt\u0026#34; func main() { var p *string fmt.Println(p) // \u0026lt;nil\u0026gt; fmt.Printf(\u0026#34;pçš„å€¼æ˜¯%v\\n\u0026#34;, p) // pçš„å€¼æ˜¯\u0026lt;nil\u0026gt; if p != nil { fmt.Println(\u0026#34;éç©º\u0026#34;) } else { fmt.Println(\u0026#34;ç©ºå€¼\u0026#34;) // ç©ºå€¼ } } ç±»å‹è½¬æ¢ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 { var ff float64 = 12.23 ii := *(*uint64)(unsafe.Pointer(\u0026amp;ff)) // uint64 ç±»å‹ fmt.Printf(\u0026#34;%064b \\n\u0026#34;, ii) ff1 := *(*float64)(unsafe.Pointer(\u0026amp;ii)) fmt.Println(ff1) // Output: // 0100000000101000011101011100001010001111010111000010100011110110 // 12.23 } æŒ‡é’ˆç»ƒä¹  ç¨‹åºå®šä¹‰ä¸€ä¸ªintå˜é‡numçš„åœ°å€å¹¶æ‰“å°ã€‚ å°†numçš„åœ°å€èµ‹ç»™æŒ‡é’ˆptrï¼Œå¹¶é€šè¿‡ptrå»ä¿®æ”¹numçš„å€¼ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 package main import \u0026#34;fmt\u0026#34; func main() { var a int fmt.Println(\u0026amp;a) var p *int p = \u0026amp;a *p = 20 fmt.Println(a) } ä½¿ç”¨æ³¨æ„ ã€å¸¸é‡ã€‘ä¸èƒ½ä½¿ç”¨\u0026amp;å–åœ°å€ï¼Œå¸¸é‡æ˜¯åªè¯»ç±»å‹å› æ­¤å–åœ°å€æ²¡å•¥æ„ä¹‰ã€‚ ã€å­—ç¬¦ä¸²å…ƒç´ ã€‘ï¼Œæ¯”å¦‚\u0026amp;string[0]ä¸èƒ½å–åœ°å€ï¼Œå­—ç¬¦ä¸²ä¹Ÿæ˜¯åªè¯»ç±»å‹å¯¹å­—ç¬¦ä¸²ä¸­çš„ç¬¦å·å–åœ°å€æ„ä¹‰ä¹Ÿä¸å¤§ã€‚ ã€å­—å…¸å…ƒç´ ã€‘ï¼Œæ¯”å¦‚\u0026amp;map[â€˜keyâ€™]ä¸èƒ½å–åœ°å€ï¼Œå­—å…¸çš„å­˜å‚¨ä½ç½®æ˜¯ç»å¸¸å˜åŒ–çš„ï¼Œå› æ­¤å¯¹å­—å…¸ä¸­å…ƒç´ å–åœ°å€æ„ä¹‰ä¸å¤§ã€‚ æ€»ç»“ å–åœ°å€æ“ä½œç¬¦\u0026amp;å’Œå–å€¼æ“ä½œç¬¦*æ˜¯ä¸€å¯¹äº’è¡¥æ“ä½œç¬¦ã€‚ \u0026amp;ï¼šå–å‡ºåœ°å€ï¼›*ï¼šæ ¹æ®åœ°å€å–å‡ºåœ°å€æŒ‡å‘çš„å€¼ã€‚ å˜é‡ã€æŒ‡é’ˆåœ°å€ã€æŒ‡é’ˆå˜é‡ã€å–åœ°å€ã€å–å€¼çš„ç›¸äº’å…³ç³»å’Œç‰¹æ€§å¦‚ä¸‹ï¼š å¯¹å˜é‡è¿›è¡Œå–åœ°å€ï¼ˆ\u0026amp;ï¼‰æ“ä½œï¼Œå¯ä»¥è·å¾—è¿™ä¸ªå˜é‡çš„å­˜å‚¨åœ°å€ã€‚ æŒ‡é’ˆå˜é‡çš„å€¼æ˜¯æŒ‡é’ˆåœ°å€ã€‚ å¯¹æŒ‡é’ˆå˜é‡è¿›è¡Œå–å€¼ï¼ˆ*ï¼‰æ“ä½œï¼Œå¯ä»¥è·å¾—æŒ‡é’ˆå˜é‡æŒ‡å‘çš„åŸå˜é‡çš„å€¼ã€‚ æŒ‡é’ˆä¼ å€¼ä¾‹å­ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 package main import \u0026#34;fmt\u0026#34; func main() { a := 10 modify1(a) fmt.Println(a) // 10 modify2(\u0026amp;a) fmt.Println(a) // 100 } func modify1(x int) { x = 100 } func modify2(x *int) { *x = 100 } ","permalink":"https://heliu.site/posts/golang/basic/pointer/","summary":"Golang æŒ‡é’ˆä»‹ç»ã€‚","title":"æŒ‡é’ˆ"},{"content":" ä½¿ç”¨åå¼•å·(``)æˆ–åŒå¼•å·(\u0026quot;\u0026quot;)æ¥å®šä¹‰å­—ç¬¦ä¸²ï¼Œåå¼•å·è¡¨ç¤ºåŸç”Ÿçš„å­—ç¬¦ä¸²ï¼Œå³ä¸è¿›è¡Œè½¬ä¹‰ã€‚ åŒå¼•å· å­—ç¬¦ä¸²ä½¿ç”¨åŒå¼•å·æ‹¬èµ·æ¥ï¼Œå…¶ä¸­ç›¸å…³çš„è½¬ä¹‰å­—ç¬¦å°†è¢«æ›¿æ¢ã€‚ 1 str := \u0026#34;hello world! \\n Hello \\n\u0026#34; // \\n è¡¨ç¤ºæ¢è¡Œ 1 2 3 4 5 6 7 8 9 func Example() { str := \u0026#34;hello world! \\n Hello \\n\u0026#34; fmt.Printf(\u0026#34;%s\u0026#34;, str) // Output: // hello world! // Hello // } åå¼•å· å­—ç¬¦ä¸²ä½¿ç”¨åå¼•å·æ‹¬èµ·æ¥ï¼Œå…¶ä¸­ç›¸å…³çš„è½¬ä¹‰å­—ç¬¦ä¸ä¼šè¢«æ›¿æ¢ã€‚ 1 str := `hello world! \\n Hello \\n`\t// \\n è¡¨ç¤ºæ¢è¡Œ 1 2 3 4 5 6 7 func Example() { str := `hello world! \\n Hello \\n` fmt.Printf(\u0026#34;%s\u0026#34;, str) // Output: // hello world! \\n Hello \\n } åŒå¼•å·å’Œåå¼•å·å­˜å‚¨çš„åŒºåˆ«ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 package main import \u0026#34;fmt\u0026#34; func main() { // éªŒè¯ä¸¤ç§å½¢å¼å­—ç¬¦ä¸²çš„åŒºåˆ« s1 := \u0026#34;hello,\\nworld\u0026#34; // 12 s2 := `hello,\\nworld` // 13 // å¯è§(åŒå¼•å·ä¸­ï¼Œ\\nå½“ä½œè½¬ä¹‰å­—ç¬¦åœ¨å¤„ç†)ï¼Œå½“ä½œä¸€ä¸ªå­—èŠ‚ // (åå¼•å·ä¸­ï¼Œ\\nå½“ä½œä¸¤ä¸ªå­—ç¬¦å¤„ç†)å½“ä½œä¸¤ä¸ªå­—èŠ‚ fmt.Println(len(s1), len(s2)) // Output: // 12 13 } å­—ç¬¦ä¸² Goè¯­è¨€ä¸­çš„stringç±»å‹æ˜¯ä¸€ç§å€¼ç±»å‹ï¼Œå­˜å‚¨çš„å­—ç¬¦ä¸²æ˜¯ä¸å¯å˜çš„ã€‚ å¦‚æœéœ€è¦ä¿®æ”¹stringçš„å†…å®¹ï¼Œéœ€è¦å°†stringè½¬æ¢ä¸º[]byteæˆ–[]runeï¼Œå¹¶ä¸”ä¿®æ”¹åçš„stringå†…å®¹æ˜¯é‡æ–°ç”Ÿæˆçš„ã€‚ Goé»˜è®¤ä½¿ç”¨UTF-8ç¼–ç ï¼Œå¯¹Unicodeçš„æ”¯æŒéå¸¸å¥½ã€‚ å­—ç¬¦ä¸²å­˜å‚¨ç»“æ„ï¼š 1 2 3 4 5 6 type StringStruct struct { // æŒ‡å‘å­—ç¬¦ä¸²çš„åº•å±‚æ•°ç»„çš„é¦–å­—èŠ‚åœ°å€ï¼Œå°±æ˜¯ä¸€ä¸ªæŒ‡é’ˆåœ°å€ Data unsafe.Pointer // ä¿å­˜å­—ç¬¦ä¸²çš„é•¿åº¦ï¼Œå…¶å®å°±æ˜¯intç±»å‹å¤§å° Len uintptr } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 type stringStruct struct { str unsafe.Pointer len uintptr } { var aa1 [32]byte var ll1 uintptr = 6 // å­—ç¬¦ä¸²ä¸€æ ·è¢«åˆ†é…åœ¨åªè¯»å†…å­˜ä¸Šï¼Œ // åªæ˜¯è¯¥åº•å±‚æ•°ç»„ä¸èƒ½æ“ä½œä½†æ˜¯èƒ½æ›¿æ¢stringStruct.strå­˜å‚¨çš„å€¼ var sss string = \u0026#34;b\u0026#34; // æ›¿æ¢æ‰åŸå…ˆæŒ‡å‘çš„åªè¯»å†…å­˜ä½ç½®åˆ°aa1æ ˆä¸Šçš„æ•°æ®ï¼Œ // ä»¥ä¸‹ä»£ç æ˜¯ä½¿sssåº•å±‚æ•°ç»„å’Œaa1ç›¸å…³è”èµ·æ¥ï¼Œæ“ä½œaa1ä¹Ÿå°±æ˜¯æ“ä½œsss s2s1 := (*stringStruct)(unsafe.Pointer(\u0026amp;sss)) s2s1.str = unsafe.Pointer(\u0026amp;aa1)\t// æ›¿æ¢è¯¥å€¼ s2s1.len = ll1 bbb1 := aa1[:ll1] bbb1[1] = \u0026#39;a\u0026#39; // [0 97 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0] // a // [0 97 0 0 0 0] fmt.Println(aa1, sss, bbb1) } byte å’Œ rune è¿™ä¸¤ä¸ªç±»å‹æ˜¯å¤„ç†å­—ç¬¦ç›¸å…³ã€‚ type byte = uint8ã€type rune = int32ã€‚ 1 2 3 4 5 6 7 // byte å’Œ rune type byte = uint8 // é•¿åº¦ 1B type rune = int32 // é•¿åº¦ 4B // ç±»å‹stringç±»å‹çš„é›¶å€¼æ˜¯é•¿åº¦ä¸ºé›¶çš„å­—ç¬¦ä¸²ï¼Œå³ç©ºå­—ç¬¦ä¸² \u0026#34;\u0026#34; var b byte = \u0026#39;a\u0026#39; // ASCIIç ç›¸å¯¹åº”æ•°å€¼ var r rune = \u0026#39;å¥½\u0026#39; // Unicodeç›¸å¯¹åº”ç¼–ç  Unicode è½¬ UTF-8 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;unicode/utf8\u0026#34; ) func main() { var s string = \u0026#34;hello Goè¯­è¨€\u0026#34;\t// 8 + 2*3 = 14 fmt.Println(len(s)) // 14 å­—èŠ‚ fmt.Println(utf8.RuneCountInString(s)) // 10 å­—ç¬¦ // æŠŠå­—ç¬¦ä¸²sæ˜¾ç¤ºè½¬æ¢ä¸º[]byteç±»å‹ï¼Œæ­¤æ—¶ä¼šåˆ†é…æ–°çš„åº•å±‚æ•°ç»„ç©ºé—´è€Œä¸æ˜¯å…±ç”¨ä¹‹å‰ slice1 := []byte(s) // utf-8ç¼–ç  è½¬ unicode // | Unicodeç¬¦å·èŒƒå›´ | UTF-8ç¼–ç æ–¹å¼ï¼Œç¼–ç æ¨¡æ¿ // n | åå…­è¿›åˆ¶ | äºŒè¿›åˆ¶ // --+-----------------------+-------------------------------------------------------- // 1 | 0000 0000 - 0000 007F | 0xxxxxxx // 2 | 0000 0080 - 0000 07FF | 110xxxxx 10xxxxxx // 3 | 0000 0800 - 0000 FFFF | 1110xxxx 10xxxxxx 10xxxxxx // 4 | 0001 0000 - 0010 FFFF | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx utf8æœ€å¤§4å­—èŠ‚ // 5 | 0020 0000 - 03FF FFFF | 111110xx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx // 6 | 0400 0000 - 7FFF FFFF | 1111110x 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx // --+-----------------------+-------------------------------------------------------- // 232 175 173\t=utf8è½¬äºŒè¿›åˆ¶=\u0026gt; 11101000 10101111 10101101 =è½¬unicode=\u0026gt; 10001011 11101101 =\u0026gt; 35821 è¯­ // 232 168 128\t=utf8è½¬äºŒè¿›åˆ¶=\u0026gt; 11101000 10101000 10000000 =è½¬unicode=\u0026gt; 10001010 00000000 =\u0026gt; 35328 è¨€ fmt.Println(slice1) // [104 101 108 108 111 32 71 111 232 175 173 232 168 128] // æŠŠå­—ç¬¦ä¸²sæ˜¾ç¤ºè½¬æ¢ä¸º[]runeç±»å‹ slice2 := []rune(s) fmt.Println(slice2) // [104 101 108 108 111 32 71 111 35821 35328] for i, v := range s { // int, rune fmt.Printf(\u0026#34;i:%d %#U %d \\n\u0026#34;, i, v, v) } /* * i:0 U+0068 \u0026#39;h\u0026#39; 104 * i:1 U+0065 \u0026#39;e\u0026#39; 101 * i:2 U+006C \u0026#39;l\u0026#39; 108 * i:3 U+006C \u0026#39;l\u0026#39; 108 * i:4 U+006F \u0026#39;o\u0026#39; 111 * i:5 U+0020 \u0026#39; \u0026#39; 32 * i:6 U+0047 \u0026#39;G\u0026#39; 71 * i:7 U+006F \u0026#39;o\u0026#39; 111 * i:8 U+8BED \u0026#39;è¯­\u0026#39; 35821 * i:11 U+8A00 \u0026#39;è¨€\u0026#39; 35328 */ // 232 175 173\t=\u0026gt; 35821 // E8 AF AD =\u0026gt; 8BED // å­—ç¬¦ä¸²çš„å•ä¸ªå­—ç¬¦æ˜¯byteä¹Ÿå°±æ˜¯uint8ç±»å‹ fmt.Printf(\u0026#34;%T\\n\u0026#34;, s[0]) // uint8 // å­—ç¬¦ä¸²ä½¿ç”¨åˆ‡ç‰‡åä¾ç„¶æ˜¯å­—ç¬¦ä¸²ç±»å‹ fmt.Printf(\u0026#34;%T\\n\u0026#34;, s[:]) // string } å­—ç¬¦ä¸²æ¯”è¾ƒ ä¸€èˆ¬çš„æ¯”è¾ƒè¿ç®—ç¬¦ï¼ˆ==ã€!=ã€\u0026lt;ã€\u0026lt;=ã€\u0026gt;=ã€\u0026gt;ï¼‰é€šè¿‡åœ¨å†…å­˜ä¸­æ¥å­—èŠ‚æ¯”è¾ƒæ¥å®ç°å­—ç¬¦ä¸²çš„å¯¹æ¯”ã€‚ æ¯”è¾ƒæºç å‡½æ•°ï¼š 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 //go:linkname runtime_cmpstring runtime.cmpstring func runtime_cmpstring(a, b string) int { l := len(a) // lè®°å½•aå’Œbæœ€å°çš„ä¸€ä¸ªé•¿åº¦ if len(b) \u0026lt; l {\tl = len(b) } for i := 0; i \u0026lt; l; i++ { // éå† c1, c2 := a[i], b[i] if c1 \u0026lt; c2 { // a \u0026lt; b è¿”å› -1 return -1 } if c1 \u0026gt; c2 { // a \u0026gt; b è¿”å› +1 return +1 } } // è¿™é‡Œè¯´æ˜å‰é¢å­—ä¸²éƒ½ä¸€æ ·ï¼Œç°åœ¨æ¯”è¾ƒè°é•¿ // ç”±äºä¸Šé¢éå†çš„æœ€çŸ­é•¿åº¦çš„æ‰€ä»¥éœ€è¦å†æ¬¡åˆ¤æ–­é•¿åº¦æ¯”è¾ƒ if len(a) \u0026lt; len(b) {\treturn -1 } if len(a) \u0026gt; len(b) { return +1 } // a == b è¿”å› 0 return 0 } å­—ç¬¦ä¸²é•¿åº¦ len()å‡½æ•°è·å–å­—ç¬¦ä¸²æ‰€å çš„å­—èŠ‚é•¿åº¦ï¼Œç”±å­—ç¬¦ä¸²çš„ç»“æ„å¯çŸ¥å­—ç¬¦ä¸²çš„é•¿åº¦ä¿å­˜åœ¨å­—ç¬¦ä¸²çš„ç¬¬äºŒä¸ªå­—æ®µä¸­ã€‚ 1 2 // ASCIIä¸­ a-\u0026gt;97 A-\u0026gt;65 fmt.Println(\u0026#39;a\u0026#39; \u0026gt; \u0026#39;A\u0026#39;) // true å†…ç½®çš„len()å‡½æ•°è·å–çš„æ˜¯å­—èŠ‚çš„é•¿åº¦å’Œï¼Œè€Œä¸æ˜¯å­—ç¬¦æ•°é‡ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;unicode/utf8\u0026#34; ) func main() { s := \u0026#34;å…¶å®å°±æ˜¯rune\u0026#34; fmt.Println(len(s)) // 16 å­—èŠ‚ 4*3 + 4 fmt.Println(utf8.RuneCountInString(s)) // 8 å­—ç¬¦ } å­—ç¬¦ä¸²çš„å†…å®¹(çº¯å­—èŠ‚)å¯ä»¥é€šè¿‡æ ‡å‡†ç´¢å¼•æ¥è·å–ï¼Œåœ¨ä¸­æ‹¬å·[]å†…å†™å…¥ç´¢å¼•ï¼Œç´¢å¼•ä»0å¼€å§‹ã€‚ å­—ç¬¦ä¸²strçš„ç¬¬ä¸€ä¸ªå­—èŠ‚ str[0]ã€‚ ç¬¬ i å­—èŠ‚ str[i - 1]ã€‚ æœ€å1ä¸ªå­—èŠ‚ str[len(str) - 1]ã€‚ 1 2 3 4 5 6 7 s1 := \u0026#34;hello, world!\u0026#34; fmt.Printf(\u0026#34;%c\\n\u0026#34;, s1[0]) // h fmt.Printf(\u0026#34;%c\\n\u0026#34;, s1[7]) // w // ä¸èƒ½ä½¿ç”¨\u0026amp;s1[0]è¿™ç§å½¢å¼å–åœ°å€ï¼Œå› ä¸ºå­—ç¬¦ä¸²æ˜¯ä¸å¯å˜ç±»å‹è¿™ç§å½¢å¼çš„å–åœ°å€æ²¡æœ‰ä»»ä½•æ„ä¹‰ // ä½†æ˜¯è·å–åˆ°s1[0]çš„åœ°å€ä¹Ÿæ˜¯æœ‰åŠæ³•çš„ï¼Œé€šè¿‡unsafe å¦‚æœå­—ç¬¦ä¸²å«æœ‰ä¸­æ–‡ç­‰å­—ç¬¦ï¼Œå¯ä»¥çœ‹åˆ°æ¯ä¸ªä¸­æ–‡å­—ç¬¦çš„ç´¢å¼•å€¼ç›¸å·®3ã€‚ Goçš„rangeå¾ªç¯åœ¨å¤„ç†å­—ç¬¦ä¸²çš„æ—¶å€™ï¼Œä¼šè‡ªåŠ¨éšå¼è§£ç UTF-8å­—ç¬¦ä¸²ï¼Œå…³äºå¾ªç¯çš„å¤„ç†å‚çœ‹forç›¸å…³æ–‡æ¡£ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 package main import ( \u0026#34;fmt\u0026#34; ) func main() { s := \u0026#34;å…¶å®å°±æ˜¯rune\u0026#34; // v å…¶å®å°±æ˜¯runeç±»å‹å€¼ for k, v := range s{ // ã€int, runeã€‘ fmt.Printf(\u0026#34;K: %d, V: %c === %d\\n\u0026#34;, k, v, v) } // Output: // K: 0, V: å…¶ === 20854 // K: 3, V: å® === 23454 // K: 6, V: å°± === 23601 // K: 9, V: æ˜¯ === 26159 // K: 12, V: r === 114 // K: 13, V: u === 117 // K: 14, V: n === 110 // K: 15, V: e === 101 } å­—ç¬¦ä¸²æ‹¼æ¥ å°†å¤šä¸ªå­—ç¬¦ä¸²æ‹¼æ¥æˆä¸€ä¸ªå­—ç¬¦ä¸²ã€‚ + æ‹¼æ¥ ä¸‹é¢çš„ç¤ºä¾‹ï¼Œå­—ç¬¦ä¸²éƒ½æ˜¯ä¸å¯å˜çš„ï¼Œæ¯æ¬¡è¿ç®—éƒ½ä¼šäº§ç”Ÿä¸€ä¸ªæ–°çš„å­—ç¬¦ä¸²ï¼Œæ‰€ä»¥ä¼šäº§ç”Ÿå¾ˆå¤šä¸´æ—¶çš„å­—ç¬¦ä¸²ã€‚ ä¸ä»…æ²¡ç”¨è¿˜ä¼šç»™åƒåœ¾å›æ”¶å¸¦æ¥é¢å¤–è´Ÿæ‹…ï¼Œæ‰€ä»¥æ€§èƒ½æ¯”è¾ƒå·®ã€‚ æ•°é‡è¾ƒå°‘çš„ + è¿˜è¡Œï¼Œæ¯”å¦‚ 5 ä¸ªæˆ–ä»¥ä¸‹ã€‚ 1 2 3 4 5 6 7 // è¿™ç§ç”±äºç¼–è¾‘å™¨ä¼šåœ¨ä»£ç è¡Œå°¾è‡ªåŠ¨è¡¥å…¨åˆ†å·çš„ç¼˜ç”±ï¼ŒåŠ å·å¿…é¡»æ”¾åœ¨ç¬¬ä¸€è¡Œ str := \u0026#34;hello\u0026#34; + \u0026#34;,world\u0026#34; // += å½¢å¼æ‹¼æ¥å­—ç¬¦ä¸² s := \u0026#34;hello\u0026#34; + \u0026#34;,world\u0026#34; s += \u0026#34;!\u0026#34; fmt.Sprintf() å†…éƒ¨ä½¿ç”¨[]byteå®ç°ï¼Œä¸åƒç›´æ¥ä½¿ç”¨+æ‹¼æ¥äº§ç”Ÿä¸´æ—¶çš„å­—ç¬¦ä¸²ã€‚ ä½†æ˜¯å†…éƒ¨é€»è¾‘æ¯”è¾ƒå¤æ‚ï¼Œå¾ˆå¤šé¢å¤–çš„åˆ¤æ–­ï¼Œç”¨åˆ°äº†æ¥å£ï¼Œæ‰€ä»¥æ€§èƒ½ä¸€èˆ¬ã€‚ 1 fmt.Sprintf(\u0026#34;%d:%s\u0026#34;, 2021, \u0026#34;Golang\u0026#34;) // 2021:Golang strings.Join() Joinä¼šå…ˆæ ¹æ®å­—ç¬¦ä¸²æ•°ç»„çš„å†…å®¹ï¼Œè®¡ç®—ä¸€ä¸ªæ‹¼æ¥ä¹‹åçš„é•¿åº¦ã€‚ ç„¶åç”³è¯·å¯¹åº”å¤§å°çš„å†…å­˜ï¼Œä¸€ä¸ªä¸€ä¸ªå­—ç¬¦ä¸²å¡«å…¥ã€‚ åœ¨å·²æœ‰ä¸€ä¸ªæ•°ç»„çš„æƒ…å†µä¸‹æ•ˆç‡å¾ˆé«˜ï¼Œä½†æ˜¯æ„é€ ä¸€ä¸ªæœ¬æ¥æ²¡æœ‰çš„æ•°æ®ä»£ä»·ä¹Ÿä¸å°ã€‚ 1 strings.Join([]string{\u0026#34;hello,\u0026#34;, \u0026#34;world\u0026#34;, \u0026#34;Golang\u0026#34;}, \u0026#34;!!!\u0026#34;) // hello,!!!world!!!Golang bytes.Buffer æ¯”è¾ƒç†æƒ³ï¼Œå¯ä»¥å½“æˆå¯å˜å­—ç¬¦ä½¿ç”¨ï¼Œå¯¹å†…å­˜çš„å¢é•¿ä¹Ÿæœ‰ä¼˜åŒ–ã€‚ å¦‚æœèƒ½é¢„ä¼°å­—ç¬¦ä¸²çš„é•¿åº¦ï¼Œå¯ä»¥ä½¿ç”¨buffer.Grow()æ¥å£æ¥è®¾ç½®capacityï¼Œå°±æ˜¯è®¾ç½®åˆ‡ç‰‡å®¹é‡ï¼Œé¿å…ç¿»å€æ‰©å®¹é€ æˆæ€§èƒ½ä¸‹é™ã€‚ 1 2 3 4 5 var buffer bytes.Buffer buffer.WriteString(\u0026#34;hello\u0026#34;) buffer.WriteString(\u0026#34;,\u0026#34;) buffer.WriteString(\u0026#34;world!\u0026#34;) fmt.Print(buffer.String()) strings.Builder å†…éƒ¨é€šè¿‡åˆ‡ç‰‡æ¥ä¿å­˜å’Œç®¡ç†å†…å®¹ã€‚ åˆ‡ç‰‡å†…éƒ¨åˆ™æ˜¯é€šè¿‡ä¸€ä¸ªæŒ‡é’ˆæŒ‡å‘å®é™…ä¿å­˜å†…å®¹çš„æ•°ç»„ã€‚ strings.BuilderåŒæ ·ä¹Ÿæä¾›äº†Grow()æ¥æ”¯æŒé¢„å®šäºå®¹é‡ï¼Œå°±æ˜¯è®¾ç½®åˆ‡ç‰‡å®¹é‡ï¼Œé¿å…ç¿»å€æ‰©å®¹é€ æˆæ€§èƒ½ä¸‹é™ã€‚ å½“å¯ä»¥é¢„å®šä¹‰éœ€è¦ä½¿ç”¨çš„å®¹é‡æ—¶ï¼Œstrings.Builderå°±èƒ½é¿å…å› æ‰©å®¹äº§ç”Ÿæ–°çš„åˆ‡ç‰‡ã€‚ strings.Builderæ˜¯éçº¿ç¨‹å®‰å…¨çš„ï¼Œæ€§èƒ½å’Œbytes.Bufferç›¸å·®æ— å‡ ã€‚ 1 2 3 4 var b1 string.Builder b1.WriteString(\u0026#34;hello,\u0026#34;) b1.WriteString(\u0026#34;world!\u0026#34;) fmt.Print(b1.String()) å­—ç¬¦ä¸²å¤„ç† æ ‡å‡†åº“å››ä¸ªå¯¹å­—ç¬¦ä¸²å¤„ç†åŒ…ï¼šbytesã€stringsã€strconvã€unicodeã€‚ åŒ… æè¿° strings æä¾›äº†è®¸å¤šå¦‚å­—ç¬¦ä¸²çš„æŸ¥è¯¢ã€æ›¿æ¢ã€æ¯”è¾ƒã€æˆªæ–­ã€æ‹†åˆ†å’Œåˆå¹¶ç­‰åŠŸèƒ½ bytes è¯¥åŒ…ä¹Ÿæä¾›äº†ç±»ä¼¼stringsåŠŸèƒ½çš„å‡½æ•°ï¼Œä½†æ˜¯é’ˆå¯¹å’Œå­—ç¬¦ä¸²æœ‰ç€ç›¸åŒç»“æ„çš„[]byteç±»å‹ï¼Œå› ä¸ºå­—ç¬¦ä¸²åªæ˜¯åªè¯»ï¼Œå› æ­¤é€æ­¥æ„å»ºå­—ç¬¦ä¸²ä¼šå¯¼è‡´å¾ˆå¤šåˆ†é…å’Œå¤åˆ¶ã€‚åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œä½¿ç”¨bytes.Bufferç±»å‹å°†æ›´æœ‰æ•ˆ strconv æä¾›äº†å¸ƒå°”å‹ã€æ•´å‹æ•°ã€æµ®ç‚¹æ•°å’Œå¯¹åº”å­—ç¬¦ä¸²çš„ç›¸äº’è½¬æ¢ï¼Œè¿˜æä¾›äº†åŒå¼•å·è½¬ä¹‰ç›¸å…³çš„è½¬æ¢ unicode æä¾›äº†IsDigitã€IsLetterã€IsUpperå’ŒIsLowerç­‰ç±»ä¼¼åŠŸèƒ½ï¼Œç”¨äºç»™å®šå­—ç¬¦åˆ†ç±» åˆ¤æ–­ä»¥æŸå­—ç¬¦ä¸²å¼€å¤´æˆ–ç»“å°¾ strings.HasPrefix(s, prefix string) bool åˆ¤æ–­æ˜¯å¦ä»¥æŸä¸ªå­—ç¬¦ä¸²å¼€å¤´ã€‚ strings.HasSuffix(s, suffix string) bool åˆ¤æ–­æ˜¯å¦ä»¥æŸä¸ªå­—ç¬¦ä¸²ç»“å°¾ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;strings\u0026#34; ) func main() { s := `å¿«æ¨‚ \\n Ak` fmt.Println(strings.HasPrefix(s, \u0026#34;å¿«æ¨‚\u0026#34;)) // true fmt.Println(strings.HasPrefix(s, \u0026#34;A\u0026#34;)) // false // Output: // true // false } å­—ç¬¦ä¸²åˆ†å‰² strings.Split(s, sep string) []string ä½¿ç”¨sepå­—ç¬¦ä¸²åˆ†éš”så­—ç¬¦ä¸²ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;strings\u0026#34; ) func main() { s := `A,B,C,D,E,F,G,H` fmt.Println(strings.Split(s, \u0026#34;,\u0026#34;)) // [A B C D E F G H] // Output: // [A B C D E F G H] } è¿”å›å­ä¸²ç´¢å¼• strings.Index(s, substr string) int è¿”å›ç¬¬ä¸€æ¬¡åŒ¹é…åˆ°çš„ç´¢å¼•ã€‚ strings.LastIndex(a, substr string) int è¿”å›æœ€åä¸€ä¸ªåŒ¹é…åˆ°çš„ç´¢å¼•ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;strings\u0026#34; ) func main() { s := `A,B,C,D,E,F,G,H` fmt.Println(strings.Index(s, \u0026#34;,\u0026#34;)) // 1 fmt.Println(strings.LastIndex(s, \u0026#34;,\u0026#34;)) // 13 fmt.Println(strings.Index(s, \u0026#34;D\u0026#34;)) // 6 fmt.Println(strings.LastIndex(s, \u0026#34;D\u0026#34;)) // 6 fmt.Println(strings.Index(s, \u0026#34;M\u0026#34;)) // -1 fmt.Println(strings.LastIndex(s, \u0026#34;M\u0026#34;)) // -1 } å­—ç¬¦ä¸²è¿æ¥ strings.Join(a []string, sep string) string ä½¿ç”¨sepå­—ç¬¦ä¸²æ‹¼æ¥aå­—ç¬¦ä¸²åˆ‡ç‰‡ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;strings\u0026#34; ) func main() { s := []string{\u0026#34;A\u0026#34;,\u0026#34;D\u0026#34;,\u0026#34;G\u0026#34;,\u0026#34;R\u0026#34;,\u0026#34;G\u0026#34;,\u0026#34;S\u0026#34;,\u0026#34;F\u0026#34;} // æ³¨æ„è¿™é‡Œçš„så¿…é¡»æ˜¯åˆ‡ç‰‡[]stringç±»å‹ fmt.Println(strings.Join(s, \u0026#34;,\u0026#34;)) // A,D,G,R,G,S,F // Output: // A,D,G,R,G,S,F } å­—ç¬¦ä¸²æ›¿æ¢ strings.Replace(s, old, new string, n int) string åœ¨så­—ç¬¦ä¸²ä¸­æœç´¢oldå­—ç¬¦ä¸²å¹¶æ›¿æ¢æˆnewå­—ç¬¦ä¸²ï¼Œnæ›¿æ¢ä¸ªæ•°ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;strings\u0026#34; ) func main() { s := \u0026#34;A,D,G,R,G,S,F,D,G,f,d,D,,FW,A,D\u0026#34; old := \u0026#34;,D\u0026#34; new := \u0026#34;-A-\u0026#34; // strings.Replace(s, old, new string, n int) // s åŸå­—ç¬¦ä¸² // old éœ€è¦è¢«æ›¿æ¢æ—§çš„å­—ç¬¦ä¸² // new éœ€è¦è¢«æ›¿æ¢æ–°çš„å­—ç¬¦ä¸² // æ›¿æ¢ä¸ªæ•° n\u0026lt;0 é»˜è®¤æ›¿æ¢å…¨éƒ¨ | n=0 ä¸æ›¿æ¢ | n=1 é»˜è®¤æ›¿æ¢ä¸€ä¸ª fmt.Println(strings.Replace(s, old, new, -1)) // A-A-,G,R,G,S,F-A-,G,f,d-A-,,FW,A-A- fmt.Println(strings.Replace(s, old, new, 0)) // A,D,G,R,G,S,F,D,G,f,d,D,,FW,A,D fmt.Println(strings.Replace(s, old, new, 1)) // A-A-,G,R,G,S,F,D,G,f,d,D,,FW,A,D fmt.Println(strings.Replace(s, old, new, 3)) // A-A-,G,R,G,S,F-A-,G,f,d-A-,,FW,A,D fmt.Println(strings.Replace(s, old, new, 30)) // A-A-,G,R,G,S,F-A-,G,f,d-A-,,FW,A-A- } ç»Ÿè®¡å­—ç¬¦åœ¨å­—ç¬¦ä¸²ä¸­çš„æ¬¡æ•° strings.Count(s, substr string) int ç»Ÿè®¡substrå­—ç¬¦ä¸²åœ¨så­—ç¬¦ä¸²ä¸­å‡ºç°çš„æ¬¡æ•°ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;strings\u0026#34; ) func main() { s := \u0026#34;A,D,G,R,G,S,F,D,G,f,d,D,,FW,A,D\u0026#34; fmt.Println(strings.Count(s, \u0026#34;,\u0026#34;)) // 15 fmt.Println(strings.Count(s, \u0026#34;D\u0026#34;)) // 4 // Output: // 15 // 4 } åˆ¤æ–­å­—ç¬¦ä¸²çš„åŒ…å«å…³ç³» strings.Contains(s, substr string) bool åˆ¤æ–­så­—ç¬¦ä¸²æ˜¯å¦åŒ…å«substrå­—ç¬¦ä¸²ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;strings\u0026#34; ) func main() { s := \u0026#34;A,D,G,R,G,S,F,D,G,f,d,D,,FW,A,D\u0026#34; fmt.Println(strings.Contains(s, \u0026#34;,D\u0026#34;)) // true fmt.Println(strings.Contains(s, \u0026#34;DD\u0026#34;)) // false // Output: // true // false } å­—ç¬¦ä¸²è½¬ä¹‰ç¬¦ Go è¯­è¨€çš„å­—ç¬¦ä¸²å¸¸è§è½¬ä¹‰ç¬¦åŒ…å«å›è½¦ã€æ¢è¡Œã€å•åŒå¼•å·ã€åˆ¶è¡¨ç¬¦ç­‰ï¼Œå¦‚ä¸‹è¡¨æ‰€ç¤ºã€‚ è½¬ä¹‰ å«ä¹‰ \\r å›è½¦ç¬¦ï¼ˆè¿”å›è¡Œé¦–ï¼‰ \\n æ¢è¡Œç¬¦ï¼ˆç›´æ¥è·³åˆ°ä¸‹ä¸€è¡Œçš„åŒåˆ—ä½ç½®ï¼‰ \\t åˆ¶è¡¨ç¬¦ \\' å•å¼•å· \\\u0026quot; åŒå¼•å· \\ åæ–œæ  1 2 3 4 5 6 7 8 9 10 11 12 package main import ( \u0026#34;fmt\u0026#34; ) func main() { fmt.Println(\u0026#34;str := \\\u0026#34;c:\\\\pprof\\\\main.exe\\\u0026#34;\u0026#34;) // Output: // str := \u0026#34;c:\\pprof\\main.exe\u0026#34; } byteå’Œruneç±»å‹ ç»„æˆæ¯ä¸ªå­—ç¬¦ä¸²çš„å…ƒç´ å«åšå­—ç¬¦ã€‚ å¯ä»¥é€šè¿‡éå†æˆ–è€…å•ä¸ªè·å–å­—ç¬¦ä¸²å…ƒç´ è·å¾—å­—ç¬¦ã€‚ å­—ç¬¦ç”¨è‹±æ–‡å•å¼•å·ï¼ˆ'ï¼‰åŒ…è£¹èµ·æ¥ã€‚ 1 2 3 4 5 // ä»¥ä¸‹å­—ç¬¦ç±»å‹éƒ½é»˜è®¤ runeç±»å‹ var a := \u0026#39;ä¸­\u0026#39; // rune var b := \u0026#39;x\u0026#39; // rune fmt.Printf(\u0026#34;b:%T\\n\u0026#34;, b) // b:int32 fmt.Printf(\u0026#34;a:%T\\n\u0026#34;, a) // a:int32 Go è¯­è¨€çš„å­—ç¬¦æœ‰ä»¥ä¸‹ä¸¤ç§ï¼š uint8ç±»å‹ï¼Œæˆ–è€…å«byteå‹ï¼Œä»£è¡¨äº†ASCIIç çš„ä¸€ä¸ªå­—ç¬¦ã€‚ runeç±»å‹ï¼Œä»£è¡¨ä¸€ä¸ªUnicodeå­—ç¬¦ã€‚ å½“éœ€è¦å¤„ç†ä¸­æ–‡ã€æ—¥æ–‡æˆ–è€…å…¶ä»–å¤åˆå­—ç¬¦æ—¶ï¼Œåˆ™éœ€è¦ç”¨åˆ°runeç±»å‹ã€‚ runeç±»å‹å®é™…æ˜¯ä¸€ä¸ªint32ã€‚ Go ä½¿ç”¨äº†ç‰¹æ®Šçš„ rune ç±»å‹æ¥å¤„ç† Unicodeï¼Œè®©åŸºäºUnicodeçš„æ–‡æœ¬å¤„ç†æ›´ä¸ºæ–¹ä¾¿ã€‚ ä¹Ÿå¯ä»¥ä½¿ç”¨ byte å‹è¿›è¡Œé»˜è®¤å­—ç¬¦ä¸²å¤„ç†ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // éå†å­—ç¬¦ä¸² func traversalString() { s := \u0026#34;pprof.cnåšå®¢\u0026#34; for i := 0; i \u0026lt; len(s); i++ { // ã€int, byteã€‘ fmt.Printf(\u0026#34;%v(%c) \u0026#34;, s[i], s[i]) } fmt.Println() for _, r := range s { // ã€int, runeã€‘ fmt.Printf(\u0026#34;%v(%c) \u0026#34;, r, r) } fmt.Println() } ä¿®æ”¹å­—ç¬¦ä¸² è¦ä¿®æ”¹å­—ç¬¦ä¸²ï¼Œéœ€è¦å…ˆå°†å…¶è½¬æ¢æˆ[]rune æˆ– []byteï¼Œå®Œæˆåå†è½¬æ¢ä¸ºstringã€‚ æ— è®ºå“ªç§è½¬æ¢ï¼Œéƒ½ä¼šé‡æ–°åˆ†é…å†…å­˜ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 func changeString() { s1 := \u0026#34;hello\u0026#34; // å¼ºåˆ¶ç±»å‹è½¬æ¢ byteS1 := []byte(s1) byteS1[0] = \u0026#39;H\u0026#39; fmt.Println(string(byteS1)) s2 := \u0026#34;åšå®¢\u0026#34; runeS2 := []rune(s2) runeS2[0] = \u0026#39;ç‹—\u0026#39; fmt.Println(string(runeS2)) } // ç±»å‹è½¬åŒ–ï¼Œä¸‹é¢å¯è§ç±»å‹è½¬æ¢éƒ½æ˜¯æ–°åˆ†é…å†…å­˜åœ°å€ // å†…å­˜åˆ†å¸ƒæ˜¯ä½å­—èŠ‚åœ¨å‰é«˜å­—èŠ‚åœ¨åæ’åºçš„ï¼Œä¸åŒçš„å¹³å°ä¸åŒ var u1 uint16 = 0b00000111_00000011 u2 := (uint8)(u1) fmt.Println(u2, \u0026amp;u1, \u0026amp;u2) // Output: // 3 0xc0000140b0 0xc0000140b2 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 type StringStruct struct { Data uintptr Len uintptr } type SliceStruct struct { Data uintptr Len uintptr Cap uintptr } func str() { s1 := \u0026#34;hello\u0026#34; fmt.Println(\u0026amp;s1) // 0xc0000102d0 fmt.Printf(\u0026#34;%#x\\n\u0026#34;, *(*uintptr)(unsafe.Pointer(\u0026amp;s1))) // 0x4a116b // çœ‹ä¸€ä¸‹s1çš„å­˜å‚¨çš„ç»“æ„ s := *(*StringStruct)(unsafe.Pointer(\u0026amp;s1)) fmt.Printf(\u0026#34;%#v\\n\u0026#34;, s) // main.StringStruct{Data:0x4a116b, Len:0x5} byteS1 := []byte(s1) // çœ‹çœ‹byteS1å­˜å‚¨çš„ç»“æ„ï¼Œä¸‹é¢ç»“æœå¯è§æ˜¯ä»æ–°åˆ†é…çš„å†…å­˜ ss := *(*SliceStruct)(unsafe.Pointer(\u0026amp;byteS1)) fmt.Printf(\u0026#34;%#v\\n\u0026#34;, ss) // main.SliceStruct{Data:0xc000074e28, Len:0x5, Cap:0x20} // è¿™é‡Œä¸ºä»€ä¹ˆå®¹é‡æ˜¯32ï¼Œæ¯”5å¤§é‚£ä¹ˆå¤šï¼Œå…·ä½“å‚çœ‹ []byte(s1) è½¬æ¢çš„æºç  fmt.Println(cap(byteS1)) // 32 // Output: // 0xc0000102d0 // 0x4a116b // main.StringStruct{Data:0x4a116b, Len:0x5} // main.SliceStruct{Data:0xc000074e28, Len:0x5, Cap:0x20} // 32 } ç±»å‹è½¬æ¢ Goè¯­è¨€ä¸­åªæœ‰æ˜¾ç¤ºç±»å‹è½¬æ¢ï¼Œæ²¡æœ‰éšå¼ç±»å‹è½¬æ¢ï¼Œè¯¥è¯­æ³•åªèƒ½åœ¨ä¸¤ä¸ªç±»å‹ä¹‹é—´æ”¯æŒç›¸äº’è½¬æ¢çš„æ—¶å€™ä½¿ç”¨ã€‚ å¼ºåˆ¶ç±»å‹è½¬æ¢çš„åŸºæœ¬è¯­æ³•å¦‚ä¸‹ï¼š T(è¡¨è¾¾å¼)ï¼šæ³¨æ„åŒºåˆ†å‡½æ•°è°ƒç”¨æƒ…å†µã€‚å› ä¸ºå‡½æ•°è°ƒç”¨ä¸æ˜¾ç¤ºè½¬æ¢ç±»å‹å½¢å¼ç›¸ä¼¼ã€‚ Tè¡¨ç¤ºè¦è½¬æ¢çš„ç±»å‹ã€‚ å¦‚è®¡ç®—ç›´è§’ä¸‰è§’å½¢çš„æ–œè¾¹é•¿æ—¶ä½¿ç”¨mathåŒ…çš„Sqrt()å‡½æ•°ã€‚ è¯¥å‡½æ•°æ¥æ”¶çš„æ˜¯float64ç±»å‹çš„å‚æ•°ï¼Œè€Œå˜é‡aå’Œbéƒ½æ˜¯intç±»å‹çš„ï¼Œè¿™ä¸ªæ—¶å€™å°±éœ€è¦å°†aå’Œbå¼ºåˆ¶ç±»å‹è½¬æ¢ä¸ºfloat64ç±»å‹ã€‚ 1 2 3 4 5 6 7 8 func sqrtDemo() { var a, b = 3, 4 var c int // math.Sqrt()æ¥æ”¶çš„å‚æ•°æ˜¯float64ç±»å‹ï¼Œéœ€è¦å¼ºåˆ¶è½¬æ¢ c = int(math.Sqrt(float64(a*a + b*b))) fmt.Println(c) } æ€»ç»“ å­—ç¬¦ä¸²è¢«è®¾è®¡æˆåªè¯»æ•°æ®ï¼Œè¿™æ ·åœ¨å¤šçº¿ç¨‹æ—¶æ“ä½œå­—ç¬¦ä¸²æ—¶ä¸éœ€è¦åŠ é”é¿å…å¹¶å‘ã€‚ ","permalink":"https://heliu.site/posts/golang/basic/string/","summary":"Golang å­—ç¬¦ä¸²ä½¿ç”¨ä»‹ç»ã€‚","title":"å­—ç¬¦ä¸²"},{"content":"å†…å­˜ç»“æ„ å­—ç¬¦ä¸²ç»“æ„ 1 2 3 4 5 6 type stringStruct struct { // æŒ‡å‘åº•å±‚æ•°ç»„ï¼Œè¿ç»­åˆ†é…çš„å­—èŠ‚ Data unsafe.Pointer // è®°å½•ç€å­—ç¬¦ä¸²çš„å­—èŠ‚é•¿åº¦ Len int } å­—ç¬¦ä¸²å†…å­˜åˆ†å¸ƒ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;unsafe\u0026#34; ) func main() { // å¦‚ä¸Šï¼šstrçš„åœ°å€ä¸º0x01f050å­˜å‚¨çš„å€¼æ˜¯0x4a1160ï¼Œ0x4a1160åˆ™æ˜¯å­—ç¬¦hçš„é¦–åœ°å€å­˜å‚¨çš„å€¼æ˜¯0x68(å­—ç¬¦h) var str string = \u0026#34;hello world!\u0026#34; // æŠŠå˜é‡strå½“æˆStringStructç»“æ„çœ‹å¾… // å­—ç¬¦ä¸²çš„å†…å­˜å¤§å°å­˜åœ¨_type.sizeä¸­ï¼Œæ›´å¤šå‚è€ƒruntime/type.goæ–‡ä»¶ sizeOf := unsafe.Sizeof(str) // å­—ç¬¦ä¸²å ç”¨å†…å­˜å¤§å°(B):16 fmt.Printf(\u0026#34;å­—ç¬¦ä¸²å ç”¨å†…å­˜å¤§å°(B):%d\\n\u0026#34;, sizeOf) // \u0026amp;str:0x01f050 // è¿™é‡Œéœ€è¦æ˜ç™½çš„æ˜¯ç»“æ„ä½“å­˜å‚¨çš„æ˜¯ç¬¬ä¸€ä¸ªå­—æ®µçš„åœ°å€ fmt.Printf(\u0026#34;\u0026amp;str:%#x\\n\u0026#34;, \u0026amp;str) // \u0026amp;StringStruct.data // \u0026amp;StringStruct.Len l := (*int)(unsafe.Pointer(uintptr(unsafe.Pointer(\u0026amp;str)) + unsafe.Sizeof(int(0)))) // å­—ç¬¦ä¸²é•¿åº¦:12 (0x0c) fmt.Printf(\u0026#34;å­—ç¬¦ä¸²é•¿åº¦:%d\\n\u0026#34;, *l) data := *(*int)(unsafe.Pointer(\u0026amp;str)) // æ•°æ®å­˜å‚¨åœ°å€ï¼š0x4a1160 fmt.Printf(\u0026#34;æ•°æ®å­˜å‚¨åœ°å€ï¼š%#x\\n\u0026#34;, data) // è·å–æŒ‡å®šæ•°æ®ï¼Œä¸æ¨èåˆ†å¼€æ“ä½œæŒ‡é’ˆæ¯”å¦‚è¿™é‡Œçš„dataå†™æˆä¸¤ä¸ªè¡¨è¾¾å¼ // uintptr(unsafe.Pointer(nil)) =\u0026gt; 0 //b0 := *(*byte)(unsafe.Pointer(uintptr(unsafe.Pointer(nil)) // + uintptr(data))) b0 := **(**byte)(unsafe.Pointer(\u0026amp;s1))\t// h // str[0]:h fmt.Printf(\u0026#34;str[0]:%c\\n\u0026#34;, b0) // ä¸å»ºè®®è¿™æ ·åˆ†å¼€å†™æˆä¸¤æ®µï¼Œå–str[8]çš„å€¼ //b8 := *(*byte)(unsafe.Pointer(uintptr(unsafe.Pointer(nil)) + // uintptr(data) + 8*unsafe.Sizeof(byte(\u0026#39;0\u0026#39;)))) b8 := (**(**[9]byte)(unsafe.Pointer(\u0026amp;str)))[8] // str[8]:r fmt.Printf(\u0026#34;str[8]:%c\\n\u0026#34;, b8) // Output: // å­—ç¬¦ä¸²å ç”¨å†…å­˜å¤§å°(B):16 // \u0026amp;str:0xc000088230 // å­—ç¬¦ä¸²é•¿åº¦:12 // æ•°æ®å­˜å‚¨åœ°å€ï¼š0x103fb6b // str[0]:h // str[8]:r } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;unsafe\u0026#34; ) // stringHeader å­—ç¬¦ä¸²ç»“æ„ type stringHeader struct { Data uintptr Len uintptr } func main() { var s0 string = \u0026#34;hello\u0026#34; // è·å–å­—ç¬¦ä¸²é•¿åº¦ l := (*stringHeader)(unsafe.Pointer(\u0026amp;s0)).Len fmt.Printf(\u0026#34;å­—ç¬¦ä¸²é•¿åº¦ï¼š%d\\n\u0026#34;, l) // s0[0] s00 := **(**byte)(unsafe.Pointer(\u0026amp;s0)) fmt.Printf(\u0026#34;s[0]ï¼š%c\\n\u0026#34;, s00) // s0[4] // *(*uintptr)(unsafe.Pointer(\u0026amp;s0)) s04 := *(*byte)(unsafe.Pointer(uintptr(unsafe.Pointer(nil)) + *(*uintptr)(unsafe.Pointer(\u0026amp;s0)) + 4*unsafe.Sizeof(byte(\u0026#39;0\u0026#39;)))) fmt.Printf(\u0026#34;s[4]ï¼š%c\\n\u0026#34;, s04) // ------------------------------------------------------------------------------------------------------- // è·å–å­—ç¬¦æ¯ä¸ªå­—ç¬¦ s1 := \u0026#34;helxo\u0026#34; fmt.Printf(\u0026#34;%c\\n\u0026#34;, **(**byte)(unsafe.Pointer(\u0026amp;s1))) // h fmt.Printf(\u0026#34;%c\\n\u0026#34;, **(**uint16)(unsafe.Pointer(\u0026amp;s1)) \u0026gt;\u0026gt; 8) // e fmt.Printf(\u0026#34;%c\\n\u0026#34;, **(**uint32)(unsafe.Pointer(\u0026amp;s1)) \u0026gt;\u0026gt; 16 \u0026amp; 0b00000000_11111111) // l fmt.Printf(\u0026#34;%c\\n\u0026#34;, **(**uint32)(unsafe.Pointer(\u0026amp;s1)) \u0026gt;\u0026gt; 24) // x fmt.Printf(\u0026#34;%c\\n\u0026#34;, **(**uint64)(unsafe.Pointer(\u0026amp;s1)) \u0026gt;\u0026gt; 32 \u0026amp; 0b00000000_00000000_00000000_11111111)\t// o a := **(**[5]byte)(unsafe.Pointer(\u0026amp;s1)) fmt.Println(a) // å­—ç¬¦ä¸å…è®¸è¢«ä¿®æ”¹ï¼Œæ‰€ä»¥è¿™é‡Œéœ€è¦å¤„ç†ä¸€ä¸‹ str1 := \u0026#34;hello world!\u0026#34; // ç¼–è¯‘æ—¶ä¼šè¢«åˆ†é…åˆ°åªè¯»ä»£ç æ®µ str1 = str1 + \u0026#34; ds\u0026#34; // è¿è¡Œæ—¶ä¼šåˆ†é…åˆ°å†…å­˜ä¸­ï¼Œè¯­è¨€å±‚é¢ä¸Šé™åˆ¶äº†åªè¯» // ab1 æ˜¯ [12]byte ç±»å‹ ab1 := **(**[12]byte)(unsafe.Pointer(\u0026amp;str1))\t// å¯¹æ¯”ä¸‹é¢çš„åŒºåˆ« ab1[0] = 101 fmt.Println(ab1, str1) // [101 101 108 108 111 32 119 111 114 108 100 33] hello world! ds // ab æ˜¯ *[12]byte ç±»å‹ ab := *(**[12]byte)(unsafe.Pointer(\u0026amp;str1)) (*ab)[0] = 101 fmt.Println(*ab, str1) // [101 101 108 108 111 32 119 111 114 108 100 33] eello world! ds // æŒ‡é’ˆæ•°ç»„å¯¹æ¯”ä¸Šé¢ ac := new([12]byte) // *[12]byte (*ac)[0] = 96 fmt.Println(*ac) // [96 0 0 0 0 0 0 0 0 0 0 0] } å­—ç¬¦ä¸²æŒ‰å€¼ä¼ å‚ ä»¥ä¸‹æˆ‘ä»¬å¯ä»¥çœ‹å‡ºï¼Œå­—ç¬¦ä¸²åœ¨å‡½æ•°é—´ä¼ é€’ä¼ é€’çš„æ˜¯stringStructç»“æ„ä½“ã€‚ æŒ‰å€¼ä¼ å‚ä¹Ÿæ˜¯ç›´æ¥æ–°åˆ›å»ºä¸ªå˜é‡åœ°å€ä¿å­˜stringStructç»“æ„ä½“ï¼Œå…¶å­—ç¬¦ä¸²æŒ‡å‘çš„åº•å±‚æ•°ç»„æ˜¯æ²¡æœ‰å‘ç”Ÿå˜åŒ–çš„ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;unsafe\u0026#34; ) func main() { var str string = \u0026#34;hello world!\u0026#34; fmt.Printf(\u0026#34;\u0026amp;str:%#x\\n\u0026#34;, \u0026amp;str) // ä»¥ä¸‹åŒºåˆ«ï¼š // uintptr(unsafe.Pointer(\u0026amp;str)) å¾—åˆ°uintptrç±»å‹å°±æ˜¯\u0026amp;stråœ°å€ï¼Œè¿™æ˜¯ä¸€ä¸ªç‰¹ä¾‹å…¶ä»–ç±»å‹ä¸å…è®¸è¿™æ ·è½¬æ¢ // (*uintptr)(unsafe.Pointer(\u0026amp;str)) å¾—åˆ°*uintptrç±»å‹ä¹Ÿæ˜¯\u0026amp;stråœ°å€ï¼Œä¸å»ºè®®ä½¿ç”¨ // *(*uintptr)(unsafe.Pointer(\u0026amp;str)) å¾—åˆ°uintptrç±»å‹æ˜¯strå­˜å‚¨é¦–uintptré•¿åº¦å­—èŠ‚çš„å€¼ l := (*int)(unsafe.Pointer(uintptr(unsafe.Pointer(\u0026amp;str)) + unsafe.Sizeof(int(0)))) // å­—ç¬¦ä¸²é•¿åº¦:12 fmt.Printf(\u0026#34;å­—ç¬¦ä¸²é•¿åº¦:%d\\n\u0026#34;, *l) data := *(*int)(unsafe.Pointer(\u0026amp;str)) // æ•°æ®å­˜å‚¨åœ°å€ï¼š0x103fb6b fmt.Printf(\u0026#34;æ•°æ®å­˜å‚¨åœ°å€ï¼š%#x\\n\u0026#34;, data) ts(str) // Output: // \u0026amp;str:0xc000036240 // å­—ç¬¦ä¸²é•¿åº¦:12 // æ•°æ®å­˜å‚¨åœ°å€ï¼š0x9dfb6b // \u0026amp;s:0xc000036250 // å­—ç¬¦ä¸²é•¿åº¦:12 // æ•°æ®å­˜å‚¨åœ°å€ï¼š0x9dfb6b } func ts(s string) { fmt.Printf(\u0026#34;\u0026amp;s:%#x\\n\u0026#34;, \u0026amp;s) l := (*int)(unsafe.Pointer(uintptr(unsafe.Pointer(\u0026amp;s)) + unsafe.Sizeof(int(0)))) // å­—ç¬¦ä¸²é•¿åº¦:12 fmt.Printf(\u0026#34;å­—ç¬¦ä¸²é•¿åº¦:%d\\n\u0026#34;, *l) data := *(*int)(unsafe.Pointer(\u0026amp;s)) // æ•°æ®å­˜å‚¨åœ°å€ï¼š0x103fb6b fmt.Printf(\u0026#34;æ•°æ®å­˜å‚¨åœ°å€ï¼š%#x\\n\u0026#34;, data) } 1 2 3 4 5 6 7 8 9 10 11 func ts() { // 0xc00000a028 -\u0026gt; 0xc00001c0a8 -\u0026gt; 1 str1 := 1 // int str := \u0026amp;str1 // *int fmt.Printf(\u0026#34;%p\\n\u0026#34;, \u0026amp;str) // 0xc00000a028 fmt.Printf(\u0026#34;%p\\n\u0026#34;, str) // 0xc00001c0a8 fmt.Printf(\u0026#34;%#v\\n\u0026#34;, uintptr(unsafe.Pointer(\u0026amp;str))) // 0xc00000a028 fmt.Printf(\u0026#34;%#v\\n\u0026#34;, (*uintptr)(unsafe.Pointer(\u0026amp;str))) // (*uintptr)(0xc00000a028) fmt.Printf(\u0026#34;%#v\\n\u0026#34;, *(*uintptr)(unsafe.Pointer(\u0026amp;str))) // 0xc00001c0a8 } []byteä¸string []byteå’Œstringéƒ½å¯ä»¥è¡¨ç¤ºå­—ç¬¦ä¸²ï¼Œå®ƒä»¬æ•°æ®ç»“æ„ä¸åŒï¼Œå…¶è¡ç”Ÿå‡ºæ¥çš„æ–¹æ³•ä¹Ÿä¸åŒã€‚ stringæ“…é•¿çš„åœºæ™¯ï¼š éœ€è¦å­—ç¬¦ä¸²æ¯”è¾ƒã€ä¸éœ€è¦nilå­—ç¬¦ä¸²ã€‚ []byteæ“…é•¿çš„åœºæ™¯ï¼š ä¿®æ”¹å­—ç¬¦ä¸²çš„æ—¶å€™ã€å‡½æ•°è¿”å›å€¼ï¼Œéœ€è¦ä½¿ç”¨nilæ¥è¡¨ç¤ºå«ä¹‰ã€éœ€è¦åˆ‡ç‰‡æ“ä½œã€‚ str2 := str1 å­—ç¬¦ä¸²é—´èµ‹å€¼ä¼šå…±ç”¨åŒä¸€ä¸ªåº•å±‚æ•°ç»„ï¼Ÿ å­—ç¬¦ä¸²é—´èµ‹å€¼ï¼Œã€ä¼šã€‘å…±ç”¨åŒä¸€ä¸ªåº•å±‚æ•°ç»„ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 { var str1 = \u0026#34;hello\u0026#34; str2 := str1 // åŒç”¨äº†ä¸€ä¸ªåº•å±‚æ•°ç»„ // å› ä¸ºå­—ç¬¦ä¸²æ—¶åªè¯»ç±»å‹ï¼Œå› æ­¤èµ‹å€¼å…±ç”¨åŒä¸€ä¸ªåº•å±‚ä¹Ÿæ²¡æœ‰é—®é¢˜ã€‚ fmt.Println(*(*stringStruct)(unsafe.Pointer(\u0026amp;str1))) // {15567553 5} fmt.Println(*(*stringStruct)(unsafe.Pointer(\u0026amp;str2))) // {15567553 5} }\ttype stringStruct struct { str uintptr len uintptr } s := []byte(str) å­—ç¬¦ä¸²å¼ºåˆ¶è½¬æˆ[]byteæ˜¯å¦å…±ç”¨åŒä¸€ä¸ªåº•å±‚æ•°ç»„ï¼Ÿ ã€ä¸ä¼šã€‘åŒç”¨ä¸€ä¸ªåº•å±‚æ•°ç»„ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;unsafe\u0026#34; ) func main() { str := \u0026#34;hello\u0026#34; s := []byte(str) s[0] = \u0026#39;e\u0026#39; fmt.Println(str, s) // æ¢ç©¶å­—ç¬¦ä¸²å¼ºåˆ¶è½¬æ¢æˆåˆ‡ç‰‡åº•å±‚æ•°ç»„æ˜¯å¦å‘ç”Ÿå˜åŒ– fmt.Printf(\u0026#34;å­—ç¬¦ä¸²æŒ‡å‘åº•å±‚æ•°ç»„ï¼š%x\\n\u0026#34;, *(*uintptr)(unsafe.Pointer(\u0026amp;str))) fmt.Printf(\u0026#34;str[0]:%c\\n\u0026#34;, *(*byte)(unsafe.Pointer(uintptr(unsafe.Pointer(nil)) + *(*uintptr)(unsafe.Pointer(\u0026amp;str))))) fmt.Printf(\u0026#34;åˆ‡ç‰‡æŒ‡å‘çš„åº•å±‚æ•°ç»„ï¼š%x\\n\u0026#34;, *(*uintptr)(unsafe.Pointer(\u0026amp;s))) fmt.Printf(\u0026#34;åˆ‡ç‰‡s[0]åœ°å€ï¼š%p\\n\u0026#34;, \u0026amp;s[0]) // Output: // hello [101 101 108 108 111] // å­—ç¬¦ä¸²æŒ‡å‘åº•å±‚æ•°ç»„ï¼š12e9c2 // str[0]:h // åˆ‡ç‰‡æŒ‡å‘çš„åº•å±‚æ•°ç»„ï¼šc00000e0b0 // åˆ‡ç‰‡s[0]åœ°å€ï¼š0xc00000e0b0 } string è½¬ []byte 1 2 3 4 5 6 7 8 9 10 11 12 package main import \u0026#34;fmt\u0026#34; func main() { s := \u0026#34;hello Goè¯­è¨€\u0026#34; // ä¸‹é¢ä»£ç å¯ä»¥çœ‹å‡ºï¼Œså’Œbå¹¶ã€æ²¡æœ‰ã€‘å…±ç”¨åŒä¸€ä¸ªåº•å±‚æ•°ç»„ b := []byte(s) // è¿™é‡Œä¼šè°ƒç”¨ runtime.stringtoslicebyte å‡½æ•° fmt.Println(b) } stringtoslicebyte() stringè½¬slice byteï¼Œstring -\u0026gt; []byteã€‚ å‚æ•°ï¼š buf *tmpBufï¼štype tmpBuf [32]byteï¼Œ[32]byteæ•°ç»„ç”¨äºè½¬æ¢å¤§å°åœ¨32å­—èŠ‚çš„ä¸´æ—¶å­˜å‚¨è½¬æ¢å®¹å™¨ã€‚ä¸Šä¸€ç« çš„\u0026quot;ä¿®æ”¹å­—ç¬¦ä¸²\u0026quot;èŠ‚stringè½¬[]byteåcapå€¼ä¸º32å°±æ˜¯è¿™ä¸ªå‚æ•°çš„åŸå› ã€‚ s stringï¼šè½¬æ¢å­—ç¬¦ä¸²ã€‚ è¿”å›å€¼ï¼š []byteï¼šè½¬æ¢åçš„slice byteã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 func stringtoslicebyte(buf *tmpBuf, s string) []byte { var b []byte // nil // tmpBuf å®¹é‡å¤Ÿ s çš„æœ¬æ¬¡è½¬æ¢ if buf != nil \u0026amp;\u0026amp; len(s) \u0026lt;= len(buf) { // è¿™é‡Œä¹Ÿå°±æ˜¯ []byte(string) æ²¡ç”¨å…±ç”¨ä¸€ä¸ªåº•å±‚æ•°ç»„çš„åŸå› æ‰€åœ¨ *buf = tmpBuf{} // æ¸…ç©º å¹¶ åˆå§‹åŒ–æ–°çš„å®¹é‡ {0xxxx, 0, 32} b = buf[:len(s)]\t} else { // å®¹å™¨å¤§å°ä¸å¤Ÿï¼Œéœ€è¦é‡æ–°ç”³è¯·å¤§å° b = rawbyteslice(len(s)) } // copy([]byte, string) int copy(b, s) // æ‹·è´å­—ç¬¦ä¸²ä¸­çš„æ•°æ® return b } rawbyteslice() rawbytesliceåˆ†é…ä¸€ä¸ªæ–°çš„byte sliceã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // rawbyteslice allocates a new byte slice. The byte slice is not zeroed. func rawbyteslice(size int) (b []byte) { // å› ä¸ºæ˜¯ byte æ‰€ä»¥ç›´æ¥ä¼  size å¤§å°å³å¯ï¼ŒåŒ¹é…æœ€è¿‘æ¥çš„å†…å­˜å—è§„æ ¼å¤§å° cap := roundupsize(uintptr(size)) // è°ƒæ•´sizeå¤§å° // è¿™é‡Œæ˜¯ []byte(string) æ²¡ç”¨å…±ç”¨ä¸€ä¸ªåº•å±‚æ•°ç»„çš„åŸå› æ‰€åœ¨ p := mallocgc(cap, nil, false) // ç”³è¯·capå¤§å°å†…å­˜ï¼Œpæ˜¯ç”³è¯·åçš„å†…å­˜åœ°å€ if cap != uintptr(size) { // æ¸…é›¶å¤šä½™çš„è¿™éƒ¨åˆ†å†…å­˜å— memclrNoHeapPointers(add(p, uintptr(size)), cap-uintptr(size)) } // å°†ç”³è¯·çš„å¤§å°èµ‹å€¼ä¸ªè¿”å›å€¼b *(*slice)(unsafe.Pointer(\u0026amp;b)) = slice{p, size, int(cap)} return } []byte è½¬ string 1 2 3 4 5 6 7 8 9 10 11 12 package main import \u0026#34;fmt\u0026#34; func main() { b := []byte{\u0026#39;h\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;l\u0026#39;, \u0026#39;l\u0026#39;, \u0026#39;o\u0026#39;} // ä¸‹é¢æºç å¯ä»¥çœ‹å‡ºï¼Œbå’Œså¹¶ã€æ²¡æœ‰ã€‘å…±ç”¨åŒä¸€ä¸ªåº•å±‚æ•°ç»„ s := string(b) // è¿™é‡Œä¼šè°ƒç”¨ runtime.slicebytetostring å‡½æ•° fmt.Println(s) } slicebytetostring() slicebytetostringå°†å­—èŠ‚åˆ‡ç‰‡è½¬æ¢ä¸ºå­—ç¬¦ä¸²ï¼Œstring([]byte)ã€‚ å®ƒç”±ç¼–è¯‘å™¨æ’å…¥åˆ°ç”Ÿæˆçš„ä»£ç ä¸­ã€‚ ptræ˜¯ä¸€ä¸ªæŒ‡é’ˆï¼ŒæŒ‡å‘åˆ‡ç‰‡çš„ç¬¬ä¸€ä¸ªå…ƒç´ ; næ˜¯åˆ‡ç‰‡çš„é•¿åº¦ã€‚ bufæ˜¯ä¸€ä¸ªå›ºå®šå¤§å°çš„ç¼“å†²åŒºï¼Œå¦‚æœç»“æœæ²¡æœ‰escapeè½¬ä¹‰å­—ç¬¦ï¼Œå®ƒå°±ä¸æ˜¯nilã€‚ å‚æ•°ï¼š buf *tmpBufï¼štype tmpBuf [32]byteï¼Œ[32]byteæ•°ç»„ ç”¨äºè½¬æ¢å¤§å°åœ¨32å­—èŠ‚çš„ä¸´æ—¶å­˜å‚¨è½¬æ¢å®¹å™¨ã€‚ ptr *byteï¼š[]byteåˆ‡ç‰‡çš„åº•å±‚æ•°ç»„åœ°å€ï¼Œä¹Ÿå°±æ˜¯slice.dataçš„å€¼ã€‚ n intï¼šåˆ‡ç‰‡çš„é•¿åº¦ï¼Œä¹Ÿå°±æ˜¯slice.lençš„å€¼ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 // slicebytetostring converts a byte slice to a string. // It is inserted by the compiler into generated code. // ptr is a pointer to the first element of the slice; // n is the length of the slice. // Buf is a fixed-size buffer for the result, // it is not nil if the result does not escape. func slicebytetostring(buf *tmpBuf, ptr *byte, n int) (str string) { // æ²¡æœ‰éœ€è¦è½¬æ¢çš„ if n == 0 { // Turns out to be a relatively common case. // Consider that you want to parse out data between parens in \u0026#34;foo()bar\u0026#34;, // you find the indices and convert the subslice to string. return \u0026#34;\u0026#34; } if raceenabled { racereadrangepc(unsafe.Pointer(ptr), uintptr(n), getcallerpc(), abi.FuncPCABIInternal(slicebytetostring)) } if msanenabled { msanread(unsafe.Pointer(ptr), uintptr(n)) } if asanenabled { asanread(unsafe.Pointer(ptr), uintptr(n)) } // å½“[]byte åªæœ‰ä¸€ä¸ªå­—ç¬¦æ—¶ if n == 1 {\t// staticuint64sæ˜¯ä¸€ä¸ª[256]uint64çš„æ•°ç»„ï¼Œä¹Ÿå°±æ˜¯ASCIIçš„æ•°ç»„æ•°ç»„ // è¿™é‡Œå¯ä»¥çœ‹å‡ºå¹¶ä¸æ˜¯ç”¨çš„åŒä¸€ä¸ªåº•å±‚æ•°ç»„ã€‚ p := unsafe.Pointer(\u0026amp;staticuint64s[*ptr])\tif goarch.BigEndian {\t// æŸäº›å¹³å°éœ€è¦å­—èŠ‚å¯¹é½ p = add(p, 7) } stringStructOf(\u0026amp;str).str = p // èµ‹å€¼ç»™å­—ç¬¦ä¸²çš„str stringStructOf(\u0026amp;str).len = 1 // èµ‹å€¼ç»™å­—ç¬¦ä¸²çš„len return } var p unsafe.Pointer if buf != nil \u0026amp;\u0026amp; n \u0026lt;= len(buf) { // å½“é•¿åº¦åœ¨32èŒƒå›´å†…æ—¶ p = unsafe.Pointer(buf)\t// ç›´æ¥ä½¿ç”¨bufçš„å®¹é‡å½“åšåœ°å€ } else { p = mallocgc(uintptr(n), nil, false) // ç”³è¯·nå¤§å°çš„å†…å­˜åœ°å€å¤‡ç”¨ } stringStructOf(\u0026amp;str).str = p stringStructOf(\u0026amp;str).len = n memmove(p, unsafe.Pointer(ptr), uintptr(n)) // å°†ptråœ°å€é•¿åº¦ä¸ºnå­—èŠ‚çš„å†…å®¹ç§»åŠ¨åˆ°pä¸­ return } 1 2 3 4 5 6 7 8 type stringStruct struct { str unsafe.Pointer len int } func stringStructOf(sp *string) *stringStruct { return (*stringStruct)(unsafe.Pointer(sp)) } string è½¬ []rune 1 2 3 4 5 6 7 8 9 10 11 12 package main import \u0026#34;fmt\u0026#34; func main() { s := \u0026#34;hello Goè¯­è¨€\u0026#34; // ä¸‹é¢ä»£ç å¯ä»¥çœ‹å‡ºï¼Œså’Œbå¹¶ã€æ²¡æœ‰ã€‘å…±ç”¨åŒä¸€ä¸ªåº•å±‚æ•°ç»„ b := []rune(s) // è¿™é‡Œä¼šè°ƒç”¨ runtime.stringtoslicerune å‡½æ•° fmt.Println(b) } stringtoslicerune() stringè½¬slice runeï¼Œ[]rune(string)ã€‚ å‚æ•°ï¼š buf *[tmpStringBufSize]runeï¼š*[32]rune 32ä½ç¼“å­˜runeã€‚ s stringï¼šç›®æ ‡å­—ç¬¦ä¸²ã€‚ è¿”å›å€¼ï¼š []runeï¼šè½¬æ¢åçš„åˆ‡ç‰‡ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 // string to slice rune func stringtoslicerune(buf *[tmpStringBufSize]rune, s string) []rune { // two passes. // unlike slicerunetostring, no race because strings are immutable. n := 0 for range s { // éå†sç»Ÿè®¡runeçš„æ€»é‡ n++ } var a []rune if buf != nil \u0026amp;\u0026amp; n \u0026lt;= len(buf) { // æ»¡è¶³32å­—èŠ‚ *buf = [tmpStringBufSize]rune{} a = buf[:n] } else { a = rawruneslice(n) // å‘ç³»ç»Ÿç”³è¯·nå¤§å°çš„å†…å­˜ } n = 0 for _, r := range s { // é€šè¿‡éå†å°†så­˜å‚¨åˆ°aä¸­ a[n] = r n++ } return a } rawruneslice() 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 // rawruneslice allocates a new rune slice. The rune slice is not zeroed. func rawruneslice(size int) (b []rune) { if uintptr(size) \u0026gt; maxAlloc/4 { // å†…å­˜æº¢å‡ºæƒ…æ™¯ throw(\u0026#34;out of memory\u0026#34;) } // rune = int32 å 4å­—èŠ‚ï¼ŒåŒ¹é…æœ€æ¥è¿‘çš„å†…å­˜å— mem := roundupsize(uintptr(size) * 4) // è¿™é‡Œæ˜¯æ²¡æœ‰ä½¿ç”¨åŒä¸€ä¸ªåœ°å€çš„åŸå›  // å‘ç³»ç»Ÿç”³è¯·å†…å­˜çš„å¤§å°æ˜¯ç›´æ¥ï¼Œè€Œsizeè¡¨ç¤ºçš„å­—ç¬¦çš„ä¸ªæ•°ï¼Œæ‰€ä»¥è¿™é‡Œæ˜¯éœ€è¦ä¹˜ä»¥4çš„ p := mallocgc(mem, nil, false)\tif mem != uintptr(size)*4 { memclrNoHeapPointers(add(p, uintptr(size)*4), mem-uintptr(size)*4) // æ¸…é›¶æœªä½¿ç”¨çš„é‚£éƒ¨åˆ†å†…å­˜å— } *(*slice)(unsafe.Pointer(\u0026amp;b)) = slice{p, size, int(mem / 4)} // ç”³è¯·åçš„èµ‹å€¼è¿”å› return } []rune è½¬ string 1 2 3 4 5 6 7 8 9 10 11 12 package main import \u0026#34;fmt\u0026#34; func main() { b := []rune{104, 101, 108, 108, 111, 32, 71, 111, 35821, 35328} // ä¸‹é¢æºç å¯ä»¥çœ‹å‡ºï¼Œbå’Œså¹¶ã€æ²¡æœ‰ã€‘å…±ç”¨åŒä¸€ä¸ªåº•å±‚æ•°ç»„ s := string(b) // è¿™é‡Œä¼šè°ƒç”¨ runtime.slicerunetostring å‡½æ•° fmt.Println(s) } slicerunetostring() slice rune è½¬ stringï¼Œstring([]rune)ã€‚ å‚æ•°ï¼š buf *tmpBufï¼štype tmpBuf [32]byteï¼Œ[32]byteæ•°ç»„ç”¨äºè½¬æ¢å¤§å°åœ¨32å­—èŠ‚çš„ä¸´æ—¶å­˜å‚¨è½¬æ¢å®¹å™¨ã€‚ a []runeï¼šè½¬æ¢çš„åˆ‡ç‰‡ã€‚ è¿”å›å€¼ï¼š stringï¼šè½¬æ¢åçš„å­—ç¬¦ä¸²ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 // slice rune to string func slicerunetostring(buf *tmpBuf, a []rune) string { if raceenabled \u0026amp;\u0026amp; len(a) \u0026gt; 0 { racereadrangepc(unsafe.Pointer(\u0026amp;a[0]), uintptr(len(a))*unsafe.Sizeof(a[0]), getcallerpc(), abi.FuncPCABIInternal(slicerunetostring)) } if msanenabled \u0026amp;\u0026amp; len(a) \u0026gt; 0 { msanread(unsafe.Pointer(\u0026amp;a[0]), uintptr(len(a))*unsafe.Sizeof(a[0])) } if asanenabled \u0026amp;\u0026amp; len(a) \u0026gt; 0 { asanread(unsafe.Pointer(\u0026amp;a[0]), uintptr(len(a))*unsafe.Sizeof(a[0])) } var dum [4]byte // ä¸´æ—¶å®¹å™¨ // è®°å½•[]runeåˆ‡ç‰‡è½¬stringéœ€è¦çš„æ€»å­—èŠ‚æ•°é‡ byte size1 := 0\tfor _, r := range a { // ã€int runeã€‘ // encoderune å‡½æ•°è§£ç rå¹¶æŠŠå€¼å­˜å…¥ç¬¬ä¸€ä¸ªå‚æ•°ä¸­ï¼Œè¿”å›è§£ç çš„å­—èŠ‚æ•°é‡ size1 += encoderune(dum[:], r)\t} // è¿”å›ä¸€ä¸ªså’Œbåº•å±‚æ•°ç»„ç›¸å…³è”çš„ï¼Œè¿™é‡Œsize1+3æ˜¯ä¸ºäº†å…¼å®¹æœ€åä¸€ä¸ªæ˜¯ASCIIæƒ…å†µ s, b := rawstringtmp(buf, size1+3)\tsize2 := 0\t// ç»Ÿè®¡æ•°é‡ for _, r := range a { // check for race // å¯èƒ½å­˜åœ¨ []rune ä¸­ \u0026#39;\u0026#39; è¿™ç§æ•°æ® if size2 \u0026gt;= size1 { break } // ä¹Ÿå°±æ˜¯è¿™é‡Œå®ç°äº†å°†æ•°æ®å†™å…¥å­—ç¬¦ä¸²åœ°å€ä¸­ï¼Œå› ä¸ºåˆ‡ç‰‡å’Œå­—ç¬¦ä¸²å…±ç”¨åŒä¸€ä¸ªåº•å±‚æ•°ç»„ // encoderuneè¯¥å‡½æ•°çš„ä½œç”¨æ˜¯å°†rè§£ç å¹¶å­˜å…¥ç¬¬ä¸€ä¸ªå‚æ•°ä½ç½®ï¼Œå¹¶è¿”å›rçš„ç¼–ç å­—èŠ‚é•¿åº¦ size2 += encoderune(b[size2:], r)\t} return s[:size2] // åˆ‡å‰²å­—ç¬¦ä¸²så¾—åˆ°çš„ä¾ç„¶æ˜¯å­—ç¬¦ä¸²ç±»å‹ } rawstringtmp() 1 2 3 4 5 6 7 8 9 10 // è¿”å›ä¸€ä¸ªså’Œbå…±ç”¨åŒä¸€ä¸ªåº•å±‚æ•°ç»„ func rawstringtmp(buf *tmpBuf, l int) (s string, b []byte) { if buf != nil \u0026amp;\u0026amp; l \u0026lt;= len(buf) { // å¦‚æœæ»¡è¶³32å­—èŠ‚å†… b = buf[:l] s = slicebytetostringtmp(\u0026amp;b[0], len(b)) // å¤„ç†så’Œbçš„å…³è”å…³ç³» } else { s, b = rawstring(l) // ä»æ–°ç”³è¯·ä¸€å—å†…å­˜ å…³è”så’Œbçš„åº•å±‚æ•°ç»„å…³è”å…³ç³» } return } slicebytetostringtmp() 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 // slicebytetostringtmp returns a \u0026#34;string\u0026#34; referring to the actual []byte bytes. // // Callers need to ensure that the returned string will not be used after // the calling goroutine modifies the original slice or synchronizes with // another goroutine. // // The function is only called when instrumenting // and otherwise intrinsified by the compiler. // // Some internal compiler optimizations use this function. // - Used for m[T1{... Tn{..., string(k), ...} ...}] and m[string(k)] // where k is []byte, T1 to Tn is a nesting of struct and array literals. // - Used for \u0026#34;\u0026lt;\u0026#34;+string(b)+\u0026#34;\u0026gt;\u0026#34; concatenation where b is []byte. // - Used for string(b)==\u0026#34;foo\u0026#34; comparison where b is []byte. func slicebytetostringtmp(ptr *byte, n int) (str string) { if raceenabled \u0026amp;\u0026amp; n \u0026gt; 0 { racereadrangepc(unsafe.Pointer(ptr), uintptr(n), getcallerpc(), abi.FuncPCABIInternal(slicebytetostringtmp)) } if msanenabled \u0026amp;\u0026amp; n \u0026gt; 0 { msanread(unsafe.Pointer(ptr), uintptr(n)) } if asanenabled \u0026amp;\u0026amp; n \u0026gt; 0 { asanread(unsafe.Pointer(ptr), uintptr(n)) } // é€šè¿‡å‚æ•°è¿”å›ä¸€ä¸ªptrå’Œè¿”å›strç›¸å…³è”çš„åº•å±‚æ•°ç»„ stringStructOf(\u0026amp;str).str = unsafe.Pointer(ptr)\tstringStructOf(\u0026amp;str).len = n return } rawstring() 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // rawstring allocates storage for a new string. The returned // string and byte slice both refer to the same storage. // The storage is not zeroed. Callers should use // b to set the string contents and then drop b. func rawstring(size int) (s string, b []byte) { // å‘ç³»ç»Ÿç”³è¯·å†…å­˜ p := mallocgc(uintptr(size), nil, false) stringStructOf(\u0026amp;s).str = p stringStructOf(\u0026amp;s).len = size *(*slice)(unsafe.Pointer(\u0026amp;b)) = slice{p, size, size} return } string -\u0026gt; string[:] è¿™ç§æƒ…å†µä¸‹æ²¡æœ‰æ–°ç”³è¯·å†…å­˜ï¼Œè€Œæ˜¯ã€å…±ç”¨ã€‘çš„ä¹‹å‰çš„å†…å­˜ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 package main import \u0026#34;fmt\u0026#34; func main() { s := \u0026#34;hello Goè¯­è¨€\u0026#34; // å­—ç¬¦ä¸²ä½¿ç”¨åˆ‡ç‰‡ç”Ÿæˆçš„ä¾ç„¶æ˜¯å­—ç¬¦ä¸²ç±»å‹ï¼ŒåŒç”¨ä¸€ä¸ªåº•å±‚æ•°æ®ã€‚ // ä¸‹é¢æˆ‘ä»¬æ¥åˆ†æä¸‹main.mainçš„æ±‡ç¼–ç  çœ‹çœ‹è¿™ä¸€è¡Œæ˜¯å¦‚ä½•æ“ä½œçš„ s1 := s[:] fmt.Println(s1) // s1çš„ç±»å‹ä¸ºstring } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 # s1 := s[:] æƒ…å†µ # æ¯”è¾ƒæ ˆæ˜¯å¦æº¢å‡º r14å­˜å‚¨çš„å½“å‰groutine string.go:5\t0x496680 493b6610 cmp rsp, qword ptr [r14+0x10]\tstring.go:5\t0x496684 0f86b9000000 jbe 0x496743 # ç»™main.mainå‡½æ•°æ ˆé¢„åˆ†é…0x78å¤§å° string.go:5\t0x49668a 4883ec78 sub rsp, 0x78\t# å°†runtime.mainå‡½æ•°çš„æ ˆåŸºå€rspå…¥æ ˆï¼Œä»¥ä¾¿main.mainæ‰§è¡Œå®Œå¥½æ¢å¤ string.go:5\t0x49668e 48896c2470 mov qword ptr [rsp+0x70], rbp\t# å°†rbpæŒ‡å‘main.mainçš„æ–°æ ˆåŸºä½ç½®ï¼Œè¡¨ç¤ºmain.mainçš„æ ˆä¿¡æ¯èŒƒå›´ string.go:5\t0x496693 488d6c2470 lea rbp, ptr [rsp+0x70]\t# è¯¥æ“ä½œç­‰äºå°†å­—ç¬¦ä¸²sçš„åº•å±‚æ•°ç»„åœ°å€æ”¾å…¥rcx string.go:6\t0x496698 488d0de87c0100 lea rcx, ptr [rip+0x17ce8]\t# åˆ™éƒ¨æ“ä½œä¸ºç»™s.strèµ‹å€¼ã€‚s.data=rip+0x17ce8 string.go:6\t0x49669f 48894c2438 mov qword ptr [rsp+0x38], rcx # è¯¥æ“ä½œä¸ºç»™s.lenèµ‹å€¼ï¼Œæ ‡æ˜å­—ç¬¦ä¸²é•¿åº¦å¤§å°ã€‚s.len=14 string.go:6\t0x4966a4 48c74424400e000000 mov qword ptr [rsp+0x40], 0xe\t# ä»¥ä¸‹ä¸¤è¡Œæ˜¯ç¬¬9è¡Œä»£ç  s1 := s[:]\t# å¯ä»¥çœ‹è§æ˜¯å…¬å…±ç”¨çš„åŒä¸€ä¸ªåº•å±‚æ•°ç»„ã€‚ string.go:9\t0x4966ad 48894c2428 mov qword ptr [rsp+0x28], rcx\tstring.go:9\t0x4966b2 48c74424300e000000 mov qword ptr [rsp+0x30], 0xe ä¿®æ”¹ç¬¬10è¡Œs1 := s[:]ä¸ºs1 := s[:5]ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 # s1 := s[:5] æƒ…å†µ string.go:5\t0x496680 493b6610 cmp rsp, qword ptr [r14+0x10] string.go:5\t0x496684 0f86c6000000 jbe 0x496750 string.go:5\t0x49668a 4883ec78 sub rsp, 0x78 string.go:5\t0x49668e 48896c2470 mov qword ptr [rsp+0x70], rbp string.go:5\t0x496693 488d6c2470 lea rbp, ptr [rsp+0x70] # è¿™é‡Œå‡ è¡Œç»™sèµ‹å€¼ string.go:6\t0x496698 488d0de87c0100 lea rcx, ptr [rip+0x17ce8]\tstring.go:6\t0x49669f 48894c2438 mov qword ptr [rsp+0x38], rcx string.go:6\t0x4966a4 48c74424400e000000 mov qword ptr [rsp+0x40], 0xe string.go:9\t0x4966ad eb00 jmp 0x4966af string.go:9\t0x4966af eb00 jmp 0x4966b1 # è¿™å‡ è¡Œs[:5]ï¼Œä¸ºä»€ä¹ˆè¿™é‡Œçš„rip+0x17ccfå’Œä¸Šé¢çš„rip+0x17ce8ä¸ä¸€è‡´ï¼Ÿ # åŸå› æ˜¯Goé‡‡ç”¨çš„åœ°å€åŠ åç§»é‡çš„å½¢å¼ï¼Œè¿™é‡Œä¸å‰é¢çš„å·®é‡æ‰€ä»¥åç§»é‡æœ‰æ‰€å˜åŒ– # è¿˜æœ‰ä¸ªåŸå› æ˜¯ç¼–è¯‘é˜¶æ®µçš„å­—ç¬¦ä¸²æ˜¯è¢«å­˜å‚¨åœ¨ä»£ç æ®µçš„ï¼Œæ‰€ä»¥é€šè¿‡è¿™ç§å½¢å¼ï¼Œ # å¦‚æœæ˜¯è¢«å­˜å‚¨åœ¨æ ˆæˆ–å †ä¸Šå‘¢ï¼Œæ ˆåˆ™æ˜¯rsp+åç§»é‡çš„å½¢å¼ string.go:9\t0x4966b1 488d0dcf7c0100 lea rcx, ptr [rip+0x17ccf]\tstring.go:9\t0x4966b8 48894c2428 mov qword ptr [rsp+0x28], rcx string.go:9\t0x4966bd 48c744243005000000 mov qword ptr [rsp+0x30], 0x5 # æ›´å¤šs1 := s[2:5]åŸºæœ¬å’Œä¸Šé¢æƒ…å†µå·®ä¸å¤š æ³¨æ„ ä¸è¦å‘½åæ ‡è¯†ç¬¦å’ŒåŒ…åç§°ä¸€æ ·ï¼Œè¿™æ ·ä¼šå¯¼è‡´å¼•ç”¨åŒ…åç§°æ—¶éœ€è¦æ·»åŠ ç‰¹æ®Šåˆ«åç§°ï¼Œæ¯”å¦‚å‘½åå‡½æ•°åç§°bytes()å’ŒbytesåŒ…ä¸€è‡´ï¼Œå¯¼è‡´bytesåŒ…éœ€è¦åˆ«åç§°bytes2 \u0026quot;bytes\u0026quot;ã€‚ å‚è€ƒ å­—ç¬¦ä¸²å†…å­˜å¸ƒå±€ å­—ç¬¦ä¸²å†…å­˜å¸ƒå±€ å­—ç¬¦ä¸²å†…å­˜ unicodeã€utf8ã€utf16ã€utf32 ","permalink":"https://heliu.site/posts/golang/basic/string-memory/","summary":"Golang ä»‹ç»å­—ç¬¦ä¸²çš„å†…å­˜ç»“æ„ã€‚","title":"å­—ç¬¦ä¸²(å†…å­˜å¸ƒå±€)"},{"content":"+å­—ç¬¦ä¸²æ‹¼æ¥ golangä¸­ä½¿ç”¨+æ‹¼æ¥å­—ç¬¦ä¸²ä¼šè°ƒç”¨concatstringX()ç›¸å…³å‡½æ•°ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 // a0 + a1 func concatstring2(buf *tmpBuf, a0, a1 string) string { return concatstrings(buf, []string{a0, a1}) } // a0 + a1 + a2 func concatstring3(buf *tmpBuf, a0, a1, a2 string) string { return concatstrings(buf, []string{a0, a1, a2}) } // a0 + a1 + a2 + a3 func concatstring4(buf *tmpBuf, a0, a1, a2, a3 string) string { return concatstrings(buf, []string{a0, a1, a2, a3}) } // a0 + a1 + a2 + a3 + a4 func concatstring5(buf *tmpBuf, a0, a1, a2, a3, a4 string) string { return concatstrings(buf, []string{a0, a1, a2, a3, a4}) } const 1 2 3 4 5 6 // The constant is known to the compiler. // There is no fundamental theory behind this number. // // è¯¥å¸¸é‡æ˜¯ç¼–è¯‘å™¨å·²çŸ¥çš„ // è¿™ä¸ªæ•°å­—èƒŒåæ²¡æœ‰åŸºæœ¬ç†è®º const tmpStringBufSize = 32 type 1 2 // å½“è¦æ‹¼æ¥çš„å­—ç¬¦ä¸²é•¿åº¦å°äºç­‰äº32å­—èŠ‚å¤§å°ï¼Œä½¿ç”¨è¯¥ä¸´æ—¶ç¼“å­˜å®¹å™¨ï¼Œå¦åˆ™é‡æ–°ç”Ÿæˆä¸€ä¸ªå†…å­˜ç©ºé—´ä½¿ç”¨ type tmpBuf [tmpStringBufSize]byte\t// tmpBufåªæ˜¯ç”¨äºå®šä¹‰ä¸€ä¸ª*[32]byteçš„ç¼“å†² concatstrings() 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 // concatstrings implements a Go string concatenation x+y+z+... // The operands are passed in the slice a. // If buf != nil, the compiler has determined that the result does not // escape the calling function, so the string data can be stored in buf // if small enough. // // concatstrings å®ç°äº†ä¸€ä¸ª Go å­—ç¬¦ä¸²è¿æ¥ x+y+z+... æ“ä½œæ•°åœ¨åˆ‡ç‰‡ a ä¸­ä¼ é€’ // å¦‚æœ buf != nilï¼Œç¼–è¯‘å™¨å·²ç»ç¡®å®šç»“æœä¸ä¼šè½¬ä¹‰è°ƒç”¨å‡½æ•°ï¼Œæ‰€ä»¥å¦‚æœè¶³å¤Ÿå°ï¼Œå­—ç¬¦ä¸²æ•°æ®å¯ä»¥å­˜å‚¨åœ¨ buf ä¸­ func concatstrings(buf *tmpBuf, a []string) string { idx := 0 // è®°å½•aä¸­æœ€åä¸€ä¸ªä¸ä¸ºç©ºçš„ä¸‹æ ‡ç´¢å¼•å€¼ l := 0 // ç»Ÿè®¡aåˆ‡ç‰‡ä¸­æ‰€æœ‰å­—ç¬¦ä¸²å…ƒç´ çš„å­—èŠ‚æ•°é‡ï¼Œè¯¥å€¼ä¸»è¦ç”¨äºç»Ÿè®¡æ‹¼æ¥æ€»å¤§å°ç”¨äºç¡®å®šå†…å­˜ count := 0 // ç»Ÿè®¡aåˆ‡ç‰‡ä¸­æœ‰æ•ˆçš„å…ƒç´ æ•°é‡ï¼Œä¸ä¸ºç©ºçš„å­—ç¬¦ä¸² for i, x := range a { n := len(x) // è·å–å­—ç¬¦ä¸²é•¿åº¦å­—èŠ‚ if n == 0 { continue } // è¯¥æƒ…å†µå‘ç”Ÿåœ¨å­—ç¬¦ä¸²æ•°é‡å¤ªé•¿å¯¼è‡´intç±»å‹æº¢å‡ºæƒ…å†µ if l+n \u0026lt; l {\tthrow(\u0026#34;string concatenation too long\u0026#34;) } l += n // åŠ ä¸Šå½“å‰å­—ç¬¦ä¸²çš„é•¿åº¦ï¼Œè®°å½•çš„æ˜¯æ‰€æœ‰çš„å­—èŠ‚Bæ•°é‡ count++ // åˆ‡ç‰‡aä¸­æ‰€æœ‰æœ‰æ•ˆçš„çš„å­—ç¬¦ä¸²ï¼Œä¹Ÿå°±æ˜¯ä¸æ˜¯ç©ºä¸²çš„å­—ç¬¦ä¸²æ•°é‡ idx = i // è®°å½•æœ€æœ‰ä¸€ä¸ªæœ‰æ•ˆçš„å­—ç¬¦ä¸²çš„ç´¢å¼•ä¸‹æ ‡æ•° } if count == 0 { return \u0026#34;\u0026#34; } // If there is just one string and either it is not on the stack // or our result does not escape the calling frame (buf != nil), // then we can return that string directly. // // å¦‚æœåªæœ‰ä¸€ä¸ªå­—ç¬¦ä¸²å¹¶ä¸”å®ƒä¸åœ¨å †æ ˆä¸Šï¼Œæˆ–è€…æˆ‘ä»¬çš„ç»“æœæ²¡æœ‰è½¬ä¹‰è°ƒç”¨å¸§ï¼ˆbufï¼= nilï¼‰ï¼Œé‚£ä¹ˆæˆ‘ä»¬å¯ä»¥ç›´æ¥è¿”å›è¯¥å­—ç¬¦ä¸² // !stringDataOnStack(a[idx]) å¦‚æœä¸ºtrueè¡¨ç¤ºå½“å‰a[idx]ä¸åœ¨å½“å‰goroutineçš„è¿è¡Œæ ˆä¸­ï¼Œé‚£ä¹ˆè¡¨ç¤ºå¯ä»¥è¿”å› // å› ä¸ºgoroutineçš„æ ˆä¼šåœ¨gè¢«è¿è¡Œå®Œé”€æ¯ï¼Œæ‰€ä»¥ä¸é€‚åˆç›´æ¥è¿”å› // a[idx]åœ¨goroutineæ ˆä¸Šæ—¶ï¼Œç»§ç»­å»ä¸‹é¢ rawstringtmp if count == 1 \u0026amp;\u0026amp; (buf != nil || !stringDataOnStack(a[idx])) { return a[idx] // å¦‚æœcountä¸º1é‚£ä¹ˆ idxå­˜å‚¨çš„å°±æ˜¯è¿™ä¸ªå”¯ä¸€çš„æœ‰æ•ˆçš„å­—ç¬¦ä¸²ç´¢å¼•å€¼ } // sä¸bæ˜¯é•¿åº¦ä¸ºlçš„åº•å±‚æ•°ç»„ç›¸äº’å…³è”çš„ï¼Œè¿™æ‰€ä»¥è¿™æ ·æ˜¯å­—ç¬¦ä¸²æ˜¯ä¸å¯å˜ç±»å‹æˆ‘ä»¬éœ€è¦é€šè¿‡åˆ‡ç‰‡å¤„ç† s, b := rawstringtmp(buf, l)\t// æŠŠæ¥è‡ªaçš„å­—ç¬¦ä¸²æ‹·è´åˆ°bä¸­ï¼Œä¹Ÿå°±æ˜¯æ‹·è´åˆ°sä¸­ for _, x := range a { // æ‹·è´xåˆ°b\t// int copy([]byte, string) // è¿™ä¸€æ­¥æ“ä½œæ˜¯å› ä¸ºcopyå‡½æ•°çš„æ‹·è´æœºåˆ¶ copy(b, x)\tb = b[len(x):]\t} return s // såˆ™æ˜¯æ‹¼æ¥åçš„å­—ç¬¦ä¸² } stringDataOnStack() 1 2 3 4 5 6 7 8 9 // stringDataOnStack reports whether the string\u0026#39;s data is // stored on the current goroutine\u0026#39;s stack. // // stringDataOnStack æŠ¥å‘Šå­—ç¬¦ä¸²çš„æ•°æ®æ˜¯å¦å­˜å‚¨åœ¨å½“å‰ goroutine çš„å †æ ˆä¸­ func stringDataOnStack(s string) bool { ptr := uintptr(stringStructOf(\u0026amp;s).str) // ptrè·å–æ˜¯å­—ç¬¦ä¸²çš„åº•å±‚å€¼ stk := getg().stack\t// stkæ˜¯å½“å‰æ­£åœ¨è¿è¡Œçš„goroutineçš„æ ˆé¡¶å’Œæ ˆåº•èŒƒå›´ return stk.lo \u0026lt;= ptr \u0026amp;\u0026amp; ptr \u0026lt; stk.hi // åˆ¤æ–­å½“å‰å­—ç¬¦ä¸²æ˜¯å¦åœ¨è¿™ä¸ªèŒƒå›´å†… } stringStructOf() 1 2 3 4 5 6 7 8 9 func stringStructOf(sp *string) *stringStruct { /* type stringStruct struct { str unsafe.Pointer len int } */ return (*stringStruct)(unsafe.Pointer(sp)) } rawstringtmp() 1 2 3 4 5 6 7 8 9 10 11 // så’Œbéƒ½åˆ†åˆ«æŒ‡å‘bufï¼Œå¹¶ä¸”é•¿åº¦ä¸ºl func rawstringtmp(buf *tmpBuf, l int) (s string, b []byte) { // å½“å‰è¦å¤„ç†çš„é•¿åº¦låœ¨bufçš„èŒƒå›´å†… if buf != nil \u0026amp;\u0026amp; l \u0026lt;= len(buf) { b = buf[:l] // bufæ˜¯æ•°å­—æŒ‡é’ˆï¼Œå› æ­¤bæ˜¯åˆ‡ç‰‡å¼•ç”¨buf s = slicebytetostringtmp(\u0026amp;b[0], len(b)) // å°†bufä¸så…³è”èµ·æ¥ } else { s, b = rawstring(l) // é‡æ–°åˆ†é…å†…å­˜ï¼ŒæŠŠså’Œbå…³è”èµ·æ¥ } return } slicebytetostringtmp() 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 // slicebytetostringtmp returns a \u0026#34;string\u0026#34; referring to the actual []byte bytes. // // Callers need to ensure that the returned string will not be used after // the calling goroutine modifies the original slice or synchronizes with // another goroutine. // // The function is only called when instrumenting // and otherwise intrinsified by the compiler. // // Some internal compiler optimizations use this function. // - Used for m[T1{... Tn{..., string(k), ...} ...}] and m[string(k)] // where k is []byte, T1 to Tn is a nesting of struct and array literals. // - Used for \u0026#34;\u0026lt;\u0026#34;+string(b)+\u0026#34;\u0026gt;\u0026#34; concatenation where b is []byte. // - Used for string(b)==\u0026#34;foo\u0026#34; comparison where b is []byte. func slicebytetostringtmp(ptr *byte, n int) (str string) { if raceenabled \u0026amp;\u0026amp; n \u0026gt; 0 { racereadrangepc(unsafe.Pointer(ptr), uintptr(n), getcallerpc(), abi.FuncPCABIInternal(slicebytetostringtmp)) } if msanenabled \u0026amp;\u0026amp; n \u0026gt; 0 { msanread(unsafe.Pointer(ptr), uintptr(n)) } if asanenabled \u0026amp;\u0026amp; n \u0026gt; 0 { asanread(unsafe.Pointer(ptr), uintptr(n)) } // ä½¿stræŒ‡å‘ptrï¼Œé•¿åº¦ä¸ºn stringStructOf(\u0026amp;str).str = unsafe.Pointer(ptr) stringStructOf(\u0026amp;str).len = n return } rawstring() 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // rawstring allocates storage for a new string. The returned // string and byte slice both refer to the same storage. // The storage is not zeroed. Callers should use // b to set the string contents and then drop b. func rawstring(size int) (s string, b []byte) { p := mallocgc(uintptr(size), nil, false)\t// é‡æ–°ç”³è¯·å†…å­˜ // å…³è”så’Œb stringStructOf(\u0026amp;s).str = p stringStructOf(\u0026amp;s).len = size *(*slice)(unsafe.Pointer(\u0026amp;b)) = slice{p, size, size} return } ","permalink":"https://heliu.site/posts/golang/basic/string-splice/","summary":"Golang +æ‹¼æ¥ä»‹ç»ã€‚","title":"å­—ç¬¦ä¸²(+æ‹¼æ¥)"},{"content":"æ•°æ®ç»“æ„åŠç±»å‹ç»“æ„ æ•°æ®ç»“æ„åŠç±»å‹ç»“æ„ç»„æˆå›¾ï¼šï¼ˆå…³äºç±»å‹æ„æˆè¯¦ç»†åé¢æ–‡ç« ä»‹ç»ï¼‰ æ•°æ®ç»“æ„ æ•°æ®ç»“æ„è®°å½•å­—ç¬¦ä¸²è®°å½•çš„å†…å­˜æ•°æ®ç›¸å…³ä¿¡æ¯ã€‚æ¯”å¦‚ã€å­—ç¬¦ä¸²çš„å†…å®¹ã€‘ä»¥åŠã€å­—ç¬¦ä¸²çš„é•¿åº¦ã€‘ã€‚ String.dataï¼šæ˜¯ä¸€ä¸ªæŒ‡é’ˆï¼ŒæŒ‡å‘ä¸€ä¸ªbyteç±»å‹æ•°ç»„çš„é¦–åœ°å€ã€‚ String.lenï¼šè®°å½•å½“å‰å­—ç¬¦ä¸²çš„é•¿åº¦ï¼Œä»¥å­—èŠ‚ä¸ºå•ä½ã€‚ 1 2 3 4 type String struct { data unsafe.Pointer len int } ç±»å‹ç»“æ„ ç±»å‹ç»“æ„è®°å½•å­—ç¬¦ä¸²ç±»å‹ç›¸å…³ä¿¡æ¯ã€‚æ¯”å¦‚å­—ç¬¦ä¸²ã€å ç”¨å†…å­˜å¤§å°ã€‘ã€åŒ…å«æŒ‡é’ˆæ•°é‡ã€‘ã€å­—æ®µå¯¹é½ã€‘ç­‰ä¿¡æ¯ã€‚ _typeï¼šè®°å½•ç±»å‹åŸæ•°æ®ç»“æ„ï¼Œç”¨äºè¡¨ç¤ºæ‰€æœ‰ç±»å‹å…±æœ‰çš„å±æ€§ç»“æ„ã€‚ å…³äº_typeçš„å…·ä½“å«ä¹‰åœ¨ç›¸å…³ç« èŠ‚åˆ—å‡ºã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 type u struct { _type } type _type struct { size uintptr ptrdata uintptr hash uint32 tflag tflag align uint8 fieldAlign uint8 kind uint8 equal func(unsafe.Pointer, unsafe.Pointer) bool gcdata *byte str nameOff ptrToThis typeOff } ","permalink":"https://heliu.site/posts/golang/basic/string-type/","summary":"Golang å­—ç¬¦ä¸²çš„ç±»å‹ç»“æ„ä»‹ç»ã€‚","title":"å­—ç¬¦ä¸²(ç±»å‹ç»“æ„)"},{"content":"ifè¯­å¥ ifè¯­å¥åç´§è·Ÿä¸€ä¸ªæˆ–å¤šä¸ªè¯­å¥ç»„æˆï¼Œæ³¨æ„å¸ƒå°”è¡¨è¾¾å¼ä¸èƒ½ç”¨0æˆ–1ã€‚ å¦‚æœè¡¨è¾¾å¼æ±‚å€¼ä¸ºtrueï¼Œåˆ™æ‰§è¡Œ\u0026quot;if\u0026quot;åˆ†æ”¯ï¼Œå¦åˆ™æ‰§è¡Œ\u0026quot;else\u0026quot;åˆ†æ”¯ã€‚ GoLangä¸æ”¯æŒä¸‰ç›®è¿ç®— a \u0026gt; b ? a : bï¼Œå®˜æ–¹çš„è§£é‡Šæ˜¯ä¸‰ç›®è¿ç®—ä¼šå¯¼è‡´å¤æ‚çš„è¡¨è¾¾å¼ã€‚ 1 2 3 4 5 6 7 8 // 1) if expr { } //\tOR // 2) if Init; expr { } if å¸ƒå°”è¡¨è¾¾å¼ {\t// å¸ƒå°”è¡¨è¾¾å¼ä¸ºtrueæ—¶æ‰§è¡Œ } else { // å¸ƒå°”è¡¨è¾¾å¼ä¸ºfalseæ—¶æ‰§è¡Œ } ç”±äºifå’Œswitchéƒ½æ¥å—åˆå§‹åŒ–è¯­å¥ï¼Œå› æ­¤é€šå¸¸ä¼šçœ‹åˆ°ç”¨äºè®¾ç½®å±€éƒ¨å˜é‡çš„è¯­å¥ã€‚ è¯¥è¯­å¥åœ¨è®¡ç®—è¡¨è¾¾å¼ä¹‹å‰æ‰§è¡Œã€‚ ifå’Œelse ifåéƒ½å¯ä»¥è·Ÿã€Init; exprã€‘è¯­å¥ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 package main import ( \u0026#34;fmt\u0026#34; ) func main() { // è¿™é‡Œæ³¨æ„ï¼Œè¿™é‡Œä½¿ç”¨çš„æ˜¯ ; ä¸æ˜¯ , // 1. ;åˆ†å·ï¼šç”¨äºåˆ†éš”è¯­å¥ // 2. ,é€—å·ï¼šå¸¸ç”¨è¯­åˆ†éš”å˜é‡å¤šè¿”å›èµ‹å€¼å½¢å¼ if x := 1; x \u0026lt; 10 { fmt.Println(\u0026#34;12345\u0026#34;) } else if x \u0026gt; 0 { // else if x = 2; x \u0026gt; 0 {} fmt.Println(\u0026#34;6789\u0026#34;) } else { fmt.Println(\u0026#34;147258369\u0026#34;) } // be equivalent to // æ³¨æ„ï¼šxx çš„ä½œç”¨åŸŸï¼Œå½“å‰åˆ†æ”¯ä»¥åéƒ½é€‚ç”¨ { xx := 1 if xx \u0026lt; 10 { fmt.Println(\u0026#34;12345\u0026#34;) } else { if xx \u0026gt; 0 { fmt.Println(\u0026#34;6789\u0026#34;) } else { fmt.Println(\u0026#34;147258369\u0026#34;) } } } // else if å…¨éƒ¨éƒ½å¯ä»¥è½¬æ¢æˆif elseå½¢å¼ï¼Œè¿™é‡Œæ˜¯ä¸ºäº†æ›´å¥½çš„ç†è§£åˆå§‹åŒ–è¯­å¥æ‰€åœ¨å—ä½ç½® // Output: // 12345 // 12345 } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 func Ts() { rand.Seed(time.Now().UnixNano()) n := rand.Intn(100) // 1. éªŒè¯ if Init; expr {} è¯­å¥ // 2. éªŒè¯ else if Init; expr {} è¯­å¥ if x := 2; x+n \u0026gt; 5 { print(x) // 2 } else if x = 1; x-n \u0026gt; 2 { print(x) // 1 } else if n == 2 { print(x) // 1 } else { print(x) // 1 } } å½“ifè¯­å¥æ²¡æœ‰è¿›å…¥ä¸‹ä¸€ä¸ªè¯­å¥ï¼Œå³æ­£æ–‡ä»¥breakã€continueã€gotoæˆ–returnç»“å°¾æ—¶ï¼Œçœç•¥ä¸å¿…è¦çš„elseã€‚ 1 2 3 4 f, err := os.Open(name) if err != nil { return err } breakè¯­å¥ ä¸€ä¸ªbreakçš„ä½œç”¨èŒƒå›´ä¸ºè¯¥è¯­å¥å‡ºç°çš„æœ€å†…éƒ¨çš„ç»“æ„ï¼Œå®ƒå¯ä»¥ç”¨äºä»»ä½•å½¢å¼çš„forå¾ªç¯ã€‚ åœ¨switchæˆ–selectè¯­å¥ä¸­ï¼Œbreakè¯­å¥çš„ä½œç”¨æ˜¯è·³è¿‡æ•´ä¸ªä»£ç å—ï¼Œç»§ç»­æ‰§è¡Œswitchæˆ–selectå¤–åç»­çš„ä»£ç ã€‚ è¯­å¥ä¸­å¦‚æœæœ‰æ ‡ç­¾ï¼Œåˆ™å¿…é¡»æ˜¯åŒ…å«forã€switchæˆ–selectè¯­å¥çš„æ ‡ç­¾ã€‚å¹¶ä¸”è¯¥æ ‡ç­¾æ˜¯å¯ä»¥æ‰§è¡Œç»ˆæ­¢çš„ã€‚ breakä¸¤ä¸ªä½œç”¨ï¼š é’ˆå¯¹forå…³é”®å­—ç»“æŸå¾ªç¯ã€‚ é’ˆå¯¹switchã€selectå…³é”®å­—è·³å‡ºæ•´ä¸ªä»£ç å—ã€‚ä½†switchå’Œselectçš„caseåæ˜¯é»˜è®¤è‡ªå¸¦breakï¼Œå¦‚æœæ˜¾ç¤ºå†™ä¸Šä¹Ÿåªæ˜¯è·³å‡ºswitchå’Œselectå—ã€‚ breakåœ¨switchä¸­å¯ä»¥ä½œä¸ºifåˆ†æ”¯ç»“æŸæ¡ä»¶ã€‚ 1 2 3 4 5 6 7 switch { case true: if true { break\t// æ¯”å¦‚è¿™é‡Œï¼Œé€€å‡ºcaseåˆ†æ”¯ } // å…¶ä»–ä»£ç  ... } å› æ­¤åœ¨switchæˆ–selectå—ä¸­ä½¿ç”¨breakå…³é”®å­—åªèƒ½è·³å‡ºã€å½“å‰ã€‘switchæˆ–selectå—ã€‚å¦‚æœæƒ³è·³å‡ºå¤–å±‚forå¾ªç¯åˆ™éœ€è¦break LabelåŠ ä¸Šæ ‡ç­¾åç§°ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 package main import ( \u0026#34;fmt\u0026#34; ) func main() { fmt.Println(\u0026#34;start\u0026#34;) OuterLoop:\t// å®šä¹‰æ ‡ç­¾ for i := 0; i \u0026lt; 3; i++ { fmt.Println(\u0026#34;i å¾ªç¯ï¼š\u0026#34;, i) for j := 0; j \u0026lt; 3; j++ { fmt.Println(\u0026#34;j å¾ªç¯ï¼š\u0026#34;, j) // switchå’Œselecté»˜è®¤æ˜¯è‡ªå¸¦breakçš„ switch j { case 0: fmt.Println(\u0026#34;break\u0026#34;) break // break åªæ˜¯è·³å‡ºswitchè¯­å¥å—ï¼Œä¸ä¼šè·³å‡ºåˆ°forå— case 2: fmt.Println(\u0026#34;2 OuterLoop\u0026#34;) // switché»˜è®¤å¸¦æœ‰breakè¯­å¥ï¼Œè¿™é‡ŒæŒ‡æ˜breakè¯­å¥è¦è·³å‡ºçš„æ ‡ç­¾ä½ç½® break OuterLoop // ç›´æ¥è·³å‡ºæ•´ä¸ªå¾ªç¯ } fmt.Println(\u0026#34;switch:\u0026#34;, j) } } fmt.Println(\u0026#34;end\u0026#34;) // Output: // start // i å¾ªç¯ï¼š 0 // j å¾ªç¯ï¼š 0 // break // switch: 0 // j å¾ªç¯ï¼š 1 // switch: 1 // j å¾ªç¯ï¼š 2 // 2 OuterLoop // end } æ³¨æ„break label; label(æ ‡ç­¾)åªèƒ½æ˜¯ä¹‹å‰å‡ºç°çš„ï¼Œcontinueå…³é”®å­—ä¹Ÿæ˜¯ã€‚ä½†æ˜¯gotoå…³é”®å­—å´å¯ä»¥è·³è½¬åˆ°åé¢çš„æ ‡ç­¾å¤„ã€‚ continueè¯­å¥ å…³é”®å­—continueç”¨åœ¨å…³é”®å­—forï¼ˆç»“æŸæœ¬æ¬¡å¾ªç¯ï¼Œç»§ç»­ä¸‹æ¬¡å¾ªç¯ï¼‰ï¼Œä½†ä¸æ˜¯æ— æ¡ä»¶æ‰§è¡Œä¸‹ä¸€æ¬¡å¾ªç¯ï¼Œæ‰§è¡Œä¹‹å‰ä¾æ—§éœ€è¦æ»¡è¶³å¾ªç¯çš„åˆ¤æ–­æ¡ä»¶ã€‚ å¦‚æœæœ‰ä¸€ä¸ªæ ‡ç­¾ï¼Œé‚£ä¹ˆå®ƒå¿…é¡»æ˜¯ä¸€ä¸ªå°é—­çš„forè¯­å¥ï¼Œå¹¶ä¸”æ˜¯å½“å‰æ‰§è¡Œè¿›ç¨‹çš„æ ‡ç­¾ã€‚ 1 2 3 4 5 6 7 8 9 RowLoop: for y, row := range rows { for x, data := range row { if data == endOfRow { continue RowLoop } row[x] = data + bias(x, y) } } ä½¿ç”¨ç¤ºä¾‹ï¼š 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 func main() { rows := []string{\u0026#34;hello\u0026#34;, \u0026#34;world\u0026#34;} rowLoop: for _, row := range rows { for _, data := range row { if data == \u0026#39;l\u0026#39; { // continue ç”¨äºç»“æŸæœ¬æ¬¡å¾ªç¯ï¼Œè¿›è¡Œä¸‹ä¸€æ¬¡å¾ªç¯ continue rowLoop } fmt.Printf(\u0026#34;%c\\n\u0026#34;, data) } } // Output: // h // e // w // o // r } æ ‡ç­¾ forã€switchã€selectè¯­å¥éƒ½å¯ä»¥é…åˆæ ‡ç­¾ï¼ˆlabelï¼‰å½¢å¼çš„æ ‡è¯†ç¬¦ä½¿ç”¨ã€‚æ ‡ç­¾å¯ä»¥åœ¨ä»£ç çš„ä»»ä½•åœ°æ–¹ï¼ˆå‡½æ•°ä½“å†…ï¼‰ã€‚ å³æŸä¸€è¡Œç¬¬ä¸€ä¸ªå¯ä»¥å†’å·ï¼ˆ:ï¼‰ç»“å°¾çš„å•è¯ï¼ˆGofmt ä¼šå°†åç»­ä»£ç è‡ªåŠ¨ç§»è‡³ä¸‹ä¸€è¡Œï¼‰ æ ‡ç­¾çš„åç§°æ˜¯å¤§å°å†™æ•æ„Ÿçš„ï¼Œä¸ºäº†æå‡å¯è¯»æ€§ï¼ˆå¯ä»¥é¦–å­—æ¯å¤§å°ï¼Œå¯è¯»æ€§æ¯”è¾ƒé«˜å°±è¡Œï¼‰ã€‚ 1 2 ERROR: // Error or err log.Panic(\u0026#34;error\u0026#34;)\t// æ ‡ç­¾åçš„ä»£ç  æ ‡ç­¾ç”¨äºbreakã€continueã€gotoè¯­å¥ï¼Œå®šä¹‰ä»æœªä½¿ç”¨çš„æ ‡ç­¾æ˜¯éæ³•çš„ï¼Œä¸èƒ½ç¼–è¯‘æˆåŠŸã€‚ï¼ˆå®šä¹‰äº†æ ‡ç­¾ä¸€å®šè¦ä½¿ç”¨ï¼‰ gotoè¯­å¥ gotoè¯­å¥æ˜¯è·³è½¬åˆ°å…·ä½“æœ‰ç›¸åŒå‡½æ•°å†…ç›¸åº”æ ‡ç­¾çš„è¯­å¥ã€‚ï¼ˆç»“åˆæ ‡ç­¾ä½¿ç”¨ï¼Œé€šå¸¸ç”¨åœ¨ä¸€äº›å…¬å…±ä»£ç éƒ¨åˆ†æˆ–å¾ªç¯é€»è¾‘å¤„ï¼‰ 1 goto ERROR Goè¯­è¨€ä¸é¼“åŠ±å¤šå±‚åµŒå¥—ä½¿ç”¨æ ‡ç­¾å’Œgotoè¯­å¥ï¼Œå› ä¸ºå®ƒä»¬ä¼šå¯¼è‡´éå¸¸ç³Ÿç³•çš„ç¨‹åºè®¾è®¡ï¼Œè€Œä¸”æ€»æœ‰æ›´åŠ å¯è¯»çš„æ›¿ä»£æ–¹æ¡ˆæ¥å®ç°ç›¸åŒå¾—éœ€æ±‚ã€‚ å—å¤–çš„gotoè¯­å¥ä¸èƒ½è·³è½¬åˆ°è¯¥å—å†…çš„æ ‡ç­¾ã€‚ï¼ˆåªèƒ½å¹³çº§è·³æˆ–è·³å‡ºåˆ°å¤–å±‚å—ï¼‰ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // ä»¥ä¸‹ä»£ç ä¸èƒ½é€šè¿‡ç¼–è¯‘ package main import \u0026#34;fmt\u0026#34; var x int = 10 func main() { if x % 2 == 1 { goto L1 // L1æ ‡ç­¾åœ¨å—å†… } for x \u0026lt; 10 { x-- fmt.Println(x) L1: // åœ¨forå†…éƒ¨ x-- fmt.Println(x) } } gotoè¯­å¥æ˜¯å¯ä»¥è·³è½¬åˆ°åé¢å‡ºç°çš„æ ‡ç­¾çš„ï¼Œå‰ææ˜¯æ»¡è¶³å—å¤–çš„gotoè¯­å¥ä¸èƒ½è·³è½¬åˆ°å—å†…çš„æ ‡ç­¾ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 package main import ( \u0026#34;fmt\u0026#34; ) var x = 10 func main() { goto TL // å‘åè·³è½¬åˆ°TLå¤„ï¼Œè¿™ç§æ¯”è¾ƒå°‘ç”¨ï¼Œå› ä¸ºæ¥ä¸‹é¢çš„ä»£ç æ°¸ä¹…ä¸ä¼šæ‰§è¡Œ fmt.Println(x) // è¿™è¡Œä»£ç ä¸ä¼šæ‰§è¡Œ TL: fmt.Println(\u0026#34;TL\u0026#34;) // Output: // TL } gotoå¤šç”¨äºè·³è½¬åˆ°å‰é¢ä»£ç çš„æ ‡ç­¾å¤„ï¼Œè¿™æ ·å°±å½¢æˆäº†å¾ªç¯ã€‚ æ€»ç»“ gotoã€breakã€continueï¼šä¸‰ä¸ªè¯­å¥éƒ½å¯ä»¥é…åˆæ ‡ç­¾(label)ä½¿ç”¨ã€‚ æ ‡ç­¾ååŒºåˆ†å¤§å°å†™ï¼Œå®šä¹‰åè‹¥ä¸ä½¿ç”¨ä¼šé€ æˆç¼–è¯‘é”™è¯¯ã€‚ continueã€breaké…åˆæ ‡ç­¾(label)å¯ç”¨äºå¤šå±‚å¾ªç¯è·³å‡ºã€‚ gotoæ˜¯è°ƒæ•´æ‰§è¡Œä½ç½®ï¼Œä¸continueã€breaké…åˆæ ‡ç­¾(label)çš„ç»“æœå¹¶ä¸ç›¸åŒã€‚ ","permalink":"https://heliu.site/posts/golang/process/if/","summary":"Golang ifã€breakã€contineã€gotoä»‹ç»ã€‚","title":"æµç¨‹æ§åˆ¶(æ¡ä»¶è¯­å¥)"},{"content":"forè®¡æ•°å™¨è¿­ä»£ 1 for åˆå§‹åŒ–è¯­å¥; æ¡ä»¶è¯­å¥; ä¿®é¥°è¯­å¥ {} ç”±ä¸‰éƒ¨åˆ†ç»„æˆå¾ªç¯çš„å¤´éƒ¨ï¼Œç›¸äº’ä¹‹é—´ä½¿ç”¨è‹±æ–‡åˆ†å·ï¼ˆ;ï¼‰éš”å¼€ï¼Œä½†å¹¶ä¸éœ€è¦æ‹¬å·å°†å®ƒä»¬æ‹¬èµ·æ¥ã€‚ åŒºåˆ«å…¶ä»–è¯­è¨€å½¢å¼å¦‚ã€for (åˆå§‹åŒ–è¯­å¥; æ¡ä»¶è¯­å¥; ä¿®é¥°è¯­å¥) {} ã€‘å…¶å®ä½¿ç”¨æ‹¬å·åŒ…èµ·æ¥ä¹Ÿå¯ä»¥ã€‚ åŒæ—¶ä½¿ç”¨å¤šä¸ªè®¡æ•°å™¨ è¿™å¾—ç›ŠäºGoè¯­è¨€å…·æœ‰å¹³è¡Œèµ‹å€¼çš„ç‰¹æ€§ã€‚ åŒºåˆ«æ€»ç»“ï¼š forå…³é”®å­—åé¢ä¸éœ€è¦æ‹¬å·ã€‚ åˆå§‹åŒ–è¯­å¥å’Œä¿®é¥°è¯­å¥å¯ä»¥ä½¿ç”¨å¹³è¡Œèµ‹å€¼çš„ç‰¹æ€§ã€‚ 1 2 3 4 // æ³¨æ„è¿™é‡Œçš„ ã€åˆå§‹åŒ–è¯­å¥ã€‘ å’Œ ã€ä¿®é¥°è¯­å¥ã€‘ // åˆå§‹åŒ–è¯­å¥ï¼ši, j := 0, N // ä¿®é¥°è¯­å¥ï¼ši, j = i+1, j-1 for i, j := 0, N; i \u0026lt; j; i, j = i+1, j-1 {} for{} å¯ä»¥è®¤ä¸ºè¿™æ˜¯æ²¡æœ‰ã€åˆå§‹åŒ–è¯­å¥ã€‘å’Œã€ä¿®é¥°è¯­å¥ã€‘çš„forç»“æ„ï¼Œå› æ­¤;;ä¾¿æ˜¯å¤šä½™çš„äº†ã€‚ å³ä½¿æ˜¯æ¡ä»¶è¯­å¥ä¹Ÿå¯ä»¥çœç•¥ï¼Œå¦‚ã€i: = 0; ;i++ã€‘æˆ–ã€for {} æˆ– for ;; {}ã€‘å¤šä½™çš„;;ä¼šåœ¨ä½¿ç”¨æ—¶ç§»é™¤ï¼Œè¿™äº›å¾ªç¯çš„æœ¬è´¨å°±æ˜¯æ— é™å¾ªç¯ã€‚ ä¹Ÿå¯ä»¥å†™æˆã€for true {}ã€‘ä¸€èˆ¬éƒ½æ˜¯ç›´æ¥å†™æˆã€for {}ã€‘ã€‚ å¦‚æœforå¾ªç¯çš„å¤´éƒ¨æ²¡æœ‰æ¡ä»¶è¯­å¥ï¼Œé»˜è®¤ä¸ºtrueå’Œswitchæ²¡æœ‰è¡¨è¾¾å¼ç±»ä¼¼é»˜è®¤ä¸ºtrueã€‚ ä¸€èˆ¬Goå¤„ç†ç±»ä¼¼æƒ…å†µçš„å¸¸ç”¨æ³•åˆ™ï¼Œå› æ­¤å¾ªç¯ä½“å†…å¿…é¡»æœ‰ç›¸å…³çš„æ¡ä»¶åˆ¤æ–­ä»¥ç¡®ä¿ä¼šåœ¨æŸä¸ªæ—¶åˆ»é€€å‡ºå¾ªç¯ã€‚ åŒºåˆ«æ€»ç»“ï¼š ã€for {}ã€‘æˆ‘ä»¬å¯ä»¥ç†è§£ä¸ºã€for æ¡ä»¶è¯­å¥ {}ã€‘è¿™ç§å½¢å¼ï¼Œçœç•¥äº†åˆå§‹åŒ–è¯­å¥å’Œä¿®é¥°è¯­å¥ï¼Œä¸å…¶ä»–è¯­è¨€ã€while (true) {}ã€‘ç”¨æ³•ç±»ä¼¼ã€‚ 1 for {} // ç­‰ä»·äº for true {} ä½¿ç”¨ç¤ºä¾‹ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 package main import ( \u0026#34;fmt\u0026#34; ) func main() { // åˆ›å»º[]intåˆ‡ç‰‡ a := []int{1,2,3,4,5,6} // äº¤æ¢åˆ‡ç‰‡é¦–å°¾æ•°æ® for i,j := 0,len(a)-1; i \u0026lt; j; i,j = i+1,j-1 { a[i], a[j] = a[j], a[i] } fmt.Println(a) // [6 5 4 3 2 1] // å¤šé‡å¾ªç¯æ»¡è¶³æ¡ä»¶é€€å‡º for j := 0; j \u0026lt; 5; j++ { for i := 0; i \u0026lt; 10; i++ { if i \u0026gt; 5 { break } fmt.Printf(\u0026#34;%d \u0026#34;, i) } fmt.Println() } // Output: // [6 5 4 3 2 1] // 0 1 2 3 4 5 // 0 1 2 3 4 5 // 0 1 2 3 4 5 // 0 1 2 3 4 5 // 0 1 2 3 4 5 } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 s := \u0026#34;abc\u0026#34; // 1) å¸¸è§çš„ for å¾ªç¯ï¼Œæ”¯æŒåˆå§‹åŒ–è¯­å¥ for i,n := 0,len(s); i \u0026lt; n; i++ { fmt.Printf(\u0026#34;%c\\n\u0026#34;, s[i]) } // Output: // a // b // c n := len(s) // 2) æ›¿ä»£ while (n \u0026gt; 0) {} for n \u0026gt; 0 { fmt.Println(s[n-1]) n-- } // Output: // 99 // 98 // 97 // 3) æ›¿æ¢ while (true) {} æˆ– for (;;) {} for { fmt.Println(s) } // Output: // abc // ... 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 package main import \u0026#34;fmt\u0026#34; func main() { var b int = 15 var a int // [1, 2, 3, 5, 0, 0] numbers := [6]int{1, 2, 3, 5} // 1) for å¾ªç¯ for a := 0; a \u0026lt; 10; a++ { fmt.Printf(\u0026#34;a çš„å€¼ä¸ºï¼š%d\\n\u0026#34;, a) } // 2) for true for a \u0026lt; b { a++ fmt.Printf(\u0026#34;a çš„å€¼ä¸ºï¼š%d\\n\u0026#34;, a) } // 3) for range for i, x := range numbers { fmt.Printf(\u0026#34;ç¬¬ %d ä½ x çš„å€¼ = %d\\n\u0026#34;, i, x) } // Output: // a çš„å€¼ä¸ºï¼š0 // a çš„å€¼ä¸ºï¼š1 // a çš„å€¼ä¸ºï¼š2 // a çš„å€¼ä¸ºï¼š3 // a çš„å€¼ä¸ºï¼š4 // a çš„å€¼ä¸ºï¼š5 // a çš„å€¼ä¸ºï¼š6 // a çš„å€¼ä¸ºï¼š7 // a çš„å€¼ä¸ºï¼š8 // a çš„å€¼ä¸ºï¼š9 // a çš„å€¼ä¸ºï¼š1 // a çš„å€¼ä¸ºï¼š2 // a çš„å€¼ä¸ºï¼š3 // a çš„å€¼ä¸ºï¼š4 // a çš„å€¼ä¸ºï¼š5 // a çš„å€¼ä¸ºï¼š6 // a çš„å€¼ä¸ºï¼š7 // a çš„å€¼ä¸ºï¼š8 // a çš„å€¼ä¸ºï¼š9 // a çš„å€¼ä¸ºï¼š10 // a çš„å€¼ä¸ºï¼š11 // a çš„å€¼ä¸ºï¼š12 // a çš„å€¼ä¸ºï¼š13 // a çš„å€¼ä¸ºï¼š14 // a çš„å€¼ä¸ºï¼š15 // ç¬¬ 0 ä½ x çš„å€¼ = 1 // ç¬¬ 1 ä½ x çš„å€¼ = 2 // ç¬¬ 2 ä½ x çš„å€¼ = 3 // ç¬¬ 3 ä½ x çš„å€¼ = 5 // ç¬¬ 4 ä½ x çš„å€¼ = 0 // ç¬¬ 5 ä½ x çš„å€¼ = 0 } åˆ¤æ–­ä¸€ä¸ªæ•°æ˜¯å¦æ˜¯è´¨æ•° 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;math\u0026#34; ) func main() { for i := uint64(2) ; i \u0026lt; 100; i++ { if isPrime(i) { fmt.Printf(\u0026#34;%d æ˜¯ç´ æ•°\\n\u0026#34;, i) } } } // isPrime åˆ¤æ–­numæ˜¯å¦æ˜¯ç´ æ•°(è´¨æ•°) ç´ æ•°åªèƒ½è¢«1å’Œæœ¬èº«æ•´é™¤ func isPrime(num uint64) bool { // å‡è®¾Aæ˜¯æ¡ä»¶ï¼ŒBæ˜¯ç»“è®º // ç”±Aå¯ä»¥æ¨å‡ºBï¼Œç”±Bå¯ä»¥æ¨å‡ºAï¼Œåˆ™Aæ˜¯Bçš„ (å……è¦æ¡ä»¶) // ç”±Aå¯ä»¥æ¨å‡ºBï¼Œç”±Bä¸å¯ä»¥æ¨å‡ºAï¼Œåˆ™Aæ˜¯Bçš„ (å……åˆ†ä¸å¿…è¦æ¡ä»¶) // ç”±Aä¸å¯ä»¥æ¨å‡ºBï¼Œç”±Bå¯ä»¥æ¨å‡ºAï¼Œåˆ™Aæ˜¯Bçš„ (å¿…è¦ä¸å……åˆ†æ¡ä»¶) // ç”±Aä¸å¯ä»¥æ¨å‡ºBï¼Œç”±Bä¸å¯ä»¥æ¨å‡ºAï¼Œåˆ™Aæ˜¯Bçš„ (æ—¢ä¸å……åˆ†ä¹Ÿä¸å¿…è¦æ¡ä»¶) // å¤§äºç­‰äº5çš„è´¨æ•°ä¸€å®šå’Œ6çš„å€æ•°ç›¸é‚» (å……åˆ†ä¸å¿…è¦æ¡ä»¶) // ä¸6çš„å€æ•°ç›¸é‚»çš„æ•°ä¸ä¸€å®šæ˜¯å¤§äºç­‰äº5çš„è´¨æ•° // è¯æ˜ï¼š(n \u0026gt;= 1, nå±äºè‡ªç„¶æ•°) // 6n + 0\t=\u0026gt; 2*3*n\t=\u0026gt; åˆæ•° // 6n + 1 -----\u0026gt; å¯èƒ½æ˜¯ç´ æ•°(7)ï¼Œä¹Ÿå¯èƒ½æ˜¯åˆæ•°(25) // 6n + 2\t=\u0026gt; 2*(3n+1)\t=\u0026gt; åˆæ•° // 6n + 3\t=\u0026gt; 3*(2n+1)\t=\u0026gt; åˆæ•° // 6n + 4\t=\u0026gt; 2*(3n+2)\t=\u0026gt; åˆæ•° // 6n + 5 -----\u0026gt; å¯èƒ½æ˜¯ç´ æ•°(11)ï¼Œä¹Ÿå¯èƒ½æ˜¯åˆæ•°(35) // ä¸Šé¢çš„åˆ—è¡¨èƒ½è¡¨ç¤ºæ‰€æœ‰\u0026gt;=5çš„è‡ªç„¶æ•°ï¼Œå› æ­¤å¤§äºç­‰äº5çš„è´¨æ•°ä¸€å®šå’Œ6çš„å€æ•°ç›¸é‚» // 5ä»¥ä¸‹çš„è´¨æ•°åˆ†åˆ«ä¸º 2å’Œ3 if num == 2 || num == 3 { return true } // å¤§äºç­‰äº5çš„è´¨æ•°ä¸€å®šå’Œ6çš„å€æ•°ç›¸é‚»ï¼Œç›¸åä¸åœ¨6çš„å€æ•°ä¸¤ä¾§çš„ä¸€å®šæ˜¯åˆæ•° // è¿™é‡Œæ’é™¤äº†æ‰€æœ‰è¢«2å’Œ3æ•´é™¤çš„åˆæ•°ï¼Œå› æ­¤åé¢çš„forå¾ªç¯åªéœ€éªŒè¯æ˜¯å¦èƒ½è¢«å…¶ä»–è´¨æ•°æ•´é™¤å³å¯ if num % 6 != 1 \u0026amp;\u0026amp; num % 6 != 5 { return false } // ä¸€ä¸ªæ•°èƒ½è¿›è¡Œå› å¼åˆ†è§£ï¼Œé‚£ä¹ˆåˆ†è§£æ—¶å¾—åˆ°çš„ä¸¤ä¸ªæ•° // ä¸€å®šæ˜¯ä¸€ä¸ªå°äºç­‰äº sqrt(n) å’Œ ä¸€ä¸ªå¤§äºç­‰äº sqrt(n) // æ•…éå†å¾ªç¯çš„æ¬¡æ•°å°±æ˜¯sqrt(n)å‘ä¸Šå–æ•´æ¬¡æ•° tmp := uint64(math.Ceil(math.Sqrt(float64(num)))) // ä¸6çš„å€æ•°ç›¸é‚»çš„æ•°ä¸ä¸€å®šæ˜¯å¤§äºç­‰äº5çš„è´¨æ•°(è´¨æ•°) var i uint64 = 5 // è¿™é‡Œiè¡¨ç¤ºç¬¬ä¸€ä¸ªç´ æ•°5 // è¿™é‡Œçš„i += 6åŒ…å«æ‰€æœ‰å½“å‰numå› å¼åˆ†è§£çš„æ‰€æœ‰å…¬å› å¼ï¼Œä¹Ÿå°±æ˜¯æ‰€æœ‰çš„ç´ æ•° for ; i \u0026lt;= tmp; i += 6 { // i å’Œ i + 2 æ˜¯6çš„å€æ•°å‰åä¸¤ä¸ªæ•°å­— // åˆ¤æ–­numæ˜¯å¦èƒ½å› å¼åˆ†è§£ï¼Œèƒ½è¿›è¡Œå› å¼åˆ†è§£åˆ™æ˜¯åˆæ•°ï¼Œå¦åˆ™æ˜¯ç´ æ•° if num % i == 0 || num % (i + 2) == 0 { return false } } return true } /* Output: 2 æ˜¯ç´ æ•° 3 æ˜¯ç´ æ•° 5 æ˜¯ç´ æ•° 7 æ˜¯ç´ æ•° 11 æ˜¯ç´ æ•° 13 æ˜¯ç´ æ•° 17 æ˜¯ç´ æ•° 19 æ˜¯ç´ æ•° 23 æ˜¯ç´ æ•° 29 æ˜¯ç´ æ•° 31 æ˜¯ç´ æ•° 37 æ˜¯ç´ æ•° 41 æ˜¯ç´ æ•° 43 æ˜¯ç´ æ•° 47 æ˜¯ç´ æ•° 53 æ˜¯ç´ æ•° 59 æ˜¯ç´ æ•° 61 æ˜¯ç´ æ•° 67 æ˜¯ç´ æ•° 71 æ˜¯ç´ æ•° 73 æ˜¯ç´ æ•° 79 æ˜¯ç´ æ•° 83 æ˜¯ç´ æ•° 89 æ˜¯ç´ æ•° 97 æ˜¯ç´ æ•° */ for-range ã€for - rangeã€‘ç»“æ„æ˜¯Goè¯­è¨€ç‰¹æœ‰çš„ä¸€ç§è¿­ä»£ç»“æ„ï¼Œå®ƒåœ¨è®¸å¤šæƒ…å†µä¸‹éƒ½éå¸¸æœ‰ç”¨ã€‚ å¯ä»¥è¿­ä»£ä»»ä½•ä¸€ä¸ªé›†åˆï¼Œä¹ŸåŒ…æ‹¬æ•°ç»„(array)å’Œå­—å…¸(map)å’Œå­—ç¬¦ä¸²(string)å’Œé€šé“(channel)å’Œåˆ‡ç‰‡(slice)ï¼ŒåŒæ—¶å¯ä»¥è·å¾—æ¯æ¬¡è¿­ä»£æ‰€å¯¹åº”çš„ç´¢å¼•å’Œå€¼ã€‚ 1 2 // ixï¼šç´¢å¼• valï¼šå€¼ for ix, val := range coll {} å¦‚æœåªéœ€è¦rangeé‡Œçš„ç´¢å¼•å€¼ï¼Œå¯ä»¥åªå†™keyçœç•¥valueã€‚ 1 for key := range coll {} valå€¼å§‹ç»ˆä¸ºé›†åˆä¸­å¯¹åº”ç´¢å¼•çš„å‰¯æœ¬ï¼Œå› æ­¤å®ƒä¸€èˆ¬åªå…·æœ‰åªè¯»æ€§è´¨ã€‚ å¯¹å®ƒæ‰€æœ‰çš„ä»»ä½•ä¿®æ”¹éƒ½ä¸ä¼šå½±å“åˆ°é›†åˆä¸­åŸæœ‰çš„å€¼ã€‚ å¦‚æœvalä¸ºæŒ‡é’ˆï¼Œåˆ™ä¼šäº§ç”ŸæŒ‡é’ˆçš„å‰¯æœ¬ï¼Œä¾æ—§å¯ä»¥ä¿®æ”¹é›†åˆä¸­çš„åŸå€¼ã€‚ rangeéå†çš„ä¹Ÿæ˜¯å‰¯æœ¬ã€‚ forå¾ªç¯çš„rangeæ ¼å¼å¯ä»¥å¯¹sliceã€mapã€arrayã€stringã€chanç­‰è¿›è¡Œè¿­ä»£å¾ªç¯ã€‚ Golangçš„rangeç±»ä¼¼è¿­ä»£å™¨æ“ä½œï¼Œè¿”å›ã€(ç´¢å¼•, å€¼) ã€‘æˆ–ã€(é”®, å€¼)ã€‘ã€‚ ç±»å‹ key value æè¿° string index æ˜¯ int ç±»å‹ s[index] æ˜¯ rune ç±»å‹ å­—ç¬¦ä¸² array/slice index æ˜¯ int ç±»å‹ s[index] æ˜¯å­˜å‚¨çš„å…ƒç´ ç±»å‹ æ•°ç»„/åˆ‡ç‰‡ map key m[key] æ˜¯mapå­˜å‚¨ç±»å‹ å­—å…¸ï¼Œéå†é¡ºåºæ˜¯éšæœºçš„ channel element æ˜¯chanå­˜å‚¨ç±»å‹ é€šé“ å¯ä»¥å¿½ç•¥ä¸æƒ³è¦çš„è¿”å›å€¼ï¼Œæˆ–ä½¿ç”¨_è¿™ä¸ªç‰¹æ®Šå˜é‡ã€‚æ³¨æ„_æ˜¯å†…ç½®å·²ç»å£°æ˜çš„ï¼Œå› æ­¤ä¸èƒ½ä½¿ç”¨è¿™ç§å½¢å¼_:=1ï¼Œä¸èƒ½ä½¿ç”¨:=åº”è¯¥ä½¿ç”¨=ã€‚ ä½¿ç”¨ç¤ºä¾‹ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 package main import \u0026#34;fmt\u0026#34; func main() { s := \u0026#34;abc\u0026#34; // range å˜é‡å­—ç¬¦ä¸²æ˜¯æŒ‰ç…§Unicodeéå†çš„ // 1) å¿½ç•¥ç¬¬äºŒä¸ªå‚æ•°, æ”¯æŒ string/array/slice/map for i := range s { // ã€int, runeã€‘ fmt.Printf(\u0026#34;%d %c\\n\u0026#34;, i, s[i]) } // Output: // 0 a // 1 b // 2 c // 2) å¿½ç•¥ ç¬¬ä¸€ä¸ªå‚æ•° for _, c := range s { // ã€int, runeã€‘ fmt.Println(c) } // Output: // 97 // 98 // 99 // 3) å¿½ç•¥å…¨éƒ¨è¿”å›å€¼ï¼Œä»…è¿­ä»£ n := 0 // sä¸ºå­—ç¬¦ä¸²æ—¶ï¼Œç»Ÿè®¡runeå­—ç¬¦æ•°é‡ for range s { // ã€int, runeã€‘ n++ } fmt.Println(n) m := map[string]int{\u0026#34;a\u0026#34;:1, \u0026#34;b\u0026#34;:2} // è¿”å› (key, value) // éå†mapï¼Œé¡ºåºæ˜¯éšæœºçš„ for k, v := range m { // ã€string, intã€‘ fmt.Println(k, v) } // Output: // b 2 // a 1 } for-rangeä¼šæ‹·è´éå†å¯¹è±¡ æ³¨æ„ä¸‹é¢çš„ä»£ç rangeå¤åˆ¶äº†aå¯¹è±¡æ•°æ®æ‰€ä»¥è¾“å‡ºç»“æœå’Œé¢„æœŸçš„ä¸åŒã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;unsafe\u0026#34; ) func main() { // æ•°ç»„å¸ƒå±€ å†…å­˜ä¸­è¿ç»­åˆ†é… // åœ°å€ 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25\tå­—èŠ‚B // |\u0026lt;---a[0]----\u0026gt;| |\u0026lt;-------a[1]------\u0026gt;| |\u0026lt;--------a[2]------\u0026gt;| a := [3]int{0, 1, 2} // æŸ¥çœ‹açš„å†…å­˜å ç”¨å¤§å° int åœ¨64ä½ç³»ç»Ÿä¸‹å 8å­—èŠ‚ 3*8 = 24å­—èŠ‚ fmt.Println(unsafe.Sizeof(a)) // 24 // indexã€value éƒ½æ˜¯ä»å¤åˆ¶å“ä¸­å–å‡º for i, v := range a { // ã€int, intã€‘ // åœ¨ä¿®æ”¹å‰ï¼Œæˆ‘ä»¬å…ˆä¿®æ”¹åŸæ•°ç»„ if i == 0 { a[1], a[2] = 999, 999 // ç¡®è®¤ä¿®æ”¹æœ‰æ•ˆï¼Œè¾“å‡º[0, 999, 999] fmt.Println(a) // [0 999 999] } // ä½¿ç”¨å¤åˆ¶å“ä¸­å–å‡ºçš„ value ä¿®æ”¹åŸæ•°ç»„ a[i] = v + 100 } // æ³¨æ„è¿™é‡Œçš„è¾“å‡º fmt.Println(a) // [100 101 102] // Output: // 24 // [0 999 999] // [100 101 102] } for-rangeéå†åˆ‡ç‰‡ æ”¹ç”¨å¼•ç”¨ç±»å‹ï¼Œå…¶åº•å±‚æ•°æ®ä¸ä¼šè¢«å¤åˆ¶ï¼Œæ³¨æ„ä¸‹é¢ä»£ç ã€‚ å¦å¤–ä¸¤ç§å¼•ç”¨ç±»å‹mapã€channelæ˜¯æŒ‡é’ˆåŒ…è£…ï¼Œè€Œä¸åƒsliceæ˜¯structã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 package main import \u0026#34;fmt\u0026#34; func main() { // å¸ƒå±€ type slice struct { pointer, len, cap } // slice pointer len cap // | 5 5 // v // array 0 1 2 3 4 5 ... // å‡è®¾ä»¥ä¸‹åˆ‡ç‰‡çš„ç»“æ„å¦‚ä¸‹struct {0x01f00, 5, 5} s := []int{1, 2, 3, 4, 5} // rangeéå†åˆ‡ç‰‡ï¼Œå¤åˆ¶ç»“æ„ä½“struct {0x01f00, 5, 5}ç”¨äºéå† // éå†æ—¶æŒ‡å‘pointeræŒ‡é’ˆç§»åŠ¨è·å–æ•°æ® for i, v := range s { // ã€int, intã€‘ if i == 0 { // ä¿®æ”¹sçš„åˆ‡ç‰‡ç»“æ„ä¸ºstruct {0x01f00, 3, 5}ï¼Œè€Œå¤åˆ¶çš„å‰¯æœ¬ä¸å˜struct {0x01f00, 5, 5} s = s[:3] // [low:high:max] len=high-lowã€cap=max-low // ä¿®æ”¹[0x01f00+2*8,0x01f00+3*8)åœ°å€ä½ç½®ä»3ä¿®æ”¹ä¸º100 s[2] = 100 } fmt.Println(i, v) } fmt.Println(s) // Output: // 0 1 // 1 2 // 2 100 // 3 4 // 4 5 // [1 2 100] } for-rangeéå†å­—ç¬¦ä¸² å­—ç¬¦ä¸²æ˜¯Unicodeç¼–ç çš„å­—ç¬¦é›†åˆä½¿ç”¨for-rangeç»“æ„è¿­ä»£å­—ç¬¦ä¸²ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 package main import ( \u0026#34;fmt\u0026#34; ) func main() { for pos, char := range \u0026#34;è¯­è¨€\\x80é›¨\u0026#34; { // ã€int, runeã€‘ fmt.Printf(\u0026#34;%d character %#U starts at byte position %d\\n\u0026#34;, char, char, pos) } // Output: // 35821 character U+8BED \u0026#39;è¯­\u0026#39; starts at byte position 0 // 35328 character U+8A00 \u0026#39;è¨€\u0026#39; starts at byte position 3 // 65533 character U+FFFD \u0026#39;ï¿½\u0026#39; starts at byte position 6 // 38632 character U+96E8 \u0026#39;é›¨\u0026#39; starts at byte position 7 } æ³¨æ„ éå†åˆ‡ç‰‡ï¼šä¸‹é¢ç¨‹åºä¸Šæœ‰æ²¡æœ‰å¯ä¼˜åŒ–çš„ç©ºé—´ï¼Ÿ 1 2 3 4 5 func rangeTest(slice []int) { for index, value := range slice { _, _ = index, value } } è§£æï¼šä½¿ç”¨ range éå†ï¼Œæ¯æ¬¡è¿­ä»£ä¼šå¯¹ index,value è¿›è¡Œèµ‹å€¼ï¼Œè‹¥æ•°æ®å¾ˆå¤§æˆ– value ç±»å‹ä¸º string æ—¶ï¼Œå¯¹ value çš„èµ‹å€¼æ“ä½œå¯ä»¥è¿›è¡Œä¼˜åŒ–ï¼Œå³å¿½ç•¥ value å€¼ï¼Œä½¿ç”¨ slice[index] æ¥è·å– value çš„å€¼ã€‚ è§£æï¼šä½¿ç”¨ range éå†ï¼Œæ¯æ¬¡è¿­ä»£ä¼šå¯¹ index,value è¿›è¡Œèµ‹å€¼ï¼Œè‹¥æ•°æ®å¾ˆå¤§æˆ– value ç±»å‹ä¸º string æ—¶ï¼Œå¯¹ value çš„èµ‹å€¼æ“ä½œå¯ä»¥è¿›è¡Œä¼˜åŒ–ï¼Œå³å¿½ç•¥ value å€¼ï¼Œä½¿ç”¨ slice[index] æ¥è·å– value çš„å€¼ã€‚ 1 2 3 4 5 func rangeTest(slice []int) { for index, _ := range slice { _, _ = index, slice[index] } } åŠ¨æ€éå†ï¼šä¸‹é¢ç¨‹åºä¸Šèƒ½å¦æ­£å¸¸ç»“æŸï¼Ÿ 1 2 3 4 5 6 7 8 9 func main() { v := []int{1,2,3} // æˆ‘ä»¬çŸ¥é“rangeéå†çš„æ˜¯vçš„å‰¯æœ¬ï¼Œä¹Ÿå°±æ˜¯ v1 := v éå†çš„æ˜¯v1 æ‰€ä»¥ä¸‹é¢åªä¼šå¾ªç¯3æ¬¡ for i := range v { v = append(v, i) } fmt.Println(v) // [1 2 3 0 1 2] // æœ€åå˜é‡å®Œ v = []int{1,2,3,0,1,2} } è§£æï¼šä¼šæ­£å¸¸ç»“æŸã€‚å¾ªç¯å†…å†æ”¹å˜åˆ‡ç‰‡çš„é•¿åº¦ï¼Œä¸å½±å“å¾ªç¯æ¬¡æ•°ï¼Œå¾ªç¯æ¬¡æ•°åœ¨å¾ªç¯å¼€å§‹å‰å°±å·²ç»æ˜¯ç¡®å®šäº†çš„ã€‚ éå†Mapï¼šä¸‹é¢ç¨‹åºä¸Šæœ‰æ²¡æœ‰å¯ä¼˜åŒ–çš„ç©ºé—´ï¼Ÿ 1 2 3 4 5 func rangeTest(mapTest map[int]string) { for key, _ := range mapTest { _, _ = key, mapTest[key] } } è§£æï¼šä½¿ç”¨ range éå†ï¼Œæ ¹æ®ç¬¬ä¸€é¢˜ç»éªŒï¼Œæˆ‘ä»¬æ ¹æ® key å€¼æ¥è·å–value çš„å€¼ï¼Œçœ‹ä¼¼å‡å°‘äº†ä¸€æ¬¡èµ‹å€¼ï¼Œä½†ä½¿ç”¨ mapTest[key] æ¥è·å– value å€¼çš„æ€§èƒ½æ¶ˆè€—å¯èƒ½é«˜äºèµ‹å€¼æ¶ˆè€—ã€‚èƒ½å¦ä¼˜åŒ–å–å†³äº map æ‰€å­˜å‚¨æ•°æ®ç»“æ„ç‰¹å¾ï¼Œåº”ç»“åˆå®é™…æƒ…å†µè¿›è¡Œã€‚ æˆ‘ä»¬çŸ¥é“mapTest[key]çš„å–å€¼æ˜¯ä¸€ä¸ªéå¸¸å¤æ‚çš„å‡½æ•°è°ƒç”¨ï¼ŒmapTest[key]çš„ä½¿ç”¨åè€Œä¼šå¢åŠ è´Ÿæ‹…ã€‚ å‚è€ƒ range å®ç°åŸç† ","permalink":"https://heliu.site/posts/golang/process/for/","summary":"Golang forå¾ªç¯ä»‹ç»ã€‚","title":"æµç¨‹æ§åˆ¶(å¾ªç¯è¯­å¥)"},{"content":"è¿­ä»£string rangeè¿­ä»£stringï¼Œkeyä¸ºintç±»å‹ï¼Œvalueä¸ºruneç±»å‹ã€‚ 1 2 3 4 5 str := \u0026#34;hello world! Gopher\u0026#34; for i, v := range str { // ã€int, runeã€‘ fmt.Println(i, v) // original body } ä¸Šé¢è¿­ä»£å­—ç¬¦ä¸²ä»£ç ç­‰æ•ˆäºä¸‹é¢ä»£ç ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 // 1) è·å–å­—ç¬¦ä¸²é•¿åº¦ // å­—ç¬¦ä¸²æ€»é•¿åº¦ï¼Œè¯¥é•¿åº¦æ˜¯å­—èŠ‚æ•°é‡ç”¨äºéå†å­—ç¬¦ä¸²çš„æ€»é•¿åº¦ lenTemp := len(str) // ä¸‹ä¸€æ¬¡éå†çš„ä¸‹æ ‡ä½ç½®ï¼Œè¿™æ˜¯ç”±äºutf8æ˜¯ä¸å®šé•¿ç¼–ç éœ€è¦è®°å½•ä¸Šä¸€æ¬¡å¤„ç†åçš„ä½ç½® var nextIndexTemp int\t// 2) key/value // æ³¨æ„ï¼šè¿™é‡Œçš„keyå’Œvalueï¼Œå®šä¹‰åœ¨forå¤–ï¼Œä¹Ÿæ˜¯\u0026amp;iå’Œ\u0026amp;væ˜¯å›ºå®šçš„åŸå›  var i int // éå†ç”¨åˆ°çš„ç´¢å¼•ï¼Œä¹Ÿå°±æ˜¯index var v rune // éå†å‡ºæ¥å­˜å‚¨çš„å€¼ï¼Œä¹Ÿå°±æ˜¯value // éå†å­—ç¬¦ä¸² for indexTemp := 0; indexTemp \u0026lt; lenTemp; indexTemp = nextIndexTemp { // è·å–å¼€å¤´8bitçš„å¤§å°ï¼Œå› ä¸ºè¯¥8bitèƒ½åŒºåˆ†å­˜å‚¨çš„æ˜¯ASCII 1bitè¿˜æ˜¯å¤šä¸ªä½¿ç”¨utf8ç¼–ç çš„å­—èŠ‚ valueTemp := rune(str[indexTemp])\t// utf8.RuneSelf = 0x80 = 128 å•å­—ç¬¦æœ€å¤§å€¼ // ASCIIç å­—ç¬¦å 1å­—èŠ‚ï¼Œè¯¥æ¡ä»¶æ»¡è¶³è¯´æ˜ï¼Œå­˜å‚¨çš„æ˜¯ASCIIç å ç”¨ä¸€ä¸ªå­—èŠ‚ if valueTemp \u0026lt; utf8.RuneSelf {\tnextIndexTemp = indexTemp + 1 } else { // è¯¥æ¡ä»¶æ»¡è¶³è¯´æ˜æ˜¯ä½¿ç”¨utf8ç¼–ç çš„å¤šä¸ªå­—èŠ‚å ç”¨ï¼Œ // ä½¿ç”¨decoderuneè·å–è¯¥Unicodeå€¼å’Œåœ¨Utf8ä¸­ç¼–ç å ç”¨çš„å­—èŠ‚å¤§å°æ•°ç›® // decoderuneè§£ç å­—ç¬¦ä¸²strä»indexTempä½ç½®å¼€å§‹ï¼Œå…·ä½“æ–¹æ³•åœ¨runtime/utf8.goæ–‡ä»¶ä¸­ // è¯¥å‡½æ•°ä¸utf8ç¼–ç ç›¸å…³ // valueTempè§£æçš„runeï¼ŒnextIndexTempå½“å‰çš„indexTemp+è§£æçš„runeçš„é•¿åº¦ valueTemp, nextIndexTemp = decoderune(str, indexTemp)\t} // 3) æ‹·è´èµ‹å€¼ // æ³¨æ„ï¼šè¿™é‡Œå°±æ˜¯ä¸ºä»€ä¹ˆfor rangeä¸­å–\u0026amp;iå’Œ\u0026amp;våœ°å€æ˜¯å›ºå®šçš„åŸå›  i = indexTemp // å½“å‰è·å–åˆ°çš„ç´¢å¼• v = valueTemp // å½“å‰è·å–åˆ°çš„å­—ç¬¦ fmt.Println(i, v) // original body } decoderune()ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 // runtime/utf8.go æ–‡ä»¶ä¸­decoderuneæ–¹æ³• // decoderune returns the non-ASCII rune at the start of // s[k:] and the index after the rune in s. // // decoderune assumes that caller has checked that // the to be decoded rune is a non-ASCII rune. // // If the string appears to be incomplete or decoding problems // are encountered (runeerror, k + 1) is returned to ensure // progress when decoderune is used to iterate over a string. func decoderune(s string, k int) (r rune, pos int) { pos = k // è§£æå¼€å§‹ä½ç½® if k \u0026gt;= len(s) { // å·²ç»åˆ°å­—ç¬¦ä¸²çš„æœ€å¤§é•¿åº¦äº† return runeError, k + 1 } s = s[k:] // ä»kä½ç½®åˆ†å‰²å­—ç¬¦ä¸² switch { // [t2, t3) --\u0026gt; [11000000, 11100000) case t2 \u0026lt;= s[0] \u0026amp;\u0026amp; s[0] \u0026lt; t3: // è¯¥å­—æ®µ2å­—èŠ‚ç¼–ç  // 0080-07FF two byte sequence // [locb, hicb] æ˜¯ç¬¬äºŒä¸ªå­—èŠ‚çš„èŒƒå›´å¤§å° [10000000, 10111111] if len(s) \u0026gt; 1 \u0026amp;\u0026amp; (locb \u0026lt;= s[1] \u0026amp;\u0026amp; s[1] \u0026lt;= hicb) { // ä»ç¼–ç ä¸­å–å‡ºç¼–ç çš„æ•°æ®ç»„æˆrune // mask2 = 00011111ï¼Œmaskx = 00111111 r = rune(s[0]\u0026amp;mask2)\u0026lt;\u0026lt;6 | rune(s[1]\u0026amp;maskx) pos += 2 if rune1Max \u0026lt; r { return } } // [t3, t4) --\u0026gt; [11100000, 11110000) case t3 \u0026lt;= s[0] \u0026amp;\u0026amp; s[0] \u0026lt; t4: // è¯¥å­—æ®µ3å­—èŠ‚ç¼–ç  // 0800-FFFF three byte sequence if len(s) \u0026gt; 2 \u0026amp;\u0026amp; (locb \u0026lt;= s[1] \u0026amp;\u0026amp; s[1] \u0026lt;= hicb) \u0026amp;\u0026amp; (locb \u0026lt;= s[2] \u0026amp;\u0026amp; s[2] \u0026lt;= hicb) { r = rune(s[0]\u0026amp;mask3)\u0026lt;\u0026lt;12 | rune(s[1]\u0026amp;maskx)\u0026lt;\u0026lt;6 | rune(s[2]\u0026amp;maskx) pos += 3 if rune2Max \u0026lt; r \u0026amp;\u0026amp; !(surrogateMin \u0026lt;= r \u0026amp;\u0026amp; r \u0026lt;= surrogateMax) { return } } // [t4, t5) --\u0026gt; [11110000, 11111000) case t4 \u0026lt;= s[0] \u0026amp;\u0026amp; s[0] \u0026lt; t5: // è¯¥å­—æ®µ4å­—èŠ‚ç¼–ç  // 10000-1FFFFF four byte sequence if len(s) \u0026gt; 3 \u0026amp;\u0026amp; (locb \u0026lt;= s[1] \u0026amp;\u0026amp; s[1] \u0026lt;= hicb) \u0026amp;\u0026amp; (locb \u0026lt;= s[2] \u0026amp;\u0026amp; s[2] \u0026lt;= hicb) \u0026amp;\u0026amp; (locb \u0026lt;= s[3] \u0026amp;\u0026amp; s[3] \u0026lt;= hicb) { r = rune(s[0]\u0026amp;mask4)\u0026lt;\u0026lt;18 | rune(s[1]\u0026amp;maskx)\u0026lt;\u0026lt;12 | rune(s[2]\u0026amp;maskx)\u0026lt;\u0026lt;6 | rune(s[3]\u0026amp;maskx) pos += 4 if rune3Max \u0026lt; r \u0026amp;\u0026amp; r \u0026lt;= maxRune { return } } } return runeError, k + 1 } for-rangeä¸èƒ½éå†*stringç±»å‹ã€‚ for-rangeå¯¹äºå­—ç¬¦ä¸²å¹¶æ²¡æœ‰å¤åˆ¶ä¸€ä»½å­—ç¬¦ä¸²è¿›è¡Œç¼–ç ï¼Œå…¶å®ä¹Ÿä¸å¿…è¦å› ä¸ºå­—ç¬¦ä¸²çš„è¯­ä¹‰æœ¬æ¥å°±æ˜¯ä¸å¯å˜æ•°æ®ã€‚ è¿­ä»£array rangeè¿­ä»£arrayï¼Œkeyä¸ºintç±»å‹ï¼Œvalueä¸ºæ•°ç»„çš„å…ƒç´ ç±»å‹ã€‚ 1 2 3 4 5 arr := [5]int{0,1,2,3,4} for i, v := range arr { // ã€int, intã€‘ fmt.Println(i, v) // original body } ä¸Šé¢è¿­ä»£æ•°ç»„ä»£ç ç­‰æ•ˆäºä¸‹é¢ä»£ç ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 // 1) è·å–æ•°ç»„é•¿åº¦ // æ³¨æ„ï¼šè¿™é‡Œæ”¯æŒæŒ‡é’ˆæ•°ç»„ï¼Œæ¯”å¦‚len(*[2]int) == 2 lenTemp := len(arr) // 2) æ‹·è´æ•°ç»„ // æ³¨æ„ï¼šè¿™é‡Œæ”¯æŒæŒ‡é’ˆæ•°ç»„ï¼Œæ¯”å¦‚arræ˜¯*[2]int // è¿™é‡Œä¹Ÿå°±æ˜¯ä¸ºä»€ä¹ˆä½¿ç”¨æ•°ç»„æŒ‡é’ˆå’Œæ•°ç»„æœ¬èº«çš„æ€§èƒ½å·®å¼‚ï¼Œ // ä½¿ç”¨æ•°ç»„æŒ‡é’ˆè¿™é‡Œçš„èµ‹å€¼æ˜¯æŒ‡é’ˆèµ‹å€¼ï¼Œè€Œä½¿ç”¨æ•°ç»„è¿™é‡Œæ˜¯å€¼å¤åˆ¶å½“æ•°æ®é‡å¤§æ—¶æ€§èƒ½å·®åˆ«è¿˜æ˜¯æ¯”è¾ƒæ˜æ˜¾ rangeArr := arr // å¤åˆ¶ä¸€ä»½éœ€è¦éå†çš„æ•°ç»„ï¼Œæ³¨æ„è¿™é‡Œçš„å‰¯æœ¬æ˜¯ä¸åŸæ•°ç»„æ²¡æœ‰ä»»ä½•è”ç³» // 3) key/value // æ³¨æ„ï¼šè¿™é‡Œçš„keyå’Œvalueï¼Œå®šä¹‰åœ¨forå¤–ï¼Œä¹Ÿæ˜¯\u0026amp;iå’Œ\u0026amp;væ˜¯å›ºå®šçš„åŸå›  var i, v int // å®šä¹‰éå†éœ€è¦æ¥æ”¶çš„keyå’Œvalueå˜é‡ // for rangeçš„ç¼–è¯‘ç­‰åŒä»£ç  for indexTemp := 0; indexTemp \u0026lt; lenTemp; indexTemp++ { // æ³¨æ„ï¼šè¿™é‡Œæ”¯æŒæŒ‡é’ˆæ•°ç»„èµ‹å€¼ valueTemp := rangeArr[indexTemp] // æ•°ç»„æ”¯æŒè¯­æ³•ç³– // 4) æ‹·è´èµ‹å€¼ // æ³¨æ„ï¼šè¿™é‡Œå°±æ˜¯ä¸ºä»€ä¹ˆfor rangeä¸­å–\u0026amp;iå’Œ\u0026amp;våœ°å€æ˜¯å›ºå®šçš„åŸå›  i = indexTemp // æ‹·è´èµ‹å€¼ v = valueTemp // æ‹·è´èµ‹å€¼ fmt.Println(i, v) // original body } æ•°ç»„éå†å’Œåˆ‡ç‰‡éå†æœ€ä¸»è¦çš„åŒºåˆ«å°±æ˜¯éå†å‰¯æœ¬ï¼Œæ•°ç»„çš„å‰¯æœ¬ä¸åŸæ•°ç»„æ²¡æœ‰ä»»ä½•å…³è”åªæ˜¯å€¼å…¨éƒ¨ç›¸åŒè€Œå·²ï¼Œè€Œåˆ‡ç‰‡åˆ™æ˜¯å‰¯æœ¬å’ŒåŸåˆ‡ç‰‡æ•°å…±ç”¨åŒä¸€ä¸ªåº•å±‚æ•°ç»„ã€‚ rangeèƒ½éå†ã€æ•°ç»„æŒ‡é’ˆã€‘è€Œã€ä¸èƒ½ã€‘éå†åˆ‡ç‰‡æŒ‡é’ˆï¼Œè¿™å¾—ç›Šäºæ•°å€¼æŒ‡é’ˆåœ¨èµ‹å€¼å’Œlen()å‡½æ•°ä¸ŠGoæ”¯æŒçš„ã€è¯­æ³•ç³–ã€‘è½¬æ¢ä½¿å¾—rangeå¯¹æ•°ç»„æŒ‡é’ˆåŒæ ·é€‚ç”¨ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 // rangeéå†æŒ‡é’ˆæ•°ç»„æ—¶ï¼Œä¼šè§£å¼•ç”¨æ•°ç»„æŒ‡é’ˆæ‹·è´å‰¯æœ¬éå† package main import \u0026#34;fmt\u0026#34; func main() { var aa *[2]string = new([2]string) // 1) è¯­æ³•ç³–1ï¼šèµ‹å€¼ //(*aa)[0] = \u0026#34;a\u0026#34; aa[0] = \u0026#34;a\u0026#34; // è¯­æ³•ç³– //(*aa)[1] = \u0026#34;bb\u0026#34; aa[1] = \u0026#34;bb\u0026#34;// è¯­æ³•ç³– // 2) è¯­æ³•ç³–2ï¼šå–å€¼ // c := (*aa)[1] c := aa[1] // è¯­æ³•ç³– // 3) è¯­æ³•ç³–3ï¼šæ±‚é•¿åº¦ // l := len(aa) // len(*aa) // åœ¨Goä¸­æ”¯æŒæ•°ç»„çš„æŒ‡é’ˆç›¸å…³çš„è¯­æ³•ç³–ï¼Œæ‰€ä»¥å¯¼è‡´ä½¿ç”¨æ•°ç»„å’Œæ•°ç»„æŒ‡é’ˆå¥½åƒå¹¶æ²¡æœ‰å¤šå¤§çš„åŒºåˆ« // æ¯”å¦‚æ•°ç»„æŒ‡é’ˆaaèƒ½ä½¿ç”¨aa[0] = \u0026#34;a\u0026#34;è¿™ç§å½¢å¼èµ‹å€¼ï¼Œä¹Ÿèƒ½ä½¿ç”¨len(aa)è¿™ç§å½¢å¼æ±‚é•¿åº¦ï¼Œ // å…¶ä»–ç±»å‹çš„æŒ‡é’ˆåˆ™ä¸æ”¯æŒ // è¿™äº›è¯­æ³•ç³–ä¹Ÿå¯¼è‡´äº†èƒ½ä½¿ç”¨rangeéå†æ•°ç»„æŒ‡é’ˆ // range æ‹·è´ *aa å‰¯æœ¬éå† for i, s := range aa { // å½“æ•°ç»„å¾ˆå¤§æ—¶ï¼Œéå†æ•°ç»„æŒ‡é’ˆæ˜¯ä¸€ä¸ªä¸é”™çš„é€‰æ‹© if i == 0 { aa[1] = \u0026#34;cc\u0026#34; } fmt.Println(i, s) } fmt.Println(aa) // Output: // 0 a // 1 cc // \u0026amp;[a cc] } éªŒè¯æ•°ç»„éå†æ˜¯å€¼æ‹·è´ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 {\tslice1 := [4]int{0,1,2,3} // è¿™é‡Œæ‹·è´çš„æ˜¯æ•°ç»„çš„å‰¯æœ¬ï¼Œå› æ­¤ifæ¡ä»¶æˆç«‹ä¸ä¼šå½±å“å€¼ for i, v := range slice1 { // [4]int if i == 1 { slice1[3] += 10 } fmt.Println(i, v) } fmt.Println(slice1) // Output: // 0 0 // 1 1 // 2 2 // 3 3 // [0 1 2 13] } { slice1 := [4]int{0,1,2,3} // è¿™é‡Œæ‹·è´çš„æ˜¯æ•°ç»„çš„æŒ‡é’ˆï¼Œå› æ­¤ifæ¡ä»¶æˆç«‹ä¼šå½±å“å€¼ for i, v := range \u0026amp;slice1 { // *[4]int if i == 1 { slice1[3] += 10 } fmt.Println(i, v) } // Output: // 0 0 // 1 1 // 2 2 // 3 13 } è¿­ä»£slice éå†sliceå‰ä¼šå…ˆè·å–sliceçš„é•¿åº¦lenTempæ¥ä½œä¸ºå¾ªç¯æ¬¡æ•°ï¼Œå¾ªç¯ä½“ä¸­ï¼Œæ¯æ¬¡å¾ªç¯ä¼šå…ˆè·å–å…ƒç´ å€¼ã€‚ å¦‚æœfor-rangeä¸­æ¥æ”¶indexå’Œvalueçš„è¯ï¼Œåˆ™ä¼šå¯¹indexå’Œvalueè¿›è¡Œä¸€æ¬¡èµ‹å€¼ã€‚ æ•°ç»„ä¸æ•°ç»„æŒ‡é’ˆçš„éå†è¿‡ç¨‹ä¸sliceåŸºæœ¬ä¸€è‡´ï¼Œä½†æ˜¯ä¹Ÿæœ‰åŒºåˆ«ï¼ŒåŒºåˆ«åœ¨äºå‰¯æœ¬å¤åˆ¶çš„æ˜¯ä¸åŸæ•°ç»„æ˜¯ä¸€ä¸ªå®Œå…¨ä¸ç›¸å¹²çš„æ•°ç»„ã€‚ for-rangeè¿­ä»£sliceï¼Œkeyä¸ºintï¼Œvalueä¸ºå­˜å‚¨çš„å…ƒç´ ç±»å‹ã€‚ 1 2 3 4 5 slice1 := []int{0,1,2,3} for i, v := range slice1 { // ã€int, intã€‘ fmt.Println(i, v) // original body } ä¸Šé¢è¿­ä»£åˆ‡ç‰‡ä»£ç ç­‰æ•ˆäºä¸‹é¢ä»£ç ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 // 1) æ‹·è´åˆ‡ç‰‡ // æ³¨æ„ï¼šæ‹·è´çš„åˆ‡ç‰‡ä¸åŸåˆ‡ç‰‡å…±ç”¨äº†åŒä¸€ä¸ªåº•å±‚æ•°ç»„ // ä¹Ÿéœ€è¦æ³¨æ„ï¼Œlenå’Œcapä¹Ÿæ‹·è´å…ƒåˆ‡ç‰‡çš„å€¼ï¼Œå› æ­¤for rangeä¿®æ”¹ä¸èµ·ä½œç”¨ï¼Œ rangeSlice := slice1 // 2) è·å–åˆ‡ç‰‡é•¿åº¦ï¼Œä¹Ÿæ˜¯éå†çš„æ¬¡æ•° // éå†çš„æ­¤æ—¶åˆ‡ç‰‡é•¿åº¦æ˜¯å›ºå®šçš„ lenTemp := len(rangeSlice) // æ‹¿åˆ°éœ€è¦éå†çš„åˆ‡ç‰‡æ€»é•¿åº¦ // 3) key/value // æ³¨æ„ï¼šè¿™é‡Œçš„keyå’Œvalueï¼Œå®šä¹‰åœ¨forå¤–ï¼Œä¹Ÿæ˜¯\u0026amp;iå’Œ\u0026amp;væ˜¯å›ºå®šçš„åŸå›  var i, v int // å®šä¹‰éå†éœ€è¦çš„keyå’Œvalueå˜é‡ // for rangeçš„ç¼–è¯‘ç­‰åŒä»£ç  for indexTemp := 0; indexTemp \u0026lt; lenTemp; indexTemp++ { valueTemp := rangeSlice[indexTemp] // 4) æ‹·è´èµ‹å€¼ // æ³¨æ„ï¼šè¿™é‡Œå°±æ˜¯ä¸ºä»€ä¹ˆfor rangeä¸­å–\u0026amp;iå’Œ\u0026amp;våœ°å€æ˜¯å›ºå®šçš„åŸå›  i = indexTemp v = valueTemp fmt.Println(i, v) // original body } ç”±äºå¾ªç¯å¼€å§‹å‰å¾ªç¯æ¬¡æ•°å°±å·²ç»ç¡®å®šäº†ï¼Œæ‰€ä»¥å¾ªç¯è¿‡ç¨‹ä¸­æ–°æ·»åŠ çš„å…ƒç´ æ˜¯æ— æ³•éå†åˆ°çš„ã€‚ ä½†æ˜¯å¾ªç¯è¿‡ç¨‹ä¸­ä¿®æ”¹åé¢è¿˜æœªå¾ªç¯çš„å€¼ï¼Œåˆ™ä¼šå½±å“ï¼Œè¿™æ˜¯ç”±äºåœ¨rangeå¾ªç¯å‰èµ‹å€¼çš„å‰¯æœ¬ä¸åŸåˆ‡ç‰‡å…±ç”¨äº†ä¸€ä¸ªåº•å±‚æ•°ç»„å¯¼è‡´çš„ï¼Œæ‰€ä»¥èƒ½ç›¸äº’å½±å“ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 { slice1 := []int{0,1,2,3} for i, v := range slice1 { // ã€int, intã€‘ if i == 1 { slice1[3] += 10 } fmt.Println(i, v) } // Output: // 0 0 // 1 1 // 2 2 // 3 13 } è¿­ä»£channel channeléå†æ˜¯ä¾æ¬¡ä»channelä¸­è¯»å–æ•°æ®ï¼Œè¯»å–å‰æ˜¯ä¸çŸ¥é“é‡Œé¢æœ‰å¤šå°‘ä¸ªå…ƒç´ çš„ã€‚ å¦‚æœchannelä¸­æ²¡æœ‰å…ƒç´ ï¼Œåˆ™ä¼šé˜»å¡ç­‰å¾…ï¼Œå¦‚æœchannelå·²è¢«å…³é—­ï¼Œåˆ™ä¼šè§£é™¤é˜»å¡å¹¶é€€å‡ºå¾ªç¯ã€‚ for-rangeè¿­ä»£channelï¼Œåªèƒ½è·å–ä¸€ä¸ªå€¼ï¼Œkeyä¸ºchannelå­˜å‚¨çš„å…ƒç´ ç±»å‹ã€‚ 1 2 3 4 5 6 c := make(chan int) // rangeéå†chan for v := range c { // ã€intã€‘ fmt.Println(v) // original body } ä¸Šé¢è¿­ä»£channelä»£ç ç­‰æ•ˆäºä¸‹é¢ä»£ç ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // è¿™é‡Œæ˜¯\u0026amp;vä¸ºä»€ä¹ˆéƒ½æ˜¯åŒä¸€ä¸ªåœ°å€çš„åŸå›  var v int // vå…¶å®å°±æ˜¯å›ºå®šçš„ä¸€ä¸ªå˜é‡ for { // æ³¨æ„å¦‚æœä¸å…³é—­channelè¿™é‡Œä¼šä¸€ç›´é˜»å¡ // æˆ‘ä»¬çŸ¥é“ \u0026lt;- ç¬¦å·ä¼šè°ƒç”¨ç›¸å…³çš„å‡½æ•°ï¼Œå¦‚æœchanå…³é—­äº†ä¼šè¿”å›falseé€€å‡ºå¾ªç¯ value_temp, ok := \u0026lt;- c\t// æœ‰æ•°æ®åˆ™ä¼šç›´æ¥è¿”å›æ•°æ®ï¼Œæ²¡æœ‰æ•°æ®åˆ™ä¼šé˜»å¡ï¼Œé€šè¿‡chançš„å­¦ä¹ çŸ¥é“é˜»å¡æ„å‘³ç€ // å½“å‰goroutineè¢«è°ƒç¦»è°ƒåº¦å¾ªç¯ç­‰å¾…æ•°æ®åˆ°æ¥è¢«é‡æ–°è°ƒèµ· // ok = falseï¼Œé€šé“å·²ç»å…³é—­ã€‚ if !ok { break } // 2) æ‹·è´å€¼ v = value_temp fmt.Println(v) // original body } ç¼–è¯‘åçš„ä¼ªä»£ç ï¼Œä¸ä¸Šé¢ç­‰ä»·ã€‚å…³äºchanrecv2()åœ¨channelä¸­ä»‹ç»ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 var v int for { ok := chanrecv2(c, \u0026amp;value_temp) if !ok { break } v = index_temp fmt.Println(v) // original body } æ³¨æ„ï¼š ä½¿ç”¨for-rangeéå†channelæ—¶åªèƒ½è·å–ä¸€ä¸ªè¿”å›å€¼ã€‚ ã€for-range \u0026lt;-chã€‘æƒ…å†µï¼Œè¯¥æƒ…å†µå¯ä»¥ç”¨åœ¨ ã€channel mapã€channel array|*arrayã€channel sliceã€channel stringã€‘ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 func chanTs2() { ch := make(chan map[int]int) // æ³¨æ„ï¼šè¿™é‡Œæ˜¯ \u0026lt;-chï¼Œå‰é¢çš„æ˜¯ ch for k, v := range \u0026lt;-ch { println(k, v) } // --------------------------- // as ç­‰ä»·äºä¸‹é¢ä»£ç  // --------------------------- // æ³¨æ„ï¼šè¿™é‡Œåªä¼šæ‰§è¡Œä¸€æ¬¡ a := \u0026lt;-ch for k, v := range a { println(k, v) } } è¿­ä»£map for-rangeè¿­ä»£mapï¼Œkeyä¸ºmapçš„é”®ï¼Œvalueä¸ºmapçš„å€¼ã€‚ 1 2 3 4 5 map1 := map[string]string{\u0026#34;one\u0026#34;:\u0026#34;1\u0026#34;, \u0026#34;tow\u0026#34;:\u0026#34;2\u0026#34;} for i, v := range map1 { // ã€string, stringã€‘ fmt.Println(i, v) // original body } ä¸Šé¢è¿­ä»£mapä»£ç ç­‰æ•ˆäºä¸‹é¢ä»£ç ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 // 1) key/value // è¿™é‡Œä¹Ÿæ˜¯ä¸ºä»€ä¹ˆ\u0026amp;iå’Œ\u0026amp;væ˜¯ä¸€ä¸ªå›ºå®šçš„åœ°å€çš„åŸå›  // å®šä¹‰éå†æ‰€éœ€è¦çš„keyå’Œvalueå˜é‡ var i, v string // 2) map_iteration_struct // map_iteration_structæ˜¯ä¸€ä¸ªhiterç»“æ„ä½“ï¼Œå­˜å‚¨ç€mapçš„éå†ç›¸å…³ä¿¡æ¯ var hiter map_iteration_struct\t// mapiterinit åˆå§‹åŒ–mapå‚çœ‹runtime/map.goæ–‡ä»¶ // hiteræ˜¯ä¸€ä¸ªå“ˆå¸Œè¿­ä»£ç»“æ„ï¼Œmapiternextè¿­ä»£ä¸‹ä¸€ä¸ªå“ˆå¸Œ for mapiterinit(type, range, \u0026amp;hiter); hiter.key != nil; mapiternext(\u0026amp;hiter) { index_temp := *hiter.key value_temp := *hiter.val // 3) æ‹·è´æ•°æ® i = index_temp v = value_temp fmt.Println(i, v) // original body } éå†mapæ—¶æ²¡æœ‰æŒ‡å®šå¾ªç¯æ¬¡æ•°ï¼Œå¾ªç¯ä½“ä¸éå†sliceç±»ä¼¼ã€‚ç”±äºmapåº•å±‚å®ç°ä¸sliceä¸åŒï¼Œmapåº•å±‚ä½¿ç”¨ hashè¡¨å®ç°çš„ã€‚ æ’å…¥æ•°æ®ä½ç½®æ˜¯éšæœºçš„ï¼Œæ‰€ä»¥éå†è¿‡ç¨‹ä¸­æ–°æ’å…¥çš„æ•°æ®ä¸èƒ½ä¿è¯éå†åˆ°ã€‚ ä»¥ä¸‹ç›¸å…³çš„å‡½æ•°åœ¨mapç¯‡ä¸­è¿˜ä¼šè¯¦ç»†çš„è®¨è®ºã€‚ type hiter structã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 // A hash iteration structure. // If you modify hiter, also change cmd/compile/internal/reflectdata/reflect.go // and reflect/value.go to match the layout of this structure. type hiter struct { // å½“å‰éå†çš„keyåœ°å€ key unsafe.Pointer // Must be in first position. Write nil to indicate iteration end (see cmd/compile/internal/walk/range.go). // å½“å‰éå†çš„elemåœ°å€ elem unsafe.Pointer // Must be in second position (see cmd/compile/internal/walk/range.go). // å½“å‰mapçš„ç±»å‹ç»“æ„ t *maptype // å½“å‰mapçš„å†…å­˜ç»“æ„ h *hmap\t// å½“å‰mapçš„å¸¸è§„æ¡¶åœ°å€ buckets unsafe.Pointer // bucket ptr at hash_iter initialization time // å½“å‰æ­£åœ¨éå†çš„æ¡¶ bptr *bmap // current bucket å½“å‰å­˜å‚¨æ¡¶ // h.extra.overflow overflow *[]*bmap // keeps overflow buckets of hmap.buckets alive\t// h.extra.oldoverflow oldoverflow *[]*bmap // keeps overflow buckets of hmap.oldbuckets alive // å¼€å§‹éå†çš„æ¡¶å·ï¼Œéšæœºçš„ï¼Œç”¨äºå¼€å§‹éå†çš„èµ·ç‚¹ä»¥åŠç»“æŸéå†çš„ç»ˆç‚¹ startBucket uintptr // bucket iteration started at // tophashåç§»å€¼ï¼Œåœ¨[0,7]ä¸­éšæœºç”Ÿæˆçš„å€¼ï¼Œç”¨äºåç»­ i + offset \u0026amp; 7 ç”¨ä½œåç§»é‡ offset uint8 // intra-bucket offset to start from during iteration (should be big enough to hold bucketCnt-1) // å½“å‰éå†å·²è¿‡æœ€å¤§æ¡¶(1 \u0026lt;\u0026lt; B)æ—¶è¢«è®¾ç½®ä¸ºtrue wrapped bool // already wrapped around from end of bucket array to beginning // åˆå§‹åŒ–æ—¶æ¡¶çš„æ•°é‡ 1 \u0026lt;\u0026lt; B B uint8 // å½“å‰æ¡¶éå†çš„ç´¢å¼•ï¼Œé»˜è®¤å€¼ä»0å¼€å§‹ï¼Œè¯¥å€¼é…åˆoffsetéå†tophashï¼Œi + offset \u0026amp; 7 i uint8 // åˆå§‹åŒ–æ—¶æ˜¯startBucketçš„å€¼ // 1. bptr == nilæ—¶bucketå­˜å‚¨éœ€è¦éå†çš„æ¡¶å· // 2. bptr != nilæ—¶bucketä¸‹ä¸ªæ¡¶çš„æ¡¶å· bucket uintptr // å­˜å‚¨çš„æ˜¯å½“å‰è¿­ä»£å™¨çš„æ¡¶å· // noCheck.ä¸éœ€è¦æ£€æŸ¥ï¼Œæ•°æ®åœ¨bptræ¡¶é‡Œé¢ // å…¶ä»–éœ€è¦æ£€æŸ¥ checkBucket uintptr // éœ€è¦æ£€æŸ¥çš„æ¡¶å· } mapiterinit()ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 // mapiterinit initializes the hiter struct used for ranging over maps. // The hiter struct pointed to by \u0026#39;it\u0026#39; is allocated on the stack // by the compilers order pass or on the heap by reflect_mapiterinit. // Both need to have zeroed hiter since the struct contains pointers. // mapiterinit åˆå§‹åŒ–ç”¨äºåœ¨mapä¸Šçš„ hiter ç»“æ„ // \u0026#39;it\u0026#39; æŒ‡å‘çš„ hiter ç»“æ„ç”±ç¼–è¯‘å™¨é¡ºåºä¼ é€’åœ¨å †æ ˆä¸Šåˆ†é…ï¼Œæˆ–è€…ç”± reflect_mapiterinit åœ¨å †ä¸Šåˆ†é…ã€‚ // ç”±äºç»“æ„åŒ…å«æŒ‡é’ˆï¼Œå› æ­¤ä¸¤è€…éƒ½éœ€è¦å°† hiter å½’é›¶ã€‚ // // è¿­ä»£åˆå§‹åŒ– // t *maptypeï¼šå½“å‰mapçš„å…ƒç´ ç±»å‹ // h *hmapï¼šå½“å‰mapçš„å†…å­˜ç»“æ„ // it *hiterï¼šè¿­ä»£å™¨ç»“æ„ func mapiterinit(t *maptype, h *hmap, it *hiter) { if raceenabled \u0026amp;\u0026amp; h != nil { callerpc := getcallerpc() racereadpc(unsafe.Pointer(h), callerpc, abi.FuncPCABIInternal(mapiterinit)) } it.t = t // å­˜å‚¨å½“å‰mapçš„ç±»å‹ç»“æ„åœ°å€ if h == nil || h.count == 0 { // å¦‚æœå½“å‰mapä¸ºç©ºç›´æ¥è¿”å› return } if unsafe.Sizeof(hiter{})/goarch.PtrSize != 12 { // åˆ¤æ–­hiterç»“æ„æ˜¯å¦æ­£ç¡® throw(\u0026#34;hash_iter size incorrect\u0026#34;) // see cmd/compile/internal/reflectdata/reflect.go } it.h = h // å­˜å‚¨å½“å‰mapçš„å†…å­˜ç»“æ„åœ°å€ // grab snapshot of bucket state it.B = h.B // è®°å½•å½“å‰mapçš„æ¡¶æ•°é‡ it.buckets = h.buckets // è®°å½•å½“å‰mapçš„å¸¸è§„æ¡¶åœ°å€ if t.bucket.ptrdata == 0 { // åˆ¤æ–­å½“å‰æ¡¶ç±»å‹çš„ptrdataå­—æ®µï¼Œè¯¥å­—æ®µä¸º0è¯´æ˜å­˜å‚¨çš„éƒ½æ˜¯æ ‡é‡æ•°æ® // åˆ†é…å½“å‰åˆ‡ç‰‡å¹¶è®°ä½æŒ‡å‘å½“å‰åˆ‡ç‰‡å’Œæ—§åˆ‡ç‰‡çš„æŒ‡é’ˆã€‚ // å³ä½¿è¡¨å¢é•¿ and/or åœ¨æˆ‘ä»¬è¿­ä»£æ—¶å°†æº¢å‡ºæ¡¶æ·»åŠ åˆ°è¡¨ä¸­ï¼Œè¿™ä¹Ÿä¼šä¿ç•™æ‰€æœ‰ç›¸å…³çš„æº¢å‡ºæ¡¶ã€‚ h.createOverflow() // åˆ›å»ºæº¢å‡ºæ¡¶ it.overflow = h.extra.overflow it.oldoverflow = h.extra.oldoverflow } // decide where to start // å†³å®šä»å“ªé‡Œå¼€å§‹ r := uintptr(fastrand()) // ç”Ÿæˆéšæœºæ•°å†³å®šä»å“ªé‡Œå¼€å§‹ // bucketCntBits = 3 if h.B \u0026gt; 31-bucketCntBits { // å¦‚æœå½“å‰çš„æ¡¶æ•° \u0026gt; 31 - 3 r += uintptr(fastrand()) \u0026lt;\u0026lt; 31 } it.startBucket = r \u0026amp; bucketMask(h.B) // ç¡®å®šå¼€å§‹çš„æ¡¶å·ï¼Œè¿™é‡Œä¹Ÿæ˜¯for rangeéšæœºçš„åŸå›  it.offset = uint8(r \u0026gt;\u0026gt; h.B \u0026amp; (bucketCnt - 1)) // å¼€å§‹çš„tophashä½ç½®å¤„ // iterator state it.bucket = it.startBucket // è®°ä½æˆ‘ä»¬æœ‰ä¸€ä¸ªè¿­ä»£å™¨ã€‚ // å¯ä»¥ä¸å¦ä¸€ä¸ª mapiterinit() å¹¶å‘è¿è¡Œã€‚\t// iterator = 1 å­˜åœ¨æ¡¶æ­£åœ¨åœ¨ä½¿ç”¨è¿­ä»£å™¨æ ‡å¿— // oldIterator = 2 å­˜åœ¨æ—§æ¡¶æ­£åœ¨ä½¿ç”¨è¿­ä»£å™¨æ ‡å¿— // è®¾ç½®æ­£åœ¨è¿­ä»£çš„æ ‡å¿—ä½ if old := h.flags; old\u0026amp;(iterator|oldIterator) != iterator|oldIterator { atomic.Or8(\u0026amp;h.flags, iterator|oldIterator) // åŸå­é”è®¾ç½®hmapçš„flagså‚æ•°æ ‡å¿—æ­£åœ¨ä½¿ç”¨è¿­ä»£å™¨ } mapiternext(it) } mapiternext()ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 // å‘ä¸‹å¯»æ‰¾ä¸‹ä¸€ä¸ªkey func mapiternext(it *hiter) { h := it.h // è·å–å½“å‰hmapå†…å­˜ç»“æ„ if raceenabled { callerpc := getcallerpc() racereadpc(unsafe.Pointer(h), callerpc, abi.FuncPCABIInternal(mapiternext)) } // å½“å‰æœ‰hashWritingæ“ä½œæ—¶ï¼Œæ¯”å¦‚m[k]=væˆ–deleteå‡½æ•°æ—¶éƒ½ä¼šæŠ¥é”™ if h.flags\u0026amp;hashWriting != 0 { throw(\u0026#34;concurrent map iteration and map write\u0026#34;) } t := it.t // è·å–mapçš„ç»“æ„ // æœ¬æ¬¡éœ€è¦éå†çš„æ¡¶å· bucket := it.bucket // å½“å‰çš„æ¡¶å· // æœ¬æ¬¡éœ€è¦éå†çš„æ¡¶ï¼Œå¦‚æœä¸ºnilè¯´æ˜éœ€è¦å»bucketå¯»æ‰¾ b := it.bptr // å½“å‰å­˜å‚¨æ¡¶ // æœ¬æ¬¡åº”è¯¥éå†çš„ç´¢å¼• i := it.i // éå†ç´¢å¼•é»˜è®¤0 checkBucket := it.checkBucket // éå†ä¸€éå½“å‰æ¡¶åŠå…¶æº¢å‡ºæ¡¶ç›´åˆ°b=nil next: // å½“å‰æ¡¶éå†å®Œæ—¶ï¼Œåˆ‡æ¢åˆ°ä¸‹ä¸€ä¸ªæ¡¶å»éå† if b == nil { // å½“å‰éå†çš„æ¡¶å’Œå¼€å§‹çš„æ¡¶ç›¸ç­‰ å¹¶ä¸” å·²ç»éå†è¿‡äº†æœ€å¤§æ¡¶æ•°ï¼Œè¯´æ˜éå†äº†ä¸€åœˆäº† if bucket == it.startBucket \u0026amp;\u0026amp; it.wrapped { // ç»“æŸéå†çš„æ¡ä»¶ // end of iteration it.key = nil it.elem = nil return } // h.growing() å½“å‰æ­£åœ¨æ‰©å®¹ä¸­ if h.growing() \u0026amp;\u0026amp; it.B == h.B { // h.growing()å½“å‰mapæ­£å¤„äºæ‰©å®¹çŠ¶æ€ // è¿­ä»£å™¨æ˜¯åœ¨å¢é•¿è¿‡ç¨‹ä¸­å¯åŠ¨çš„ï¼Œä½†å¢é•¿å°šæœªå®Œæˆã€‚ // å¦‚æœæˆ‘ä»¬æŸ¥çœ‹çš„bucketå°šæœªå¡«å……ï¼ˆå³ï¼Œæ—§bucketæœªè¢«æ¸…ç©ºï¼‰ï¼Œé‚£ä¹ˆæˆ‘ä»¬éœ€è¦éå†æ—§bucketsï¼Œåªè¿”å›å°†è¿ç§»åˆ°æ­¤bucketçš„bucketsã€‚ oldbucket := bucket \u0026amp; it.h.oldbucketmask() // æ—§æ¡¶çš„æ¡¶å· b = (*bmap)(add(h.oldbuckets, oldbucket*uintptr(t.bucketsize)))\t// è·å–æ¡¶ä½ç½® // å½“å‰æ¡¶çš„tophash[0]ä¸æ˜¯2|3|4æ—¶ï¼Œè¯´æ˜æ•°æ®æ²¡æœ‰è¢«è¿ç§» if !evacuated(b) {\tcheckBucket = bucket // éœ€è¦æ£€æŸ¥çš„æ¡¶å· } else { // è¯´æ˜æ•°æ®åœ¨æ–°æ¡¶é‡Œé¢ï¼Œæ•°æ®å·²è¢«è¿ç§» b = (*bmap)(add(it.buckets, bucket*uintptr(t.bucketsize)))\tcheckBucket = noCheck } } else { // 1.æ²¡æœ‰æ‰©å®¹ 2.æ‰©å®¹äº†ä½†æ˜¯it.B != h.B b = (*bmap)(add(it.buckets, bucket*uintptr(t.bucketsize))) // æ–°æ¡¶ checkBucket = noCheck } bucket++ // æ¡¶å·åŠ ä¸€ // å½“å‰æ¡¶å·ç­‰äºæœ€å¤§æ¡¶å· if bucket == bucketShift(it.B) { // bucketShift(it.B) ç­‰äº 1 \u0026gt;\u0026gt; B bucket = 0 // æ ‡è®°ä»0å·æ¡¶å¼€å§‹ it.wrapped = true // æ ‡è®°å·²ç»è¿‡äº†æœ€å¤§æ¡¶äº† } i = 0 // æ–°æ¡¶é‡ç½®ç´¢å¼•ä¸º0 } // éå†å½“å‰æ¡¶çš„æ‰€æœ‰å…ƒç´ \tbucketCnt = 8 // ä»å½“å‰æ¡¶éå†æ•°æ® for ; i \u0026lt; bucketCnt; i++ { offi := (i + it.offset) \u0026amp; (bucketCnt - 1) // æ ¹æ®it.offsetåç§»é‡å¼€å§‹éšæœºéå†å…ƒç´ [0,7] // b.tophash[offi] \u0026lt;= 1 æˆ– evacuatedEmpty = 4 è¡¨ç¤ºæ¡¶æ•°æ®ä¸ºç©º if isEmpty(b.tophash[offi]) || b.tophash[offi] == evacuatedEmpty { // å¦‚æœå½“å‰ä½ç½®ä¸º0æˆ–1æˆ–4è¡¨ç¤ºæ¡¶ä¸ºç©º continue } k := add(unsafe.Pointer(b), dataOffset+uintptr(offi)*uintptr(t.keysize)) // åç§»åˆ°å½“å‰keyä½ç½® if t.indirectkey() { // åˆ¤æ–­å½“å‰keyå­˜å‚¨æ˜¯å¦æ˜¯å·²æŒ‡é’ˆå­˜å‚¨è€Œä¸æ˜¯å­˜å‚¨çš„keyæœ¬èº« k = *((*unsafe.Pointer)(k)) } // åç§»åˆ°å½“å‰elemä½ç½® e := add(unsafe.Pointer(b), dataOffset+bucketCnt*uintptr(t.keysize)+uintptr(offi)*uintptr(t.elemsize)) // checkBucket != noCheck æ•°æ®åœ¨æ—§æ¡¶ å¹¶ä¸” !h.sameSizeGrow() ç¿»å€æ‰©å®¹ // éœ€è¦éªŒè¯æ¡¶æ—¶ï¼Œæ—§æ¡¶å­˜åœ¨æ•°æ® if checkBucket != noCheck \u0026amp;\u0026amp; !h.sameSizeGrow() { // å­˜åœ¨æ²¡æœ‰è¿ç§»å®Œçš„æ—§æ¡¶æ—¶ï¼Œå»æ£€æŸ¥æ—§æ¡¶ // t.reflexivekey() ä¸ºtrueè¡¨ç¤º k == k å§‹ç»ˆæˆç«‹ // t.reflexivekey() || t.key.equal(k, k) -\u0026gt; k == k å§‹ç»ˆæˆç«‹æƒ…å†µ if t.reflexivekey() || t.key.equal(k, k) { // å¦‚æœoldbucketä¸­çš„é¡¹ä¸æ˜¯é’ˆå¯¹è¿­ä»£ä¸­çš„å½“å‰æ–°bucketï¼Œè¯·è·³è¿‡å®ƒ hash := t.hasher(k, uintptr(h.hash0)) if hash\u0026amp;bucketMask(it.B) != checkBucket { // éœ€è¦è·³è¿‡çš„æƒ…å†µ continue } } else { // k == k ä¸æ˜¯å§‹ç»ˆæˆç«‹ // b.tophash[offi]\u0026amp;1 çš„æœ€ä½ä½ å‚çœ‹æ•°æ®è¿ç§»éƒ¨åˆ†çš„å»å‘ if checkBucket\u0026gt;\u0026gt;(it.B-1) != uintptr(b.tophash[offi]\u0026amp;1) { continue } } } // å°†æ‰¾åˆ°çš„kå’Œeä¿å­˜åˆ°hiterä¸­ // evacuatedX = 2ã€evacuatedY = 3 // b.tophash[offi] != evacuatedX \u0026amp;\u0026amp; b.tophash[offi] != evacuatedY å­˜åœ¨æœ‰æ•ˆæ•°æ® // !(t.reflexivekey() || t.key.equal(k, k))\t-\u0026gt; x == x ä¸æ˜¯å§‹ç»ˆæˆç«‹ if (b.tophash[offi] != evacuatedX \u0026amp;\u0026amp; b.tophash[offi] != evacuatedY) || !(t.reflexivekey() || t.key.equal(k, k)) { // è¿™æ˜¯éœ€è¦çš„æ•°æ®ï¼Œæˆ‘ä»¬å¯ä»¥è¿”å›å®ƒ // æˆ– // key!=keyï¼Œå› æ­¤æ— æ³•åˆ é™¤æˆ–æ›´æ–°æ¡ç›®ï¼Œå› æ­¤æˆ‘ä»¬å¯ä»¥åªè¿”å›å®ƒ // è¿™å¯¹æˆ‘ä»¬æ¥è¯´å¾ˆå¹¸è¿ï¼Œå› ä¸ºå½“key!=keyå…³é”®æ˜¯æˆ‘ä»¬æ‰¾ä¸åˆ°å®ƒ it.key = k if t.indirectelem() { e = *((*unsafe.Pointer)(e)) } it.elem = e } else { // æ•°æ®è¢«è¿ç§»åˆ°å…¶ä»–åœ°æ–¹äº† // è‡ªä»è¿­ä»£å™¨å¯åŠ¨ä»¥æ¥ï¼Œå“ˆå¸Œè¡¨ä¸€ç›´åœ¨å¢é•¿ // è¿™ä¸ªkeyçš„æ•°æ®ç°åœ¨åœ¨å…¶ä»–åœ°æ–¹ // æ£€æŸ¥æ•°æ®çš„å½“å‰å“ˆå¸Œè¡¨ // æ­¤ä»£ç å¤„ç†ä»¥ä¸‹æƒ…å†µï¼š //\tå·²è¢«åˆ é™¤ã€æ›´æ–°æˆ–åˆ é™¤å¹¶é‡æ–°æ’å…¥ //\tæ³¨æ„ï¼šæˆ‘ä»¬éœ€è¦é‡æ–°æ ‡è®°å¯†é’¥ï¼Œå› ä¸ºå®ƒå¯èƒ½å·²æ›´æ–°ä¸ºequal()ï¼Œä½†ä¸æ˜¯ç›¸åŒçš„keyï¼ˆä¾‹å¦‚+0.0 vs-0.0ï¼‰ rk, re := mapaccessK(t, h, k) // æ ¹æ®keyå»å¯»æ‰¾ç›¸åº”çš„æ•°æ®ï¼Œå¯èƒ½æ˜¯æ–°æ¡¶ä¹Ÿå¯èƒ½æ˜¯æ—§æ¡¶ // æ¯å¯»æ‰¾åˆ°ï¼Œå¯èƒ½keyå·²è¢«åˆ é™¤ if rk == nil { continue // key has been deleted } it.key = rk it.elem = re } it.bucket = bucket // å›å†™æ¡¶å· // è®°å½•å½“å‰æ­£åœ¨éå†çš„æ¡¶ if it.bptr != b { // avoid unnecessary write barrier; see issue 14921 it.bptr = b\t// é¿å…ä¸å¿…è¦çš„å†™å…¥éšœç¢ } it.i = i + 1 // iåŠ ä¸€ it.checkBucket = checkBucket return } b = b.overflow(t) // å¦‚æœä¸Šé¢æ¡¶éå†å®Œæ¥åˆ°å»åé¢æ¡¶æ‰¾ i = 0 goto next } mapaccessK()ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 // returns both key and elem. Used by map iterator // æ ¹æ®keyæ‰¾åˆ°ç›¸åº”çš„å€¼ func mapaccessK(t *maptype, h *hmap, key unsafe.Pointer) (unsafe.Pointer, unsafe.Pointer) { if h == nil || h.count == 0 { return nil, nil } hash := t.hasher(key, uintptr(h.hash0)) // å½“å‰keyç”Ÿæˆçš„hashå€¼ m := bucketMask(h.B) // (1 \u0026lt;\u0026lt; B) - 1 b := (*bmap)(add(h.buckets, (hash\u0026amp;m)*uintptr(t.bucketsize))) // keyå­˜å‚¨çš„å½“å‰æ¡¶ // æ˜¯å¦åœ¨æ‰©å®¹ä¸­ if c := h.oldbuckets; c != nil { if !h.sameSizeGrow() {\t// ç¿»å€æ‰©å®¹ // There used to be half as many buckets; mask down one more power of two. m \u0026gt;\u0026gt;= 1 } // å»æ—§æ¡¶é‡Œé¢æŸ¥çœ‹æ•°æ®æ˜¯å¦è¢«è¿ç§»äº† oldb := (*bmap)(add(c, (hash\u0026amp;m)*uintptr(t.bucketsize)))\t// æ•°æ®æ²¡æœ‰è¢«è¿ç§» tophash[0] != [2,3,4] if !evacuated(oldb) { b = oldb } } top := tophash(hash) // tophash bucketloop: // éå†å½“å‰æ¡¶åŠæº¢å‡ºæ¡¶å¯»æ‰¾ key for ; b != nil; b = b.overflow(t) { for i := uintptr(0); i \u0026lt; bucketCnt; i++ { if b.tophash[i] != top { if b.tophash[i] == emptyRest { // emptyRest = 0 break bucketloop } continue } // æ‰¾åˆ°äº†key // 1. å¯èƒ½æ˜¯hashå†²çªåˆ™è¿˜éœ€è¦å‘åå»æŸ¥æ‰¾ // 2. ç¡®å®æ‰¾åˆ°äº†keyç›´æ¥è¿”å›å³å¯ k := add(unsafe.Pointer(b), dataOffset+i*uintptr(t.keysize)) if t.indirectkey() { k = *((*unsafe.Pointer)(k)) } // keyåŒ¹é…æˆåŠŸ if t.key.equal(key, k) { e := add(unsafe.Pointer(b), dataOffset+bucketCnt*uintptr(t.keysize)+i*uintptr(t.elemsize)) if t.indirectelem() { e = *((*unsafe.Pointer)(e)) } return k, e } } } return nil, nil } æ€»ç»“ for-rangeä¸æ”¯æŒã€å­—ç¬¦ä¸²æŒ‡é’ˆã€‘ã€ã€åˆ‡ç‰‡æŒ‡é’ˆã€‘ã€ã€mapæŒ‡é’ˆã€‘ã€ã€channelæŒ‡é’ˆã€‘ï¼Œä½†æ”¯æŒã€æ•°ç»„æŒ‡é’ˆã€‘éå†ã€‚ ","permalink":"https://heliu.site/posts/golang/process/range/","summary":"Golang for rangeè¿­ä»£stringã€channelã€arrayã€sliceã€mapè§£æã€‚","title":"æµç¨‹æ§åˆ¶(rangeè¿­ä»£)"},{"content":" è¡¨è¾¾å¼å‹switchï¼šåŒ…å«ä¸switchè¡¨è¾¾å¼çš„å€¼è¿›è¡Œæ¯”è¾ƒçš„è¡¨è¾¾å¼ã€‚ ç±»å‹å‹switchï¼šåŒ…å«ä¸switchè¡¨è¾¾å¼çš„ç±»å‹è¿›è¡Œæ¯”è¾ƒçš„ç±»å‹ã€‚ switch ä½¿ç”¨æ–¹å¼ switch var{} switch è¡¨è¾¾å¼å¯ä»¥æ‰§è¡Œä¸€ä¸ªç®€å•è¯­å¥å®Œæˆè¿ç®—ä»è€Œå¾—åˆ°è¡¨è¾¾å¼çš„å€¼ã€‚ 1 2 3 4 5 6 7 8 switch var { // switch ä¼šåˆ¤æ–­varçš„ç±»å‹ case val1: // case ä¼šåˆ¤æ–­val1çš„ç±»å‹ä»¥ä¾¿å’Œvarèƒ½æ¯”è¾ƒ // ... case val2: // ... default: // ... } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 package main import ( \u0026#34;fmt\u0026#34; ) const B1 = false func main() { switch B1 { case false: fmt.Println(\u0026#34;fallthrough è¯­å¥ æ¥åˆ°æ‰§è¡Œä¸‹ä¸€ä¸ªè¯­å¥\u0026#34;) fallthrough case true: fmt.Println(\u0026#34;true\u0026#34;) fallthrough case false: fmt.Println(123) fallthrough case true: fmt.Println(456789) default: fmt.Println(\u0026#34;default\u0026#34;) } fmt.Println(\u0026#34;default 1234\u0026#34;) // \u0026gt; ---------------------------------------------------- var i1 = 2 switch i1 { default: fmt.Println(\u0026#34;default\u0026#34;) case 0,1,2,3: fmt.Println(\u0026#34;123456789\u0026#34;) case 4,5,6,7: fmt.Println(\u0026#34;987654321\u0026#34;) } // \u0026gt; ---------------------------------------------------- switch i1 { default: fmt.Println(\u0026#34;default\u0026#34;) case 0: case 1: case 2: case 3: fmt.Println(\u0026#34;123456789\u0026#34;) case 4,5,6,7: fmt.Println(\u0026#34;987654321\u0026#34;) } // æ³¨æ„ case 0,1,2,3: å½¢å¼å’Œ case 0: case 1: case 2: è¿™ç§å½¢å¼çš„åŒºåˆ« // Output: // fallthrough è¯­å¥ æ¥åˆ°æ‰§è¡Œä¸‹ä¸€ä¸ªè¯­å¥ // true // 123 // 456789 // default 1234 // 123456789 } switch{} ä¸æä¾›ä»»ä½•è¢«åˆ¤æ–­çš„å€¼ï¼ˆå®é™…ä¸Šé»˜è®¤ä¸ºåˆ¤æ–­æ˜¯å¦ä¸ºtrueï¼‰ç„¶ååœ¨æ¯ä¸ªcaseåˆ†æ”¯ä¸­æ£€æµ‹ä¸åŒçš„æ¡ä»¶ï¼Œå½“ä»»ä¸€åˆ†æ”¯çš„æµ‹è¯•ç»“æœä¸ºtrueæ—¶ï¼Œè¯¥åˆ†æ”¯çš„ä»£ç ä¼šè¢«æ‰§è¡Œï¼Œæ­¤æ—¶è¯­å¥ç›¸å½“äºswitch trueã€‚ 1 2 3 4 5 6 7 8 switch { // é»˜è®¤æ¨å¯¼ä¸ºå¸ƒå°”ç±»å‹ true case condition1: // condition1æ¯”è¾ƒæ¡ä»¶ // ... case condition2: // ... default: // ... } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 package main import ( \u0026#34;fmt\u0026#34; ) func main() { var x, y, z = 2, 1, 3 // switch {} ç­‰ä»·äº switch true {} switch { case x \u0026lt; y: fmt.Printf(\u0026#34;x:%d,y:%d\\n\u0026#34;, x, y) case x \u0026lt; z: fmt.Printf(\u0026#34;x:%d,z:%d\\n\u0026#34;, x, z) case z == 3: fmt.Println(\u0026#34;z==4\\n\u0026#34;) } // Output: // x:2,z:3 } switch Init; var{} switchè¯­å¥ç¬¬ä¸‰ç§å½¢å¼ï¼ŒåŒ…å«ä¸€ä¸ªåˆå§‹åŒ–è¯­å¥ã€‚ 1 2 3 4 5 6 7 8 switch Init; var { case val1: // ... case val2: // ... default: // ... } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 package main import ( \u0026#34;fmt\u0026#34; ) func main() { // switch x, y, z := 2, 1, 3; {} ç­‰ä»·äº switch x, y, z := 2, 1, 3; true {} // ç­‰ä»·äº // { // x, y, z := 2, 1, 3; // switch true { // // ... ... // } // } switch x, y, z := 2, 1, 3; { case x \u0026lt; y: fmt.Printf(\u0026#34;x:%d,y:%d\\n\u0026#34;, x, y) case x \u0026lt; z: fmt.Printf(\u0026#34;x:%d,z:%d\\n\u0026#34;, x, z) case z == 3: fmt.Println(\u0026#34;z==4\\n\u0026#34;) } switch x, y, z := 2, 1, 3; false { case x \u0026lt; y: fmt.Printf(\u0026#34;x:%d,y:%d\\n\u0026#34;, x, y) case x \u0026lt; z: fmt.Printf(\u0026#34;x:%d,z:%d\\n\u0026#34;, x, z) case z == 3: fmt.Println(\u0026#34;z==4\\n\u0026#34;) } // Output: // x:2,z:3 // x:2,y:1 } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 package main import \u0026#34;fmt\u0026#34; func main() { var j = 0 switch j { case 0: // æ³¨æ„è¿™ç§å’Œcase 0, 1:å½¢å¼çš„åŒºåˆ« case 1: fmt.Println(\u0026#34;11\u0026#34;) case 2: fmt.Println(\u0026#34;22\u0026#34;) default: fmt.Println(\u0026#34;def def\u0026#34;) } var k = 0 switch k { case 0: fmt.Println(\u0026#34;fallthrough\u0026#34;) fallthrough case 1: fmt.Println(\u0026#34;111\u0026#34;) case 2: fmt.Println(\u0026#34;211\u0026#34;) default: fmt.Println(\u0026#34;def def def\u0026#34;) } var m = 0 switch m { case 0, 1: fmt.Println(\u0026#34;1111\u0026#34;) case 2: fmt.Println(\u0026#34;2111\u0026#34;) default: fmt.Println(\u0026#34;def def def def\u0026#34;) } var n = 0 switch { case n \u0026gt; 0 \u0026amp;\u0026amp; n \u0026lt; 10: fmt.Println(\u0026#34;i \u0026gt; 0 and i \u0026lt; 10\u0026#34;) case n \u0026gt; 10 \u0026amp;\u0026amp; n \u0026lt; 20: fmt.Println(\u0026#34;i \u0026gt; 10 and i \u0026lt; 20\u0026#34;) default: fmt.Println(\u0026#34;def def def def def\u0026#34;) } // Output: // fallthrough // 111 // 1111 // def def def def def } è¡¨è¾¾å¼å‹switch å¦‚æœswitchè¡¨è¾¾å¼æ±‚å€¼ä¸ºæ— ç±»å‹å¸¸é‡ï¼Œåˆ™é¦–å…ˆå°†å…¶è½¬æ¢ä¸ºé»˜è®¤ç±»å‹ï¼ˆæ•´å‹é»˜è®¤intï¼Œæµ®ç‚¹æ•°é»˜è®¤float64ï¼Œå­—ç¬¦ä¸²é»˜è®¤stringï¼Œå¤æ•°é»˜è®¤complex128ï¼‰ã€‚ å¦‚æœæ˜¯æ— ç±»å‹çš„å¸ƒå°”å€¼ï¼Œåˆ™é¦–å…ˆå°†å…¶è½¬æ¢ä¸ºboolç±»å‹ã€‚ é¢„å…ˆå£°æ˜çš„æ— ç±»å‹å€¼nilä¸èƒ½ç”¨ä½œå¼€å…³è¡¨è¾¾å¼ï¼ˆç”±äºswitchè½¬æ¢nilä¸ºé»˜è®¤ç±»å‹æŠ¥é”™ï¼‰ã€‚ å¦‚æœswitchè¡¨è¾¾å¼æ˜¯æ— ç±»å‹çš„ï¼Œåˆ™é¦–å…ˆå°†å…¶è½¬æ¢ä¸ºswitchè¡¨è¾¾å¼çš„ç±»å‹ã€‚ å¯¹äºæ¯ä¸ªï¼ˆå¯èƒ½å·²è½¬æ¢çš„ï¼‰switchè¡¨è¾¾å¼xå’Œswitchè¡¨è¾¾å¼çš„å€¼tï¼Œxå’Œtå¿…é¡»å¯ä»¥è¿›è¡Œæœ‰æ•ˆçš„æ¯”è¾ƒã€‚ åœ¨switchæˆ–defaultå­—å¥ä¸­ï¼Œæœ€åä¸€ä¸ªéç©ºè¯­å¥å¯ä»¥æ˜¯fallthroughè¯­å¥ã€‚ ä»¥æŒ‡ç¤ºåº”è¯¥ä»è¯¥å­—å¥çš„æœ«å°¾æµå‘ä¸‹ä¸€ä¸ªå­—å¥çš„ç¬¬ä¸€ä¸ªè¯­å¥ï¼Œæ— è®ºä¸‹ä¸€ä¸ªå­—å¥çš„æ¡ä»¶æ˜¯å¦æ»¡è¶³ã€‚ å‡ºç°fallthroughè¯­å¥åï¼Œå®ƒåé¢åªèƒ½æ¥ä¸‹ä¸€ä¸ªå­—å¥ã€‚ 1 2 3 4 5 6 7 8 switch expr { case v1: // pass case v2: // pass default: // pass } nilä¸èƒ½ä½œä¸ºswitchè¡¨è¾¾å¼ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 package main import \u0026#34;fmt\u0026#34; func main() { // è¿™é‡Œswitchå°†nilè½¬æ¢æˆé»˜è®¤ç±»å‹è¿›è¡Œä»¥ä¸‹æ¯”è¾ƒæ—¶æŠ¥é”™ // å’Œä¹‹å‰çš„ a := nil æˆ– var a = nil ä¸€æ ·æŠ¥é”™ä¸èƒ½åˆ¤æ–­å‡ºaçš„å…·ä½“ç±»å‹ // ç”±æ­¤å¯è§swicthéœ€è¦ç¡®å®šå˜é‡çš„å”¯ä¸€ç±»å‹ switch nil { // æŠ¥é”™ case nil: fmt.Println(\u0026#34;nil\u0026#34;) default: fmt.Println(\u0026#34;default\u0026#34;) } // .\\os.go:8:2: use of untyped nil // ä¸‹é¢è¿™ç§å´æ˜¯å¯ä»¥ var m map[string]string switch m { // è¿™é‡Œèƒ½ç¡®è®¤mæ˜¯mapç±»å‹ case nil: fmt.Println(\u0026#34;nil\u0026#34;) default: fmt.Println(\u0026#34;default\u0026#34;) } // Output: // nil } æ— ç±»å‹å¸¸é‡ç”¨ä½œswitch 1 2 3 4 5 6 7 8 9 10 11 12 13 14 package main import \u0026#34;fmt\u0026#34; const Sw = 12 func main() { switch Sw { // Swè¢«é»˜è®¤æ¨å¯¼ä¸ºintç±»å‹ // (untyped float constant) truncated to int // æŠ¥é”™ï¼Œ1.1è¢«é»˜è®¤æ¨å¯¼ä¸ºfloat64ç±»å‹æ— æ³•ä¸intç±»å‹æ¯”è¾ƒ case 1.1:\tfmt.Println() } } switchå¸¸ç”¨ç¤ºä¾‹ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 package main import \u0026#34;fmt\u0026#34; func main() { // å®šä¹‰å±€éƒ¨å˜é‡ var grade string = \u0026#34;B\u0026#34; var marks int = 90 switch marks { case 90: grade = \u0026#34;A\u0026#34; case 80: grade = \u0026#34;B\u0026#34; // è¿™é‡Œä¸å…¶ä»–è¯­è¨€å†™æ³•çš„æ ¹æœ¬åŸå› æ˜¯goé»˜è®¤ä¼šæ·»åŠ breakè¯­å¥ï¼Œè€Œå…¶ä»–è¯­è¨€æ²¡æœ‰è¿™ä¸€ç‰¹æ€§çš„åŸå›  case 50, 60, 70: // è¿™é‡ŒåŒºåˆ†å…¶ä»–è¯­è¨€ case 50: case 60: case 70: grade = \u0026#34;C\u0026#34; default: grade = \u0026#34;D\u0026#34; } // switch çœç•¥æ¡ä»¶ é»˜è®¤ä¸º switch true {} // å’Œfor {} ä¸€æ ·çœç•¥æ¡ä»¶é»˜è®¤ä¸º for true {} switch { case grade == \u0026#34;A\u0026#34;: fmt.Printf(\u0026#34;ä¼˜ç§€\\n\u0026#34;) case grade == \u0026#34;B\u0026#34;, grade == \u0026#34;C\u0026#34;: fmt.Printf(\u0026#34;è‰¯å¥½\\n\u0026#34;) case grade == \u0026#34;D\u0026#34;: fmt.Printf(\u0026#34;åŠæ ¼\\n\u0026#34;) case grade == \u0026#34;F\u0026#34;: fmt.Printf(\u0026#34;ä¸åŠæ ¼\\n\u0026#34;) default: fmt.Printf(\u0026#34;å·®\\n\u0026#34;) } fmt.Printf(\u0026#34;ä½ çš„ç­‰çº§æ˜¯ %s\\n\u0026#34;, grade) // Output: // ä¼˜ç§€ // ä½ çš„ç­‰çº§æ˜¯ A } fallthroughå…³é”®å­— 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 package main import ( \u0026#34;fmt\u0026#34; ) func main() { // fallthrough å…³é”®å­— ç»§ç»­æ‰§è¡Œä¸‹ä¸€ä¸ªcaseä¸åˆ¤æ–­caseå€¼ switch { case false: fmt.Println(\u0026#34;fallthrough è¯­å¥ æ¥åˆ°æ‰§è¡Œä¸‹ä¸€ä¸ªè¯­å¥\u0026#34;) fallthrough case true: fmt.Println(\u0026#34;true\u0026#34;) fallthrough case false: fmt.Println(123) fallthrough case true: fmt.Println(456789) // fallthroughå¼ºåˆ¶æ‰§è¡Œã€ç´§æŒ¨ç€ç›¸é‚»ã€‘çš„caseæˆ–defaultå—ï¼Œ // å¦‚æœåé¢æ²¡æœ‰ç´§æŒ¨ç€çš„åˆ™æŠ¥é”™ fallthrough default: fmt.Println(\u0026#34;default\u0026#34;) } // Output: // true // 123 // 456789 // default } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 package main import \u0026#34;fmt\u0026#34; func main() { var k = 2 switch k { case 0: fmt.Println(\u0026#34;fallthrough\u0026#34;) case 2: fmt.Println(\u0026#34;211\u0026#34;) fallthrough // å¯è§ï¼Œfallthrough åç´§æŒ¨ç€ default ä¹Ÿä¼šæ‰§è¡Œå®ƒã€‚ default: fmt.Println(\u0026#34;def def def\u0026#34;) case 1: fmt.Println(\u0026#34;111\u0026#34;) } // Output: // 211 // def def def } fallthroughå’Œdefaultä¸€èµ·ä½¿ç”¨ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 switch { default: // æ¯”å¦‚è¿™é‡Œå½“åŒ¹é…æ¡ä»¶éƒ½ä¸é€šè¿‡ï¼Œåˆ™åˆ°defaultè¿™é‡Œ fmt.Println(\u0026#34;1\u0026#34;) fallthrough // fallthroughåç»§ç»­æ‰§è¡Œåé¢çš„case case true: fmt.Println(\u0026#34;2\u0026#34;) } // Output: // 2 switch { default: // æ¯”å¦‚è¿™é‡Œå½“åŒ¹é…æ¡ä»¶éƒ½ä¸é€šè¿‡ï¼Œåˆ™åˆ°defaultè¿™é‡Œ fmt.Println(\u0026#34;1\u0026#34;) fallthrough // fallthroughåç»§ç»­æ‰§è¡Œåé¢çš„case case false: fmt.Println(\u0026#34;2\u0026#34;) } // Output: // 1 // 2 ç±»å‹å‹switch æ¯”è¾ƒçš„ç±»å‹è€Œä¸æ˜¯å€¼ï¼Œå®ƒåœ¨å…¶ä»–æ–¹é¢ç±»ä¼¼è¡¨è¾¾å¼å‹switchï¼Œåªä¸è¿‡åˆ†æ”¯é€‰æ‹©çš„æ˜¯ç±»å‹è€Œä¸æ˜¯å€¼ã€‚ å®ƒç”±ä¸€ä¸ªç‰¹æ®Šçš„switchè¡¨è¾¾å¼æ ‡è®°ï¼Œè¯¥è¡¨è¾¾å¼ä½¿ç”¨ç±»å‹æ–­è¨€çš„å½¢å¼æ¥è¿›è¡ŒåŠ¨æ€ç±»å‹åˆ¤æ–­ã€‚ x.(type) switch è¯­å¥è¿˜å¯ä»¥è¢«ç”¨äº type-switch æ¥åˆ¤æ–­æŸä¸ª interface å˜é‡ä¸­å®é™…å­˜å‚¨çš„å˜é‡ç±»å‹ã€‚ type switch è¯­å¥æ ¼å¼å¦‚ä¸‹ï¼š 1 2 3 4 5 6 7 8 switch x.(type) { case type: statement(s) case type: statement(s) default: statement(s) } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 package main import ( \u0026#34;fmt\u0026#34; ) func main() { // å®šä¹‰å˜é‡t æ¥å£ç±»å‹ interface{} å¯ä»¥æ˜¯ä»»ä½•å…¶ä»–ç±»å‹ var t interface{} t = functionOfSomeType() // switch t.(type) { ... } // t.(type) æ–­è¨€tçš„ç±»å‹ .(type)å½¢å¼å¿…é¡»é…åˆswitchä½¿ç”¨ switch t1 := t.(type) { default: fmt.Printf(\u0026#34;default Type %T\\n\u0026#34;, t1) case bool: fmt.Printf(\u0026#34;bool %t\\n\u0026#34;, t1) case int: fmt.Printf(\u0026#34;integer %d\\n\u0026#34;, t1) case *bool: fmt.Printf(\u0026#34;pointer bool %t\\n\u0026#34;, *t1) case *int: fmt.Printf(\u0026#34;pointer integer %d\\n\u0026#34;, *t1) } } //func functionOfSomeType () bool { // return false //} // bool false //func functionOfSomeType () uint { // return 123 //} // default Type uint //func functionOfSomeType () int { // return 123 //} // integer 123 //func functionOfSomeType () *int { // a := 123 // return \u0026amp;a //} // pointer integer 123 func functionOfSomeType () *bool { a := true return \u0026amp;a } // pointer bool true æ³¨æ„ val1å’Œval2å¯ä»¥æ˜¯åŒç±»å‹çš„ä»»æ„å€¼ï¼Œç±»å‹ä¸å±€é™äºå¸¸æ•°æˆ–æ•´æ•°ï¼Œä½†å¿…é¡»æ˜¯ç›¸åŒçš„ç±»å‹ï¼Œæˆ–æœ€ç»ˆç»“æœä¸ºç›¸åŒç±»å‹çš„è¡¨è¾¾å¼ã€‚ å‰èŠ±æ‹¬å·{å¿…é¡»å’Œswitchå…³é”®å­—åœ¨åŒä¸€è¡Œã€‚ å¯ä»¥åŒæ—¶æµ‹è¯•å¤šä¸ªå¯èƒ½ç¬¦åˆæ¡ä»¶çš„å€¼ï¼Œä½¿ç”¨é€—å·åˆ†å‰²å®ƒä»¬ã€‚ å¦‚case val1, val2, val3è€Œåœ¨å…¶ä»–è¯­è¨€ä¸­åˆ™æ˜¯case val1: case val2: case val3:è¿™ç§å½¢å¼ã€‚ ä¸€æ—¦æˆåŠŸåœ°åŒ¹é…åˆ°æŸä¸ªåˆ†æ”¯ï¼Œåœ¨æ‰§è¡Œå®Œç›¸åº”ä»£ç åå°±ä¼šé€€å‡ºæ•´ä¸ªswitchä»£ç å—ã€‚ ä¹Ÿå°±æ˜¯è¯´ï¼Œä¸éœ€è¦ç‰¹åˆ«ä½¿ç”¨breakè¯­å¥æ¥è¡¨ç¤ºç»“æŸï¼Œå¦‚æœä½¿ç”¨äº†ä»ç„¶æ˜¯åœ¨switchå—ä¸­ã€‚ å¦‚æœåœ¨æ‰§è¡Œå®Œæ¯ä¸ªåˆ†æ”¯çš„ä»£ç åï¼Œè¿˜æ˜¯å¸Œæœ›ç»§ç»­æ‰§è¡Œåç»­åˆ†æ”¯çš„ä»£ç ã€‚ å¯ä»¥ä½¿ç”¨fallthroughå…³é”®å­—æ¥è¾¾åˆ°ç›®çš„ï¼Œfallthroughå¼ºåˆ¶æ‰§è¡Œåé¢çš„(ç´§æŒ¨ç€çš„)ä¸‹ä¸€æ¡åˆ†æ”¯ä»£ç ï¼Œä¸ç®¡æ˜¯caseæˆ–defaultåˆ†æ”¯éƒ½ä¼šæ‰§è¡Œã€‚ fallthroughä¸ä¼šåˆ¤æ–­ä¸‹ä¸€æ¡åˆ†æ”¯çš„è¡¨è¾¾å¼ç»“æœæ˜¯å¦ä¸ºçœŸã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 package main import ( \u0026#34;fmt\u0026#34; ) func main() { switch a := 1; { case a == 1: fmt.Printf(\u0026#34;a == %d\\n\u0026#34;, a) fallthrough case a == 2: fmt.Println(\u0026#34;a == 2\u0026#34;) case a == 3: fmt.Println(\u0026#34;a == 3\u0026#34;) fallthrough case a == 5: fmt.Println(\u0026#34;a == 5\u0026#34;) fallthrough default: fmt.Println(\u0026#34;default\u0026#34;) case a == 4: fmt.Println(\u0026#34;a == 4\u0026#34;) } // Output: // a == 1 // a == 2 } ","permalink":"https://heliu.site/posts/golang/process/switch/","summary":"Golang ä»‹ç»switchçš„ç”¨æ³•ã€‚","title":"æµç¨‹æ§åˆ¶(switch)"},{"content":" selectæ˜¯Goä¸­çš„ä¸€ä¸ªæ§åˆ¶ç»“æ„ï¼Œç±»ä¼¼switchè¯­å¥ã€‚ ä¸»è¦ä½œç”¨æ˜¯å¤„ç†å¼‚æ­¥é€šé“æ“ä½œï¼Œæ‰€æœ‰æƒ…å†µéƒ½ä¼šæ¶‰åŠé€šä¿¡æ“ä½œï¼Œä¸»è¦ç”¨äºchannelæ“ä½œã€‚ å› æ­¤selectä¼šç›‘å¬åˆ†æ”¯è¯­å¥ä¸­é€šé“çš„è¯»å†™æ“ä½œï¼Œå½“åˆ†æ”¯ä¸­çš„é€šé“è¯»å†™æ“ä½œä¸ºéé˜»å¡çŠ¶æ€ï¼ˆå³èƒ½è¯»å†™ï¼‰æ—¶ï¼Œå°†ä¼šè§¦å‘ç›¸åº”çš„åŠ¨ä½œã€‚ selectè¯­å¥ä¼šé€‰æ‹©ä¸€ç»„å¯ä»¥å‘é€æˆ–æ¥æ”¶æ“ä½œä¸­çš„ä¸€ä¸ªåˆ†æ”¯ç»§ç»­æ‰§è¡Œï¼Œselectæ²¡æœ‰æ¡ä»¶è¡¨è¾¾å¼ï¼Œä¸€ç›´ç­‰å¾…caseè¿›å…¥å¯è¿è¡ŒçŠ¶æ€ã€‚ æ€»ç»“ï¼š selectä¸­çš„case`è¯­å¥å¿…é¡»æ˜¯å¯¹é€šé“çš„æ“ä½œã€‚ selectä¸­çš„defaultå­å¥æ€»æ˜¯å¯è¿è¡Œçš„ã€‚ å¦‚æœæœ‰å¤šä¸ªåˆ†æ”¯éƒ½å¯ä»¥è¿è¡Œï¼Œselectä¼šä¼ªéšæœºå…¬å¹³çš„é€‰å‡ºä¸€ä¸ªæ‰§è¡Œï¼Œå…¶ä»–åˆ†æ”¯ä¸ä¼šæ‰§è¡Œã€‚ å¦‚æœæ²¡æœ‰å¯è¿è¡Œçš„åˆ†æ”¯ï¼Œä¸”æœ‰defaultè¯­å¥ï¼Œé‚£ä¹ˆå°±ä¼šæ‰§è¡Œdefaultçš„åŠ¨ä½œã€‚ å¦‚æœæ²¡æœ‰å¯è¿è¡Œçš„åˆ†æ”¯ï¼Œä¸”æ²¡æœ‰defaultè¯­å¥ï¼Œselectå°†é˜»å¡ï¼Œç›´åˆ°æŸä¸ªåˆ†æ”¯å¯ä»¥è¿è¡Œã€‚ å…³äºselectå…³é”®å­—çš„è¿è¡ŒåŸç†åœ¨channelç¯‡ä»‹ç»ã€‚(å¦‚æœæ‚¨è¿˜ä¸ç†Ÿæ‚‰channelï¼Œå‚çœ‹channelåå†é˜…è¯»æœ¬ç¯‡æ–‡ç« ) è¯­æ³•æ ¼å¼ Goç¼–ç¨‹è¯­è¨€ä¸­selectè¯­å¥çš„è¯­æ³•å¦‚ä¸‹ï¼š 1 2 3 4 5 6 7 8 select { case communication clause: statement(s) case communication clause: statement(s) default: statement(s) } ä½¿ç”¨ç¤ºä¾‹ nil channelä½¿ç”¨select defaultç»“æ„ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 package main import \u0026#34;fmt\u0026#34; func main() { var c1, c2, c3 chan int // nil var i1, i2 int // ç”±äºselectgoå‡½æ•°çš„æºä»£ç å¯çŸ¥ï¼Œgoä¼šæŠŠæ‰€æœ‰énilçš„channelç»„æˆä¸€ä¸ªsend+recvé›† // ç„¶åall channel lock ä¼ªéšæœºçš„éå†caseé›†ã€‚ // ç”±äºè¿™é‡Œçš„channeléƒ½æ˜¯nilï¼Œåˆ™ä¸å­˜åœ¨caseé›†ï¼Œç›´æ¥èµ°default select { case i1 = \u0026lt;-c1: fmt.Printf(\u0026#34;received \u0026#34;, i1, \u0026#34; from c1\\n\u0026#34;) case c2 \u0026lt;- i2: fmt.Printf(\u0026#34;sent \u0026#34;, i2, \u0026#34; to c2\\n\u0026#34;) case i3, ok := \u0026lt;-c3: if ok { fmt.Printf(\u0026#34;received \u0026#34;, i3, \u0026#34; from c3\\n\u0026#34;) } else { fmt.Printf(\u0026#34;c3 is closed\\n\u0026#34;) } default: // èµ°é»˜è®¤åˆ†æ”¯ fmt.Printf(\u0026#34;no communication\\n\u0026#34;) } // Output: // no communication } ä¸å­˜åœ¨defaultåˆ†æ”¯æ—¶ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;time\u0026#34; ) func main() { var c1, c2, c3 chan int // nil var i1, i2 int // ç”±äºselectgoå‡½æ•°çš„æºä»£ç å¯çŸ¥ï¼Œgoä¼šæŠŠæ‰€æœ‰énilçš„channelç»„æˆä¸€ä¸ªsend+recvé›† // ç„¶åall channel lock ä¼ªéšæœºçš„éå†caseé›†ã€‚ // ç”±äºè¿™é‡Œåªæœ‰Timer.Cè¿™ä¸ªchanåœ¨caseé›†ä¸­ï¼Œåˆ™è·å–lockç„¶åä»è¿™é‡Œè¯»å–æ•°æ®ï¼Œä¸èƒ½ç«‹åˆ»å®Œæˆåˆ™è¢«æŒ‚èµ·ç­‰å¾…ã€‚ select { case i1 = \u0026lt;-c1: fmt.Printf(\u0026#34;received \u0026#34;, i1, \u0026#34;from c1\\n\u0026#34;) case c2 \u0026lt;- i2: fmt.Printf(\u0026#34;sent \u0026#34;, i2, \u0026#34;to c2\\n\u0026#34;) case i3, ok := (\u0026lt;-c3): if ok { fmt.Printf(\u0026#34;received \u0026#34;, i3, \u0026#34;from c3\\n\u0026#34;) } else { fmt.Printf(\u0026#34;c3 is closed\\n\u0026#34;) } // func After(d Duration) \u0026lt;-chan Time // Afterä¼šåœ¨å¦ä¸€çº¿ç¨‹ç»è¿‡æ—¶é—´æ®µdåå‘è¿”å›å€¼å‘é€å½“æ—¶çš„æ—¶é—´ã€‚ç­‰ä»·äºNewTimer(d).C case \u0026lt;-time.After(time.Second * 3): // è¶…æ—¶é€€å‡º fmt.Println(\u0026#34;request time out\u0026#34;) } // Output: // request time out } å¸¸ç”¨ç”¨æ³• è¶…æ—¶åˆ¤æ–­ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;time\u0026#34; ) var resChan = make(chan int) func main() { test() // request time out // Output: // request time out } func test() { // 1. caseé›†æ˜¯send+recvçš„é›†åˆï¼Œä¸åŒ…å«default // 2. è·å–æ‰€æœ‰ all channel lock // 3. ä¼ªéšæœºéå†æ‰€æœ‰çš„caseé›†ï¼Œå¯»æ‰¾æ˜¯å¦æœ‰ç«‹åˆ»å®Œæˆchannelã€‚ // 4. å¦‚æœéƒ½æ²¡æœ‰åˆ™ä»¥sudogå½¢å¼å°è£…å½“å‰goroutineæŒ‚åœ¨æ‰€æœ‰çš„channelä¸Šï¼Œall channel unlock å†æ¬¡è°ƒåº¦å¾ªç¯ç­‰å¾…å”¤é†’ã€‚ // 5. å½“goroutineè¢«å”¤é†’ï¼Œå¤„ç†æ‰€æœ‰æŒ‚åœ¨channelä¸Šçš„sudogï¼Œç„¶åè¿”å›ï¼Œå› ä¸ºæ•°æ®äº¤æ¢å·²ç»åœ¨å”¤é†’å‰å¤„ç†äº†ã€‚ select { case data := \u0026lt;-resChan:\t// ç­‰å¾…ä»resChanä¸­è¯»å–æ•°æ® doData(data) case \u0026lt;-time.After(time.Second * 3): // 3ç§’åä¼šåƒtime.Cé€šé“ä¸­å†™å…¥å½“å‰æ—¶é—´ï¼Œè¿™é‡Œå¾—åˆ°é€‰ä¸­ fmt.Println(\u0026#34;request time out\u0026#34;) } } func doData(data int) { fmt.Println(\u0026#34;doDataï¼š\u0026#34;, data) } åˆ¤æ–­channelæ˜¯å¦é˜»å¡ã€‚ 1 2 3 4 5 6 7 8 9 10 11 // åœ¨æŸäº›æƒ…å†µä¸‹æ˜¯å­˜åœ¨ä¸å¸Œæœ›channelç¼“å­˜æ»¡äº†çš„éœ€æ±‚çš„ï¼Œå¯ä»¥ç”¨å¦‚ä¸‹æ–¹æ³•åˆ¤æ–­ ch := make (chan int, 5) // ... dataï¼š= 0 // tryLock å½¢å¼ï¼Œæ˜¯å¦èƒ½ç«‹å³å®Œæˆã€‚ select { case ch \u0026lt;- data: default: //åšç›¸åº”æ“ä½œï¼Œæ¯”å¦‚ä¸¢å¼ƒdataã€‚è§†éœ€æ±‚è€Œå®š } selectä½œç”¨åœ¨channel c\u0026lt;-v 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // compiler implements // // select { // case c \u0026lt;- v: // ... foo // default: // ... bar // } // // as // // if selectnbsend(c, v) { // ... foo // } else { // ... bar // } func selectnbsend(c *hchan, elem unsafe.Pointer) (selected bool) { // selectedè¿”å›å€¼ true.è¯¥åˆ†æ”¯è¢«é€‰ä¸­ false.è¯¥åˆ†æ”¯ä¸ä¼šè¢«é€‰ä¸­ return chansend(c, elem, false, getcallerpc()) } v\u0026lt;-c 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 // compiler implements // // select { // case v = \u0026lt;-c: // ... foo // default: // ... bar // } // // as // // if selectnbrecv(\u0026amp;v, c) { // ... foo // } else { // ... bar // } func selectnbrecv(elem unsafe.Pointer, c *hchan) (selected bool) { // chanrecvå‡½æ•°å­˜åœ¨ä¸¤ä¸ªè¿”å›å€¼ å¸ƒå°” // selected è¿”å›å€¼ true.è¯¥åˆ†æ”¯è¢«é€‰ä¸­ false.è¯¥åˆ†æ”¯ä¸ä¼šè¢«é€‰ä¸­ // ç¬¬äºŒä¸ªè¿”å›å€¼ï¼Œå½“å‰æ˜¯å¦è¯»å–æ•°æ®æˆåŠŸï¼Œ false.è¯»å–å¤±è´¥ true.è¯»å–æˆåŠŸ selected, _ = chanrecv(c, elem, false) return } v, ok = \u0026lt;-c 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 // compiler implements // // select { // case v, ok = \u0026lt;-c: // ... foo // default: // ... bar // } // // as // // if c != nil \u0026amp;\u0026amp; selectnbrecv2(\u0026amp;v, \u0026amp;ok, c) { // ... foo // } else { // ... bar // } func selectnbrecv2(elem unsafe.Pointer, received *bool, c *hchan) (selected bool) { // TODO(khr): just return 2 values from this function, now that it is in Go. // chanrecvå‡½æ•°å­˜åœ¨ä¸¤ä¸ªè¿”å›å€¼ å¸ƒå°”å€¼ // selected è¿”å›å€¼ true.è¯¥åˆ†æ”¯è¢«é€‰ä¸­ false.è¯¥åˆ†æ”¯ä¸ä¼šè¢«é€‰ä¸­ // ç¬¬äºŒä¸ªè¿”å›å€¼ï¼Œå½“å‰æ˜¯å¦è¯»å–æ•°æ®æˆåŠŸï¼Œ false.è¯»å–å¤±è´¥ true.è¯»å–æˆåŠŸ selected, *received = chanrecv(c, elem, false) return } ","permalink":"https://heliu.site/posts/golang/process/select/","summary":"Golang selectä»‹ç»ã€‚","title":"æµç¨‹æ§åˆ¶(select)"},{"content":"package åŒ…çš„æ¦‚å¿µ ä½¿ç”¨åŒ…æ¥ç»„ç»‡ç®¡ç†ä»£ç ï¼ŒåŒ…æ˜¯ç»“æ„åŒ–ä»£ç çš„ä¸€ç§æ–¹å¼ã€‚ æ¯ä¸ª.goæ–‡ä»¶éƒ½å¿…é¡»å½’å±äºæŸä¸€ä¸ªåŒ…ï¼Œæ¯ä¸ª.goæ–‡ä»¶éƒ½å¯èƒ½æœ‰init()å‡½æ•°ã€‚ åŒ…ååœ¨æºæ–‡ä»¶ä¸­ç¬¬ä¸€è¡Œé€šè¿‡å…³é”®å­—packageæŒ‡å®šï¼ŒåŒ…åè¦å°å†™ã€‚ 1 package fmt æ¯ä¸ªç›®å½•ä¸‹é¢å¯ä»¥æœ‰å¤šä¸ª.goæ–‡ä»¶ï¼Œè¿™äº›æ–‡ä»¶åªèƒ½å±äºåŒä¸€ä¸ªåŒ…ï¼Œå¦åˆ™ç¼–è¯‘æ—¶ä¼šæŠ¥é”™ã€‚ åŒä¸€ä¸ªåŒ…ä¸‹çš„ä¸åŒ.goæ–‡ä»¶ç›¸äº’ä¹‹é—´å¯ä»¥ç›´æ¥å¼•ç”¨å˜é‡å’Œå‡½æ•°ï¼Œæ‰€ä»¥è¿™äº›æ–‡ä»¶ä¸­å®šä¹‰çš„å…¨å±€å˜é‡å’Œå‡½æ•°ä¸èƒ½é‡åã€‚ Goè¯­è¨€çš„å¯æ‰§è¡Œåº”ç”¨ç¨‹åºå¿…é¡»æœ‰mainåŒ…ï¼Œè€Œä¸”åœ¨mainåŒ…ä¸­å¿…é¡»ä¸”åªèƒ½æœ‰ä¸€ä¸ªmain()å‡½æ•°ã€‚ mainå‡½æ•°æ˜¯åº”ç”¨ç¨‹åºè¿è¡Œå¼€å§‹çš„å…¥å£ï¼Œåœ¨mainåŒ…ä¸­å¯ä»¥ä½¿ç”¨init()å‡½æ•°ã€‚ Goè¯­è¨€ä¸å¼ºåˆ¶è¦æ±‚åŒ…çš„åç§°å’Œæ–‡ä»¶æ‰€åœ¨ç›®å½•åç§°ç›¸åŒï¼Œä½†æ˜¯è¿™ä¸¤è€…æœ€å¥½ä¿æŒç›¸åŒï¼Œå¦åˆ™å¾ˆå®¹æ˜“å¼•èµ·æ­§ä¹‰ã€‚ å› ä¸ºå¯¼å…¥åŒ…çš„æ—¶å€™ä¼šä½¿ç”¨ç›®å½•åä½œä¸ºåŒ…çš„è·¯å¾„ï¼Œè€Œä»£ç ä¸­ä½¿ç”¨æ—¶ï¼Œå´è¦ä½¿ç”¨åŒ…çš„åç§°ã€‚ åŒ…çš„åˆå§‹åŒ– å¯æ‰§è¡Œåº”ç”¨ç¨‹åºçš„åˆå§‹åŒ–å’Œæ‰§è¡Œéƒ½èµ·å§‹äºmainåŒ…ã€‚ å¦‚æœmainåŒ…çš„æºä»£ç ä¸­æ²¡æœ‰åŒ…å«main()å‡½æ•°ï¼Œåˆ™ä¼šå¼•å‘æ„å»ºç¨‹åºé”™è¯¯ undefined: main.mianã€‚ main()å‡½æ•°å³æ²¡æœ‰å‚æ•°ï¼Œä¹Ÿæ²¡æœ‰è¿”å›ç±»å‹ï¼Œinit()å‡½æ•°å’Œmain()å‡½æ•°åœ¨è¿™ä¸€ç‚¹ä¸Šä¸€æ ·ã€‚ å¦‚æœmainåŒ…è¿˜å¯¼å…¥äº†å…¶ä»–çš„åŒ…ï¼Œé‚£ä¹ˆåœ¨ç¼–è¯‘æ—¶ä¼šå°†å®ƒä»¬ä¾æ¬¡å¯¼å…¥ã€‚ æœ‰æ—¶ä¸€ä¸ªåŒ…ä¼šè¢«å¤šä¸ªåŒ…åŒæ—¶å¯¼å…¥ï¼Œé‚£ä¹ˆå®ƒåªä¼šè¢«å¯¼å…¥ä¸€æ¬¡ï¼ˆå¦‚å¾ˆå¤šåŒ…å¯èƒ½éƒ½ä¼šç”¨åˆ°fmtåŒ…ï¼Œä½†å®ƒåªä¼šè¢«å¯¼å…¥ä¸€æ¬¡ï¼Œå› ä¸ºæ²¡æœ‰å¿…è¦å¯¼å…¥å¤šæ¬¡ï¼‰ å½“æ‰€æœ‰è¢«å¯¼å…¥çš„åŒ…éƒ½åŠ è½½å®Œæ¯• å°±ä¼šå¯¹mainåŒ…ä¸­çš„åŒ…çº§å¸¸é‡å’Œå˜é‡è¿›è¡Œåˆå§‹åŒ– ç„¶åæ‰§è¡ŒmainåŒ…ä¸­çš„init()å‡½æ•°ï¼Œæœ€åæ‰§è¡Œmain()å‡½æ•° å¯¼å…¥åŒ…çš„é¡ºåºï¼šå¯¼å…¥åŒ…æ–‡ä»¶ï¼Œå¯¹(å…¨å±€)å¸¸é‡å’Œå˜é‡è¿›è¡Œåˆå§‹åŒ–ï¼Œç„¶åæ‰§è¡Œinit()å‡½æ•°ï¼ˆå¦‚æœå‡½æ•°å­˜åœ¨çš„æƒ…å†µä¸‹ï¼‰ Goè¯­è¨€ä¸­çš„init()å‡½æ•°å¸¸ç”¨äºåŒ…çš„åˆå§‹åŒ–ï¼Œè¯¥å‡½æ•°æ˜¯Goè¯­è¨€çš„ä¸€ä¸ªé‡è¦ç‰¹å¾ã€‚ initå‡½æ•°æ˜¯ç”¨äºç¨‹åºæ‰§è¡Œå‰è¿›è¡ŒåŒ…çš„åˆå§‹åŒ–çš„å‡½æ•°ï¼Œä¾‹å¦‚åˆå§‹åŒ–åŒ…é‡Œçš„å˜é‡ç­‰ã€‚ æ¯ä¸ªåŒ…å¯ä»¥æ‹¥æœ‰å¤šä¸ªinitå‡½æ•°ï¼Œï¼ˆåŒä¸€ä¸ªåŒ…ä¸‹ä¸åŒçš„.goæ–‡ä»¶ä¸­éƒ½å…è®¸å®šä¹‰init()å‡½æ•°ï¼‰ã€‚ åŒä¸€ä¸ªåŒ…ä¸­çš„å¤šä¸ªinit()å‡½æ•°çš„æ‰§è¡Œé¡ºåºæ˜¯éšæœºçš„ã€‚ ä¸åŒåŒ…çš„init()å‡½æ•°æŒ‰ç…§åŒ…å¯¼å…¥çš„ä¾èµ–å…³ç³»å†³å®šè¯¥å‡½æ•°çš„æ‰§è¡Œé¡ºåºã€‚ init()å‡½æ•°ä¸èƒ½è¢«å…¶ä»–å‡½æ•°è°ƒç”¨ï¼Œå…¶åœ¨mainå‡½æ•°æ‰§è¡Œä¹‹å‰ï¼Œè‡ªåŠ¨è¢«è°ƒç”¨ã€‚ åŒ…çš„å¯¼å…¥ Goè¯­è¨€ç¨‹åºé€šè¿‡å¯¼å…¥importå…³é”®å­—å°†ä¸€ç»„åŒ…é“¾æ¥åœ¨ä¸€èµ·é€šè¿‡å¯¼å…¥åŒ…ä¸ºç¨‹åºæ‰€ä½¿ç”¨ï¼Œç¨‹åºä¸­æœªä½¿ç”¨çš„åŒ…ï¼Œä¸èƒ½å¯¼å…¥è¿›æ¥ã€‚ å¯¼å…¥æ“ä½œä¼šä½¿ç”¨ç›®å½•åä½œä¸ºåŒ…çš„è·¯å¾„è€Œä¸æ˜¯åŒ…åï¼Œå®é™…åº”ç”¨ä¸­ä¸€èˆ¬ä¼šä¿æŒä¸¤è€…ä¸€è‡´ã€‚ ä¾‹å¦‚æ ‡å‡†åŒ…ä¸­å®šä¹‰çš„bigåŒ…ï¼špackage big;å¯¼å…¥æ—¶è¯­å¥ä¸ºimport \u0026quot;math/big\u0026quot;ã€‚ å¯¼å…¥æ—¶æºä»£ç åœ¨$GOROOTç›®å½•ä¸‹çš„src/math/bigç›®å½•ä¸­ã€‚ ç¨‹åºä»£ç ä½¿ç”¨big.Intæ—¶ï¼ŒbigæŒ‡çš„æ˜¯.goæ–‡ä»¶ä¸­å®šä¹‰çš„åŒ…åç§°ã€‚ å½“å¯¼å…¥å¤šä¸ªåŒ…æ—¶ï¼Œä¸€èˆ¬æŒ‰ç…§å­—æ¯é¡ºåºæ’åˆ—åŒ…åç§°ã€‚ ä¸ºé¿å…åç§°å†²çªï¼ŒåŒä¸€åŒ…ä¸­æ‰€æœ‰å¯¹è±¡çš„æ ‡è¯†ç¬¦å¿…é¡»å”¯ä¸€ï¼Œä½†æ˜¯ç›¸åŒçš„æ ‡è¯†ç¬¦å¯ä»¥åœ¨ä¸åŒçš„åŒ…ä¸­ä½¿ç”¨ï¼Œå› ä¸ºå¯ä»¥ä½¿ç”¨åŒ…åæ¥åŒºåˆ†å®ƒä»¬ã€‚ 1 2 3 package main import \u0026#34;context\u0026#34; // åŠ è½½contextåŒ… å¯¼å…¥å¤šä¸ªåŒ…çš„å¸¸è§çš„æ–¹å¼ã€‚ 1 2 3 4 import ( \u0026#34;fmt\u0026#34; \u0026#34;net/http\u0026#34; ) 1 2 // è°ƒç”¨å¯¼å…¥çš„åŒ…å‡½æ•°çš„ä¸€èˆ¬æ–¹å¼ fmt.Println(\u0026#34;hello world!\u0026#34;) ä¸‰ç§ç‰¹æ®Šçš„åŒ…å¯¼å…¥ import (. \u0026quot;fmt\u0026quot;) ç‚¹æ“ä½œå«ä¹‰æ˜¯åŒ…å¯¼å…¥ä¹‹åï¼Œåœ¨è°ƒç”¨è¿™ä¸ªåŒ…çš„å‡½æ•°æ—¶ï¼Œå¯ä»¥çœç•¥å‰ç¼€çš„åŒ…åã€‚ å¦‚fmt.Println(\u0026quot;hello world\u0026quot;)å¯ä»¥å†™æˆPrintln(\u0026quot;hello world\u0026quot;)ã€‚ import (f \u0026quot;fmt\u0026quot;) åˆ«åæ“ä½œå°±æ˜¯å¯ä»¥æŠŠåŒ…å‘½åæˆå¦å¤–ä¸€ä¸ªå®¹æ˜“è®°ä½çš„åå­—ã€‚ å¦‚fmt.Println(\u0026quot;hello world\u0026quot;)å¯ä»¥å†™æˆf.Println(\u0026quot;hello world\u0026quot;)ã€‚ import (_ \u0026quot;fmt\u0026quot;) _æ“ä½œæ˜¯å¼•å…¥æŸä¸ªåŒ…ï¼Œä½†ä¸ç›´æ¥ä½¿ç”¨åŒ…é‡Œçš„å‡½æ•°ï¼Œè€Œæ˜¯è°ƒç”¨è¯¥åŒ…é‡Œé¢çš„initå‡½æ•°ã€‚ æœ‰æ—¶åœ¨å¼€å‘ä¸­ç”±äºæŸç§åŸå› æŸä¸ªåŸæ¥å¯¼å…¥çš„åŒ…ç°åœ¨ä¸åœ¨ä½¿ç”¨ï¼Œä¹Ÿå¯ä»¥é‡‡ç”¨è¿™ç§æ–¹å¼å¤„ç†ã€‚ 1 2 3 4 import ( _ \u0026#34;fmt\u0026#34; _ \u0026#34;github.com/go-sql-driver/mysql\u0026#34; ) æ ‡å‡†åº“ åœ¨Goè¯­è¨€çš„å®‰è£…ç›®å½•é‡ŒåŒ…å«æ ‡å‡†åº“çš„å„ç§åŒ…ï¼Œåœ¨$GOROOT/srcä¸­å¯ä»¥çœ‹åˆ°æºç ï¼Œå¯ä»¥æ ¹æ®æƒ…å†µè‡ªè¡Œé‡æ–°ç¼–è¯‘ã€‚ è®¿é—®https://golang.google.cn/pkg/#stdlibäº†è§£æ›´å¤šè¯¦æƒ…ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 unsafe: åŒ…å«äº†ä¸€äº›æ‰“ç ´Gpè¯­è¨€â€œç±»å‹å®‰å…¨â€çš„å‘½ä»¤ï¼Œä¸€è¾¹çš„ç¨‹åºä¸­ä¸ä¼šè¢«è°ƒç”¨ï¼Œå¯ç”¨åœ¨C++ç¨‹åºçš„è°ƒè¯•ä¸­ syscall-os-os/exec: os: æä¾›ç»™æˆ‘ä»¬ä¸€ä¸ªå¹³å°æ— å…³æ€§çš„æ“ä½œç³»ç»ŸåŠŸèƒ½æ¥å£ï¼Œé‡‡ç”¨ç±»ä¼¼UNIXè®¾è®¡ï¼Œéšè—äº†ä¸åŒæ“ä½œç³»ç»Ÿé—´çš„å·®å¼‚ï¼Œè®©ä¸åŒçš„æ–‡ä»¶ç³»ç»Ÿå’Œæ“ä½œç³»ç»Ÿå¯¹è±¡è¡¨ç°ä¸€è‡´ os/exec: æä¾›è¿è¡Œå¤–éƒ¨æ“ä½œç³»ç»Ÿå‘½ä»¤å’Œç¨‹åºæ–¹å¼ syscall: åº•å±‚çš„å¤–éƒ¨åŒ…ï¼Œæä¾›äº†æ“ä½œç³»ç»Ÿåº•å±‚è°ƒç”¨çš„åŸºæœ¬æ¥å£ archive/tar å’Œ /zip-compress: å‹ç¼©(è§£å‹ç¼©)æ–‡ä»¶åŠŸèƒ½ fmt-io-bufio-path/filepath-flag: fmt: æä¾›æ ¼å¼åŒ–è¾“å…¥è¾“å‡ºçš„åŠŸèƒ½ io: æä¾›åŸºæœ¬è¾“å…¥è¾“å‡ºåŠŸèƒ½ï¼Œå¤§å¤šæ•°æ˜¯å›´ç»•ç³»ç»ŸåŠŸèƒ½çš„å°è£… bufio: ç¼“å†²è¾“å…¥è¾“å‡ºåŠŸèƒ½çš„å°è£… path/filepath: ç”¨æ¥æ“ä½œåœ¨å½“å‰ç³»ç»Ÿä¸­çš„ç›®æ ‡æ–‡ä»¶åè·¯å¾„ flag: å¯¹å‘½ä»¤è¡Œå‚æ•°çš„æ“ä½œ strings-strconv-unicode-regexp-bytes: strings: æä¾›å¯¹å­—ç¬¦çš„æ“ä½œ strconv: æä¾›å°†å­—ç¬¦ä¸²è½¬æ¢ä¸ºåŸºç¡€ç±»å‹çš„åŠŸèƒ½ unicode: ä¸ºunicodeå‹çš„å­—ç¬¦ä¸²æä¾›ç‰¹æ®Šçš„åŠŸèƒ½ regexp: æ­£åˆ™è¡¨è¾¾å¼åŠŸèƒ½ bytes: æä¾›å¯¹å­—ç¬¦å‹åˆ†ç‰‡çš„æ“ä½œ math-math/cmath-math/big-math/rand-sort: math: åŸºæœ¬çš„æ•°å­¦å‡½æ•° math/cmath: å¯¹å¤æ•°çš„æ“ä½œ math/rand: ä¼ªéšæœºæ•°ç”Ÿæˆ sort: ä¸ºæ•°ç»„æ’åºå’Œè‡ªå®šä¹‰é›†åˆ math/big: å¤§æ•°çš„å®ç°å’Œè®¡ç®— container-/list-ring-heap: å®ç°å¯¹é›†åˆçš„æ“ä½œ list: åŒé“¾è¡¨ ring: ç¯å½¢é“¾è¡¨ time-log: time: æ—¥æœŸå’Œæ—¶é—´çš„åŸºæœ¬æ“ä½œ log: è®°å½•ç¨‹åºè¿è¡Œæ—¶äº§ç”Ÿçš„æ—¥å¿— encoding/JSON-encoding/xml-text/template: encoding/json: è¯»å–å¹¶è§£ç å’Œå†™å…¥å¹¶ç¼–ç jsonæ•°æ® encoding/xml: ç®€å•çš„XML1.0è§£æå™¨ text/template: ç”ŸæˆåƒHTMLä¸€æ ·çš„æ•°æ®ä¸æ–‡æœ¬æ··åˆçš„æ•°æ®é©±åŠ¨æ¨¡æ¿ net-net/http-html: net: ç½‘ç»œæ•°æ®çš„åŸºæœ¬æ“ä½œ http: æä¾›äº†ä¸€ä¸ªå¯æ‰©å±•çš„HTTPæœåŠ¡å™¨å’Œå®¢æˆ·ç«¯ï¼Œè§£æHTTPè¯·æ±‚å’Œå›å¤ html: HTML5è§£æå™¨ runtime: Goç¨‹åºè¿è¡Œæ—¶çš„äº¤äº’æ“ä½œï¼Œä¾‹å¦‚åƒåœ¾å›æ”¶å’Œåç¨‹åˆ›å»º reflect: å®ç°é€šè¿‡ç¨‹åºè¿è¡Œæ—¶åå°„ï¼Œè®©ç¨‹åºæ“ä½œä»»æ„ç±»å‹çš„å˜é‡ ä»githubå®‰è£…åŒ… å¦‚æœæƒ³å®‰è£…githubä¸Šçš„é¡¹ç›®åˆ°æœ¬åœ°è®¡ç®—æœºï¼Œå¯æ‰“å¼€ç»ˆç«¯æ‰§è¡Œï¼šgo get -u github.com/ffhelicopter/tmmã€‚ ç°åœ¨è¿™å°è®¡ç®—æœºä¸Šçš„å…¶ä»–Goå¼•ç”¨ç¨‹åºä¹Ÿå¯ä»¥é€šè¿‡å¯¼å…¥è·¯å¾„github.com/ffhelicopter/tmmæ¥ä½¿ç”¨ã€‚ import \u0026quot;github.com/ffhelicopter/tmm\u0026quot; Goå¯¹åŒ…çš„ç‰ˆæœ¬ç®¡ç†ä¸æ˜¯å¾ˆå‹å¥½ï¼Œè‡³å°‘åœ¨go1.10å‰æ˜¯å¦‚æ­¤ï¼Œä¸è¿‡ç°åœ¨ç¬¬ä¸‰æ–¹é¡¹ç›®åšå¾—ä¸é”™. æœ‰å…´è¶£çš„è¯»è€…å¯ä»¥äº†è§£ä¸€ä¸‹ï¼ˆglideã€godepã€govendorï¼‰. Gomodulesæ˜¯1.11ç‰ˆæœ¬è§£å†³â€œåŒ…ä¾èµ–ç®¡ç†â€çš„å®éªŒæ€§æŠ€æœ¯æ–¹æ¡ˆï¼Œåé¢ç« èŠ‚å­¦ä¹ ã€‚ å¯¼å…¥å¤–éƒ¨å®‰è£…åŒ… å¦‚æœè¦åœ¨åº”ç”¨ä¸­ä½¿ç”¨ä¸€ä¸ªæˆ–å¤šä¸ªå¤–éƒ¨åŒ…ï¼Œå¯ä»¥ä½¿ç”¨go installåœ¨æœ¬åœ°è®¡ç®—æœºä¸Šå®‰è£…å®ƒä»¬ã€‚ go installæ˜¯è‡ªåŠ¨åŒ…å®‰è£…å·¥å…·ï¼Œå¦‚éœ€è¦å°†åŒ…å®‰è£…åˆ°æœ¬åœ°ï¼Œå®ƒä¼šä»è¿œç«¯ä»“åº“ä¸‹è½½åŒ…ï¼Œå®Œæˆæ£€å‡ºã€ç¼–è¯‘å’Œå®‰è£…ã€‚ åŒ…å®‰è£…çš„å…ˆå†³æ¡ä»¶æ˜¯è¦è‡ªåŠ¨å¤„ç†åŒ…è‡ªèº«ä¾èµ–å…³ç³»ï¼Œè¢«ä¾èµ–çš„åŒ…ä¹Ÿä¼šå®‰è£…åˆ°å­ç›®å½•ä¸‹ã€‚ å¦‚æœæƒ³ä½¿ç”¨https://github.com/gocolly/collyè¿™ç§æ‰˜ç®¡åœ¨Google Codeã€GitHubå’ŒLaunchpadç­‰ä»£ç ç½‘ç«™ä¸Šçš„åŒ…ã€‚ ä¹Ÿå¯ä»¥é€šè¿‡å¦‚ä¸‹å‘½ä»¤å®‰è£…ï¼šgo install github.com/gocolly/collyã€‚ å°†ä¸€ä¸ªåä¸ºgithub.com/gocolly/collyçš„åŒ…å®‰è£…åœ¨$GoPATH/pkg/ç›®å½•ä¸‹ã€‚ go install/buildç”¨æ¥ç¼–è¯‘åŒ…å’Œä¾èµ–çš„åŒ…ï¼ŒåŒºåˆ«å¦‚ä¸‹ï¼š go buildåªå¯¹mainåŒ…æœ‰æ•ˆï¼Œåœ¨å½“å‰ç›®å½•ç¼–è¯‘ç”Ÿæˆä¸€ä¸ªå¯æ‰§è¡Œçš„äºŒè¿›åˆ¶æ–‡ä»¶ï¼Œä¾èµ–åŒ…ç”Ÿæˆçš„é™æ€åº“æ–‡ä»¶æ”¾åœ¨$GOOATH/pkgã€‚ go installä¸€èˆ¬ç”Ÿæˆé™æ€æ–‡ä»¶ï¼Œæ”¾åœ¨$GOPATH/pkgç›®å½•ä¸‹ï¼Œæ–‡ä»¶æ‰©å±•åä¸ºaã€‚ å¦‚æœä¸ºmainåŒ…ï¼Œè¿è¡Œgo buildåˆ™ä¼šåœ¨$GOPATH/binç”Ÿæˆä¸€ä¸ªå¯æ‰§è¡Œçš„äºŒè¿›åˆ¶æ–‡ä»¶ã€‚ ä½¿ç”¨Godoc åœ¨ç¨‹åºä¸­ä¸€èˆ¬éƒ½ä¼šä½¿ç”¨æ³¨é‡Šï¼ŒæŒ‰ç…§ä¸€å®šè§„åˆ™ï¼ŒGodocå·¥å…·ä¼šæ”¶é›†è¿™äº›æ³¨é‡Šå¹¶äº§ç”Ÿä¸€ä¸ªæŠ€æœ¯æ–‡æ¡£ã€‚ Godocä¼šä¸ºæ¯ä¸ªæ–‡ä»¶ç”Ÿæˆä¸€ç³»åˆ—çš„ç½‘é¡µã€‚ è®¿é—®Godocæ–‡æ¡£çš„æ–¹æ³•æ˜¯ï¼š å‘½ä»¤è¡Œä¸‹è¿›å…¥ç›®å½•å¹¶è¾“å…¥å‘½ä»¤ï¼šgodoc -http=:6060 -goroot=\u0026quot;.\u0026quot;ã€‚ ç„¶ååœ¨æµè§ˆå™¨ä¸­æ‰“å¼€åœ°å€ï¼šhttp://localhost:6060ã€‚ æ­¤æ—¶ä¼šçœ‹åˆ°æœ¬åœ°çš„Godocé¡µé¢ï¼Œä»å·¦åˆ°å³ä¸€æ¬¡æ˜¾ç¤ºå‡ºç›®å½•ä¸­çš„åŒ…ã€‚ æˆ–è€…ç›´æ¥åœ¨æµè§ˆå™¨ä¸­æ‰“å¼€åœ°å€http://localhost:6060/pkg/go42/chapter-4/4.2/1/ã€‚ Goç¨‹åºçš„ç¼–è¯‘ åœ¨Goè¯­è¨€ä¸­ï¼Œå’Œç¼–è¯‘æœ‰å…³çš„å‘½ä»¤ä¸»è¦æ˜¯go runã€go buildã€go installè¿™ä¸‰ä¸ªå‘½ä»¤ã€‚ go runåªèƒ½ä½œç”¨äºmainåŒ…æ–‡ä»¶ã€‚ å…ˆè¿è¡Œcompileå‘½ä»¤ç”Ÿæˆ.aæ–‡ä»¶ã€‚ ç„¶åé“¾æ¥å‘½ä»¤ç”Ÿæˆæœ€ç»ˆå¯æ‰§è¡Œæ–‡ä»¶å¹¶è¿è¡Œç¨‹åºï¼Œæ­¤è¿‡ç¨‹ä¸­äº§ç”Ÿçš„æ˜¯ä¸´æ—¶æ–‡ä»¶ã€‚ åœ¨go runé€€å‡ºå‰ä¼šåˆ é™¤è¿™äº›ä¸´æ—¶æ–‡ä»¶ï¼ˆå«.aæ–‡ä»¶å’Œå¯æ‰§è¡Œæ–‡ä»¶ï¼‰ã€‚ æœ€åç›´æ¥åœ¨å‘½ä»¤è¡Œè¾“å‡ºç¨‹åºæ‰§è¡Œç»“æœã€‚ go runå‘½ä»¤åœ¨ç¬¬äºŒæ¬¡æ‰§è¡Œçš„æ—¶å€™ï¼Œå¦‚æœå‘ç°å¯¼å…¥çš„ä»£ç åŒ…æ²¡æœ‰å‘ç”Ÿå˜åŒ–ã€‚ åˆ™ä¸ä¼šå†æ¬¡ç¼–è¯‘è¿™ä¸ªå¯¼å…¥çš„ä»£ç åŒ…ï¼Œè€Œæ˜¯ç›´æ¥è¿›è¡Œé“¾æ¥ç”Ÿæˆæœ€ç»ˆå¯æ‰§è¡Œæ–‡ä»¶å¹¶è¿è¡Œç¨‹åºã€‚ go installç”¨äºç¼–è¯‘å¹¶å®‰è£…æŒ‡å®šçš„ä»£ç åŒ…åŠå®ƒä»¬çš„ä¾èµ–åŒ…ã€‚ å¹¶ä¸”å°†ç¼–è¯‘åç”Ÿæˆçš„å¯æ‰§è¡Œæ–‡ä»¶æ”¾åˆ°binç›®å½•ä¸‹ï¼ˆ$GOPATH/binï¼‰ã€‚ ç¼–è¯‘åçš„åŒ…æ–‡ä»¶æ”¾åˆ°å½“å‰å·¥ä½œåŒºçš„pkgçš„å¹³å°ç›¸å…³ç›®å½•ä¸‹ã€‚ go buildç”¨äºç¼–è¯‘æŒ‡å®šçš„ä»£ç åŒ…ä»¥åŠå®ƒä»¬çš„ä¾èµ–åŒ…ã€‚ å¦‚æœç”¨æ¥ç¼–è¯‘émainåŒ…çš„æºç ï¼Œåˆ™åªåšæ£€æŸ¥æ€§çš„ç¼–è¯‘ï¼Œè€Œä¸ä¼šè¾“å‡ºä»»ä½•ç»“æœæ–‡ä»¶ã€‚ å¦‚æœæ˜¯ä¸€ä¸ªå¯æ‰§è¡Œç¨‹åºçš„æºç ï¼ˆå³mainåŒ…ï¼‰ï¼Œè¿‡ç¨‹ä¸go runå¤§ä½“ç›¸åŒï¼Œåªæ˜¯ä¼šåœ¨å½“å‰ç›®å½•ç”Ÿæˆä¸€ä¸ªå¯æ‰§è¡Œæ–‡ä»¶ã€‚ ä½¿ç”¨go buildæ˜¯æœ‰ä¸€ä¸ªåœ°æ–¹æ³¨æ„ï¼š å¯¹å¤–å‘å¸ƒç¼–è¯‘æ–‡ä»¶æ—¶å¦‚æœä¸å¸Œæœ›è¢«äººçœ‹åˆ°æºä»£ç ï¼Œå¯ä½¿ç”¨go build -ldflagså‘½ä»¤ã€‚ è®¾ç½®å‚æ•°ã€-ldflags \u0026quot;-w -s\u0026quot;ã€‘å†ç¼–è¯‘å‘å¸ƒï¼Œè¿™æ ·ä½¿ç”¨gdbè°ƒè¯•æ—¶æ— æ³•çœ‹åˆ°æºä»£ç ã€‚ GO111MODULE Go 1.11æ–°å¢äº†å¯¹æ¨¡å—çš„æ”¯æŒï¼Œå¸Œæœ›å€Ÿæ­¤è§£å†³â€œåŒ…ä¾èµ–ç®¡ç†â€é—®é¢˜ã€‚ å¯ä»¥é€šè¿‡è®¾ç½®ç¯å¢ƒå˜é‡GO111MODULEæ¥å¼€å¯æˆ–å…³é—­æ¨¡å—æ”¯æŒï¼Œå®ƒæœ‰ä¸‰ä¸ªå¯é€‰å€¼ï¼šoffã€onã€autoï¼Œé»˜è®¤å€¼æ˜¯autoã€‚ GO111MODULE = off æ— æ¨¡å—æ”¯æŒï¼Œgoä¼šä»GOPATHå’Œvendoræ–‡ä»¶å¤¹å¯»æ‰¾åŒ…ã€‚ GO111MODEL = on æ¨¡å—æ”¯æŒï¼Œgoä¼šä»GOPATHå’Œvendoræ–‡ä»¶å¤¹ï¼Œå€¼æ ¹æ®go.modä¸‹è½½ä¾èµ–ã€‚ GO111MODEL = auto åœ¨$GOPATH/srcå¤–é¢ä¸”æ ¹ç›®å½•æœ‰go.modæ–‡ä»¶æ—¶ï¼Œå¼€å¯æ¨¡å—æ”¯æŒã€‚ ","permalink":"https://heliu.site/posts/golang/package/bag/","summary":"Golang åŒ…ä»‹ç»ã€‚","title":"package"},{"content":" ç”¨æ³•ï¼šgo mod \u0026lt;command\u0026gt; [arguments]ã€‚ commandæ”¯æŒå‘½ä»¤åˆ—è¡¨ï¼š å‘½ä»¤ go mod \u0026lt;command\u0026gt; ä½œç”¨ go mod init ç”Ÿæˆ go.mod æ–‡ä»¶ go mod download ä¸‹è½½ go.mod æ–‡ä»¶ä¸­æŒ‡æ˜çš„æ‰€æœ‰ä¾èµ– go mod tidy æ•´ç†ç°æœ‰çš„ä¾èµ– go mod graph æŸ¥çœ‹ç°æœ‰çš„ä¾èµ–ç»“æ„ go mod edit ç¼–è¾‘ go.mod æ–‡ä»¶ go mod vendor å¯¼å‡ºé¡¹ç›®æ‰€æœ‰çš„ä¾èµ–åˆ°vendorç›®å½• go mod verify æ ¡éªŒä¸€ä¸ªæ¨¡å—æ˜¯å¦è¢«ç¯¡æ”¹è¿‡ go mod why æŸ¥çœ‹ä¸ºä»€ä¹ˆéœ€è¦ä¾èµ–æŸæ¨¡å— go mod init ç”¨æ³•ï¼šgo mod init [module-path]ã€‚ ç¤ºä¾‹ï¼š # åˆå§‹åŒ–å½“å‰ç›®å½•å¹¶åˆ›å»ºä¸€ä¸ªgo.modæ–‡ä»¶ï¼Œæ¨¡å—è·¯å¾„æ ¹æ®å…¶ä»–æ¡ä»¶æ¨æ–­åˆ¤æ–­ $ go mod init # åˆå§‹åŒ–å½“å‰ç›®å½•å¹¶åˆ›å»ºä¸€ä¸ªgo.modæ–‡ä»¶ï¼Œæ¨¡å—è·¯å¾„ä¸ºexample.com/m $ go mod init example.com/m ä»‹ç»ï¼š go mod initå‘½ä»¤åœ¨å½“å‰ç›®å½•ä¸­åˆå§‹åŒ–å¹¶å†™å…¥ä¸€ä¸ªæ–°çš„go.modæ–‡ä»¶ï¼Œå®é™…ä¸Šåˆ›å»ºäº†ä¸€ä¸ªä»¥å½“å‰ç›®å½•ä¸ºæ ¹çš„æ–°æ¨¡å—ã€‚ go.modæ–‡ä»¶å¿…é¡»ä¸å­˜åœ¨æ—¶æ‰§è¡Œä¸Šé¢å‘½ä»¤ï¼Œå¦åˆ™ä¼šæç¤ºgo.modæ–‡ä»¶å·²å­˜åœ¨æç¤ºã€‚ å¦‚å½“å‰å­˜åœ¨ä¸€ä¸ªç©ºé¡¹ç›®demoï¼Œåœ¨demoç›®å½•ä¸‹æ‰§è¡Œgo mod init gitee.com/bms/demoï¼Œä¼šç”Ÿæˆå¦‚ä¸‹go.modæ–‡ä»¶ï¼Œå½“å‰goç‰ˆæœ¬æ˜¯go1.16.3ã€‚ module gitee.com/bms/demo go 1.16 initæ¥å—ä¸€ä¸ªå¯é€‰å‚æ•°ï¼Œå³æ–°æ¨¡å—çš„æ¨¡å—è·¯å¾„ï¼Œæœ‰å…³é€‰æ‹©æ¨¡å—è·¯å¾„çš„è¯´æ˜ï¼Œè¯·å‚é˜…æ¨¡å—è·¯å¾„ã€‚ å¦‚æœçœç•¥äº†æ¨¡å—è·¯å¾„å‚æ•°ï¼Œinitå°†å°è¯•ä½¿ç”¨.goæ–‡ä»¶ã€vendoringå·¥å…·é…ç½®æ–‡ä»¶å’Œå½“å‰ç›®å½•ï¼ˆå¦‚æœåœ¨GOPATHä¸­ï¼‰ä¸­çš„å¯¼å…¥æ³¨é‡Šæ¥æ¨æ–­æ¨¡å—è·¯å¾„ã€‚ å¦‚æœå­˜åœ¨vendoringå·¥å…·çš„é…ç½®æ–‡ä»¶ï¼Œinitå°†å°è¯•ä»ä¸­å¯¼å…¥æ¨¡å—éœ€æ±‚ã€‚ initæ”¯æŒä»¥ä¸‹é…ç½®æ–‡ä»¶ï¼š GLOCKFILE (Glock) Godeps/Godeps.json (Godeps) Gopkg.lock (dep) dependencies.tsv (godeps) glide.lock (glide) vendor.conf (trash) vendor.yml (govend) vendor/manifest (gvt) vendor/vendor.json (govendor) Vendoringå·¥å…·é…ç½®æ–‡ä»¶æ— æ³•å§‹ç»ˆä»¥å®Œç¾çš„ä¿çœŸåº¦è¿›è¡Œç¿»è¯‘ã€‚ ä¾‹å¦‚ï¼ŒåŒä¸€ä¸ªä»“åº“ä¸­çš„å¤šä¸ªåŒ…åœ¨ä¸åŒç‰ˆæœ¬ä¸­å¯¼å…¥ï¼Œè€Œä»“åº“ä¸­åªåŒ…å«ä¸€ä¸ªæ¨¡å—ï¼Œé‚£ä¹ˆå¯¼å…¥çš„go.modå°±åªèƒ½éœ€è¦ä¸€ä¸ªç‰ˆæœ¬çš„æ¨¡å—ã€‚ æ‚¨å¯èƒ½å¸Œæœ›è¿è¡Œgo list -m allä»¥æ£€æŸ¥æ„å»ºåˆ—è¡¨ä¸­çš„æ‰€æœ‰ç‰ˆæœ¬ï¼Œå¹¶è¿è¡Œgo mod tidyä»¥æ·»åŠ ç¼ºå°‘çš„éœ€æ±‚å¹¶åˆ é™¤æœªä½¿ç”¨çš„éœ€æ±‚ã€‚ go mod download å°†å‘½åçš„æ¨¡å—ä¸‹è½½åˆ°æ¨¡å—ç¼“å­˜ä¸­ï¼ˆæ¨¡å—ç¼“å­˜å‚è€ƒå®˜æ–¹æ¨¡å—å‚è€ƒæ–‡æ¡£ï¼‰ã€‚ å‚æ•°å¯ä»¥æ˜¯æ¨¡å—è·¯å¾„æˆ–æ¨¡å—æ¨¡å¼ï¼Œé€‰æ‹©ä¸»æ¨¡å—çš„ä¾èµ–é¡¹æˆ–è¡¨å•çš„ç‰ˆæœ¬æŸ¥è¯¢path@versionã€‚ ä¸å¸¦å‚æ•°ï¼Œdownloadé€‚ç”¨äºä¸»æ¨¡å—çš„æ‰€æœ‰ä¾èµ–é¡¹ã€‚ è¯¥goå‘½ä»¤å°†åœ¨æ­£å¸¸æ‰§è¡ŒæœŸé—´æ ¹æ®éœ€è¦è‡ªåŠ¨ä¸‹è½½æ¨¡å—ã€‚ go mod downloadå‘½ä»¤ä¸»è¦ç”¨äºé¢„å¡«å……æ¨¡å—ç¼“å­˜æˆ–åŠ è½½è¦ç”±æ¨¡å—ä»£ç†æœåŠ¡çš„æ•°æ®ã€‚ é»˜è®¤æƒ…å†µä¸‹ï¼Œdownloadä¸å‘æ ‡å‡†è¾“å‡ºå†™å…¥ä»»ä½•å†…å®¹ã€‚å®ƒå°†è¿›åº¦æ¶ˆæ¯å’Œé”™è¯¯æ‰“å°åˆ°æ ‡å‡†é”™è¯¯ã€‚ ç”¨æ³•ï¼šgo mod download [-json] [-x] [modules] -jsonï¼š -jsonï¼šdownloadå°†ä¸€ç³»åˆ—JSONå¯¹è±¡æ‰“å°åˆ°æ ‡å‡†è¾“å‡ºï¼Œæè¿°æ¯ä¸ªä¸‹è½½çš„æ¨¡å—ï¼ˆæˆ–å¤±è´¥ï¼‰ å¯¹åº”å¦‚ä¸‹ç»“æ„ï¼š type Module struct { Path string // æ¨¡å—è·¯å¾„ Version string // æ¨¡å—ç‰ˆæœ¬ Error string // é”™è¯¯æ¨¡æ¿æè¿° Info string // ç¼“å­˜çš„ .info æ–‡ä»¶çš„ç»å¯¹è·¯å¾„ GoMod string // ç¼“å­˜ .mod æ–‡ä»¶çš„ç»å¯¹è·¯å¾„ Zip string // ç¼“å­˜çš„ .zip æ–‡ä»¶çš„ç»å¯¹è·¯å¾„ Dir string // ç¼“å­˜æºæ ¹ç›®å½•çš„ç»å¯¹è·¯å¾„ Sum string // checksumè·¯å¾„ï¼Œç‰ˆæœ¬ï¼ˆæ¯”å¦‚åœ¨go.sumï¼‰ GoModSum string // go.modçš„checksumï¼ˆæ¯”å¦‚åœ¨go.sumï¼‰ -xï¼šdownloadæ‰“å°å‘½ä»¤downloadæ‰§è¡Œåˆ°æ ‡å‡†é”™è¯¯ ç¤ºä¾‹ï¼š $ go mod download -json -x gitee.com/phpbms/demo { \u0026#34;Path\u0026#34;: \u0026#34;gitee.com/phpbms/demo\u0026#34;, \u0026#34;Version\u0026#34;: \u0026#34;v0.0.0-20211021090521-71a745ffbccb\u0026#34;, \u0026#34;Info\u0026#34;: \u0026#34;/mnt/g/Go/worker/pkg/mod/cache/download/gitee.com/phpbms/demo/@v/v0.0.0-20211021090521-71a745ffbccb.info\u0026#34;, \u0026#34;GoMod\u0026#34;: \u0026#34;/mnt/g/Go/worker/pkg/mod/cache/download/gitee.com/phpbms/demo/@v/v0.0.0-20211021090521-71a745ffbccb.mod\u0026#34;, \u0026#34;Zip\u0026#34;: \u0026#34;/mnt/g/Go/worker/pkg/mod/cache/download/gitee.com/phpbms/demo/@v/v0.0.0-20211021090521-71a745ffbccb.zip\u0026#34;, \u0026#34;Dir\u0026#34;: \u0026#34;/mnt/g/Go/worker/pkg/mod/gitee.com/phpbms/demo@v0.0.0-20211021090521-71a745ffbccb\u0026#34;, \u0026#34;Sum\u0026#34;: \u0026#34;h1:JJlXgKY8MUQtOlnSHtbIsHtRU9DNbxx9NUgpsDt3pQA=\u0026#34;, \u0026#34;GoModSum\u0026#34;: \u0026#34;h1:6H8vzSoXg8Ey2gdfFaP7ToLmbOnfc04IAcuTFDKqSV8=\u0026#34; } go mod tidy go mod tidyç¡®ä¿go.modæ–‡ä»¶ä¸æ¨¡å—ä¸­çš„æºä»£ç åŒ¹é…ã€‚ å®ƒæ·»åŠ äº†æ„å»ºå½“å‰æ¨¡å—çš„åŒ…å’Œä¾èµ–é¡¹æ‰€éœ€çš„ä»»ä½•ç¼ºå¤±çš„æ¨¡å—è¦æ±‚ï¼Œå¹¶åˆ é™¤äº†å¯¹ä¸æä¾›ä»»ä½•ç›¸å…³åŒ…çš„æ¨¡å—çš„è¦æ±‚ã€‚ å®ƒè¿˜å‘go.sumæ·»åŠ ä»»ä½•ç¼ºå¤±çš„æ¡ç›®å¹¶åˆ é™¤ä¸å¿…è¦çš„æ¡ç›®ã€‚ go mod tidyé€šè¿‡é€’å½’åŠ è½½ä¸»æ¨¡å—ä¸­çš„æ‰€æœ‰åŒ…ä»¥åŠå®ƒä»¬å¯¼å…¥çš„æ‰€æœ‰åŒ…æ¥å·¥ä½œï¼Œè¿™åŒ…æ‹¬æµ‹è¯•å¯¼å…¥çš„åŒ…ï¼ˆåŒ…æ‹¬å…¶ä»–æ¨¡å—ä¸­çš„æµ‹è¯•ï¼‰ã€‚ go mod tidyå°±åƒå¯ç”¨äº†æ‰€æœ‰æ„å»ºæ ‡è®°ä¸€æ ·ï¼Œå› æ­¤å®ƒä¼šè€ƒè™‘ç‰¹å®šäºå¹³å°çš„æºæ–‡ä»¶å’Œéœ€è¦è‡ªå®šä¹‰æ„å»ºæ ‡è®°çš„æ–‡ä»¶ï¼Œå³ä½¿è¿™äº›æºæ–‡ä»¶é€šå¸¸ä¸ä¼šè¢«æ„å»ºã€‚ æœ‰ä¸€ä¸ªä¾‹å¤–ï¼šå¿½ç•¥æ„å»ºæ ‡è®°æœªå¯ç”¨ï¼Œå› æ­¤ä¸ä¼šè€ƒè™‘å…·æœ‰æ„å»ºçº¦æŸã€// +build ignoreã€‘çš„æ–‡ä»¶ã€‚ è¯·æ³¨æ„ï¼Œgo mod tidyä¸ä¼šè€ƒè™‘ä¸»æ¨¡å—ä¸­åä¸ºtestdataæˆ–åç§°ä»¥.æˆ–_é™¤éè¿™äº›åŒ…æ˜¯ç”±å…¶ä»–åŒ…æ˜¾å¼å¯¼å…¥çš„ã€‚ ä¸€æ—¦go mod tidyåŠ è½½äº†è¿™ç»„åŒ…ï¼Œå®ƒä¼šç¡®ä¿æä¾›ä¸€ä¸ªæˆ–å¤šä¸ªåŒ…çš„æ¯ä¸ªæ¨¡å—åœ¨ä¸»æ¨¡å—çš„go.modæ–‡ä»¶ä¸­éƒ½æœ‰ä¸€ä¸ªrequireæŒ‡ä»¤ï¼Œæˆ–è€…å¦‚æœä¸»æ¨¡å—åœ¨go 1.16æˆ–æ›´ä½ç‰ˆæœ¬ - æ˜¯å¿…éœ€çš„å¦ä¸€ä¸ªå¿…éœ€çš„æ¨¡å—ã€‚ go mod tidyå°†æ·»åŠ å¯¹æ¯ä¸ªç¼ºå¤±æ¨¡å—çš„æœ€æ–°ç‰ˆæœ¬çš„è¦æ±‚ï¼ˆæœ‰å…³æœ€æ–°ç‰ˆæœ¬çš„å®šä¹‰ï¼Œè¯·å‚é˜…ç‰ˆæœ¬æŸ¥è¯¢ï¼‰ï¼Œgo mod tidyå°†åˆ é™¤ä¸æä¾›ä¸Šè¿°é›†åˆä¸­ä»»ä½•åŒ…çš„æ¨¡å—çš„requireæŒ‡ä»¤ã€‚ go mod tidyè¿˜å¯ä»¥æ·»åŠ æˆ–åˆ é™¤require æŒ‡ä»¤çš„// indirectï¼Œ// indirecté—´æ¥æ³¨é‡Šè¡¨ç¤ºæ¨¡å—ä¸æä¾›ç”±ä¸»æ¨¡å—ä¸­çš„åŒ…å¯¼å…¥çš„åŒ…ã€‚ ç”¨æ³•ï¼šgo mod tidy [-e] [-v] [-go=version] [-compat=version]ã€‚ ä»‹ç»ï¼š -eï¼š(åœ¨Go 1.16ä¸­æ·»åŠ )åœ¨åŠ è½½åŒ…æ—¶é‡åˆ°é”™è¯¯æ—¶å°è¯•ç»§ç»­ã€‚ -vï¼šå°†æœ‰å…³å·²åˆ é™¤æ¨¡å—çš„ä¿¡æ¯æ‰“å°åˆ°æ ‡å‡†é”™è¯¯ã€‚ -go=ï¼šå°†goæŒ‡ä»¤æ›´æ–°ä¸ºæŒ‡å®šçš„ç‰ˆæœ¬ï¼Œæ ¹æ®è¯¥ç‰ˆæœ¬å¯ç”¨æˆ–ç¦ç”¨æ¨¡å—å›¾ä¿®å‰ªå’Œå»¶è¿Ÿæ¨¡å—åŠ è½½ï¼ˆå¹¶æ ¹æ®éœ€è¦æ·»åŠ æˆ–åˆ é™¤// indirecté—´æ¥æ³¨é‡Šï¼‰ã€‚ -compat=ï¼šå½“æ¨¡å—å›¾ç”±goæŒ‡ä»¤ä¸­æŒ‡ç¤ºçš„ç‰ˆæœ¬ä¹‹å‰çš„Goç‰ˆæœ¬åŠ è½½æ—¶ï¼Œgo mod tidyå°†æ£€æŸ¥æ‰€é€‰ç‰ˆæœ¬çš„æ¨¡å—æ˜¯å¦ä¸ä¼šæ›´æ”¹ã€‚è¿˜å¯ä»¥é€šè¿‡-compatæ ‡å¿—æ˜¾å¼æŒ‡å®šç‰ˆæœ¬æ£€æŸ¥çš„å…¼å®¹æ€§ã€‚ go mod graph ä»¥æ–‡æœ¬å½¢å¼æ‰“å°æ¨¡å—éœ€æ±‚å›¾ã€‚ ç”¨æ³•ï¼šgo mod graph [-go=version]ã€‚ ä»‹ç»ï¼š æ¨¡å—å›¾ä¸­çš„æ¯ä¸ªé¡¶ç‚¹ä»£è¡¨ä¸€ä¸ªæ¨¡å—çš„ç‰¹å®šç‰ˆæœ¬ï¼Œå›¾ä¸­çš„æ¯æ¡è¾¹ä»£è¡¨å¯¹ä¾èµ–é¡¹çš„æœ€ä½ç‰ˆæœ¬çš„è¦æ±‚ã€‚ go mod graphæ‰“å°å›¾å½¢çš„è¾¹ç¼˜ï¼Œæ¯è¡Œä¸€ä¸ªã€‚ æ¯è¡Œæœ‰ä¸¤ä¸ªç©ºæ ¼åˆ†éš”çš„å­—æ®µï¼šæ¨¡å—ç‰ˆæœ¬åŠå…¶ä¾èµ–é¡¹ä¹‹ä¸€ã€‚ æ¯ä¸ªæ¨¡å—ç‰ˆæœ¬éƒ½æ ‡è¯†ä¸ºpath@versionå½¢å¼çš„å­—ç¬¦ä¸²ã€‚ ä¸»æ¨¡å—æ²¡æœ‰@versionåç¼€ï¼Œå› ä¸ºå®ƒæ²¡æœ‰ç‰ˆæœ¬ã€‚ -go=ï¼šgo mod graphæŠ¥å‘Šç»™å®šGoç‰ˆæœ¬åŠ è½½çš„æ¨¡å—å›¾ï¼Œè€Œä¸æ˜¯go.modæ–‡ä»¶ä¸­çš„goæŒ‡ä»¤æŒ‡ç¤ºçš„ç‰ˆæœ¬ã€‚ æœ‰å…³å¦‚ä½•é€‰æ‹©ç‰ˆæœ¬çš„æ›´å¤šä¿¡æ¯ï¼Œè¯·å‚é˜…æœ€å°ç‰ˆæœ¬é€‰æ‹©(MVS)ã€‚ å¦è¯·å‚é˜…go list -mä»¥æ‰“å°é€‰å®šçš„ç‰ˆæœ¬ï¼Œå¹¶æŸ¥çœ‹go mod whyä»¥äº†è§£ä¸ºä»€ä¹ˆéœ€è¦æ¨¡å—ã€‚ example.com/main example.com/a@v1.1.0 example.com/main example.com/b@v1.2.0 example.com/a@v1.1.0 example.com/b@v1.1.1 example.com/a@v1.1.0 example.com/c@v1.3.0 example.com/b@v1.1.0 example.com/c@v1.1.0 example.com/b@v1.2.0 example.com/c@v1.2.0 go mod edit è¯¥å‘½ä»¤æä¾›äº†ä¸€ä¸ªç”¨äºç¼–è¾‘å’Œæ ¼å¼åŒ–go.modæ–‡ä»¶çš„å‘½ä»¤è¡Œç•Œé¢ï¼Œä¸»è¦ä¾›å·¥å…·å’Œè„šæœ¬ä½¿ç”¨ã€‚ go mod editåªè¯»å–ä¸€ä¸ªgo.modæ–‡ä»¶ï¼Œå®ƒä¸æŸ¥æ‰¾æœ‰å…³å…¶ä»–æ¨¡å—çš„ä¿¡æ¯ã€‚ é»˜è®¤æƒ…å†µä¸‹ï¼Œgo mod editè¯»å–å’Œå†™å…¥go.modä¸»æ¨¡å—çš„æ–‡ä»¶ï¼Œä½†å¯ä»¥åœ¨ç¼–è¾‘æ ‡å¿—åæŒ‡å®šä¸åŒçš„ç›®æ ‡æ–‡ä»¶ã€‚ ç”¨æ³•ï¼šgo mod edit [editing flags] [-fmt|-print|-json] [go.mod] editing flagsï¼šæŒ‡å®šç¼–è¾‘æ“ä½œé€‰é¡¹ï¼š(editing flagså¯ä»¥é‡å¤ä½¿ç”¨ï¼ŒæŒ‰ç»™å®šçš„é¡ºåº) -moduleï¼šæ›´æ”¹æ¨¡å—çš„è·¯å¾„(go.modæ–‡ä»¶çš„moduleè¡Œ)ï¼Œä¿®æ”¹moduleè¡Œæ¨¡å—åç§°ã€‚ -go=versionï¼šè®¾ç½®go.modæ–‡ä»¶çš„Goç‰ˆæœ¬ã€‚ -require=path@versionï¼šæ·»åŠ æŒ‡å®šçš„æ¨¡å—è·¯å¾„å’Œç‰ˆæœ¬ä¸Šçš„è¦æ±‚ï¼Œä¼šè¦†ç›–go.modä¸Šçš„ä»»ä½•ç°æœ‰è¦æ±‚pathã€‚ -droprequire=pathï¼šåˆ é™¤æŒ‡å®šçš„æ¨¡å—è·¯å¾„å’Œç‰ˆæœ¬ä¸Šçš„è¦æ±‚ã€‚ -exclude=path@versionï¼šå¢åŠ ç»™å®šçš„æ¨¡å—è·¯å¾„ï¼Œ-exclude=path@versionå¦‚æœè¯¥æ’é™¤å·²å­˜åœ¨ï¼Œ åˆ™ä¸ºç©ºæ“ä½œã€‚ -dropexclude=path@versionï¼šæ”¾å¼ƒå¯¹ç»™å®šçš„æ¨¡å—è·¯å¾„å’Œç‰ˆæœ¬çš„æ’é™¤ã€‚ -replace=old[@v]=new[@v]ï¼šæ·»åŠ äº†ç»™å®šæ¨¡å—è·¯å¾„å’Œç‰ˆæœ¬å¯¹çš„æ›¿æ¢ã€‚ å¦‚æœçœç•¥old@våˆ™æ·»åŠ å·¦ä¾§æ²¡æœ‰ç‰ˆæœ¬çš„æ›¿æ¢ï¼Œè¿™é€‚ç”¨äºæ—§æ¨¡å—è·¯å¾„çš„æ‰€æœ‰ç‰ˆæœ¬ã€‚ å¦‚æœçœç•¥new@våˆ™æ–°è·¯å¾„åº”è¯¥æ˜¯æœ¬åœ°æ¨¡å—æ ¹ç›®å½•ï¼Œè€Œä¸æ˜¯æ¨¡å—è·¯å¾„ã€‚ æ³¨æ„ï¼š-replaceè¦†ç›–çš„ä»»ä½•å†—ä½™æ›¿æ¢old[@v]ï¼Œå› æ­¤çœç•¥@vå°†åˆ é™¤ç‰¹å®šç‰ˆæœ¬çš„æ›¿æ¢ã€‚ -dropreplace=old[@v]ï¼šä¸¢å¼ƒç»™å®šæ¨¡å—è·¯å¾„å’Œç‰ˆæœ¬å¯¹çš„æ›¿æ¢ã€‚ å¦‚æœ@væä¾›äº†ï¼Œåˆ™åˆ é™¤ç»™å®šç‰ˆæœ¬çš„æ›¿æ¢,å·¦ä¾§æ²¡æœ‰ç‰ˆæœ¬çš„ç°æœ‰æ›¿ä»£å“ä»å¯æ›´æ¢æ¨¡å—ã€‚ å¦‚æœ@vçœç•¥ ï¼Œåˆ™åˆ é™¤æ²¡æœ‰ç‰ˆæœ¬çš„æ›¿æ¢ã€‚ -retract=versionï¼šæ·»åŠ å›æ”¶å¯¹äºç»™å®šçš„ç‰ˆæœ¬ï¼Œå…¶å¯ä»¥æ˜¯ä¸€ä¸ªå•ä¸€çš„ç‰ˆæœ¬ï¼ˆå¦‚v1.2.3ï¼‰æˆ–é—´éš”ï¼ˆç­‰[v1.1.0,v1.2.0]ï¼‰ã€‚ æ³¨æ„ï¼š-retractæ ‡å¿—ä¸èƒ½ä¸ºretractæŒ‡ä»¤æ·»åŠ åŸºæœ¬åŸç†æ³¨é‡Šã€‚ -dropretract=versionï¼šåˆ é™¤å›æ”¶å¯¹äºç»™å®šçš„ç‰ˆæœ¬ã€‚ -fmtã€-printã€-jsonï¼šé¢å¤–æ ‡å¿—æ¥æ§åˆ¶è¾“å‡ºã€‚ -fmtï¼šé‡æ–°æ ¼å¼åŒ–go.modæ–‡ä»¶è€Œä¸è¿›è¡Œå…¶ä»–æ›´æ”¹ã€‚ ä½¿ç”¨æˆ–é‡å†™go.modæ–‡ä»¶çš„ä»»ä½•å…¶ä»–ä¿®æ”¹ä¹Ÿæš—ç¤ºäº†è¿™ç§é‡æ–°æ ¼å¼åŒ–ã€‚ å”¯ä¸€éœ€è¦æ­¤æ ‡å¿—çš„æƒ…å†µæ˜¯æ²¡æœ‰æŒ‡å®šå…¶ä»–æ ‡å¿—ï¼Œå¦‚go mod edit -fmtã€‚ -printï¼šgo.modä»¥å…¶æ–‡æœ¬æ ¼å¼æ‰“å°final ï¼Œè€Œä¸æ˜¯å°†å…¶å†™å›ç£ç›˜ï¼ˆå°±æ˜¯æ‰“å°go.modæ–‡ä»¶å†…å®¹ï¼‰ã€‚ -jsonï¼šgo.modä»¥ JSON æ ¼å¼æ‰“å°æœ€ç»ˆç»“æœï¼Œè€Œä¸æ˜¯ä»¥æ–‡æœ¬æ ¼å¼å°†å…¶å†™å›ç£ç›˜go mod edit -jsonã€‚ // jsonæ‰“å°æ ¼å¼ { \u0026#34;Module\u0026#34;: { \u0026#34;Path\u0026#34;: \u0026#34;mymod\u0026#34; }, \u0026#34;Go\u0026#34;: \u0026#34;1.17\u0026#34;, \u0026#34;Require\u0026#34;: [ { \u0026#34;Path\u0026#34;: \u0026#34;gitee.com/phpbms/demo\u0026#34;, \u0026#34;Version\u0026#34;: \u0026#34;v0.0.0-20211021090521-71a745ffbccb\u0026#34;, \u0026#34;Indirect\u0026#34;: true } ], \u0026#34;Exclude\u0026#34;: null, \u0026#34;Replace\u0026#34;: null, \u0026#34;Retract\u0026#34;: null } // å¯¹åº”ç›¸å…³ç»“æ„ä½“ type Module struct { Path string Version string } type GoMod struct { Module Module Go string Require []Require Exclude []Module Replace []Replace } type Require struct { Path string Version string Indirect bool } type Replace struct { Old Module New Module } type Retract struct { Low string High string Rationale string } ç¤ºä¾‹ï¼š # æ·»åŠ æ›¿æ¢æŒ‡ä»¤ $ go mod edit -replace example.com/a@v1.0.0=./a # åˆ é™¤æ›¿æ¢æŒ‡ä»¤ $ go mod edit -dropreplace example.com/a@v1.0.0 # è®¾ç½®goç‰ˆæœ¬ï¼Œæ·»åŠ éœ€æ±‚ï¼Œæ‰“å°æ–‡ä»¶è€Œä¸æ˜¯å†™å…¥ç£ç›˜ $ go mod edit -go=1.14 -require=example.com/m@v1.0.0 -print # æ ¼å¼åŒ– go.mod æ–‡ä»¶ $ go mod edit -fmt # æ ¼å¼åŒ–å¹¶æ‰“å°ä¸åŒçš„ .mod æ–‡ä»¶ $ go mod edit -print tools.mod # æ‰“å° go.mod æ–‡ä»¶çš„ JSON è¡¨ç¤º $ go mod edit -json # æ‰€æœ‰å‘½ä»¤ä½¿ç”¨ $ go mod edit -module=mydemo1 -go=1.16 -require=gitee.com/phpbms/demo/v3@v3.0.0 -exclude=gitee.com/phpbms/demo/v3@v3.0.1 -replace=gitee.com/phpbms/demo/v2@v2.0.1=gitee.com/phpbms/demo/v2@v2.0.0 -retract=v1.1.1 -print ./go.mod # ä¿®æ”¹goç‰ˆæœ¬ï¼Œä»ä¹‹å‰çš„ go 1.20 ä¿®æ”¹ä¸º go 1.21rc2 $ go mod edit -go 1.21rc2 go mod vendor åœ¨ä¸»æ¨¡å—çš„æ ¹ç›®å½•ä¸­æ„é€ ä¸€ä¸ªåä¸ºvendorçš„ç›®å½•ï¼Œè¯¥ç›®å½•åŒ…å«æ”¯æŒä¸»æ¨¡å—ä¸­åŒ…çš„æ„å»ºå’Œæµ‹è¯•æ‰€éœ€çš„æ‰€æœ‰åŒ…çš„å‰¯æœ¬ã€‚ ä¸åŒ…æ‹¬ä»…é€šè¿‡ä¸»æ¨¡å—ä¹‹å¤–çš„åŒ…æµ‹è¯•å¯¼å…¥çš„åŒ…ã€‚ ä¸go mod tidyå’Œå…¶ä»–æ¨¡å—å‘½ä»¤ä¸€æ ·ï¼Œåœ¨æ„å»ºvendorç›®å½•æ—¶ä¸è€ƒè™‘é™¤äº†ignoreä¹‹å¤–çš„æ„å»ºçº¦æŸã€‚ å½“å¯ç”¨vendoringæ—¶ï¼Œgoå‘½ä»¤å°†ä»vendorç›®å½•åŠ è½½åŒ…ï¼Œè€Œä¸æ˜¯å°†æ¨¡å—ä»å…¶æºä¸‹è½½åˆ°æ¨¡å—ç¼“å­˜ä¸­ï¼Œå¹¶ä½¿ç”¨é‚£äº›ä¸‹è½½å‰¯æœ¬çš„åŒ…ã€‚ go mod vendorè¿˜ä¼šåˆ›å»ºæ–‡ä»¶vendor/modules.txtï¼Œå…¶ä¸­åŒ…å«vendoråŒ…çš„åˆ—è¡¨ä»¥åŠä»ä¸­å¤åˆ¶å®ƒä»¬çš„æ¨¡å—ç‰ˆæœ¬ã€‚ å½“å¯ç”¨vendoringæ—¶ï¼Œæ­¤æ¸…å•ç”¨ä½œæ¨¡å—ç‰ˆæœ¬ä¿¡æ¯çš„æ¥æºï¼Œå¦‚go list -må’Œgo version -mæ‰€æŠ¥å‘Šçš„ã€‚ å½“goå‘½ä»¤è¯»å–vendor/modules.txtæ—¶ï¼Œå®ƒä¼šæ£€æŸ¥æ¨¡å—ç‰ˆæœ¬æ˜¯å¦ä¸go.modä¸€è‡´ã€‚ å¦‚æœgo.modåœ¨vendor/modules.txtç”Ÿæˆåå‘ç”Ÿäº†å˜åŒ–ï¼Œåˆ™åº”å†æ¬¡è¿è¡Œgo mod vendorã€‚ è¯·æ³¨æ„ï¼Œgo mod vendorä¼šåœ¨é‡æ–°æ„å»ºä¹‹å‰åˆ é™¤vendorç›®å½•ï¼ˆå¦‚æœå®ƒå­˜åœ¨ï¼‰ã€‚ ä¸åº”å¯¹vendorçš„è½¯ä»¶åŒ…è¿›è¡Œæœ¬åœ°æ›´æ”¹ã€‚ goå‘½ä»¤ä¸ä¼šæ£€æŸ¥vendorç›®å½•ä¸­çš„åŒ…æ˜¯å¦æœªè¢«ä¿®æ”¹ï¼Œä½†æ˜¯å¯ä»¥é€šè¿‡è¿è¡Œgo mod vendorå¹¶æ£€æŸ¥æ²¡æœ‰è¿›è¡Œä»»ä½•æ›´æ”¹æ¥éªŒè¯vendorç›®å½•çš„å®Œæ•´æ€§ã€‚ ä½¿ç”¨ï¼šgo mod vendor [-e] [-v]ã€‚ -eï¼šï¼ˆåœ¨Go 1.16ä¸­æ·»åŠ ï¼‰åœ¨åŠ è½½åŒ…æ—¶é‡åˆ°é”™è¯¯æ—¶å°è¯•ç»§ç»­ã€‚ -vï¼šå°†vendoræ¨¡å—å’ŒåŒ…çš„åç§°æ‰“å°ä¸ºæ ‡å‡†é”™è¯¯ã€‚ go mod verify æ£€æŸ¥å­˜å‚¨åœ¨æ¨¡å—ç¼“å­˜ä¸­çš„ä¸»æ¨¡å—çš„ä¾èµ–é¡¹è‡ªä¸‹è½½ä»¥æ¥æ²¡æœ‰è¢«ä¿®æ”¹ã€‚ æ‰§è¡Œæ­¤æ£€æŸ¥ï¼Œå¯¹æ¯ä¸ªä¸‹è½½çš„module.zipæ–‡ä»¶å’Œæå–çš„ç›®å½•è¿›è¡Œæ•£åˆ—ç„¶åå°†è¿™äº›æ•£åˆ—ä¸é¦–æ¬¡ä¸‹è½½æ¨¡å—æ—¶è®°å½•çš„æ•£åˆ—è¿›è¡Œæ¯”è¾ƒã€‚ go mod verify æ£€æŸ¥æ„å»ºåˆ—è¡¨ä¸­çš„æ¯ä¸ªæ¨¡å—ï¼ˆå¯ä»¥ä½¿ç”¨go list -m allæ‰“å°æ‰€æœ‰æ¨¡å—ï¼‰ã€‚ å¦‚æœæ‰€æœ‰æ¨¡å—éƒ½æœªä¿®æ”¹ï¼Œåˆ™go mod verify æ‰“å°all modules verifiedå¦åˆ™ï¼Œå®ƒå°†æŠ¥å‘Šå“ªäº›æ¨¡å—å·²æ›´æ”¹å¹¶ä»¥éé›¶çŠ¶æ€é€€å‡ºã€‚ æ³¨æ„ï¼šæ‰€æœ‰æ¨¡å—æ„ŸçŸ¥å‘½ä»¤éƒ½ä¼šéªŒè¯ä¸»æ¨¡å—çš„go.sumæ–‡ä»¶ä¸­çš„å“ˆå¸Œå€¼æ˜¯å¦ä¸ä¸ºä¸‹è½½åˆ°æ¨¡å—ç¼“å­˜ä¸­çš„æ¨¡å—è®°å½•çš„å“ˆå¸Œå€¼åŒ¹é…ã€‚ å¦‚æœgo.sumä¸­ç¼ºå°‘å“ˆå¸Œï¼ˆä¾‹å¦‚ï¼Œå› ä¸ºæ¨¡å—æ˜¯ç¬¬ä¸€æ¬¡ä½¿ç”¨ï¼‰ï¼Œåˆ™goå‘½ä»¤ä½¿ç”¨æ ¡éªŒå’Œæ•°æ®åº“éªŒè¯å…¶å“ˆå¸Œã€‚ é™¤éæ¨¡å—è·¯å¾„ä¸GOPRIVATEæˆ–GONOSUMDBåŒ¹é…ã€‚ go mod verifyä¸ä¼šä¸ºä¸åœ¨ç¼“å­˜ä¸­çš„æ¨¡å—ä¸‹è½½å†…å®¹ï¼Œä¹Ÿä¸ä¼šä½¿ç”¨go.sumæ–‡ä»¶æ¥éªŒè¯æ¨¡å—å†…å®¹ã€‚ ä½†æ˜¯ï¼Œgo mod verifyå¯èƒ½ä¼šä¸‹è½½go.modæ–‡ä»¶ä»¥æ‰§è¡Œæœ€å°‘çš„ç‰ˆæœ¬é€‰æ‹©ã€‚ å®ƒå°†ä½¿ç”¨go.sumæ¥éªŒè¯è¿™äº›æ–‡ä»¶ï¼Œå¹¶ä¸”å¯èƒ½ä¼šä¸ºä¸¢å¤±çš„å“ˆå¸Œæ·»åŠ go.sumæ¡ç›®ã€‚ ç”¨æ³•ï¼šgo mod verifyã€‚ $ go mod verify all modules verified go mod why go mod whyåœ¨å¯¼å…¥å›¾ä¸­æ˜¾ç¤ºä»ä¸»æ¨¡å—åˆ°æ¯ä¸ªåˆ—å‡ºçš„åŒ…çš„æœ€çŸ­è·¯å¾„ã€‚ ç”¨æ³•ï¼šgo mod why [-m] [-vendor] packages...ã€‚ -mï¼šgo mod whyå°†å…¶å‚æ•°è§†ä¸ºæ¨¡å—åˆ—è¡¨ã€‚ go mod whyä¼šæ‰“å°æ¯ä¸ªæ¨¡å—ä¸­ä»»ä½•åŒ…çš„è·¯å¾„ã€‚ è¯·æ³¨æ„ï¼Œå³ä½¿ä½¿ç”¨-mï¼Œgo mod whyæŸ¥è¯¢åŒ…å›¾ï¼Œè€Œä¸æ˜¯go mod graphæ‰“å°çš„æ¨¡å—å›¾ã€‚ -vendorï¼šgo mod whyå¿½ç•¥ä¸»æ¨¡å—ä¹‹å¤–çš„åŒ…æµ‹è¯•ä¸­çš„å¯¼å…¥ï¼ˆå°±åƒgo mod vendoræ‰€åšçš„é‚£æ ·ï¼‰ã€‚ é»˜è®¤æƒ…å†µä¸‹ï¼Œ go mod whyä¼šè€ƒè™‘ä¸allæ¨¡å¼åŒ¹é…çš„åŒ…å›¾ã€‚ è¿™ä¸ªæ ‡å¿—åœ¨Go 1.16ä¹‹ååœ¨å£°æ˜go 1.16æˆ–æ›´é«˜ç‰ˆæœ¬çš„æ¨¡å—ä¸­æ— æ•ˆï¼ˆä½¿ç”¨go.modä¸­çš„goæŒ‡ä»¤ï¼‰ï¼Œå› ä¸ºallçš„å«ä¹‰å·²æ›´æ”¹ä»¥åŒ¹é…go modä¾›åº”å•†åŒ¹é…çš„åŒ…é›†ã€‚ ç¤ºä¾‹ï¼š è¾“å‡ºæ˜¯ä¸€ä¸ªèŠ‚åºåˆ—ï¼Œæ¯ä¸ªåœ¨å‘½ä»¤è¡Œä¸Šå‘½åçš„åŒ…æˆ–æ¨¡å—éƒ½æœ‰ä¸€ä¸ªèŠ‚ï¼Œç”¨ç©ºè¡Œåˆ†éš”ã€‚ æ¯èŠ‚ä»¥æ³¨é‡Šè¡Œå¼€å¤´ï¼Œä»¥#å¼€å¤´ï¼Œç»™å‡ºç›®æ ‡åŒ…æˆ–æ¨¡å—ã€‚ åç»­è¡Œç»™å‡ºäº†é€šè¿‡å¯¼å…¥å›¾çš„è·¯å¾„ï¼Œæ¯è¡Œä¸€ä¸ªåŒ…ã€‚ å¦‚æœåŒ…æˆ–æ¨¡å—ä¸æ˜¯ä»ä¸»æ¨¡å—å¼•ç”¨çš„ï¼Œåˆ™è¯¥èŠ‚å°†æ˜¾ç¤ºä¸€ä¸ªå¸¦æ‹¬å·çš„æ³¨é‡Šï¼Œè¡¨æ˜è¯¥äº‹å®ã€‚ $ go mod why golang.org/x/text/language golang.org/x/text/encoding # golang.org/x/text/language rsc.io/quote rsc.io/sampler golang.org/x/text/language # golang.org/x/text/encoding (main module does not need package golang.org/x/text/encoding) ","permalink":"https://heliu.site/posts/golang/package/module/","summary":"Golang go moduleså‘½ä»¤ä»‹ç»ã€‚","title":"go modules"},{"content":" ç”¨æ³•ï¼šgo work \u0026lt;command\u0026gt; [arguments] command åˆ—è¡¨ï¼š editï¼šä»å·¥å…·æˆ–è„šæœ¬ç¼–è¾‘ go.workã€‚ initï¼šåˆå§‹åŒ–å·¥ä½œåŒºæ–‡ä»¶ã€‚ syncï¼šå°†å·¥ä½œåŒºæ„å»ºåˆ—è¡¨åŒæ­¥åˆ°æ¨¡å—ã€‚ useï¼šå°†æ¨¡å—æ·»åŠ åˆ°å·¥ä½œåŒºæ–‡ä»¶ã€‚ go work init ç”¨æ³•ï¼šgo work init [moddirs]ã€‚ initåœ¨å½“å‰ç›®å½•ä¸­åˆå§‹åŒ–å¹¶å†™å…¥ä¸€ä¸ªæ–°çš„go.workæ–‡ä»¶ï¼Œå®é™…ä¸Šæ˜¯åœ¨å½“å‰ç›®å½•ä¸­åˆ›å»ºäº†ä¸€ä¸ªæ–°çš„å·¥ä½œç©ºé—´ã€‚ go work initå¯é€‰æ‹©æ¥å—å·¥ä½œåŒºæ¨¡å—çš„è·¯å¾„ä½œä¸ºå‚æ•°ã€‚å¦‚æœçœç•¥è¯¥å‚æ•°ï¼Œå°†åˆ›å»ºä¸€ä¸ªæ²¡æœ‰æ¨¡å—çš„ç©ºå·¥ä½œåŒºã€‚ æ¯ä¸ªå‚æ•°è·¯å¾„éƒ½æ·»åŠ åˆ°go.workæ–‡ä»¶ä¸­çš„useæŒ‡ä»¤ä¸­ã€‚ å½“å‰çš„goç‰ˆæœ¬ä¹Ÿå°†åˆ—åœ¨go.workæ–‡ä»¶ä¸­ã€‚ ç¤ºä¾‹ï¼š 1 2 # åˆå§‹åŒ–ä¸€ä¸ªæ–°çš„å·¥ä½œåŒºï¼Œåé¢å‚æ•°å°±æ˜¯å…·ä½“çš„å­æ¨¡å— $ go work init ./queue ./hello 1 2 3 4 5 6 7 8 9 // é¡¹ç›®ç›®å½•æ„æˆ workspace |-- queue # å­æ¨¡å— | |-- go.mod | |-- queue.go |-- hello # å­æ¨¡å— | |-- go.mod | |-- main.go\t|-- go.work # å·¥ä½œåŒº é€šå¸¸go.workæ–‡ä»¶ä¸è¦æäº¤åˆ°gitä¸Šï¼Œå› ä¸ºå®ƒä¸»è¦ç”¨äºæœ¬åœ°ä»£ç å¼€å‘ã€‚ go work edit ç”¨æ³•ï¼šgo work edit [editing flags] [go.work]ã€‚ç”¨äºç¼–è¾‘go.workæ–‡ä»¶ã€‚ go work editå‘½ä»¤æä¾›äº†ä¸€ä¸ªç”¨äºç¼–è¾‘go.workçš„å‘½ä»¤è¡Œç•Œé¢ï¼Œä¸»è¦ä¾›å·¥å…·æˆ–è„šæœ¬ä½¿ç”¨ã€‚ å®ƒåªè¯»å–go.work;å®ƒä¸æŸ¥æ‰¾æœ‰å…³æ‰€æ¶‰åŠæ¨¡å—çš„ä¿¡æ¯ã€‚å¦‚æœæ²¡æœ‰æŒ‡å®šæ–‡ä»¶ï¼Œeditåœ¨å½“å‰ç›®å½•åŠå…¶çˆ¶ç›®å½•ä¸­æŸ¥æ‰¾go.workæ–‡ä»¶ã€‚ editing flags fmtï¼šé‡æ–°æ ¼å¼åŒ–go.workæ–‡ä»¶è€Œä¸è¿›è¡Œå…¶ä»–æ›´æ”¹ã€‚ä½¿ç”¨æˆ–é‡å†™go.workæ–‡ä»¶çš„ä»»ä½•å…¶ä»–ä¿®æ”¹ä¹Ÿæš—ç¤ºäº†è¿™ç§é‡æ–°æ ¼å¼åŒ–ã€‚å”¯ä¸€éœ€è¦æ­¤æ ‡å¿—çš„æƒ…å†µæ˜¯æ²¡æœ‰æŒ‡å®šå…¶ä»–æ ‡å¿—ã€‚ ç¤ºä¾‹ï¼šgo work edit -fmtã€‚ç”¨äºæ ¼å¼åŒ–go.workæ–‡ä»¶ã€‚ $ go work edit -fmt -use=pathï¼šä»go.workæ–‡ä»¶çš„æ¨¡å—ç›®å½•é›†ä¸­æ·»åŠ useæŒ‡ä»¤ã€‚å»ºè®®ä½¿ç”¨go work useæŒ‡ä»¤ã€‚ ç¤ºä¾‹ï¼šgo work edit -use=./queueã€‚æ·»åŠ å­æ¨¡å—ã€‚ $ go work edit -use ./ququq -dropuse=pathï¼šä»go.workæ–‡ä»¶çš„æ¨¡å—ç›®å½•é›†ä¸­åˆ é™¤useæŒ‡ä»¤ã€‚ ç¤ºä¾‹ï¼šgo work edit -dropuse=./queueã€‚åˆ é™¤å­æ¨¡å—queueã€‚ $ go work edit -dropuse ./queue -replace=old[@v]=new[@v]ï¼šæ·»åŠ äº†ç»™å®šæ¨¡å—è·¯å¾„å’Œç‰ˆæœ¬å¯¹çš„æ›¿æ¢ã€‚ å¦‚æœold@vä¸­çš„@vè¢«çœç•¥ï¼Œåˆ™æ·»åŠ å·¦ä¾§æ²¡æœ‰ç‰ˆæœ¬çš„æ›¿æ¢ï¼Œé€‚ç”¨äºæ—§æ¨¡å—è·¯å¾„çš„æ‰€æœ‰ç‰ˆæœ¬ã€‚ å¦‚æœçœç•¥new@vä¸­çš„@vï¼Œåˆ™æ–°è·¯å¾„åº”è¯¥æ˜¯æœ¬åœ°æ¨¡å—æ ¹ç›®å½•ï¼Œè€Œä¸æ˜¯æ¨¡å—è·¯å¾„ã€‚ è¯·æ³¨æ„ï¼Œ-replaceä¼šè¦†ç›–old[@v]çš„ä»»ä½•å†—ä½™æ›¿æ¢ï¼Œå› æ­¤çœç•¥@vå°†åˆ é™¤ç‰¹å®šç‰ˆæœ¬çš„ç°æœ‰æ›¿æ¢ã€‚ ç¤ºä¾‹ï¼šgo work edit -replace myzx.cn/helium/queue=./queueã€‚ $ go work edit -replace myzx.cn/helium/queue=./queue -dropreplace=old[@v]ï¼šåˆ é™¤ç»™å®šæ¨¡å—è·¯å¾„å’Œç‰ˆæœ¬å¯¹çš„æ›¿æ¢ã€‚å¦‚æœçœç•¥äº†@vï¼Œåˆ™ä¼šåˆ é™¤å·¦ä¾§æ²¡æœ‰ç‰ˆæœ¬çš„æ›¿æ¢ã€‚ ç¤ºä¾‹ï¼šgo work edit -dropreplace myzx.cn/helium/queueã€‚ $ go work edit -dropreplace myzx.cn/helium/queue -go=versionï¼šè®¾ç½®é¢„æœŸçš„Goè¯­è¨€ç‰ˆæœ¬ã€‚ ç¤ºä¾‹ï¼šgo work edit -go 1.19ã€‚ $ go work edit -go 1.19 è¿™äº›editing flagså¯ä»¥é‡å¤ä½¿ç”¨ã€‚ æ›´æ”¹æŒ‰ç»™å®šçš„é¡ºåºåº”ç”¨ã€‚ go work editæœ‰é¢å¤–çš„æ ‡å¿—æ¥æ§åˆ¶å®ƒçš„è¾“å‡º -printï¼šä»¥æ–‡æœ¬æ ¼å¼æ‰“å°æœ€ç»ˆçš„go.workï¼Œè€Œä¸æ˜¯å°†å…¶å†™å›go.modã€‚ $ go work edit -print -jsonï¼šä»¥JSONæ ¼å¼æ‰“å°æœ€ç»ˆçš„go.workæ–‡ä»¶ï¼Œè€Œä¸æ˜¯å°†å…¶å†™å›go.modã€‚ $ go work edit -json JSONè¾“å‡ºå¯¹åº”äºä»¥ä¸‹Goç±»å‹ï¼š 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 type Module struct { Path string Version string } type GoWork struct { Go string Directory []Directory Replace []Replace } type Use struct { Path string ModulePath string } type Replace struct { Old Module New Module } go work use ç”¨æ³•ï¼šgo work use [-r] [moddirs]ã€‚useæŒ‡å®šä½¿ç”¨çš„æ¨¡å—ç›®å½•ã€‚ go work useå‘½ä»¤æä¾›äº†ä¸€ä¸ªå‘½ä»¤è¡Œç•Œé¢ï¼Œç”¨äºå°†ç›®å½•ï¼ˆå¯é€‰åœ°ä»¥é€’å½’æ–¹å¼ï¼‰æ·»åŠ åˆ°go.workæ–‡ä»¶ä¸­ã€‚ useæŒ‡ä»¤å°†è¢«æ·»åŠ åˆ°å‘½ä»¤è¡Œgo.workæ–‡ä»¶ä¸­åˆ—å‡ºçš„æ¯ä¸ªå‚æ•°ç›®å½•çš„go.workæ–‡ä»¶ï¼ˆå¦‚æœå®ƒå­˜åœ¨äºç£ç›˜ä¸Šï¼‰ï¼Œæˆ–è€…ä»go.workæ–‡ä»¶ä¸­åˆ é™¤ï¼ˆå¦‚æœå®ƒä¸å­˜åœ¨äºç£ç›˜ä¸Šï¼‰ã€‚ åˆ é™¤åŠŸèƒ½ä½¿ç”¨ï¼šgo work edit -dropuse ./queueå‘½ä»¤ã€‚ -rï¼šé€’å½’æœç´¢å‚æ•°ç›®å½•ä¸­çš„æ¨¡å—ï¼Œå¹¶ä¸”ä½¿ç”¨å‘½ä»¤å°±åƒæ¯ä¸ªç›®å½•éƒ½è¢«æŒ‡å®šä¸ºå‚æ•°ä¸€æ ·æ“ä½œï¼šå³ï¼Œå°†ä¸ºå­˜åœ¨çš„ç›®å½•æ·»åŠ ä½¿ç”¨æŒ‡ä»¤ï¼Œä¸ºä¸å­˜åœ¨çš„ç›®å½•åˆ é™¤ä½¿ç”¨æŒ‡ä»¤ã€‚ é€’å½’çš„æ·»åŠ å­æ¨¡å—åˆ°å½“å‰å·¥ä½œåŒºï¼Œè¿™å¯¹äºå­æ¨¡å—å¼•ç”¨äº†å¾ˆå¤šæ¨¡å—å¾ˆç”¨ç”¨å¤„ã€‚ ç¤ºä¾‹ï¼šgo work use ./queueï¼Œæ·»åŠ queueå­æ¨¡å—ã€‚ $ go work use ./queue go work sync ç”¨æ³•ï¼šgo work syncã€‚æ²¡æœ‰å‚æ•°ã€‚ go work syncå‘½ä»¤å°†å·¥ä½œåŒºçš„æ„å»ºåˆ—è¡¨åŒæ­¥å›å·¥ä½œåŒºçš„æ¨¡å—ã€‚è¯¥å‘½ä»¤ä¼šä¿®æ”¹go.workæ–‡ä»¶ã€‚ å·¥ä½œåŒºçš„æ„å»ºåˆ—è¡¨æ˜¯ç”¨äºåœ¨å·¥ä½œåŒºä¸­è¿›è¡Œæ„å»ºçš„æ‰€æœ‰ï¼ˆä¼ é€’ï¼‰ä¾èµ–æ¨¡å—çš„ç‰ˆæœ¬é›†ã€‚go work syncä½¿ç”¨æœ€å°ç‰ˆæœ¬é€‰æ‹©(MVS)ç®—æ³•ç”Ÿæˆè¯¥æ„å»ºåˆ—è¡¨ï¼Œç„¶åå°†è¿™äº›ç‰ˆæœ¬åŒæ­¥å›å·¥ä½œåŒºä¸­æŒ‡å®šçš„æ¯ä¸ªæ¨¡å—ï¼ˆä½¿ç”¨useæŒ‡ä»¤ï¼‰ã€‚ ä¸€æ—¦è®¡ç®—äº†å·¥ä½œåŒºæ„å»ºåˆ—è¡¨ï¼Œå·¥ä½œåŒºä¸­æ¯ä¸ªæ¨¡å—çš„go.modæ–‡ä»¶éƒ½ä¼šè¢«é‡å†™ï¼Œå¹¶ä½¿ç”¨ä¸è¯¥æ¨¡å—ç›¸å…³çš„ä¾èµ–é¡¹è¿›è¡Œå‡çº§ä»¥åŒ¹é…å·¥ä½œåŒºæ„å»ºåˆ—è¡¨ã€‚è¯·æ³¨æ„ï¼Œæœ€å°ç‰ˆæœ¬é€‰æ‹©ä¿è¯æ¯ä¸ªæ¨¡å—çš„æ„å»ºåˆ—è¡¨ç‰ˆæœ¬å§‹ç»ˆä¸æ¯ä¸ªå·¥ä½œåŒºæ¨¡å—ä¸­çš„ç›¸åŒæˆ–æ›´é«˜ã€‚ $ go work sync go env GOWORK æŸ¥çœ‹ç¯å¢ƒå˜é‡ï¼ŒæŸ¥çœ‹å½“å‰å·¥ä½œåŒºæ–‡ä»¶è·¯å¾„ã€‚å¯ä»¥æ’æŸ¥å·¥ä½œåŒºæ–‡ä»¶æ˜¯å¦è®¾ç½®æ­£ç¡®ã€‚go.workè·¯å¾„æ‰¾ä¸åˆ°å¯ä»¥ä½¿ç”¨GOWORKæŒ‡å®šã€‚ ç¤ºä¾‹ï¼š $ go env GOWORK G:\\workspace\\go.work ç¦ç”¨å·¥ä½œåŒºï¼Œç›´æ¥æŠŠGOWORKè®¾ç½®ä¸ºoffå³å¯ã€‚ ","permalink":"https://heliu.site/posts/golang/package/work/","summary":"Golang go work å‘½ä»¤ä»‹ç»ã€‚","title":"go work"},{"content":"GO111MODULE Goè¯­è¨€æä¾›äº†GO111MODULEè¿™ä¸ªç¯å¢ƒå˜é‡æ¥ä½œä¸ºGo modulesçš„å¼€å…³ï¼Œå…¶å…è®¸è®¾ç½®ä»¥ä¸‹å‚æ•°ï¼š autoï¼šåªè¦é¡¹ç›®åŒ…å«äº†go.modæ–‡ä»¶(åœ¨$GOPATH/srcå¤–é¢ä¸”æ ¹ç›®å½•æœ‰go.modæ–‡ä»¶æ—¶)çš„è¯å¯ç”¨Go modulesã€‚ onï¼šå¯ç”¨Go modulesï¼Œæ¨èè®¾ç½®ï¼Œä¼šå¿½ç•¥GOPATHå’Œvendoræ–‡ä»¶å¤¹ï¼Œåªæ ¹æ®go.modä¸‹è½½ä¾èµ–ã€‚ offï¼šç¦ç”¨Go modulesï¼Œä¸æ¨èè®¾ç½®ï¼Œä¼šä»GOPATHå’Œvendoræ–‡ä»¶å¤¹å¯»æ‰¾åŒ…ã€‚ GO111MODULEç›¸å…³è§£é‡Šï¼š GO111MODULEè¿™ä¸ªå‘½åä»£è¡¨ç€Goè¯­è¨€åœ¨1.11ç‰ˆæœ¬æ·»åŠ çš„ï¼Œé’ˆå¯¹Moduleçš„å˜é‡ã€‚ åƒæ˜¯åœ¨Go1.5ç‰ˆæœ¬çš„æ—¶å€™ï¼Œä¹Ÿå‘å¸ƒäº†ä¸€ä¸ªç³»ç»Ÿç¯å¢ƒå˜é‡GO15VENDOREXPERIMENTã€‚ ä½œç”¨æ˜¯ç”¨äºå¼€å¯vendorç›®å½•çš„æ”¯æŒï¼Œå½“æ—¶å…¶é»˜è®¤å€¼ä¹Ÿä¸æ˜¯å¼€å¯ï¼Œä»…ä»…ä½œä¸ºexperimentalã€‚ å…¶éšååœ¨Go1.6ç‰ˆæœ¬æ—¶ä¹Ÿå°†é»˜è®¤å€¼æ”¹ä¸ºäº†å¼€å¯ï¼Œå¹¶ä¸”æœ€åä½œä¸ºäº†officialï¼ŒGO15VENDOREXPERIMENTç³»ç»Ÿå˜é‡å°±é€€å‡ºäº†å†å²èˆå°ã€‚ è€Œæœªæ¥GO111MODULEè¿™ä¸€ä¸ªç³»ç»Ÿç¯å¢ƒå˜é‡ä¹Ÿä¼šé¢ä¸´è¿™ä¸ªé—®é¢˜ï¼Œä¸å»é™¤æ˜¯ä¸ºäº†å…¼å®¹è€ç‰ˆæœ¬ã€‚ $ go env -w GO111MODULE=auto GOPROXY è¿™ä¸ªç¯å¢ƒå˜é‡ä¸»è¦æ˜¯ç”¨äºè®¾ç½®Goæ¨¡å—ä»£ç†ï¼Œç›´æ¥é€šè¿‡é•œåƒç«™ç‚¹æ¥å¿«é€Ÿæ‹‰å–ã€‚ GOPROXYçš„é»˜è®¤å€¼æ˜¯ï¼šhttps://proxy.golang.org,directï¼Œè¿™æœ‰ä¸€ä¸ªå¾ˆä¸¥é‡çš„é—®é¢˜ï¼Œå°±æ˜¯https://proxy.golang.orgåœ¨å›½å†…æ˜¯æ— æ³•è®¿é—®çš„ã€‚ åœ¨è¯¥é…ç½®ä¸‹ï¼Œgoå‘½ä»¤é¦–å…ˆå»Googleè¿è¡Œçš„Goæ¨¡å—é•œåƒï¼Œå¦‚æœé•œåƒæ²¡æœ‰æ¨¡å—ï¼Œåˆ™å›é€€åˆ°ç›´æ¥è¿æ¥ã€‚ å¯ä»¥è®¾ç½®GOPRIVATEå’ŒGONOPROXYç¯å¢ƒå˜é‡ä»¥é˜²æ­¢ä½¿ç”¨ä»£ç†ä¸‹è½½ç‰¹å®šæ¨¡å—ã€‚ ä¸­å›½å¤§é™†æ¨èä½¿ç”¨ go env -w GOPROXY=https://goproxy.cn,directã€‚ å…¶ä»–æºåœ°å€åˆ—è¡¨ï¼šhttps://goproxy.cnã€https://goproxy.ioã€https://goproxy.baidu.com/ã€‚ GOPROXYçš„å€¼æ˜¯ä¸€ä¸ªä»¥è‹±æ–‡é€—å·(,)æˆ–ç«–çº¿(|)åˆ†å‰²çš„Goæ¨¡å—ä»£ç†åˆ—è¡¨ï¼Œå…è®¸è®¾ç½®å¤šä¸ªæ¨¡å—ä»£ç†ã€‚ å‡è®¾ä½ ä¸æƒ³ä½¿ç”¨ï¼Œä¹Ÿå¯ä»¥å°†å…¶è®¾ç½®ä¸ºâ€œoffâ€ ï¼Œè¿™å°†ä¼šç¦æ­¢Goåœ¨åç»­æ“ä½œä¸­ä½¿ç”¨ä»»ä½•Goæ¨¡å—ä»£ç†ã€‚ä¹Ÿå°±æ˜¯go env -w GOPROXY=offã€‚ direct æ˜¯ä»€ä¹ˆ? æ˜¯ä¸€ä¸ªç‰¹æ®ŠæŒ‡ç¤ºç¬¦ï¼Œç”¨äºæŒ‡ç¤ºGoå›æºåˆ°æ¨¡å—ç‰ˆæœ¬çš„æºåœ°å€å»æŠ“å–ï¼ˆæ¯”å¦‚GitHubç­‰ï¼‰ã€‚ å½“å€¼åˆ—è¡¨ä¸­ä¸Šä¸€ä¸ªGoæ¨¡å—ä»£ç†è¿”å›404æˆ–410é”™è¯¯æ—¶ï¼ŒGoè‡ªåŠ¨å°è¯•åˆ—è¡¨ä¸­çš„ä¸‹ä¸€ä¸ªã€‚ é‡è§â€œdirectâ€æ—¶å›æºï¼Œä¹Ÿå°±æ˜¯å›åˆ°æºåœ°å€å»æŠ“å–ï¼Œè€Œé‡è§EOFæ—¶ç»ˆæ­¢å¹¶æŠ›å‡ºç±»ä¼¼â€œinvalid version: unknown revision...â€çš„é”™è¯¯ã€‚ æ¨¡å—ä»£ç†URLåˆ—è¡¨ï¼Œä»¥é€—å· (,) æˆ–ç«–çº¿ (|) åˆ†éš”ï¼š å½“goå‘½ä»¤æŸ¥æ‰¾æŸä¸ªæ¨¡å—çš„ä¿¡æ¯æ—¶ï¼Œå®ƒä¼šä¾æ¬¡è”ç³»åˆ—è¡¨ä¸­çš„æ¯ä¸ªä»£ç†ï¼Œç›´åˆ°æ”¶åˆ°æˆåŠŸå“åº”æˆ–ç»ˆç«¯é”™è¯¯ä¸ºæ­¢ã€‚ ä»£ç†å¯èƒ½ä¼šä»¥404ï¼ˆæœªæ‰¾åˆ°ï¼‰æˆ–410ï¼ˆå·²æ¶ˆå¤±ï¼‰çŠ¶æ€å“åº”ï¼Œä»¥æŒ‡ç¤ºè¯¥æ¨¡å—åœ¨è¯¥æœåŠ¡å™¨ä¸Šä¸å¯ç”¨ã€‚ goå‘½ä»¤çš„é”™è¯¯å›é€€è¡Œä¸ºç”±URLä¹‹é—´çš„åˆ†éš”ç¬¦å†³å®šï¼š ,ï¼šgoå‘½ä»¤ä¼šåœ¨404æˆ–410é”™è¯¯åå›é€€åˆ°ä¸‹ä¸€ä¸ªURLï¼Œæ‰€æœ‰å…¶ä»–é”™è¯¯éƒ½è¢«è§†ä¸ºç»ˆç«¯é”™è¯¯ã€‚ |ï¼šgoå‘½ä»¤åœ¨å‡ºç°ä»»ä½•é”™è¯¯ï¼ˆåŒ…æ‹¬è¶…æ—¶ç­‰éHTTPé”™è¯¯ï¼‰åå›é€€åˆ°ä¸‹ä¸€ä¸ªæºã€‚ GOPROXYçš„URLå¯èƒ½å…·æœ‰httpsã€httpæˆ–fileæ–¹æ¡ˆï¼Œå¦‚æœURLæ²¡æœ‰æ–¹æ¡ˆï¼Œåˆ™å‡å®šä¸ºhttpsã€‚ æ¨¡å—ç¼“å­˜å¯ä»¥ç›´æ¥ç”¨ä½œæ–‡ä»¶ä»£ç†ï¼šgo env -w GOPROXY=file://$(go env GOMODCACHE)/cache/downloadã€‚ å¯ä»¥ä½¿ç”¨ä¸¤ä¸ªå…³é”®å­—ä»£æ›¿ä»£ç†URLï¼š offï¼šç¦æ­¢ä»ä»»ä½•æ¥æºä¸‹è½½æ¨¡å—ã€‚ directï¼šç›´æ¥ä»ç‰ˆæœ¬æ§åˆ¶å­˜å‚¨åº“ä¸‹è½½ï¼Œè€Œä¸æ˜¯ä½¿ç”¨æ¨¡å—ä»£ç†ã€‚ $ go env -w GOPROXY=https://goproxy.cn,direct GOSUMDB ç”¨äºåœ¨æ‹‰å–æ¨¡å—ç‰ˆæœ¬æ—¶ï¼ˆæ— è®ºæ˜¯ä»æºç«™æ‹‰å–è¿˜æ˜¯é€šè¿‡Go module proxyæ‹‰å–ï¼‰ä¿è¯æ‹‰å–åˆ°çš„æ¨¡å—ç‰ˆæœ¬æ•°æ®æœªç»è¿‡ç¯¡æ”¹ã€‚è‹¥å‘ç°ä¸ä¸€è‡´ï¼Œä¹Ÿå°±æ˜¯å¯èƒ½å­˜åœ¨ç¯¡æ”¹ï¼Œå°†ä¼šç«‹å³ä¸­æ­¢ã€‚ GOSUMDBçš„é»˜è®¤å€¼ä¸ºï¼šsum.golang.orgï¼Œåœ¨å›½å†…ä¹Ÿæ˜¯æ— æ³•è®¿é—®çš„ï¼Œä½†æ˜¯GOSUMDBå¯ä»¥è¢«Goæ¨¡å—ä»£ç†æ‰€ä»£ç†ã€‚ å› æ­¤æˆ‘ä»¬å¯ä»¥é€šè¿‡è®¾ç½®GOPROXYæ¥è§£å†³ï¼Œè€Œå…ˆå‰æˆ‘ä»¬æ‰€è®¾ç½®çš„æ¨¡å—ä»£ç†goproxy.cnå°±èƒ½æ”¯æŒä»£ç†sum.golang.orgã€‚ æ‰€ä»¥è¿™ä¸€ä¸ªé—®é¢˜åœ¨è®¾ç½®GOPROXYåï¼Œä½ å¯ä»¥ä¸éœ€è¦è¿‡åº¦å…³å¿ƒã€‚ å¦å¤–è‹¥å¯¹GOSUMDBçš„å€¼æœ‰è‡ªå®šä¹‰éœ€æ±‚ï¼Œå…¶æ”¯æŒå¦‚ä¸‹æ ¼å¼ï¼š æ ¼å¼ 1ï¼š\u0026lt;SUMDB_NAME\u0026gt;+\u0026lt;PUBLIC_KEY\u0026gt;ã€‚ æ ¼å¼ 2ï¼š\u0026lt;SUMDB_NAME\u0026gt;+\u0026lt;PUBLIC_KEY\u0026gt; \u0026lt;SUMDB_URL\u0026gt;ã€‚ ä¹Ÿå¯ä»¥å°†å…¶è®¾ç½®ä¸ºâ€œoffâ€ï¼Œä¹Ÿå°±æ˜¯ç¦æ­¢Goåœ¨åç»­æ“ä½œä¸­æ ¡éªŒæ¨¡å—ç‰ˆæœ¬ï¼Œä¹Ÿå°±æ˜¯go env -w GOSUMDB=offã€‚ å¦‚æœGOSUMDBè®¾ç½®ä¸ºoffæˆ–è€…ä½¿ç”¨go getè®¾ç½®-insecureæ ‡å¿—åˆ™ä¸ä¼šæŸ¥è¯¢æ ¡éªŒå’Œæ•°æ®åº“ï¼Œå¹¶æ¥å—æ‰€æœ‰æ— æ³•è¯†åˆ«çš„æ¨¡å—ã€‚ ä»£ä»·æ˜¯æ”¾å¼ƒå¯¹æ‰€æœ‰æ¨¡å—è¿›è¡Œå·²éªŒè¯çš„å¯é‡å¤ä¸‹è½½çš„å®‰å…¨ä¿è¯ã€‚ ç»•è¿‡ç‰¹å®šæ¨¡å—çš„æ ¡éªŒå’Œæ•°æ®åº“çš„æ›´å¥½æ–¹æ³•æ˜¯ä½¿ç”¨GOPRIVATEæˆ–GONOSUMDBç¯å¢ƒå˜é‡ã€‚ ç›¸å…³å‚è€ƒæ–‡æ¡£ï¼šhttps://goproxy.io/zh/docs/GOSUMDB-env.htmlã€‚ GOPRIVATE ç”¨äºå½“å‰é¡¹ç›®ä¾èµ–äº†ç§æœ‰æ¨¡å—ï¼Œå¦‚ä½ å…¬å¸çš„ç§æœ‰gitä»“åº“ï¼Œåˆæˆ–æ˜¯githubä¸­çš„ç§æœ‰åº“ï¼Œéƒ½æ˜¯å±äºç§æœ‰æ¨¡å—ï¼Œéƒ½æ˜¯è¦è¿›è¡Œè®¾ç½®çš„ï¼Œå¦åˆ™ä¼šæ‹‰å–å¤±è´¥ã€‚ å°±æ˜¯ä¾èµ–äº†ç”±GOPROXYæŒ‡å®šçš„Goæ¨¡å—ä»£ç†æˆ–ç”±GOSUMDBæŒ‡å®šGo checksum databaseéƒ½æ— æ³•è®¿é—®åˆ°çš„æ¨¡å—æ—¶çš„åœºæ™¯ã€‚ ä»¥è‹±æ–‡é€—å·â€œ,â€åˆ†å‰²çš„æ¨¡å—è·¯å¾„å‰ç¼€ï¼Œä¹Ÿå°±æ˜¯å¯ä»¥è®¾ç½®å¤šä¸ªï¼Œä¾‹å¦‚ï¼š go env -w GOPRIVATE=\u0026quot;git.example.com,github.com/helium/bms\u0026quot;ã€‚ è®¾ç½®åï¼Œå‰ç¼€ä¸ºgit.xxx.comå’Œgithub.com/helium/bmsçš„æ¨¡å—éƒ½ä¼šè¢«è®¤ä¸ºæ˜¯ç§æœ‰æ¨¡å—ã€‚ å¦‚æœä¸æƒ³æ¯æ¬¡éƒ½é‡æ–°è®¾ç½®ï¼Œæˆ‘ä»¬ä¹Ÿå¯ä»¥åˆ©ç”¨é€šé…ç¬¦ï¼Œä¾‹å¦‚ï¼š go env -w GOPRIVATE=\u0026quot;*.example.com\u0026quot;ã€‚ è¿™æ ·å­è®¾ç½®çš„è¯ï¼Œæ‰€æœ‰æ¨¡å—è·¯å¾„ä¸ºexample.comçš„å­åŸŸå(ä¾‹å¦‚ï¼šgit.example.com)éƒ½å°†ä¸ç»è¿‡Go module proxyå’ŒGo checksum databaseã€‚ éœ€è¦æ³¨æ„çš„æ˜¯ä¸åŒ…æ‹¬example.comæœ¬èº«ã€‚ ç›¸å…³å‚è€ƒæ–‡æ¡£ï¼šhttps://goproxy.io/zh/docs/GOPRIVATE-env.htmlã€‚ GONOPROXY ç”¨äºæŒ‡å®šä¸ä½¿ç”¨æ¨¡å—ä»£ç†ï¼ˆå¦‚proxy.golang.orgï¼‰ä¸‹è½½æ¨¡å—çš„æ¨¡å—è·¯å¾„å‰ç¼€åˆ—è¡¨ã€‚ æ¨¡å—ä»£ç†æ˜¯Go 1.13åŠä»¥ä¸Šç‰ˆæœ¬æ¨å‡ºçš„åŠŸèƒ½ï¼Œç”¨äºç¼“å­˜å…¬å…±æ¨¡å—ï¼Œä»¥åŠ å¿«æ¨¡å—ä¸‹è½½é€Ÿåº¦å’Œæé«˜æ¨¡å—ä¸‹è½½çš„å¯é æ€§ã€‚ è¯¥å˜é‡åŒ…å«ä¸€ä¸ªç”±é€—å·åˆ†éš”çš„æ¨¡å—è·¯å¾„å‰ç¼€åˆ—è¡¨ã€‚ å¦‚æœä½ æœ‰ä¸€ä¸ªç§æœ‰æ¨¡å—å­˜å‚¨åœ¨ git.example.comï¼Œå¹¶å¸Œæœ›Goå‘½ä»¤ç›´æ¥ä»è¯¥ä»“åº“ä¸‹è½½æ¨¡å—è€Œä¸æ˜¯é€šè¿‡æ¨¡å—ä»£ç†ï¼Œä½ å¯ä»¥è®¾ç½®GONOPROXY=git.example.comã€‚ GONOSUMDB ç”¨äºæŒ‡å®šä¸æ£€æŸ¥å…¶æ ¡éªŒå’Œçš„æ¨¡å—è·¯å¾„å‰ç¼€åˆ—è¡¨ã€‚ Go modulesä½¿ç”¨æ ¡éªŒå’Œæ•°æ®åº“ï¼ˆå¦‚sum.golang.orgï¼‰æ¥ç¡®ä¿ä¸‹è½½çš„æ¨¡å—ç‰ˆæœ¬æ²¡æœ‰è¢«ç¯¡æ”¹ã€‚ ä¸GONOPROXYç±»ä¼¼ï¼Œè¯¥å˜é‡ä¹ŸåŒ…å«ä¸€ä¸ªç”±é€—å·åˆ†éš”çš„æ¨¡å—è·¯å¾„å‰ç¼€åˆ—è¡¨ã€‚ å‡è®¾ä½ æœ‰ç§æœ‰æ¨¡å—å¹¶ä¸”ä¸å¸Œæœ›Goå‘½ä»¤å°è¯•éªŒè¯è¿™äº›æ¨¡å—çš„æ ¡éªŒå’Œï¼Œä½ å¯ä»¥è®¾ç½®GONOSUMDB=git.example.comã€‚ GOVCS æ§åˆ¶goå‘½ä»¤å¯ä»¥ç”¨æ¥ä¸‹è½½å…¬å…±å’Œç§æœ‰æ¨¡å—ï¼Œï¼ˆç”±å®ƒä»¬çš„è·¯å¾„æ˜¯å¦ä¸GOPRIVATEä¸­çš„æ¨¡å¼åŒ¹é…ï¼‰æˆ–å…¶ä»–ä¸globæ¨¡å¼åŒ¹é…çš„æ¨¡å—çš„ç‰ˆæœ¬æ§åˆ¶å·¥å…·é›†ã€‚ å¦‚æœæœªè®¾ç½®GOVCSï¼Œæˆ–è€…æ¨¡å—ä¸GOVCSä¸­çš„ä»»ä½•æ¨¡å¼éƒ½ä¸åŒ¹é…ï¼Œåˆ™goå‘½ä»¤å¯èƒ½å¯¹å…¬å…±æ¨¡å—ä½¿ç”¨gitå’Œhgï¼Œæˆ–å¯¹ç§æœ‰æ¨¡å—ä½¿ç”¨ä»»ä½•å·²çŸ¥çš„ç‰ˆæœ¬æ§åˆ¶å·¥å…·ã€‚ å…·ä½“æ¥è¯´ï¼Œgoå‘½ä»¤å°±åƒGOVCSè¢«è®¾ç½®ä¸ºï¼ˆé»˜è®¤æ¨¡å¼ï¼‰ï¼špublic:git|hg,private:allã€‚ ","permalink":"https://heliu.site/posts/golang/package/env/","summary":"Golang ç¯å¢ƒå˜é‡ä»‹ç»ã€‚","title":"æ¨¡å—ç›¸å…³ç¯å¢ƒå˜é‡"},{"content":" å·¥ä½œåŒºæ˜¯ç£ç›˜ä¸Šæ¨¡å—çš„é›†åˆï¼Œåœ¨è¿è¡Œæœ€å°ç‰ˆæœ¬é€‰æ‹©(MVS)æ—¶ç”¨ä½œæ ¹æ¨¡å—ã€‚ å·¥ä½œç©ºé—´å¯ä»¥åœ¨go.workæ–‡ä»¶ä¸­å£°æ˜ï¼Œè¯¥æ–‡ä»¶æŒ‡å®šå·¥ä½œç©ºé—´ä¸­æ¯ä¸ªæ¨¡å—çš„æ¨¡å—ç›®å½•çš„ç›¸å¯¹è·¯å¾„ã€‚ å½“ä¸å­˜åœ¨go.workæ–‡ä»¶æ—¶ï¼Œå·¥ä½œåŒºç”±åŒ…å«å½“å‰ç›®å½•çš„å•ä¸ªæ¨¡å—ç»„æˆã€‚ å¤§å¤šæ•°ä¸æ¨¡å—ä¸€èµ·ä½¿ç”¨çš„goå­å‘½ä»¤åœ¨ç”±å½“å‰å·¥ä½œç©ºé—´ç¡®å®šçš„æ¨¡å—é›†ä¸Šè¿è¡Œã€‚ go mod initã€go mod whyã€go mod editã€go mod tidyã€go mod vendorå’Œgo getå§‹ç»ˆåœ¨å•ä¸ªä¸»æ¨¡å—ä¸Šè¿è¡Œã€‚ å‘½ä»¤é¦–å…ˆæ£€æŸ¥-workfileæ ‡å¿—æ¥ç¡®å®šå®ƒæ˜¯å¦åœ¨å·¥ä½œåŒºä¸Šä¸‹æ–‡ä¸­ã€‚å¦‚æœ-workfileè®¾ç½®ä¸ºoffï¼Œåˆ™è¯¥å‘½ä»¤å°†ä½äºå•æ¨¡å—ä¸Šä¸‹æ–‡ä¸­ã€‚ å¦‚æœå®ƒä¸ºç©ºæˆ–æœªæä¾›ï¼Œè¯¥å‘½ä»¤å°†æœç´¢å½“å‰å·¥ä½œç›®å½•ï¼Œç„¶åæ˜¯åç»­çˆ¶ç›®å½•ï¼Œä»¥æŸ¥æ‰¾æ–‡ä»¶go.workã€‚å¦‚æœæ‰¾åˆ°ä¸€ä¸ªæ–‡ä»¶ï¼Œè¯¥å‘½ä»¤å°†åœ¨å®ƒå®šä¹‰çš„å·¥ä½œç©ºé—´ä¸­è¿è¡Œï¼› å¦åˆ™ï¼Œå·¥ä½œåŒºå°†ä»…åŒ…å«åŒ…å«å·¥ä½œç›®å½•çš„æ¨¡å—ã€‚å¦‚æœ-workfileå‘½åä»¥.workç»“å°¾çš„ç°æœ‰æ–‡ä»¶çš„è·¯å¾„ï¼Œåˆ™å°†å¯ç”¨å·¥ä½œåŒºæ¨¡å¼ã€‚ä»»ä½•å…¶ä»–å€¼éƒ½æ˜¯é”™è¯¯ã€‚ go.workæ–‡ä»¶ä¸€èˆ¬ä¸ä¼ åˆ°gitä¸Šï¼Œåªæ˜¯æœ¬åœ°ä¸€ä¸ªå…¬å…±åŒºæ–‡ä»¶ã€‚ go.workæ–‡ä»¶ å·¥ä½œç©ºé—´ç”±åä¸ºgo.workï¼ŒUTF-8ç¼–ç æ–‡æœ¬æ–‡ä»¶å®šä¹‰ã€‚ go.workæ–‡ä»¶æ˜¯é¢å‘è¡Œçš„ã€‚æ¯è¡ŒåŒ…å«ä¸€ä¸ªæŒ‡ä»¤ï¼Œç”±å…³é”®å­—å’Œå‚æ•°ç»„æˆã€‚ ä¾‹å¦‚ï¼š go 1.18 use ./my/first/thing use ./my/second/thing replace example.com/bad/thing v1.4.5 =\u0026gt; example.com/good/thing v1.4.5 ä¸go.modæ–‡ä»¶ä¸€æ ·ï¼Œå¯ä»¥ä»ç›¸é‚»è¡Œä¸­åˆ†è§£å‡ºå‰å¯¼å…³é”®å­—æ¥åˆ›å»ºå—ã€‚ use ( ./my/first/thing ./my/second/thing ) goå‘½ä»¤æä¾›äº†å‡ ä¸ªç”¨äºæ“ä½œgo.workæ–‡ä»¶çš„å­å‘½ä»¤ã€‚ go work initï¼šåˆ›å»ºæ–°çš„go.workæ–‡ä»¶ã€‚ go work useï¼šå°†æ¨¡å—ç›®å½•æ·»åŠ åˆ°go.workæ–‡ä»¶ä¸­ã€‚ go work editï¼šæ‰§è¡Œä½çº§ç¼–è¾‘ã€‚ go work syncï¼šå°†å·¥ä½œåŒºæ„å»ºåˆ—è¡¨åŒæ­¥åˆ°æ¨¡å—ã€‚ Goç¨‹åºå¯ä»¥ä½¿ç”¨golang.org/x/mod/modfileåŒ…ä»¥ç¼–ç¨‹æ–¹å¼è¿›è¡Œç›¸åŒçš„æ›´æ”¹ã€‚ è¯æ±‡å…ƒç´  go.workæ–‡ä»¶ä¸­çš„è¯æ³•å…ƒç´ çš„å®šä¹‰æ–¹å¼ä¸go.modæ–‡ä»¶å®Œå…¨ç›¸åŒã€‚ è¯­æ³• go.workè¯­æ³•åœ¨ä¸‹é¢ä½¿ç”¨æ‰©å±•å·´ç§‘æ–¯-ç‘™å°”å½¢å¼(EBNF)æŒ‡å®šã€‚æœ‰å…³EBNFè¯­æ³•çš„è¯¦ç»†ä¿¡æ¯ï¼Œè¯·å‚é˜…Goè¯­è¨€è§„èŒƒä¸­çš„ç¬¦å·éƒ¨åˆ†ã€‚ 1 2 3 4 GoWork = { Directive } . Directive = GoDirective | UseDirective | ReplaceDirective . æ¢è¡Œç¬¦(newline)ã€æ ‡è¯†ç¬¦(ident)å’Œå­—ç¬¦ä¸²(string)åˆ†åˆ«è¡¨ç¤ºã€‚ æ¨¡å—è·¯å¾„å’Œç‰ˆæœ¬ç”¨ModulePathå’ŒVersionè¡¨ç¤ºã€‚æ¨¡å—è·¯å¾„å’Œç‰ˆæœ¬çš„æŒ‡å®šæ–¹å¼ä¸go.modæ–‡ä»¶å®Œå…¨ç›¸åŒã€‚ 1 2 ModulePath = ident | string . /* see restrictions above */ Version = ident | string . /* see restrictions above */ goæŒ‡ä»¤ æœ‰æ•ˆçš„go.workæ–‡ä»¶ä¸­éœ€è¦goæŒ‡ä»¤ã€‚ç‰ˆæœ¬å¿…é¡»æ˜¯æœ‰æ•ˆçš„Goå‘è¡Œç‰ˆæœ¬ï¼šä¸€ä¸ªæ­£æ•´æ•°ï¼Œåè·Ÿä¸€ä¸ªç‚¹å’Œä¸€ä¸ªéè´Ÿæ•´æ•°ï¼ˆä¾‹å¦‚ï¼Œ1.18ã€1.19ï¼‰ã€‚ goæŒ‡ä»¤æŒ‡ç¤ºgo.workæ–‡ä»¶æ‰“ç®—ä½¿ç”¨çš„goå·¥å…·é“¾ç‰ˆæœ¬ã€‚å¦‚æœå¯¹go.workæ–‡ä»¶æ ¼å¼è¿›è¡Œäº†æ›´æ”¹ï¼Œå·¥å…·é“¾çš„æœªæ¥ç‰ˆæœ¬å°†æ ¹æ®å…¶æŒ‡ç¤ºçš„ç‰ˆæœ¬è§£é‡Šæ–‡ä»¶ã€‚ ä¸€ä¸ªgo.workæ–‡ä»¶æœ€å¤šå¯ä»¥åŒ…å«ä¸€ä¸ªgoæŒ‡ä»¤ã€‚ 1 2 GoDirective = \u0026#34;go\u0026#34; GoVersion newline . GoVersion = string | ident . /* valid release version; see above */ ç¤ºä¾‹ï¼š go 1.18 useæŒ‡ä»¤ ç”¨æˆ·å°†ç£ç›˜ä¸Šçš„æ¨¡å—æ·»åŠ åˆ°å·¥ä½œç©ºé—´ä¸­çš„ä¸»è¦æ¨¡å—é›†ã€‚å®ƒçš„å‚æ•°æ˜¯åŒ…å«æ¨¡å—çš„go.modæ–‡ä»¶çš„ç›®å½•çš„ç›¸å¯¹è·¯å¾„ã€‚ ä½¿ç”¨useæŒ‡ä»¤ä¸ä¼šæ·»åŠ åŒ…å«åœ¨å…¶å‚æ•°ç›®å½•çš„å­ç›®å½•ä¸­çš„æ¨¡å—ã€‚ è¿™äº›æ¨¡å—å¯ä»¥é€šè¿‡åŒ…å«å…¶go.modæ–‡ä»¶çš„ç›®å½•æ·»åŠ åˆ°å•ç‹¬çš„ä½¿ç”¨æŒ‡ä»¤ä¸­ã€‚ 1 2 3 UseDirective = \u0026#34;use\u0026#34; ( UseSpec | \u0026#34;(\u0026#34; newline { UseSpec } \u0026#34;)\u0026#34; newline ) . UseSpec = FilePath newline . FilePath = /* platform-specific relative or absolute file path */ ç¤ºä¾‹ï¼š use ./mymod // example.com/mymod use ( ../othermod ./subdir/thirdmod ) replaceæŒ‡ä»¤ ä¸go.modæ–‡ä»¶ä¸­çš„replaceæŒ‡ä»¤ç±»ä¼¼ï¼Œgo.workæ–‡ä»¶ä¸­çš„replaceæŒ‡ä»¤å°†æ¨¡å—çš„ç‰¹å®šç‰ˆæœ¬æˆ–æ¨¡å—çš„æ‰€æœ‰ç‰ˆæœ¬çš„å†…å®¹æ›¿æ¢ä¸ºå…¶ä»–åœ°æ–¹çš„å†…å®¹ã€‚ go.workä¸­çš„é€šé…ç¬¦æ›¿æ¢ä¼šè¦†ç›–go.modæ–‡ä»¶ä¸­ç‰¹å®šäºç‰ˆæœ¬çš„æ›¿æ¢ã€‚ go.workæ–‡ä»¶ä¸­çš„replaceæŒ‡ä»¤ä¼šè¦†ç›–å·¥ä½œåŒºæ¨¡å—ä¸­ç›¸åŒæ¨¡å—æˆ–æ¨¡å—ç‰ˆæœ¬çš„ä»»ä½•æ›¿æ¢ã€‚ 1 2 3 4 ReplaceDirective = \u0026#34;replace\u0026#34; ( ReplaceSpec | \u0026#34;(\u0026#34; newline { ReplaceSpec } \u0026#34;)\u0026#34; newline ) . ReplaceSpec = ModulePath [ Version ] \u0026#34;=\u0026gt;\u0026#34; FilePath newline | ModulePath [ Version ] \u0026#34;=\u0026gt;\u0026#34; ModulePath Version newline . FilePath = /* platform-specific relative or absolute file path */ ç¤ºä¾‹ï¼š replace golang.org/x/net v1.2.3 =\u0026gt; example.com/fork/net v1.4.5 replace ( golang.org/x/net v1.2.3 =\u0026gt; example.com/fork/net v1.4.5 golang.org/x/net =\u0026gt; example.com/fork/net v1.4.5 golang.org/x/net v1.2.3 =\u0026gt; ./fork/net golang.org/x/net =\u0026gt; ./fork/net ) é”™è¯¯çš„go.work åŒæ—¶åœ¨useå’ŒreplaceæŒ‡å®šç›¸åŒçš„æœ¬åœ°è·¯å¾„ã€‚åŒæ—¶æŒ‡å®š./exampleã€‚ go 1.18 use ( ./hello ./example ) replace ( github.com/link1st/example =\u0026gt; ./example ) ","permalink":"https://heliu.site/posts/golang/package/go-work/","summary":"Golang go.workæ–‡ä»¶å†…å®¹ä»‹ç»ã€‚","title":"go.work æ–‡ä»¶"},{"content":" æ¨¡å—ç”±å…¶æ ¹ç›®å½•ä¸­åä¸ºgo.modï¼ŒUTF-8ç¼–ç æ–‡æœ¬æ–‡ä»¶å®šä¹‰ã€‚ go.modæ–‡ä»¶æ˜¯é¢å‘è¡Œçš„ã€‚æ¯è¡ŒåŒ…å«ä¸€ä¸ªæŒ‡ä»¤ï¼Œç”±å…³é”®å­—åè·Ÿå‚æ•°ç»„æˆã€‚ä¾‹å¦‚ï¼š 1 2 3 4 5 6 7 8 9 module example.com/my/thing go 1.12 require example.com/other/thing v1.0.2 require example.com/new/thing/v2 v2.3.4 exclude example.com/old/thing v1.2.3 replace example.com/bad/thing v1.4.5 =\u0026gt; example.com/good/thing v1.4.5 retract [v1.9.0, v1.9.5] å‰å¯¼å…³é”®å­—å¯ä»¥ä»ç›¸é‚»è¡Œä¸­åˆ†è§£å‡ºæ¥ä»¥åˆ›å»ºä¸€ä¸ªå—ï¼Œå°±åƒåœ¨Go importä¸­ä¸€æ ·ã€‚ 1 2 3 4 require ( example.com/new/thing/v2 v2.3.4 example.com/old/thing v1.2.3 ) go.modæ–‡ä»¶è¢«è®¾è®¡ä¸ºäººç±»å¯è¯»å’Œæœºå™¨å¯å†™ã€‚goå‘½ä»¤æä¾›äº†å‡ ä¸ªæ›´æ”¹go.modæ–‡ä»¶çš„å­å‘½ä»¤ã€‚ä¾‹å¦‚ï¼š go getå¯ä»¥å‡çº§æˆ–é™çº§ç‰¹å®šçš„ä¾èµ–é¡¹ã€‚ åŠ è½½æ¨¡å—å›¾çš„å‘½ä»¤å°†åœ¨éœ€è¦æ—¶è‡ªåŠ¨æ›´æ–°go.modã€‚ go mod editå¯ä»¥æ‰§è¡Œä½çº§ç¼–è¾‘ã€‚ ä¸»æ¨¡å—ä»¥åŠä½¿ç”¨æœ¬åœ°æ–‡ä»¶è·¯å¾„æŒ‡å®šçš„ä»»ä½•æ›¿æ¢æŒ‡ä»¤æ›¿æ¢éƒ½éœ€è¦ä¸€ä¸ªgo.modæ–‡ä»¶ã€‚ä½†æ˜¯ï¼Œç¼ºå°‘æ˜ç¡®çš„go.modæ–‡ä»¶çš„æ¨¡å—å¯èƒ½ä»ç„¶éœ€è¦ä½œä¸ºä¾èµ–é¡¹ï¼Œæˆ–è€…ç”¨ä½œä½¿ç”¨æ¨¡å—ã€‚ è¯æ±‡å…ƒç´  å¯¹ä¸€ä¸ªgo.modæ–‡ä»¶è¿›è¡Œåˆ†æï¼Œå…¶å†…å®¹è¢«åˆ†æˆæ ‡è®°å½¢å¼ã€‚ æœ‰å‡ ç§æ ‡è®°ï¼šç©ºæ ¼ã€æ³¨é‡Šã€æ ‡ç‚¹ç¬¦å·ã€å…³é”®å­—ã€æ ‡è¯†ç¬¦å’Œå­—ç¬¦ä¸²ã€‚ ç©ºç™½ï¼šç”±ç©ºæ ¼(U+0020)ã€åˆ¶è¡¨ç¬¦(U+0009)ã€å›è½¦(U+000D)å’Œæ¢è¡Œç¬¦(U+000A)ç»„æˆã€‚ é™¤äº†æ¢è¡Œç¬¦ä¹‹å¤–çš„ç©ºç™½å­—ç¬¦æ²¡æœ‰ä»»ä½•ä½œç”¨ï¼Œé™¤éåˆ†éš”æœ¬æ¥ä¸å…¶ä»–ç»„åˆçš„æ ‡è®°ã€‚ æ¢è¡Œç¬¦æ˜¯é‡è¦çš„æ ‡è®°ã€‚ æ³¨é‡Šï¼šä»¥//å¼€å§‹åˆ°è¡Œå°¾ã€‚/**/æ³¨é‡Šä¸å…è®¸æ·»åŠ æ³¨é‡Šæ–‡æ¡ˆã€‚ æ ‡ç‚¹ç¬¦å·ï¼šåŒ…æ‹¬ï¼ˆ,ï¼‰å’Œ=\u0026gt;ã€‚ å…³é”®å­—ï¼šæ˜¯åŒºåˆ†go.modæ–‡ä»¶ä¸­ä¸åŒç§ç±»çš„æŒ‡ä»¤ã€‚ å…è®¸çš„å…³é”®å­—moduleï¼Œgoï¼Œrequireï¼Œreplaceï¼Œexcludeï¼Œretractã€‚ æ ‡è¯†ç¬¦ï¼šéç©ºç™½å­—ç¬¦çš„åºåˆ—ï¼Œä¾‹å¦‚æ¨¡å—è·¯å¾„æˆ–è¯­ä¹‰ç‰ˆæœ¬ã€‚ å­—ç¬¦ä¸²ï¼šå¸¦å¼•å·çš„å­—ç¬¦åºåˆ—ï¼Œæœ‰ä¸¤ç§å­—ç¬¦ä¸²ï¼š ä»¥å¼•å·(\u0026quot;,U+0022)å¼€å¤´å’Œç»“å°¾çš„è§£é‡Šå­—ç¬¦ä¸²ã€‚ è§£é‡Šçš„å­—ç¬¦ä¸²å¯èƒ½åŒ…å«ç”±åæ–œæ (\\,U+005C)åè·Ÿå¦ä¸€ä¸ªå­—ç¬¦ç»„æˆçš„è½¬ä¹‰åºåˆ—ã€‚ è½¬ä¹‰å¼•å·(\\\u0026quot;)ä¸ä¼šç»ˆæ­¢å·²è§£é‡Šçš„å­—ç¬¦ä¸²ã€‚ è§£é‡Šå­—ç¬¦ä¸²çš„ä¸å¸¦å¼•å·çš„å€¼æ˜¯å¼•å·ä¹‹é—´çš„å­—ç¬¦åºåˆ—ï¼Œæ¯ä¸ªè½¬ä¹‰åºåˆ—éƒ½è¢«åæ–œæ åé¢çš„å­—ç¬¦\\\u0026ldquo;æ›¿æ¢ï¼ˆä¾‹å¦‚ï¼Œè¢«æ›¿æ¢ä¸º\u0026rdquo;ï¼Œ\\nè¢«æ›¿æ¢ä¸ºnï¼‰ã€‚ ä»¥é‡éŸ³ç¬¦ (`,U+0060)å¼€å¤´å’Œç»“å°¾çš„åŸå§‹å­—ç¬¦ä¸²ã€‚ ç›¸æ¯”ä¹‹ä¸‹ï¼ŒåŸå§‹å­—ç¬¦ä¸²çš„ä¸å¸¦å¼•å·çš„å€¼åªæ˜¯é‡éŸ³ç¬¦ä¹‹é—´çš„å­—ç¬¦åºåˆ—ï¼Œåæ–œæ åœ¨åŸå§‹å­—ç¬¦ä¸²ä¸­æ²¡æœ‰ç‰¹æ®Šå«ä¹‰ã€‚ æ ‡è¯†ç¬¦å’Œå­—ç¬¦ä¸²åœ¨go.modè¯­æ³•ä¸­æ˜¯å¯ä»¥äº’æ¢çš„ã€‚ æ¨¡å—è·¯å¾„å’Œç‰ˆæœ¬ go.modæ–‡ä»¶ä¸­çš„å¤§å¤šæ•°æ ‡è¯†ç¬¦å’Œå­—ç¬¦ä¸²è¦ä¹ˆæ˜¯æ¨¡å—è·¯å¾„ï¼Œè¦ä¹ˆæ˜¯ç‰ˆæœ¬ã€‚ æ¨¡å—è·¯å¾„å¿…é¡»æ»¡è¶³ä»¥ä¸‹è¦æ±‚ï¼š è·¯å¾„å¿…é¡»ç”±ä¸€ä¸ªæˆ–å¤šä¸ªä»¥æ–œçº¿(/,U+002F)åˆ†éš”çš„è·¯å¾„å…ƒç´ ç»„æˆï¼Œå®ƒä¸èƒ½ä»¥æ–œçº¿å¼€å¤´æˆ–ç»“å°¾ã€‚ æ¯ä¸ªè·¯å¾„æ˜¯ç”±å¤šä¸ªASCIIå­—æ¯ï¼ŒASCIIæ•°å­—æˆ–éç©ºå­—ç¬¦ä¸²ï¼Œå’Œæœ‰é™çš„ASCIIæ ‡ç‚¹ç¬¦å·ï¼ˆ-ã€.ã€_ã€~ï¼‰ã€‚ è·¯å¾„å…ƒç´ ä¸èƒ½ä»¥ç‚¹(., U+002E)å¼€å§‹æˆ–ç»“æŸã€‚ ç›´åˆ°ç¬¬ä¸€ä¸ªç‚¹çš„å…ƒç´ å‰ç¼€ä¸èƒ½æ˜¯Windowsä¸Šçš„ä¿ç•™æ–‡ä»¶åï¼Œæ— è®ºå¤§å°å†™ï¼ˆCONã€com1ã€NuLç­‰ï¼‰ï¼Œä¸èƒ½ä»¥con.æˆ–com1.æˆ–Nul.ç­‰å¼€å¤´ã€‚ ç¬¬ä¸€ä¸ªç‚¹ä¹‹å‰çš„å…ƒç´ å‰ç¼€ä¸å¾—ä»¥æ³¢æµªå·(~)åè·Ÿä¸€ä¸ªæˆ–å¤šä¸ªæ•°å­—ï¼ˆå¦‚EXAMPL~1.COMï¼‰ç»“å°¾ã€‚ å¦‚æœæ¨¡å—è·¯å¾„å‡ºç°åœ¨requireæŒ‡ä»¤ä¸­å¹¶ä¸”æ²¡æœ‰è¢«æ›¿æ¢ï¼Œæˆ–è€…æ¨¡å—è·¯å¾„å‡ºç°åœ¨replaceæŒ‡ä»¤çš„å³ä¾§ï¼Œåˆ™è¯¥goå‘½ä»¤å¯èƒ½éœ€è¦ä¸‹è½½å…·æœ‰è¯¥è·¯å¾„çš„æ¨¡å—ï¼Œå¹¶ä¸”å¿…é¡»æ»¡è¶³ä¸€äº›é™„åŠ è¦æ±‚ã€‚ å‰å¯¼è·¯å¾„å…ƒç´ ï¼ˆç›´åˆ°ç¬¬ä¸€ä¸ªæ–œæ ï¼Œå¦‚æœæœ‰çš„è¯ï¼‰ï¼ŒæŒ‰ç…§çº¦å®šï¼ŒåŸŸåå¿…é¡»åªåŒ…å«å°å†™ASCIIå­—æ¯ã€ASCIIæ•°å­—ã€ç‚¹ï¼ˆ.,U+002Eï¼‰å’Œç ´æŠ˜å·ï¼ˆ-,U+002Dï¼‰å®ƒå¿…é¡»è‡³å°‘åŒ…å«ä¸€ä¸ªç‚¹ï¼Œå¹¶ä¸”ä¸èƒ½ä»¥ç ´æŠ˜å·å¼€å¤´ã€‚ å¯¹äºå½¢å¼çš„æœ€ç»ˆè·¯å¾„å…ƒç´ /vNåœ¨é‚£é‡ŒNæ˜¯æ•°å­—ï¼ˆASCIIæ•°å­—å’Œç‚¹ï¼‰ï¼ŒNä¸å¾—å¸¦å‰å¯¼é›¶çš„å¼€å§‹ï¼Œä¸€å®šä¸èƒ½/v1ï¼Œä¸€å®šä¸èƒ½åŒ…å«ä»»ä½•åœ†ç‚¹ã€‚ å¯¹äºä»¥gopkg.in/å¼€å¤´çš„è·¯å¾„ï¼Œæ­¤è¦æ±‚å°†æ›¿æ¢ä¸ºè·¯å¾„éµå¾ªgopkg.inæœåŠ¡çº¦å®šçš„è¦æ±‚ã€‚ go.modæ–‡ä»¶ä¸­çš„ç‰ˆæœ¬å¯èƒ½æ˜¯è§„èŒƒçš„æˆ–éè§„èŒƒçš„ï¼Œè§„èŒƒç‰ˆæœ¬ä»¥å­—æ¯vå¼€å¤´ï¼Œåè·Ÿç¬¦åˆè¯­ä¹‰ç‰ˆæœ¬æ§åˆ¶2.0.0è§„èŒƒçš„è¯­ä¹‰ç‰ˆæœ¬ã€‚ éè§„èŒƒç‰ˆæœ¬åªå…è®¸åœ¨ä¸»æ¨¡å—çš„go.modæ–‡ä»¶ä¸­ï¼Œè¯¥goå‘½ä»¤å°†å°è¯•æ—¶ï¼Œå®ƒä¼šè‡ªåŠ¨ç”¨ç­‰æ•ˆçš„è§„èŒƒç‰ˆæœ¬æ›¿æ¢æ¯ä¸ªéè§„èŒƒç‰ˆæœ¬æ›´æ–°çš„go.modæ–‡ä»¶ã€‚ åœ¨ä¸€ä¸ªæ¨¡å—è·¯å¾„ä¸ç‰ˆæœ¬ç›¸å…³çš„åœ°æ–¹ï¼ˆå¦‚requireï¼Œreplaceå’ŒexcludeæŒ‡ä»¤ï¼‰ï¼Œæœ€åçš„è·¯å¾„å…ƒç´ å¿…é¡»ä¸ç‰ˆæœ¬æ˜¯ä¸€è‡´çš„ï¼Œè¯·å‚é˜…ä¸»è¦ç‰ˆæœ¬åç¼€ã€‚ è¯­æ³• go.modä¸‹é¢ä½¿ç”¨æ‰©å±•å·´ç§‘æ–¯-è¯ºå°”å½¢å¼(EBNF)æŒ‡å®šè¯­æ³•ã€‚æœ‰å…³EBNFè¯­æ³•çš„è¯¦ç»†ä¿¡æ¯ï¼Œè¯·å‚é˜…Goè¯­è¨€è§„èŒƒä¸­çš„ç¬¦å·éƒ¨åˆ†ã€‚ 1 2 3 4 5 6 7 GoMod = { Directive } . Directive = ModuleDirective | GoDirective | RequireDirective | ExcludeDirective | ReplaceDirective | RetractDirective . æ¢è¡Œï¼Œæ ‡è¯†ç¬¦å’Œå­—ç¬¦ä¸²åˆ†åˆ«æ ‡æ³¨newlineï¼Œidentå’Œ stringã€‚ æ¨¡å—è·¯å¾„å’Œç‰ˆæœ¬ç”¨ModulePathå’Œè¡¨ç¤ºVersionã€‚ 1 2 ModulePath = ident | string . /* see restrictions above */ Version = ident | string . /* see restrictions above */ moduleæ¨¡å—æŒ‡ä»¤ ä¸€ä¸ªmoduleæŒ‡ä»¤å®šä¹‰äº†ä¸»æ¨¡å—çš„è·¯å¾„ã€‚ä¸€ä¸ªgo.modæ–‡ä»¶å¿…é¡»åªåŒ…å«ä¸€ä¸ªmoduleæŒ‡ä»¤ã€‚ moduleæŒ‡ä»¤å®šä¹‰äº†æ¨¡å—åç§°ï¼š ModuleDirective = \u0026quot;module\u0026quot; ( ModulePath | \u0026quot;(\u0026quot; newline ModulePath newline \u0026quot;)\u0026quot; ) newline . ç¤ºä¾‹ï¼š module golang.org/x/net Deprecatedï¼šå¼ƒç”¨æ ‡å¿— å¯ä»¥åœ¨Deprecated:æ®µè½å¼€å¤´åŒ…å«å­—ç¬¦ä¸²ï¼ˆåŒºåˆ†å¤§å°å†™ï¼‰çš„æ³¨é‡Šå—ä¸­å°†æ¨¡å—æ ‡è®°ä¸ºå·²å¼ƒç”¨ã€‚ å¼ƒç”¨æ¶ˆæ¯åœ¨å†’å·ä¹‹åå¼€å§‹å¹¶è¿è¡Œåˆ°æ®µè½çš„æœ«å°¾ã€‚æ³¨é‡Šå¯èƒ½å‡ºç°åœ¨moduleæŒ‡ä»¤ä¹‹å‰æˆ–ä¹‹åå‡ºç°åœ¨åŒä¸€è¡Œã€‚ ç¤ºä¾‹ï¼š // Deprecated: æ”¹ç”¨ example.com/mod/v2 module example.com/mod ä»Go 1.17å¼€å§‹ï¼Œgo list -m -uæ£€æŸ¥æ„å»ºåˆ—è¡¨ä¸­æ‰€æœ‰å¼ƒç”¨æ¨¡å—çš„ä¿¡æ¯ã€‚go getæ£€æŸ¥æ„å»ºåœ¨å‘½ä»¤è¡Œä¸Šå‘½åçš„åŒ…æ‰€éœ€çš„ä¸æ¨èä½¿ç”¨çš„æ¨¡å—ã€‚ å½“è¯¥goå‘½ä»¤æ£€ç´¢æ¨¡å—çš„å¼ƒç”¨ä¿¡æ¯æ—¶ï¼Œå®ƒä¼šä»ä¸@latestç‰ˆæœ¬æŸ¥è¯¢åŒ¹é…çš„ç‰ˆæœ¬åŠ è½½go.modæ–‡ä»¶ï¼Œè€Œä¸è€ƒè™‘æ’¤å›çš„æˆ–æ’é™¤çš„ã€‚goå‘½ä»¤ä»åŒä¸€ä¸ªgo.modæ–‡ä»¶åŠ è½½æ’¤å›ã€‚ è¦å¼ƒç”¨æ¨¡å—ï¼Œä½œè€…å¯ä»¥æ·»åŠ // Deprecated:è¯„è®ºå¹¶æ ‡è®°æ–°ç‰ˆæœ¬ã€‚ä½œè€…å¯èƒ½ä¼šåœ¨æ›´é«˜ç‰ˆæœ¬ä¸­æ›´æ”¹æˆ–åˆ é™¤å¼ƒç”¨æ¶ˆæ¯ã€‚ å¼ƒç”¨é€‚ç”¨äºæ¨¡å—çš„æ‰€æœ‰æ¬¡è¦ç‰ˆæœ¬ã€‚ä»¥v2ä¸ºä¾‹ï¼Œä¸»ç‰ˆæœ¬é«˜äºè¢«è®¤ä¸ºæ˜¯å•ç‹¬çš„æ¨¡å—ï¼Œå› ä¸ºå®ƒä»¬çš„ä¸»ç‰ˆæœ¬åç¼€ä¸ºå®ƒä»¬æä¾›äº†ä¸åŒçš„æ¨¡å—è·¯å¾„ã€‚ å¼ƒç”¨æ¶ˆæ¯æ—¨åœ¨é€šçŸ¥ç”¨æˆ·è¯¥æ¨¡å—ä¸å†å—æ”¯æŒå¹¶æä¾›è¿ç§»è¯´æ˜ï¼Œä¾‹å¦‚è¿ç§»åˆ°æœ€æ–°çš„ä¸»è¦ç‰ˆæœ¬ã€‚ä¸èƒ½å¼ƒç”¨å•ä¸ªæ¬¡è¦ç‰ˆæœ¬å’Œè¡¥ä¸ç‰ˆæœ¬ï¼Œretractå¯èƒ½æ›´é€‚åˆå•ä¸ªç‰ˆæœ¬ã€‚ go ç‰ˆæœ¬æŒ‡ä»¤ ä¸€ä¸ªgoæŒ‡ä»¤è¡¨æ˜ä¸€ä¸ªæ¨¡å—æ˜¯åœ¨å‡è®¾Goçš„ç»™å®šç‰ˆæœ¬çš„è¯­ä¹‰çš„æƒ…å†µä¸‹ç¼–å†™çš„ã€‚ ç‰ˆæœ¬å¿…é¡»æ˜¯æœ‰æ•ˆçš„Goå‘å¸ƒç‰ˆæœ¬ï¼šä¸€ä¸ªæ­£æ•´æ•°ï¼Œåè·Ÿä¸€ä¸ªç‚¹å’Œä¸€ä¸ªéè´Ÿæ•´æ•°ï¼ˆä¾‹å¦‚ï¼Œ1.9,1.14ï¼‰ã€‚ç¤ºä¾‹ï¼šgo 1.14ã€‚ goæŒ‡ä»¤æœ€åˆæ—¨åœ¨æ”¯æŒGoè¯­è¨€çš„å‘åä¸å…¼å®¹æ›´æ”¹ï¼ˆè¯·å‚é˜…Go 2 transitionï¼‰ã€‚ è‡ªå¼•å…¥æ¨¡å—ä»¥æ¥ï¼Œæ²¡æœ‰å‘ç”Ÿä¸å…¼å®¹çš„è¯­è¨€æ›´æ”¹ï¼Œä½†è¯¥goæŒ‡ä»¤ä»ç„¶å½±å“æ–°è¯­è¨€åŠŸèƒ½çš„ä½¿ç”¨ï¼š å¯¹äºæ¨¡å—å†…çš„åŒ…ï¼Œç¼–è¯‘å™¨æ‹’ç»ä½¿ç”¨åœ¨goæŒ‡ä»¤æŒ‡å®šçš„ç‰ˆæœ¬ä¹‹åå¼•å…¥çš„è¯­è¨€åŠŸèƒ½ã€‚ä¾‹å¦‚ï¼Œå¦‚æœä¸€ä¸ªæ¨¡å—æœ‰æŒ‡ä»¤go 1.12ï¼Œå®ƒçš„åŒ…å¯èƒ½ä¸ä¼šä½¿ç”¨åƒ1_000_000 Go 1.13ä¸­å¼•å…¥çš„æ•°å­—æ–‡å­—ã€‚ å¦‚æœè¾ƒæ—§çš„Goç‰ˆæœ¬æ„å»ºæ¨¡å—çš„åŒ…ä¹‹ä¸€å¹¶é‡åˆ°ç¼–è¯‘é”™è¯¯ï¼Œåˆ™è¯¥é”™è¯¯ä¼šæŒ‡å‡ºè¯¥æ¨¡å—æ˜¯ä¸ºè¾ƒæ–°çš„Goç‰ˆæœ¬ç¼–å†™çš„ã€‚å‡è®¾ä¸€ä¸ªæ¨¡å—æœ‰go 1.13ä¸€ä¸ªåŒ…ä½¿ç”¨æ•°å­—æ–‡å­—1_000_000ã€‚å¦‚æœè¯¥åŒ…æ˜¯ç”¨Go 1.12æ„å»ºçš„ï¼Œç¼–è¯‘å™¨ä¼šæ³¨æ„åˆ°ä»£ç æ˜¯ä¸ºGo 1.13ç¼–å†™çš„ã€‚ åœ¨go 1.17æˆ–æ›´é«˜ç‰ˆæœ¬ï¼š go.modæ–‡ä»¶ä¸ºæ¯ä¸ªæ¨¡å—åŒ…å«ä¸€ä¸ªæ˜¾å¼çš„requireæŒ‡ä»¤ï¼Œè¯¥æŒ‡ä»¤æä¾›ç”±ä¸»æ¨¡å—ä¸­çš„åŒ…æˆ–æµ‹è¯•ä¼ é€’å¯¼å…¥çš„ä»»ä½•åŒ…ã€‚ï¼ˆåœ¨go 1.16åŠæ›´ä½ç‰ˆæœ¬ä¸­ï¼Œä»…å½“æœ€å°ç‰ˆæœ¬é€‰æ‹©ä¼šé€‰æ‹©ä¸åŒç‰ˆæœ¬æ—¶æ‰åŒ…å«é—´æ¥ä¾èµ–é¡¹ã€‚ï¼‰æ­¤é¢å¤–ä¿¡æ¯å¯ç”¨æ¨¡å—å›¾ä¿®å‰ªå’Œå»¶è¿Ÿæ¨¡å—åŠ è½½ã€‚ ç”±äºå¯èƒ½å­˜åœ¨// indirectæ¯”ä»¥å‰goç‰ˆæœ¬æ›´å¤šçš„ä¾èµ–é¡¹ ï¼Œå› æ­¤é—´æ¥ä¾èµ–é¡¹è®°å½•åœ¨go.modæ–‡ä»¶ä¸­çš„å•ç‹¬å—ä¸­ã€‚ go mod vendorçœç•¥äº†vendorä¾èµ–çš„go.modå’Œgo.sumæ–‡ä»¶ã€‚ï¼ˆè¿™å…è®¸åœ¨vendorçš„å­ç›®å½•ä¸­è°ƒç”¨goå‘½ä»¤æ¥è¯†åˆ«æ­£ç¡®çš„ä¸»æ¨¡å—ã€‚ï¼‰ go mod vendorå°†goæ¯ä¸ªä¾èµ–é¡¹go.modæ–‡ä»¶çš„ç‰ˆæœ¬è®°å½•åœ¨vendor/modules.txtã€‚ ä¸€ä¸ªgo.modæ–‡ä»¶æœ€å¤šå¯ä»¥åŒ…å«ä¸€ä¸ªgoæŒ‡ä»¤ã€‚å¦‚æœå½“å‰Goç‰ˆæœ¬ä¸å­˜åœ¨ï¼Œå¤§å¤šæ•°å‘½ä»¤ä¼šæ·»åŠ ä¸€ä¸ªgoæŒ‡ä»¤ã€‚ 1 2 GoDirective = \u0026#34;go\u0026#34; GoVersion newline . GoVersion = string | ident . /* valid release version; see above */ require éœ€æ±‚æŒ‡ä»¤ ä¸€ä¸ªrequireæŒ‡ä»¤å£°æ˜ä¸€ä¸ªç»™å®šçš„æ¨¡å—ä¾èµ–çš„æœ€ä½ç‰ˆæœ¬ã€‚å¯¹äºæ¯ä¸ªæ‰€éœ€çš„æ¨¡å—ç‰ˆæœ¬ï¼Œgoå‘½ä»¤åŠ è½½è¯¥ç‰ˆæœ¬çš„go.modæ–‡ä»¶å¹¶åˆå¹¶æ¥è‡ªè¯¥æ–‡ä»¶çš„requireã€‚åŠ è½½æ‰€æœ‰requireåï¼Œgoå‘½ä»¤å°†ä½¿ç”¨æœ€å°ç‰ˆæœ¬é€‰æ‹© (MVS)è§£å†³å®ƒä»¬ä»¥ç”Ÿæˆæ„å»ºåˆ—è¡¨ã€‚ goå‘½ä»¤ä¼šè‡ªåŠ¨ä¸ºæŸäº›requireæ·»åŠ // indirecté—´æ¥ä¾èµ–æ³¨é‡Šã€‚// indirectè¡¨ç¤ºä¸»æ¨¡å—ä¸­çš„ä»»ä½•åŒ…éƒ½ä¸ä¼šç›´æ¥å¯¼å…¥æ‰€éœ€æ¨¡å—ä¸­çš„åŒ…ã€‚ å¦‚æœgoæŒ‡ä»¤æŒ‡å®šgo 1.16æˆ–æ›´ä½ç‰ˆæœ¬ï¼Œåˆ™å½“æ‰€é€‰æ¨¡å—çš„ç‰ˆæœ¬é«˜äºä¸»æ¨¡å—çš„å…¶ä»–ä¾èµ–é¡¹å·²ç»æš—ç¤ºï¼ˆä¼ é€’ï¼‰çš„ç‰ˆæœ¬æ—¶ï¼Œgoå‘½ä»¤ä¼šæ·»åŠ ä¸€ä¸ªindirectã€‚è¿™å¯èƒ½æ˜¯ç”±äºæ˜¾å¼å‡çº§ï¼ˆgo get -u ./...ï¼‰ã€åˆ é™¤äº†å…ˆå‰å¼ºåŠ è¦æ±‚çš„å…¶ä»–ä¾èµ–é¡¹ï¼ˆgo mod tidyï¼‰ï¼Œæˆ–è€…å¯¼å…¥äº†ä¸€ä¸ªåŒ…è€Œæ²¡æœ‰ç›¸åº”è¦æ±‚çš„ä¾èµ–é¡¹go.modæ–‡ä»¶ï¼ˆä¾‹å¦‚å®Œå…¨ç¼ºå°‘go.modæ–‡ä»¶çš„ä¾èµ–é¡¹ï¼‰ åœ¨go 1.17åŠæ›´é«˜ç‰ˆæœ¬ä¸­ï¼Œgoå‘½ä»¤ä¸ºæ¯ä¸ªæ¨¡å—æ·»åŠ äº†ä¸€ä¸ªindirectï¼Œè¯¥æ¨¡å—æä¾›ç”±ä¸»æ¨¡å—ä¸­çš„åŒ…æˆ–æµ‹è¯•å¯¼å…¥ï¼ˆç”šè‡³indirectï¼‰çš„ä»»ä½•åŒ…ï¼Œæˆ–ä½œä¸ºå‚æ•°ä¼ é€’ç»™go getã€‚ è¿™äº›æ›´å…¨é¢çš„è¦æ±‚æ”¯æŒæ¨¡å—å›¾ä¿®å‰ªå’Œå»¶è¿Ÿæ¨¡å—åŠ è½½ã€‚ 1 2 RequireDirective = \u0026#34;require\u0026#34; ( RequireSpec | \u0026#34;(\u0026#34; newline { RequireSpec } \u0026#34;)\u0026#34; newline ) . RequireSpec = ModulePath Version newline . ç¤ºä¾‹ï¼š 1 2 3 4 5 6 require golang.org/x/net v1.2.3 require ( golang.org/x/crypto v1.4.5 // indirect golang.org/x/text v1.6.7 ) exclude æ’é™¤æŒ‡ä»¤ excludeæŒ‡ä»¤é˜²æ­¢æ¨¡å—ç‰ˆæœ¬è¢«goå‘½ä»¤åŠ è½½ã€‚(æ’é™¤æŒ‡å®šçš„æ¨¡å—ç‰ˆæœ¬) ä»Go 1.16å¼€å§‹ï¼Œå¦‚æœä»»ä½•go.modæ–‡ä»¶ä¸­çš„requireæŒ‡ä»¤å¼•ç”¨çš„ç‰ˆæœ¬è¢«ä¸»æ¨¡å—çš„go.modæ–‡ä»¶ä¸­çš„excludeæŒ‡ä»¤æ’é™¤ï¼Œåˆ™è¯¥requireå°†è¢«å¿½ç•¥ã€‚ è¿™å¯èƒ½ä¼šå¯¼è‡´åƒgo getå’Œgo mod tidyè¿™æ ·çš„å‘½ä»¤å°†æ›´é«˜ç‰ˆæœ¬çš„æ–°è¦æ±‚æ·»åŠ åˆ°go.modï¼Œå¦‚æœåˆé€‚ï¼Œå¸¦æœ‰// indirectã€‚ åœ¨Go 1.16ä¹‹å‰ï¼Œå¦‚æœä¸€ä¸ªæ’é™¤çš„ç‰ˆæœ¬è¢«requireæŒ‡ä»¤å¼•ç”¨ï¼Œgoå‘½ä»¤ä¼šåˆ—å‡ºæ¨¡å—çš„å¯ç”¨ç‰ˆæœ¬ï¼ˆå¦‚go list -m -versionsæ‰€ç¤ºï¼‰å¹¶åŠ è½½ä¸‹ä¸€ä¸ªæ›´é«˜çš„éæ’é™¤ç‰ˆæœ¬ã€‚è¿™å¯èƒ½å¯¼è‡´ä¸ç¡®å®šçš„ç‰ˆæœ¬é€‰æ‹©ï¼Œå› ä¸ºä¸‹ä¸€ä¸ªæ›´é«˜çš„ç‰ˆæœ¬å¯èƒ½ä¼šéšç€æ—¶é—´çš„æ¨ç§»è€Œæ”¹å˜ã€‚ä¸ºæ­¤ç›®çš„ï¼Œå‘è¡Œç‰ˆå’Œé¢„å‘è¡Œç‰ˆéƒ½è¢«è€ƒè™‘åœ¨å†…ï¼Œä½†ä¼ªç‰ˆæœ¬åˆ™ä¸ç„¶ã€‚å¦‚æœæ²¡æœ‰æ›´é«˜ç‰ˆæœ¬ï¼Œgoå‘½ä»¤æŠ¥é”™ã€‚ excludeæŒ‡ä»¤ä»…é€‚ç”¨äºä¸»æ¨¡å—çš„go.modæ–‡ä»¶ï¼Œåœ¨å…¶ä»–æ¨¡å—ä¸­è¢«å¿½ç•¥ã€‚æœ‰å…³è¯¦ç»†ä¿¡æ¯ï¼Œè¯·å‚é˜…æœ€å°ç‰ˆæœ¬é€‰æ‹©ã€‚ 1 2 ExcludeDirective = \u0026#34;exclude\u0026#34; ( ExcludeSpec | \u0026#34;(\u0026#34; newline { ExcludeSpec } \u0026#34;)\u0026#34; newline ) . ExcludeSpec = ModulePath Version newline . ç¤ºä¾‹ï¼š 1 2 3 4 5 6 exclude golang.org/x/net v1.2.3 exclude ( golang.org/x/crypto v1.4.5 golang.org/x/text v1.6.7 ) replace æ›¿æ¢æŒ‡ä»¤ replaceæŒ‡ä»¤ç”¨åœ¨åˆ«å¤„æ‰¾åˆ°çš„å†…å®¹æ›¿æ¢æ¨¡å—çš„ç‰¹å®šç‰ˆæœ¬æˆ–æ¨¡å—çš„æ‰€æœ‰ç‰ˆæœ¬çš„å†…å®¹ã€‚ä»¥ä½¿ç”¨å¦ä¸€ä¸ªæ¨¡å—è·¯å¾„å’Œç‰ˆæœ¬æˆ–ç‰¹å®šäºå¹³å°çš„æ–‡ä»¶è·¯å¾„æ¥æŒ‡å®šæ›¿æ¢ã€‚ å¦‚æœç®­å¤´å·¦ä¾§(=\u0026gt;)å­˜åœ¨æŸä¸ªç‰ˆæœ¬ï¼Œåˆ™ä»…æ›¿æ¢è¯¥æ¨¡å—çš„ç‰¹å®šç‰ˆæœ¬ã€‚å…¶ä»–ç‰ˆæœ¬å°†æ­£å¸¸è®¿é—®ã€‚å¦‚æœçœç•¥å·¦ç‰ˆæœ¬ï¼Œåˆ™æ›¿æ¢æ¨¡å—çš„æ‰€æœ‰ç‰ˆæœ¬ã€‚ å¦‚æœç®­å¤´å³ä¾§çš„è·¯å¾„æ˜¯ç»å¯¹æˆ–ç›¸å¯¹è·¯å¾„ï¼ˆä»¥./æˆ–../å¼€å¤´ï¼‰ï¼Œåˆ™è§£é‡Šä¸ºæ›¿æ¢æ¨¡å—æ ¹ç›®å½•çš„æœ¬åœ°æ–‡ä»¶è·¯å¾„ï¼Œå¿…é¡»åŒ…å«ä¸€ä¸ªgo.modæ–‡ä»¶ã€‚åœ¨è¿™ç§æƒ…å†µä¸‹å¿…é¡»çœç•¥æ›¿æ¢ç‰ˆæœ¬ã€‚ å¦‚æœå³ä¾§çš„è·¯å¾„ä¸æ˜¯æœ¬åœ°è·¯å¾„ï¼Œåˆ™å¿…é¡»æ˜¯æœ‰æ•ˆçš„æ¨¡å—è·¯å¾„ã€‚åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œéœ€è¦ä¸€ä¸ªç‰ˆæœ¬ã€‚ç›¸åŒçš„æ¨¡å—ç‰ˆæœ¬ä¸å¾—å‡ºç°åœ¨æ„å»ºåˆ—è¡¨ä¸­ã€‚ ä¸ç®¡æ›¿æ¢æ˜¯ç”¨æœ¬åœ°è·¯å¾„è¿˜æ˜¯æ¨¡å—è·¯å¾„æŒ‡å®šçš„ï¼Œå¦‚æœæ›¿æ¢æ¨¡å—æœ‰go.modæ–‡ä»¶ï¼Œå®ƒçš„moduleæŒ‡ä»¤å¿…é¡»åŒ¹é…å®ƒæ›¿æ¢çš„æ¨¡å—è·¯å¾„ã€‚ replaceæŒ‡ä»¤ä»…é€‚ç”¨äºä¸»æ¨¡å—çš„go.modæ–‡ä»¶ï¼Œåœ¨å…¶ä»–æ¨¡å—ä¸­è¢«å¿½ç•¥ã€‚æœ‰å…³è¯¦ç»†ä¿¡æ¯ï¼Œè¯·å‚é˜…æœ€å°ç‰ˆæœ¬é€‰æ‹©ã€‚ å¦‚æœæœ‰å¤šä¸ªä¸»æ¨¡å—ï¼Œåˆ™åº”ç”¨æ‰€æœ‰ä¸»æ¨¡å—çš„ go.mod æ–‡ä»¶ã€‚ ä¸å…è®¸è·¨ä¸»æ¨¡å—å†²çªçš„æ›¿æ¢æŒ‡ä»¤ï¼Œå¹¶ä¸”å¿…é¡»åœ¨ go.work æ–‡ä»¶çš„æ›¿æ¢ä¸­åˆ é™¤æˆ–è¦†ç›–ã€‚ è¯·æ³¨æ„ï¼Œå•ç‹¬çš„replaceæŒ‡ä»¤ä¸ä¼šå°†æ¨¡å—æ·»åŠ åˆ°æ¨¡å—å›¾ä¸­ã€‚åœ¨ä¸»æ¨¡å—çš„go.modæ–‡ä»¶æˆ–ä¾èµ–é¡¹çš„go.modæ–‡ä»¶ä¸­ï¼Œè¿˜éœ€è¦å¼•ç”¨æ›¿æ¢æ¨¡å—ç‰ˆæœ¬çš„requireæŒ‡ä»¤ã€‚å¦‚æœä¸éœ€è¦å·¦ä¾§çš„æ¨¡å—ç‰ˆæœ¬ï¼Œåˆ™æ›¿æ¢æŒ‡ä»¤æ— æ•ˆã€‚ 1 2 3 4 ReplaceDirective = \u0026#34;replace\u0026#34; ( ReplaceSpec | \u0026#34;(\u0026#34; newline { ReplaceSpec } \u0026#34;)\u0026#34; newline ) . ReplaceSpec = ModulePath [ Version ] \u0026#34;=\u0026gt;\u0026#34; FilePath newline | ModulePath [ Version ] \u0026#34;=\u0026gt;\u0026#34; ModulePath Version newline . FilePath = /* platform-specific relative or absolute file path */ ç¤ºä¾‹ï¼š 1 2 3 4 5 6 7 8 replace golang.org/x/net v1.2.3 =\u0026gt; example.com/fork/net v1.4.5 replace ( golang.org/x/net v1.2.3 =\u0026gt; example.com/fork/net v1.4.5 golang.org/x/net =\u0026gt; example.com/fork/net v1.4.5 golang.org/x/net v1.2.3 =\u0026gt; ./fork/net golang.org/x/net =\u0026gt; ./fork/net ) retract æ’¤å›æŒ‡ä»¤ retractæŒ‡ä»¤æŒ‡ç¤ºä¸åº”ä¾èµ–ç”±go.modå®šä¹‰çš„æ¨¡å—çš„ç‰ˆæœ¬æˆ–ç‰ˆæœ¬èŒƒå›´ã€‚å½“ç‰ˆæœ¬è¿‡æ—©å‘å¸ƒæˆ–ç‰ˆæœ¬å‘å¸ƒåå‘ç°ä¸¥é‡é—®é¢˜æ—¶ï¼Œæ’¤å›æŒ‡ä»¤å¾ˆæœ‰ç”¨ã€‚æ’¤å›çš„ç‰ˆæœ¬åº”è¯¥åœ¨ç‰ˆæœ¬æ§åˆ¶å­˜å‚¨åº“å’Œæ¨¡å—ä»£ç†ä¸­ä¿æŒå¯ç”¨ï¼Œä»¥ç¡®ä¿ä¾èµ–äºå®ƒä»¬çš„æ„å»ºä¸ä¼šè¢«ç ´åã€‚æ’¤å›è¿™ä¸ªè¯æ˜¯ä»å­¦æœ¯æ–‡çŒ®ä¸­å€Ÿæ¥çš„ï¼šè¢«æ’¤å›çš„ç ”ç©¶è®ºæ–‡ä»ç„¶å¯ç”¨ï¼Œä½†å®ƒæœ‰é—®é¢˜ï¼Œä¸åº”ä½œä¸ºæœªæ¥å·¥ä½œçš„åŸºç¡€ã€‚ å½“æ¨¡å—ç‰ˆæœ¬è¢«æ’¤å›æ—¶ï¼Œç”¨æˆ·ä¸ä¼šä½¿ç”¨go getã€go mod tidyæˆ–å…¶ä»–å‘½ä»¤è‡ªåŠ¨å‡çº§åˆ°å®ƒã€‚ä¾èµ–äºæ’¤å›ç‰ˆæœ¬çš„æ„å»ºåº”è¯¥ç»§ç»­å·¥ä½œï¼Œä½†æ˜¯å½“ç”¨æˆ·ä½¿ç”¨go list -m -uæ£€æŸ¥æ›´æ–°æˆ–ä½¿ç”¨go getæ›´æ–°ç›¸å…³æ¨¡å—æ—¶ï¼Œä¼šæ”¶åˆ°æ’¤å›é€šçŸ¥ã€‚ è¦æ’¤å›ä¸€ä¸ªç‰ˆæœ¬ï¼Œæ¨¡å—ä½œè€…åº”è¯¥å‘go.modæ·»åŠ ä¸€ä¸ªæ’¤å›æŒ‡ä»¤ï¼Œç„¶åå‘å¸ƒä¸€ä¸ªåŒ…å«è¯¥æŒ‡ä»¤çš„æ–°ç‰ˆæœ¬ã€‚æ–°ç‰ˆæœ¬å¿…é¡»é«˜äºå…¶ä»–å‘å¸ƒæˆ–é¢„å‘å¸ƒç‰ˆæœ¬ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œåœ¨è€ƒè™‘æ’¤å›ä¹‹å‰ï¼Œ@latestç‰ˆæœ¬æŸ¥è¯¢åº”è¯¥è§£æä¸ºæ–°ç‰ˆæœ¬ã€‚goå‘½ä»¤ä»go list -m -retracted $modpath@latestï¼ˆå…¶ä¸­$modpathæ˜¯æ¨¡å—è·¯å¾„ï¼‰æ˜¾ç¤ºçš„ç‰ˆæœ¬åŠ è½½å¹¶åº”ç”¨æ’¤å›ã€‚ é™¤éä½¿ç”¨-retractedæ ‡å¿—ï¼Œå¦åˆ™ä»go list -m -versionsæ‰“å°çš„ç‰ˆæœ¬åˆ—è¡¨ä¸­éšè—å·²æ’¤å›çš„ç‰ˆæœ¬ã€‚è§£æ@\u0026gt;=v1.2.3æˆ–@latestä¹‹ç±»çš„ç‰ˆæœ¬æŸ¥è¯¢æ—¶ï¼Œå°†æ’é™¤æ’¤å›çš„ç‰ˆæœ¬ã€‚ åŒ…å«æ’¤å›çš„ç‰ˆæœ¬å¯èƒ½ä¼šæ’¤å›è‡ªå·±ã€‚å¦‚æœæ¨¡å—çš„æœ€é«˜å‘è¡Œç‰ˆæˆ–é¢„å‘è¡Œç‰ˆè‡ªè¡Œæ”¶å›ï¼Œåˆ™åœ¨æ’é™¤æ”¶å›çš„ç‰ˆæœ¬åï¼Œ@latestæŸ¥è¯¢å°†è§£æä¸ºè¾ƒä½ç‰ˆæœ¬ã€‚ ä¾‹å¦‚ï¼Œè€ƒè™‘æ¨¡å—example.com/mçš„ä½œè€…æ„å¤–å‘å¸ƒç‰ˆæœ¬v1.0.0çš„æƒ…å†µã€‚ä¸ºäº†é˜²æ­¢ç”¨æˆ·å‡çº§åˆ°v1.0.0ï¼Œä½œè€…å¯ä»¥åœ¨go.modä¸­æ·»åŠ ä¸¤ä¸ªæ’¤æ¶ˆæŒ‡ä»¤ï¼Œç„¶åå°†æ’¤å›æ ‡è®°ä¸ºv1.0.1ã€‚ 1 2 3 4 retract ( v1.0.0 // æ„å¤–å‘å¸ƒ v1.0.1 // ä»…åŒ…å«æ’¤å› ) å½“ç”¨æˆ·è¿è¡Œgo get example.com/m@latestæ—¶ï¼Œgoå‘½ä»¤ä»v1.0.1è¯»å–æ’¤å›ï¼Œç°åœ¨æ˜¯æœ€é«˜ç‰ˆæœ¬ã€‚v1.0.0å’Œv1.0.1éƒ½å·²æ’¤å›ï¼Œå› æ­¤goå‘½ä»¤å°†å‡çº§ï¼ˆæˆ–é™çº§ï¼ï¼‰åˆ°ä¸‹ä¸€ä¸ªæœ€é«˜ç‰ˆæœ¬ï¼Œå¯èƒ½æ˜¯v0.9.5ã€‚ æ’¤å›æŒ‡ä»¤å¯ä»¥ä½¿ç”¨å•ä¸ªç‰ˆæœ¬ï¼ˆå¦‚v1.0.0ï¼‰æˆ–å…·æœ‰ä¸Šä¸‹é™çš„å°é—­åŒºé—´ç‰ˆæœ¬ç¼–å†™ï¼Œç”±[å’Œ]åˆ†éš”ï¼ˆå¦‚[v1.1.0, v1.2.0]ï¼‰ã€‚å•ä¸ªç‰ˆæœ¬ç›¸å½“äºä¸Šä¸‹é™ç›¸åŒçš„åŒºé—´ã€‚åƒå…¶ä»–æŒ‡ä»¤ä¸€æ ·ï¼Œå¤šä¸ªæ’¤å›æŒ‡ä»¤å¯ä»¥ç»„åˆåœ¨ä¸€ä¸ªå—ä¸­ï¼Œç”±ï¼ˆåœ¨ä¸€è¡Œçš„æœ«å°¾å’Œï¼‰åœ¨å®ƒè‡ªå·±çš„è¡Œä¸Šåˆ†éš”ã€‚ æ¯ä¸ªæ’¤å›æŒ‡ä»¤éƒ½åº”è¯¥æœ‰ä¸€ä¸ªæ³¨é‡Šæ¥è§£é‡Šæ’¤å›çš„ç†ç”±ï¼Œå°½ç®¡è¿™ä¸æ˜¯å¼ºåˆ¶æ€§çš„ã€‚goå‘½ä»¤å¯èƒ½ä¼šåœ¨æœ‰å…³æ’¤å›ç‰ˆæœ¬çš„è­¦å‘Šå’Œgoåˆ—è¡¨è¾“å‡ºä¸­æ˜¾ç¤ºæ’¤å›æ³¨é‡Šã€‚æ’¤å›æ³¨é‡Šå¯ä»¥å†™åœ¨æ’¤å›æŒ‡ä»¤çš„æ­£ä¸Šæ–¹ï¼ˆä¸­é—´æ²¡æœ‰ç©ºè¡Œï¼‰ï¼Œä¹Ÿå¯ä»¥å†™åœ¨åŒä¸€è¡Œä¹‹åã€‚å¦‚æœæ³¨é‡Šå‡ºç°åœ¨å—ä¸Šæ–¹ï¼Œåˆ™å®ƒé€‚ç”¨äºå—å†…æ²¡æœ‰è‡ªå·±æ³¨é‡Šçš„æ‰€æœ‰æ’¤å›æŒ‡ä»¤ã€‚æ’¤å›æ³¨é‡Šå¯èƒ½è·¨è¶Šå¤šè¡Œã€‚ 1 2 RetractDirective = \u0026#34;retract\u0026#34; ( RetractSpec | \u0026#34;(\u0026#34; newline { RetractSpec } \u0026#34;)\u0026#34; newline ) . RetractSpec = ( Version | \u0026#34;[\u0026#34; Version \u0026#34;,\u0026#34; Version \u0026#34;]\u0026#34; ) newline . ç¤ºä¾‹ï¼š 1 2 3 4 5 6 retract v1.0.0 retract [v1.0.0, v1.9.9] retract ( v1.0.0 [v1.0.0, v1.9.9] ) RetractæŒ‡ä»¤æ˜¯åœ¨Go 1.16ä¸­æ·»åŠ çš„ã€‚å¦‚æœåœ¨ä¸»æ¨¡å—çš„go.modæ–‡ä»¶ä¸­å†™å…¥äº†æ’¤å›æŒ‡ä»¤ï¼Œåˆ™Go 1.15åŠæ›´ä½ç‰ˆæœ¬å°†æŠ¥å‘Šé”™è¯¯ï¼Œå¹¶ä¸”å°†å¿½ç•¥ä¾èµ–é¡¹çš„go.modæ–‡ä»¶ä¸­çš„æ’¤å›æŒ‡ä»¤ã€‚ è‡ªåŠ¨æ›´æ–° å¦‚æœgo.modç¼ºå°‘ä¿¡æ¯æˆ–ä¸èƒ½å‡†ç¡®åæ˜ ç°å®ï¼Œå¤§å¤šæ•°å‘½ä»¤éƒ½ä¼šæŠ¥å‘Šé”™è¯¯ã€‚go getå’Œgo mod tidyå‘½ä»¤å¯ç”¨äºè§£å†³å¤§å¤šæ•°è¿™äº›é—®é¢˜ã€‚ æ­¤å¤–ï¼Œ-mod=modæ ‡å¿—å¯ä»¥ä¸å¤§å¤šæ•°æ¨¡å—æ„ŸçŸ¥å‘½ä»¤ï¼ˆgo buildã€go testç­‰ï¼‰ä¸€èµ·ä½¿ç”¨ï¼Œä»¥æŒ‡ç¤ºgoå‘½ä»¤è‡ªåŠ¨ä¿®å¤go.modå’Œgo.sumä¸­çš„é—®é¢˜ã€‚ ä¾‹å¦‚ï¼Œè€ƒè™‘è¿™ä¸ªgo.modæ–‡ä»¶ï¼š 1 2 3 4 5 6 7 8 9 10 11 12 13 module example.com/M go 1.16 require ( example.com/A v1 example.com/B v1.0.0 example.com/C v1.0.0 example.com/D v1.2.3 example.com/E dev ) exclude example.com/D v1.2.3 ä½¿ç”¨-mod=modè§¦å‘çš„æ›´æ–°å°†éè§„èŒƒç‰ˆæœ¬æ ‡è¯†ç¬¦é‡å†™ä¸ºè§„èŒƒsemverå½¢å¼ï¼Œå› æ­¤example.com/Açš„v1å˜ä¸ºv1.0.0ï¼Œexample.com/Eçš„devæˆä¸ºdevä¸Šæœ€æ–°æäº¤çš„ä¼ªç‰ˆæœ¬åˆ†æ”¯ï¼Œå¯èƒ½æ˜¯v0.0.0-20180523231146-b3f5c0f6e5f1ã€‚ è¯¥æ›´æ–°ä¿®æ”¹äº†è¦æ±‚ä»¥éµå®ˆæ’é™¤è§„åˆ™ï¼Œå› æ­¤å¯¹æ’é™¤çš„example.com/D v1.2.3çš„requireæ›´æ–°ä¸ºä½¿ç”¨example.com/Dçš„ä¸‹ä¸€ä¸ªå¯ç”¨ç‰ˆæœ¬ï¼Œå¯èƒ½æ˜¯v1.2.4æˆ–v1.3.0ã€‚ æ­¤æ›´æ–°åˆ é™¤äº†å¤šä½™æˆ–è¯¯å¯¼æ€§çš„è¦æ±‚ã€‚ä¾‹å¦‚ï¼Œå¦‚æœexample.com/A v1.0.0æœ¬èº«éœ€è¦example.com/B v1.2.0å’Œexample.com/C v1.0.0ï¼Œé‚£ä¹ˆ go.modå¯¹example.com/B v1.0.0çš„è¦æ±‚å…·æœ‰è¯¯å¯¼æ€§ï¼ˆå·²å–ä»£é€šè¿‡example.com/Aéœ€è¦v1.2.0ï¼‰ï¼Œå¹¶ä¸”å®ƒå¯¹example.com/C v1.0.0çš„è¦æ±‚æ˜¯å¤šä½™çš„ï¼ˆæš—ç¤ºexample.com/Aéœ€è¦ç›¸åŒç‰ˆæœ¬ï¼‰ï¼Œå› æ­¤ä¸¤è€…éƒ½å°†è¢«åˆ é™¤ã€‚å¦‚æœä¸»æ¨¡å—åŒ…å«ç›´æ¥ä»example.com/Bæˆ–example.com/Cå¯¼å…¥åŒ…çš„åŒ…ï¼Œé‚£ä¹ˆéœ€æ±‚å°†è¢«ä¿ç•™ä½†æ›´æ–°åˆ°æ­£åœ¨ä½¿ç”¨çš„å®é™…ç‰ˆæœ¬ã€‚ æœ€åï¼Œæ›´æ–°ä»¥è§„èŒƒæ ¼å¼é‡æ–°æ ¼å¼åŒ–go.modï¼Œä»¥ä¾¿æœªæ¥çš„æœºæ¢°æ›´æ”¹å°†å¯¼è‡´æœ€å°å·®å¼‚ã€‚ å¦‚æœåªéœ€è¦æ›´æ”¹æ ¼å¼ï¼Œgoå‘½ä»¤å°†ä¸ä¼šæ›´æ–°go.modã€‚ å› ä¸ºæ¨¡å—å›¾å®šä¹‰äº†importè¯­å¥çš„å«ä¹‰ï¼Œæ‰€ä»¥ä»»ä½•åŠ è½½åŒ…çš„å‘½ä»¤ä¹Ÿä½¿ç”¨go.modï¼Œå› æ­¤å¯ä»¥æ›´æ–°å®ƒï¼ŒåŒ…æ‹¬go buildã€go getã€go installã€go listã€go testã€go mod tidyã€‚ åœ¨Go 1.15åŠæ›´ä½ç‰ˆæœ¬ä¸­ï¼Œé»˜è®¤å¯ç”¨-mod=modæ ‡å¿—ï¼Œå› æ­¤ä¼šè‡ªåŠ¨æ‰§è¡Œæ›´æ–°ã€‚ä»Go 1.16å¼€å§‹ï¼Œgoå‘½ä»¤çš„è¡Œä¸ºå°±åƒè®¾ç½®äº†-mod=readonlyä¸€æ ·ï¼Œå¦‚æœéœ€è¦å¯¹go.modè¿›è¡Œä»»ä½•æ›´æ”¹ï¼Œåˆ™goå‘½ä»¤ä¼šæŠ¥å‘Šé”™è¯¯å¹¶å»ºè®®ä¿®å¤ã€‚ ","permalink":"https://heliu.site/posts/golang/package/go-mod/","summary":"Golang go.modæ–‡ä»¶å†…å®¹ä»‹ç»ã€‚","title":"go.mod æ–‡ä»¶"},{"content":" æœ¬æ•™ç¨‹ä»‹ç»Goä¸­å¤šæ¨¡å—å·¥ä½œåŒºçš„åŸºç¡€çŸ¥è¯†ã€‚ä½¿ç”¨å¤šæ¨¡å—å·¥ä½œåŒºï¼Œæ‚¨å¯ä»¥å‘Šè¯‰Goå‘½ä»¤æ‚¨æ­£åœ¨åŒæ—¶åœ¨å¤šä¸ªæ¨¡å—ä¸­ç¼–å†™ä»£ç ï¼Œå¹¶è½»æ¾åœ°åœ¨è¿™äº›æ¨¡å—ä¸­æ„å»ºå’Œè¿è¡Œä»£ç ã€‚ åœ¨æœ¬æ•™ç¨‹ä¸­ï¼Œæ‚¨å°†åœ¨å…±äº«çš„å¤šæ¨¡å—å·¥ä½œåŒºä¸­åˆ›å»ºä¸¤ä¸ªæ¨¡å—ï¼Œå¯¹è¿™äº›æ¨¡å—è¿›è¡Œæ›´æ”¹ï¼Œå¹¶åœ¨æ„å»ºä¸­æŸ¥çœ‹è¿™äº›æ›´æ”¹çš„ç»“æœã€‚ å¿…é¡»æ¡ä»¶ï¼š Go 1.18æˆ–æ›´é«˜ç‰ˆæœ¬çš„å®‰è£…ã€‚ ç”¨äºç¼–è¾‘ä»£ç çš„å·¥å…·ã€‚ æ‚¨æ‹¥æœ‰çš„ä»»ä½•æ–‡æœ¬ç¼–è¾‘å™¨éƒ½å¯ä»¥æ­£å¸¸å·¥ä½œã€‚ ä¸€ä¸ªå‘½ä»¤ç»ˆç«¯ã€‚Goåœ¨Linuxå’ŒMacä¸Šçš„ä»»ä½•ç»ˆç«¯ä»¥åŠWindowsä¸­çš„PowerShellæˆ–cmdä¸Šéƒ½èƒ½å¾ˆå¥½åœ°å·¥ä½œã€‚ æœ¬æ•™ç¨‹éœ€è¦go1.18æˆ–æ›´é«˜ç‰ˆæœ¬ã€‚ ä½¿ç”¨go.dev/dlä¸­çš„é“¾æ¥ï¼Œç¡®ä¿æ‚¨å·²åœ¨Go 1.18æˆ–æ›´é«˜ç‰ˆæœ¬ä¸­å®‰è£…äº†Goã€‚ åˆ›å»ºä¸€ä¸ªæ¨¡å— é¦–å…ˆï¼Œä¸ºæ‚¨è¦ç¼–å†™çš„ä»£ç åˆ›å»ºä¸€ä¸ªæ¨¡å—ã€‚ æ‰“å¼€å‘½ä»¤æç¤ºç¬¦å¹¶åˆ‡æ¢åˆ°æ‚¨çš„ä¸»ç›®å½•ã€‚ åœ¨Linuxæˆ–Macä¸Šï¼šcdã€‚ åœ¨Windowsä¸Šï¼šC:\\\u0026gt; cd %HOMEPATH%ã€‚ æœ¬æ•™ç¨‹çš„å…¶ä½™éƒ¨åˆ†å°†æ˜¾ç¤º$ä½œä¸ºæç¤ºã€‚æ‚¨ä½¿ç”¨çš„å‘½ä»¤ä¹Ÿå¯ä»¥åœ¨Windowsä¸Šè¿è¡Œã€‚ åœ¨å‘½ä»¤æç¤ºç¬¦ä¸‹ï¼Œä¸ºæ‚¨çš„ä»£ç åˆ›å»ºä¸€ä¸ªåä¸ºå·¥ä½œåŒºçš„ç›®å½•ã€‚ 1 2 $ mkdir workspace $ cd workspace åˆå§‹åŒ–æ¨¡å— æˆ‘ä»¬çš„ç¤ºä¾‹å°†åˆ›å»ºä¸€ä¸ªhelloä¾èµ–äºgolang.org/x/exampleæ¨¡å—çš„æ–°æ¨¡å—ã€‚ åˆ›å»ºhelloæ¨¡å—ï¼š 1 2 3 4 $ mkdir hello $ cd hello $ go mod init example.com/hello go: creating new go.mod: module example.com/hello ä½¿ç”¨go getæ·»åŠ å¯¹golang.org/x/exampleæ¨¡å—çš„ä¾èµ–ï¼ˆå¦‚æœæœ‰éœ€è¦ï¼‰ã€‚ 1 2 3 $ go get golang.org/x/example go: downloading golang.org/x/example v0.0.0-20220304235025-ad95e7f791d8 go get: added golang.org/x/example v0.0.0-20220304235025-ad95e7f791d8 åœ¨helloç›®å½•ä¸‹åˆ›å»ºhello.goï¼Œå†…å®¹å¦‚ä¸‹ï¼š 1 2 3 4 5 6 7 8 9 10 11 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;golang.org/x/example/stringutil\u0026#34; ) func main() { fmt.Println(stringutil.Reverse(\u0026#34;Hello\u0026#34;)) } ç°åœ¨ï¼Œè¿è¡Œhelloç¨‹åºï¼š 1 2 3 $ go mod tidy $ go run . olleH ç›®å½•ç»“æ„ä¸ºï¼š 1 2 3 4 |--workspace |----hello |------hello.go |------go.mod åˆ›å»ºå·¥ä½œåŒº åœ¨è¿™ä¸€æ­¥ä¸­ï¼Œæˆ‘ä»¬å°†åˆ›å»ºä¸€ä¸ªgo.workæ–‡ä»¶æ¥æŒ‡å®šæ¨¡å—çš„å·¥ä½œåŒºã€‚ åˆå§‹åŒ–å·¥ä½œåŒº åœ¨workspaceç›®å½•ä¸­ï¼Œè¿è¡Œï¼š 1 2 3 # go1.18beta2.exe work init ./hello ## æœ¬åœ°ç”¨çš„go1.18beta2ç‰ˆæœ¬ # å½“å‰ç›®å½•æ˜¯ hello çš„ä¸Šçº§ç›®å½•ä¸‹ï¼Œæ‰§è¡Œå®Œgo work initåä¼šç”Ÿæˆä¸€ä¸ªgo.workæ–‡ä»¶ $ go work init ./hello go work initå‘½ä»¤å‘Šè¯‰goä¸ºåŒ…å«./helloç›®å½•ä¸­çš„æ¨¡å—çš„å·¥ä½œç©ºé—´åˆ›å»ºä¸€ä¸ªgo.workæ–‡ä»¶ã€‚ goå‘½ä»¤ç”Ÿæˆä¸€ä¸ªå¦‚ä¸‹æ‰€ç¤ºçš„go.workæ–‡ä»¶ï¼š go 1.18 use ./hello go.workæ–‡ä»¶çš„è¯­æ³•ä¸go.modç›¸ä¼¼ã€‚ goæŒ‡ä»¤å‘Šè¯‰Goåº”è¯¥ä½¿ç”¨å“ªä¸ªç‰ˆæœ¬çš„Goæ¥è§£é‡Šæ–‡ä»¶ã€‚å®ƒç±»ä¼¼äºgo.modæ–‡ä»¶ä¸­çš„goæŒ‡ä»¤ã€‚ useæŒ‡ä»¤å‘Šè¯‰Goåœ¨æ„å»ºæ—¶helloç›®å½•ä¸­çš„æ¨¡å—åº”è¯¥æ˜¯ä¸»æ¨¡å—ã€‚ å› æ­¤ï¼Œåœ¨å·¥ä½œåŒºçš„ä»»ä½•å­ç›®å½•ä¸­ï¼Œè¯¥æ¨¡å—éƒ½å°†å¤„äºæ´»åŠ¨çŠ¶æ€ã€‚ ç›®å½•ç»“æ„ä¸ºï¼š 1 2 3 4 5 |--workspace |----hello |------hello.go |------go.mod |----go.work è¿è¡Œå·¥ä½œåŒºä¸‹çš„ç›®å½• åœ¨workspaceç›®å½•ä¸­ï¼Œè¿è¡Œï¼š 1 2 3 # go1.18beta2.exe run example.com/hello $ go run example.com/hello olleH Goå‘½ä»¤åŒ…æ‹¬å·¥ä½œåŒºä¸­çš„æ‰€æœ‰æ¨¡å—ä½œä¸ºä¸»æ¨¡å—ã€‚è¿™å…è®¸æˆ‘ä»¬åœ¨æ¨¡å—ä¸­å¼•ç”¨ä¸€ä¸ªåŒ…ï¼Œç”šè‡³åœ¨æ¨¡å—ä¹‹å¤–ã€‚ åœ¨æ¨¡å—æˆ–å·¥ä½œåŒºä¹‹å¤–è¿è¡Œgo runå‘½ä»¤ä¼šå¯¼è‡´é”™è¯¯ï¼Œå› ä¸ºgoå‘½ä»¤ä¸çŸ¥é“è¦ä½¿ç”¨å“ªäº›æ¨¡å—ã€‚ æ¥ä¸‹æ¥ï¼Œæˆ‘ä»¬å°†golang.org/x/exampleæ¨¡å—çš„æœ¬åœ°å‰¯æœ¬æ·»åŠ åˆ°å·¥ä½œåŒºã€‚ç„¶åï¼Œæˆ‘ä»¬å°†å‘stringutilåŒ…æ·»åŠ ä¸€ä¸ªæ–°å‡½æ•°ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨å®ƒæ¥ä»£æ›¿Reverseã€‚ ä¸‹è½½å’Œä¿®æ”¹golang.org/x/exampleæ¨¡å— åœ¨è¿™ä¸€æ­¥ä¸­ï¼Œæˆ‘ä»¬å°†ä¸‹è½½åŒ…å«golang.org/x/exampleæ¨¡å—çš„Gitå­˜å‚¨åº“çš„å‰¯æœ¬ï¼Œå°†å…¶æ·»åŠ åˆ°å·¥ä½œåŒºï¼Œç„¶åå‘å…¶ä¸­æ·»åŠ ä¸€ä¸ªæˆ‘ä»¬å°†ä»helloç¨‹åºä¸­ä½¿ç”¨çš„æ–°å‡½æ•°ã€‚ å…‹éš†å­˜å‚¨åº“ï¼Œåœ¨workspaceç›®å½•ä¸­ï¼Œè¿è¡Œgitå‘½ä»¤æ¥å…‹éš†å­˜å‚¨åº“ï¼š 1 2 3 4 5 6 7 8 $ git clone https://github.com/golang/example Cloning into \u0026#39;example\u0026#39;... remote: Enumerating objects: 182, done. remote: Counting objects: 100% (30/30), done. remote: Compressing objects: 100% (20/20), done. remote: Total 182 (delta 6), reused 16 (delta 4), pack-reused 152R Receiving objects: 100% (182/182), 138.39 KiB | 1.05 MiB/s, done. Resolving deltas: 100% (74/74), done. å°†æ¨¡å—æ·»åŠ åˆ°å·¥ä½œåŒºã€‚ 1 2 # go1.18beta2.exe work use ./example $ go work use ./example go work useå‘½ä»¤å°†ä¸€ä¸ªæ–°æ¨¡å—æ·»åŠ åˆ°go.workæ–‡ä»¶ä¸­ã€‚å®ƒç°åœ¨çœ‹èµ·æ¥åƒè¿™æ ·ï¼š go 1.18 use ( ./hello ./example ) ç›®å½•ç»“æ„ï¼š 1 2 3 4 5 6 7 8 |--workspace |----hello |------hello.go |------go.mod |----example |------stringutil |--------reverse.go |----go.work è¯¥æ¨¡å—ç°åœ¨åŒ…æ‹¬example.com/helloæ¨¡å—å’Œgolang.org/x/exampleæ¨¡å—ã€‚ è¿™å°†å…è®¸æˆ‘ä»¬ä½¿ç”¨æˆ‘ä»¬å°†åœ¨stringutilæ¨¡å—çš„å‰¯æœ¬ä¸­ç¼–å†™çš„æ–°ä»£ç ï¼Œè€Œä¸æ˜¯ä½¿ç”¨go getå‘½ä»¤ä¸‹è½½çš„æ¨¡å—ç¼“å­˜ä¸­çš„æ¨¡å—ç‰ˆæœ¬ã€‚ æ·»åŠ æ–°åŠŸèƒ½ï¼š æˆ‘ä»¬å°†åœ¨golang.org/x/example/stringutilåŒ…ä¸­æ·»åŠ ä¸€ä¸ªå°†å­—ç¬¦ä¸²å¤§å†™çš„æ–°å‡½æ•°ã€‚ å°†æ–°æ–‡ä»¶å¤¹æ·»åŠ åˆ°åŒ…å«ä»¥ä¸‹å†…å®¹çš„workspace/example/stringutilç›®å½•ï¼šå¹¶å‘½ä»¤ä¸ºupper.goæ–‡ä»¶ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 package stringutil import \u0026#34;unicode\u0026#34; // ToUpper uppercases all the runes in its argument string. func ToUpper(s string) string { r := []rune(s) for i := range r { r[i] = unicode.ToUpper(r[i]) } return string(r) } ä¿®æ”¹helloç¨‹åºä»¥ä½¿ç”¨è¯¥åŠŸèƒ½ï¼Œä¿®æ”¹workspace/hello/hello.goçš„å†…å®¹ï¼ŒåŒ…å«ä»¥ä¸‹å†…å®¹ï¼š 1 2 3 4 5 6 7 8 9 10 11 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;golang.org/x/example/stringutil\u0026#34; ) func main() { fmt.Println(stringutil.ToUpper(\u0026#34;Hello\u0026#34;)) } è¿è¡Œworkspaceç›®å½•ä¸‹ä»£ç  ä»workspaceç›®å½•ï¼Œè¿è¡Œï¼š 1 2 # go1.18beta2.exe run example.com/hello $ go run example.com/hello Goå‘½ä»¤åœ¨go.workæ–‡ä»¶æŒ‡å®šçš„helloç›®å½•ä¸­æŸ¥æ‰¾å‘½ä»¤è¡Œä¸­æŒ‡å®šçš„example.com/helloæ¨¡å—ï¼ŒåŒæ ·ä½¿ç”¨go.workæ–‡ä»¶è§£ægolang.org/x/exampleå¯¼å…¥ã€‚ å¯ä»¥ä½¿ç”¨go.workè€Œä¸æ˜¯æ·»åŠ æ›¿æ¢æŒ‡ä»¤æ¥è·¨å¤šä¸ªæ¨¡å—å·¥ä½œã€‚ ç”±äºè¿™ä¸¤ä¸ªæ¨¡å—ä½äºåŒä¸€ä¸ªå·¥ä½œåŒºä¸­ï¼Œå› æ­¤å¾ˆå®¹æ˜“åœ¨ä¸€ä¸ªæ¨¡å—ä¸­è¿›è¡Œæ›´æ”¹å¹¶åœ¨å¦ä¸€ä¸ªæ¨¡å—ä¸­ä½¿ç”¨å®ƒã€‚ ","permalink":"https://heliu.site/posts/golang/package/use-work/","summary":"Golang workä½¿ç”¨ä»‹ç»ã€‚","title":"å·¥ä½œåŒºä½¿ç”¨"},{"content":" åœ¨æœ¬æ•™ç¨‹ä¸­ï¼Œæ‚¨å°†åˆ›å»ºä¸¤ä¸ªæ¨¡å—ã€‚ç¬¬ä¸€ä¸ªæ˜¯æ—¨åœ¨ç”±å…¶ä»–åº“æˆ–åº”ç”¨ç¨‹åºå¯¼å…¥çš„åº“ã€‚ç¬¬äºŒä¸ªæ˜¯è°ƒç”¨è€…åº”ç”¨ç¨‹åºï¼Œå®ƒå°†ä½¿ç”¨ç¬¬ä¸€ä¸ªã€‚ æœ¬æ•™ç¨‹çš„åºåˆ—åŒ…æ‹¬ä¸ƒä¸ªç®€çŸ­çš„ä¸»é¢˜ï¼Œæ¯ä¸ªä¸»é¢˜éƒ½è¯´æ˜äº†è¯­è¨€çš„ä¸åŒéƒ¨åˆ†ï¼š åˆ›å»ºä¸€ä¸ªæ¨¡å— â€”â€” ç¼–å†™ä¸€ä¸ªå°æ¨¡å—ï¼Œå…¶ä¸­åŒ…å«å¯ä»¥ä»å¦ä¸€ä¸ªæ¨¡å—è°ƒç”¨çš„å‡½æ•°ã€‚ ä»å¦ä¸€ä¸ªæ¨¡å—è°ƒç”¨æ‚¨çš„ä»£ç  â€”â€” å¯¼å…¥å¹¶ä½¿ç”¨æ‚¨çš„æ–°æ¨¡å—ã€‚ è¿”å›å¹¶å¤„ç†é”™è¯¯ â€”â€” æ·»åŠ ç®€å•çš„é”™è¯¯å¤„ç†ã€‚ è¿”å›ä¸€ä¸ªéšæœºçš„é—®å€™ â€”â€” åœ¨åˆ‡ç‰‡ä¸­å¤„ç†æ•°æ®ï¼ˆGo çš„åŠ¨æ€å¤§å°çš„æ•°ç»„ï¼‰ã€‚ è¿”å›å¤šäººçš„é—®å€™ â€”â€” åœ¨ map ä¸­å­˜å‚¨ é”®/å€¼ å¯¹ã€‚ æ·»åŠ æµ‹è¯• â€”â€” ä½¿ç”¨ Go çš„å†…ç½®å•å…ƒæµ‹è¯•åŠŸèƒ½æ¥æµ‹è¯•ä½ çš„ä»£ç ã€‚ ç¼–è¯‘å’Œå®‰è£…åº”ç”¨ç¨‹åº â€”â€” åœ¨æœ¬åœ°ç¼–è¯‘å’Œå®‰è£…ä½ çš„ä»£ç ã€‚ å¯åŠ¨ä¸€ä¸ªå…¶ä»–äººå¯ä»¥ä½¿ç”¨çš„æ¨¡å— é¦–å…ˆåˆ›å»ºä¸€ä¸ªGoæ¨¡å—ã€‚åœ¨ä¸€ä¸ªæ¨¡å—ä¸­ï¼Œæ‚¨ä¸ºä¸€ç»„ç¦»æ•£ä¸”æœ‰ç”¨çš„åŠŸèƒ½æ”¶é›†ä¸€ä¸ªæˆ–å¤šä¸ªç›¸å…³åŒ…ã€‚ä¾‹å¦‚ï¼Œæ‚¨å¯èƒ½ä¼šåˆ›å»ºä¸€ä¸ªåŒ…å«å…·æœ‰è´¢åŠ¡åˆ†æåŠŸèƒ½çš„åŒ…çš„æ¨¡å—ï¼Œä»¥ä¾¿å…¶ä»–ç¼–å†™è´¢åŠ¡åº”ç”¨ç¨‹åºçš„äººå¯ä»¥ä½¿ç”¨æ‚¨çš„å·¥ä½œã€‚æœ‰å…³å¼€å‘æ¨¡å—çš„æ›´å¤šä¿¡æ¯ï¼Œè¯·å‚é˜… å¼€å‘å’Œå‘å¸ƒæ¨¡å—ã€‚ Goä»£ç è¢«åˆ†ç»„åˆ°åŒ…ä¸­ï¼ŒåŒ…è¢«åˆ†ç»„åˆ°æ¨¡å—ä¸­ã€‚æ‚¨çš„æ¨¡å—æŒ‡å®šäº†è¿è¡Œä»£ç æ‰€éœ€çš„ä¾èµ–é¡¹ï¼ŒåŒ…æ‹¬ Go ç‰ˆæœ¬å’Œå®ƒæ‰€éœ€çš„ä¸€ç»„å…¶ä»–æ¨¡å—ã€‚ å½“æ‚¨åœ¨æ¨¡å—ä¸­æ·»åŠ æˆ–æ”¹è¿›åŠŸèƒ½æ—¶ï¼Œæ‚¨ä¼šå‘å¸ƒæ¨¡å—çš„æ–°ç‰ˆæœ¬ã€‚ç¼–å†™è°ƒç”¨æ¨¡å—ä¸­å‡½æ•°çš„ä»£ç çš„å¼€å‘äººå‘˜å¯ä»¥å¯¼å…¥æ¨¡å—çš„æ›´æ–°åŒ…å¹¶ä½¿ç”¨æ–°ç‰ˆæœ¬è¿›è¡Œæµ‹è¯•ï¼Œç„¶åå†å°†å…¶æŠ•å…¥ç”Ÿäº§ä½¿ç”¨ã€‚ æ‰“å¼€å‘½ä»¤æç¤ºç¬¦å¹¶cdåˆ°æ‚¨çš„ä¸»ç›®å½•ï¼š åœ¨ Linux æˆ– Mac ä¸Šï¼šcdã€‚ åœ¨ Windows ä¸Šï¼šcd %HOMEPATH%ã€‚ ä¸ºæ‚¨çš„Goæ¨¡å—æºä»£ç  åˆ›å»ºä¸€ä¸ªdemoç›®å½•ã€‚ ä¾‹å¦‚ï¼Œä»æ‚¨çš„ä¸»ç›®å½•ä½¿ç”¨ä»¥ä¸‹å‘½ä»¤ï¼š mkdir greetings1 cd greetings1 ä½¿ç”¨go mod initå‘½ä»¤å¯åŠ¨æ‚¨çš„æ¨¡å—ã€‚è¿è¡Œgo mod initå‘½ä»¤ï¼Œç»™å®ƒä½ çš„æ¨¡å—è·¯å¾„ â€”â€” åœ¨è¿™é‡Œï¼Œä½¿ç”¨gitee.com/phpbms/greetingsã€‚ è¿è¡Œgo mod initå‘½ä»¤ï¼Œç»™å®ƒä½ çš„æ¨¡å—è·¯å¾„â€”â€”åœ¨è¿™é‡Œï¼Œä½¿ç”¨gitee.com/phpbms/greetingsã€‚å¦‚æœæ‚¨å‘å¸ƒä¸€ä¸ªæ¨¡å—ï¼Œè¿™å¿…é¡»æ˜¯Goå·¥å…·å¯ä»¥ä»ä¸­ä¸‹è½½æ‚¨çš„æ¨¡å—çš„è·¯å¾„ã€‚é‚£å°†æ˜¯æ‚¨çš„ä»£ç å­˜å‚¨åº“ã€‚æœ‰å…³ä½¿ç”¨æ¨¡å—è·¯å¾„å‘½åæ¨¡å—çš„æ›´å¤šä¿¡æ¯ï¼Œè¯·å‚é˜… ç®¡ç†ä¾èµ–é¡¹ã€‚ $ go mod init gitee.com/phpbms/greetings1 go: creating new go.mod: module gitee.com/phpbms/greetings1 ç›®å½•ç»“æ„ï¼š |--greetings1/ |----go.mod # gitee.com/phpbms/greetings1 è¯¥go mod initå‘½ä»¤ä¼šåˆ›å»ºä¸€ä¸ªgo.modæ–‡ä»¶æ¥è·Ÿè¸ªä»£ç çš„ä¾èµ–å…³ç³»ã€‚åˆ°ç›®å‰ä¸ºæ­¢ï¼Œè¯¥æ–‡ä»¶ä»…åŒ…å«æ¨¡å—çš„åç§°å’Œä»£ç æ”¯æŒçš„Goç‰ˆæœ¬ã€‚ä½†æ˜¯å½“æ‚¨æ·»åŠ ä¾èµ–é¡¹æ—¶ï¼Œgo.modæ–‡ä»¶å°†åˆ—å‡ºæ‚¨çš„ä»£ç æ‰€ä¾èµ–çš„ç‰ˆæœ¬ã€‚è¿™ä½¿æ„å»ºä¿æŒå¯é‡å¤æ€§ï¼Œå¹¶ä½¿æ‚¨å¯ä»¥ç›´æ¥æ§åˆ¶è¦ä½¿ç”¨çš„æ¨¡å—ç‰ˆæœ¬ã€‚ åœ¨æ‚¨çš„æ–‡æœ¬ç¼–è¾‘å™¨ä¸­ï¼Œåˆ›å»ºä¸€ä¸ªç”¨äºç¼–å†™ä»£ç çš„æ–‡ä»¶å¹¶å°†å…¶å‘½åä¸ºgreetings.goã€‚ å°†ä»¥ä¸‹ä»£ç ç²˜è´´åˆ°æ‚¨çš„greetings.goæ–‡ä»¶ä¸­å¹¶ä¿å­˜æ–‡ä»¶ package greetings1 import \u0026#34;fmt\u0026#34; // Hello returns a greeting for the named person. func Hello(name string) string { message := fmt.Sprintf(\u0026#34;Hi, %v. Welcome!\u0026#34;, name) return message } è¿™æ˜¯æ‚¨çš„æ¨¡å—çš„ç¬¬ä¸€ä¸ªä»£ç ã€‚å®ƒä¼šå‘ä»»ä½•è¯·æ±‚çš„å‘¼å«è€…è¿”å›é—®å€™è¯­ã€‚æ‚¨å°†åœ¨ä¸‹ä¸€æ­¥ç¼–å†™è°ƒç”¨æ­¤å‡½æ•°çš„ä»£ç ï¼Œåœ¨æ­¤ä»£ç ä¸­ï¼š å£°æ˜ä¸€ä¸ªgreetings1åŒ…æ¥æ”¶é›†ç›¸å…³åŠŸèƒ½ã€‚ å®ç°ä¸€ä¸ªHelloå‡½æ•°æ¥è¿”å›é—®å€™è¯­ã€‚ è¯¥å‡½æ•°æ¥å—ä¸€ä¸ªnameç±»å‹ä¸ºçš„å‚æ•°stringã€‚è¯¥å‡½æ•°è¿˜è¿”å›ä¸€ä¸ªstringã€‚åœ¨Goä¸­ï¼Œåç§°ä»¥å¤§å†™å­—æ¯å¼€å¤´çš„å‡½æ•°å¯ä»¥è¢«ä¸åœ¨åŒä¸€ä¸ªåŒ…ä¸­çš„å‡½æ•°è°ƒç”¨ã€‚è¿™åœ¨Goä¸­ç§°ä¸ºå¯¼å‡ºåç§°ã€‚æœ‰å…³å¯¼å‡ºåç§°çš„æ›´å¤šä¿¡æ¯ï¼Œè¯·å‚é˜…Go tourä¸­çš„å¯¼å‡ºåç§°ã€‚ å£°æ˜ä¸€ä¸ªmessageå˜é‡æ¥ä¿å­˜ä½ çš„é—®å€™ï¼Œåœ¨Goä¸­ï¼Œ:=è¿ç®—ç¬¦æ˜¯åœ¨ä¸€è¡Œä¸­å£°æ˜å’Œåˆå§‹åŒ–å˜é‡çš„å¿«æ·æ–¹å¼ï¼ˆGoä½¿ç”¨å³ä¾§çš„å€¼æ¥ç¡®å®šå˜é‡çš„ç±»å‹ï¼‰ã€‚ä»é•¿è¿œæ¥çœ‹ï¼Œæ‚¨å¯èƒ½å·²å°†å…¶å†™ä¸ºï¼š var message string message = fmt.Sprintf(\u0026#34;Hi, %v. Welcome!\u0026#34;, name) ç›®å½•ç»“æ„ï¼š |--greetings1/ |----go.mod\t# gitee.com/phpbms/greetings1 |----greetings.go\t# greetings1 ä»å¦ä¸€ä¸ªæ¨¡å—è°ƒç”¨æ‚¨çš„ä»£ç  åœ¨(1)ä¸­ï¼Œæ‚¨åˆ›å»ºäº†ä¸€ä¸ªgreetings1æ¨¡å—ã€‚åœ¨æœ¬èŠ‚ä¸­ï¼Œæ‚¨å°†ç¼–å†™ä»£ç æ¥è°ƒç”¨Helloæ‚¨åˆšåˆšç¼–å†™çš„æ¨¡å—ä¸­çš„å‡½æ•°ã€‚æ‚¨å°†ç¼–å†™å¯ä»¥ä½œä¸ºåº”ç”¨ç¨‹åºæ‰§è¡Œçš„ä»£ç ï¼Œå¹¶è°ƒç”¨greetings1æ¨¡å—ä¸­çš„ä»£ç ã€‚ helloä¸ºæ‚¨çš„Goæ¨¡å—æºä»£ç  åˆ›å»ºä¸€ä¸ªç›®å½•ã€‚è¿™æ˜¯ä½ å†™ä½ çš„è°ƒç”¨è€…çš„åœ°æ–¹ã€‚ åˆ›å»ºæ­¤ç›®å½•åï¼Œæ‚¨åº”è¯¥åœ¨å±‚æ¬¡ç»“æ„çš„åŒä¸€çº§åˆ«ä¸ŠåŒæ—¶æ‹¥æœ‰ä¸€ä¸ªhelloå’Œä¸€ä¸ªgreetingsç›®å½•ï¼Œå¦‚ä¸‹æ‰€ç¤ºï¼š \u0026lt;home\u0026gt;/ |-- greetings1/ |-- hello2/ ä¾‹å¦‚ï¼Œå¦‚æœæ‚¨çš„å‘½ä»¤æç¤ºç¬¦ä½äºgreetings1ç›®å½•ä¸­ï¼Œæ‚¨å¯ä»¥ä½¿ç”¨ä»¥ä¸‹å‘½ä»¤ï¼š cd .. mkdir hello2 cd hello2 ä¸ºæ‚¨è¦ç¼–å†™çš„ä»£ç å¯ç”¨ä¾èµ–é¡¹è·Ÿè¸ªï¼Œè¦ä¸ºæ‚¨çš„ä»£ç å¯ç”¨ä¾èµ–é¡¹è·Ÿè¸ªï¼Œè¯·è¿è¡Œgo mod init commandï¼Œå¹¶ä¸ºå…¶æä¾›æ‚¨çš„ä»£ç æ‰€åœ¨çš„æ¨¡å—çš„åç§°ã€‚ å‡ºäºæœ¬æ•™ç¨‹çš„ç›®çš„ï¼Œè¯·ä½¿ç”¨gitee.com/phpbms/hello2æ¨¡å—è·¯å¾„ã€‚ $ go mod init gitee.com/phpbms/hello2 go: creating new go.mod: module gitee.com/phpbms/hello2 åœ¨æ–‡æœ¬ç¼–è¾‘å™¨çš„hello2ç›®å½•ä¸­ï¼Œåˆ›å»ºä¸€ä¸ªç”¨äºç¼–å†™ä»£ç çš„æ–‡ä»¶å¹¶å°†å…¶å‘½åä¸ºhello.goã€‚ ç¼–å†™ä»£ç æ¥è°ƒç”¨Helloå‡½æ•°ï¼Œç„¶åæ‰“å°å‡½æ•°çš„è¿”å›å€¼ package main import ( \u0026#34;fmt\u0026#34; \u0026#34;gitee.com/phpbms/greetings1\u0026#34; ) func main() { message := greetings1.Hello(\u0026#34;Gol\u0026#34;) fmt.Println(message) } ç›®å½•ç»“æ„ï¼š |--greetings1/ |----go.mod # gitee.com/phpbms/greetings1 |----greetings.go # greetings1 |--hello2/ |----go.mod # gitee.com/phpbms/hello2 |----hello.go # main åœ¨æ­¤ä»£ç ä¸­ï¼š\nå£°æ˜ä¸€ä¸ªmainåŒ…ã€‚åœ¨Goä¸­ï¼Œä½œä¸ºåº”ç”¨ç¨‹åºæ‰§è¡Œçš„ä»£ç å¿…é¡»åœ¨mainåŒ…ä¸­ã€‚ å¯¼å…¥ä¸¤ä¸ªåŒ…ï¼šgitee.com/phpbms/greetings1å’ŒfmtåŒ…ã€‚è¿™ä½¿æ‚¨çš„ä»£ç å¯ä»¥è®¿é—®è¿™äº›åŒ…ä¸­çš„å‡½æ•°ã€‚å¯¼å…¥gitee.com/phpbms/greetings1ï¼ˆåŒ…å«åœ¨æ‚¨ä¹‹å‰åˆ›å»ºçš„æ¨¡å—ä¸­çš„åŒ…ï¼‰ä½¿æ‚¨å¯ä»¥è®¿é—®è¯¥HelloåŠŸèƒ½ã€‚æ‚¨è¿˜å¯import fmtï¼Œå…·æœ‰å¤„ç†è¾“å…¥å’Œè¾“å‡ºæ–‡æœ¬çš„åŠŸèƒ½ï¼ˆä¾‹å¦‚å°†æ–‡æœ¬æ‰“å°åˆ°æ§åˆ¶å°ï¼‰ greetingsé€šè¿‡è°ƒç”¨åŒ…çš„ Helloå‡½æ•° æ¥è·å¾—é—®å€™ã€‚ ç¼–è¾‘gitee.com/phpbms/greetings1æ¨¡å—ä»¥ä½¿ç”¨æ‚¨çš„æœ¬åœ°gitee.com/phpbms/greetings1æ¨¡å—ã€‚\nå¯¹äºç”Ÿäº§ç”¨é€”ï¼Œæ‚¨gitee.com/phpbms/greetings1å°†ä»å…¶å­˜å‚¨åº“å‘å¸ƒæ¨¡å—ï¼ˆä½¿ç”¨åæ˜ å…¶å‘å¸ƒä½ç½®çš„æ¨¡å—è·¯å¾„ï¼‰ï¼ŒGo å·¥å…·å¯ä»¥åœ¨å…¶ä¸­æ‰¾åˆ°å®ƒå¹¶ä¸‹è½½å®ƒã€‚ç›®å‰ï¼Œç”±äºæ‚¨å°šæœªå‘å¸ƒè¯¥æ¨¡å—ï¼Œæ‚¨éœ€è¦è°ƒæ•´è¯¥example.com/helloæ¨¡å—ï¼Œä»¥ä¾¿å®ƒå¯ä»¥ gitee.com/phpbms/greetings1åœ¨æ‚¨çš„æœ¬åœ°æ–‡ä»¶ç³»ç»Ÿä¸Šæ‰¾åˆ°ä»£ç ã€‚\nä¸ºæ­¤ï¼Œè¯·ä½¿ç”¨go mod editå‘½ä»¤ç¼–è¾‘example.com/helloæ¨¡å—ä»¥å°†Goå·¥å…·ä»å…¶æ¨¡å—è·¯å¾„ï¼ˆæ¨¡å—æ‰€åœ¨çš„ä½ç½®ï¼‰é‡å®šå‘åˆ°æœ¬åœ°ç›®å½•ï¼ˆæ¨¡å—æ‰€åœ¨çš„ä½ç½®ï¼‰ã€‚\nåœ¨helloç›®å½•ä¸­çš„å‘½ä»¤æç¤ºç¬¦ä¸‹ï¼Œè¿è¡Œä»¥ä¸‹å‘½ä»¤ï¼š ã€go mod edit -replace gitee.com/phpbms/greetings1=../greetings1ã€‘ã€‚ è¯¥å‘½ä»¤æŒ‡å®šgitee.com/phpbms/greetings1åº”æ›¿æ¢../greetings1ä¸ºä»¥å®šä½ä¾èµ–é¡¹ã€‚è¿è¡Œå‘½ä»¤åï¼Œ hello ç›®å½•ä¸­çš„ go.mod æ–‡ä»¶åº”è¯¥åŒ…å«ä¸€ä¸ªreplaceæŒ‡ä»¤ï¼š module gitee.com/phpbms/hello2 go 1.16 replace gitee.com/phpbms/greetings1 =\u0026gt; ../greetings1 åœ¨helloç›®å½•ä¸‹çš„å‘½ä»¤æç¤ºç¬¦ä¸‹ï¼Œè¿è¡Œã€go mod tidyã€‘å‘½ä»¤åŒæ­¥gitee.com/phpbms/hello2æ¨¡å—çš„ä¾èµ–ï¼Œæ·»åŠ ä»£ç éœ€è¦ä½†æ¨¡å—ä¸­å°šæœªè·Ÿè¸ªçš„ä¾èµ–ã€‚ $ go mod tidy -v go: found gitee.com/phpbms/greetings1 in gitee.com/phpbms/greetings1 v0.0.0-00010101000000-000000000000 å‘½ä»¤å®Œæˆåï¼Œgitee.com/phpbms/hello2æ¨¡å—çš„go.modæ–‡ä»¶åº”å¦‚ä¸‹æ‰€ç¤ºï¼š module gitee.com/phpbms/hello2 go 1.16 replace gitee.com/phpbms/greetings1 =\u0026gt; ../greetings1 require gitee.com/phpbms/greetings1 v0.0.0-00010101000000-000000000000 è¯¥å‘½ä»¤åœ¨greetings1ç›®å½•ä¸­æ‰¾åˆ°äº†æœ¬åœ°ä»£ç ï¼Œç„¶åæ·»åŠ äº†ä¸€ä¸ªrequireæŒ‡ä»¤æ¥æŒ‡å®šgitee.com/phpbms/hello2éœ€è¦gitee.com/phpbms/greetings1ã€‚å½“æ‚¨åœ¨hello.goä¸­å¯¼å…¥é—®å€™åŒ…æ—¶ï¼Œæ‚¨åˆ›å»ºäº†æ­¤ä¾èµ–é¡¹ã€‚\næ¨¡å—è·¯å¾„åé¢çš„æ•°å­—æ˜¯ä¸€ä¸ªä¼ªç‰ˆæœ¬å· â€”â€” ä¸€ä¸ªç”Ÿæˆçš„æ•°å­—ç”¨æ¥ä»£æ›¿è¯­ä¹‰ç‰ˆæœ¬å·ï¼ˆæ¨¡å—è¿˜æ²¡æœ‰ï¼‰ï¼Œè¦å¼•ç”¨å·²å‘å¸ƒçš„æ¨¡å—ï¼Œgo.modæ–‡ä»¶é€šå¸¸ä¼šçœç•¥replaceæŒ‡ä»¤å¹¶ä½¿ç”¨ requireæœ«å°¾å¸¦æœ‰æ ‡è®°ç‰ˆæœ¬å·çš„æŒ‡ä»¤ã€‚require gitee.com/phpbms/greetings1 v1.1.0ã€‚æœ‰å…³ç‰ˆæœ¬å·çš„æ›´å¤šä¿¡æ¯ï¼Œè¯·å‚é˜…æ¨¡å—ç‰ˆæœ¬ç¼–å·ã€‚\nåœ¨helloç›®å½•ä¸­çš„å‘½ä»¤æç¤ºç¬¦å¤„ï¼Œè¿è¡Œæ‚¨çš„ä»£ç ä»¥ç¡®è®¤å…¶å·¥ä½œã€‚\n$ go run . Hi, Gol. Welcome! è¿”å›å¹¶å¤„ç†é”™è¯¯ å¤„ç†é”™è¯¯æ˜¯å¯é ä»£ç çš„åŸºæœ¬ç‰¹å¾ã€‚åœ¨æœ¬èŠ‚ä¸­ï¼Œæ‚¨å°†æ·»åŠ ä¸€äº›ä»£ç æ¥ä»greetings1æ¨¡å—è¿”å›é”™è¯¯ï¼Œç„¶ååœ¨è°ƒç”¨è€…ä¸­å¤„ç†å®ƒã€‚ åœ¨greetings/greetings.goä¸­ï¼Œæ·»åŠ ä¸‹é¢çªå‡ºæ˜¾ç¤ºçš„ä»£ç ï¼Œå¦‚æœæ‚¨ä¸çŸ¥é“è¯¥å‘è°æ‰“æ‹›å‘¼ï¼Œåˆ™å‘é€é—®å€™æ˜¯æ²¡æœ‰æ„ä¹‰çš„ã€‚å¦‚æœåç§°ä¸ºç©ºï¼Œåˆ™å‘è°ƒç”¨è€…è¿”å›é”™è¯¯ã€‚å°†ä»¥ä¸‹ä»£ç å¤åˆ¶åˆ°greetings.goå¹¶ä¿å­˜æ–‡ä»¶ã€‚ package greetings1 import ( \u0026#34;errors\u0026#34; \u0026#34;fmt\u0026#34; ) // Hello returns a greeting for the named person. func Hello(name string) (string, error) { if name == \u0026#34;\u0026#34; { return \u0026#34;\u0026#34;, errors.New(\u0026#34;empty\u0026#34;) } message := fmt.Sprintf(\u0026#34;Hi, %v. Welcome!\u0026#34;, name) return message, nil } åœ¨æ­¤ä»£ç ä¸­ï¼š æ›´æ”¹å‡½æ•°ï¼Œä½¿å…¶è¿”å›ä¸¤ä¸ªå€¼ï¼ša stringå’Œan errorã€‚æ‚¨çš„è°ƒç”¨è€…å°†æ£€æŸ¥ç¬¬äºŒä¸ªå€¼ä»¥æŸ¥çœ‹æ˜¯å¦å‘ç”Ÿé”™è¯¯ã€‚ï¼ˆä»»ä½•Goå‡½æ•°éƒ½å¯ä»¥è¿”å›å¤šä¸ªå€¼ã€‚æœ‰å…³æ›´å¤šä¿¡æ¯ï¼Œè¯·å‚é˜…Effective Goã€‚ï¼‰ å¯¼å…¥Goæ ‡å‡†åº“errorsåŒ…ï¼Œä»¥ä¾¿æ‚¨å¯ä»¥ä½¿ç”¨å…¶errors.NewåŠŸèƒ½ã€‚ æ·»åŠ ifè¯­å¥ä»¥æ£€æŸ¥æ— æ•ˆè¯·æ±‚ï¼ˆåç§°åº”ä¸ºç©ºå­—ç¬¦ä¸²ï¼‰ï¼Œå¦‚æœè¯·æ±‚æ— æ•ˆåˆ™è¿”å›é”™è¯¯ã€‚è¯¥errors.Newå‡½æ•°è¿”å›ä¸€ä¸ª erroråŒ…å«æ‚¨çš„æ¶ˆæ¯ã€‚ æ·»åŠ nilï¼ˆæ„å‘³ç€æ²¡æœ‰é”™è¯¯ï¼‰ä½œä¸ºæˆåŠŸè¿”å›ä¸­çš„ç¬¬äºŒä¸ªå€¼ã€‚è¿™æ ·ï¼Œè°ƒç”¨è€…å°±å¯ä»¥çœ‹åˆ°å‡½æ•°æˆåŠŸäº†ã€‚ åœ¨hello2/hello.goæ–‡ä»¶ä¸­ï¼Œå¤„ç†Helloå‡½æ•°ç°åœ¨è¿”å›çš„é”™è¯¯ä»¥åŠéé”™è¯¯å€¼ã€‚å°†ä»¥ä¸‹ä»£ç ç²˜è´´åˆ°hello.goä¸­ã€‚ package main import ( \u0026#34;fmt\u0026#34; \u0026#34;gitee.com/phpbms/greetings1\u0026#34; \u0026#34;log\u0026#34; ) func main() { // Set properties of the predefined Logger, including // the log entry prefix and a flag to disable printing // the time, source file, and line number. log.SetPrefix(\u0026#34;greetings: \u0026#34;) log.SetFlags(0) // Request a greeting message. message, err := greetings1.Hello(\u0026#34;\u0026#34;) // If an error was returned, print it to the console and // exit the program. if err != nil { log.Fatal(err) } // If no error was returned, print the returned message // to the console. fmt.Println(message) } åœ¨æ­¤ä»£ç ä¸­ï¼š å°†logåŒ…é…ç½®ä¸ºåœ¨å…¶æ—¥å¿—æ¶ˆæ¯çš„å¼€å¤´æ‰“å°å‘½ä»¤åç§°ï¼ˆâ€œgreetings:â€ï¼‰ï¼Œä¸å¸¦æ—¶é—´æˆ³æˆ–æºæ–‡ä»¶ä¿¡æ¯ã€‚ å°†ä¸¤ä¸ªHelloè¿”å›å€¼ï¼ˆåŒ…æ‹¬ ï¼‰åˆ†é…errorç»™å˜é‡ã€‚ å°†Helloå‚æ•°ä»Gladysçš„åç§°æ›´æ”¹ä¸ºç©ºå­—ç¬¦ä¸²ï¼Œä»¥ä¾¿æ‚¨å¯ä»¥å°è¯•æ‚¨çš„é”™è¯¯å¤„ç†ä»£ç ã€‚ å¯»æ‰¾ä¸€ä¸ªéé›¶errorå€¼ã€‚åœ¨è¿™ç§æƒ…å†µä¸‹ç»§ç»­ä¸‹å»æ˜¯æ²¡æœ‰æ„ä¹‰çš„ã€‚ ä½¿ç”¨æ ‡å‡†åº“ä¸­çš„å‡½æ•°log packageè¾“å‡ºé”™è¯¯ä¿¡æ¯ã€‚å¦‚æœå‡ºç°é”™è¯¯ï¼Œåˆ™ä½¿ç”¨logåŒ…çš„Fatalå‡½æ•°æ‰“å°é”™è¯¯å¹¶åœæ­¢ç¨‹åºã€‚ åœ¨helloç›®å½•ä¸­çš„å‘½ä»¤è¡Œä¸­ï¼Œè¿è¡Œhello.goä»¥ç¡®è®¤ä»£ç æœ‰æ•ˆã€‚ç°åœ¨æ‚¨ä¼ å…¥ä¸€ä¸ªç©ºåç§°ï¼Œæ‚¨å°†æ”¶åˆ°é”™è¯¯æ¶ˆæ¯ã€‚ $ go run . greetings: empty name exit status 1 è¿”å›éšæœºé—®å€™è¯­å¥ åœ¨æœ¬èŠ‚ä¸­ï¼Œæ‚¨å°†æ›´æ”¹ä»£ç ï¼Œä»¥ä¾¿ä¸æ˜¯æ¯æ¬¡éƒ½è¿”å›ä¸€ä¸ªé—®å€™è¯­ï¼Œè€Œæ˜¯è¿”å›å¤šä¸ªé¢„å®šä¹‰çš„é—®å€™è¯­æ¶ˆæ¯ä¹‹ä¸€ã€‚ ä¸ºæ­¤ï¼Œæ‚¨å°†ä½¿ç”¨Goåˆ‡ç‰‡ã€‚åˆ‡ç‰‡ç±»ä¼¼äºæ•°ç»„ï¼Œä¸åŒä¹‹å¤„åœ¨äºå®ƒçš„å¤§å°ä¼šéšç€æ‚¨æ·»åŠ å’Œåˆ é™¤é¡¹ç›®è€ŒåŠ¨æ€å˜åŒ–ã€‚sliceæ˜¯Goæœ€æœ‰ç”¨çš„ç±»å‹ä¹‹ä¸€ã€‚ æ‚¨å°†æ·»åŠ ä¸€å°éƒ¨åˆ†æ¥åŒ…å«ä¸‰ä¸ªé—®å€™æ¶ˆæ¯ï¼Œç„¶åè®©æ‚¨çš„ä»£ç éšæœºè¿”å›å…¶ä¸­ä¸€ä¸ªæ¶ˆæ¯ã€‚æœ‰å…³åˆ‡ç‰‡çš„æ›´å¤šä¿¡æ¯ï¼Œè¯·å‚é˜…Goåšå®¢ä¸­çš„Goåˆ‡ç‰‡ã€‚ åœ¨greetings1/greetings.goä¸­ï¼Œæ›´æ”¹æ‚¨çš„ä»£ç ï¼Œä½¿å…¶çœ‹èµ·æ¥å¦‚ä¸‹æ‰€ç¤ºã€‚ package greetings1 import ( \u0026#34;errors\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;math/rand\u0026#34; \u0026#34;time\u0026#34; ) // Hello returns a greeting for the named person. func Hello(name string) (string, error) { if name == \u0026#34;\u0026#34; { return \u0026#34;\u0026#34;, errors.New(\u0026#34;empty\u0026#34;) } message := fmt.Sprintf(randomFormat(), name) return message, nil } // init sets initial values for variables used in the function. func init() { rand.Seed(time.Now().UnixNano()) } // randomFormat returns one of a set of greeting messages. The returned // message is selected at random. func randomFormat() string { // A slice of message formats. formats := []string{ \u0026#34;Hi, %v. Welcome!\u0026#34;, \u0026#34;Great to see you, %v!\u0026#34;, \u0026#34;Hail, %v! Well met!\u0026#34;, } return formats[rand.Intn(len(formats))] } åœ¨æ­¤ä»£ç ä¸­ï¼š æ·»åŠ ä¸€ä¸ªrandomFormatå‡½æ•°ï¼Œè¿”å›éšæœºé€‰æ‹©çš„é—®å€™æ¶ˆæ¯æ ¼å¼ã€‚è¯·æ³¨æ„ï¼Œ randomFormatä»¥å°å†™å­—æ¯å¼€å¤´ï¼Œä½¿å…¶åªèƒ½ç”±å…¶è‡ªå·±çš„åŒ…ä¸­çš„ä»£ç è®¿é—®ï¼ˆæ¢å¥è¯è¯´ï¼Œå®ƒä¸ä¼šè¢«å¯¼å‡ºï¼‰ã€‚ åœ¨ä¸­randomFormatï¼Œå£°æ˜ä¸€ä¸ªformatså…·æœ‰ä¸‰ç§æ¶ˆæ¯æ ¼å¼çš„åˆ‡ç‰‡ã€‚å½“å£°æ˜ä¸€ä¸ªåˆ‡ç‰‡ï¼Œä½ åœ¨æ‹¬å·å¿½ç•¥å®ƒçš„å¤§å°ï¼Œåƒè¿™æ ·ï¼š[]stringã€‚è¿™å‘Šè¯‰ Go åˆ‡ç‰‡åº•å±‚æ•°ç»„çš„å¤§å°å¯ä»¥åŠ¨æ€æ›´æ”¹ã€‚ ä½¿ç”¨math/rand åŒ…ç”Ÿæˆä¸€ä¸ªéšæœºæ•°ï¼Œç”¨äºä»åˆ‡ç‰‡ä¸­é€‰æ‹©ä¸€ä¸ªé¡¹ç›®ã€‚ æ·»åŠ ä¸€ä¸ªinitå‡½æ•°ä»¥randä½¿ç”¨å½“å‰æ—¶é—´ä¸ºåŒ…åšç§å­ã€‚Goinitåœ¨ç¨‹åºå¯åŠ¨æ—¶è‡ªåŠ¨æ‰§è¡Œå‡½æ•°ï¼Œåœ¨å…¨å±€å˜é‡åˆå§‹åŒ–åã€‚æœ‰å…³initå‡½æ•°çš„æ›´å¤šä¿¡æ¯ï¼Œè¯·å‚é˜… Effective Goã€‚ åœ¨ä¸­Helloï¼Œè°ƒç”¨è¯¥randomFormatå‡½æ•°ä»¥è·å–æ‚¨å°†è¿”å›çš„æ¶ˆæ¯çš„æ ¼å¼ï¼Œç„¶åä¸€èµ·ä½¿ç”¨è¯¥æ ¼å¼å’Œnameå€¼æ¥åˆ›å»ºè¯¥æ¶ˆæ¯ã€‚ åƒä»¥å‰ä¸€æ ·è¿”å›æ¶ˆæ¯ï¼ˆæˆ–é”™è¯¯ï¼‰ã€‚ åœ¨hello2/hello.goä¸­ï¼Œæ›´æ”¹æ‚¨çš„ä»£ç ï¼Œä½¿å…¶çœ‹èµ·æ¥å¦‚ä¸‹æ‰€ç¤ºã€‚æ‚¨åªæ˜¯å°†Gladysçš„åå­—ï¼ˆæˆ–ä¸åŒçš„åå­—ï¼Œå¦‚æœæ‚¨å–œæ¬¢ï¼‰ä½œä¸ºå‚æ•°æ·»åŠ åˆ°Hello hello.goä¸­çš„å‡½æ•°è°ƒç”¨ä¸­ã€‚ package main import ( \u0026#34;fmt\u0026#34; \u0026#34;gitee.com/phpbms/greetings1\u0026#34; \u0026#34;log\u0026#34; ) func main() { // Set properties of the predefined Logger, including // the log entry prefix and a flag to disable printing // the time, source file, and line number. log.SetPrefix(\u0026#34;greetings: \u0026#34;) log.SetFlags(0) // Request a greeting message. message, err := greetings1.Hello(\u0026#34;Gla\u0026#34;) // If an error was returned, print it to the console and // exit the program. if err != nil { log.Fatal(err) } // If no error was returned, print the returned message // to the console. fmt.Println(message) } åœ¨å‘½ä»¤è¡Œçš„helloç›®å½•ä¸­ï¼Œè¿è¡Œhello.goä»¥ç¡®è®¤ä»£ç æœ‰æ•ˆã€‚å¤šæ¬¡è¿è¡Œå®ƒï¼Œæ³¨æ„åˆ°é—®å€™è¯­å‘ç”Ÿäº†å˜åŒ–ã€‚ $ hello go run . Great to see you, Gla! $ hello go run . Great to see you, Gla! $ hello go run . Hi, Gla. Welcome! å›å¤å¤šäººé—®å€™ åœ¨æ‚¨å¯¹æ¨¡å—ä»£ç æ‰€åšçš„æœ€åæ›´æ”¹ä¸­ï¼Œæ‚¨å°†æ·»åŠ å¯¹åœ¨ä¸€ä¸ªè¯·æ±‚ä¸­ä¸ºå¤šäººè·å–é—®å€™çš„æ”¯æŒã€‚æ¢å¥è¯è¯´ï¼Œæ‚¨å°†å¤„ç†å¤šå€¼è¾“å…¥ï¼Œç„¶åå°†è¯¥è¾“å…¥ä¸­çš„å€¼ä¸å¤šå€¼è¾“å‡ºé…å¯¹ã€‚ä¸ºæ­¤ï¼Œæ‚¨éœ€è¦å°†ä¸€ç»„åç§°ä¼ é€’ç»™ä¸€ä¸ªå¯ä»¥ä¸ºæ¯ä¸ªåç§°è¿”å›é—®å€™è¯­çš„å‡½æ•°ã€‚ ä½†æœ‰ä¸€ä¸ªéšœç¢ã€‚å°†Helloå‡½æ•°çš„å‚æ•°ä»å•ä¸ªåç§°æ›´æ”¹ä¸ºä¸€ç»„åç§°ä¼šæ›´æ”¹å‡½æ•°çš„ç­¾åã€‚å¦‚æœæ‚¨å·²ç»å‘å¸ƒäº†example.com/greetings æ¨¡å—å¹¶ä¸”ç”¨æˆ·å·²ç»ç¼–å†™äº†è°ƒç”¨ çš„ä»£ç Helloï¼Œé‚£ä¹ˆè¿™ç§æ›´æ”¹ä¼šç ´åä»–ä»¬çš„ç¨‹åºã€‚ åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œæ›´å¥½çš„é€‰æ‹©æ˜¯ç¼–å†™ä¸€ä¸ªå…·æœ‰ä¸åŒåç§°çš„æ–°å‡½æ•°ã€‚æ–°å‡½æ•°å°†é‡‡ç”¨å¤šä¸ªå‚æ•°ã€‚è¿™ä¿ç•™äº†æ—§åŠŸèƒ½ä»¥å®ç°å‘åå…¼å®¹æ€§ã€‚ åœ¨greetings1/greetings.goä¸­ï¼Œæ›´æ”¹æ‚¨çš„ä»£ç ï¼Œä½¿å…¶çœ‹èµ·æ¥å¦‚ä¸‹æ‰€ç¤ºã€‚ package greetings1 import ( \u0026#34;errors\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;math/rand\u0026#34; \u0026#34;time\u0026#34; ) // Hello returns a greeting for the named person. func Hello(name string) (string, error) { if name == \u0026#34;\u0026#34; { return \u0026#34;\u0026#34;, errors.New(\u0026#34;empty\u0026#34;) } message := fmt.Sprintf(randomFormat(), name) return message, nil } // init sets initial values for variables used in the function. func init() { rand.Seed(time.Now().UnixNano()) } // randomFormat returns one of a set of greeting messages. The returned // message is selected at random. func randomFormat() string { // A slice of message formats. formats := []string{ \u0026#34;Hi, %v. Welcome!\u0026#34;, \u0026#34;Great to see you, %v!\u0026#34;, \u0026#34;Hail, %v! Well met!\u0026#34;, } return formats[rand.Intn(len(formats))] } // Hellos returns a map that associates each of the named people // with a greeting message. func Hellos(names []string) (map[string]string, error) { // A map to associate names with messages. messages := make(map[string]string, len(names)) // Loop through the received slice of names, calling // the Hello function to get a message for each name. for _, name := range names { message, err := Hello(name) if err != nil { return nil, err } // In the map, associate the retrieved message with // the name. messages[name] = message } return messages, nil } åœ¨æ­¤ä»£ç ä¸­ï¼š æ·»åŠ ä¸€ä¸ªHelloså‡½æ•°ï¼Œå…¶å‚æ•°æ˜¯ä¸€æ®µåç§°è€Œä¸æ˜¯å•ä¸ªåç§°ã€‚æ­¤å¤–ï¼Œæ‚¨å°†å…¶è¿”å›ç±»å‹ä¹‹ä¸€ä»aæ›´æ”¹stringä¸ºaï¼Œmapä»¥ä¾¿æ‚¨å¯ä»¥è¿”å›æ˜ å°„åˆ°é—®å€™æ¶ˆæ¯çš„åç§°ã€‚ è®©æ–°Helloså‡½æ•°è°ƒç”¨ç°æœ‰Helloå‡½æ•°ã€‚è¿™æœ‰åŠ©äºå‡å°‘é‡å¤ï¼ŒåŒæ—¶ä¿ç•™ä¸¤ä¸ªåŠŸèƒ½ã€‚ åˆ›å»ºmessagesæ˜ å°„ä»¥å°†æ¯ä¸ªæ¥æ”¶åˆ°çš„åç§°ï¼ˆä½œä¸ºé”®ï¼‰ä¸ç”Ÿæˆçš„æ¶ˆæ¯ï¼ˆä½œä¸ºå€¼ï¼‰ç›¸å…³è”ã€‚åœ¨Goä¸­ï¼Œæ‚¨ä½¿ç”¨ä»¥ä¸‹è¯­æ³•åˆå§‹åŒ–mapï¼šæ‚¨è®©å‡½æ•°å°†æ­¤æ˜ å°„è¿”å›ç»™è°ƒç”¨è€…ã€‚æœ‰å…³åœ°å›¾çš„æ›´å¤šä¿¡æ¯ï¼Œè¯·å‚é˜…Goåšå®¢ä¸Šçš„Go mapå®æˆ˜ã€‚make(map[*key-type*]*value-type*) å¾ªç¯éå†æ‚¨çš„å‡½æ•°æ”¶åˆ°çš„åç§°ï¼Œæ£€æŸ¥æ¯ä¸ªåç§°æ˜¯å¦å…·æœ‰éç©ºå€¼ï¼Œç„¶åå°†æ¶ˆæ¯ä¸æ¯ä¸ªåç§°å…³è”ã€‚åœ¨æ­¤ forå¾ªç¯ä¸­ï¼Œrangeè¿”å›ä¸¤ä¸ªå€¼ï¼šå¾ªç¯ä¸­å½“å‰é¡¹ç›®çš„ç´¢å¼•å’Œé¡¹ç›®å€¼çš„å‰¯æœ¬ã€‚æ‚¨ä¸éœ€è¦ç´¢å¼•ï¼Œå› æ­¤æ‚¨ä½¿ç”¨ Go ç©ºç™½æ ‡è¯†ç¬¦ï¼ˆä¸‹åˆ’çº¿ï¼‰æ¥å¿½ç•¥å®ƒã€‚æœ‰å…³æ›´å¤šä¿¡æ¯ï¼Œè¯·å‚é˜… Effective Go ä¸­çš„ç©ºç™½æ ‡è¯†ç¬¦ã€‚ åœ¨ä½ çš„hello2/hello.goè°ƒç”¨ä»£ç ä¸­ï¼Œä¼ é€’ä¸€æ®µåç§°ï¼Œç„¶åæ‰“å°ä½ è¿”å›çš„åç§°/æ¶ˆæ¯æ˜ å°„çš„å†…å®¹ã€‚åœ¨hello.goä¸­ï¼Œæ›´æ”¹æ‚¨çš„ä»£ç ï¼Œä½¿å…¶çœ‹èµ·æ¥å¦‚ä¸‹æ‰€ç¤ºã€‚ package main import ( \u0026#34;fmt\u0026#34; \u0026#34;gitee.com/phpbms/greetings1\u0026#34; \u0026#34;log\u0026#34; ) func main() { // Set properties of the predefined Logger, including // the log entry prefix and a flag to disable printing // the time, source file, and line number. log.SetPrefix(\u0026#34;greetings: \u0026#34;) log.SetFlags(0) names := []string{\u0026#34;Gladys\u0026#34;, \u0026#34;Samantha\u0026#34;, \u0026#34;Darrin\u0026#34;} // Request a greeting message. message, err := greetings1.Hellos(names) // If an error was returned, print it to the console and // exit the program. if err != nil { log.Fatal(err) } // If no error was returned, print the returned message // to the console. fmt.Println(message) } é€šè¿‡è¿™äº›æ›´æ”¹ï¼š åˆ›å»ºä¸€ä¸ªnameså˜é‡ä½œä¸ºåŒ…å«ä¸‰ä¸ªåç§°çš„åˆ‡ç‰‡ç±»å‹ã€‚ å°†nameså˜é‡ä½œä¸ºå‚æ•°ä¼ é€’ç»™ Helloså‡½æ•°ã€‚ åœ¨å‘½ä»¤è¡Œä¸­ï¼Œåˆ‡æ¢åˆ°åŒ…å«hello/hello.goçš„ç›®å½•ï¼Œç„¶åä½¿ç”¨go runæ¥ç¡®è®¤ä»£ç æ˜¯å¦æœ‰æ•ˆã€‚è¾“å‡ºåº”è¯¥æ˜¯å°†åç§°ä¸æ¶ˆæ¯ç›¸å…³è”çš„åœ°å›¾çš„å­—ç¬¦ä¸²è¡¨ç¤ºå½¢å¼ï¼Œå¦‚ä¸‹æ‰€ç¤ºï¼š $ go run . map[Darrin:Hail, Darrin! Well met! Gladys:Hail, Gladys! Well met! Samantha:Hail, Samantha! Well met!] æ·»åŠ æµ‹è¯• æ—¢ç„¶æ‚¨å·²ç»å°†ä»£ç æ”¾åˆ°äº†ä¸€ä¸ªç¨³å®šçš„ä½ç½®ï¼ˆé¡ºä¾¿è¯´ä¸€å¥ï¼Œåšå¾—å¾ˆå¥½ï¼‰ï¼Œè¯·æ·»åŠ ä¸€ä¸ªæµ‹è¯•ã€‚åœ¨å¼€å‘æœŸé—´æµ‹è¯•æ‚¨çš„ä»£ç å¯ä»¥æš´éœ²åœ¨æ‚¨è¿›è¡Œæ›´æ”¹æ—¶å‘ç°çš„é”™è¯¯ã€‚åœ¨æœ¬ä¸»é¢˜ä¸­ï¼Œæ‚¨å°†ä¸ºè¯¥Helloå‡½æ•°æ·»åŠ ä¸€ä¸ªæµ‹è¯• ã€‚ Go å¯¹å•å…ƒæµ‹è¯•çš„å†…ç½®æ”¯æŒä½¿æ‚¨å¯ä»¥æ›´è½»æ¾åœ°è¿›è¡Œæµ‹è¯•ã€‚å…·ä½“æ¥è¯´ï¼Œä½¿ç”¨å‘½åçº¦å®šã€Goçš„testingåŒ…å’Œgo testå‘½ä»¤ï¼Œæ‚¨å¯ä»¥å¿«é€Ÿç¼–å†™å’Œæ‰§è¡Œæµ‹è¯•ã€‚ åœ¨ greetings1 ç›®å½•ä¸­ï¼Œåˆ›å»ºä¸€ä¸ªåä¸ºgreetings_test.goçš„æ–‡ä»¶ã€‚ä»¥_test.goç»“å°¾çš„æ–‡ä»¶åå‘Šè¯‰go testå‘½ä»¤è¯¥æ–‡ä»¶åŒ…å«æµ‹è¯•å‡½æ•°ã€‚ åœ¨greetings_test.goä¸­ï¼Œç²˜è´´ä»¥ä¸‹ä»£ç å¹¶ä¿å­˜æ–‡ä»¶ã€‚ package greetings1 import ( \u0026#34;regexp\u0026#34; \u0026#34;testing\u0026#34; ) // TestHelloName calls greetings.Hello with a name, checking // for a valid return value. func TestHelloName(t *testing.T) { name := \u0026#34;Gladys\u0026#34; want := regexp.MustCompile(`\\b`+name+`\\b`) msg, err := Hello(\u0026#34;Gladys\u0026#34;) if !want.MatchString(msg) || err != nil { t.Fatalf(`Hello(\u0026#34;Gladys\u0026#34;) = %q, %v, want match for %#q, nil`, msg, err, want) } } // TestHelloEmpty calls greetings.Hello with an empty string, // checking for an error. func TestHelloEmpty(t *testing.T) { msg, err := Hello(\u0026#34;\u0026#34;) if msg != \u0026#34;\u0026#34; || err == nil { t.Fatalf(`Hello(\u0026#34;\u0026#34;) = %q, %v, want \u0026#34;\u0026#34;, error`, msg, err) } } åœ¨æ­¤ä»£ç ä¸­ï¼š åœ¨ä¸æ‚¨æ­£åœ¨æµ‹è¯•çš„ä»£ç ç›¸åŒçš„åŒ…ä¸­å®ç°æµ‹è¯•åŠŸèƒ½ã€‚ åˆ›å»ºä¸¤ä¸ªæµ‹è¯•å‡½æ•°æ¥æµ‹è¯•greetings.Hello å‡½æ•°ã€‚æµ‹è¯•å‡½æ•°åç§°çš„å½¢å¼ä¸ºTest*Name*ï¼Œå…¶ä¸­Nameè¡¨ç¤ºç‰¹å®šæµ‹è¯•çš„ä¸€äº›å†…å®¹ã€‚æ­¤å¤–ï¼Œæµ‹è¯•å‡½æ•°å°†æŒ‡å‘åŒ…testing.Tç±»å‹çš„æŒ‡é’ˆä½œä¸ºå‚æ•°ã€‚æ‚¨å¯ä»¥ä½¿ç”¨æ­¤å‚æ•°çš„æ–¹æ³•æ¥æŠ¥å‘Šå’Œè®°å½•æ‚¨çš„æµ‹è¯•ã€‚ å®ç°ä¸¤ä¸ªæµ‹è¯•ï¼š TestHelloNameè°ƒç”¨è¯¥Helloå‡½æ•°ï¼Œä¼ é€’ä¸€ä¸ªnameå€¼ï¼Œè¯¥å‡½æ•°åº”è¯¥èƒ½å¤Ÿä½¿ç”¨è¯¥å€¼è¿”å›æœ‰æ•ˆçš„å“åº”æ¶ˆæ¯ã€‚å¦‚æœè°ƒç”¨è¿”å›é”™è¯¯æˆ–æ„å¤–å“åº”æ¶ˆæ¯ï¼ˆä¸åŒ…å«æ‚¨ä¼ å…¥çš„åç§°çš„æ¶ˆæ¯ï¼‰ï¼Œåˆ™ä½¿ç”¨tå‚æ•°çš„Fatalfå°†æ¶ˆæ¯æ‰“å°åˆ°æ§åˆ¶å°å¹¶ç»“æŸæ‰§è¡Œã€‚ TestHelloEmpty``Helloç”¨ç©ºå­—ç¬¦ä¸²è°ƒç”¨å‡½æ•°ã€‚æ­¤æµ‹è¯•æ—¨åœ¨ç¡®è®¤æ‚¨çš„é”™è¯¯å¤„ç†å·¥ä½œæ­£å¸¸ã€‚å¦‚æœè°ƒç”¨è¿”å›éç©ºå­—ç¬¦ä¸²æˆ–æ²¡æœ‰é”™è¯¯ï¼Œåˆ™ä½¿ç”¨tå‚æ•°çš„Fatalfæ–¹æ³•å°†æ¶ˆæ¯æ‰“å°åˆ°æ§åˆ¶å°å¹¶ç»“æŸæ‰§è¡Œã€‚ åœ¨greetingsç›®å½•ä¸‹çš„å‘½ä»¤è¡Œï¼Œè¿è¡Œgo testå‘½ä»¤æ‰§è¡Œæµ‹è¯•ï¼Œè¯¥go testå‘½ä»¤æ‰§è¡Œæµ‹è¯•Testæ–‡ä»¶ï¼ˆåç§°ä»¥_test.goç»“å°¾ï¼‰ä¸­çš„æµ‹è¯•å‡½æ•°ï¼ˆåç§°ä»¥Test_å¼€å¤´ï¼‰ã€‚æ‚¨å¯ä»¥æ·»åŠ -væ ‡å¿—ä»¥è·å–åˆ—å‡ºæ‰€æœ‰æµ‹è¯•åŠå…¶ç»“æœçš„è¯¦ç»†è¾“å‡ºã€‚æµ‹è¯•åº”è¯¥é€šè¿‡ã€‚ $ go test PASS ok gitee.com/phpbms/greetings1 0.024s $ go test -v === RUN TestHelloName --- PASS: TestHelloName (0.00s) === RUN TestHelloEmpty --- PASS: TestHelloEmpty (0.00s) PASS ok gitee.com/phpbms/greetings1 0.025s ä¸­æ–­greetings.Helloå‡½æ•°ä»¥æŸ¥çœ‹å¤±è´¥çš„æµ‹è¯•ã€‚è¯¥TestHelloNameæµ‹è¯•åŠŸèƒ½æ£€æŸ¥æ‚¨æŒ‡å®šä¸ºåç§°çš„è¿”å›å€¼Helloå‡½æ•°çš„å‚æ•°ã€‚è¦æŸ¥çœ‹å¤±è´¥çš„æµ‹è¯•ç»“æœï¼Œè¯·æ›´æ”¹greetings.Helloå‡½æ•°ä½¿å…¶ä¸å†åŒ…å«åç§°ã€‚åœ¨greetings/greetings.goä¸­ï¼Œç²˜è´´ä»¥ä¸‹ä»£ç ä»£æ›¿ Helloå‡½æ•°ã€‚è¯·æ³¨æ„ï¼Œçªå‡ºæ˜¾ç¤ºçš„è¡Œä¼šæ›´æ”¹å‡½æ•°è¿”å›çš„å€¼ï¼Œå°±å¥½åƒnameå‚æ•°å·²è¢«æ„å¤–åˆ é™¤ä¸€æ ·ã€‚ // Hello returns a greeting for the named person. func Hello(name string) (string, error) { // If no name was given, return an error with a message. if name == \u0026#34;\u0026#34; { return name, errors.New(\u0026#34;empty name\u0026#34;) } // Create a message using a random format. // message := fmt.Sprintf(randomFormat(), name)\t// è¿™è¡Œæ›¿æ¢äº† message := fmt.Sprint(randomFormat()) return message, nil } åœ¨greetingsç›®å½•ä¸‹çš„å‘½ä»¤è¡Œï¼Œè¿è¡Œgo testæ‰§è¡Œæµ‹è¯•ã€‚è¿™ä¸€æ¬¡ï¼Œåœ¨go testæ²¡æœ‰-væ ‡å¿—çš„æƒ…å†µä¸‹è¿è¡Œã€‚è¾“å‡ºå°†ä»…åŒ…å«å¤±è´¥çš„æµ‹è¯•çš„ç»“æœï¼Œè¿™åœ¨æ‚¨è¿›è¡Œå¤§é‡æµ‹è¯•æ—¶éå¸¸æœ‰ç”¨ã€‚è¯¥TestHelloNameæµ‹è¯•å°†å¤±è´¥-TestHelloEmptyè¿˜é€šè¿‡ã€‚ $ go test -v === RUN TestHelloName greetings_test.go:15: Hello(\u0026#34;Gladys\u0026#34;) = \u0026#34;Hail, %v! Well met!\u0026#34;, \u0026lt;nil\u0026gt;, want match for `\\bGladys\\b`, nil --- FAIL: TestHelloName (0.00s) === RUN TestHelloEmpty --- PASS: TestHelloEmpty (0.00s) FAIL exit status 1 FAIL gitee.com/phpbms/greetings1 0.025s ç¼–è¯‘å¹¶å®‰è£…åº”ç”¨ç¨‹åº åœ¨æœ€åä¸€ä¸ªä¸»é¢˜ä¸­ï¼Œæ‚¨å°†å­¦ä¹ å‡ ä¸ªæ–°goå‘½ä»¤ã€‚è™½ç„¶è¯¥go runå‘½ä»¤æ˜¯åœ¨æ‚¨è¿›è¡Œé¢‘ç¹æ›´æ”¹æ—¶ç¼–è¯‘å’Œè¿è¡Œç¨‹åºçš„æœ‰ç”¨å¿«æ·æ–¹å¼ï¼Œä½†å®ƒä¸ä¼šç”ŸæˆäºŒè¿›åˆ¶å¯æ‰§è¡Œæ–‡ä»¶ã€‚ æœ¬ä¸»é¢˜ä»‹ç»äº†ä¸¤ä¸ªç”¨äºæ„å»ºä»£ç çš„é™„åŠ å‘½ä»¤ï¼š è¯¥go buildå‘½ä»¤ç¼–è¯‘åŒ…åŠå…¶ä¾èµ–é¡¹ï¼Œä½†ä¸å®‰è£…ç»“æœã€‚ è¯¥go installå‘½ä»¤ç¼–è¯‘å¹¶å®‰è£…è½¯ä»¶åŒ…ã€‚ æ­¥éª¤å¦‚ä¸‹ ä»hello2ç›®å½•ä¸­çš„å‘½ä»¤è¡Œï¼Œè¿è¡Œgo build å‘½ä»¤å°†ä»£ç ç¼–è¯‘ä¸ºå¯æ‰§è¡Œæ–‡ä»¶ã€‚ ä»hello2ç›®å½•ä¸­çš„å‘½ä»¤è¡Œï¼Œè¿è¡Œæ–°çš„hello å¯æ‰§è¡Œæ–‡ä»¶ä»¥ç¡®è®¤ä»£ç æœ‰æ•ˆã€‚è¯·æ³¨æ„ï¼Œæ ¹æ®æ‚¨åœ¨æµ‹è¯•åæ˜¯å¦æ›´æ”¹äº†greetings.goä»£ç ï¼Œæ‚¨çš„ç»“æœå¯èƒ½ä¼šæœ‰æ‰€ä¸åŒã€‚ åœ¨Linuxæˆ–Macä¸Šï¼š $ ./hello map[Darrin:Great to see you, Darrin! Gladys:Hail, Gladys! Well met! Samantha:Hail, Samantha! Well met!] åœ¨ Windows ä¸Šï¼š $ hello.exe map[Darrin:Great to see you, Darrin! Gladys:Hail, Gladys! Well met! Samantha:Hail, Samantha! Well met!] æ‚¨å·²å°†åº”ç”¨ç¨‹åºç¼–è¯‘ä¸ºå¯æ‰§è¡Œæ–‡ä»¶ï¼Œä»¥ä¾¿å¯ä»¥è¿è¡Œå®ƒã€‚ä½†æ˜¯è¦å½“å‰è¿è¡Œå®ƒï¼Œæ‚¨çš„æç¤ºéœ€è¦ä½äºå¯æ‰§è¡Œæ–‡ä»¶çš„ç›®å½•ä¸­ï¼Œæˆ–è€…æŒ‡å®šå¯æ‰§è¡Œæ–‡ä»¶çš„è·¯å¾„ã€‚æ¥ä¸‹æ¥ï¼Œæ‚¨å°†å®‰è£…å¯æ‰§è¡Œæ–‡ä»¶ï¼Œä»¥ä¾¿æ— éœ€æŒ‡å®šå…¶è·¯å¾„å³å¯è¿è¡Œå®ƒã€‚ å‘ç° Go å®‰è£…è·¯å¾„ï¼Œè¯¥goå‘½ä»¤å°†åœ¨å…¶ä¸­å®‰è£…å½“å‰åŒ…ã€‚æ‚¨å¯ä»¥é€šè¿‡è¿è¡Œå‘½ä»¤æ¥å‘ç°å®‰è£…è·¯å¾„ï¼Œ å¦‚ä¸‹ä¾‹æ‰€ç¤ºï¼š go list -f \u0026#39;{{.Target}}\u0026#39; ä¾‹å¦‚ï¼Œå‘½ä»¤çš„è¾“å‡ºå¯èƒ½æ˜¯/home/gopher/bin/helloï¼Œè¿™æ„å‘³ç€äºŒè¿›åˆ¶æ–‡ä»¶å®‰è£…åˆ°/home/gopher/binã€‚åœ¨ä¸‹ä¸€æ­¥ä¸­æ‚¨å°†éœ€è¦æ­¤å®‰è£…ç›®å½•ã€‚\nå°† Go å®‰è£…ç›®å½•æ·»åŠ åˆ°ç³»ç»Ÿçš„ shell è·¯å¾„ã€‚è¿™æ ·ï¼Œæ‚¨å°±å¯ä»¥è¿è¡Œç¨‹åºçš„å¯æ‰§è¡Œæ–‡ä»¶ï¼Œè€Œæ— éœ€æŒ‡å®šå¯æ‰§è¡Œæ–‡ä»¶çš„ä½ç½®ã€‚\nåœ¨Linuxæˆ–Macä¸Šï¼Œè¿è¡Œä»¥ä¸‹å‘½ä»¤ï¼š export PATH=$PATH:/path/to/your/install/directory åœ¨Windowsä¸Šï¼Œè¿è¡Œä»¥ä¸‹å‘½ä»¤ï¼š set PATH=%PATH%;C:\\path\\to\\your\\install\\directory ä½œä¸ºæ›¿ä»£æ–¹æ¡ˆï¼Œå¦‚æœæ‚¨$HOME/binåœ¨ shell è·¯å¾„ä¸­å·²ç»æœ‰ä¸€ä¸ªç›®å½• ï¼Œå¹¶ä¸”æ‚¨æƒ³åœ¨é‚£é‡Œå®‰è£… Go ç¨‹åºï¼Œæ‚¨å¯ä»¥é€šè¿‡GOBINä½¿ç”¨ä»¥ä¸‹å‘½ä»¤è®¾ç½®å˜é‡æ¥ æ›´æ”¹å®‰è£…ç›®æ ‡ï¼šgo env\ngo env -w GOBIN=/path/to/your/bin // or go env -w GOBIN=C:\\path\\to\\your\\bin æ›´æ–° shell è·¯å¾„åï¼Œè¿è¡Œgo installå‘½ä»¤æ¥ç¼–è¯‘å’Œå®‰è£…åŒ…ã€‚ go install åªéœ€é”®å…¥å…¶åç§°å³å¯è¿è¡Œæ‚¨çš„åº”ç”¨ç¨‹åºã€‚ä¸ºäº†ä½¿è¿™å˜å¾—æœ‰è¶£ï¼Œæ‰“å¼€ä¸€ä¸ªæ–°çš„å‘½ä»¤æç¤ºç¬¦å¹¶helloåœ¨å…¶ä»–ç›®å½•ä¸­è¿è¡Œå¯æ‰§è¡Œæ–‡ä»¶åç§°ã€‚ $ hello map[Darrin:Hail, Darrin! Well met! Gladys:Great to see you, Gladys! Samantha:Hail, Samantha! Well met!] ","permalink":"https://heliu.site/posts/golang/package/use-mod/","summary":"Golang åˆ›å»ºæ¨¡å—ä»‹ç»ã€‚","title":"åˆ›å»ºæ¨¡å—"},{"content":" æ‚¨å¯ä»¥å°†ç›¸å…³åŒ…æ”¶é›†åˆ°æ¨¡å—ä¸­ï¼Œç„¶åå‘å¸ƒæ¨¡å—ä¾›å…¶ä»–å¼€å‘äººå‘˜ä½¿ç”¨ã€‚æœ¬ä¸»é¢˜æ¦‚è¿°äº†å¼€å‘å’Œå‘å¸ƒæ¨¡å—ã€‚ ä¸ºäº†æ”¯æŒå¼€å‘ã€å‘å¸ƒå’Œä½¿ç”¨æ¨¡å—ï¼Œæ‚¨å¯ä»¥ä½¿ç”¨ï¼š æ‚¨å¼€å‘å’Œå‘å¸ƒæ¨¡å—çš„å·¥ä½œæµç¨‹ï¼Œéšç€æ—¶é—´çš„æ¨ç§»ä½¿ç”¨æ–°ç‰ˆæœ¬å¯¹å…¶è¿›è¡Œä¿®æ”¹ã€‚è¯·å‚é˜…ã€å¼€å‘å’Œå‘å¸ƒæ¨¡å—çš„å·¥ä½œæµç¨‹ã€‘ã€‚ å¸®åŠ©æ¨¡å—ç”¨æˆ·ç†è§£å¹¶ä»¥ç¨³å®šæ–¹å¼å‡çº§åˆ°æ–°ç‰ˆæœ¬çš„è®¾è®¡å®è·µã€‚è¯·å‚ã€é˜…è®¾è®¡å’Œå¼€å‘ã€‘ã€‚ ç”¨äºå‘å¸ƒæ¨¡å—å’Œæ£€ç´¢å…¶ä»£ç çš„å»ä¸­å¿ƒåŒ–ç³»ç»Ÿã€‚æ‚¨ä½¿æ‚¨çš„æ¨¡å—å¯ä¾›å…¶ä»–å¼€å‘äººå‘˜ä»æ‚¨è‡ªå·±çš„å­˜å‚¨åº“ä¸­ä½¿ç”¨å¹¶ä½¿ç”¨ç‰ˆæœ¬å·å‘å¸ƒã€‚è¯·å‚é˜… å»ä¸­å¿ƒåŒ–å‡ºç‰ˆã€‚ ä¸€ä¸ªåŒ…æœç´¢å¼•æ“å’Œæ–‡æ¡£æµè§ˆå™¨(pkg.go.dev)ï¼Œå¼€å‘äººå‘˜å¯ä»¥åœ¨å…¶ä¸­æ‰¾åˆ°æ‚¨çš„æ¨¡å—ã€‚è¯·å‚é˜…åŒ…å‘ç°ã€‚ ä¸€ç§æ¨¡å—ç‰ˆæœ¬ç¼–å·çº¦å®šï¼Œç”¨äºå‘ä½¿ç”¨æ‚¨çš„æ¨¡å—çš„å¼€å‘äººå‘˜ä¼ è¾¾å¯¹ç¨³å®šæ€§å’Œå‘åå…¼å®¹æ€§çš„æœŸæœ›ã€‚è¯·å‚é˜… ç‰ˆæœ¬æ§åˆ¶ã€‚ Go å·¥å…·ä½¿å…¶ä»–å¼€å‘äººå‘˜æ›´å®¹æ˜“ç®¡ç†ä¾èµ–é¡¹ï¼ŒåŒ…æ‹¬è·å–æ¨¡å—çš„æºä»£ç ã€å‡çº§ç­‰ã€‚è¯·å‚é˜…ç®¡ç†ä¾èµ–é¡¹ã€‚ ä¹Ÿå¯ä»¥çœ‹çœ‹ï¼š å¦‚æœæ‚¨åªæ˜¯å¯¹ä½¿ç”¨å…¶ä»–äººå¼€å‘çš„è½¯ä»¶åŒ…æ„Ÿå…´è¶£ï¼Œé‚£ä¹ˆè¿™ä¸æ˜¯æ‚¨çš„ä¸»é¢˜ã€‚ç›¸åï¼Œè¯·å‚é˜…ç®¡ç†ä¾èµ–é¡¹ã€‚ æœ‰å…³åŒ…å«ä¸€äº›æ¨¡å—å¼€å‘åŸºç¡€çŸ¥è¯†çš„æ•™ç¨‹ï¼Œè¯·å‚é˜…æ•™ç¨‹ï¼šåˆ›å»º Go æ¨¡å—ã€‚ å¼€å‘å’Œå‘å¸ƒæ¨¡å—çš„å·¥ä½œæµç¨‹ å½“æ‚¨æƒ³ä¸ºå…¶ä»–äººå‘å¸ƒæ‚¨çš„æ¨¡å—æ—¶ï¼Œæ‚¨å¯ä»¥é‡‡ç”¨ä¸€äº›çº¦å®šæ¥ç®€åŒ–è¿™äº›æ¨¡å—çš„ä½¿ç”¨ã€‚ æ¨¡å—å‘å¸ƒå’Œç‰ˆæœ¬æ§åˆ¶å·¥ä½œæµç¨‹ä¸­æ›´è¯¦ç»†åœ°æè¿°äº†ä»¥ä¸‹é«˜çº§æ­¥éª¤ã€‚ è®¾è®¡å’Œç¼–ç æ¨¡å—å°†åŒ…å«çš„åŒ…ã€‚ ä½¿ç”¨çº¦å®šå°†ä»£ç æäº¤åˆ°æ‚¨çš„å­˜å‚¨åº“ï¼Œä»¥ç¡®ä¿å…¶ä»–äººå¯ä»¥é€šè¿‡ Go å·¥å…·ä½¿ç”¨å®ƒã€‚ å‘å¸ƒæ¨¡å—ä»¥ä½¿å…¶å¯è¢«å¼€å‘äººå‘˜å‘ç°ã€‚ éšç€æ—¶é—´çš„æ¨ç§»ï¼Œä½¿ç”¨ä½¿ç”¨ç‰ˆæœ¬ç¼–å·çº¦å®šçš„ç‰ˆæœ¬æ¥ä¿®æ”¹æ¨¡å—ï¼Œä»¥è¡¨æ˜æ¯ä¸ªç‰ˆæœ¬çš„ç¨³å®šæ€§å’Œå‘åå…¼å®¹æ€§ã€‚ è®¾è®¡å’Œå¼€å‘ å¦‚æœæ¨¡å—ä¸­çš„åŠŸèƒ½å’ŒåŒ…å½¢æˆä¸€ä¸ªè¿è´¯çš„æ•´ä½“ï¼Œæ‚¨çš„æ¨¡å—å°†æ›´å®¹æ˜“è¢«å¼€å‘äººå‘˜æ‰¾åˆ°å’Œä½¿ç”¨ã€‚å½“ä½ è®¾è®¡ä¸€ä¸ªæ¨¡å—çš„å…¬å…± API æ—¶ï¼Œå°½é‡ä¿æŒå®ƒçš„åŠŸèƒ½é›†ä¸­å’Œç¦»æ•£ã€‚ æ­¤å¤–ï¼Œåœ¨è®¾è®¡å’Œå¼€å‘æ¨¡å—æ—¶è€ƒè™‘åˆ°å‘åå…¼å®¹æ€§å¯ä»¥å¸®åŠ©å…¶ç”¨æˆ·å‡çº§ï¼ŒåŒæ—¶æœ€å¤§é™åº¦åœ°å‡å°‘ä»–ä»¬è‡ªå·±çš„ä»£ç çš„æµå¤±ã€‚æ‚¨å¯ä»¥åœ¨ä»£ç ä¸­ä½¿ç”¨æŸäº›æŠ€æœ¯æ¥é¿å…å‘å¸ƒç ´åå‘åå…¼å®¹æ€§çš„ç‰ˆæœ¬ã€‚æœ‰å…³è¿™äº›æŠ€æœ¯çš„æ›´å¤šä¿¡æ¯ï¼Œè¯·å‚é˜…Goåšå®¢ä¸Šçš„ä¿æŒæ¨¡å—å…¼å®¹ã€‚ åœ¨å‘å¸ƒæ¨¡å—ä¹‹å‰ï¼Œæ‚¨å¯ä»¥ä½¿ç”¨replaceæŒ‡ä»¤åœ¨æœ¬åœ°æ–‡ä»¶ç³»ç»Ÿä¸Šå¼•ç”¨å®ƒã€‚è¿™ä½¿å¾—åœ¨æ¨¡å—ä»åœ¨å¼€å‘æ—¶ç¼–å†™è°ƒç”¨æ¨¡å—ä¸­çš„å‡½æ•°çš„å®¢æˆ·ç«¯ä»£ç å˜å¾—æ›´åŠ å®¹æ˜“ã€‚æœ‰å…³è¯¦ç»†ä¿¡æ¯ï¼Œè¯·å‚é˜…æ¨¡å—å‘å¸ƒå’Œç‰ˆæœ¬æ§åˆ¶å·¥ä½œæµç¨‹ä¸­çš„â€œé’ˆå¯¹æœªå‘å¸ƒçš„æ¨¡å—è¿›è¡Œç¼–ç â€ ã€‚ å»ä¸­å¿ƒåŒ–å‡ºç‰ˆ åœ¨Goä¸­ï¼Œæ‚¨é€šè¿‡åœ¨å­˜å‚¨åº“ä¸­æ ‡è®°å…¶ä»£ç æ¥å‘å¸ƒæ‚¨çš„æ¨¡å—ï¼Œä»¥ä½¿å…¶å¯ä¾›å…¶ä»–å¼€å‘äººå‘˜ä½¿ç”¨ã€‚ æ‚¨ä¸éœ€è¦å°†æ¨¡å—æ¨é€åˆ°é›†ä¸­å¼æœåŠ¡ï¼Œå› ä¸ºGoå·¥å…·å¯ä»¥ç›´æ¥ä»æ‚¨çš„å­˜å‚¨åº“ï¼ˆä½¿ç”¨æ¨¡å—çš„è·¯å¾„å®šä½ï¼Œè¿™æ˜¯ä¸€ä¸ªçœç•¥äº†è¯¥æ–¹æ¡ˆçš„URLï¼‰æˆ–ä»ä»£ç†æœåŠ¡å™¨ä¸‹è½½æ‚¨çš„æ¨¡å—ã€‚ åœ¨ä»–ä»¬çš„ä»£ç ä¸­å¯¼å…¥ä½ çš„åŒ…åï¼Œå¼€å‘äººå‘˜ä½¿ç”¨Goå·¥å…·ï¼ˆåŒ…æ‹¬go getå‘½ä»¤ï¼‰ä¸‹è½½ä½ çš„æ¨¡å—ä»£ç ä»¥è¿›è¡Œç¼–è¯‘ã€‚ä¸ºäº†æ”¯æŒæ­¤æ¨¡å‹ï¼Œæ‚¨éµå¾ªçº¦å®šå’Œæœ€ä½³å®è·µï¼Œä½¿Goå·¥å…·ï¼ˆä»£è¡¨å…¶ä»–å¼€å‘äººå‘˜ï¼‰å¯ä»¥ä»å­˜å‚¨åº“ä¸­æ£€ç´¢æ¨¡å—çš„æºä»£ç ã€‚ ä¾‹å¦‚ï¼ŒGoå·¥å…·ä½¿ç”¨ä½ æŒ‡å®šçš„æ¨¡å—çš„æ¨¡å—è·¯å¾„ï¼Œä»¥åŠä½ ç”¨æ¥æ ‡è®°æ¨¡å—ä»¥å‘å¸ƒçš„æ¨¡å—ç‰ˆæœ¬å·ï¼Œä¸ºå®ƒçš„ç”¨æˆ·å®šä½å’Œä¸‹è½½æ¨¡å—ã€‚ æœ‰å…³æºå’Œå‘å¸ƒçº¦å®šä»¥åŠæœ€ä½³å®è·µçš„æ›´å¤šä¿¡æ¯ï¼Œè¯·å‚é˜…ç®¡ç†æ¨¡å—æºã€‚ æœ‰å…³å‘å¸ƒæ¨¡å—çš„åˆ†æ­¥è¯´æ˜ï¼Œè¯·å‚é˜…å‘å¸ƒæ¨¡å—ã€‚ åŒ…å‘ç° åœ¨æ‚¨å‘å¸ƒäº†æ‚¨çš„æ¨¡å—å¹¶ä¸”æœ‰äººä½¿ç”¨Goå·¥å…·è·å–äº†å®ƒä¹‹åï¼Œå®ƒå°†åœ¨GoåŒ…å‘ç°ç«™ç‚¹pkg.go.devä¸Šå¯è§ã€‚åœ¨é‚£é‡Œï¼Œå¼€å‘äººå‘˜å¯ä»¥æœç´¢è¯¥ç«™ç‚¹ä»¥æ‰¾åˆ°å®ƒå¹¶é˜…è¯»å…¶æ–‡æ¡£ã€‚ è¦å¼€å§‹ä½¿ç”¨è¯¥æ¨¡å—ï¼Œå¼€å‘äººå‘˜ä»è¯¥æ¨¡å—å¯¼å…¥åŒ…ï¼Œç„¶åè¿è¡Œgo getå‘½ä»¤ä¸‹è½½å…¶æºä»£ç ä»¥è¿›è¡Œç¼–è¯‘ã€‚ æœ‰å…³å¼€å‘äººå‘˜å¦‚ä½•æŸ¥æ‰¾å’Œä½¿ç”¨æ¨¡å—çš„æ›´å¤šä¿¡æ¯ï¼Œè¯·å‚é˜…ç®¡ç†ä¾èµ–é¡¹ã€‚ ç‰ˆæœ¬æ§åˆ¶ å½“æ‚¨éšç€æ—¶é—´çš„æ¨ç§»ä¿®æ”¹å’Œæ”¹è¿›æ‚¨çš„æ¨¡å—æ—¶ï¼Œæ‚¨ä¼šåˆ†é…ç‰ˆæœ¬å·ï¼ˆåŸºäºè¯­ä¹‰ç‰ˆæœ¬æ§åˆ¶æ¨¡å‹ï¼‰ï¼Œæ—¨åœ¨è¡¨æ˜æ¯ä¸ªç‰ˆæœ¬çš„ç¨³å®šæ€§å’Œå‘åå…¼å®¹æ€§ã€‚è¿™æœ‰åŠ©äºä½¿ç”¨æ‚¨çš„æ¨¡å—çš„å¼€å‘äººå‘˜ç¡®å®šæ¨¡å—ä½•æ—¶ç¨³å®šä»¥åŠå‡çº§æ˜¯å¦å¯èƒ½åŒ…æ‹¬è¡Œä¸ºçš„é‡å¤§å˜åŒ–ã€‚æ‚¨å¯ä»¥é€šè¿‡åœ¨å­˜å‚¨åº“ä¸­æ ‡è®°æ¨¡å—çš„æºä»£ç æ¥æŒ‡ç¤ºæ¨¡å—çš„ç‰ˆæœ¬å·ã€‚ æœ‰å…³å¼€å‘ä¸»è¦ç‰ˆæœ¬æ›´æ–°çš„æ›´å¤šä¿¡æ¯ï¼Œè¯·å‚é˜…å¼€å‘ä¸»è¦ç‰ˆæœ¬æ›´æ–°ã€‚ æœ‰å…³å¦‚ä½•ä¸ºGoæ¨¡å—ä½¿ç”¨è¯­ä¹‰ç‰ˆæœ¬æ§åˆ¶æ¨¡å‹çš„æ›´å¤šä¿¡æ¯ï¼Œè¯·å‚é˜…æ¨¡å—ç‰ˆæœ¬ç¼–å·ã€‚ æ¨¡å—å‘å¸ƒå’Œç‰ˆæœ¬æ§åˆ¶å·¥ä½œæµç¨‹ å½“æ‚¨å¼€å‘ä¾›å…¶ä»–å¼€å‘äººå‘˜ä½¿ç”¨çš„æ¨¡å—æ—¶ï¼Œæ‚¨å¯ä»¥éµå¾ªæœ‰åŠ©äºç¡®ä¿ä½¿ç”¨è¯¥æ¨¡å—çš„å¼€å‘äººå‘˜è·å¾—å¯é ã€ä¸€è‡´çš„ä½“éªŒçš„å·¥ä½œæµç¨‹ã€‚ æœ¬ä¸»é¢˜æè¿°äº†è¯¥å·¥ä½œæµä¸­çš„é«˜çº§æ­¥éª¤ã€‚ æœ‰å…³æ¨¡å—å¼€å‘çš„æ¦‚è¿°ï¼Œè¯·å‚é˜…å¼€å‘å’Œå‘å¸ƒæ¨¡å—ã€‚ ä¹Ÿå¯ä»¥çœ‹çœ‹ å¦‚æœæ‚¨åªæƒ³åœ¨ä»£ç ä¸­ä½¿ç”¨å¤–éƒ¨åŒ…ï¼Œè¯·åŠ¡å¿…æŸ¥çœ‹ç®¡ç†ä¾èµ–é¡¹ã€‚ å¯¹äºæ¯ä¸ªæ–°ç‰ˆæœ¬ï¼Œæ‚¨éƒ½ç”¨å…¶ç‰ˆæœ¬å·è¡¨ç¤ºå¯¹æ¨¡å—çš„æ›´æ”¹ã€‚æœ‰å…³æ›´å¤šä¿¡æ¯ï¼Œè¯·å‚é˜…æ¨¡å—ç‰ˆæœ¬ç¼–å·ã€‚ å¸¸è§çš„å·¥ä½œæµç¨‹æ­¥éª¤ ä»¥ä¸‹åºåˆ—è¯´æ˜äº†ç¤ºä¾‹æ–°æ¨¡å—çš„å‘å¸ƒå’Œç‰ˆæœ¬æ§åˆ¶å·¥ä½œæµç¨‹æ­¥éª¤ã€‚æœ‰å…³æ¯ä¸ªæ­¥éª¤çš„æ›´å¤šä¿¡æ¯ï¼Œè¯·å‚é˜…æœ¬ä¸»é¢˜ä¸­çš„éƒ¨åˆ†ã€‚\nå¼€å§‹ä¸€ä¸ªæ¨¡å—å¹¶ç»„ç»‡å®ƒçš„æºä»£ç ï¼Œä½¿å¼€å‘äººå‘˜æ›´å®¹æ˜“ä½¿ç”¨å’Œç»´æŠ¤ã€‚å¦‚æœæ‚¨æ˜¯å¼€å‘æ¨¡å—çš„æ–°æ‰‹ï¼Œè¯·æŸ¥çœ‹æ•™ç¨‹ï¼šåˆ›å»ºGoæ¨¡å—ã€‚åœ¨ Go çš„å»ä¸­å¿ƒåŒ–æ¨¡å—å‘å¸ƒç³»ç»Ÿä¸­ï¼Œå¦‚ä½•ç»„ç»‡ä»£ç å¾ˆé‡è¦ã€‚æœ‰å…³æ›´å¤šä¿¡æ¯ï¼Œè¯·å‚é˜…ç®¡ç†æ¨¡å—æºã€‚ è®¾ç½®ä¸ºç¼–å†™è°ƒç”¨æœªå‘å¸ƒæ¨¡å—ä¸­çš„å‡½æ•°çš„æœ¬åœ°å®¢æˆ·ç«¯ä»£ç ã€‚åœ¨å‘å¸ƒæ¨¡å—ä¹‹å‰ï¼Œå¯¹äºä½¿ç”¨è¯¸å¦‚go getã€‚ åœ¨æ­¤é˜¶æ®µæµ‹è¯•æ¨¡å—ä»£ç çš„ä¸€ä¸ªå¥½æ–¹æ³•æ˜¯åœ¨å®ƒä½äºè°ƒç”¨ä»£ç çš„æœ¬åœ°ç›®å½•ä¸­æ—¶å°è¯•å®ƒã€‚æœ‰å…³æœ¬åœ°å¼€å‘çš„æ›´å¤šä¿¡æ¯ï¼Œè¯·å‚é˜…é’ˆå¯¹æœªå‘å¸ƒçš„æ¨¡å—è¿›è¡Œç¼–ç ã€‚ å½“æ¨¡å—çš„ä»£ç å‡†å¤‡å¥½ä¾›å…¶ä»–å¼€å‘äººå‘˜è¯•ç”¨æ—¶ï¼Œå¼€å§‹å‘å¸ƒv0é¢„å‘å¸ƒç‰ˆæœ¬ï¼Œä¾‹å¦‚alphaå’Œbetaã€‚æœ‰å…³æ›´å¤šä¿¡æ¯ï¼Œè¯·å‚é˜…å‘å¸ƒé¢„å‘å¸ƒç‰ˆæœ¬ã€‚ å‘å¸ƒä¸€ä¸ªä¸ä¿è¯ç¨³å®š**çš„v0ï¼Œä½†ç”¨æˆ·å¯ä»¥å°è¯•ã€‚**æœ‰å…³æ›´å¤šä¿¡æ¯ï¼Œè¯·å‚é˜…å‘å¸ƒç¬¬ä¸€ä¸ªï¼ˆä¸ç¨³å®šï¼‰ç‰ˆæœ¬ã€‚ åœ¨æ‚¨çš„ v0 ç‰ˆæœ¬å‘å¸ƒåï¼Œæ‚¨å¯ä»¥ï¼ˆå¹¶ä¸”åº”è¯¥ï¼ï¼‰ç»§ç»­ å‘å¸ƒå®ƒçš„æ–°ç‰ˆæœ¬ã€‚è¿™äº›æ–°ç‰ˆæœ¬å¯èƒ½åŒ…æ‹¬é”™è¯¯ä¿®å¤ï¼ˆè¡¥ä¸ç‰ˆæœ¬ï¼‰ã€å¯¹æ¨¡å—å…¬å…± API çš„æ·»åŠ ï¼ˆæ¬¡è¦ç‰ˆæœ¬ï¼‰ï¼Œç”šè‡³æ˜¯é‡å¤§æ›´æ”¹ã€‚ç”±äºv0ç‰ˆæœ¬ä¸ä¿è¯ç¨³å®šæ€§æˆ–å‘åå…¼å®¹æ€§ï¼Œå› æ­¤æ‚¨å¯ä»¥å¯¹å…¶ç‰ˆæœ¬è¿›è¡Œé‡å¤§æ›´æ”¹ã€‚æœ‰å…³æ›´å¤šä¿¡æ¯ï¼Œè¯·å‚é˜…å‘å¸ƒé”™è¯¯ä¿®å¤å’Œå‘å¸ƒéç ´åæ€§APIæ›´æ”¹ã€‚ å½“æ‚¨å‡†å¤‡å¥½å‘å¸ƒçš„ç¨³å®šç‰ˆæœ¬æ—¶ï¼Œæ‚¨å¯ä»¥å°†é¢„å‘å¸ƒç‰ˆæœ¬å‘å¸ƒä¸ºalphaså’Œbetasã€‚æœ‰å…³æ›´å¤šä¿¡æ¯ï¼Œè¯·å‚é˜…å‘å¸ƒé¢„å‘å¸ƒç‰ˆæœ¬ã€‚ å‘å¸ƒ v1 ä½œä¸ºç¬¬ä¸€ä¸ªç¨³å®šç‰ˆæœ¬ã€‚è¿™æ˜¯å¯¹æ¨¡å—ç¨³å®šæ€§åšå‡ºæ‰¿è¯ºçš„ç¬¬ä¸€ä¸ªç‰ˆæœ¬ã€‚æœ‰å…³æ›´å¤šä¿¡æ¯ï¼Œè¯·å‚é˜…å‘å¸ƒç¬¬ä¸€ä¸ªç¨³å®šç‰ˆæœ¬ã€‚ åœ¨ v1 ç‰ˆæœ¬ä¸­ï¼Œç»§ç»­ä¿®å¤é”™è¯¯ï¼Œå¹¶åœ¨å¿…è¦æ—¶å¯¹æ¨¡å—çš„å…¬å…± API è¿›è¡Œæ·»åŠ ã€‚æœ‰å…³æ›´å¤šä¿¡æ¯ï¼Œè¯·å‚é˜…å‘å¸ƒé”™è¯¯ä¿®å¤å’Œå‘å¸ƒéç ´åæ€§ API æ›´æ”¹ã€‚ å¦‚æœæ— æ³•é¿å…ï¼Œè¯·åœ¨æ–°çš„ä¸»è¦ç‰ˆæœ¬ä¸­å‘å¸ƒé‡å¤§æ›´æ”¹ã€‚ä¸»è¦ç‰ˆæœ¬æ›´æ–°â€”â€”ä¾‹å¦‚ä» v1.xx åˆ° v2.xxâ€”â€”å¯¹äºæ¨¡å—çš„ç”¨æˆ·æ¥è¯´å¯èƒ½æ˜¯ä¸€ä¸ªéå¸¸å…·æœ‰ç ´åæ€§çš„å‡çº§ã€‚è¿™åº”è¯¥æ˜¯æœ€åçš„æ‰‹æ®µã€‚æœ‰å…³æ›´å¤šä¿¡æ¯ï¼Œè¯·å‚é˜…å‘å¸ƒé‡å¤§ API æ›´æ”¹ã€‚ ","permalink":"https://heliu.site/posts/golang/package/publish-mod/","summary":"Golang å‘å¸ƒæ¨¡å—æµç¨‹ä»‹ç»ã€‚","title":"å¼€å‘å’Œå‘å¸ƒæ¨¡å—"},{"content":"æ•°ç»„çš„å®šä¹‰ ğŸš€ æ•°ç»„æ˜¯å…·æœ‰ç›¸åŒå”¯ä¸€ç±»å‹çš„ä¸€ç»„å·²ç¼–ç ä¸”é•¿åº¦å›ºå®šçš„æ•°æ®é¡¹åºåˆ—ã€‚ è¿™æ˜¯ä¸€ç§åŒæ„çš„æ•°æ®ç»“æ„ï¼Œè¿™ç§ç±»å‹å¯ä»¥æ˜¯ä»»æ„çš„åŸºç¡€ç±»å‹ï¼Œå¦‚æ•´å‹ã€å­—ç¬¦ä¸²æˆ–è‡ªå®šä¹‰ç±»å‹ã€‚ æ•°ç»„é•¿åº¦å¿…é¡»æ˜¯ä¸€ä¸ªå¸¸é‡è¡¨è¾¾å¼ï¼ˆç¼–è¯‘æœŸé—´èƒ½ç¡®å®šçš„å€¼ï¼‰ï¼Œå¹¶ä¸”æ˜¯ä¸€ä¸ªéè´Ÿæ•°ã€‚ æ•°ç»„çš„é•¿åº¦ä¹Ÿæ˜¯æ•°ç»„ç±»å‹çš„ä¸€éƒ¨åˆ†ï¼Œ[5]intå’Œ[10]intæ˜¯å±äºä¸åŒç±»å‹ã€‚ å¦‚æœæƒ³è®©æ•°ç»„å…ƒç´ ï¼Œç±»å‹ä¸ºä»»æ„ç±»å‹ï¼Œå¯ä»¥ä½¿ç”¨ç©ºæ¥å£interface{}ä½œä¸ºç±»å‹ï¼Œä½†ä½¿ç”¨æ—¶ï¼Œå¿…é¡»å…ˆåšä¸€ä¸ªç±»å‹åˆ¤æ–­ã€‚ è®¿é—®è¶Šç•Œï¼Œå¦‚æœä¸‹æ ‡åœ¨æ•°ç»„åˆæ³•èŒƒå›´ä¹‹å¤–ï¼Œåˆ™è§¦å‘è®¿é—®è¶Šç•Œï¼Œä¼španicã€‚ æ•°ç»„æ˜¯å€¼ç±»å‹ï¼Œèµ‹å€¼å’Œä¼ å‚ä¼šå¤åˆ¶æ•´ä¸ªæ•°ç»„ï¼Œè€Œä¸æ˜¯æŒ‡é’ˆã€‚å› æ­¤æ”¹å˜å‰¯æœ¬çš„å€¼ï¼Œä¸ä¼šæ”¹å˜æœ¬èº«çš„å€¼ã€‚ åªæ”¯æŒ \u0026ldquo;==\u0026quot;ã€\u0026rdquo;!=\u0026quot; æ“ä½œç¬¦ã€‚ï¼ˆä¸æ”¯æŒ \u0026ldquo;\u0026gt;\u0026quot;ã€\u0026quot;\u0026lt;\u0026quot;ã€\u0026quot;\u0026gt;=\u0026quot;ã€\u0026quot;\u0026lt;=\u0026quot;ï¼ŒåŸå› æ˜¯å¤§äºã€å°äºå¯¹äºæ•°ç»„æ¥è¯´æ²¡å•¥æ„ä¹‰ï¼Œæˆ‘ä»¬ä¹Ÿä¸ä¼šæ¯”è¾ƒä¸¤ä¸ªæ•°ç»„è°å¤§è°å°ï¼‰ æŒ‡é’ˆæ•°ç»„ [n]*Tï¼Œæ•°ç»„æŒ‡é’ˆ *[n]Tã€‚ æ•°ç»„å…ƒç´ ä¸ºç©ºæ¥å£ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;unsafe\u0026#34; ) func main() { // æ•°ç»„ a æ‰€å å†…å­˜ 16 * 5 = 80 å­—èŠ‚ var a [5]interface{} = [5]interface{}{1, \u0026#34;hello\u0026#34;, false, 0.23, 2i} // ç©ºæ¥å£çš„ç»“æ„æ„é€ ï¼Œtype eface struct {typ *_type, data uintptr} fmt.Printf(\u0026#34;æ•°ç»„aå ç”¨å†…å­˜çš„å¤§å°%d\\n\u0026#34;, unsafe.Sizeof(a))\t// æ•°ç»„aå ç”¨å†…å­˜çš„å¤§å°80 5*(8+8) // [5]interface {}{1, \u0026#34;hello\u0026#34;, false, 0.23, (0+2i)} fmt.Printf(\u0026#34;%#v\\n\u0026#34;, a) // è¿™é‡Œéå†å¯ä»¥æ”¹æˆéå† \u0026amp;aï¼Œè¿™æ ·é¿å…äº†å¤§æ•°ç»„çš„å¤åˆ¶ // å˜é‡æŒ‡é’ˆæ•°ç»„æ˜¯Goçš„è¯­æ³•ç³– for i, v := range a { // ã€int, anyã€‘ fmt.Printf(\u0026#34;i:%d v:%#v t:%T\\n\u0026#34;, i , v, v) // å¿…é¡»è¦åšæ–­è¨€æ‰èƒ½ä½¿ç”¨ï¼Œç©ºæ¥å£.(å…·ä½“ç±»å‹) if ii, ok := v.(int); ok { fmt.Println(ii + 10) } } // Output: // æ•°ç»„aå ç”¨å†…å­˜çš„å¤§å°80 // [5]interface {}{1, \u0026#34;hello\u0026#34;, false, 0.23, (0+2i)} // i:0 v:1 t:int // 11 // i:1 v:\u0026#34;hello\u0026#34; t:string // i:2 v:false t:bool // i:3 v:0.23 t:float64 // i:4 v:(0+2i) t:complex128 } æŒ‡é’ˆæ•°ç»„å’Œæ•°ç»„æŒ‡é’ˆ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 package main import \u0026#34;fmt\u0026#34; func main() { // 1. æŒ‡é’ˆæ•°ç»„ï¼Œæ•°ç»„çš„å…ƒç´ æ˜¯æŒ‡é’ˆç±»å‹ var p1 [2]*int = [2]*int{} // [2]*int{nil, nil} fmt.Println(p1) var a int = 5 p1[1] = \u0026amp;a fmt.Println(p1) // Output: // [\u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt;] // [\u0026lt;nil\u0026gt; 0xc00000e0b8] // 2. æ•°ç»„æŒ‡é’ˆ var p2 *[2]int fmt.Println(p2) a1 := [2]int{1, 2} p2 = \u0026amp;a1 fmt.Printf(\u0026#34;%#v\u0026#34;, p2) // Output // \u0026lt;nil\u0026gt; // \u0026amp;[2]int{1, 2} } æ•°ç»„å’Œæ•°ç»„æŒ‡é’ˆ åœ¨Goä¸­æ•°ç»„å’Œæ•°ç»„æŒ‡é’ˆçš„ç”¨æ³•åŸºæœ¬ä¸€è‡´ï¼Œèƒ½éå†ï¼ˆrangeï¼‰ã€èµ‹å€¼ã€å–å€¼ã€æ±‚é•¿åº¦ç­‰ï¼Œè¿™æ˜¯ç”±äºæ•°ç»„æŒ‡é’ˆæ“ä½œæ—¶å­˜åœ¨è¯­æ³•ç³–æ”¯æŒã€‚ åˆ‡ç‰‡(slice)åˆ™ä¸å…è®¸è¿™æ ·æ“ä½œï¼Œåªæœ‰æ•°ç»„æ˜¯ç‰¹æœ‰çš„ï¼Œä¸ºå•¥æ•°ç»„æ”¯æŒéå†æ•°ç»„åœ°å€ï¼Œå¾ˆå¤§åŸå› æ˜¯å¤§æ•°æ®æ•°ç»„éå†çš„æ‹·è´å¼€é”€æ¯”è¾ƒå¤§ï¼Œé‡‡ç”¨æŒ‡é’ˆå½¢å¼åˆ™ä¸éœ€è¦æ‹·è´ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 { // *[5]int a1 := new([5]int) // 1) è¯­æ³•ç³–ï¼š (*a1)[0] = 12 a1[0] = 12\t// 2) è¯­æ³•ç³–ï¼š c := (*a1)[1] c := a1[1]\t// 3) è¯­æ³•ç³–ï¼š l := len(*a1) l := len(a1)\t// éå†a1ï¼Œè¿™æ˜¯ç”±äºä¸Šé¢ä¸¤ä¸ªè¯­æ³•ç³–(2)(3)çš„æ”¯æŒ for i := range a1 { // ã€int, intã€‘ } } æ•°ç»„çš„å£°æ˜ä¸ä½¿ç”¨ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 // 1) æŒ‡å®šç´¢å¼• var a = [5]string{3:\u0026#34;hello\u0026#34;, \u0026#34;world\u0026#34;} // [5]string{\u0026#34;\u0026#34;, \u0026#34;\u0026#34;, \u0026#34;\u0026#34;, \u0026#34;hello\u0026#34;, \u0026#34;world\u0026#34;} fmt.Printf(\u0026#34;%#v\\n\u0026#34;, a) // 2) ... åªèƒ½ç”¨åœ¨æœ€å¤–å±‚æ•°ç»„ // ... çš„ç”¨æ³• // 1. ç”¨äºæ•°ç»„å£°æ˜çš„æœ€å¤–å±‚æ•°ç»„ï¼Œè‡ªåŠ¨ç»Ÿè®¡æ•°ç»„é•¿åº¦ã€‚ // 2. ç”¨ä½œå‡½æ•°çš„æœ€åä¸€ä¸ªå‚æ•°ï¼Œ...T è¡¨ç¤ºå¯å˜å‚æ•° []T åˆ‡ç‰‡å½¢å¼ã€‚ // 3. ç”¨ä½œåˆ‡ç‰‡å []T... è¡¨ç¤ºè§£å¼•ç”¨ã€‚ã€append([]int{1,2}, []int{3,4,5}...)ã€‘ // 4. åªæœ‰åœ¨ã€append([]byte(\u0026#34;hello \u0026#34;), \u0026#34;world\u0026#34;...)ã€‘æ—¶å¯ä»¥ä½¿ç”¨ ã€string...ã€‘ å½¢å¼å…¶ä»–åœ°æ–¹ä¸è¢«å…è®¸ã€‚ // slice = append(slice, elem1, elem2) // slice = append(slice, anotherSlice...) // slice = append([]byte(\u0026#34;hello \u0026#34;), \u0026#34;world\u0026#34;...) // ... ä½œä¸ºè§£å¼•ç”¨æ—¶ï¼Œåªèƒ½ç”¨åœ¨Sliceå’Œstringä¸­ var b = [...]string{3:\u0026#34;hello\u0026#34;, \u0026#34;world\u0026#34;} // [5]string{\u0026#34;\u0026#34;, \u0026#34;\u0026#34;, \u0026#34;\u0026#34;, \u0026#34;hello\u0026#34;, \u0026#34;world\u0026#34;} fmt.Printf(\u0026#34;%#v\\n\u0026#34;, b) // 3) é»˜è®¤å€¼ï¼Œæ³¨æ„ä¸æ˜¯ç©ºæ•°ç»„ï¼Œæ•°ç»„ä¸å­˜åœ¨ç©ºæ•°ç»„æ¦‚å¿µï¼Œæ•°ç»„ä¸­ä¸€å®šæ˜¯å­˜åœ¨å€¼çš„å³ä½¿æ˜¯é»˜è®¤å€¼ var c [2]uint8\t// [2]uint8{0, 0} // Output: // [5]string{\u0026#34;\u0026#34;, \u0026#34;\u0026#34;, \u0026#34;\u0026#34;, \u0026#34;hello\u0026#34;, \u0026#34;world\u0026#34;} // [5]string{\u0026#34;\u0026#34;, \u0026#34;\u0026#34;, \u0026#34;\u0026#34;, \u0026#34;hello\u0026#34;, \u0026#34;world\u0026#34;} ä¸€ç»´æ•°ç»„æˆ–å¤šç»´æ•°ç»„ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 package main import ( \u0026#34;fmt\u0026#34; ) func main() { // 1. å¸¸ç”¨åˆå§‹åŒ– var arrAge = [5]int{15,16,15,18,17}\t// [5]int{15,16,15,18,17}\t// 2. æŒ‡å®šç´¢å¼•ä½ç½®çš„åˆå§‹åŒ– var arrName = [5]string{3:\u0026#34;Chris\u0026#34;, 4:\u0026#34;Ron\u0026#34;}\t// [5]string{\u0026#34;\u0026#34;,\u0026#34;\u0026#34;,\u0026#34;\u0026#34;,\u0026#34;Chris\u0026#34;, \u0026#34;Ron\u0026#34;} var arrCount = [4]int{500, 2:100}\t// [4]int{500,0,100,0} // 3. æ•°ç»„é•¿åº¦åˆå§‹åŒ–æ ¹æ®å…ƒç´ å¤šå°‘å†³å®š var arrLazy = [...]int{5,6,7,8,23}\t// [5]int{5,6,7,8,23}\tvar arrPack = [...]int{10,5:100}\t// [6]int{10,0,0,0,0,100} // 4. ä¸æŒ‡å®šé»˜è®¤å€¼ var arrRoom [20]int\t// [20]int{0,0,0,...} // 5. ä½¿ç”¨newå‡½æ•° var arrBed = new([20]int)\t// *[20]int{0,0,0,...} // 6. æ•°ç»„ç±»å‹æ˜¯ç»“æ„ä½“ d := [...]struct{ name string\t// å 16å­—èŠ‚ age uint8\t// å 1å­—èŠ‚ å†…å­˜å¯¹é½å å 8å­—èŠ‚ }{ {\u0026#34;user1\u0026#34;, 10}, {\u0026#34;user2\u0026#34;, 20},\t// åˆ«å¿˜äº†æœ€åä¸€è¡Œçš„é€—å·ï¼Œè¿™æ˜¯ç”±äºGOè¯­æ³•è§£æ } fmt.Println(unsafe.Sizeof(d))\t// 48 = (16+8) * 2 fmt.Printf(\u0026#34;arrAge:%#v arrAge:Type:%T\\n\u0026#34;, arrAge, arrAge) fmt.Printf(\u0026#34;arrName:%#v arrName:Type:%T\\n\u0026#34;, arrName, arrName) fmt.Printf(\u0026#34;arrCount:%#v arrCount:Type:%T\\n\u0026#34;, arrCount, arrCount) fmt.Printf(\u0026#34;arrLazy:%#v arrLazy:Type:%T\\n\u0026#34;, arrLazy, arrLazy) fmt.Printf(\u0026#34;arrPack:%#v arrPack:Type:%T\\n\u0026#34;, arrPack, arrPack) fmt.Printf(\u0026#34;arrRoom:%#v arrRoom:Type:%T\\n\u0026#34;, arrRoom, arrRoom) fmt.Printf(\u0026#34;arrBed:%#v arrBed:Type:%T\\n\u0026#34;, arrBed, arrBed) fmt.Printf(\u0026#34;d:%#v d:Type:%T\\n\u0026#34;, d, d) } /* * arrAge:[5]int{15, 16, 15, 18, 17} arrAge:Type:[5]int * arrName:[5]string{\u0026#34;\u0026#34;, \u0026#34;\u0026#34;, \u0026#34;\u0026#34;, \u0026#34;Chris\u0026#34;, \u0026#34;Ron\u0026#34;} arrName:Type:[5]string * arrCount:[4]int{500, 0, 100, 0} arrCount:Type:[4]int * arrLazy:[5]int{5, 6, 7, 8, 23} arrLazy:Type:[5]int * arrPack:[6]int{10, 0, 0, 0, 0, 100} arrPack:Type:[6]int * arrRoom:[20]int{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0} arrRoom:Type:[20]int * arrBed:\u0026amp;[20]int{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0} arrBed:Type:*[20]int * d: * [2]struct { name string; age uint8 } * { * struct { name string; age uint8 }{name:\u0026#34;user1\u0026#34;, age:0xa}, * struct { name string; age uint8 }{name:\u0026#34;user2\u0026#34;, age:0x14} * } * d:Type: * [2]struct { name string; age uint8 } */ Goè¯­è¨€ä¸­æ•°ç»„æ˜¯ä¸€ç§å€¼ç±»å‹ï¼ˆä¸åƒC/C++ä¸­æ˜¯æŒ‡å‘é¦–å…ƒç´ çš„æŒ‡é’ˆï¼‰ï¼Œæ‰€ä»¥å¯ä»¥é€šè¿‡new()æ¥åˆ›å»ºã€‚ // ç”³è¯· 5 * 8 byteå†…å­˜ var arr1 = new([5]int)\t// *[5]int ä½¿ç”¨new([5]int)åˆ›å»ºå’Œvar arr2 [5]intçš„åŒºåˆ«ï¼Œarr1çš„ç±»å‹æ˜¯ *[5]intï¼Œè€Œarr2çš„ç±»å‹æ˜¯[5]intã€‚ æ•°ç»„é•¿åº¦ä¸åŒç®—ä½œä¸åŒç±»å‹ åœ¨Goè¯­è¨€ä¸­ï¼Œæ•°ç»„çš„é•¿åº¦éƒ½ç®—åœ¨ç±»å‹é‡Œï¼Œç”±äºåœ¨æ•°ç»„çš„ç±»å‹æè¿°ç»“æ„ä¸­è®°å½•ç€æ•°ç»„çš„é•¿åº¦ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 package main import ( \u0026#34;fmt\u0026#34; ) func main() { // 1) new([5]int) åˆ›å»ºçš„æ˜¯æ•°ç»„æŒ‡é’ˆ var arr1 = new([5]int) // *[5]int // æŠŠæ•°ç»„ [5]int çœ‹åšå¦‚ä¸‹æ„æˆï¼š // a: struct { // a1 int // a2 int // a3 int // a4 int // a5 int // } // åˆ™ arr1 = \u0026amp;a // arr1ç±»å‹:*[5]int, \u0026amp;arr1:0xc00000a028, arr1:0xc000012420, \u0026amp;arr1[0]:0xc000012420 fmt.Printf(\u0026#34;arr1ç±»å‹:%T, \u0026amp;arr1:%p, arr1:%p, \u0026amp;arr1[0]:%p\\n\u0026#34;, arr1, \u0026amp;arr1, arr1, \u0026amp;arr1[0]) // arr1:\u0026amp;[5]int{0, 0, 0, 0, 0} fmt.Printf(\u0026#34;arr1:%#v\\n\u0026#34;, arr1) // arrå’Œarr1æŒ‡å‘åŒä¸€åœ°å€ï¼Œå› è€Œä¿®æ”¹arr1å’ŒarråŒæ ·ä¹Ÿç”Ÿæ•ˆ arr := arr1 // arrç±»å‹:*[5]int, \u0026amp;arr:0xc00000a038, arr:0xc000012420, \u0026amp;arr[0]:0xc000012420 fmt.Printf(\u0026#34;arrç±»å‹:%T, \u0026amp;arr:%p, arr:%p, \u0026amp;arr[0]:%p\\n\u0026#34;, arr, \u0026amp;arr, arr, \u0026amp;arr[0]) // arr:\u0026amp;[5]int{0, 0, 0, 0, 0} fmt.Printf(\u0026#34;arr:%#v\\n\u0026#34;, arr) arr1[2] = 100 // (*arr1)[2] = 100 fmt.Println(arr1[2], arr[2]) // 100 100 // 2) éæŒ‡é’ˆå½¢å¼ [5]int var arr2 [5]int // newArræ˜¯arr2çš„å‰¯æœ¬ï¼Œå› æ­¤ä¿®æ”¹ä»»ä½•ä¸€ä¸ªå€¼éƒ½ä¸ä¼šæ”¹å˜å¦å¤–ä¸€ä¸ªå€¼ newArr := arr2 arr2[2] = 100 fmt.Println(arr2[2], newArr[2]) // 100 0 } å‡½æ•°æˆ–æ–¹æ³•æ—¶ï¼Œå¦‚æœå‚æ•°æ˜¯æ•°ç»„ï¼Œéœ€è¦æ³¨æ„å‚æ•°ä¸èƒ½è¿‡å¤§ã€‚ ç”±äºæŠŠä¸€ä¸ªå¤§æ•°ç»„ä¼ é€’ç»™å‡½æ•°ä¼šæ¶ˆè€—å¾ˆå¤šå†…å­˜ï¼ˆå€¼ä¼ é€’ï¼‰ï¼Œå¯ä»¥ä½¿ç”¨å…¶ä»–æ–¹å¼ä¼ é€’ã€‚ ä¼ é€’æ•°ç»„çš„æŒ‡é’ˆã€‚ ä½¿ç”¨åˆ‡ç‰‡ï¼ˆå¸¸ç”¨é€‰æ‹©ï¼‰ã€‚ å¤šç»´æ•°ç»„ 1 2 3 [...][5]int{ {10,20},{30,40} } // len() é•¿åº¦æ ¹æ®å®é™…åˆå§‹åŒ–æ—¶æ•°ç»„çš„é•¿åº¦æ¥å®šï¼Œè¿™é‡Œæ˜¯ 2 [3][2]int // len() é•¿åº¦è¿™é‡Œæ˜¯ 3 [2][2][2]float64 // å¯ä»¥è¿™æ ·ç†è§£[2]([2]([2]float64)) å®šä¹‰å¤šç»´æ•°ç»„æ˜¯ï¼Œä»…ç¬¬ä¸€ç»´å…è®¸ä½¿ç”¨ \u0026ldquo;...\u0026quot;ã€‚ å†…ç½®å‡½æ•°len()å’Œcap()éƒ½è¿”å›ç¬¬ä¸€ç»´åº¦é•¿åº¦ã€‚ len()è·å–çš„æ˜¯æ•°ç»„çš„é•¿åº¦ã€‚ cap()è·å–çš„æ˜¯æ•°ç»„çš„å®¹é‡ï¼Œè¿™é‡Œä¹Ÿå°±æ˜¯è¿”å›æ•°ç»„çš„é•¿åº¦ã€‚ å®šä¹‰æ•°ç»„æ—¶ \u0026ldquo;...\u0026rdquo; è¡¨ç¤ºé•¿åº¦ä¸å®šï¼Œåˆå§‹åŒ–æ—¶æ ¹æ®å®é™…é•¿åº¦æ¥ç¡®å®šæ•°ç»„çš„é•¿åº¦ã€‚ 1 2 b := [...][5]int{ {10,20},{30,40,50,60} } fmt.Println(b[1][3], len(b)) // 60 2 æ•°ç»„å…ƒç´ å¯ä»¥é€šè¿‡ç´¢å¼•ï¼ˆä¸‹æ ‡ï¼‰æ¥è¯»å–æˆ–è€…ä¿®æ”¹ï¼Œæ‰€ä»¥ä»0å¼€å§‹ã€‚ éå†æ•°ç»„çš„æ–¹æ³•å¯ä»¥ä½¿ç”¨foræˆ–è€…for-rangeã€‚è¿™ä¸¤ç§å¯¹äºåˆ‡ç‰‡ä¸€æ ·é€‚ç”¨ã€‚å¤šç»´æ•°ç»„çš„éå†éœ€è¦ä½¿ç”¨å¤šå±‚çš„åµŒå¥—ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 package main import ( \u0026#34;fmt\u0026#34; ) func main() { var arrAge = [5]int{18,20,15,22,16} for i := 0; i \u0026lt; len(arrAge) ; i++ { // ã€int, intã€‘ fmt.Println(arrAge[i]) } fmt.Println(\u0026#34;-------------------------\u0026#34;) for key, val := range arrAge { // ã€int, intã€‘ fmt.Println(key, val) } // Output: // 18 // 20 // 15 // 22 // 16 // ------------------------- // 0 18 // 1 20 // 2 15 // 3 22 // 4 16 } æ•°ç»„ä¹‹é—´æ¯”è¾ƒ æ•°ç»„å…ƒç´ ç±»å‹æ”¯æŒ == æˆ– != æ“ä½œç¬¦ï¼Œé‚£ä¹ˆæ•°ç»„ä¹Ÿæ”¯æŒæ­¤æ“ä½œã€‚ ä½†å¦‚æœæ•°ç»„ç±»å‹ä¸ä¸€æ ·åˆ™ä¸æ”¯æŒï¼ˆéœ€è¦æ•°ç»„é•¿åº¦å’Œæ•°ç»„ç±»å‹ä¸€è‡´ï¼Œå¦åˆ™ç¼–è¯‘ä¸é€šè¿‡ï¼‰ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 package main import ( \u0026#34;fmt\u0026#34; ) func main() { var arrRoom [20]int var arrBed [20]int fmt.Println(arrRoom == arrBed) // true var a [2]int = [2]int{0, 1} var b [2]int = [2]int{0, 1} var c [2]int = [2]int{0, 2} fmt.Println(a == b) // true fmt.Println(a == c) // false // Output: // true // true // false } æ•°ç»„æ¯”è¾ƒçš„æ ¸å¿ƒä»£ç ç¤ºä¾‹ï¼šä»¥ä¸‹ä»£ç æŠ„è‡ªsrc/reflect/type.goæ–‡ä»¶ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 // typè¡¨ç¤ºæ•°ç»„çš„å…ƒç±»å‹_typeï¼Œetypåˆ™æ˜¯æ•°ç»„å…ƒç´ çš„å…ƒç±»å‹_type // ä¸¾ä¾‹å¦‚ [5]string æ•°ç»„ï¼Œè¿™é‡Œçš„typå°±æ˜¯[5]stringæ•°ç»„ç±»å‹ï¼Œetypå°±æ˜¯stringç±»å‹ etyp := typ.common() // esizeè¡¨ç¤ºæ•°ç»„å…ƒç´ æ‰€åœ¨å†…å­˜å¤§å°ï¼Œè¿™é‡Œçš„esizeå°±æ˜¯stringç±»å‹çš„å¤§å°16å­—èŠ‚ esize := etyp.Size() // æ ‡è®°æ•°ç»„æ¯”è¾ƒå­—æ®µä¸ºnilï¼Œnilè¡¨ç¤ºå½“å‰ç±»å‹ä¸å¯æ¯”è¾ƒ array.equal = nil // è¿™é‡Œå…ˆæ ‡è®°é»˜è®¤å€¼ // åˆ¤æ–­etyp.equalä¹Ÿå°±æ˜¯æ•°ç»„çš„å…ƒç´ ç±»å‹(string)æ˜¯å¦å¯ä»¥æ¯”è¾ƒï¼Œå¦‚æœè¯¥ç±»å‹ä¸å¯æ¯”è¾ƒåˆ™å½“å‰æ•°ç»„ä¹Ÿä¸å¯æ¯”è¾ƒ if eequal := etyp.equal; eequal != nil { // æ•°ç»„å…ƒç´ å¯ä»¥æ¯”è¾ƒæ—¶ï¼Œåˆå§‹åŒ–æ•°ç»„çš„æ¯”è¾ƒå­—æ®µé—­åŒ…å½¢å¼ // på’Œqåˆ†è¡¨è¡¨ç¤ºéœ€è¦æ¯”è¾ƒçš„ä¸¤ä¸ªæ•°ç»„åœ°å€ array.equal = func(p, q unsafe.Pointer) bool { // array.equalæ•°ç»„çš„æ¯”è¾ƒæ–¹æ³• for i := 0; i \u0026lt; count; i++ { // éå†æ•°ç»„çš„æ‰€æœ‰å…ƒç´ ï¼Œcountè®°å½•æ•°ç»„å…ƒç´ çš„å¤§å° pi := arrayAt(p, i, esize, \u0026#34;i \u0026lt; count\u0026#34;) // arrayAtåç§»åˆ°pçš„æ¯ä¸ªå…ƒç´ ä½ç½®ï¼Œå¾—åˆ°æ•°ç»„å…ƒç´ å€¼ qi := arrayAt(q, i, esize, \u0026#34;i \u0026lt; count\u0026#34;) // arrayAtåç§»åˆ°qçš„æ¯ä¸ªå…ƒç´ ä½ç½®ï¼Œå¾—åˆ°æ•°ç»„å…ƒç´ å€¼ // eequalåˆ™æ˜¯æ•°ç»„å…ƒç´ ç±»å‹çš„æ¯”è¾ƒå‡½æ•°ï¼Œè¿™é‡Œä¸¾ä¾‹æ˜¯stringæ¯”è¾ƒå‡½æ•° if !eequal(pi, qi) { // eequalæ•°ç»„å…ƒç´ ç±»å‹çš„æ¯”è¾ƒæ–¹æ³•ï¼Œæ¯”è¾ƒpiå’Œqi return false // ä¸¤ä¸ªæ•°ç»„ä¸ç›¸ç­‰æ—¶ } } return true // ä¸¤ä¸ªæ•°ç»„ä¸€è‡´æ—¶ } } å€¼æ‹·è´è¡Œä¸ºä¼šé€ æˆæ€§èƒ½é—®é¢˜ï¼Œé€šå¸¸ä¼šå»ºè®®ä½¿ç”¨ sliceï¼Œæˆ–æ•°ç»„æŒ‡é’ˆã€‚ å¤šç»´æ•°ç»„éå† 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 package main import ( \u0026#34;fmt\u0026#34; ) func main() { // äºŒç»´æ•°ç»„ï¼Œ2X3 var f [2][3]int = [...][3]int{{1, 2, 3}, {7, 8, 9}} for k1, v1 := range f { // ã€int, [3]intã€‘ for k2, v2 := range v1 { // ã€int, intã€‘ fmt.Printf(\u0026#34;(%d,%d)=%d \u0026#34;, k1, k2, v2) } fmt.Println() } // Output: // (0,0)=1 (0,1)=2 (0,2)=3 // (1,0)=7 (1,1)=8 (1,2)=9 } æ•°ç»„æ‹·è´å’Œä¼ å‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 package main import \u0026#34;fmt\u0026#34; func printArr(arr *[5]int) { arr[0] = 10 // (*arr)[0] // for i, v := range *arr for i, v := range arr { // ã€int, intã€‘ fmt.Println(i, v) } } func main() { var arr1 [5]int printArr(\u0026amp;arr1) fmt.Println(arr1) arr2 := [...]int{2, 4, 6, 8, 10} printArr(\u0026amp;arr2) fmt.Println(arr2) } /* * 0 10 * 1 0 * 2 0 * 3 0 * 4 0 * [10 0 0 0 0] * 0 10 * 1 4 * 2 6 * 3 8 * 4 10 * [10 4 6 8 10] */ æ±‚æ•°ç»„æ‰€æœ‰å…ƒç´ ä¹‹å’Œ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;math/rand\u0026#34; \u0026#34;time\u0026#34; ) // æ±‚å…ƒç´ å’Œ func sumArr(a *[10]int) int { var sum int = 0 for i := 0; i \u0026lt; len(a); i++ { // è¯­æ³•ç³– len(*a) sum += a[i] // è¯­æ³•ç³– (*a)[i] } //for _, v := range a { //\tsum += v //} return sum } func main() { // è‹¥æƒ³åšä¸€ä¸ªçœŸæ­£çš„éšæœºæ•°ï¼Œä¸€èˆ¬ä½¿ç”¨æ—¶é—´çº³ç§’æ’­ç§éšæœºæ•° // seed()ç§å­é»˜è®¤æ˜¯1ï¼Œrand.Seed(1) rand.Seed(time.Now().UnixNano()) var b [10]int for i := 0; i \u0026lt; len(b); i++ { // äº§ç”Ÿä¸€ä¸ª0åˆ°1000éšæœºæ•° b[i] = rand.Intn(1000) } sum := sumArr(\u0026amp;b) fmt.Printf(\u0026#34;sum=%d\\n\u0026#34;, sum) // Output: // sum=3171 } æ‰¾å‡ºæ•°ç»„ä¸­å’Œä¸ºç»™å®šå€¼çš„ä¸¤ä¸ªå…ƒç´ çš„ä¸‹æ ‡ ä¾‹å¦‚æ•°ç»„[1,3,5,8,7]ï¼Œæ‰¾å‡ºä¸¤ä¸ªå…ƒç´ ä¹‹å’Œç­‰äº8çš„ä¸‹æ ‡åˆ†åˆ«æ˜¯(0, 4)å’Œ(1, 2)ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 package main import \u0026#34;fmt\u0026#34; // æ‰¾å‡ºæ•°ç»„ä¸­å’Œä¸ºç»™å®šå€¼çš„ä¸¤ä¸ªå…ƒç´ çš„ä¸‹æ ‡ï¼Œä¾‹å¦‚æ•°ç»„[1,3,5,8,7]ï¼Œ // æ‰¾å‡ºä¸¤ä¸ªå…ƒç´ ä¹‹å’Œç­‰äº8çš„ä¸‹æ ‡åˆ†åˆ«æ˜¯ï¼ˆ0ï¼Œ4ï¼‰å’Œï¼ˆ1ï¼Œ2ï¼‰ // æ±‚å…ƒç´ å’Œï¼Œæ˜¯ç»™å®šçš„å€¼ func myTest(a []int, target int) { for i := 0; i \u0026lt; len(a); i++ { other := target - a[i] for j := i + 1; j \u0026lt; len(a); j++ { if a[j] == other { fmt.Printf(\u0026#34;(%d,%d)\\n\u0026#34;, i, j) } } } } func main() { b := [5]int{1, 3, 5, 8, 7} // b[:] ä¼šå¼•ç”¨æ•°ç»„bçš„åœ°å€ï¼Œå¦‚æœmyTestå‡½æ•°ä¿®æ”¹å‚æ•°aåˆ™ä¼šå½±å“åˆ°bã€‚ myTest(b[:], 8) } éšæœºæ‰“ä¹±ä¸€ä¸ªæ•°ç»„ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;math/rand\u0026#34; \u0026#34;time\u0026#34; ) func main() { // éšæœºæ‰“ä¹±ä¸€ä¸ªæ•°ç»„ // 1) ç»™ [12]int èµ‹å€¼ var ar [12]int = [12]int{} for i := range \u0026amp;ar { ar[i] = i + 1 } fmt.Println(ar) rand.Seed(time.Now().UnixNano()) // 2) æ‰“ä¹± [12]int n := len(ar) // 12 for i := 1; i \u0026lt; n; i++ { // æ ¹æ®éšæœºæ•°æ‰“ä¹±ar j := rand.Int() % (i+1) ar[i], ar[j] = ar[j], ar[i] } fmt.Println(ar) } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;math/rand\u0026#34; \u0026#34;time\u0026#34; ) func shuffleArray(arr []int) { // è·å–éšæœºæ•°ç§å­ rand.Seed(time.Now().UnixNano()) // éå†æ•°ç»„ï¼Œéšæœºäº¤æ¢å…ƒç´  for i := len(arr) - 1; i \u0026gt; 0; i-- { j := rand.Intn(i + 1) arr[i], arr[j] = arr[j], arr[i] } } func main() { arr := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20} shuffleArray(arr) fmt.Println(arr) } ... çš„ä½¿ç”¨ ç”¨äºæ•°ç»„æ—¶ï¼Œ...åªèƒ½ç”¨åœ¨æœ€å¤–å±‚æ•°ç»„ã€‚ ç”¨äºæ•°ç»„ç”³æ˜çš„æœ€å¤–å±‚æ•°ç»„ï¼Œè‡ªåŠ¨ç»Ÿè®¡æ•°ç»„é•¿åº¦ã€‚ ç”¨ä½œå‡½æ•°çš„æœ€åä¸€ä¸ªå‚æ•°ï¼Œ...Tè¡¨ç¤ºå¯å˜å‚æ•°[]Tåˆ‡ç‰‡å½¢å¼ã€‚ ç”¨ä½œåˆ‡ç‰‡å[]T...è¡¨ç¤ºè§£å¼•ç”¨ã€‚ã€append([]int{1,2}, []int{3,4,5}\u0026hellip;)ã€‘ åªæœ‰åœ¨ã€append([]byte(\u0026ldquo;hello \u0026ldquo;), \u0026ldquo;world\u0026rdquo;\u0026hellip;)ã€‘æ—¶å¯ä»¥ä½¿ç”¨ã€string...ã€‘å½¢å¼å…¶ä»–åœ°æ–¹ä¸è¢«å…è®¸ã€‚ ...ä½œä¸ºè§£å¼•ç”¨æ—¶ï¼Œåªèƒ½ç”¨åœ¨Sliceå’Œstringä¸­ã€‚ append()ç›¸å…³ç”¨æ³•ã€‚ slice = append(slice, elem1, elem2) slice = append(slice, anotherSlice...) slice = append([]byte(\u0026quot;hello \u0026quot;), \u0026quot;world\u0026quot;...) æ³¨æ„ åœ¨Goè¯­è¨€ä¸­åªæœ‰æ•°ç»„å’Œæ•°ç»„æŒ‡é’ˆèƒ½ç›¸äº’æ··ç”¨ï¼Œå…¶ä»–ç±»å‹åˆ™ä¸èƒ½ï¼Œæ¯”å¦‚åˆ‡ç‰‡å’Œåˆ‡ç‰‡æŒ‡é’ˆç­‰ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 { sl := [4]int{1,2,3,4} str3 := \u0026amp;sl // str3[1]ã€range str3ã€len(str3) ç­‰æ“ä½œ _ = str3[1] // (*str3)[1] è¯­æ³•ç³– for range str3 {\t} _ = len(str3) // len(*str3) è¯­æ³•ç³– _ = cap(str3) // cap(*str3) è¯­æ³•ç³– } ","permalink":"https://heliu.site/posts/golang/array/use/","summary":"æ•°ç»„çš„å®šä¹‰åŠåŸºç¡€ä½¿ç”¨ã€‚","title":"æ•°ç»„ä½¿ç”¨"},{"content":" æ•°ç»„åœ¨å†…å­˜ä¸­æ˜¯è¿ç»­åˆ†é…çš„ï¼Œæ•°ç»„çš„å¤§å°ä¿å­˜åœ¨æ•°ç»„ç±»å‹å…ƒæ•°æ®ä¸­çš„ã€‚ [3]int çš„å†…å­˜å¸ƒå±€ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // ç¤ºä¾‹[3]int æ•°ç»„å¸ƒå±€ å†…å­˜ä¸­è¿ç»­åˆ†é… // åœ°å€ 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 // |\u0026lt;---a[0]----\u0026gt;| |\u0026lt;-------a[1]------\u0026gt;| |\u0026lt;--------a[2]------\u0026gt;| a := [3]int{0, 1, 2} // açš„åœ°å€\u0026amp;aä¹Ÿå°±æ˜¯å½“å‰ç¤ºä¾‹çš„0å³å†…å­˜çš„é¦–åœ°å€ // æŸ¥çœ‹açš„å†…å­˜å ç”¨å¤§å° int åœ¨64ä½ç³»ç»Ÿä¸‹å 8å­—èŠ‚ 3*8 = 24å­—èŠ‚ fmt.Println(unsafe.Sizeof(a)) // 24 // æ•°ç»„çš„é•¿åº¦ä¿å­˜åœ¨ç±»å‹å…ƒæ•°æ®ä¸­ type arrayType struct { _type // æ•°ç»„ç±»å‹ç»“æ„ elem *_type // æ•°ç»„å…ƒç´ ç±»å‹ç»“æ„ slice *_type // åˆ‡ç‰‡ç±»å‹ç»“æ„ len uintptr // æ•°ç»„é•¿åº¦ } [3]string çš„å†…å­˜å¸ƒå±€ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 // ç¤ºä¾‹[5]string å­—ç¬¦ä¸²æ•°ç»„å†…å­˜å¸ƒå±€ // å­—ç¬¦ä¸²ç»“æ„æˆ‘ä»¬æ˜¯å¦‚ä¸‹ 64ä½æ“ä½œç³»ç»Ÿä¸‹ // string struct // å­—æ®µ ç±»å‹ å¤§å° ç¤ºä¾‹ // data uintptr 8byte æŒ‡å‘åº•å±‚æ•°ç»„ å¦‚x[0] -\u0026gt; [\u0026#39;h\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;l\u0026#39;, \u0026#39;l\u0026#39;, \u0026#39;o\u0026#39;, \u0026#39;2\u0026#39;, \u0026#39;1\u0026#39;] // len int 8byte è®°å½•å­—ç¬¦çš„é•¿åº¦ å¦‚x[0] 7 // // | // 0 1 ... 6 7 8 9 ... 14 15 16 17 .. 22 23 24 25 ... 30 31 32 33 .. 39 40 41 42 ... å†…å­˜åœ°å€byte // | | | | | | | | | | ... // |x[0].data| | x[0].len | | x[1].data | | x[1].len | | x2[2].data | ... // | 8B | | 8B | | 8B | | 8B | | 8B | ... // // æ•°ç»„çš„é•¿åº¦è®°å½•åœ¨æ•°ç»„çš„ç±»å‹å…ƒæ•°æ®ä¸­ x := [5]string{\u0026#34;hello21\u0026#34;, \u0026#34;word\u0026#34;, \u0026#34;! 1\u0026#34;, \u0026#34;! 2\u0026#34;, \u0026#34;! 3\u0026#34;} // æ•°ç»„xå ç”¨å†…å­˜å¤§å°(å­—èŠ‚) 5*16 fmt.Println(unsafe.Sizeof(x))\t// 80 éªŒè¯[2]stringçš„å†…å­˜å¸ƒå±€ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;unsafe\u0026#34; ) // array2Str ç±» [2]string å†…å­˜ç»“æ„å¸ƒå±€ // å› æ­¤ æ•°ç»„ ç›´æ¥çœ‹æˆç›¸åº”çš„ç»“æ„ä½“ type array2Str struct { a0Data unsafe.Pointer a0Len int a1Data unsafe.Pointer a1Len int } func main() { a := [2]string{\u0026#34;hello\u0026#34;, \u0026#34;world!\u0026#34;} // 16 * 2 = 32 // æŠŠ a çœ‹æˆ array2Str ç»“æ„ä½“ s := **(**[5]byte)(unsafe.Pointer(\u0026amp;a)) // a[0]; array2Str.p1 fmt.Println(string(s[:]), unsafe.Sizeof(a)) // hello 32 // \u0026amp;array2Str.l1 // æŠŠ a çœ‹æˆ array2Str è¿™é‡Œæ¯”è¾ƒå¥½ç†è§£ a0l := (*int)(unsafe.Pointer(uintptr(unsafe.Pointer(\u0026amp;a)) + unsafe.Sizeof(uintptr(0)))) // len(a[0]) //a0l := (*(*[2]int)(unsafe.Pointer(\u0026amp;a)))[1] // 5 fmt.Println(*a0l) // 5 ss := (*array2Str)(unsafe.Pointer(\u0026amp;a)) fmt.Println(*ss) // {4807271 5 4807756 6} } æ•°ç»„çš„æŒ‰å€¼ä¼ å‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;unsafe\u0026#34; ) func main() { a := [2]int{10, 20} // æ•°ç»„aå ç”¨å†…å­˜å¤§å°ï¼š16 fmt.Printf(\u0026#34;æ•°ç»„aå ç”¨å†…å­˜å¤§å°ï¼š%d\\n\u0026#34;, unsafe.Sizeof(a)) fmt.Printf(\u0026#34;æ•°ç»„aåœ°å€ï¼š%p\\n\u0026#34;, \u0026amp;a) x(a) // Output: // æ•°ç»„aå ç”¨å†…å­˜å¤§å°ï¼š16 // æ•°ç»„aåœ°å€ï¼š0xc00000e0b0 // æ•°ç»„aå ç”¨å†…å­˜å¤§å°ï¼š16 // æ•°ç»„aåœ°å€ï¼š0xc00000e0d0 // ä»æ•°ç»„açš„åœ°å€å¯ä»¥çœ‹å‡ºï¼Œmainå‡½æ•°çš„æ ˆåˆ†é…æ˜¯ç»æŒ¨ç€çš„ } func x(a [2]int) { // æ•°ç»„aå ç”¨å†…å­˜å¤§å°ï¼š16 fmt.Printf(\u0026#34;æ•°ç»„aå ç”¨å†…å­˜å¤§å°ï¼š%d\\n\u0026#34;, unsafe.Sizeof(a)) fmt.Printf(\u0026#34;æ•°ç»„aåœ°å€ï¼š%p\u0026#34;, \u0026amp;a) } ","permalink":"https://heliu.site/posts/golang/array/memory/","summary":"Golang æ•°ç»„çš„å†…å­˜å¸ƒå±€ä»‹ç»ã€‚","title":"æ•°ç»„çš„å†…å­˜å¸ƒå±€"},{"content":" Golang çš„å…ƒç±»å‹åœ¨interfaceç« èŠ‚æ‰ä¼šä»‹ç»ï¼Œå¦‚æœä¸ç†Ÿæ‚‰ç•¥è¿‡ã€‚ æ•°ç»„å…ƒç±»å‹ç»“æ„ æ•°ç»„å…ƒç±»å‹ï¼šæ„æˆæ•°ç»„ç±»å‹çš„ç»“æ„ã€‚ï¼ˆæ•°ç»„ç±»å‹å’Œè‡ªå®šä¹‰æ•°ç»„ç±»å‹ï¼‰ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 // æ•°ç»„ç±»å‹ type arrayType struct { _type // æ•°ç»„å…ƒç±»å‹ï¼Œä¹Ÿå°±æ˜¯æ•°ç»„ç±»å‹ç›¸å…³ä¿¡æ¯ elem *_type // æ•°ç»„å…ƒç´ å…ƒç±»å‹ï¼Œæ¯”å¦‚[2]stringä¸­çš„stringç±»å‹ç›¸å…³ä¿¡æ¯ slice *_type // åˆ‡ç‰‡å…ƒç±»å‹ï¼Œä¸ºä»€ä¹ˆæ•°ç»„ç±»å‹ç»“æ„ä¸­æœ‰ä¸€ä¸ªåˆ‡ç‰‡çš„å…ƒç±»å‹ã€‚åœ¨åå°„çš„æ–¹æ³•ä¸­è¢«ç”¨åˆ°ç”¨äºå¿«é€Ÿæ‰¾åˆ°åˆ‡ç‰‡ len uintptr // æ•°ç»„é•¿åº¦ï¼Œæ•°ç»„çš„é•¿åº¦æ˜¯ä¿å­˜åœ¨å…ƒç±»å‹ä¸­çš„ } // è‡ªå®šä¹‰æ•°ç»„ç±»å‹ type u struct { arrayType u uncommonType } // uncommonType æ˜¯è‡ªå®šä¹‰æ–¹æ³•é›† type uncommonType struct { pkgPath int32 // 4B åç§»åˆ°åŒ…åç§°è·¯å¾„ mcount uint16 // 2B æ–¹æ³•æ€»æ•°é‡ xcount uint16 // 2B å¯å¯¼å‡ºæ–¹æ³•æ•°é‡ moff uint32 // 4B åç§»åˆ°é¦–æ–¹æ³•çš„åç§»é‡ï¼Œæ–¹æ³•æ˜¯æŒ‰ç…§æ–¹æ³•åæ­£åºæ’åºçš„ï¼Œå› æ­¤å¯¼å‡ºæ–¹æ³•åœ¨æœ€å‰é¢ _ uint32 // 4B å ä½å†…å­˜è¡¥é½ï¼Œè¡¥é½4Bï¼Œè¯¥uncommonTypeæ­£å¥½æ˜¯16Bæ— è®ºæ˜¯32ä½ä¸‹è¿˜æ˜¯64ä½ä¸‹éƒ½å…¼å®¹ } // æ–¹æ³•ç±»å‹ type method struct { name nameOff // åç§»é‡ æ–¹æ³•å mtyp typeOff // åç§»é‡ æ–¹æ³•ç±»å‹ ifn textOff // åç§»é‡ æ–¹æ³•åœ°å€ ç”¨äºæ¥å£ ç¼–è¯‘å™¨ç”Ÿæˆçš„åŒ…è£…æ–¹æ³• tfn textOff // åç§»é‡ æ–¹æ³•åœ°å€ } æŸ¥çœ‹æ•°ç»„çš„_typeä¿¡æ¯ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;unsafe\u0026#34; ) // sType ä¸è®ºåœ¨32ä½ä¸‹è¿˜æ˜¯64ä½ä¸‹åˆšå¥½æ˜¯8çš„å€æ•°éƒ½å…¼å®¹ type sType struct { size uintptr // å½“å‰ç±»å‹å ç”¨å­—èŠ‚å¤§å°ï¼Œå­—èŠ‚B ptrData uintptr // ç±»å‹ä¸­ä¹Ÿå¯åŒ…å«æŒ‡é’ˆçš„å­—èŠ‚æ•°Bï¼Œåœ¨å½“å‰å¤§å°èŒƒå›´åéƒ½æ˜¯æ ‡é‡æ•°æ® hash uint32 // ç±»å‹å”¯ä¸€å“ˆå¸Œå€¼ï¼Œç”¨äºå¿«é€ŸåŒºåˆ†å…ƒç´ ç±»å‹ tFlag uint8 // è®°å½•ç€å½“å‰ç±»å‹çš„é¢å¤–ä¿¡æ¯ï¼Œæ¯”å¦‚åç§°ã€æ–¹æ³•é›†ã€åç§°*å‰ç¼€ã€åŒ…è·¯å¾„ã€tagæ ‡ç­¾ç­‰ align uint8 // ç±»å‹çš„å¯¹é½é‡ fieldAlign uint8 // ç»“æ„ä½“å­—æ®µçš„å¯¹é½é‡ kind uint8 // ç±»å‹æšä¸¾ï¼Œä¹Ÿå°±æ˜¯å½“å‰ç±»å‹å€¼ equal func(uintptr, uintptr) // ç±»å‹æ¯”è¾ƒå‡½æ•°ï¼Œä¸ä¸ºnilè¡¨ç¤ºå¯æ¯”è¾ƒ gcData *byte // åƒåœ¾å›æ”¶ç›¸å…³ï¼Œè®°å½•å½“å‰ç±»å‹å¼•ç”¨çš„å›æ”¶çŠ¶æ€ç­‰ str int32 // å½“å‰ç±»å‹nameçš„åç§»é‡ï¼Œåˆ°å½“å‰ç±»å‹åç§°è·¯å¾„çš„åç§»é‡ï¼Œä¹Ÿå°±æ˜¯tFlagä¿¡æ¯å¯¹åº”çš„å†…å®¹å¤„ ptrToThis int32 // å½“å‰ç±»å‹çš„æŒ‡é’ˆç±»å‹çš„åç§»é‡ï¼Œä¹Ÿå°±æ˜¯[2]intåç§»åˆ°*[2]intçš„åç§»é‡ } //type AA [2]string func main() { var s = [2]string{\u0026#34;hello\u0026#34;, \u0026#34;world!\u0026#34;} //var s AA = [2]string{\u0026#34;hello\u0026#34;, \u0026#34;world!\u0026#34;} // type eface interface {typ *_type, data uintptr} var ss interface{} = s at := **(**sType)(unsafe.Pointer(\u0026amp;ss)) // main.sType{ // size:0x20, // 2 * 16 = 32 // ptrData:0x18, // 16 + 8 = 3 * 8 = 24ï¼Œåœ¨24å­—èŠ‚åå…¨éƒ¨éƒ½æ˜¯æ ‡é‡æ•°æ® // hash:0xe9e55850, // tFlag:0x2, // 0000 0010 // align:0x8, // fieldAlign:0x8, // kind:0x11, // 16 + 1 = 17 // equal:(func(uintptr, uintptr))(0x45dee0), // å¯æ¯”è¾ƒ // gcData:(*uint8)(0x49d780), // str:5888, // ptrToThis:0 // æ•°ç»„è¯¥å€¼éƒ½ä¸º0 // } fmt.Printf(\u0026#34;%#v\\n\u0026#34;, at) } æŸ¥çœ‹æ•°ç»„å…¨éƒ¨ä¿¡æ¯ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;unsafe\u0026#34; ) type sType struct { size uintptr // å½“å‰ç±»å‹å ç”¨å­—èŠ‚å¤§å° B ptrData uintptr // ç±»å‹ä¸­ä¹Ÿå¯åŒ…å«æŒ‡é’ˆçš„å­—èŠ‚æ•° B åœ¨å½“å‰å¤§å°èŒƒå›´åéƒ½æ˜¯æ ‡é‡æ•°æ® hash uint32 // ç±»å‹å”¯ä¸€å“ˆå¸Œå€¼ tFlag uint8 // è®°å½•ç€å½“å‰ç±»å‹çš„é¢å¤–ä¿¡æ¯ï¼Œæ¯”å¦‚åç§°ã€æ–¹æ³•é›†ã€åç§°*å‰ç¼€ã€åŒ…è·¯å¾„ã€tagæ ‡ç­¾ç­‰ align uint8 // ç±»å‹çš„å¯¹é½é‡ fieldAlign uint8 // ç»“æ„ä½“å­—æ®µçš„å¯¹é½é‡ kind uint8 // ç±»å‹æšä¸¾ equal func(uintptr, uintptr) // ç±»å‹æ¯”è¾ƒå‡½æ•° gcData *byte // åƒåœ¾å›æ”¶ç›¸å…³ str int32 // å½“å‰ç±»å‹nameçš„åç§»é‡ ptrToThis int32 // å½“å‰ç±»å‹çš„æŒ‡é’ˆç±»å‹çš„åç§»é‡ } type arrayType struct { sType elem *sType slice *sType len uintptr } func main() { var s = [2]string{\u0026#34;hello\u0026#34;, \u0026#34;world!\u0026#34;} // type eface interface {typ *_type, data uintptr} var ss interface{} = s at := **(**arrayType)(unsafe.Pointer(\u0026amp;ss)) // main.arrayType{ // sType:main.sType{ // size:0x20, // ptrData:0x18, // hash:0xe9e55850, // tFlag:0x2, // align:0x8, // fieldAlign:0x8, // kind:0x11, // equal:(func(uintptr, uintptr))(0x45dee0), // gcData:(*uint8)(0x49d880), // str:5896, // ptrToThis:0 // }, // elem:(*main.sType)(0x486fa0), // slice:(*main.sType)(0x486120), // len:0x2 // } fmt.Printf(\u0026#34;%#v\\n\u0026#34;, at) fmt.Println(*at.elem) // {16 8 3774831796 7 8 8 24 0x402d20 0x4b4268 3135 21952} fmt.Println(*at.slice) // {24 8 183740627 2 8 8 23 \u0026lt;nil\u0026gt; 0x4b4268 5068 0} } è‡ªå®šä¹‰æ•°ç»„ç±»å‹ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;unsafe\u0026#34; ) type sType struct { size uintptr // å½“å‰ç±»å‹å ç”¨å­—èŠ‚å¤§å° B ptrData uintptr // ç±»å‹ä¸­ä¹Ÿå¯åŒ…å«æŒ‡é’ˆçš„å­—èŠ‚æ•° B åœ¨å½“å‰å¤§å°èŒƒå›´åéƒ½æ˜¯æ ‡é‡æ•°æ® hash uint32 // ç±»å‹å”¯ä¸€å“ˆå¸Œå€¼ tFlag uint8 // è®°å½•ç€å½“å‰ç±»å‹çš„é¢å¤–ä¿¡æ¯ï¼Œæ¯”å¦‚åç§°ã€æ–¹æ³•é›†ã€åç§°*å‰ç¼€ã€åŒ…è·¯å¾„ã€tagæ ‡ç­¾ç­‰ align uint8 // ç±»å‹çš„å¯¹é½é‡ fieldAlign uint8 // ç»“æ„ä½“å­—æ®µçš„å¯¹é½é‡ kind uint8 // ç±»å‹æšä¸¾ equal func(uintptr, uintptr) // ç±»å‹æ¯”è¾ƒå‡½æ•° gcData *byte // åƒåœ¾å›æ”¶ç›¸å…³ str int32 // å½“å‰ç±»å‹nameçš„åç§»é‡ ptrToThis int32 // å½“å‰ç±»å‹çš„æŒ‡é’ˆç±»å‹çš„åç§»é‡ } // æ•°ç»„å…ƒç±»å‹ type arrayType struct { sType elem *sType slice *sType len uintptr } // è‡ªå®šä¹‰æ•°ç»„ç±»å‹ï¼ŒåŒ…å«è‡ªå®šä¹‰æ–¹æ³• type u struct { arrayType uncommonType } // è‡ªå®šä¹‰æ–¹æ³•é›† type uncommonType struct { pkgPath int32 // 4B åç§»åˆ°è¡¨åç§°è·¯å¾„ mCount uint16 // 2B æ€»æ–¹æ³•æ•°é‡ xCount uint16 // 2B å¯å¯¼å‡ºæ–¹æ³•æ•°é‡ mOff uint32 // 4B åç§»åˆ°é¦–æ–¹æ³•çš„åç§»é‡ï¼Œæ–¹æ³•æ˜¯æŒ‰ç…§æ–¹æ³•åæ­£åºæ’åºçš„ï¼Œå› æ­¤å¯¼å‡ºæ–¹æ³•åœ¨æœ€å‰é¢ _ uint32 // 4B å ä½å†…å­˜è¡¥é½ } // AA å®šä¹‰è‡ªå®šä¹‰ç±»å‹ type AA [2]uint8 func (a AA) String() string { return \u0026#34;å¯å¯¼å‡ºæ–¹æ³•\u0026#34; } func (a *AA) setName(i uint8) { a[0] = i // è¿™é‡Œæ˜¯è¯­æ³•ç³– (*a)[0] = 1 } // ptrType represents a pointer type. æŒ‡é’ˆç±»å‹ type ptrType struct { sType elem *sType // pointer element (pointed at) type } type up struct { ptrType uncommonType } func main() { // éªŒè¯è‡ªå®šä¹‰ç±»å‹ var a AA a.setName(12) // AAç±»å‹ var inter any = a // è¯¥ç±»å‹åªå®ç°äº†Stringæ–¹æ³• s := **(**u)(unsafe.Pointer(\u0026amp;inter)) fmt.Printf(\u0026#34;%#v\\n\u0026#34;, s) // *AAç±»å‹ æ˜¯æŒ‡é’ˆç±»å‹ var inter1 any = \u0026amp;a // è¯¥ç±»å‹åªå®ç°äº†setNameæ–¹æ³•,ä½†æ˜¯è¿˜æœ‰ç¼–è¯‘åŒ…è£…çš„*AA String()æ–¹æ³• s1 := **(**up)(unsafe.Pointer(\u0026amp;inter1)) fmt.Printf(\u0026#34;%#v\\n\u0026#34;, s1) } // kind: 0x11 æ˜¯ 17 arrayç±»å‹ // AAç±»å‹ // main.u{ // arrayType:main.arrayType{ // sType:main.sType{ // size:0x2, // ptrData:0x0, // hash:0xeb895ab, // tFlag:0xf, // align:0x1, // fieldAlign:0x1, // kind:0x11, // equal:(func(uintptr, uintptr))(0xb02c40), // gcData:(*uint8)(0xbc8010), // str:4503, // ptrToThis:45344 // }, // elem:(*main.sType)(0xb94e20), // slice:(*main.sType)(0xb93f20), // len:0x2 // }, // uncommonType:main.uncommonType{ // pkgPath:522, // mCount:0x1, // æ–¹æ³•æ€»æ•°1 // xCount:0x1, // mOff:0x10, // _:0x0 // } // } // kind: 0x36 æ˜¯ 54 = 32(ç±»å‹é—´æ¥å­˜åœ¨æ¥å£å€¼ä¸­) + 22(æŒ‡é’ˆç±»å‹) // *AAç±»å‹ // main.up{ // ptrType:main.ptrType{ // sType:main.sType{ // size:0x8, // ptrData:0x8, // hash:0xae85f2d0, // tFlag:0x9, // 1001 // align:0x8, // fieldAlign:0x8, // kind:0x36, // 0x36 = 54 = 32 + 22 // equal:(func(uintptr, uintptr))(0x9f2c80), // gcData:(*uint8)(0xab8330), // str:4512, // ptrToThis:0 // }, // elem:(*main.sType)(0xa88fc0) // }, // uncommonType:main.uncommonType{ // pkgPath:522, // mCount:0x2, // æ–¹æ³•æ€»æ•°2 // xCount:0x1, // mOff:0x10, // _:0x0 // } // } ","permalink":"https://heliu.site/posts/golang/array/meta/","summary":"Golang æ•°ç»„çš„å…ƒç±»å‹ä»‹ç»ã€‚","title":"æ•°ç»„çš„å…ƒç±»å‹"},{"content":" æœ¬ç¯‡æ–‡ç« éƒ½æ˜¯sliceçš„æºç èµ°è¯»ã€‚ æ³¨æ„ï¼šslice ä¸æ˜¯å¹¶å‘å®‰å…¨çš„æ•°æ®ç»“æ„ï¼Œå¤§å®¶åœ¨ä½¿ç”¨æ—¶è¯·åŠ¡å¿…æ³¨æ„å¹¶å‘å®‰å…¨é—®é¢˜ã€‚ type slice struct åˆ‡ç‰‡çš„å†…å­˜å¸ƒå±€ã€‚ arrayï¼šæŒ‡å‘ä¸€ä¸ª[cap]Tå¤§å°çš„æ•°ç»„åœ°å€ã€‚å°±æ˜¯æŒ‡å‘ä¸€ä¸ªcapå®¹é‡å¤§å°çš„æ•°ç»„é¦–åœ°å€ã€‚ lenï¼šè®°å½•åˆ‡ç‰‡å·²å­˜å‚¨å…ƒç´ çš„é•¿åº¦ï¼Œä¹Ÿæ˜¯å¯è®¿é—®çš„æœ€å¤§ä¸‹æ ‡len - 1ã€‚ capï¼šè®°å½•åˆ‡ç‰‡çš„å®¹é‡ï¼Œä¹Ÿå°±æ˜¯å½“å‰åˆ‡ç‰‡å­˜å‚¨çš„æœ€å¤§å…ƒç´ æ•°é‡ï¼ˆæœªæ‰©å®¹å‰ï¼‰ã€‚ type slice struct { array unsafe.Pointer len int cap int } type notInHeapSlice struct notInHeapSliceæ˜¯go:notinheapå†…å­˜æ”¯æŒçš„sliceã€‚ ä¹Ÿå°±æ˜¯è¯¥ç±»å‹çš„å¯¹è±¡ä¸æ˜¯åœ¨å †ä¸­åˆ›å»ºçš„ï¼Œä¹Ÿå°±æ˜¯GCä¸ä¼šæ‰«æï¼Œå¤šç”¨äºå†…å­˜ç®¡ç†æ¨¡å—ä¸­ã€‚ 1 2 3 4 5 6 // A notInHeapSlice is a slice backed by go:notinheap memory. type notInHeapSlice struct { array *notInHeap // æŒ‡å‘ä¸€ä¸ªèµ·å§‹åœ°å€ len int cap int } type notInHeap struct notInHeapæ˜¯ç”±sysAllocæˆ–persistentAllocç­‰åº•å±‚åˆ†é…å™¨åˆ†é…çš„å †å¤–å†…å­˜ã€‚ ä¸€èˆ¬æ¥è¯´ï¼Œæœ€å¥½ä½¿ç”¨æ ‡è®°ä¸ºgo:notinheapçš„çœŸå®ç±»å‹ï¼Œä½†åœ¨æ— æ³•è¿™æ ·åšçš„æƒ…å†µä¸‹(æ¯”å¦‚åœ¨åˆ†é…å™¨ä¸­)ï¼Œå®ƒç”¨ä½œé€šç”¨ç±»å‹ã€‚ TODOï¼šä½¿ç”¨å®ƒä½œä¸ºsysAlloc,persistentAllocç­‰çš„è¿”å›ç±»å‹? 1 2 3 4 5 6 7 8 9 10 11 // notInHeap is off-heap memory allocated by a lower-level allocator // like sysAlloc or persistentAlloc. // // In general, it\u0026#39;s better to use real types marked as go:notinheap, // but this serves as a generic type for situations where that isn\u0026#39;t // possible (like in the allocators). // // TODO: Use this as the return type of sysAlloc, persistentAlloc, etc? // //go:notinheap type notInHeap struct{} add() 1 2 3 4 func (p *notInHeap) add(bytes uintptr) *notInHeap { // p + bytes return (*notInHeap)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + bytes)) } make() makeå†…ç½®å‡½æ•°åˆ†é…å¹¶åˆå§‹åŒ–ä¸€ä¸ªç±»å‹ä¸ºsliceã€mapæˆ–chançš„å¯¹è±¡(only)ã€‚ å’Œnewä¸€æ ·ï¼Œç¬¬ä¸€ä¸ªå‚æ•°æ˜¯ç±»å‹ï¼Œè€Œä¸æ˜¯å€¼ã€‚ä¸newä¸åŒï¼Œmakeçš„è¿”å›å€¼ç±»å‹ä¸å…¶å‚æ•°çš„ç±»å‹ç›¸åŒï¼Œè€Œä¸æ˜¯æŒ‡å‘å‚æ•°çš„æŒ‡é’ˆã€‚ å…·ä½“çš„ç»“æœå–å†³äºç±»å‹ï¼š Sliceï¼š sizeæŒ‡å®šäº†é•¿åº¦ã€‚åˆ‡ç‰‡çš„å®¹é‡ç­‰äºå®ƒçš„é•¿åº¦ã€‚ ä»¥æä¾›ç¬¬äºŒä¸ªæ•´æ•°å‚æ•°æ¥æŒ‡å®šä¸åŒçš„å®¹é‡;å®ƒå¿…é¡»ä¸å°äºé•¿åº¦ã€‚ ä¾‹å¦‚ï¼Œmake([]int, 0, 10)ä¼šåˆ†é…ä¸€ä¸ªé•¿åº¦ä¸º10çš„åº•å±‚æ•°ç»„ï¼Œå¹¶è¿”å›ä¸€ä¸ªé•¿åº¦ä¸º0ã€å®¹é‡ä¸º10çš„åˆ‡ç‰‡ã€‚ Mapï¼šä¸€ä¸ªç©ºçš„mapåˆ†é…äº†è¶³å¤Ÿçš„ç©ºé—´æ¥ä¿å­˜æŒ‡å®šæ•°é‡çš„å…ƒç´ ã€‚åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œå¯ä»¥çœç•¥é•¿åº¦ï¼Œåˆ†é…ä¸€ä¸ªè¾ƒå°çš„èµ·å§‹é•¿åº¦ã€‚ Channelï¼šchannelç¼“å†²åŒºä½¿ç”¨æŒ‡å®šçš„ç¼“å†²åŒºå®¹é‡åˆå§‹åŒ–ã€‚å¦‚æœä¸º0ï¼Œæˆ–è€…sizeè¢«çœç•¥ï¼Œåˆ™channelæ˜¯æ— ç¼“å†²çš„ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 // The make built-in function allocates and initializes an object of type // slice, map, or chan (only). Like new, the first argument is a type, not a // value. Unlike new, make\u0026#39;s return type is the same as the type of its // argument, not a pointer to it. The specification of the result depends on // the type: //\tSlice: The size specifies the length. The capacity of the slice is //\tequal to its length. A second integer argument may be provided to //\tspecify a different capacity; it must be no smaller than the //\tlength. For example, make([]int, 0, 10) allocates an underlying array //\tof size 10 and returns a slice of length 0 and capacity 10 that is //\tbacked by this underlying array. //\tMap: An empty map is allocated with enough space to hold the //\tspecified number of elements. The size may be omitted, in which case //\ta small starting size is allocated. //\tChannel: The channel\u0026#39;s buffer is initialized with the specified //\tbuffer capacity. If zero, or the size is omitted, the channel is //\tunbuffered. func make(t Type, size ...IntegerType) Type makeslice() make([]T *_type, len, cap int) *_typeï¼šè®°å½•ç€åˆ‡ç‰‡å…ƒç´ ç±»å‹ï¼Œæ¯”å¦‚[]stringåˆ‡ç‰‡è¿™é‡Œæ˜¯stringçš„å…ƒç±»å‹ã€‚ lenï¼šåˆ‡ç‰‡çš„é•¿åº¦ï¼Œè¯¥å‚æ•°æ˜¯å¿…ä¼ ã€‚ capï¼šåˆ‡ç‰‡çš„å®¹é‡ï¼Œè¯¥å‚æ•°æ˜¯å¯ä¼ ï¼Œé»˜è®¤ä¼šä¼ lenå¤§å°ã€‚ makeslice()å‡½æ•°æ˜¯åˆ‡ç‰‡ç”³è¯·å†…å­˜çš„make()å‡½æ•°åŸå‹ï¼Œä¸»è¦è´Ÿè´£ç”³è¯·slice.arrayå­—æ®µæŒ‡å‘çš„å†…å­˜å¤§å°ã€‚ é‚£ä¹ˆåˆ‡ç‰‡çš„24å­—èŠ‚å¤§å°å†…å­˜æ˜¯åœ¨ä»€ä¹ˆæ—¶å€™åˆ†é…çš„ï¼Ÿï¼ˆ64ä½ç³»ç»Ÿä¸‹ä¸º24å­—èŠ‚å†…å­˜ï¼Œ32ç³»ç»Ÿä¸‹ä¸º12å­—èŠ‚å†…å­˜ï¼‰ å¯èƒ½åœ¨å‡½æ•°æ ˆä¸Šç›´æ¥åˆ†é…24å­—èŠ‚å¤§å°å†…å­˜ã€‚ ä¹Ÿå¯èƒ½åœ¨å †ä¸Šåˆ†é…24å­—èŠ‚å¤§å°å†…å­˜ã€‚ è°ƒç”¨äº†makeslice()å‡½æ•°ï¼Œå…¶slice.arrayæŒ‡å‘çš„å†…å­˜å—ä¸€å®šæ˜¯åœ¨å †ä¸Šã€‚æ²¡æœ‰è°ƒè¯¥å‡½æ•°æ—¶å¯èƒ½å†…å­˜åˆ†é…åœ¨æ ˆä¸Šã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 func makeslice(et *_type, len, cap int) unsafe.Pointer { // 1ï¼‰åˆ¤æ–­et.size * uintptr(cap)æ˜¯å¦é€ æˆå†…å­˜æº¢å‡º mem, overflow := math.MulUintptr(et.size, uintptr(cap)) // æŒ‰ç…§capè®¡ç®—çš„ // 1. ã€overflow == trueã€‘ï¼šæº¢å‡º // 2. ã€mem \u0026gt; maxAllocã€‘ï¼šè¶…è¿‡æ“ä½œç³»ç»Ÿæœ€å¤§å†…å­˜ // 3. ã€len \u0026lt; 0ã€‘ï¼šé”™è¯¯çš„lenå‚æ•° // 4. ã€len \u0026gt; capã€‘ï¼šé•¿åº¦å¤§äºå®¹é‡ if overflow || mem \u0026gt; maxAlloc || len \u0026lt; 0 || len \u0026gt; cap { // NOTE: Produce a \u0026#39;len out of range\u0026#39; error instead of a // \u0026#39;cap out of range\u0026#39; error when someone does make([]T, bignumber). // \u0026#39;cap out of range\u0026#39; is true too, but since the cap is only being // supplied implicitly, saying len is clearer. // See golang.org/issue/4085. // // å½“æœ‰äºº make([]T, bignumber) æ—¶ï¼Œäº§ç”Ÿä¸€ä¸ª \u0026#39;len out of range\u0026#39; é”™è¯¯è€Œä¸æ˜¯ \u0026#39;cap out of range\u0026#39; é”™è¯¯æç¤º // å½“ \u0026#39;cap out of range\u0026#39; ä¹Ÿæ˜¯å¤ªé•¿äº†ï¼Œç”±äºcapåªæ˜¯éšå¼åœ°æä¾›ï¼Œæ‰€ä»¥è¯´lenæ›´æ¸…æ¥šçš„æç¤ºã€‚ mem, overflow := math.MulUintptr(et.size, uintptr(len))\t// æ ¹æ®lenè®¡ç®— if overflow || mem \u0026gt; maxAlloc || len \u0026lt; 0 { panicmakeslicelen() // painc \u0026#39;len out of range\u0026#39; } panicmakeslicecap() // panic \u0026#39;cap out of range\u0026#39; } // 2ï¼‰å‘æ“ä½œç³»ç»Ÿç”³è¯·memå¤§å°çš„å†…å­˜å—ï¼Œè¿”å›ç”³è¯·åˆ°å†…å­˜å—çš„é¦–åœ°å€ return mallocgc(mem, et, true) } makeslice64() int64ç‰ˆæœ¬ï¼Œå¦‚æœå½“å‰æ˜¯åœ¨32ä½ç³»ç»Ÿä¸­æ—¶ï¼Œintå…¶å®æ˜¯int32å¤§å°ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 func makeslice64(et *_type, len64, cap64 int64) unsafe.Pointer { len := int(len64) // 32ä½ç³»ç»Ÿä¸‹è½¬æ¢ä¼šä¸¢å¤±éƒ¨åˆ†æ•°æ® if int64(len) != len64 { panicmakeslicelen() // painc \u0026#39;len out of range\u0026#39; } cap := int(cap64) if int64(cap) != cap64 { panicmakeslicecap() // panic \u0026#39;cap out of range\u0026#39; } return makeslice(et, len, cap) } len() ä»¥ä¸‹ä¼ªä»£ç è·å–åˆ‡ç‰‡çš„é•¿åº¦ã€‚ lenå‡½æ•°çš„åŸå‹ï¼šfunc len(array []T) intã€‚ 1 2 3 4 // ä¼ªä»£ç ç¤ºä¾‹ func len(array []T) int { return array.len } cap() ä»¥ä¸‹ä¼ªä»£ç è·å–åˆ‡ç‰‡çš„å®¹é‡ã€‚ capå‡½æ•°çš„åŸå‹ï¼šfunc cap(array []T) intã€‚ 1 2 3 4 // ä¼ªä»£ç ç¤ºä¾‹ func cap(array []T) int { return array.cap } copy() copyå†…ç½®å‡½æ•°å°†å…ƒç´ ä»æºç‰‡å¤åˆ¶åˆ°ç›®æ ‡ç‰‡ã€‚(ä½œä¸ºç‰¹æ®Šæƒ…å†µï¼Œå®ƒä¹Ÿä¼šå°†bytesä»stringå¤åˆ¶åˆ°byteåˆ‡ç‰‡ã€‚) æºå’Œç›®æ ‡å¯èƒ½é‡å ã€‚ copyè¿”å›å¤åˆ¶çš„å…ƒç´ æ•°é‡ï¼Œè¿™å°†æ˜¯len(src)å’Œlen(dst)çš„æœ€å°å€¼ã€‚src-\u0026gt;dstã€‚ 1 2 3 4 5 6 // The copy built-in function copies elements from a source slice into a // destination slice. (As a special case, it also will copy bytes from a // string to a slice of bytes.) The source and destination may overlap. Copy // returns the number of elements copied, which will be the minimum of // len(src) and len(dst). func copy(dst, src []Type) int slicecopy() slicecopyç”¨äºå°†pointerlesså…ƒç´ çš„å­—ç¬¦ä¸²æˆ–åˆ‡ç‰‡å¤åˆ¶åˆ°åˆ‡ç‰‡ä¸­ã€‚ æ³¨æ„ï¼šcopy()çš„å‡½æ•°åŸå‹ä¸­æ²¡æœ‰å¯å˜å‚æ•°ï¼ˆ... Tï¼‰çš„å½¢å¼å‚æ•°ã€‚ slicecopy é€‚ç”¨ä»¥ä¸‹ä¸¤ç§æƒ…å†µï¼šfm -\u0026gt; to ã€copy(to, fm []T) intã€‘ ã€copy(to []byte, fm string) intã€‘ æ³¨æ„ä»¥ä¸‹slicecopyå‡½æ•°å¯èƒ½åœ¨go1.18+ç‰ˆæœ¬ä¸­ä¸æ˜¯è¿™æ ·çš„ï¼Œè¿™ä¸€ç‰ˆé‡‡ç”¨çš„æ˜¯go1.22å·¦å³ç‰ˆæœ¬çš„æºç ï¼Œä½†æ˜¯åªæ˜¯å‘ç”Ÿäº†å˜åŒ–å…·ä½“é€»è¾‘æ²¡å˜ã€‚ å‚æ•°ï¼šfromPtr -\u0026gt; toPtr toPtr unsafe.Pointerï¼šç›®æ ‡åœ°å€ï¼Œä¹Ÿå°±æ˜¯ä¸Šé¢çš„to.arrayå€¼ã€‚ toLen intï¼šç›®æ ‡é•¿åº¦ï¼Œä¹Ÿå°±æ˜¯ä¸Šé¢çš„to.lenå€¼ã€‚ fromPtr unsafe.Pointerï¼šæ¥æºåœ°å€ï¼Œä¹Ÿå°±æ˜¯ä¸Šé¢çš„fm.arrayå€¼ã€‚ fromLen intï¼šæ¥æºé•¿åº¦ï¼Œä¹Ÿå°±æ˜¯ä¸Šé¢çš„fm.lenå€¼ã€‚ width uintptrï¼šåˆ‡ç‰‡ç±»å‹å ç”¨å†…å­˜å¤§å°ï¼Œä¹Ÿå°±æ˜¯[]Tçš„Tç±»å‹çš„å¤§å°ã€‚ è¿”å›å€¼ï¼š intï¼šæ‹·è´çš„å…ƒç´ æ•°é‡ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 // slicecopy is used to copy from a string or slice of pointerless elements into a slice. func slicecopy(toPtr unsafe.Pointer, toLen int, fromPtr unsafe.Pointer, fromLen int, width uintptr) int { // 1) æ‹·è´æˆ–è¢«æ‹·è´é•¿åº¦ä¸º0ç›´æ¥è¿”å› if fromLen == 0 || toLen == 0 { return 0 } // 2) æ‹·è´å…ƒç´ çš„ä¸ªæ•°å–å†³äºæ‹·è´æˆ–è¢«æ‹·è´çš„æœ€å°é•¿åº¦ n := fromLen if toLen \u0026lt; n { n = toLen } // 3) æ‹·è´çš„å…ƒç´ å¤§å°ä¸º0ï¼Œç›´æ¥è¿”å›n if width == 0 {\t// []struct{} return n } // 4) size éœ€è¦æ‹·è´çš„æ€»å†…å­˜å¤§å°/å­—èŠ‚ã€‚ size := uintptr(n) * width if raceenabled { callerpc := getcallerpc() pc := abi.FuncPCABIInternal(slicecopy) racereadrangepc(fromPtr, size, callerpc, pc) racewriterangepc(toPtr, size, callerpc, pc) } if msanenabled { msanread(fromPtr, size) msanwrite(toPtr, size) } if asanenabled { asanread(fromPtr, size) asanwrite(toPtr, size) } // ä¸€èˆ¬æƒ…å†µä¸‹ï¼Œè¿™é‡Œçš„å€¼å¤§çº¦æ˜¯2xï¼ˆåªæœ‰1å­—èŠ‚éœ€è¦æ‹·è´ï¼‰ // to := make([]byte, 1); copy(to, \u0026#34;hello\u0026#34;) // ã€[]byteã€‘ OR ã€[]uint8ã€‘ OR ã€[]int8ã€‘ OR ã€[]boolã€‘ if size == 1 { // common case worth about 2x to do here // TODO: is this still worth it with new memmove impl? // // TODO: ä½¿ç”¨æ–°çš„memmove implï¼Œè¿™ä»ç„¶å€¼å¾—å—? // å·²çŸ¥fromPtrå’ŒtoPtræ˜¯ byte æŒ‡é’ˆ *(*byte)(toPtr) = *(*byte)(fromPtr) // known to be a byte pointer } else { memmove(toPtr, fromPtr, size) // æ‹·è´æ•°æ® } return n } memmove() memmoveä»fromå¤åˆ¶nä¸ªå­—èŠ‚åˆ°toã€‚ memmoveç¡®ä¿ä»»ä½•ä½äºfromä¸­çš„æŒ‡é’ˆéƒ½ä»¥ä¸å¯åˆ†å‰²çš„å†™å…¥æ–¹å¼å†™å…¥åˆ°toä¸­ï¼Œå› æ­¤ï¼ŒåŠ¨æ€è¯»å–æ— æ³•è§‚å¯Ÿåˆ°ä¸€ä¸ªåªå†™äº†ä¸€åŠçš„æŒ‡é’ˆã€‚ è¿™æ˜¯å¿…è¦çš„ï¼Œä»¥é˜²æ­¢åƒåœ¾æ”¶é›†å™¨å‘ç°æ— æ•ˆæŒ‡é’ˆï¼Œè¿™ä¸éæ‰˜ç®¡è¯­è¨€ä¸­çš„memmoveä¸åŒã€‚ ä¸è¿‡ï¼Œåªæœ‰å½“fromå’Œtoå¯èƒ½åŒ…å«æŒ‡é’ˆæ—¶ï¼Œmemmove()æ‰éœ€è¦è¿™ä¹ˆåšï¼Œåªæœ‰å½“fromã€toå’Œnéƒ½æ˜¯ word-alignedæ—¶æ‰ä¼šè¿™æ ·åšã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 // memmove copies n bytes from \u0026#34;from\u0026#34; to \u0026#34;to\u0026#34;. // // memmove ensures that any pointer in \u0026#34;from\u0026#34; is written to \u0026#34;to\u0026#34; with // an indivisible write, so that racy reads cannot observe a // half-written pointer. This is necessary to prevent the garbage // collector from observing invalid pointers, and differs from memmove // in unmanaged languages. However, memmove is only required to do // this if \u0026#34;from\u0026#34; and \u0026#34;to\u0026#34; may contain pointers, which can only be the // case if \u0026#34;from\u0026#34;, \u0026#34;to\u0026#34;, and \u0026#34;n\u0026#34; are all be word-aligned. // // Implementations are in memmove_*.s. // //go:noescape func memmove(to, from unsafe.Pointer, n uintptr) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 TEXT runtimeÂ·memmove\u0026lt;ABIInternal\u0026gt;(SB), NOSPLIT, $0-24 // AX = to // BX = from // CX = n MOVQ AX, DI MOVQ BX, SI MOVQ CX, BX tail: // TESTæŒ‡ä»¤ç”¨äºå¯¹BXå¯„å­˜å™¨çš„å†…å®¹å’Œè‡ªèº«è¿›è¡ŒæŒ‰ä½ä¸æ“ä½œï¼Œä½†æ˜¯ä¸æ”¹å˜å¯„å­˜å™¨çš„å†…å®¹ã€‚ TESTQ BX, BX # æ£€æŸ¥BXæ˜¯å¦ä¸º0 // æ£€æŸ¥ä¸Šä¸€æ¡æŒ‡ä»¤ï¼ˆTESTï¼‰æ‰§è¡Œåæ˜¯å¦è®¾ç½®äº†é›¶æ ‡å¿—ï¼ˆZFï¼‰ JEQ move_0 # Jump if Equal // è¿™æ˜¯ä¸€ä¸ªæ¯”è¾ƒæŒ‡ä»¤ï¼Œç”¨äºæ¯”è¾ƒBXå¯„å­˜å™¨ä¸­çš„å€¼å’Œç«‹å³æ•°2ã€‚ // å…·ä½“æ¥è¯´ï¼Œå®ƒä¼šå°†BXå¯„å­˜å™¨çš„å€¼å’Œ2ç›¸å‡ï¼Œä½†ä¸æ”¹å˜ä»»ä½•å¯„å­˜å™¨çš„å€¼ï¼Œåªæ˜¯æ ¹æ®ç»“æœè®¾ç½®çŠ¶æ€æ ‡å¿—ã€‚ CMPQ BX, $2 // BX \u0026lt;= 2 æˆç«‹ JBE move_1or2 # Jump if Below or Equal CMPQ BX, $4 # \u0026lt;= 4 JB move_3 JBE move_4 CMPQ BX, $8 # \u0026lt;= 8 JB move_5through7 JE move_8 CMPQ BX, $16 JBE move_9through16 CMPQ BX, $32 JBE move_17through32 CMPQ BX, $64 JBE move_33through64 CMPQ BX, $128 JBE move_65through128 CMPQ BX, $256 JBE move_129through256 TESTB $1, runtimeÂ·useAVXmemmove(SB) JNZ avxUnaligned //... ... append() å†…ç½®å‡½æ•°append()å°†å…ƒç´ æ·»åŠ åˆ°åˆ‡ç‰‡çš„æœ«å°¾ã€‚ å¦‚æœå®ƒæœ‰è¶³å¤Ÿçš„å®¹é‡ï¼Œç›®çš„åœ°å°†è¢«é‡æ–°åˆ’åˆ†ä»¥å®¹çº³æ–°çš„å…ƒç´ ã€‚å¦‚æœæ²¡æœ‰ï¼Œå°†åˆ†é…ä¸€ä¸ªæ–°çš„åº•å±‚æ•°ç»„ã€‚ æ³¨æ„ï¼šappend()å‡½æ•°å­˜åœ¨å¯å˜å‚æ•°ï¼ˆ... Tï¼‰çš„å½¢å¼çš„å‚æ•°ã€‚ append()è¿”å›æ›´æ–°åçš„sliceã€‚å› æ­¤ï¼Œæœ‰å¿…è¦å°†append()çš„ç»“æœå­˜å‚¨åœ¨ä¿å­˜åˆ‡ç‰‡æœ¬èº«çš„å˜é‡ä¸­ï¼š ã€slice = append(slice, elem1, elem2)ã€‘ ã€slice = append(slice, anotherSlice...)ã€‘ ä½œä¸ºä¸€ç§ç‰¹æ®Šæƒ…å†µï¼Œå¯ä»¥å°†å­—ç¬¦ä¸²æ·»åŠ åˆ°å­—èŠ‚åˆ‡ç‰‡ä¸­ï¼Œå¦‚ä¸‹æ‰€ç¤ºï¼š ã€slice = append([]byte(\u0026quot;hello \u0026quot;), \u0026quot;world\u0026quot;...)ã€‘ 1 2 3 4 5 6 7 8 9 10 11 12 13 // The append built-in function appends elements to the end of a slice. If // it has sufficient capacity, the destination is resliced to accommodate the // new elements. If it does not, a new underlying array will be allocated. // Append returns the updated slice. It is therefore necessary to store the // result of append, often in the variable holding the slice itself: // //\tslice = append(slice, elem1, elem2) //\tslice = append(slice, anotherSlice...) // // As a special case, it is legal to append a string to a byte slice, like this: // //\tslice = append([]byte(\u0026#34;hello \u0026#34;), \u0026#34;world\u0026#34;...) func append(slice []Type, elems ...Type) []Type append æ‰§è¡Œæ­¥éª¤ï¼š å¦‚æœå½“å‰append()å‡½æ•°æ‰§è¡Œå®Œååˆ‡ç‰‡ä¸ä¼š\u0026ldquo;ç¿»å€æ‰©å®¹\u0026quot;é‚£ä¹ˆï¼Œç›´æ¥æ˜¯æŠŠappend()åè¿½åŠ çš„æ•°æ®æ‹·è´åˆ°åˆ‡ç‰‡çš„åç»­ç©ºé—´å³å¯ã€‚ å¦‚æœå½“å‰append()å‡½æ•°æ‰§è¡Œå®Œåéœ€è¦\u0026ldquo;ç¿»å€æ‰©å®¹\u0026rdquo;ï¼Œé‚£ä¹ˆå…ˆè°ƒç”¨runtime.growslice()æ‰©å®¹å‡½æ•°ï¼Œç„¶ååœ¨æ‹·è´æ•°æ®è¿½åŠ åˆ°æ–°çš„å†…å­˜ç©ºé—´ã€‚ growslice() growslice()åœ¨append()å‡½æ•°æœŸé—´å¤„ç†åˆ‡ç‰‡å¢é•¿ã€‚ å®ƒå°†sliceå…ƒç´ ç±»å‹ã€æ—§çš„sliceå’Œæ‰€éœ€çš„æ–°æœ€å°å®¹é‡ä¼ é€’ç»™å®ƒï¼Œç„¶åè¿”å›ä¸€ä¸ªè‡³å°‘å…·æœ‰è¯¥å®¹é‡çš„æ–°sliceï¼Œå¹¶å°†æ—§æ•°æ®å¤åˆ¶åˆ°å…¶ä¸­ã€‚ æ–°sliceçš„é•¿åº¦è¢«è®¾ç½®ä¸ºæ—§sliceçš„é•¿åº¦ï¼Œè€Œä¸æ˜¯æ–°è¯·æ±‚çš„å®¹é‡ã€‚ è¿™æ˜¯ä¸ºäº†æ–¹ä¾¿codegenã€‚æ—§ç‰‡çš„é•¿åº¦ç«‹å³ç”¨äºè®¡ç®—åœ¨è¿½åŠ æœŸé—´åœ¨ä½•å¤„å†™å…¥æ–°å€¼ã€‚ TODOï¼šå½“æ—§çš„åç«¯æ¶ˆå¤±æ—¶ï¼Œé‡æ–°è€ƒè™‘è¿™ä¸ªå†³å®šã€‚ SSAåç«¯å¯èƒ½æ›´å–œæ¬¢æ–°çš„é•¿åº¦ï¼Œæˆ–è€…åªè¿”å›ptr/capä»¥èŠ‚çœæ ˆç©ºé—´ã€‚ å‚æ•°ï¼š et *_typeï¼šåˆ‡ç‰‡å…ƒç´ çš„å…ƒç±»å‹ã€‚ old sliceï¼šæœªç¿»å€æ‰©å®¹å‰åˆ‡ç‰‡ã€‚ cap intï¼šappend()å‡½æ•°åéœ€è¦çš„é•¿åº¦ old.len + n = capã€‚ä¹Ÿå°±æ˜¯append(s S, x ...T) Så‡½æ•°ä¸­len(S) + len(x) = capåçš„é•¿åº¦ã€‚ è¿”å›å€¼ï¼šslice slice.dataï¼šæ–°ç”³è¯·çš„åœ°å€ã€‚ slice.lenï¼šold.lençš„å€¼ã€‚æ³¨æ„è¿™é‡Œæ˜¯æ—§åˆ‡ç‰‡çš„é•¿åº¦ã€‚ slice.capï¼šæ‰©å®¹åçš„å®¹é‡ã€‚ è¯¥å‡½æ•°åœ¨append()å‡½æ•°è°ƒç”¨æ—¶æ ¹æ®æ¡ä»¶è§¦å‘ã€‚å¦‚old = append(old, 1, 2, 1), len(old) + 3 \u0026gt; cap(old)æ—¶å°±éœ€è¦æ‰©å®¹äº†ã€‚ æ³¨æ„ï¼Œå…³äºsliceçš„æ‰©å®¹è§„åˆ™åœ¨go1.18å‰æ˜¯æ ¹æ®lençš„ä¸€å¥—è§„åˆ™ï¼Œè€Œåœ¨ä»¥åç‰ˆæœ¬åˆæ˜¯æ ¹æ®capçš„ä¸€å¥—è§„åˆ™ï¼Œæœ¬ç¯‡é‡‡ç”¨çš„æ˜¯go1.22å·¦å³ç‰ˆæœ¬çš„ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 // growslice handles slice growth during append. // It is passed the slice element type, the old slice, and the desired new minimum capacity, // and it returns a new slice with at least that capacity, with the old data // copied into it. // The new slice\u0026#39;s length is set to the old slice\u0026#39;s length, // NOT to the new requested capacity. // This is for codegen convenience. The old slice\u0026#39;s length is used immediately // to calculate where to write new values during an append. // TODO: When the old backend is gone, reconsider this decision. // The SSA backend might prefer the new length or to return only ptr/cap and save stack space. func growslice(et *_type, old slice, cap int) slice { if raceenabled { callerpc := getcallerpc() racereadrangepc(old.array, uintptr(old.len*int(et.size)), callerpc, abi.FuncPCABIInternal(growslice)) } if msanenabled { msanread(old.array, uintptr(old.len*int(et.size))) } if asanenabled { asanread(old.array, uintptr(old.len*int(et.size))) } // 1) åˆ‡ç‰‡é•¿åº¦æº¢å‡ºåˆ¤æ–­ if cap \u0026lt; old.cap { panic(errorString(\u0026#34;growslice: cap out of range\u0026#34;)) } // 2) åˆ‡ç‰‡å…ƒç´ ç±»å‹ å ç”¨å†…å­˜ä¸ºé›¶ æƒ…å†µ // è¿™ç§æƒ…å†µå‡ºç°åœ¨ï¼š // var s []struct{} // s = append(s, struct{}{}, struct{}{}) if et.size == 0 { // append should not create a slice with nil pointer but non-zero len. // We assume that append doesn\u0026#39;t need to preserve old.array in this case. // // Appendä¸åº”è¯¥åˆ›å»ºä¸€ä¸ªæŒ‡é’ˆä¸ºnilçš„åˆ‡ç‰‡ï¼Œè€Œæ˜¯ä¸€ä¸ªlenä¸ºnon-zeroçš„åˆ‡ç‰‡ã€‚ // åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œæˆ‘ä»¬å‡è®¾appendä¸éœ€è¦ä¿å­˜old.arrayã€‚ // èµ‹å€¼slice.arrayæŒ‡å®šåœ°å€ï¼Œä¸ºäº†ç¡®ä¿sliceä¸æ˜¯nil // sliceä¸ºnilçš„åˆ¤æ–­æ¡ä»¶æ˜¯ï¼Œåªè¦slice.array==0x00,ä¸ç®¡lenå’Œcapçš„å€¼ä¸ºå¤šå°‘éƒ½ä¸ºnil return slice{unsafe.Pointer(\u0026amp;zerobase), old.len, cap} } // 3) è¯„ä¼°æ‰©å®¹åçš„å®¹é‡ // ---+-------+----------------------------------------------------------------------------------- // é¢„ | if | oldCap * 2 \u0026lt; cap ------\u0026gt; newCap = cap ä½¿ç”¨capå€¼ // ä¼° |-------+----------------------------------------------------------------------------------- // è§„ | else | oldCap \u0026lt; 256 ------\u0026gt; newCap = oldCap * 2 ç¿»å€æ‰©å®¹ // åˆ™ | | oldCap \u0026gt;= 256 ------\u0026gt; newCap = oldCap * 5/4 + 256 * 3/4 åœ¨åŸå®¹é‡ä¸Šæ‰©å®¹1/4åœ¨æ‰©å®¹192 // ---+-------+----------------------------------------------------------------------------------- newcap := old.cap doublecap := newcap + newcap if cap \u0026gt; doublecap { // 2å€æ—§å®¹é‡ \u0026lt; capæ—¶ï¼Œåˆ™æŒ‰ç…§capç®—ã€‚ newcap = cap } else { const threshold = 256 if old.cap \u0026lt; threshold { newcap = doublecap } else { // Check 0 \u0026lt; newcap to detect overflow // and prevent an infinite loop. // // æ£€æŸ¥ 0 \u0026lt; newcap ä»¥æ£€æµ‹æº¢å‡ºå¹¶é˜²æ­¢æ— é™å¾ªç¯ã€‚ for 0 \u0026lt; newcap \u0026amp;\u0026amp; newcap \u0026lt; cap { // Transition from growing 2x for small slices // to growing 1.25x for large slices. This formula // gives a smooth-ish transition between the two. newcap += (newcap + 3*threshold) / 4 } // Set newcap to the requested cap when // the newcap calculation overflowed. if newcap \u0026lt;= 0 { newcap = cap } } } // 4) å†…å­˜è§„æ ¼åŒ¹é… // å†…å­˜æ˜¯å¦æº¢å‡º true.æº¢å‡º false.æ²¡æœ‰æº¢å‡º var overflow bool\t// lenmem æ—§åˆ‡ç‰‡å…ƒç´ å ç”¨çš„å†…å­˜å¤§å° // è¯¥å€¼ç”¨äºè¿ç§»æ—§æ•°æ®çš„ä¾æ®/å­—èŠ‚ // newlenmem ç¿»å€ååˆ‡ç‰‡å…ƒç´ å ç”¨çš„å†…å­˜å¤§å° // è¯¥å€¼æ˜¯å½“å‰æ‰©å®¹åå®é™…å ç”¨çš„å¤§å°/å­—èŠ‚ // å› æ­¤capmem-newlenmemè¿™éƒ¨åˆ†å†…å­˜æ˜¯å¤šä½™çš„ï¼Œä¸ä¼šè¢«ç”¨åˆ°ã€‚ // capmem ç¿»å€åæ–°å®¹é‡å ç”¨çš„å†…å­˜å¤§å°ï¼Œ // ç”¨äºå‘æ“ä½œç³»ç»Ÿç”³è¯·çš„å†…å­˜å¤§å°/å­—èŠ‚ // è¿™éƒ¨åˆ†å†…å­˜å¯èƒ½å¤§äºnewlenmemçš„å€¼ï¼Œå› ä¸ºGoçš„å†…å­˜ç”³è¯·æ˜¯æœ‰è§„æ ¼çš„ã€‚ var lenmem, newlenmem, capmem uintptr // Specialize for common values of et.size. // For 1 we don\u0026#39;t need any division/multiplication. // For goarch.PtrSize, compiler will optimize division/multiplication into a shift by a constant. // For powers of 2, use a variable shift. // // ä¸“é—¨ç”¨äº et.size çš„å…±åŒå€¼ã€‚ // å¯¹äº1ï¼Œæˆ‘ä»¬ä¸éœ€è¦ä»»ä½•é™¤æ³•/ä¹˜æ³• // å¯¹äº goarch.PtrSizeï¼Œç¼–è¯‘å™¨å°†é™¤æ³•/ä¹˜æ³• ä¼˜åŒ–ä¸ºä¸€ä¸ªå¸¸é‡çš„ä½ç§» // å¯¹äº2çš„å¹‚æ¬¡æ–¹ï¼Œä½¿ç”¨å¯å˜ä½ç§» switch { // å€˜è‹¥æ•°ç»„å…ƒç´ çš„å¤§å°ä¸º 1ï¼Œåˆ™æ–°å®¹é‡å¤§å°ä¸º 1 * newcap. // åŒæ—¶ä¼šé’ˆå¯¹ span class è¿›è¡Œå–æ•´ case et.size == 1: // 1å­—èŠ‚ lenmem = uintptr(old.len) newlenmem = uintptr(cap) capmem = roundupsize(uintptr(newcap)) // åŒ¹é…æœ€è¿‘æ¥çš„å†…å­˜å—è§„æ ¼ overflow = uintptr(newcap) \u0026gt; maxAlloc // æ˜¯å¦å†…å­˜æº¢å‡º newcap = int(capmem) // ä»æ–°è°ƒæ•´ç¿»å€åæ–°å®¹é‡ // å€˜è‹¥æ•°ç»„å…ƒç´ ä¸ºæŒ‡é’ˆç±»å‹ï¼Œåˆ™æ ¹æ®æŒ‡é’ˆå ç”¨ç©ºé—´ç»“åˆå…ƒç´ ä¸ªæ•°è®¡ç®—ç©ºé—´å¤§å° // å¹¶ä¼šé’ˆå¯¹ span class è¿›è¡Œå–æ•´ case et.size == goarch.PtrSize: // 4æˆ–8å­—èŠ‚ lenmem = uintptr(old.len) * goarch.PtrSize newlenmem = uintptr(cap) * goarch.PtrSize capmem = roundupsize(uintptr(newcap) * goarch.PtrSize) overflow = uintptr(newcap) \u0026gt; maxAlloc/goarch.PtrSize newcap = int(capmem / goarch.PtrSize) // å€˜è‹¥å…ƒç´ å¤§å°ä¸º 2 çš„æŒ‡æ•°ï¼Œåˆ™ç›´æ¥é€šè¿‡ä½è¿ç®—è¿›è¡Œç©ºé—´å¤§å°çš„è®¡ç®— case isPowerOfTwo(et.size): // 2çš„å¹‚æ¬¡æ–¹ var shift uintptr if goarch.PtrSize == 8 { // Mask shift for better code generation. // // æ©ç ç§»ä½ä»¥æ›´å¥½åœ°ç”Ÿæˆä»£ç ã€‚ // sys.Ctz64å‡½æ•°è®¡æ•°å°¾éƒ¨(ä½é˜¶)é›¶ï¼Œå¦‚æœå…¨éƒ¨ä¸ºé›¶ï¼Œåˆ™ä¸º64ã€‚ // æ¯”å¦‚ et.size æ˜¯2^8ä¹Ÿå°±æ˜¯ 1_0000_0000ï¼Œä¹Ÿå°±æ˜¯8ä¸ªé›¶ shift = uintptr(sys.Ctz64(uint64(et.size))) \u0026amp; 63 // 64ä½ } else { shift = uintptr(sys.Ctz32(uint32(et.size))) \u0026amp; 31 // 32ä½ } lenmem = uintptr(old.len) \u0026lt;\u0026lt; shift newlenmem = uintptr(cap) \u0026lt;\u0026lt; shift capmem = roundupsize(uintptr(newcap) \u0026lt;\u0026lt; shift) overflow = uintptr(newcap) \u0026gt; (maxAlloc \u0026gt;\u0026gt; shift) newcap = int(capmem \u0026gt;\u0026gt; shift) // å…œåº•åˆ†æ”¯ï¼šæ ¹æ®å…ƒç´ å¤§å°ä¹˜ä»¥å…ƒç´ ä¸ªæ•° // å†é’ˆå¯¹ span class è¿›è¡Œå–æ•´ default: lenmem = uintptr(old.len) * et.size newlenmem = uintptr(cap) * et.size // math.MulUintptr è¿”å› capmem = et.size * uintptr(newcap); overflow æ˜¯å¦æº¢å‡º capmem, overflow = math.MulUintptr(et.size, uintptr(newcap)) capmem = roundupsize(capmem) newcap = int(capmem / et.size) } // ä»¥ä¸Šä»£ç å› ä¸ºä¼šå»åŒ¹é…å†…å­˜è§„æ ¼ï¼Œæ‰€ä»¥ä¼šä»æ–°è®¡ç®—newcapè¿™ä¸ªç¿»å€åçš„å€¼ // The check of overflow in addition to capmem \u0026gt; maxAlloc is needed // to prevent an overflow which can be used to trigger a segfault // on 32bit architectures with this example program: // // é™¤äº†capmem \u0026gt; maxAllocä¹‹å¤–ï¼Œè¿˜éœ€è¦æ£€æŸ¥æº¢å‡ºï¼Œä»¥é˜²æ­¢æº¢å‡ºï¼Œ // è¯¥æº¢å‡ºå¯ç”¨äºåœ¨32ä½ä½“ç³»ç»“æ„ä¸Šè§¦å‘æ®µæ•…éšœï¼Œç¤ºä¾‹ç¨‹åºå¦‚ä¸‹: // // type T [1\u0026lt;\u0026lt;27 + 1]int64 // // var d T // var s []T // // func main() { // s = append(s, d, d, d, d)\t// print(len(s), \u0026#34;\\n\u0026#34;) // } // 4*(1\u0026lt;\u0026lt;27 + 1)*8 if overflow || capmem \u0026gt; maxAlloc { panic(errorString(\u0026#34;growslice: cap out of range\u0026#34;)) } // ç”³è¯·åˆ°çš„å†…å­˜é¦–åœ°å€ var p unsafe.Pointer if et.ptrdata == 0 { // åˆ‡ç‰‡å…ƒç´ ç±»å‹ä¸åŒ…å«æŒ‡é’ˆ // capmem ç”³è¯·çš„å†…å­˜; nil ç±»å‹å…ƒç±»å‹ç”¨äºåˆ¤æ–­æ˜¯å¦ä¸ºæŒ‡é’ˆç±»å‹; false æ˜¯å¦é‡ç½®å†…å­˜ä¸ºé›¶å€¼; p = mallocgc(capmem, nil, false) // å‘æ“ä½œç³»ç»Ÿç”³è¯·å†…å­˜å— // The append() that calls growslice is going to overwrite from // old.len to cap (which will be the new length). // Only clear the part that will not be overwritten. // // è°ƒç”¨ growslice çš„ append() æ–¹æ³•ä¼šå°† old.len è¦†ç›–åˆ° cap(è¿™å°†æ˜¯æ–°çš„é•¿åº¦)ã€‚ // åªæ¸…é™¤ä¸ä¼šè¢«è¦†ç›–çš„éƒ¨åˆ†ã€‚ // æ¸…é›¶capmem-newlenmemè¿™å—å†…å­˜ï¼Œè¿™å¿«å†…å­˜æ˜¯å¤šä½™çš„ï¼Œä¸ä¼šè¢«ç”¨åˆ°ã€‚ memclrNoHeapPointers(add(p, newlenmem), capmem-newlenmem)\t} else { // åˆ‡ç‰‡å…ƒç´ ç±»å‹åŒ…å«æŒ‡é’ˆ // Note: can\u0026#39;t use rawmem (which avoids zeroing of memory), // because then GC can scan uninitialized memory. // // Note: ä¸èƒ½ä½¿ç”¨rawmem(å®ƒå¯ä»¥é¿å…å†…å­˜å½’é›¶)ï¼Œå› ä¸ºè¿™æ ·GCä¼šæ‰«ææœªåˆå§‹åŒ–çš„å†…å­˜ã€‚ p = mallocgc(capmem, et, true) // å‘æ“ä½œç³»ç»Ÿç”³è¯·å†…å­˜å— if lenmem \u0026gt; 0 \u0026amp;\u0026amp; writeBarrier.enabled { // å¼€å¯äº†å†™å±éšœ // Only shade the pointers in old.array since we know the destination slice p // only contains nil pointers because it has been cleared during alloc. // // åœ¨ old.array ä¸­åªå¯¹æŒ‡é’ˆè¿›è¡Œ shade å¤„ç†ï¼Œå› ä¸ºæˆ‘ä»¬çŸ¥é“ç›®æ ‡åˆ‡ç‰‡ p åªåŒ…å«nilæŒ‡é’ˆï¼Œ // å› ä¸ºå®ƒåœ¨allocæœŸé—´å·²è¢«æ¸…é™¤ã€‚ // lenmem-et.size+et.ptrdata åˆšå¥½æ˜¯old.arrayå­˜åœ¨çš„éƒ½æ˜¯æŒ‡é’ˆ // -et.sizeï¼šå‡å»æœ€åä¸€ä¸ªå…ƒç´ çš„å†…å­˜ // +et.ptrdataï¼šå†åŠ ä¸Šæœ€åä¸€ä¸ªå…ƒç´ çš„æŒ‡é’ˆ // åˆšå¥½å¤„ç†å®Œæœ€åä¸€ä¸ªå…ƒç´ åé¢ä¸æ˜¯æŒ‡é’ˆçš„éƒ¨åˆ†å†…å­˜ã€‚ // [dst, dst+size] bulkBarrierPreWriteSrcOnly(uintptr(p), uintptr(old.array), lenmem-et.size+et.ptrdata)\t} } // ä»old.arrayä¸­è¿ç§»lenmemå¤§å°å†…å­˜æ•°æ®åˆ°pä¸­ memmove(p, old.array, lenmem) // æ³¨æ„ï¼šè¿™é‡Œè¿”å›çš„æ˜¯ old.lenï¼Œå› ä¸ºæ­¤æ—¶è¿˜æ˜¯ä¹‹å‰çš„æ—§æ•°æ® return slice{p, old.len, newcap} } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 // bulkBarrierPreWriteSrcOnly is like bulkBarrierPreWrite but // does not execute write barriers for [dst, dst+size). // // In addition to the requirements of bulkBarrierPreWrite // callers need to ensure [dst, dst+size) is zeroed. // // This is used for special cases where e.g. dst was just // created and zeroed with malloc. // // The type of the space can be provided purely as an optimization, // however it is not used with GOEXPERIMENT=noallocheaders. // //go:nosplit func bulkBarrierPreWriteSrcOnly(dst, src, size uintptr, _ *abi.Type) { // GCå¹¶å‘æ ‡è®°é˜¶æ®µï¼Œè¿™é‡Œéœ€è¦å¤„ç†æ··åˆå†™å±éšœç›¸å…³äº‹é¡¹ï¼Œå› ä¸ºåœ¨æ‹·è´æŒ‡é’ˆæ•°æ® if (dst|src|size)\u0026amp;(goarch.PtrSize-1) != 0 { throw(\u0026#34;bulkBarrierPreWrite: unaligned arguments\u0026#34;) } if !writeBarrier.enabled { return // å¹¶å‘æ ‡è®°å·²ç»“æŸ } buf := \u0026amp;getg().m.p.ptr().wbBuf // å†™å±éšœç¼“å†²åŒº h := heapBitsForAddr(dst, size) for { var addr uintptr if h, addr = h.next(); addr == 0 { break } srcx := (*uintptr)(unsafe.Pointer(addr - dst + src)) p := buf.get1() p[0] = *srcx } } æ‰€æœ‰0å­—èŠ‚åˆ†é…çš„åŸºåœ°å€ã€‚ 1 2 // base address for all 0-byte allocations var zerobase uintptr roundupsize() mallocgcè¿”å›å°†åˆ†é…çš„å†…å­˜å—çš„å¤§å°ï¼Œå¦‚æœæ‚¨è¦æ±‚è¯¥å¤§å°ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // Returns size of the memory block that mallocgc will allocate if you ask for the size. func roundupsize(size uintptr) uintptr { // _MaxSmallSize = 32768 if size \u0026lt; _MaxSmallSize { // smallSizeMax = 1024 if size \u0026lt;= smallSizeMax-8 { // ä»¥æœ€ä¸‹8Bå€æ•°å¯¹é½ // smallSizeDiv = 8ï¼ŒdivRoundUp ç­‰ä»·äº ceil(size/8) // size_to_class8å’Œclass_to_size è®°å½•ç€ size çš„æ˜ å°„å…³ç³» return uintptr(class_to_size[size_to_class8[divRoundUp(size, smallSizeDiv)]]) } else { // ä»¥æœ€å°128Bå€æ•°å¯¹é½ // largeSizeDiv = 128 return uintptr(class_to_size[size_to_class128[divRoundUp(size-smallSizeMax, largeSizeDiv)]]) } } // _PageSize = 8192 if size+_PageSize \u0026lt; size { return size } return alignUp(size, _PageSize) // å¯¹é½8KB } alignUp() alignUpå°†nå–æ•´ä¸ºaçš„å€æ•°ã€‚aå¿…é¡»æ˜¯2çš„å¹‚ã€‚ 1 2 3 4 // alignUp rounds n up to a multiple of a. a must be a power of 2. func alignUp(n, a uintptr) uintptr { return (n + a - 1) \u0026amp;^ (a - 1) } MulUintptr() MulUintptrè¿”å›a * bä»¥åŠä¹˜æ³•è¿ç®—æ˜¯å¦æº¢å‡ºã€‚ åœ¨å—æ”¯æŒçš„å¹³å°ä¸Šï¼Œè¿™æ˜¯ç”±ç¼–è¯‘å™¨é™ä½çš„å›ºæœ‰ç‰¹æ€§ã€‚ 1 2 3 4 5 6 7 8 9 10 11 // MulUintptr returns a * b and whether the multiplication overflowed. // On supported platforms this is an intrinsic lowered by the compiler. func MulUintptr(a, b uintptr) (uintptr, bool) { // a|b \u0026lt; 1\u0026lt;\u0026lt;16 || a|b \u0026lt; 1\u0026lt;\u0026lt;32 if a|b \u0026lt; 1\u0026lt;\u0026lt;(4*goarch.PtrSize) || a == 0 { return a * b, false } // const MaxUintptr = ^uintptr(0) overflow := b \u0026gt; MaxUintptr/a return a * b, overflow } ","permalink":"https://heliu.site/posts/golang/slice/theory/","summary":"sliceçš„å†…å­˜ç»“æ„ã€makeã€copyã€appendå‡½æ•°åŠæ‰©å®¹ä»‹ç»ã€‚","title":"Slice(åŸç†)"},{"content":"ä»€ä¹ˆæ˜¯è¾¹ç•Œæ£€æŸ¥ è¾¹ç•Œæ£€æŸ¥ï¼Œè‹±æ–‡åBounds Check Eliminationï¼Œç®€ç§°ä¸º BCEã€‚ å®ƒæ˜¯Goè¯­è¨€ä¸­é˜²æ­¢æ•°ç»„ã€åˆ‡ç‰‡è¶Šç•Œè€Œå¯¼è‡´å†…å­˜ä¸å®‰å…¨çš„æ£€æŸ¥æ‰‹æ®µã€‚å¦‚æœæ£€æŸ¥ä¸‹æ ‡å·²ç»è¶Šç•Œäº†ï¼Œå°±ä¼šäº§ç”ŸPanicã€‚ è¾¹ç•Œæ£€æŸ¥ä½¿å¾—æˆ‘ä»¬çš„ä»£ç èƒ½å¤Ÿå®‰å…¨åœ°è¿è¡Œï¼Œä½†æ˜¯å¦ä¸€æ–¹é¢ï¼Œä¹Ÿä½¿å¾—æˆ‘ä»¬çš„ä»£ç è¿è¡Œæ•ˆç‡ç•¥å¾®é™ä½ã€‚ æ¯”å¦‚ä¸‹é¢è¿™æ®µä»£ç ï¼Œä¼šè¿›è¡Œä¸‰æ¬¡çš„è¾¹ç•Œæ£€æŸ¥ã€‚ 1 2 3 4 5 6 7 8 9 package main func f(s []int) { _ = s[0] // æ£€æŸ¥ç¬¬ä¸€æ¬¡ _ = s[1] // æ£€æŸ¥ç¬¬äºŒæ¬¡ _ = s[2] // æ£€æŸ¥ç¬¬ä¸‰æ¬¡ } func main() {} ä½ å¯èƒ½ä¼šå¥½å¥‡äº†ï¼Œä¸‰æ¬¡ï¼Ÿæˆ‘æ˜¯æ€ä¹ˆçŸ¥é“å®ƒè¦æ£€æŸ¥ä¸‰æ¬¡çš„ã€‚ å®é™…ä¸Šï¼Œä½ åªè¦åœ¨ç¼–è¯‘çš„æ—¶å€™ï¼ŒåŠ ä¸Šå‚æ•°-gcflags=\u0026quot;-d=ssa/check_bce/debug=1\u0026quot;å³å¯ï¼Œå‘½ä»¤å¦‚ä¸‹ï¼š 1 2 3 4 5 $ go build -gcflags=\u0026#34;-d=ssa/check_bce/debug=1\u0026#34; main.go # command-line-arguments ./main.go:4:7: Found IsInBounds ./main.go:5:7: Found IsInBounds ./main.go:6:7: Found IsInBounds è¾¹ç•Œæ£€æŸ¥çš„æ¡ä»¶ å¹¶ä¸æ˜¯æ‰€æœ‰çš„å¯¹æ•°ç»„ã€åˆ‡ç‰‡è¿›è¡Œç´¢å¼•æ“ä½œéƒ½éœ€è¦è¾¹ç•Œæ£€æŸ¥ã€‚ æ¯”å¦‚ä¸‹é¢è¿™ä¸ªç¤ºä¾‹ï¼Œå°±ä¸éœ€è¦è¿›è¡Œè¾¹ç•Œæ£€æŸ¥ï¼Œå› ä¸ºç¼–è¯‘å™¨æ ¹æ®ä¸Šä¸‹æ–‡å·²ç»å¾—çŸ¥ï¼Œsè¿™ä¸ªåˆ‡ç‰‡çš„é•¿åº¦æ˜¯å¤šå°‘ï¼Œä½ çš„ç»ˆæ­¢ç´¢å¼•æ˜¯å¤šå°‘ï¼Œç«‹é©¬å°±èƒ½åˆ¤æ–­åˆ°åº•æœ‰æ²¡æœ‰è¶Šç•Œï¼Œå› æ­¤æ˜¯ä¸éœ€è¦å†è¿›è¡Œè¾¹ç•Œæ£€æŸ¥ï¼Œå› ä¸ºåœ¨ç¼–è¯‘çš„æ—¶å€™å°±å·²ç»çŸ¥é“è¿™ä¸ªåœ°æ–¹ä¼šä¸ä¼š panicã€‚ 1 2 3 4 5 6 7 8 9 package main func f() { s := []int{1,2,3,4} // panic: runtime error: slice bounds out of range [:9] with capacity 4 _ = s[:9] // ä¸éœ€è¦è¾¹ç•Œæ£€æŸ¥ } func main() {} å› æ­¤å¯ä»¥å¾—å‡ºç»“è®ºï¼Œå¯¹äºåœ¨ç¼–è¯‘é˜¶æ®µæ— æ³•åˆ¤æ–­æ˜¯å¦ä¼šè¶Šç•Œçš„ç´¢å¼•æ“ä½œæ‰ä¼šéœ€è¦è¾¹ç•Œæ£€æŸ¥ï¼Œæ¯”å¦‚è¿™æ ·å­ï¼š 1 2 3 4 5 6 7 package main func f(s []int) { _ = s[:9] // éœ€è¦è¾¹ç•Œæ£€æŸ¥ } func main() {} è¾¹ç•Œæ£€æŸ¥çš„ç‰¹æ®Šæ¡ˆä¾‹ æ¡ˆä¾‹ä¸€ åœ¨å¦‚ä¸‹ç¤ºä¾‹ä»£ç ä¸­ï¼Œç”±äºç´¢å¼•2åœ¨æœ€å‰é¢å·²ç»æ£€æŸ¥è¿‡ä¼šä¸ä¼šè¶Šç•Œï¼Œå› æ­¤èªæ˜çš„ç¼–è¯‘å™¨å¯ä»¥æ¨æ–­å‡ºåé¢çš„ç´¢å¼•0å’Œ1ä¸ç”¨å†æ£€æŸ¥ã€‚ 1 2 3 4 5 6 7 8 9 package main func f(s []int) { _ = s[2] // æ£€æŸ¥ä¸€æ¬¡ _ = s[1] // ä¸ä¼šæ£€æŸ¥ _ = s[0] // ä¸ä¼šæ£€æŸ¥ } func main() {} æ¡ˆä¾‹äºŒ åœ¨ä¸‹é¢è¿™ä¸ªç¤ºä¾‹ä¸­ï¼Œå¯ä»¥åœ¨é€»è¾‘ä¸Šä¿è¯ä¸ä¼šè¶Šç•Œçš„ä»£ç ï¼ŒåŒæ ·æ˜¯ä¸ä¼šè¿›è¡Œè¶Šç•Œæ£€æŸ¥çš„ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 package main // [low:high:max] // len = high - low // cap = max - low // s =\u0026gt; len = 10, cap = 20 func f(s []int) { for index, _ := range s { // ä»¥ä¸‹æ“ä½œéƒ½æ˜¯åœ¨æœ‰æ•ˆçš„ç´¢å¼•èŒƒå›´ _ = s[index] _ = s[:index+1] // index [0,9] _ = s[index:len(s)] // len(s) = 10 } } func main() {} æ¡ˆä¾‹ä¸‰ åœ¨å¦‚ä¸‹ç¤ºä¾‹ä»£ç ä¸­ï¼Œè™½ç„¶æ•°ç»„çš„é•¿åº¦å’Œå®¹é‡å¯ä»¥ç¡®å®šï¼Œä½†æ˜¯ç´¢å¼•æ˜¯é€šè¿‡rand.Intn()å‡½æ•°å–å¾—çš„éšæœºæ•°ï¼Œåœ¨ç¼–è¯‘å™¨çœ‹æ¥è¿™ä¸ªç´¢å¼•å€¼æ˜¯ä¸ç¡®å®šçš„ï¼Œå®ƒæœ‰å¯èƒ½å¤§äºæ•°ç»„çš„é•¿åº¦ï¼Œä¹Ÿæœ‰å¯èƒ½å°äºæ•°ç»„çš„é•¿åº¦ã€‚ å› æ­¤ç¬¬ä¸€æ¬¡æ˜¯éœ€è¦è¿›è¡Œæ£€æŸ¥çš„ï¼Œæœ‰äº†ç¬¬ä¸€æ¬¡æ£€æŸ¥åï¼Œç¬¬äºŒæ¬¡ç´¢å¼•ä»é€»è¾‘ä¸Šå°±èƒ½æ¨æ–­ï¼Œæ‰€ä»¥ä¸ä¼šå†è¿›è¡Œè¾¹ç•Œæ£€æŸ¥ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 package main import ( \u0026#34;math/rand\u0026#34; ) func f() { s := make([]int, 3, 5) index := rand.Intn(3) // [0,1,2,3] _ = s[:index] // ç¬¬ä¸€æ¬¡æ£€æŸ¥ _ = s[index:] // ç¬¬äºŒæ¬¡æ£€æŸ¥ } func main() {} æˆ‘ä»¬åªæœ‰å½“æ•°ç»„çš„é•¿åº¦å’Œå®¹é‡ç›¸ç­‰æ—¶ï¼Œ:indexæˆç«‹ï¼Œæ‰èƒ½ä¸€å®šèƒ½æ¨å‡ºindex:ä¹Ÿæˆç«‹ï¼Œè¿™æ ·çš„è¯ï¼Œåªè¦åšä¸€æ¬¡æ£€æŸ¥å³å¯ã€‚ ä¸€æ—¦æ•°ç»„çš„é•¿åº¦å’Œå®¹é‡ä¸ç›¸ç­‰ï¼Œé‚£ä¹ˆindexåœ¨ç¼–è¯‘å™¨çœ‹æ¥æ˜¯æœ‰å¯èƒ½å¤§äºæ•°ç»„é•¿åº¦çš„ï¼Œç”šè‡³å¤§äºæ•°ç»„çš„å®¹é‡ã€‚ æˆ‘ä»¬å‡è®¾indexå–å¾—çš„éšæœºæ•°ä¸º4ï¼Œé‚£ä¹ˆå®ƒå¤§äºæ•°ç»„é•¿åº¦ï¼Œæ­¤æ—¶s[:index]è™½ç„¶å¯ä»¥æˆåŠŸï¼Œä½†æ˜¯s[index:]æ˜¯è¦å¤±è´¥çš„ï¼Œå› æ­¤ç¬¬äºŒæ¬¡è¾¹ç•Œçš„æ£€æŸ¥æ˜¯æœ‰å¿…è¦çš„ã€‚ ä½ å¯èƒ½ä¼šè¯´ï¼Œindexä¸æ˜¯æœ€å¤§å€¼ä¸º3å—ï¼Ÿæ€ä¹ˆå¯èƒ½æ˜¯4å‘¢ï¼Ÿè¦çŸ¥é“ç¼–è¯‘å™¨åœ¨ç¼–è¯‘çš„æ—¶å€™ï¼Œå¹¶ä¸çŸ¥é“indexçš„æœ€å¤§å€¼æ˜¯3å‘¢ã€‚ æ€»ç»“ï¼š å½“æ•°ç»„çš„é•¿åº¦å’Œå®¹é‡ç›¸ç­‰æ—¶ï¼Œs[:index]æˆç«‹èƒ½å¤Ÿä¿è¯s[index:]ä¹Ÿæˆç«‹ï¼Œå› ä¸ºåªè¦æ£€æŸ¥ä¸€æ¬¡å³å¯ã€‚ å½“æ•°ç»„çš„é•¿åº¦å’Œå®¹é‡ä¸ç­‰æ—¶ï¼Œs[:index]æˆç«‹ä¸èƒ½ä¿è¯s[index:]ä¹Ÿæˆç«‹ï¼Œå› ä¸ºè¦æ£€æŸ¥ä¸¤æ¬¡æ‰å¯ä»¥ã€‚ æ¡ˆä¾‹å›› ç”±äºæ•°ç»„æ˜¯è°ƒç”¨è€…ä¼ å…¥çš„å‚æ•°ï¼Œæ‰€ä»¥ç¼–è¯‘å™¨ç¼–è¯‘çš„æ—¶å€™æ— æ³•å¾—çŸ¥æ•°ç»„çš„é•¿åº¦å’Œå®¹é‡æ˜¯å¦ç›¸ç­‰ï¼Œå› æ­¤åªèƒ½ä¿é™©ä¸€ç‚¹ï¼Œä¸¤ä¸ªéƒ½æ£€æŸ¥ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 package main import ( \u0026#34;math/rand\u0026#34; ) func f(s []int, index int) { _ = s[:index] // ç¬¬ä¸€æ¬¡æ£€æŸ¥ _ = s[index:] // ç¬¬äºŒæ¬¡æ£€æŸ¥ } func main() {} ä½†æ˜¯å¦‚æœæŠŠä¸¤ä¸ªè¡¨è¾¾å¼çš„é¡ºåºåè¿‡æ¥ï¼Œå°±åªè¦åšä¸€æ¬¡æ£€æŸ¥å°±è¡Œäº†ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 package main import ( \u0026#34;math/rand\u0026#34; ) func f(s []int, index int) { _ = s[index:] // ç¬¬ä¸€æ¬¡æ£€æŸ¥ _ = s[:index] // ä¸ç”¨æ£€æŸ¥ } func main() {} ä¸»åŠ¨æ¶ˆé™¤è¾¹ç•Œæ£€æŸ¥ è™½ç„¶ç¼–è¯‘å™¨å·²ç»éå¸¸åŠªåŠ›å»æ¶ˆé™¤ä¸€äº›åº”è¯¥æ¶ˆé™¤çš„è¾¹ç•Œæ£€æŸ¥ï¼Œä½†éš¾å…ä¼šæœ‰ä¸€äº›é—æ¼ã€‚ è¿™å°±éœ€è¦â€è­¦æ°‘åˆä½œâ€ï¼Œå¯¹äºé‚£äº›ç¼–è¯‘å™¨è¿˜æœªè€ƒè™‘åˆ°çš„åœºæ™¯ï¼Œä½†å¼€å‘è€…åˆæåŠ›è¿½æ±‚ç¨‹åºçš„è¿è¡Œæ•ˆç‡çš„ï¼Œå¯ä»¥ä½¿ç”¨ä¸€äº›å°æŠ€å·§ç»™å‡ºä¸€äº›æš—ç¤ºï¼Œå‘Šè¯‰ç¼–è¯‘å™¨å“ªäº›åœ°æ–¹å¯ä»¥ä¸ç”¨åšè¾¹ç•Œæ£€æŸ¥ã€‚ æ¯”å¦‚ä¸‹é¢è¿™ä¸ªç¤ºä¾‹ï¼Œä»ä»£ç çš„é€»è¾‘ä¸Šæ¥è¯´ï¼Œæ˜¯å®Œå…¨æ²¡æœ‰å¿…è¦åšè¾¹ç•Œæ£€æŸ¥çš„ï¼Œä½†æ˜¯ç¼–è¯‘å™¨å¹¶æ²¡æœ‰é‚£ä¹ˆæ™ºèƒ½ï¼Œå®é™…ä¸Šæ¯ä¸ªforå¾ªç¯ï¼Œå®ƒéƒ½è¦åšä¸€æ¬¡è¾¹ç•Œçš„æ£€æŸ¥ï¼Œéå¸¸çš„æµªè´¹æ€§èƒ½ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 package main func f0(is []int, bs []byte) { if len(is) \u0026gt;= 256 { //is=is[:256] for _, n := range bs { // æ¯ä¸ªå¾ªç¯éƒ½è¦è¾¹ç•Œæ£€æŸ¥ï¼Œ // å› ä¸ºç¼–è¯‘å™¨å¹¶ä¸çŸ¥é“is[n]è¿™é‡Œçš„isçš„é•¿åº¦æ˜¯å¦ä¼šè¶…è¿‡byteå¤§å° _ = is[n] } } } func main() {} 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 TEXT main.f0(SB) /mnt/hgfs/g/hello1/struct.go func f0(is []int, bs []byte) { 0x4552e0 4883ec50 SUBQ $0x50, SP 0x4552e4 48896c2448 MOVQ BP, 0x48(SP) 0x4552e9 488d6c2448 LEAQ 0x48(SP), BP 0x4552ee 4889442458 MOVQ AX, 0x58(SP) # is.data 0x4552f3 48895c2460 MOVQ BX, 0x60(SP) # is.len 0x4552f8 48894c2468 MOVQ CX, 0x68(SP) # is.cap 0x4552fd 48897c2470 MOVQ DI, 0x70(SP) # bs.data 0x455302 4889742478 MOVQ SI, 0x78(SP) # bs.len 0x455307 4c89842480000000 MOVQ R8, 0x80(SP) # bs.cap if len(is) \u0026gt;= 256 { 0x45530f 48895c2428 MOVQ BX, 0x28(SP) # BX=is.len 0x455314 4881fb00010000 CMPQ $0x100, BX # is.len ä¸ 256æ¯”è¾ƒ 0x45531b 7d02 JGE 0x45531f 0x45531d eb36 JMP 0x455355 for _, n := range bs { 0x45531f 488b542470 MOVQ 0x70(SP), DX # DX=bs.data 0x455324 488b5c2478 MOVQ 0x78(SP), BX # BX=bs.len 0x455329 488bb42480000000 MOVQ 0x80(SP), SI # SI=bs.cap 0x455331 4889542430 MOVQ DX, 0x30(SP) 0x455336 48895c2438 MOVQ BX, 0x38(SP) 0x45533b 4889742440 MOVQ SI, 0x40(SP) 0x455340 48c744242000000000 MOVQ $0x0, 0x20(SP) 0x455349 488b542438 MOVQ 0x38(SP), DX\t# DX=bs.len 0x45534e 4889542418 MOVQ DX, 0x18(SP) 0x455353 eb0c JMP 0x455361 } 0x455355 eb00 JMP 0x455357 0x455357 488b6c2448 MOVQ 0x48(SP), BP 0x45535c 4883c450 ADDQ $0x50, SP 0x455360 c3 RET for _, n := range bs { 0x455361 488b542420 MOVQ 0x20(SP), DX # DX=0 0x455366 4839542418 CMPQ DX, 0x18(SP) # DX ä¸ bs.len å¾ªç¯åˆ¤æ–­æ¡ä»¶ 0x45536b 7f02 JG 0x45536f 0x45536d eb2e JMP 0x45539d 0x45536f 488b542430 MOVQ 0x30(SP), DX 0x455374 4803542420 ADDQ 0x20(SP), DX 0x455379 0fb602 MOVZX 0(DX), AX 0x45537c 88442417 MOVB AL, 0x17(SP) _ = is[n] 0x455380 488b4c2460 MOVQ 0x60(SP), CX 0x455385 4839c1 CMPQ AX, CX # è¶Šç•Œåˆ¤æ–­ 0x455388 7702 JA 0x45538c 0x45538a eb13 JMP 0x45539f 0x45538c eb00 JMP 0x45538e for _, n := range bs { 0x45538e 488b542420 MOVQ 0x20(SP), DX 0x455393 48ffc2 INCQ DX 0x455396 4889542420 MOVQ DX, 0x20(SP) 0x45539b ebc4 JMP 0x455361 } 0x45539d ebb8 JMP 0x455357 _ = is[n] 0x45539f 90 NOPL 0x4553a0 e81bd3ffff CALL runtime.panicIndex(SB) 0x4553a5 90 NOPL å¯ä»¥è¯•ç€åœ¨forå¾ªç¯å‰åŠ ä¸Šè¿™ä¹ˆä¸€å¥is = is[:256]æ¥å‘Šè¯‰ç¼–è¯‘å™¨æ–°isçš„é•¿åº¦ä¸º256ï¼Œæœ€å¤§ç´¢å¼•å€¼ä¸º255ï¼Œä¸ä¼šè¶…è¿‡byteçš„æœ€å¤§å€¼ï¼Œå› ä¸ºis[n]ä»é€»è¾‘ä¸Šæ¥è¯´æ˜¯ä¸€å®šä¸ä¼šè¶Šç•Œçš„ã€‚ 1 2 3 4 5 6 7 8 9 10 11 package main func f00(is []int, bs []byte) { if len(is) \u0026gt;= 256 { is = is[:256] for _, n := range bs { _ = is[n] // ä¸éœ€è¦åšè¾¹ç•Œæ£€æŸ¥ } } } func main() {} 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 TEXT main.f00(SB) /mnt/hgfs/g/hello1/t1.go func f00(is []int, bs []byte) { 0x4552e0 4883ec50 SUBQ $0x50, SP 0x4552e4 48896c2448 MOVQ BP, 0x48(SP) 0x4552e9 488d6c2448 LEAQ 0x48(SP), BP 0x4552ee 4889442458 MOVQ AX, 0x58(SP) 0x4552f3 48895c2460 MOVQ BX, 0x60(SP) 0x4552f8 48894c2468 MOVQ CX, 0x68(SP) 0x4552fd 48897c2470 MOVQ DI, 0x70(SP) 0x455302 4889742478 MOVQ SI, 0x78(SP) 0x455307 4c89842480000000 MOVQ R8, 0x80(SP) if len(is) \u0026gt;= 256 { 0x45530f 48895c2428 MOVQ BX, 0x28(SP) 0x455314 4881fb00010000 CMPQ $0x100, BX # 256 ä¸ is.len æ¯”è¾ƒ 0x45531b 7d02 JGE 0x45531f 0x45531d eb54 JMP 0x455373 is = is[:256] // æ¶ˆé™¤è¾¹ç•Œæ£€æŸ¥ 0x45531f 488b542468 MOVQ 0x68(SP), DX # DX=is.cap 0x455324 4881fa00010000 CMPQ $0x100, DX # 256 ä¸ is.cap æ¯”è¾ƒ 0x45532b 7305 JAE 0x455332 0x45532d e993000000 JMP 0x4553c5 0x455332 eb00 JMP 0x455334 0x455334 48c744246000010000 MOVQ $0x100, 0x60(SP) # is.len=256 for _, n := range bs { 0x45533d 488b542470 MOVQ 0x70(SP), DX # DX=bs.data 0x455342 488b5c2478 MOVQ 0x78(SP), BX # BX=bs.len 0x455347 488bb42480000000 MOVQ 0x80(SP), SI # SI=bs.cap 0x45534f 4889542430 MOVQ DX, 0x30(SP) 0x455354 48895c2438 MOVQ BX, 0x38(SP) 0x455359 4889742440 MOVQ SI, 0x40(SP) 0x45535e 48c744242000000000 MOVQ $0x0, 0x20(SP) 0x455367 488b542438 MOVQ 0x38(SP), DX # DX=bs.len 0x45536c 4889542418 MOVQ DX, 0x18(SP) 0x455371 eb0c JMP 0x45537f } 0x455373 eb00 JMP 0x455375 0x455375 488b6c2448 MOVQ 0x48(SP), BP 0x45537a 4883c450 ADDQ $0x50, SP 0x45537e c3 RET for _, n := range bs { 0x45537f 488b542420 MOVQ 0x20(SP), DX # DX=0 0x455384 4839542418 CMPQ DX, 0x18(SP) # 0 ä¸ bs.len æ¯”è¾ƒ 0x455389 7f02 JG 0x45538d 0x45538b eb2e JMP 0x4553bb 0x45538d 488b542430 MOVQ 0x30(SP), DX # DX=bs.data 0x455392 4803542420 ADDQ 0x20(SP), DX # DX=0+DX 0x455397 0fb602 MOVZX 0(DX), AX # AX=*bs.data 0x45539a 88442417 MOVB AL, 0x17(SP) _ = is[n] 0x45539e 488b4c2460 MOVQ 0x60(SP), CX # CX=256 0x4553a3 4839c1 CMPQ AX, CX # è¶Šç•Œåˆ¤æ–­ 0x4553a6 7702 JA 0x4553aa 0x4553a8 eb13 JMP 0x4553bd 0x4553aa eb00 JMP 0x4553ac for _, n := range bs { 0x4553ac 488b542420 MOVQ 0x20(SP), DX 0x4553b1 48ffc2 INCQ DX 0x4553b4 4889542420 MOVQ DX, 0x20(SP) 0x4553b9 ebc4 JMP 0x45537f } 0x4553bb ebb8 JMP 0x455375 _ = is[n] 0x4553bd 0f1f00 NOPL 0(AX) 0x4553c0 e8fbd2ffff CALL runtime.panicIndex(SB) is = is[:256] // æ¶ˆé™¤è¾¹ç•Œæ£€æŸ¥ 0x4553c5 b900010000 MOVL $0x100, CX 0x4553ca e871d3ffff CALL runtime.panicSliceAcap(SB) 0x4553cf 90 NOPL ","permalink":"https://heliu.site/posts/golang/slice/check/","summary":"Golang sliceè¾¹ç•Œæ£€æŸ¥ã€‚","title":"è¾¹ç•Œæ£€æŸ¥"},{"content":"epollæè¿° é€‚ç”¨èŒƒå›´ï¼šè¿æ¥æ•°é‡å¤šï¼Œä½†æ´»åŠ¨è¿æ¥è¾ƒå°‘çš„æƒ…å†µã€‚ epollé«˜æ•ˆçš„å¥¥ç§˜ï¼šepollç²¾å·§çš„ä½¿ç”¨3ä¸ªæ–¹æ³•å®ç°selectæ–¹æ³•è¦åšçš„äº‹ï¼š epoll_create()ï¼šåˆ›å»ºä¸€ä¸ªepollæ–‡ä»¶æè¿°ç¬¦ã€‚ æ‰§è¡Œä¸€æ¬¡epoll_create()å‡½æ•°å°±ä¼šåˆ›å»ºä¸€ä¸ªepollæ± ï¼Œå› æ­¤åˆå§‹åŒ–æ‰§è¡Œä¸€æ¬¡å³å¯ã€‚ epoll_createå‡½æ•°ä¼šè¿”å›ä¸€ä¸ªepollæ–‡ä»¶æè¿°ç¬¦ã€‚ epoll_ctrl()ï¼šæ·»åŠ /ä¿®æ”¹/åˆ é™¤éœ€è¦ä¾¦å¬çš„æ–‡ä»¶æè¿°ç¬¦åŠå…¶äº‹ä»¶ã€‚ ä¸€ä¸ªsocketåªéœ€è°ƒç”¨è¯¥å‡½æ•°ä¸€æ¬¡æ³¨å†Œå½“å‰æ–‡ä»¶æè¿°ç¬¦ã€‚ è¯¥å‡½æ•°æ³¨å†Œæ—¶å¯ä»¥æ·»åŠ å…·ä½“çš„ä¾¦å¬çš„äº‹ä»¶å’Œç”¨æˆ·æ•°æ®ï¼Œå½“å‰äº‹ä»¶è§¦å‘æ—¶å¯ä»¥æ ¹æ®epoll_waitå‡½æ•°è·å–äº‹ä»¶ã€‚ è¿”å›æ³¨å†ŒæˆåŠŸå’Œå¤±è´¥ç»“æœã€‚ epoll_wait()ï¼šæ¥æ”¶å‘ç”Ÿåœ¨è¢«ä¾¦å¬çš„æè¿°ç¬¦ä¸Šçš„ï¼Œç”¨æˆ·æ„Ÿå…´è¶£çš„IOäº‹ä»¶ï¼Œè¿”å›å·²å°±ç»ªçš„äº‹ä»¶é›†ã€‚ æŸ¥è¯¢ç³»ç»Ÿæœ€å¤§æ”¯æŒFDæ•°ç›®ï¼šcat /proc/sys/fs/file-maxã€‚ ç†è§£epollçš„å…³é”®è¦ç´ ï¼šçº¢é»‘æ ‘ã€é“¾è¡¨ã€‚ çº¢é»‘æ ‘ï¼šå­˜å‚¨epollæ‰€ç›‘å¬çš„å¥—æ¥å­—ã€‚epollåœ¨å®ç°ä¸Šé‡‡ç”¨çº¢é»‘æ ‘å»å­˜å‚¨æ‰€æœ‰å¥—æ¥å­—ï¼Œå½“æ·»åŠ æˆ–è€…åˆ é™¤ä¸€ä¸ªå¥—æ¥å­—æ—¶ï¼ˆepoll_ctlï¼‰ï¼Œéƒ½åœ¨çº¢é»‘æ ‘ä¸Šå»å¤„ç†ï¼Œçº¢é»‘æ ‘æœ¬èº«æ’å…¥å’Œåˆ é™¤æ€§èƒ½æ¯”è¾ƒå¥½ï¼Œæ—¶é—´å¤æ‚åº¦O(logN)ã€‚ é€šè¿‡epoll_ctlå‡½æ•°æ·»åŠ è¿›æ¥çš„äº‹ä»¶éƒ½ä¼šè¢«æ”¾åœ¨çº¢é»‘æ ‘çš„æŸä¸ªèŠ‚ç‚¹å†…ï¼Œæ‰€ä»¥é‡å¤æ·»åŠ æ˜¯æ²¡æœ‰ç”¨çš„ã€‚å½“æŠŠäº‹ä»¶æ·»åŠ è¿›æ¥çš„æ—¶å€™æ—¶å€™ä¼šå®Œæˆå…³é”®çš„ä¸€æ­¥ï¼Œé‚£å°±æ˜¯è¯¥äº‹ä»¶éƒ½ä¼šä¸ç›¸åº”çš„è®¾å¤‡ï¼ˆç½‘å¡ï¼‰é©±åŠ¨ç¨‹åºå»ºç«‹å›è°ƒå…³ç³»ï¼Œå½“ç›¸åº”çš„äº‹ä»¶å‘ç”Ÿåï¼Œå°±ä¼šè°ƒç”¨è¿™ä¸ªå›è°ƒå‡½æ•°ï¼Œè¯¥å›è°ƒå‡½æ•°åœ¨å†…æ ¸ä¸­è¢«ç§°ä¸ºï¼šep_poll_callbackï¼Œè¿™ä¸ªå›è°ƒå‡½æ•°å…¶å®å°±æ‰€æŠŠè¿™ä¸ªäº‹ä»¶æ·»åŠ åˆ°rdllistè¿™ä¸ªåŒå‘é“¾è¡¨ä¸­ã€‚ä¸€æ—¦æœ‰äº‹ä»¶å‘ç”Ÿï¼Œepollå°±ä¼šå°†è¯¥äº‹ä»¶æ·»åŠ åˆ°åŒå‘é“¾è¡¨ä¸­ã€‚é‚£ä¹ˆå½“æˆ‘ä»¬è°ƒç”¨epoll_waitæ—¶ï¼Œepoll_waitåªéœ€è¦æ£€æŸ¥rdliståŒå‘é“¾è¡¨ä¸­æ˜¯å¦æœ‰å­˜åœ¨æ³¨å†Œçš„äº‹ä»¶ï¼Œæ•ˆç‡éå¸¸å¯è§‚ã€‚è¿™é‡Œä¹Ÿéœ€è¦å°†å‘ç”Ÿäº†çš„äº‹ä»¶å¤åˆ¶åˆ°ç”¨æˆ·æ€å†…å­˜ä¸­å³å¯ã€‚ä¸­æ–­ç¨‹åºè¿˜æœ‰ä¸€ä¸ªé‡è¦ä½œç”¨æ˜¯å°†é˜»å¡çš„è¿›ç¨‹å”¤é†’èµ·æ¥æ‰§è¡Œã€‚ æ€»ç»“ï¼š çº¢é»‘æ ‘çš„ä½œç”¨ï¼šå½“æœ‰äº‹ä»¶å‘ç”Ÿæ—¶ï¼Œå¯ä»¥å¿«é€Ÿæ ¹æ®fdæŸ¥æ‰¾epitemï¼ˆæ‰¾åˆ°å¾—epitermä¼šç»„æˆé“¾è¡¨ä¼ é€’ç»™ç”¨æˆ·ç©ºé—´åšè¿›ä¸€æ­¥å¤„ç†ï¼‰ï¼Œæ¯”éå†é“¾è¡¨å¿«å¤šäº†ï¼ å†…æ ¸ä¸­é“¾è¡¨é€‚ç”¨çš„åœºæ™¯ï¼šç”¨æ¥åšé˜Ÿåˆ—æˆ–æ ˆï¼Œå­˜å‚¨çš„æ¯ä¸ªèŠ‚ç‚¹éƒ½è¦å¤„ç†ï¼ˆè¯´ç™½äº†å°±æ˜¯éœ€è¦éå†ï¼‰ï¼Œä¸å­˜åœ¨æŸ¥æ‰¾çš„éœ€æ±‚åœºæ™¯ï¼ epolläº‹ä»¶åº•å±‚æœ€ç»ˆæ˜¯ä¸­æ–­è§¦å‘çš„ï¼šå½“ç½‘å¡æ”¶åˆ°æ•°æ®åï¼Œé€šè¿‡ä¸­æ–­é€šçŸ¥æ“ä½œç³»ç»Ÿæ¥å–æ•°æ®ï¼Œè¿›è€Œè§¦å‘epolläº‹ä»¶ï¼ epoll_create() åœ¨epollæ—©æœŸçš„å®ç°ä¸­ï¼Œå¯¹äºç›‘æ§æ–‡ä»¶æè¿°ç¬¦çš„ç»„ç»‡å¹¶ä¸æ˜¯ä½¿ç”¨çº¢é»‘æ ‘ï¼Œè€Œæ˜¯hashè¡¨ã€‚æ‰€ä»¥åœ¨epoll_createçš„å‚æ•°sizeæ²¡æœ‰ä»€ä¹ˆæ„ä¹‰ã€‚ epoll_createï¼šè¯¥å‡½æ•°åˆå§‹åŒ–æ—¶åªæ‰§è¡Œä¸€æ¬¡ã€‚ 1 2 3 4 5 6 7 // åˆ›å»ºä¸€ä¸ªepollå¥æŸ„ // åˆ›å»ºä¸€ä¸ªepollçš„å¥æŸ„ï¼Œsizeç”¨æ¥å‘Šè¯‰å†…æ ¸è¿™ä¸ªç›‘å¬çš„æ•°ç›®ä¸€å…±æœ‰å¤šå¤§ï¼Œåœ¨çº¢é»‘æ ‘ä¸­è¯¥å‚æ•°sizeæ— æ•ˆ int epoll_create(int size);\t// è¿”å›å€¼ï¼š //\tEINVAL å¤§å°ä¸æ˜¯æ­£æ•°ã€‚ // ENFILE å·²è¾¾åˆ°ç³»ç»Ÿå¯¹æ‰“å¼€æ–‡ä»¶æ€»æ•°çš„é™åˆ¶ã€‚ // ENOMEM æ²¡æœ‰è¶³å¤Ÿçš„å†…å­˜æ¥åˆ›å»ºå†…æ ¸å¯¹è±¡ã€‚ epoll_ctl() 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 // æ·»åŠ æ–‡ä»¶æè¿°ç¬¦åˆ°çº¢é»‘æ ‘ä¸­ int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event); // epfdï¼šä¸ºepoll_createåˆ›å»ºçš„fd // opï¼šæŒ‡å®šæ“ä½œç±»å‹ // EPOLL_CTL_ADDï¼š\tå°†ç›®æ ‡æ–‡ä»¶æè¿°ç¬¦fdæ·»åŠ åˆ°epollæè¿°ç¬¦epfdä¸­ï¼Œå¹¶å°†äº‹ä»¶eventä¸fdé“¾æ¥çš„å†…éƒ¨æ–‡ä»¶å…³è”èµ·æ¥ã€‚ // EPOLL_CTL_MODï¼š\tæ›´æ”¹ä¸ç›®æ ‡æ–‡ä»¶æè¿°ç¬¦fdå…³è”çš„äº‹ä»¶eventã€‚ // EPOLL_CTL_DELï¼š\tä»epollæ–‡ä»¶æè¿°ç¬¦epfdä¸­åˆ é™¤ç›®æ ‡æ–‡ä»¶æè¿°ç¬¦fdã€‚è¯¥äº‹ä»¶è¢«å¿½ç•¥ï¼Œå¯ä»¥ä¸ºNULLã€‚ // fdï¼šè¦æ“ä½œçš„æ–‡ä»¶æè¿°ç¬¦ï¼Œä¹Ÿå°±æ˜¯æˆ‘ä»¬è¦åŠ å…¥çš„fdï¼Œå¯ä»¥æ˜¯åˆ›å»ºçš„socketæˆ–å…¶ä»–æ–‡ä»¶å¥æŸ„ã€‚ // eventï¼šæŒ‡å®šäº‹ä»¶ï¼Œå®ƒæ˜¯epoll_eventç»“æ„æŒ‡é’ˆç±»å‹ // epoll_event å®šä¹‰ï¼š // eventsï¼šæè¿°äº‹ä»¶ç±»å‹ï¼Œå’Œpollæ”¯æŒçš„äº‹ä»¶ç±»å‹åŸºæœ¬ç›¸åŒï¼ˆä¸¤ä¸ªé¢å¤–çš„äº‹ä»¶ï¼šEPOLLETå’ŒEPOLLONESHOTï¼Œé«˜æ•ˆè¿ä½œçš„å…³é”®ï¼‰ // eventså¯ä»¥æ˜¯ä»¥ä¸‹å‡ ä¸ªå®çš„é›†åˆï¼š // EPOLLIN ï¼šè¡¨ç¤ºå¯¹åº”çš„æ–‡ä»¶æè¿°ç¬¦å¯ä»¥è¯»ï¼ˆåŒ…æ‹¬å¯¹ç«¯SOCKETæ­£å¸¸å…³é—­ï¼‰ã€‚å…³è”æ–‡ä»¶æè¿°ç¬¦çš„read()æ“ä½œ // EPOLLOUTï¼šè¡¨ç¤ºå¯¹åº”çš„æ–‡ä»¶æè¿° ç¬¦å¯ä»¥å†™ï¼Œå…³è”æ–‡ä»¶æè¿°ç¬¦çš„write()æ“ä½œã€‚ // EPOLLPRIï¼šè¡¨ç¤ºå¯¹åº”çš„æ–‡ä»¶æè¿°ç¬¦æœ‰ç´§æ€¥çš„æ•°æ®å¯è¯»ï¼ˆè¿™é‡Œåº”è¯¥è¡¨ç¤ºæœ‰å¸¦å¤–æ•°æ®åˆ°æ¥ï¼‰ // EPOLLERRï¼šæè¿°ç¬¦äº§ç”Ÿé”™è¯¯æ—¶è§¦å‘ï¼Œé»˜è®¤æ£€æµ‹äº‹ä»¶ // EPOLLHUPï¼šæœ¬ç«¯æè¿°ç¬¦äº§ç”Ÿä¸€ä¸ªæŒ‚æ–­äº‹ä»¶ï¼Œé»˜è®¤ç›‘æµ‹äº‹ä»¶ // EPOLLRDHUPï¼šå¯¹ç«¯æè¿°ç¬¦äº§ç”Ÿä¸€ä¸ªæŒ‚æ–­äº‹ä»¶ // EPOLLETï¼š å°†EPOLLè®¾ä¸ºè¾¹ç¼˜è§¦å‘(Edge Triggered)æ¨¡å¼ï¼Œè¿™æ˜¯ç›¸å¯¹äºæ°´å¹³è§¦å‘(Level Triggered)æ¥è¯´çš„ // EPOLLONESHOTï¼šåªç›‘å¬ä¸€æ¬¡äº‹ä»¶ï¼Œå½“ç›‘å¬å®Œè¿™æ¬¡äº‹ä»¶ä¹‹åï¼Œå¦‚æœè¿˜éœ€è¦ç»§ç»­ç›‘å¬è¿™ä¸ªsocketçš„è¯ï¼Œéœ€è¦å†æ¬¡æŠŠè¿™ä¸ªsocketåŠ å…¥åˆ°EPOLLé˜Ÿåˆ—é‡Œ // dataï¼šå­˜å‚¨ç”¨æˆ·æ•°æ®ï¼Œè¯¥å­—æ®µæ˜¯ä¸€ä¸ªæŒ‡é’ˆç±»å‹å› æ­¤åœ¨waitå‡½æ•°ä¸­æˆ‘ä»¬å¯ä»¥æ‹¿åˆ°è¯¥æ•°æ®è¿›è¡Œç›¸å…³æ“ä½œ // eventæ˜¯æˆ‘ä»¬æ‰€å…³å¿ƒçš„äº‹ä»¶ç±»å‹ï¼Œæ³¨æ„åªæœ‰æˆ‘ä»¬æ³¨å†Œçš„äº‹ä»¶æ‰ä¼šåœ¨epoll_waitè¢«å”¤é†’åä¼ é€’åˆ°ç”¨æˆ·ç©ºé—´ï¼Œå¦åˆ™è™½ç„¶å†…æ ¸å¯ä»¥æ”¶åˆ°ä½†ä¸ä¼šä¼ é€’ epoll_wait() 1 2 3 4 5 6 7 8 9 10 11 // æˆåŠŸæ—¶è¿”å›å°±ç»ªçš„æ–‡ä»¶æè¿°ç¬¦çš„ä¸ªæ•°ï¼Œå¤±è´¥æ—¶è¿”å›-1å¹¶è®¾ç½®errno int epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout); // timeoutï¼šæŒ‡å®šepollçš„è¶…æ—¶æ—¶é—´ï¼Œå•ä½æ˜¯æ¯«ç§’ // å½“timeoutä¸º-1æ—¶ï¼Œepoll_waitè°ƒç”¨å°†æ°¸ä¹…é˜»å¡ï¼Œç›´åˆ°æŸä¸ªäº‹ä»¶å‘ç”Ÿ // å½“timeoutä¸º0æ—¶ï¼Œepoll_waitè°ƒç”¨å°†ç«‹å³è¿”å› // å½“timeoutå¤§äº0æ—¶ï¼Œepoll_waité˜»å¡timeoutäº‹ä»¶åè¿”å› // maxeventsï¼šæŒ‡å®šæœ€å¤šç›‘å¬å¤šå°‘ä¸ªäº‹ä»¶ï¼Œæ„æ€æ˜¯ä¸€æ¬¡è¿”å›æœ€å¤§çš„å°±ç»ªäº‹ä»¶æ•°é‡ // eventsï¼šæ£€æµ‹åˆ°äº‹ä»¶ï¼Œå°†æ‰€æœ‰å°±ç»ªçš„äº‹ä»¶ä»å†…æ ¸äº‹ä»¶è¡¨ä¸­å¤åˆ¶åˆ°å®ƒçš„ç¬¬äºŒä¸ªå‚æ•°eventsæŒ‡å‘çš„æ•°ç»„ä¸­ // è¯¥å‚æ•°è·å–ä»å†…æ ¸å¾—åˆ°çš„äº‹ä»¶çš„é›†åˆï¼Œæ‹¿åˆ°å‰é¢å‡½æ•°æ³¨å†Œçš„ç”¨æˆ·æ•°æ®è¿›è¡Œæ ‡è®° // è¿”å›å€¼intï¼Œè¡¨ç¤ºéœ€è¦å¤„ç†çš„äº‹ä»¶æ•°ç›®ï¼Œå¦‚æœè¿”å›0è¡¨ç¤ºå·²è¶…æ—¶ selectã€pollã€epoll ç³»ç»Ÿè°ƒç”¨ select poll epoll äº‹ä»¶é›†åˆ é€šè¿‡ä¼ å…¥3ä¸ªå‚æ•°å¯è¯»ã€å¯å†™ã€å¼‚å¸¸äº‹ä»¶å†…æ ¸é€šè¿‡å¯¹è¿™äº›å‚æ•°åœ¨çº¿ä¿®æ”¹æ¥åé¦ˆå…¶ä¸­çš„å°±ç»ªäº‹ä»¶ï¼Œè¿™ä½¿å¾—ç”¨æˆ·æ¯æ¬¡è°ƒç”¨selectéƒ½è¦é‡ç½®è¿™3ä¸ªå‚æ•° ç»Ÿä¸€å¤„ç†æ‰€æœ‰äº‹ä»¶ç±»å‹ï¼Œå› æ­¤åªéœ€è¦ä¸€ä¸ªäº‹ä»¶é›†å‚æ•°ã€‚ç”¨æˆ·é€šè¿‡pollfd.eventsä¼ å…¥æ„Ÿå…´è¶£çš„äº‹ä»¶ï¼Œå†…æ ¸é€šè¿‡ä¿®æ”¹pollfd.reventsåé¦ˆå…¶ä¸­å°±ç»ªçš„äº‹ä»¶ å†…æ ¸é€šè¿‡ä¸€ä¸ªäº‹ä»¶è¡¨ç›´æ¥ç®¡ç†ç”¨æˆ·æ„Ÿå…´è¶£çš„æ‰€æœ‰äº‹ä»¶ã€‚å› æ­¤æ¯æ¬¡è°ƒç”¨epoll_waitæ—¶ï¼Œæ— éœ€åå¤ä¼ å…¥ç”¨æˆ·æ„Ÿå…´è¶£çš„äº‹ä»¶ã€‚epoll_waitç³»ç»Ÿè°ƒç”¨çš„å‚æ•°eventsä»…ç”¨æ¥åé¦ˆå°±ç»ªçš„äº‹ä»¶ åº”ç”¨ç¨‹åºç´¢å¼•å°±ç»ªæ–‡ä»¶æè¿°ç¬¦çš„æ—¶é—´å¤æ‚åº¦ O(n) O(n) O(1) æœ€å¤§æ”¯æŒæ–‡ä»¶æè¿°ç¬¦æ•° ä¸€èˆ¬æœ‰æœ€å¤§å€¼é™åˆ¶ 65535 65535 å·¥ä½œæ¨¡å¼ LT LT æ”¯æŒETé«˜æ•ˆæ¨¡å¼ å†…æ ¸å®ç°å’Œå·¥ä½œæ•ˆç‡ é‡‡ç”¨è½®è¯¢æ–¹å¼æ£€æµ‹å°±ç»ªäº‹ä»¶ï¼Œæ—¶é—´å¤æ‚åº¦ï¼šO(n) é‡‡ç”¨è½®è¯¢æ–¹å¼æ£€æµ‹å°±ç»ªäº‹ä»¶ï¼Œæ—¶é—´å¤æ‚åº¦ï¼šO(n) é‡‡ç”¨å›è°ƒæ–¹å¼æ£€æµ‹å°±ç»ªäº‹ä»¶ï¼Œæ—¶é—´å¤æ‚åº¦ï¼šO(1) socket() åˆ›å»ºä¸€ä¸ªsocketï¼Œä¸ºä¸€ä¸ªsocketæ•°æ®ç»“æ„åˆ†é…å­˜å‚¨ç©ºé—´ã€‚ ä¸¤ä¸ªç½‘ç»œç¨‹åºä¹‹é—´çš„ä¸€ä¸ªç½‘ç»œè¿æ¥åŒ…æ‹¬äº”ç§ä¿¡æ¯ï¼šã€é€šä¿¡åè®®ã€‘ã€ã€æœ¬åœ°åè®®åœ°å€ã€‘ã€ã€æœ¬åœ°ä¸»æœºç«¯å£ã€‘ã€ã€è¿œç«¯ä¸»æœºåœ°å€ã€‘å’Œã€è¿œç«¯åè®®ç«¯å£ã€‘ã€‚ è¯¥å‡½æ•°ä¸ä¼šé˜»å¡ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 int socket(int domain, int type, int protocol); // 1) domain å‚æ•°ï¼šäº’è”ç½‘åè®®æ—ï¼Œå¸¸ç”¨çš„æœ‰ä»¥ä¸‹ // AF_INETï¼š è¡¨ç¤ºé€šè¿‡IPv4,é€šä¿¡æ–¹å¼(é€šè¿‡IPv4ç½‘ç»œè¿æ¥èµ·æ¥çš„ä¸»æœº),åº”ç”¨ç¨‹åºé—´çš„é€šä¿¡(32ä½IPv4åœ°å€+16ä½ç«¯å£å·),åœ°å€ç»“æ„(sockaddr_in) // AF_INET6ï¼šè¡¨ç¤ºé€šè¿‡IPv6,é€šä¿¡æ–¹å¼(é€šè¿‡IPv6ç½‘ç»œè¿æ¥èµ·æ¥çš„ä¸»æœº),åº”ç”¨ç¨‹åºé—´çš„é€šä¿¡(128ä½Ipv6åœ°å€+16ä½ç«¯å£å·),åœ°å€ç»“æ„(sockaddr_in6) // AF_UNIXï¼š å†…æ ¸ä¸­,åŒä¸€ä¸»æœºé—´é€šä¿¡,åœ°å€æ ¼å¼(è·¯å¾„å),åœ°å€ç»“æ„(sockaddr_un) // AF_ROUTEï¼šè·¯ç”±å¥—æ¥å­— // AF_KEYï¼šå¯†é’¥å¥—æ¥å­— // AF_UNSPECï¼šæœªæŒ‡å®š // AFï¼šæ˜¯â€œAddress Familyâ€çš„ç®€å†™ï¼ŒINETæ˜¯â€œInetnetâ€çš„ç®€å†™ // 2) type å‚æ•°ï¼šè¡¨ç¤º æ•°æ®ä¼ è¾“æ–¹å¼/å¥—æ¥å­—ç±»å‹ // SOCK_STREAMï¼šè¡¨ç¤ºä½¿ç”¨ \u0026#34;æµæ ¼å¼å¥—æ¥å­—/é¢å‘è¿æ¥çš„å¥—æ¥å­—\u0026#34;ï¼Œæœ‰åºçš„ã€é¢å‘è¿æ¥çš„ã€å¯é çš„åŒå‘é€šä¿¡çš„å­—èŠ‚æµé€šä¿¡ // SOCK_DGRAMï¼š è¡¨ç¤ºä½¿ç”¨ \u0026#34;æ•°æ®æŠ¥å¥—æ¥å­—/æ— è¿æ¥çš„å¥—æ¥å­—\u0026#34;ï¼Œä¸è¿æ¥ã€ä¸å¯é ã€å›ºå®šé•¿åº¦çš„æ•°æ®æŠ¥é€šä¿¡ // SOCK_NONBLOCKï¼šå°†socketå‡½æ•°è¿”å›çš„æ–‡ä»¶æè¿°ç¬¦æŒ‡å®šä¸ºéé˜»å¡ï¼Œå¯ä»¥å’Œä¸Šé¢çš„å®ä½¿ç”¨â€™|â€™è¿ç®—ï¼ˆå¦‚é‡‡ç”¨SOCK_STREAM | SOCK_NONBLOCKè¡¨ç¤ºä½¿ç”¨TCPåè®®ä¸”æ˜¯éé˜»å¡ï¼‰ï¼Œé»˜è®¤æ˜¯é˜»å¡æ¨¡å¼ // SOCK_RDMï¼šè¡¨ç¤ºæƒ³ä½¿ç”¨åŸå§‹ç½‘ç»œé€šä¿¡ï¼ˆå¦‚å½“domainå‚æ•°è®¾ç½®ä¸ºPF_INETæ—¶å°±è¡¨ç¤ºç›´æ¥ä½¿ç”¨TCP/IPåè®®æ—ä¸­çš„ipåè®®ï¼‰ // SOCK_CLOEXECï¼šä¸€æ—¦è¿›ç¨‹execæ‰§è¡Œæ–°ç¨‹åºæ—¶ï¼Œè‡ªåŠ¨å…³é—­socketè¿”å›çš„å¥—æ¥å­—æ–‡ä»¶æè¿°ç¬¦ï¼Œä¹Ÿå°±æ˜¯forkçš„ç¨‹åºä¸èƒ½å…±ç”¨ä¸€ä¸ªsocket // 3) protocol å‚æ•°ï¼šè¡¨ç¤ºä¼ è¾“åè®®ï¼Œå¸¸ç”¨çš„æœ‰ä»¥ä¸‹ // IPPROTO_TCPï¼š è¡¨ç¤ºTCPä¼ è¾“åè®® // IPPTOTO_UDPï¼š è¡¨ç¤ºUDPä¼ è¾“åè®® // IPPROTO_SCTPï¼šè¡¨ç¤ºSCTPä¼ è¾“åè®® // IPPROTO_TIPCï¼šè¡¨ç¤ºTIPCä¼ è¾“åè®® // ä¸€èˆ¬è¯¥å‚æ•°é»˜è®¤ä¼ å…¥0ï¼Œsocketç¨‹åºæ ¹æ®å‰ä¸¤ä¸ªå‚æ•°è‡ªåŠ¨æ¨æ–­ç±»å‹ // è¿”å›å€¼ï¼šæˆåŠŸæ—¶è¿”å›åˆ›å»ºçš„socketçš„æ–‡ä»¶æè¿°ç¬¦;å¤±è´¥æ—¶è¿”å›-1ï¼Œå¹¶è®¾ç½®errnoé”™è¯¯ä¿¡æ¯ // æœ‰äº†åœ°å€ç±»å‹å’Œæ•°æ®ä¼ è¾“æ–¹å¼ï¼Œè¿˜ä¸è¶³ä»¥å†³å®šé‡‡ç”¨å“ªç§åè®®å—ï¼Ÿä¸ºä»€ä¹ˆè¿˜éœ€è¦ç¬¬ä¸‰ä¸ªå‚æ•°å‘¢ï¼Ÿ // 1. ä¸€èˆ¬æƒ…å†µä¸‹æœ‰äº†å‰ä¸¤ä¸ªå‚æ•°å°±å¯ä»¥åˆ›å»ºsocketï¼Œæ“ä½œç³»ç»Ÿä¼šè‡ªåŠ¨æ¨æ¼”å‡ºåè®®ç±»å‹ // 2. é™¤éé‡åˆ°è¿™æ ·çš„æƒ…å†µï¼šæœ‰ä¸¤ç§ä¸åŒçš„åè®®æ”¯æŒåŒä¸€ç§åœ°å€ç±»å‹å’Œæ•°æ®ä¼ è¾“ç±»å‹ // 3. å¦‚æœæˆ‘ä»¬ä¸æŒ‡æ˜ä½¿ç”¨å“ªç§åè®®ï¼Œæ“ä½œç³»ç»Ÿæ˜¯æ²¡åŠæ³•è‡ªåŠ¨æ¨æ¼”çš„ // int tcp_socket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); // æ»¡è¶³å‰é¢ä¸¤ä¸ªå‚æ•°çš„åªæœ‰TCPåè®®ï¼Œå› æ­¤å¯ä»¥å†™æˆå¦‚ä¸‹ // int tcp_socket = socket(AF_INET, SOCK_STREAM, 0); // int udp_socket = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP); // æ»¡è¶³å‰é¢ä¸¤ä¸ªå‚æ•°çš„åªæœ‰UDPåè®®ï¼Œå› æ­¤å¯ä»¥å†™æˆå¦‚ä¸‹ // int udp_socket = socket(AF_INET, SOCK_DGRAM, 0); bind() Bindå‡½æ•°å°†socketä¸æœ¬æœºä¸Šçš„ä¸€ä¸ªç«¯å£ç›¸å…³è”ï¼Œéšåä½ å°±å¯ä»¥åœ¨è¯¥ç«¯å£ç›‘å¬æœåŠ¡è¯·æ±‚ ç»™socketç»‘å®šä¸€ä¸ªåœ°å€ï¼Œè¿™æ ·clientå¯¹è¿™ä¸ªåœ°å€çš„ç›¸åº”æ”¶å‘æ•°æ®å°±èƒ½å’Œsocketç›¸å…³è” æœåŠ¡ç«¯: å¿…é¡»è¦è°ƒç”¨bindè¿›è¡Œç»‘å®šï¼Œbind æ˜¯ç»‘å®šæœ¬åœ°åœ°å€ï¼Œå®ƒä¸è´Ÿè´£å¯¹ç«¯åœ°å€ï¼Œä¸€èˆ¬ç”¨äºæœåŠ¡å™¨ç«¯ï¼Œå®¢æˆ·ç«¯æ˜¯ç³»ç»ŸæŒ‡å®šçš„ã€‚ å®¢æˆ·ç«¯: éå¿…é¡»è°ƒç”¨ï¼Œå¦‚ä¸è°ƒç”¨ï¼Œåˆ™ç³»ç»Ÿè‡ªåŠ¨åˆ†é…ä¸€ä¸ªç«¯å£å’Œæœ¬åœ°åœ°å€æ¥è¿›è¡Œå’Œsocketç»‘å®š socketå‡½æ•°å¹¶æ²¡æœ‰ä¸ºå¥—æ¥å­—ç»‘å®šæœ¬åœ°åœ°å€å’Œç«¯å£å·ï¼Œå¯¹äºæœåŠ¡å™¨ç«¯åˆ™å¿…é¡»æ˜¾æ€§ç»‘å®šåœ°å€å’Œç«¯å£å·ï¼Œbindå‡½æ•°ä¸»è¦æ˜¯æœåŠ¡å™¨ç«¯ä½¿ç”¨ï¼ŒæŠŠä¸€ä¸ªæœ¬åœ°åè®®åœ°å€èµ‹äºˆå¥—æ¥å­— è¯¥å‡½æ•°ä¸ä¼šé˜»å¡ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen); // sockfdï¼šå‚æ•°æ˜¯è°ƒç”¨socketå‡½æ•°è¿”å›çš„socketæè¿°ç¬¦ // addrï¼šå‚æ•°æ˜¯ä¸€ä¸ªæŒ‡å‘åŒ…å«æœ‰æœ¬æœºIPåœ°å€åŠç«¯å£å·ç­‰ä¿¡æ¯çš„sockaddrç±»å‹çš„æŒ‡é’ˆ // æ—©æœŸçš„sockaddr // struct sockaddr { // sa_family_t sa_faily;\t// åœ°å€æ—,AF_XXX // char sa_data[14];\t// å­—ç¬¦æ•°ç»„ï¼Œå­˜æ”¾ipå’Œç«¯å£ // } // åé¢å‡ºç°äº†IPv4å’ŒIPv6ï¼Œå› æ­¤æŠŠsockaddrç»“æ„æ›´è¯¦ç»†ç»†åˆ†,ä¸‹é¢ç»“æ„éƒ½èƒ½ä¸sockaddrè¿›è¡Œè½¬æ¢ // ipv4 // struct sockaddr_in { // __kernel_sa_family_t sin_family; // åœ°å€æ— // __be16 sin_port; // ç«¯å£ // struct in_addr sin_addr; // Internetåœ°å€ // // å ä½,ä»¥æ»¡è¶³sockaddr_inæ‰€å å¤§å°ä¸sockaddrç›¸åŒ // unsigned char __pad[__SOCK_SIZE__ - sizeof(short int) - sizeof(unsigned short int) - sizeof(struct in_addr)]; // } // // Internetåœ°å€ // struct in_addr { // __be32 s_addr; // 32ä¸ºæ— ç¬¦å·æ•´å‹æ•°æ®ï¼Œæ­£å¥½å­˜å‚¨IPåœ°å€ // }; // ipv6 // struct sockaddr_in6 { // unsigned short int sin6_family; // AF_INET6 // __be16 sin6_port; // ä¼ è¾“å±‚ç«¯å£ // __be32 sin6_flowinfo; // IPv6 æµä¿¡æ¯ // struct in6_addr sin6_addr; // IPv6 åœ°å€ // __u32 sin6_scope_id; // scope id (new in RFC2553) // }; // unix addr // #define UNIX_PATH_MAX 108 // struct sockaddr_un { // __kernel_sa_family_t sun_family; // AF_UNIX // char sun_path[UNIX_PATH_MAX]; // }; // addrlenï¼šå‚æ•°æ˜¯åœ°å€å‚æ•°çš„é•¿åº¦sizeof(addr) // è¿”å›å€¼ï¼šæˆåŠŸè¿”å›0ï¼Œå¤±è´¥è¿”å›-1, å¹¶ä¸”è®¾ç½®errno // æ¯”å¦‚ç»‘å®šä¸€ä¸ªipv4åœ°å€ struct sockaddr_in addr; // å®šä¹‰ç»“æ„ä½“å˜é‡ addr.sin_family = AF_INET; // æŒ‡å®šåè®®æ—ä¸ºIPv4 addr.sin_port = htons(5006);// æŒ‡å®šç«¯å£å· addr.sin_addr.s_addr = inet_addr(\u0026#34;192.168.1.10\u0026#34;); // æŒ‡å®šIP // è¿›è¡Œå¥—æ¥å­—æ–‡ä»¶ ip/ç«¯å£çš„ç»‘å®š ret = bind(sockfd, (struct sockaddr*)\u0026amp;addr, sizeof(addr)); // å…¶ä»–ç›¸å…³å‡½æ•° // htonl() æŠŠ32ä½å€¼ä»ä¸»æœºå­—èŠ‚åºè½¬æ¢æˆç½‘ç»œå­—èŠ‚åº // htons() æŠŠ16ä½å€¼ä»ä¸»æœºå­—èŠ‚åºè½¬æ¢æˆç½‘ç»œå­—èŠ‚åº // ntohl() æŠŠ32ä½å€¼ä»ç½‘ç»œå­—èŠ‚åºè½¬æ¢æˆä¸»æœºå­—èŠ‚åº // ntohs() æŠŠ16ä½å€¼ä»ç½‘ç»œå­—èŠ‚åºè½¬æ¢æˆä¸»æœºå­—èŠ‚åº // inet_addr() å­—ç¬¦ä¸²å½¢å¼çš„ip,ç”¨äºå°†ç‚¹åˆ†åè¿›åˆ¶IPè½¬æ¢ä¸ºIPV4çš„32ä½æ— ç¬¦å·æ•´å‹IP listen() ä»…ä¾›æœåŠ¡å™¨ç«¯è°ƒç”¨ï¼ŒæŠŠä¸€ä¸ªæœªè¿æ¥çš„å¥—æ¥å­—è½¬æ¢ä¸ºä¸€ä¸ªè¢«åŠ¨å¥—æ¥å­—ï¼ŒæŒ‡ç¤ºå†…æ ¸åº”è¯¥æ¥å—æŒ‡å‘è¯¥å¥—æ¥å­—çš„è¿æ¥è¯·æ±‚ã€‚ å…¶å†…éƒ¨å®ç°å½’æ ¹ç»“åº•å°±æ˜¯è®¾ç½®sockç»“æ„çš„çŠ¶æ€ï¼Œè®¾ç½®å…¶ä¸ºTCP_LISTENã€‚ è¯¥å‡½æ•°ä¸ä¼šé˜»å¡ã€‚ listenå‡½æ•°æŠŠä¸€ä¸ªæœªè¿æ¥çš„å¥—æ¥å­—è½¬æ¢ä¸ºä¸€ä¸ªè¢«åŠ¨å¥—æ¥å­—ï¼ŒæŒ‡ç¤ºå†…æ ¸åº”æ¥å—æŒ‡å‘è¯¥å¥—æ¥å­—çš„è¿æ¥è¯·æ±‚ï¼Œå…¶å†…éƒ¨å®ç°å½’æ ¹åˆ°åº•å°±æ˜¯è®¾ç½®sockç»“æ„çš„çŠ¶æ€ï¼Œè®¾ç½®å…¶ä¸ºTCP_LISTENã€‚ è¿™ä¸ªå‡½æ•°ä¹Ÿæ˜¯æœåŠ¡å™¨ç«¯è°ƒç”¨ï¼Œå…¶å¥—æ¥å­—çš„åœ°å€ä¿¡æ¯çŠ¶æ€å’Œbindå‡½æ•°æ‰§è¡Œä¹‹åæ˜¯ä¸€æ ·çš„ï¼Œåªç»‘å®šäº†æœ¬åœ°åœ°å€ä¿¡æ¯ï¼Œä¸çŸ¥é“å¯¹ç«¯çš„åœ°å€ä¿¡æ¯ã€‚ 1 2 3 4 5 6 int listen(int sockfd, int backlog); // sockfdï¼šsocket()æ‰€åˆ›å»ºçš„fd // backlogï¼šåœ¨tcpä¸‰æ¬¡æ¡æ‰‹çš„æ—¶å€™ï¼Œç¬¬ä¸€æ¬¡æ¡æ‰‹å‘é€SYN=1ï¼Œserverç«¯æ¥æ”¶åˆ°ä¹‹åï¼Œåœ¨å›å¤äº†Ack=1ä¹‹åï¼Œ // ä¼šæŠŠè¿™ä¸ªè¿˜æœªå®Œæˆ3æ¬¡æ¡æ‰‹çš„è¿æ¥æ”¾å…¥åˆ°ä¸€ä¸ªé˜Ÿåˆ—ä¸­ï¼Œè¿™ä¸ªé˜Ÿåˆ—éœ€è¦æŒ‡å®šä¸€ä¸ªé•¿åº¦ï¼Œè¯¥å‚æ•°å°±æ˜¯ç”¨æ¥æŒ‡å®šè¿™ä¸ªåŠè¿æ¥é˜Ÿåˆ—é•¿åº¦çš„ // åœ¨linuxä¸­è¯¥å‚æ•°é»˜è®¤å€¼ç”±cat /proc/sys/net/ipv4/tcp_max_syn_backlogå†³å®šï¼Œé»˜è®¤1024 accept() è¯¥å‡½æ•°è¿”å›ä¸€ä¸ªå·²å»ºç«‹é“¾æ¥çš„å¯ç”¨ æ•°æ®é€šä¿¡ çš„å¥—æ¥å­— å½“socketæ¨¡å¼è®¾ç½®ä¸ºé˜»å¡ï¼Œacceptå‡½æ•°çš„åŠŸèƒ½æ˜¯é˜»å¡ç­‰å¾…clientå‘èµ·ä¸‰æ¬¡æ¡æ‰‹ï¼Œå½“3æ¬¡æ¡æ‰‹å®Œæˆçš„æ—¶å€™ï¼Œacceptè§£é™¤é˜»å¡ï¼Œå¹¶ä»å…¨è¿æ¥é˜Ÿåˆ—ä¸­å–å‡ºä¸€ä¸ªsocketï¼Œå°±å¯ä»¥å¯¹è¿™ä¸ªsocketè¿æ¥è¿›è¡Œè¯»å†™æ“ä½œ è¯¥å‡½æ•°ä¼šé˜»å¡ç­‰å¾…é“¾æ¥ã€‚ 1 2 3 4 5 int accept(int sockfd, struct sockaddr *cliaddr, socklen_t *addrlen); // è¿”å›å€¼ï¼šéè´Ÿæ•°æˆåŠŸï¼Œè¿”å›ä¸€ä¸ªæ–°çš„fdï¼Œè¿™ä¸ªfdç”¨æ¥å’Œå¯¹ç«¯è¿›è¡Œé€šä¿¡ï¼Œ-1 å‡ºé”™ // sockfdï¼šç›‘å¬åçš„å¥—æ¥å­—ï¼Œä¹Ÿå°±æ˜¯listenå‡½æ•°è¿”å›çš„fd // cliaddrï¼šç”¨æ¥æ¥æ”¶å¯¹ç«¯çš„è¿æ¥åœ°å€ä¿¡æ¯ï¼Œå¦‚æœå¯¹å®¢æˆ·ç«¯ä¿¡æ¯ä¸æ„Ÿå…´è¶£å¯ä»¥æŠŠè¯¥å€¼è®¾ç½®æˆç©ºNULL // addrlenï¼šcliaddrçš„é•¿åº¦ accept4() accept4()æœ‰ç¬¬å››ä¸ªå‚æ•°flagsï¼Œè¿™ä¸ªå‚æ•°å¦‚æœä¸º0ï¼Œå°±è·Ÿaccept()ä¸€æ ·ã€‚ é¢å¤–æ·»åŠ çš„flagså‚æ•°å¯ä»¥ä¸ºæ–°è¿æ¥æè¿°ç¬¦è®¾ç½® O_NONBLOCK | O_CLOEXEC (æ‰§è¡Œexecåå…³é—­)è¿™ä¸¤ä¸ªæ ‡è®°ã€‚ SOCK_NONBLOCK: ä¸ºæ–°æ‰“å¼€çš„æ–‡ä»¶æè¿°ç¬¦è®¾ç½®O_NONBLOCKæ ‡å¿—ä½ï¼Œè¿™è·Ÿç”¨fcntl()è®¾ç½®çš„æ•ˆæœæ˜¯ä¸€æ ·çš„ï¼ŒåŒºåˆ«å°±æ˜¯ç”¨fcntl()çš„è¯éœ€è¦å¤šè°ƒç”¨ä¸ªå‡½æ•°ã€‚ SOCK_CLOEXEC: ä¸ºæ–°æ‰“å¼€çš„æ–‡ä»¶æè¿°ç¬¦è®¾ç½®FD_CLOEXECæ ‡å¿—ä½ï¼Œè¯¥æ ‡å¿—ä½çš„ä½œç”¨æ˜¯åœ¨è¿›ç¨‹ä½¿ç”¨fork()åŠ ä¸Šexecve()çš„æ—¶å€™è‡ªåŠ¨å…³é—­æ‰“å¼€çš„æ–‡ä»¶æè¿°ç¬¦ã€‚ 1 int accept4(int sockfd, struct sockaddr *addr,socklen_t *addrlen, int flags); connect() TCPå®¢æˆ·ç”¨connectå‡½æ•°æ¥å»ºç«‹ä¸TCPæœåŠ¡å™¨çš„è¿æ¥ï¼Œå…¶å®æ˜¯å®¢æˆ·åˆ©ç”¨connectå‡½æ•°å‘æœåŠ¡å™¨å‘å‡ºè¿æ¥è¯·æ±‚ç”¨æˆ·å®¢æˆ·ç«¯ã€‚ 1 2 3 int connect(int sockfd, const struct sockaddr *servaddr, socklen_t addrlen); // sockfdï¼šç”±socketå‡½æ•°è¿”å›çš„å¥—æ¥å­—æè¿°ç¬¦ // ç¬¬äºŒã€ä¸‰ä¸ªå‚æ•°åˆ†åˆ«æ˜¯æŒ‡å‘å¥—æ¥å£åœ°å€ç»“æ„çš„æŒ‡é’ˆå’Œè¯¥ç»“æ„çš„å¤§å°ï¼Œå¥—æ¥å£åœ°å€ç»“æ„å¿…é¡»å«æœ‰æœåŠ¡å™¨çš„IPåœ°å€å’Œç«¯å£å· read() ä»æ‰“å¼€æ–‡ä»¶ä¸­è¯»å–æ•°æ®ã€‚ 1 2 3 4 5 ssize_t read(int fd, void *buf, size_t count); // fdï¼šsocketçš„æ–‡ä»¶æè¿°ç¬¦ // bufï¼šè¯»å–åˆ°çš„å®¹å™¨ // countï¼šbufçš„å¤§å° // è¿”å›å€¼ï¼šä¸ºå®é™…è¯»å–åˆ°çš„å­—èŠ‚æ•°ï¼Œå¦‚æœè¿”å›0ï¼Œè¡¨ç¤ºå·²è¾¾åˆ°æ–‡ä»¶å°¾æˆ–æ˜¯æ— å¯è¯»çš„æ•°æ® ","permalink":"https://heliu.site/posts/golang/netpoll/linux/","summary":"Linux epollå‡½æ•°ç®€ä»‹ã€‚","title":"Linux epoll"},{"content":" ä»¥ä¸‹æ¥è‡ªgo1.19.3/src/runtime/netpoll_epoll.goæ–‡ä»¶ã€‚ æœ¬ç¯‡æ–‡ç« æ˜¯é’ˆå¯¹netpoll_epoll.goæ–‡ä»¶çš„æºç èµ°è¯»ã€‚ variables 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 var ( // epoll æè¿°ç¬¦, epollcreate å‡½æ•°åˆ›å»ºè¿”å›çš„æ–‡ä»¶æè¿°ç¬¦ epfd int32 = -1 // epoll descriptor // ä¿å­˜çš„æ˜¯pipe2()æˆ–pip()å‡½æ•°åˆ›å»ºçš„è¯»å†™æè¿°ç¬¦ï¼Œpip2()æˆ–pip()å‡½æ•°åˆ›å»ºçš„readå’Œwriteï¼Œåªè¦ä»»æ„ä¸€æ–¹æ“ä½œå¦ä¸€æ–¹èƒ½è·å–åˆ°æ•°æ® // netpollBreakRdä¼šè¢«æ³¨å†Œåˆ°epollä¸­ï¼Œå½“å†™æè¿°ç¬¦å‘é‡Œå†™æ•°æ®æ—¶ä¼šè§¦å‘waitç›‘å¬å‡½æ•°è¿”å›å°±ç»ªçš„äº‹ä»¶é›† // è¿™å¯¹è¯»å†™æè¿°ç¬¦çš„ä½œç”¨åœ¨äºé€šä¿¡ï¼Œå½“æœ‰å…¶ä»–åç¨‹åœ¨waité˜»å¡ç­‰å¾…æ—¶ï¼Œå¯ä»¥é€šè¿‡å†™æè¿°ç¬¦å†™å…¥æ•°æ®è®©ç­‰å¾…çš„åç¨‹è¿”å› // ä¸»è¦é’ˆå¯¹ epoll_wait() å‡½æ•°é˜»å¡çš„çº¿ç¨‹ï¼Œé€šè¿‡è¿™é‡Œçš„äº‹ä»¶ä½¿è°ƒç”¨ epoll_wait() å‡½æ•°çš„çº¿ç¨‹é™·å…¥å†…æ ¸è¿”å›ã€‚ // å¯¹äº epoll_wait() çš„ timeout å‚æ•°ä¸º0çš„æƒ…å†µï¼Œè¿™é‡Œçš„äº‹ä»¶ä¼šè¢«å¿½ç•¥ netpollBreakRd, netpollBreakWr uintptr // for netpollBreak // ç”¨äºé¿å…é‡å¤è°ƒç”¨ netpollBreak() // åœ¨å‘netpollBreakWrä¸­å†™å…¥æ•°æ®æ—¶ï¼Œè¯¥å€¼ä¼šä»0å˜æˆ1ï¼Œæ§åˆ¶åªå†™ä¸€æ¬¡æ ‡å¿—ç¬¦å· // è¯¥å‚æ•°æ˜¯åŸå­æ€§çš„ netpollWakeSig uint32 // used to avoid duplicate calls of netpollBreak ) netpollGenericInit() åˆå§‹åŒ–netpollã€‚go1.19.3/src/runtime/netpoll.goæ–‡ä»¶ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 func netpollGenericInit() { // var netpollInited uint32 // æ˜¯å¦å·²åˆå§‹åŒ–epollæ ‡å¿— 0.æœªåˆå§‹åŒ– 1.å·²åˆå§‹åŒ– if atomic.Load(\u0026amp;netpollInited) == 0 { // var netpollInitLock mutex åˆå§‹åŒ– lockInit(\u0026amp;netpollInitLock, lockRankNetpollInit) lock(\u0026amp;netpollInitLock) // è¿™é‡Œéœ€è¦åˆ¤æ–­ netpollInited == 0ï¼›åŸå› åœ¨äºå¯èƒ½å­˜åœ¨å¤šä¸ªåç¨‹å¹¶å‘åœ¨ç­‰å¾…åˆå§‹åŒ–epoll // å½“è¿™äº›åç¨‹è·å–çš„é”æƒé™æ—¶ï¼Œè¿™é‡Œçš„netpollInitedå·²è¢«è®¾ç½®æˆ1äº†ï¼Œå·²ç»è¢«åˆå§‹åŒ–äº† if netpollInited == 0 { netpollinit() // åˆå§‹åŒ–netpoll atomic.Store(\u0026amp;netpollInited, 1)\t// netpollInited } unlock(\u0026amp;netpollInitLock) } } netpollinit() go1.19.3/src/runtime/netpoll_epoll.goã€‚ è°ƒç”¨epollcreateåˆ›å»ºnetpollerã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 func netpollinit() { // epollcreate å‡½æ•°å†…ä¼šè°ƒç”¨ epollcreate1 // _EPOLL_CLOEXECï¼šå½“å‰è¿›ç¨‹forkå‡ºæ¥çš„ä»»ä½•å­è¿›ç¨‹åœ¨æ‰§è¡Œå‰éƒ½ä¼šå…³é—­epollæè¿°ç¬¦ï¼Œä¹Ÿå› æ­¤ï¼Œå­è¿›ç¨‹ä¸èƒ½å¤Ÿè®¿é—®epollå®ä¾‹ epfd = epollcreate1(_EPOLL_CLOEXEC) // å°äº0è¡¨ç¤ºåˆ›å»ºå‡ºé”™ï¼Œå¤§äº0è¡¨ç¤ºè¿”å›çš„åˆ›å»ºåçš„æ–‡ä»¶å¥æŸ„ID if epfd \u0026lt; 0 {\tepfd = epollcreate(1024) if epfd \u0026lt; 0 { println(\u0026#34;runtime: epollcreate failed with\u0026#34;, -epfd) throw(\u0026#34;runtime: netpollinit failed\u0026#34;) } // ç³»ç»Ÿè°ƒç”¨ fcntl è®¾ç½® FD_CLOEXECï¼Œå‚çœ‹ epollcreate1 å‡½æ•°å‚æ•° // fcntlï¼šfd, F_SETFD, FD_CLOEXEC closeonexec(epfd) } // åˆ›å»ºä¸€ä¸ªç”¨äºé€šä¿¡çš„ç®¡é“,è¿”å›è¯»å†™,ä¸»è¦ç”¨äºé‚£äº›ç­‰å¾…åœ¨IOè½®è¯¢ä¸­çš„çº¿ç¨‹é€šä¿¡ // åˆ›å»ºä¸€ä¸ªéé˜»å¡å¼pipeï¼Œç”¨æ¥å”¤é†’é˜»å¡ä¸­çš„ netpollerã€‚ // pipe2(_O_NONBLOCK | _O_CLOEXEC) r, w, errno := nonblockingPipe() // ä¸»è¦ç”¨äºBreakç›¸å…³çš„å‡½æ•°ï¼Œä¸»è¦ç”¨äºç½‘ç»œè½®è¯¢å”¤é†’ä¿¡å· if errno != 0 { println(\u0026#34;runtime: pipe failed with\u0026#34;, -errno) throw(\u0026#34;runtime: pipe failed\u0026#34;) } // epollevent æ˜¯äº‹ä»¶ç±»å‹ // type epollevent struct { //\tevents uint32 // äº‹ä»¶ç±»å‹ //\tdata [8]byte // å­˜å‚¨ç”¨æˆ·æ•°æ®ï¼Œåˆšå¥½æ˜¯ä¸€ä¸ªæŒ‡é’ˆå­˜å‚¨çš„å¤§å°ï¼Œè¯¥æ•°æ®ç”¨æˆ·æ˜¯å¯ä»¥ä¿®æ”¹çš„ // } ev := epollevent{ // æ³¨æ„ï¼šè¿™é‡Œé»˜è®¤æ³¨å†Œçš„æ˜¯æ°´å¹³è§¦å‘ï¼Œå› æ­¤ä¼šä¸€ç›´è§¦å‘ events: _EPOLLIN, // EPOLLIN è¡¨ç¤ºå¯¹åº”çš„æ–‡ä»¶æè¿°ç¬¦å¯ä»¥è¯»ï¼ˆåŒ…æ‹¬å¯¹ç«¯SOCKETæ­£å¸¸å…³é—­ï¼‰ } // var netpollBreakRd uintptr *(**uintptr)(unsafe.Pointer(\u0026amp;ev.data)) = \u0026amp;netpollBreakRd // ev.data = \u0026amp;netpollBreakRd // å°†è¯»å–æ•°æ®çš„æ–‡ä»¶æè¿°ç¬¦åŠ å…¥ç›‘å¬ï¼Œå½“ä½¿ç”¨wå†™æ•°æ®æ—¶ï¼Œè¯¥rä¼šè¢«è§¦å‘ // func epollctl(epfd, op, fd int32, ev *epollevent) int32 // _EPOLL_CTL_ADD å°†ç›®æ ‡æ–‡ä»¶æè¿°ç¬¦fdæ·»åŠ åˆ°epollæè¿°ç¬¦epfdä¸­ï¼Œå¹¶å°†äº‹ä»¶eventä¸fdé“¾æ¥çš„å†…éƒ¨æ–‡ä»¶å…³è”èµ·æ¥ã€‚ errno = epollctl(epfd, _EPOLL_CTL_ADD, r, \u0026amp;ev) // r è¢«æ·»åŠ åˆ°epollä¸­ if errno != 0 { println(\u0026#34;runtime: epollctl failed with\u0026#34;, -errno) throw(\u0026#34;runtime: epollctl failed\u0026#34;) } // netpollBreakRdã€netpollBreakWr æ˜¯éé˜»å¡ç®¡é“ä¸¤ç«¯çš„æ–‡ä»¶æè¿°ç¬¦ï¼Œåˆ†åˆ«è¢«ç”¨ä½œè¯»å–ç«¯å’Œå†™å…¥ç«¯ã€‚ // è¯»å–ç«¯ netpollBreakRd è¢«æ·»åŠ åˆ° epoll ä¸­ç›‘å¬ _EPOLLIN äº‹ä»¶ï¼Œåç»­ä»å†™å…¥ç«¯netpollBreakWr // å†™å…¥æ•°æ®å°±èƒ½å”¤é†’é˜»å¡ä¸­çš„ pollerã€‚ netpollBreakRd = uintptr(r) // netpollBreakRdä¿å­˜pip2çš„read netpollBreakWr = uintptr(w) // netpollBreakRdä¿å­˜pip2çš„write } netpollopen() æŠŠè¦ç›‘å¬çš„æ–‡ä»¶æè¿°ç¬¦fdå’Œä¸ä¹‹å…³è”çš„pollDescç»“æ„æ·»åŠ åˆ°pollerå®ä¾‹ä¸­ã€‚ è¯¥æ–¹æ³•å¯¹äºä¸€ä¸ªsocketåªéœ€è°ƒç”¨ä¸€æ¬¡å³å¯ï¼Œè¡¨ç¤ºæ³¨å†Œfdåˆ°epollä¸­ã€‚ å‚æ•°ï¼š fd uintptrï¼šæ–‡ä»¶æè¿°ç¬¦ã€‚ pd *pollDescï¼šç”¨æˆ·æ•°æ®ã€‚ è¿”å›å€¼ï¼šint32ï¼š0-æ³¨å†ŒæˆåŠŸã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 func netpollopen(fd uintptr, pd *pollDesc) int32 { // type epollevent struct { // events uint32 // äº‹ä»¶ç±»å‹ // data [8]byte // å­˜å‚¨ç”¨æˆ·æ•°æ®ï¼Œåˆšå¥½æ˜¯ä¸€ä¸ªæŒ‡é’ˆå­˜å‚¨çš„å¤§å°ï¼Œè¯¥æ•°æ®ç”¨æˆ·æ˜¯å¯ä»¥ä¿®æ”¹çš„ // } var ev epollevent // EPOLLINï¼šè¡¨ç¤ºå¯¹åº”çš„æ–‡ä»¶æè¿°ç¬¦å¯ä»¥è¯»ï¼ˆåŒ…æ‹¬å¯¹ç«¯SOCKETæ­£å¸¸å…³é—­ï¼‰ // EPOLLOUTï¼šè¡¨ç¤ºå¯¹åº”çš„æ–‡ä»¶æè¿°ç¬¦å¯ä»¥å†™ // EPOLLRDHUPï¼šå¯¹ç«¯æè¿°ç¬¦äº§ç”Ÿä¸€ä¸ªæŒ‚æ–­äº‹ä»¶ï¼Œæ¯”å¦‚æ¥è‡ªå¯¹ç«¯çš„socketæŒ‚æ–­äº‹ä»¶ç­‰ // EPOLLETï¼šå°†EPOLLè®¾ä¸ºè¾¹ç¼˜è§¦å‘(Edge Triggered)æ¨¡å¼ï¼Œè¿™æ˜¯ç›¸å¯¹äºæ°´å¹³è§¦å‘(Level Triggered)æ¥è¯´çš„ // pollDescï¼šç±»å‹çš„æ•°æ®ç»“æ„pdä½œä¸ºä¸fdå…³è”çš„è‡ªå®šæ•°æ®ä¼šè¢«ä¸€åŒæ·»åŠ åˆ°epollä¸­ã€‚ ev.events = _EPOLLIN | _EPOLLOUT | _EPOLLRDHUP | _EPOLLET // epollevent æ˜¯ç”±eventså’Œdataç»„æˆï¼Œdataæ¥è‡ªç”¨æˆ·ç©ºé—´ä¼ å…¥çš„æ•°æ® *(**pollDesc)(unsafe.Pointer(\u0026amp;ev.data)) = pd // ev.data = pd // _EPOLL_CTL_ADD å°†ç›®æ ‡æ–‡ä»¶æè¿°ç¬¦fdæ·»åŠ åˆ°epollæè¿°ç¬¦epfdä¸­ï¼Œå¹¶å°†äº‹ä»¶eventä¸fdé“¾æ¥çš„å†…éƒ¨æ–‡ä»¶å…³è”èµ·æ¥ã€‚ return -epollctl(epfd, _EPOLL_CTL_ADD, int32(fd), \u0026amp;ev) } è§¦å‘æ¨¡å¼LT\\ ETï¼š æ°´å¹³è§¦å‘ï¼šLT å¯¹äºè¯»æ“ä½œï¼Œåªè¦ç¼“å†²å†…å®¹ä¸ä¸ºç©ºï¼ŒLTæ¨¡å¼è¿”å›è¯»å°±ç»ªã€‚ å¯¹äºå†™æ“ä½œï¼Œåªè¦ç¼“å†²åŒºè¿˜ä¸æ»¡ï¼ŒLTæ¨¡å¼ä¼šè¿”å›å†™å°±ç»ªã€‚ æ°´å¹³è§¦å‘æè¿°ï¼š å½“è¢«ç›‘æ§çš„æ–‡ä»¶æè¿°ç¬¦ä¸Šæœ‰å¯è¯»å†™äº‹ä»¶å‘ç”Ÿæ—¶ï¼Œepoll_wait()ä¼šé€šçŸ¥å¤„ç†ç¨‹åºå»è¯»å†™ã€‚ å¦‚æœè¿™æ¬¡æ²¡æœ‰æŠŠæ•°æ®ä¸€æ¬¡æ€§å…¨éƒ¨è¯»å†™å®Œ(å¦‚è¯»å†™ç¼“å†²åŒºå¤ªå°)ï¼Œé‚£ä¹ˆä¸‹æ¬¡è°ƒç”¨ epoll_wait()æ—¶ï¼Œå®ƒè¿˜ä¼šé€šçŸ¥ä½ åœ¨ä¸Šæ²¡è¯»å†™å®Œçš„æ–‡ä»¶æè¿°ç¬¦ä¸Šç»§ç»­è¯»å†™ï¼Œå½“ç„¶å¦‚æœä½ ä¸€ç›´ä¸å»è¯»å†™ï¼Œå®ƒä¼šä¸€ç›´é€šçŸ¥ä½ ã€‚ å¦‚æœç³»ç»Ÿä¸­æœ‰å¤§é‡ä½ ä¸éœ€è¦è¯»å†™çš„å°±ç»ªæ–‡ä»¶æè¿°ç¬¦ï¼Œè€Œå®ƒä»¬æ¯æ¬¡éƒ½ä¼šè¿”å›ï¼Œè¿™æ ·ä¼šå¤§å¤§é™ä½å¤„ç†ç¨‹åºæ£€ç´¢è‡ªå·±å…³å¿ƒçš„å°±ç»ªæ–‡ä»¶æè¿°ç¬¦çš„æ•ˆç‡ã€‚ è¾¹ç¼˜è§¦å‘ï¼šET å¯¹äºè¯»æ“ä½œï¼š å½“ç¼“å†²åŒºç”±ä¸å¯è¯»å˜ä¸ºå¯è¯»çš„æ—¶å€™ï¼Œå³ç¼“å†²åŒºç”±ç©ºå˜ä¸ºä¸ç©ºçš„æ—¶å€™ã€‚ å½“æœ‰æ–°æ•°æ®åˆ°è¾¾æ—¶ï¼Œå³ç¼“å†²åŒºä¸­çš„å¾…è¯»æ•°æ®å˜å¤šçš„æ—¶å€™ã€‚ å½“ç¼“å†²åŒºæœ‰æ•°æ®å¯è¯»ï¼Œä¸”åº”ç”¨è¿›ç¨‹å¯¹ç›¸åº”çš„æè¿°ç¬¦è¿›è¡ŒEPOLL_CTL_MODä¿®æ”¹EPOLLINäº‹ä»¶æ—¶ã€‚ å¯¹äºå†™æ“ä½œï¼š å½“ç¼“å†²åŒºç”±ä¸å¯å†™å˜ä¸ºå¯å†™æ—¶ã€‚ å½“æœ‰æ—§æ•°æ®è¢«å‘é€èµ°ï¼Œå³ç¼“å†²åŒºä¸­çš„å†…å®¹å˜å°‘çš„æ—¶å€™ã€‚ å½“ç¼“å†²åŒºæœ‰ç©ºé—´å¯å†™ï¼Œä¸”åº”ç”¨è¿›ç¨‹å¯¹ç›¸åº”çš„æè¿°ç¬¦è¿›è¡ŒEPOLL_CTL_MODä¿®æ”¹EPOLLOUTäº‹ä»¶æ—¶ã€‚ è¾¹ç¼˜è§¦å‘æè¿°ï¼š å½“è¢«ç›‘æ§çš„æ–‡ä»¶æè¿°ç¬¦ä¸Šæœ‰å¯è¯»å†™äº‹ä»¶å‘ç”Ÿæ—¶ï¼Œepoll_wait()ä¼šé€šçŸ¥å¤„ç†ç¨‹åºå»è¯»å†™ã€‚ å¦‚æœè¿™æ¬¡æ²¡æœ‰æŠŠæ•°æ®å…¨éƒ¨è¯»å†™å®Œ(å¦‚è¯»å†™ç¼“å†²åŒºå¤ªå°)ï¼Œé‚£ä¹ˆä¸‹æ¬¡è°ƒç”¨ epoll_wait()æ—¶ï¼Œå®ƒä¸ä¼šé€šçŸ¥ä½ ï¼Œä¹Ÿå°±æ˜¯å®ƒåªä¼šé€šçŸ¥ä½ ä¸€æ¬¡ï¼Œç›´åˆ°è¯¥æ–‡ä»¶æè¿°ç¬¦ä¸Šå‡ºç°ç¬¬äºŒæ¬¡å¯è¯»å†™äº‹ä»¶æ‰ä¼šé€šçŸ¥ä½ ã€‚ è¿™ç§æ¨¡å¼æ¯”æ°´å¹³è§¦å‘æ•ˆç‡é«˜ï¼Œç³»ç»Ÿä¸ä¼šå……æ–¥å¤§é‡ä½ ä¸å…³å¿ƒçš„å°±ç»ªæ–‡ä»¶æè¿°ç¬¦ã€‚ åœ¨ETæ¨¡å¼ä¸‹ï¼Œç¼“å†²åŒºä»ä¸å¯è¯»å˜æˆå¯è¯»ï¼Œä¼šå”¤é†’åº”ç”¨è¿›ç¨‹ï¼Œç¼“å†²åŒºæ•°æ®å˜å°‘çš„æƒ…å†µï¼Œåˆ™ä¸ä¼šå†å”¤é†’åº”ç”¨è¿›ç¨‹ã€‚ ä¸¾ä¾‹ï¼š ä¸¾ä¾‹1ï¼š è¯»ç¼“å†²åŒºåˆšå¼€å§‹æ˜¯ç©ºçš„ è¯»ç¼“å†²åŒºå†™å…¥2KBæ•°æ® æ°´å¹³è§¦å‘å’Œè¾¹ç¼˜è§¦å‘æ¨¡å¼æ­¤æ—¶éƒ½ä¼šå‘å‡ºå¯è¯»ä¿¡å· æ”¶åˆ°ä¿¡å·é€šçŸ¥åï¼Œè¯»å–äº†1KBçš„æ•°æ®ï¼Œè¯»ç¼“å†²åŒºè¿˜å‰©ä½™1KBæ•°æ® æ°´å¹³è§¦å‘ä¼šå†æ¬¡è¿›è¡Œé€šçŸ¥ï¼Œè€Œè¾¹ç¼˜è§¦å‘ä¸ä¼šå†è¿›è¡Œé€šçŸ¥ ä¸¾ä¾‹2ï¼š æ°´å¹³è§¦å‘ï¼š0ä¸ºæ— æ•°æ®ï¼Œ1ä¸ºæœ‰æ•°æ®ã€‚ç¼“å†²åŒºæœ‰æ•°æ®åˆ™ä¸€ç›´ä¸º1ï¼Œåˆ™ä¸€ç›´è§¦å‘ã€‚ è¾¹ç¼˜è§¦å‘ï¼š0ä¸ºæ— æ•°æ®ï¼Œ1ä¸ºæœ‰æ•°æ®ï¼Œåªè¦åœ¨0å˜åˆ°1çš„ä¸Šå‡æ²¿æ‰è§¦å‘ã€‚ netpollclose() æŠŠæ–‡ä»¶æè¿°ç¬¦fdä»pollerå®ä¾‹ä¸­ç§»é™¤ï¼Œä¹Ÿå°±æ˜¯ä»epollä¸­åˆ é™¤ã€‚ 1 2 3 4 5 6 func netpollclose(fd uintptr) int32 { var ev epollevent // _EPOLL_CTL_DEL ä»epollæ–‡ä»¶æè¿°ç¬¦epfdä¸­åˆ é™¤ç›®æ ‡æ–‡ä»¶æè¿°ç¬¦fdã€‚ // è¯¥äº‹ä»¶è¢«å¿½ç•¥ï¼Œå¯ä»¥ä¸ºNULLã€‚ return -epollctl(epfd, _EPOLL_CTL_DEL, int32(fd), \u0026amp;ev)\t} netpollIsPollDescriptor() åˆ¤æ–­æ˜¯å¦æ˜¯é¡¶å±‚pollï¼Œä»¥åŠæ˜¯pip2åˆ›å»ºçš„è¯»å’Œå†™æ–‡ä»¶æè¿°ç¬¦ã€‚ åˆ¤æ–­æ–‡ä»¶æè¿°ç¬¦æ˜¯å¦è¢«pollerä½¿ç”¨ã€‚epfdã€netpollBreakRdã€netpollBreakWrå±äºè¢«pollerä½¿ç”¨çš„æè¿°ç¬¦ã€‚ 1 2 3 func netpollIsPollDescriptor(fd uintptr) bool { return fd == uintptr(epfd) || fd == netpollBreakRd || fd == netpollBreakWr } netpollBreak() ç”¨æ¥å”¤é†’é˜»å¡ä¸­çš„netpollï¼Œå®ƒå®é™…ä¸Šå°±æ˜¯å‘netpollBreakWræè¿°ç¬¦ä¸­å†™å…¥æ•°æ®ï¼Œè¿™æ ·ä¸€æ¥epollå°±ä¼šç›‘å¬åˆ°ã€‚ netpollBreakRdçš„EPOLLINäº‹ä»¶(EPOLLINè¡¨ç¤ºå¯¹åº”çš„æ–‡ä»¶æè¿°ç¬¦å¯ä»¥è¯»ï¼ˆåŒ…æ‹¬å¯¹ç«¯SOCKETæ­£å¸¸å…³é—­ï¼‰)ã€‚netpollBreakä¸­æ–­epollwaitã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 // netpollBreak interrupts an epollwait. func netpollBreak() { // netpollWakeSigä¿¡å·ä¸»è¦ç”¨äºæœ¬è½®å·²ç»é€šçŸ¥è¿‡IOè½®è¯¢ï¼Œä½†æ˜¯è¿˜æ²¡å¤„ç†æœ‰å…¶ä»–çš„è°ƒç”¨æ­¤æ–¹æ³•æ—¶ // ä½¿ç”¨åŸå­æ“ä½œå°†netpollWakeSigç”±0å˜æˆ1ï¼Œè¡¨ç¤ºæ­£åœ¨å”¤é†’epollã€‚ if atomic.Cas(\u0026amp;netpollWakeSig, 0, 1) {\tfor { var b byte // å‘netpollBreakWrä¸­å†™å…¥æ•°æ®ï¼Œä¼šå¯¼è‡´é‚£äº›é˜»å¡åœ¨netpollå‡½æ•°ä¸­çš„çº¿ç¨‹ç›´æ¥è¿”å›å»æ‰§è¡Œåé¢ä»£ç  // netpollBreakWråœ¨pipe2å‡½æ•°ä¸­æ³¨å†Œæ—¶å·²ç»è®¾ç½®äº†éé˜»å¡ã€‚å› æ­¤è¿™é‡Œä¸ä¼šé˜»å¡ã€‚ n := write(netpollBreakWr, unsafe.Pointer(\u0026amp;b), 1) // å†™å…¥æˆåŠŸ if n == 1 { break } // åœ¨å†™å…¥ä»»ä½•æ•°æ®ä¹‹å‰ï¼Œè°ƒç”¨è¢«ä¿¡å·ä¸­æ–­ã€‚ if n == -_EINTR { continue // é‡è¯•ã€‚ } // å·²ä½¿ç”¨ O_NONBLOCK é€‰æ‹©äº†éé˜»å¡ I/Oï¼Œå¹¶ä¸”å†™å…¥å°†é˜»å¡ã€‚ // _EAGAINï¼šè¡¨ç¤ºç›®å‰æ²¡æœ‰å¯ç”¨çš„æ•°æ® if n == -_EAGAIN { return } println(\u0026#34;runtime: netpollBreak write failed with\u0026#34;, -n) throw(\u0026#34;runtime: netpollBreak write failed\u0026#34;) } } } netpoll() netpollæ£€æŸ¥å‡†å¤‡å°±ç»ªçš„ç½‘ç»œè¿æ¥ã€‚è¿”å›å¯è¿è¡Œçš„goroutineåˆ—è¡¨ã€‚ å‚æ•°ï¼š delay \u0026lt; 0ï¼šæ— é™æœŸé˜»å¡ã€‚ delay == 0ï¼šä¸é˜»å¡ï¼Œç«‹å³è¿”å›ã€‚ delay \u0026gt; 0ï¼šé˜»å¡é•¿è¾¾delayçº³ç§’ã€‚ è¿”å›å€¼ï¼šgListï¼šä¸€ç»„å°±ç»ªçš„goroutineã€‚ æ ¹æ®å…¥å‚delayè®¾ç½®è°ƒç”¨epoll_waitçš„timeoutå€¼ï¼Œè°ƒç”¨epoll_waitä»epollçš„eventpoll.rdlliståŒå‘åˆ—è¡¨ä¸­è·å–IOå°±ç»ªçš„fdåˆ—è¡¨ï¼Œéå†epoll_waitè¿”å›çš„fdåˆ—è¡¨ï¼Œ æ ¹æ®è°ƒç”¨epoll_ctlæ³¨å†Œfdæ—¶å°è£…çš„ä¸Šä¸‹æ–‡ä¿¡æ¯ç»„è£…å¯è¿è¡Œçš„goroutineå¹¶è¿”å›ã€‚ æ‰§è¡Œå®Œnetpollä¹‹åï¼Œä¼šè¿”å›ä¸€ä¸ªå°±ç»ªfdåˆ—è¡¨å¯¹åº”çš„goroutineåˆ—è¡¨ï¼Œæ¥ä¸‹æ¥å°†å°±ç»ªçš„goroutineåŠ å…¥åˆ°è°ƒåº¦é˜Ÿåˆ—ä¸­ï¼Œç­‰å¾…è°ƒåº¦è¿è¡Œã€‚ netpollçš„è°ƒç”¨æ—¶æœºï¼š åœ¨è°ƒåº¦å™¨ä¸­æ‰§è¡Œruntime.schedule()ï¼Œè¯¥æ–¹æ³•ä¸­ä¼šæ‰§è¡Œruntime.findrunnable()å‡½æ•°ä¸­è°ƒç”¨äº†runtime.netpollè·å–å¾…æ‰§è¡Œçš„goroutineã€‚ Go runtimeåœ¨ç¨‹åºå¯åŠ¨çš„æ—¶å€™ä¼šåˆ›å»ºä¸€ä¸ªç‹¬ç«‹çš„sysmonç›‘æ§çº¿ç¨‹ï¼Œsysmonæ¯20us~10msè¿è¡Œä¸€æ¬¡ï¼Œæ¯æ¬¡è¿è¡Œä¼šæ£€æŸ¥è·ç¦»ä¸Šä¸€æ¬¡æ‰§è¡Œnetpollæ˜¯å¦è¶…è¿‡10msï¼Œå¦‚æœæ˜¯åˆ™ä¼šè°ƒç”¨ä¸€æ¬¡runtime.netpollã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 // netpoll checks for ready network connections. // Returns list of goroutines that become runnable. // // delay \u0026lt; 0: blocks indefinitely;\t// delay == 0: does not block, just polls; // delay \u0026gt; 0: block for up to that many nanoseconds; func netpoll(delay int64) gList { // 1) epollæ²¡æœ‰åˆå§‹åŒ– if epfd == -1 {\treturn gList{} } // 2) ä¸‹é¢æŠŠçº³ç§’çº§çš„ delay è½¬æ¢æˆæ¯«ç§’çº§çš„ waitmsã€‚ var waitms int32 if delay \u0026lt; 0 { waitms = -1 // æ°¸ä¹…é˜»å¡ï¼Œç›´åˆ°äº‹ä»¶å°±ç»ªè¿”å› } else if delay == 0 { waitms = 0 // ä¸é˜»å¡ï¼Œç«‹å³è¿”å› } else if delay \u0026lt; 1e6 { // å°äº1æ¯«ç§’ï¼Œä¿®æ”¹ä¸ºé˜»å¡1æ¯«ç§’ waitms = 1 // é˜»å¡1æ¯«ç§’ } else if delay \u0026lt; 1e15 { // å°äº 11.5 day // 1e6 è¡¨ç¤º 1æ¯«ç§’ waitms = int32(delay / 1e6) // é˜»å¡æŒ‡å®šæ¯«ç§’ } else { // An arbitrary cap on how long to wait for a timer. // 1e9 ms == ~11.5 days. waitms = 1e9 // æœ€é•¿ 11.5å¤© } // 3) é€šè¿‡epollwaitå‡½æ•°ç­‰å¾…IOäº‹ä»¶ï¼Œç¼“å†²åŒºå¤§å°ä¸º128ä¸ªepolleventã€‚ // è¶…æ—¶æ—¶é—´æ˜¯ waitms æ¯«ç§’ã€‚å¦‚æœ epollwaitå‡½æ•°è¢«ä¸­æ–­æ‰“æ–­ï¼Œå°±é€šè¿‡gotoæ¥é‡è¯•ã€‚ // waitms å¤§äº0æ—¶ä¸ä¼šé‡è¯•ï¼Œå› ä¸ºéœ€è¦è¿”å›è°ƒç”¨è€…ä¸­å»é‡æ–°è®¡ç®—è¶…æ—¶æ—¶é—´ã€‚ // ä¸‹é¢ä¼ å…¥epollwaitçš„æ•°é‡æ˜¯128ï¼Œè¡¨ç¤ºä¸€æ¬¡æœ€å¤§å°±ç»ª128ä¸ªäº‹ä»¶ // è¿™æ ·å¯èƒ½å­˜åœ¨æ­¤æ¬¡å¤§äº128æ•°é‡æ—¶ï¼Œéœ€è¦ç­‰åˆ°ä¸‹ä¸€ä¸ªIOè½®è¯¢æ—¶é—´çª—å£ // type epollevent struct { // events uint32 // äº‹ä»¶ç±»å‹ // data [8]byte // å­˜å‚¨ç”¨æˆ·æ•°æ®ï¼Œåˆšå¥½æ˜¯ä¸€ä¸ªæŒ‡é’ˆå­˜å‚¨çš„å¤§å°ï¼Œè¯¥æ•°æ®ç”¨æˆ·æ˜¯å¯ä»¥ä¿®æ”¹çš„ // } var events [128]epollevent // ç”¨äºå­˜å‚¨å·²ç»å‡†å¤‡å¥½çš„æè¿°ç¬¦çš„äº‹ä»¶æ•°æ® retry: // è°ƒç”¨epollwaitç­‰å¾…æ–‡ä»¶æè¿°ç¬¦è½¬æ¢æˆå¯å†™æˆ–å¯è¯»ï¼Œå¦‚æœæ²¡æœ‰epollwaitä¼šé˜»å¡ n := epollwait(epfd, \u0026amp;events[0], int32(len(events)), waitms) // è¿”å›æ´»è·ƒçš„æ•°é‡n if n \u0026lt; 0 { // EBADFï¼šepfd ä¸æ˜¯æœ‰æ•ˆçš„æ–‡ä»¶æè¿°ç¬¦ã€‚ // EFAULTï¼šäº‹ä»¶æŒ‡å‘çš„å†…å­˜åŒºåŸŸæ— æ³•ç”¨å†™æƒé™è®¿é—®ã€‚ // EINVALï¼šepfd ä¸æ˜¯epollæ–‡ä»¶æè¿°ç¬¦ï¼Œæˆ–è€…maxevents(ç¬¬ä¸‰ä¸ªå‚æ•°)å°äºç­‰äº0ã€‚ if n != -_EINTR { // EINTR è¢«CPUä¸­æ–­ println(\u0026#34;runtime: epollwait on fd\u0026#34;, epfd, \u0026#34;failed with\u0026#34;, -n) throw(\u0026#34;runtime: netpoll failed\u0026#34;) } // If a timed sleep was interrupted, just return to // recalculate how long we should sleep now. // // å¦‚æœå®šæ—¶ç¡çœ è¢«ä¸­æ–­ï¼Œåªéœ€è¿”å›é‡æ–°è®¡ç®—æˆ‘ä»¬ç°åœ¨åº”è¯¥ç¡å¤šä¹…ã€‚ // _EINTR: åœ¨ä»»ä½•è¯·æ±‚çš„äº‹ä»¶å‘ç”Ÿæˆ–è¶…æ—¶åˆ°æœŸä¹‹å‰ï¼Œè¯¥è°ƒç”¨è¢«ä¿¡å·å¤„ç†ç¨‹åºä¸­æ–­ã€‚ if waitms \u0026gt; 0 { return gList{} } // è¢«ä¸­æ–­ AND waitms \u0026lt;= 0 æƒ…å†µé‡è¯• goto retry } // type gList struct { head guintptr } var toRun gList // æ„å‘³ç€è¢«ç›‘æ§çš„æ–‡ä»¶æè¿°ç¬¦å‡ºç°äº†å¾…å¤„ç†çš„äº‹ä»¶ for i := int32(0); i \u0026lt; n; i++ { // å°±ç»ªçš„IOäº‹ä»¶é›† ev := \u0026amp;events[i] // å½“å‰å°±ç»ªæè¿°ç¬¦æ²¡æœ‰äº‹ä»¶ç±»å‹ï¼Œç›´æ¥è·³è¿‡ if ev.events == 0 { continue } // äº‹ä»¶æ¥æºæ˜¯å¦æ˜¯netpollBreakRdï¼Œè¯¥æè¿°ç¬¦æ¥ä¹‹pipe2å‡½æ•°åˆ›å»º // æ¥è‡ªpipe2å‡½æ•°åˆ›å»ºçš„é€šä¿¡ï¼ŒnetpollBreakRdæ˜¯LTæ°´å¹³è§¦å‘å¦‚æœä¸è¯»å–ä¼šä¸€ç›´è§¦å‘ // è¯¥äº‹ä»¶æ¥è‡ª netpollBreak() æ–¹æ³•ï¼Œè¯¥æ–¹æ³•åªä¼šåœ¨åˆ›å»ºtimeræ—¶å’ŒfindRunnable()å‡½æ•°ä¸­è¢«è°ƒç”¨ã€‚ if *(**uintptr)(unsafe.Pointer(\u0026amp;ev.data)) == \u0026amp;netpollBreakRd { // å¯¹äºæ–‡ä»¶æè¿°ç¬¦ netpollBreakRd è€Œè¨€ï¼Œåªæœ‰ _EPOLLIN äº‹ä»¶æ˜¯æ­£å¸¸çš„ï¼Œå…¶ä»–éƒ½ä¼šè¢«è§†ä¸ºå¼‚å¸¸ã€‚ if ev.events != _EPOLLIN { println(\u0026#34;runtime: netpoll: break fd ready for\u0026#34;, ev.events) throw(\u0026#34;runtime: netpoll: break fd ready for something unexpected\u0026#34;) } // è¿™ç§æƒ…å†µä¸‹åªå¤„ç†ä¸æ˜¯ç«‹å³è¿”å›æƒ…å†µä¸‹ï¼Œå¦‚æœæ˜¯ç«‹å³è¿”å›æƒ…å†µæ—¶ï¼Œæ•°æ®å¹¶æœªè¢«è¯»å–ï¼Œä¸‹æ¬¡è¿˜ä¼šè§¦å‘è¯¥ä¿¡å· // è¿™ç§æƒ…å†µä¸‹åªåœ¨runtime.findrunnable()å‡½æ•°ä¸­å­˜åœ¨ï¼Œçº¿ç¨‹åœ¨å¯»æ‰¾gæ— æœæ—¶ï¼Œæœ€ååªèƒ½åœ¨IOè½®è¯¢å¤„ç­‰å¾… // åªæœ‰åœ¨ delay ä¸ä¸º0ï¼Œä¹Ÿå°±æ˜¯é˜»å¡å¼netpollæ—¶ï¼Œæ‰è¯»å–netpollBreakRdä¸­çš„æ•°æ®ã€‚ if delay != 0 { // netpollBreakRd çš„æœ¬æ„ä¹Ÿæ˜¯åªå”¤é†’delay != 0çš„netpollï¼Œå› ä¸ºè¿™äº›åœ¨é˜»å¡éœ€è¦è¿”å› // netpollBreak could be picked up by a // nonblocking poll. Only read the byte // if blocking. // netpollBreak å¯ä»¥é€šè¿‡éé˜»å¡è½®è¯¢æ¥è·å–ã€‚ ä»…åœ¨é˜»å¡æ—¶è¯»å–å­—èŠ‚ã€‚ var tmp [16]byte // æŠŠå†™å…¥çš„æ•°æ®è¯»å–è®©ç¼“å­˜åŒºä¸ºç©º read(int32(netpollBreakRd), noescape(unsafe.Pointer(\u0026amp;tmp[0])), int32(len(tmp)))\t// å°†netpollWakeSigç”±1å˜æˆ0ï¼Œè¡¨ç¤ºå½“å‰äº‹ä»¶å·²è¢«è¯»å– atomic.Store(\u0026amp;netpollWakeSig, 0)\t} continue } // æ ¹æ®epollè¿”å›çš„IOäº‹ä»¶æ ‡å¿—ä½ä¸ºmodeèµ‹å€¼ // r è¡¨ç¤ºå¯è¯»ï¼Œw è¡¨ç¤ºå¯å†™ï¼Œr+w è¡¨ç¤ºæ—¢å¯è¯»åˆå¯å†™ã€‚ // æ£€æµ‹IOäº‹ä»¶ä¸­çš„é”™è¯¯æ ‡å¿—ä½ï¼Œå¹¶ç›¸åº”çš„ä¸ºpd.everrèµ‹å€¼ã€‚ // åˆ¤æ–­å‘ç”Ÿçš„äº‹ä»¶ç±»å‹,è¯»ç±»å‹æˆ–è€…å†™ç±»å‹ var mode int32\t// å­˜å‚¨å½“å‰ç±»å‹ // EPOLLIN ï¼šè¡¨ç¤ºå¯¹åº”çš„æ–‡ä»¶æè¿°ç¬¦å¯ä»¥è¯»ï¼ˆåŒ…æ‹¬å¯¹ç«¯SOCKETæ­£å¸¸å…³é—­ï¼‰ // EPOLLRDHUPï¼šå¯¹ç«¯æè¿°ç¬¦äº§ç”Ÿä¸€ä¸ªæŒ‚æ–­äº‹ä»¶ // EPOLLHUPï¼šæœ¬ç«¯æè¿°ç¬¦äº§ç”Ÿä¸€ä¸ªæŒ‚æ–­äº‹ä»¶ï¼Œé»˜è®¤ç›‘æµ‹äº‹ä»¶ // EPOLLERRï¼šè¡¨ç¤ºå¯¹åº”çš„æ–‡ä»¶æè¿°ç¬¦å‘ç”Ÿé”™è¯¯ if ev.events\u0026amp;(_EPOLLIN|_EPOLLRDHUP|_EPOLLHUP|_EPOLLERR) != 0 { mode += \u0026#39;r\u0026#39; } // EPOLLOUTï¼šè¡¨ç¤ºå¯¹åº”çš„æ–‡ä»¶æè¿°ç¬¦å¯ä»¥å†™ // EPOLLHUPï¼šæœ¬ç«¯æè¿°ç¬¦äº§ç”Ÿä¸€ä¸ªæŒ‚æ–­äº‹ä»¶ï¼Œé»˜è®¤ç›‘æµ‹äº‹ä»¶ // EPOLLERRï¼šè¡¨ç¤ºå¯¹åº”çš„æ–‡ä»¶æè¿°ç¬¦å‘ç”Ÿé”™è¯¯ if ev.events\u0026amp;(_EPOLLOUT|_EPOLLHUP|_EPOLLERR) != 0 { mode += \u0026#39;w\u0026#39; } // modeä¸ä¸º0ï¼Œè¡¨ç¤ºæœ‰IOäº‹ä»¶ï¼Œéœ€è¦ä»ev.dataå­—æ®µå¾—åˆ°ä¸IOäº‹ä»¶å…³è”çš„pollDescã€‚ if mode != 0 { // å–å‡ºä¿å­˜åœ¨ epollevent é‡Œçš„pollDescï¼Œå› ä¸ºè¦æ ¹æ®è¿™ä¸ªå†…å®¹å»æ¢å¤gå¦‚æœgå·²è¢«æŒ‚èµ·æ—¶ pd := *(**pollDesc)(unsafe.Pointer(\u0026amp;ev.data)) // *pollDesc // å¯¹åº”çš„_EPOLLERRæ–‡ä»¶æè¿°ç¬¦å‡ºç°é”™è¯¯æ—¶ï¼Œæ ‡è®°é”™è¯¯ pd.setEventErr(ev.events == _EPOLLERR)\t// è®¾ç½®pollDescçš„EpollErré”™è¯¯ä½ï¼Œå¦‚æœæ˜¯è¿™ç§çŠ¶æ€ netpollready(\u0026amp;toRun, pd, mode)\t// å¤„ç†å°±ç»ªçš„æè¿°ç¬¦ } } return toRun } netpollready() go1.19.3/src/runtime/runtime/netpoll.goã€‚ netpollreadyç”±ç‰¹å®šäºå¹³å°çš„netpollå‡½æ•°è°ƒç”¨ã€‚å®ƒå£°æ˜ä¸pdç›¸å…³çš„fdå·²ç»ä¸ºI/Oåšå¥½äº†å‡†å¤‡ã€‚ toRunå‚æ•°ç”¨äºæ„å»ºä¸€ä¸ªä»netpollè¿”å›çš„goroutinesåˆ—è¡¨ã€‚modeå‚æ•°æ˜¯'r'ã€'w'æˆ–'r'+'w'ï¼Œè¡¨ç¤ºfdæ˜¯å¦å‡†å¤‡å¥½è¯»ã€å†™æˆ–åŒæ—¶è¯»å’Œå†™ã€‚ è¿™å¯èƒ½ä¼šåœ¨æ•´ä¸ªç³»ç»Ÿåœæ­¢æ—¶è¿è¡Œï¼Œå› æ­¤ä¸å…è®¸è®¾ç½®å†™å±éšœã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 // netpollready is called by the platform-specific netpoll function. // It declares that the fd associated with pd is ready for I/O. // The toRun argument is used to build a list of goroutines to return // from netpoll. The mode argument is \u0026#39;r\u0026#39;, \u0026#39;w\u0026#39;, or \u0026#39;r\u0026#39;+\u0026#39;w\u0026#39; to indicate // whether the fd is ready for reading or writing or both. // // This may run while the world is stopped, so write barriers are not allowed. //go:nowritebarrier func netpollready(toRun *gList, pd *pollDesc, mode int32) { var rg, wg *g if mode == \u0026#39;r\u0026#39; || mode == \u0026#39;r\u0026#39;+\u0026#39;w\u0026#39; { // netpollunblock å¯èƒ½è¿”å› goroutine æˆ– nil rg = netpollunblock(pd, \u0026#39;r\u0026#39;, true) } if mode == \u0026#39;w\u0026#39; || mode == \u0026#39;r\u0026#39;+\u0026#39;w\u0026#39; { wg = netpollunblock(pd, \u0026#39;w\u0026#39;, true) } if rg != nil { // å¹¶å…¥ toRun ä¸­ï¼Œè¿™éƒ¨åˆ† goroutine ç­‰å¾…æ”¾å…¥è°ƒåº¦æ± ä¸­ toRun.push(rg) } if wg != nil { toRun.push(wg) } } netpollunblock() go1.19.3/src/runtime/runtime/netpoll.goã€‚ netpollunblockè§£é™¤é˜»å¡ã€‚ å‚æ•°ï¼š pd *pollDescï¼špollDescã€‚ mode int32ï¼šè¯»ræˆ–å†™wã€‚ ioready boolï¼štrue-I/Oè¯»ï¼ˆç”¨äºä»pollDescä¸­è·å– goroutineï¼‰ï¼Œfalse-è¯»å†™è¶…æ—¶ä»pollDescä¸­è·å–goroutineã€‚ è¿”å›å€¼ï¼š*gè¿”å›å°±ç»ªçš„goroutineï¼Œå¯èƒ½æ˜¯nilã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 func netpollunblock(pd *pollDesc, mode int32, ioready bool) *g { // æ ¹æ® mode ä»rgæˆ–wgå–å‡º goroutineã€‚ gpp := \u0026amp;pd.rg if mode == \u0026#39;w\u0026#39; { gpp = \u0026amp;pd.wg } for { // åŸå­è¯»å– old := gpp.Load() // pdReadyï¼šè¡¨ç¤ºfdçš„æ•°æ®å·²ç»å°±ç»ªï¼Œå¯ä¾›è¯»å–æˆ–å†™ã€‚è¯¥å€¼ä»gä¿®æ”¹pdReadyã€‚ // è¿™ç§æƒ…å†µå¯èƒ½ goroutine å·²ç»è¢«è¿”å›ç»™è°ƒç”¨è€…äº†ã€‚ä»€ä¹ˆéƒ½ä¸åšç›´æ¥è¿”å›ã€‚ if old == pdReady { return nil } // nilï¼šæ²¡æœ‰ä»€ä¹ˆå¯åšçš„ if old == 0 \u0026amp;\u0026amp; !ioready { // Only set pdReady for ioready. runtime_pollWait // will check for timeout/cancel before waiting. // // åªåœ¨ioreadyä¸­è®¾ç½®pdReadyã€‚runtime_pollWaitå°†åœ¨ç­‰å¾…ä¹‹å‰æ£€æŸ¥ timeout/cancelã€‚ return nil } // oldæ˜¯0ã€goroutineã€pdWaitè¿™ä¸‰ç§æƒ…å†µã€‚ var new uintptr if ioready { // ä¿®æ”¹ä¸ºpdReadyï¼Œè¡¨ç¤ºæ•°æ®å·²å°±ç»ªæˆ–å†™ new = pdReady } // CAS äº¤æ¢ if gpp.CompareAndSwap(old, new) { // pdWaitï¼šè¡¨ç¤ºæŸä¸ªgoroutineå³å°†æŒ‚èµ·å¹¶ç­‰å¾…fdçš„å¯è¯»å¯å†™äº‹ä»¶ã€‚ if old == pdWait { old = 0 // nil } return (*g)(unsafe.Pointer(old)) // nil æˆ– *g } } } wakeNetPoller() è¯¥å‡½æ•°åœ¨timeæºç ä¸­è¢«è°ƒç”¨ï¼Œç”¨äºåˆ¤æ–­æ˜¯å¦éœ€è¦å‘èµ·I/Oç½‘ç»œè½®è¯¢ã€‚ è¯¥æ–¹æ³•æ˜¯ä¸ºäº†é˜²æ­¢å®šæ—¶å™¨è§¦å‘æ—¶é—´åˆ°äº†æ²¡æœ‰çº¿ç¨‹èƒ½è§¦å‘çš„æƒ…å†µï¼Œå½“åªå‰©é˜»å¡åœ¨netpollçš„çº¿ç¨‹æˆ–æ‰€æœ‰çš„çº¿ç¨‹éƒ½å¤„äºç­‰å¾…ä¸­æ—¶ï¼Œtimerå¯èƒ½ä¸èƒ½æŒ‰æ—¶è§¦å‘çš„æƒ…å†µã€‚ wakeenetpollerå”¤é†’åœ¨ç½‘ç»œè½®è¯¢å™¨(network poller)ä¸­ç¡çœ çš„çº¿ç¨‹ï¼Œå¦‚æœå®ƒä¸æ‰“ç®—åœ¨whenå‚æ•°ä¹‹å‰è¢«å”¤é†’; æˆ–è€…å”¤é†’ä¸€ä¸ªç©ºé—²çš„Pæ¥æœåŠ¡è®¡æ—¶å™¨(timers)å’Œç½‘ç»œè½®è¯¢å™¨(network poller)(å¦‚æœè¿˜æ²¡æœ‰çš„è¯)ã€‚ when int64ï¼šè¡¨ç¤ºæœ€è¿‘çš„timerè§¦å‘çš„æ—¶é—´ç‚¹ï¼Œå› æ­¤ä¸ºäº†é¿å…å½“å‰æœ€è¿‘çš„timeråˆ°æ—¶é—´èƒ½å‡†æ—¶è§¦å‘ï¼Œéœ€è¦è°ƒæ•´netpollçš„é˜»å¡äº‹ä»¶ç‚¹ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 // wakeNetPoller wakes up the thread sleeping in the network poller if it isn\u0026#39;t // going to wake up before the when argument; or it wakes an idle P to service // timers and the network poller if there isn\u0026#39;t one already. func wakeNetPoller(when int64) { // sched.lastpollï¼šè®°å½•çš„æ˜¯ä¸Šæ¬¡æ‰§è¡Œnetpollçš„æ—¶é—´ï¼Œå¦‚æœç­‰äº0ï¼Œåˆ™è¡¨ç¤ºæŸä¸ªçº¿ç¨‹æ­£åœ¨é˜»å¡å¼åœ°æ‰§è¡Œnetpollã€‚ // sched.lastpoll è¢«è®¾ç½®ä¸º0åªä¼šåœ¨ findrunnable å‡½æ•°ä¸­ã€‚ if atomic.Load64(\u0026amp;sched.lastpoll) == 0 { // In findrunnable we ensure that when polling the pollUntil // field is either zero or the time to which the current // poll is expected to run. This can have a spurious wakeup // but should never miss a wakeup. // // åœ¨ findrunnable ä¸­ï¼Œæˆ‘ä»¬è¦ç¡®ä¿è½®è¯¢æ—¶ pollUntil å­—æ®µè¦ä¹ˆæ˜¯0ï¼Œè¦ä¹ˆä¸ºå½“å‰pollé¢„æœŸè¿è¡Œçš„æ—¶é—´ã€‚ // è¿™é‡Œå¯èƒ½ä¼šæ˜¯ä¸€ä¸ªè™šå‡çš„å”¤é†’ï¼Œä½†ä¸åº”è¯¥é”™è¿‡å”¤é†’ã€‚ // sched.pollUntilï¼šè¡¨ç¤ºé˜»å¡å¼åœ°netpollå°†åœ¨ä½•æ—¶è¢«å”¤é†’ã€‚è¯¥å€¼åœ¨ findrunnable å‡½æ•°ä¸­è¢«è®¾ç½®ã€‚ // sched.pollUntil å€¼å¤§äº0æ—¶ï¼Œè¡¨ç¤ºæœ€è¿‘çš„timerè§¦å‘æ—¶é—´æ®µã€‚ pollerPollUntil := int64(atomic.Load64(\u0026amp;sched.pollUntil)) // pollerPollUntil \u0026gt; whenï¼šå­˜åœ¨æœ€æ–°çš„è®¡æ—¶å™¨è¢«åŠ å…¥whenæ—¶é—´æ®µåè§¦å‘ if pollerPollUntil == 0 || pollerPollUntil \u0026gt; when { netpollBreak() } } else { // There are no threads in the network poller, try to get // one there so it can handle new timers. if GOOS != \u0026#34;plan9\u0026#34; { // Temporary workaround - see issue #42303. wakep() // å°è¯•å”¤é†’ä¸€ä¸ªç©ºé—²çš„Pèµ·æ¥æœåŠ¡timerå’Œnetwork pollerã€‚ } } } netpollarm() è¯¥å‡½æ•°åœ¨linuxä¸Šä¸ä¼šè°ƒç”¨ï¼Œå……å½“ä¸€ä¸ªå ä½ä½œç”¨ã€‚ 1 2 3 func netpollarm(pd *pollDesc, mode int) { throw(\u0026#34;runtime: unused\u0026#34;) // runtime: æœªä½¿ç”¨çš„ } å‚è€ƒ è¯¦è§£Goè¯­è¨€I/Oå¤šè·¯å¤ç”¨netpolleræ¨¡å‹ epollè¯¦è§£ epollæºç è§£æ(1) epoll_create ","permalink":"https://heliu.site/posts/golang/netpoll/epoll/","summary":"Golang å°è£…çš„åº•å±‚epollä»£ç ã€‚","title":"Golang epoll"},{"content":" ğŸ”¥å¦‚æœè§‰å¾—æˆ‘çš„æ–‡ç« å¯¹æ‚¨æœ‰ç”¨ï¼Œå¸®æˆ‘ä¹°æ¯â˜•ã€‚æ‚¨çš„æ”¯æŒå°†é¼“åŠ±æˆ‘ç»§ç»­åˆ›ä½œã€‚ğŸ‰ğŸ‰ğŸ‰\nwechat alipay ","permalink":"https://heliu.site/support/","summary":" ğŸ”¥å¦‚æœè§‰å¾—æˆ‘çš„æ–‡ç« å¯¹æ‚¨æœ‰ç”¨ï¼Œå¸®æˆ‘ä¹°æ¯â˜•ã€‚æ‚¨çš„æ”¯æŒå°†é¼“åŠ±æˆ‘ç»§ç»­åˆ›ä½œã€‚ğŸ‰ğŸ‰ğŸ‰\nwechat alipay ","title":"æ‰“èµ"}]