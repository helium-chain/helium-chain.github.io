[{"content":" æœ¬ç¯‡åšå®¢ä¸»è¦ä»‹ç» golang ä¸­æ•°ç»„çš„å®šä¹‰åŠåŸºæœ¬ä½¿ç”¨ æœ‰å…³æ•°ç»„çš„å†…å­˜å¸ƒå±€åŠå…ƒæ•°æ®ç»“æ„å°†åœ¨æ•°ç»„çš„ç¬¬äºŒç¯‡ä¸­ä»‹ç» æœ¬ç‰‡æ–‡ç« å¯èƒ½æ¶‰åŠåˆ°æ•°ç»„å¤–çš„å…¶ä»–çŸ¥è¯†ï¼Œä¸ç†Ÿæ‚‰çš„è¯·å¿½ç•¥ï¼Œé‡ç‚¹å…³æ³¨æ•°ç»„ä½¿ç”¨ æœ¬åšå®¢ä¸»è¦æ˜¯ä½œè€…çš„å­¦ä¹ ç¬”è®°ï¼Œå¦‚é‡åˆ°é”™è¯¯è¯·æŒ‡æ­£ 1. æ•°ç»„çš„å®šä¹‰ ğŸš€ æ•°ç»„æ˜¯å…·æœ‰ç›¸åŒå”¯ä¸€ç±»å‹çš„ä¸€ç»„å·²ç¼–ç ä¸”é•¿åº¦å›ºå®šçš„æ•°æ®é¡¹åºåˆ—ã€‚ è¿™æ˜¯ä¸€ç§åŒæ„çš„æ•°æ®ç»“æ„ï¼Œè¿™ç§ç±»å‹å¯ä»¥æ˜¯ä»»æ„çš„åŸºç¡€ç±»å‹ï¼Œå¦‚æ•´å‹ã€å­—ç¬¦ä¸²æˆ–è‡ªå®šä¹‰ç±»å‹ã€‚ æ•°ç»„é•¿åº¦å¿…é¡»æ˜¯ä¸€ä¸ªå¸¸é‡è¡¨è¾¾å¼ï¼ˆç¼–è¯‘æœŸé—´èƒ½ç¡®å®šçš„å€¼ï¼‰ï¼Œå¹¶ä¸”æ˜¯ä¸€ä¸ªéè´Ÿæ•°ã€‚ æ•°ç»„çš„é•¿åº¦ä¹Ÿæ˜¯æ•°ç»„ç±»å‹çš„ä¸€éƒ¨åˆ†ï¼Œ[5]intå’Œ[10]intæ˜¯å±äºä¸åŒç±»å‹ã€‚ å¦‚æœæƒ³è®©æ•°ç»„å…ƒç´ ï¼Œç±»å‹ä¸ºä»»æ„ç±»å‹ï¼Œå¯ä»¥ä½¿ç”¨ç©ºæ¥å£interface{}ä½œä¸ºç±»å‹ï¼Œä½†ä½¿ç”¨æ—¶ï¼Œå¿…é¡»å…ˆåšä¸€ä¸ªç±»å‹åˆ¤æ–­ã€‚ è®¿é—®è¶Šç•Œï¼Œå¦‚æœä¸‹æ ‡åœ¨æ•°ç»„åˆæ³•èŒƒå›´ä¹‹å¤–ï¼Œåˆ™è§¦å‘è®¿é—®è¶Šç•Œï¼Œä¼španicã€‚ æ•°ç»„æ˜¯å€¼ç±»å‹ï¼Œèµ‹å€¼å’Œä¼ å‚ä¼šå¤åˆ¶æ•´ä¸ªæ•°ç»„ï¼Œè€Œä¸æ˜¯æŒ‡é’ˆã€‚å› æ­¤æ”¹å˜å‰¯æœ¬çš„å€¼ï¼Œä¸ä¼šæ”¹å˜æœ¬èº«çš„å€¼ã€‚ åªæ”¯æŒ \u0026ldquo;==\u0026quot;ã€\u0026rdquo;!=\u0026quot; æ“ä½œç¬¦ã€‚ï¼ˆä¸æ”¯æŒ \u0026ldquo;\u0026gt;\u0026quot;ã€\u0026quot;\u0026lt;\u0026quot;ã€\u0026quot;\u0026gt;=\u0026quot;ã€\u0026quot;\u0026lt;=\u0026quot;ï¼ŒåŸå› æ˜¯å¤§äºã€å°äºå¯¹äºæ•°ç»„æ¥è¯´æ²¡å•¥æ„ä¹‰ï¼Œæˆ‘ä»¬ä¹Ÿä¸ä¼šæ¯”è¾ƒä¸¤ä¸ªæ•°ç»„è°å¤§è°å°ï¼‰ æŒ‡é’ˆæ•°ç»„ [n]*Tï¼Œæ•°ç»„æŒ‡é’ˆ *[n]Tã€‚ 1.1 æ•°ç»„å…ƒç´ ä¸ºç©ºæ¥å£ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;unsafe\u0026#34; ) func main() { // æ•°ç»„ a æ‰€å å†…å­˜ 16 * 5 = 80 å­—èŠ‚ var a [5]interface{} = [5]interface{}{1, \u0026#34;hello\u0026#34;, false, 0.23, 2i} // ç©ºæ¥å£çš„ç»“æ„æ„é€ ï¼Œtype eface struct {typ *_type, data uintptr} fmt.Printf(\u0026#34;æ•°ç»„aå ç”¨å†…å­˜çš„å¤§å°%d\\n\u0026#34;, unsafe.Sizeof(a))\t// æ•°ç»„aå ç”¨å†…å­˜çš„å¤§å°80 5*(8+8) // [5]interface {}{1, \u0026#34;hello\u0026#34;, false, 0.23, (0+2i)} fmt.Printf(\u0026#34;%#v\\n\u0026#34;, a) // è¿™é‡Œéå†å¯ä»¥æ”¹æˆéå† \u0026amp;aï¼Œè¿™æ ·é¿å…äº†å¤§æ•°ç»„çš„å¤åˆ¶ // å˜é‡æŒ‡é’ˆæ•°ç»„æ˜¯Goçš„è¯­æ³•ç³– for i, v := range a { // ã€int, anyã€‘ fmt.Printf(\u0026#34;i:%d v:%#v t:%T\\n\u0026#34;, i , v, v) // å¿…é¡»è¦åšæ–­è¨€æ‰èƒ½ä½¿ç”¨ï¼Œç©ºæ¥å£.(å…·ä½“ç±»å‹) if ii, ok := v.(int); ok { fmt.Println(ii + 10) } } // Output: // æ•°ç»„aå ç”¨å†…å­˜çš„å¤§å°80 // [5]interface {}{1, \u0026#34;hello\u0026#34;, false, 0.23, (0+2i)} // i:0 v:1 t:int // 11 // i:1 v:\u0026#34;hello\u0026#34; t:string // i:2 v:false t:bool // i:3 v:0.23 t:float64 // i:4 v:(0+2i) t:complex128 } 1.2 æŒ‡é’ˆæ•°ç»„å’Œæ•°ç»„æŒ‡é’ˆ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 package main import \u0026#34;fmt\u0026#34; func main() { // 1. æŒ‡é’ˆæ•°ç»„ï¼Œæ•°ç»„çš„å…ƒç´ æ˜¯æŒ‡é’ˆç±»å‹ var p1 [2]*int = [2]*int{} // [2]*int{nil, nil} fmt.Println(p1) var a int = 5 p1[1] = \u0026amp;a fmt.Println(p1) // Output: // [\u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt;] // [\u0026lt;nil\u0026gt; 0xc00000e0b8] // 2. æ•°ç»„æŒ‡é’ˆ var p2 *[2]int fmt.Println(p2) a1 := [2]int{1, 2} p2 = \u0026amp;a1 fmt.Printf(\u0026#34;%#v\u0026#34;, p2) // Output // \u0026lt;nil\u0026gt; // \u0026amp;[2]int{1, 2} } 1.3 æ•°ç»„å’Œæ•°ç»„æŒ‡é’ˆ åœ¨Goä¸­æ•°ç»„å’Œæ•°ç»„æŒ‡é’ˆçš„ç”¨æ³•åŸºæœ¬ä¸€è‡´ï¼Œèƒ½éå†ï¼ˆrangeï¼‰ã€èµ‹å€¼ã€å–å€¼ã€æ±‚é•¿åº¦ç­‰ï¼Œè¿™æ˜¯ç”±äºæ•°ç»„æŒ‡é’ˆæ“ä½œæ—¶å­˜åœ¨è¯­æ³•ç³–æ”¯æŒã€‚ åˆ‡ç‰‡(slice)åˆ™ä¸å…è®¸è¿™æ ·æ“ä½œï¼Œåªæœ‰æ•°ç»„æ˜¯ç‰¹æœ‰çš„ï¼Œä¸ºå•¥æ•°ç»„æ”¯æŒéå†æ•°ç»„åœ°å€ï¼Œå¾ˆå¤§åŸå› æ˜¯å¤§æ•°æ®æ•°ç»„éå†çš„æ‹·è´å¼€é”€æ¯”è¾ƒå¤§ï¼Œé‡‡ç”¨æŒ‡é’ˆå½¢å¼åˆ™ä¸éœ€è¦æ‹·è´ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 { // *[5]int a1 := new([5]int) // 1) è¯­æ³•ç³–ï¼š (*a1)[0] = 12 a1[0] = 12\t// 2) è¯­æ³•ç³–ï¼š c := (*a1)[1] c := a1[1]\t// 3) è¯­æ³•ç³–ï¼š l := len(*a1) l := len(a1)\t// éå†a1ï¼Œè¿™æ˜¯ç”±äºä¸Šé¢ä¸¤ä¸ªè¯­æ³•ç³–(2)(3)çš„æ”¯æŒ for i := range a1 { // ã€int, intã€‘ } } 2. æ•°ç»„çš„å£°æ˜ä¸ä½¿ç”¨ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 // 1) æŒ‡å®šç´¢å¼• var a = [5]string{3:\u0026#34;hello\u0026#34;, \u0026#34;world\u0026#34;} // [5]string{\u0026#34;\u0026#34;, \u0026#34;\u0026#34;, \u0026#34;\u0026#34;, \u0026#34;hello\u0026#34;, \u0026#34;world\u0026#34;} fmt.Printf(\u0026#34;%#v\\n\u0026#34;, a) // 2) ... åªèƒ½ç”¨åœ¨æœ€å¤–å±‚æ•°ç»„ // ... çš„ç”¨æ³• // 1. ç”¨äºæ•°ç»„å£°æ˜çš„æœ€å¤–å±‚æ•°ç»„ï¼Œè‡ªåŠ¨ç»Ÿè®¡æ•°ç»„é•¿åº¦ã€‚ // 2. ç”¨ä½œå‡½æ•°çš„æœ€åä¸€ä¸ªå‚æ•°ï¼Œ...T è¡¨ç¤ºå¯å˜å‚æ•° []T åˆ‡ç‰‡å½¢å¼ã€‚ // 3. ç”¨ä½œåˆ‡ç‰‡å []T... è¡¨ç¤ºè§£å¼•ç”¨ã€‚ã€append([]int{1,2}, []int{3,4,5}...)ã€‘ // 4. åªæœ‰åœ¨ã€append([]byte(\u0026#34;hello \u0026#34;), \u0026#34;world\u0026#34;...)ã€‘æ—¶å¯ä»¥ä½¿ç”¨ ã€string...ã€‘ å½¢å¼å…¶ä»–åœ°æ–¹ä¸è¢«å…è®¸ã€‚ // slice = append(slice, elem1, elem2) // slice = append(slice, anotherSlice...) // slice = append([]byte(\u0026#34;hello \u0026#34;), \u0026#34;world\u0026#34;...) // ... ä½œä¸ºè§£å¼•ç”¨æ—¶ï¼Œåªèƒ½ç”¨åœ¨Sliceå’Œstringä¸­ var b = [...]string{3:\u0026#34;hello\u0026#34;, \u0026#34;world\u0026#34;} // [5]string{\u0026#34;\u0026#34;, \u0026#34;\u0026#34;, \u0026#34;\u0026#34;, \u0026#34;hello\u0026#34;, \u0026#34;world\u0026#34;} fmt.Printf(\u0026#34;%#v\\n\u0026#34;, b) // 3) é»˜è®¤å€¼ï¼Œæ³¨æ„ä¸æ˜¯ç©ºæ•°ç»„ï¼Œæ•°ç»„ä¸å­˜åœ¨ç©ºæ•°ç»„æ¦‚å¿µï¼Œæ•°ç»„ä¸­ä¸€å®šæ˜¯å­˜åœ¨å€¼çš„å³ä½¿æ˜¯é»˜è®¤å€¼ var c [2]uint8\t// [2]uint8{0, 0} // Output: // [5]string{\u0026#34;\u0026#34;, \u0026#34;\u0026#34;, \u0026#34;\u0026#34;, \u0026#34;hello\u0026#34;, \u0026#34;world\u0026#34;} // [5]string{\u0026#34;\u0026#34;, \u0026#34;\u0026#34;, \u0026#34;\u0026#34;, \u0026#34;hello\u0026#34;, \u0026#34;world\u0026#34;} 2.1 ä¸€ç»´æ•°ç»„æˆ–å¤šç»´æ•°ç»„ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 package main import ( \u0026#34;fmt\u0026#34; ) func main() { // 1. å¸¸ç”¨åˆå§‹åŒ– var arrAge = [5]int{15,16,15,18,17}\t// [5]int{15,16,15,18,17}\t// 2. æŒ‡å®šç´¢å¼•ä½ç½®çš„åˆå§‹åŒ– var arrName = [5]string{3:\u0026#34;Chris\u0026#34;, 4:\u0026#34;Ron\u0026#34;}\t// [5]string{\u0026#34;\u0026#34;,\u0026#34;\u0026#34;,\u0026#34;\u0026#34;,\u0026#34;Chris\u0026#34;, \u0026#34;Ron\u0026#34;} var arrCount = [4]int{500, 2:100}\t// [4]int{500,0,100,0} // 3. æ•°ç»„é•¿åº¦åˆå§‹åŒ–æ ¹æ®å…ƒç´ å¤šå°‘å†³å®š var arrLazy = [...]int{5,6,7,8,23}\t// [5]int{5,6,7,8,23}\tvar arrPack = [...]int{10,5:100}\t// [6]int{10,0,0,0,0,100} // 4. ä¸æŒ‡å®šé»˜è®¤å€¼ var arrRoom [20]int\t// [20]int{0,0,0,...} // 5. ä½¿ç”¨newå‡½æ•° var arrBed = new([20]int)\t// *[20]int{0,0,0,...} // 6. æ•°ç»„ç±»å‹æ˜¯ç»“æ„ä½“ d := [...]struct{ name string\t// å 16å­—èŠ‚ age uint8\t// å 1å­—èŠ‚ å†…å­˜å¯¹é½å å 8å­—èŠ‚ }{ {\u0026#34;user1\u0026#34;, 10}, {\u0026#34;user2\u0026#34;, 20},\t// åˆ«å¿˜äº†æœ€åä¸€è¡Œçš„é€—å·ï¼Œè¿™æ˜¯ç”±äºGOè¯­æ³•è§£æ } fmt.Println(unsafe.Sizeof(d))\t// 48 = (16+8) * 2 fmt.Printf(\u0026#34;arrAge:%#v arrAge:Type:%T\\n\u0026#34;, arrAge, arrAge) fmt.Printf(\u0026#34;arrName:%#v arrName:Type:%T\\n\u0026#34;, arrName, arrName) fmt.Printf(\u0026#34;arrCount:%#v arrCount:Type:%T\\n\u0026#34;, arrCount, arrCount) fmt.Printf(\u0026#34;arrLazy:%#v arrLazy:Type:%T\\n\u0026#34;, arrLazy, arrLazy) fmt.Printf(\u0026#34;arrPack:%#v arrPack:Type:%T\\n\u0026#34;, arrPack, arrPack) fmt.Printf(\u0026#34;arrRoom:%#v arrRoom:Type:%T\\n\u0026#34;, arrRoom, arrRoom) fmt.Printf(\u0026#34;arrBed:%#v arrBed:Type:%T\\n\u0026#34;, arrBed, arrBed) fmt.Printf(\u0026#34;d:%#v d:Type:%T\\n\u0026#34;, d, d) } /* * arrAge:[5]int{15, 16, 15, 18, 17} arrAge:Type:[5]int * arrName:[5]string{\u0026#34;\u0026#34;, \u0026#34;\u0026#34;, \u0026#34;\u0026#34;, \u0026#34;Chris\u0026#34;, \u0026#34;Ron\u0026#34;} arrName:Type:[5]string * arrCount:[4]int{500, 0, 100, 0} arrCount:Type:[4]int * arrLazy:[5]int{5, 6, 7, 8, 23} arrLazy:Type:[5]int * arrPack:[6]int{10, 0, 0, 0, 0, 100} arrPack:Type:[6]int * arrRoom:[20]int{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0} arrRoom:Type:[20]int * arrBed:\u0026amp;[20]int{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0} arrBed:Type:*[20]int * d: * [2]struct { name string; age uint8 } * { * struct { name string; age uint8 }{name:\u0026#34;user1\u0026#34;, age:0xa}, * struct { name string; age uint8 }{name:\u0026#34;user2\u0026#34;, age:0x14} * } * d:Type: * [2]struct { name string; age uint8 } */ Goè¯­è¨€ä¸­æ•°ç»„æ˜¯ä¸€ç§å€¼ç±»å‹ï¼ˆä¸åƒC/C++ä¸­æ˜¯æŒ‡å‘é¦–å…ƒç´ çš„æŒ‡é’ˆï¼‰ï¼Œæ‰€ä»¥å¯ä»¥é€šè¿‡new()æ¥åˆ›å»ºã€‚ // ç”³è¯· 5 * 8 byteå†…å­˜ var arr1 = new([5]int)\t// *[5]int ä½¿ç”¨new([5]int)åˆ›å»ºå’Œvar arr2 [5]intçš„åŒºåˆ«ï¼Œarr1çš„ç±»å‹æ˜¯ *[5]intï¼Œè€Œarr2çš„ç±»å‹æ˜¯[5]intã€‚ ","permalink":"http://localhost:1313/posts/golang/array/array/","summary":"æ•°ç»„çš„å®šä¹‰åŠåŸºç¡€ä½¿ç”¨ã€‚","title":"æ•°ç»„(ä¸€)"},{"content":"Golang è½¯ä»¶å®‰è£… é¦–å…ˆéœ€è¦ä¸‹è½½Goè¯­è¨€å®‰è£…åŒ… ä¸‹è½½åœ°å€ä¸ºï¼ˆä¸­å›½å¤§é™†å¯èƒ½è®¿é—®ä¸åˆ°ï¼‰ï¼šhttps://golang.org/dl/ å›½å†…ä¸‹è½½åœ°å€ï¼šhttps://golang.google.cn/dl/ å®˜æ–¹å®‰è£…æ•™ç¨‹ï¼šhttps://golang.google.cn/doc/installï¼Œå®˜æ–¹çš„å®‰è£…æ•™ç¨‹å·²å¾ˆè¯¦ç»†ï¼ˆhttps://golang.google.cn/docï¼‰ æºç ç¼–è¯‘å®‰è£…(Linux) UNIX/Linux/Mac OSå’ŒFreeBSDç³»ç»Ÿå¯ä»¥ä½¿ç”¨å¦‚ä¸‹æºç å®‰è£…æ–¹æ³•ã€‚ä»¥ä¸‹ç¤ºä¾‹Linuxå®‰è£… Macç³»ç»Ÿä¸‹å¯ä»¥ä½¿ç”¨ä»¥.pkgä¸ºæ‰©å±•åçš„å®‰è£…åŒ…ç›´æ¥åŒå‡»æ¥å®Œæˆå®‰è£…ï¼Œå®‰è£…ç›®å½•åœ¨/usr/local/go/ä¸‹ã€‚ Linuxå®‰è£…golangæ­¥éª¤ ä¸‹è½½å®‰è£…åŒ… wget https://golang.google.cn/dl/go1.17.3.linux-amd64.tar.gzï¼ˆæ›¿æ¢ä½ çš„ç‰ˆæœ¬ï¼‰ 32-bit Linux ä¸‹è½½å®‰è£…åŒ… https://golang.google.cn/dl/go1.17.3.linux-386.tar.gz 64-bit Linux ä¸‹è½½å®‰è£…åŒ… https://golang.google.cn/dl/go1.17.3.linux-amd64.tar.gz åˆ é™¤è€ç‰ˆæœ¬ï¼ˆå¦‚æœå­˜åœ¨åˆ™æ‰§è¡Œï¼Œä¸å­˜åœ¨åˆ™å¿½ç•¥ï¼‰ rm -rf /usr/local/go è§£å‹å®‰è£…åŒ… sudo tar -xzf go1.17.3.linux-amd64.tar.gz -C /usr/local é…ç½®ç¯å¢ƒå˜é‡ï¼šä½¿ç”¨go env -wå‘½ä»¤ä¸€èˆ¬åªæ˜¯æœ¬æ¬¡ç”Ÿæ•ˆ PATH ç¯å¢ƒå˜é‡ export PATH=$PATH:/usr/local/go/bin GoLangå·¥å…·ä½ç½®ï¼ŒåŒ…å«goã€gofmtå·¥å…· GOROOT å˜é‡ export GOROOT=/usr/local/go GoLangå®‰è£…åŒ…ä½ç½® ä½¿ç”¨ go env -w GOROOT=/usr/local/goé…ç½®ä¹Ÿæ˜¯å¯ä»¥çš„ GOPATH å˜é‡ export GOPATH=/var/local/go GoLang 1.11 ç‰ˆæœ¬å‰é¡¹ç›®ç®¡ç†åŒ…ä½ç½® ä½¿ç”¨go env -w GOPATH=/var/local/goé…ç½®ä¹Ÿæ˜¯å¯ä»¥çš„ æ‰“å°Goç‰ˆæœ¬å· go version å¦‚æœä¸Šé¢(ç¬¬4æ­¥)ç¯å¢ƒå˜é‡é…ç½®ä¸æˆåŠŸï¼Œé‚£ä¹ˆæ‰§è¡Œå¦‚ä¸‹æ­¥éª¤é…ç½®ï¼š sudo vim ~/.bashrcå‘½ä»¤æ‰“å¼€æ–‡ä»¶ åœ¨æ–‡ä»¶æœ€åæ·»åŠ ï¼š 1 2 3 4 5 6 7 export GOROOT=/usr/local/go export GOPATH=/var/local/go export PATH=$PATH:$GOROOT/bin:$GOPATH/bin export GOPROXY=\u0026#34;https://goproxy.cn,direct\u0026#34; # åœ¨linuxä¸­è®¾ç½®ä¸´æ—¶ç›®å½•ï¼Œwindowsä¸ç”¨ export TMPDIR=/tmp æœ€åä½¿é…ç½®ç”Ÿæ•ˆ source ~/.bashrc Windows å®‰è£… ä¸‹è½½ https://golang.google.cn/dl/go1.17.3.windows-amd64.zipï¼Œç›´æ¥è§£å‹åˆ°å®‰è£…ç›®å½•ï¼Œå¦‚D:\\Goï¼Œç„¶åæŠŠD:\\Go\\binç›®å½•æ·»åŠ åˆ°PATHç¯å¢ƒå˜é‡ä¸­ã€‚ è®¾ç½®GOPATHå’ŒGOROOTç¯å¢ƒå˜é‡ï¼š GOPATH=D:\\goproject GOROOT=D:\\GO\\ ä¹Ÿå¯ä»¥é€‰æ‹©https://golang.google.cn/dl/go1.17.3.windows-amd64.msiï¼ŒåŒå‡»è¿è¡Œç¨‹åºï¼Œæ ¹æ®æç¤ºæ¥æ“ä½œå®‰è£…ã€‚ GOROOTã€GOPATH GOROOT GOROOTï¼šGoè½¯ä»¶çš„å®‰è£…åŒ…ç»å¯¹è·¯å¾„ï¼Œé»˜è®¤æ˜¯/usr/local/go GOPATH $GOPATHå…è®¸æœ‰å¤šä¸ªç›®å½•ï¼Œå½“æœ‰å¤šä¸ªç›®å½•æ—¶ï¼Œè¯·æ³¨æ„åˆ†éš”ç¬¦ï¼ŒWindowsä¸­çš„åˆ†éš”ç¬¦æ˜¯åˆ†å·(;)ã€‚å½“æœ‰å¤šä¸ªç›®å½•æ—¶é»˜è®¤å°†go getå‘½ä»¤è·å–çš„åŒ…å­˜æ”¾åœ¨ç¬¬ä¸€ä¸ªç›®å½•ä¸‹ï¼Œå½“åœ¨GOPATHæ¨¡å¼ä¸‹è¿è¡Œæ—¶æ˜¯è¿™æ ·å¤„ç†çš„ $GOPATHç›®å½•ä¸‹çº¦å®šæœ‰ä¸‰ä¸ªå­ç›®å½•ï¼š srcç›®å½•ï¼šå­˜æ”¾æºä»£ç ï¼ˆå¦‚.goï¼Œ.cï¼Œ.hï¼Œ.sç­‰æ–‡ä»¶ï¼‰ã€‚æŒ‰ç…§Goé»˜è®¤çº¦å®šï¼Œsrcç›®å½•æ˜¯go runï¼Œgo installç­‰å‘½ä»¤çš„å½“å‰å·¥ä½œè·¯å¾„ï¼ˆå³åœ¨æ­¤è·¯å¾„ä¸‹æ‰§è¡Œä¸Šè¿°å‘½ä»¤ï¼‰ã€‚srcä¹Ÿæ˜¯ç”¨æˆ·ä»£ç å­˜æ”¾çš„ä¸»è¦ç›®å½•ï¼Œæ‰€æœ‰çš„æºä»£ç éƒ½å­˜æ”¾åœ¨è¿™ä¸ªç›®å½•ä¸‹é¢ï¼Œä¸€èˆ¬ä¸€ä¸ªé¡¹ç›®å’Œä¸€ä¸ªç›®å½•å¯¹åº”ã€‚ï¼ˆå½“åœ¨GOPATHæ¨¡å¼ä¸‹è¿è¡Œæ—¶æ˜¯è¿™æ ·å¤„ç†çš„ï¼Œä½†æ˜¯Goå®˜æ–¹åœ¨Go 1.11ç‰ˆæœ¬åä¸å†æ¨èä½¿ç”¨GOPATHæ¨¡å¼ç¼–å†™Goä»£ç ï¼Œå› æ­¤srcç›®å½•æ— ç”¨å¤„ï¼‰ pkgç›®å½•ï¼šå­˜æ”¾ç¼–è¯‘æ—¶ç”Ÿæˆçš„ä¸­é—´æ–‡ä»¶ï¼ˆæ¯”å¦‚ï¼š.aï¼‰ binç›®å½•ï¼šå­˜æ”¾ç¼–è¯‘åç”Ÿæˆçš„å¯æ‰§è¡Œæ–‡ä»¶ï¼Œæ¯”å¦‚åé¢å®‰è£…çš„delveæ’ä»¶æˆ–å¤šç‰ˆæœ¬goè½¯ä»¶å°±æ˜¯åœ¨è¿™ä¸ªç›®å½•é‡Œ ç®¡ç†Goå®‰è£… å®‰è£…å¤šä¸ªGoç‰ˆæœ¬ åœ¨åŒä¸€å°æœºå™¨ä¸Šå®‰è£…å¤šä¸ªGoç‰ˆæœ¬ã€‚ä¾‹å¦‚ï¼Œæˆ‘ä»¬å¯èƒ½å¸Œæœ›åœ¨å¤šä¸ªGoç‰ˆæœ¬ä¸Šæµ‹è¯•ä»£ç ã€‚ æ³¨æ„ï¼šéœ€è¦ä½¿ç”¨è¿™ç§å½¢å¼å®‰è£…éœ€è¦å…ˆå®‰è£…git å¤šç‰ˆæœ¬goå®‰è£…æ­¥éª¤ è¦å®‰è£…å…¶ä»–Goç‰ˆæœ¬ï¼Œè¿è¡Œgo installå‘½ä»¤ï¼ŒæŒ‡å®šè¦å®‰è£…çš„ç‰ˆæœ¬çš„ä¸‹è½½ä½ç½®ã€‚å¦‚ä¸‹ç¤ºä¾‹å®‰è£…ç‰ˆæœ¬1.10.7ï¼š go install golang.org/dl/go1.10.7@latest è¿™é‡Œä½¿ç”¨go installç¼–è¯‘å¹¶å®‰è£…æŒ‡å®šçš„åŒ…æ¥å®ç°å¤šç‰ˆæœ¬goå®‰è£ï¼Œç”Ÿæˆåçš„å¯æ‰§è¡Œæ–‡ä»¶åœ¨binç›®å½•ä¸‹ï¼ˆ$GOPATH/binï¼‰ go1.10.7 downloadä¸‹è½½ï¼Œéœ€è¦åˆ‡æ¢åˆ°$GOPATH/binä¸‹å»æ‰§è¡Œï¼Œç”Ÿæˆçš„å®‰è£…è·¯å¾„åœ¨/root/sdk/go1.10.7 1 2 $ go install golang.org/dl/go1.10.7@latest # å®‰è£…å¹¶ç¼–è¯‘go1.10.7ç‰ˆæœ¬ $ go1.10.7 download è¦ä½¿ç”¨æ–°ä¸‹è½½çš„ç‰ˆæœ¬è¿è¡Œå‘½ä»¤ï¼Œå¦‚ä¸‹æ‰€ç¤ºï¼š 1 2 $ go1.10.7 version go version go1.10.7 linux/amd64 å½“ä½ å®‰è£…äº†å¤šä¸ªç‰ˆæœ¬æ—¶ï¼Œå¯ä»¥ä½¿ç”¨å¦‚ä¸‹å‘½ä»¤æŸ¥çœ‹æ¯ä¸ªç‰ˆæœ¬çš„å®‰è£…ä½ç½®ï¼š 1 $ go1.10.7 env GOROOT è¦å¸è½½ä¸‹è½½çš„ç‰ˆæœ¬æ—¶ï¼Œåªéœ€è¦åˆ é™¤å…¶ç”±GOROOTç¯å¢ƒå˜é‡å’Œgo.X.Y.ZäºŒè¿›åˆ¶æ–‡ä»¶æŒ‡å®šçš„å®‰è£…ç›®å½•å³å¯ å¸è½½Go ä½¿ç”¨å¦‚ä¸‹æ‰€æè¿°çš„æ­¥éª¤ä»ç³»ç»Ÿä¸­åˆ é™¤Go Linux / macOS / FreeBSD åˆ é™¤goç›®å½•ï¼šé€šå¸¸æ˜¯/usr/local/goç›®å½•ã€‚ ä»PATHç¯å¢ƒå˜é‡ä¸­åˆ é™¤Go binç›®å½•ã€‚ åœ¨Linuxå’ŒFreeBSDä¸‹ï¼Œç¼–è¾‘/etc/profileæˆ–$HOME/.profileã€‚ å¦‚æœæ‚¨ä½¿ç”¨macOSè½¯ä»¶åŒ…å®‰è£…äº†Goï¼Œè¯·åˆ é™¤/etc/paths.d/goæ–‡ä»¶ã€‚ Windows åˆ é™¤Goçš„æœ€ç®€å•æ–¹æ³•æ˜¯é€šè¿‡Windowsæ§åˆ¶é¢æ¿ä¸­çš„ Add/Remove ç¨‹åºï¼š åœ¨æ§åˆ¶é¢æ¿ä¸­ï¼ŒåŒå‡» Add/Remove ç¨‹åºã€‚ åœ¨ Add/Remove ç¨‹åºä¸­ï¼Œé€‰æ‹©è¦å¸è½½çš„è½¯ä»¶ï¼Œå•å‡»å¸è½½ï¼Œç„¶åæŒ‰ç…§æç¤ºè¿›è¡Œæ“ä½œã€‚ è¦ä½¿ç”¨å·¥å…·åˆ é™¤Goï¼Œæ‚¨è¿˜å¯ä»¥ä½¿ç”¨å‘½ä»¤è¡Œï¼š é€šè¿‡è¿è¡Œä»¥ä¸‹å‘½ä»¤ä½¿ç”¨å‘½ä»¤è¡Œå¸è½½ï¼šmsiexec /x go{{version}}.windows-{{cpu-arch}}.msi /q æ³¨æ„ï¼šå¯¹ Windows ä½¿ç”¨æ­¤å¸è½½è¿‡ç¨‹å°†è‡ªåŠ¨åˆ é™¤ç”±åŸå§‹å®‰è£…åˆ›å»ºçš„ Windows ç¯å¢ƒå˜é‡ã€‚ ","permalink":"http://localhost:1313/posts/golang/install/install/","summary":"Go è½¯ä»¶å®‰è£…ã€‚","title":"Install Golang"},{"content":"type Pool struct Pool æ˜¯ä¸€ç»„å¯ä»¥å•ç‹¬ä¿å­˜å’Œæ£€ç´¢çš„ä¸´æ—¶å¯¹è±¡ã€‚ å‚¨å­˜åœ¨ Pool ä¸­çš„ä»»ä½•ç‰©å“éƒ½å¯ä»¥åœ¨ä»»ä½•æ—¶é—´è‡ªåŠ¨ç§»é™¤ï¼Œæ— éœ€é€šçŸ¥ã€‚å¦‚æœåœ¨æ­¤å‘ç”Ÿæ—¶ Pool æŒæœ‰å”¯ä¸€çš„å¼•ç”¨ï¼Œåˆ™å¯èƒ½ä¼šé‡Šæ”¾è¯¥å…ƒç´ ã€‚ Pool å¯ä»¥è¢«å¤šä¸ªgoroutinesåŒæ—¶ä½¿ç”¨ã€‚ Pool's çš„ç›®çš„æ˜¯ç¼“å­˜å·²åˆ†é…ä½†æœªä½¿ç”¨çš„é¡¹ï¼Œä»¥ä¾¿ä»¥åé‡ç”¨ï¼Œå‡è½»åƒåœ¾æ”¶é›†å™¨çš„å‹åŠ›ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œå®ƒä½¿æ„å»ºé«˜æ•ˆçš„ã€çº¿ç¨‹å®‰å…¨çš„ç©ºé—²åˆ—è¡¨å˜å¾—å®¹æ˜“ã€‚ä½†å®ƒå¹¶ä¸é€‚ç”¨äºæ‰€æœ‰ç©ºé—²é“¾è¡¨ã€‚ Pool çš„é€‚å½“ä½¿ç”¨æ˜¯ç®¡ç†ä¸€ç»„åœ¨åŒ…çš„å¹¶å‘ç‹¬ç«‹å®¢æˆ·ç«¯ä¹‹é—´å…±äº«å’Œå¯èƒ½è¢«é‡ç”¨çš„ä¸´æ—¶é¡¹ã€‚Pool æä¾›äº†ä¸€ç§åœ¨å¤šä¸ªå®¢æˆ·ç«¯ä¹‹é—´æ‘Šé”€åˆ†é…å¼€é”€çš„æ–¹æ³•ã€‚ ä¸€ä¸ªè‰¯å¥½ä½¿ç”¨ Pool çš„ä¾‹å­æ˜¯fmtåŒ…ï¼Œå®ƒç»´æŠ¤äº†ä¸€ä¸ªåŠ¨æ€å¤§å°çš„ä¸´æ—¶è¾“å‡ºç¼“å†²åŒºå­˜å‚¨ã€‚storeåœ¨è´Ÿè½½ä¸‹æ‰©å±•(å½“è®¸å¤šgoroutinesæ­£åœ¨ç§¯ææ‰“å°æ—¶)ï¼Œåœ¨é™é»˜æ—¶æ”¶ç¼©ã€‚ å¦ä¸€æ–¹é¢ï¼Œä½œä¸ºç”Ÿå­˜æœŸè¾ƒçŸ­çš„å¯¹è±¡çš„ä¸€éƒ¨åˆ†ç»´æŠ¤çš„ç©ºé—²åˆ—è¡¨ä¸é€‚åˆç”¨äº Poolï¼Œå› ä¸ºåœ¨è¿™ç§æƒ…å†µä¸‹å¼€é”€ä¸èƒ½å¾ˆå¥½åœ°åˆ†æ‘Šã€‚ åœ¨ç¬¬ä¸€æ¬¡ä½¿ç”¨åï¼Œä¸èƒ½å¤åˆ¶æ± ã€‚ sync.Pool æ˜¯åç¨‹å®‰å…¨çš„ï¼Œä½¿ç”¨å‰ï¼Œè®¾ç½®å¥½å¯¹è±¡çš„ New å‡½æ•°ï¼Œç”¨åœ¨ Pool é‡Œæ²¡æœ‰ç¼“å­˜çš„å¯¹è±¡æ—¶ï¼Œåˆ›å»ºä¸€ä¸ªã€‚ä¹‹ååœ¨ç¨‹åºçš„ä»»ä½•åœ°æ–¹ã€ä»»ä½•æ—¶å€™ä»…é€šè¿‡ Get() å’Œ Put() æ–¹æ³•å°±å¯ä»¥å–å’Œè¿˜å¯¹è±¡äº† 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 // A Pool is a set of temporary objects that may be individually saved and // retrieved. // // Any item stored in the Pool may be removed automatically at any time without // notification. If the Pool holds the only reference when this happens, the // item might be deallocated. // // A Pool is safe for use by multiple goroutines simultaneously. // // Pool\u0026#39;s purpose is to cache allocated but unused items for later reuse, // relieving pressure on the garbage collector. That is, it makes it easy to // build efficient, thread-safe free lists. However, it is not suitable for all // free lists. // // An appropriate use of a Pool is to manage a group of temporary items // silently shared among and potentially reused by concurrent independent // clients of a package. Pool provides a way to amortize allocation overhead // across many clients. // // An example of good use of a Pool is in the fmt package, which maintains a // dynamically-sized store of temporary output buffers. The store scales under // load (when many goroutines are actively printing) and shrinks when // quiescent. // // On the other hand, a free list maintained as part of a short-lived object is // not a suitable use for a Pool, since the overhead does not amortize well in // that scenario. It is more efficient to have such objects implement their own // free list. // // A Pool must not be copied after first use. type Pool struct { // ä½¿å¾—å†…åµŒäº†noCopyçš„å¯¹è±¡åœ¨è¿›è¡Œgo veté™æ€æ£€æŸ¥çš„æ—¶å€™ï¼Œå¯ä»¥æ£€æŸ¥å‡ºæ˜¯å¦è¢«å¤åˆ¶ noCopy noCopy // è®¿é—®æ—¶æ ¹æ®Pçš„idå»è®¿é—®å¯¹åº”ä¸‹æ ‡çš„local[pid] // é€šè¿‡è¿™æ ·çš„è®¾è®¡ï¼Œå¤šä¸ªgoroutineä½¿ç”¨åŒä¸€ä¸ªPoolæ—¶ï¼Œå‡å°‘äº†ç«äº‰ï¼Œæå‡äº†æ€§èƒ½ // localå­—æ®µæŒ‡å‘å­˜å‚¨[P]poolloaclæ•°ç»„çš„æŒ‡é’ˆï¼Œç±»å‹ä¸º[P]poolLocal // // local æ˜¯ [P]poolLocal æ•°ç»„çš„é¦–åœ°å€ // P æ˜¯å½“å‰Pçš„æ•°é‡ï¼Œä¸€èˆ¬é»˜è®¤ä¸ºCPUçš„æ ¸æ•° local unsafe.Pointer // local fixed-size per-P pool, actual type is [P]poolLocal // localSize æ˜¯ä¸Šé¢ local æ•°ç»„çš„å¤§å° // æ ¹æ® localSize åˆ¤æ–­æ˜¯å¦åˆå§‹åŒ–ï¼Œpidä¸ºPçš„idæ”¹å€¼æ˜¯ä¸€ä¸ª0çš„é€’å¢å€¼ // 1. localSize ä¸º0æ—¶ï¼Œæ²¡æœ‰åˆå§‹åŒ– // 2. localSize \u0026lt;= pid æ—¶ï¼Œå¯èƒ½æ˜¯æ²¡æœ‰åˆå§‹åŒ–ï¼Œä¹Ÿå¯èƒ½æ˜¯Pçš„æ•°é‡å‘ç”Ÿäº†å˜åŒ–ï¼Œå˜å¤šäº† localSize uintptr // size of the local array // victim å’Œ victimSize ä½œä¸ºæ¬¡çº§ç¼“å­˜ä½¿ç”¨ï¼ŒGCæ—¶å°†å¯¹è±¡æ”¾å…¥å…¶ä¸­ï¼Œä¸‹ä¸€æ¬¡GCæ¥ä¸´ä¹‹å‰å¦‚æœæœ‰Getè°ƒç”¨åˆ™ä¼šä»p.victimä¸­å–ï¼Œç›´åˆ°å†ä¸€æ¬¡GCæ¥æ—¶å›æ”¶ // ä» p.victim ä¸­å–å‡ºå¯¹è±¡ä½¿ç”¨å®Œæ¯•ä¹‹åå¹¶æœªè¿”å› p.victim ä¸­ï¼ˆè€Œæ˜¯æ”¾å›p.localï¼‰ä¸­ï¼Œåœ¨ä¸€å®šç¨‹åº¦ä¸Šä¹Ÿå‡å°äº†ä¸‹ä¸€æ¬¡GCçš„å¼€é”€ // åŸæ¥1æ¬¡GCçš„å¼€é”€è¢«æ‹‰é•¿åˆ°2æ¬¡åˆ‡ä¼šæœ‰ä¸€å®šç¨‹åº¦çš„å¼€é”€å‡å°ï¼Œè¿™å°±æ˜¯ p.victim å¼•å…¥çš„æ„å›¾ // victim å’Œ victimSize ä¼šåœ¨ä¸€è½®GCåˆ°æ¥æ—¶ï¼Œåˆ†åˆ«\u0026#34;æ¥ç®¡\u0026#34; local å’Œ localSize // victim çš„æœºåˆ¶ç”¨äºå‡å°‘GCåå†·å¯åŠ¨å¯¼è‡´çš„æ€§èƒ½æŠ–åŠ¨ï¼Œè®©åˆ†é…å¯¹è±¡æ›´å¹³æ»‘ // sync.Pool å¼•å…¥çš„æ„å›¾åœ¨äºé™ä½GCå‹åŠ›çš„åŒæ—¶æé«˜å‘½ä¸­ç‡ victim unsafe.Pointer // local from previous cycle æ¥è‡ªä¸Šä¸€ä¸ªå‘¨æœŸçš„local victimSize uintptr // size of victims array\tæ¥è‡ªä¸Šä¸€ä¸ªå‘¨æœŸçš„localçš„å¤§å° // New optionally specifies a function to generate // a value when Get would otherwise return nil. // It may not be changed concurrently with calls to Get. // // Newå¯é€‰åœ°æŒ‡å®šä¸€ä¸ªå‡½æ•°ï¼Œç”¨äºåœ¨Getè¿”å›nilæ—¶ç”Ÿæˆä¸€ä¸ªå€¼ã€‚ // å®ƒä¸èƒ½åœ¨è°ƒç”¨Getæ—¶åŒæ—¶æ”¹å˜ã€‚ New func() any\t// æˆ‘ä»¬æŒ‡å®šçš„æ–°å»ºå¯¹è±¡çš„æ–¹æ³• } // \u0026gt; ----------------------------------------------------------------------------------- type poolLocal struct { poolLocalInternal\t// 32 bytes // Prevents false sharing on widespread platforms with // 128 mod (cache line size) = 0 . // // å°†poolLocalè¡¥é½è‡³128å­—èŠ‚ï¼ˆå³ä¸¤ä¸ªcache lineï¼‰çš„å€æ•°ï¼Œé˜²æ­¢false sharingä¼ªå…±äº« // ä»…å ä½ç”¨ï¼Œé˜²æ­¢åœ¨cache lineä¸Šåˆ†é…å¤šä¸ª poolLocalInternal // ç¡®ä¿CPUç¼“å­˜æœºåˆ¶ä¸åŒï¼Œä¸€èˆ¬å»ºè®®ç¡®ä¿æœ‰128å­—èŠ‚è·ç¦» pad [128 - unsafe.Sizeof(poolLocalInternal{})%128]byte\t// ä½¿poolLocalæ€»å…±å 128å­—èŠ‚ // CPU Cache // ç°ä»£cpuä¸­ï¼Œcacheéƒ½åˆ’åˆ†æˆä»¥cache line(cache block)ä¸ºå•ä½ï¼Œåœ¨x86_64ä½“ç³»ä¸‹ä¸€èˆ¬éƒ½æ˜¯64å­—èŠ‚ï¼Œcache lineæ˜¯æ“ä½œçš„æœ€å°å•å…ƒ // ç¨‹åºå³ä½¿åªæƒ³è¯»å†…å­˜ä¸­çš„1ä¸ªå­—èŠ‚æ•°æ®ï¼Œä¹Ÿè¦åŒæ—¶æŠŠé™„è¿‘63èŠ‚å­—åŠ è½½åˆ°cacheä¸­ï¼Œå¦‚æœè¯»å–è¶…ä¸ª64å­—èŠ‚ï¼Œé‚£ä¹ˆå°±è¦åŠ è½½åˆ°å¤šä¸ªcache lineä¸­ // è¿™æ ·ï¼Œè®¿é—®åç»­63å­—èŠ‚æ•°æ®æ—¶å°±å¯ä»¥ç›´æ¥ä»cache lineä¸­è¯»å–ï¼Œæ€§èƒ½æœ‰å¾ˆå¤§æå‡ // false sharing // ä¼ªå…±äº«çš„éæ ‡å‡†å®šä¹‰ä¸ºï¼š // ç¼“å­˜ç³»ç»Ÿä¸­æ˜¯ä»¥ç¼“å­˜è¡Œï¼ˆcache lineï¼‰ä¸ºå•ä½å­˜å‚¨çš„ï¼Œå½“å¤šçº¿ç¨‹ä¿®æ”¹äº’ç›¸ç‹¬ç«‹çš„å˜é‡æ—¶ï¼Œå¦‚æœè¿™äº›å˜é‡å…±äº«åŒä¸€ä¸ªç¼“å­˜è¡Œï¼Œ // å°±ä¼šä»¤æ•´ä¸ª cache line å¤±æ•ˆï¼Œæ— æ„ä¸­å½±å“å½¼æ­¤çš„æ€§èƒ½ï¼Œè¿™å°±æ˜¯ä¼ªå…±äº« // å¦‚æœæ²¡ç”¨padå­—æ®µæ—¶ï¼Œé‚£ä¹ˆå½“éœ€è¦è®¿é—®0å·ç´¢å¼•çš„poolLocalæ—¶ï¼ŒCPUåŒæ—¶ä¼šæŠŠ0å·å’Œ1å·ç´¢å¼•åŒæ—¶åŠ è½½åˆ°cpu cacheï¼Œåœ¨åªä¿®æ”¹0å·ç´¢å¼•çš„æƒ…å†µä¸‹ï¼Œ // ä¼šè®©1å·ç´¢å¼•çš„poolLocalå¤±æ•ˆã€‚è¿™æ ·ï¼Œå½“å…¶ä»–çº¿ç¨‹æƒ³è¦è¯»å–1å·ç´¢å¼•æ—¶ï¼Œå‘ç”Ÿcache missï¼Œè¿˜å¾—é‡æ–°å†åŠ è½½ï¼Œå¯¹æ€§èƒ½æœ‰æŸï¼Œ // å¢åŠ ä¸€ä¸ªpadï¼Œè¡¥é½ç¼“å­˜è¡Œï¼Œè®©ç›¸å…³çš„å­—æ®µèƒ½ç‹¬ç«‹åœ°åŠ è½½åˆ°ç¼“å­˜è¡Œå°±ä¸ä¼šå‡ºç°false shardingäº† } // \u0026gt; ----------------------------------------------------------------------------------- // Local per-P Pool appendix. type poolLocalInternal struct { // privateåªæœ‰å½“å‰Pèƒ½ç”¨ private any // Can be used only by the respective P. // å…¶ä»–Péƒ½å¯ä»¥ç”¨ï¼Œå½“privateæ²¡æœ‰æ—¶ä¼˜å…ˆå»å½“å‰Pçš„local.sharedä¸­å–ï¼Œå¦‚æœè¿˜æ²¡æœ‰å°±å»å…¶ä»–Pä¸­çš„local.sharedä¸­çªƒå–ä¸€ä¸ªæ¥ç”¨ shared poolChain // Local P can pushHead/popHead; any P can popTail. } Variables å…¨å±€å˜é‡ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 var ( allPoolsMu Mutex\t// å…¨å±€äº’æ–¥é” // allPools is the set of pools that have non-empty primary // caches. Protected by either 1) allPoolsMu and pinning or 2) // STW. // // allPools æ˜¯å…·æœ‰éç©ºä¸»é”®ç¼“å­˜çš„ pool é›†åˆ // å—ä»»ä½•ä¸€æ–¹ä¿æŠ¤ 1) allPoolsMu å’Œ pinning 2) STW // åœ¨Getå‡½æ•°ä¸­ï¼Œåˆå§‹åŒ–æ—¶è¢«ä¿å­˜åœ¨è¿™é‡Œ allPools []*Pool\t// ä¿å­˜æ¥è‡ªç”¨æˆ·åˆ›å»ºçš„Poolå®ä¾‹ï¼Œç”¨æˆ·ç«¯å¯èƒ½åˆ›å»ºå¤šä¸ªPoolï¼Œæ¯”å¦‚fmtåŒ…åˆ›å»ºçš„Poolä¹Ÿä¼šä¿å­˜åœ¨è¿™é‡Œ // oldPools is the set of pools that may have non-empty victim // caches. Protected by STW. // // oldPoolsæ˜¯ä¸€ç»„å¯èƒ½å…·æœ‰éç©ºvictim cachesçš„æ± ã€‚å—STWä¿æŠ¤ã€‚ // åœ¨GCå¼€å§‹æ—¶ï¼Œä¿å­˜allPoolsä¸­çš„å€¼ oldPools []*Pool\t// oldPoolsåªæ˜¯ä¿å­˜äº† allPools çš„å€¼ï¼Œå¯è§æ˜¯é˜²æ­¢è¢«GCå›æ”¶ç›¸å…³æ•°æ® ) type poolLocal struct æœ¬åœ° Poolï¼Œå¯¹é½Cache lineçš„å€æ•°ã€‚ 1 2 3 4 5 6 7 8 9 type poolLocal struct { poolLocalInternal // Prevents false sharing on widespread platforms with // 128 mod (cache line size) = 0 . // // ç”¨ 128 mod (cache line size) = 0 é˜²æ­¢åœ¨å¹¿æ³›ä¼ æ’­çš„å¹³å°ä¸Š false sharingã€‚ pad [128 - unsafe.Sizeof(poolLocalInternal{})%128]byte } type poolLocalInternal struct 1 2 3 4 5 6 7 8 9 // Local per-P Pool appendix. type poolLocalInternal struct { // private ç§æœ‰çš„ï¼Œåªèƒ½ç”±ç›¸åº”çš„Pä½¿ç”¨ã€‚ private any // Can be used only by the respective P. // shared å…±äº«çš„ï¼Œlocal P å¯ä»¥ pushHead/popHead; ä»»ä½•På¯ä»¥ popTail // å½“å½“å‰Pçš„privateæ²¡æœ‰ï¼Œé‚£ä¹ˆä¼˜å…ˆä»å½“å‰Pçš„sharedä¸­å–ï¼Œè¿˜æ²¡æœ‰åˆ™ä»å…¶ä»–Pçš„sharedä¸­å–ï¼Œ // è¿˜æ˜¯æ²¡æœ‰å¦‚æœNewå‡½æ•°å­˜åœ¨åˆ™ä½¿ç”¨è¯¥å‡½æ•°ç”Ÿæˆ shared poolChain // Local P can pushHead/popHead; any P can popTail. } type poolChain struct poolChainæ˜¯poolDequeueçš„åŠ¨æ€ç‰ˆæœ¬ã€‚ å‚çœ‹ poolqueue.go æ–‡æ¡£ã€‚ï¼ˆç¬¬äºŒç¯‡ä¸­ä»‹ç»ï¼‰ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // poolChain is a dynamically-sized version of poolDequeue. // // This is implemented as a doubly-linked list queue of poolDequeues // where each dequeue is double the size of the previous one. Once a // dequeue fills up, this allocates a new one and only ever pushes to // the latest dequeue. Pops happen from the other end of the list and // once a dequeue is exhausted, it gets removed from the list. type poolChain struct { // head is the poolDequeue to push to. This is only accessed // by the producer, so doesn\u0026#39;t need to be synchronized. head *poolChainElt // tail is the poolDequeue to popTail from. This is accessed // by consumers, so reads and writes must be atomic. tail *poolChainElt } Pool Methods Get() ä¼˜å…ˆä»å½“å‰ P çš„ local.private ä¸­å–ï¼Œæ²¡æœ‰åˆ™ä»å½“å‰ P çš„ local.shared ä¸­å–ï¼Œè¿˜æ²¡æœ‰åˆ™å»å…¶ä»– P ä¸­ local.shared ä¸­çªƒå–ä¸€ä¸ª è°ƒç”¨è€…ä¸åº”è¯¥è®¤ä¸ºGetçš„è¿”å›å€¼å’Œä¼ é€’ç»™Putå€¼ä¹‹é—´æœ‰ä»»ä½•å…³ç³» å‡å¦‚Getæ–¹æ³•æ²¡æœ‰å–å¾— itemï¼Œå¦‚ p.New é nilï¼ŒGetè¿”å›è°ƒç”¨ p.New çš„ç»“æœï¼›å¦åˆ™è¿”å›nil 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 // Get selects an arbitrary item from the Pool, removes it from the // Pool, and returns it to the caller. // Get may choose to ignore the pool and treat it as empty. // Callers should not assume any relation between values passed to Put and // the values returned by Get. // // If Get would otherwise return nil and p.New is non-nil, Get returns // the result of calling p.New. func (p *Pool) Get() any { if race.Enabled { race.Disable() } l, pid := p.pin()\t// è¿”å›å½“å‰å·¥ä½œçº¿ç¨‹æ‰€åœ¨çš„*poolLocalå’Œpid x := l.private\t// å–å½“å‰privateä¸Šæ•°æ® l.private = nil\t// å¹¶æ¸…é›¶private // å¦‚æœ local private æ²¡æœ‰ if x == nil {\t// Try to pop the head of the local shard. We prefer // the head over the tail for temporal locality of // reuse. // // å°è¯•ä»local shardçš„headå–å‡ºã€‚å¯¹äºé‡å¤ä½¿ç”¨ä¸€æ—¶çš„localityæˆ‘ä»¬æ›´å–œæ¬¢headè€Œä¸æ˜¯tail x, _ = l.shared.popHead()\t// å°è¯•ä»sharedçš„headå¼¹å‡ºä¸€ä¸ªæ•°æ® if x == nil { x = p.getSlow(pid)\t// å¦‚æœä¸Šé¢è¿˜æœªç©ºï¼Œåˆ™å»å…¶ä»–Pä¸­å·å–ï¼Œæˆ–ä»victim cacheå»æ‹¿å» } } runtime_procUnpin()\t// å…è®¸å½“å‰å·¥ä½œçº¿ç¨‹è¢«æŠ¢å  if race.Enabled { race.Enable() if x != nil { race.Acquire(poolRaceAddr(x)) } } // å¦‚æœä¸Šé¢éƒ½æ²¡æœ‰æ‹¿åˆ°æ•°æ®å¹¶ä¸”åˆå®šä¹‰äº†Newæ–¹æ³•è°ƒç”¨è¯¥æ–¹æ³•åˆ›å»ºæ•°æ® if x == nil \u0026amp;\u0026amp; p.New != nil {\tx = p.New() } return x } pin() pin å°†å½“å‰ goroutine å›ºå®šåˆ° Pï¼Œç¦ç”¨æŠ¢å å¹¶ä¸º P å’Œ P çš„idè¿”å› poolLocalæ± ã€‚ è°ƒç”¨è€…åœ¨å¤„ç†æ± æ—¶å¿…é¡»è°ƒç”¨runtime_procUnpin()ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 // pin pins the current goroutine to P, disables preemption and // returns poolLocal pool for the P and the P\u0026#39;s id. // Caller must call runtime_procUnpin() when done with the pool. func (p *Pool) pin() (*poolLocal, int) { // è¯¥å‡½æ•°ä¸»è¦ä½œç”¨æ˜¯åŠ é”Mç¦æ­¢å½“å‰Mè¢«æŠ¢å ï¼Œç„¶åè¿”å›Mæ­£ç»‘å®šçš„Pçš„id pid := runtime_procPin()\t// In pinSlow we store to local and then to localSize, here we load in opposite order. // Since we\u0026#39;ve disabled preemption, GC cannot happen in between. // Thus here we must observe local at least as large localSize. // We can observe a newer/larger local, it is fine (we must observe its zero-initialized-ness). // // åœ¨pinSlowä¸­ï¼Œæˆ‘ä»¬å­˜å‚¨åˆ°localï¼Œç„¶åå­˜å‚¨åˆ°localSizeï¼Œåœ¨è¿™é‡Œæˆ‘ä»¬æŒ‰ç›¸åçš„é¡ºåºåŠ è½½ã€‚ // å› ä¸ºæˆ‘ä»¬å·²ç»ç¦ç”¨äº†æŠ¢å ï¼Œæ‰€ä»¥GCä¸èƒ½åœ¨è¿™ä¸¤è€…ä¹‹é—´å‘ç”Ÿã€‚ // å› æ­¤ï¼Œè¿™é‡Œæˆ‘ä»¬å¿…é¡»æ³¨æ„localè‡³å°‘ä¸ºlarge localSizeã€‚ // æˆ‘ä»¬å¯ä»¥è§‚å¯Ÿåˆ°ä¸€ä¸ª æ›´æ–°/æ›´å¤§ çš„ localï¼Œè¿™æ˜¯æ²¡é—®é¢˜çš„(æˆ‘ä»¬å¿…é¡»è§‚å¯Ÿåˆ°å®ƒçš„é›¶åˆå§‹åŒ–)ã€‚ s := runtime_LoadAcquintptr(\u0026amp;p.localSize) // load-acquire;\tåŸå­è¯»å–p.localSizeå€¼ l := p.local // load-consume;\tå­˜å‚¨æ•°æ®çš„æ•°ç»„åœ°å€ // uintptr(pid) \u0026gt;= s; å¯èƒ½ 1)æ²¡æœ‰åˆå§‹åŒ–è¿‡ 2)Pçš„æ•°é‡å˜å¤šäº† if uintptr(pid) \u0026lt; s { return indexLocal(l, pid), pid } return p.pinSlow()\t// åˆå§‹åŒ–å» } // \u0026gt; --------------------------------------------------------------------------------- // go1.19.3/src/runtime/proc.go //go:linkname sync_runtime_procPin sync.runtime_procPin //go:nosplit func sync_runtime_procPin() int { return procPin() } // \u0026gt; --------------------------------------------------------------------------------- // go1.19.3/src/runtime/proc.go //go:nosplit func procPin() int { _g_ := getg() mp := _g_.m mp.locks++ return int(mp.p.ptr().id) } // \u0026gt; --------------------------------------------------------------------------------- // go1.19.3/src/runtime/proc.go //go:linkname sync_runtime_procUnpin sync.runtime_procUnpin //go:nosplit func sync_runtime_procUnpin() { procUnpin() } // \u0026gt; --------------------------------------------------------------------------------- // go1.19.3/src/runtime/proc.go //go:nosplit func procUnpin() { _g_ := getg() _g_.m.locks-- } // \u0026gt; --------------------------------------------------------------------------------- // go1.19.3/src/sync/pool.go //go:linkname runtime_LoadAcquintptr runtime/internal/atomic.LoadAcquintptr func runtime_LoadAcquintptr(ptr *uintptr) uintptr // \u0026gt; --------------------------------------------------------------------------------- // go1.19.3/src/runtime/proc.go // læ˜¯p.localï¼Œiæ˜¯pid func indexLocal(l unsafe.Pointer, i int) *poolLocal { // è·å–åˆ°iä¸‹æ ‡çš„æ•°æ®åœ°å€ lp := unsafe.Pointer(uintptr(l) + uintptr(i)*unsafe.Sizeof(poolLocal{})) return (*poolLocal)(lp) } pinSlow() pinSlow ä¸»è¦æ˜¯å®Œæˆ pool.local çš„åˆå§‹åŒ–åˆ›å»º 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 func (p *Pool) pinSlow() (*poolLocal, int) { // Retry under the mutex. // Can not lock the mutex while pinned. runtime_procUnpin() allPoolsMu.Lock()\tdefer allPoolsMu.Unlock()\tpid := runtime_procPin()\t// poolCleanup won\u0026#39;t be called while we are pinned. s := p.localSize l := p.local // å†æ¬¡æ£€æŸ¥çš„æ„ä¹‰åœ¨äºï¼Œå¯èƒ½å‡ºç°æ­¤æ—¶Poolå·²ç»è¢«åˆå§‹åŒ– if uintptr(pid) \u0026lt; s { return indexLocal(l, pid), pid } if p.local == nil { // æ–°åˆå§‹åŒ–çš„Poolè®°å½•åˆ°allPools allPools = append(allPools, p)\t// allPoolsæ˜¯å­˜å‚¨[]*Poolåˆ‡ç‰‡ } // If GOMAXPROCS changes between GCs, we re-allocate the array and lose the old one. // å¦‚æœ GOMAXPROCS åœ¨ GC ä¹‹é—´å‘ç”Ÿå˜åŒ–ï¼Œæˆ‘ä»¬å°†é‡æ–°åˆ†é…æ•°ç»„å¹¶ä¸¢å¤±æ—§æ•°ç»„ // runtime.GOMAXPROCS å‡½æ•° å‚æ•°æ˜¯0æˆ–åŸå¤§å°å€¼ç›´æ¥è¿”å›CPUä¸­æ•°é‡ï¼Œå…¶ä»–åˆ™ä¿®æ”¹Pçš„æ•°é‡ size := runtime.GOMAXPROCS(0)\t// è¿”å›Pçš„æ€»æ•°é‡ local := make([]poolLocal, size)\t// åˆ›å»ºpoolLocalç±»å‹åˆ‡ç‰‡ï¼Œé•¿åº¦å’Œå®¹é‡éƒ½ä¸ºsize atomic.StorePointer(\u0026amp;p.local, unsafe.Pointer(\u0026amp;local[0])) // store-release runtime_StoreReluintptr(\u0026amp;p.localSize, uintptr(size)) // store-release return \u0026amp;local[pid], pid } // \u0026gt; --------------------------------------------------------------------------------- //go:linkname runtime_StoreReluintptr runtime/internal/atomic.StoreReluintptr func runtime_StoreReluintptr(ptr *uintptr, val uintptr) uintptr getSlow() ä»å…¶ä»– P çš„ share ä¸­å»å·å–å…ƒç´  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 func (p *Pool) getSlow(pid int) any { // See the comment in pin regarding ordering of the loads. // è¯·å‚é˜…pinä¸­å…³äºè´Ÿè½½æ’åºçš„æ³¨é‡Šã€‚ // åŸå­è¯»å– p.localSize size := runtime_LoadAcquintptr(\u0026amp;p.localSize) // load-acquire locals := p.local // load-consume // Try to steal one element from other procs. // å°è¯•ä»å…¶ä»–è¿›ç¨‹ä¸­çªƒå–ä¸€ä¸ªå…ƒç´ ã€‚ for i := 0; i \u0026lt; int(size); i++ { // å·å–é¡ºåºä»å½“å‰Pçš„ä¸‹ä¸€ä¸ªPå¼€å§‹éå†ä¸€åœˆ l := indexLocal(locals, (pid+i+1)%int(size))\tif x, _ := l.shared.popTail(); x != nil { return x } } // Try the victim cache. We do this after attempting to steal // from all primary caches because we want objects in the // victim cache to age out if at all possible. // // è¯•è¯• victim cacheã€‚æˆ‘ä»¬è¯•å›¾ä»æ‰€æœ‰primary cachesä¸­çªƒå–æ•°æ®åæ‰è¿™æ ·åšï¼Œ // å› ä¸ºæˆ‘ä»¬å¸Œæœ›victim cacheä¸­çš„å¯¹è±¡å°½å¯èƒ½çš„è¿‡æœŸ size = atomic.LoadUintptr(\u0026amp;p.victimSize)\t// åŸå­è¯»å–victimSize if uintptr(pid) \u0026gt;= size { return nil } locals = p.victim l := indexLocal(locals, pid)\t// å–å‡ºpidå¯¹åº”Pool // å…ˆä» private ä¸­å– if x := l.private; x != nil { l.private = nil return x } // ä»å…¶ä»–Pçš„ share ä¸­å– for i := 0; i \u0026lt; int(size); i++ { l := indexLocal(locals, (pid+i)%int(size)) if x, _ := l.shared.popTail(); x != nil { return x } } // Mark the victim cache as empty for future gets don\u0026#39;t bother // with it. // // å°† victim cache æ ‡è®°ä¸ºç©ºï¼Œä»¥ä¾¿å°†æ¥è·å–ï¼Œä¸è¦è´¹å¿ƒå¤„ç†å®ƒã€‚ atomic.StoreUintptr(\u0026amp;p.victimSize, 0) return nil } indexLocal() 1 2 3 4 func indexLocal(l unsafe.Pointer, i int) *poolLocal { lp := unsafe.Pointer(uintptr(l) + uintptr(i)*unsafe.Sizeof(poolLocal{})) return (*poolLocal)(lp) } Put() Putæ–¹æ³•å°†xæ”¾å…¥ pool ä¸­ æŠŠ x æ”¾å…¥æ± å­ä¸­æ—¶ï¼Œå»ºè®®æ¸…é™¤ä¸Šé¢ç›¸å…³æ•°æ® 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 // Put adds x to the pool. func (p *Pool) Put(x any) { if x == nil { return } if race.Enabled { if fastrandn(4) == 0 { // Randomly drop x on floor. return } race.ReleaseMerge(poolRaceAddr(x)) race.Disable() } // è·å– P å¯¹åº”çš„ *poolLocal l, _ := p.pin() // å¦‚æœå½“å‰privateä¸ºnilåˆ™æŠŠè¿™ä¸ªå­˜å‚¨åœ¨è¿™é‡Œï¼Œç­‰å¾…ä¸‹æ¬¡ä¼˜å…ˆè¢«ä½¿ç”¨ if l.private == nil { l.private = x x = nil } if x != nil {\t// è¿™ç§æƒ…å†µæ˜¯privateå·²ç»æœ‰æ•°æ®äº†ï¼Œåˆ™æ”¾å…¥sharedé˜Ÿåˆ—ä¸­ l.shared.pushHead(x) } runtime_procUnpin()\t// å…è®¸å½“å‰å·¥ä½œçº¿ç¨‹è¢«æŠ¢å ï¼ŒåŸå› æ˜¯pinå‡½æ•°é‡Œé¢åŠ äº†é”çš„è¿™é‡Œéœ€è¦è§£é” if race.Enabled { race.Enable() } } init() æ³¨å†Œ poolCleanup å‡½æ•°ï¼Œåœ¨GCå¼€å§‹æ—¶è°ƒç”¨ å¯¹äº Pool è€Œè¨€ï¼Œå¹¶ä¸èƒ½æ— é™æ‰©å±•ï¼Œå¦åˆ™å¯¹è±¡å ç”¨å†…å­˜å¤ªå¤šä¼šå¼•èµ·å†…å­˜æº¢å‡ºï¼ˆå‡ ä¹æ‰€æœ‰çš„æ± æŠ€æœ¯ä¸­éƒ½ä¼šåœ¨æŸä¸ªæ—¶åˆ»æ¸…ç©ºæˆ–æ¸…é™¤éƒ¨åˆ†ç¼“å­˜å¯¹è±¡ã€‚Goå‘ç”Ÿåœ¨GCæ—¶æ¸…é™¤éƒ¨åˆ†å†…å­˜ï¼‰ åœ¨ pool.go æ–‡ä»¶çš„ init å‡½æ•°é‡Œï¼Œæ³¨å†ŒGCå‘ç”Ÿæ—¶ï¼Œå¦‚ä½•æ¸…ç† Pool çš„å‡½æ•° poolCleanup 1 2 3 4 5 6 7 8 9 10 11 12 func init() { runtime_registerPoolCleanup(poolCleanup) } // go1.19.3/src/runtime/mgc.go //go:linkname sync_runtime_registerPoolCleanup sync.runtime_registerPoolCleanup func sync_runtime_registerPoolCleanup(f func()) { poolcleanup = f } // go1.19.3/src/runtime/mgc.go var poolcleanup func() ä½¿ç”¨ç¤ºä¾‹ Poolï¼šæ˜¯ä¸€ä¸ªå¯ä»¥åˆ†åˆ«å­˜å–çš„ä¸´æ—¶å¯¹è±¡çš„é›†åˆ Poolï¼šä¸­ä¿å­˜çš„ä»»ä½• item éƒ½å¯èƒ½éšæ—¶ä¸åšé€šå‘Šçš„é‡Šæ”¾æ‰ å¦‚æœPoolæŒæœ‰è¯¥å¯¹è±¡çš„å”¯ä¸€å¼•ç”¨ï¼Œè¿™ä¸ª item å°±å¯èƒ½è¢«å›æ”¶ Poolï¼šå¯ä»¥å®‰å…¨çš„è¢«å¤šä¸ªçº¿ç¨‹åŒæ—¶ä½¿ç”¨ Poolï¼šçš„ç›®çš„æ˜¯ç¼“å­˜ç”³è¯·ä½†æœªä½¿ç”¨ item ç”¨äºä¹‹åçš„é‡ç”¨ï¼Œå·²å‡è½»GCçš„å‹åŠ› ä¹Ÿå°±æ˜¯è¯´ï¼Œè®©åˆ›å»ºé«˜æ•ˆè€Œçº¿ç¨‹å®‰å…¨çš„ç©ºé—²åˆ—è¡¨æ›´å®¹æ˜“ ä½†Poolå¹¶ä¸é€‚åˆç”¨äºå¤šæœ‰ç©ºé—²åˆ—è¡¨ Poolï¼šçš„åˆç†ç”¨æ³•æ˜¯ç”¨äºç®¡ç†ä¸€ç»„é™é™çš„è¢«å¤šä¸ªç‹¬ç«‹å¹¶å‘çº¿ç¨‹å…±äº«å¹¶å¯èƒ½é‡ç”¨çš„ä¸´æ—¶ item Poolæä¾›äº†è®©å¤šä¸ªçº¿ç¨‹åˆ†æ‘Šå†…å­˜ç”³è¯·æ¶ˆè€—çš„æ–¹æ³• Poolï¼šçš„ä¸€ä¸ªå¥½ä¾‹å­åœ¨fmtåŒ…é‡Œé¢ è¯¥Poolç»´æŠ¤ä¸€ä¸ªåŠ¨æ€å¤§å°çš„ä¸´æ—¶è¾“å‡ºç¼“å­˜ä»“åº“ è¯¥åˆ›åº“ä¼šåœ¨è¿‡è½½ï¼ˆè®¸å¤šçº¿ç¨‹æ´»è·ƒçš„æ‰“å°æ—¶ï¼‰å¢å¤§ï¼Œåœ¨æ²‰å¯‚æ—¶ç¼©å° å¦ä¸€æ–¹é¢ï¼Œç®¡ç†è¿™çŸ­å¯¿å‘½å¯¹è±¡çš„ç©ºé—²åˆ—è¡¨ä¸é€‚åˆä½¿ç”¨Pool å› ä¸ºè¿™ç§æƒ…å†µä¸‹å†…å­˜ç”³è¯·æ¶ˆè€—ä¸èƒ½å¾ˆå¥½çš„åˆ†é… è¿™æ—¶åº”è¯¥ç”±è¿™äº›å¯¹è±¡è‡ªå·±å®ç°ç©ºé—²åˆ—è¡¨ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;sync\u0026#34; ) var pool *sync.Pool type Person struct { Name string } func initPool() { pool = \u0026amp;sync.Pool { New: func() interface{} { fmt.Println(\u0026#34;Creating a new Person\u0026#34;) return new(Person) }, } } func main() { initPool() // pool.Get() è¿”å›interface{} // ç„¶åæ–­è¨€ æ˜¯å¦ä¸º *Person p := pool.Get().(*Person) fmt.Println(\u0026#34;é¦–æ¬¡ä» pool é‡Œè·å–ï¼š\u0026#34;, p) p.Name = \u0026#34;first\u0026#34; fmt.Printf(\u0026#34;è®¾ç½® p.Name = %s\\n\u0026#34;, p.Name) // å°†pæ”¾å›æ± ä¸­ pool.Put(p) fmt.Println(\u0026#34;Pool é‡Œå·²æœ‰ä¸€ä¸ªå¯¹è±¡ï¼š\u0026amp;{first}ï¼Œè°ƒç”¨ Getï¼š\u0026#34;, pool.Get().(*Person)) fmt.Println(\u0026#34;Pool æ²¡æœ‰å¯¹è±¡äº†ï¼Œè°ƒç”¨ Getï¼š\u0026#34;, pool.Get().(*Person)) } Creating a new Person é¦–æ¬¡ä» pool é‡Œè·å–ï¼š \u0026amp;{} è®¾ç½® p.Name = first Pool é‡Œå·²æœ‰ä¸€ä¸ªå¯¹è±¡ï¼š\u0026amp;{first}ï¼Œè°ƒç”¨ Getï¼š \u0026amp;{first} Creating a new Person Pool æ²¡æœ‰å¯¹è±¡äº†ï¼Œè°ƒç”¨ Getï¼š \u0026amp;{} é¦–å…ˆï¼Œéœ€è¦åˆå§‹åŒ– Poolï¼Œå”¯ä¸€éœ€è¦çš„å°±æ˜¯è®¾ç½®å¥½Newå‡½æ•° å½“è°ƒç”¨ Get æ–¹æ³•æ—¶ï¼Œå¦‚æœæ± å­é‡Œç¼“å­˜äº†å¯¹è±¡ï¼Œå°±ç›´æ¥è¿”å›ç¼“å­˜çš„å¯¹è±¡ å¦‚æœæ²¡æœ‰å­˜è´§ï¼Œåˆ™è°ƒç”¨Newå‡½æ•°åˆ›å»ºä¸€ä¸ªæ–°çš„å¯¹è±¡ å¦å¤–ï¼Œæˆ‘ä»¬å‘ç°Getæ–¹æ³•å–å‡ºæ¥çš„å¯¹è±¡å’Œä¸Šæ¬¡Putè¿›å»çš„å¯¹è±¡å®é™…ä¸Šæ˜¯åŒä¸€ä¸ªï¼ŒPoolæ²¡æœ‰åšä»»ä½•â€œæ¸…ç©ºâ€çš„å¤„ç† ä½†æˆ‘ä»¬ä¸åº”å½“å¯¹æ­¤æœ‰ä»»ä½•å‡è®¾ï¼Œå› ä¸ºåœ¨å®é™…çš„å¹¶å‘ä½¿ç”¨åœºæ™¯ä¸­ æ— æ³•ä¿è¯è¿™ç§é¡ºåºï¼Œæœ€å¥½çš„åšæ³•æ˜¯åœ¨Putå‰ï¼Œå°†å¯¹è±¡æ¸…ç©º ","permalink":"http://localhost:1313/posts/golang/sync/pool/","summary":"Poolæ˜¯ä¸€ç»„å¯ä»¥å•ç‹¬ä¿å­˜å’Œæ£€ç´¢çš„ä¸´æ—¶å¯¹è±¡ã€‚","title":"sync.Pool"},{"content":"type RWMutex struct ğŸš€ åœ¨runtime/rwmutex.goä¸­æœ‰è¿™ä¸ªæ–‡ä»¶çš„ä¿®æ”¹è¿‡çš„å‰¯æœ¬ã€‚å¦‚æœä½ åœ¨è¿™é‡Œåšäº†ä»»ä½•æ›´æ”¹ï¼Œçœ‹çœ‹æ˜¯å¦åº”è¯¥åœ¨é‚£é‡Œä¹Ÿåšæ›´æ”¹ã€‚ RWMutex æ˜¯ä¸€ç§ è¯»/å†™ äº’æ–¥é”ã€‚è¯¥é”å¯ä»¥ç”±ä»»æ„æ•°é‡çš„è¯»æˆ–å•ä¸ªå†™æŒæœ‰ã€‚ RWMutex çš„é›¶å€¼æ˜¯ä¸€ä¸ªæœªé”å®šçš„äº’æ–¥é”ã€‚RWMutex åœ¨ç¬¬ä¸€æ¬¡ä½¿ç”¨åä¸èƒ½å¤åˆ¶ã€‚ å¦‚æœä¸€ä¸ªgoroutineæŒæœ‰ä¸€ä¸ªç”¨äºè¯»å–çš„RWMutexï¼Œè€Œå¦ä¸€ä¸ªgoroutineå¯èƒ½ä¼šè°ƒç”¨Lockï¼Œ é‚£ä¹ˆä»»ä½•goroutineéƒ½ä¸åº”è¯¥æœŸæœ›èƒ½å¤Ÿè·å¾—ä¸€ä¸ªè¯»é”ï¼Œç›´åˆ°åˆå§‹çš„è¯»é”è¢«é‡Šæ”¾ã€‚ ç‰¹åˆ«æ˜¯ï¼Œè¿™ç¦æ­¢äº†é€’å½’è¯»é”å®šã€‚è¿™æ˜¯ä¸ºäº†ç¡®ä¿é”æœ€ç»ˆå¯ç”¨ã€‚è¢«é˜»å¡çš„é”è°ƒç”¨ä¼šæ’é™¤æ–°çš„è¯»å–å™¨è·å–é”ã€‚ RWMutexï¼šè¯»å†™äº’æ–¥é” 1) è¯¥é”å¯ä»¥è¢«åŒæ—¶å¤šä¸ªè¯»å–è€…æŒæœ‰æˆ–å”¯ä¸€å†™å…¥è€…æŒæœ‰ 2) RWMutexå¯ä»¥åˆ›å»ºä¸ºå…¶ä»–ç»“æ„ä½“çš„å­—æ®µ 3) é›¶å€¼ä¸ºè§£é”çŠ¶æ€ RWMutex ç±»å‹çš„é”ä¹Ÿå’Œçº¿ç¨‹æ— å…³ï¼Œå¯ä»¥ç”±ä¸åŒçš„çº¿ç¨‹åŠ è¯»å–é”/å†™å…¥å’Œè§£è¯»å–é”/å†™å…¥é” 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 // There is a modified copy of this file in runtime/rwmutex.go. // If you make any changes here, see if you should make them there. // A RWMutex is a reader/writer mutual exclusion lock. // The lock can be held by an arbitrary number of readers or a single writer. // The zero value for a RWMutex is an unlocked mutex. // // A RWMutex must not be copied after first use. // // If a goroutine holds a RWMutex for reading and another goroutine might // call Lock, no goroutine should expect to be able to acquire a read lock // until the initial read lock is released. In particular, this prohibits // recursive read locking. This is to ensure that the lock eventually becomes // available; a blocked Lock call excludes new readers from acquiring the // lock. type RWMutex struct { // 1) ä¸€æŠŠäº’æ–¥é”ï¼Œä¿æŠ¤ä»¥ä¸‹å­—æ®µ // æ‰€æœ‰å†™goroutineäº‰æŠ¢sync.Mutexé”çš„goroutineéƒ½è¿™è¿™é‡Œæ’é˜Ÿç­‰å¾… w Mutex // held if there are pending writers // 2) semaphore è¯»å†™ç­‰å¾…æ±  // è·å–åˆ° sync.Mutex é”gorutineï¼Œå¹¶ç­‰å¾…æ­£åœ¨è¿è¡Œ è¯»goroutine æ—¶ï¼Œè¯¥å†™goroutineåœ¨è¿™é‡Œç­‰å¾… // å› æ­¤è¿™é‡Œåªå¯èƒ½æ˜¯åªæœ‰ä¸€ä¸ªå†™goroutineåœ¨ç­‰å¾…æˆ–è€…æ²¡æœ‰ writerSem uint32 // semaphore for writers to wait for completing readers // readerSem è®°å½•ç€æ‰€æœ‰ç­‰å¾…è¯»çš„åç¨‹ï¼Œå½“æœ‰å†™æ“ä½œæ­£åœ¨è¿›è¡Œä¸­ï¼Œåé¢æ¥çš„è¯»æ“ä½œå…¨éƒ¨æ’é˜Ÿç­‰å¾…åœ¨è¿™é‡Œ // ç­‰å¾…æ­£åœ¨è¿›è¡Œä¸­çš„è¯»æ“ä½œå®Œæˆåé‡Šæ”¾writerSemä¸­çš„å†™æ“ä½œå®Œæˆåï¼Œè¿™é‡Œæ’é˜Ÿçš„è¯»åç¨‹å°†è¢«é‡Šæ”¾ readerSem uint32 // semaphore for readers to wait for completing writers // 3) è¯»ç­‰å¾…æ•°é‡ // readerCount è®°å½•çš„æ‰€æœ‰çš„è¯»goroutineæ•°é‡ï¼ˆã€æ­£åœ¨æ‰§è¡Œçš„goroutineã€‘+ã€ç­‰å¾…åœ¨readerSemä¸­çš„goroutineã€‘ï¼‰ï¼Œ // è°ƒç”¨RLockæ–¹æ³•è¯¥å€¼å°±ä¼šåŠ ä¸€ // å½“æœ‰å†™goroutineè·å–åˆ°sync.Mutexæ—¶ï¼Œä¼šå°†è¯¥å€¼åŸå­æ“ä½œå‡å»rwmutexMaxReaderså˜æˆè´Ÿæ•°ï¼Œ // å‘ŠçŸ¥RLockæ–¹æ³•æœ‰å†™æ“ä½œåœ¨è¿›è¡Œï¼Œgoroutineå»readerSemå§ readerCount int32 // number of pending readers // åœ¨è·å–åˆ°Mutexåï¼Œè®°å½•å½“å‰ã€æ­£åœ¨è¿›è¡Œçš„è¯»goroutineæ•°é‡ã€‘ï¼Œä¸åŒ…æ‹¬å­˜åœ¨readerSemæ’é˜Ÿçš„ï¼Œè¿™äº›è¯»goroutineæ­£åœ¨å·¥ä½œçº¿ç¨‹ä¸Šè¿è¡Œ // åœ¨å½“å‰å†™æ“ä½œå¼€å§‹æ—¶ç­‰å¾…æ­£åœ¨è¿è¡Œå…¨éƒ¨è¯»goroutineçš„æ•°é‡ï¼Œæ³¨æ„è¿™é‡Œå¯ä»¥æ˜¯è´Ÿæ•° readerWait int32 // number of departing readers } const 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 // 2^30 = 1,073,741,824\tå®Œå…¨èƒ½æ»¡è¶³è¯»å–çš„æ•°é‡ const rwmutexMaxReaders = 1 \u0026lt;\u0026lt; 30\t// æœ€å¤§è¯»å–æ•°é‡ // Happens-before relationships are indicated to the race detector via: // - Unlock -\u0026gt; Lock: readerSem // - Unlock -\u0026gt; RLock: readerSem // - RUnlock -\u0026gt; Lock: writerSem // // The methods below temporarily disable handling of race synchronization // events in order to provide the more precise model above to the race // detector. // // For example, atomic.AddInt32 in RLock should not appear to provide // acquire-release semantics, which would incorrectly synchronize racing // readers, thus potentially missing races. // // Happens-beforeå…³ç³»é€šè¿‡ä»¥ä¸‹æ–¹å¼æŒ‡ç¤ºç«äº‰æ£€æµ‹å™¨: // Unlock -\u0026gt; Lock: readerSem // Unlock -\u0026gt; RLock: readerSem // RUnlock -\u0026gt; Lock: writerSem // // ä¸‹é¢çš„æ–¹æ³•æš‚æ—¶ç¦ç”¨äº†ç«äº‰åŒæ­¥äº‹ä»¶çš„å¤„ç†ï¼Œä»¥ä¾¿ä¸ºç«äº‰æ£€æµ‹å™¨æä¾›æ›´ç²¾ç¡®çš„æ¨¡å‹ã€‚ // ä¾‹å¦‚ï¼ŒRLockä¸­çš„ atomic.AddInt32 çœ‹èµ·æ¥ä¸åº”è¯¥æä¾› è·å–-é‡Šæ”¾è¯­ä¹‰ï¼Œè¿™å°†ä¸æ­£ç¡®åœ°åŒæ­¥ç«äº‰çš„é˜…è¯»å™¨ï¼Œä»è€Œå¯èƒ½é”™è¿‡ç«äº‰ã€‚ å­—æ®µå’Œæ–¹æ³•æè¿° Lock()ã€Unlock() å†™æ“ä½œæ—¶è°ƒç”¨çš„æ–¹æ³•ï¼Œå¦‚æœé”å·²è¢«readeræˆ–waiteræŒæœ‰ï¼Œé‚£ä¹ˆLockæ–¹æ³•ä¼šä¸€ç›´é˜»å¡ï¼Œç›´åˆ°èƒ½è·å–åˆ°é” å†™æ“ä½œæ—¶ï¼Œå¦‚æœé”è¢«readersæŒæœ‰ï¼Œé‚£ä¹ˆå°†ç­‰å¾…æ‰€æœ‰çš„readerè§£é”ï¼Œè¿”å›å†™æ“ä½œè·å¾—é”ï¼Œè¿™æœŸé—´è¿˜æœ‰æ¥çš„readerå…¨éƒ¨å»æ’é˜Ÿç­‰å¾…ï¼Œç­‰å¾…å†™æ“ä½œè§£é”å†™æ“ä½œè§£é”æœŸé—´å…ˆæŠŠç­‰å¾…åœ¨æ’é˜Ÿçš„å…¨éƒ¨é‡Šæ”¾å‡ºæ¥ï¼Œç„¶åå†å»è§£é”äº’æ–¥é”ã€‚åœ¨äº’æ–¥é”è§£é”å°æ®µæ—¶é—´æ¥çš„è¯»æ“ä½œç›´æ¥è·å–é”ä¸éœ€è¦å»æ’é˜Ÿï¼Œäº’æ–¥é”è§£é”åæ‰å…è®¸æ’é˜Ÿçš„å†™æ“ä½œæˆ–æ­£åœ¨æ¥çš„å†™æ“ä½œå»äº‰æŠ¢äº’æ–¥å†™é” å†™æ“ä½œæ—¶ï¼Œå¦‚æœé”å·²è¢«waiteræŒæœ‰ï¼Œé‚£ä¹ˆå½“å‰å†™æ“ä½œç­‰å¾…åœ¨RWRutex.w.seamä¿¡å·é‡ä¸­ï¼Œç­‰å¾…å‰é¢ä¸€ä¸ªå†™é”å®Œæˆï¼Œæ­¤æ—¶æ¥çš„è¯»æ“ä½œå…¨éƒ¨é˜»å¡èµ·ï¼Œå·²ç»åœ¨è¿›è¡Œçš„è¯»æ“ä½œæ­£å¸¸è¿›è¡Œ Unlockæ–¹æ³•æ˜¯é…å¯¹çš„é‡Šæ”¾é”çš„æ–¹æ³• RLock()ã€RUnlock() è¯»æ“ä½œæ—¶è°ƒç”¨çš„æ–¹æ³•ï¼Œå¦‚æœé”å·²ç»è¢«writeræŒæœ‰çš„è¯ï¼ŒRLockæ–¹æ³•ä¼šä¸€ç›´é˜»å¡ï¼Œç›´åˆ°èƒ½è·å–åˆ°é”ï¼Œå¦åˆ™å°±ç›´æ¥è¿”å› è¯»æ“ä½œæ—¶æ²¡æœ‰waiteræŒæœ‰é”æƒ…å†µï¼Œç›´æ¥è®°å½•readerCountåŠ ä¸€ï¼Œè¿”å›å°±è¿”å›ï¼Œè¡¨ç¤ºè·å–åˆ°é” è¯»æ“ä½œæ—¶å­˜åœ¨waiteræŒæœ‰é”æƒ…å†µï¼Œåˆ™å½“å‰è¯»æ“ä½œæ’é˜Ÿåœ¨readerSemï¼Œç­‰å¾…å½“å‰å†™å®Œæˆ è€ŒRUnlockæ˜¯readeré‡Šæ”¾é”çš„æ–¹æ³• RLocker() è¿™ä¸ªæ–¹æ³•çš„ä½œç”¨æ˜¯ä¸ºè¯»æ“ä½œè¿”å›ä¸€ä¸ªLockeræ¥å£çš„å¯¹è±¡ï¼Œå®ƒçš„Lockæ–¹æ³•ä¼šè°ƒç”¨RWMutexçš„RLockæ–¹æ³•ï¼Œå®ƒçš„Unlockæ–¹æ³•ä¼šè°ƒç”¨RWMutexçš„RUnlockæ–¹æ³• Lock() Lock é”å®š rw ç”¨äºå†™å…¥ã€‚ å¦‚æœé”å·²ç»é”å®šç”¨äºè¯»æˆ–å†™ï¼Œé‚£ä¹ˆé”å°†é˜»å¡ï¼Œç›´åˆ°é”å¯ç”¨ä¸ºæ­¢ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 // Lock locks rw for writing. // If the lock is already locked for reading or writing, // Lock blocks until the lock is available. func (rw *RWMutex) Lock() { if race.Enabled { _ = rw.w.state race.Disable() } // 1) å°è¯•è·å– sync.Mutex é” // First, resolve competition with other writers. // // é¦–å…ˆï¼Œè§£å†³ä¸å…¶ä»– writers çš„ç«äº‰ã€‚ // å¦‚æœå­˜åœ¨å¤šä¸ªå†™gorutineçš„éƒ½åœ¨è°ƒç”¨Lockç«äº‰é”ï¼Œè¿™é‡Œéœ€è¦å…ˆå»ç«äº‰é” rw.w.Lock()\t// sync.Mutex // 2) åŸå­ä¿®æ”¹readerCountå€¼ï¼Œå‘Šè¯‰åé¢è¯»goroutineè°ƒç”¨Rlockå‡½æ•°éœ€è¦å»readerSemä¸­æŒ‚èµ· // ç”±äºåˆšè·å–åˆ°é”ï¼Œå› æ­¤æ­¤æ—¶åªå­˜åœ¨æ­£åœ¨è¿è¡Œè¯»goroutineå’Œç­‰å¾…åœ¨writerSemä¸­å†™goroutineï¼Œä¸å­˜åœ¨ç­‰å¾…åœ¨readerSemä¸­çš„goroutine // å› æ­¤ readerCount å­˜å‚¨çš„æ˜¯æ­£åœ¨è¿è¡Œè¯»goroutineï¼Œåœ¨ä¸‹é¢è¿™è¡ŒåŸå­æ“ä½œæ‰§è¡Œå‰éƒ½è®¤ä¸ºè¯»goroutineæ˜¯ä¸éœ€è¦æŒ‚èµ·çš„ // Announce to readers there is a pending writer. // // é€šè¿‡æŠŠrw.readerCountè®¾ç½®æˆä¸€ä¸ªè´Ÿæ•°ï¼Œæ¥å‘ŠçŸ¥å…¶ä»–è¯»goroutineå½“å‰æœ‰å†™çš„goroutineæ­£åœ¨ç­‰å¾…è¿›å…¥ä¸´ç•ŒåŒº // atomic.AddInt32(\u0026amp;rw.readerCount, -rwmutexMaxReaders); å‘Šè¯‰åé¢æ¥çš„è¯»æ“ä½œå»æ’é˜Ÿç­‰å¾…ï¼Œä½ ä»¬åº”è¯¥åœ¨æœ¬æ¬¡å†™æ“ä½œå®Œåå†å»è¯»å–æ•°æ® // ç”±äºå½“å‰åˆšè·å–åˆ° Mutex,æ‰€ä»¥è¿™é‡Œçš„ r åº”è¯¥è¡¨ç¤ºå½“å‰æ­£åœ¨è¿è¡Œçš„è¯»goroutineçš„æ•°é‡ï¼Œä¸åŒ…å«è¢«æŒ‚èµ·çš„ goroutine r := atomic.AddInt32(\u0026amp;rw.readerCount, -rwmutexMaxReaders) + rwmutexMaxReaders\t// åŸå­æ“ä½œè¡¨ç¤ºå½“å‰æœ‰å†™çš„åç¨‹æ¥äº† // åœ¨ä¸Šé¢è¿™è¡ŒåŸå­æ“ä½œæ‰§è¡Œåï¼Œéƒ½æœ‰æ¥çš„è¯»goroutineåœ¨è°ƒç”¨RLockæ–¹æ³•æ—¶ï¼Œéƒ½ä¼šè¢«æŒ‚èµ·åœ¨readerSemä¸­ // å› æ­¤ r æ˜¯æ‰€æœ‰æ­£åœ¨è¿è¡Œè¯»goroutineçš„æ•°é‡ // ä¸Šé¢çš„åŸå­æ“ä½œä¸RLockå‡½æ•°çš„åŸå­æ“ä½œå½¢æˆä¸€å¯¹ä¸´ç•ŒåŒºåŸŸäº’æ–¥ // Wait for active readers. // // 1. r != 0ï¼šå­˜åœ¨æ­£åœ¨è¿è¡Œçš„è¯»goroutine // 2. atomic.AddInt32(\u0026amp;rw.readerWait, r) != 0ï¼šç»§ç»­åˆ¤æ–­è¿™æ®µæ—¶é—´å‘¢è¿™äº›è¯»goroutineæ˜¯å¦å…¨éƒ¨è¯»å–å®Œï¼Œ // æ²¡æœ‰è¯»å–å®Œè¿™é‡Œéœ€è¦æŠŠå½“å‰å†™goroutineæŒ‚èµ·åœ¨writerSem // è¿™é‡Œçš„åŸå­æ“ä½œä¸RUlockå‡½æ•°çš„ \u0026#34;atomic.AddInt32(\u0026amp;rw.readerWait, -1) == 0\u0026#34; å½¢æˆä¸´ç•ŒåŒºåŸŸäº’æ–¥ if r != 0 \u0026amp;\u0026amp; atomic.AddInt32(\u0026amp;rw.readerWait, r) != 0 {\t// readerWaitè®°å½•ç€æ­£åœ¨è¿è¡Œä¸­ï¼Œè¿˜æ²¡æœ‰è°ƒç”¨RUnlockçš„goroutine // å­˜åœ¨éœ€è¦ç­‰å¾…è¯»çš„åç¨‹ï¼ŒæŠŠå½“å‰åç¨‹åŠ å…¥writerSemå†™ä¿¡æ¯æ±  // falseï¼šè¿™é‡ŒåŠ å…¥çš„æ˜¯å°¾éƒ¨ï¼Œç”±äºwriterSemåªå¯èƒ½å­˜ä¸€ä¸ªå†™goroutine runtime_SemacquireMutex(\u0026amp;rw.writerSem, false, 0)\t} if race.Enabled { race.Enable() race.Acquire(unsafe.Pointer(\u0026amp;rw.readerSem)) race.Acquire(unsafe.Pointer(\u0026amp;rw.writerSem)) } } Unlock() Unlock æ–¹æ³•è§£é™¤rwçš„å†™å…¥é”çŠ¶æ€ã€‚ å¦‚æœ rw åœ¨è¿›å…¥è§£é”æ—¶æ²¡æœ‰é”å®šå†™å…¥ï¼Œè¿™æ˜¯ä¸€ä¸ªè¿è¡Œæ—¶é”™è¯¯ã€‚ ä¸ Mutexes ä¸€æ ·ï¼Œä¸€ä¸ªè¢«é”çš„ RWMutex ä¸ä¸€ä¸ªç‰¹å®šçš„ goroutine æ— å…³ã€‚ ä¸€ä¸ª goroutine å¯ä»¥ RLock(é”å®š)ä¸€ä¸ª RWMutexï¼Œç„¶åå®‰æ’å¦ä¸€ä¸ª goroutine è¿è¡Œ RUnlock(è§£é”)å®ƒã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 // Unlock unlocks rw for writing. It is a run-time error if rw is // not locked for writing on entry to Unlock. // // As with Mutexes, a locked RWMutex is not associated with a particular // goroutine. One goroutine may RLock (Lock) a RWMutex and then // arrange for another goroutine to RUnlock (Unlock) it. func (rw *RWMutex) Unlock() { if race.Enabled { _ = rw.w.state race.Release(unsafe.Pointer(\u0026amp;rw.readerSem)) race.Disable() } // 1) å½“Unlockæ–¹æ³•è¢«è°ƒç”¨ï¼Œä¹Ÿå°±è¯´æ˜æ•°æ®çš„ç›¸å…³å†™æ“ä½œå·²ç»å®Œæˆäº†ï¼Œæ­¤æ—¶å…¶ä»–æ¥è¯»çš„goroutineå¯ä»¥æ­£å¸¸è¯»å–æ–°æ•°æ® // Announce to readers there is no active writer. // // å‘Šè¯‰æ‰€æœ‰RLockçš„åç¨‹ï¼Œæ²¡æœ‰æ­£åœ¨å†™çš„é”ï¼Œæ­¤æ—¶æ¥è¯»çš„åç¨‹ä¸å¿…ç­‰å¾…ç›´æ¥å¯ä»¥è¯»å–åˆ°æ•°æ® // å› ä¸ºç¨‹åºè°ƒç”¨äº†Unlockæ–¹æ³•ä»£è¡¨æˆ‘ä»¬å‰é¢ä»¥æŠŠæ•°æ®æ›´æ–°äº†ï¼Œæ­¤æ—¶åœ¨ä¿¡å·é‡ä¸­ç­‰å¾…è¯»çš„åç¨‹å’Œæ­¤æ—¶åé¢æ¥è¯»çš„åç¨‹éƒ½å¯ä»¥å®‰å…¨è¯»å–æ•°æ®äº† // è¿™é‡Œä¸RLockå‡½æ•°çš„ \u0026#34;atomic.AddInt32(\u0026amp;rw.readerCount, 1) \u0026lt; 0\u0026#34; å½¢æˆä¸´ç•ŒåŒºäº’æ–¥ r := atomic.AddInt32(\u0026amp;rw.readerCount, rwmutexMaxReaders)\t// è¿™é‡Œçš„rå…¨éƒ½æ˜¯ç­‰å¾…åœ¨ä¿¡å·é‡çš„æ•°é‡ // æ²¡æœ‰è°ƒç”¨Lockæ–¹æ³•ï¼Œè€Œæ˜¯ç›´æ¥è°ƒç”¨Unlockæ–¹æ³•è¿™é‡Œä¼šæŠ¥é”™ if r \u0026gt;= rwmutexMaxReaders { race.Enable() throw(\u0026#34;sync: Unlock of unlocked RWMutex\u0026#34;) } // Unblock blocked readers, if any. // // é‡Šæ”¾æ‰ç­‰å¾…åœ¨ä¿¡å·é‡çš„åç¨‹ï¼Œæ³¨æ„è¿™é‡Œæ˜¯é‡Šæ”¾å®Œäº†æ‰æŠŠäº’æ–¥é”è§£é”çš„æ‰å…è®¸å…¶ä»–å†™æ“ä½œè¿›è¡Œ // å› ä¸ºå‰é¢çš„æ•°æ®å·²ç»æ›´æ–°äº†ï¼Œæ‰€ä»¥è¿™é‡Œéœ€è¦æŠŠåœ¨ä¿¡å·é‡ä¸­çš„åç¨‹å…¨éƒ¨æ”¾åœ¨Pæœ¬åœ°é˜Ÿåˆ—æˆ–å…¨å±€é˜Ÿåˆ—ä¸­ç­‰å¾…è°ƒåº¦å™¨è°ƒåº¦å»æ¥è¿è¡Œ // è¿™é‡Œä¹Ÿæ˜¯ä¸ºä»€ä¹ˆå…¶ä»–å†™goroutineè·å–åˆ°Mutexé”æ—¶ï¼Œä¸å­˜åœ¨ç­‰å¾…åœ¨readerSemä¸Šçš„è¯»goroutineçš„åŸå› ï¼Œå› ä¸ºMutexè§£é”åœ¨åé¢ä¸€æ­¥ for i := 0; i \u0026lt; int(r); i++ { runtime_Semrelease(\u0026amp;rw.readerSem, false, 0)\t// å–å‡ºç­‰å¾…åœ¨readerSemçš„å†™goroutine } // Allow other writers to proceed. // // å…è®¸å…¶ä»– writers ç»§ç»­ rw.w.Unlock()\t// sync.Mutex if race.Enabled { race.Enable() } } TryLock() TryLock è¯•å›¾é”å®š rw è¿›è¡Œå†™å…¥ï¼Œå¹¶æŠ¥å‘Šæ˜¯å¦æˆåŠŸã€‚ è¯·æ³¨æ„ï¼Œè™½ç„¶ç¡®å®å­˜åœ¨æ­£ç¡®ä½¿ç”¨ TryLock çš„æƒ…å†µï¼Œä½†å¾ˆå°‘ï¼Œè€Œä¸” TryLock çš„ä½¿ç”¨é€šå¸¸è¡¨æ˜äº’æ–¥é‡çš„ç‰¹å®šä½¿ç”¨ä¸­å­˜åœ¨æ›´æ·±å±‚çš„é—®é¢˜ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 // TryLock tries to lock rw for writing and reports whether it succeeded. // // Note that while correct uses of TryLock do exist, they are rare, // and use of TryLock is often a sign of a deeper problem // in a particular use of mutexes. func (rw *RWMutex) TryLock() bool { if race.Enabled { _ = rw.w.state race.Disable() } // å°è¯•è·å–Mutexé” if !rw.w.TryLock() { if race.Enabled { race.Enable() } return false } // åŸå­äº¤æ¢ readerCount ç”± 0 -\u0026gt; -rwmutexMaxReaders // å¯è§åªæœ‰åœ¨æ²¡æœ‰è¯»goroutineçš„æ—¶å€™ï¼ŒTryLockå‡½æ•°æ‰ä¼šè¿”å›æˆåŠŸ if !atomic.CompareAndSwapInt32(\u0026amp;rw.readerCount, 0, -rwmutexMaxReaders) { // å­˜åœ¨å…¶ä»–æ­£åœ¨è¯»å†™åç¨‹ rw.w.Unlock()\t// è§£é”äº’æ–¥é” if race.Enabled { race.Enable() } return false } if race.Enabled { race.Enable() race.Acquire(unsafe.Pointer(\u0026amp;rw.readerSem)) race.Acquire(unsafe.Pointer(\u0026amp;rw.writerSem)) } return true } RLock() RLockè®¾ç½®rwè¯»é”ã€‚ å®ƒä¸åº”è¯¥ç”¨äºé€’å½’çš„è¯»é”å®š;è¢«é˜»å¡çš„é”è°ƒç”¨ä¼šæ’é™¤æ–°çš„è¯»å–å™¨è·å–é”ã€‚è¯·å‚é˜…RWMutexç±»å‹çš„æ–‡æ¡£ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 // RLock locks rw for reading. // // It should not be used for recursive read locking; a blocked Lock // call excludes new readers from acquiring the lock. See the // documentation on the RWMutex type. func (rw *RWMutex) RLock() { if race.Enabled { _ = rw.w.state race.Disable() } // æŠŠrw.readerCountåŠ ä¸€ï¼Œå¦‚æœè¯¥å€¼å°äº0ï¼Œè¯´æ˜å­˜åœ¨å…¶ä»–goroutineæ­£åœ¨å†™æ“ä½œï¼Œä¹Ÿå°±æ˜¯å‰é¢çš„Lockæ–¹æ³• // è¿™é‡Œä¹Ÿè¡¨æ˜äº†readerCountå­—æ®µæ˜¯è®°å½•æ‰€æœ‰å†™goroutineçš„æ•°é‡ if atomic.AddInt32(\u0026amp;rw.readerCount, 1) \u0026lt; 0 { // A writer is pending, wait for it. // // ä¸€ä¸ªå†™é”æ­£åœ¨ç»§ç»­ï¼Œç­‰å¾…å®ƒå®Œæˆ runtime_SemacquireMutex(\u0026amp;rw.readerSem, false, 0)\t// å°†å½“å‰è¯»goroutineæŒ‚åœ¨readerSemä¸Š } if race.Enabled { race.Enable() race.Acquire(unsafe.Pointer(\u0026amp;rw.readerSem)) } } RUnlock() RUnlock è§£é™¤ä¸€ä¸ª RLock è°ƒç”¨ã€‚ å®ƒä¸ä¼šå½±å“å…¶ä»–åŒæ—¶é˜…è¯»çš„è¯»è€…ã€‚ å¦‚æœrwåœ¨è¿›å…¥RUnlockæ—¶æ²¡æœ‰é”å®šè¯»å–ï¼Œåˆ™æ˜¯ä¸€ä¸ªè¿è¡Œæ—¶é”™è¯¯ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 // RUnlock undoes a single RLock call; // it does not affect other simultaneous readers. // It is a run-time error if rw is not locked for reading // on entry to RUnlock. func (rw *RWMutex) RUnlock() { if race.Enabled { _ = rw.w.state race.ReleaseMerge(unsafe.Pointer(\u0026amp;rw.writerSem)) race.Disable() } // æŠŠå‰é¢è¯»åŠ é”å‡ä¸€ï¼Œå¦‚æœrå°äº0ï¼Œè¯´æ˜æ­£åœ¨è¿›è¡Œå†™æ“ä½œä¸­ // è¿™é‡Œä¹Ÿæœ‰ä¸€ç§å¯èƒ½æ˜¯æ²¡æœ‰å­˜åœ¨å†™æ“ä½œä¸­åˆæ²¡æœ‰è°ƒç”¨Rlockå‡½æ•°è°ƒç”¨äº†RUnlockå‡½æ•°å¯¼è‡´æ€»æœ‰ä¸€ä¸ªgoroutineè¿™é‡Œrw.readerCount=-1 if r := atomic.AddInt32(\u0026amp;rw.readerCount, -1); r \u0026lt; 0 { // Outlined slow-path to allow the fast-path to be inlined // // æœ‰å­˜åœ¨å†™åœ¨è¿›è¡Œï¼Œå› æ­¤éœ€è¦åˆ¤æ–­å½“å‰æ˜¯å¦éœ€è¦å–å‡ºè¯¥å†™goroutine // åŸå› æ˜¯å¯èƒ½å­˜åœ¨è¯»goroutineåœ¨è¿è¡Œä¸­ï¼Œè¯¥å†™goroutineåœ¨writerSemä¸­ç­‰å¾… rw.rUnlockSlow(r)\t} if race.Enabled { race.Enable() } } rUnlockSlow() 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 func (rw *RWMutex) rUnlockSlow(r int32) { // åˆ¤æ–­æ²¡æœ‰è°ƒç”¨RLockå‡½æ•°è°ƒç”¨RUnlockå‡½æ•°æŠ¥é”™ // 1. r+1 == -rwmutexMaxReaders =\u0026gt; r + rwmutexMaxReaders == 1 // 2. r+1 == 0ï¼Œå°±æ˜¯åˆ¤æ–­ä¸Šé¢æ²¡æœ‰è°ƒç”¨RLockå‡½æ•°è°ƒç”¨RUnlockå‡½æ•°æ—¶æƒ…å†µ if r+1 == 0 || r+1 == -rwmutexMaxReaders { race.Enable() throw(\u0026#34;sync: RUnlock of unlocked RWMutex\u0026#34;) } // A writer is pending. // // rw.readerWait è®°å½•ç€å½“å‰æ­£åœ¨è¿è¡Œçš„goroutineæ²¡åœ¨ä¿¡å·æ± çš„æ•°é‡ï¼Œè¿™é‡Œåˆ¤æ–­æ˜¯å¦å·²ç»æ˜¯æœ€åä¸€ä¸ª // è¿™é‡Œçš„åŸå­æ“ä½œå’ŒLockå‡½æ•°ä¸­çš„ \u0026#34;atomic.AddInt32(\u0026amp;rw.readerWait, r) != 0\u0026#34; å½¢æˆä¸´ç•ŒåŒºäº’æ–¥ if atomic.AddInt32(\u0026amp;rw.readerWait, -1) == 0 {\t// å¦‚æœæ˜¯æœ€åä¸€ä¸ªï¼ŒæŠŠç­‰å¾…å†™çš„goroutineå–å‡º // The last reader unblocks the writer. runtime_Semrelease(\u0026amp;rw.writerSem, false, 1)\t// ä»writerSemä¸­å–å‡ºç­‰å¾…åœ¨è¿™é‡Œçš„è¯»goroutine } } TryRLock() å°è¯•è·å–è¯»é”ï¼Œè¯¥æ–¹æ³•åªè¦ä¸å­˜åœ¨å†™åç¨‹éƒ½ä¼šè·å–è¯»é”æˆåŠŸã€‚ TryRLock è¯•å›¾é”å®š rw ä»¥è¿›è¡Œè¯»å–ï¼Œå¹¶æŠ¥å‘Šæ˜¯å¦æˆåŠŸã€‚ è¯·æ³¨æ„ï¼Œè™½ç„¶ç¡®å®å­˜åœ¨å¯¹ TryRLock çš„æ­£ç¡®ä½¿ç”¨ï¼Œä½†å¾ˆå°‘ï¼Œè€Œä¸” TryRLock çš„ä½¿ç”¨é€šå¸¸è¡¨æ˜äº’æ–¥é‡çš„ç‰¹å®šä½¿ç”¨ä¸­å­˜åœ¨æ›´æ·±å±‚çš„é—®é¢˜ã€‚ è¯¥æ–¹æ³•åœ¨æ²¡æœ‰å†™æ“ä½œçš„æƒ…å†µä¸‹æ˜¯ä¸€å®šèƒ½æ‹¿å»åˆ°é”çš„ã€‚å­˜åœ¨å†™æ“ä½œæ—¶æ‰ä¼šè¿”å› falseã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 // TryRLock tries to lock rw for reading and reports whether it succeeded. // // Note that while correct uses of TryRLock do exist, they are rare, // and use of TryRLock is often a sign of a deeper problem // in a particular use of mutexes. func (rw *RWMutex) TryRLock() bool { if race.Enabled { _ = rw.w.state race.Disable() } // TryRLock å‡½æ•°è·å–åˆ°è¯»é”åªèƒ½å‘ç”Ÿåœ¨ readerCount \u0026gt;= 0 çŠ¶æ€ä¸‹ for { c := atomic.LoadInt32(\u0026amp;rw.readerCount)\t// åŸå­è¯»å– readerCount if c \u0026lt; 0 { // å†™æ“ä½œåœ¨è¿›è¡Œä¸­æˆ–è€…åœ¨ç­‰å¾…è¯»å®Œæˆã€‚ if race.Enabled { race.Enable() } return false } // å°è¯•åŸå­äº¤æ¢ readerCount å€¼ // å¦‚æœäº¤æ¢å¤±è´¥å¯èƒ½æœ‰å…¶ä»–è¯»æ“ä½œæˆ–å†™æ“ä½œå‘ç”Ÿï¼Œå†æ¬¡å¾ªç¯ã€‚ if atomic.CompareAndSwapInt32(\u0026amp;rw.readerCount, c, c+1) { if race.Enabled { race.Enable() race.Acquire(unsafe.Pointer(\u0026amp;rw.readerSem)) } return true\t// è·å–åˆ°é”å } } } RLocker() RLocker è¿”å›ä¸€ä¸ª Locker æ¥å£ï¼Œé€šè¿‡è°ƒç”¨ rw å®ç° Lock å’Œ Unlock æ–¹æ³•ã€‚RLock å’Œ rw.RUnlockã€‚ æ„ä¹‰åœ¨äºè¿”å›æ¥å£Lockeré™åˆ¶åªèƒ½è°ƒç”¨æ¥å£çš„ï¼Œæ¯”å¦‚ sync.Cond ä¸­éœ€è¦çš„é” 1 2 3 4 5 // RLocker returns a Locker interface that implements // the Lock and Unlock methods by calling rw.RLock and rw.RUnlock. func (rw *RWMutex) RLocker() Locker { return (*rlocker)(rw) } type Locker interface Lockeræ¥å£ä»£è¡¨ä¸€ä¸ªå¯ä»¥åŠ é”å’Œè§£é”çš„å¯¹è±¡ã€‚ è¯¥æ¥å£å®šä¹‰åœ¨sync/mutex.goæ–‡ä»¶ä¸­ã€‚ 1 2 3 4 type Locker interface { Lock() Unlock() } type rlocker RWMutex 1 type rlocker RWMutex\t// sync.RWMutex Lock() 1 2 3 4 5 6 func (r *rlocker) Lock() { // å› ä¸º rlocker å’Œ RWMutexæ˜¯ä¸¤ä¸ªç±»å‹ï¼Œè™½ç„¶åº•å±‚ä¸€æ · // ä½†æ˜¯ rlocker åªæ”¯æŒ Lock() å’Œ Unlock() æ–¹æ³• // éœ€è¦è½¬æ¢æˆ (*RWMutex) æ‰èƒ½è°ƒç”¨ RLock() æ–¹æ³•ã€‚ (*RWMutex)(r).RLock() } Unlock() 1 2 3 func (r *rlocker) Unlock() { (*RWMutex)(r).RUnlock() } ä½¿ç”¨ç¤ºä¾‹ è¯»å†™é”ï¼šæ˜¯å¤šè¯»å•å†™äº’æ–¥é”ï¼Œåˆ†åˆ«é’ˆå¯¹è¯»æ“ä½œå’Œå†™æ“ä½œè¿›è¡Œé”å®šå’Œè§£é”æ“ä½œ ç»å¸¸ç”¨äºè¯»æ¬¡æ•°è¿œè¿œå¤šäºå†™æ¬¡æ•°çš„åœºåˆ åœ¨Goè¯­è¨€ä¸­ï¼Œè¯»å†™é”ç”±ç»“æ„ä½“ç±»å‹ sync.RWMutex å®ç° åŸºæœ¬éµå®ˆåŸåˆ™ï¼š å†™é”å®šæƒ…å†µä¸‹ï¼Œå¯¹è¯»å†™é”å®šè¿›è¡Œè¯»é”å®šæˆ–å†™é”å®šï¼Œéƒ½å°†é˜»å¡ï¼Œè€Œä¸”è¯»é”ä¸å†™é”ä¹‹é—´æ˜¯äº’æ–¥çš„ è¯»é”å®šæƒ…å†µä¸‹ï¼Œå¯¹è¯»å†™é”è¿›è¡Œå†™é”å®šï¼Œå°†é˜»å¡ åŠ è¯»é”æ—¶ä¸ä¼šé˜»å¡ï¼Œå³å¯å¤šè¯» å¯¹æœªè¢«å†™é”å®šçš„è¯»å†™é”è¿›è¡Œå†™è§£é”ï¼Œä¼šå¼•å‘è¿è¡Œæ—¶å¼‚å¸¸ å¯¹æœªè¢«è¯»è¯»é”å®šçš„è¯»å†™é”è¿›è¡Œè¯»è§£é”æ—¶ä¹Ÿä¼šå¼•å‘è¿è¡Œæ—¶å¼‚å¸¸ å†™è§£é”åœ¨è¿›è¡Œçš„åŒæ—¶ä¼šè¯•å›¾å”¤é†’æ‰€æœ‰å› è¿›è¡Œè¯»é”å®šè€Œè¢«é˜»å¡çš„åç¨‹ è¯»è§£é”åœ¨è¿›è¡Œçš„æ—¶å€™åˆ™ä¼šè¯•å›¾å”¤é†’ä¸€ä¸ªå› è¿›è¡Œå†™é”å®šè€Œè¢«é˜»å¡çš„åç¨‹ ä¸äº’æ–¥é”ç±»å‹ï¼Œsync.RWMutex ç±»å‹çš„é›¶å€¼å°±å·²ç»æ˜¯ç«‹å³å¯ç”¨çš„è¯»å†™é”äº† 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;sync\u0026#34; \u0026#34;time\u0026#34; ) var m *sync.RWMutex func main() { wg := sync.WaitGroup{} wg.Add(20) var rwMutex sync.RWMutex Data := 0 for i := 0; i \u0026lt; 10; i++ { go func(t int) { rwMutex.RLock()\t// è¯»åŠ é” defer rwMutex.RUnlock()\t// è¯»è§£é” fmt.Printf(\u0026#34;è¯»æ•°æ®ï¼š%v %d\\n\u0026#34;, Data, i) wg.Done() time.Sleep(1 * time.Second) // è¿™å¥ä»£ç ç¬¬ä¸€æ¬¡è¿è¡Œåï¼Œè¯»è§£é” // å¾ªç¯åˆ°ç¬¬äºŒä¸ªæ—¶ï¼Œ è¯»é”å®šåï¼Œè¿™ä¸ªgoroutineå°±æ²¡æœ‰é˜»å¡ï¼ŒåŒæ—¶è¯»æˆåŠŸ }(i) go func(t int) { rwMutex.Lock()\t// å†™åŠ é” defer rwMutex.Unlock()\t// å†™è§£é” Data += 1 fmt.Printf(\u0026#34;å†™æ•°æ®ï¼š%v %d\\n\u0026#34;, Data, t) wg.Done() // å¯¹è¯»å†™é”è¿›è¡Œè¯»é”å®šæˆ–è€…å†™é”å®šï¼Œéƒ½å°†é˜»å¡ // å†™é”å®šä¸‹æ˜¯éœ€è¦è§£é”åæ‰èƒ½å†™çš„ time.Sleep(5 * time.Second) }(i) } wg.Wait() } è¯»æ•°æ®ï¼š0 3 å†™æ•°æ®ï¼š1 2 è¯»æ•°æ®ï¼š1 10 è¯»æ•°æ®ï¼š1 10 è¯»æ•°æ®ï¼š1 10 è¯»æ•°æ®ï¼š1 10 è¯»æ•°æ®ï¼š1 10 è¯»æ•°æ®ï¼š1 10 è¯»æ•°æ®ï¼š1 10 è¯»æ•°æ®ï¼š1 10 è¯»æ•°æ®ï¼š1 10 å†™æ•°æ®ï¼š2 1 å†™æ•°æ®ï¼š3 3 å†™æ•°æ®ï¼š4 4 å†™æ•°æ®ï¼š5 5 å†™æ•°æ®ï¼š6 6 å†™æ•°æ®ï¼š7 0 å†™æ•°æ®ï¼š8 9 å†™æ•°æ®ï¼š9 7 å†™æ•°æ®ï¼š10 8 é€šè¿‡ç¨‹åºè¿è¡Œçš„è¾“å‡ºå¯ä»¥çœ‹åˆ°ï¼Œåœ¨å†™é”å®šæƒ…å†µä¸‹ï¼Œå¯¹è¯»å†™é”è¿›è¡Œé”å®šæˆ–è€…å†™é”å®šï¼Œéƒ½å°†é˜»å¡ æŠŠå†™æ•°æ®ä¸­çš„Sleepè®¾ç½®æ›´é•¿æ—¶é—´ï¼Œåœ¨ç¬¬ä¸€æ¬¡å†™é”å®šåï¼Œè¯»æ•°æ®ä¹Ÿæ²¡æœ‰è¿›è¡Œ å†æ¬¡å†™é”å®šæ˜¯åœ¨ rwMutex.Unlock() å®Œæˆåï¼Œæ‰èƒ½è¿›è¡Œ rwMutex.lock() è€Œè¯»æ•°æ®æ—¶åˆ™å¯ä»¥å¤šæ¬¡è¯»ï¼Œä¸ä¸€å®šéœ€è¦ç­‰ rwMutex.RUnlock() å®Œæˆ ","permalink":"http://localhost:1313/posts/golang/sync/rwmutex/","summary":"RWMutexæ˜¯ä¸€ç§è¯»å†™äº’æ–¥é”ã€‚","title":"sync.RwMutex"},{"content":"type Once struct ğŸš€ Onceæ˜¯åªæ‰§è¡Œä¸€æ¬¡åŠ¨ä½œçš„å¯¹è±¡ï¼Œåº”ç”¨åœºæ™¯ï¼Œæ¯”å¦‚åŠ è½½é…ç½®æ–‡ä»¶åªéœ€è¦åŠ è½½ä¸€æ¬¡ã€‚ é¦–æ¬¡ä½¿ç”¨Onceåï¼Œä¸èƒ½å¤åˆ¶Onceã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 // Once is an object that will perform exactly one action. // // A Once must not be copied after first use. type Once struct { // done indicates whether the action has been performed. // It is first in the struct because it is used in the hot path. // The hot path is inlined at every call site. // Placing done first allows more compact instructions on some architectures (amd64/386), // and fewer instructions (to calculate offset) on other architectures. // // done è¡¨ç¤ºæ“ä½œæ˜¯å¦å·²ç»æ‰§è¡Œã€‚ // å®ƒåœ¨ç»“æ„ä½“ä¸­ä½äºé¦–ä½ï¼Œå› ä¸ºå®ƒåœ¨ hot path ä¸­ä½¿ç”¨ã€‚ // hot path å†…è”åœ¨æ¯ä¸ªè°ƒç”¨ç‚¹ã€‚ // åœ¨æŸäº›ä½“ç³»ç»“æ„ä¸Š(amd64/386)ï¼Œå°†doneæ”¾åœ¨ç¬¬ä¸€ä½å¯ä»¥è®©æŒ‡ä»¤æ›´ç´§å‡‘ï¼Œè€Œåœ¨å…¶ä»–ä½“ç³»ç»“æ„ä¸Šå¯ä»¥è®©æŒ‡ä»¤æ›´å°‘(ç”¨äºè®¡ç®—åç§»é‡)ã€‚ done uint32\t// 0.æœªè¢«è°ƒç”¨è¿‡ 1.å·²è¢«è°ƒç”¨è¿‡ m Mutex\t// äº’æ–¥é” } // å…¶ä¸­è§£é‡Šäº†ä¸ºä»€ä¹ˆå°† done ç½®ä¸º Once çš„ç¬¬ä¸€ä¸ªå­—æ®µï¼šdone åœ¨çƒ­è·¯å¾„ä¸­ï¼Œdone æ”¾åœ¨ç¬¬ä¸€ä¸ªå­—æ®µï¼Œèƒ½å¤Ÿå‡å°‘ CPU æŒ‡ä»¤ï¼Œä¹Ÿå°±æ˜¯è¯´ï¼Œè¿™æ ·åšèƒ½å¤Ÿæå‡æ€§èƒ½ã€‚ // 1. çƒ­è·¯å¾„(hot path)æ˜¯ç¨‹åºéå¸¸é¢‘ç¹æ‰§è¡Œçš„ä¸€ç³»åˆ—æŒ‡ä»¤ï¼Œsync.Once ç»å¤§éƒ¨åˆ†åœºæ™¯éƒ½ä¼šè®¿é—® o.doneï¼Œåœ¨çƒ­è·¯å¾„ä¸Šæ˜¯æ¯”è¾ƒå¥½ç†è§£çš„ï¼Œ //\tå¦‚æœ hot path ç¼–è¯‘åçš„æœºå™¨ç æŒ‡ä»¤æ›´å°‘ï¼Œæ›´ç›´æ¥ï¼Œå¿…ç„¶æ˜¯èƒ½å¤Ÿæå‡æ€§èƒ½çš„ã€‚ // 2. ä¸ºä»€ä¹ˆæ”¾åœ¨ç¬¬ä¸€ä¸ªå­—æ®µå°±èƒ½å¤Ÿå‡å°‘æŒ‡ä»¤å‘¢ï¼Ÿå› ä¸ºç»“æ„ä½“ç¬¬ä¸€ä¸ªå­—æ®µçš„åœ°å€å’Œç»“æ„ä½“çš„æŒ‡é’ˆæ˜¯ç›¸åŒçš„ï¼Œå¦‚æœæ˜¯ç¬¬ä¸€ä¸ªå­—æ®µï¼Œç›´æ¥å¯¹ç»“æ„ä½“çš„æŒ‡é’ˆè§£å¼•ç”¨å³å¯ã€‚ // å¦‚æœæ˜¯å…¶ä»–çš„å­—æ®µï¼Œé™¤äº†ç»“æ„ä½“æŒ‡é’ˆå¤–ï¼Œè¿˜éœ€è¦è®¡ç®—ä¸ç¬¬ä¸€ä¸ªå€¼çš„åç§»(calculate offset)ã€‚åœ¨æœºå™¨ç ä¸­ï¼Œåç§»é‡æ˜¯éšæŒ‡ä»¤ä¼ é€’çš„é™„åŠ å€¼ï¼Œ // CPU éœ€è¦åšä¸€æ¬¡åç§»å€¼ä¸æŒ‡é’ˆçš„åŠ æ³•è¿ç®—ï¼Œæ‰èƒ½è·å–è¦è®¿é—®çš„å€¼çš„åœ°å€ã€‚å› ä¸ºï¼Œè®¿é—®ç¬¬ä¸€ä¸ªå­—æ®µçš„æœºå™¨ä»£ç æ›´ç´§å‡‘ï¼Œé€Ÿåº¦æ›´å¿«ã€‚ Do() å½“ä¸”ä»…å½“ Do æ˜¯ç¬¬ä¸€æ¬¡ä¸º Once å®ä¾‹è°ƒç”¨å‡½æ•° f æ—¶ï¼ŒDo æ‰ä¼šè°ƒç”¨å‡½æ•° fã€‚ æ¢å¥è¯è¯´ï¼Œç»™å®švar once Onceï¼Œå¦‚æœ once.Do(f) è¢«å¤šæ¬¡è°ƒç”¨ï¼Œåªæœ‰ç¬¬ä¸€æ¬¡è°ƒç”¨ä¼šè°ƒç”¨fï¼Œå³ä½¿æ¯æ¬¡è°ƒç”¨ f çš„å€¼ä¸åŒã€‚ æ¯ä¸ªå‡½æ•°æ‰§è¡Œæ—¶éƒ½éœ€è¦ä¸€ä¸ª Once çš„æ–°å®ä¾‹ã€‚ Do ç”¨äºå¿…é¡»åªè¿è¡Œä¸€æ¬¡çš„åˆå§‹åŒ–ã€‚ ç”±äº f æ˜¯ niladicï¼Œå› æ­¤å¯èƒ½éœ€è¦ä½¿ç”¨å‡½æ•°å­—é¢é‡æ¥æ•è·Doè°ƒç”¨çš„å‡½æ•°çš„å‚æ•°:config.once.Do(func() { config.init(filename) }) niladicï¼šè¢«è§£é‡Šä¸ºä¸å¸¦å‚æ•°çš„é—­åŒ…å‡½æ•°ã€‚ å› ä¸ºåªæœ‰åœ¨å¯¹ f çš„è°ƒç”¨è¿”å›ä¹‹å‰ï¼Œæ‰ä¼šè¿”å›å¯¹ Do çš„è°ƒç”¨ï¼Œå¦‚æœ f å¯¼è‡´Doè¢«è°ƒç”¨ï¼Œå®ƒå°±ä¼šæ­»é”ã€‚ï¼ˆfå‡½æ•°å†…ä¸èƒ½åœ¨è°ƒç”¨å¤–å±‚çš„Doå‡½æ•°ï¼‰ å¦‚æœfå‘ç”Ÿpanicï¼ŒDoè®¤ä¸ºå®ƒå›æ¥äº†;Doçš„åç»­è°ƒç”¨ä¸éœ€è¦è°ƒç”¨fã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 // Do calls the function f if and only if Do is being called for the // first time for this instance of Once. In other words, given // var once Once // if once.Do(f) is called multiple times, only the first call will invoke f, // even if f has a different value in each invocation. A new instance of // Once is required for each function to execute. // // Do is intended for initialization that must be run exactly once. Since f // is niladic, it may be necessary to use a function literal to capture the // arguments to a function to be invoked by Do: // config.once.Do(func() { config.init(filename) }) // // Because no call to Do returns until the one call to f returns, if f causes // Do to be called, it will deadlock. // // If f panics, Do considers it to have returned; future calls of Do return // without calling f. func (o *Once) Do(f func()) { // Note: Here is an incorrect implementation of Do: // //\tif atomic.CompareAndSwapUint32(\u0026amp;o.done, 0, 1) { //\tf() //\t} // // Do guarantees that when it returns, f has finished. // This implementation would not implement that guarantee: // given two simultaneous calls, the winner of the cas would // call f, and the second would return immediately, without // waiting for the first\u0026#39;s call to f to complete. // This is why the slow path falls back to a mutex, and why // the atomic.StoreUint32 must be delayed until after f returns. // // æ³¨æ„:ä¸‹é¢æ˜¯ä¸€ä¸ªä¸æ­£ç¡®çš„Doå®ç°ã€‚ // ä»¥ä¸‹å½¢å¼ä¸èƒ½ä¿è¯Doå‡½æ•°è¿”å›æ—¶få‡½æ•°å·²æ‰§è¡Œå®Œï¼Œå› ä¸ºæˆ‘ä»¬æ˜¯å…ˆæ ‡è®°åæ‰§è¡Œfçš„ã€‚ // if atomic.CompareAndSwapUint32(\u0026amp;o.done, 0, 1) { // f() // } // // Do ä¿è¯å½“å®ƒè¿”å›æ—¶ï¼Œf å·²ç»å®Œæˆ // è¿™ç§å®ç°ä¸ä¼šå®ç°è¿™ç§ä¿è¯:ç»™å®šä¸¤ä¸ªåŒæ—¶è°ƒç”¨ï¼Œcasçš„èµ¢å®¶å°†è°ƒç”¨fï¼Œè€Œç¬¬äºŒä¸ªå°†ç«‹å³è¿”å›ï¼Œè€Œæ— éœ€ç­‰å¾…ç¬¬ä¸€ä¸ªè°ƒç”¨å®Œæˆã€‚ // è¿™å°±æ˜¯æ…¢è·¯å¾„å›é€€åˆ°äº’æ–¥é‡çš„åŸå› ï¼Œä¹Ÿæ˜¯åŸå­æ€§çš„åŸå› ã€‚StoreUint32å¿…é¡»å»¶è¿Ÿåˆ°fè¿”å›ä¹‹åã€‚ // åç»­å¤§éƒ¨åˆ†æƒ…å†µä¼šä»è¿™é‡Œåˆ¤æ–­å¤±è´¥ if atomic.LoadUint32(\u0026amp;o.done) == 0 { // Outlined slow-path to allow inlining of the fast-path. o.doSlow(f) } } doSlow() 1 2 3 4 5 6 7 8 9 10 11 12 func (o *Once) doSlow(f func()) { o.m.Lock() // è·å–é” defer o.m.Unlock() // å»¶è¿Ÿé‡Šæ”¾é” // å½“å‡ºç°å¹¶å‘æ—¶ï¼Œè¿™é‡Œä¼šæ‹¦ä½ç­‰å¾…ç€çš„åç¨‹ if o.done == 0 {\t// åœ¨f()æ‰§è¡Œå®Œåæ‰ä¼šæ ‡è®°doneä¸º1ã€‚ defer atomic.StoreUint32(\u0026amp;o.done, 1) // éœ€è¦ä¿è¯få‡½æ•°ä¸ä¼šå‘ç”Ÿpanic // å¦‚æœå‘ç”Ÿpanicï¼Œåˆ™o.doneä¼šè¢«æ ‡è®°ä¸º1ï¼Œåç»­ä¸ä¼šåœ¨è°ƒç”¨få‡½æ•° f() } } ä½¿ç”¨åœºæ™¯ sync.Once æ˜¯ Go æ ‡å‡†åº“æä¾›çš„ä½¿å‡½æ•°åªæ‰§è¡Œä¸€æ¬¡çš„å®ç°ã€‚ å¸¸åº”ç”¨äºã€å•ä¾‹æ¨¡å¼ã€‘ï¼Œä¾‹å¦‚ã€åˆå§‹åŒ–é…ç½®ã€‘ã€ã€ä¿æŒæ•°æ®åº“è¿æ¥ã€‘ç­‰ã€‚ä½œç”¨ä¸ init å‡½æ•°ç±»ä¼¼ï¼Œä½†æœ‰åŒºåˆ«ã€‚ init å‡½æ•°æ˜¯å½“æ‰€åœ¨çš„ package é¦–æ¬¡è¢«åŠ è½½æ—¶æ‰§è¡Œï¼Œè‹¥è¿Ÿè¿Ÿæœªè¢«ä½¿ç”¨ï¼Œåˆ™æ—¢æµªè´¹äº†å†…å­˜ï¼Œåˆå»¶é•¿äº†ç¨‹åºåŠ è½½æ—¶é—´ã€‚ sync.Once å¯ä»¥åœ¨ä»£ç çš„ä»»æ„ä½ç½®åˆå§‹åŒ–å’Œè°ƒç”¨ï¼Œå› æ­¤å¯ä»¥å»¶è¿Ÿåˆ°ä½¿ç”¨æ—¶å†æ‰§è¡Œï¼Œå¹¶å‘åœºæ™¯ä¸‹æ˜¯çº¿ç¨‹å®‰å…¨çš„ã€‚ åœ¨å¤šæ•°æƒ…å†µä¸‹ï¼Œsync.Once è¢«ç”¨äºæ§åˆ¶å˜é‡çš„åˆå§‹åŒ–ï¼Œè¿™ä¸ªå˜é‡çš„è¯»å†™æ»¡è¶³å¦‚ä¸‹ä¸‰ä¸ªæ¡ä»¶ï¼š å½“ä¸”ä»…å½“ç¬¬ä¸€æ¬¡è®¿é—®æŸä¸ªå˜é‡æ—¶ï¼Œè¿›è¡Œåˆå§‹åŒ–ï¼ˆå†™ï¼‰ã€‚ å˜é‡åˆå§‹åŒ–è¿‡ç¨‹ä¸­ï¼Œæ‰€æœ‰è¯»éƒ½è¢«é˜»å¡ï¼Œç›´åˆ°åˆå§‹åŒ–å®Œæˆã€‚ å˜é‡ä»…åˆå§‹åŒ–ä¸€æ¬¡ï¼Œåˆå§‹åŒ–å®Œæˆåé©»ç•™åœ¨å†…å­˜é‡Œã€‚ sync.Once ä»…æä¾›äº†ä¸€ä¸ªæ–¹æ³• Doï¼Œå‚æ•° f æ˜¯å¯¹è±¡åˆå§‹åŒ–å‡½æ•°ã€‚ func (o *Once) Do(f func())ã€‚ ä½¿ç”¨ç¤ºä¾‹ ç®€å•çš„ç¤ºä¾‹ è€ƒè™‘ä¸€ä¸ªç®€å•çš„åœºæ™¯ï¼Œå‡½æ•° ReadConfig éœ€è¦è¯»å–ç¯å¢ƒå˜é‡ï¼Œå¹¶è½¬æ¢ä¸ºå¯¹åº”çš„é…ç½®ã€‚ ç¯å¢ƒå˜é‡åœ¨ç¨‹åºæ‰§è¡Œå‰å·²ç»ç¡®å®šï¼Œæ‰§è¡Œè¿‡ç¨‹ä¸­ä¸ä¼šå‘ç”Ÿæ”¹å˜ã€‚ ReadConfig å¯èƒ½ä¼šè¢«å¤šä¸ªåç¨‹å¹¶å‘è°ƒç”¨ï¼Œä¸ºäº†æå‡æ€§èƒ½ï¼ˆå‡å°‘æ‰§è¡Œæ—¶é—´å’Œå†…å­˜å ç”¨ï¼‰ï¼Œä½¿ç”¨ sync.Once æ˜¯ä¸€ä¸ªæ¯”è¾ƒå¥½çš„æ–¹å¼ã€‚ åœ¨è¿™ä¸ªä¾‹å­ä¸­ï¼Œå£°æ˜äº† 2 ä¸ªå…¨å±€å˜é‡ï¼Œonce å’Œ configã€‚ config æ˜¯éœ€è¦åœ¨ ReadConfig å‡½æ•°ä¸­åˆå§‹åŒ–çš„(å°†ç¯å¢ƒå˜é‡è½¬æ¢ä¸º Config ç»“æ„ä½“)ï¼ŒReadConfig å¯èƒ½ä¼šè¢«å¹¶å‘è°ƒç”¨ã€‚ å¦‚æœ ReadConfig æ¯æ¬¡éƒ½æ„é€ å‡ºä¸€ä¸ªæ–°çš„ Config ç»“æ„ä½“ï¼Œæ—¢æµªè´¹å†…å­˜ï¼Œåˆæµªè´¹åˆå§‹åŒ–æ—¶é—´ã€‚ å¦‚æœ ReadConfig ä¸­ä¸åŠ é”ï¼Œåˆå§‹åŒ–å…¨å±€å˜é‡ config å°±å¯èƒ½å‡ºç°å¹¶å‘å†²çªã€‚ è¿™ç§æƒ…å†µä¸‹ï¼Œä½¿ç”¨ sync.Once æ—¢èƒ½å¤Ÿä¿è¯å…¨å±€å˜é‡åˆå§‹åŒ–æ—¶æ˜¯çº¿ç¨‹å®‰å…¨çš„ï¼Œåˆèƒ½èŠ‚çœå†…å­˜å’Œåˆå§‹åŒ–æ—¶é—´ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 type Config struct { Server string Port int64 } var ( once sync.Once config *Config ) func ReadConfig() *Config { once.Do(func() { var err error config = \u0026amp;Config{Server: os.Getenv(\u0026#34;TT_SERVER_URL\u0026#34;)} config.Port, err = strconv.ParseInt(os.Getenv(\u0026#34;TT_PORT\u0026#34;), 10, 0) if err != nil { config.Port = 8080 // default port } log.Println(\u0026#34;init config\u0026#34;) }) return config } func main() { for i := 0; i \u0026lt; 10; i++ { go func() { _ = ReadConfig() }() } time.Sleep(time.Second) } æ ‡å‡†åº“ä¸­çš„ä½¿ç”¨ æ¯”å¦‚ package html ä¸­ï¼Œå¯¹è±¡ entity åªè¢«åˆå§‹åŒ–ä¸€æ¬¡ã€‚ å­—å…¸ entity åŒ…å« 2005 ä¸ªé”®å€¼å¯¹ï¼Œè‹¥ä½¿ç”¨ init åœ¨åŒ…åŠ è½½æ—¶åˆå§‹åŒ–ï¼Œè‹¥ä¸è¢«ä½¿ç”¨ï¼Œå°†ä¼šæµªè´¹å¤§é‡å†…å­˜ã€‚ html.UnescapeString(s) å‡½æ•°æ˜¯çº¿ç¨‹å®‰å…¨çš„ï¼Œå¯èƒ½ä¼šè¢«ç”¨æˆ·ç¨‹åºåœ¨å¹¶å‘åœºæ™¯ä¸‹è°ƒç”¨ï¼Œå› æ­¤å¯¹ entity çš„åˆå§‹åŒ–éœ€è¦åŠ é”ï¼Œä½¿ç”¨ sync.Once èƒ½ä¿è¯è¿™ä¸€ç‚¹ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 var populateMapsOnce sync.Once var entity map[string]rune func populateMaps() { entity = map[string]rune{ \u0026#34;AElig;\u0026#34;: \u0026#39;\\U000000C6\u0026#39;, \u0026#34;AMP;\u0026#34;: \u0026#39;\\U00000026\u0026#39;, \u0026#34;Aacute;\u0026#34;: \u0026#39;\\U000000C1\u0026#39;, \u0026#34;Abreve;\u0026#34;: \u0026#39;\\U00000102\u0026#39;, \u0026#34;Acirc;\u0026#34;: \u0026#39;\\U000000C2\u0026#39;, // çœç•¥ 2000 é¡¹ } } func UnescapeString(s string) string { populateMapsOnce.Do(populateMaps) i := strings.IndexByte(s, \u0026#39;\u0026amp;\u0026#39;) if i \u0026lt; 0 { return s } // çœç•¥åç»­çš„å®ç° } æ™®é€šç¤ºä¾‹ å¯¹åªéœ€è¦è¿è¡Œä¸€æ¬¡çš„ä»£ç ï¼Œå¦‚å…¨å±€æ€§çš„åˆå§‹åŒ–æ“ä½œï¼Œæˆ–è€…é˜²æ­¢å¤šæ¬¡é‡å¤æ‰§è¡Œï¼ˆæ¯”å¦‚é‡å¤æäº¤ç­‰ï¼‰éƒ½æœ‰å¾ˆå¥½çš„ä½œç”¨ æ— è®º sync.Once.Do(f func()) é‡Œé¢çš„få‡½æ•°æ˜¯å¦å˜åŒ–ï¼Œåªè¦ Once.Do() è¿è¡Œä¸€æ¬¡å°±æ²¡æœ‰æœºä¼šå†æ¬¡è¿è¡Œäº† Once æ˜¯ä¸€ä¸ªç»“æ„ä½“ï¼Œé€šè¿‡åˆ¤æ–­ done å€¼æ¥ç¡®å®šæ˜¯å¦æ‰§è¡Œä¸‹ä¸€æ­¥ å½“ done ä¸º1æ—¶ç›´æ¥è¿”å›ï¼Œå¦åˆ™é”å®šåæ‰§è¡Œfå‡½æ•°ä»¥åŠç½®doneå€¼ä¸º1 è€Œå¯¹ done çš„å€¼å¾—ä¿®æ”¹ä½¿ç”¨äº† atomic.StoreUint32ï¼ˆåŸå­çº§çš„æ“ä½œï¼‰ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;sync\u0026#34; \u0026#34;time\u0026#34; ) var once sync.Once func onces() { fmt.Println(\u0026#34;once\u0026#34;) } func onced() { fmt.Println(\u0026#34;onced\u0026#34;) } func main() { for i, v := range make([]string, 10){ once.Do(onces) fmt.Println(\u0026#34;v:\u0026#34;, v, \u0026#34;--i:\u0026#34;, i) } for i := 0; i \u0026lt; 10; i++ { go func(i int) { once.Do(onced) fmt.Println(i) }(i) } time.Sleep(3 * time.Second) } once v: --i: 0 v: --i: 1 v: --i: 2 v: --i: 3 v: --i: 4 v: --i: 5 v: --i: 6 v: --i: 7 v: --i: 8 v: --i: 9 0 1 3 4 2 6 5 7 8 9 ","permalink":"http://localhost:1313/posts/golang/sync/once/","summary":"Onceæ˜¯åªæ‰§è¡Œä¸€ä¸ªåŠ¨ä½œçš„å¯¹è±¡ã€‚","title":"sync.Once"},{"content":"type Mutex struct ğŸš€ åŒ…è¯´æ˜ï¼š\nsync åŒ…æä¾›äº†åŸºæœ¬çš„åŒæ­¥åŸè¯­ï¼Œå¦‚äº’æ–¥é”ã€‚ é™¤äº† Once å’Œ WaitGroup ç±»å‹ä¹‹å¤–ï¼Œå¤§å¤šæ•°éƒ½ä¾›åº•å±‚åº“ä¾‹ç¨‹ä½¿ç”¨ã€‚ æ›´é«˜å±‚æ¬¡çš„åŒæ­¥æœ€å¥½é€šè¿‡ channels å’Œé€šä¿¡æ¥å®Œæˆã€‚ åŒ…å«åœ¨æ­¤åŒ…ä¸­å®šä¹‰çš„ç±»å‹çš„å€¼ä¸åº”è¢«å¤åˆ¶ã€‚ 1 2 3 4 5 6 7 // Package sync provides basic synchronization primitives such as mutual // exclusion locks. Other than the Once and WaitGroup types, most are intended // for use by low-level library routines. Higher-level synchronization is // better done via channels and communication. // // Values containing the types defined in this package should not be copied. package sync Mutex æ˜¯ä¸€æŠŠäº’æ–¥é”ã€‚äº’æ–¥é”çš„é›¶å€¼æ˜¯æœªé”å®šçš„ã€‚ Mutex åœ¨ç¬¬ä¸€æ¬¡ä½¿ç”¨åä¸èƒ½è¢«å¤åˆ¶ã€‚ åœ¨ Go å†…å­˜æ¨¡å‹çš„æœ¯è¯­ä¸­ï¼Œç¬¬ n æ¬¡è°ƒç”¨ Unlockï¼Œç¬¬ m æ¬¡è°ƒç”¨ Lock åœ¨åŒæ­¥å®Œæˆä»¥å‰ ä»»ä½• n \u0026lt; mã€‚ æˆåŠŸè°ƒç”¨ TryLock ç­‰åŒäºè°ƒç”¨ Lockã€‚è°ƒç”¨ TryLock å¤±è´¥æ ¹æœ¬ä¸ä¼šå»ºç«‹ä»»ä½•å…³ç³» åœ¨åŒæ­¥å®Œæˆä»¥å‰ã€‚ å®ƒæ˜¯ä¸€æŠŠç»“åˆäº†ã€è‡ªæ—‹é”ã€‘å’Œã€ä¿¡å·é‡ã€‘ä¼˜åŒ–è¿‡çš„é”ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 // A Mutex is a mutual exclusion lock. // The zero value for a Mutex is an unlocked mutex. // // A Mutex must not be copied after first use. // // In the terminology of the Go memory model, // the n\u0026#39;th call to Unlock â€œsynchronizes beforeâ€ the m\u0026#39;th call to Lock // for any n \u0026lt; m. // A successful call to TryLock is equivalent to a call to Lock. // A failed call to TryLock does not establish any â€œsynchronizes beforeâ€ // relation at all. type Mutex struct { // Mutex çš„çŠ¶æ€ä¿¡æ¯ state int32\t// åˆå§‹æ—¶ä¸º 0 // semaphore ç›¸å…³å­—æ®µï¼Œè¯¥å­—æ®µä¹Ÿæ˜¯ä¸ºä»€ä¹ˆ Mutex ä¸è®©æ‹·è´çš„åŸå›  sema uint32 // åˆå§‹æ—¶ä¸º 0 } Mutex çš„å†…å­˜å¸ƒå±€ï¼š Mutex æ˜¯ä¸€ä¸ªäº’æ–¥é”ï¼Œå¯ä»¥åˆ›å»ºä¸ºå…¶ä»–ç»“æ„ä½“çš„å­—æ®µï¼Œé›¶å€¼ä¸ºè§£é”çŠ¶æ€ã€‚ Mutex ç±»å‹çš„é”å’Œçº¿ç¨‹æ— å…³ï¼Œå¯ä»¥ç”±ä¸åŒçš„çº¿ç¨‹åŠ é”å’Œè§£é”ã€‚ Mutex ç»“æ„å¸ƒå±€ï¼š state è®°å½• Mutex çš„ç›¸å…³ä¿¡æ¯ã€‚ sema åœ¨ Mutex ä¸­æ²¡æœ‰ä»»ä½•ä½œç”¨ï¼Œä¸»è¦æ˜¯åœ¨ semaphore ä¸­ï¼Œè¯¥å­—æ®µæ˜¯ Mutex ä¸èƒ½è¢«æ‹·è´çš„æ ¹æœ¬åŸå› ï¼Œåœ¨ semaphore ä¸­ä¸»è¦æ ‡è¯†æœ‰ wakeup å‘ç”Ÿã€‚ ã€æ­£å¸¸æ¨¡å¼ã€‘å’Œã€é¥¥é¥¿æ¨¡å¼ã€‘ï¼š æ­£å¸¸æ¨¡å¼ï¼šä¸€ä¸ªå°è¯•åŠ é”çš„ goroutine ä¼šå…ˆè‡ªæ—‹å‡ æ¬¡ï¼Œå°è¯•é€šè¿‡åŸå­æ“ä½œè·å¾—é”ï¼Œè‹¥å‡ æ¬¡è‡ªæ—‹ä¹‹åä»ä¸èƒ½è·å¾—é”ï¼Œåˆ™é€šè¿‡ä¿¡å·é‡ï¼ˆsemaphoreï¼‰æ’é˜Ÿç­‰å¾…ã€‚æ‰€æœ‰çš„ç­‰å¾…è€…ä¼šæŒ‰ç…§å…ˆå…¥å…ˆå‡ºï¼ˆFIFOï¼‰çš„é¡ºåºæ’é˜Ÿï¼Œä½†æ˜¯å½“ä¸€ä¸ªç­‰å¾…è€…è¢«å”¤é†’åå¹¶ä¸ä¼šç›´æ¥æ‹¥æœ‰é”ï¼Œè€Œæ˜¯éœ€è¦å’Œåæ¥è€…ï¼ˆå¤„äºè‡ªæ—‹é˜¶æ®µï¼Œå°šæœªæ’é˜Ÿç­‰å¾…çš„åç¨‹ï¼‰ç«äº‰ã€‚è¿™ç§æƒ…å†µä¸‹åæ¥è€…æ›´æœ‰ä¼˜åŠ¿ï¼Œä¸€æ–¹é¢åŸå› æ˜¯åæ¥è€…æ­£åœ¨CPUä¸Šè¿è¡Œï¼Œè‡ªç„¶æ¯”åˆšå”¤é†’çš„ goroutine æ›´æœ‰ä¼˜åŠ¿ï¼Œå¦ä¸€æ–¹é¢å¤„äºè‡ªæ—‹çŠ¶æ€çš„ goroutine å¯ä»¥æœ‰å¾ˆå¤šï¼Œè€Œè¢«å”¤é†’çš„ goroutine æ¯æ¬¡åªæœ‰ä¸€ä¸ªï¼Œæ‰€ä»¥è¢«å”¤é†’çš„ goroutine æœ‰å¾ˆå¤§æ¦‚ç‡è·å–ä¸åˆ°é”ï¼Œè¿™ç§æƒ…å†µä¸‹å®ƒä¼šè¢«é‡æ–°æ’å…¥é˜Ÿåˆ—çš„å¤´éƒ¨ï¼Œè€Œä¸æ˜¯å°¾éƒ¨ã€‚å½“ä¸€ä¸ª goroutine æœ¬æ¬¡åŠ é”ç­‰å¾…çš„æ—¶é—´è¶…è¿‡äº† 1ms åï¼Œå®ƒä¼šæŠŠå½“å‰ Mutex åˆ‡æ¢è‡³é¥¥é¥¿çŠ¶æ€ã€‚ é¥¥é¥¿æ¨¡å¼ï¼šMutex çš„æ‰€æœ‰æƒä»æ‰§è¡Œ Unlock çš„ goroutine ç›´æ¥ä¼ é€’ç»™ç­‰å¾…é˜Ÿåˆ—å¤´éƒ¨çš„ goroutineã€‚åæ¥è€…ä¸ä¼šè‡ªæ—‹ï¼Œä¹Ÿä¸ä¼šå°è¯•è·å¾—é”ï¼Œå®ƒä»¬ä¼šç›´æ¥ä»é˜Ÿåˆ—çš„å°¾éƒ¨æ’é˜Ÿç­‰å¾…ï¼Œå³ä½¿ Mutex å¤„äº Unlocked çŠ¶æ€ã€‚å½“ä¸€ä¸ªç­‰å¾…è€…è·å¾—äº†é”ä¹‹åï¼Œå®ƒä¼šåœ¨ä»¥ä¸‹ä¸¤ç§æƒ…å†µæ—¶å°† Mutex ç”±é¥¥é¥¿æ¨¡å¼åˆ‡æ¢å›æ­£å¸¸æ¨¡å¼ï¼š(1)å®ƒæ˜¯æœ€åä¸€ä¸ªç­‰å¾…è€…ï¼Œå³ç­‰å¾…é˜Ÿåˆ—ç©ºäº†ã€‚(2)å®ƒçš„ç­‰å¾…æ—¶é—´å°äº1msï¼Œä¹Ÿå°±æ˜¯å®ƒåˆšæ¥ä¸ä¹…ï¼Œåé¢è‡ªç„¶æ›´æ²¡æœ‰é¥¥é¥¿çš„ goroutine äº†ã€‚ æ­£å¸¸æ¨¡å¼ä¸‹ Mutex æœ‰æ›´å¥½çš„æ€§èƒ½ï¼Œä½†æ˜¯é¥¥é¥¿æ¨¡å¼å¯¹äºé˜²æ­¢å°¾ç«¯å»¶é•¿ï¼ˆé˜Ÿåˆ—å°¾ç«¯çš„ goroutine è¿Ÿè¿ŸæŠ¢ä¸åˆ°é”ï¼‰æ¥è®²ç‰¹åˆ«é‡è¦ã€‚ const 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 const ( // æ˜¯å¦ä¸Šé”æ ‡å¿—ä½ï¼›0-æœªä¸Šé”ï¼Œ1-å·²ä¸Šé”ï¼› mutexLocked = 1 \u0026lt;\u0026lt; iota\t// 001 // æ˜¯å¦æœ‰ goroutine ä»é˜»å¡ä¸­è¢«å”¤é†’ï¼›0-æ²¡æœ‰ï¼›1-æœ‰ï¼› // å½“è¯¥æ ‡å¿—ä½è¢«è®¾ç½®æ—¶ï¼ŒUnlock æ“ä½œä¸ä¼šå”¤é†’æ’é˜Ÿçš„ goroutineã€‚ mutexWoken\t// 010 // æ˜¯å¦å¤„äºé¥¥é¥¿æ¨¡å¼ï¼›0-éé¥¥é¥¿ï¼Œ1-é¥¥é¥¿ï¼› mutexStarving\t// 100 // æœ€ä½ä½å­˜åœ¨3ä¸ªbitä½æ ‡è¯†ç‰¹ä¿—ä¿¡æ¯ï¼Œåˆ†åˆ«ä¸ºä¸Šè¿°çš„ mutexLockedã€mutexWokenã€mutexStarving mutexWaiterShift = iota\t// 3 // äº’æ–¥å…¬å¹³ // äº’æ–¥é‡å¯ä»¥æœ‰ä¸¤ç§æ“ä½œæ¨¡å¼:æ­£å¸¸(normal)å’Œé¥¥é¥¿(starvation)ã€‚ // åœ¨æ­£å¸¸æ¨¡å¼(normal mode)ä¸‹ï¼šç­‰å¾…çš„waitersæŒ‰FIFO(å…ˆè¿›å…ˆå‡º)é¡ºåºæ’é˜Ÿï¼Œä½†è¢«å”¤é†’çš„waiterä¸æ‹¥æœ‰äº’æ–¥é”ï¼Œå¹¶ä¸æ–°åˆ°è¾¾çš„goroutinesç«äº‰æ‰€æœ‰æƒã€‚ // æ–°åŠ å…¥çš„goroutinesæœ‰ä¸€ä¸ªä¼˜åŠ¿ï¼Œå®ƒä»¬å·²ç»åœ¨CPUä¸Šè¿è¡Œï¼Œå¹¶ä¸”å¯èƒ½æœ‰å¾ˆå¤šï¼Œæ‰€ä»¥å”¤é†’çš„waiterså¾ˆæœ‰å¯èƒ½ä¼šå¤±è´¥ã€‚ // åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œå®ƒè¢«é‡æ–°å®‰æ’åœ¨ç­‰å¾…é˜Ÿåˆ—çš„å‰é¢ã€‚å¦‚æœwaiterè¶…è¿‡1msæœªèƒ½è·å–äº’æ–¥é”ï¼Œå®ƒå°†äº’æ–¥é”åˆ‡æ¢åˆ°é¥¥é¥¿æ¨¡å¼ã€‚ // åœ¨é¥¥é¥¿æ¨¡å¼(starvation mode)ä¸‹ï¼šäº’æ–¥é”çš„æ‰€æœ‰æƒç›´æ¥ä»æ­£åœ¨è§£é”çš„goroutineç§»äº¤ç»™é˜Ÿåˆ—å‰é¢çš„waiterã€‚ // æ–°åˆ°è¾¾çš„goroutinesä¸ä¼šå°è¯•è·å–äº’æ–¥é”ï¼Œå³ä½¿å®ƒçœ‹èµ·æ¥å·²ç»è§£é”ï¼Œä¹Ÿä¸ä¼šå°è¯•æ—‹è½¬ã€‚ç›¸åï¼Œå®ƒä»¬æŠŠè‡ªå·±æ’åœ¨ç­‰å¾…é˜Ÿåˆ—çš„å°¾éƒ¨ã€‚ // å¦‚æœä¸€ä¸ªwaiteræ”¶åˆ°äº’æ–¥é”çš„æ‰€æœ‰æƒï¼Œå¹¶ä¸”å‘ç° //\t1) å®ƒæ˜¯é˜Ÿåˆ—ä¸­æœ€åä¸€ä¸ªwaiterï¼Œæˆ–è€… //\t2) å®ƒç­‰å¾…çš„æ—¶é—´å°‘äº1æ¯«ç§’ï¼Œå®ƒä¼šå°†äº’æ–¥é”åˆ‡æ¢å›æ­£å¸¸å·¥ä½œæ¨¡å¼ã€‚ // æ™®é€šæ¨¡å¼(Normal mode)å…·æœ‰æ›´å¥½çš„æ€§èƒ½ï¼Œå› ä¸ºgoroutineå¯ä»¥è¿ç»­å¤šæ¬¡è·å–äº’æ–¥é‡ï¼Œå³ä½¿æœ‰é˜»å¡çš„ç­‰å¾…ã€‚ // é¥¥é¥¿æ¨¡å¼(Starvation mode)å¯¹äºé¢„é˜²æœ‰äº›gä¸€å€¼è·å–ä¸åˆ°é”çš„å°¾å»¶è¿Ÿå…·æœ‰é‡è¦æ„ä¹‰ã€‚(è¯¥æ¨¡å¼é˜²æ­¢æœ‰äº›å§‹ç»ˆæ‹¿ä¸åˆ°é”çš„ä¸€ç›´ç­‰å¾…åœ¨ä¿¡å·æ± é‡Œé¢çš„goroutine) // æ­£å¸¸æ¨¡å¼ \u0026lt;-\u0026gt; é¥¥é¥¿æ¨¡å¼ ç›¸äº’è½¬æ¢çš„æ—¶é—´é˜€é—¨ // é¥¥é¥¿æ¨¡å¼ï¼Œå½“å‰ä»semaphoreä¸­wakeupçš„goroutineçš„sleepæ—¶é—´è¶…è¿‡1msï¼Œå†æ¬¡è·å–é”å¤±è´¥æ—¶ä¼šè¢«æ ‡è®°ä¸ºé¥¥é¥¿æ¨¡å¼ // é¥¥é¥¿æ¨¡å¼ä¸‹ï¼šstate å€¼çš„ mutexLockedå’ŒmutexWoken ä½å¯èƒ½ä¸º0æˆ–1ï¼Œè¢«å”¤é†’çš„goroutine mutexLockedå’ŒmutexWoken ä½éƒ½ä¸º0 starvationThresholdNs = 1e6\t// sync.Mutex è¿›å…¥é¥¥é¥¿æ¨¡å¼çš„ç­‰å¾…æ—¶é—´é˜ˆå€¼1msã€‚ ) Lock() Lock é”ä½ mã€‚ å¦‚æœé”å·²ç»è¢«ä½¿ç”¨ï¼Œè°ƒç”¨ goroutine ä¼šé˜»å¡ï¼Œç›´åˆ° mutex å¯ç”¨ã€‚ Lock å’Œ Unlock æ˜¯ä¸€å¯¹æ“ä½œã€‚ è¯¥æ–¹æ³•ä¸»è¦é€šè¿‡ atomic å‡½æ•°å®ç°äº†Fast pathï¼Œç›¸åº”çš„Slow pathè¢«å•ç‹¬æ”¾åœ¨äº†lockSlow()æ–¹æ³•ä¸­ã€‚ æ ¹æ®æºç æ³¨é‡Šçš„è¯´æ³•ï¼Œè¿™æ ·æ˜¯ä¸ºäº†ä¾¿äºç¼–è¯‘å™¨å¯¹ Fast path è¿›è¡Œå†…è”ä¼˜åŒ–ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 // Lock locks m. // If the lock is already in use, the calling goroutine // blocks until the mutex is available. func (m *Mutex) Lock() { // 1) ä½¿ç”¨CASå°è¯•è·å–é” // Fast pathæœŸæœ› Mutex å¤„äº Unlocked çŠ¶æ€ï¼Œæ²¡æœ‰ goroutine åœ¨æ’é˜Ÿï¼Œæ›´ä¸ä¼šé¥¥é¥¿ã€‚ // ç†æƒ³çŠ¶æ€ä¸‹ï¼Œä¸€ä¸ªCASæ“ä½œå°±å¯ä»¥è·å¾—é”ã€‚ // Fast path: grab unlocked mutex. // // å¿«é€Ÿè·¯å¾„ï¼šè·å–è§£é”çš„äº’æ–¥é‡ã€‚ // åŸå­æ“ä½œæ¯”è¾ƒ m.state çš„æ—§å€¼ä¸º 0 å¹¶äº¤æ¢æˆæ–°å€¼ 1ï¼ŒæˆåŠŸåˆ™è¡¨ç¤ºè·å–åˆ°é”ã€‚ // è¿™ç§æƒ…å†µå‘ç”Ÿåœ¨ state=0 æ—¶ï¼Œæ²¡æœ‰ç­‰å¾…çš„goroutineã€‚ if atomic.CompareAndSwapInt32(\u0026amp;m.state, 0, mutexLocked) { if race.Enabled { race.Acquire(unsafe.Pointer(m)) } return } // 2) m.state != 0 æ—¶éƒ½ä¼šèµ° Slow path // CAS æ“ä½œæ²¡èƒ½è·å¾—é”ï¼Œå°±éœ€è¦è¿›å…¥ Slow pathäº†ã€‚ // Slow path (outlined so that the fast path can be inlined) // // å¦‚æœä¸Šé¢å¿«é€Ÿæ–¹å¼æ‹¿å–ä¸åˆ°é”ï¼Œåˆ™å»å’Œå…¶ä»–ç«äº‰ã€‚ä¸Šé¢æƒ…å†µæ‹¿ä¸åˆ°é”ï¼Œå¯èƒ½ï¼š // 1. å­˜åœ¨æœ‰å…¶ä»–goroutineæ­£åœ¨æŒæœ‰é”ã€‚ // 2. ä¸å­˜åœ¨å…¶ä»–goroutineæŒæœ‰é”ï¼Œå­˜åœ¨è¢«å”¤é†’çš„goroutineæˆ–è¿˜æœ‰ç­‰å¾…çš„goroutineã€‚ // å½“å‰å¯èƒ½å¤„äºã€æ­£å¸¸æ¨¡å¼ã€‘æˆ–ã€é¥¥é¥¿æ¨¡å¼ã€‘ m.lockSlow() } lockSlow() å¦‚æœè°ƒç”¨è€…æ‹¿å–ä¸åˆ°é”ï¼Œåˆ™ä¸‹é¢æ“ä½œæµç¨‹æ˜¯å…ˆè‡ªæ—‹è¯•å›¾æ‹¿å»é”ï¼Œå®åœ¨æ‹¿å–ä¸åˆ°é”åˆ™è¿›å…¥ä¿¡å·æ± å»ç­‰å¾…æ‹¿å–é”ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 // ç«äº‰è·å–é” // 1. å…ˆè‡ªæ—‹ç­‰å¾…å…¶ä»–goroutineè§£é”ï¼ˆæ»¡è¶³è‡ªæ—‹æ¡ä»¶æ—¶ï¼‰ // 2. å°è¯•ä¿®æ”¹ state å€¼ç«äº‰é” // 3. ç«äº‰æˆåŠŸï¼Œè·å–é”é€€å‡º // 4. ç«äº‰å¤±è´¥ï¼Œsleep goroutine func (m *Mutex) lockSlow() { // 1. å½“å‰goroutineé¦–æ¬¡è¿›å…¥semaphoreæ± sleepçš„æ—¶é—´/çº³ç§’ï¼Œä¸‹æ¬¡wakeupåç”¨äºåˆ¤æ–­ æ­£å¸¸æ¨¡å¼ \u0026lt;-\u0026gt; é¥¥é¥¿æ¨¡å¼ è½¬æ¢ // 2. queueLifo := waitStartTime != 0; è¿›å…¥ semaphore æ± çš„é¦–æˆ–å°¾ï¼Œfalse.å°¾ true.é¦– var waitStartTime int64\t// mutexæ¨¡å¼ ã€false.æ­£å¸¸æ¨¡å¼ã€‘ ã€true.é¥¥é¥¿æ¨¡å¼ã€‘ // 1. æ­£å¸¸æ¨¡å¼ä¸‹ï¼Œæ–°æ¥è·å–é”çš„goroutineå¦‚æœæ»¡è¶³æ¡ä»¶ä¼šè¿›è¡Œè‡ªæ—‹ç­‰å¾…é”è¢«é‡Šæ”¾ï¼Œå¦‚æœè¿˜æ‹¿å–ä¸åˆ°é”åˆ™å»ä¿¡å·æ± æœ€å‰é¢ç­‰å¾…ã€‚ // 2. é¥¥é¥¿æ¨¡å¼ä¸‹ï¼Œæ–°æ¥è·å–é”çš„goroutineä¸ä¼šè¿›è¡Œè‡ªæ—‹ï¼Œç›´æ¥å»ä¿¡å·æ± çš„æœ«å°¾å»ç­‰å¾…ã€‚ starving := false\t// æ˜¯å¦æœ‰goroutineè¢«å”¤é†’ false.æ²¡æœ‰ // æœ‰è¢«å”¤é†’çš„goroutineæ—¶ï¼Œä¼šè¯•å›¾å»æ‹¿å»é”ï¼Œå¯èƒ½æ˜¯è·Ÿå½“å‰æ­£åœ¨è·å–é”çš„goroutineç«äº‰ // 1. åœ¨è‡ªæ—‹æƒ…å†µä¸‹æ»¡è¶³æ¡ä»¶è®¾ç½® awoke ä¸º true // 2. éé¥¥é¥¿æ¨¡å¼ä¸‹è¢«å”¤é†’çš„goroutine awoke ä¼šè¢«è®¾ç½®ä¸º true // 3. åœ¨é¥¥é¥¿æ¨¡å¼ä¸‹ awoke å˜é‡æ²¡æœ‰ç”¨ awoke := false\t// ç”¨äºåŸå­è®¾ç½® mutexWoken ä½ï¼Œé€šçŸ¥ Unlock å‡½æ•°æœ‰ woken çš„goroutineäº†ï¼Œä¸è¦å»wakeup goroutine // è®°å½•æ—‹è½¬çš„æ¬¡æ•°ï¼Œå½“æ²¡æœ‰è·å–é”æ—¶ï¼Œä¼šå°è¯•4æ¬¡å»è‡ªæ—‹è·å– iter := 0\t// è‡ªæ—‹è®¡æ•°å™¨\t// ä»¥ä¸‹ä»£ç éƒ½æ˜¯ä» old -\u0026gt; new çš„åŸå­æ“ä½œï¼Œå»å°è¯•ä¿®æ”¹ state å€¼ old := m.state\t// æ—§å€¼state // è¯¥å¾ªç¯åªæœ‰åœ¨è·å–åˆ°é”çš„æ—¶å€™æ‰ä¼šé€€å‡ºï¼Œå› æ­¤æ‰€æœ‰æœªè·å–åˆ°é”çš„goroutineéƒ½å°†åœ¨è¿™é‡Œç­‰å¾…è·å–é” for { // 1) é¥¥é¥¿æ¨¡å¼ä¸‹ä¸è¦è‡ªæ—‹ï¼Œå› ä¸ºæ‰€æœ‰æƒæŒ‰ç…§é¡ºåºä¼ é€’ï¼Œè‡ªæ—‹æ²¡æœ‰æ„ä¹‰ã€‚ // æ­£å¸¸æ¨¡å¼ä¸‹é”æ²¡æœ‰è¢«é‡Šæ”¾æ»¡è¶³è‡ªæ—‹æ¡ä»¶éœ€è¦è‡ªæ—‹ã€‚ // Don\u0026#39;t spin in starvation mode, ownership is handed off to waiters // so we won\u0026#39;t be able to acquire the mutex anyway. // // ä¸è¦åœ¨é¥¥é¥¿æ¨¡å¼ä¸‹æ—‹è½¬ï¼Œæ‰€æœ‰æƒå·²ç§»äº¤ç»™waitersï¼Œå› æ­¤æˆ‘ä»¬æ— è®ºå¦‚ä½•éƒ½æ— æ³•è·å¾—äº’æ–¥é” // 1. old\u0026amp;(mutexLocked|mutexStarving) == mutexLocked; Mutexæ²¡æœ‰å¤„äºé¥¥é¥¿æ¨¡å¼å¹¶ä¸”å·²è¢«é”å®šã€‚ // 2. runtime_canSpin(iter); æŠ¥å‘Šå½“å‰æ—‹è½¬è¦æ±‚æ¡ä»¶ã€‚ //\tä¸»åŠ¨æ—‹è½¬æ¡ä»¶ï¼š //\tæ—‹è½¬æ¬¡æ•°å°äº4æ¬¡ å¹¶ä¸” å¤šæ ¸CPUè¿è¡Œ å¹¶ä¸”é™¤äº†å½“å‰Pè¿˜æœ‰å…¶ä»–Pæ­£åœ¨è¿è¡Œï¼ˆä¸æ˜¯ç©ºé—²æˆ–è‡ªæ—‹çŠ¶æ€çš„Pï¼‰å¹¶ä¸” å½“å‰Pæ²¡æœ‰å…¶ä»–gäº† //\tè¿™ç§æƒ…å†µéœ€è¦å»å°è¯•è‡ªæ—‹è·å–ä¸‹é”ï¼Œå…¶ä»–æƒ…å†µåˆ™ä¸éœ€è¦è‡ªæ—‹å»è·å–é” // ä»¥ä¸‹è‡ªæ—‹çš„æ„ä¹‰ï¼Œåœç•™ç‰‡åˆ»ç­‰å¾…å…¶ä»–goroutineè®©å‡ºé”ï¼Œç„¶åæ ‡è®°mutexWokenå­˜åœ¨è¢«å”¤é†’çš„goroutineä½¿è‡ªå·±è·å–é”ä¼˜å…ˆçº§æ›´é«˜ if old\u0026amp;(mutexLocked|mutexStarving) == mutexLocked \u0026amp;\u0026amp; runtime_canSpin(iter) {\t// è‡ªæ—‹åœ¨è¿™é‡Œ // Active spinning makes sense. // Try to set mutexWoken flag to inform Unlock // to not wake other blocked goroutines. // // ä¸»åŠ¨æ—‹è½¬æ˜¯æœ‰é“ç†çš„ã€‚ // å°è¯•è®¾ç½® mutexflag æ¥é€šçŸ¥ Unlock ä¸è¦å”¤é†’å…¶ä»–è¢«é˜»å¡åœ¨ä¿¡å·æ± çš„goroutinesã€‚ // ä»¥ä¸‹é€»è¾‘æ˜¯å¤„äºè‡ªæ—‹ï¼Œè‡ªæ—‹çš„æ„ä¹‰åœ¨äºæ ‡è®°æœ‰æ­£åœ¨è¢«å”¤é†’çš„goroutineï¼Œå…¶ä»–çº¿ç¨‹ä¸è¦å†æ¬¡å”¤é†’å¯¼è‡´è¿‡å¤šgoroutineè¢«å”¤é†’ // // 1. !awoke; ï¼šæ²¡æœ‰æ ‡è®°å½“å‰goroutineè¢«å”¤é†’ // 2. old\u0026amp;mutexWoken == 0; ï¼šæ²¡æœ‰è¢«å”¤é†’çš„goroutineï¼ŒåŒ…æ‹¬å…¶ä»–gå’Œå½“å‰g // 3. old\u0026gt;\u0026gt;mutexWaiterShift != 0; ï¼šå­˜åœ¨ç­‰å¾…æ’é˜Ÿåœ¨ä¿¡å·æ± çš„goroutine // 4. atomic.CompareAndSwapInt32(\u0026amp;m.state, old, old|mutexWoken); //\tè®¾ç½®æ ‡å¿—æœ‰goroutineè¢«å”¤é†’ï¼Œè¿™é‡Œè®¾ç½®æˆåŠŸé‚£unlockåˆ™ä¸ä¼šå†å»å”¤é†’goroutine if !awoke \u0026amp;\u0026amp; old\u0026amp;mutexWoken == 0 \u0026amp;\u0026amp; old\u0026gt;\u0026gt;mutexWaiterShift != 0 \u0026amp;\u0026amp; atomic.CompareAndSwapInt32(\u0026amp;m.state, old, old|mutexWoken) { // æ ‡è®°ä¸ºå”¤é†’çŠ¶æ€ï¼Œä¸»è¦æ˜¯å‘Šè¯‰unlockä¸è¦å†å»å”¤é†’goroutineäº†ï¼Œè¿™é‡Œæœ‰è‡ªæ—‹çš„åœ¨ç­‰å¾… awoke = true } // çŸ­æš‚å»¶è¿Ÿä¸€æ®µæ—¶é—´ï¼Œä¸»è¦æ˜¯ç­‰å¾…å…¶ä»–gè§£é” // å¦‚æœæ­¤æ—¶Unlockäº†ç¬¬ä¸€ä¸ªifåˆ™ä¸ä¼šå†åˆ¤æ–­ä¸ºtrueï¼Œç›´æ¥å»äº‰æŠ¢é”äº† runtime_doSpin()\titer++ old = m.state\t// ä»æ–°èµ‹å€¼ç»™old continue } // 2) é”å¯èƒ½å·²è¢«é‡Šæ”¾å°è¯•ç«äº‰è·å–ï¼Œæˆ–é”è¿˜æœªè§£é™¤å»sleepã€‚ // ä»£ç æ‰§è¡Œåˆ°è¿™é‡Œï¼Œåªå¯èƒ½å¤„äºä»¥ä¸‹å‡ ç§æƒ…å†µ // 1. è‡ªæ—‹æ¬¡æ•°ä»¥å®Œï¼ŒçŠ¶æ€ä¾ç„¶æ˜¯ mutexLockedã€‚ // 2. çŠ¶æ€æ˜¯ mutexStarving å¤„äºé¥¥é¥¿çŠ¶æ€ã€‚ // 3. çŠ¶æ€æ˜¯æœªåŠ é”çŠ¶æ€ï¼Œé”å·²è¢«è§£é™¤ã€‚ // ï¼ˆå¤„äºé¥¥é¥¿æ¨¡å¼ï¼‰ æˆ– ï¼ˆè‡ªæ—‹æ¬¡æ•°è¶…è¿‡4æ¬¡ï¼‰ æˆ– ï¼ˆå½“å‰å…¶ä»–goroutineå·²Unlockï¼‰æˆ– ï¼ˆä¸æ»¡è¶³è‡ªæ—‹æ¡ä»¶ï¼‰ //\tå¦‚æœé”å·²Unlockï¼Œé‚£ä¹ˆå°è¯•å»è·å–é”ï¼›å¦‚æœé”å¤„äºLockï¼Œé‚£ä¹ˆä¹Ÿå°è¯•è·å–ï¼Œå¦åˆ™åŠ å…¥åˆ°ä¿¡å·æ± ä¸­ç­‰å¾… // old æ˜¯æœ¬è½®åŸå­æ“ä½œçš„ state å€¼ // new æ˜¯æœ¬è½®éœ€è¦äº‰æŠ¢é”ä¿®æ”¹åçš„ state å€¼ // æ­£å¸¸æ¨¡å¼ä¸‹: // 1. åœ¨oldæœªæŒæœ‰é”æƒ…å†µä¸‹ï¼Œè°å…ˆåŸå­æ“ä½œä» old ä¿®æ”¹ä¸º new è°å°±å…ˆè·å–åˆ°é” // 2. åœ¨oldæŒæœ‰é”æƒ…å†µä¸‹ï¼Œå½“å‰goroutineéœ€è¦sleep new := old // 2.1) æ­£å¸¸æ¨¡å¼ä¸‹éœ€è¦äº‰æŠ¢é”ï¼Œå› æ­¤éœ€è¦è®¾ç½®mutexLockedçŠ¶æ€ // Don\u0026#39;t try to acquire starving mutex, new arriving goroutines must queue. // // ä¸è¦å°è¯•è·å–å¤„äºé¥¥é¥¿çš„Mutexï¼Œåæ¥çš„goroutineså¿…é¡»æ’é˜Ÿã€‚ // // å¤„äºé¥¥é¥¿æ¨¡å¼ä¸‹ï¼Œä¸ºä»€ä¹ˆä¸éœ€è¦è®¾ç½®mutexLockedæ ‡å¿—å‘¢ï¼Ÿ // 1. å¤„äºé¥¥é¥¿æ¨¡å¼ä¸‹é”çš„æŒæœ‰æƒæ˜¯æ‰‹æŠŠæ‰‹äº¤ç»™åé¢ç­‰å¾…çš„goroutineï¼Œå› æ­¤mutexLockedæ ‡å¿—è®¾ç½®ä¸è®¾ç½®ä¸é‡è¦ // 2. å¯¹äºæ–°æ¥çš„goroutineï¼ŒmutexLockedä½å¯èƒ½ä¸º0æˆ–1ï¼Œä½†æ˜¯å½“å‰goroutineä¸ä¼šå»æŒ£æŠ¢é”ç›´æ¥sleepï¼Œå› æ­¤mutexLockedä½ä¸é‡è¦ // 3. å¯¹äºä»sleepä¸­wakeupçš„goroutineï¼Œä¸€å®šæ˜¯æ¥è‡ªUnlockå‡½æ•°è€Œæ¥è‡ªè¯¥å‡½æ•°mutexLockedä½ä¸€å®šæ˜¯0ï¼Œå·²è¢«è§£é” if old\u0026amp;mutexStarving == 0 {\t// å¤„äºæ­£å¸¸æ¨¡å¼ // newè¡¨ç¤ºæ–°å€¼ä¿®æ”¹çš„çŠ¶æ€ mutexLockedéœ€è¦é”ï¼Œä¸ç®¡å½“å‰æ˜¯Lockæˆ–Unlockå½“å‰éƒ½éœ€è¦è®¾ç½®mutexLockedè¡¨ç¤ºéœ€è¦å»äº‰æŠ¢é” new |= mutexLocked\t} // 2.2) é”è¿˜æœªè¢«é‡Šæ”¾ æˆ– å¤„äºé¥¥é¥¿æ¨¡å¼ä¸‹ è¿™ä¸¤ç§æƒ…å†µä¸‹éƒ½ä¼šå»sleepï¼Œå› æ­¤éœ€è¦åŠ ä¸€ã€‚ // å¦‚æœoldé”æ²¡é‡Šæ”¾ æˆ– å¤„äºé¥¥é¥¿çŠ¶æ€ï¼Œé‚£ä¹ˆå½“å‰çš„goroutineåˆ™æ˜¯éœ€è¦è¢«åŠ å…¥åˆ°ä¿¡å·æ± é‡Œé¢å»çš„ if old\u0026amp;(mutexLocked|mutexStarving) != 0 {\t// å¤„äºLockæˆ–åˆ™é¥¥é¥¿æ¨¡å¼å½“å‰géœ€è¦åŠ å…¥åˆ°ä¿¡å·æ±  new += 1 \u0026lt;\u0026lt; mutexWaiterShift\t// æ•°é‡å¢åŠ 1 } // 2.3) å½“å‰ goroutine å°† mutex åˆ‡æ¢è‡³é¥¥é¥¿æ¨¡å¼ // å¦‚æœ mutex å·²ç»å¤„äº unlocked çŠ¶æ€ï¼Œå°±ä¸è¦åˆ‡æ¢äº†ï¼Œ // å› ä¸º Unlock() å‡½æ•°è®¤ä¸ºå¤„äºé¥¥é¥¿æ¨¡å¼çš„ mutex ç­‰å¾…é˜Ÿåˆ—ä¸ä¸ºç©ºã€‚ // The current goroutine switches mutex to starvation mode. // But if the mutex is currently unlocked, don\u0026#39;t do the switch. // Unlock expects that starving mutex has waiters, which will not // be true in this case. // // å½“å‰çš„ goroutine å°†äº’æ–¥é”åˆ‡æ¢åˆ°é¥¥é¥¿æ¨¡å¼ï¼Œä½†å¦‚æœäº’æ–¥é”å½“å‰å·²è§£é”ï¼Œå°±ä¸è¦åˆ‡æ¢ã€‚ // UnlockæœŸæœ›å¤„äºé¥¥é¥¿çŠ¶æ€çš„äº’æ–¥é”æœ‰waitersï¼Œä½†åœ¨æœ¬ä¾‹ä¸­å¹¶éå¦‚æ­¤ã€‚ // // starving=true å‘ç”Ÿåœ¨ï¼šè¿™ä¸ªgoroutineè¢«åŠ å…¥åˆ°ä¿¡å·æ± åå†åº¦è¢«å”¤é†’å»äº‰æŠ¢é”æ—¶ï¼Œå‘ç°ç­‰å¾…æ—¶é—´å·²ç»è¶…è¿‡1msæ—¶ // old\u0026amp;mutexLocked != 0ï¼Œè¡¨ç¤ºè¿™ä¸ªè¢«å”¤é†’çš„goroutineå†æ¬¡äº‰æŠ¢é”æ—¶é”æ²¡è¢«å…¶ä»–gorutineé‡Šæ”¾ï¼Œè¿™æ¬¡å†äº‰æŠ¢å°†å¤±è´¥åˆ™ä¼šæ ‡è®°æˆé¥¥é¥¿æ¨¡å¼ if starving \u0026amp;\u0026amp; old\u0026amp;mutexLocked != 0 {\t// è¿™ç§æƒ…å†µä¸‹å½“å‰goroutineåŸºæœ¬æ‹¿å»ä¸åˆ°é” new |= mutexStarving // æ ‡è®°æˆé¥¥é¥¿æ¨¡å¼æ—¶ï¼Œé”ä¸€å®šè¢«å…¶ä»–æŒæœ‰ï¼›ä½†æ˜¯å”¤é†’çš„gå¤„äºé¥¥é¥¿æ¨¡å¼æ—¶ï¼Œé”ä¸€å®šæ˜¯UnlockçŠ¶æ€ } // 2.4) å½“å‰goroutineæ˜¯è¢«å”¤é†’çš„ï¼Œæ£€æŸ¥å¹¶æ¸…é™¤æ ‡å¿—ä½ // awoke=true è¡¨ç¤ºæ¥è‡ªè‡ªæ—‹æˆ–è¢«å”¤é†’çš„goroutineä¸¤ç§å½¢å¼ // 1. è‡ªæ—‹çŠ¶æ€ä¸‹ awoke=trueï¼Œstate ä¸­ mutexWoken ä½å·²è¢«è®¾ç½®ä¸º 1 // 2. è¢«å”¤é†’çš„goroutineä¸‹ awoke=true åœ¨æœ¬å‡½æ•°çš„å”¤é†’åè¢«è®¾ç½®ï¼Œè€Œ state ä¸­ mutexWoken ä½åœ¨Unlockå‡½æ•°ä¸­è¢«è®¾ç½® // å› æ­¤ awoke=true å°±ä¸€å®šå­˜åœ¨ state ä¸­ mutexWoken ä½ä¸º1ï¼Œnew\u0026amp;mutexWoken != 0æˆç«‹ if awoke {\t// awokeæœ‰ç­‰å¾…çš„goroutineè¢«å”¤é†’ // The goroutine has been woken from sleep, // so we need to reset the flag in either case. // // goroutine å·²ç»ä»ç¡çœ ä¸­å”¤é†’ï¼Œæ‰€ä»¥æˆ‘ä»¬éœ€è¦åœ¨ä»»ä½•ä¸€ç§æƒ…å†µä¸‹é‡ç½®æ ‡å¿— if new\u0026amp;mutexWoken == 0 {\t// ä¸è®ºæ¥è‡ªè‡ªæ—‹æˆ–è¢«å”¤é†’çš„goroutineè¿™é‡Œéƒ½ä¸èƒ½ä¸º0ï¼Œæ­£å¸¸çŠ¶å†µä¸‹ throw(\u0026#34;sync: inconsistent mutex state\u0026#34;) } new \u0026amp;^= mutexWoken // æ¸…é™¤è¢«å”¤é†’æ ‡å¿—ä½mutexWokenï¼Œå› ä¸ºä¸‹é¢å³å°†å»äº‰æŠ¢é”ï¼Œæˆ–è€…è½½å…¥å»ä¿¡å·æ± ç­‰å¾… } // å°è¯•ä½¿ç”¨åŸå­ä¿®æ”¹stateï¼Œæ‰€æœ‰çš„goroutineéƒ½ä¼šé€šè¿‡è¯¥æ¡ä»¶ï¼Œä½†æ˜¯ä¸€è½®åªèƒ½æˆåŠŸä¸€ä¸ª // è¿™é‡Œä¿®æ”¹m.stateæˆåŠŸäº†ï¼Œå¹¶ä¸ä»£è¡¨ä¸€å®šè·å–åˆ°äº†é”ï¼Œä¹Ÿæœ‰å¯èƒ½æ˜¯å½“å‰géœ€è¦åŠ å…¥åˆ°ä¿¡å·æ± ä¸­å» if atomic.CompareAndSwapInt32(\u0026amp;m.state, old, new) {\t// å¦‚æœä¸Šä¸€ä¸ªæ‹¿å»åˆ°é”çš„stateæ˜¯æ­£å¸¸æ¨¡å¼å¹¶æ²¡æœ‰é”ï¼Œåˆ™è¿™é‡Œç›´æ¥é€€å‡ºï¼Œè¿™é‡Œè¡¨ç¤ºå½“å‰goroutineè·å–åˆ°äº†é”ï¼Œæ­£å¸¸æ¨¡å¼éƒ½æ˜¯ä»è¿™é‡Œé€€å‡ºçš„ // æ­£å¸¸æ¨¡å¼ä¸‹è·å–åˆ°é”çš„æƒ…å†µï¼Œè¿™é‡Œä¸ä¼šå‡ºç°æ ‡è®°æˆé¥¥é¥¿æ¨¡å¼ä½†è¿™é‡Œåˆåˆ¤æ–­ä¸ºtrueé€€å‡ºäº†çš„æƒ…å†µï¼ŒåŸå› æ˜¯æ ‡è®°æˆé¥¥é¥¿æ¨¡å¼çš„å‰ç½®æ¡ä»¶æ˜¯å½“å‰oldæ˜¯Lock if old\u0026amp;(mutexLocked|mutexStarving) == 0 {\t// è°å…ˆæ‹¿åˆ°é”é€€å‡ºï¼Œæ¥åˆ°æ‰§è¡Œgoroutineåé¢ä»£ç  break // locked the mutex with CAS } // åé¢å¤„ç†é€»è¾‘æ˜¯ä¹‹å‰æœ‰é”ï¼Œè¿™ä¸ªgoroutineéœ€è¦å»æ’é˜Ÿæƒ…å†µï¼Œæˆ–å½“å‰æ¨¡å¼å¤„äºé¥¥é¥¿æ¨¡å¼ï¼Œç›´æ¥æŠŠè¯¥goroutineåŠ å…¥åˆ°å°¾éƒ¨ // If we were already waiting before, queue at the front of the queue. // // å¦‚æœæˆ‘ä»¬ä¹‹å‰å·²ç»åœ¨ç­‰å¾…ï¼Œè¯·åœ¨é˜Ÿåˆ—çš„å‰é¢æ’é˜Ÿ // waitStartTimeå¦‚æœä¸ç­‰äº0è¯´æ˜å…ˆå‰å…¥é˜Ÿè¿‡æœ‰è¢«å”¤é†’è¿‡ï¼Œæ­£å¸¸ç¬¬ä¸€æ¬¡å…¥é˜Ÿè¿™é‡Œæ˜¯false // è¢«å”¤é†’ä¹‹åæ²¡æœ‰æŠ¢åˆ°é”ï¼Œéœ€è¦æ’å…¥é˜Ÿåˆ—å¤´éƒ¨ï¼Œè€Œä¸æ˜¯å°¾éƒ¨ã€‚ queueLifo := waitStartTime != 0 // é¦–æ¬¡è¿›å…¥ä¿¡å·æ± å»ç­‰å¾…æ—¶ if waitStartTime == 0 {\t// è¿™é‡Œè¡¨ç¤ºè¿™ä¸ªgoroutineä»ä¿¡å·æ± ä¸­ç¬¬ä¸€æ¬¡è¢«å”¤é†’ä¾ç„¶æ²¡æœ‰è·å–åˆ°é”ï¼Œä»æ–°è®¾ç½®æ—¶é—´ waitStartTime = runtime_nanotime()\t// æ³¨æ„ï¼šé™¤ç¬¬ä¸€æ¬¡å…¥é˜Ÿååé¢æ¯æ¬¡ç¼“å­˜waitStartTimeæ—¶é—´éƒ½ä¸ä¼šè¢«åˆ·æ–° } // è¿™é‡Œå­˜åœ¨è¢«å”¤é†’ä½†æ˜¯è¿˜æ˜¯æ²¡æ‹¿åˆ°é”çš„æƒ…å†µä¼šå†æ¬¡è¢«å…¥é˜Ÿ // runtime_SemacquireMutexçš„queueLifoå‚æ•°ä¸ºtrueåˆ™æ˜¯æ’å…¥çš„ä¿¡å·æ± å¤´éƒ¨ï¼Œfalseæ’å…¥åˆ°å°¾éƒ¨ //\té¦–æ¬¡è¿›å…¥ä¿¡å·æ± ï¼Œåˆ™ç›´æ¥æ’åœ¨å°¾éƒ¨ //\tä»ä¿¡å·æ± ä¸­å‡ºæ¥åˆäº‰æŠ¢å¤±è´¥è¿›å…¥ä¿¡å·æ± æ’åœ¨å¤´éƒ¨ // å¦‚æˆ‘ä»¬å–å‡ºgorutineåˆ™æ˜¯ä»å¤´éƒ¨å¼€å§‹å¾€åå–ï¼Œè¿™ä¹Ÿå°±æ˜¯æˆ‘ä»¬è¯´çš„å…ˆè¿›å…ˆå‡º // å› ä¸ºç¬¬ä¸€æ¬¡åŠ å…¥ä¿¡å·æ± çš„éƒ½æ˜¯æ’å…¥åˆ°å°¾éƒ¨ï¼Œå½“å†è¢«å”¤é†’ä¾ç„¶æ²¡æœ‰è·å–åˆ°é”æ—¶ï¼Œåˆ™æ˜¯è¢«æ”¾å›åˆ°å¤´éƒ¨ // å½“å‰goroutineå»æ’é˜Ÿï¼Œè¿™é‡Œå½“å‰groutineè¢«è°ƒç¦»å·¥ä½œçº¿ç¨‹ç­‰å¾…æŠ¢åˆ°é”åç»§ç»­åé¢æ‰§è¡Œ runtime_SemacquireMutex(\u0026amp;m.sema, queueLifo, 1)\t// è¢«å”¤é†’çš„gï¼Œæ¥åˆ°ä»è¿™é‡Œæ‰§è¡Œå°è¯•å»è·å–é”ï¼›å¯èƒ½å½“å‰å¤„äºé¥¥é¥¿æ¨¡å¼æˆ–å¤„äºæ­£å¸¸æ¨¡å¼ï¼Œå”¤é†’gçš„ç›¸å…³ä»£ç ä½äºUnlockå‡½æ•° // å¦‚æœç­‰å¾…çš„æ—¶é—´å¤§äº1msåˆ™æ ‡è®°æˆé¥¥é¥¿æ¨¡å¼ï¼Œä»¥ä¸‹é€»è¾‘æ˜¯å½“å‰goroutineè¢«å”¤é†’åå†æ¬¡å°è¯•è·å–é” // ç­‰å¾…æ—¶é—´è¶…è¿‡äº†1msï¼Œç­‰å¾…æ—¶é—´å¤ªä¹…éœ€è¦è¢«æ ‡è®°ä¸ºé¥¥é¥¿çŠ¶æ€ starving = starving || runtime_nanotime()-waitStartTime \u0026gt; starvationThresholdNs old = m.state\t// è·å–å½“å‰çš„çŠ¶æ€ // å¦‚æœå¤„äºé¥¥é¥¿æ¨¡å¼ï¼Œå¤„äºé¥¥é¥¿æ¨¡å¼ä¸‹å”¤é†’çš„goroutineç«‹å³è·å–é”ï¼Œå› ä¸ºæ­£å¸¸æ¥æŠ¢çš„goroutineéƒ½ä¼šè¢«å…¥é˜Ÿï¼Œ // ç„¶åä¸€ä¸ªä¸ªæ¥è·å– // æ‰€æœ‰é¥¥é¥¿æ¨¡å¼ä¸‹è·å–é”çš„å‡ºå£éƒ½åœ¨è¿™é‡Œï¼Œè¯¥æ¡ä»¶æ»¡è¶³è¯´æ˜å½“å‰goroutineè·å–åˆ°é”æŒæœ‰æƒ if old\u0026amp;mutexStarving != 0 {\t// If this goroutine was woken and mutex is in starvation mode, // ownership was handed off to us but mutex is in somewhat // inconsistent state: mutexLocked is not set and we are still // accounted as waiter. Fix that. // // å½“å‰ä»£ç ä½ç½®çš„ goroutine è‚¯å®šæ˜¯è¢«å”¤é†’çš„ï¼Œè€Œä¸” Mutex å¤„äºé¥¥é¥¿æ¨¡å¼ // æ‰€æœ‰æƒè¢«ç›´æ¥äº¤ç»™å½“å‰ goroutine // ä½†æ˜¯è¿™ç§æƒ…å†µä¸‹ mutex çš„ state ä¼šä¸å®é™…æƒ…å†µä¸ä¸€è‡´ // mutexLocked æ ‡å¿—ä½æ²¡æœ‰è®¾ç½® // è€Œä¸”ç­‰å¾…è€…è®¡æ•°ä¸­ä¹Ÿæ²¡æœ‰å‡å»å½“å‰ goroutineã€‚éœ€è¦ä¿®å¤ state // æ³¨æ„é¥¥é¥¿æ¨¡å¼ä¸‹ä¼ é€’ mutex æ‰€æœ‰æƒä¸ä¼šè®¾ç½® mutexWoken æ ‡å¿—ï¼Œåªæœ‰æ­£å¸¸æ¨¡å¼ä¸‹å”¤é†’æ‰ä¼š // // é¥¥é¥¿æ¨¡å¼ä¸‹ old\u0026gt;\u0026gt;mutexWaiterShift != 0ï¼Œå½“å‰ä¸€å®šä¸èƒ½æ˜¯æœ€åä¸€ä¸ªï¼Œ // å› ä¸ºä¸‹é¢ old\u0026gt;\u0026gt;mutexWaiterShift == 1 ä¼šé€€å‡ºé¥¥é¥¿æ¨¡å¼ // old\u0026amp;(mutexLocked|mutexWoken) != 0 å› ä¸ºå¤„äºé¥¥é¥¿æ¨¡å¼ä¸‹ï¼Œæ‰€æœ‰çš„goroutineéƒ½ä¼šå»æ’é˜Ÿsleepï¼Œ // è¢«wakeupçš„goroutineä¸€å®šæ¥è‡ªUnlockå‡½æ•°ï¼Œ // æ­¤æ—¶mutexLockedä¸€å®šè§£é”ï¼ŒmutexWokenä¸€å®šæ˜¯è¢«æ¸…é™¤çš„ if old\u0026amp;(mutexLocked|mutexWoken) != 0 || old\u0026gt;\u0026gt;mutexWaiterShift == 0 { // é¥¥é¥¿æ¨¡å¼ä¸‹ï¼ŒmutexLockedå’ŒmutexWokenå¿…å®šä¸º0ï¼Œå‚çœ‹ä¸Šé¢ä»£ç ã€‚ throw(\u0026#34;sync: inconsistent mutex state\u0026#34;) } // +mutexLocked -1\u0026lt;\u0026lt;mutexWaiterShift delta := int32(mutexLocked - 1\u0026lt;\u0026lt;mutexWaiterShift)\t// å°†ç­‰å¾…çš„æ•°é‡å‡ä¸€ // ç­‰å¾…æ—¶é—´å°äº1ms æˆ– å½“å‰goroutineæ˜¯é˜Ÿåˆ—æœ€åä¸€ä¸ªï¼Œåˆ™æ ‡è®°é€€å‡ºé¥¥é¥¿æ¨¡å¼ if !starving || old\u0026gt;\u0026gt;mutexWaiterShift == 1 { // Exit starvation mode. // Critical to do it here and consider wait time. // Starvation mode is so inefficient, that two goroutines // can go lock-step infinitely once they switch mutex // to starvation mode. delta -= mutexStarving\t// é€€å‡ºé¥¥é¥¿æ¨¡å¼ } atomic.AddInt32(\u0026amp;m.state, delta) // ä¿®æ”¹stateï¼Œè¿”å›ç›´æ¥è¿”å›ï¼Œåº”ä¸ºè¯¥goroutine è·å–åˆ°é”äº† break\t// é¥¥é¥¿æ¨¡å¼ä»è¿™é‡Œé€€å‡ºï¼Œå› æ­¤é¥¥é¥¿æ¨¡å¼ä¸‹è¢«å”¤é†’çš„goroutineç›´æ¥ä»è¿™é‡Œé€€å‡º } // æ­£å¸¸æ¨¡å¼ä¸‹ï¼Œè®¾ç½®ä¸ºå”¤é†’å»äº‰æŠ¢é” awoke = true\t// stateçš„mutexWokenä½åœ¨Unlockå‡½æ•°ä¸­è¢«è®¾ç½® iter = 0\t// è‡ªæ—‹æ¬¡æ•°é‡ç½® } else { // ä»old-\u0026gt;new åŸå­è®¾ç½®ï¼Œå¦‚æœè®¾ç½®å¤±è´¥ä»æ–°å†æ¥ old = m.state } } if race.Enabled { race.Acquire(unsafe.Pointer(m)) } } sync_runtime_canSpin() sync.Mutex ä¸»åŠ¨æ—‹è½¬æ¡ä»¶ã€‚ ä¸ä¸»åŠ¨æ—‹è½¬æ¡ä»¶ï¼š ã€æ—‹è½¬æ¬¡æ•°å¤§äºç­‰äº4æ¬¡ã€‘æˆ–ã€å•æ ¸CPUåœ¨è¿è¡Œã€‘ æˆ–ã€é™¤äº†å½“å‰På…¶ä»–Péƒ½å¤„äºç©ºé—²æˆ–è‡ªæ—‹çŠ¶æ€ã€‘ï¼Œä¸éœ€è¦ä¸»åŠ¨å»æ—‹è½¬ç­‰å¾…è·å–é”ã€‚ å¦‚æœå½“å‰Pçš„runqä¸ä¸ºç©ºï¼Œä¹Ÿæ²¡å¿…è¦å»è‡ªæ—‹ï¼Œå› ä¸ºé‡Œé¢çš„gè¿˜ç­‰ç€å»æ‰§è¡Œï¼Œç›´æ¥æŠŠå½“å‰gæŒ‚èµ·ã€‚ ä¸»åŠ¨æ—‹è½¬æ¡ä»¶ï¼š ã€æ—‹è½¬æ¬¡æ•°å°äº4æ¬¡ã€‘å¹¶ä¸”ã€å¤šæ ¸CPUè¿è¡Œã€‘å¹¶ä¸”ã€é™¤äº†å½“å‰Pè¿˜æœ‰å…¶ä»–Pæ­£åœ¨è¿è¡Œã€‘ï¼ˆä¸æ˜¯ç©ºé—²æˆ–è‡ªæ—‹çŠ¶æ€çš„Pï¼‰å¹¶ä¸” ã€å½“å‰Pæ²¡æœ‰å…¶ä»–gäº†ã€‘ã€‚ è¿™ç§æƒ…å†µéœ€è¦å»å°è¯•è‡ªæ—‹è·å–ä¸‹é”ï¼Œå…¶ä»–æƒ…å†µåˆ™ä¸éœ€è¦è‡ªæ—‹å»è·å–é”ã€‚ runtime/proc.goæ–‡ä»¶ä¸­ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 // Active spinning for sync.Mutex. //go:linkname sync_runtime_canSpin sync.runtime_canSpin //go:nosplit func sync_runtime_canSpin(i int) bool { // sync.Mutex is cooperative, so we are conservative with spinning. // Spin only few times and only if running on a multicore machine and // GOMAXPROCS\u0026gt;1 and there is at least one other running P and local runq is empty. // As opposed to runtime mutex we don\u0026#39;t do passive spinning here, // because there can be work on global runq or on other Ps. // // sync.Mutexæ˜¯åˆä½œæ€§çš„ï¼Œæ‰€ä»¥æˆ‘ä»¬å¯¹spinningæ˜¯ä¿å®ˆçš„ã€‚ // åªæ—‹è½¬å‡ æ¬¡ï¼Œä¸”ä»…å½“è¿è¡Œåœ¨å¤šæ ¸è®¡ç®—æœºå’ŒGOMAXPROCS\u0026gt;1ä¸Šï¼Œå¹¶ä¸”è‡³å°‘æœ‰ä¸€ä¸ªå…¶ä»–è¿è¡ŒPä¸”æœ¬åœ°runqä¸ºç©ºæ—¶ã€‚ // ä¸è¿è¡Œæ—¶äº’æ–¥é”ç›¸åï¼Œæˆ‘ä»¬åœ¨è¿™é‡Œä¸åšè¢«åŠ¨æ—‹è½¬ï¼Œå› ä¸ºå¯ä»¥åœ¨å…¨å±€runqæˆ–å…¶ä»–Pä¸Šè¿›è¡Œå·¥ä½œã€‚ // // ä»¥ä¸‹æ¡ä»¶æ»¡è¶³ä¸€é¡¹éƒ½ä¸ä¼šå†æ¬¡è‡ªæ—‹å»è·å–é” // 1. const active_spin = 4; æœ€å¤šå°è¯•4æ¬¡è‡ªæ—‹è·å– // 2. var ncpu int32 \u0026lt;= 1; å¦‚æœæ˜¯å•æ ¸CPU // 3. gomaxprocs \u0026lt;= int32(sched.npidle+sched.nmspinning)+1; // 3.1 gomaxprocsï¼šè¡¨ç¤ºæ€»çš„P // 3.2 sched.npidleç©ºé—²çš„Pæ•°é‡ // 3.3 sched.nmspinningæ­£åœ¨è‡ªæ—‹çš„Mæ•°é‡(è¿™é‡Œé¢å¯èƒ½å­˜åœ¨æ­£åœ¨äº‰æŠ¢é”ï¼Œå¤„åœ¨è‡ªæ—‹éƒ½æ˜¯åªæœ‰ä¸€ä¸ªgçš„æƒ…å†µ) // é™¤äº†å½“å‰På…¶ä»–çš„Péƒ½å¾ˆé—²ï¼Œä¹Ÿä¸å¿…è¦è‡ªæ—‹äº†ã€‚ if i \u0026gt;= active_spin || ncpu \u0026lt;= 1 || gomaxprocs \u0026lt;= int32(sched.npidle+sched.nmspinning)+1 { return false } // è¿™é‡Œä¸åƒ runtime.mutex é‚£æ ·è¿›è¡Œæ¶ˆæè‡ªæ—‹ï¼Œå› ä¸ºå…¨å±€ runq æˆ–å…¶ä»– P ä¸Šæˆ–è®¸è¿˜æœ‰å¯è¿è¡Œçš„ä»»åŠ¡ã€‚ // å½“å‰æœ¬åœ°Pä¸ä¸ºç©ºï¼Œä¹Ÿä¸éœ€è¦è‡ªæ—‹å†å‡ºå»å°è¯•è·å–é”ï¼Œå…¶ä»–goroutineè¿˜ç­‰èµ·çš„ã€‚ if p := getg().m.p.ptr(); !runqempty(p) { return false } return true } sync_runtime_doSpin() çŸ­æš‚çš„å»¶è¿Ÿã€‚ runtime/proc.go æ–‡ä»¶ä¸­ã€‚ 1 2 3 4 5 6 //go:linkname sync_runtime_doSpin sync.runtime_doSpin //go:nosplit func sync_runtime_doSpin() { // å¾ªç¯30æ¬¡ç­‰å¾… procyield(active_spin_cnt)\t// active_spin_cnt=30 } procyield() çŸ­æš‚çš„å»¶è¿Ÿã€‚ 1 2 3 4 5 6 7 8 # runtime/asm_amd.64.s TEXT runtimeÂ·procyield(SB),NOSPLIT,$0-0 MOVL\tcycles+0(FP), AX\t# AX=30 å‚æ•° again: PAUSE # è‡ªæ—‹é™ä½CPUå‘çƒ­å’Œæ€§èƒ½ä¼˜åŒ–ã€‚ SUBL\t$1, AX\t# AX -= 1 JNZ\tagain RET Unlock() Unlockè§£é”mã€‚ å¦‚æœmåœ¨è¿›å…¥è§£é”æ—¶æ²¡æœ‰è¢«é”å®šï¼Œåˆ™æ˜¯ä¸€ä¸ªè¿è¡Œæ—¶é”™è¯¯ã€‚ ä¸€ä¸ªé”å®šçš„äº’æ–¥é‡ä¸ä¸€ä¸ªç‰¹å®šçš„goroutineæ— å…³ã€‚ å…è®¸ä¸€ä¸ªgoroutineé”å®šä¸€ä¸ªäº’æ–¥é‡ï¼Œç„¶åå®‰æ’å¦ä¸€ä¸ªgoroutineè§£é”å®ƒã€‚ è¯¥æ–¹æ³•ä¸»è¦é€šè¿‡ atomic å‡½æ•°å®ç°äº† Fast pathï¼Œç›¸åº”çš„ Slow pathè¢«å•ç‹¬æ”¾åœ¨äº† unlockSlow() æ–¹æ³•ä¸­ã€‚ æ ¹æ®æºç æ³¨é‡Šçš„è¯´æ³•ï¼Œè¿™æ ·æ˜¯ä¸ºäº†ä¾¿äºç¼–è¯‘å™¨å¯¹ Fast path è¿›è¡Œå†…è”ä¼˜åŒ–ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 // Unlock unlocks m. // It is a run-time error if m is not locked on entry to Unlock. // // A locked Mutex is not associated with a particular goroutine. // It is allowed for one goroutine to lock a Mutex and then // arrange for another goroutine to unlock it. func (m *Mutex) Unlock() { if race.Enabled { _ = m.state race.Release(unsafe.Pointer(m)) } // 1) é€šè¿‡åŸå­æ“ä½œä» state ä¸­å‡å» mutexLockedï¼Œä¹Ÿå°±æ˜¯é‡Šæ”¾é” // ç„¶åæ ¹æ® state çš„æ–°å€¼(new)æ¥åˆ¤æ–­æ˜¯å¦éœ€è¦æ‰§è¡Œ Slow pathã€‚ // Fast path: drop lock bit. // // Fast path: ç›´æ¥æŠŠé”æ ‡å¿—ä½æ”¾å¼€ // å¦‚æœä¹‹å‰mutexLockedä½ä¸º1åˆ™ä¿®æ”¹ä¸º0ï¼›å¦‚æœä¹‹å‰mutexLockedä½ä¸º0åˆ™ä¿®æ”¹ä¸º1ï¼› new := atomic.AddInt32(\u0026amp;m.state, -mutexLocked)\t// å¦‚æœåˆ é™¤äº†é”çš„bitä½ï¼Œstateç­‰äº0è¯´æ˜æ²¡æœ‰ç­‰å¾…æŠ¢é”çš„goroutineç›´æ¥è¿”å› // newä¸º0ï¼Œæ„å‘³ç€æ²¡æœ‰å…¶ä»– goroutine åœ¨æ’é˜Ÿï¼Œæ‰€ä»¥ä¸éœ€è¦æ‰§è¡Œé¢å¤–æ“ä½œã€‚ // newä¸ä¸º0ï¼Œåˆ™å¯èƒ½éœ€è¦å”¤é†’æŸä¸ª goroutineã€‚ // Unlock æ‰§è¡Œå®Œåmutex.state!=0 åˆ™å­˜åœ¨ä»¥ä¸‹å¯èƒ½ // æ­£å¸¸æ¨¡å¼ä¸‹ // 1. å½“å‰å­˜åœ¨ç­‰å¾…çš„goroutineå»å”¤é†’å®ƒ //\t2. å½“å‰å­˜åœ¨è‡ªæ—‹ç­‰å¾…çš„goroutineï¼Œåˆ™ä¸å”¤é†’å…¶ä»–ç­‰å¾…çš„goroutine // é¥¥é¥¿æ¨¡å¼ä¸‹ // 1. ç›´æ¥å°†é”äº¤ç»™ç­‰å¾…é˜Ÿåˆ—çš„ç¬¬ä¸€ä¸ªgoroutine if new != 0 {\t// è¿˜å­˜åœ¨å…¶ä»–ç­‰å¾…é˜Ÿåˆ—ä¸­çš„goroutine // Outlined slow path to allow inlining the fast path. // To hide unlockSlow during tracing we skip one extra frame when tracing GoUnblock. // // æ¦‚è¿°äº†æ…¢é€Ÿè·¯å¾„ä»¥å…è®¸å†…è”å¿«é€Ÿè·¯å¾„ // ä¸ºäº†åœ¨è·Ÿè¸ªè¿‡ç¨‹ä¸­éšè— unlockSlowï¼Œæˆ‘ä»¬åœ¨è·Ÿè¸ª GoUnblock æ—¶ä¼šè·³è¿‡ä¸€ä¸ªé¢å¤–çš„å¸§ m.unlockSlow(new) } } unlockSlow() 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 func (m *Mutex) unlockSlow(new int32) { // åˆ¤æ–­æœªåŠ é”çš„æƒ…å†µä¸‹ä¸èƒ½å¤šæ¬¡è°ƒç”¨unlock // æ­£å¸¸é€»è¾‘è¿™é‡Œ new+mutexLocked åº”è¯¥ä¸º1 if (new+mutexLocked)\u0026amp;mutexLocked == 0 {\t// è¿™ç§æƒ…å†µåˆ¤æ–­ä¹‹å‰æ ¹æœ¬å°±æ²¡åŠ è¿‡é”ï¼Œåˆ™å»è§£é”è¿™ä¼šç›´æ¥æŠ¥é”™è¯¯ throw(\u0026#34;sync: unlock of unlocked mutex\u0026#34;) } // æ­£å¸¸æ¨¡å¼ä¸‹ if new\u0026amp;mutexStarving == 0 { // ä» old -\u0026gt; new åŸå­æ“ä½œï¼Œä¸»è¦æ˜¯å”¤é†’goroutine old := new for {\t// ä»¥ä¸‹ä»£ç æ˜¯é€šè¿‡å”¤é†’goroutineå’Œå…¶ä»–æ­£åœ¨è¿è¡Œçš„goroutineå»äº‰æŠ¢é” // If there are no waiters or a goroutine has already // been woken or grabbed the lock, no need to wake anyone. // In starvation mode ownership is directly handed off from unlocking // goroutine to the next waiter. We are not part of this chain, // since we did not observe mutexStarving when we unlocked the mutex above. // So get off the way. // // å¦‚æœæ²¡æœ‰waitersï¼Œæˆ–goroutineå·²ç»è¢«å«é†’æˆ–æŠ¢äº†é”ï¼Œæ²¡æœ‰å¿…è¦å«é†’ä»»ä½•äººã€‚ // åœ¨é¥¥é¥¿æ¨¡å¼ä¸‹ï¼Œæ‰€æœ‰æƒä¼šä»è§£é”goroutineç›´æ¥ç§»äº¤ç»™ä¸‹ä¸€ä¸ªwaiterã€‚ // æˆ‘ä»¬ä¸æ˜¯è¿™ä¸ªé“¾çš„ä¸€éƒ¨åˆ†ï¼Œå› ä¸ºæˆ‘ä»¬åœ¨ä¸Šé¢è§£é”äº’æ–¥é”æ—¶æ²¡æœ‰è§‚å¯Ÿåˆ°mutexStarvingã€‚æ‰€ä»¥åˆ«æŒ¡é“ã€‚ // // æ²¡æœ‰ç­‰å¾…çš„goroutine æˆ– (æœ‰å…¶ä»–çš„goroutineå·²è¿‘è·å¾—é” æˆ– æœ‰è¢«å”¤é†’çš„goroutine æˆ– å½“å‰å¤„äºé¥¥é¥¿æ¨¡å¼ä¸‹) if old\u0026gt;\u0026gt;mutexWaiterShift == 0 || old\u0026amp;(mutexLocked|mutexWoken|mutexStarving) != 0 { return\t// ç›´æ¥è¿”å›ï¼Œä¸éœ€è¦å†å»åç»­å¤„ç† } // Grab the right to wake someone. // // ç­‰åœ¨è¢«å”¤é†’çš„goroutineæ•°é‡å‡ä¸€ï¼Œè®¾ç½®æœ‰è¢«å”¤é†’æ ‡å¿— new = (old - 1\u0026lt;\u0026lt;mutexWaiterShift) | mutexWoken\t// è®¾ç½®éœ€è¦å”¤é†’ä¸€ä¸ªgoroutineçš„æ–°çŠ¶æ€ if atomic.CompareAndSwapInt32(\u0026amp;m.state, old, new) {\t// åŸå­è®¾ç½®æˆåŠŸï¼Œè¯´æ˜æ²¡æœ‰å…¶ä»–æ­£åœ¨äº‰æŠ¢æˆ–å½“å‰äº‰æŠ¢æˆåŠŸ runtime_Semrelease(\u0026amp;m.sema, false, 1)\t// å–å‡ºç­‰å¾…çš„goroutineæ”¾å…¥æœ¬åœ°Pç­‰å¾…è¢«è°ƒåº¦ï¼Œé¥­åè¿”å› return } old = m.state\t// æ²¡æœ‰è·å–æˆåŠŸï¼Œåˆ™ç›´æ¥æ›¿æ¢æ—§stateï¼Œå†æ¬¡å°è¯• } } else {\t// é¥¥é¥¿æ¨¡å¼ä¸‹ // Starving mode: handoff mutex ownership to the next waiter, and yield // our time slice so that the next waiter can start to run immediately. // Note: mutexLocked is not set, the waiter will set it after wakeup. // But mutex is still considered locked if mutexStarving is set, // so new coming goroutines won\u0026#39;t acquire it. // // é¥¥é¥¿æ¨¡å¼ï¼šå°†mutexæ‰€æœ‰æƒç§»äº¤ç»™ä¸‹ä¸€ä¸ªwaiterï¼Œå¹¶è®©å‡ºæˆ‘ä»¬çš„æ—¶é—´ç‰‡ï¼Œä»¥ä¾¿ä¸‹ä¸€ä¸ªwaiterå¯ä»¥ç«‹å³å¼€å§‹è¿è¡Œ // æ³¨æ„ï¼šmutexLocked æ²¡æœ‰è®¾ç½®ï¼Œwaiterä¼šåœ¨å”¤é†’åè®¾ç½® // ä½†æ˜¯å¦‚æœè®¾ç½®äº† mutexStarvingï¼Œmutex ä»ç„¶è¢«è®¤ä¸ºæ˜¯é”å®šçš„ï¼Œæ‰€ä»¥æ–°çš„ goroutines ä¸ä¼šè·å–å®ƒ // å¤„äºé¥¥é¥¿æ¨¡å¼ä¸‹ä»è¿™é‡Œå”¤é†’çš„goroutineï¼Œstateä¸­mutexLockedä½ï¼Œä¸€å®šä¸º0 runtime_Semrelease(\u0026amp;m.sema, true, 1)\t// é¥¥é¥¿æ¨¡å¼ä¸‹åªä»é¦–éƒ¨å–å‡ºgoroutineç­‰å¾…è¢«è°ƒåº¦å³å¯ // è¿™é‡Œåœ¨é¥¥é¥¿æ¨¡å¼ä¸‹ä¸ºç”šä¸åˆ¤æ–­ç­‰å¾…çš„goroutineæ•°é‡ï¼Ÿ // åŸå› æ˜¯ï¼šå¤„äºé¥¥é¥¿æ¨¡å¼ä¸‹ç­‰å¾…çš„goroutineæ•°é‡ä¸€å®šæ˜¯\u0026gt;=1çš„ã€‚ // å› ä¸ºæœ€åä¸€ä¸ªgoroutineä¼šæŠŠæ¨¡å¼åˆ‡æ¢æˆæ­£å¸¸æ¨¡å¼ï¼Œç›¸å…³ä»£ç ä½äºLockå‡½æ•° } } TryLock() TryLockè¯•å›¾é”å®šmå¹¶æŠ¥å‘Šæ˜¯å¦æˆåŠŸã€‚ è¯·æ³¨æ„ï¼Œè™½ç„¶ç¡®å®å­˜åœ¨æ­£ç¡®ä½¿ç”¨TryLockçš„æƒ…å†µï¼Œä½†å¾ˆå°‘ï¼Œè€Œä¸”TryLockçš„ä½¿ç”¨é€šå¸¸è¡¨æ˜äº’æ–¥é‡çš„ç‰¹å®šä½¿ç”¨ä¸­å­˜åœ¨æ›´æ·±å±‚çš„é—®é¢˜ã€‚ TryLock å¯ä»¥ç”¨äºåœ¨ä¸šåŠ¡æ¯”è¾ƒç¹å¿™æ—¶å»å°è¯•è·å–é”ï¼Œå¤±è´¥åˆ™æç¤ºç›¸å…³æ–‡æ¡ˆç­‰ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 // TryLock tries to lock m and reports whether it succeeded. // // Note that while correct uses of TryLock do exist, they are rare, // and use of TryLock is often a sign of a deeper problem // in a particular use of mutexes. func (m *Mutex) TryLock() bool { old := m.state // å½“å‰é”å­˜åœ¨ æˆ– å½“å‰å¤„äºé¥¥é¥¿æ¨¡å¼ if old\u0026amp;(mutexLocked|mutexStarving) != 0 { return false\t// è·å–å¤±è´¥ } // There may be a goroutine waiting for the mutex, but we are // running now and can try to grab the mutex before that // goroutine wakes up. // // å¯èƒ½æœ‰ä¸€ä¸ªgoroutineåœ¨ç­‰å¾…äº’æ–¥é‡ï¼Œä½†æˆ‘ä»¬ç°åœ¨æ­£åœ¨è¿è¡Œï¼Œå¹¶ä¸”å¯ä»¥å°è¯•åœ¨goroutineå”¤é†’ä¹‹å‰è·å–äº’æ–¥é‡ã€‚ // // å°è¯•å»äº‰æŠ¢é”ï¼Œè¿™é‡Œçš„oldä¸€å®šæ˜¯æ²¡åŠ é”å¹¶å¤„äºæ­£å¸¸æ¨¡å¼ä¸‹å»å°è¯•äº‰æŠ¢ if !atomic.CompareAndSwapInt32(\u0026amp;m.state, old, old|mutexLocked) { return false\t// äº‰æŠ¢å¤±è´¥æƒ…å†µ } if race.Enabled { race.Acquire(unsafe.Pointer(m)) } return true\t// äº‰æŠ¢æˆåŠŸ } type Locker interface Lockeræ¥å£ä»£è¡¨ä¸€ä¸ªå¯ä»¥åŠ é”å’Œè§£é”çš„å¯¹è±¡ 1 2 3 4 5 // A Locker represents an object that can be locked and unlocked. type Locker interface { Lock() Unlock() } ä½¿ç”¨ç¤ºä¾‹ sync.Mutex äº’æ–¥é”ï¼šæ˜¯ä¼ ç»Ÿçš„å¹¶å‘ç¨‹åºå¯¹å…±äº«èµ„æºè¿›è¡Œè®¿é—®æ§åˆ¶çš„ä¸»è¦æ‰‹æ®µï¼ŒGoè¯­è¨€ä¸­æ¨èä½¿ç”¨é€šé“(channel)æ¥å®ç°èµ„æºå…±äº«å’Œé€šä¿¡ äº’æ–¥é”ï¼šç”±æ ‡å‡†åº“ sync åŒ…ä¸­åˆ†çš„ Mutex ç»“æ„ä½“ç±»å‹å®ç° åªæœ‰ä¸¤ä¸ªå…¬å¼€æ–¹æ³•ï¼š Lock() ï¼šè·å¾—é” Unlock() ï¼šé‡Šæ”¾é” åŒä¸€ä¸ªåç¨‹ä¸­åŒæ­¥è°ƒç”¨ä½¿ç”¨Lock()åŠ é”åï¼Œä¸èƒ½å†å¯¹å…¶åŠ é”ï¼Œå¦åˆ™ä¼šå¼•å‘è¿è¡Œæ—¶å¼‚å¸¸ï¼Œåªèƒ½åœ¨ Unlock() ä¹‹åå†æ¬¡ Lock() å¤šä¸ªåç¨‹ä¸­å¼‚æ­¥è°ƒç”¨Lock()æ²¡æœ‰é—®é¢˜ï¼Œä½†æ¯ä¸ªåç¨‹åªèƒ½è°ƒç”¨ä¸€æ¬¡Lock()ï¼Œç”±äºå¤šä¸ªåç¨‹ä¹‹é—´äº§ç”Ÿäº†é”ç«äº‰ï¼Œå› æ­¤ä¸ä¼šæœ‰è¿è¡Œæ—¶å¼‚å¸¸ äº’æ–¥é”ï¼šé€‚ç”¨äºåªå…è®¸æœ‰ä¸€ä¸ªè¯»æˆ–è€…å†™çš„åœºæ™¯ï¼Œæ‰€ä»¥è¯¥é”ä¹Ÿå«å…¨å±€é” å¦‚æœåœ¨ä½¿ç”¨ Unlock() å‰æœªåŠ é”ï¼Œå°±ä¼šå¼•èµ·ä¸€ä¸ªè¿è¡Œé”™è¯¯ï¼Œå·²ç»é”å®šçš„ Mutex å¹¶ä¸ä¸ç‰¹å®šçš„åç¨‹ç›¸å…³ï¼Œè¿™æ ·å¯ä»¥åˆ©ç”¨ä¸€ä¸ªåç¨‹å¯¹å…¶åŠ é”ï¼Œåœ¨åˆ©ç”¨å…¶å®ƒåç¨‹å¯¹å…¶è§£é” 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 // LockA() ä¸­æœ‰ Lock() // LockB() ä¸­ä¹Ÿæœ‰ Lock() // LockB() çš„ Lock() è¿è¡Œæ—¶ï¼Œé”è¿˜æ²¡æœ‰ Unlock()ï¼Œç¨‹åºå‘ç”Ÿ panic // è¿™æ˜¯åœ¨åŒæ­¥è°ƒç”¨äº’æ–¥é”ä¸­å¸¸è§çš„é—®é¢˜ï¼Œä¸€èˆ¬åœ¨ä¸€å¯¹äº’æ–¥é”ä¸­é—´ä¸è¦è°ƒç”¨å…¶å®ƒå‡½æ•°ï¼Œå³ä½¿è¦ç”¨ä¹Ÿå°½é‡é‡‡ç”¨å¼‚æ­¥æ–¹å¼ package main import ( \u0026#34;fmt\u0026#34; \u0026#34;sync\u0026#34; \u0026#34;time\u0026#34; ) var mutex sync.Mutex func main() { LockA() time.Sleep(10) } func LockA() { mutex.Lock()\t// åŠ é” fmt.Println(\u0026#34;Lock in A\u0026#34;) LockB() time.Sleep(5) fmt.Println(\u0026#34;Wake up in A\u0026#34;) mutex.Unlock()\t// è§£é” fmt.Println(\u0026#34;Unlock in A\u0026#34;) } func LockB() { fmt.Println(\u0026#34;B\u0026#34;) mutex.Lock()\t// åŠ é”\tmain goroutineåœ¨è¿™é‡Œè¢«é˜»å¡ï¼Œå¯¼è‡´deadlock fmt.Println(\u0026#34;Lock in B\u0026#34;) mutex.Unlock()\t// è§£é” fmt.Println(\u0026#34;Unlock in B\u0026#34;) } /* Lock in A B fatal error: all goroutines are asleep - deadlock! goroutine 1 [semacquire]: sync.runtime_SemacquireMutex(0x593b24, 0x0, 0x1) D:/True-False/Go/src/runtime/sema.go:71 +0x4e sync.(*Mutex).lockSlow(0x593b20) D:/True-False/Go/src/sync/mutex.go:138 +0x103 sync.(*Mutex).Lock(...) D:/True-False/Go/src/sync/mutex.go:81 main.LockB() D:/True-False/WWW/GoLang/src/xuexi/mutex.go:28 +0x194 main.LockA() D:/True-False/WWW/GoLang/src/xuexi/mutex.go:19 +0xa2 main.main() D:/True-False/WWW/GoLang/src/xuexi/mutex.go:12 +0x29 exit status 2 */ æŠŠä¸Šé¢åŒæ­¥æ”¹ä¸ºå¼‚æ­¥ï¼ŒæŠŠLockA()çš„LockB()æ”¹ä¸ºgo LockB() 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;sync\u0026#34; \u0026#34;time\u0026#34; ) var mutex sync.Mutex func main() { LockA() time.Sleep(10) } func LockA() { mutex.Lock()\t// åŠ é” fmt.Println(\u0026#34;Lock in A\u0026#34;) go LockB() time.Sleep(5) fmt.Println(\u0026#34;Wake up in A\u0026#34;) mutex.Unlock()\t// è§£é” fmt.Println(\u0026#34;Unlock in A\u0026#34;) } func LockB() { fmt.Println(\u0026#34;B\u0026#34;) mutex.Lock()\t// åŠ é”\tlockB goroutineç­‰å¾…LockAè§£é”ï¼Œå…ˆè‡ªæ—‹å†æ˜¯è¢«æŒ‚èµ· fmt.Println(\u0026#34;Lock in B\u0026#34;) mutex.Unlock()\t// è§£é” fmt.Println(\u0026#34;Unlock in B\u0026#34;) } /* Lock in A B Wake up in A Unlock in A Lock in B Unlock in B */ å»ºè®®ï¼šåŒä¸€ä¸ªäº’æ–¥é”çš„æˆå¯¹é”å®šå’Œè§£é”æ“ä½œå¯ä»¥æ”¾åœ¨åŒä¸€å±‚æ¬¡çš„ä»£ç å—ä¸­ ç»å…¸ç”¨æ³•å¦‚ä¸‹ï¼š 1 2 3 4 5 6 7 8 var lck sync.Mutex func foo() { lck.Lock()\t// åŠ é” defer lck.Unlock()\t// è§£é” // ... ... } // lck.Lock() ä¼šé˜»å¡ç›´åˆ°è·å–é”ï¼Œç„¶ååˆ©ç”¨deferè¯­å¥åœ¨å‡½æ•°è¿”å›æ—¶è‡ªåŠ¨é‡Šæ”¾é” ç¤ºä¾‹ä»£ç ï¼Œé€šè¿‡ä¸‰ä¸ªåç¨‹æ¥ä½“ç°sync.Mutexå¯¹èµ„æºçš„è®¿é—®æ§åˆ¶ç‰¹å¾ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;sync\u0026#34; \u0026#34;time\u0026#34; ) func main() { //var wg sync.WaitGroup wg := sync.WaitGroup{} var mutex sync.Mutex fmt.Println(\u0026#34;Locking (G0)\u0026#34;) mutex.Lock()\t// åŠ é” fmt.Println(\u0026#34;locked (G0)\u0026#34;) wg.Add(3) for i := 1; i \u0026lt; 4; i++ { go func(i int) { fmt.Printf(\u0026#34;Locking (G%d)\\n\u0026#34;, i) mutex.Lock()\t// åŠ é” fmt.Printf(\u0026#34;Locked (G%d)\\n\u0026#34;, i) time.Sleep(time.Second * 2)\t// å»¶è¿Ÿ2s mutex.Unlock()\t// è§£é” fmt.Printf(\u0026#34;unlocked (G%d)\\n\u0026#34;, i) wg.Done() }(i) } time.Sleep(time.Second * 5) fmt.Println(\u0026#34;ready unlock (G0)\u0026#34;) mutex.Unlock()\t// è§£é” fmt.Printf(\u0026#34;unlocked (G0)\u0026#34;) wg.Wait() } // ç¨‹åºè¿è¡Œç»“æœå¯ä»¥çœ‹å‡ºï¼Œå½“æœ‰é”é‡Šæ”¾æ—¶ï¼Œæ‰èƒ½è¿›è¡ŒåŠ é”åŠ¨ä½œ // è¿è¡Œç»“æœå¦‚ä¸‹ Locking (G0) locked (G0) Locking (G1) Locking (G2) Locking (G3) ready unlock (G0) unlocked (G0)Locked (G1) unlocked (G1) Locked (G2) unlocked (G2) Locked (G3) unlocked (G3) Mutex ä¹Ÿå¯ä»¥ä½œä¸ºç»“æ„ä½“çš„ä¸€éƒ¨åˆ†ï¼Œè¿™æ ·ç»“æ„ä½“åœ¨è¢«å¤šçº¿ç¨‹å¤„ç†æ—¶æ•°æ®å®‰å…¨æ‰æœ‰ä¿éšœ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;sync\u0026#34; \u0026#34;time\u0026#34; ) type Book struct { BookName string L *sync.Mutex } func (bk *Book) SetName(wg *sync.WaitGroup, name string) { defer func() { fmt.Println(\u0026#34;Unlock set name:\u0026#34;, name) bk.L.Unlock()\t// è§£é” wg.Done() }() bk.L.Lock()\t// åŠ é” fmt.Println(\u0026#34;Lock set name:\u0026#34;, name) time.Sleep(1 * time.Second) bk.BookName = name } func main() { bk := Book{} //bk.L = \u0026amp;sync.Mutex{} bk.L = new(sync.Mutex) //wg := new(sync.WaitGroup) wg := \u0026amp;sync.WaitGroup{} books := []string{\u0026#34;\u0026lt;\u0026lt;ä¸‰å›½æ¼”ä¹‰\u0026gt;\u0026gt;\u0026#34;, \u0026#34;\u0026lt;\u0026lt;é“å¾·ç»\u0026gt;\u0026gt;\u0026#34;, \u0026#34;\u0026lt;\u0026lt;è¥¿æ¸¸è®°\u0026gt;\u0026gt;\u0026#34;} for _, book := range books { wg.Add(1) go bk.SetName(wg, book) } wg.Wait() } Lock set name: \u0026lt;\u0026lt;è¥¿æ¸¸è®°\u0026gt;\u0026gt; Unlock set name: \u0026lt;\u0026lt;è¥¿æ¸¸è®°\u0026gt;\u0026gt; Lock set name: \u0026lt;\u0026lt;ä¸‰å›½æ¼”ä¹‰\u0026gt;\u0026gt; Unlock set name: \u0026lt;\u0026lt;ä¸‰å›½æ¼”ä¹‰\u0026gt;\u0026gt; Lock set name: \u0026lt;\u0026lt;é“å¾·ç»\u0026gt;\u0026gt; Unlock set name: \u0026lt;\u0026lt;é“å¾·ç»\u0026gt;\u0026gt; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;sync\u0026#34; \u0026#34;time\u0026#34; ) func main() { var m sync.Mutex go func() { m.Lock() defer m.Unlock() fmt.Println(\u0026#34;1\u0026#34;) m.Lock()\t// è¿™é‡Œå½“å‰goroutineå°†è¢«æ°¸ä¹…ä¿å­˜åˆ°ä¿¡å·æ± ä¸­å¾—ä¸åˆ°è¿è¡Œæœºä¼š fmt.Println(\u0026#34;2\u0026#34;) defer m.Unlock() fmt.Println(\u0026#34;3\u0026#34;) }() time.Sleep(5 * time.Second) // Output: // 1 } æ³¨æ„äº‹é¡¹ Lock() å’Œ UnLock() æ–¹æ³•åº”è¯¥æˆå¯¹å‡ºç°ã€‚ sync.Mutex ä¸å…è®¸è¢«å€¼æ‹·è´ï¼Œæ‹·è´åœ°å€å¯ä»¥ã€‚ ","permalink":"http://localhost:1313/posts/golang/sync/mutex/","summary":"Mutexæ˜¯ä¸€ç§äº’æ–¥é”ã€‚","title":"sync.Mutex"},{"content":"type WaitGroup struct ğŸš€ WaitGroup ç­‰å¾… goroutine é›†åˆå®Œæˆã€‚ main goroutine è°ƒç”¨ Add æ¥è®¾ç½®è¦ç­‰å¾…çš„ goroutine çš„æ•°é‡ã€‚ç„¶åæ¯ä¸ª goroutine è¿è¡Œå¹¶åœ¨å®Œæˆæ—¶è°ƒç”¨ Doneã€‚ åŒæ—¶ï¼Œå¯ä»¥ä½¿ç”¨ Wait æ¥é˜»å¡ï¼Œç›´åˆ°æ‰€æœ‰ goroutine å®Œæˆã€‚ WaitGroup åœ¨ç¬¬ä¸€æ¬¡ä½¿ç”¨åä¸èƒ½è¢«å¤åˆ¶ã€‚ WaitGroupï¼šç”¨äºç­‰å¾…ä¸€ç»„çº¿ç¨‹çš„ç»“æŸï¼Œçˆ¶çº¿ç¨‹è°ƒç”¨Addæ–¹æ³•æ¥è®¾å®šåº”ç­‰å¾…çš„çº¿ç¨‹çš„æ•°é‡ã€‚ æ¯ä¸ªè¢«ç­‰å¾…çš„çº¿ç¨‹åœ¨ç»“æŸæ—¶åº”è°ƒç”¨Doneæ–¹æ³•ï¼ŒåŒæ—¶ï¼Œä¸»çº¿ç¨‹é‡Œå¯ä»¥è°ƒç”¨Waitæ–¹æ³•é˜»å¡è‡³æ‰€æœ‰çº¿ç¨‹ç»“æŸã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 // A WaitGroup waits for a collection of goroutines to finish. // The main goroutine calls Add to set the number of // goroutines to wait for. Then each of the goroutines // runs and calls Done when finished. At the same time, // Wait can be used to block until all goroutines have finished. // // A WaitGroup must not be copied after first use. type WaitGroup struct { // WaitGroup é¦–æ¬¡ä½¿ç”¨åä¸èƒ½è¢«æ‹·è´çš„åŸå› ã€æ˜¯ \u0026amp;state2 åœ°å€ä¼šå‘ç”Ÿå˜åŒ–ã€‘ // semaPhore è¦æ±‚ \u0026amp;state2 åœ°å€æ˜¯ä¸€ä¸ªï¼Œä¸ç„¶ä»å…¶ä¸­å”¤é†’ goroutine ä¼šæ‰¾ä¸åˆ° noCopy noCopy\t// ç¼–è¯‘å™¨æ£€æŸ¥WaitGroupå¯¹è±¡æ˜¯å¦è¢«æ‹·è´è¿‡ // 64-bit value: high 32 bits are counter, low 32 bits are waiter count. // 64-bit atomic operations require 64-bit alignment, but 32-bit // compilers only guarantee that 64-bit fields are 32-bit aligned. // For this reason on 32 bit architectures we need to check in state() // if state1 is aligned or not, and dynamically \u0026#34;swap\u0026#34; the field order if // needed. // // 64ä½å€¼: é«˜32ä½æ˜¯ counter è®¡æ•°ï¼Œä½32ä½æ˜¯ waiter è®¡æ•°ã€‚ // 64-bit = ( uint64(counter) \u0026lt;\u0026lt; 32 ) | uint32( waiter ) // ã€64ä½åŸå­æ“ä½œéœ€è¦64ä½å¯¹é½ã€‘ï¼Œä½†æ˜¯32ä½ç¼–è¯‘å™¨åªä¿è¯64ä½å­—æ®µæ˜¯32ä½å¯¹é½çš„ã€‚ // å› æ­¤ï¼Œåœ¨32ä½æ¶æ„ä¸Šï¼Œæˆ‘ä»¬éœ€è¦æ£€æŸ¥åœ¨state()æ˜¯å¦å°†state1å¯¹é½ï¼Œå¹¶åœ¨éœ€è¦æ—¶åŠ¨æ€ â€œäº¤æ¢â€ å­—æ®µé¡ºåºã€‚ // æ„æ€æ˜¯ï¼šåœ¨32ä½æ“ä½œç³»ç»Ÿä¸‹ä½¿ç”¨64ä½åŸå­æ“ä½œæ—¶ï¼Œè¢«æ“ä½œåœ°å€å¿…é¡»æ˜¯64ä½å¯¹é½çš„ï¼Œä¸ç„¶ä¼šå®•æœºã€‚ state1 uint64\t// (uint64(counter) \u0026lt;\u0026lt; 32) | uint32(waiter) state2 uint32 } type noCopy struct noCopy å¯ä»¥åµŒå…¥åˆ°ç¬¬ä¸€æ¬¡ä½¿ç”¨åä¸å¾—å¤åˆ¶çš„ç»“æ„ä¸­. sync/cond.goæ–‡ä»¶ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 // noCopy may be embedded into structs which must not be copied // after the first use. // // See https://golang.org/issues/8005#issuecomment-190753527 // for details. type noCopy struct{} // Lock is a no-op used by -copylocks checker from `go vet`. // // Lock æ˜¯ `go vet` çš„ -copylocks æ£€æŸ¥å™¨ä½¿ç”¨çš„æ— æ“ä½œ func (*noCopy) Lock() {} func (*noCopy) Unlock() {} WaitGroup ç»“æ„å¸ƒå±€ Semaphoreï¼šä¿¡å·é‡ç”¨äºæŒ‚èµ· Wait å‡½æ•°çš„è°ƒç”¨è€…çš„ goroutineã€‚ï¼ˆéœ€è¦ä¸€ä¸ª uint32 ç±»å‹ï¼‰ Counterï¼šç­‰å¾…çš„è¿è¡Œçš„ goroutine æ•°é‡ï¼Œè¯¥å€¼åœ¨ Add å’Œ Done å‡½æ•°ä¸­è¢«æ“ä½œã€‚ Waiterï¼šç­‰å¾…åœ¨ Semaphore ä¸­çš„ goroutine æ•°é‡ã€‚ ä¸ºä»€ä¹ˆéœ€è¦è¿™ä¹ˆè®¾è®¡å‘¢ï¼Ÿå› ä¸º Waiter + Counter æ˜¯ä¸€ä¸ªæ•´ä½“ä½œä¸º64ä½ï¼Œè¢«åŸå­æ“ä½œï¼Œè€Œ64ä½åŸå­æ“ä½œåˆè¦æ±‚å¿…é¡»æ˜¯64ä½å¯¹é½çš„ã€‚ï¼ˆå…·ä½“å‚çœ‹state()æºç ï¼‰ åœ¨1.22ç‰ˆæœ¬ä¸­ï¼Œstate1ä¹Ÿå°±æ˜¯Waiterå’ŒCounterä½¿ç”¨atomic.Uint64æ›¿ä»£äº†ã€‚ä»¥ä¸‹å›¾æ˜¯1.18å‰ç‰ˆæœ¬çš„ã€‚ Semaã€Counterã€Waiter WaitGroup ç»“æ„è®¾è®¡ç›®çš„æ˜¯ç­‰å¾…é›†åˆä¸­çš„goroutineå®Œæˆï¼Œå› æ­¤ main goroutine å°±æ˜¯äº§ç”Ÿè¿™ä¸ªç­‰å¾…é›†åˆçš„ï¼Œå®ƒç­‰å¾…é›†åˆä¸­çš„æ‰€æœ‰goroutineå®Œæˆå†ç»§ç»­åç»­ã€‚ Counter åˆ™æ˜¯è®¡æ•°å½“å‰ç­‰å¾…é›†åˆä¸­çš„goroutineçš„æ•°é‡ï¼Œä¸€ä¸ªgoroutineè¢«åˆ›å»ºæ”¾å…¥é›†åˆæ—¶å°±åº”è¯¥è®¡æ•°Counterå€¼ï¼Œä¸€ä¸ªgoroutineå®Œæˆæ—¶ä¹Ÿåº”è¯¥è®¡æ•°Counterã€‚ å› æ­¤goroutineè¢«åŠ å…¥åˆ°ç­‰å¾…é›†åˆä¸­éƒ½æ˜¯åœ¨main goroutineä¸­æ“ä½œåŒ…æ‹¬Counterçš„è®¡æ•°ï¼Œä¸€ä¸ªgoroutineå®Œæˆè®¡æ•°Counteråº”è¯¥åœ¨è¿™goroutineå®Œæˆæ—¶æ“ä½œã€‚ Semaphore åˆ™æ˜¯ main goroutine åœ¨è°ƒç”¨Wait()å‡½æ•°æ—¶ï¼Œmain goroutineéœ€è¦ç­‰å¾…ç­‰å¾…é›†åˆgoroutineå®Œæˆè€ŒæŒ‚èµ·åœ¨Semaphoreæ± å­é‡Œã€‚ Waiter åˆ™æ˜¯è®°å½•Semaphoreä¸­ç­‰å¾…çš„goroutineçš„æ•°é‡ã€‚ Add() å’Œ Done() å‡½æ•°æ˜¯è®¡æ•°Counterçš„ç›¸å…³æ–¹æ³•ï¼Œåœ¨ç­‰å¾…é›†åˆgoroutineä¸­æœ€åä¸€ä¸ªgoroutineå®Œæˆæ—¶ï¼Œå¦‚æœæœ‰ç­‰å¾…åœ¨Semaphoreçš„goroutineåº”è¯¥å…¨éƒ¨å”¤é†’ã€‚ Wait() å‡½æ•°æ˜¯ç­‰å¾…ç­‰å¾…é›†åˆgoroutineå®Œæˆï¼Œmain goroutineä¸»åŠ¨æŒ‚èµ·è‡ªå·±çš„ç›¸å…³é€»è¾‘ã€‚ state() State è¿”å›æŒ‡å‘å­˜å‚¨åœ¨ wg.state* ä¸­çš„ State å’Œ sema å­—æ®µçš„æŒ‡é’ˆã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 // state returns pointers to the state and sema fields stored within wg.state*. func (wg *WaitGroup) state() (statep *uint64, semap *uint32) { // unsafe.Alignof(wg.state1) == 8ï¼šè¯´æ˜state1å­—æ®µå¯¹é½ä¸º8å­—èŠ‚ï¼Œè¿™ç§æƒ…å†µæ˜¯64ä½å¹³å° // uintptr(unsafe.Pointer(\u0026amp;wg.state1))%8 == 0ï¼šè¯´æ˜wg.state1çš„åœ°å€æŒ‰ç…§8å­—èŠ‚å¯¹é½çš„ï¼Œå¯èƒ½æ˜¯64æˆ–32å¹³å° if unsafe.Alignof(wg.state1) == 8 || uintptr(unsafe.Pointer(\u0026amp;wg.state1))%8 == 0 { // state1 is 64-bit aligned: nothing to do. // state1 æ˜¯ 64 ä½å¯¹é½çš„ï¼šæ— äº‹å¯åš return \u0026amp;wg.state1, \u0026amp;wg.state2\t// state1æ˜¯64ä½å¯¹é½ï¼Œstate1å°±æ˜¯stateï¼Œstate2å°±æ˜¯sema } else { // state1 is 32-bit aligned but not 64-bit aligned: this means that // (\u0026amp;state1)+4 is 64-bit aligned. // // State1æ˜¯32ä½å¯¹é½ï¼Œè€Œä¸æ˜¯64ä½å¯¹é½:è¿™æ„å‘³ç€ (\u0026amp;state1)+4 æ˜¯64ä½å¯¹é½ã€‚ // è¿™ç§æƒ…å†µå¤„ç†å°±æ˜¯ä¸ºäº†æ»¡è¶³åç»­ï¼š64ä½åŸå­æ“ä½œéœ€è¦64ä½å¯¹é½ state := (*[3]uint32)(unsafe.Pointer(\u0026amp;wg.state1))\treturn (*uint64)(unsafe.Pointer(\u0026amp;state[1])), \u0026amp;state[0] } } Add() Add å°† delta (å¯èƒ½æ˜¯è´Ÿæ•°)æ·»åŠ åˆ° WaitGroup counterã€‚ å¦‚æœ counter å˜ä¸º0ï¼Œæ‰€æœ‰åœ¨ç­‰å¾…æ—¶è¢«é˜»å¡çš„ goroutine éƒ½ä¼šè¢«é‡Šæ”¾ã€‚å¦‚æœ counter å˜ä¸ºè´Ÿæ•°ï¼Œåˆ™ä¼š paincã€‚ è¯·æ³¨æ„ï¼Œå½“ counter ä¸º0æ—¶ï¼Œdeltaä¸ºæ­£çš„è°ƒç”¨å¿…é¡»å‘ç”Ÿåœ¨ç­‰å¾…ä¹‹å‰ã€‚ ä½¿ç”¨è´Ÿçš„deltaè°ƒç”¨ï¼Œæˆ–è€…ä» counter å¤§äºé›¶å¼€å§‹ä½¿ç”¨æ­£çš„deltaè°ƒç”¨ï¼Œéƒ½å¯èƒ½åœ¨ä»»ä½•æ—¶å€™å‘ç”Ÿã€‚ é€šå¸¸ï¼Œè¿™æ„å‘³ç€å¯¹Addçš„è°ƒç”¨åº”è¯¥åœ¨åˆ›å»ºgoroutineè¯­å¥æˆ–å…¶ä»–è¦ç­‰å¾…çš„äº‹ä»¶ä¹‹å‰æ‰§è¡Œã€‚ å¦‚æœé‡ç”¨ä¸€ä¸ª WaitGroup æ¥ç­‰å¾…å‡ ä¸ªç‹¬ç«‹çš„äº‹ä»¶é›†ï¼Œé‚£ä¹ˆæ–°çš„Addè°ƒç”¨å¿…é¡»åœ¨æ‰€æœ‰å…ˆå‰çš„waitè°ƒç”¨éƒ½è¿”å›ä¹‹åå‘ç”Ÿã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 // Add adds delta, which may be negative, to the WaitGroup counter. // If the counter becomes zero, all goroutines blocked on Wait are released. // If the counter goes negative, Add panics. // // Note that calls with a positive delta that occur when the counter is zero // must happen before a Wait. Calls with a negative delta, or calls with a // positive delta that start when the counter is greater than zero, may happen // at any time. // Typically this means the calls to Add should execute before the statement // creating the goroutine or other event to be waited for. // If a WaitGroup is reused to wait for several independent sets of events, // new Add calls must happen after all previous Wait calls have returned. // See the WaitGroup example. func (wg *WaitGroup) Add(delta int) { // 1) åŸå­æ“ä½œ statep += delta // statep *uint64ï¼šã€Waiter + Counterã€‘ // semap *uint32ï¼šã€semaphoreã€‘ // *statep = (uint64(counter) \u0026lt;\u0026lt; 32) | uint32(waiter) statep, semap := wg.state() if race.Enabled { _ = *statep // trigger nil deref early if delta \u0026lt; 0 { // Synchronize decrements with Wait. race.ReleaseMerge(unsafe.Pointer(wg)) } race.Disable() defer race.Enable() } // åŸå­æ“ä½œ {counter += delta; state = counter;} delta å¯èƒ½ä¸ºè´Ÿæ•° // è¿™é‡Œçš„64ä½åŸå­æ“ä½œä¹Ÿå°±æ˜¯ä¸ºä»€ä¹ˆéœ€è¦ state å‡½æ•°çš„åŸå›  state := atomic.AddUint64(statep, uint64(delta)\u0026lt;\u0026lt;32) // counter += delta // æ³¨æ„è¿™é‡Œæ˜¯ int32 ç±»å‹ï¼ŒåŸå› æ˜¯ delta æ˜¯æ¥è‡ªç”¨æˆ·ä¼ å…¥ï¼Œå¯èƒ½æœ€åå¯¼è‡´ v \u0026lt; 0 æƒ…å†µå‘ç”Ÿ v := int32(state \u0026gt;\u0026gt; 32)\t// counter é«˜32ä½ w := uint32(state)\t// waiter ä½32ä½ if race.Enabled \u0026amp;\u0026amp; delta \u0026gt; 0 \u0026amp;\u0026amp; v == int32(delta) { // The first increment must be synchronized with Wait. // Need to model this as a read, because there can be // several concurrent wg.counter transitions from 0. race.Read(unsafe.Pointer(semap)) } // 2) counter ä¸èƒ½ä¸ºè´Ÿæ•° // counter ä¸åº”è¯¥å‡ºç°ä¸ºè´Ÿæ•°æƒ…å†µ if v \u0026lt; 0 { panic(\u0026#34;sync: negative WaitGroup counter\u0026#34;) } // 3) Add(\u0026gt;0) å’Œ Wait å‡½æ•°ä¸èƒ½å¹¶å‘è°ƒç”¨ // Add(\u0026gt;0) å’Œ Wait() å‡½æ•°å¹¶å‘è¢«è°ƒç”¨ // 1. w != 0 å­˜åœ¨ç­‰å¾…çš„waiter // 2. delta \u0026gt; 0 æœ¬æ¬¡è°ƒç”¨æ˜¯æ·»åŠ ä¸æ˜¯å‡å°‘ // 3. v == int32(delta) å½“å‰æ·»åŠ çš„æ•°é‡å°±æ˜¯æ€»æ•°é‡ï¼Œä¹‹å‰ä¸º0 if w != 0 \u0026amp;\u0026amp; delta \u0026gt; 0 \u0026amp;\u0026amp; v == int32(delta) { panic(\u0026#34;sync: WaitGroup misuse: Add called concurrently with Wait\u0026#34;) } // 4) if ( v \u0026gt; 0 || (v == 0 \u0026amp;\u0026amp; w == 0) ) return // Counterè®¡æ•°æ•°é‡å¤§äºé›¶ æˆ– æ²¡æœ‰ç­‰å¾…çš„waiterç›´æ¥è¿”å› // 1. v \u0026gt; 0ï¼šä»£è¡¨ä¸æ˜¯æœ€åä¸€ä¸ªï¼Œå› æ­¤ç›´æ¥è¿”å› // 2. v == 0 \u0026amp;\u0026amp; w == 0ï¼šä¹Ÿæ˜¯ç›´æ¥è¿”å› if v \u0026gt; 0 || w == 0 {\t// è¿™é‡Œçš„æ¡ä»¶æ¯”è¾ƒå…³é”® return } // 5) v == 0 \u0026amp;\u0026amp; w \u0026gt; 0 // è¿™ç§æƒ…å†µéœ€è¦å»æŠŠ semap ä¸Šé¢æŒ‚èµ·çš„ goroutine å…¨éƒ¨å”¤é†’ // This goroutine has set counter to 0 when waiters \u0026gt; 0. // Now there can\u0026#39;t be concurrent mutations of state: // - Adds must not happen concurrently with Wait, // - Wait does not increment waiters if it sees counter == 0. // Still do a cheap sanity check to detect WaitGroup misuse. // // å½“ waiters \u0026gt; 0 æ—¶ï¼Œæ­¤ goroutine å°† counter è®¾ç½®ä¸º 0 // ç°åœ¨ä¸èƒ½æœ‰å¹¶å‘çš„ state çªå˜ï¼š // - Add ä¸èƒ½ä¸ Wait åŒæ—¶å‘ç”Ÿ // - å¦‚æœçœ‹åˆ° counter == 0ï¼ŒWait ä¸ä¼šå¢åŠ  waiter // ä»ç„¶è¦åšä¸€ä¸ªå»‰ä»·çš„å¥å…¨æ£€æŸ¥æ¥æ£€æµ‹WaitGroupçš„æ»¥ç”¨ã€‚ // // WaitGroupè¯¯ç”¨:Addä¸Waitå¹¶å‘è°ƒç”¨ // è¿™ç§æƒ…å†µå‘ç”Ÿåœ¨ï¼šæœ€åä¸€ä¸ªgoroutineè¿è¡Œå®Œéœ€è¦å”¤é†’ç­‰å¾…çš„waiteræ­¤æ—¶Addæ–¹æ³•æœ‰è¢«è°ƒç”¨ if *statep != state { panic(\u0026#34;sync: WaitGroup misuse: Add called concurrently with Wait\u0026#34;) } // Reset waiters count to 0. *statep = 0\t// é‡ç½® Counter = 0ï¼ŒWaiter = 0 for ; w != 0; w-- { // falseæ­£å¸¸æ¨¡å¼ // å°†ç­‰å¾…åœ¨ semaphore ä¸­çš„goroutineå–å‡ºç­‰å¾…è°ƒåº¦ runtime_Semrelease(semap, false, 0) } } Done() Done å°† WaitGroup counter å‡1ã€‚ 1 2 3 4 // Done decrements the WaitGroup counter by one. func (wg *WaitGroup) Done() { wg.Add(-1) } Wait() Wait é˜»å¡ï¼Œç›´åˆ° WaitGroup counter ä¸º0ã€‚ Wait å‡½æ•°çš„è°ƒç”¨æœŸé—´ï¼Œå¯èƒ½å¤„äºå¤šä¸ªgoroutineåœ¨è°ƒç”¨ Done å‡½æ•°ã€‚ Wait() å‡½æ•°å…è®¸è¢«å¤šä¸ªçº¿ç¨‹åŒæ—¶è°ƒç”¨ã€‚Wait() å‡½æ•°ä¸€å®šè¦æ‰€æœ‰çš„Counteréƒ½æ ‡è®°å®Œæ¯•åæ‰è°ƒç”¨è¯¥æ–¹æ³•ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 // Wait blocks until the WaitGroup counter is zero. func (wg *WaitGroup) Wait() { // statep *uint64ï¼šã€Waiter + Counterã€‘ // semap *uint32ï¼šã€semaphoreã€‘ // *statep = (uint64(counter) \u0026lt;\u0026lt; 32) | uint32(waiter) statep, semap := wg.state() if race.Enabled { _ = *statep // trigger nil deref early race.Disable() } for { state := atomic.LoadUint64(statep)\t// åŸå­è¯»å– statep v := int32(state \u0026gt;\u0026gt; 32)\t// counter w := uint32(state)\t// waiter // è¿™ç§æƒ…å†µï¼Œæ¯”å¦‚åœ¨è°ƒç”¨Waitå‡½æ•°æ—¶å…ˆè°ƒç”¨sleepç¡çœ å¾ˆé•¿ä¸€æ®µæ—¶é—´ // ä¹Ÿå°±æ˜¯ Wait å‡½æ•°è¿˜æ²¡å¼€å§‹æ‰§è¡Œ å…¶ä»–goroutine å·²ç»æ‰§è¡Œå®Œäº†ï¼Œå› æ­¤ç›´æ¥è¿”å›å³å¯ if v == 0 {\t// Counter is 0, no need to wait. // // è®¡æ•°å™¨ä¸º 0ï¼Œæ— éœ€ç­‰å¾… if race.Enabled { race.Enable() race.Acquire(unsafe.Pointer(wg)) } return } // Increment waiters count. // // å¢åŠ waiteræ•°é‡ï¼Œæ­£å¸¸é€»è¾‘ä¸‹åœ¨è¿™é‡Œç­‰å¾…çš„åªæœ‰main goroutineä¸€ä¸ª // è¿™é‡Œå¯èƒ½ä¼šå¤±è´¥ï¼Œå¯èƒ½æœ‰å¾ˆå¤šgoroutineæ­£åœ¨è°ƒç”¨Addæˆ–Doneæ–¹æ³•ä¿®æ”¹Counterå¯¼è‡´è¿™é‡ŒåŸå­æ“ä½œå¤±è´¥ if atomic.CompareAndSwapUint64(statep, state, state+1) { if race.Enabled \u0026amp;\u0026amp; w == 0 { // Wait must be synchronized with the first Add. // Need to model this is as a write to race with the read in Add. // As a consequence, can do the write only for the first waiter, // otherwise concurrent Waits will race with each other. race.Write(unsafe.Pointer(semap)) } // è¯¥æ–¹æ³•æœ€åä¼šè°ƒç”¨semacquire1ï¼Œæˆ‘ä»¬åœ¨sync.Mutexä¸­å·²ç»è®¨è®ºè¿‡ // è¿™é‡Œä¼šæŠŠå½“å‰goroutineå…¥é˜Ÿï¼Œæ³¨æ„è¿™é‡Œå…¥é˜Ÿçš„æ˜¯main goroutine // runtime_Semacquire å°†å½“å‰ goroutine åŠ å…¥åˆ° semaphore çš„å°¾éƒ¨ runtime_Semacquire(semap)\t// ä¸»çº¿ç¨‹åœ¨è¿™é‡Œè¢«è°ƒç¦»å·¥ä½œçº¿ç¨‹ï¼Œä¸‹æ¬¡æ¢å¤æ—¶ä»è¿™é‡Œæ¥åˆ°æ‰§è¡Œ // å½“å‰goroutineè¢«Doneå‡½æ•°å”¤é†’æ—¶ï¼Œä¸€å®šæ˜¯ *statep == 0ï¼Œä¸ç„¶æµç¨‹æœ‰é—®é¢˜ if *statep != 0 { panic(\u0026#34;sync: WaitGroup is reused before previous Wait has returned\u0026#34;) } if race.Enabled { race.Enable() race.Acquire(unsafe.Pointer(wg)) } return\t// ç›´æ¥è¿”å›åˆ°è°ƒç”¨Waitæ–¹æ³•ä½ç½®å¤„ } } } ä½¿ç”¨ç¤ºä¾‹ WaitGroupï¼šç”¨äºçº¿ç¨‹æ€»åŒæ­¥ï¼Œå®ƒç­‰å¾…ä¸€ç»„çº¿ç¨‹é›†åˆå®Œæˆï¼Œæ‰ä¼šç»§ç»­å‘ä¸‹æ‰§è¡Œã€‚ ä¸»çº¿ç¨‹è°ƒç”¨ Add() æ–¹æ³•æ¥è®¾ç½®ç­‰å¾…çš„åç¨‹æ•°é‡ï¼š ç„¶åæ¯ä¸ªåç¨‹è¿è¡Œï¼Œå¹¶åœ¨å®Œæˆåè°ƒç”¨ Done() æ–¹æ³•ï¼ŒAdd(-1) å’Œ Done() æ•ˆæœä¸€è‡´ï¼Œéƒ½è¡¨ç¤ºç­‰åˆ°çš„åç¨‹æ•°é‡å‡å°‘ä¸€ä¸ªã€‚ åŒæ—¶ï¼ŒWait() æ–¹æ³•ç”¨æ¥é˜»å¡ä¸»çº¿ç¨‹ï¼Œç›´åˆ°æ‰€æœ‰åç¨‹å®Œæˆæ‰ä¼šå‘ä¸‹æ‰§è¡Œã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;sync\u0026#34; ) func main() { var wg sync.WaitGroup wg.Add(10)\t// (\u0026amp;wg).Add(10) -\u0026gt; (*WaitGroup).Add(\u0026amp;wg, 10) for i := 0; i \u0026lt; 10; i++ { //wg.Add(1)\t// (\u0026amp;wg).Add(1)\t-\u0026gt; (*WaitGroup).Add(\u0026amp;wg, 1) go func(i int) { defer wg.Done()\t// (\u0026amp;wg).Done() -\u0026gt; (*WaitGroup).Done(\u0026amp;wg) fmt.Println(i) }(i) } fmt.Println(\u0026#34;æˆ‘åœ¨å¾ªç¯å¤–\u0026#34;) // é˜»å¡ä¸»çº¿ç¨‹ï¼Œç­‰æ‰€æœ‰åç¨‹å®Œæˆ wg.Wait()\t// (\u0026amp;wg).Wait() -\u0026gt; (*WaitGroup).Wait(\u0026amp;wg) // Output: // 1 // 9 // 3 // 4 // æˆ‘åœ¨å¾ªç¯å¤– // 5 // 6 // 7 // 8 // 2 // 0 } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;net/http\u0026#34; \u0026#34;sync\u0026#34; ) func main() { var wg sync.WaitGroup var urls []string = []string{ \u0026#34;http://baidu.com/\u0026#34;, \u0026#34;https://wzapi.myzx.cn/\u0026#34;, } wg.Add(len(urls)) for _, url := range urls { // wg.Add(1) go func(url string) { defer wg.Done() response, err := http.Get(url) fmt.Println(response, err, url) }(url) } wg.Wait() fmt.Println(\u0026#34;over\u0026#34;) // Output: // \u0026amp;{200 OK 200 HTTP/1.1 1 1 map[Accept-Ranges:[bytes] Cache-Control:[max-age=86400] Connection:[Keep-Alive] Content-Length:[81] Content-Type:[text/html] Date:[Thu, 22 Apr 2021 03:19:50 GMT] Etag:[\u0026#34;51-47cf7e6ee8400\u0026#34;] Expires:[Fri, 23 A // pr 2021 03:19:50 GMT] Last-Modified:[Tue, 12 Jan 2010 13:48:00 GMT] Server:[Apache]] 0xc00003a140 81 [] false false map[] 0xc000044000 \u0026lt;nil\u0026gt;} \u0026lt;nil\u0026gt; http://baidu.com/ // \u0026amp;{200 OK 200 HTTP/1.1 1 1 map[Access-Control-Allow-Headers:[Origin, X-Requested-With, Content-Type, Acceptfecshop-uuid, fecshop-lang, fecshop-currency, access-token, x-token, authorization] Access-Control-Allow-Methods:[*] Access-Co // ntrol-Allow-Origin:[*] Cache-Control:[no-cache, private] Connection:[keep-alive] Content-Type:[text/html; charset=UTF-8] Date:[Thu, 22 Apr 2021 03:19:50 GMT] Etag:[W/\u0026#34;be34c7da7adc79dfee6c76195ba1dbdad7b5bc9b\u0026#34;] Server:[MYBWS/1.1] Set // -Cookie:[acw_tc=2760829816190615907855703e97def055d99950b742716bbf6b2d8e6e2288;path=/;HttpOnly;Max-Age=1800 XSRF-TOKEN=eyJpdiI6IjFPZm9TcTYzblc5c0JJMFdSSW5EZ0E9PSIsInZhbHVlIjoiTXhEbHNlbVRXelMwTnR4UE5nY1JsNTRDTEJ4SmUzaFFsQkZTak9nTEtib // m5rczF3VlF6bVE1YitjNU5EbzlXMms4bTZLV0RiRTk4WXZMSFBBMFoxQ0V0OUpuYWxwN1ppYmpydjFFUzRQWXVBbktaNW82dFNVXC9BXC9FOG9Qb094VSIsIm1hYyI6IjNmYTMyZDUyYzk0ZWY0ZjJkNzJjOGY3M2FiYWYzZDYwNTA4YjFmZTBiZTljMzI1ZTI1MzY1MGQyZDAxYjQwN2QifQ%3D%3D; expires // =Thu, 22-Apr-2021 05:19:50 GMT; Max-Age=7200; path=/ laravel_session=eyJpdiI6IlA2cXcxRHVWYVgxa3VZRnNFY09LbkE9PSIsInZhbHVlIjoiK1ptMGIwOTdZbGp5dlwvRlNMK2pWb3hLVVErV0wxOFBQSmp1dVRkWExcL1VZbm1zVFwvUmRGT0dZcXJlcTZSRmhoWk1hdkJxYU9kUUFrNjB // RK3o4cW5TanZVZXZSYjVEN29CNUU2bEVHdHVoUVVESkhJcG1ETDVCS3FSTmtwYkJTcDciLCJtYWMiOiIwMTM3NDg2NTJlNDJkMGFhN2Y0NDA2YzJhYzcyMTQ4MzY1NDU1YzlmMjYwOTUxNjM0ZDJkYjUzYWJmMmMxZTE1In0%3D; expires=Thu, 22-Apr-2021 05:19:50 GMT; Max-Age=7200; path=/ // ; httponly]] 0xc0001220a0 -1 [chunked] false true map[] 0xc00010a000 0xc00004e0b0} \u0026lt;nil\u0026gt; https://wzapi.myzx.cn/ // over } æ€»ç»“ sync.WaitGroup æ›´å¤šæ˜¯ å¤šä¸ªgoroutineé€šçŸ¥ä¸€ä¸ªgoroutine,æ›´åƒæ˜¯main goroutineç­‰å¾…é›†åˆçš„æ‰€æœ‰goroutineå®Œæˆä¸€é¡¹ä»»åŠ¡ï¼Œå¤šå¯¹ä¸€ sync.Cond åˆ™æ›´åƒå¤šä¸ªgoroutineç­‰å¾…main goroutineçš„å·¥ä½œå®Œæˆï¼Œä¸€å¯¹å¤šï¼Œæ›´åƒæ˜¯å¹¿æ’­å½¢å¼ ä½¿ç”¨æ³¨æ„ ä»¥ä¸‹ä½¿ç”¨æ–¹å¼æ˜¯ä¸æ­£ç¡®çš„ã€‚ package main import ( \u0026#34;fmt\u0026#34; \u0026#34;sync\u0026#34; ) func main() { var wg sync.WaitGroup // ã€ä¸èƒ½å¦å¤–å¯åŠ¨åç¨‹å»æ‰§è¡ŒAdd()å’ŒDone()ï¼Œå› ä¸ºmainçš„Wait()ä¸ä¼šé˜»å¡ç­‰å¾…ã€‘ go func() { for i := 0; i \u0026lt; 10; i++ { wg.Add(1)\t// (\u0026amp;wg).Add(1)\t-\u0026gt; (*WaitGroup).Add(\u0026amp;wg, 1) go func(i int) { defer wg.Done()\t// (\u0026amp;wg).Done() -\u0026gt; (*WaitGroup).Done(\u0026amp;wg) fmt.Println(i) }(i) } }() // è¿™é‡Œå¹¶ä¸ä¼šé˜»å¡ç­‰å¾…ï¼Œå› ä¸ºè®¡æ•°å™¨ä¸º0 wg.Wait() // Output: } ","permalink":"http://localhost:1313/posts/golang/sync/waitgroup/","summary":"WaitGroupç­‰å¾…ä¸€ç»„goroutineå®Œæˆã€‚","title":"sync.WaitGroup"},{"content":"åŸºæœ¬æ•°æ®ç±»å‹ å¸ƒå°”ç±»å‹ å¸ƒå°”å‹å€¼åªèƒ½æ˜¯å¸¸é‡trueæˆ–falseã€‚ 1 2 3 4 5 // true å’Œ false æ˜¯ä¸¤ä¸ªæ— ç±»å‹çš„å¸ƒå°”å€¼ const ( true = 0 == 0 // æ— ç±»å‹å¸ƒå°”å€¼ false = 0 != 0 // æ— ç±»å‹å¸ƒå°”å€¼ï¼ˆé»˜è®¤å€¼falseï¼‰ ) Goè¯­è¨€ä¸­ä¸å…è®¸å°†æ•´å‹å¼ºåˆ¶è½¬å¸ƒå°”å‹ï¼Œä¹Ÿä¸å…è®¸å°†å¸ƒå°”å‹å¼ºåˆ¶è½¬æ•´å‹ã€‚ å¦‚ï¼šb := (int)(false)ï¼Œa := (bool)(1)è¿™éƒ½æ˜¯é”™è¯¯çš„ã€‚ å¸ƒå°”å‹æ— æ³•å‚ä¸æ•°å€¼è¿ç®—ï¼Œä¹Ÿæ— æ³•ä¸å…¶ä»–ç±»å‹è¿›è¡Œè½¬æ¢ï¼Œå¸ƒå°”ç±»å‹ä»…ç”¨åœ¨æ¡ä»¶åˆ¤æ–­ä¸­ã€‚ é€šè¿‡æŒ‡é’ˆè¿ç®—(unsafe)å¯ä»¥å®ç°0æˆ–1è½¬å¸ƒå°”ç±»å‹ï¼Œåä¹‹äº¦ç„¶ã€‚ boolå†…å­˜å¸ƒå±€ å¸ƒå°”ç±»å‹å ä¸€å­—èŠ‚ï¼Œä¹Ÿå°±æ˜¯8bitï¼Œå…¶åœ¨å†…å­˜ä¸­å­˜å‚¨çš„å€¼æ˜¯0æˆ–é0ã€‚8bitå…¨æ˜¯0è¡¨ç¤ºfalseï¼Œå…¶ä»–æƒ…å†µè¡¨ç¤ºtrueã€‚ å‡è®¾å®šä¹‰å˜é‡bï¼Œvar b boolï¼Œé»˜è®¤å€¼ä¸ºfalseå…¶å†…å­˜å­˜å‚¨ä¸º0ï¼› ç»™å˜é‡bèµ‹å€¼trueï¼Œb = trueï¼Œå…¶å†…å­˜è®¾ç½®ä¸º1ã€‚ ç»™å˜é‡bèµ‹å€¼falseï¼Œb = falseï¼Œå…¶å†…å­˜è®¾ç½®ä¸º0ã€‚ å¸ƒå°”ç±»å‹ä½œä¸ºæ¡ä»¶åˆ¤æ–­æ—¶ï¼Œå…¶å†…å­˜å€¼ä¸º0ï¼Œåˆ™åˆ¤æ–­ä¸ºtrueï¼›é0åˆ™åˆ¤æ–­ä¸ºfalseã€‚ æ›´å¤šå…³äºå¸ƒå°”ç±»å‹çš„å…ƒç»“æ„ç±»å‹ï¼Œå‚çœ‹_typeç»“æ„ï¼Œè®°å½•ç€å¸ƒå°”å‹çš„ç›¸å…³å‚æ•°ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 // å…³äºå®šä¹‰å¸ƒå°”ç±»å‹ç¤ºä¾‹ var b bool = false // å®šä¹‰å¸ƒå°”ç±»å‹å˜é‡bå¹¶è®¾ç½®å…¶å€¼ä¸ºfalse var a bool // å®šä¹‰å¸ƒå°”ç±»å‹å˜é‡aå¹¶è®¾ç½®å…¶å€¼ä¸ºfalse // --------------------------------------------------------------- // 1) å¸ƒå°”å€¼æ˜¯ä»¥æ€æ ·çš„å½¢å¼ä¿å­˜åœ¨å†…å­˜ä¸­çš„ // ------------------------------------------------------- // falseï¼šåœ¨å†…å­˜ä¸­å­˜å‚¨çš„æ˜¯0b0000_0000ä¹Ÿå°±æ˜¯æ•´å‹0 // trueï¼š åœ¨å†…å­˜ä¸­å­˜å‚¨çš„æ˜¯0b0000_0001ä¹Ÿå°±æ˜¯æ•´å‹1 // ------------------------------------------------------- // ç¤ºä¾‹ä¸­æ˜¯ boolè½¬int8ç±»å‹ï¼Œå½“ç„¶ä¹Ÿèƒ½è½¬å…¶ä»–ç±»å‹ // ------------------------------------------------------- var b0 bool = false\t// å‡è®¾b0åœ°å€ 0xc000014090 var b1 bool = true // *bool -\u0026gt; *int8 // i1 å­˜å‚¨çš„æ˜¯b0çš„åœ°å€0xc000014090 ç±»å‹ä¸º*int8 // æ³¨æ„åŒºåˆ«ï¼š*(*int8)(unsafe.Pointer(\u0026amp;b0)) å­˜å‚¨çš„æ˜¯b0çš„å€¼ ç±»å‹ä¸ºint8 // æ³¨æ„åŒºåˆ«ï¼š(**int8)(unsafe.Pointer(\u0026amp;b0)) *bool -\u0026gt; **int8 i1 := (*int8)(unsafe.Pointer(\u0026amp;b0)) i2 := (*int8)(unsafe.Pointer(\u0026amp;b1)) fmt.Println(*i1, *i2)\t// 0 1 // --------------------------------------------------------------- // 2) æ•´æ•°ç±»å‹è½¬æ¢æˆå¸ƒå°”å€¼æ˜¯æ€æ ·ä¸ªæƒ…å†µ // ------------------------------------------------------- // 0b0000_0000 è½¬å¸ƒå°”æ˜¯ falseï¼Œå…¶ä»–å…¨æ˜¯ true // 0ï¼šè½¬å¸ƒå°”æ˜¯ false // 32768ï¼š(2^15)è½¬å¸ƒå°”æ˜¯ false // 1ï¼šè½¬å¸ƒå°”æ˜¯ true // 2ï¼šè½¬å¸ƒå°”æ˜¯ true // -1ï¼šè½¬å¸ƒå°”æ˜¯ true æ³¨æ„è½¬æ¢æ—¶å¸ƒå°”å€¼åªéœ€è¦1å­—èŠ‚é•¿åº¦8bit // ------------------------------------------------------- var b0 int8 = 0 var b1 int8 = 1 i1 := (*bool)(unsafe.Pointer(\u0026amp;b0)) i2 := (*bool)(unsafe.Pointer(\u0026amp;b1)) fmt.Println(*i1, *i2)\t// false true // -------------------------------------------------------- // 3) ä¸‹é¢æˆ‘ä»¬æŠŠå…¶ä»–ç±»å‹è½¬æ¢æˆå¸ƒå°”å€¼ç„¶åå†è½¬å›ä¹‹å‰çš„ç±»å‹ // -------------------------------------------------------- // ä»¥ä¸‹ä»£ç è¯´æ˜ä½¿ç”¨unsafeè½¬æ¢ä»…ä»…æ˜¯æŠŠç¬¬ä¸€ä¸ªå­—èŠ‚æŒ‡å‘boolåœ°å€ // -------------------------------------------------------- // 3.1) int8 -\u0026gt; bool -\u0026gt; int8 var b0 int8 = 0 var b1 int8 = -125 // 1000 0011 i1 := (*bool)(unsafe.Pointer(\u0026amp;b0)) i2 := (*bool)(unsafe.Pointer(\u0026amp;b1)) fmt.Println(*i1, *i2)\t// false true i11 := (*int8)(unsafe.Pointer(i1)) i22 := (*int8)(unsafe.Pointer(i2)) fmt.Println(*i11, *i22)\t// 0 -125 // 3.2) int -\u0026gt; bool -\u0026gt; int var b0 int = 0 var b1 int = 55536 i1 := (*bool)(unsafe.Pointer(\u0026amp;b0)) i2 := (*bool)(unsafe.Pointer(\u0026amp;b1)) fmt.Println(*i1, *i2)\t// false true i11 := (*int)(unsafe.Pointer(i1)) i22 := (*int)(unsafe.Pointer(i2)) fmt.Println(*i11, *i22)\t// 0 55536 // 3.3) uint16 -\u0026gt; bool ä¿®æ”¹ -\u0026gt; uint16 var b0 uint16 = 0 var b1 uint16 = 0b10000000_11111111 i1 := (*bool)(unsafe.Pointer(\u0026amp;b0)) i2 := (*bool)(unsafe.Pointer(\u0026amp;b1)) fmt.Println(*i1, *i2)\t// false true *i2 = false i11 := (*uint16)(unsafe.Pointer(i1)) i22 := (*uint16)(unsafe.Pointer(i2)) // 32768 -\u0026gt; 0b10000000_00000000 fmt.Println(*i11, *i22)\t// 0 32768 // 4) ä¸Šé¢å‘ç°å°†å¸ƒå°”ç±»å‹èµ‹å€¼ä¸ºfalseä¼šå°†å†…å­˜çš„8ä¸ºbitå…¨éƒ¨è®¾ç½®ä¸º0ï¼Œä¹Ÿå°±æ˜¯85è¡Œä»£ç å¤„ // é‚£ä¹ˆå°†ä¸€ä¸ªæœ¬å°±æ˜¯å¸ƒå°”trueç±»å‹èµ‹å€¼ä¸ºtrueï¼Œå†…å­˜ä¸­æ˜¯å¦è®°å½•çš„å¤§å°ä¸º1ï¼Ÿ var b1 int = 12 bb := (*bool)(unsafe.Pointer(\u0026amp;b1)) *bb = true fmt.Println(*(*int)(unsafe.Pointer(bb)))\t// 1 // é€šè¿‡ä»£ç æµ‹è¯• å¸ƒå°”çš„èµ‹å€¼å°±æ˜¯æŠŠå†…å­˜ä¸­çš„æ•°å€¼falseæ”¹ä¸º0 trueæ”¹ä¸º1 æ€»ç»“ï¼š Goå†…å­˜å­—æ®µæ’åºæ˜¯ï¼Œä½å­—èŠ‚åœ¨å‰é«˜å­—èŠ‚åœ¨åã€‚ï¼ˆä¸åŒçš„ç¡¬ä»¶è®¾å¤‡å¯èƒ½ä¸åŒï¼‰ã€‚ æ¯”å¦‚33007äºŒè¿›åˆ¶å¦‚10000000_11101111ï¼Œåœ¨å†…å­˜ä¸­æ˜¯ç¬¬ä¸€ä¸ªå­—èŠ‚11101111ç¬¬äºŒä¸ªå­—èŠ‚10000000ã€‚ å¸ƒå°”ç±»å‹å 1å­—èŠ‚ï¼ˆ8bitï¼‰ï¼Œæ‰€æœ‰ä½éƒ½ä¸º0æ—¶è¡¨ç¤ºfalseï¼Œå¦åˆ™è¡¨ç¤ºtrueã€‚ å› æ­¤10000000_00000000è¿™ç§å½¢å¼è½¬boolç¬¬ä¸€ä¸ªå­—èŠ‚æ˜¯00000000è¿”å›falseã€‚ ä½¿ç”¨unsafeè½¬æ¢ç±»å‹ä»…ä»…æ˜¯æŠŠé¦–å­—èŠ‚è½¬boolçš„åœ°å€ã€‚ ä¹Ÿå°±æ˜¯ä¸Šé¢çš„33007ï¼ˆ10000000_11101111ï¼‰è½¬boolï¼ŒæŠŠ11101111è¿™ä¸ªç¬¬ä¸€ä¸ªå­—èŠ‚åœ°å€ç»™å¸ƒå°”å€¼ã€‚ å¸ƒå°”ç±»å‹åœ¨è¢«èµ‹å€¼æ—¶ï¼Œtrueä¼šä¿®æ”¹å†…å­˜å­˜å‚¨å€¼ä¸º1ï¼Œfalseä¼šä¿®æ”¹å­˜å‚¨å€¼ä¸º0ã€‚ æ•´æ•°ç±»å‹ æœ‰ç¬¦å·æ•´å‹ ç±»å‹ é•¿åº¦(B/å­—èŠ‚) èŒƒå›´(ç§‘å­¦è®¡æ•°) èŒƒå›´ é»˜è®¤å€¼ int8 1B (8bit) [-2^7, 2^7-1] [-128, 127] 0 int16 2B (16bit) [-2^15, 2^15-1] [-32768, 32767] 0 int32 4B (32bit) [-2^31, 2^31-1] [-2147483648, 2147483647] 0 int64 8B (64bit) [-2^63, 2^63-1] [-9223372036854775808, 9223372036854775807] 0 int ä¸ç³»ç»Ÿæœ‰å…³ï¼Œ32ä½ä¸‹4å­—èŠ‚ï¼Œ64ä½ä¸‹8å­—èŠ‚ 0 è¡¥ç ä¸æºç  æœ‰ç¬¦å·è´Ÿæ•°ç±»å‹è½¬äºŒè¿›åˆ¶ï¼Œè´Ÿæ•°æ•´å‹æ•°å€¼éƒ½æ˜¯é‡‡ç”¨è¡¥ç å½¢å¼ä¿å­˜ï¼Œå½“ç„¶æ­£æ•°çš„è¡¥ç å°±æ˜¯è‡ªå·±ã€‚ å…ˆæ˜¯å°†å¯¹åº”çš„æ­£æ•´æ•°è½¬æ¢æˆäºŒè¿›åˆ¶åã€‚ å¯¹äºŒè¿›åˆ¶å–åã€‚ ç„¶åå¯¹ç»“æœå†åŠ ä¸€ã€‚ è¡¥ç çš„è¿ç®—ï¼šä¸¤ä¸ªè¡¥ç ç›¸åŠ ï¼Œç®—æ³•ä¸äºŒè¿›åˆ¶åŠ æ³•ç›¸åŒï¼Œå’Œä»ç„¶æ˜¯è¡¥ç ï¼ˆè¡¥ç è®¡ç®—åå¯èƒ½å­˜åœ¨æº¢å‡ºæƒ…å†µï¼‰ è¡¥ç è½¬æºç ã€‚ æ­£æ•°ï¼šç¬¦å·ä½ä¸º0æ—¶ï¼Œå³è¡¥ç å°±æ˜¯æºç  è´Ÿæ•°ï¼šç¬¦å·ä½ä¸º1æ—¶ï¼Œå³è¡¥ç çš„è¡¥ç å°±æ˜¯æºç  # -42å­˜å‚¨å½¢å¼ï¼šå‡è®¾è¿™é‡Œæ˜¯int8ç±»å‹ 8ä½bitä½ # 1. 42è½¬äºŒè¿›åˆ¶ï¼Œ00101010 # 2. 00101010 å–å 11010101 # 3. 11010101åŠ ä¸€ï¼Œ11010101 + 00000001 = 11010110\tè¡¥ç  # æœ€ç»ˆ-42çš„äºŒè¿›åˆ¶è¡¨ç¤ºå½¢å¼ï¼Œ11010110 # 11010110 è¡¥ç è½¬æºç  # 1. æœ€é«˜ä½ä¸º1è¡¨ç¤ºè´Ÿæ•° # 2. 11010110 å–å 00101001 # 3. 00101001åŠ ä¸€ï¼Œ00101001 + 00000001 = 00101010\tæºç  # æ€»ç»“ï¼š- å·çš„æ“ä½œé€»è¾‘å°±æ˜¯ä¸Šé¢æ­¥éª¤2(å–å)å’Œæ­¥éª¤3(åŠ ä¸€) # æœ€é«˜ä½è¡¨ç¤ºç¬¦å·ä½ 0.æ­£æ•° 1.è´Ÿæ•° # å†…å­˜ä¸­éƒ½æ˜¯é‡‡ç”¨è¡¥ç å½¢å¼å­˜å‚¨çš„ 1 2 3 4 5 6 7 // éªŒè¯ -42 æ˜¯å¦æ˜¯ 11010110 var b0 int8 = -42 // i1 := uint8(b0) i1 := (*uint8)(unsafe.Pointer(\u0026amp;b0)) fmt.Printf(\u0026#34;%.8b\u0026#34;, *i1)\t// 11010110 ä¾‹å¦‚ï¼š-1æ˜¯11111111ï¼Œ127æ˜¯01111111ï¼Œæœ€é«˜ä½bitè¡¨ç¤ºç¬¦å·ä½ï¼Œ0è¡¨ç¤ºæ­£æ•°(+)ï¼Œ1è¡¨ç¤ºè´Ÿæ•°(-)ã€‚ # -1 è½¬äºŒè¿›åˆ¶ # 1 -\u0026gt; 00000001 # ~1 -\u0026gt; 11111110 å–å # +1\t-\u0026gt; 11111111 åŠ ä¸€ # 127 è½¬äºŒè¿›åˆ¶ # 127\t-\u0026gt; 01111111 **-**å·ï¼šæ“ä½œåœ¨æ•´å‹ä¸­çš„æ“ä½œæ­¥éª¤(å–å)ç„¶å(åŠ ä¸€) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 // åœ¨time.Durationä¸­çš„String()æ–¹æ³•ä¸­æœ‰è¿™æ ·ä¸€æ®µä»£ç  // d ä¸ºint64ç±»å‹ï¼Œè¿™é‡Œæ­£æ˜¯åˆ©ç”¨äº†-(-42)=42, u=(-42) func (d Duration) String() string { // ... u := uint64(d) // è¿™é‡Œå¦‚æœæ˜¯è´Ÿæ•°ï¼Œåˆ™è½¬æ¢åä¸€å®šæ˜¯ä¸ªå¾ˆå¤§çš„æ•°å­— neg := d \u0026lt; 0 // negä¸ºtrueè¡¨ç¤ºæ˜¯è´Ÿæ•°ï¼Œä¸ºfalseè¡¨ç¤ºæ˜¯æ­£æ•°æˆ–0 if neg { u = -u // è¿™é‡Œå†æ¬¡æŒ‰ç…§è´Ÿæ•°å­˜å‚¨å½¢å¼ï¼Œæ­£æ•°çš„äºŒè¿›åˆ¶å–ååŠ 1ç­‰åˆ°æ­£æ•°ä¹Ÿå°±æ˜¯(-d) } // ... } // æ¯”å¦‚æˆ‘ä»¬ä½¿ç”¨ä¸Šé¢æ–¹æ³•å†™ä¸€ä¸ªabså–ç»å¯¹å€¼å‡½æ•°ï¼Œå¹¶è½¬æ¢æ— ç¬¦å·ç±»å‹ä¸ºæœ‰ç¬¦å·ç±»å‹ type i int64 func (i i) abs() uint64 { if i \u0026gt; 0 { return uint64(i) } return -uint64(i) } æ— ç¬¦å·æ•´å‹(unsigned) ç±»å‹ é•¿åº¦(B/å­—èŠ‚) èŒƒå›´ èŒƒå›´ é»˜è®¤å€¼ uint8 1B (8bit) [0, 2^8-1] [0, 255] 0 uint16 2B (16bit) [0, 2^16-1] [0, 65535] 0 uint32 4B (32bit) [0, 2^32-1] [0, 4294967295] 0 uint64 8B (64bit) [0, 2^64-1] [0, 18446744073709551615] 0 uint ä¸ç³»ç»Ÿæœ‰å…³ï¼Œ32ä½ä¸‹4å­—èŠ‚ï¼Œ64ä½ä¸‹8å­—èŠ‚ 0 æ— ç¬¦å·è½¬äºŒè¿›åˆ¶ é™¤äºŒå–ä½™ï¼Œç„¶åå€’åºæ’åˆ—ï¼Œé«˜ä½è¡¥é›¶ # ç¤ºä¾‹42è½¬äºŒè¿›åˆ¶ï¼Œæ­£æ•´æ•°è½¬äºŒè¿›åˆ¶ é™¤äºŒ æ±‚ä½™ æ’åºæ–¹å‘ åè¿›åˆ¶ 42 || 2 | 42 .... 42/2 ä½™ .... 0 ^ 0*2^0 = 0 |_______ + 2 | 21 .... 21/2 ä½™ .... 1 | 1*2^1 = 2 |_______ + 2 | 10 .... 10/2 ä½™ .... 0 | 0*2^2 = 0 |_______ + 2 | 5 .... 5/2 ä½™ .... 1 | 1*2^3 = 8 |________ + 2 | 2 .... 2/2 ä½™ .... 0 | 0*2^4 = 0 |________ + 1 .... 1/2 ä½™ .... 1 | 1*2^5 = 32 # 42 å¯¹åº”äºŒè¿›åˆ¶ä½ 00101010 -\u0026gt; 0*2^0 + 1*2^1 + 0*2^2 + 1*2^3 + 0*2^4 + 1*2^5 = 42 å…¶ä»–æ•´æ•°ç±»å‹ ç±»å‹ ç­‰ä»·äº é•¿åº¦/å­—èŠ‚ å¤‡æ³¨ é»˜è®¤å€¼ byte type byte = uint8 1B å­˜å‚¨ä¸€å­—èŠ‚å†…å®¹ 0 rune type rune = int32 4B å­˜å‚¨ä¸€å­—ç¬¦å†…å®¹(Unciodeç¼–ç ) 0 uintptr uint 4Bæˆ–8B åˆšå¥½èƒ½å­˜å‚¨å˜é‡åœ°å€ 0 1 2 3 4 5 6 7 // type byte = uint8 var b byte // é»˜è®¤å€¼ 0 // type rune = int32 var r rune // é»˜è®¤å€¼ 0 fmt.Printf(\u0026#34;b: %T\\n\u0026#34;, b)\t// b: uint8 fmt.Printf(\u0026#34;r: %T\\n\u0026#34;, r)\t// r: int32 æµ®ç‚¹æ•°ç±»å‹ ç±»å‹ æè¿° é»˜è®¤å€¼ float32 IEEE-754 32ä½æµ®ç‚¹å‹æ•°4å­—èŠ‚ï¼Œå¤§çº¦å­˜å‚¨å°æ•°ä½æ•°7ä½ï¼ˆåè¿›åˆ¶ç§‘å­¦è®¡æ•°æ³•n.xxx*e+10æƒ…å†µä¸‹ï¼‰ï¼Œè¿™é‡Œçš„7ä½æ˜¯xçš„ä½æ•° 0.0 float64 IEEE-754 64ä½æµ®ç‚¹å‹æ•°8å­—èŠ‚ï¼Œå¤§çº¦å­˜å‚¨å°æ•°ä½æ•°16ä½ï¼ˆåè¿›åˆ¶ç§‘å­¦è®¡æ•°æ³•n.xxx*e+10æƒ…å†µä¸‹ï¼‰ï¼Œè¿™é‡Œçš„16ä½æ˜¯xçš„ä½æ•° 0.0 IEEE-754 æµ®ç‚¹æ•°åœ¨å†…å­˜ä¸­å¦‚ä½•å­˜å‚¨ æµ®ç‚¹æ•°éœ€è¦å…ˆè½¬æ¢æˆäºŒè¿›åˆ¶æ‰èƒ½å­˜å‚¨åœ¨å†…å­˜ä¸­ï¼Œå› æ­¤æ‹†åˆ†æˆæ­£æ•°å’Œå°æ•°ï¼š å¯¹äºæ­£æ•°éƒ¨åˆ†ï¼š æŒ‰ç…§æœ‰ç¬¦å·è§„åˆ™è®¡ç®—å³å¯ï¼Œæ¯”å¦‚42æˆ–-42æ˜¯00101010ï¼Œç¬¦å·ä½åé¢å•ç‹¬å¤„ç† å¯¹äºå°æ•°éƒ¨åˆ†ï¼š å¯¹å°æ•°ç‚¹ä»¥åçš„æ•°ä¹˜ä»¥2ï¼Œå–ç»“æœçš„æ•´æ•°éƒ¨åˆ†(ä¸æ˜¯1å°±æ˜¯0)ï¼Œç„¶åå†ç”¨å°æ•°éƒ¨åˆ†å†ä¹˜ä»¥2ï¼Œå†å–ç»“æœçš„æ•´æ•°éƒ¨åˆ† ä»¥æ­¤ç±»æ¨ï¼Œç›´åˆ°å°æ•°éƒ¨åˆ†ä¸º0æˆ–è€…ä½æ•°å·²ç»å¤Ÿäº†å°±ç»“æŸ ç„¶åæŠŠå–çš„æ•´æ•°éƒ¨åˆ†æŒ‰å…ˆåæ¬¡åºæ’åˆ—ï¼Œå°±æ„æˆäº†äºŒè¿›åˆ¶å°æ•°éƒ¨åˆ†çš„åºåˆ— # å¦‚42.635648ï¼Œå¤„ç†å°æ•°éƒ¨åˆ†å°±æ˜¯0.635648 å°æ•°éƒ¨ä½ä¹˜2 = å–æ­£æ•°ä½ æ’åºæ–¹å‘ åè¿›åˆ¶ 0.6328125 || 0.635648 * 2 = 1.271296 ... å–æ­£æ•°ä½ ... 1 | 2^-1 1/2 0.5 0.271296 * 2 = 0.542592 ... å–æ­£æ•°ä½ ... 0 | 0 + 0.542592 * 2 = 1.085184 ... å–æ­£æ•°ä½ ... 1 | 2^-3 1/2^3 0.125 0.085184 * 2 = 0.170368 ... å–æ­£æ•°ä½ ... 0 | 0 0.170368 * 2 = 0.340736 ... å–æ­£æ•°ä½ ... 0 | 0 + 0.340736 * 2 = 0.681472 ... å–æ­£æ•°ä½ ... 0 | 0 0.681472 * 2 = 1.362944 ... å–æ­£æ•°ä½ ... 1 v 2^-7 1/2^7 0.0078125 ... ... # ç»„æˆäºŒè¿›åˆ¶ 1010001... -\u0026gt; 2^5 + 2^3 + 2^1 + 2^-1 + 2^-3 + 2^-7 # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - # å¦‚-0.1ï¼Œå¤„ç†å°æ•°éƒ¨åˆ†å°±æ˜¯0.1 å°æ•°éƒ¨ä½ä¹˜2 = å–æ­£æ•°ä½ æ’åºæ–¹å‘ åè¿›åˆ¶ 0.099609375 || 0.1 * 2 = 0.2 ... å–æ­£æ•°ä½ ... 0 | 0 0.2 * 2 = 0.4 ... å–æ­£æ•°ä½ ... 0 | 0 0.4 * 2 = 0.8 ... å–æ­£æ•°ä½ ... 0 | 0 0.8 * 2 = 1.6 ... å–æ­£æ•°ä½ ... 1 | 1/2^4 0.0625 0.6 * 2 = 1.2 ... å–æ­£æ•°ä½ ... 1 | 1/2^5 0.03125 0.2 * 2 = 0.4 ... å–æ­£æ•°ä½ ... 0 | 0 + 0.4 * 2 = 0.8 ... å–æ­£æ•°ä½ ... 0 | 0 0.8 * 2 = 1.6 ... å–æ­£æ•°ä½ ... 1 | 1/2^8 0.00390625 0.6 * 2 = 1.2 ... å–æ­£æ•°ä½ ... 1 | 1/2^9 0.001953125 0.2 * 2 = 0.4 ... å–æ­£æ•°ä½ ... 0 v 0 ... ... # ç»„æˆäºŒè¿›åˆ¶ 0001100110... ç„¶åæŠŠæ•´æ•°éƒ¨åˆ†è½¬äºŒè¿›åˆ¶å’Œå°æ•°éƒ¨åˆ†è½¬äºŒè¿›åˆ¶åŠ ä¸€èµ·ï¼Œå¦‚(101010.1010001...) æµ®ç‚¹æ•°æ˜¯å¦‚ä½•å­˜å‚¨åœ¨å†…å­˜ä¸­ æ¯”å¦‚ä¸Šé¢çš„101010.1010001...è½¬æ¢äºŒè¿›åˆ¶ç§‘å­¦è®¡æ•°æ³•è¡¨ç¤º1.010101010001... * 2^5\nåè¿›åˆ¶ äºŒè¿›åˆ¶ è®¡ç®—æ–¹å¼ äºŒè¿›åˆ¶ç§‘å­¦è®¡æ•°æ³•è¡¨ç¤º 3.5 11.1 3.5 = 2^1 + 2^0 + 2^-1 11.1 = 1.11 * 2^1 10.625 1010.101 10.625 = 2^3 + 2^1 + 2^-1 + 2^-3 1010.101 = 1.010101 * 2^3 0.6 0.10011001.. 0.6 = 2^-1 + 2^-4 + 2^-5 + 2^-8 .. 0.100110011001.. = 1.00110011001.. * 2^-1 ä»ä¸Šé¢å¯ä»¥è§‚å¯Ÿåˆ°ï¼Œå¯¹äºä»»ä½•æ•°æ¥è¯´ï¼Œè¡¨ç¤ºæˆäºŒè¿›åˆ¶ç§‘å­¦è®¡æ•°æ³•åï¼Œéƒ½å¯ä»¥è½¬æ¢æˆ1.xxx * 2^nå½¢å¼\nå¯¹äºè´Ÿæ•°æ¥è¯´ï¼Œåˆ™å¯ä»¥è¡¨ç¤ºæˆ-1.xxx * 2^nå½¢å¼\næµ®ç‚¹æ•°çš„å­˜å‚¨å½¢å¼å¯ä»¥åˆ†ä¸ºä¸‰éƒ¨åˆ†ï¼š ç¬¦å·ä½ï¼ˆSï¼‰ å°¾æ•°(xxx)ï¼ˆMï¼‰ æŒ‡æ•°(n)ï¼ˆEï¼‰ æ ¹æ®æŒ‡æ•°åˆåˆ†ä¸ºä¸‰ç§ç±»å‹ï¼šè§„æ ¼æ•°(normal number)ã€éè§„æ ¼æ•°(subnormal number)ã€ç‰¹æ®Šæ•°(non-number)ã€‚ æŒ‡æ•°ä½ -\u0026gt; å…¨ä¸º0 ä¸å…¨ä¸º0ä¸”ä¸å…¨ä¸º1 å…¨ä¸º1 å¯¹åº”çš„æ•° -\u0026gt; éè§„æ ¼æ•°(subnormal number) è§„æ ¼æ•°(normal number) ç‰¹æ®Šæ•°(non-number) éè§„æ ¼æ•°(subnormal number)ï¼šæŒ‡æ•°ä½å…¨ä¸º0ï¼Œç”¨äºè¡¨ç¤º0æˆ–éå¸¸æ¥è¿‘0çš„æ•°ã€‚ è§„æ ¼æ•°(normal number)ï¼šæŒ‡æ•°ä½ä¸å…¨ä¸º0ä¸”ä¸å…¨ä¸º1ï¼Œç”¨äºè¡¨ç¤ºæ­£å¸¸çš„æ•°å€¼ã€‚ ç‰¹æ®Šæ•°(non-number)ï¼šæŒ‡æ•°ä½å…¨ä¸º1ï¼Œç”¨äºè¡¨ç¤ºÂ±infinityæˆ–NaNã€‚ ","permalink":"http://localhost:1313/posts/golang/basic/type/","summary":"Golang å†…ç½®çš„åŸºæœ¬ç±»å‹ä»‹ç»ã€‚","title":"å†…ç½®ç±»å‹"},{"content":" ğŸ”¥å¦‚æœè§‰å¾—æˆ‘çš„æ–‡ç« å¯¹æ‚¨æœ‰ç”¨ï¼Œå¸®æˆ‘ä¹°æ¯â˜•ã€‚æ‚¨çš„æ”¯æŒå°†é¼“åŠ±æˆ‘ç»§ç»­åˆ›ä½œã€‚ğŸ‰ğŸ‰ğŸ‰\nwechat alipay ","permalink":"http://localhost:1313/support/","summary":" ğŸ”¥å¦‚æœè§‰å¾—æˆ‘çš„æ–‡ç« å¯¹æ‚¨æœ‰ç”¨ï¼Œå¸®æˆ‘ä¹°æ¯â˜•ã€‚æ‚¨çš„æ”¯æŒå°†é¼“åŠ±æˆ‘ç»§ç»­åˆ›ä½œã€‚ğŸ‰ğŸ‰ğŸ‰\nwechat alipay ","title":"æ‰“èµ"}]